- title: __initial_text__
  contents:
  - '                           LDP Specification

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The architecture for Multi Protocol Label Switching (MPLS) is\n\
    \   described in RFC 3031.  A fundamental concept in MPLS is that two\n   Label\
    \ Switching Routers (LSRs) must agree on the meaning of the\n   labels used to\
    \ forward traffic between and through them.  This common\n   understanding is\
    \ achieved by using a set of procedures, called a\n   label distribution protocol,\
    \ by which one LSR informs another of\n   label bindings it has made.  This document\
    \ defines a set of such\n   procedures called LDP (for Label Distribution Protocol)\
    \ by which LSRs\n   distribute labels to support MPLS forwarding along normally\
    \ routed\n   paths.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1          LDP Overview  .......................................\
    \   5\n   1.1        LDP Peers  ..........................................   6\n\
    \   1.2        LDP Message Exchange  ...............................   6\n   1.3\
    \        LDP Message Structure  ..............................   7\n   1.4   \
    \     LDP Error Handling  .................................   7\n   1.5      \
    \  LDP Extensibility and Future Compatibility  .........   7\n   1.6        Specification\
    \ Language  .............................   7\n   2          LDP Operation  ......................................\
    \   8\n   2.1        FECs  ...............................................   8\n\
    \   2.2        Label Spaces, Identifiers, Sessions and Transport  ..   9\n   2.2.1\
    \      Label Spaces  .......................................   9\n   2.2.2   \
    \   LDP Identifiers  ....................................  10\n   2.2.3      LDP\
    \ Sessions  .......................................  10\n   2.2.4      LDP Transport\
    \  ......................................  11\n   2.3        LDP Sessions between\
    \ non-Directly Connected LSRs  ...  11\n   2.4        LDP Discovery   .....................................\
    \  11\n   2.4.1      Basic Discovery Mechanism  ..........................  12\n\
    \   2.4.2      Extended Discovery Mechanism  .......................  12\n   2.5\
    \        Establishing and Maintaining LDP Sessions  ..........  13\n   2.5.1 \
    \     LDP Session Establishment  ..........................  13\n   2.5.2    \
    \  Transport Connection Establishment  .................  13\n   2.5.3      Session\
    \ Initialization  .............................  14\n   2.5.4      Initialization\
    \ State Machine  .......................  17\n   2.5.5      Maintaining Hello\
    \ Adjacencies  ......................  20\n   2.5.6      Maintaining LDP Sessions\
    \  ...........................  20\n   2.6        Label Distribution and Management\
    \  ..................  21\n   2.6.1      Label Distribution Control Mode  ....................\
    \  21\n   2.6.1.1    Independent Label Distribution Control  .............  21\n\
    \   2.6.1.2    Ordered Label Distribution Control  .................  21\n   2.6.2\
    \      Label Retention Mode  ...............................  22\n   2.6.2.1 \
    \   Conservative Label Retention Mode  ..................  22\n   2.6.2.2    Liberal\
    \ Label Retention Mode  .......................  22\n   2.6.3      Label Advertisement\
    \ Mode  ...........................  23\n   2.7        LDP Identifiers and Next\
    \ Hop Addresses  .............  23\n   2.8        Loop Detection  .....................................\
    \  24\n   2.8.1      Label Request Message  ..............................  24\n\
    \   2.8.2      Label Mapping Message  ..............................  26\n   2.8.3\
    \      Discussion  .........................................  27\n   2.9     \
    \   Authenticity and Integrity of LDP Messages  .........  28\n   2.9.1      TCP\
    \ MD5 Signature Option  ...........................  28\n   2.9.2      LDP Use\
    \ of TCP MD5 Signature Option  ................  30\n   2.10       Label Distribution\
    \ for Explicitly Routed LSPs  ......  30\n   3          Protocol Specification\
    \  .............................  31\n   3.1        LDP PDUs  ...........................................\
    \  31\n   3.2        LDP Procedures  .....................................  32\n\
    \   3.3        Type-Length-Value Encoding  .........................  32\n   3.4\
    \        TLV Encodings for Commonly Used Parameters  .........  34\n   3.4.1 \
    \     FEC TLV  ............................................  34\n   3.4.1.1  \
    \  FEC Procedures  .....................................  37\n   3.4.2      Label\
    \ TLVs  .........................................  37\n   3.4.2.1    Generic Label\
    \ TLV  ..................................  37\n   3.4.2.2    ATM Label TLV  ......................................\
    \  38\n   3.4.2.3    Frame Relay Label TLV  ..............................  38\n\
    \   3.4.3      Address List TLV  ...................................  39\n   3.4.4\
    \      Hop Count TLV  ......................................  40\n   3.4.4.1 \
    \   Hop Count Procedures  ...............................  40\n   3.4.5      Path\
    \ Vector TLV  ....................................  41\n   3.4.5.1    Path Vector\
    \ Procedures  .............................  42\n   3.4.5.1.1  Label Request Path\
    \ Vector  ..........................  42\n   3.4.5.1.2  Label Mapping Path Vector\
    \  ..........................  43\n   3.4.6      Status TLV  .........................................\
    \  43\n   3.5        LDP Messages  .......................................  45\n\
    \   3.5.1      Notification Message  ...............................  47\n   3.5.1.1\
    \    Notification Message Procedures  ....................  48\n   3.5.1.2   \
    \ Events Signaled by Notification Messages  ...........  49\n   3.5.1.2.1  Malformed\
    \ PDU or Message  ...........................  49\n   3.5.1.2.2  Unknown or Malformed\
    \ TLV  ...........................  50\n   3.5.1.2.3  Session KeepAlive Timer\
    \ Expiration  .................  50\n   3.5.1.2.4  Unilateral Session Shutdown\
    \  ........................  51\n   3.5.1.2.5  Initialization Message Events \
    \ ......................  51\n   3.5.1.2.6  Events Resulting From Other Messages\
    \  ...............  51\n   3.5.1.2.7  Internal Errors  ....................................\
    \  51\n   3.5.1.2.8  Miscellaneous Events  ...............................  51\n\
    \   3.5.2      Hello Message  ......................................  51\n   3.5.2.1\
    \    Hello Message Procedures  ...........................  54\n   3.5.3     \
    \ Initialization Message  .............................  55\n   3.5.3.1    Initialization\
    \ Message Procedures  ..................  63\n   3.5.4      KeepAlive Message\
    \  ..................................  63\n   3.5.4.1    KeepAlive Message Procedures\
    \  .......................  63\n   3.5.5      Address Message  ....................................\
    \  64\n   3.5.5.1    Address Message Procedures  .........................  64\n\
    \   3.5.6      Address Withdraw Message  ...........................  65\n   3.5.6.1\
    \    Address Withdraw Message Procedures  ................  66\n   3.5.7     \
    \ Label Mapping Message  ..............................  66\n   3.5.7.1    Label\
    \ Mapping Message Procedures  ...................  67\n   3.5.7.1.1  Independent\
    \ Control Mapping  ........................  67\n   3.5.7.1.2  Ordered Control\
    \ Mapping  ............................  68\n   3.5.7.1.3  Downstream on Demand\
    \ Label Advertisement  ...........  68\n   3.5.7.1.4  Downstream Unsolicited Label\
    \ Advertisement  .........  69\n   3.5.8      Label Request Message  ..............................\
    \  69\n   3.5.8.1    Label Request Message Procedures  ...................  70\n\
    \   3.5.9      Label Abort Request Message  ........................  72\n   3.5.9.1\
    \    Label Abort Request Message Procedures  .............  73\n   3.5.10    \
    \ Label Withdraw Message  .............................  74\n   3.5.10.1   Label\
    \ Withdraw Message Procedures  ..................  75\n   3.5.11     Label Release\
    \ Message  ..............................  76\n   3.5.11.1   Label Release Message\
    \ Procedures  ...................  77\n   3.6        Messages and TLVs for Extensibility\
    \  ................  78\n   3.6.1      LDP Vendor-private Extensions  ......................\
    \  78\n   3.6.1.1    LDP Vendor-private TLVs  ............................  78\n\
    \   3.6.1.2    LDP Vendor-private Messages  ........................  80\n   3.6.2\
    \      LDP Experimental Extensions  ........................  81\n   3.7     \
    \   Message Summary  ....................................  81\n   3.8        TLV\
    \ Summary  ........................................  82\n   3.9        Status\
    \ Code Summary  ................................  83\n   3.10       Well-known\
    \ Numbers  .................................  84\n   3.10.1     UDP and TCP Ports\
    \  ..................................  84\n   3.10.2     Implicit NULL Label \
    \ ................................  84\n   4          IANA Considerations  ................................\
    \  84\n   4.1        Message Type Name Space  ............................  84\n\
    \   4.2        TLV Type Name Space  ................................  85\n   4.3\
    \        FEC Type Name Space  ................................  85\n   4.4   \
    \     Status Code Name Space  .............................  86\n   4.5      \
    \  Experiment ID Name Space  ...........................  86\n   5          Security\
    \ Considerations  ............................  86\n   5.1        Spoofing  ...........................................\
    \  86\n   5.2        Privacy  ............................................  87\n\
    \   5.3        Denial of Service  ..................................  87\n   6\
    \          Areas for Future Study  .............................  89\n   7   \
    \       Intellectual Property Considerations  ...............  89\n   8      \
    \    Acknowledgments  ....................................  89\n   9         \
    \ References  .........................................  89\n   10         Authors'\
    \ Addresses  .................................  92\n   Appendix A LDP Label Distribution\
    \ Procedures  ..................  93\n   A.1        Handling Label Distribution\
    \ Events  .................  95\n   A.1.1      Receive Label Request  ..............................\
    \  96\n   A.1.2      Receive Label Mapping  ..............................  99\n\
    \   A.1.3      Receive Label Abort Request  ........................ 105\n   A.1.4\
    \      Receive Label Release  .............................. 107\n   A.1.5   \
    \   Receive Label Withdraw  ............................. 109\n   A.1.6      Recognize\
    \ New FEC  .................................. 110\n   A.1.7      Detect Change\
    \ in FEC Next Hop  ...................... 113\n   A.1.8      Receive Notification\
    \ / Label Request Aborted  ....... 116\n   A.1.9      Receive Notification / No\
    \ Label Resources  .......... 116\n   A.1.10     Receive Notification / No Route\
    \  .................... 117\n   A.1.11     Receive Notification / Loop Detected\
    \  ............... 118\n   A.1.12     Receive Notification / Label Resources Available\
    \  ... 118\n   A.1.13     Detect local label resources have become available \
    \ . 119\n   A.1.14     LSR decides to no longer label switch a FEC  ........ 120\n\
    \   A.1.15     Timeout of deferred label request  .................. 121\n   A.2\
    \        Common Label Distribution Procedures  ............... 121\n   A.2.1 \
    \     Send_Label  ......................................... 121\n   A.2.2    \
    \  Send_Label_Request  ................................. 123\n   A.2.3      Send_Label_Withdraw\
    \  ................................ 124\n   A.2.4      Send_Notification  ..................................\
    \ 125\n   A.2.5      Send_Message  ....................................... 125\n\
    \   A.2.6      Check_Received_Attributes  .......................... 126\n   A.2.7\
    \      Prepare_Label_Request_Attributes  ................... 127\n   A.2.8   \
    \   Prepare_Label_Mapping_Attributes  ................... 129\n   Full Copyright\
    \ Statement  ...................................... 132\n"
- title: 1. LDP Overview
  contents:
  - "1. LDP Overview\n   The MPLS architecture [RFC3031] defines a label distribution\
    \ protocol\n   as a set of procedures by which one Label Switched Router (LSR)\n\
    \   informs another of the meaning of labels used to forward traffic\n   between\
    \ and through them.\n   The MPLS architecture does not assume a single label distribution\n\
    \   protocol.  In fact, a number of different label distribution\n   protocols\
    \ are being standardized.  Existing protocols have been\n   extended so that label\
    \ distribution can be piggybacked on them.  New\n   protocols have also been defined\
    \ for the explicit purpose of\n   distributing labels.  The MPLS architecture\
    \ discusses some of the\n   considerations when choosing a label distribution\
    \ protocol for use in\n   particular MPLS applications such as Traffic Engineering\
    \ [RFC2702].\n   The Label Distribution Protocol (LDP) defined in this document\
    \ is a\n   new protocol defined for distributing labels.  It is the set of\n \
    \  procedures and messages by which Label Switched Routers (LSRs)\n   establish\
    \ Label Switched Paths (LSPs) through a network by mapping\n   network-layer routing\
    \ information directly to data-link layer\n   switched paths.  These LSPs may\
    \ have an endpoint at a directly\n   attached neighbor (comparable to IP hop-by-hop\
    \ forwarding), or may\n   have an endpoint at a network egress node, enabling\
    \ switching via all\n   intermediary nodes.\n   LDP associates a Forwarding Equivalence\
    \ Class (FEC) [RFC3031] with\n   each LSP it creates.  The FEC associated with\
    \ an LSP specifies which\n   packets are \"mapped\" to that LSP.  LSPs are extended\
    \ through a\n   network as each LSR \"splices\" incoming labels for a FEC to the\n\
    \   outgoing label assigned to the next hop for the given FEC.\n   More information\
    \ about the applicability of LDP can be found in\n   [RFC3037].\n   This document\
    \ assumes familiarity with the MPLS architecture\n   [RFC3031].  Note that [RFC3031]\
    \ includes a glossary of MPLS\n   terminology, such as ingress, label switched\
    \ path, etc.\n"
- title: 1.1. LDP Peers
  contents:
  - "1.1. LDP Peers\n   Two LSRs which use LDP to exchange label/FEC mapping information\
    \ are\n   known as \"LDP Peers\" with respect to that information and we speak\
    \ of\n   there being an \"LDP Session\" between them.  A single LDP session\n\
    \   allows each peer to learn the other's label mappings; i.e., the\n   protocol\
    \ is bi-directional.\n"
- title: 1.2. LDP Message Exchange
  contents:
  - "1.2. LDP Message Exchange\n   There are four categories of LDP messages:\n  \
    \    1. Discovery messages, used to announce and maintain the presence\n     \
    \    of an LSR in a network.\n      2. Session messages, used to establish, maintain,\
    \ and terminate\n         sessions between LDP peers.\n      3. Advertisement\
    \ messages, used to create, change, and delete\n         label mappings for FECs.\n\
    \      4. Notification messages, used to provide advisory information and\n  \
    \       to signal error information.\n   Discovery messages provide a mechanism\
    \ whereby LSRs indicate their\n   presence in a network by sending a Hello message\
    \ periodically.  This\n   is transmitted as a UDP packet to the LDP port at the\
    \ `all routers on\n   this subnet' group multicast address.  When an LSR chooses\
    \ to\n   establish a session with another LSR learned via the Hello message,\n\
    \   it uses the LDP initialization procedure over TCP transport.  Upon\n   successful\
    \ completion of the initialization procedure, the two LSRs\n   are LDP peers,\
    \ and may exchange advertisement messages.\n   When to request a label or advertise\
    \ a label mapping to a peer is\n   largely a local decision made by an LSR.  In\
    \ general, the LSR\n   requests a label mapping from a neighboring LSR when it\
    \ needs one,\n   and advertises a label mapping to a neighboring LSR when it wishes\n\
    \   the neighbor to use a label.\n   Correct operation of LDP requires reliable\
    \ and in order delivery of\n   messages.  To satisfy these requirements LDP uses\
    \ the TCP transport\n   for session, advertisement and notification messages;\
    \ i.e., for\n   everything but the UDP-based discovery mechanism.\n"
- title: 1.3. LDP Message Structure
  contents:
  - "1.3. LDP Message Structure\n   All LDP messages have a common structure that\
    \ uses a Type-Length-\n   Value (TLV) encoding scheme; see Section \"Type-Length-Value\"\
    \n   encoding.  The Value part of a TLV-encoded object, or TLV for short,\n  \
    \ may itself contain one or more TLVs.\n"
- title: 1.4. LDP Error Handling
  contents:
  - "1.4. LDP Error Handling\n   LDP errors and other events of interest are signaled\
    \ to an LDP peer\n   by notification messages.\n   There are two kinds of LDP\
    \ notification messages:\n      1. Error notifications, used to signal fatal errors.\
    \  If an LSR\n         receives an error notification from a peer for an LDP session,\n\
    \         it terminates the LDP session by closing the TCP transport\n       \
    \  connection for the session and discarding all label mappings\n         learned\
    \ via the session.\n      2. Advisory notifications, used to pass an LSR information\
    \ about\n         the LDP session or the status of some previous message received\n\
    \         from the peer.\n"
- title: 1.5. LDP Extensibility and Future Compatibility
  contents:
  - "1.5. LDP Extensibility and Future Compatibility\n   Functionality may be added\
    \ to LDP in the future.  It is likely that\n   future functionality will utilize\
    \ new messages and object types\n   (TLVs).  It may be desirable to employ such\
    \ new messages and TLVs\n   within a network using older implementations that\
    \ do not recognize\n   them.  While it is not possible to make every future enhancement\n\
    \   backwards compatible, some prior planning can ease the introduction\n   of\
    \ new capabilities.  This specification defines rules for handling\n   unknown\
    \ message types and unknown TLVs for this purpose.\n"
- title: 1.6. Specification Language
  contents:
  - "1.6. Specification Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2. LDP Operation
  contents:
  - '2. LDP Operation

    '
- title: 2.1. FECs
  contents:
  - "2.1. FECs\n   It is necessary to precisely specify which packets may be mapped\
    \ to\n   each LSP.  This is done by providing a FEC specification for each\n \
    \  LSP.  The FEC identifies the set of IP packets which may be mapped to\n   that\
    \ LSP.\n   Each FEC is specified as a set of one or more FEC elements.  Each FEC\n\
    \   element identifies a set of packets which may be mapped to the\n   corresponding\
    \ LSP.  When an LSP is shared by multiple FEC elements,\n   that LSP is terminated\
    \ at (or before) the node where the FEC elements\n   can no longer share the same\
    \ path.\n   Following are the currently defined types of FEC elements.  New\n\
    \   element types may be added as needed:\n      1. Address Prefix.  This element\
    \ is an address prefix of any\n         length from 0 to a full address, inclusive.\n\
    \      2. Host Address.  This element is a full host address.\n   (We will see\
    \ below that an Address Prefix FEC element which is a full\n   address has a different\
    \ effect than a Host Address FEC element which\n   has the same address.)\n  \
    \ We say that a particular address \"matches\" a particular address\n   prefix\
    \ if and only if that address begins with that prefix.  We also\n   say that a\
    \ particular packet matches a particular LSP if and only if\n   that LSP has an\
    \ Address Prefix FEC element which matches the packet's\n   destination address.\
    \  With respect to a particular packet and a\n   particular LSP, we refer to any\
    \ Address Prefix FEC element which\n   matches the packet as the \"matching prefix\"\
    .\n   The procedure for mapping a particular packet to a particular LSP\n   uses\
    \ the following rules.  Each rule is applied in turn until the\n   packet can\
    \ be mapped to an LSP.\n      -  If there is exactly one LSP which has a Host\
    \ Address FEC\n         element that is identical to the packet's destination\
    \ address,\n         then the packet is mapped to that LSP.\n      -  If there\
    \ are multiple LSPs, each containing a Host Address FEC\n         element that\
    \ is identical to the packet's destination address,\n         then the packet\
    \ is mapped to one of those LSPs.  The procedure\n         for selecting one of\
    \ those LSPs is beyond the scope of this\n         document.\n      -  If a packet\
    \ matches exactly one LSP, the packet is mapped to\n         that LSP.\n     \
    \ -  If a packet matches multiple LSPs, it is mapped to the LSP\n         whose\
    \ matching prefix is the longest.  If there is no one LSP\n         whose matching\
    \ prefix is longest, the packet is mapped to one\n         from the set of LSPs\
    \ whose matching prefix is longer than the\n         others.  The procedure for\
    \ selecting one of those LSPs is\n         beyond the scope of this document.\n\
    \      -  If it is known that a packet must traverse a particular egress\n   \
    \      router, and there is an LSP which has an Address Prefix FEC\n         element\
    \ which is an address of that router, then the packet is\n         mapped to that\
    \ LSP.  The procedure for obtaining this knowledge\n         is beyond the scope\
    \ of this document.\n   The procedure for determining that a packet must traverse\
    \ a\n   particular egress router is beyond the scope of this document.  (As\n\
    \   an example, if one is running a link state routing algorithm, it may\n   be\
    \ possible to obtain this information from the link state data base.\n   As another\
    \ example, if one is running BGP, it may be possible to\n   obtain this information\
    \ from the BGP next hop attribute of the\n   packet's route.)\n   It is worth\
    \ pointing out a few consequences of these rules:\n      -  A packet may be sent\
    \ on the LSP whose Address Prefix FEC\n         element is the address of the\
    \ packet's egress router ONLY if\n         there is no LSP matching the packet's\
    \ destination address.\n      -  A packet may match two LSPs, one with a Host\
    \ Address FEC\n         element and one with an Address Prefix FEC element.  In\
    \ this\n         case, the packet is always assigned to the former.\n      - \
    \ A packet which does not match a particular Host Address FEC\n         element\
    \ may not be sent on the corresponding LSP, even if the\n         Host Address\
    \ FEC element identifies the packet's egress router.\n"
- title: 2.2. Label Spaces, Identifiers, Sessions and Transport
  contents:
  - '2.2. Label Spaces, Identifiers, Sessions and Transport

    '
- title: 2.2.1. Label Spaces
  contents:
  - "2.2.1. Label Spaces\n   The notion of \"label space\" is useful for discussing\
    \ the assignment\n   and distribution of labels.  There are two types of label\
    \ spaces:\n      -  Per interface label space.  Interface-specific incoming labels\n\
    \         are used for interfaces that use interface resources for\n         labels.\
    \  An example of such an interface is a label-controlled\n         ATM interface\
    \ that uses VCIs as labels, or a Frame Relay\n         interface that uses DLCIs\
    \ as labels.\n         Note that the use of a per interface label space only makes\n\
    \         sense when the LDP peers are \"directly connected\" over an\n      \
    \   interface, and the label is only going to be used for traffic\n         sent\
    \ over that interface.\n      -  Per platform label space.  Platform-wide incoming\
    \ labels are\n         used for interfaces that can share the same labels.\n"
- title: 2.2.2. LDP Identifiers
  contents:
  - "2.2.2. LDP Identifiers\n   An LDP identifier is a six octet quantity used to\
    \ identify an LSR\n   label space.  The first four octets identify the LSR and\
    \ must be a\n   globally unique value, such as a 32-bit router Id assigned to\
    \ the\n   LSR.  The last two octets identify a specific label space within the\n\
    \   LSR.  The last two octets of LDP Identifiers for platform-wide label\n   spaces\
    \ are always both zero.  This document uses the following print\n   representation\
    \ for LDP Identifiers:\n             <LSR Id> : <label space id>\n   e.g., lsr171:0,\
    \ lsr19:2.\n   Note that an LSR that manages and advertises multiple label spaces\n\
    \   uses a different LDP Identifier for each such label space.\n   A situation\
    \ where an LSR would need to advertise more than one label\n   space to a peer\
    \ and hence use more than one LDP Identifier occurs\n   when the LSR has two links\
    \ to the peer and both are ATM (and use per\n   interface labels).  Another situation\
    \ would be where the LSR had two\n   links to the peer, one of which is ethernet\
    \ (and uses per platform\n   labels) and the other of which is ATM.\n"
- title: 2.2.3. LDP Sessions
  contents:
  - "2.2.3. LDP Sessions\n   LDP sessions exist between LSRs to support label exchange\
    \ between\n   them.\n      When an LSR uses LDP to advertise more than one label\
    \ space to\n      another LSR it uses a separate LDP session for each label space.\n"
- title: 2.2.4. LDP Transport
  contents:
  - "2.2.4. LDP Transport\n   LDP uses TCP as a reliable transport for sessions.\n\
    \      When multiple LDP sessions are required between two LSRs there is\n   \
    \   one TCP session for each LDP session.\n"
- title: 2.3. LDP Sessions between non-Directly Connected LSRs
  contents:
  - "2.3. LDP Sessions between non-Directly Connected LSRs\n   LDP sessions between\
    \ LSRs that are not directly connected at the link\n   level may be desirable\
    \ in some situations.\n   For example, consider a \"traffic engineering\" application\
    \ where LSRa\n   sends traffic matching some criteria via an LSP to non-directly\n\
    \   connected LSRb rather than forwarding the traffic along its normally\n   routed\
    \ path.\n   The path between LSRa and LSRb would include one or more intermediate\n\
    \   LSRs (LSR1,...LSRn).  An LDP session between LSRa and LSRb would\n   enable\
    \ LSRb to label switch traffic arriving on the LSP from LSRa by\n   providing\
    \ LSRb means to advertise labels for this purpose to LSRa.\n   In this situation\
    \ LSRa would apply two labels to traffic it forwards\n   on the LSP to LSRb: a\
    \ label learned from LSR1 to forward traffic\n   along the LSP path from LSRa\
    \ to LSRb; and a label learned from LSRb\n   to enable LSRb to label switch traffic\
    \ arriving on the LSP.\n   LSRa first adds the label learned via its LDP session\
    \ with LSRb to\n   the packet label stack (either by replacing the label on top\
    \ of the\n   packet label stack with it if the packet arrives labeled or by\n\
    \   pushing it if the packet arrives unlabeled).  Next, it pushes the\n   label\
    \ for the LSP learned from LSR1 onto the label stack.\n"
- title: 2.4. LDP Discovery
  contents:
  - "2.4. LDP Discovery\n   LDP discovery is a mechanism that enables an LSR to discover\n\
    \   potential LDP peers.  Discovery makes it unnecessary to explicitly\n   configure\
    \ an LSR's label switching peers.\n   There are two variants of the discovery\
    \ mechanism:\n      -  A basic discovery mechanism used to discover LSR neighbors\
    \ that\n         are directly connected at the link level.\n      -  An extended\
    \ discovery mechanism used to locate LSRs that are\n         not directly connected\
    \ at the link level.\n"
- title: 2.4.1. Basic Discovery Mechanism
  contents:
  - "2.4.1. Basic Discovery Mechanism\n   To engage in LDP Basic Discovery on an interface\
    \ an LSR periodically\n   sends LDP Link Hellos out the interface.  LDP Link Hellos\
    \ are sent as\n   UDP packets addressed to the well-known LDP discovery port for\
    \ the\n   \"all routers on this subnet\" group multicast address.\n   An LDP Link\
    \ Hello sent by an LSR carries the LDP Identifier for the\n   label space the\
    \ LSR intends to use for the interface and possibly\n   additional information.\n\
    \   Receipt of an LDP Link Hello on an interface identifies a \"Hello\n   adjacency\"\
    \ with a potential LDP peer reachable at the link level on\n   the interface as\
    \ well as the label space the peer intends to use for\n   the interface.\n"
- title: 2.4.2. Extended Discovery Mechanism
  contents:
  - "2.4.2. Extended Discovery Mechanism\n   LDP sessions between non-directly connected\
    \ LSRs are supported by LDP\n   Extended Discovery.\n   To engage in LDP Extended\
    \ Discovery an LSR periodically sends LDP\n   Targeted Hellos to a specific address.\
    \  LDP Targeted Hellos are sent\n   as UDP packets addressed to the well-known\
    \ LDP discovery port at the\n   specific address.\n   An LDP Targeted Hello sent\
    \ by an LSR carries the LDP Identifier for\n   the label space the LSR intends\
    \ to use and possibly additional\n   optional information.\n   Extended Discovery\
    \ differs from Basic Discovery in the following\n   ways:\n      -  A Targeted\
    \ Hello is sent to a specific address rather than to\n         the \"all routers\"\
    \ group multicast address for the outgoing\n         interface.\n      -  Unlike\
    \ Basic Discovery, which is symmetric, Extended Discovery\n         is asymmetric.\n\
    \         One LSR initiates Extended Discovery with another targeted LSR,\n  \
    \       and the targeted LSR decides whether to respond to or ignore\n       \
    \  the Targeted Hello.  A targeted LSR that chooses to respond\n         does\
    \ so by periodically sending Targeted Hellos to the\n         initiating LSR.\n\
    \   Receipt of an LDP Targeted Hello identifies a \"Hello adjacency\" with\n \
    \  a potential LDP peer reachable at the network level and the label\n   space\
    \ the peer intends to use.\n"
- title: 2.5. Establishing and Maintaining LDP Sessions
  contents:
  - '2.5. Establishing and Maintaining LDP Sessions

    '
- title: 2.5.1. LDP Session Establishment
  contents:
  - "2.5.1. LDP Session Establishment\n   The exchange of LDP Discovery Hellos between\
    \ two LSRs triggers LDP\n   session establishment.  Session establishment is a\
    \ two step process:\n            -  Transport connection establishment.\n    \
    \        -  Session initialization\n   The following describes establishment of\
    \ an LDP session between LSRs\n   LSR1 and LSR2 from LSR1's point of view.  It\
    \ assumes the exchange of\n   Hellos specifying label space LSR1:a for LSR1 and\
    \ label space LSR2:b\n   for LSR2.\n"
- title: 2.5.2. Transport Connection Establishment
  contents:
  - "2.5.2. Transport Connection Establishment\n   The exchange of Hellos results\
    \ in the creation of a Hello adjacency\n   at LSR1 that serves to bind the link\
    \ (L) and the label spaces LSR1:a\n   and LSR2:b.\n      1. If LSR1 does not already\
    \ have an LDP session for the exchange\n         of label spaces LSR1:a and LSR2:b\
    \ it attempts to open a TCP\n         connection for a new LDP session with LSR2.\n\
    \         LSR1 determines the transport addresses to be used at its end\n    \
    \     (A1) and LSR2's end (A2) of the LDP TCP connection.  Address A1\n      \
    \   is determined as follows:\n         a. If LSR1 uses the Transport Address\
    \ optional object (TLV) in\n            Hello's it sends to LSR2 to advertise\
    \ an address, A1 is the\n            address LSR1 advertises via the optional\
    \ object;\n         b. If LSR1 does not use the Transport Address optional object,\n\
    \            A1 is the source address used in Hellos it sends to LSR2.\n     \
    \    Similarly, address A2 is determined as follows:\n         a. If LSR2 uses\
    \ the Transport Address optional object, A2 is\n            the address LSR2 advertises\
    \ via the optional object;\n         b. If LSR2 does not use the Transport Address\
    \ optional object,\n            A2 is the source address in Hellos received from\
    \ LSR2.\n      2. LSR1 determines whether it will play the active or passive role\n\
    \         in session establishment by comparing addresses A1 and A2 as\n     \
    \    unsigned integers.  If A1 > A2, LSR1 plays the active role;\n         otherwise\
    \ it is passive.\n         The procedure for comparing A1 and A2 as unsigned integers\
    \ is:\n         -  If A1 and A2 are not in the same address family, they are\n\
    \            incomparable, and no session can be established.\n         -  Let\
    \ U1 be the abstract unsigned integer obtained by treating\n            A1 as\
    \ a sequence of bytes, where the byte which appears\n            earliest in the\
    \ message is the most significant byte of the\n            integer and the byte\
    \ which appears latest in the message is\n            the least significant byte\
    \ of the integer.\n            Let U2 be the abstract unsigned integer obtained\
    \ from A2 in\n            a similar manner.\n         -  Compare U1 with U2. \
    \ If U1 > U2, then A1 > A2; if U1 < U2,\n            then A1 < A2.\n      3. If\
    \ LSR1 is active, it attempts to establish the LDP TCP\n         connection by\
    \ connecting to the well-known LDP port at address\n         A2.  If LSR1 is passive,\
    \ it waits for LSR2 to establish the LDP\n         TCP connection to its well-known\
    \ LDP port.\n   Note that when an LSR sends a Hello it selects the transport address\n\
    \   for its end of the session connection and uses the Hello to advertise\n  \
    \ the address, either explicitly by including it in an optional\n   Transport\
    \ Address TLV or implicitly by omitting the TLV and using it\n   as the Hello\
    \ source address.\n   An LSR MUST advertise the same transport address in all\
    \ Hellos that\n   advertise the same label space.  This requirement ensures that\
    \ two\n   LSRs linked by multiple Hello adjacencies using the same label spaces\n\
    \   play the same connection establishment role for each adjacency.\n"
- title: 2.5.3. Session Initialization
  contents:
  - "2.5.3. Session Initialization\n   After LSR1 and LSR2 establish a transport connection\
    \ they negotiate\n   session parameters by exchanging LDP Initialization messages.\
    \  The\n   parameters negotiated include LDP protocol version, label\n   distribution\
    \ method, timer values, VPI/VCI ranges for label\n   controlled ATM, DLCI ranges\
    \ for label controlled Frame Relay, etc.\n   Successful negotiation completes\
    \ establishment of an LDP session\n   between LSR1 and LSR2 for the advertisement\
    \ of label spaces LSR1:a\n   and LSR2:b.\n   The following describes the session\
    \ initialization from LSR1's point\n   of view.\n   After the connection is established,\
    \ if LSR1 is playing the active\n   role, it initiates negotiation of session\
    \ parameters by sending an\n   Initialization message to LSR2.  If LSR1 is passive,\
    \ it waits for\n   LSR2 to initiate the parameter negotiation.\n   In general\
    \ when there are multiple links between LSR1 and LSR2 and\n   multiple label spaces\
    \ to be advertised by each, the passive LSR\n   cannot know which label space\
    \ to advertise over a newly established\n   TCP connection until it receives the\
    \ LDP Initialization message on\n   the connection.  The Initialization message\
    \ carries both the LDP\n   Identifier for the sender's (active LSR's) label space\
    \ and the LDP\n   Identifier for the receiver's (passive LSR's) label space.\n\
    \   By waiting for the Initialization message from its peer the passive\n   LSR\
    \ can match the label space to be advertised by the peer (as\n   determined from\
    \ the LDP Identifier in the PDU header for the\n   Initialization message) with\
    \ a Hello adjacency previously created\n   when Hellos were exchanged.\n     \
    \ 1. When LSR1 plays the passive role:\n         a. If LSR1 receives an Initialization\
    \ message it attempts to\n            match the LDP Identifier carried by the\
    \ message PDU with a\n            Hello adjacency.\n         b. If there is a\
    \ matching Hello adjacency, the adjacency\n            specifies the local label\
    \ space for the session.\n            Next LSR1 checks whether the session parameters\
    \ proposed in\n            the message are acceptable.  If they are, LSR1 replies\
    \ with\n            an Initialization message of its own to propose the\n    \
    \        parameters it wishes to use and a KeepAlive message to\n            signal\
    \ acceptance of LSR2's parameters.  If the parameters\n            are not acceptable,\
    \ LSR1 responds by sending a Session\n            Rejected/Parameters Error Notification\
    \ message and closing\n            the TCP connection.\n         c. If LSR1 cannot\
    \ find a matching Hello adjacency it sends a\n            Session Rejected/No\
    \ Hello Error Notification message and\n            closes the TCP connection.\n\
    \         d. If LSR1 receives a KeepAlive in response to its\n            Initialization\
    \ message, the session is operational from\n            LSR1's point of view.\n\
    \         e. If LSR1 receives an Error Notification message, LSR2 has\n      \
    \      rejected its proposed session and LSR1 closes the TCP\n            connection.\n\
    \      2. When LSR1 plays the active role:\n         a. If LSR1 receives an Error\
    \ Notification message, LSR2 has\n            rejected its proposed session and\
    \ LSR1 closes the TCP\n            connection.\n         b. If LSR1 receives an\
    \ Initialization message, it checks\n            whether the session parameters\
    \ are acceptable.  If so, it\n            replies with a KeepAlive message.  If\
    \ the session parameters\n            are unacceptable, LSR1 sends a Session Rejected/Parameters\n\
    \            Error Notification message and closes the connection.\n         c.\
    \ If LSR1 receives a KeepAlive message, LSR2 has accepted its\n            proposed\
    \ session parameters.\n         d. When LSR1 has received both an acceptable Initialization\n\
    \            message and a KeepAlive message the session is operational\n    \
    \        from LSR1's point of view.\n      It is possible for a pair of incompatibly\
    \ configured LSRs that\n      disagree on session parameters to engage in an endless\
    \ sequence of\n      messages as each NAKs the other's Initialization messages\
    \ with\n      Error Notification messages.\n      An LSR must throttle its session\
    \ setup retry attempts with an\n      exponential backoff in situations where\
    \ Initialization messages\n      are being NAK'd.  It is also recommended that\
    \ an LSR detecting\n      such a situation take action to notify an operator.\n\
    \      The session establishment setup attempt following a NAK'd\n      Initialization\
    \ message must be delayed no less than 15 seconds,\n      and subsequent delays\
    \ must grow to a maximum delay of no less than\n      2 minutes.  The specific\
    \ session establishment action that must be\n      delayed is the attempt to open\
    \ the session transport connection by\n      the LSR playing the active role.\n\
    \      The throttled sequence of Initialization NAKs is unlikely to cease\n  \
    \    until operator intervention reconfigures one of the LSRs.  After\n      such\
    \ a configuration action there is no further need to throttle\n      subsequent\
    \ session establishment attempts (until their\n      initialization messages are\
    \ NAK'd).\n      Due to the asymmetric nature of session establishment,\n    \
    \  reconfiguration of the passive LSR will go unnoticed by the active\n      LSR\
    \ without some further action.  Section \"Hello Message\"\n      describes an\
    \ optional mechanism an LSR can use to signal potential\n      LDP peers that\
    \ it has been reconfigured.\n"
- title: 2.5.4. Initialization State Machine
  contents:
  - "2.5.4. Initialization State Machine\n   It is convenient to describe LDP session\
    \ negotiation behavior in\n   terms of a state machine.  We define the LDP state\
    \ machine to have\n   five possible states and present the behavior as a state\
    \ transition\n   table and as a state transition diagram.\n               Session\
    \ Initialization State Transition Table\n      STATE         EVENT           \
    \                    NEW STATE\n      NON EXISTENT  Session TCP connection established\
    \  INITIALIZED\n                    established\n      INITIALIZED   Transmit\
    \ Initialization msg         OPENSENT\n                          (Active Role)\n\
    \                    Receive acceptable                  OPENREC\n           \
    \               Initialization msg\n                          (Passive Role )\n\
    \                      Action: Transmit Initialization\n                     \
    \         msg and KeepAlive msg\n                    Receive Any other LDP msg\
    \           NON EXISTENT\n                      Action: Transmit Error Notification\
    \ msg\n                              (NAK) and close transport connection\n  \
    \    OPENREC       Receive KeepAlive msg               OPERATIONAL\n         \
    \           Receive Any other LDP msg           NON EXISTENT\n               \
    \       Action: Transmit Error Notification msg\n                            \
    \  (NAK) and close transport connection\n      OPENSENT      Receive acceptable\
    \                  OPENREC\n                          Initialization msg\n   \
    \                   Action: Transmit KeepAlive msg\n                    Receive\
    \ Any other LDP msg           NON EXISTENT\n                      Action: Transmit\
    \ Error Notification msg\n                              (NAK) and close transport\
    \ connection\n      OPERATIONAL   Receive Shutdown msg                NON EXISTENT\n\
    \                      Action: Transmit Shutdown msg and\n                   \
    \           close transport connection\n                    Receive other LDP\
    \ msgs              OPERATIONAL\n                    Timeout                 \
    \            NON EXISTENT\n                      Action: Transmit Shutdown msg\
    \ and\n                              close transport connection\n            \
    \   Session Initialization State Transition Diagram\n                        \
    \         +------------+\n                                 |            |\n  \
    \                 +------------>|NON EXISTENT|<--------------------+\n       \
    \            |             |            |                     |\n            \
    \       |             +------------+                     |\n                 \
    \  | Session        |    ^                          |\n                   |  \
    \ connection   |    |                          |\n                   |   established\
    \  |    | Rx any LDP msg except    |\n                   |                V  \
    \  |   Init msg or Timeout    |\n                   |            +-----------+\
    \                       |\n      Rx Any other |            |           |     \
    \                  |\n         msg or    |            |INITIALIZED|          \
    \             |\n         Timeout / |        +---|           |-+             \
    \        |\n      Tx NAK msg   |        |   +-----------+ |                  \
    \   |\n                   |        | (Passive Role)  | (Active Role)       |\n\
    \                   |        | Rx Acceptable   | Tx Init msg         |\n     \
    \              |        |    Init msg /   |                     |\n          \
    \         |        | Tx Init msg     |                     |\n               \
    \    |        |    Tx KeepAlive |                     |\n                   |\
    \        V    msg          V                     |\n                   |   +-------+\
    \        +--------+                  |\n                   |   |       |     \
    \   |        |                  |\n                   +---|OPENREC|        |OPENSENT|----------------->|\n\
    \                   +---|       |        |        | Rx Any other msg |\n     \
    \              |   +-------+        +--------+    or Timeout    |\n      Rx KeepAlive\
    \ |        ^                |     Tx NAK msg       |\n         msg       |   \
    \     |                |                      |\n                   |        |\
    \                | Rx Acceptable        |\n                   |        |     \
    \           |    Init msg /        |\n                   |        +----------------+\
    \ Tx KeepAlive msg     |\n                   |                               \
    \                 |\n                   |      +-----------+                 \
    \            |\n                   +----->|           |                      \
    \       |\n                          |OPERATIONAL|                           \
    \  |\n                          |           |---------------------------->+\n\
    \                          +-----------+     Rx Shutdown msg\n               \
    \    All other  |   ^            or Timeout /\n                     LDP msgs |\
    \   |         Tx Shutdown msg\n                              |   |\n         \
    \                     +---+\n"
- title: 2.5.5. Maintaining Hello Adjacencies
  contents:
  - "2.5.5. Maintaining Hello Adjacencies\n   An LDP session with a peer has one or\
    \ more Hello adjacencies.\n   An LDP session has multiple Hello adjacencies when\
    \ a pair of LSRs is\n   connected by multiple links that share the same label\
    \ space; for\n   example, multiple PPP links between a pair of routers.  In this\n\
    \   situation the Hellos an LSR sends on each such link carry the same\n   LDP\
    \ Identifier.\n   LDP includes mechanisms to monitor the necessity of an LDP session\n\
    \   and its Hello adjacencies.\n   LDP uses the regular receipt of LDP Discovery\
    \ Hellos to indicate a\n   peer's intent to use the label space identified by\
    \ the Hello.  An LSR\n   maintains a hold timer with each Hello adjacency which\
    \ it restarts\n   when it receives a Hello that matches the adjacency.  If the\
    \ timer\n   expires without receipt of a matching Hello from the peer, LDP\n \
    \  concludes that the peer no longer wishes to label switch using that\n   label\
    \ space for that link (or target, in the case of Targeted Hellos)\n   or that\
    \ the peer has failed.  The LSR then deletes the Hello\n   adjacency.  When the\
    \ last Hello adjacency for a LDP session is\n   deleted, the LSR terminates the\
    \ LDP session by sending a Notification\n   message and closing the transport\
    \ connection.\n"
- title: 2.5.6. Maintaining LDP Sessions
  contents:
  - "2.5.6. Maintaining LDP Sessions\n   LDP includes mechanisms to monitor the integrity\
    \ of the LDP session.\n   LDP uses the regular receipt of LDP PDUs on the session\
    \ transport\n   connection to monitor the integrity of the session.  An LSR maintains\n\
    \   a KeepAlive timer for each peer session which it resets whenever it\n   receives\
    \ an LDP PDU from the session peer.  If the KeepAlive timer\n   expires without\
    \ receipt of an LDP PDU from the peer the LSR concludes\n   that the transport\
    \ connection is bad or that the peer has failed, and\n   it terminates the LDP\
    \ session by closing the transport connection.\n   After an LDP session has been\
    \ established, an LSR must arrange that\n   its peer receive an LDP PDU from it\
    \ at least every KeepAlive time\n   period to ensure the peer restarts the session\
    \ KeepAlive timer.  The\n   LSR may send any protocol message to meet this requirement.\
    \  In\n   circumstances where an LSR has no other information to communicate to\n\
    \   its peer, it sends a KeepAlive message.\n   An LSR may choose to terminate\
    \ an LDP session with a peer at any\n   time.  Should it choose to do so, it informs\
    \ the peer with a Shutdown\n   message.\n"
- title: 2.6. Label Distribution and Management
  contents:
  - "2.6. Label Distribution and Management\n   The MPLS architecture [RF3031] allows\
    \ an LSR to distribute a FEC\n   label binding in response to an explicit request\
    \ from another LSR.\n   This is known as Downstream On Demand label distribution.\
    \  It also\n   allows an LSR to distribute label bindings to LSRs that have not\n\
    \   explicitly requested them.  [RFC3031] calls this method of label\n   distribution\
    \ Unsolicited Downstream; this document uses the term\n   Downstream Unsolicited.\n\
    \   Both of these label distribution techniques may be used in the same\n   network\
    \ at the same time.  However, for any given LDP session, each\n   LSR must be\
    \ aware of the label distribution method used by its peer\n   in order to avoid\
    \ situations where one peer using Downstream\n   Unsolicited label distribution\
    \ assumes its peer is also.  See Section\n   \"Downstream on Demand label Advertisement\"\
    .\n"
- title: 2.6.1. Label Distribution Control Mode
  contents:
  - "2.6.1. Label Distribution Control Mode\n   The behavior of the initial setup\
    \ of LSPs is determined by whether\n   the LSR is operating with independent or\
    \ ordered LSP control.  An LSR\n   may support both types of control as a configurable\
    \ option.\n"
- title: 2.6.1.1. Independent Label Distribution Control
  contents:
  - "2.6.1.1. Independent Label Distribution Control\n   When using independent LSP\
    \ control, each LSR may advertise label\n   mappings to its neighbors at any time\
    \ it desires.  For example, when\n   operating in independent Downstream on Demand\
    \ mode, an LSR may answer\n   requests for label mappings immediately, without\
    \ waiting for a label\n   mapping from the next hop.  When operating in independent\
    \ Downstream\n   Unsolicited mode, an LSR may advertise a label mapping for a\
    \ FEC to\n   its neighbors whenever it is prepared to label-switch that FEC.\n\
    \   A consequence of using independent mode is that an upstream label can\n  \
    \ be advertised before a downstream label is received.\n"
- title: 2.6.1.2. Ordered Label Distribution Control
  contents:
  - "2.6.1.2. Ordered Label Distribution Control\n   When using LSP ordered control,\
    \ an LSR may initiate the transmission\n   of a label mapping only for a FEC for\
    \ which it has a label mapping\n   for the FEC next hop, or for which the LSR\
    \ is the egress.  For each\n   FEC for which the LSR is not the egress and no\
    \ mapping exists, the\n   LSR MUST wait until a label from a downstream LSR is\
    \ received before\n   mapping the FEC and passing corresponding labels to upstream\
    \ LSRs.\n   An LSR may be an egress for some FECs and a non-egress for others.\n\
    \   An LSR may act as an egress LSR, with respect to a particular FEC,\n   under\
    \ any of the following conditions:\n      1. The FEC refers to the LSR itself\
    \ (including one of its directly\n         attached interfaces).\n      2. The\
    \ next hop router for the FEC is outside of the Label\n         Switching Network.\n\
    \      3. FEC elements are reachable by crossing a routing domain\n         boundary,\
    \ such as another area for OSPF summary networks, or\n         another autonomous\
    \ system for OSPF AS externals and BGP routes\n         [RFC2328] [RFC1771].\n\
    \   Note that whether an LSR is an egress for a given FEC may change over\n  \
    \ time, depending on the state of the network and LSR configuration\n   settings.\n"
- title: 2.6.2. Label Retention Mode
  contents:
  - "2.6.2. Label Retention Mode\n   The MPLS architecture [RFC3031] introduces the\
    \ notion of label\n   retention mode which specifies whether an LSR maintains\
    \ a label\n   binding for a FEC learned from a neighbor that is not its next hop\n\
    \   for the FEC.\n"
- title: 2.6.2.1. Conservative Label Retention Mode
  contents:
  - "2.6.2.1. Conservative Label Retention Mode\n   In Downstream Unsolicited advertisement\
    \ mode, label mapping\n   advertisements for all routes may be received from all\
    \ peer LSRs.\n   When using conservative label retention, advertised label mappings\n\
    \   are retained only if they will be used to forward packets (i.e., if\n   they\
    \ are received from a valid next hop according to routing).  If\n   operating\
    \ in Downstream on Demand mode, an LSR will request label\n   mappings only from\
    \ the next hop LSR according to routing.  Since\n   Downstream on Demand mode\
    \ is primarily used when label conservation\n   is desired (e.g., an ATM switch\
    \ with limited cross connect space), it\n   is typically used with the conservative\
    \ label retention mode.\n   The main advantage of the conservative mode is that\
    \ only the labels\n   that are required for the forwarding of data are allocated\
    \ and\n   maintained.  This is particularly important in LSRs where the label\n\
    \   space is inherently limited, such as in an ATM switch.  A\n   disadvantage\
    \ of the conservative mode is that if routing changes the\n   next hop for a given\
    \ destination, a new label must be obtained from\n   the new next hop before labeled\
    \ packets can be forwarded.\n"
- title: 2.6.2.2. Liberal Label Retention Mode
  contents:
  - "2.6.2.2. Liberal Label Retention Mode\n   In Downstream Unsolicited advertisement\
    \ mode, label mapping\n   advertisements for all routes may be received from all\
    \ LDP peers.\n   When using liberal label retention, every label mappings received\n\
    \   from a peer LSR is retained regardless of whether the LSR is the next\n  \
    \ hop for the advertised mapping.  When operating in Downstream on\n   Demand\
    \ mode with liberal label retention, an LSR might choose to\n   request label\
    \ mappings for all known prefixes from all peer LSRs.\n   Note, however, that\
    \ Downstream on Demand mode is typically used by\n   devices such as ATM switch-based\
    \ LSRs for which the conservative\n   approach is recommended.\n   The main advantage\
    \ of the liberal label retention mode is that\n   reaction to routing changes\
    \ can be quick because labels already\n   exist.  The main disadvantage of the\
    \ liberal mode is that unneeded\n   label mappings are distributed and maintained.\n"
- title: 2.6.3. Label Advertisement Mode
  contents:
  - "2.6.3. Label Advertisement Mode\n   Each interface on an LSR is configured to\
    \ operate in either\n   Downstream Unsolicited or Downstream on Demand advertisement\
    \ mode.\n   LSRs exchange advertisement modes during initialization.  The major\n\
    \   difference between Downstream Unsolicited and Downstream on Demand\n   modes\
    \ is in which LSR takes responsibility for initiating mapping\n   requests and\
    \ mapping advertisements.\n"
- title: 2.7. LDP Identifiers and Next Hop Addresses
  contents:
  - "2.7. LDP Identifiers and Next Hop Addresses\n   An LSR maintains learned labels\
    \ in a Label Information Base (LIB).\n   When operating in Downstream Unsolicited\
    \ mode, the LIB entry for an\n   address prefix associates a collection of (LDP\
    \ Identifier, label)\n   pairs with the prefix, one such pair for each peer advertising\
    \ a\n   label for the prefix.\n   When the next hop for a prefix changes the LSR\
    \ must retrieve the\n   label advertised by the new next hop from the LIB for\
    \ use in\n   forwarding.  To retrieve the label the LSR must be able to map the\n\
    \   next hop address for the prefix to an LDP Identifier.\n   Similarly, when\
    \ the LSR learns a label for a prefix from an LDP peer,\n   it must be able to\
    \ determine whether that peer is currently a next\n   hop for the prefix to determine\
    \ whether it needs to start using the\n   newly learned label when forwarding\
    \ packets that match the prefix.\n   To make that decision the LSR must be able\
    \ to map an LDP Identifier\n   to the peer's addresses to check whether any are\
    \ a next hop for the\n   prefix.\n   To enable LSRs to map between a peer LDP\
    \ identifier and the peer's\n   addresses, LSRs advertise their addresses using\
    \ LDP Address and\n   Withdraw Address messages.\n   An LSR sends an Address message\
    \ to advertise its addresses to a peer.\n   An LSR sends a Withdraw Address message\
    \ to withdraw previously\n   advertised addresses from a peer\n"
- title: 2.8. Loop Detection
  contents:
  - "2.8. Loop Detection\n   Loop detection is a configurable option which provides\
    \ a mechanism\n   for finding looping LSPs and for preventing Label Request messages\n\
    \   from looping in the presence of non-merge capable LSRs.\n   The mechanism\
    \ makes use of Path Vector and Hop Count TLVs carried by\n   Label Request and\
    \ Label Mapping messages.  It builds on the following\n   basic properties of\
    \ these TLVs:\n      -  A Path Vector TLV contains a list of the LSRs that its\n\
    \         containing message has traversed.  An LSR is identified in a\n     \
    \    Path Vector list by its unique LSR Identifier (Id), which is\n         the\
    \ first four octets of its LDP Identifier.  When an LSR\n         propagates a\
    \ message containing a Path Vector TLV it adds its\n         LSR Id to the Path\
    \ Vector list.  An LSR that receives a message\n         with a Path Vector that\
    \ contains its LSR Id detects that the\n         message has traversed a loop.\
    \  LDP supports the notion of a\n         maximum allowable Path Vector length;\
    \ an LSR that detects a\n         Path Vector has reached the maximum length behaves\
    \ as if the\n         containing message has traversed a loop.\n      -  A Hop\
    \ Count TLV contains a count of the LSRS that the\n         containing message\
    \ has traversed.  When an LSR propagates a\n         message containing a Hop\
    \ Count TLV it increments the count.  An\n         LSR that detects a Hop Count\
    \ has reached a configured maximum\n         value behaves as if the containing\
    \ message has traversed a\n         loop.  By convention a count of 0 is interpreted\
    \ to mean the\n         hop count is unknown.  Incrementing an unknown hop count\
    \ value\n         results in an unknown hop count value (0).\n   The following\
    \ paragraphs describes LDP loop detection procedures.\n   For these paragraphs,\
    \ and only these paragraphs, \"MUST\" is redefined\n   to mean \"MUST if configured\
    \ for loop detection\".  The paragraphs\n   specify messages that must carry Path\
    \ Vector and Hop Count TLVs.\n   Note that the Hop Count TLV and its procedures\
    \ are used without the\n   Path Vector TLV in situations when loop detection is\
    \ not configured\n   (see [RFC3035] and [RFC3034]).\n"
- title: 2.8.1. Label Request Message
  contents:
  - "2.8.1. Label Request Message\n   The use of the Path Vector TLV and Hop Count\
    \ TLV prevent Label\n   Request messages from looping in environments that include\
    \ non-merge\n   capable LSRs.\n   The rules that govern use of the Hop Count TLV\
    \ in Label Request\n   messages by LSR R when Loop Detection is enabled are the\
    \ following:\n   -  The Label Request message MUST include a Hop Count TLV.\n\
    \   -  If R is sending the Label Request because it is a FEC ingress, it\n   \
    \   MUST include a Hop Count TLV with hop count value 1.\n   -  If R is sending\
    \ the Label Request as a result of having received a\n      Label Request from\
    \ an upstream LSR, and if the received Label\n      Request contains a Hop Count\
    \ TLV, R MUST increment the received\n      hop count value by 1 and MUST pass\
    \ the resulting value in a Hop\n      Count TLV to its next hop along with the\
    \ Label Request message;\n   The rules that govern use of the Path Vector TLV\
    \ in Label Request\n   messages by LSR R when Loop Detection is enabled are the\
    \ following:\n   -  If R is sending the Label Request because it is a FEC ingress,\n\
    \      then if R is non-merge capable, it MUST include a Path Vector TLV\n   \
    \   of length 1 containing its own LSR Id.\n   -  If R is sending the Label Request\
    \ as a result of having received a\n      Label Request from an upstream LSR,\
    \ then if the received Label\n      Request contains a Path Vector TLV or if R\
    \ is non-merge capable:\n         R MUST add its own LSR Id to the Path Vector,\
    \ and MUST pass the\n         resulting Path Vector to its next hop along with\
    \ the Label\n         Request message.  If the Label Request contains no Path\
    \ Vector\n         TLV, R MUST include a Path Vector TLV of length 1 containing\n\
    \         its own LSR Id.\n   Note that if R receives a Label Request message\
    \ for a particular FEC,\n   and R has previously sent a Label Request message\
    \ for that FEC to its\n   next hop and has not yet received a reply, and if R\
    \ intends to merge\n   the newly received Label Request with the existing outstanding\
    \ Label\n   Request, then R does not propagate the Label Request to the next hop.\n\
    \   If R receives a Label Request message from its next hop with a Hop\n   Count\
    \ TLV which exceeds the configured maximum value, or with a Path\n   Vector TLV\
    \ containing its own LSR Id or which exceeds the maximum\n   allowable length,\
    \ then R detects that the Label Request message has\n   traveled in a loop.\n\
    \   When R detects a loop, it MUST send a Loop Detected Notification\n   message\
    \ to the source of the Label Request message and drop the Label\n   Request message.\n"
- title: 2.8.2. Label Mapping Message
  contents:
  - "2.8.2. Label Mapping Message\n   The use of the Path Vector TLV and Hop Count\
    \ TLV in the Label Mapping\n   message provide a mechanism to find and terminate\
    \ looping LSPs.  When\n   an LSR receives a Label Mapping message from a next\
    \ hop, the message\n   is propagated upstream as specified below until an ingress\
    \ LSR is\n   reached or a loop is found.\n   The rules that govern the use of\
    \ the Hop Count TLV in Label Mapping\n   messages sent by an LSR R when Loop Detection\
    \ is enabled are the\n   following:\n   -  R MUST include a Hop Count TLV.\n \
    \  -  If R is the egress, the hop count value MUST be 1.\n   -  If the Label Mapping\
    \ message is being sent to propagate a Label\n      Mapping message received from\
    \ the next hop to an upstream peer,\n      the hop count value MUST be determined\
    \ as follows:\n      o  If R is a member of the edge set of an LSR domain whose\
    \ LSRs do\n         not perform 'TTL-decrement' (e.g., an ATM LSR domain or a\
    \ Frame\n         Relay LSR domain) and the upstream peer is within that domain,\n\
    \         R MUST reset the hop count to 1 before propagating the message.\n  \
    \    o  Otherwise, R MUST increment the hop count received from the\n        \
    \ next hop before propagating the message.\n   -  If the Label Mapping message\
    \ is not being sent to propagate a\n      Label Mapping message, the hop count\
    \ value MUST be the result of\n      incrementing R's current knowledge of the\
    \ hop count learned from\n      previous Label Mapping messages.  Note that this\
    \ hop count value\n      will be unknown if R has not received a Label Mapping\
    \ message from\n      the next hop.\n   Any Label Mapping message MAY contain\
    \ a Path Vector TLV.  The rules\n   that govern the mandatory use of the Path\
    \ Vector TLV in Label Mapping\n   messages sent by LSR R when Loop Detection is\
    \ enabled are the\n   following:\n   -  If R is the egress, the Label Mapping\
    \ message need not include a\n      Path Vector TLV.\n   -  If R is sending the\
    \ Label Mapping message to propagate a Label\n      Mapping message received from\
    \ the next hop to an upstream peer,\n      then:\n      o  If R is merge capable\
    \ and if R has not previously sent a Label\n         Mapping message to the upstream\
    \ peer, then it MUST include a\n         Path Vector TLV.\n      o  If the received\
    \ message contains an unknown hop count, then R\n         MUST include a Path\
    \ Vector TLV.\n      o  If R has previously sent a Label Mapping message to the\n\
    \         upstream peer, then it MUST include a Path Vector TLV if the\n     \
    \    received message reports an LSP hop count increase, a change in\n       \
    \  hop count from unknown to known, or a change from known to\n         unknown.\n\
    \      If the above rules require R include a Path Vector TLV in the\n      Label\
    \ Mapping message, R computes it as follows:\n      o  If the received Label Mapping\
    \ message included a Path Vector,\n         the Path Vector sent upstream MUST\
    \ be the result of adding R's\n         LSR Id to the received Path Vector.\n\
    \      o  If the received message had no Path Vector, the Path Vector\n      \
    \   sent upstream MUST be a path vector of length 1 containing R's\n         LSR\
    \ Id.\n   -  If the Label Mapping message is not being sent to propagate a\n \
    \     received message upstream, the Label Mapping message MUST include\n    \
    \  a Path Vector of length 1 containing R's LSR Id.\n   If R receives a Label\
    \ Mapping message from its next hop with a Hop\n   Count TLV which exceeds the\
    \ configured maximum value, or with a Path\n   Vector TLV containing its own LSR\
    \ Id or which exceeds the maximum\n   allowable length, then R detects that the\
    \ corresponding LSP contains\n   a loop.\n   When R detects a loop, it MUST stop\
    \ using the label for forwarding,\n   drop the Label Mapping message, and signal\
    \ Loop Detected status to\n   the source of the Label Mapping message.\n"
- title: 2.8.3. Discussion
  contents:
  - "2.8.3. Discussion\n   If loop detection is desired in an MPLS domain, then it\
    \ should be\n   turned on in ALL LSRs within that MPLS domain, else loop detection\n\
    \   will not operate properly and may result in undetected loops or in\n   falsely\
    \ detected loops.\n   LSRs which are configured for loop detection are NOT expected\
    \ to\n   store the path vectors as part of the LSP state.\n   Note that in a network\
    \ where only non-merge capable LSRs are present,\n   Path Vectors are passed downstream\
    \ from ingress to egress, and are\n   not passed upstream.  Even when merge is\
    \ supported, Path Vectors need\n   not be passed upstream along an LSP which is\
    \ known to reach the\n   egress.  When an LSR experiences a change of next hop,\
    \ it need pass\n   Path Vectors upstream only when it cannot tell from the hop\
    \ count\n   that the change of next hop does not result in a loop.\n   In the\
    \ case of ordered label distribution, Label Mapping messages are\n   propagated\
    \ from egress toward ingress, naturally creating the Path\n   Vector along the\
    \ way.  In the case of independent label distribution,\n   an LSR may originate\
    \ a Label Mapping message for an FEC before\n   receiving a Label Mapping message\
    \ from its downstream peer for that\n   FEC.  In this case, the subsequent Label\
    \ Mapping message for the FEC\n   received from the downstream peer is treated\
    \ as an update to LSP\n   attributes, and the Label Mapping message must be propagated\n\
    \   upstream.  Thus, it is recommended that loop detection be configured\n   in\
    \ conjunction with ordered label distribution, to minimize the\n   number of Label\
    \ Mapping update messages.\n"
- title: 2.9. Authenticity and Integrity of LDP Messages
  contents:
  - "2.9. Authenticity and Integrity of LDP Messages\n   This section specifies a\
    \ mechanism to protect against the\n   introduction of spoofed TCP segments into\
    \ LDP session connection\n   streams.  The use of this mechanism MUST be supported\
    \ as a\n   configurable option.\n   The mechanism is based on use of the TCP MD5\
    \ Signature Option\n   specified in [RFC2385] for use by BGP.  See [RFC1321] for\
    \ a\n   specification of the MD5 hash function.\n"
- title: 2.9.1. TCP MD5 Signature Option
  contents:
  - "2.9.1. TCP MD5 Signature Option\n   The following quotes from [RFC2385] outline\
    \ the security properties\n   achieved by using the TCP MD5 Signature Option and\
    \ summarizes its\n   operation:\n      \"IESG Note\n         This document describes\
    \ current existing practice for securing\n         BGP against certain simple\
    \ attacks.  It is understood to have\n         security weaknesses against concerted\
    \ attacks.\"\n      \"Abstract\n         This memo describes a TCP extension to\
    \ enhance security for\n         BGP.  It defines a new TCP option for carrying\
    \ an MD5 [RFC1321]\n         digest in a TCP segment.  This digest acts like a\
    \ signature for\n         that segment, incorporating information known only to\
    \ the\n         connection end points.  Since BGP uses TCP as its transport,\n\
    \         using this option in the way described in this paper\n         significantly\
    \ reduces the danger from certain security attacks\n         on BGP.\"\n     \
    \ \"Introduction\n         The primary motivation for this option is to allow\
    \ BGP to\n         protect itself against the introduction of spoofed TCP segments\n\
    \         into the connection stream.  Of particular concern are TCP\n       \
    \  resets.\n         To spoof a connection using the scheme described in this\
    \ paper,\n         an attacker would not only have to guess TCP sequence numbers,\n\
    \         but would also have had to obtain the password included in the\n   \
    \      MD5 digest.  This password never appears in the connection\n         stream,\
    \ and the actual form of the password is up to the\n         application.  It\
    \ could even change during the lifetime of a\n         particular connection so\
    \ long as this change was synchronized\n         on both ends (although retransmission\
    \ can become problematical\n         in some TCP implementations with changing\
    \ passwords).\n         Finally, there is no negotiation for the use of this option\
    \ in\n         a connection, rather it is purely a matter of site policy\n   \
    \      whether or not its connections use the option.\"\n      \"MD5 as a Hashing\
    \ Algorithm\n         Since this memo was first issued (under a different title),\
    \ the\n         MD5 algorithm has been found to be vulnerable to collision\n \
    \        search attacks [Dobb], and is considered by some to be\n         insufficiently\
    \ strong for this type of application.\n         This memo still specifies the\
    \ MD5 algorithm, however, since the\n         option has already been deployed\
    \ operationally, and there was\n         no \"algorithm type\" field defined to\
    \ allow an upgrade using the\n         same option number.  The original document\
    \ did not specify a\n         type field since this would require at least one\
    \ more byte, and\n         it was felt at the time that taking 19 bytes for the\
    \ complete\n         option (which would probably be padded to 20 bytes in TCP\n\
    \         implementations) would be too much of a waste of the already\n     \
    \    limited option space.\n         This does not prevent the deployment of another\
    \ similar option\n         which uses another hashing algorithm (like SHA-1).\
    \  Also, if\n         most implementations pad the 18 byte option as defined to\
    \ 20\n         bytes anyway, it would be just as well to define a new option\n\
    \         which contains an algorithm type field.\n         This would need to\
    \ be addressed in another document, however.\"\n   End of quotes from [RFC2385].\n"
- title: 2.9.2. LDP Use of TCP MD5 Signature Option
  contents:
  - "2.9.2. LDP Use of TCP MD5 Signature Option\n   LDP uses the TCP MD5 Signature\
    \ Option as follows:\n      -  Use of the MD5 Signature Option for LDP TCP connections\
    \ is a\n         configurable LSR option.\n      -  An LSR that uses the MD5 Signature\
    \ Option is configured with a\n         password (shared secret) for each potential\
    \ LDP peer.\n      -  The LSR applies the MD5 algorithm as specified in [RFC2385]\
    \ to\n         compute the MD5 digest for a TCP segment to be sent to a peer.\n\
    \         This computation makes use of the peer password as well as the\n   \
    \      TCP segment.\n      -  When the LSR receives a TCP segment with an MD5\
    \ digest, it\n         validates the segment by calculating the MD5 digest (using\
    \ its\n         own record of the password) and compares the computed digest\n\
    \         with the received digest.  If the comparison fails, the segment\n  \
    \       is dropped without any response to the sender.\n      -  The LSR ignores\
    \ LDP Hellos from any LSR for which a password\n         has not been configured.\
    \  This ensures that the LSR establishes\n         LDP TCP connections only with\
    \ LSRs for which a password has\n         been configured.\n"
- title: 2.10. Label Distribution for Explicitly Routed LSPs
  contents:
  - "2.10. Label Distribution for Explicitly Routed LSPs\n   Traffic Engineering [RFC2702]\
    \ is expected to be an important MPLS\n   application.  MPLS support for Traffic\
    \ Engineering uses explicitly\n   routed LSPs, which need not follow normally-routed\
    \ (hop-by-hop) paths\n   as determined by destination-based routing protocols.\
    \  CR-LDP [CRLDP]\n   defines extensions to LDP to use LDP to set up explicitly\
    \ routed\n   LSPs.\n"
- title: 3. Protocol Specification
  contents:
  - "3. Protocol Specification\n   Previous sections that describe LDP operation have\
    \ discussed\n   scenarios that involve the exchange of messages among LDP peers.\n\
    \   This section specifies the message encodings and procedures for\n   processing\
    \ the messages.\n   LDP message exchanges are accomplished by sending LDP protocol\
    \ data\n   units (PDUs) over LDP session TCP connections.\n   Each LDP PDU can\
    \ carry one or more LDP messages.  Note that the\n   messages in an LDP PDU need\
    \ not be related to one another.  For\n   example, a single PDU could carry a\
    \ message advertising FEC-label\n   bindings for several FECs, another message\
    \ requesting label bindings\n   for several other FECs, and a third notification\
    \ message signaling\n   some event.\n"
- title: 3.1. LDP PDUs
  contents:
  - "3.1. LDP PDUs\n   Each LDP PDU is an LDP header followed by one or more LDP messages.\n\
    \   The LDP header is:\n    0                   1                   2        \
    \           3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Version                      |         PDU Length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         LDP Identifier                        |\n   +  \
    \                             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |        \
    \                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Version\n\
    \      Two octet unsigned integer containing the version number of the\n     \
    \ protocol.  This version of the specification specifies LDP protocol\n      version\
    \ 1.\n   PDU Length\n      Two octet integer specifying the total length of this\
    \ PDU in\n      octets, excluding the Version and PDU Length fields.\n      The\
    \ maximum allowable PDU Length is negotiable when an LDP session\n      is initialized.\
    \  Prior to completion of the negotiation the maximum\n      allowable length\
    \ is 4096 bytes.\n   LDP Identifier\n      Six octet field that uniquely identifies\
    \ the label space of the\n      sending LSR for which this PDU applies.  The first\
    \ four octets\n      identify the LSR and must be a globally unique value.  It\
    \ should be\n      a 32-bit router Id assigned to the LSR and also used to identify\
    \ it\n      in loop detection Path Vectors.  The last two octets identify a\n\
    \      label space within the LSR.  For a platform-wide label space, these\n \
    \     should both be zero.\n   Note that there is no alignment requirement for\
    \ the first octet of an\n   LDP PDU.\n"
- title: 3.2. LDP Procedures
  contents:
  - "3.2. LDP Procedures\n   LDP defines messages, TLVs and procedures in the following\
    \ areas:\n      -  Peer discovery;\n      -  Session management;\n      -  Label\
    \ distribution;\n      -  Notification of errors and advisory information.\n \
    \  The sections that follow describe the message and TLV encodings for\n   these\
    \ areas and the procedures that apply to them.\n   The label distribution procedures\
    \ are complex and are difficult to\n   describe fully, coherently and unambiguously\
    \ as a collection of\n   separate message and TLV specifications.\n   Appendix\
    \ A, \"LDP Label Distribution Procedures\", describes the label\n   distribution\
    \ procedures in terms of label distribution events that\n   may occur at an LSR\
    \ and how the LSR must respond.  Appendix A is the\n   specification of LDP label\
    \ distribution procedures.  If a procedure\n   described elsewhere in this document\
    \ conflicts with Appendix A,\n   Appendix A specifies LDP behavior.\n"
- title: 3.3. Type-Length-Value Encoding
  contents:
  - "3.3. Type-Length-Value Encoding\n   LDP uses a Type-Length-Value (TLV) encoding\
    \ scheme to encode much of\n   the information carried in LDP messages.\n   An\
    \ LDP TLV is encoded as a 2 octet field that uses 14 bits to specify\n   a Type\
    \ and 2 bits to specify behavior when an LSR doesn't recognize\n   the Type, followed\
    \ by a 2 octet Length Field, followed by a variable\n   length Value field.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |U|F|        Type               |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \                           Value                             |\n   ~        \
    \                                                       ~\n   |              \
    \                                                 |\n   |                    \
    \           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                          \
    \     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   U bit\n      Unknown TLV bit.\
    \  Upon receipt of an unknown TLV, if U is clear\n      (=0), a notification must\
    \ be returned to the message originator\n      and the entire message must be\
    \ ignored; if U is set (=1), the\n      unknown TLV is silently ignored and the\
    \ rest of the message is\n      processed as if the unknown TLV did not exist.\
    \  The sections\n      following that define TLVs specify a value for the U-bit.\n\
    \   F bit\n      Forward unknown TLV bit.  This bit applies only when the U bit\
    \ is\n      set and the LDP message containing the unknown TLV is to be\n    \
    \  forwarded.  If F is clear (=0), the unknown TLV is not forwarded\n      with\
    \ the containing message; if F is set (=1), the unknown TLV is\n      forwarded\
    \ with the containing message.  The sections following\n      that define TLVs\
    \ specify a value for the F-bit.\n   Type\n      Encodes how the Value field is\
    \ to be interpreted.\n   Length\n      Specifies the length of the Value field\
    \ in octets.\n   Value\n      Octet string of Length octets that encodes information\
    \ to be\n      interpreted as specified by the Type field.\n   Note that there\
    \ is no alignment requirement for the first octet of a\n   TLV.\n   Note that\
    \ the Value field itself may contain TLV encodings.  That is,\n   TLVs may be\
    \ nested.\n   The TLV encoding scheme is very general.  In principle, everything\n\
    \   appearing in an LDP PDU could be encoded as a TLV.  This\n   specification\
    \ does not use the TLV scheme to its full generality.  It\n   is not used where\
    \ its generality is unnecessary and its use would\n   waste space unnecessarily.\
    \  These are usually places where the type\n   of a value to be encoded is known,\
    \ for example by its position in a\n   message or an enclosing TLV, and the length\
    \ of the value is fixed or\n   readily derivable from the value encoding itself.\n\
    \   Some of the TLVs defined for LDP are similar to one another.  For\n   example,\
    \ there is a Generic Label TLV, an ATM Label TLV, and a Frame\n   Relay TLV; see\
    \ Sections \"Generic Label TLV\", \"ATM Label TLV\", and\n   \"Frame Relay TLV\"\
    .\n   While it is possible to think about TLVs related in this way in terms\n\
    \   of a TLV type that specifies a TLV class and a TLV subtype that\n   specifies\
    \ a particular kind of TLV within that class, this\n   specification does not\
    \ formalize the notion of a TLV subtype.\n   The specification assigns type values\
    \ for related TLVs, such as the\n   label TLVs, from a contiguous block in the\
    \ 16-bit TLV type number\n   space.\n   Section \"TLV Summary\" lists the TLVs\
    \ defined in this version of the\n   protocol and the section in this document\
    \ that describes each.\n"
- title: 3.4. TLV Encodings for Commonly Used Parameters
  contents:
  - "3.4. TLV Encodings for Commonly Used Parameters\n   There are several parameters\
    \ used by more than one LDP message.  The\n   TLV encodings for these commonly\
    \ used parameters are specified in\n   this section.\n"
- title: 3.4.1. FEC TLV
  contents:
  - "3.4.1. FEC TLV\n   Labels are bound to Forwarding Equivalence Classes (FECs).\
    \  A FEC is\n   a list of one or more FEC elements.  The FEC TLV encodes FEC items.\n\
    \   Its encoding is:\n    0                   1                   2          \
    \         3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ |0|0| FEC (0x0100)              |      Length                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        FEC Element 1                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                                                             ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        FEC Element n                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   FEC Element 1 to FEC Element n\n      There are several types of FEC elements;\
    \ see Section \"FECs\".  The\n      FEC element encoding depends on the type of\
    \ FEC element.\n      A FEC Element value is encoded as a 1 octet field that specifies\n\
    \      the element type, and a variable length field that is the type-\n     \
    \ dependent element value.  Note that while the representation of\n      the FEC\
    \ element value is type-dependent, the FEC element encoding\n      itself is one\
    \ where standard LDP TLV encoding is not used.\n      The FEC Element value encoding\
    \ is:\n         FEC Element       Type      Value\n         type name\n      \
    \     Wildcard        0x01      No value; i.e., 0 value octets;\n            \
    \                             see below.\n           Prefix          0x02    \
    \  See below.\n           Host Address    0x03      Full host address; see below.\n\
    \      Note that this version of LDP supports the use of multiple FEC\n      Elements\
    \ per FEC for the Label Mapping message only.  The use of\n      multiple FEC\
    \ Elements in other messages is not permitted in this\n      version, and is a\
    \ subject for future study.\n      Wildcard FEC Element\n         To be used only\
    \ in the Label Withdraw and Label Release\n         Messages.  Indicates the withdraw/release\
    \ is to be applied to\n         all FECs associated with the label within the\
    \ following label\n         TLV.  Must be the only FEC Element in the FEC TLV.\n\
    \      Prefix FEC Element value encoding:\n       0                   1      \
    \             2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  Prefix (2)   |     Address Family            |     PreLen    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                     Prefix                                    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Address Family\n         Two octet quantity containing a value from ADDRESS\
    \ FAMILY\n         NUMBERS in [RFC1700] that encodes the address family for the\n\
    \         address prefix in the Prefix field.\n      PreLen\n         One octet\
    \ unsigned integer containing the length in bits of the\n         address prefix\
    \ that follows.  A length of zero indicates a\n         prefix that matches all\
    \ addresses (the default destination); in\n         this case the Prefix itself\
    \ is zero octets).\n      Prefix\n         An address prefix encoded according\
    \ to the Address Family\n         field, whose length, in bits, was specified\
    \ in the PreLen\n         field, padded to a byte boundary.\n      Host Address\
    \ FEC Element encoding:\n       0                   1                   2    \
    \               3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Host Addr (3) |     Address Family            | Host Addr Len |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \                  Host Addr                                 |\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Address Family\n         Two octet quantity containing a value from ADDRESS\
    \ FAMILY\n         NUMBERS in [RFC1700] that encodes the address family for the\n\
    \         address prefix in the Prefix field.\n      Host Addr Len\n         Length\
    \ of the Host address in octets.\n      Host Addr\n         An address encoded\
    \ according to the Address Family field.\n"
- title: 3.4.1.1. FEC Procedures
  contents:
  - "3.4.1.1. FEC Procedures\n   If in decoding a FEC TLV an LSR encounters a FEC\
    \ Element with an\n   Address Family it does not support, it should stop decoding\
    \ the FEC\n   TLV, abort processing the message containing the TLV, and send an\n\
    \   \"Unsupported Address Family\" Notification message to its LDP peer\n   signaling\
    \ an error.\n   If it encounters a FEC Element type it cannot decode, it should\
    \ stop\n   decoding the FEC TLV, abort processing the message containing the\n\
    \   TLV, and send an \"Unknown FEC\" Notification message to its LDP peer\n  \
    \ signaling an error.\n"
- title: 3.4.2. Label TLVs
  contents:
  - "3.4.2. Label TLVs\n   Label TLVs encode labels.  Label TLVs are carried by the\
    \ messages\n   used to advertise, request, release and withdraw label mappings.\n\
    \   There are several different kinds of Label TLVs which can appear in\n   situations\
    \ that require a Label TLV.\n"
- title: 3.4.2.1. Generic Label TLV
  contents:
  - "3.4.2.1. Generic Label TLV\n   An LSR uses Generic Label TLVs to encode labels\
    \ for use on links for\n   which label values are independent of the underlying\
    \ link technology.\n   Examples of such links are PPP and Ethernet.\n    0   \
    \                1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|0| Generic Label (0x0200)    |      Length                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Label                                                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Label\n      This is a 20-bit label value as specified in [RFC3032] represented\n\
    \      as a 20-bit number in a 4 octet field.\n"
- title: 3.4.2.2. ATM Label TLV
  contents:
  - "3.4.2.2. ATM Label TLV\n   An LSR uses ATM Label TLVs to encode labels for use\
    \ on ATM links.\n    0                   1                   2               \
    \    3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |0|0|\
    \ ATM Label (0x0201)        |         Length                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Res| V |          VPI          |         VCI                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Res\n      This field is reserved.  It must be set to zero on transmission\n\
    \      and must be ignored on receipt.\n   V-bits\n      Two-bit switching indicator.\
    \  If V-bits is 00, both the VPI and\n      VCI are significant.  If V-bits is\
    \ 01, only the VPI field is\n      significant.  If V-bit is 10, only the VCI\
    \ is significant.\n   VPI\n      Virtual Path Identifier.  If VPI is less than\
    \ 12-bits it should be\n      right justified in this field and preceding bits\
    \ should be set to\n      0.\n   VCI\n      Virtual Channel Identifier.  If the\
    \ VCI is less than 16- bits, it\n      should be right justified in the field\
    \ and the preceding bits must\n      be set to 0.  If Virtual Path switching is\
    \ indicated in the V-bits\n      field, then this field must be ignored by the\
    \ receiver and set to\n      0 by the sender.\n"
- title: 3.4.2.3. Frame Relay Label TLV
  contents:
  - "3.4.2.3. Frame Relay Label TLV\n   An LSR uses Frame Relay Label TLVs to encode\
    \ labels for use on Frame\n   Relay links.\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|0| Frame Relay Label (0x0202)|       Length                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Reserved    |Len|                     DLCI                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Res\n      This field is reserved.  It must be set to zero on transmission\n\
    \      and must be ignored on receipt.\n   Len\n      This field specifies the\
    \ number of bits of the DLCI.  The\n      following values are supported:\n  \
    \       0 = 10 bits DLCI\n         2 = 23 bits DLCI\n      Len values 1 and 3\
    \ are reserved.\n   DLCI\n      The Data Link Connection Identifier.  Refer to\
    \ [RFC3034] for the\n      label values and formats.\n"
- title: 3.4.3. Address List TLV
  contents:
  - "3.4.3. Address List TLV\n   The Address List TLV appears in Address and Address\
    \ Withdraw\n   messages.\n   Its encoding is:\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|0| Address List (0x0101)     |      Length                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Address Family            |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n   |                                      \
    \                         |\n   |                        Addresses           \
    \                   |\n   ~                                                  \
    \             ~\n   |                                                        \
    \       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Address Family\n      Two octet quantity containing a value from ADDRESS FAMILY\
    \ NUMBERS\n      in [RFC1700] that encodes the addresses contained in the Addresses\n\
    \      field.\n   Addresses\n      A list of addresses from the specified Address\
    \ Family.  The\n      encoding of the individual addresses depends on the Address\
    \ Family.\n      The following address encodings are defined by this version of\
    \ the\n      protocol:\n         Address Family      Address Encoding\n      \
    \   IPv4                4 octet full IPv4 address\n         IPv6             \
    \   16 octet full IPv6 address\n"
- title: 3.4.4. Hop Count TLV
  contents:
  - "3.4.4. Hop Count TLV\n   The Hop Count TLV appears as an optional field in messages\
    \ that set\n   up LSPs.  It calculates the number of LSR hops along an LSP as\
    \ the\n   LSP is being setup.\n   Note that setup procedures for LSPs that traverse\
    \ ATM and Frame Relay\n   links require use of the Hop Count TLV (see [RFC3035]\
    \ and [RFC3034]).\n    0                   1                   2             \
    \      3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |0|0|\
    \ Hop Count (0x0103)        |      Length                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     HC Value  |\n   +-+-+-+-+-+-+-+-+\n   HC Value\n      1 octet unsigned\
    \ integer hop count value.\n"
- title: 3.4.4.1. Hop Count Procedures
  contents:
  - "3.4.4.1. Hop Count Procedures\n   During setup of an LSP an LSR R may receive\
    \ a Label Mapping or Label\n   Request message for the LSP that contains the Hop\
    \ Count TLV.  If it\n   does, it should record the hop count value.\n   If LSR\
    \ R then propagates the Label Mapping message for the LSP to an\n   upstream peer\
    \ or the Label Request message to a downstream peer to\n   continue the LSP setup,\
    \ it must must determine a hop count to include\n   in the propagated message\
    \ as follows:\n   -  If the message is a Label Request message, R must increment\
    \ the\n      received hop count;\n   -  If the message is a Label Mapping message,\
    \ R determines the hop\n      count as follows:\n      o  If R is a member of\
    \ the edge set of an LSR domain whose LSRs do\n         not perform 'TTL-decrement'\
    \ and the upstream peer is within\n         that domain, R must reset the hop\
    \ count to 1 before propagating\n         the message.\n      o  Otherwise, R\
    \ must increment the received hop count.\n   The first LSR in the LSP (ingress\
    \ for a Label Request message, egress\n   for a Label Mapping message) should\
    \ set the hop count value to 1.\n   By convention a value of 0 indicates an unknown\
    \ hop count.  The\n   result of incrementing an unknown hop count is itself an\
    \ unknown hop\n   count (0).\n   Use of the unknown hop count value greatly reduces\
    \ the signaling\n   overhead when independent control is used.  When a new LSP\
    \ is\n   established, each LSR starts with unknown hop count.  Addition of a\n\
    \   new LSR whose hop count is also unknown does not cause a hop count\n   update\
    \ to be propagated upstream since the hop count remains unknown.\n   When the\
    \ egress is finally added to the LSP, then the LSRs propagate\n   hop count updates\
    \ upstream via Label Mapping messages.\n   Without use of the unknown hop count,\
    \ each time a new LSR is added to\n   the LSP a hop count update would need to\
    \ be propagated upstream if\n   the new LSR is closer to the egress than any of\
    \ the other LSRs.\n   These updates are useless overhead since they don't reflect\
    \ the hop\n   count to the egress.\n   From the perspective of the ingress node,\
    \ the fact that the hop count\n   is unknown implies nothing about whether a packet\
    \ sent on the LSP\n   will actually make it to the egress.  All it implies is\
    \ that the hop\n   count update from the egress has not yet reached the ingress.\n\
    \   If an LSR receives a message containing a Hop Count TLV, it must\n   check\
    \ the hop count value to determine whether the hop count has\n   exceeded its\
    \ configured maximum allowable value.  If so, it must\n   behave as if the containing\
    \ message has traversed a loop by sending a\n   Notification message signaling\
    \ Loop Detected in reply to the sender\n   of the message.\n   If Loop Detection\
    \ is configured, the LSR must follow the procedures\n   specified in Section \"\
    Loop Detection\".\n"
- title: 3.4.5. Path Vector TLV
  contents:
  - "3.4.5. Path Vector TLV\n   The Path Vector TLV is used with the Hop Count TLV\
    \ in Label Request\n   and Label Mapping messages to implement the optional LDP\
    \ loop\n   detection mechanism.  See Section \"Loop Detection\".  Its use in the\n\
    \   Label Request message records the path of LSRs the request has\n   traversed.\
    \  Its use in the Label Mapping message records the path of\n   LSRs a label advertisement\
    \ has traversed to setup an LSP.\n   Its encoding is:\n    0                 \
    \  1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|0| Path Vector (0x0104)      |        Length                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            LSR Id 1                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                                                             ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            LSR Id n                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   One or more LSR Ids\n      A list of router-ids indicating the path of LSRs\
    \ the message has\n      traversed.  Each LSR Id is the first four octets (router-id)\
    \ of\n      the LDP identifier for the corresponding LSR.  This ensures it is\n\
    \      unique within the LSR network.\n"
- title: 3.4.5.1. Path Vector Procedures
  contents:
  - "3.4.5.1. Path Vector Procedures\n   The Path Vector TLV is carried in Label Mapping\
    \ and Label Request\n   messages when loop detection is configured.\n"
- title: 3.4.5.1.1. Label Request Path Vector
  contents:
  - "3.4.5.1.1. Label Request Path Vector\n   Section \"Loop Detection\" specifies\
    \ situations when an LSR must\n   include a Path Vector TLV in a Label Request\
    \ message.\n   An LSR that receives a Path Vector in a Label Request message must\n\
    \   perform the procedures described in Section \"Loop Detection\".\n   If the\
    \ LSR detects a loop, it must reject the Label Request message.\n   The LSR must:\n\
    \      1. Transmit a Notification message to the sending LSR signaling\n     \
    \    \"Loop Detected\".\n      2. Not propagate the Label Request message further.\n\
    \   Note that a Label Request message with Path Vector TLV is forwarded\n   until:\n\
    \      1. A loop is found,\n      2. The LSP egress is reached,\n      3. The\
    \ maximum Path Vector limit or maximum Hop Count limit is\n         reached. \
    \ This is treated as if a loop had been detected.\n"
- title: 3.4.5.1.2. Label Mapping Path Vector
  contents:
  - "3.4.5.1.2. Label Mapping Path Vector\n   Section \"Loop Detection\" specifies\
    \ the situations when an LSR must\n   include a Path Vector TLV in a Label Mapping\
    \ message.\n   An LSR that receives a Path Vector in a Label Mapping message must\n\
    \   perform the procedures described in Section \"Loop Detection\".\n   If the\
    \ LSR detects a loop, it must reject the Label Mapping message\n   in order to\
    \ prevent a forwarding loop.  The LSR must:\n      1. Transmit a Label Release\
    \ message carrying a Status TLV to the\n         sending LSR to signal \"Loop\
    \ Detected\".\n      2. Not propagate the message further.\n      3. Check whether\
    \ the Label Mapping message is for an existing LSP.\n         If so, the LSR must\
    \ unsplice any upstream labels which are\n         spliced to the downstream label\
    \ for the FEC.\n   Note that a Label Mapping message with a Path Vector TLV is\
    \ forwarded\n   until:\n      1. A loop is found,\n      2. An LSP ingress is\
    \ reached, or\n      3. The maximum Path Vector or maximum Hop Count limit is\
    \ reached.\n         This is treated as if a loop had been detected.\n"
- title: 3.4.6. Status TLV
  contents:
  - "3.4.6. Status TLV\n   Notification messages carry Status TLVs to specify events\
    \ being\n   signaled.\n   The encoding for the Status TLV is:\n    0         \
    \          1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |U|F| Status (0x0300)           |      Length                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Status Code                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Message Type             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   U bit\n      Should be 0 when the Status TLV is sent in a Notification message.\n\
    \      Should be 1 when the Status TLV is sent in some other message.\n   F bit\n\
    \      Should be the same as the setting of the F-bit in the Status Code\n   \
    \   field.\n   Status Code\n      32-bit unsigned integer encoding the event being\
    \ signaled.  The\n      structure of a Status Code is:\n       0             \
    \      1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |E|F|                 Status Data                               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      E\
    \ bit\n         Fatal error bit.  If set (=1), this is a fatal error\n       \
    \  notification.  If clear (=0), this is an advisory notification.\n      F bit\n\
    \         Forward bit.  If set (=1), the notification should be forwarded\n  \
    \       to the LSR for the next-hop or previous-hop for the LSP, if\n        \
    \ any, associated with the event being signaled.  If clear (=0),\n         the\
    \ notification should not be forwarded.\n      Status Data\n         30-bit unsigned\
    \ integer which specifies the status information.\n      This specification defines\
    \ Status Codes (32-bit unsigned integers\n      with the above encoding).\n  \
    \    A Status Code of 0 signals success.\n   Message ID\n      If non-zero, 32-bit\
    \ value that identifies the peer message to\n      which the Status TLV refers.\
    \  If zero, no specific peer message is\n      being identified.\n   Message Type\n\
    \      If non-zero, the type of the peer message to which the Status TLV\n   \
    \   refers.  If zero, the Status TLV does not refer to any specific\n      message\
    \ type.\n   Note that use of the Status TLV is not limited to Notification\n \
    \  messages.  A message other than a Notification message may carry a\n   Status\
    \ TLV as an Optional Parameter.  When a message other than a\n   Notification\
    \ carries a Status TLV the U-bit of the Status TLV should\n   be set to 1 to indicate\
    \ that the receiver should silently discard the\n   TLV if unprepared to handle\
    \ it.\n"
- title: 3.5. LDP Messages
  contents:
  - "3.5. LDP Messages\n   All LDP messages have the following format:\n    0    \
    \               1                   2                   3\n    0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |U|   Message Type              |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \             Mandatory Parameters                      |\n   +              \
    \                                                 +\n   |                    \
    \                                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \             Optional Parameters                       |\n   +              \
    \                                                 +\n   |                    \
    \                                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   U bit\n      Unknown message bit.  Upon receipt of an unknown message, if\
    \ U is\n      clear (=0), a notification is returned to the message originator;\n\
    \      if U is set (=1), the unknown message is silently ignored.  The\n     \
    \ sections following that define messages specify a value for the\n      U-bit.\n\
    \   Message Type\n      Identifies the type of message\n   Message Length\n  \
    \    Specifies the cumulative length in octets of the Message ID,\n      Mandatory\
    \ Parameters, and Optional Parameters.\n   Message ID\n      32-bit value used\
    \ to identify this message.  Used by the sending\n      LSR to facilitate identifying\
    \ notification messages that may apply\n      to this message.  An LSR sending\
    \ a notification message in\n      response to this message should include this\
    \ Message Id in the\n      Status TLV carried by the notification message; see\
    \ Section\n      \"Notification Message\".\n   Mandatory Parameters\n      Variable\
    \ length set of required message parameters.  Some messages\n      have no required\
    \ parameters.\n      For messages that have required parameters, the required\n\
    \      parameters MUST appear in the order specified by the individual\n     \
    \ message specifications in the sections that follow.\n   Optional Parameters\n\
    \      Variable length set of optional message parameters.  Many messages\n  \
    \    have no optional parameters.\n      For messages that have optional parameters,\
    \ the optional\n      parameters may appear in any order.\n   Note that there\
    \ is no alignment requirement for the first octet of an\n   LDP message.\n   The\
    \ following message types are defined in this version of LDP:\n      Message Name\
    \            Section Title\n      Notification            \"Notification Message\"\
    \n      Hello                   \"Hello Message\"\n      Initialization      \
    \    \"Initialization Message\"\n      KeepAlive               \"KeepAlive Message\"\
    \n      Address                 \"Address Message\"\n      Address Withdraw  \
    \      \"Address Withdraw Message\"\n      Label Mapping           \"Label Mapping\
    \ Message\"\n      Label Request           \"Label Request Message\"\n      Label\
    \ Abort Request     \"Label Abort Request Message\"\n      Label Withdraw    \
    \      \"Label Withdraw Message\"\n      Label Release           \"Label Release\
    \ Message\"\n   The sections that follow specify the encodings and procedures\
    \ for\n   these messages.\n   Some of the above messages are related to one another,\
    \ for example\n   the Label Mapping, Label Request, Label Withdraw, and Label\
    \ Release\n   messages.\n   While it is possible to think about messages related\
    \ in this way in\n   terms of a message type that specifies a message class and\
    \ a message\n   subtype that specifies a particular kind of message within that\n\
    \   class, this specification does not formalize the notion of a message\n   subtype.\n\
    \   The specification assigns type values for related messages, such as\n   the\
    \ label messages, from of a contiguous block in the 16-bit message\n   type number\
    \ space.\n"
- title: 3.5.1. Notification Message
  contents:
  - "3.5.1. Notification Message\n   An LSR sends a Notification message to inform\
    \ an LDP peer of a\n   significant event.  A Notification message signals a fatal\
    \ error or\n   provides advisory information such as the outcome of processing\
    \ an\n   LDP message or the state of the LDP session.\n   The encoding for the\
    \ Notification Message is:\n    0                   1                   2    \
    \               3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Notification (0x0001)     |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Status (TLV)                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   Status TLV\n\
    \      Indicates the event being signaled.  The encoding for the Status\n    \
    \  TLV is specified in Section \"Status TLV\".\n   Optional Parameters\n     \
    \ This variable length field contains 0 or more parameters, each\n      encoded\
    \ as a TLV.  The following Optional Parameters are generic\n      and may appear\
    \ in any Notification Message:\n         Optional Parameter     Type     Length\
    \  Value\n         Extended Status        0x0301    4      See below\n       \
    \  Returned PDU           0x0302    var    See below\n         Returned Message\
    \       0x0303    var    See below\n      Other Optional Parameters, specific\
    \ to the particular event being\n      signaled by the Notification Messages may\
    \ appear.  These are\n      described elsewhere.\n      Extended Status\n    \
    \     The 4 octet value is an Extended Status Code that encodes\n         additional\
    \ information that supplements the status information\n         contained in the\
    \ Notification Status Code.\n      Returned PDU\n         An LSR uses this parameter\
    \ to return part of an LDP PDU to the\n         LSR that sent it.  The value of\
    \ this TLV is the PDU header and\n         as much PDU data following the header\
    \ as appropriate for the\n         condition being signaled by the Notification\
    \ message.\n      Returned Message\n         An LSR uses this parameter to return\
    \ part of an LDP message to\n         the LSR that sent it.  The value of this\
    \ TLV is the message\n         type and length fields and as much message data\
    \ following the\n         type and length fields as appropriate for the condition\
    \ being\n         signaled by the Notification message.\n"
- title: 3.5.1.1. Notification Message Procedures
  contents:
  - "3.5.1.1. Notification Message Procedures\n   If an LSR encounters a condition\
    \ requiring it to notify its peer with\n   advisory or error information it sends\
    \ the peer a Notification\n   message containing a Status TLV that encodes the\
    \ information and\n   optionally additional TLVs that provide more information\
    \ about the\n   condition.\n   If the condition is one that is a fatal error the\
    \ Status Code carried\n   in the notification will indicate that.  In this case,\
    \ after sending\n   the Notification message the LSR should terminate the LDP\
    \ session by\n   closing the session TCP connection and discard all state associated\n\
    \   with the session, including all label-FEC bindings learned via the\n   session.\n\
    \   When an LSR receives a Notification message that carries a Status\n   Code\
    \ that indicates a fatal error, it should terminate the LDP\n   session immediately\
    \ by closing the session TCP connection and discard\n   all state associated with\
    \ the session, including all label-FEC\n   bindings learned via the session.\n"
- title: 3.5.1.2. Events Signaled by Notification Messages
  contents:
  - "3.5.1.2. Events Signaled by Notification Messages\n   It is useful for descriptive\
    \ purpose to classify events signaled by\n   Notification Messages into the following\
    \ categories.\n"
- title: 3.5.1.2.1. Malformed PDU or Message
  contents:
  - "3.5.1.2.1. Malformed PDU or Message\n   Malformed LDP PDUs or Messages that are\
    \ part of the LDP Discovery\n   mechanism are handled by silently discarding them.\n\
    \   An LDP PDU received on a TCP connection for an LDP session is\n   malformed\
    \ if:\n      -  The LDP Identifier in the PDU header is unknown to the\n     \
    \    receiver, or it is known but is not the LDP Identifier\n         associated\
    \ by the receiver with the LDP peer for this LDP\n         session.  This is a\
    \ fatal error signaled by the Bad LDP\n         Identifier Status Code.\n    \
    \  -  The LDP protocol version is not supported by the receiver, or\n        \
    \ it is supported but is not the version negotiated for the\n         session\
    \ during session establishment.  This is a fatal error\n         signaled by the\
    \ Bad Protocol Version Status Code.\n      -  The PDU Length field is too small\
    \ (< 14) or too large\n         (> maximum PDU length).  This is a fatal error\
    \ signaled by the\n         Bad PDU Length Status Code.  Section \"Initialization\
    \ Message\"\n         describes how the maximum PDU length for a session is\n\
    \         determined.\n   An LDP Message is malformed if:\n      -  The Message\
    \ Type is unknown.\n         If the Message Type is < 0x8000 (high order bit =\
    \ 0) it is an\n         error signaled by the Unknown Message Type Status Code.\n\
    \         If the Message Type is >= 0x8000 (high order bit = 1) it is\n      \
    \   silently discarded.\n      -  The Message Length is too large, that is, indicates\
    \ that the\n         message extends beyond the end of the containing LDP PDU.\
    \  This\n         is a fatal error signaled by the Bad Message Length Status\n\
    \         Code.\n      -  The message is missing one or more Mandatory Parameters.\
    \  This\n         is a non-fatal error signalled by the Missing Message\n    \
    \     Parameters Status Code.\n"
- title: 3.5.1.2.2. Unknown or Malformed TLV
  contents:
  - "3.5.1.2.2. Unknown or Malformed TLV\n   Malformed TLVs contained in LDP messages\
    \ that are part of the LDP\n   Discovery mechanism are handled by silently discarding\
    \ the containing\n   message.\n   A TLV contained in an LDP message received on\
    \ a TCP connection of an\n   LDP is malformed if:\n      -  The TLV Length is\
    \ too large, that is, indicates that the TLV\n         extends beyond the end\
    \ of the containing message.  This is a\n         fatal error signaled by the\
    \ Bad TLV Length Status Code.\n      -  The TLV type is unknown.\n         If\
    \ the TLV type is < 0x8000 (high order bit 0) it is an error\n         signaled\
    \ by the Unknown TLV Status Code.\n         If the TLV type is >= 0x8000 (high\
    \ order bit 1) the TLV is\n         silently dropped.  Section \"Unknown TLV in\
    \ Known Message Type\"\n         elaborates on this behavior.\n      -  The TLV\
    \ Value is malformed.  This occurs when the receiver\n         handles the TLV\
    \ but cannot decode the TLV Value.  This is\n         interpreted as indicative\
    \ of a bug in either the sending or\n         receiving LSR.  It is a fatal error\
    \ signaled by the Malformed\n         TLV Value Status Code.\n"
- title: 3.5.1.2.3. Session KeepAlive Timer Expiration
  contents:
  - "3.5.1.2.3. Session KeepAlive Timer Expiration\n   This is a fatal error signaled\
    \ by the KeepAlive Timer Expired Status\n   Code.\n"
- title: 3.5.1.2.4. Unilateral Session Shutdown
  contents:
  - "3.5.1.2.4. Unilateral Session Shutdown\n   This is a fatal event signaled by\
    \ the Shutdown Status Code.  The\n   Notification Message may optionally include\
    \ an Extended Status TLV to\n   provide a reason for the Shutdown.  The sending\
    \ LSR terminates the\n   session immediately after sending the Notification.\n"
- title: 3.5.1.2.5. Initialization Message Events
  contents:
  - "3.5.1.2.5. Initialization Message Events\n   The session initialization negotiation\
    \ (see Section \"Session\n   Initialization\") may fail if the session parameters\
    \ received in the\n   Initialization Message are unacceptable.  This is a fatal\
    \ error.  The\n   specific Status Code depends on the parameter deemed unacceptable,\n\
    \   and is defined in Sections \"Initialization Message\".\n"
- title: 3.5.1.2.6. Events Resulting From Other Messages
  contents:
  - "3.5.1.2.6. Events Resulting From Other Messages\n   Messages other than the Initialization\
    \ message may result in events\n   that must be signaled to LDP peers via Notification\
    \ Messages.  These\n   events and the Status Codes used in the Notification Messages\
    \ to\n   signal them are described in the sections that describe these\n   messages.\n"
- title: 3.5.1.2.7. Internal Errors
  contents:
  - "3.5.1.2.7. Internal Errors\n   An LDP implementation may be capable of detecting\
    \ problem conditions\n   specific to its implementation.  When such a condition\
    \ prevents an\n   implementation from interacting correctly with a peer, the\n\
    \   implementation should, when capable of doing so, use the Internal\n   Error\
    \ Status Code to signal the peer.  This is a fatal error.\n"
- title: 3.5.1.2.8. Miscellaneous Events
  contents:
  - "3.5.1.2.8. Miscellaneous Events\n   These are events that fall into none of the\
    \ categories above.  There\n   are no miscellaneous events defined in this version\
    \ of the protocol.\n"
- title: 3.5.2. Hello Message
  contents:
  - "3.5.2. Hello Message\n   LDP Hello Messages are exchanged as part of the LDP\
    \ Discovery\n   Mechanism; see Section \"LDP Discovery\".\n   The encoding for\
    \ the Hello Message is:\n    0                   1                   2       \
    \            3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Hello (0x0100)            |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Common Hello Parameters TLV               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   Common Hello\
    \ Parameters TLV\n      Specifies parameters common to all Hello messages.  The\
    \ encoding\n      for the Common Hello Parameters TLV is:\n       0          \
    \         1                   2                   3\n       0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0|0| Common Hello Parms(0x0400)|      Length                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \      Hold Time                |T|R| Reserved                  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Hold Time,\n         Hello hold time in seconds.  An LSR maintains a record\
    \ of\n         Hellos received from potential peers (see Section \"Hello\n   \
    \      Message Procedures\").  Hello Hold Time specifies the time the\n      \
    \   sending LSR will maintain its record of Hellos from the\n         receiving\
    \ LSR without receipt of another Hello.\n         A pair of LSRs negotiates the\
    \ hold times they use for Hellos\n         from each other.  Each proposes a hold\
    \ time.  The hold time\n         used is the minimum of the hold times proposed\
    \ in their Hellos.\n         A value of 0 means use the default, which is 15 seconds\
    \ for\n         Link Hellos and 45 seconds for Targeted Hellos.  A value of\n\
    \         0xffff means infinite.\n      T, Targeted Hello\n         A value of\
    \ 1 specifies that this Hello is a Targeted Hello.  A\n         value of 0 specifies\
    \ that this Hello is a Link Hello.\n      R, Request Send Targeted Hellos\n  \
    \       A value of 1 requests the receiver to send periodic Targeted\n       \
    \  Hellos to the source of this Hello.  A value of 0 makes no\n         request.\n\
    \         An LSR initiating Extended Discovery sets R to 1.  If R is 1,\n    \
    \     the receiving LSR checks whether it has been configured to send\n      \
    \   Targeted Hellos to the Hello source in response to Hellos with\n         this\
    \ request.  If not, it ignores the request.  If so, it\n         initiates periodic\
    \ transmission of Targeted Hellos to the Hello\n         source.\n      Reserved\n\
    \         This field is reserved.  It must be set to zero on transmission\n  \
    \       and ignored on receipt.\n      Optional Parameters\n         This variable\
    \ length field contains 0 or more parameters, each\n         encoded as a TLV.\
    \  The optional parameters defined by this\n         version of the protocol are\n\
    \         Optional Parameter         Type     Length  Value\n         IPv4 Transport\
    \ Address     0x0401     4      See below\n         Configuration            \
    \  0x0402     4      See below\n            Sequence Number\n         IPv6 Transport\
    \ Address     0x0403    16      See below\n      IPv4 Transport Address\n    \
    \     Specifies the IPv4 address to be used for the sending LSR when\n       \
    \  opening the LDP session TCP connection.  If this optional TLV\n         is\
    \ not present the IPv4 source address for the UDP packet\n         carrying the\
    \ Hello should be used.\n      Configuration Sequence Number\n         Specifies\
    \ a 4 octet unsigned configuration sequence number that\n         identifies the\
    \ configuration state of the sending LSR.  Used by\n         the receiving LSR\
    \ to detect configuration changes on the\n         sending LSR.\n      IPv6 Transport\
    \ Address\n         Specifies the IPv6 address to be used for the sending LSR\
    \ when\n         opening the LDP session TCP connection.  If this optional TLV\n\
    \         is not present the IPv6 source address for the UDP packet\n        \
    \ carrying the Hello should be used.\n"
- title: 3.5.2.1. Hello Message Procedures
  contents:
  - "3.5.2.1. Hello Message Procedures\n   An LSR receiving Hellos from another LSR\
    \ maintains a Hello adjacency\n   corresponding to the Hellos.  The LSR maintains\
    \ a hold timer with the\n   Hello adjacency which it restarts whenever it receives\
    \ a Hello that\n   matches the Hello adjacency.  If the hold timer for a Hello\
    \ adjacency\n   expires the LSR discards the Hello adjacency: see sections\n \
    \  \"Maintaining Hello Adjacencies\" and \"Maintaining LDP Sessions\".\n   We\
    \ recommend that the interval between Hello transmissions be at most\n   one third\
    \ of the Hello hold time.\n   An LSR processes a received LDP Hello as follows:\n\
    \      1. The LSR checks whether the Hello is acceptable.  The criteria\n    \
    \     for determining whether a Hello is acceptable are\n         implementation\
    \ dependent (see below for example criteria).\n      2. If the Hello is not acceptable,\
    \ the LSR ignores it.\n      3. If the Hello is acceptable, the LSR checks whether\
    \ it has a\n         Hello adjacency for the Hello source.  If so, it restarts\
    \ the\n         hold timer for the Hello adjacency.  If not it creates a Hello\n\
    \         adjacency for the Hello source and starts its hold timer.\n      4.\
    \ If the Hello carries any optional TLVs the LSR processes them\n         (see\
    \ below).\n      5. Finally, if the LSR has no LDP session for the label space\n\
    \         specified by the LDP identifier in the PDU header for the\n        \
    \ Hello, it follows the procedures of Section \"LDP Session\n         Establishment\"\
    .\n   The following are examples of acceptability criteria for Link and\n   Targeted\
    \ Hellos:\n      A Link Hello is acceptable if the interface on which it was\n\
    \      received has been configured for label switching.\n      A Targeted Hello\
    \ from source address A is acceptable if either:\n      -  The LSR has been configured\
    \ to accept Targeted Hellos, or\n      -  The LSR has been configured to send\
    \ Targeted Hellos to A.\n      The following describes how an LSR processes Hello\
    \ optional TLVs:\n      Transport Address\n         The LSR associates the specified\
    \ transport address with the\n         Hello adjacency.\n      Configuration Sequence\
    \ Number\n         The Configuration Sequence Number optional parameter is used\
    \ by\n         the sending LSR to signal configuration changes to the\n      \
    \   receiving LSR.  When a receiving LSR playing the active role in\n        \
    \ LDP session establishment detects a change in the sending LSR\n         configuration,\
    \ it may clear the session setup backoff delay, if\n         any, associated with\
    \ the sending LSR (see Section \"Session\n         Initialization\").\n      \
    \   A sending LSR using this optional parameter is responsible for\n         maintaining\
    \ the configuration sequence number it transmits in\n         Hello messages.\
    \  Whenever there is a configuration change on\n         the sending LSR, it increments\
    \ the configuration sequence\n         number.\n"
- title: 3.5.3. Initialization Message
  contents:
  - "3.5.3. Initialization Message\n   The LDP Initialization Message is exchanged\
    \ as part of the LDP\n   session establishment procedure; see Section \"LDP Session\n\
    \   Establishment\".\n   The encoding for the Initialization Message is:\n   \
    \ 0                   1                   2                   3\n    0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Initialization (0x0200)   |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Common Session Parameters TLV             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   Common Session\
    \ Parameters TLV\n      Specifies values proposed by the sending LSR for parameters\
    \ that\n      must be negotiated for every LDP session.\n      The encoding for\
    \ the Common Session Parameters TLV is:\n       0                   1        \
    \           2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0|0| Common Sess Parms (0x0500)|      Length                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \ Protocol Version              |      KeepAlive Time           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |A|D|  Reserved |     PVLim     |      Max PDU Length           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                 Receiver LDP Identifier                       |\n      +   \
    \                            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |      \
    \                         |\n      -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++\n      Protocol\
    \ Version\n         Two octet unsigned integer containing the version number of\
    \ the\n         protocol.  This version of the specification specifies LDP\n \
    \        protocol version 1.\n      KeepAlive Time\n         Two octet unsigned\
    \ non zero integer that indicates the number\n         of seconds that the sending\
    \ LSR proposes for the value of the\n         KeepAlive Time.  The receiving LSR\
    \ MUST calculate the value of\n         the KeepAlive Timer by using the smaller\
    \ of its proposed\n         KeepAlive Time and the KeepAlive Time received in\
    \ the PDU.  The\n         value chosen for KeepAlive Time indicates the maximum\
    \ number of\n         seconds that may elapse between the receipt of successive\
    \ PDUs\n         from the LDP peer on the session TCP connection.  The KeepAlive\n\
    \         Timer is reset each time a PDU arrives.\n      A, Label Advertisement\
    \ Discipline\n         Indicates the type of Label advertisement.  A value of\
    \ 0 means\n         Downstream Unsolicited advertisement; a value of 1 means\n\
    \         Downstream On Demand.\n         If one LSR proposes Downstream Unsolicited\
    \ and the other\n         proposes Downstream on Demand, the rules for resolving\
    \ this\n         difference is:\n         -  If the session is for a label-controlled\
    \ ATM link or a\n            label-controlled Frame Relay link, then Downstream\
    \ on Demand\n            must be used.\n         -  Otherwise, Downstream Unsolicited\
    \ must be used.\n         If the label advertisement discipline determined in\
    \ this way is\n         unacceptable to an LSR, it must send a Session\n     \
    \    Rejected/Parameters Advertisement Mode Notification message in\n        \
    \ response to the Initialization message and not establish the\n         session.\n\
    \      D, Loop Detection\n         Indicates whether loop detection based on path\
    \ vectors is\n         enabled.  A value of 0 means loop detection is disabled;\
    \ a\n         value of 1 means that loop detection is enabled.\n      PVLim, Path\
    \ Vector Limit\n         The configured maximum path vector length.  Must be 0\
    \ if loop\n         detection is disabled (D = 0).  If the loop detection\n  \
    \       procedures would require the LSR to send a path vector that\n        \
    \ exceeds this limit, the LSR will behave as if a loop had been\n         detected\
    \ for the FEC in question.\n         When Loop Detection is enabled in a portion\
    \ of a network, it is\n         recommended that all LSRs in that portion of the\
    \ network be\n         configured with the same path vector limit.  Although knowledge\n\
    \         of a peer's path vector limit will not change an LSR's\n         behavior,\
    \ it does enable the LSR to alert an operator to a\n         possible misconfiguration.\n\
    \      Reserved\n         This field is reserved.  It must be set to zero on transmission\n\
    \         and ignored on receipt.\n      Max PDU Length\n         Two octet unsigned\
    \ integer that proposes the maximum allowable\n         length for LDP PDUs for\
    \ the session.  A value of 255 or less\n         specifies the default maximum\
    \ length of 4096 octets.\n         The receiving LSR MUST calculate the maximum\
    \ PDU length for the\n         session by using the smaller of its and its peer's\
    \ proposals\n         for Max PDU Length.  The default maximum PDU length applies\n\
    \         before session initialization completes.\n         If the maximum PDU\
    \ length determined this way is unacceptable\n         to an LSR, it must send\
    \ a Session Rejected/Parameters Max PDU\n         Length Notification message\
    \ in response to the Initialization\n         message and not establish the session.\n\
    \      Receiver LDP Identifier\n         Identifies the receiver's label space.\
    \  This LDP Identifier,\n         together with the sender's LDP Identifier in\
    \ the PDU header\n         enables the receiver to match the Initialization message\
    \ with\n         one of its Hello adjacencies; see Section \"Hello Message\n \
    \        Procedures\".\n         If there is no matching Hello adjacency, the\
    \ LSR must send a\n         Session Rejected/No Hello Notification message in\
    \ response to\n         the Initialization message and not establish the session.\n\
    \   Optional Parameters\n      This variable length field contains 0 or more parameters,\
    \ each\n      encoded as a TLV.  The optional parameters are:\n         Optional\
    \ Parameter       Type     Length  Value\n         ATM Session Parameters   0x0501\
    \   var     See below\n         Frame Relay Session      0x0502   var     See\
    \ below\n           Parameters\n      ATM Session Parameters\n         Used when\
    \ an LDP session manages label exchange for an ATM link\n         to specify ATM-specific\
    \ session parameters.\n       0                   1                   2      \
    \             3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0|0|   ATM Sess Parms (0x0501) |      Length                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \ M |   N   |D|                        Reserved                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                 ATM Label Range Component 1                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      ~   \
    \                                                            ~\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                 ATM Label Range Component N                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      M,\
    \ ATM Merge Capabilities\n         Specifies the merge capabilities of an ATM\
    \ switch.  The\n         following values are supported in this version of the\n\
    \         specification:\n                  Value          Meaning\n         \
    \           0            Merge not supported\n                    1          \
    \  VP Merge supported\n                    2            VC Merge supported\n \
    \                   3            VP & VC Merge supported\n         If the merge\
    \ capabilities of the LSRs differ, then:\n         -  Non-merge and VC-merge LSRs\
    \ may freely interoperate.\n         -  The interoperability of VP-merge-capable\
    \ switches with non-\n            VP-merge-capable switches is a subject for future\
    \ study.\n            When the LSRs differ on the use of VP-merge, the session\
    \ is\n            established, but VP merge is not used.\n         Note that if\
    \ VP merge is used, it is the responsibility of the\n         ingress node to\
    \ ensure that the chosen VCI is unique within the\n         LSR domain (see [ATM-VP]).\n\
    \      N, Number of label range components\n         Specifies the number of ATM\
    \ Label Range Components included in\n         the TLV.\n      D, VC Directionality\n\
    \         A value of 0 specifies bidirectional VC capability, meaning the\n  \
    \       LSR can (within a given VPI) support the use of a given VCI as\n     \
    \    a label for both link directions independently.  A value of 1\n         specifies\
    \ unidirectional VC capability, meaning (within a given\n         VPI) a given\
    \ VCI may appear in a label mapping for one\n         direction on the link only.\
    \  When either or both of the peers\n         specifies unidirectional VC capability,\
    \ both LSRs use\n         unidirectional VC label assignment for the link as follows.\n\
    \         The LSRs compare their LDP Identifiers as unsigned integers.\n     \
    \    The LSR with the larger LDP Identifier may assign only odd-\n         numbered\
    \ VCIs in the VPI/VCI range as labels.  The system with\n         the smaller\
    \ LDP Identifier may assign only even-numbered VCIs\n         in the VPI/VCI range\
    \ as labels.\n      Reserved\n         This field is reserved.  It must be set\
    \ to zero on transmission\n         and ignored on receipt.\n      One or more\
    \ ATM Label Range Components\n         A list of ATM Label Range Components which\
    \ together specify the\n         Label range supported by the transmitting LSR.\n\
    \         A receiving LSR MUST calculate the intersection between the\n      \
    \   received range and its own supported label range.  The\n         intersection\
    \ is the range in which the LSR may allocate and\n         accept labels.  LSRs\
    \ MUST NOT establish a session with\n         neighbors for which the intersection\
    \ of ranges is NULL.  In\n         this case, the LSR must send a Session Rejected/Parameters\n\
    \         Label Range Notification message in response to the\n         Initialization\
    \ message and not establish the session.\n         The encoding for an ATM Label\
    \ Range Component is:\n       0                   1                   2      \
    \             3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  Res  |    Minimum VPI        |      Minimum VCI              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Res  |    Maximum VPI        |      Maximum VCI              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Res\n            This field is reserved. It must be set to zero on\n\
    \            transmission and must be ignored on receipt.\n         Minimum VPI\
    \ (12 bits)\n            This 12 bit field specifies the lower bound of a block\
    \ of\n            Virtual Path Identifiers that is supported on the\n        \
    \    originating switch.  If the VPI is less than 12-bits it\n            should\
    \ be right justified in this field and preceding bits\n            should be set\
    \ to 0.\n         Minimum VCI (16 bits)\n            This 16 bit field specifies\
    \ the lower bound of a block of\n            Virtual Connection Identifiers that\
    \ is supported on the\n            originating switch.  If the VCI is less than\
    \ 16-bits it\n            should be right justified in this field and preceding\
    \ bits\n            should be set to 0.\n         Maximum VPI (12 bits)\n    \
    \        This 12 bit field specifies the upper bound of a block of\n         \
    \   Virtual Path Identifiers that is supported on the\n            originating\
    \ switch.  If the VPI is less than 12-bits it\n            should be right justified\
    \ in this field and preceding bits\n            should be set to 0.\n        \
    \ Maximum VCI (16 bits)\n            This 16 bit field specifies the upper bound\
    \ of a block of\n            Virtual Connection Identifiers that is supported\
    \ on the\n            originating switch.  If the VCI is less than 16-bits it\n\
    \            should be right justified in this field and preceding bits\n    \
    \        should be set to 0.\n      When peer LSRs are connected indirectly by\
    \ means of an ATM VP, the\n      sending LSR should set the Minimum and Maximum\
    \ VPI fields to 0,\n      and the receiving LSR must ignore the Minimum and Maximum\
    \ VPI\n      fields.\n      See [ATM-VP] for specification of the fields for ATM\
    \ Label Range\n      Components to be used with VP merge LSRs.\n      Frame Relay\
    \ Session Parameters\n         Used when an LDP session manages label exchange\
    \ for a Frame\n         Relay link to specify Frame Relay-specific session parameters.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0|0|   FR Sess Parms (0x0502)  |      Length                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \ M |   N   |D|                        Reserved                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Frame Relay Label Range Component 1               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      ~   \
    \                                                            ~\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Frame Relay Label Range Component N               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      M,\
    \ Frame Relay Merge Capabilities\n         Specifies the merge capabilities of\
    \ a Frame Relay switch.  The\n         following values are supported in this\
    \ version of the\n         specification:\n                  Value          Meaning\n\
    \                    0            Merge not supported\n                    1 \
    \           Merge supported\n         Non-merge and merge Frame Relay LSRs may\
    \ freely interoperate.\n      N, Number of label range components\n         Specifies\
    \ the number of Frame Relay Label Range Components\n         included in the TLV.\n\
    \      D, VC Directionality\n         A value of 0 specifies bidirectional VC\
    \ capability, meaning the\n         LSR can support the use of a given DLCI as\
    \ a label for both\n         link directions independently.  A value of 1 specifies\n\
    \         unidirectional VC capability, meaning a given DLCI may appear\n    \
    \     in a label mapping for one direction on the link only.  When\n         either\
    \ or both of the peers specifies unidirectional VC\n         capability, both\
    \ LSRs use unidirectional VC label assignment\n         for the link as follows.\
    \  The LSRs compare their LDP\n         Identifiers as unsigned integers.  The\
    \ LSR with the larger LDP\n         Identifier may assign only odd-numbered DLCIs\
    \ in the range as\n         labels.  The system with the smaller LDP Identifier\
    \ may assign\n         only even-numbered DLCIs in the range as labels.\n    \
    \  Reserved\n         This field is reserved.  It must be set to zero on transmission\n\
    \         and ignored on receipt.\n      One or more Frame Relay Label Range Components\n\
    \         A list of Frame Relay Label Range Components which together\n      \
    \   specify the Label range supported by the transmitting LSR.\n         A receiving\
    \ LSR MUST calculate the intersection between the\n         received range and\
    \ its own supported label range.  The\n         intersection is the range in which\
    \ the LSR may allocate and\n         accept labels.  LSRs MUST NOT establish a\
    \ session with\n         neighbors for which the intersection of ranges is NULL.\
    \  In\n         this case, the LSR must send a Session Rejected/Parameters\n \
    \        Label Range Notification message in response to the\n         Initialization\
    \ message and not establish the session.\n         The encoding for a Frame Relay\
    \ Label Range Component is:\n       0                   1                   2\
    \                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Reserved    |Len|                     Minimum DLCI            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \ Reserved        |                     Maximum DLCI            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Reserved\n            This field is reserved.  It must be set to zero\
    \ on\n            transmission and ignored on receipt.\n         Len\n       \
    \     This field specifies the number of bits of the DLCI.  The\n            following\
    \ values are supported:\n                 Len    DLCI bits\n                 0\
    \       10\n                 2       23\n            Len values 1 and 3 are reserved.\n\
    \         Minimum DLCI\n            This 23-bit field specifies the lower bound\
    \ of a block of\n            Data Link Connection Identifiers (DLCIs) that is\
    \ supported\n            on the originating switch.  The DLCI should be right\n\
    \            justified in this field and unused bits should be set to 0.\n   \
    \      Maximum DLCI\n            This 23-bit field specifies the upper bound of\
    \ a block of\n            Data Link Connection Identifiers (DLCIs) that is supported\n\
    \            on the originating switch.  The DLCI should be right\n          \
    \  justified in this field and unused bits should be set to 0.\n   Note that there\
    \ is no Generic Session Parameters TLV for sessions\n   which advertise Generic\
    \ Labels.\n"
- title: 3.5.3.1. Initialization Message Procedures
  contents:
  - "3.5.3.1. Initialization Message Procedures\n   See Section \"LDP Session Establishment\"\
    \ and particularly Section\n   \"Session Initialization\" for general procedures\
    \ for handling the\n   Initialization Message.\n"
- title: 3.5.4. KeepAlive Message
  contents:
  - "3.5.4. KeepAlive Message\n   An LSR sends KeepAlive Messages as part of a mechanism\
    \ that monitors\n   the integrity of the LDP session transport connection.\n \
    \  The encoding for the KeepAlive Message is:\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   KeepAlive (0x0201)        |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   Optional\
    \ Parameters\n      No optional parameters are defined for the KeepAlive message.\n"
- title: 3.5.4.1. KeepAlive Message Procedures
  contents:
  - "3.5.4.1. KeepAlive Message Procedures\n   The KeepAlive Timer mechanism described\
    \ in Section \"Maintaining LDP\n   Sessions\" resets a session KeepAlive timer\
    \ every time an LDP PDU is\n   received on the session TCP connection.  The KeepAlive\
    \ Message is\n   provided to allow reset of the KeepAlive Timer in circumstances\
    \ where\n   an LSR has no other information to communicate to an LDP peer.\n \
    \  An LSR must arrange that its peer receive an LDP Message from it at\n   least\
    \ every KeepAlive Time period.  Any LDP protocol message will do\n   but, in circumstances\
    \ where no other LDP protocol messages have been\n   sent within the period, a\
    \ KeepAlive message must be sent.\n"
- title: 3.5.5. Address Message
  contents:
  - "3.5.5. Address Message\n   An LSR sends the Address Message to an LDP peer to\
    \ advertise its\n   interface addresses.\n   The encoding for the Address Message\
    \ is:\n    0                   1                   2                   3\n   \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Address (0x0300)          |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \                   Address List TLV                          |\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   Address\
    \ List TLV\n      The list of interface addresses being advertised by the sending\n\
    \      LSR.  The encoding for the Address List TLV is specified in Section\n \
    \     \"Address List TLV\".\n   Optional Parameters\n      No optional parameters\
    \ are defined for the Address message.\n"
- title: 3.5.5.1. Address Message Procedures
  contents:
  - "3.5.5.1. Address Message Procedures\n   An LSR that receives an Address Message\
    \ message uses the addresses it\n   learns to maintain a database for mapping\
    \ between peer LDP\n   Identifiers and next hop addresses; see Section \"LDP Identifiers\
    \ and\n   Next Hop Addresses\".\n   When a new LDP session is initialized and\
    \ before sending Label\n   Mapping or Label Request messages an LSR should advertise\
    \ its\n   interface addresses with one or more Address messages.\n   Whenever\
    \ an LSR \"activates\" a new interface address, it should\n   advertise the new\
    \ address with an Address message.\n   Whenever an LSR \"de-activates\" a previously\
    \ advertised address, it\n   should withdraw the address with an Address Withdraw\
    \ message; see\n   Section \"Address Withdraw Message\".\n   If an LSR does not\
    \ support the Address Family specified in the\n   Address List TLV, it should\
    \ send an \"Unsupported Address Family\"\n   Notification to its LDP signalling\
    \ an error and abort processing the\n   message.\n"
- title: 3.5.6. Address Withdraw Message
  contents:
  - "3.5.6. Address Withdraw Message\n   An LSR sends the Address Withdraw Message\
    \ to an LDP peer to withdraw\n   previously advertised interface addresses.\n\
    \   The encoding for the Address Withdraw Message is:\n    0                 \
    \  1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Address Withdraw (0x0301) |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \                   Address List TLV                          |\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   Address\
    \ list TLV\n      The list of interface addresses being withdrawn by the sending\n\
    \      LSR.  The encoding for the Address list TLV is specified in\n      Section\
    \ \"Address List TLV\".\n   Optional Parameters\n      No optional parameters\
    \ are defined for the Address Withdraw\n      message.\n"
- title: 3.5.6.1. Address Withdraw Message Procedures
  contents:
  - "3.5.6.1. Address Withdraw Message Procedures\n   See Section \"Address Message\
    \ Procedures\"\n"
- title: 3.5.7. Label Mapping Message
  contents:
  - "3.5.7. Label Mapping Message\n   An LSR sends a Label Mapping message to an LDP\
    \ peer to advertise\n   FEC-label bindings to the peer.\n   The encoding for the\
    \ Label Mapping Message is:\n   0                   1                   2    \
    \               3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Label Mapping (0x0400)    |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     FEC TLV                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Label TLV                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   FEC TLV\n\
    \      Specifies the FEC component of the FEC-Label mapping being\n      advertised.\
    \  See Section \"FEC TLV\" for encoding.\n   Label TLV\n      Specifies the Label\
    \ component of the FEC-Label mapping.  See\n      Section \"Label TLV\" for encoding.\n\
    \   Optional Parameters\n      This variable length field contains 0 or more parameters,\
    \ each\n      encoded as a TLV.  The optional parameters are:\n         Optional\
    \ Parameter    Length       Value\n         Label Request         4          \
    \  See below\n             Message ID TLV\n         Hop Count TLV         1  \
    \          See below\n         Path Vector TLV       variable     See below\n\
    \      The encodings for the Hop Count, and Path Vector TLVs can be found\n  \
    \    in Section \"TLV Encodings for Commonly Used Parameters\".\n      Label Request\
    \ Message ID\n         If this Label Mapping message is a response to a Label\
    \ Request\n         message it must include the Request Message Id optional\n\
    \         parameter.  The value of this optional parameter is the Message\n  \
    \       Id of the corresponding Label Request Message.\n      Hop Count\n    \
    \     Specifies the running total of the number of LSR hops along the\n      \
    \   LSP being setup by the Label Message.  Section \"Hop Count\n         Procedures\"\
    \ describes how to handle this TLV.\n      Path Vector\n         Specifies the\
    \ LSRs along the LSP being setup by the Label\n         Message.  Section \"Path\
    \ Vector Procedures\" describes how to\n         handle this TLV.\n"
- title: 3.5.7.1. Label Mapping Message Procedures
  contents:
  - "3.5.7.1. Label Mapping Message Procedures\n   The Mapping message is used by\
    \ an LSR to distribute a label mapping\n   for a FEC to an LDP peer.  If an LSR\
    \ distributes a mapping for a FEC\n   to multiple LDP peers, it is a local matter\
    \ whether it maps a single\n   label to the FEC, and distributes that mapping\
    \ to all its peers, or\n   whether it uses a different mapping for each of its\
    \ peers.\n   An LSR is responsible for the consistency of the label mappings it\n\
    \   has distributed, and that its peers have these mappings.\n   An LSR receiving\
    \ a Label Mapping message from a downstream LSR for a\n   Prefix or Host Address\
    \ FEC Element should not use the label for\n   forwarding unless its routing table\
    \ contains an entry that exactly\n   matches the FEC Element.\n   See Appendix\
    \ A \"LDP Label Distribution Procedures\" for more details.\n"
- title: 3.5.7.1.1. Independent Control Mapping
  contents:
  - "3.5.7.1.1. Independent Control Mapping\n   If an LSR is configured for independent\
    \ control, a mapping message is\n   transmitted by the LSR upon any of the following\
    \ conditions:\n      1. The LSR recognizes a new FEC via the forwarding table,\
    \ and the\n         label advertisement mode is Downstream Unsolicited\n     \
    \    advertisement.\n      2. The LSR receives a Request message from an upstream\
    \ peer for a\n         FEC present in the LSR's forwarding table.\n      3. The\
    \ next hop for a FEC changes to another LDP peer, and loop\n         detection\
    \ is configured.\n      4. The attributes of a mapping change.\n      5. The receipt\
    \ of a mapping from the downstream next hop  AND\n            a) no upstream mapping\
    \ has been created  OR\n            b) loop detection is configured  OR\n    \
    \        c) the attributes of the mapping have changed.\n"
- title: 3.5.7.1.2. Ordered Control Mapping
  contents:
  - "3.5.7.1.2. Ordered Control Mapping\n   If an LSR is doing ordered control, a\
    \ Mapping message is transmitted\n   by downstream LSRs upon any of the following\
    \ conditions:\n      1. The LSR recognizes a new FEC via the forwarding table,\
    \ and is\n         the egress for that FEC.\n      2. The LSR receives a Request\
    \ message from an upstream peer for a\n         FEC present in the LSR's forwarding\
    \ table, and the LSR is the\n         egress for that FEC OR has a downstream\
    \ mapping for that FEC.\n      3. The next hop for a FEC changes to another LDP\
    \ peer, and loop\n         detection is configured.\n      4. The attributes of\
    \ a mapping change.\n      5. The receipt of a mapping from the downstream next\
    \ hop  AND\n            a) no upstream mapping has been created   OR\n       \
    \     b) loop detection is configured   OR\n            c) the attributes of the\
    \ mapping have changed.\n"
- title: 3.5.7.1.3. Downstream on Demand Label Advertisement
  contents:
  - "3.5.7.1.3. Downstream on Demand Label Advertisement\n   In general, the upstream\
    \ LSR is responsible for requesting label\n   mappings when operating in Downstream\
    \ on Demand mode.  However,\n   unless some rules are followed, it is possible\
    \ for neighboring LSRs\n   with different advertisement modes to get into a livelock\
    \ situation\n   where everything is functioning properly, but no labels are\n\
    \   distributed.  For example, consider two LSRs Ru and Rd where Ru is\n   the\
    \ upstream LSR and Rd is the downstream LSR for a particular FEC.\n   In this\
    \ example, Ru is using Downstream Unsolicited advertisement\n   mode and Rd is\
    \ using Downstream on Demand mode.  In this case, Rd may\n   assume that Ru will\
    \ request a label mapping when it wants one and Ru\n   may assume that Rd will\
    \ advertise a label if it wants Ru to use one.\n   If Rd and Ru operate as suggested,\
    \ no labels will be distributed from\n   Rd to Ru.\n   This livelock situation\
    \ can be avoided if the following rule is\n   observed: an LSR operating in Downstream\
    \ on Demand mode should not be\n   expected to send unsolicited mapping advertisements.\
    \  Therefore, if\n   the downstream LSR is operating in Downstream on Demand mode,\
    \ the\n   upstream LSR is responsible for requesting label mappings as needed.\n"
- title: 3.5.7.1.4. Downstream Unsolicited Label Advertisement
  contents:
  - "3.5.7.1.4. Downstream Unsolicited Label Advertisement\n   In general, the downstream\
    \ LSR is responsible for advertising a label\n   mapping when it wants an upstream\
    \ LSR to use the label.  An upstream\n   LSR may issue a mapping request if it\
    \ so desires.\n   The combination of Downstream Unsolicited mode and conservative\
    \ label\n   retention can lead to a situation where an LSR releases the label\
    \ for\n   a FEC that it later needs.  For example, if LSR Rd advertises to LSR\n\
    \   Ru the label for a FEC for which it is not Ru's next hop, Ru will\n   release\
    \ the label.  If Ru's next hop for the FEC later changes to Rd,\n   it needs the\
    \ previously released label.\n   To deal with this situation either Ru can explicitly\
    \ request the\n   label when it needs it, or Rd can periodically readvertise it\
    \ to Ru.\n   In many situations Ru will know when it needs the label from Rd.\
    \  For\n   example, when its next hop for the FEC changes to Rd.  However, there\n\
    \   could be situations when Ru does not.  For example, Rd may be\n   attempting\
    \ to establish an LSP with non-standard properties.  Forcing\n   Ru to explicitly\
    \ request the label in this situation would require it\n   to maintain state about\
    \ a potential LSP with non-standard properties.\n   In situations where Ru knows\
    \ it needs the label, it is responsible\n   for explicitly requesting the label\
    \ by means of a Label Request\n   message.  In situations where Ru may not know\
    \ that it needs the\n   label, Rd is responsible for periodically readvertising\
    \ the label to\n   Ru.\n   For this version of LDP, the only situation where Ru\
    \ knows it needs a\n   label for a FEC from Rd is when Rd is its next hop for\
    \ the FEC, Ru\n   does not have a label from Rd, and the LSP for the FEC is one\
    \ that\n   can be established with TLVs defined in this document.\n"
- title: 3.5.8. Label Request Message
  contents:
  - "3.5.8. Label Request Message\n   An LSR sends the Label Request Message to an\
    \ LDP peer to request a\n   binding (mapping) for a FEC.\n   The encoding for\
    \ the Label Request Message is:\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Label Request (0x0401)    |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     FEC TLV                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   FEC TLV\n\
    \      The FEC for which a label is being requested.  See Section \"FEC\n    \
    \  TLV\" for encoding.\n   Optional Parameters\n      This variable length field\
    \ contains 0 or more parameters, each\n      encoded as a TLV.  The optional parameters\
    \ are:\n         Optional Parameter     Length       Value\n         Hop Count\
    \ TLV          1            See below\n         Path Vector TLV        variable\
    \     See below\n      The encodings for the Hop Count, and Path Vector TLVs can\
    \ be found\n      in Section \"TLV Encodings for Commonly Used Parameters\".\n\
    \      Hop Count\n         Specifies the running total of the number of LSR hops\
    \ along the\n         LSP being setup by the Label Request Message.  Section \"\
    Hop\n         Count Procedures\" describes how to handle this TLV.\n      Path\
    \ Vector\n         Specifies the LSRs along the LSR being setup by the Label\n\
    \         Request Message.  Section \"Path Vector Procedures\" describes\n   \
    \      how to handle this TLV.\n"
- title: 3.5.8.1. Label Request Message Procedures
  contents:
  - "3.5.8.1. Label Request Message Procedures\n   The Request message is used by\
    \ an upstream LSR to explicitly request\n   that the downstream LSR assign and\
    \ advertise a label for a FEC.\n   An LSR may transmit a Request message under\
    \ any of the following\n   conditions:\n      1. The LSR recognizes a new FEC\
    \ via the forwarding table, and the\n         next hop is an LDP peer, and the\
    \ LSR doesn't already have a\n         mapping from the next hop for the given\
    \ FEC.\n      2. The next hop to the FEC changes, and the LSR doesn't already\n\
    \         have a mapping from that next hop for the given FEC.\n         Note\
    \ that if the LSR already has a pending Label Request\n         message for the\
    \ new next hop it should not issue an additional\n         Label Request in response\
    \ to the next hop change.\n      3. The LSR receives a Label Request for a FEC\
    \ from an upstream LDP\n         peer, the FEC next hop is an LDP peer, and the\
    \ LSR doesn't\n         already have a mapping from the next hop.\n         Note\
    \ that since a non-merge LSR must setup a separate LSP for\n         each upstream\
    \ peer requesting a label, it must send a separate\n         Label Request for\
    \ each such peer.  A consequence of this is\n         that a non-merge LSR may\
    \ have multiple Label Request messages\n         for a given FEC outstanding at\
    \ the same time.\n   The receiving LSR should respond to a Label Request message\
    \ with a\n   Label Mapping for the requested label or with a Notification message\n\
    \   indicating why it cannot satisfy the request.\n   When the FEC for which a\
    \ label is requested is a Prefix FEC Element\n   or a Host Address FEC Element,\
    \ the receiving LSR uses its routing\n   table to determine its response.  Unless\
    \ its routing table includes\n   an entry that exactly matches the requested Prefix\
    \ or Host Address,\n   the LSR must respond with a No Route Notification message.\n\
    \   The message ID of the Label Request message serves as an identifier\n   for\
    \ the Label Request transaction.  When the receiving LSR responds\n   with a Label\
    \ Mapping message, the mapping message must include a\n   Label Request/Returned\
    \ Message ID TLV optional parameter which\n   includes the message ID of the Label\
    \ Request message.  Note that\n   since LSRs use Label Request message IDs as\
    \ transaction identifiers\n   an LSR should not reuse the message ID of a Label\
    \ Request message\n   until the corresponding transaction completes.\n   This\
    \ version of the protocol defines the following Status Codes for\n   the Notification\
    \ message that signals a request cannot be satisfied:\n      No Route\n      \
    \   The FEC for which a label was requested includes a FEC Element\n         for\
    \ which the LSR does not have a route.\n      No Label Resources\n         The\
    \ LSR cannot provide a label because of resource limitations.\n         When resources\
    \ become available the LSR must notify the\n         requesting LSR by sending\
    \ a Notification message with the Label\n         Resources Available Status Code.\n\
    \         An LSR that receives a No Label Resources response to a Label\n    \
    \     Request message must not issue further Label Request messages\n        \
    \ until it receives a Notification message with the Label\n         Resources\
    \ Available Status code.\n      Loop Detected\n         The LSR has detected a\
    \ looping Label Request message.\n   See Appendix A \"LDP Label Distribution Procedures\"\
    \ for more details.\n"
- title: 3.5.9. Label Abort Request Message
  contents:
  - "3.5.9. Label Abort Request Message\n   The Label Abort Request message may be\
    \ used to abort an outstanding\n   Label Request message.\n   The encoding for\
    \ the Label Abort Request Message is:\n    0                   1             \
    \      2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Label Abort Req (0x0404)  |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     FEC TLV                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Label Request Message ID TLV              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   FEC TLV\n\
    \      Identifies the FEC for which the Label Request is being aborted.\n   Label\
    \ Request Message ID TLV\n      Specifies the message ID of the Label Request\
    \ message to be\n      aborted.\n   Optional Parameters\n      No optional parameters\
    \ are defined for the Label Abort Req\n      message.\n"
- title: 3.5.9.1. Label Abort Request Message Procedures
  contents:
  - "3.5.9.1. Label Abort Request Message Procedures\n   An LSR Ru may send a Label\
    \ Abort Request message to abort an\n   outstanding Label Request message for\
    \ FEC sent to LSR Rd in the\n   following circumstances:\n      1. Ru's next hop\
    \ for FEC has changed from LSR Rd to LSR X; or\n      2. Ru is a non-merge, non-ingress\
    \ LSR and has received a Label\n         Abort Request for FEC from an upstream\
    \ peer Y.\n      3. Ru is a merge, non-ingress LSR and has received a Label Abort\n\
    \         Request for FEC from an upstream peer Y and Y is the only\n        \
    \ (last) upstream LSR requesting a label for FEC.\n   There may be other situations\
    \ where an LSR may choose to abort an\n   outstanding Label Request message in\
    \ order to reclaim resource\n   associated with the pending LSP.  However, specification\
    \ of general\n   strategies for using the abort mechanism is beyond the scope\
    \ of LDP.\n   When an LSR receives a Label Abort Request message, if it has not\n\
    \   previously responded to the Label Request being aborted with a Label\n   Mapping\
    \ message or some other Notification message, it must\n   acknowledge the abort\
    \ by responding with a Label Request Aborted\n   Notification message.  The Notification\
    \ must include a Label Request\n   Message ID TLV that carries the message ID\
    \ of the aborted Label\n   Request message.\n   If an LSR receives a Label Abort\
    \ Request Message after it has\n   responded to the Label Request in question\
    \ with a Label Mapping\n   message or a Notification message, it ignores the abort\
    \ request.\n   If an LSR receives a Label Mapping message in response to a Label\n\
    \   Request message after it has sent a Label Abort Request message to\n   abort\
    \ the Label Request, the label in the Label Mapping message is\n   valid.  The\
    \ LSR may choose to use the label or to release it with a\n   Label Release message.\n\
    \   An LSR aborting a Label Request message may not reuse the Message ID\n   for\
    \ the Label Request message until it receives one of the following\n   from its\
    \ peer:\n      -  A Label Request Aborted Notification message acknowledging the\n\
    \         abort;\n      -  A Label Mapping message in response to the Label Request\n\
    \         message being aborted;\n      -  A Notification message in response\
    \ to the Label Request message\n         being aborted (e.g., Loop Detected, No\
    \ Label Resources, etc.).\n   To protect itself against tardy peers or faulty\
    \ peer implementations\n   an LSR may choose to time out receipt of the above.\
    \  The time out\n   period should be relatively long (several minutes).  If the\
    \ time out\n   period elapses with no reply from the peer the LSR may reuse the\n\
    \   Message Id of the Label Request message; if it does so, it should\n   also\
    \ discard any record of the outstanding Label Request and Label\n   Abort messages.\n\
    \   Note that the response to a Label Abort Request message is never\n   \"ordered\"\
    .  That is, the response does not depend on the downstream\n   state of the LSP\
    \ setup being aborted.  An LSR receiving a Label Abort\n   Request message must\
    \ process it immediately, regardless of the\n   downstream state of the LSP, responding\
    \ with a Label Request Aborted\n   Notification or ignoring it, as appropriate.\n"
- title: 3.5.10. Label Withdraw Message
  contents:
  - "3.5.10. Label Withdraw Message\n   An LSR sends a Label Withdraw Message to an\
    \ LDP peer to signal the\n   peer that the peer may not continue to use specific\
    \ FEC-label\n   mappings the LSR had previously advertised.  This breaks the mapping\n\
    \   between the FECs and the labels.\n   The encoding for the Label Withdraw Message\
    \ is:\n    0                   1                   2                   3\n   \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Label Withdraw (0x0402)   |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     FEC TLV                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Label TLV (optional)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   FEC TLV\n\
    \      Identifies the FEC for which the FEC-label mapping is being\n      withdrawn.\n\
    \   Optional Parameters\n      This variable length field contains 0 or more parameters,\
    \ each\n      encoded as a TLV.  The optional parameters are:\n         Optional\
    \ Parameter    Length       Value\n         Label TLV             variable   \
    \  See below\n      The encoding for Label TLVs are found in Section \"Label TLVs\"\
    .\n      Label\n         If present, specifies the label being withdrawn (see\
    \ procedures\n         below).\n"
- title: 3.5.10.1. Label Withdraw Message Procedures
  contents:
  - "3.5.10.1. Label Withdraw Message Procedures\n   An LSR transmits a Label Withdraw\
    \ message under the following\n   conditions:\n      1. The LSR no longer recognizes\
    \ a previously known FEC for which\n         it has advertised a label.\n    \
    \  2. The LSR has decided unilaterally (e.g., via configuration) to\n        \
    \ no longer label switch a FEC (or FECs) with the label mapping\n         being\
    \ withdrawn.\n   The FEC TLV specifies the FEC for which labels are to be withdrawn.\n\
    \   If no Label TLV follows the FEC, all labels associated with the FEC\n   are\
    \ to be withdrawn; otherwise only the label specified in the\n   optional Label\
    \ TLV is to be withdrawn.\n   The FEC TLV may contain the Wildcard FEC Element;\
    \ if so, it may\n   contain no other FEC Elements.  In this case, if the Label\
    \ Withdraw\n   message contains an optional Label TLV, then the label is to be\n\
    \   withdrawn from all FECs to which it is bound.  If there is not an\n   optional\
    \ Label TLV in the Label Withdraw message, then the sending\n   LSR is withdrawing\
    \ all label mappings previously advertised to the\n   receiving LSR.\n   An LSR\
    \ that receives a Label Withdraw message must respond with a\n   Label Release\
    \ message.\n   See Appendix A \"LDP Label Distribution Procedures\" for more details.\n"
- title: 3.5.11. Label Release Message
  contents:
  - "3.5.11. Label Release Message\n   An LSR sends a Label Release message to an\
    \ LDP peer to signal the\n   peer that the LSR no longer needs specific FEC-label\
    \ mappings\n   previously requested of and/or advertised by the peer.\n   The\
    \ encoding for the Label Release Message is:\n    0                   1      \
    \             2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   Label Release (0x0403)   |      Message Length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     FEC TLV                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Label TLV (optional)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Optional Parameters                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message ID\n      32-bit value used to identify this message.\n   FEC TLV\n\
    \      Identifies the FEC for which the FEC-label mapping is being\n      released.\n\
    \   Optional Parameters\n      This variable length field contains 0 or more parameters,\
    \ each\n      encoded as a TLV.  The optional parameters are:\n         Optional\
    \ Parameter    Length       Value\n         Label TLV             variable   \
    \  See below\n      The encodings for Label TLVs are found in Section \"Label\
    \ TLVs\".\n      Label\n         If present, the label being released (see procedures\
    \ below).\n"
- title: 3.5.11.1. Label Release Message Procedures
  contents:
  - "3.5.11.1. Label Release Message Procedures\n   An LSR transmits a Label Release\
    \ message to a peer when it is no\n   longer needs a label previously received\
    \ from or requested of that\n   peer.\n   An LSR must transmit a Label Release\
    \ message under any of the\n   following conditions:\n      1. The LSR which sent\
    \ the label mapping is no longer the next hop\n         for the mapped FEC, and\
    \ the LSR is configured for conservative\n         operation.\n      2. The LSR\
    \ receives a label mapping from an LSR which is not the\n         next hop for\
    \ the FEC, and the LSR is configured for\n         conservative operation.\n \
    \     3. The LSR receives a Label Withdraw message.\n   Note that if an LSR is\
    \ configured for \"liberal mode\", a release\n   message will never be transmitted\
    \ in the case of conditions (1) and\n   (2) as specified above.  In this case,\
    \ the upstream LSR keeps each\n   unused label, so that it can immediately be\
    \ used later if the\n   downstream peer becomes the next hop for the FEC.\n  \
    \ The FEC TLV specifies the FEC for which labels are to be released.\n   If no\
    \ Label TLV follows the FEC, all labels associated with the FEC\n   are to be\
    \ released; otherwise only the label specified in the\n   optional Label TLV is\
    \ to be released.\n   The FEC TLV may contain the Wildcard FEC Element; if so,\
    \ it may\n   contain no other FEC Elements.  In this case, if the Label Release\n\
    \   message contains an optional Label TLV, then the label is to be\n   released\
    \ for all FECs to which it is bound.  If there is not an\n   optional Label TLV\
    \ in the Label Release message, then the sending LSR\n   is releasing all label\
    \ mappings previously learned from the receiving\n   LSR.\n   See Appendix A \"\
    LDP Label Distribution Procedures\" for more details.\n"
- title: 3.6. Messages and TLVs for Extensibility
  contents:
  - "3.6. Messages and TLVs for Extensibility\n   Support for LDP extensibility includes\
    \ the rules for the U and F bits\n   that specify how an LSR should handle unknown\
    \ TLVs and messages.\n   This section specifies TLVs and messages for vendor-private\
    \ and\n   experimental use.\n"
- title: 3.6.1. LDP Vendor-private Extensions
  contents:
  - "3.6.1. LDP Vendor-private Extensions\n   Vendor-private TLVs and messages are\
    \ used to convey vendor-private\n   information between LSRs.\n"
- title: 3.6.1.1. LDP Vendor-private TLVs
  contents:
  - "3.6.1.1. LDP Vendor-private TLVs\n   The Type range 0x3E00 through 0x3EFF is\
    \ reserved for vendor-private\n   TLVs.\n   The encoding for a vendor-private\
    \ TLV is:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |U|F|    Type (0x3E00-0x3EFF)   |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Vendor ID                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \                         Data....                            |\n   ~        \
    \                                                       ~\n   |              \
    \                                                 |\n   |                    \
    \           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                          \
    \     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   U bit\n      Unknown TLV bit.\
    \  Upon receipt of an unknown TLV, if U is clear\n      (=0), a notification must\
    \ be returned to the message originator\n      and the entire message must be\
    \ ignored; if U is set (=1), the\n      unknown TLV is silently ignored and the\
    \ rest of the message is\n      processed as if the unknown TLV did not exist.\n\
    \      The determination as to whether a vendor-private message is\n      understood\
    \ is based on the Type and the mandatory Vendor ID field.\n   F bit\n      Forward\
    \ unknown TLV bit.  This bit only applies when the U bit is\n      set and the\
    \ LDP message containing the unknown TLV is is to be\n      forwarded.  If F is\
    \ clear (=0), the unknown TLV is not forwarded\n      with the containing message;\
    \ if F is set (=1), the unknown TLV is\n      forwarded with the containing message.\n\
    \   Type\n      Type value in the range 0x3E00 through 0x3EFF.  Together, the\
    \ Type\n      and Vendor Id field specify how the Data field is to be\n      interpreted.\n\
    \   Length\n      Specifies the cumulative length in octets of the Vendor ID and\n\
    \      Data fields.\n   Vendor Id\n      802 Vendor ID as assigned by the IEEE.\n\
    \   Data\n      The remaining octets after the Vendor ID in the Value field are\n\
    \      optional vendor-dependent data.\n"
- title: 3.6.1.2. LDP Vendor-private Messages
  contents:
  - "3.6.1.2. LDP Vendor-private Messages\n   The Message Type range 0x3E00 through\
    \ 0x3EFF is reserved for vendor-\n   private Messages.\n    0                \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |U|    Msg Type (0x3E00-0x3EFF) |      Message Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Message ID                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Vendor ID                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +                                                               +\n   |  \
    \                   Remaining Mandatory Parameters            |\n   +        \
    \                                                       +\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \             Optional Parameters                       |\n   +              \
    \                                                 +\n   |                    \
    \                                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   U bit\n      Unknown message bit.  Upon receipt of an unknown message, if\
    \ U is\n      clear (=0), a notification is returned to the message originator;\n\
    \      if U is set (=1), the unknown message is silently ignored.\n      The determination\
    \ as to whether a vendor-private message is\n      understood is based on the\
    \ Msg Type and the Vendor ID parameter.\n   Msg Type\n      Message type value\
    \ in the range 0x3E00 through 0x3EFF.  Together,\n      the Msg Type and the Vendor\
    \ ID specify how the message is to be\n      interpreted.\n   Message Length\n\
    \      Specifies the cumulative length in octets of the Message ID,\n      Vendor\
    \ ID, Remaining Mandatory Parameters and Optional Parameters.\n   Message ID\n\
    \      32-bit integer used to identify this message.  Used by the sending\n  \
    \    LSR to facilitate identifying notification messages that may apply\n    \
    \  to this message.  An LSR sending a notification message in\n      response\
    \ to this message will include this Message Id in the\n      notification message;\
    \ see Section \"Notification Message\".\n   Vendor ID\n      802 Vendor ID as\
    \ assigned by the IEEE.\n   Remaining Mandatory Parameters\n      Variable length\
    \ set of remaining required message parameters.\n   Optional Parameters\n    \
    \  Variable length set of optional message parameters.\n"
- title: 3.6.2. LDP Experimental Extensions
  contents:
  - "3.6.2. LDP Experimental Extensions\n   LDP support for experimentation is similar\
    \ to support for vendor-\n   private extensions with the following differences:\n\
    \      -  The Type range 0x3F00 through 0x3FFF is reserved for\n         experimental\
    \ TLVs.\n      -  The Message Type range 0x3F00 through 0x3FFF is reserved for\n\
    \         experimental messages.\n      -  The encodings for experimental TLVs\
    \ and messages are similar to\n         the vendor-private encodings with the\
    \ following difference.\n         Experimental TLVs and messages use an Experiment\
    \ ID field in\n         place of a Vendor ID field.  The Experiment ID field is\
    \ used\n         with the Type or Message Type field to specify the\n        \
    \ interpretation of the experimental TLV or Message.\n         Administration\
    \ of Experiment IDs is the responsibility of the\n         experimenters.\n"
- title: 3.7. Message Summary
  contents:
  - "3.7. Message Summary\n   The following are the LDP messages defined in this version\
    \ of the\n   protocol.\n      Message Name            Type     Section Title\n\
    \      Notification            0x0001   \"Notification Message\"\n      Hello\
    \                   0x0100   \"Hello Message\"\n      Initialization         \
    \ 0x0200   \"Initialization Message\"\n      KeepAlive               0x0201  \
    \ \"KeepAlive Message\"\n      Address                 0x0300   \"Address Message\"\
    \n      Address Withdraw        0x0301   \"Address Withdraw Message\"\n      Label\
    \ Mapping           0x0400   \"Label Mapping Message\"\n      Label Request  \
    \         0x0401   \"Label Request Message\"\n      Label Withdraw          0x0402\
    \   \"Label Withdraw Message\"\n      Label Release           0x0403   \"Label\
    \ Release Message\"\n      Label Abort Request     0x0404   \"Label Abort Request\
    \ Message\"\n      Vendor-Private          0x3E00-  \"LDP Vendor-private Extensions\"\
    \n                              0x3EFF\n      Experimental            0x3F00-\
    \  \"LDP Experimental Extensions\"\n                              0x3FFF\n"
- title: 3.8. TLV Summary
  contents:
  - "3.8. TLV Summary\n   The following are the TLVs defined in this version of the\
    \ protocol.\n      TLV                      Type      Section Title\n      FEC\
    \                      0x0100    \"FEC TLV\"\n      Address List             0x0101\
    \    \"Address List TLV\"\n      Hop Count                0x0103    \"Hop Count\
    \ TLV\"\n      Path Vector              0x0104    \"Path Vector TLV\"\n      Generic\
    \ Label            0x0200    \"Generic Label TLV\"\n      ATM Label          \
    \      0x0201    \"ATM Label TLV\"\n      Frame Relay Label        0x0202    \"\
    Frame Relay Label TLV\"\n      Status                   0x0300    \"Status TLV\"\
    \n      Extended Status          0x0301    \"Notification Message\"\n      Returned\
    \ PDU             0x0302    \"Notification Message\"\n      Returned Message \
    \        0x0303    \"Notification Message\"\n      Common Hello             0x0400\
    \    \"Hello Message\"\n         Parameters\n      IPv4 Transport Address   0x0401\
    \    \"Hello Message\"\n      Configuration            0x0402    \"Hello Message\"\
    \n         Sequence Number\n      IPv6 Transport Address   0x0403    \"Hello Message\"\
    \n      Common Session           0x0500    \"Initialization Message\"\n      \
    \   Parameters\n      ATM Session Parameters   0x0501    \"Initialization Message\"\
    \n      Frame Relay Session      0x0502    \"Initialization Message\"\n      \
    \   Parameters\n      Label Request            0x0600    \"Label Mapping Message\"\
    \n          Message ID\n      Vendor-Private           0x3E00-   \"LDP Vendor-private\
    \ Extensions\"\n                               0x3EFF\n      Experimental    \
    \         0x3F00-   \"LDP Experimental Extensions\"\n                        \
    \       0x3FFF\n"
- title: 3.9. Status Code Summary
  contents:
  - "3.9. Status Code Summary\n   The following are the Status Codes defined in this\
    \ version of the\n   protocol.\n   The \"E\" column is the required setting of\
    \ the Status Code E-bit; the\n   \"Status Data\" column is the value of the 30-bit\
    \ Status Data field in\n   the Status Code TLV.\n   Note that the setting of the\
    \ Status Code F-bit is at the discretion\n   of the LSR originating the Status\
    \ TLV.\n      Status Code           E   Status Data   Section Title\n      Success\
    \               0   0x00000000    \"Status TLV\"\n      Bad LDP Identifier   \
    \ 1   0x00000001    \"Events Signaled by ...\"\n      Bad Protocol Version  1\
    \   0x00000002    \"Events Signaled by ...\"\n      Bad PDU Length        1  \
    \ 0x00000003    \"Events Signaled by ...\"\n      Unknown Message Type  0   0x00000004\
    \    \"Events Signaled by ...\"\n      Bad Message Length    1   0x00000005  \
    \  \"Events Signaled by ...\"\n      Unknown TLV           0   0x00000006    \"\
    Events Signaled by ...\"\n      Bad TLV length        1   0x00000007    \"Events\
    \ Signaled by ...\"\n      Malformed TLV Value   1   0x00000008    \"Events Signaled\
    \ by ...\"\n      Hold Timer Expired    1   0x00000009    \"Events Signaled by\
    \ ...\"\n      Shutdown              1   0x0000000A    \"Events Signaled by ...\"\
    \n      Loop Detected         0   0x0000000B    \"Loop Detection\"\n      Unknown\
    \ FEC           0   0x0000000C    \"FEC Procedures\"\n      No Route         \
    \     0   0x0000000D    \"Label Request Mess ...\"\n      No Label Resources \
    \   0   0x0000000E    \"Label Request Mess ...\"\n      Label Resources /    \
    \ 0   0x0000000F    \"Label Request Mess ...\"\n          Available\n      Session\
    \ Rejected/     1   0x00000010    \"Session Initialization\"\n         No Hello\n\
    \      Session Rejected/     1   0x00000011    \"Session Initialization\"\n  \
    \       Parameters Advertisement Mode\n      Session Rejected/     1   0x00000012\
    \    \"Session Initialization\"\n         Parameters Max PDU Length\n      Session\
    \ Rejected/     1   0x00000013    \"Session Initialization\"\n         Parameters\
    \ Label Range\n      KeepAlive Timer       1   0x00000014    \"Events Signaled\
    \ by ...\"\n          Expired\n      Label Request Aborted 0   0x00000015    \"\
    Label Request Abort ...\"\n      Missing Message       0   0x00000016    \"Events\
    \ Signaled by ...\"\n          Parameters\n      Unsupported Address   0   0x00000017\
    \    \"FEC Procedures\"\n          Family                              \"Address\
    \ Message Proc ...\"\n      Session Rejected/     1   0x00000018    \"Session\
    \ Initialization\"\n         Bad KeepAlive Time\n      Internal Error        1\
    \   0x00000019    \"Events Signaled by ...\"\n"
- title: 3.10. Well-known Numbers
  contents:
  - '3.10. Well-known Numbers

    '
- title: 3.10.1. UDP and TCP Ports
  contents:
  - "3.10.1. UDP and TCP Ports\n   The UDP port for LDP Hello messages is 646.\n \
    \  The TCP port for establishing LDP session connections is 646.\n"
- title: 3.10.2. Implicit NULL Label
  contents:
  - "3.10.2. Implicit NULL Label\n   The Implicit NULL label (see [RFC3031]) is represented\
    \ as a Generic\n   Label TLV with a Label field value as specified by [RFC3032].\n"
- title: 4. IANA Considerations
  contents:
  - "4. IANA Considerations\n   LDP defines the following name spaces which require\
    \ management:\n      -  Message Type Name Space.\n      -  TLV Type Name Space.\n\
    \      -  FEC Type Name Space.\n      -  Status Code Name Space.\n      -  Experiment\
    \ ID Name Space.\n   The following sections provide guidelines for managing these\
    \ name\n   spaces.\n"
- title: 4.1. Message Type Name Space
  contents:
  - "4.1. Message Type Name Space\n   LDP divides the name space for message types\
    \ into three ranges.  The\n   following are the guidelines for managing these\
    \ ranges:\n      -  Message Types 0x0000 - 0x3DFF.  Message types in this range\
    \ are\n         part of the LDP base protocol.  Following the policies outlined\n\
    \         in [IANA], Message types in this range are allocated through an\n  \
    \       IETF Consensus action.\n      -  Message Types 0x3E00 - 0x3EFF.  Message\
    \ types in this range are\n         reserved for Vendor Private extensions and\
    \ are the\n         responsibility of the individual vendors (see Section \"LDP\n\
    \         Vendor-private Messages\").  IANA management of this range of\n    \
    \     the Message Type Name Space is unnecessary.\n      -  Message Types 0x3F00\
    \ - 0x3FFF.  Message types in this range are\n         reserved for Experimental\
    \ extensions and are the responsibility\n         of the individual experimenters\
    \ (see Sections \"LDP Experimental\n         Extensions\" and \"Experiment ID\
    \ Name Space\").  IANA management\n         of this range of the Message Type\
    \ Name Space is unnecessary;\n         however, IANA is responsible for managing\
    \ part of the\n         Experiment ID Name Space (see below).\n"
- title: 4.2. TLV Type Name Space
  contents:
  - "4.2. TLV Type Name Space\n   LDP divides the name space for TLV types into three\
    \ ranges.  The\n   following are the guidelines for managing these ranges:\n \
    \     -  TLV Types 0x0000 - 0x3DFF.  TLV types in this range are part of\n   \
    \      the LDP base protocol.  Following the policies outlined in\n         [IANA],\
    \ TLV types in this range are allocated through an IETF\n         Consensus action.\n\
    \      -  TLV Types 0x3E00 - 0x3EFF.  TLV types in this range are\n         reserved\
    \ for Vendor Private extensions and are the\n         responsibility of the individual\
    \ vendors (see Section \"LDP\n         Vendor-private TLVs\").  IANA management\
    \ of this range of the\n         TLV Type Name Space is unnecessary.\n      -\
    \  TLV Types 0x3F00 - 0x3FFF.  TLV types in this range are\n         reserved\
    \ for Experimental extensions and are the responsibility\n         of the individual\
    \ experimenters (see Sections \"LDP Experimental\n         Extensions\" and \"\
    Experiment ID Name Space\").  IANA management\n         of this range of the TLV\
    \ Name Space is unnecessary; however,\n         IANA is responsible for managing\
    \ part of the Experiment ID Name\n         Space (see below).\n"
- title: 4.3. FEC Type Name Space
  contents:
  - "4.3. FEC Type Name Space\n   The range for FEC types is 0 - 255.\n   Following\
    \ the policies outlined in [IANA], FEC types in the range 0 -\n   127 are allocated\
    \ through an IETF Consensus action, types in the\n   range 128 - 191 are allocated\
    \ as First Come First Served, and types\n   in the range 192 - 255 are reserved\
    \ for Private Use.\n"
- title: 4.4. Status Code Name Space
  contents:
  - "4.4. Status Code Name Space\n   The range for Status Codes is 0x00000000 - 0x3FFFFFFF.\n\
    \   Following the policies outlined in [IANA], Status Codes in the range\n   0x00000000\
    \ - 0x1FFFFFFF are allocated through an IETF Consensus\n   action, codes in the\
    \ range 0x20000000 - 0x3EFFFFFF are allocated as\n   First Come First Served,\
    \ and codes in the range 0x3F000000 -\n   0x3FFFFFFF are reserved for Private\
    \ Use.\n"
- title: 4.5. Experiment ID Name Space
  contents:
  - "4.5. Experiment ID Name Space\n   The range for Experiment Ids is 0x00000000\
    \ - 0xffffffff.\n   Following the policies outlined in [IANA], Experiment Ids\
    \ in the\n   range 0x00000000 - 0xefffffff are allocated as First Come First\n\
    \   Served and Experiment Ids in the range 0xf0000000 - 0xffffffff are\n   reserved\
    \ for Private Use.\n"
- title: 5. Security Considerations
  contents:
  - "5. Security Considerations\n   This section identifies threats to which LDP may\
    \ be vulnerable and\n   discusses means by which those threats might be mitigated.\n"
- title: 5.1. Spoofing
  contents:
  - "5.1. Spoofing\n   There are two types of LDP communication that could be the\
    \ target of\n   a spoofing attack.\n   1. Discovery exchanges carried by UDP.\n\
    \      LSRs directly connected at the link level exchange Basic Hello\n      messages\
    \ over the link.  The threat of spoofed Basic Hellos can be\n      reduced by:\n\
    \         o  Accepting Basic Hellos only on interfaces to which LSRs that\n  \
    \          can be trusted are directly connected.\n         o  Ignoring Basic\
    \ Hellos not addressed to the All Routers on\n            this Subnet multicast\
    \ group.\n      LSRs not directly connected at the link level may use Extended\n\
    \      Hello messages to indicate willingness to establish an LDP\n      session.\
    \  An LSR can reduce the threat of spoofed Extended Hellos\n      by filtering\
    \ them and accepting only those originating at sources\n      permitted by an\
    \ access list.\n   2. Session communication carried by TCP.\n      LDP specifies\
    \ use of the TCP MD5 Signature Option to provide for\n      the authenticity and\
    \ integrity of session messages.\n      [RFC2385] asserts that MD5 authentication\
    \ is now considered by\n      some to be too weak for this application.  It also\
    \ points out that\n      a similar TCP option with a stronger hashing algorithm\
    \ (it cites\n      SHA-1 as an example) could be deployed.  To our knowledge no\
    \ such\n      TCP option has been defined and deployed.  However, we note that\n\
    \      LDP can use whatever TCP message digest techniques are available,\n   \
    \   and when one stronger than MD5 is specified and implemented,\n      upgrading\
    \ LDP to use it would be relatively straightforward.\n"
- title: 5.2. Privacy
  contents:
  - "5.2. Privacy\n   LDP provides no mechanism for protecting the privacy of label\n\
    \   distribution.\n   The security requirements of label distribution protocols\
    \ are\n   essentially identical to those of the protocols which distribute\n \
    \  routing information.  By providing a mechanism to ensure the\n   authenticity\
    \ and integrity of its messages LDP provides a level of\n   security which is\
    \ at least as good as, though no better than, that\n   which can be provided by\
    \ the routing protocols themselves.  The more\n   general issue of whether privacy\
    \ should be required for routing\n   protocols is beyond the scope of this document.\n\
    \   One might argue that label distribution requires privacy to address\n   the\
    \ threat of label spoofing.  However, that privacy would not\n   protect against\
    \ label spoofing attacks since data packets carry\n   labels in the clear.  Furthermore,\
    \ label spoofing attacks can be made\n   without knowledge of the FEC bound to\
    \ a label.\n   To avoid label spoofing attacks, it is necessary to ensure that\n\
    \   labeled data packets are labeled by trusted LSRs and that the labels\n   placed\
    \ on the packets are properly learned by the labeling LSRs.\n"
- title: 5.3. Denial of Service
  contents:
  - "5.3. Denial of Service\n   LDP provides two potential targets for denial of service\
    \ (DoS)\n   attacks:\n   1. Well known UDP Port for LDP Discovery\n      An LSR\
    \ administrator can address the threat of DoS attacks via\n      Basic Hellos\
    \ by ensuring that the LSR is directly connected only\n      to peers which can\
    \ be trusted to not initiate such an attack.\n      Interfaces to peers interior\
    \ to the administrator's domain should\n      not represent a threat since interior\
    \ peers are under the\n      administrator's control.  Interfaces to peers exterior\
    \ to the\n      domain represent a potential threat since exterior peers are not.\n\
    \      An administrator can reduce that threat by connecting the LSR only\n  \
    \    to exterior peers that can be trusted to not initiate a Basic\n      Hello\
    \ attack.\n      DoS attacks via Extended Hellos are potentially a more serious\n\
    \      threat.  This threat can be addressed by filtering Extended Hellos\n  \
    \    using access lists that define addresses with which extended\n      discovery\
    \ is permitted.  However, performing the filtering\n      requires LSR resource.\n\
    \      In an environment where a trusted MPLS cloud can be identified,\n     \
    \ LSRs at the edge of the cloud can be used to protect interior LSRs\n      against\
    \ DoS attacks via Extended Hellos by filtering out Extended\n      Hellos originating\
    \ outside of the trusted MPLS cloud, accepting\n      only those originating at\
    \ addresses permitted by access lists.\n      This filtering protects LSRs in\
    \ the interior of the cloud but\n      consumes resources at the edges.\n   2.\
    \ Well known TCP port for LDP Session Establishment\n      Like other control\
    \ plane protocols that use TCP, LDP may be the\n      target of DoS attacks, such\
    \ a SYN attacks.  LDP is no more or less\n      vulnerable to such attacks than\
    \ other control plane protocols that\n      use TCP.\n      The threat of such\
    \ attacks can be mitigated somewhat by the\n      following:\n         o  An LSR\
    \ should avoid promiscuous TCP listens for LDP session\n            establishment.\
    \  It should use only listens that are specific\n            to discovered peers.\
    \  This enables it to drop attack packets\n            early in their processing\
    \ since they are less likely to\n            match existing or in-progress connections.\n\
    \         o  The use of the MD5 option helps somewhat since it prevents a\n  \
    \          SYN from being accepted unless the MD5 segment checksum is\n      \
    \      valid.  However, the receiver must compute the checksum\n            before\
    \ it can decide to discard an otherwise acceptable SYN\n            segment.\n\
    \         o  The use of access list mechanisms applied at the boundary of\n  \
    \          the MPLS cloud in a manner similar to that suggested above\n      \
    \      for Extended Hellos can protect the interior against attacks\n        \
    \    originating from outside the cloud.\n"
- title: 6. Areas for Future Study
  contents:
  - "6. Areas for Future Study\n   The following topics not addressed in this version\
    \ of LDP are\n   possible areas for future study:\n      -  Section 2.16 of the\
    \ MPLS architecture [RFC3031] requires that\n         the initial label distribution\
    \ protocol negotiation between\n         peer LSRs enable each LSR to determine\
    \ whether its peer is\n         capable of popping the label stack.  This version\
    \ of LDP\n         assumes that LSRs support label popping for all link types\n\
    \         except ATM and Frame Relay.  A future version may specify means\n  \
    \       to make this determination part of the session initiation\n         negotiation.\n\
    \      -  LDP support for CoS is not specified in this version.  CoS\n       \
    \  support may be addressed in a future version.\n      -  LDP support for multicast\
    \ is not specified in this version.\n         Multicast support may be addressed\
    \ in a future version.\n      -  LDP support for multipath label switching is\
    \ not specified in\n         this version.  Multipath support may be addressed\
    \ in a future\n         version.\n"
- title: 7. Intellectual Property Considerations
  contents:
  - "7. Intellectual Property Considerations\n   The IETF has been notified of intellectual\
    \ property rights claimed in\n   regard to some or all of the specification contained\
    \ in this\n   document.  For more information consult the online list of claimed\n\
    \   rights.\n"
- title: 8. Acknowledgments
  contents:
  - "8. Acknowledgments\n   The ideas and text in this document have been collected\
    \ from a number\n   of sources.  We would like to thank Rick Boivie, Ross Callon,\
    \ Alex\n   Conta, Eric Gray, Yoshihiro Ohba, Eric Rosen, Bernard Suter, Yakov\n\
    \   Rekhter, and Arun Viswanathan.\n"
- title: 9. References
  contents:
  - "9. References\n   [ATM-VP]    N. Feldman, B. Jamoussi, S. Komandur, A, Viswanathan,\
    \ T\n               Worster, \"MPLS using ATM VP Switching\", Work in Progress.\n\
    \   [CRLDP]     L. Andersson, A. Fredette, B. Jamoussi, R. Callon, P.\n      \
    \         Doolan, N. Feldman, E. Gray, J. Halpern, J. Heinanen T.\n          \
    \     E. Kilty, A. G.  Malis, M. Girish, K. Sundell, P.\n               Vaananen,\
    \ T. Worster, L. Wu, R.  Dantu, \"Constraint-Based\n               LSP Setup using\
    \ LDP\", Work in Progress.\n   [DIFFSERV]  Blake, S., Black, D., Carlson, M.,\
    \ Davies, E., Wang, Z.\n               and W. Weiss, \"An Architecture for Differentiated\n\
    \               Services\", RFC 2475, December 1998.\n   [IANA]      Narten, T.\
    \ and H. Alvestrand, \"Guidelines for Writing an\n               IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC 2434,\n               October 1998.\n   [RFC1321]\
    \   Rivest, R., \"The MD5 Message-Digest Algorithm,\" RFC 1321,\n            \
    \   April 1992.\n   [RFC1483]   Heinanen, J., \"Multiprotocol Encapsulation over\
    \ ATM\n               Adaptation Layer 5\", RFC 1483, July 1993.\n   [RFC2328]\
    \   Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, April 1998.\n   [RFC1700] \
    \  Reynolds, J. and J. Postel, \"ASSIGNED NUMBERS\", STD 2,\n               RFC\
    \ 1700, October 1994.\n   [RFC1771]   Rekhter, Y. and T. Li, \"A Border Gateway\
    \ Protocol 4\n               (BGP-4)\", RFC 1771, March 1995.\n   [RFC2119]  \
    \ Bradner, S., \"Key words for use in RFCs to Indicate\n               Requirement\
    \ Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2205]   Braden, R., Zhang, L.,\
    \ Berson, S., Herzog, S. and S.\n               Jamin, \"Resource ReSerVation\
    \ Protocol (RSVP) -- Version 1\n               Functional Specification\", RFC\
    \ 2205, September 1997.\n   [RFC2385]   Heffernan, A., \"Protection of BGP Sessions\
    \ via the TCP\n               MD5 Signature Option\", RFC 2385, August 1998.\n\
    \   [RFC2702]   Awduche, D., Malcolm, J., Agogbua, J., O'Dell, M. and J.\n   \
    \            McManus, \"Requirements for Traffic Engineering over\n          \
    \     MPLS\", RFC 2702, September 1999.\n   [RFC3031]   Rosen, E., Viswanathan,\
    \ A. and R. Callon, \"Multiprotocol\n               Label Switching Architecture\"\
    , RFC 3031, January 2001.\n   [RFC3032]   Rosen, E., Rekhter, Y., Tappan, D.,\
    \ Farinacci, D.,\n               Fedorkow, G.,  Li, T. and A. Conta, \"MPLS Label\
    \ Stack\n               Encoding\", RFC 3032, January 2001.\n   [RFC3034]   Conta,\
    \ A., Doolan, P. and A. Malis, \"Use of Label\n               Switching on Frame\
    \ Relay Networks Specification\", RFC\n               3034, January 2001.\n  \
    \ [RFC3035]   Davie, B., Lawrence, J., McCloghrie, K., Rekhter, Y.,\n        \
    \       Rosen, E., Swallow, G. and P. Doolan, \"MPLS using LDP and\n         \
    \      ATM VC Switching\", RFC 3035, January 2001.\n   [RFC3037]   Thomas, B.\
    \ and E. Gray, \"LDP Applicability\", RFC 3037,\n               January 2001.\n"
- title: 10. Authors' Addresses
  contents:
  - "10. Authors' Addresses\n   Loa Andersson\n   Nortel Networks Inc\n   St Eriksgatan\
    \ 115, PO Box 6701\n   113 85 Stockholm\n   Sweden\n   Phone: +46 8 5088 36 34\n\
    \   Mobile: +46 70 522 78 34\n   EMail: loa.andersson@nortelnetworks.com\n   Paul\
    \ Doolan\n   Ennovate Networks\n   60 Codman Hill Rd\n   Marlborough MA 01719\n\
    \   Phone: 978-263-2002\n   EMail: pdoolan@ennovatenetworks.com\n   Nancy Feldman\n\
    \   IBM Research\n   30 Saw Mill River Road\n   Hawthorne, NY 10532\n   Phone:\
    \  914-784-3254\n   EMail: nkf@us.ibm.com\n   Andre Fredette\n   PhotonEx Corporation\n\
    \   8C Preston Court\n   Bedford, MA 01730\n   Phone: 781-301-4655\n   EMail:\
    \ fredette@photonex.com\n   Bob Thomas\n   Cisco Systems, Inc.\n   250 Apollo\
    \ Dr.\n   Chelmsford, MA 01824\n   Phone:  978-244-8078\n   EMail: rhthomas@cisco.com\n"
- title: Appendix A. LDP Label Distribution Procedures
  contents:
  - "Appendix A. LDP Label Distribution Procedures\n   This section specifies label\
    \ distribution behavior in terms of LSR\n   response to the following events:\n\
    \      -  Receive Label Request Message;\n      -  Receive Label Mapping Message;\n\
    \      -  Receive Label Abort Request Message;\n      -  Receive Label Release\
    \ Message;\n      -  Receive Label Withdraw Message;\n      -  Recognize new FEC;\n\
    \      -  Detect change in FEC next hop;\n      -  Receive Notification Message\
    \ / Label Request Aborted;\n      -  Receive Notification Message / No Label Resources;\n\
    \      -  Receive Notification Message / No Route;\n      -  Receive Notification\
    \ Message / Loop Detected;\n      -  Receive Notification Message / Label Resources\
    \ Available;\n      -  Detect local label resources have become available;\n \
    \     -  LSR decides to no longer label switch a FEC;\n      -  Timeout of deferred\
    \ label request.\n   The specification of LSR behavior in response to an event\
    \ has three\n   parts:\n      1. Summary.  Prose that describes LSR response to\
    \ the event in\n         overview.\n      2. Context.  A list of elements referred\
    \ to by the Algorithm part\n         of the specification.  (See 3.)\n      3.\
    \ Algorithm.  An algorithm for LSR response to the event.\n   The Summary may\
    \ omit details of the LSR response, such as bookkeeping\n   action or behavior\
    \ dependent on the LSR label advertisement mode,\n   control mode, or label retention\
    \ mode in use.  The intent is that the\n   Algorithm fully and unambiguously specify\
    \ the LSR response.\n   The algorithms in this section use procedures defined\
    \ in the MPLS\n   architecture specification [RFC3031] for hop-by-hop routed traffic.\n\
    \   These procedures are:\n      -  Label Distribution procedure, which is performed\
    \ by a\n         downstream LSR to determine when to distribute a label for a\n\
    \         FEC to LDP peers.  The architecture defines four Label\n         Distribution\
    \ procedures:\n         .  Downstream Unsolicited Independent Control, called\n\
    \            PushUnconditional in [RFC3031].\n         .  Downstream Unsolicited\
    \ Ordered Control, called\n            PushConditional in [RFC3031].\n       \
    \  .  Downstream On Demand Independent Control, called\n            PulledUnconditional\
    \ in [RFC3031].\n         .  Downstream On Demand Ordered Control, called\n  \
    \          PulledConditional in [RFC3031].\n      -  Label Withdrawal procedure,\
    \ which is performed by a downstream\n         LSR to determine when to withdraw\
    \ a FEC label mapping\n         previously distributed to LDP peers.  The architecture\
    \ defines\n         a single Label Withdrawal procedure.  Whenever an LSR breaks\n\
    \         the binding between a label and a FEC, it must withdraw the FEC\n  \
    \       label mapping from all LDP peers to which it has previously\n        \
    \ sent the mapping.\n      -  Label Request procedure, which is performed by an\
    \ upstream LSR\n         to determine when to explicitly request that a downstream\
    \ LSR\n         bind a label to a FEC and send it the corresponding label\n  \
    \       mapping.  The architecture defines three Label Request\n         procedures:\n\
    \         .  Request Never.  The LSR never requests a label.\n         .  Request\
    \ When Needed.  The LSR requests a label whenever\n            it needs one.\n\
    \         .  Request On Request.  This procedure is used by\n            non-label\
    \ merging LSRs.  The LSR requests a label\n            when it receives a request\
    \ for one, in addition\n            to whenever it needs one.\n      -  Label\
    \ Release procedure, which is performed by an upstream LSR\n         to determine\
    \ when to release a previously received label\n         mapping for a FEC.  The\
    \ architecture defines two Label Release\n         procedures:\n         .  Conservative\
    \ label retention, called Release On Change in\n            [RFC3031].\n     \
    \    .  Liberal label retention, called No Release On Change in\n            [RFC3031].\n\
    \      -  Label Use procedure, which is performed by an LSR to determine\n   \
    \      when to start using a FEC label for forwarding/switching.  The\n      \
    \   architecture defines three Label Use procedures:\n         .  Use Immediate.\
    \  The LSR immediately uses a label received\n            from a FEC next hop\
    \ for forwarding/switching.\n         .  Use If Loop Free.  The LSR uses a FEC\
    \ label received from a\n            FEC next hop for forwarding/switching only\
    \ if it has\n            determined that by doing so it will not cause a forwarding\n\
    \            loop.\n         .  Use If Loop Not Detected.  This procedure is the\
    \ same as Use\n            Immediate unless the LSR has detected a loop in the\
    \ FEC LSP.\n            Use of the FEC label for forwarding/switching will continue\n\
    \            until the next hop for the FEC changes or the loop is no\n      \
    \      longer detected.\n         This version of LDP does not include a loop\
    \ prevention\n         mechanism; therefore, the procedures below do not make\
    \ use of\n         the Use If Loop Free procedure.\n      -  Label No Route procedure\
    \ (called Label Not Available procedure\n         in [RFC3031]), which is performed\
    \ by an upstream LSR to\n         determine how to respond to a No Route notification\
    \ from a\n         downstream LSR in response to a request for a FEC label\n \
    \        mapping.  The architecture specification defines two Label No\n     \
    \    Route procedures:\n         .  Request Retry.  The LSR should issue the label\
    \ request at a\n            later time.\n         .  No Request Retry.  The LSR\
    \ should assume the downstream LSR\n            will provide a label mapping when\
    \ the downstream LSR has a\n            next hop and it should not reissue the\
    \ request.\n"
- title: A.1. Handling Label Distribution Events
  contents:
  - "A.1. Handling Label Distribution Events\n   This section defines LDP label distribution\
    \ procedures by specifying\n   an algorithm for each label distribution event.\
    \  The requirement on\n   an LDP implementation is that its event handling must\
    \ have the effect\n   specified by the algorithms.  That is, an implementation\
    \ need not\n   follow exactly the steps specified by the algorithms as long as\
    \ the\n   effect is identical.\n   The algorithms for handling label distribution\
    \ events share common\n   actions.  The specifications below package these common\
    \ actions into\n   procedure units.  Specifications for these common procedures\
    \ are in\n   their own section \"Common Label Distribution Procedures\", which\n\
    \   follows this.\n   An implementation would use data structures to store information\n\
    \   about protocol activity.  This appendix specifies the information to\n   be\
    \ stored in sufficient detail to describe the algorithms, and\n   assumes the\
    \ ability to retrieve the information as needed.  It does\n   not specify the\
    \ details of the data structures.\n"
- title: A.1.1. Receive Label Request
  contents:
  - "A.1.1. Receive Label Request\n   Summary:\n      The response by an LSR to receipt\
    \ of a FEC label request from an\n      LDP peer may involve one or more of the\
    \ following actions:\n      -  Transmission of a notification message to the requesting\
    \ LSR\n         indicating why a label mapping for the FEC cannot be provided;\n\
    \      -  Transmission of a FEC label mapping to the requesting LSR;\n      -\
    \  Transmission of a FEC label request to the FEC next hop;\n      -  Installation\
    \ of labels for forwarding/switching use by the LSR.\n   Context:\n      -  LSR.\
    \  The LSR handling the event.\n      -  MsgSource.  The LDP peer that sent the\
    \ message.\n      -  FEC.  The FEC specified in the message.\n      -  RAttributes.\
    \  Attributes received with the message.  E.g., Hop\n         Count, Path Vector.\n\
    \      -  SAttributes.  Attributes to be included in Label Request\n         message,\
    \ if any, propagated to FEC Next Hop.\n      -  StoredHopCount.  The hop count,\
    \ if any, previously recorded for\n         the FEC.\n   Algorithm:\n      LRq.1\
    \   Execute procedure Check_Received_Attributes (MsgSource,\n              LabelRequest,\
    \ RAttributes).\n              If Loop Detected, goto LRq.13.\n      LRq.2   Is\
    \ there a Next Hop for FEC?\n              If not, goto LRq.5.\n      LRq.3  \
    \ Is MsgSource the Next Hop?\n              Ifnot, goto LRq.6.\n      LRq.4  \
    \ Execute procedure Send_Notification (MsgSource, Loop\n              Detected).\n\
    \              Goto LRq.13\n      LRq.5   Execute procedure Send_Notification\
    \ (MsgSource, No Route).\n              Goto LRq.13.\n      LRq.6   Has LSR previously\
    \ received a label request for FEC from\n              MsgSource?\n          \
    \    If not, goto LRq.8.  (See Note 1.)\n      LRq.7   Is the label request a\
    \ duplicate request?\n              If so, Goto LRq.13.  (See Note 2.)\n     \
    \ LRq.8   Record label request for FEC received from MsgSource and\n         \
    \     mark it pending.\n      LRq.9   Perform LSR Label Distribution procedure:\n\
    \            For Downstream Unsolicited Independent Control OR\n            For\
    \ Downstream On Demand Independent Control\n               1. Has LSR previously\
    \ received and retained a label\n                  mapping for FEC from Next Hop?.\n\
    \                  Is so, set Propagating to IsPropagating.\n                \
    \  If not, set Propagating to NotPropagating.\n               2. Execute procedure\n\
    \                  Prepare_Label_Mapping_Attributes(MsgSource, FEC,\n        \
    \          RAttributes, SAttributes, Propagating,\n                  StoredHopCount).\n\
    \               3. Execute procedure Send_Label (MsgSource, FEC,\n           \
    \       SAttributes).\n               4. Is LSR egress for FEC? OR\n         \
    \         Has LSR previously received and retained a label\n                 \
    \ mapping for FEC from Next Hop?\n                  If so, goto LRq.11.\n    \
    \              If not, goto LRq.10.\n            For Downstream Unsolicited Ordered\
    \ Control OR\n            For Downstream On Demand Ordered Control\n         \
    \      1. Is LSR egress for FEC? OR\n                  Has LSR previously received\
    \ and retained a label\n                  mapping for FEC from Next Hop?  (See\
    \ Note 3.)\n                  If not, goto LRq.10.\n               2. Execute\
    \ procedure\n                  Prepare_Label_Mapping_Attributes(MsgSource, FEC,\n\
    \                  RAttributes, SAttributes, IsPropagating,\n                \
    \  StoredHopCount)\n               3. Execute procedure Send_Label (MsgSource,\
    \ FEC,\n                  SAttributes).\n                  Goto LRq.11.\n    \
    \  LRq.10  Perform LSR Label Request procedure:\n            For Request Never\n\
    \               1. Goto LRq.13.\n            For Request When Needed OR\n    \
    \        For Request On Request\n               1. Execute procedure Prepare_Label_Request_Attributes\n\
    \                  (Next Hop, FEC, RAttributes, SAttributes);\n              \
    \ 2. Execute procedure Send_Label_Request (Next Hop, FEC,\n                  SAttributes).\n\
    \                  Goto LRq.13.\n      LRq.11  Has LSR successfully sent a label\
    \ for FEC to MsgSource?\n              If not, goto LRq.13.  (See Note 4.)\n \
    \     LRq.12  Perform LSR Label Use procedure.\n            For Use Immediate\
    \ OR\n            For Use If Loop Not Detected\n               1. Install label\
    \ sent to MsgSource and label from Next\n                  Hop (if LSR is not\
    \ egress) for forwarding/switching\n                  use.\n      LRq.13  DONE\n\
    \   Notes:\n      1. In the case where MsgSource is a non-label merging LSR it\
    \ will\n         send a label request for each upstream LDP peer that has\n  \
    \       requested a label for FEC from it.  The LSR must be able to\n        \
    \ distinguish such requests from a non-label merging MsgSource\n         from\
    \ duplicate label requests.\n         The LSR uses the message ID of received\
    \ Label Request messages\n         to detect duplicate requests.  This means that\
    \ an LSR (the\n         upstream peer) may not reuse the message ID used for a\
    \ Label\n         Request until the Label Request transaction has completed.\n\
    \      2. When an LSR sends a label request to a peer it records that the\n  \
    \       request has been sent and marks it as outstanding.  As long as\n     \
    \    the request is marked outstanding the LSR should not send\n         another\
    \ request for the same label to the peer.  Such a second\n         request would\
    \ be a duplicate.  The Send_Label_Request procedure\n         described below\
    \ obeys this rule.\n         A duplicate label request is considered a protocol\
    \ error and\n         should be dropped by the receiving LSR (perhaps with a suitable\n\
    \         notification returned to MsgSource).\n      3. If LSR is not merge-capable,\
    \ this test will fail.\n      4. The Send_Label procedure may fail due to lack\
    \ of label\n         resources, in which case the LSR should not perform the Label\n\
    \         Use procedure.\n"
- title: A.1.2. Receive Label Mapping
  contents:
  - "A.1.2. Receive Label Mapping\n   Summary:\n      The response by an LSR to receipt\
    \ of a FEC label mapping from an\n      LDP peer may involve one or more of the\
    \ following actions:\n      -  Transmission of a label release message for the\
    \ FEC label to\n         the LDP peer;\n      -  Transmission of label mapping\
    \ messages for the FEC to one or\n         more LDP peers,\n      -  Installation\
    \ of the newly learned label for\n         forwarding/switching use by the LSR.\n\
    \   Context:\n      -  LSR.  The LSR handling the event.\n      -  MsgSource.\
    \  The LDP peer that sent the message.\n      -  FEC.  The FEC specified in the\
    \ message.\n      -  Label.  The label specified in the message.\n      -  PrevAdvLabel.\
    \  The label for FEC, if any, previously advertised\n         to an upstream peer.\n\
    \      -  StoredHopCount.  The hop count previously recorded for the FEC.\n  \
    \    -  RAttributes.  Attributes received with the message.  E.g., Hop\n     \
    \    Count, Path Vector.\n      -  SAttributes to be included in Label Mapping\
    \ message, if any,\n         propagated to upstream peers.\n   Algorithm:\n  \
    \    LMp.1   Does the received label mapping match an outstanding\n          \
    \    label request for FEC previously sent to MsgSource.\n              If not,\
    \ goto LMp.3.\n      LMp.2   Delete record of outstanding FEC label request.\n\
    \      LMp.3   Execute procedure Check_Received_Attributes (MsgSource,\n     \
    \         LabelMapping, RAttributes).\n              If No Loop Detected, goto\
    \ LMp.9.\n      LMp.4   Does the LSR have a previously received label mapping\
    \ for\n              FEC from MsgSource? (See Note 1.)\n              If not,\
    \ goto LMp.8.  (See Note 2.)\n      LMp.5   Does the label previously received\
    \ from MsgSource match\n              Label (i.e., the label received in the message)?\n\
    \              (See Note 3.)\n              If not, goto LMp.8.  (See Note 4.)\n\
    \      LMp.6   Delete matching label mapping for FEC previously\n            \
    \  received from MsgSource.\n      LMp.7   Remove Label from forwarding/switching\
    \ use.  (See Note 5.)\n              Goto LMp.33.\n      LMp.8   Execute procedure\
    \ Send_Message (MsgSource, Label Release,\n              FEC, Label, Loop Detected\
    \ Status code).  Goto LMp.33.\n      LMp.9   Does LSR have a previously received\
    \ label mapping for FEC\n              from MsgSource for the LSP in question?\
    \  (See Note 6.)\n              If not, goto LMp.11.\n      LMp.10  Does the label\
    \ previously received from MsgSource match\n              Label (i.e., the label\
    \ received in the message)?\n              (See Note 3.)\n              If not,\
    \ goto LMp.32.  (See Note 4.)\n      LMp.11  Determine the Next Hop for FEC.\n\
    \      LMp.12  Is MsgSource the Next Hop for FEC?\n              If so, goto LMp.14.\n\
    \      LMp.13  Perform LSR Label Release procedure:\n            For Conservative\
    \ Label retention:\n              1. Goto LMp.32.\n            For Liberal Label\
    \ retention:\n              1. Record label mapping for FEC with Label and\n \
    \                RAttributes has been received from MsgSource.\n             \
    \    Goto LMp.33.\n      LMp.14  Is LSR an ingress for FEC?\n              If\
    \ not, goto LMp.16.\n      LMp.15  Install Label for forwarding/switching use.\n\
    \      LMp.16  Record label mapping for FEC with Label and RAttributes\n     \
    \         has been received from MsgSource.\n      LMp.17  Iterate through LMp.31\
    \ for each Peer.  (See Note 7).\n      LMp.18  Has LSR previously sent a label\
    \ mapping for FEC to Peer\n              for the LSP in question?  (See Note 8.)\n\
    \              If so, goto LMp.22.\n      LMp.19  Is the Downstream Unsolicited\
    \ Ordered Control Label\n              Distribution procedure being used by LSR?\
    \  If not, goto\n              LMp.28.\n      LMp.20  Execute procedure Prepare_Label_Mapping_Attributes(Peer,\n\
    \              FEC, RAttributes, SAttributes, IsPropagating,\n              StoredHopCount).\n\
    \      LMp.21  Execute procedure Send_Message (Peer, Label Mapping, FEC,\n   \
    \           PrevAdvLabel, SAttributes).\n              Goto LMp.28\n      LMp.22\
    \  Iterate through LMp.27 for each label mapping for FEC\n              previously\
    \ sent to Peer.\n      LMp.23  Are RAttributes in the received label mapping consistent\n\
    \              with those previously sent to Peer?\n              If so, continue\
    \ iteration from LMp.22 for next label\n              mapping. (See Note 9.)\n\
    \      LMp.24  Execute procedure Prepare_Label_Mapping_Attributes(Peer,\n    \
    \          FEC, RAttributes, SAttributes, IsPropagating,\n              StoredHopCount).\n\
    \      LMp.25  Execute procedure Send_Message (Peer, Label Mapping, FEC,\n   \
    \           PrevAdvLabel, SAttributes).  (See Note 10.)\n      LMp.26  Update\
    \ record of label mapping for FEC previously sent to\n              Peer to include\
    \ the new attributes sent.\n      LMp.27  End iteration from LMp.22.\n      LMp.28\
    \  Does LSR have any label requests for FEC from Peer marked\n              as\
    \ pending?\n              If not, goto LMp.30.\n      LMp.29  Perform LSR Label\
    \ Distribution procedure:\n            For Downstream Unsolicited Independent\
    \ Control OR\n            For Downstream Unsolicited Ordered Control\n       \
    \       1. Execute procedure\n                 Prepare_Label_Mapping_Attributes(Peer,\
    \ FEC,\n                 RAttributes, SAttributes, IsPropagating,\n          \
    \       UnknownHopCount).\n              2. Execute procedure Send_Label (Peer,\
    \ FEC, SAttributes).\n                 If the procedure fails, continue iteration\
    \ for\n                 next Peer at LMp.17.\n              3. If no pending requests\
    \ exist for Peer goto LMp.30.\n                 (See Note 11.)\n            For\
    \ Downstream On Demand Independent Control OR\n            For Downstream On Demand\
    \ Ordered Control\n              1. Iterate through Step 5 for each pending label\n\
    \                 request for FEC from Peer marked as pending.\n             \
    \ 2. Execute procedure\n                 Prepare_Label_Mapping_Attributes(Peer,\
    \ FEC,\n                 RAttributes, SAttributes, IsPropagating,\n          \
    \       UnknownHopCount)\n              3. Execute procedure Send_Label (Peer,\
    \ FEC,\n                 SAttributes).\n                 If the procedure fails,\
    \ continue iteration for next\n                 Peer at LMp.17.\n            \
    \  4. Delete record of pending request.\n              5. End iteration from Step\
    \ 1.\n              6. Goto LMp.30.\n      LMp.30  Perform LSR Label Use procedure:\n\
    \            For Use Immediate OR\n            For Use If Loop Not Detected\n\
    \              1. Iterate through Step 3 for each label mapping for\n        \
    \         FEC previously sent to Peer.\n              2. Install label received\
    \ and label sent to Peer for\n                 forwarding/switching use.\n   \
    \           3. End iteration from Step 1.\n              4. Goto LMp.31.\n   \
    \   LMp.31  End iteration from LMp.17.\n              Go to LMp.33.\n      LMp.32\
    \  Execute procedure Send_Message (MsgSource, Label Release,\n              FEC,\
    \ Label).\n      LMp.33  DONE.\n   Notes:\n      1.  If the LSR is merging there\
    \ should be at most 1 received\n          mapping for the FEC for the LSP in question.\
    \  In the non-\n          merging case there could be multiple received mappings\
    \ for the\n          FEC for the LSP in question.\n      2.  If LSR has detected\
    \ a loop and it has not previously received\n          a label mapping from MsgSource\
    \ for the FEC, it simply releases\n          the label.\n      3.  Does the Label\
    \ received in the message match any of the 1 or\n          more label mappings\
    \ identified in the previous step (LMp.4 or\n          LMp.9)?\n      4.  An unsolicited\
    \ mapping with a different label from the same\n          peer would be an attempt\
    \ to establish multipath label\n          switching, which is not supported in\
    \ this version of LDP.\n      5.  If Label is not in forwarding/switching use,\
    \ LMp.7 has no\n          effect.\n      6.  If the received label mapping message\
    \ matched an outstanding\n          label request in LMp.1, then (by definition)\
    \ LSR has not\n          previously received a label mapping for FEC for the LSP\
    \ in\n          question.  If the LSR is merging upstream labels for the LSP\n\
    \          in question, there should be at most 1 received mapping.  In\n    \
    \      the non-merging case, there could be multiple received label\n        \
    \  mappings for the same FEC, one for each resulting LSP.\n      7.  The LMp.17\
    \ iteration includes MsgSource in order to handle the\n          case where LSR\
    \ is operating in Downstream Unsolicited ordered\n          control mode.  Ordered\
    \ control prevents LSR from advertising a\n          label for FEC until it has\
    \ received a label mapping from its\n          next hop (MsgSource) for FEC.\n\
    \      8.  If LSR is merging the LSP it may have previously sent label\n     \
    \     mappings for the FEC LSP to one or more peers.  If LSR is not\n        \
    \  merging, it may have sent a label mapping for the LSP in\n          question\
    \ to at most one LSR.\n      9.  The loop detection Path Vector attribute is considered\
    \ in this\n          check.  If the received RAttributes include a Path Vector\
    \ and\n          no Path Vector had been previously sent to the Peer, or if the\n\
    \          received Path Vector is inconsistent with the Path Vector\n       \
    \   previously sent to the Peer, then the attributes are\n          considered\
    \ to be inconsistent.  Note that an LSR is not\n          required to store a\
    \ received Path Vector after it propagates\n          the Path Vector in a mapping\
    \ message.  If an LSR does not\n          store the Path Vector, it has no way\
    \ to check the consistency\n          of a newly received Path Vector.  This means\
    \ that whenever\n          such an LSR receives a mapping message carrying a Path\
    \ Vector\n          it must always propagate the Path Vector.\n      10. LMp.22\
    \ through LMp.27 deal with a situation that can arise\n          when the LSR\
    \ is using independent control and it receives a\n          mapping from the downstream\
    \ peer after it has sent a mapping\n          to an upstream peer.  In this situation\
    \ the LSR needs to\n          propagate any changed attributes, such as Hop Count,\
    \ upstream.\n          If Loop Detection is configured on, the propagated attributes\n\
    \          must include the Path Vector\n      11. An LSR operating in Downstream\
    \ Unsolicited mode must process\n          any Label Request messages it receives.\
    \  If there are pending\n          label requests, fall through into the Downstream\
    \ on Demand\n          procedures in order to satisfy the pending requests.\n"
- title: A.1.3. Receive Label Abort Request
  contents:
  - "A.1.3. Receive Label Abort Request\n   Summary:\n      When an LSR receives a\
    \ label abort request message from a peer, it\n      checks whether it has already\
    \ responded to the label request in\n      question. If it has, it silently ignores\
    \ the message.  If it has\n      not, it sends the peer a Label Request Aborted\
    \ Notification.  In\n      addition, if it has a label request outstanding for\
    \ the LSP in\n      question to a downstream peer, it sends a Label Abort Request\
    \ to\n      the downstream peer to abort the LSP.\n   Context:\n      -  LSR.\
    \  The LSR handling the event.\n      -  MsgSource.  The LDP peer that sent the\
    \ message.\n      -  FEC.  The FEC specified in the message.\n      -  RequestMessageID.\
    \  The message ID of the label request message\n         to be aborted.\n    \
    \  -  Next Hop.  The next hop for the FEC.\n   Algorithm:\n      LAbR.1  Does\
    \ the message match a previously received label request\n              message\
    \ from MsgSource? (See Note 1.)\n              If not, goto LAbR.12.\n      LAbR.2\
    \  Has LSR responded to the previously received label\n              request?\n\
    \              If so, goto LAbR.12.\n      LAbR.3  Execute procedure Send_Message(MsgSource,\
    \ Notification,\n              Label Request Aborted, TLV), where TLV is the Label\n\
    \              Request Message ID TLV received in the label abort\n          \
    \    request message.\n      LAbR.4  Does LSR have a label request message outstanding\
    \ for\n              FEC?\n              If so, goto LAbR.7\n      LAbR.5  Does\
    \ LSR have a label mapping for FEC?\n              If not, goto LAbR.11\n    \
    \  LAbR.6  Generate Event: Received Label Release Message for FEC\n          \
    \    from MsgSource.  (See Note 2.)\n              Goto LAbR.11.\n      LAbR.7\
    \  Is LSR merging the LSP for FEC?\n              If not, goto LAbR.9.\n     \
    \ LAbR.8  Are there upstream peers other than MsgSource that have\n          \
    \    requested a label for FEC?\n              If so, goto LAbR.11.\n      LAbR.9\
    \  Execute procedure Send_Message (Next Hop, Label Abort\n              Request,\
    \ FEC, TLV), where TLV is a Label Request Message\n              ID TLV containing\
    \ the Message ID used by the LSR in the\n              outstanding Label Request\
    \ message.\n      LAbR.10  Record that a label abort request for FEC is pending.\n\
    \      LAbR.11  Delete record of label request for FEC from MsgSource.\n     \
    \ LAbR.12  DONE\n   Notes:\n      1. LSR uses FEC and the Label Request Message\
    \ ID TLV carried by\n         the label abort request to locate its record (if\
    \ any) for the\n         previously received label request from MsgSource.\n \
    \     2. If LSR has received a label mapping from NextHop, it should\n       \
    \  behave as if it had advertised a label mapping to MsgSource and\n         MsgSource\
    \ has released it.\n"
- title: A.1.4. Receive Label Release
  contents:
  - "A.1.4. Receive Label Release\n   Summary:\n      When an LSR receives a label\
    \ release message for a FEC from a\n      peer, it checks whether other peers\
    \ hold the released label.  If\n      none do, the LSR removes the label from\
    \ forwarding/switching use,\n      if it has not already done so, and if the LSR\
    \ holds a label\n      mapping from the FEC next hop, it releases the label mapping.\n\
    \   Context:\n      -  LSR.  The LSR handling the event.\n      -  MsgSource.\
    \  The LDP peer that sent the message.\n      -  Label.  The label specified in\
    \ the message.\n      -  FEC.  The FEC specified in the message.\n   Algorithm:\n\
    \      LRl.1   Remove MsgSource from record of peers that hold Label for\n   \
    \           FEC.  (See Note 1.)\n      LRl.2   Does message match an outstanding\
    \ label withdraw for FEC\n              previously sent to MsgSource?\n      \
    \        If not, goto LRl.4\n      LRl.3   Delete record of outstanding label\
    \ withdraw for FEC\n              previously sent to MsgSource.\n      LRl.4 \
    \  Is LSR merging labels for this FEC?\n              If not, goto LRl.6.  (See\
    \ Note 2.)\n      LRl.5   Has LSR previously advertised a label for this FEC to\n\
    \              other peers?\n              If so, goto LRl.10.\n      LRl.6  \
    \ Is LSR egress for the FEC?\n              If so, goto LRl.10\n      LRl.7  \
    \ Is there a Next Hop for FEC? AND\n              Does LSR have a previously received\
    \ label mapping for FEC\n              from Next Hop?\n              If not, goto\
    \ LRl.10.\n      LRl.8   Is LSR configured to propagate releases?\n          \
    \    If not, goto LRl.10.  (See Note 3.)\n      LRl.9   Execute procedure Send_Message\
    \ (Next Hop, Label Release,\n              FEC, Label from Next Hop).\n      LRl.10\
    \  Remove Label from forwarding/switching use for traffic\n              from\
    \ MsgSource.\n      LRl.11  Do any peers still hold Label for FEC?\n         \
    \     If so, goto LRl.13.\n      LRl.12  Free the Label.\n      LRl.13  DONE.\n\
    \   Notes:\n      1. If LSR is using Downstream Unsolicited label distribution,\
    \ it\n         should not re-advertise a label mapping for FEC to MsgSource\n\
    \         until MsgSource requests it.\n      2. LRl.4 through LRl.8 deal with\
    \ determining whether where the LSR\n         should propagate the label release\
    \ to a downstream peer\n         (LRl.9).\n      3. If LRl.8 is reached, no upstream\
    \ LSR holds a label for the FEC,\n         and the LSR holds a label for the FEC\
    \ from the FEC Next Hop.\n         The LSR could propagate the Label Release to\
    \ the Next Hop.  By\n         propagating the Label Release the LSR releases a\
    \ potentially\n         scarce label resource.  In doing so, it also increases\
    \ the\n         latency for re-establishing the LSP should MsgSource or some\n\
    \         other upstream LSR send it a new Label Request for FEC.\n         Whether\
    \ or not to propagate the release is not a protocol\n         issue.  Label distribution\
    \ will operate properly whether or not\n         the release is propagated.  The\
    \ decision to propagate or not\n         should take into consideration factors\
    \ such as: whether labels\n         are a scarce resource in the operating environment;\
    \ the\n         importance of keeping LSP setup latency low by keeping the\n \
    \        amount of signaling required small; whether LSP setup is\n         ingress-controlled\
    \ or egress-controlled in the operating\n         environment.\n"
- title: A.1.5. Receive Label Withdraw
  contents:
  - "A.1.5. Receive Label Withdraw\n   Summary:\n      When an LSR receives a label\
    \ withdraw message for a FEC from an\n      LDP peer, it responds with a label\
    \ release message and it removes\n      the label from any forwarding/switching\
    \ use.  If ordered control\n      is in use, the LSR sends a label withdraw message\
    \ to each LDP peer\n      to which it had previously sent a label mapping for\
    \ the FEC.  If\n      the LSR is using Downstream on Demand label advertisement\
    \ with\n      independent control, it then acts as if it had just recognized the\n\
    \      FEC.\n   Context:\n      -  LSR.  The LSR handling the event.\n      -\
    \  MsgSource.  The LDP peer that sent the message.\n      -  Label.  The label\
    \ specified in the message.\n      -  FEC.  The FEC specified in the message.\n\
    \   Algorithm:\n      LWd.1   Remove Label from forwarding/switching use.  (See\
    \ Note 1.)\n      LWd.2   Execute procedure Send_Message (MsgSource, Label Release,\n\
    \              FEC, Label)\n      LWd.3   Has LSR previously received and retained\
    \ a matching label\n              mapping for FEC from MsgSource?\n          \
    \    If not, goto LWd.13.\n      LWd.4   Delete matching label mapping for FEC\
    \ previously received\n              from MsgSource.\n      LWd.5   Is LSR using\
    \ ordered control?\n              If so, goto LWd.8.\n      LWd.6   Is MsgSource\
    \ using Downstream On Demand label\n              advertisement?\n           \
    \   If not, goto LWd.13.\n      LWd.7   Generate Event: Recognize New FEC for\
    \ FEC.\n              Goto LWd.13.  (See Note 2.)\n      LWd.8   Iterate through\
    \ LWd.12 for each Peer, other than\n              MsgSource.\n      LWd.9   Has\
    \ LSR previously sent a label mapping for FEC to Peer?\n              If not,\
    \ continue iteration for next Peer at LWd.8.\n      LWd.10  Does the label previously\
    \ sent to Peer \"map\" to the\n              withdrawn Label?\n              If\
    \ not, continue iteration for next Peer at LWd.8.\n              (See Note 3.)\n\
    \      LWd.11  Execute procedure Send_Label_Withdraw (Peer, FEC, Label\n     \
    \         previously sent to Peer).\n      LWd.12  End iteration from LWd.8.\n\
    \      LWd.13  DONE\n   Notes:\n      1. If Label is not in forwarding/switching\
    \ use, LWd.1 has no\n         effect.\n      2. LWd.7 handles the case where the\
    \ LSR is using Downstream On\n         Demand label distribution with independent\
    \ control.  In this\n         situation the LSR should send a label request to\
    \ the FEC next\n         hop as if it had just recognized the FEC.\n      3. LWd.10\
    \ handles both label merging (one or more incoming labels\n         map to the\
    \ same outgoing label) and no label merging (one label\n         maps to the outgoing\
    \ label) cases.\n"
- title: A.1.6. Recognize New FEC
  contents:
  - "A.1.6. Recognize New FEC\n   Summary:\n      The response by an LSR to learning\
    \ a new FEC via the routing table\n      may involve one or more of the following\
    \ actions:\n      -  Transmission of label mappings for the FEC to one or more\
    \ LDP\n         peers;\n      -  Transmission of a label request for the FEC to\
    \ the FEC next\n         hop;\n      -  Any of the actions that can occur when\
    \ the LSR receives a label\n         mapping for the FEC from the FEC next hop.\n\
    \   Context:\n      -  LSR.  The LSR handling the event.\n      -  FEC. The newly\
    \ recognized FEC.\n      -  Next Hop.  The next hop for the FEC.\n      -  InitAttributes.\
    \  Attributes to be associated with the new FEC.\n         (See Note 1.)\n   \
    \   -  SAttributes.  Attributes to be included in Label Mapping or\n         Label\
    \ Request messages, if any, sent to peers.\n      -  StoredHopCount.  Hop count\
    \ associated with FEC label mapping,\n         if any, previously received from\
    \ Next Hop.\n   Algorithm:\n      FEC.1   Perform LSR Label Distribution procedure:\n\
    \            For Downstream Unsolicited Independent Control\n               1.\
    \ Iterate through 5 for each Peer.\n               2. Has LSR previously received\
    \ and retained a label\n                  mapping for FEC from Next Hop?\n   \
    \               If so, set Propagating to IsPropagating.\n                  If\
    \ not, set Propagating to NotPropagating.\n               3. Execute procedure\
    \ Prepare_Label_Mapping_Attributes\n                  (Peer, FEC, InitAttributes,\
    \ SAttributes, Propagating,\n                  Unknown hop count(0)).\n      \
    \         4. Execute procedure Send_Label (Peer, FEC, SAttributes)\n         \
    \      5. End iteration from 1.\n                  Goto FEC.2.\n            For\
    \ Downstream Unsolicited Ordered Control\n               1. Iterate through 5\
    \ for each Peer.\n               2. Is LSR egress for the FEC? OR\n          \
    \        Has LSR previously received and retained a label\n                  mapping\
    \ for FEC from Next Hop?\n                  If not, continue iteration for next\
    \ Peer.\n               3. Execute procedure Prepare_Label_Mapping_Attributes\n\
    \                  (Peer, FEC, InitAttributes, SAttributes, Propagating,\n   \
    \               StoredHopCount).\n               4. Execute procedure Send_Label\
    \ (Peer, FEC, SAttributes)\n               5. End iteration from 1.\n        \
    \          Goto FEC.2.\n            For Downstream On Demand Independent Control\
    \ OR\n            For Downstream On Demand Ordered Control\n               1.\
    \ Goto FEC.2.  (See Note 2.)\n      FEC.2   Has LSR previously received and retained\
    \ a label\n              mapping for FEC from Next Hop?\n              If so,\
    \ goto FEC.5\n      FEC.3   Is Next Hop an LDP peer?\n              If not, Goto\
    \ FEC.6\n      FEC.4   Perform LSR Label Request procedure:\n            For Request\
    \ Never\n              1. Goto FEC.6\n            For Request When Needed OR\n\
    \            For Request On Request\n              1. Execute procedure\n    \
    \             Prepare_Label_Request_Attributes\n                 (Next Hop, FEC,\
    \ InitAttributes, SAttributes);\n              2. Execute procedure Send_Label_Request\
    \ (Next\n                 Hop, FEC, SAttributes).\n                 Goto FEC.6.\n\
    \      FEC.5   Generate Event: Received Label Mapping from Next Hop.\n       \
    \       (See Note 3.)\n      FEC.6   DONE.\n   Notes:\n      1. An example of\
    \ an attribute that might be part of InitAttributes\n         is one which specifies\
    \ desired LSP characteristics, such as\n         class of service (CoS).  (Note\
    \ that while the current version\n         of LDP does not specify a CoS attribute,\
    \ LDP extensions may.)\n         The means by which FEC InitAttributes, if any,\
    \ are specified is\n         beyond the scope of LDP.  Note that the InitAttributes\
    \ will not\n         include a known Hop Count or a Path Vector.\n      2. An\
    \ LSR using Downstream On Demand label distribution would send\n         a label\
    \ only if it had a previously received label request\n         marked as pending.\
    \  The LSR would have no such pending requests\n         because it responds to\
    \ any label request for an unknown FEC by\n         sending the requesting LSR\
    \ a No Route notification and\n         discarding the label request; see LRq.3\n\
    \      3. If the LSR has a label for the FEC from the Next Hop, it should\n  \
    \       behave as if it had just received the label from the Next Hop.\n     \
    \    This occurs in the case of Liberal label retention mode.\n"
- title: A.1.7. Detect Change in FEC Next Hop
  contents:
  - "A.1.7. Detect Change in FEC Next Hop\n   Summary:\n      The response by an LSR\
    \ to a change in the next hop for a FEC may\n      involve one or more of the\
    \ following actions:\n      -  Removal of the label from the FEC's old next hop\
    \ from\n         forwarding/switching use;\n      -  Transmission of label mapping\
    \ messages for the FEC to one or\n         more LDP peers;\n      -  Transmission\
    \ of a label request to the FEC's new next hop;\n      -  Any of the actions that\
    \ can occur when the LSR receives a label\n         mapping from the FEC's new\
    \ next hop.\n   Context:\n      -  LSR.  The LSR handling the event.\n      -\
    \  FEC.  The FEC whose next hop changed.\n      -  New Next Hop.  The current\
    \ next hop for the FEC.\n      -  Old Next Hop.  The previous next hop for the\
    \ FEC.\n      -  OldLabel.  Label, if any, previously received from Old Next\n\
    \         Hop.\n      -  CurAttributes.  The attributes, if any, currently associated\n\
    \         with the FEC.\n      -  SAttributes.  Attributes to be included in Label\
    \ Label Request\n         message, if any, sent to New Next Hop.\n   Algorithm:\n\
    \      NH.1   Has LSR previously received and retained a label mapping\n     \
    \        for FEC from Old Next Hop?\n             If not, goto NH.6.\n      NH.2\
    \   Remove label from forwarding/switching use.  (See Note 1.)\n      NH.3   Is\
    \ LSR using Liberal label retention?\n             If so, goto NH.6.\n      NH.4\
    \   Execute procedure Send_Message (Old Next Hop, Label\n             Release,\
    \ OldLabel).\n      NH.5   Delete label mapping for FEC previously received from\
    \ Old\n             Next Hop.\n      NH.6   Does LSR have a label request pending\
    \ with Old Next Hop?\n             If not, goto NH.10.\n      NH.7   Is LSR using\
    \ Conservative label retention?\n             If not, goto NH.10.\n      NH.8\
    \   Execute procedure Send_Message (Old Next Hop, Label Abort\n             Request,\
    \ FEC, TLV), where TLV is a Label Request Message\n             ID TLV that carries\
    \ the message ID of the pending label\n             request.\n      NH.9   Record\
    \ a label abort request is pending for FEC with Old\n             Next Hop.\n\
    \      NH.10  Is there a New Next Hop for the FEC?\n             If not, goto\
    \ NH.16.\n      NH.11  Has LSR previously received and retained a label mapping\n\
    \             for FEC from New Next Hop?\n             If not, goto NH.13.\n \
    \     NH.12  Generate Event: Received Label Mapping from New Next Hop.\n     \
    \        Goto NH.20.  (See Note 2.)\n      NH.13  Is LSR using Downstream on Demand\
    \ advertisement? OR\n             Is Next Hop using Downstream on Demand advertisement?\
    \ OR\n             Is LSR using Conservative label retention? (See Note 3.)\n\
    \             If so, goto NH.14.\n             If not, goto NH.20.\n      NH.14\
    \  Execute procedure Prepare_Label_Request_Attributes (Next\n             Hop,\
    \ FEC, CurAttributes, SAttributes)\n      NH.15  Execute procedure Send_Label_Request\
    \ (New Next Hop, FEC,\n             SAttributes).  (See Note 4.)\n           \
    \  Goto NH.20.\n      NH.16  Iterate through NH.19 for each Peer.\n      NH.17\
    \  Has LSR previously sent a label mapping for FEC to Peer?\n             If not,\
    \ continue iteration for next Peer at NH.16.\n      NH.18  Execute procedure Send_Label_Withdraw\
    \ (Peer, FEC, Label\n             previously sent to Peer).\n      NH.19  End\
    \ iteration from NH.16.\n      NH.20  DONE.\n   Notes:\n      1. If Label is not\
    \ in forwarding/switching use, NH.2 has no\n         effect.\n      2. If the\
    \ LSR has a label for the FEC from the New Next Hop, it\n         should behave\
    \ as if it had just received the label from the New\n         Next Hop.\n    \
    \  3. The purpose of the check on label retention mode is to avoid a\n       \
    \  race with steps LMp.12-LMp.13 of the procedure for handling a\n         Label\
    \ Mapping message where the LSR operating in Conservative\n         Label retention\
    \ mode may have released a label mapping received\n         from the New Next\
    \ Hop before it detected the FEC next hop had\n         changed.\n      4. Regardless\
    \ of the Label Request procedure in use by the LSR, it\n         must send a label\
    \ request if the conditions in NH.8 hold.\n         Therefore it executes the\
    \ Send_Label_Request procedure directly\n         rather than perform LSR Label\
    \ Request procedure.\n"
- title: A.1.8. Receive Notification / Label Request Aborted
  contents:
  - "A.1.8. Receive Notification / Label Request Aborted\n   Summary:\n      When\
    \ an LSR receives a Label Request Aborted notification from an\n      LDP peer\
    \ it records that the corresponding label request\n      transaction, if any,\
    \ has completed.\n   Context:\n      -  LSR.  The LSR handling the event.\n  \
    \    -  FEC.  The FEC for which a label was requested.\n      -  RequestMessageID.\
    \  The message ID of the label request message\n         to be aborted.\n    \
    \  -  MsgSource.  The LDP peer that sent the Notification message.\n   Algorithm:\n\
    \      LRqA.1  Does the notification correspond to an outstanding label\n    \
    \          request abort for FEC? (See Note 1).\n              If not, goto LRqA.3.\n\
    \      LRqA.2  Record that the label request for FEC has been aborted.\n     \
    \ LRqA.3  DONE\n   Notes:\n      1. The LSR uses the FEC and RequestMessageID\
    \ to locate its record,\n         if any, of the outstanding label request abort.\n"
- title: A.1.9. Receive Notification / No Label Resources
  contents:
  - "A.1.9. Receive Notification / No Label Resources\n   Summary:\n      When an\
    \ LSR receives a No Label Resources notification from an LDP\n      peer, it stops\
    \ sending label request messages to the peer until it\n      receives a Label\
    \ Resources Available Notification from the peer.\n   Context:\n      -  LSR.\
    \  The LSR handling the event.\n      -  FEC.  The FEC for which a label was requested.\n\
    \      -  MsgSource.  The LDP peer that sent the Notification message.\n   Algorithm:\n\
    \      NoRes.1 Delete record of outstanding label request for FEC sent\n     \
    \         to MsgSource.\n      NoRes.2 Record label mapping for FEC from MsgSource\
    \ is needed but\n              that no label resources are available.\n      NoRes.3\
    \ Set status record indicating it is not OK to send label\n              requests\
    \ to MsgSource.\n      NoRes.4 DONE.\n"
- title: A.1.10. Receive Notification / No Route
  contents:
  - "A.1.10. Receive Notification / No Route\n   Summary:\n      When an LSR receives\
    \ a No Route notification from an LDP peer in\n      response to a Label Request\
    \ message, the Label No Route procedure\n      in use dictates its response. The\
    \ LSR either will take no further\n      action, or it will defer the label request\
    \ by starting a timer and\n      send another Label Request message to the peer\
    \ when the timer\n      later expires.\n   Context:\n      -  LSR.  The LSR handling\
    \ the event.\n      -  FEC.  The FEC for which a label was requested.\n      -\
    \  Attributes.  The attributes associated with the label request.\n      -  MsgSource.\
    \  The LDP peer that sent the Notification message.\n   Algorithm:\n      NoNH.1\
    \  Delete record of outstanding label request for FEC sent\n              to MsgSource.\n\
    \      NoNH.2  Perform LSR Label No Route procedure.\n            For Request\
    \ No Retry\n              1. Goto NoNH.3.\n            For Request Retry\n   \
    \           1. Record deferred label request for FEC and Attributes\n        \
    \         to be sent to MsgSource.\n              2. Start timeout.  Goto NoNH.3.\n\
    \      NoNH.3  DONE.\n"
- title: A.1.11. Receive Notification / Loop Detected
  contents:
  - "A.1.11. Receive Notification / Loop Detected\n   Summary:\n      When an LSR\
    \ receives a Loop Detected Status Code from an LDP peer\n      in response to\
    \ a Label Request message or a Label Mapping message,\n      it behaves as if\
    \ it had received a No Route notification.\n   Context:\n      See \"Receive Notification\
    \ / No Route\".\n   Algorithm:\n      See \"Receive Notification / No Route\"\n\
    \   Notes:\n      1. When the Loop Detected notification is in response to a Label\n\
    \         Request message, it arrives in a Status Code TLV in a\n         Notification\
    \ message.  When it is in response to a Label\n         Mapping message, it arrives\
    \ in a Status Code TLV in a Label\n         Release message.\n"
- title: A.1.12. Receive Notification / Label Resources Available
  contents:
  - "A.1.12. Receive Notification / Label Resources Available\n   Summary:\n     \
    \ When an LSR receives a Label Resources Available notification from\n      an\
    \ LDP peer, it resumes sending label requests to the peer.\n   Context:\n    \
    \  -  LSR.  The LSR handling the event.\n      -  MsgSource.  The LDP peer that\
    \ sent the Notification message.\n      -  SAttributes.  Attributes stored with\
    \ postponed Label Request\n         message.\n   Algorithm:\n      Res.1   Set\
    \ status record indicating it is OK to send label\n              requests to MsgSource.\n\
    \      Res.2   Iterate through Res.6 for each record of a FEC label\n        \
    \      mapping needed from MsgSource for which no label\n              resources\
    \ are available.\n      Res.3   Is MsgSource the next hop for FEC?\n         \
    \     If not, goto Res.5.\n      Res.4   Execute procedure Send_Label_Request\
    \ (MsgSource, FEC,\n              SAttributes).  If the procedure fails, terminate\n\
    \              iteration.\n      Res.5   Delete record that no resources are available\
    \ for a label\n              mapping for FEC needed from MsgSource.\n      Res.6\
    \   End iteration from Res.2\n      Res.7   DONE.\n"
- title: A.1.13. Detect local label resources have become available
  contents:
  - "A.1.13. Detect local label resources have become available\n   Summary:\n   \
    \   After an LSR has sent a No Label Resources notification to an LDP\n      peer,\
    \ when label resources later become available it sends a Label\n      Resources\
    \ Available notification to each such peer.\n   Context:\n      -  LSR.  The LSR\
    \ handling the event.\n      -  Attributes.  Attributes stored with postponed\
    \ Label Mapping\n         message.\n   Algorithm:\n      ResA.1  Iterate through\
    \ ResA.4 for each Peer to which LSR has\n              previously sent a No Label\
    \ Resources notification.\n      ResA.2  Execute procedure Send_Notification (Peer,\
    \ Label\n              Resources Available)\n      ResA.3  Delete record that\
    \ No Label Resources notification was\n              previously sent to Peer.\n\
    \      ResA.4  End iteration from ResA.1\n      ResA.5  Iterate through ResA.8\
    \ for each record of a label mapping\n              needed for FEC for Peer but\
    \ no-label-resources.  (See Note\n              1.)\n      ResA.6  Execute procedure\
    \ Send_Label (Peer, FEC, Attributes).  If\n              the procedure fails,\
    \ terminate iteration.\n      ResA.7  Clear record of FEC label mapping needed\
    \ for peer but no-\n              label-resources.\n      ResA.8  End iteration\
    \ from ResA.5\n      ResA.9  DONE.\n   Notes:\n      1. Iteration ResA.5 through\
    \ ResA.8 handles the situation where the\n         LSR is using Downstream Unsolicited\
    \ label distribution and was\n         previously unable to allocate a label for\
    \ a FEC.\n"
- title: A.1.14. LSR decides to no longer label switch a FEC
  contents:
  - "A.1.14. LSR decides to no longer label switch a FEC\n   Summary:\n      An LSR\
    \ may unilaterally decide to no longer label switch a FEC for\n      an LDP peer.\
    \  An LSR that does so must send a label withdraw message\n      for the FEC to\
    \ the peer.\n   Context:\n      -  Peer.  The peer.\n      -  FEC.  The FEC.\n\
    \      -  PrevAdvLabel.  The label for FEC previously advertised to Peer.\n  \
    \ Algorithm:\n      NoLS.1  Execute procedure Send_Label_Withdraw (Peer, FEC,\n\
    \              PrevAdvLabel).  (See Note 1.)\n      NoLS.2  DONE.\n   Notes:\n\
    \      1. The LSR may remove the label from forwarding/switching use as\n    \
    \     part of this event or as part of processing the label release\n        \
    \ from the peer in response to the label withdraw.\n"
- title: A.1.15. Timeout of deferred label request
  contents:
  - "A.1.15. Timeout of deferred label request\n   Summary:\n      Label requests\
    \ are deferred in response to No Route and Loop\n      Detected notifications.\
    \  When a deferred FEC label request for a\n      peer times out, the LSR sends\
    \ the label request.\n   Context:\n      -  LSR.  The LSR handling the event.\n\
    \      -  FEC.  The FEC associated with the timeout event.\n      -  Peer.  The\
    \ LDP peer associated with the timeout event.\n      -  Attributes.  Attributes\
    \ stored with deferred Label Request\n         message.\n   Algorithm:\n     \
    \ TO.1    Retrieve the record of the deferred label request.\n      TO.2    Is\
    \ Peer the next hop for FEC?\n              If not, goto TO.4.\n      TO.3   \
    \ Execute procedure Send_Label_Request (Peer, FEC).\n      TO.4    DONE.\n"
- title: A.2. Common Label Distribution Procedures
  contents:
  - "A.2. Common Label Distribution Procedures\n      This section specifies utility\
    \ procedures used by the algorithms\n      that handle label distribution events.\n"
- title: A.2.1. Send_Label
  contents:
  - "A.2.1. Send_Label\n   Summary:\n      The Send_Label procedure allocates a label\
    \ for a FEC for an LDP\n      peer, if possible, and sends a label mapping for\
    \ the FEC to the\n      peer.  If the LSR is unable to allocate the label and\
    \ if it has a\n      pending label request from the peer, it sends the LDP peer\
    \ a No\n      Label Resources notification.\n   Parameters:\n      -  Peer.  The\
    \ LDP peer to which the label mapping is to be sent.\n      -  FEC.  The FEC for\
    \ which a label mapping is to be sent.\n      -  Attributes.  The attributes to\
    \ be included with the label\n         mapping.\n   Additional Context:\n    \
    \  -  LSR.  The LSR executing the procedure.\n      -  Label.  The label allocated\
    \ and sent to Peer.\n   Algorithm:\n      SL.1   Does LSR have a label to allocate?\n\
    \             If not, goto SL.9.\n      SL.2   Allocate Label and bind it to the\
    \ FEC.\n      SL.3   Install Label for forwarding/switching use.\n      SL.4 \
    \  Execute procedure Send_Message (Peer, Label Mapping, FEC,\n             Label,\
    \ Attributes).\n      SL.5   Record label mapping for FEC with Label and Attributes\
    \ has\n             been sent to Peer.\n      SL.6   Does LSR have a record of\
    \ a FEC label request from Peer\n             marked as pending?\n           \
    \  If not, goto SL.8.\n      SL.7   Delete record of pending label request for\
    \ FEC from Peer.\n      SL.8   Return success.\n      SL.9   Does LSR have a label\
    \ request for FEC from Peer marked as\n             pending?\n             If\
    \ not, goto SL.13.\n      SL.10  Execute procedure Send_Notification (Peer, No\
    \ Label\n             Resources).\n      SL.11  Delete record of pending label\
    \ request for FEC from Peer.\n      SL.12  Record No Label Resources notification\
    \ has been sent to\n             Peer.\n             Goto SL.14.\n      SL.13\
    \  Record label mapping needed for FEC and Attributes for\n             Peer,\
    \ but no-label-resources.  (See Note 1.)\n      SL.14  Return failure.\n   Notes:\n\
    \      1. SL.13 handles the case of Downstream Unsolicited label\n         distribution\
    \ when the LSR is unable to allocate a label for a\n         FEC to send to a\
    \ Peer.\n"
- title: A.2.2. Send_Label_Request
  contents:
  - "A.2.2. Send_Label_Request\n   Summary:\n      An LSR uses the Send_Label_Request\
    \ procedure to send a request for\n      a label for a FEC to an LDP peer if currently\
    \ permitted to do so.\n   Parameters:\n      -  Peer.  The LDP peer to which the\
    \ label request is to be sent.\n      -  FEC.  The FEC for which a label request\
    \ is to be sent.\n      -  Attributes.  Attributes to be included in the label\
    \ request.\n         E.g., Hop Count, Path Vector.\n   Additional Context:\n \
    \     -  LSR.  The LSR executing the procedure.\n   Algorithm:\n      SLRq.1 \
    \ Has a label request for FEC previously been sent to Peer\n              and\
    \ is it marked as outstanding?\n              If so, Return success.  (See Note\
    \ 1.)\n      SLRq.2  Is status record indicating it is OK to send label\n    \
    \          requests to Peer set?\n              If not, goto SLRq.6\n      SLRq.3\
    \  Execute procedure Send_Message (Peer, Label Request, FEC,\n              Attributes).\n\
    \      SLRq.4  Record label request for FEC has been sent to Peer and\n      \
    \        mark it as outstanding.\n      SLRq.5  Return success.\n      SLRq.6\
    \  Postpone the label request by recording label mapping for\n              FEC\
    \ and Attributes from Peer is needed but that no label\n              resources\
    \ are available.\n      SLRq.7  Return failure.\n   Notes:\n      1. If the LSR\
    \ is a non-merging LSR it must distinguish between\n         attempts to send\
    \ label requests for a FEC triggered by\n         different upstream LDP peers\
    \ from duplicate requests.  This\n         procedure will not send a duplicate\
    \ label request.\n"
- title: A.2.3. Send_Label_Withdraw
  contents:
  - "A.2.3. Send_Label_Withdraw\n   Summary:\n      An LSR uses the Send_Label_Withdraw\
    \ procedure to withdraw a label\n      for a FEC from an LDP peer.  To do this\
    \ the LSR sends a Label\n      Withdraw message to the peer.\n   Parameters:\n\
    \      -  Peer.  The LDP peer to which the label withdraw is to be sent.\n   \
    \   -  FEC.  The FEC for which a label is being withdrawn.\n      -  Label.  The\
    \ label being withdrawn\n   Additional Context:\n      -  LSR.  The LSR executing\
    \ the procedure.\n   Algorithm:\n      SWd.1  Execute procedure Send_Message (Peer,\
    \ Label Withdraw, FEC,\n             Label)\n      SWd.2  Record label withdraw\
    \ for FEC has been sent to Peer and\n             mark it as outstanding.\n"
- title: A.2.4. Send_Notification
  contents:
  - "A.2.4. Send_Notification\n   Summary:\n      An LSR uses the Send_Notification\
    \ procedure to send an LDP peer a\n      notification message.\n   Parameters:\n\
    \      -  Peer.  The LDP peer to which the Notification message is to be\n   \
    \      sent.\n      -  Status.  Status code to be included in the Notification\n\
    \         message.\n   Additional Context:\n      None.\n   Algorithm:\n     \
    \ SNt.1  Execute procedure Send_Message (Peer, Notification, Status)\n"
- title: A.2.5. Send_Message
  contents:
  - "A.2.5. Send_Message\n   Summary:\n      An LSR uses the Send_Message procedure\
    \ to send an LDP peer an LDP\n      message.\n   Parameters:\n      -  Peer. \
    \ The LDP peer to which the message is to be sent.\n      -  Message Type.  The\
    \ type of message to be sent.\n      -  Additional message contents . . .  .\n\
    \   Additional Context:\n      None.\n   Algorithm:\n      This procedure is the\
    \ means by which an LSR sends an LDP message\n      of the specified type to the\
    \ specified LDP peer.\n"
- title: A.2.6. Check_Received_Attributes
  contents:
  - "A.2.6. Check_Received_Attributes\n   Summary:\n      Check the attributes received\
    \ in a Label Mapping or Label Request\n      message.  If the attributes include\
    \ a Hop Count or Path Vector,\n      perform a loop detection check.  If a loop\
    \ is detected, cause a\n      Loop Detected Notification message to be sent to\
    \ MsgSource.\n   Parameters:\n      -  MsgSource.  The LDP peer that sent the\
    \ message.\n      -  MsgType.  The type of message received.\n      -  RAttributes.\
    \  The attributes in the message.\n   Additional Context:\n      -  LSR Id.  The\
    \ unique LSR Id of this LSR.\n      -  Hop Count.  The Hop Count, if any, in the\
    \ received attributes.\n      -  Path Vector.  The Path Vector, if any in the\
    \ received\n         attributes.\n   Algorithm:\n      CRa.1   Do RAttributes\
    \ include Hop Count?\n              If not, goto CRa.5.\n      CRa.2   Does Hop\
    \ Count exceed Max allowable hop count?\n              If so, goto CRa.6.\n  \
    \    CRa.3   Do RAttributes include Path Vector?\n              If not, goto CRa.5.\n\
    \      CRa.4   Does Path Vector Include LSR Id? OR\n              Does length\
    \ of Path Vector exceed Max allowable length?\n              If so, goto CRa.6\n\
    \      CRa.5   Return No Loop Detected.\n      CRa.6   Is MsgType LabelMapping?\n\
    \              If so, goto CRa.8.  (See Note 1.)\n      CRa.7   Execute procedure\
    \ Send_Notification (MsgSource, Loop\n              Detected)\n      CRa.8   Return\
    \ Loop Detected.\n      CRa.9   DONE\n   Notes:\n      1. When the attributes\
    \ being checked were received in a Label\n         Mapping message, the LSR sends\
    \ the Loop Detected notification\n         in a Status Code TLV in a Label Release\
    \ message.  (See Section\n         \"Receive Label Mapping\").\n"
- title: A.2.7. Prepare_Label_Request_Attributes
  contents:
  - "A.2.7. Prepare_Label_Request_Attributes\n   Summary:\n      This procedure is\
    \ used whenever a Label Request is to be sent to a\n      Peer to compute the\
    \ Hop Count and Path Vector, if any, to include\n      in the message.\n   Parameters:\n\
    \      -  Peer.  The LDP peer to which the message is to be sent.\n      -  FEC.\
    \  The FEC for which a label request is to be sent.\n      -  RAttributes.  The\
    \ attributes this LSR associates with the LSP\n         for FEC.\n      -  SAttributes.\
    \  The attributes to be included in the Label\n         Request message.\n   Additional\
    \ Context:\n      -  LSR Id.  The unique LSR Id of this LSR.\n   Algorithm:\n\
    \      PRqA.1  Is Hop Count required for this Peer (see Note 1.) ? OR\n      \
    \        Do RAttributes include a Hop Count? OR\n              Is Loop Detection\
    \ configured on LSR?\n              If not, goto PRqA.14.\n      PRqA.2  Is LSR\
    \ ingress for FEC?\n              If not, goto PRqA.6.\n      PRqA.3  Include\
    \ Hop Count of 1 in SAttributes.\n      PRqA.4  Is Loop Detection configured on\
    \ LSR?\n              If not, goto PRqA.14.\n      PRqA.5  Is LSR merge-capable?\n\
    \              If so, goto PRqA.14.\n              If not, goto PRqA.13.\n   \
    \   PRqA.6  Do RAttributes include a Hop Count?\n              If not, goto PRqA.8.\n\
    \      PRqA.7  Increment RAttributes Hop Count and copy the resulting Hop\n  \
    \            Count to SAttributes.  (See Note 2.)\n              Goto PRqA.9.\n\
    \      PRqA.8  Include Hop Count of unknown (0) in SAttributes.\n      PRqA.9\
    \  Is Loop Detection configured on LSR?\n              If not, goto PRqA.14.\n\
    \      PRqA.10 Do RAttributes have a Path Vector?\n              If so, goto PRqA.12.\n\
    \      PRqA.11 Is LSR merge-capable?\n              If so, goto PRqA.14.\n   \
    \           If not, goto PRqA.13.\n      PRqA.12 Add LSR Id to beginning of Path\
    \ Vector from RAttributes\n              and copy the resulting Path Vector into\
    \ SAttributes.\n              Goto PRqA.14.\n      PRqA.13 Include Path Vector\
    \ of length 1 containing LSR Id in\n              SAttributes.\n      PRqA.14\
    \ DONE.\n   Notes:\n      1. The link with Peer may require that Hop Count be\
    \ included in\n         Label Request messages; for example, see [RFC3035] and\n\
    \         [RFC3034].\n      2. For hop count arithmetic, unknown + 1 = unknown.\n"
- title: A.2.8.  Prepare_Label_Mapping_Attributes
  contents:
  - "A.2.8.  Prepare_Label_Mapping_Attributes\n   Summary:\n      This procedure is\
    \ used whenever a Label Mapping is to be sent to a\n      Peer to compute the\
    \ Hop Count and Path Vector, if any, to include\n      in the message.\n   Parameters:\n\
    \      -  Peer.  The LDP peer to which the message is to be sent.\n      -  FEC.\
    \  The FEC for which a label request is to be sent.\n      -  RAttributes.  The\
    \ attributes this LSR associates with the LSP\n         for FEC.\n      -  SAttributes.\
    \  The attributes to be included in the Label\n         Mapping message.\n   \
    \   -  IsPropagating.  The LSR is sending the Label Mapping message to\n     \
    \    propagate one received from the FEC next hop.\n      -  PrevHopCount.  The\
    \ Hop Count, if any, this LSR associates with\n         the LSP for the FEC.\n\
    \   Additional Context:\n      -  LSR Id.  The unique LSR Id of this LSR.\n  \
    \ Algorithm:\n      PMpA.1  Is Hop Count required for this Peer (see Note 1.)\
    \ ? OR\n              Do RAttributes include a Hop Count? OR\n              Is\
    \ Loop Detection configured on LSR?\n              If not, goto PMpA.21.\n   \
    \   PMpA.2  Is LSR egress for FEC?\n              If not, goto PMpA.4.\n     \
    \ PMpA.3  Include Hop Count of 1 in SAttributes.  Goto PMpA.21.\n      PMpA.4\
    \  Do RAttributes have a Hop Count?\n              If not, goto PMpA.8.\n    \
    \  PMpA.5  Is LSR member of edge set for an LSR domain whose LSRs do\n       \
    \       not perform TTL decrement AND\n              Is Peer in that domain (See\
    \ Note 2.).\n              If not, goto PMpA.7.\n      PMpA.6  Include Hop Count\
    \ of 1 in SAttributes.  Goto PMpA.9.\n      PMpA.7  Increment RAttributes Hop\
    \ Count and copy the resulting\n              Hop Count to SAttributes.  See Note\
    \ 2.  Goto PMpA.9.\n      PMpA.8  Include Hop Count of unknown (0) in SAttributes.\n\
    \      PMpA.9  Is Loop Detection configured on LSR?\n              If not, goto\
    \ PMpA.21.\n      PMpA.10 Do RAttributes have a Path Vector?\n              If\
    \ so, goto PMpA.19.\n      PMpA.11 Is LSR propagating a received Label Mapping?\n\
    \              If not, goto PMpA.20.\n      PMpA.12 Does LSR support merging?\n\
    \              If not, goto PMpA.14.\n      PMpA.13 Has LSR previously sent a\
    \ Label Mapping for FEC to Peer?\n              If not, goto PMpA.20.\n      PMpA.14\
    \ Do RAttributes include a Hop Count?\n              If not, goto PMpA.21.\n \
    \     PMpA.15 Is Hop Count in Rattributes unknown(0)?\n              If so, goto\
    \ PMpA.20.\n      PMpA.16 Has LSR previously sent a Label Mapping for FEC to Peer?\n\
    \              If not goto PMpA.21.\n      PMpA.17 Is Hop Count in RAttributes\
    \ different from PrevHopCount ?\n              If not goto PMpA.21.\n      PMpA.18\
    \ Is the Hop Count in RAttributes > PrevHopCount? OR\n              Is PrevHopCount\
    \ unknown(0)\n              If not, goto PMpA.21.\n      PMpA.19 Add LSR Id to\
    \ beginning of Path Vector from RAttributes\n              and copy the resulting\
    \ Path Vector into SAttributes.\n              Goto PMpA.21.\n      PMpA.20 Include\
    \ Path Vector of length 1 containing LSR Id in\n              SAttributes.\n \
    \     PMpA.21 DONE.\n   Notes:\n      1. The link with Peer may require that Hop\
    \ Count be included in\n         Label Mapping messages; for example, see [RFC3035]\
    \ and\n         [RFC3034].\n      2. If the LSR is at the edge of a cloud of LSRs\
    \ that do not\n         perform TTL-decrement and it is propagating the Label\
    \ Mapping\n         message upstream into the cloud, it sets the Hop Count to\
    \ 1 so\n         that Hop Count across the cloud is calculated properly.  This\n\
    \         ensures proper TTL management for packets forwarded across the\n   \
    \      part of the LSP that passes through the cloud.\n      3. For hop count\
    \ arithmetic, unknown + 1 = unknown.\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2001).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
