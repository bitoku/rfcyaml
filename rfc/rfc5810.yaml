- title: __initial_text__
  contents:
  - "           Forwarding and Control Element Separation (ForCES)\n             \
    \            Protocol Specification\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies the Forwarding and Control Element Separation\n\
    \   (ForCES) protocol.  The ForCES protocol is used for communications\n   between\
    \ Control Elements(CEs) and Forwarding Elements (FEs) in a\n   ForCES Network\
    \ Element (ForCES NE).  This specification is intended\n   to meet the ForCES\
    \ protocol requirements defined in RFC 3654.\n   Besides the ForCES protocol,\
    \ this specification also defines the\n   requirements for the Transport Mapping\
    \ Layer (TML).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5810.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \   2. Terminology and Conventions .....................................6\n  \
    \    2.1. Requirements Language ......................................6\n    \
    \  2.2. Other Notation .............................................6\n      2.3.\
    \ Integers ...................................................6\n   3. Definitions\
    \ .....................................................6\n   4. Overview .......................................................10\n\
    \      4.1. Protocol Framework ........................................11\n  \
    \         4.1.1. The PL .............................................13\n    \
    \       4.1.2. The TML ............................................14\n      \
    \     4.1.3. The FEM/CEM Interface ..............................14\n      4.2.\
    \ ForCES Protocol Phases ....................................15\n           4.2.1.\
    \ Pre-association ....................................16\n           4.2.2. Post-association\
    \ ...................................18\n      4.3. Protocol Mechanisms .......................................19\n\
    \           4.3.1. Transactions, Atomicity, Execution, and Responses ..19\n  \
    \         4.3.2. Scalability ........................................25\n    \
    \       4.3.3. Heartbeat Mechanism ................................26\n      \
    \     4.3.4. FE Object and FE Protocol LFBs .....................27\n      4.4.\
    \ Protocol Scenarios ........................................27\n           4.4.1.\
    \ Association Setup State ............................27\n           4.4.2. Association\
    \ Established State or Steady State ......29\n   5. TML Requirements ...............................................31\n\
    \      5.1. TML Parameterization ......................................34\n  \
    \ 6. Message Encapsulation ..........................................35\n    \
    \  6.1. Common Header .............................................35\n      6.2.\
    \ Type Length Value (TLV) Structuring .......................40\n           6.2.1.\
    \ Nested TLVs ........................................41\n           6.2.2. Scope\
    \ of the T in TLV ..............................41\n      6.3. ILV .......................................................41\n\
    \      6.4. Important Protocol Encapsulations .........................42\n  \
    \         6.4.1. Paths ..............................................42\n    \
    \       6.4.2. Keys ...............................................42\n      \
    \     6.4.3. DATA TLVs ..........................................43\n        \
    \   6.4.4. Addressing LFB Entities ............................43\n   7. Protocol\
    \ Construction ..........................................44\n      7.1. Discussion\
    \ on Encoding ....................................48\n           7.1.1. Data Packing\
    \ Rules .................................48\n           7.1.2. Path Flags .........................................49\n\
    \           7.1.3. Relation of Operational Flags with Global\n               \
    \   Message Flags ......................................49\n           7.1.4.\
    \ Content Path Selection .............................49\n           7.1.5. LFBselect-TLV\
    \ ......................................49\n           7.1.6. OPER-TLV ...........................................50\n\
    \           7.1.7. RESULT TLV .........................................52\n  \
    \         7.1.8. DATA TLV ...........................................55\n    \
    \       7.1.9. SET and GET Relationship ...........................56\n      7.2.\
    \ Protocol Encoding Visualization ...........................56\n      7.3. Core\
    \ ForCES LFBs ..........................................59\n           7.3.1.\
    \ FE Protocol LFB ....................................60\n           7.3.2. FE\
    \ Object LFB ......................................63\n      7.4. Semantics of\
    \ Message Direction ............................63\n      7.5. Association Messages\
    \ ......................................64\n           7.5.1. Association Setup\
    \ Message ..........................64\n           7.5.2. Association Setup Response\
    \ Message .................66\n           7.5.3. Association Teardown Message\
    \ .......................68\n      7.6. Configuration Messages ....................................69\n\
    \           7.6.1. Config Message .....................................69\n  \
    \         7.6.2. Config Response Message ............................71\n    \
    \  7.7. Query Messages ............................................73\n      \
    \     7.7.1. Query Message ......................................73\n        \
    \   7.7.2. Query Response Message .............................75\n      7.8.\
    \ Event Notification Message ................................77\n      7.9. Packet\
    \ Redirect Message ...................................79\n      7.10. Heartbeat\
    \ Message ........................................82\n   8. High Availability\
    \ Support ......................................83\n      8.1. Relation with the\
    \ FE Protocol .............................83\n      8.2. Responsibilities for\
    \ HA ...................................86\n   9. Security Considerations ........................................87\n\
    \      9.1. No Security ...............................................87\n  \
    \         9.1.1. Endpoint Authentication ............................88\n    \
    \       9.1.2. Message Authentication .............................88\n      9.2.\
    \ ForCES PL and TML Security Service ........................88\n           9.2.1.\
    \ Endpoint Authentication Service ....................88\n           9.2.2. Message\
    \ Authentication Service .....................89\n           9.2.3. Confidentiality\
    \ Service ............................89\n   10. Acknowledgments ...............................................89\n\
    \   11. References ....................................................89\n  \
    \    11.1. Normative References .....................................89\n    \
    \  11.2. Informative References ...................................90\n   Appendix\
    \ A.  IANA Considerations ..................................91\n     A.1.  Message\
    \ Type Namespace ....................................91\n     A.2.  Operation\
    \ Selection .......................................92\n     A.3.  Header Flags\
    \ ..............................................93\n     A.4.  TLV Type Namespace\
    \ ........................................93\n     A.5.  RESULT-TLV Result Values\
    \ ..................................94\n     A.6.  Association Setup Response\
    \ ................................94\n     A.7.  Association Teardown Message\
    \ ..............................95\n   Appendix B.  ForCES Protocol LFB Schema\
    \ ...........................96\n     B.1.  Capabilities .............................................102\n\
    \     B.2.  Components ...............................................102\n  \
    \ Appendix C.  Data Encoding Examples ..............................103\n   Appendix\
    \ D.  Use Cases ...........................................107\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Forwarding and Control Element Separation (ForCES) defines\
    \ an\n   architectural framework and associated protocols to standardize\n   information\
    \ exchange between the control plane and the forwarding\n   plane in a ForCES\
    \ Network Element (ForCES NE).  RFC 3654 has defined\n   the ForCES requirements,\
    \ and RFC 3746 has defined the ForCES\n   framework.  While there may be multiple\
    \ protocols used within the\n   overall ForCES architecture, the terms \"ForCES\
    \ protocol\" and\n   \"protocol\" as used in this document refer to the protocol\
    \ used to\n   standardize the information exchange between Control Elements (CEs)\n\
    \   and Forwarding Elements (FEs) only.\n   The ForCES FE model [RFC5812] presents\
    \ a formal way to define FE\n   Logical Function Blocks (LFBs) using XML.  LFB\
    \ configuration\n   components, capabilities, and associated events are defined\
    \ when the\n   LFB is formally created.  The LFBs within the FE are accordingly\n\
    \   controlled in a standardized way by the ForCES protocol.\n   This document\
    \ defines the ForCES protocol specifications.  The ForCES\n   protocol works in\
    \ a master-slave mode in which FEs are slaves and CEs\n   are masters.  The protocol\
    \ includes commands for transport of LFB\n   configuration information, association\
    \ setup, status, event\n   notifications, etc.\n   Section 3 provides a glossary\
    \ of terminology used in the\n   specification.\n   Section 4 provides an overview\
    \ of the protocol, including a\n   discussion on the protocol framework and descriptions\
    \ of the Protocol\n   Layer (PL), a Transport Mapping Layer (TML), and the ForCES\
    \ protocol\n   mechanisms.  Section 4.4 describes several protocol scenarios and\n\
    \   includes message exchange descriptions.\n   While this document does not define\
    \ the TML, Section 5 details the\n   services that a TML MUST provide (TML requirements).\n\
    \   The ForCES protocol defines a common header for all protocol\n   messages.\
    \  The header is defined in Section 6.1, while the protocol\n   messages are defined\
    \ in Section 7.\n   Section 8 describes the protocol support for high-availability\n\
    \   mechanisms including redundancy and fail over.\n   Section 9 defines the security\
    \ mechanisms provided by the PL and TML.\n"
- title: 2.  Terminology and Conventions
  contents:
  - '2.  Terminology and Conventions

    '
- title: 2.1.  Requirements Language
  contents:
  - "2.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 2.2.  Other Notation
  contents:
  - "2.2.  Other Notation\n   In Table 1 and Table 2, the following notation is used\
    \ to indicate\n   multiplicity:\n      (value)+ .... means \"1 or more instances\
    \ of value\"\n      (value)* .... means \"0 or more instances of value\"\n"
- title: 2.3.  Integers
  contents:
  - "2.3.  Integers\n   All integers are to be coded as unsigned binary integers of\n\
    \   appropriate length.\n"
- title: 3.  Definitions
  contents:
  - "3.  Definitions\n   This document follows the terminology defined by the ForCES\n\
    \   requirements in [RFC3654] and by the ForCES framework in [RFC3746].\n   The\
    \ definitions be are repeated below for clarity.\n   Addressable Entity (AE):\n\
    \   A physical device that is directly addressable given some\n   interconnect\
    \ technology.  For example, on IP networks, it is a device\n   that can be reached\
    \ using an IP address; and on a switch fabric, it\n   is a device that can be\
    \ reached using a switch fabric port number.\n   Control Element (CE):\n   A logical\
    \ entity that implements the ForCES protocol and uses it to\n   instruct one or\
    \ more FEs on how to process packets.  CEs handle\n   functionality such as the\
    \ execution of control and signaling\n   protocols.\n   CE Manager (CEM):\n  \
    \ A logical entity responsible for generic CE management tasks.  It is\n   particularly\
    \ used during the pre-association phase to determine with\n   which FE(s) a CE\
    \ should communicate.  This process is called FE\n   discovery and may involve\
    \ the CE manager learning the capabilities of\n   available FEs.\n   Data Path:\n\
    \   A conceptual path taken by packets within the forwarding plane inside\n  \
    \ an FE.\n   Forwarding Element (FE):\n   A logical entity that implements the\
    \ ForCES protocol.  FEs use the\n   underlying hardware to provide per-packet\
    \ processing and handling as\n   directed/controlled by one or more CEs via the\
    \ ForCES protocol.\n   FE Model:\n   A model that describes the logical processing\
    \ functions of an FE.\n   The FE model is defined using Logical Function Blocks\
    \ (LFBs).\n   FE Manager (FEM):\n   A logical entity responsible for generic FE\
    \ management tasks.  It is\n   used during the pre-association phase to determine\
    \ with which CE(s)\n   an FE should communicate.  This process is called CE discovery\
    \ and\n   may involve the FE manager learning the capabilities of available\n\
    \   CEs.  An FE manager may use anything from a static configuration to a\n  \
    \ pre-association phase protocol (see below) to determine which CE(s)\n   to use.\
    \  Being a logical entity, an FE manager might be physically\n   combined with\
    \ any of the other logical entities such as FEs.\n   ForCES Network Element (NE):\n\
    \   An entity composed of one or more CEs and one or more FEs.  To\n   entities\
    \ outside an NE, the NE represents a single point of\n   management.  Similarly,\
    \ an NE usually hides its internal organization\n   from external entities.\n\
    \   High Touch Capability:\n   This term will be used to apply to the capabilities\
    \ found in some\n   forwarders to take action on the contents or headers of a\
    \ packet\n   based on content other than what is found in the IP header.  Examples\n\
    \   of these capabilities include quality of service (QoS) policies,\n   virtual\
    \ private networks, firewall, and L7 content recognition.\n   Inter-FE Topology:\n\
    \   See FE Topology.\n   Intra-FE Topology:\n   See LFB Topology.\n   LFB (Logical\
    \ Function Block):\n   The basic building block that is operated on by the ForCES\
    \ protocol.\n   The LFB is a well-defined, logically separable functional block\
    \ that\n   resides in an FE and is controlled by the CE via the ForCES protocol.\n\
    \   The LFB may reside at the FE's data path and process packets or may\n   be\
    \ purely an FE control or configuration entity that is operated on\n   by the\
    \ CE.  Note that the LFB is a functionally accurate abstraction\n   of the FE's\
    \ processing capabilities, but not a hardware-accurate\n   representation of the\
    \ FE implementation.\n   FE Topology:\n   A representation of how the multiple\
    \ FEs within a single NE are\n   interconnected.  Sometimes this is called inter-FE\
    \ topology, to be\n   distinguished from intra-FE topology (i.e., LFB topology).\n\
    \   LFB Class and LFB Instance:\n   LFBs are categorized by LFB classes.  An LFB\
    \ instance represents an\n   LFB class (or type) existence.  There may be multiple\
    \ instances of\n   the same LFB class (or type) in an FE.  An LFB class is represented\n\
    \   by an LFB class ID, and an LFB instance is represented by an LFB\n   instance\
    \ ID.  As a result, an LFB class ID associated with an LFB\n   instance ID uniquely\
    \ specifies an LFB existence.\n   LFB Meta Data:\n   Meta data is used to communicate\
    \ per-packet state from one LFB to\n   another, but is not sent across the network.\
    \  The FE model defines\n   how such meta data is identified, produced, and consumed\
    \ by the LFBs.\n   It defines the functionality but not how meta data is encoded\
    \ within\n   an implementation.\n   LFB Component:\n   Operational parameters\
    \ of the LFBs that must be visible to the CEs\n   are conceptualized in the FE\
    \ model as the LFB components.  The LFB\n   components include, for example, flags,\
    \ single parameter arguments,\n   complex arguments, and tables that the CE can\
    \ read and/or write via\n   the ForCES protocol (see below).\n   LFB Topology:\n\
    \   Representation of how the LFB instances are logically interconnected\n   and\
    \ placed along the data path within one FE.  Sometimes it is also\n   called intra-FE\
    \ topology, to be distinguished from inter-FE topology.\n   Pre-association Phase:\n\
    \   The period of time during which an FE manager and a CE manager are\n   determining\
    \ which FE(s) and CE(s) should be part of the same network\n   element.\n   Post-association\
    \ Phase:\n   The period of time during which an FE knows which CE is to control\
    \ it\n   and vice versa.  This includes the time during which the CE and FE\n\
    \   are establishing communication with one another.\n   ForCES Protocol:\n  \
    \ While there may be multiple protocols used within the overall ForCES\n   architecture,\
    \ the terms \"ForCES protocol\" and \"protocol\" refer to the\n   Fp reference\
    \ points in the ForCES framework in [RFC3746].  This\n   protocol does not apply\
    \ to CE-to-CE communication, FE-to-FE\n   communication, or communication between\
    \ FE and CE managers.\n   Basically, the ForCES protocol works in a master-slave\
    \ mode in which\n   FEs are slaves and CEs are masters.  This document defines\
    \ the\n   specifications for this ForCES protocol.\n   ForCES Protocol Layer (ForCES\
    \ PL):\n   A layer in the ForCES protocol architecture that defines the ForCES\n\
    \   protocol messages, the protocol state transfer scheme, and the ForCES\n  \
    \ protocol architecture itself (including requirements of ForCES TML as\n   shown\
    \ below).  Specifications of ForCES PL are defined by this\n   document.\n   ForCES\
    \ Protocol Transport Mapping Layer (ForCES TML):\n   A layer in ForCES protocol\
    \ architecture that uses the capabilities of\n   existing transport protocols\
    \ to specifically address protocol message\n   transportation issues, such as\
    \ how the protocol messages are mapped\n   to different transport media (like\
    \ TCP, IP, ATM, Ethernet, etc.), and\n   how to achieve and implement reliability,\
    \ multicast, ordering, etc.\n   The ForCES TML specifications are detailed in\
    \ separate ForCES\n   documents, one for each TML.\n"
- title: 4.  Overview
  contents:
  - "4.  Overview\n   The reader is referred to the framework document [RFC3746],\
    \ and in\n   particular, Sections 3 and 4, for an architectural overview and an\n\
    \   explanation of how the ForCES protocol fits in.  There may be some\n   content\
    \ overlap between the framework document and this section in\n   order to provide\
    \ clarity.  This document is authoritative on the\n   protocol, whereas [RFC3746]\
    \ is authoritative on the architecture.\n"
- title: 4.1.  Protocol Framework
  contents:
  - "4.1.  Protocol Framework\n   Figure 1 below is reproduced from the framework\
    \ document for clarity.\n   It shows an NE with two CEs and two FEs.\n       \
    \                     ---------------------------------------\n              \
    \              | ForCES Network Element              |\n     --------------  \
    \ Fc    | --------------      --------------  |\n     | CE Manager |---------+-|\
    \     CE 1   |------|    CE 2    |  |\n     --------------         | |       \
    \     |  Fr  |            |  |\n           |                | -------------- \
    \     --------------  |\n           | Fl             |         |  |    Fp    \
    \   /          |\n           |                |       Fp|  |----------| /    \
    \       |\n           |                |         |             |/            |\n\
    \           |                |         |             |             |\n       \
    \    |                |         |     Fp     /|----|        |\n           |  \
    \              |         |  /--------/      |        |\n     --------------  \
    \   Ff  | --------------      --------------  |\n     | FE Manager |---------+-|\
    \     FE 1   |  Fi  |     FE 2   |  |\n     --------------         | |       \
    \     |------|            |  |\n                            | -------------- \
    \     --------------  |\n                            |   |  |  |  |          |\
    \  |  |  |    |\n                            ----+--+--+--+----------+--+--+--+-----\n\
    \                                |  |  |  |          |  |  |  |\n            \
    \                    |  |  |  |          |  |  |  |\n                        \
    \          Fi/f                   Fi/f\n          Fp: CE-FE interface\n      \
    \    Fi: FE-FE interface\n          Fr: CE-CE interface\n          Fc: Interface\
    \ between the CE manager and a CE\n          Ff: Interface between the FE manager\
    \ and an FE\n          Fl: Interface between the CE manager and the FE manager\n\
    \          Fi/f: FE external interface\n                  Figure 1: ForCES Architectural\
    \ Diagram\n   The ForCES protocol domain is found in the Fp reference points.\
    \  The\n   Protocol Element configuration reference points, Fc and Ff, also play\n\
    \   a role in the booting up of the ForCES protocol.  The protocol\n   element\
    \ configuration (indicated by reference points Fc, Ff, and Fl\n   in [RFC3746])\
    \ is out of scope of the ForCES protocol but is touched\n   on in this document\
    \ in discussion of FEM and CEM since it is an\n   integral part of the protocol\
    \ pre-association phase.\n   Figure 2 below shows further breakdown of the Fp\
    \ interfaces by means\n   of the example of an MPLS QoS-enabled Network Element.\n\
    \         -------------------------------------------------\n         |      \
    \ |       |       |       |       |       |\n         |OSPF   |RIP    |BGP   \
    \ |RSVP   |LDP    |. . .  |\n         |       |       |       |       |      \
    \ |       |\n         -------------------------------------------------    CE\n\
    \         |               ForCES Interface                |\n         -------------------------------------------------\n\
    \                                 ^   ^\n                                 |  \
    \ |\n                         ForCES  |   |data\n                         control\
    \ |   |packets\n                         messages|   |(e.g., routing packets)\n\
    \                                 |   |\n                                 v  \
    \ v\n         -------------------------------------------------\n         |  \
    \             ForCES Interface                |\n         -------------------------------------------------\
    \    FE\n         |       |       |       |       |       |       |\n        \
    \ |LPM Fwd|Meter  |Shaper |MPLS   |Classi-|. . .  |\n         |       |      \
    \ |       |       |fier   |       |\n         -------------------------------------------------\n\
    \                 Figure 2: Examples of CE and FE Functions\n   The ForCES interface\
    \ shown in Figure 2 constitutes two pieces: the PL\n   and the TML.\n   This is\
    \ depicted in Figure 3 below.\n         +------------------------------------------------\n\
    \         |               CE PL                           |\n         +------------------------------------------------\n\
    \         |              CE TML                           |\n         +------------------------------------------------\n\
    \                                   ^\n                                   |\n\
    \                      ForCES       |   (i.e.,  ForCES data + control\n      \
    \                PL           |    packets )\n                      messages \
    \    |\n                      over         |\n                      specific \
    \    |\n                      TML          |\n                      encaps   \
    \    |\n                      and          |\n                      transport\
    \    |\n                                   |\n                               \
    \    v\n         +------------------------------------------------\n         |\
    \              FE TML                           |\n         +------------------------------------------------\n\
    \         |               FE PL                           |\n         +------------------------------------------------\n\
    \                        Figure 3: ForCES Interface\n   The PL is in fact the\
    \ ForCES protocol.  Its semantics and message\n   layout are defined in this document.\
    \  The TML layer is necessary to\n   connect two ForCES PLs as shown in Figure\
    \ 3 above.  The TML is out of\n   scope for this document but is within scope\
    \ of ForCES.  This document\n   defines requirements the PL needs the TML to meet.\n\
    \   Both the PL and the TML are standardized by the IETF.  While only one\n  \
    \ PL is defined, different TMLs are expected to be standardized.  To\n   interoperate,\
    \ the TML at the CE and FE are expected to conform to the\n   same definition.\n\
    \   On transmit, the PL delivers its messages to the TML.  The local TML\n   delivers\
    \ the message to the destination TML.  On receive, the TML\n   delivers the message\
    \ to its destination PL.\n"
- title: 4.1.1.  The PL
  contents:
  - "4.1.1.  The PL\n   The PL is common to all implementations of ForCES and is standardized\n\
    \   by the IETF as defined in this document.  The PL is responsible for\n   associating\
    \ an FE or CE to an NE.  It is also responsible for tearing\n   down such associations.\
    \  An FE uses the PL to transmit various\n   subscribed-to events to the CE PL\
    \ as well as to respond to various\n   status requests issued from the CE PL.\
    \  The CE configures both the FE\n   and associated LFBs' operational parameters\
    \ using the PL.  In\n   addition, the CE may send various requests to the FE to\
    \ activate or\n   deactivate it, reconfigure its HA parameterization, subscribe\
    \ to\n   specific events, etc.  More details can be found in Section 7.\n"
- title: 4.1.2.  The TML
  contents:
  - "4.1.2.  The TML\n   The TML transports the PL messages.  The TML is where the\
    \ issues of\n   how to achieve transport-level reliability, congestion control,\n\
    \   multicast, ordering, etc. are handled.  It is expected that more than\n  \
    \ one TML will be standardized.  The various possible TMLs could vary\n   their\
    \ implementations based on the capabilities of underlying media\n   and transport.\
    \  However, since each TML is standardized,\n   interoperability is guaranteed\
    \ as long as both endpoints support the\n   same TML.  All ForCES protocol layer\
    \ implementations MUST be portable\n   across all TMLs, because all TMLs MUST\
    \ have the top-edge semantics\n   defined in this document.\n"
- title: 4.1.3.  The FEM/CEM Interface
  contents:
  - "4.1.3.  The FEM/CEM Interface\n   The FEM and CEM components, although valuable\
    \ in the setup and\n   configurations of both the PL and TML, are out of scope\
    \ of the ForCES\n   protocol.  The best way to think of them is as configurations/\n\
    \   parameterizations for the PL and TML before they become active (or\n   even\
    \ at runtime based on implementation).  In the simplest case, the\n   FE or CE\
    \ reads a static configuration file.  RFC 3746 has a more\n   detailed description\
    \ on how the FEM and CEM could be used.  The pre-\n   association phase, where\
    \ the CEM and FEM can be used, are described\n   briefly in Section 4.2.1.\n \
    \  An example of typical things the FEM/CEM could configure would be\n   TML-specific\
    \ parameterizations such as:\n   a.  How the TML connection should happen (for\
    \ example, what IP\n       addresses to use, transport modes, etc.)\n   b.  The\
    \ ID for the FE (FEID) or CE (CEID) (which would also be issued\n       during\
    \ the pre-association phase)\n   c.  Security parameterization such as keys, etc.\n\
    \   d.  Connection association parameters\n   An example of connection association\
    \ parameters might be:\n   o  simple parameters: send up to 3 association messages\
    \ every 1\n      second\n   o  complex parameters: send up to 4 association messages\
    \ with\n      increasing exponential timeout\n"
- title: 4.2.  ForCES Protocol Phases
  contents:
  - "4.2.  ForCES Protocol Phases\n   ForCES, in relation to NEs, involves two phases:\
    \ the pre-association\n   phase where configuration/initialization/bootup of the\
    \ TML and PL\n   layer happens, and the post-association phase where the ForCES\n\
    \   protocol operates to manipulate the parameters of the FEs.\n             \
    \          CE sends Association Setup\n           +---->--->------------>---->---->---->------->----+\n\
    \           |                                                 Y\n           ^\
    \                                                 |\n           |            \
    \                                     Y\n       +---+-------+                \
    \                     +-------------+\n       |FE pre-    |                  \
    \                   | FE post-    |\n       |association|    CE sends Association\
    \ Teardown    | association |\n       |phase      |<------- <------<-----<------<-------+\
    \ phase       |\n       |           |                                     |  \
    \           |\n       +-----------+                                     +-------------+\n\
    \             ^                                               Y\n            \
    \ |                                               |\n             +-<---<------<-----<------<----<---------<------+\n\
    \                           FE loses association\n                     Figure\
    \ 4: The FE Protocol Phases\n   In the mandated case, once associated, the FE\
    \ may forward packets\n   depending on the configuration of its specific LFBs.\
    \  An FE that is\n   associated to a CE will continue sending packets until it\
    \ receives an\n   Association Teardown Message or until it loses association.\
    \  An\n   unassociated FE MAY continue sending packets when it has a high\n  \
    \ availability capability.  The extra details are explained in\n   Section 8 and\
    \ not discussed here to allow for a clear explanation of\n   the basics.\n   The\
    \ FE state transitions are controlled by means of the FE Object LFB\n   FEState\
    \ component, which is defined in [RFC5812], Section 5.1, and\n   also explained\
    \ in Section 7.3.2.\n   The FE initializes in the FEState OperDisable.  When the\
    \ FE is ready\n   to process packets in the data path, it transitions itself to\
    \ the\n   OperEnable state.\n   The CE may decide to pause the FE after it already\
    \ came up as\n   OperEnable.  It does this by setting the FEState to AdminDisable.\n\
    \   The FE stays in the AdminDisable state until it is explicitly\n   configured\
    \ by the CE to transition to the OperEnable state.\n   When the FE loses its association\
    \ with the CE, it may go into the\n   pre-association phase depending on the programmed\
    \ policy.  For the FE\n   to properly complete the transition to the AdminDisable\
    \ state, it\n   MUST stop packet forwarding and this may impact multiple LFBS.\
    \  How\n   this is achieved is outside the scope of this specification.\n"
- title: 4.2.1.  Pre-association
  contents:
  - "4.2.1.  Pre-association\n   The ForCES interface is configured during the pre-association\
    \ phase.\n   In a simple setup, the configuration is static and is typically read\n\
    \   from a saved configuration file.  All the parameters for the\n   association\
    \ phase are well known after the pre-association phase is\n   complete.  A protocol\
    \ such as DHCP may be used to retrieve the\n   configuration parameters instead\
    \ of reading them from a static\n   configuration file.  Note, this will still\
    \ be considered static pre-\n   association.  Dynamic configuration may also happen\
    \ using the Fc, Ff,\n   and Fl reference points (refer to [RFC3746]).  Vendors\
    \ may use their\n   own proprietary service discovery protocol to pass the parameters.\n\
    \   Essentially, only guidelines are provided here and the details are\n   left\
    \ to the implementation.\n   The following are scenarios reproduced from the framework\
    \ document to\n   show a pre-association example.\n      <----Ff ref pt--->  \
    \            <--Fc ref pt------->\n      FE Manager      FE                CE\
    \ Manager    CE\n       |              |                 |             |\n   \
    \    |              |                 |             |\n    (security exchange)\
    \               (security exchange)\n      1|<------------>| authentication 1|<----------->|authentication\n\
    \       |              |                 |             |\n     (FE ID, components)\
    \              (CE ID, components)\n      2|<-------------| request        2|<------------|request\n\
    \       |              |                 |             |\n      3|------------->|\
    \ response       3|------------>|response\n      (corresponding CE ID)       \
    \   (corresponding FE ID)\n       |              |                 |         \
    \    |\n       |              |                 |             |\n        Figure\
    \ 5: Examples of a Message Exchange over the Ff and Fc\n                     \
    \        Reference Points\n      <-----------Fl ref pt-------------->        \
    \    |\n      FE Manager      FE               CE Manager     CE\n       |   \
    \           |                 |             |\n       |              |       \
    \          |             |\n      (security exchange)               |        \
    \     |\n      1|<------------------------------>|             |\n       |   \
    \           |                 |             |\n      (a list of CEs and their\
    \ components)            |\n      2|<-------------------------------|        \
    \     |\n       |              |                 |             |\n      (a list\
    \ of FEs and their components)            |\n      3|------------------------------->|\
    \             |\n       |              |                 |             |\n   \
    \    |              |                 |             |\n    Figure 6: Example of\
    \ a Message Exchange over the Fl Reference Point\n   Before the transition to\
    \ the association phase, the FEM will have\n   established contact with a CEM\
    \ component.  Initialization of the\n   ForCES interface will have completed,\
    \ and authentication as well as\n   capability discovery may be complete.  Both\
    \ the FE and CE would have\n   the necessary information for connecting to each\
    \ other for\n   configuration, accounting, identification, and authentication\n\
    \   purposes.  To summarize, at the completion of this stage both sides\n   have\
    \ all the necessary protocol parameters such as timers, etc.  The\n   Fl reference\
    \ point may continue to operate during the association\n   phase and may be used\
    \ to force a disassociation of an FE or CE.  The\n   specific interactions of\
    \ the CEM and the FEM that are part of the\n   pre-association phase are out of\
    \ scope; for this reason, these\n   details are not discussed any further in this\
    \ specification.  The\n   reader is referred to the framework document [RFC3746]\
    \ for a slightly\n   more detailed discussion.\n"
- title: 4.2.2.  Post-association
  contents:
  - "4.2.2.  Post-association\n   In this phase, the FE and CE components communicate\
    \ with each other\n   using the ForCES protocol (PL over TML) as defined in this\
    \ document.\n   There are three sub-phases:\n   o  Association Setup Stage\n \
    \  o  Established Stage\n   o  Association Lost Stage\n"
- title: 4.2.2.1.  Association Setup Stage
  contents:
  - "4.2.2.1.  Association Setup Stage\n   The FE attempts to join the NE.  The FE\
    \ may be rejected or accepted.\n   Once granted access into the NE, capabilities\
    \ exchange happens with\n   the CE querying the FE.  Once the CE has the FE capability\n\
    \   information, the CE can offer an initial configuration (possibly to\n   restore\
    \ state) and can query certain components within either an LFB\n   or the FE itself.\n\
    \   More details are provided in Section 4.4.\n   On successful completion of\
    \ this stage, the FE joins the NE and is\n   moved to the Established Stage.\n"
- title: 4.2.2.2.  Established Stage
  contents:
  - "4.2.2.2.  Established Stage\n   In this stage, the FE is continuously updated\
    \ or queried.  The FE may\n   also send asynchronous event notifications to the\
    \ CE or synchronous\n   heartbeat notifications if programmed to do so.  This\
    \ stage continues\n   until a termination occurs, either due to loss of connectivity\
    \ or due\n   to a termination initiated by either the CE or the FE.\n   Refer\
    \ to the section on protocol scenarios, Section 4.4, for more\n   details.\n"
- title: 4.2.2.3.  Association Lost Stage
  contents:
  - "4.2.2.3.  Association Lost Stage\n   In this stage, both or either the CE or\
    \ FE declare the other side is\n   no longer associated.  The disconnection could\
    \ be initiated by either\n   party for administrative purposes but may also be\
    \ driven by\n   operational reasons such as loss of connectivity.\n   A core LFB\
    \ known as the FE Protocol Object (FEPO) is defined (refer\n   to Appendix B and\
    \ Section 7.3.1).  FEPO defines various timers that\n   can be used in conjunction\
    \ with a traffic-sensitive heartbeat\n   mechanism (Section 4.3.3) to detect loss\
    \ of connectivity.\n   The loss of connectivity between TMLs does not indicate\
    \ a loss of\n   association between respective PL layers.  If the TML cannot repair\n\
    \   the transport loss before the programmed FEPO timer thresholds\n   associated\
    \ with the FE is exceeded, then the association between the\n   respective PL\
    \ layers will be lost.\n   FEPO defines several policies that can be programmed\
    \ to define\n   behavior upon a detected loss of association.  The FEPO's programmed\n\
    \   CE failover policy (refer to Sections 8, 7.3.1, 4.3.3, and B) defines\n  \
    \ what takes place upon loss of association.\n   For this version of the protocol\
    \ (as defined in this document), the\n   FE, upon re-association, MUST discard\
    \ any state it has as invalid and\n   retrieve new state.  This approach is motivated\
    \ by a desire for\n   simplicity (as opposed to efficiency).\n"
- title: 4.3.  Protocol Mechanisms
  contents:
  - "4.3.  Protocol Mechanisms\n   Various semantics are exposed to the protocol users\
    \ via the PL header\n   including transaction capabilities, atomicity of transactions,\
    \ two-\n   phase commits, batching/parallelization, high availability, and\n \
    \  failover as well as command pipelines.\n   The EM (Execution Mode) flag, AT\
    \ (Atomic Transaction) flag, and TP\n   (Transaction Phase) flag as defined in\
    \ the common header\n   (Section 6.1) are relevant to these mechanisms.\n"
- title: 4.3.1.  Transactions, Atomicity, Execution, and Responses
  contents:
  - "4.3.1.  Transactions, Atomicity, Execution, and Responses\n   In the master-slave\
    \ relationship, the CE instructs one or more FEs on\n   how to execute operations\
    \ and how to report the results.\n   This section details the different modes\
    \ of execution that a CE can\n   order the FE(s) to perform, as defined in Section\
    \ 4.3.1.1.  It also\n   describes the different modes a CE can ask the FE(s) to\
    \ use for\n   formatting the responses after processing the operations as\n  \
    \ requested.  These modes relate to the transactional two-phase commit\n   operations.\n"
- title: 4.3.1.1.  Execution
  contents:
  - "4.3.1.1.  Execution\n   There are 3 execution modes that can be requested for\
    \ a batch of\n   operations spanning one or more LFB selectors (refer to\n   Section\
    \ 7.1.5) in one protocol message.  The EM flag defined in the\n   common header\
    \ (Section 6.1) selects the execution mode for a protocol\n   message, as below:\n\
    \   a.  execute-all-or-none\n   b.  continue-execute-on-failure\n   c.  execute-until-failure\n"
- title: 4.3.1.1.1.  execute-all-or-none
  contents:
  - "4.3.1.1.1.  execute-all-or-none\n   When set to this mode of execution, independent\
    \ operations in a\n   message MAY be targeted at one or more LFB selectors within\
    \ an FE.\n   All these operations are executed serially, and the FE MUST have\
    \ no\n   execution failure for any of the operations.  If any operation fails\n\
    \   to execute, then all the previous ones that have been executed prior\n   to\
    \ the failure will need to be undone.  That is, there is rollback\n   for this\
    \ mode of operation.\n   Refer to Section 4.3.1.2.2 for how this mode is used\
    \ in cases of\n   transactions.  In such a case, no operation is executed unless\
    \ a\n   commit is issued by the CE.\n   Care should be taken on how this mode\
    \ is used because a mis-\n   configuration could result in traffic losses.  To\
    \ add certainty to\n   the success of an operation, one should use this mode in\
    \ a\n   transactional operation as described in Section 4.3.1.2.2\n"
- title: 4.3.1.1.2.  continue-execute-on-failure
  contents:
  - "4.3.1.1.2.  continue-execute-on-failure\n   If several independent operations\
    \ are targeted at one or more LFB\n   selectors, execution continues for all operations\
    \ at the FE even if\n   one or more operations fail.\n"
- title: 4.3.1.1.3.  execute-until-failure
  contents:
  - "4.3.1.1.3.  execute-until-failure\n   In this mode, all operations are executed\
    \ on the FE sequentially\n   until the first failure.  The rest of the operations\
    \ are not executed\n   but operations already completed are not undone.  That\
    \ is, there is\n   no rollback in this mode of operation.\n"
- title: 4.3.1.2.  Transaction and Atomicity
  contents:
  - '4.3.1.2.  Transaction and Atomicity

    '
- title: 4.3.1.2.1.  Transaction Definition
  contents:
  - "4.3.1.2.1.  Transaction Definition\n   A transaction is defined as a collection\
    \ of one or more ForCES\n   operations within one or more PL messages that MUST\
    \ meet the ACIDity\n   properties [ACID], defined as:\n   Atomicity:   In a transaction\
    \ involving two or more discrete pieces\n                of information, either\
    \ all of the pieces are committed\n                or none are.\n   Consistency:\
    \ A transaction either creates a new and valid state of\n                data\
    \ or, if any failure occurs, returns all data to the\n                state it\
    \ was in before the transaction was started.\n   Isolation:   A transaction in\
    \ process and not yet committed MUST\n                remain isolated from any\
    \ other transaction.\n   Durability:  Committed data is saved by the system such\
    \ that, even in\n                the event of a failure and a system restart,\
    \ the data is\n                available in its correct state.\n   There are cases\
    \ where the CE knows exact memory and implementation\n   details of the FE such\
    \ as in the case of an FE-CE pair from the same\n   vendor where the FE-CE pair\
    \ is tightly coupled.  In such a case, the\n   transactional operations may be\
    \ simplified further by extra\n   computation at the CE.  This view is not discussed\
    \ further other than\n   to mention that it is not disallowed.\n   As defined\
    \ above, a transaction is always atomic and MAY be\n   a.  Within an FE alone\n\
    \       Example: updating multiple tables that are dependent on each\n       other.\
    \  If updating one fails, then any that were already updated\n       MUST be undone.\n\
    \   b.  Distributed across the NE\n       Example: updating table(s) that are\
    \ inter-dependent across\n       several FEs (such as L3 forwarding-related tables).\n"
- title: 4.3.1.2.2.  Transaction Protocol
  contents:
  - "4.3.1.2.2.  Transaction Protocol\n   By use of the execution mode, as defined\
    \ in Section 4.3.1.1, the\n   protocol has provided a mechanism for transactional\
    \ operations within\n   one stand-alone message.  The 'execute-all-or-none' mode\
    \ can meet the\n   ACID requirements.\n   For transactional operations of multiple\
    \ messages within one FE or\n   across FEs, a classical transactional protocol\
    \ known as two-phase\n   commit (2PC) [2PCREF] is supported by the protocol to\
    \ achieve the\n   transactional operations utilizing Config messages (Section\
    \ 7.6.1).\n   The COMMIT and TRCOMP operations in conjunction with the AT and\
    \ the\n   TP flags in the common header (Section 6.1) are provided for 2PC-\n\
    \   based transactional operations spanning multiple messages.\n   The AT flag,\
    \ when set, indicates that this message belongs to an\n   Atomic Transaction.\
    \  All messages for a transaction operation MUST\n   have the AT flag set.  If\
    \ not set, it means that the message is a\n   stand-alone message and does not\
    \ participate in any transaction\n   operation that spans multiple messages.\n\
    \   The TP flag indicates the Transaction Phase to which this message\n   belongs.\
    \  There are 4 possible phases for a transactional operation\n   known as:\n \
    \     SOT (Start of Transaction)\n      MOT (Middle of Transaction)\n      EOT\
    \ (End of Transaction)\n      ABT (Abort)\n   The COMMIT operation is used by\
    \ the CE to signal to the FE(s) to\n   commit a transaction.  When used with an\
    \ ABT TP flag, the COMMIT\n   operation signals the FE(s) to roll back (i.e.,\
    \ un-COMMIT) a\n   previously committed transaction.\n   The TRCOMP operation\
    \ is a small addition to the classical 2PC\n   approach.  TRCOMP is sent by the\
    \ CE to signal to the FE(s) that the\n   transaction they have COMMITed is now\
    \ over.  This allows the FE(s) an\n   opportunity to clear state they may have\
    \ kept around to perform a\n   roll back (if it became necessary).\n   A transaction\
    \ operation is started with a message in which the TP\n   flag is set to Start\
    \ of Transaction (SOT).  Multi-part messages,\n   after the first one, are indicated\
    \ by the Middle of Transaction (MOT)\n   flag.  All messages from the CE MUST\
    \ set the AlwaysACK flag\n   (Section 6) to solicit responses from the FE(s).\n\
    \   Before the CE issues a commit (described further below), the FE MUST\n   only\
    \ validate that the operation can be executed but not execute it.\n      Any failure\
    \ notified by an FE causes the CE to abort the\n      transaction on all FEs involved\
    \ in the transaction.  This is\n      achieved by sending a Config message with\
    \ an ABT flag and a COMMIT\n      operation.\n      If there are no failures by\
    \ any participating FE, the transaction\n      commitment phase is signaled from\
    \ the CE to the FE by an End of\n      Transaction (EOT) configuration message\
    \ with a COMMIT operation.\n   The FE MUST respond to the CE's EOT message.  There\
    \ are two possible\n   failure scenarios in which the CE MUST abort the transaction\
    \ (as\n   described above):\n   a.  If any participating FE responds with a failure\
    \ message in\n       relation to the transaction.\n   b.  If no response is received\
    \ from a participating FE within a\n       specified timeout.\n   If all participating\
    \ FEs respond with a success indicator within the\n   expected time, then the\
    \ CE MUST issue a TRCOMP operation to all\n   participating FEs.  An FE MUST NOT\
    \ respond to a TRCOMP.\n   Note that a transactional operation is generically\
    \ atomic; therefore,\n   it requires that the execution modes of all messages\
    \ in a transaction\n   operation should always be kept the same and be set to\
    \ 'execute-all-\n   or-none'.  If the EM flag is set to other execution modes,\
    \ it will\n   result in a transaction failure.\n   As noted above, a transaction\
    \ may span multiple messages.  It is up\n   to the CE to keep track of the different\
    \ outstanding messages making\n   up a transaction.  As an example, the correlator\
    \ field could be used\n   to mark transactions and a sequence field to label the\
    \ different\n   messages within the same atomic transaction, but this is out of\
    \ scope\n   and up to implementations.\n"
- title: 4.3.1.2.3.  Recovery
  contents:
  - "4.3.1.2.3.  Recovery\n   Any of the participating FEs or the CE or the associations\
    \ between\n   them may fail after the EOT Response message has been sent by the\
    \ FE\n   but before the CE has received all the responses, e.g., if the EOT\n\
    \   response never reaches the CE.\n   In this protocol revision, as indicated\
    \ in Section 4.2.2.3, an FE\n   losing an association would be required to get\
    \ entirely new state\n   from the newly associated CE upon a re-association. \
    \ Although this\n   approach is simplistic and provides likeliness of losing data\
    \ path\n   traffic, it is a design choice to avoid the additional complexity of\n\
    \   managing graceful restarts.  The HA mechanisms (Section 8) are\n   provided\
    \ to allow for a continuous operation in case of FE failures.\n   Flexibility\
    \ is provided on how to react when an FE loses association.\n   This is dictated\
    \ by the CE failover policy (refer to Section 8 and\n   Section 7.3).\n"
- title: 4.3.1.2.4.  Transaction Messaging Example
  contents:
  - "4.3.1.2.4.  Transaction Messaging Example\n   This section illustrates an example\
    \ of how a successful two-phase\n   commit between a CE and an FE would look in\
    \ the simple case.\n         FE PL                                           \
    \       CE PL\n           |                                                  \
    \    |\n           | (1) Config, SOT,AT, EM=All-or-None, OP= SET/DEL,etc  |\n\
    \           |<-----------------------------------------------------|\n       \
    \    |                                                      |\n           | (2)\
    \ ACKnowledge                                      |\n           |----------------------------------------------------->|\n\
    \           |                                                      |\n       \
    \    | (3) Config, MOT,AT, EM=All-or-None, OP= SET/DEL,etc  |\n           |<-----------------------------------------------------|\n\
    \           |                                                      |\n       \
    \    | (4) ACKnowledge                                      |\n           |----------------------------------------------------->|\n\
    \           |                                                      |\n       \
    \    | (5) Config, MOT,AT, EM=All-or-None, OP= SET/DEL,etc  |\n           |<-----------------------------------------------------|\n\
    \           |                                                      |\n       \
    \    | (6) ACKnowledge                                      |\n           |----------------------------------------------------->|\n\
    \           .                                                      .\n       \
    \    .                                                      .\n           .  \
    \                                                    .\n           .         \
    \                                             .\n           |                \
    \                                      |\n           | (N) Config, EOT,AT, EM=All-or-None,\
    \ OP= COMMIT       |\n           |<-----------------------------------------------------|\n\
    \           |                                                      |\n       \
    \    | (N+1)Config-response, ACKnowledge, OP=COMMIT-RESPONSE|\n           |----------------------------------------------------->|\n\
    \           |                                                      |\n       \
    \    | (N+2) Config, OP=TRCOMP                              |\n           |<-----------------------------------------------------|\n\
    \                  Figure 7: Example of a Two-Phase Commit\n   For the scenario\
    \ illustrated above:\n   o  In step 1, the CE issues a Config message with an\
    \ operation of\n      choice like a DEL or SET.  The transaction flags are set\
    \ to\n      indicate a Start of Transaction (SOT), Atomic Transaction (AT),\n\
    \      and execute-all-or-none.\n   o  The FE validates that it can execute the\
    \ request successfully and\n      then issues an acknowledgment back to the CE\
    \ in step 2.\n   o  In step 3, the same sort of construct as in step 1 is repeated\
    \ by\n      the CE with the transaction flag changed to Middle of Transaction\n\
    \      (MOT).\n   o  The FE validates that it can execute the request successfully\
    \ and\n      then issues an acknowledgment back to the CE in step 4.\n   o  The\
    \ CE-FE exchange continues in the same manner until all the\n      operations\
    \ and their parameters are transferred to the FE.  This\n      happens in step\
    \ (N-1).\n   o  In step N, the CE issues a commit.  A commit is a Config message\n\
    \      with an operation of type COMMIT.  The transaction flag is set to\n   \
    \   End of Transaction (EOT).  Essentially, this is an \"empty\" message\n   \
    \   asking the FE to execute all the operations it has gathered since\n      the\
    \ beginning of the transaction (message #1).\n   o  The FE at this point executes\
    \ the full transaction.  It then\n      issues an acknowledgment back to the CE\
    \ in step (N+1) that\n      contains a COMMIT-RESPONSE.\n   o  The CE in this\
    \ case has the simple task of issuing a TRCOMP\n      operation to the FE in step\
    \ (N+2).\n"
- title: 4.3.2.  Scalability
  contents:
  - "4.3.2.  Scalability\n   It is desirable that the PL not become the bottleneck\
    \ when larger\n   bandwidth pipes become available.  To pick a hypothetical example\
    \ in\n   today's terms, if a 100-Gbps pipe is available and there is\n   sufficient\
    \ work, then the PL should be able to take advantage of this\n   and use all of\
    \ the 100-Gbps pipe.  Two mechanisms have been provided\n   to achieve this. \
    \ The first one is batching and the second one is a\n   command pipeline.\n  \
    \ Batching is the ability to send multiple commands (such as Config) in\n   one\
    \ Protocol Data Unit (PDU).  The size of the batch will be affected\n   by, among\
    \ other things, the path MTU.  The commands may be part of\n   the same transaction\
    \ or may be part of unrelated transactions that\n   are independent of each other.\n\
    \   Command pipelining allows for pipelining of independent transactions\n   that\
    \ do not affect each other.  Each independent transaction could\n   consist of\
    \ one or more batches.\n"
- title: 4.3.2.1.  Batching
  contents:
  - "4.3.2.1.  Batching\n   There are several batching levels at different protocol\
    \ hierarchies.\n   o  Multiple PL PDUs can be aggregated under one TML message.\n\
    \   o  Multiple LFB classes and instances (as indicated in the LFB\n      selector)\
    \ can be addressed within one PL PDU.\n   o  Multiple operations can be addressed\
    \ to a single LFB class and\n      instance.\n"
- title: 4.3.2.2.  Command Pipelining
  contents:
  - "4.3.2.2.  Command Pipelining\n   The protocol allows any number of messages to\
    \ be issued by the CE\n   before the corresponding acknowledgments (if requested)\
    \ have been\n   returned by the FE.  Hence, pipelining is inherently supported\
    \ by the\n   protocol.  Matching responses with requests messages can be done\n\
    \   using the correlator field in the message header.\n"
- title: 4.3.3.  Heartbeat Mechanism
  contents:
  - "4.3.3.  Heartbeat Mechanism\n   Heartbeats (HBs) between FEs and CEs are traffic\
    \ sensitive.  An HB is\n   sent only if no PL traffic is sent between the CE and\
    \ FE within a\n   configured interval.  This has the effect of reducing the amount\
    \ of\n   HB traffic in the case of busy PL periods.\n   An HB can be sourced by\
    \ either the CE or FE.  When sourced by the CE,\n   a response can be requested\
    \ (similar to the ICMP ping protocol).  The\n   FE can only generate HBs in the\
    \ case of being configured to do so by\n   the CE.  Refer to Section 7.3.1 and\
    \ Section 7.10 for details.\n"
- title: 4.3.4.  FE Object and FE Protocol LFBs
  contents:
  - "4.3.4.  FE Object and FE Protocol LFBs\n   All PL messages operate on LFB constructs,\
    \ as this provides more\n   flexibility for future enhancements.  This means that\
    \ maintenance and\n   configurability of FEs, NE, and the ForCES protocol itself\
    \ MUST be\n   expressed in terms of this LFB architecture.  For this reason,\n\
    \   special LFBs are created to accommodate this need.\n   In addition, this shows\
    \ how the ForCES protocol itself can be\n   controlled by the very same type of\
    \ structures (LFBs) it uses to\n   control functions such as IP forwarding, filtering,\
    \ etc.\n   To achieve this, the following specialized LFBs are introduced:\n \
    \  o  FE Protocol LFB, which is used to control the ForCES protocol.\n   o  FE\
    \ Object LFB, which is used to control components relative to the\n      FE itself.\
    \  Such components include FEState [RFC5812], vendor,\n      etc.\n   These LFBs\
    \ are detailed in Section 7.3.\n"
- title: 4.4.  Protocol Scenarios
  contents:
  - "4.4.  Protocol Scenarios\n   This section provides a very high level description\
    \ of sample message\n   sequences between a CE and an FE.  For protocol message\
    \ encoding\n   refer to Section 6.1, and for the semantics of the protocol refer\
    \ to\n   Section 4.3.\n"
- title: 4.4.1.  Association Setup State
  contents:
  - "4.4.1.  Association Setup State\n   The associations among CEs and FEs are initiated\
    \ via the Association\n   Setup message from the FE.  If a Setup Request is granted\
    \ by the CE,\n   a successful Setup Response message is sent to the FE.  If CEs\
    \ and\n   FEs are operating in an insecure environment, then the security\n  \
    \ associations have to be established between them before any\n   association\
    \ messages can be exchanged.  The TML MUST take care of\n   establishing any security\
    \ associations.\n   This is typically followed by capability query, topology query,\
    \ etc.\n   When the FE is ready to start processing the data path, it sets the\n\
    \   FEO FEState component to OperEnable (refer to [RFC5812] for details)\n   and\
    \ reports it to the CE as such when it is first queried.\n   Typically, the FE\
    \ is expected to be ready to process the data path\n   before it associates, but\
    \ there may be rare cases where it needs time\n   do some pre-processing -- in\
    \ such a case, the FE will start in the\n   OperDisable state and when it is ready\
    \ will transition to the\n   OperEnable state.  An example of an FE starting in\
    \ OperDisable then\n   transitioning to OperEnable is illustrated in Figure 8.\
    \  The CE could\n   at any time also disable the FE's data path operations by\
    \ setting the\n   FEState to AdminDisable.  The FE MUST NOT process packets during\
    \ this\n   state unless the CE sets the state back to OperEnable.  These\n   sequences\
    \ of messages are illustrated in Figure 8 below.\n           FE PL           \
    \       CE PL\n             |                       |\n             |   Asso Setup\
    \ Req      |\n             |---------------------->|\n             |         \
    \              |\n             |   Asso Setup Resp     |\n             |<----------------------|\n\
    \             |                       |\n             | LFBx Query capability\
    \ |\n             |<----------------------|\n             |                  \
    \     |\n             | LFBx Query Resp       |\n             |---------------------->|\n\
    \             |                       |\n             | FEO Query (Topology) \
    \ |\n             |<----------------------|\n             |                  \
    \     |\n             | FEO Query Resp        |\n             |---------------------->|\n\
    \             |                       |\n             | FEO OperEnable Event \
    \ |\n             |---------------------->|\n             |                  \
    \     |\n             |  Config FEO Adminup   |\n             |<----------------------|\n\
    \             |                       |\n             | FEO Config-Resp      \
    \ |\n             |---------------------->|\n             |                  \
    \     |\n   Figure 8: Message Exchange between CE and FE to Establish\n   an NE\
    \ Association\n   On successful completion of this state, the FE joins the NE.\n"
- title: 4.4.2.  Association Established State or Steady State
  contents:
  - "4.4.2.  Association Established State or Steady State\n   In this state, the\
    \ FE is continuously updated or queried.  The FE may\n   also send asynchronous\
    \ event notifications to the CE, synchronous\n   Heartbeat messages, or Packet\
    \ Redirect message to the CE.  This\n   continues until a termination (or deactivation)\
    \ is initiated by\n   either the CE or FE.  Figure 9 below, helps illustrate this\
    \ state.\n           FE PL                          CE PL\n             |    \
    \                          |\n             |    Heartbeat                 |\n\
    \             |<---------------------------->|\n             |               \
    \               |\n             |   Heartbeat                  |\n           \
    \  |----------------------------->|\n             |                          \
    \    |\n             | Config-set LFBy (Event sub.) |\n             |<-----------------------------|\n\
    \             |                              |\n             |     Config Resp\
    \ LFBy         |\n             |----------------------------->|\n            \
    \ |                              |\n             |  Config-set LFBx Component\
    \   |\n             |<-----------------------------|\n             |         \
    \                     |\n             |     Config Resp  LFBx        |\n     \
    \        |----------------------------->|\n             |                    \
    \          |\n             |Config-Query LFBz (Stats)     |\n             |<---------------------------\
    \ -|\n             |                              |\n             |    Query Resp\
    \ LFBz           |\n             |----------------------------->|\n          \
    \   |                              |\n             |    FE Event Report      \
    \     |\n             |----------------------------->|\n             |       \
    \                       |\n             |  Config-Del LFBx Component   |\n   \
    \          |<-----------------------------|\n             |                  \
    \            |\n             |     Config Resp LFBx         |\n             |----------------------------->|\n\
    \             |                              |\n             |    Packet Redirect\
    \ LFBx      |\n             |----------------------------->|\n             | \
    \                             |\n             |    Heartbeat                 |\n\
    \             |<-----------------------------|\n             .               \
    \               .\n             .                              .\n           \
    \  |                              |\n   Figure 9: Message Exchange between CE\
    \ and FE during\n   Steady-State Communication\n   Note that the sequence of messages\
    \ shown in the figure serve only as\n   examples and the message exchange sequences\
    \ could be different from\n   what is shown in the figure.  Also, note that the\
    \ protocol scenarios\n   described in this section do not include all the different\
    \ message\n   exchanges that would take place during failover.  That is described\n\
    \   in the HA section (Section 8).\n"
- title: 5.  TML Requirements
  contents:
  - "5.  TML Requirements\n   The requirements below are expected to be met by the\
    \ TML.  This text\n   does not define how such mechanisms are delivered.  As an\
    \ example,\n   the mechanisms to meet the requirements could be defined to be\n\
    \   delivered via hardware or between 2 or more TML software processes on\n  \
    \ different CEs or FEs in protocol-level schemes.\n   Each TML MUST describe how\
    \ it contributes to achieving the listed\n   ForCES requirements.  If for any\
    \ reason a TML does not provide a\n   service listed below, a justification needs\
    \ to be provided.\n   Implementations that support the ForCES protocol specification\
    \ MUST\n   implement [RFC5811].  Note that additional TMLs might be specified\
    \ in\n   the future, and if a new TML defined in the future that meets the\n \
    \  requirements listed here proves to be better, then the \"MUST\n   implement\
    \ TML\" may be redefined.\n   1.  Reliability\n       Various ForCES messages\
    \ will require varying degrees of reliable\n       delivery via the TML.  It is\
    \ the TML's responsibility to provide\n       these shades of reliability and\
    \ describe how the different ForCES\n       messages map to reliability.\n   \
    \    The most common level of reliability is what we refer to as\n       strict\
    \ or robust reliability in which we mean no losses,\n       corruption, or re-ordering\
    \ of information being transported while\n       ensuring message delivery in\
    \ a timely fashion.\n       Payloads such as configuration from a CE and its response\
    \ from an\n       FE are mission critical and must be delivered in a robust\n\
    \       reliable fashion.  Thus, for information of this sort, the TML\n     \
    \  MUST either provide built-in protocol mechanisms or use a\n       reliable\
    \ transport protocol for achieving robust/strict\n       reliability.\n      \
    \ Some information or payloads, such as redirected packets or\n       packet sampling,\
    \ may not require robust reliability (can tolerate\n       some degree of losses).\
    \  For information of this sort, the TML\n       could define to use a mechanism\
    \ that is not strictly reliable\n       (while conforming to other TML requirements\
    \ such as congestion\n       control).\n       Some information or payloads, such\
    \ as heartbeat packets, may\n       prefer timeliness over reliable delivery.\
    \  For information of\n       this sort, the TML could define to use a mechanism\
    \ that is not\n       strictly reliable (while conforming to other TML requirements\n\
    \       such as congestion control).\n   2.  Security\n       TML provides security\
    \ services to the ForCES PL.  Because a\n       ForCES PL is used to operate an\
    \ NE, attacks designed to confuse,\n       disable, or take information from a\
    \ ForCES-based NE may be seen\n       as a prime objective during a network attack.\n\
    \       An attacker in a position to inject false messages into a PL\n       stream\
    \ can affect either the FE's treatment of the data path (for\n       example,\
    \ by falsifying control data reported as coming from the\n       CE) or the CE\
    \ itself (by modifying events or responses reported\n       as coming from the\
    \ FE).  For this reason, CE and FE node\n       authentication and TML message\
    \ authentication are important.\n       The PL messages may also contain information\
    \ of value to an\n       attacker, including information about the configuration\
    \ of the\n       network, encryption keys, and other sensitive control data, so\n\
    \       care must be taken to confine their visibility to authorized\n       users.\n\
    \       *  The TML MUST provide a mechanism to authenticate ForCES CEs\n     \
    \     and FEs, in order to prevent the participation of unauthorized\n       \
    \   CEs and unauthorized FEs in the control and data path\n          processing\
    \ of a ForCES NE.\n       *  The TML SHOULD provide a mechanism to ensure message\n\
    \          authentication of PL data transferred from the CE to FE (and\n    \
    \      vice versa), in order to prevent the injection of incorrect\n         \
    \ data into PL messages.\n       *  The TML SHOULD provide a mechanism to ensure\
    \ the\n          confidentiality of data transferred from the ForCES PL, in\n\
    \          order to prevent disclosure of PL-level information\n          transported\
    \ via the TML.\n       The TML SHOULD provide these services by employing TLS\
    \ or IPsec.\n   3.  Congestion control\n       The transport congestion control\
    \ scheme used by the TML needs to\n       be defined.  The congestion control\
    \ mechanism defined by the TML\n       MUST prevent transport congestive collapse\
    \ [RFC2914] on either\n       the FE or CE side.\n   4.  Uni/multi/broadcast addressing/delivery,\
    \ if any\n       If there is any mapping between PL- and TML-level uni/multi/\n\
    \       broadcast addressing, it needs to be defined.\n   5.  HA decisions\n \
    \      It is expected that availability of transport links is the TML's\n    \
    \   responsibility.  However, based upon its configuration, the PL\n       may\
    \ wish to participate in link failover schemes and therefore\n       the TML MUST\
    \ support this capability.\n       Please refer to Section 8 for details.\n  \
    \ 6.  Encapsulations used\n       Different types of TMLs will encapsulate the\
    \ PL messages on\n       different types of headers.  The TML needs to specify\
    \ the\n       encapsulation used.\n   7.  Prioritization\n       It is expected\
    \ that the TML will be able to handle up to 8\n       priority levels needed by\
    \ the PL and will provide preferential\n       treatment.\n       While the TML\
    \ needs to define how this is achieved, it should be\n       noted that the requirement\
    \ for supporting up to 8 priority levels\n       does not mean that the underlying\
    \ TML MUST be capable of\n       providing up to 8 actual priority levels.  In\
    \ the event that the\n       underlying TML layer does not have support for 8\
    \ priority levels,\n       the supported priority levels should be divided between\
    \ the\n       available TML priority levels.  For example, if the TML only\n \
    \      supports 2 priority levels, 0-3 could go in one TML priority\n       level,\
    \ while 4-7 could go in the other.\n       The TML MUST NOT re-order config packets\
    \ with the same priority.\n   8.  Node Overload Prevention\n       The TML MUST\
    \ define mechanisms it uses to help prevent node\n       overload.\n       Overload\
    \ results in starvation of node compute cycles and/or\n       bandwidth resources,\
    \ which reduces the operational capacity of a\n       ForCES NE.  NE node overload\
    \ could be deliberately instigated by\n       a hostile node to attack a ForCES\
    \ NE and create a denial of\n       service (DoS).  It could also be created by\
    \ a variety of other\n       reasons such as large control protocol updates (e.g.,\
    \ BGP flaps),\n       which consequently cause a high frequency of CE to FE table\n\
    \       updates, HA failovers, or component failures, which migrate an FE\n  \
    \     or CE load overwhelming the new CE or FE, etc.  Although the\n       environments\
    \ under which SIP and ForCES operate are different,\n       [RFC5390] provides\
    \ a good guide to generic node requirements one\n       needs to guard for.\n\
    \       A ForCES node CPU may be overwhelmed because the incoming packet\n   \
    \    rate is higher than it can keep up with -- in such a case, a\n       node's\
    \ transport queues grow and transport congestion\n       subsequently follows.\
    \  A ForCES node CPU may also be adversely\n       overloaded with very few packets,\
    \ i.e., no transport congestion\n       at all (e.g., a in a DoS attack against\
    \ a table hashing algorithm\n       that overflows the table and/or keeps the\
    \ CPU busy so it does not\n       process other tasks).  The TML node overload\
    \ solution specified\n       MUST address both types of node overload scenarios.\n"
- title: 5.1.  TML Parameterization
  contents:
  - "5.1.  TML Parameterization\n   It is expected that it should be possible to use\
    \ a configuration\n   reference point, such as the FEM or the CEM, to configure\
    \ the TML.\n   Some of the configured parameters may include:\n   o  PL ID\n \
    \  o  Connection Type and associated data.  For example, if a TML uses\n     \
    \ IP/TCP/UDP, then parameters such as TCP and UDP port and IP\n      addresses\
    \ need to be configured.\n   o  Number of transport connections\n   o  Connection\
    \ capability, such as bandwidth, etc.\n   o  Allowed/supported connection QoS\
    \ policy (or congestion control\n      policy)\n"
- title: 6.  Message Encapsulation
  contents:
  - "6.  Message Encapsulation\n   All PL PDUs start with a common header Section\
    \ 6.1 followed by one or\n   more TLVs Section 6.2, which may nest other TLVs\
    \ Section 6.2.1.  All\n   fields are in network byte order.\n"
- title: 6.1.  Common Header
  contents:
  - "6.1.  Common Header\n   0                   1                   2           \
    \        3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |version|\
    \ rsvd  | Message Type  |             Length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Source ID                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Destination ID                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Correlator[63:32]                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Correlator[31:0]                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             Flags                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 10: Common Header\n   The message is 32-bit aligned.\n\
    \   Version (4 bits):\n      Version number.  Current version is 1.\n   rsvd (4\
    \ bits):\n      Unused at this point.  A receiver should not interpret this field.\n\
    \      Senders MUST set it to zero and receivers MUST ignore this field.\n   Message\
    \ Type (8 bits):\n      Commands are defined in Section 7.\n   Length (16 bits):\n\
    \      length of header + the rest of the message in DWORDS (4-byte\n      increments).\n\
    \   Source ID  (32 bits):\n   Dest ID (32 bits):\n      *   Each of the source\
    \ and destination IDs are 32-bit IDs that are\n          unique NE-wide and that\
    \ identify the termination points of a\n          ForCES PL message.\n      *\
    \   IDs allow multi/broad/unicast addressing with the following\n          approach:\n\
    \          a.  A split address space is used to distinguish FEs from CEs.\n  \
    \            Even though in a large NE there are typically two or more\n     \
    \         orders of magnitude of more FEs than CEs, the address\n            \
    \  space is split uniformly for simplicity.\n          b.  The address space allows\
    \ up to 2^30 (over a billion) CEs\n              and the same amount of FEs.\n\
    \   0                   1                   2                   3\n   0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |TS |                           sub-ID                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 11: ForCES ID Format\n           c.  The 2 most significant\
    \ bits called Type Switch (TS) are\n             used to split the ID space as\
    \ follows:\n   TS        Corresponding ID range       Assignment\n   --      \
    \  ----------------------       ----------\n   0b00      0x00000000 to 0x3FFFFFFF\
    \     FE IDs (2^30)\n   0b01      0x40000000 to 0x7FFFFFFF     CE IDs (2^30)\n\
    \   0b10      0x80000000 to 0xBFFFFFFF     reserved\n   0b11      0xC0000000 to\
    \ 0xFFFFFFEF     multicast IDs (2^30 - 16)\n   0b11      0xFFFFFFF0 to 0xFFFFFFFC\
    \     reserved\n   0b11      0xFFFFFFFD                   all CEs broadcast\n\
    \   0b11      0xFFFFFFFE                   all FEs broadcast\n   0b11      0xFFFFFFFF\
    \                   all FEs and CEs (NE) broadcast\n             Figure 12: Type\
    \ Switch ID Space\n      *   Multicast or broadcast IDs are used to group endpoints\
    \ (such\n          as CEs and FEs).  As an example, one could group FEs in some\n\
    \          functional group, by assigning a multicast ID.  Likewise,\n       \
    \   subgroups of CEs that act, for instance, in a back-up mode may\n         \
    \ be assigned a multicast ID to hide them from the FE.\n          +   Multicast\
    \ IDs can be used for both source or destination\n              IDs.\n       \
    \   +   Broadcast IDs can be used only for destination IDs.\n      *   This document\
    \ does not discuss how a particular multicast ID\n          is associated to a\
    \ given group though it could be done via\n          configuration process.  The\
    \ list of IDs an FE owns or is part\n          of are listed on the FE Object\
    \ LFB.\n   Correlator (64 bits):\n      This field is set by the CE to correlate\
    \ ForCES Request messages\n      with the corresponding Response messages from\
    \ the FE.\n      Essentially, it is a cookie.  The correlator is handled\n   \
    \   transparently by the FE, i.e., for a particular Request message\n      the\
    \ FE MUST assign the same correlator value in the corresponding\n      Response\
    \ message.  In the case where the message from the CE does\n      not elicit a\
    \ response, this field may not be useful.\n      The correlator field could be\
    \ used in many implementations in\n      specific ways by the CE.  For example,\
    \ the CE could split the\n      correlator into a 32-bit transactional identifier\
    \ and 32-bit\n      message sequence identifier.  Another example is a 64-bit\
    \ pointer\n      to a context block.  All such implementation-specific uses of\
    \ the\n      correlator are outside the scope of this specification.\n      It\
    \ should be noted that the correlator is transmitted on the\n      network as\
    \ if it were a 64-bit unsigned integer with the leftmost\n      or most significant\
    \ octet (bits 63-56) transmitted first.\n      Whenever the correlator field is\
    \ not relevant, because no message\n      is expected, the correlator field is\
    \ set to 0.\n   Flags (32 bits):\n   Identified so far:\n   0                \
    \   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   |     |     |   | |   |                                     |\n   |ACK|\
    \ Pri |Rsr  |EM |A|TP |     Reserved                        |\n   |   |     |\
    \ vd. |   |T|   |                                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 13: Header Flags\n   - ACK: ACK indicator (2 bits)\n   The\
    \ ACK indicator flag is only used by the CE when sending a Config\n   message\
    \ (Section 7.6.1) or an HB message (Section 7.10) to indicate\n   to the message\
    \ receiver whether or not a response is required by the\n   sender.  Note that\
    \ for all other messages than the Config message or\n   the HB message this flag\
    \ MUST be ignored.\n   The flag values are defined as follows:\n      'NoACK'\
    \ (0b00) - to indicate that the message receiver MUST NOT\n      send any Response\
    \ message back to this message sender.\n      'SuccessACK'(0b01) - to indicate\
    \ that the message receiver MUST\n      send a Response message back only when\
    \ the message has been\n      successfully processed by the receiver.\n      'FailureACK'(0b10)\
    \ - to indicate that the message receiver MUST\n      send a Response message\
    \ back only when there is failure by the\n      receiver in processing (executing)\
    \ the message.  In other words,\n      if the message can be processed successfully,\
    \ the sender will not\n      expect any response from the receiver.\n      'AlwaysACK'\
    \ (0b11) - to indicate that the message receiver MUST\n      send a Response message.\n\
    \   Note that in above definitions, the term success implies a complete\n   execution\
    \ without any failure of the message.  Anything else than a\n   complete successful\
    \ execution is defined as a failure for the message\n   processing.  As a result,\
    \ for the execution modes (defined in\n   Section 4.3.1.1) like execute-all-or-none,\
    \ execute-until-failure, and\n   continue-execute-on-failure, if any single operation\
    \ among several\n   operations in the same message fails, it will be treated as\
    \ a failure\n   and result in a response if the ACK indicator has been set to\n\
    \   'FailureACK' or 'AlwaysACK'.\n   Also note that, other than in Config and\
    \ HB messages, requirements\n   for responses of messages are all given in a default\
    \ way rather than\n   by ACK flags.  The default requirements of these messages\
    \ and the\n   expected responses are summarized below.  Detailed descriptions\
    \ can\n   be found in the individual message definitions:\n           +   Association\
    \ Setup message always expects a response.\n           +   Association Teardown\
    \ Message, and Packet Redirect\n               message, never expect responses.\n\
    \           +   Query message always expects a response.\n           +   Response\
    \ message never expects further responses.\n   - Pri: Priority (3 bits)\n   ForCES\
    \ protocol defines 8 different levels of priority (0-7).  The\n   priority level\
    \ can be used to distinguish between different protocol\n   message types as well\
    \ as between the same message type.  The higher\n   the priority value, the more\
    \ important the PDU is.  For example, the\n   REDIRECT packet message could have\
    \ different priorities to\n   distinguish between routing protocol packets and\
    \ ARP packets being\n   redirected from FE to CE.  The normal priority level is\
    \ 1.  The\n   different priorities imply messages could be re-ordered; however,\n\
    \   re-ordering is undesirable when it comes to a set of messages within\n   a\
    \ transaction and caution should be exercised to avoid this.\n   - EM: Execution\
    \ Mode (2 bits)\n   There are 3 execution modes; refer to Section 4.3.1.1 for\
    \ details.\n      Reserved..................... (0b00)\n      `execute-all-or-none`\
    \ ....... (0b01)\n      `execute-until-failure` ..... (0b10)\n      `continue-execute-on-failure`\
    \ (0b11)\n   - AT:  Atomic Transaction (1 bit)\n   This flag indicates if the\
    \ message is a stand-alone message or one of\n   multiple messages that belong\
    \ to 2PC transaction operations.  See\n   Section 4.3.1.2.2 for details.\n   \
    \   Stand-alone message ......... (0b0)\n      2PC transaction message ..... (0b1)\n\
    \   - TP: Transaction Phase (2 bits)\n   A message from the CE to the FE within\
    \ a transaction could be\n   indicative of the different phases the transaction\
    \ is in.  Refer to\n   Section 4.3.1.2.2 for details.\n      SOT (start of transaction)\
    \ ..... (0b00)\n      MOT (middle of transaction) .... (0b01)\n      EOT (end\
    \ of transaction) ........(0b10)\n      ABT (abort) .....................(0b11)\n"
- title: 6.2.  Type Length Value (TLV) Structuring
  contents:
  - "6.2.  Type Length Value (TLV) Structuring\n   TLVs are extensively used by the\
    \ ForCES protocol.  TLVs have some\n   very nice properties that make them a good\
    \ candidate for encoding the\n   XML definitions of the LFB class model.  These\
    \ are:\n   o  Providing for binary type-value encoding that is close to the XML\n\
    \      string tag-value scheme.\n   o  Allowing for fast generalized binary-parsing\
    \ functions.\n   o  Allowing for forward and backward tag compatibility.  This\
    \ is\n      equivalent to the XML approach, i.e., old applications can ignore\n\
    \      new TLVs and newer applications can ignore older TLVs.\n   0          \
    \         1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | TLV Type                    | TLV Length                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Value (Essentially the TLV Data)                   |\n   ~  \
    \                                                             ~\n   ~        \
    \                                                       ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 14: TLV Representation\n   TLV Type (16):\n   The\
    \ TLV type field is 2 octets, and semantically indicates the type\n   of data\
    \ encapsulated within the TLV.\n   TLV Length (16):\n   The TLV length field is\
    \ 2 octets, and includes the length of the TLV\n   type (2 octets), TLV Length\
    \ (2 octets), and the length of the TLV\n   data found in the value field, in\
    \ octets.  Note that this length is\n   the actual length of the value, before\
    \ any padding for alignment is\n   added.\n   TLV Value (variable):\n   The TLV\
    \ value field carries the data.  For extensibility, the TLV\n   value may in fact\
    \ be a TLV.  Padding is required when the length is\n   not a multiple of 32 bits,\
    \ and is the minimum number of octets\n   required to bring the TLV to a multiple\
    \ of 32 bits.  The length of\n   the value before padding is indicated by the\
    \ TLV Length field.\n   Note: The value field could be empty, which implies the\
    \ minimal\n   length a TLV could be is 4 (length of \"T\" field and length of\
    \ \"L\"\n   field).\n"
- title: 6.2.1.  Nested TLVs
  contents:
  - "6.2.1.  Nested TLVs\n   TLV values can be other TLVs.  This provides the benefits\
    \ of protocol\n   flexibility (being able to add new extensions by introducing\
    \ new TLVs\n   when needed).  The nesting feature also allows for a conceptual\n\
    \   optimization with the XML LFB definitions to binary PL representation\n  \
    \ (represented by nested TLVs).\n"
- title: 6.2.2.  Scope of the T in TLV
  contents:
  - "6.2.2.  Scope of the T in TLV\n   There are two global name scopes for the \"\
    Type\" in the TLV.  The\n   first name scope is for OPER-TLVs and is defined in\
    \ A.4 whereas the\n   second name scope is outside OPER-TLVs and is defined in\
    \ section A.2.\n"
- title: 6.3.  ILV
  contents:
  - "6.3.  ILV\n   The ILV is a slight variation of the TLV.  This sets the type (\"\
    T\")\n   to be a 32-bit local index that refers to a ForCES component ID\n   (refer\
    \ to Section 6.4.1).\n   The ILV length field is a 4-octet integer, and includes\
    \ the length of\n   the ILV type (4 octets), ILV Length (4 octets), and the length\
    \ of the\n   ILV data found in the value field, in octets.  Note that, as in the\n\
    \   case of the TLV, this length is the actual length of the value,\n   before\
    \ any padding for alignment is added.\n    0                   1             \
    \      2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Identifier                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Length                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Value                                  |\n   .  \
    \                                                             .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 15: ILV Representation\n   It should be noted that\
    \ the \"I\" values are of local scope and are\n   defined by the data declarations\
    \ from the LFB definition.  Refer to\n   Section 7.1.8 for discussions on usage\
    \ of ILVs.\n"
- title: 6.4.  Important Protocol Encapsulations
  contents:
  - "6.4.  Important Protocol Encapsulations\n   In this section, we review a few\
    \ encapsulation concepts that are used\n   by the ForCES protocol for its operations.\n\
    \   We briefly re-introduce two concepts, paths, and keys, from the\n   ForCES\
    \ model [RFC5812] in order to provide context.  The reader is\n   referred to\
    \ [RFC5812] for a lot of the finer details.\n   For readability reasons, we introduce\
    \ the encapsulation schemes that\n   are used to carry content in a protocol message,\
    \ namely, FULLDATA-\n   TLV, SPARSEDATA-TLV, and RESULT-TLV.\n"
- title: 6.4.1.  Paths
  contents:
  - "6.4.1.  Paths\n   The ForCES model [RFC5812] defines an XML-based language that\
    \ allows\n   for a formal definition of LFBs.  This is similar to the relationship\n\
    \   between ASN.1 and SNMP MIB definition (MIB being analogous to the LFB\n  \
    \ and ASN.1 being analogous to the XML model language).  Any entity\n   that the\
    \ CE configures on an FE MUST be formally defined in an LFB.\n   These entities\
    \ could be scalars (e.g., a 32-bit IPv4 address) or\n   vectors (such as a nexthop\
    \ table).  Each entity within the LFB is\n   given a numeric 32-bit identifier\
    \ known as a \"component id\".  This\n   scheme allows the component to be \"\
    addressed\" in a protocol\n   construct.\n   These addressable entities could\
    \ be hierarchical (e.g., a table\n   column or a cell within a table row).  In\
    \ order to address\n   hierarchical data, the concept of a path is introduced\
    \ by the model\n   [RFC5812].  A path is a series of 32-bit component IDs that\
    \ are\n   typically presented in a dot-notation (e.g., 1.2.3.4).  Section 7\n\
    \   formally defines how paths are used to reference data that is being\n   encapsulated\
    \ within a protocol message.\n"
- title: 6.4.2.  Keys
  contents:
  - "6.4.2.  Keys\n   The ForCES model [RFC5812] defines two ways to address table\
    \ rows.\n   The standard/common mechanism is to allow table rows to be referenced\n\
    \   by a 32-bit index.  The secondary mechanism is via keys that allow\n   for\
    \ content addressing.  An example key is a multi-field content key\n   that uses\
    \ the IP address and prefix length to uniquely reference an\n   IPv4 routing table\
    \ row.  In essence, while the common scheme to\n   address a table row is via\
    \ its table index, a table row's path could\n   be derived from a key.  The KEYINFO-TLV\
    \ (Section 7) is used to carry\n   the data that is used to do the lookup.\n"
- title: 6.4.3.  DATA TLVs
  contents:
  - "6.4.3.  DATA TLVs\n   Data from or to the FE is carried in two types of TLVs:\
    \ FULLDATA-TLV\n   and SPARSEDATA-TLV.  Responses to operations executed by the\
    \ FE are\n   carried in RESULT-TLVs.\n   In FULLDATA-TLV, the data is encoded\
    \ in such a way that a receiver of\n   such data, by virtue of being armed with\
    \ knowledge of the path and\n   the LFB definition, can infer or correlate the\
    \ TLV \"Value\" contents.\n   This is essentially an optimization that helps reduce\
    \ the amount of\n   description required for the transported data in the protocol\n\
    \   grammar.  Refer to Appendix C for an example of FULLDATA-TLVs.\n   A number\
    \ of operations in ForCES will need to reference optional data\n   within larger\
    \ structures.  The SPARSEDATA-TLV encoding is provided to\n   make it easier to\
    \ encapsulate optionally appearing data components.\n   Refer to Appendix C for\
    \ an example of SPARSEDATA-TLV.\n   RESULT-TLVs carry responses back from the\
    \ FE based on a config issued\n   by the CE.  Refer to Appendix C for examples\
    \ of RESULT-TLVs and\n   Section 7.1.7 for layout.\n"
- title: 6.4.4.  Addressing LFB Entities
  contents:
  - "6.4.4.  Addressing LFB Entities\n   Section 6.4.1 and Section 6.4.2 discuss how\
    \ to target an entity\n   within an LFB.  However, the addressing mechanism used\
    \ requires that\n   an LFB type and instance are selected first.  The LFB selector\
    \ is\n   used to select an LFB type and instance being targeted.  Section 7\n\
    \   goes into more details; for our purpose, we illustrate this concept\n   using\
    \ Figure 16 below.  More examples of layouts can be found reading\n   further\
    \ into the text (example: Figure 22).\n      main hdr (Message type: example \"\
    config\")\n       |\n       |\n       |\n       +- T = LFBselect\n           \
    \   |\n              +-- LFBCLASSID (unique per LFB defined)\n              |\n\
    \              |\n              +-- LFBInstance  (runtime configuration)\n   \
    \           |\n              +-- T = An operation TLV describes what we do to\
    \ an entity\n                  |   //Refer to the OPER-TLV values enumerated below\n\
    \                  |   //the TLVs that can be used for operations\n          \
    \        |\n                  |\n                  +--+-- one or more path encodings\
    \ to target an entity\n                     | // Refer to the discussion on keys\
    \ and paths\n                     |\n                     |\n                \
    \     +-- The associated data, if any, for the entity\n                      \
    \  // Refer to discussion on FULL/SPARSE DATA TLVs\n                       Figure\
    \ 16: Entity Addressing\n"
- title: 7.  Protocol Construction
  contents:
  - "7.  Protocol Construction\n   A protocol layer PDU consists of a common header\
    \ (defined in\n   Section 6.1 ) and a message body.  The common header is followed\
    \ by a\n   message-type-specific message body.  Each message body is formed from\n\
    \   one or more top-level TLVs.  A top-level TLV may contain one or more\n   sub-TLVs;\
    \ these sub-TLVs are described in this document as OPER-TLVs,\n   because they\
    \ describe an operation to be done.\n   +-------------+---------------+---------------------+---------------+\n\
    \   |   Message   | Top-Level TLV |     OPER-TLV(s)     |   Reference   |\n  \
    \ |     Name    |               |                     |               |\n   +-------------+---------------+---------------------+---------------+\n\
    \   | Association |  (LFBselect)* |        REPORT       | Section 7.5.1 |\n  \
    \ |    Setup    |               |                     |               |\n   |\
    \ Association | ASRresult-TLV |         none        | Section 7.5.2 |\n   |  \
    \  Setup    |               |                     |               |\n   |   Response\
    \  |               |                     |               |\n   | Association |\
    \ ASTreason-TLV |         none        | Section 7.5.3 |\n   |   Teardown  |  \
    \             |                     |               |\n   |    Config   |  (LFBselect)+\
    \ |  (SET | SET-PROP |  | Section 7.6.1 |\n   |             |               |\
    \    DEL | COMMIT |   |               |\n   |             |               |  \
    \     TRCOMP)+      |               |\n   |    Config   |  (LFBselect)+ |   (SET-RESPONSE\
    \ |   | Section 7.6.2 |\n   |   Response  |               | SET-PROP-RESPONSE\
    \ | |               |\n   |             |               |    DEL-RESPONSE |  \
    \ |               |\n   |             |               |  COMMIT-RESPONSE)+  |\
    \               |\n   |    Query    |  (LFBselect)+ |  (GET | GET-PROP)+  | Section\
    \ 7.7.1 |\n   |    Query    |  (LFBselect)+ |   (GET-RESPONSE |   | Section 7.7.2\
    \ |\n   |   Response  |               | GET-PROP-RESPONSE)+ |               |\n\
    \   |    Event    |   LFBselect   |        REPORT       |  Section 7.8  |\n  \
    \ |   Notifi-   |               |                     |               |\n   |\
    \    cation   |               |                     |               |\n   |  \
    \  Packet   |  REDIRECT-TLV |         none        |  Section 7.9  |\n   |   Redirect\
    \  |               |                     |               |\n   |  Heartbeat  |\
    \      none     |         none        |  Section 7.10 |\n   +-------------+---------------+---------------------+---------------+\n\
    \                                  Table 1\n   The different messages are illustrated\
    \ in Table 1.  The different\n   message type numerical values are defined in\
    \ Appendix A.1.  All the\n   TLV values are defined in Appendix A.2.\n   An LFBselect\
    \ TLV (refer to Section 7.1.5) contains the LFB Classid\n   and LFB instance being\
    \ referenced as well as the OPER-TLV(s) being\n   applied to that reference.\n\
    \   Each type of OPER-TLV is constrained as to how it describes the paths\n  \
    \ and selectors of interest.  The following BNF describes the basic\n   structure\
    \ of an OPER-TLV and Table 2 gives the details for each type.\n       OPER-TLV\
    \ := 1*PATH-DATA-TLV\n       PATH-DATA-TLV := PATH  [DATA]\n       PATH := flags\
    \ IDcount IDs [SELECTOR]\n       SELECTOR :=  KEYINFO-TLV\n       DATA := FULLDATA-TLV\
    \ / SPARSEDATA-TLV / RESULT-TLV /\n               1*PATH-DATA-TLV\n       KEYINFO-TLV\
    \ := KeyID FULLDATA-TLV\n       FULLDATA-TLV := encoded data component which may\
    \ nest\n                      further FULLDATA-TLVs\n       SPARSEDATA-TLV :=\
    \ encoded data that may have optionally\n                        appearing components\n\
    \       RESULT-TLV := Holds result code and optional FULLDATA-TLV\n          \
    \              Figure 17: BNF of OPER-TLV\n   o  PATH-DATA-TLV identifies the\
    \ exact component targeted and may have\n      zero or more paths associated with\
    \ it.  The last PATH-DATA-TLV in\n      the case of nesting of paths via the DATA\
    \ construct in the case of\n      SET, SET-PROP requests, and GET-RESPONSE/GET-PROP-RESPONSE\
    \ is\n      terminated by encoded data or response in the form of either\n   \
    \   FULLDATA-TLV or SPARSEDATA-TLV or RESULT-TLV.\n   o  PATH provides the path\
    \ to the data being referenced.\n      *  flags (16 bits) are used to further\
    \ refine the operation to be\n         applied on the path.  More on these later.\n\
    \      *  IDcount (16 bits): count of 32-bit IDs\n      *  IDs: zero or more 32-bit\
    \ IDs (whose count is given by IDcount)\n         defining the main path.  Depending\
    \ on the flags, IDs could be\n         field IDs only or a mix of field and dynamic\
    \ IDs.  Zero is used\n         for the special case of using the entirety of the\
    \ containing\n         context as the result of the path.\n   o  SELECTOR is an\
    \ optional construct that further defines the PATH.\n      Currently, the only\
    \ defined selector is the KEYINFO-TLV, used for\n      selecting an array entry\
    \ by the value of a key field.  The\n      presence of a SELECTOR is correct only\
    \ when the flags also\n      indicate its presence.\n   o  A KEYINFO-TLV contains\
    \ information used in content keying.\n      *  A 32-bit KeyID is used in a KEYINFO-TLV.\
    \  It indicates which\n         key for the current array is being used as the\
    \ content key for\n         array entry selection.\n      *  The key's data is\
    \ the data to look for in the array, in the\n         fields identified by the\
    \ key field.  The information is encoded\n         according to the rules for\
    \ the contents of a FULLDATA-TLV, and\n         represents the field or fields\
    \ that make up the key identified\n         by the KeyID.\n   o  DATA may contain\
    \ a FULLDATA-TLV, SPARSEDATA-TLV, a RESULT-TLV, or\n      1 or more further PATH-DATA\
    \ selections.  FULLDATA-TLV and\n      SPARSEDATA-TLV are only allowed on SET\
    \ or SET-PROP requests, or on\n      responses that return content information\
    \ (GET-RESPONSE, for\n      example).  PATH-DATA may be included to extend the\
    \ path on any\n      request.\n      *  Note: Nested PATH-DATA-TLVs are supported\
    \ as an efficiency\n         measure to permit common subexpression extraction.\n\
    \      *  FULLDATA-TLV and SPARSEDATA-TLV contain \"the data\" whose path\n  \
    \       has been selected by the PATH.  Refer to Section 7.1 for\n         details.\n\
    \      *  The following table summarizes the applicability and\n         restrictions\
    \ of the FULL/SPARSEDATA-TLVs and the RESULT-TLV to\n         the OPER-TLVs.\n\
    \   +-------------------+-------------------------------+---------------+\n  \
    \ |      OPER-TLV     |            DATA TLV           |   RESULT-TLV  |\n   +-------------------+-------------------------------+---------------+\n\
    \   |        SET        |                               |      none     |\n  \
    \ |      SET-PROP     |        (FULLDATA-TLV |        |      none     |\n   |\
    \                   |        SPARSEDATA-TLV)+       |               |\n   |  \
    \  SET-RESPONSE   |              none             | (RESULT-TLV)+ |\n   | SET-PROP-RESPONSE\
    \ |              none             | (RESULT-TLV)+ |\n   |        DEL        |\
    \                               |      none     |\n   |    DEL-RESPONSE   |  \
    \            none             | (RESULT-TLV)+ |\n   |        GET        |    \
    \          none             |      none     |\n   |      GET-PROP     |      \
    \        none             |      none     |\n   |    GET-RESPONSE   |        (FULLDATA-TLV)+\
    \        | (RESULT-TLV)* |\n   | GET-PROP-RESPONSE |        (FULLDATA-TLV)+  \
    \      | (RESULT-TLV)* |\n   |       REPORT      |        (FULLDATA-TLV)+    \
    \    |      none     |\n   |       COMMIT      |              none           \
    \  |      none     |\n   |  COMMIT-RESPONSE  |              none             |\
    \ (RESULT-TLV)+ |\n   |       TRCOMP      |              none             |  \
    \    none     |\n   +-------------------+-------------------------------+---------------+\n\
    \                                     Table 2\n   o  RESULT-TLV contains the indication\
    \ of whether the individual SET\n      or SET-PROP succeeded.  RESULT-TLV is included\
    \ on the assumption\n      that individual parts of a SET request can succeed\
    \ or fail\n      separately.\n   In summary, this approach has the following characteristics:\n\
    \   o  There can be one or more LFB class ID and instance ID combinations\n  \
    \    targeted in a message (batch).\n   o  There can one or more operations on\
    \ an addressed LFB class ID/\n      instance ID combination (batch).\n   o  There\
    \ can be one or more path targets per operation (batch).\n   o  Paths may have\
    \ zero or more data values associated (flexibility\n      and operation specific).\n\
    \   It should be noted that the above is optimized for the case of a\n   single\
    \ LFB class ID and instance ID targeting.  To target multiple\n   instances within\
    \ the same class, multiple LFBselects are needed.\n"
- title: 7.1.  Discussion on Encoding
  contents:
  - "7.1.  Discussion on Encoding\n   Section 6.4.3 discusses the two types of DATA\
    \ encodings (FULLDATA-TLV\n   and SPARSEDATA-TLV) and the justifications for their\
    \ existence.  In\n   this section, we explain how they are encoded.\n"
- title: 7.1.1.  Data Packing Rules
  contents:
  - "7.1.1.  Data Packing Rules\n   The scheme for encoding data used in this document\
    \ adheres to the\n   following rules:\n   o  The Value (\"V\" of TLV) of FULLDATA-TLV\
    \ will contain the data being\n      transported.  This data will be as was described\
    \ in the LFB\n      definition.\n   o  Variable-sized data within a FULLDATA-TLV\
    \ will be encapsulated\n      inside another FULLDATA-TLV inside the V of the\
    \ outer TLV.  For an\n      example of such a setup, refer to Appendices C and\
    \ D.\n   o  In the case of FULLDATA-TLVs:\n      *  When a table is referred to\
    \ in the PATH (IDs) of a PATH-DATA-\n         TLV, then the FULLDATA-TLV's \"\
    V\" will contain that table's row\n         content prefixed by its 32-bit index/subscript.\
    \  On the other\n         hand, the PATH may contain an index pointing to a row\
    \ in table;\n         in such a case, the FULLDATA-TLV's \"V\" will only contain\
    \ the\n         content with the index in order to avoid ambiguity.\n"
- title: 7.1.2.  Path Flags
  contents:
  - "7.1.2.  Path Flags\n   Only bit 0, the SELECTOR Bit, is currently used in the\
    \ path flags as\n   illustrated in Figure 18.\n      0                   1\n \
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | |                           |\n      |S|   Reserved                |\n\
    \      | |                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Figure 18: Path Flags\n      The semantics of the flag are defined as follows:\n\
    \   o  SELECTOR Bit: F_SELKEY(set to 1) indicates that a KEY Selector is\n   \
    \   present following this path information, and should be considered\n      in\
    \ evaluating the path content.\n"
- title: 7.1.3.  Relation of Operational Flags with Global Message Flags
  contents:
  - "7.1.3.  Relation of Operational Flags with Global Message Flags\n   Global flags,\
    \ such as the execution mode and the atomicity indicators\n   defined in the header,\
    \ apply to all operations in a message.  Global\n   flags provide semantics that\
    \ are orthogonal to those provided by the\n   operational flags, such as the flags\
    \ defined in path-data.  The scope\n   of operational flags is restricted to the\
    \ operation.\n"
- title: 7.1.4.  Content Path Selection
  contents:
  - "7.1.4.  Content Path Selection\n   The KEYINFO-TLV describes the KEY as well\
    \ as associated KEY data.\n   KEYs, used for content searches, are restricted\
    \ and described in the\n   LFB definition.\n"
- title: 7.1.5.  LFBselect-TLV
  contents:
  - "7.1.5.  LFBselect-TLV\n   The LFBselect TLV is an instance of a TLV as defined\
    \ in Section 6.2.\n   The definition is as follows:\n     0                  \
    \ 1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        Type = LFBselect       |               Length          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                          LFB Class ID                         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                        LFB Instance ID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                        OPER-TLV                               |\n    .\
    \                                                               .\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    ~                           ...                                 ~\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                        OPER-TLV                               |\n    .\
    \                                                               .\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 19: PL PDU Layout\n   Type:\n   The type of the\
    \ TLV is \"LFBselect\"\n   Length:\n   Length of the TLV including the T and L\
    \ fields, in octets.\n   LFB Class ID:\n   This field uniquely recognizes the\
    \ LFB class/type.\n   LFB Instance ID:\n   This field uniquely identifies the\
    \ LFB instance.\n   OPER-TLV:\n   It describes an operation nested in the LFBselect\
    \ TLV.  Note that\n   usually there SHOULD be at least one OPER-TLV present for\
    \ an LFB\n   select TLV.\n"
- title: 7.1.6.  OPER-TLV
  contents:
  - "7.1.6.  OPER-TLV\n   The OPER-TLV is a place holder in the grammar for TLVs that\
    \ define\n   operations.  The different types are defined in Table 3, below.\n\
    \   +-------------------+--------+--------------------------------------+\n  \
    \ |      OPER-TLV     |   TLV  |               Comments               |\n   |\
    \                   | \"Type\" |                                      |\n   +-------------------+--------+--------------------------------------+\n\
    \   |        SET        | 0x0001 |   From CE to FE.  Used to create or  |\n  \
    \ |                   |        |       add or update components       |\n   |\
    \      SET-PROP     | 0x0002 |   From CE to FE.  Used to create or  |\n   |  \
    \                 |        |  add or update component properties  |\n   |    SET-RESPONSE\
    \   | 0x0003 |     From FE to CE.  Used to carry    |\n   |                  \
    \ |        |           response of a SET          |\n   | SET-PROP-RESPONSE |\
    \ 0x0004 |     From FE to CE.  Used to carry    |\n   |                   |  \
    \      |        response of a SET-PROP        |\n   |        DEL        | 0x0005\
    \ |   From CE to FE.  Used to delete or  |\n   |                   |        |\
    \          remove an component         |\n   |    DEL-RESPONSE   | 0x0006 |  \
    \   From FE to CE.  Used to carry    |\n   |                   |        |    \
    \       response of a DEL          |\n   |        GET        | 0x0007 |  From\
    \ CE to FE.  Used to retrieve an |\n   |                   |        |        \
    \       component              |\n   |      GET-PROP     | 0x0008 |  From CE to\
    \ FE.  Used to retrieve an |\n   |                   |        |          component\
    \ property          |\n   |    GET-RESPONSE   | 0x0009 |     From FE to CE.  Used\
    \ to carry    |\n   |                   |        |           response of a GET\
    \          |\n   | GET-PROP-RESPONSE | 0x000A |     From FE to CE.  Used to carry\
    \    |\n   |                   |        |        response of a GET-PROP      \
    \  |\n   |       REPORT      | 0x000B |   From FE to CE.  Used to carry an   |\n\
    \   |                   |        |          asynchronous event          |\n  \
    \ |       COMMIT      | 0x000C |    From CE to FE.  Used to issue a   |\n   |\
    \                   |        |      commit in a 2PC transaction     |\n   |  COMMIT-RESPONSE\
    \  | 0x000D |   From FE to CE.  Used to confirm a  |\n   |                   |\
    \        |      commit in a 2PC transaction     |\n   |       TRCOMP      | 0x000E\
    \ |   From CE to FE.  Used to indicate   |\n   |                   |        |\
    \  NE-wide success of 2PC transaction  |\n   +-------------------+--------+--------------------------------------+\n\
    \                                  Table 3\n   Different messages use OPER-TLV\
    \ and define how they are used (refer\n   to Table 1 and Table 2).\n   SET, SET-PROP,\
    \ and GET/GET-PROP requests are issued by the CE and do\n   not carry RESULT-TLVs.\
    \  On the other hand, SET-RESPONSE, SET-PROP-\n   RESPONSE, and GET-RESPONSE/GET-PROP-RESPONSE\
    \ carry RESULT-TLVs.\n   A GET-RESPONSE in response to a successful GET will have\
    \ FULLDATA-\n   TLVs added to the leaf paths to carry the requested data.  For\
    \ GET\n   operations that fail, instead of the FULLDATA-TLV there will be a\n\
    \   RESULT-TLV.\n   For a SET-RESPONSE/SET-PROP-RESPONSE, each FULLDATA-TLV or\n\
    \   SPARSEDATA-TLV in the original request will be replaced with a\n   RESULT-TLV\
    \ in the response.  If the request set the FailureACK flag,\n   then only those\
    \ items that failed will appear in the response.  If\n   the request was for AlwaysACK,\
    \ then all components of the request\n   will appear in the response with RESULT-TLVs.\n\
    \   Note that if a SET/SET-PROP request with a structure in a FULLDATA-\n   TLV\
    \ is issued, and some field in the structure is invalid, the FE\n   will not attempt\
    \ to indicate which field was invalid, but rather will\n   indicate that the operation\
    \ failed.  Note further that if there are\n   multiple errors in a single leaf\
    \ PATH-DATA/FULLDATA-TLB, the FE can\n   select which error it chooses to return.\
    \  So if a FULLDATA-TLV for a\n   SET/SET-PROP of a structure attempts to write\
    \ one field that is read\n   only, and attempts to set another field to an invalid\
    \ value, the FE\n   can return indication of either error.\n   A SET/SET-PROP\
    \ operation on a variable-length component with a length\n   of 0 for the item\
    \ is not the same as deleting it.  If the CE wishes\n   to delete, then the DEL\
    \ operation should be used whether the path\n   refers to an array component or\
    \ an optional structure component.\n"
- title: 7.1.7.  RESULT TLV
  contents:
  - "7.1.7.  RESULT TLV\n   The RESULT-TLV is an instance of TLV defined in Section\
    \ 6.2.  The\n   definition is as follows:\n        0                   1     \
    \              2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |    Type = RESULT-TLV          |               Length          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   | Result Value  |                  Reserved                     |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                   Figure 20: RESULT-TLV\n                           Defined\
    \ Result Values\n   +-----------------------------+-----------+-------------------------+\n\
    \   |         Result Value        |   Value   |        Definition       |\n  \
    \ +-----------------------------+-----------+-------------------------+\n   |\
    \          E_SUCCESS          |    0x00   |         Success         |\n   |  \
    \     E_INVALID_HEADER      |    0x01   |  Unspecified error with |\n   |    \
    \                         |           |         header.         |\n   |      E_LENGTH_MISMATCH\
    \      |    0x02   |   Header length field   |\n   |                         \
    \    |           |  does not match actual  |\n   |                           \
    \  |           |      packet length.     |\n   |      E_VERSION_MISMATCH     |\
    \    0x03   |  Unresolvable mismatch  |\n   |                             |  \
    \         |       in versions.      |\n   |  E_INVALID_DESTINATION_PID  |    0x04\
    \   |    Destination PID is   |\n   |                             |          \
    \ | invalid for the message |\n   |                             |           |\
    \        receiver.        |\n   |        E_LFB_UNKNOWN        |    0x05   |  \
    \ LFB Class ID is not   |\n   |                             |           |    known\
    \ by receiver.   |\n   |       E_LFB_NOT_FOUND       |    0x06   |  LFB Class\
    \ ID is known  |\n   |                             |           |   by receiver\
    \ but not   |\n   |                             |           |    currently in\
    \ use.    |\n   | E_LFB_INSTANCE_ID_NOT_FOUND |    0x07   |  LFB Class ID is known\
    \  |\n   |                             |           |    but the specified    |\n\
    \   |                             |           |  instance of that class |\n  \
    \ |                             |           |     does not exist.     |\n   |\
    \        E_INVALID_PATH       |    0x08   |  The specified path is  |\n   |  \
    \                           |           |       impossible.       |\n   |  E_COMPONENT_DOES_NOT_EXIST\
    \ |    0x09   |  The specified path is  |\n   |                             |\
    \           |     possible but the    |\n   |                             |  \
    \         |    component does not   |\n   |                             |    \
    \       | exist (e.g., attempt to |\n   |                             |      \
    \     | modify a table row that |\n   |                             |        \
    \   |  has not been created). |\n   |           E_EXISTS          |    0x0A  \
    \ |   The specified object  |\n   |                             |           |\
    \   exists but it cannot  |\n   |                             |           | exist\
    \ for the operation |\n   |                             |           |    to succeed\
    \ (e.g.,    |\n   |                             |           |    attempt to add\
    \ an    |\n   |                             |           |  existing LFB instance\
    \  |\n   |                             |           |   or array subscript).  |\n\
    \   |         E_NOT_FOUND         |    0x0B   |   The specified object  |\n  \
    \ |                             |           |  does not exist but it  |\n   |\
    \                             |           |    MUST exist for the   |\n   |  \
    \                           |           |   operation to succeed  |\n   |    \
    \                         |           |    (e.g., attempt to    |\n   |      \
    \                       |           |  delete a non-existing  |\n   |        \
    \                     |           |  LFB instance or array  |\n   |          \
    \                   |           |       subscript).       |\n   |         E_READ_ONLY\
    \         |    0x0C   |   Attempt to modify a   |\n   |                      \
    \       |           |     read-only value.    |\n   |   E_INVALID_ARRAY_CREATION\
    \  |    0x0D   |   Attempt to create an  |\n   |                             |\
    \           | array with an unallowed |\n   |                             |  \
    \         |        subscript.       |\n   |     E_VALUE_OUT_OF_RANGE    |    0x0E\
    \   |     Attempt to set a    |\n   |                             |          \
    \ |   parameter to a value  |\n   |                             |           |\
    \      outside of its     |\n   |                             |           |  \
    \   allowable range.    |\n   |     E_CONTENTS_TOO_LONG     |    0x0D   |    \
    \ Attempt to write    |\n   |                             |           |   contents\
    \ larger than  |\n   |                             |           | the target object\
    \ space |\n   |                             |           |    (i.e., exceeding\
    \ a   |\n   |                             |           |         buffer).     \
    \   |\n   |     E_INVALID_PARAMETERS    |    0x10   |   Any other error with \
    \ |\n   |                             |           |     data parameters.    |\n\
    \   |    E_INVALID_MESSAGE_TYPE   |    0x11   |   Message type is not   |\n  \
    \ |                             |           |       acceptable.       |\n   |\
    \       E_INVALID_FLAGS       |    0x12   |  Message flags are not  |\n   |  \
    \                           |           |    acceptable for the   |\n   |    \
    \                         |           |   given message type.   |\n   |      \
    \  E_INVALID_TLV        |    0x13   | A TLV is not acceptable |\n   |        \
    \                     |           |  for the given message  |\n   |          \
    \                   |           |          type.          |\n   |        E_EVENT_ERROR\
    \        |    0x14   | Unspecified error while |\n   |                       \
    \      |           |    handling an event.   |\n   |       E_NOT_SUPPORTED   \
    \    |    0x15   |   Attempt to perform a  |\n   |                           \
    \  |           |  valid ForCES operation |\n   |                             |\
    \           |  that is unsupported by |\n   |                             |  \
    \         |  the message receiver.  |\n   |        E_MEMORY_ERROR       |    0x16\
    \   | A memory error occurred |\n   |                             |          \
    \ |    while processing a   |\n   |                             |           |\
    \    message (no error    |\n   |                             |           | detected\
    \ in the message |\n   |                             |           |         itself).\
    \        |\n   |       E_INTERNAL_ERROR      |    0x17   |   An unspecified error\
    \  |\n   |                             |           |      occurred while     |\n\
    \   |                             |           |   processing a message  |\n  \
    \ |                             |           |  (no error detected in  |\n   |\
    \                             |           |   the message itself).  |\n   |  \
    \            -              | 0x18-0xFE |         Reserved        |\n   |    \
    \ E_UNSPECIFIED_ERROR     |    0xFF   |  Unspecified error (for |\n   |      \
    \                       |           |    when the FE cannot   |\n   |        \
    \                     |           |     decide what went    |\n   |          \
    \                   |           |         wrong).         |\n   +-----------------------------+-----------+-------------------------+\n\
    \                                  Table 4\n"
- title: 7.1.8.  DATA TLV
  contents:
  - "7.1.8.  DATA TLV\n   A FULLDATA-TLV has \"T\"= FULLDATA-TLV and a 16-bit length\
    \ followed by\n   the data value/contents.  Likewise, a SPARSEDATA-TLV has \"\
    T\" =\n   SPARSEDATA-TLV, a 16-bit length, followed by the data value/contents.\n\
    \   In the case of the SPARSEDATA-TLV, each component in the Value part\n   of\
    \ the TLV will be further encapsulated in an ILV.\n   Below are the encoding rules\
    \ for the FULLDATA-TLV and SPARSEDATA-\n   TLVs.  Appendix C is very useful in\
    \ illustrating these rules:\n   1.  Both ILVs and TLVs MUST be 32-bit aligned.\
    \  Any padding bits used\n       for the alignment MUST be zero on transmission\
    \ and MUST be\n       ignored upon reception.\n   2.  FULLDATA-TLVs may be used\
    \ at a particular path only if every\n       component at that path level is present.\
    \  In example 1(c) of\n       Appendix C, this concept is illustrated by the presence\
    \ of all\n       components of the structure S in the FULLDATA-TLV encoding. \
    \ This\n       requirement holds regardless of whether the fields are fixed or\n\
    \       variable length, mandatory or optional.\n       *   If a FULLDATA-TLV\
    \ is used, the encoder MUST lay out data for\n           each component in the\
    \ same order in which the data was\n           defined in the LFB specification.\
    \  This ensures the decoder\n           is able to retrieve the data.  To use\
    \ the example 1 again in\n           Appendix C, this implies the encoder/decoder\
    \ is assumed to\n           have knowledge of how structure S is laid out in the\n\
    \           definition.\n       *   In the case of a SPARSEDATA-TLV, it does not\
    \ need to be\n           ordered since the \"I\" in the ILV uniquely identifies\
    \ the\n           component.  Examples 1(a) and 1(b) in Appendix C illustrate\n\
    \           the power of SPARSEDATA-TLV encoding.\n   3.  Inside a FULLDATA-TLV\n\
    \       *   The values for atomic, fixed-length fields are given without\n   \
    \        any TLV encapsulation.\n       *   The values for atomic, variable-length\
    \ fields are given\n           inside FULLDATA-TLVs.\n       *   The values for\
    \ arrays are in the form of index/subscript,\n           followed by value as\
    \ stated in \"Data Packing Rules\"\n           (Section 7.1.1) and demonstrated\
    \ by the examples in the\n           appendices.\n   4.  Inside a SPARSEDATA-TLV\n\
    \       *   The values of all fields MUST be given with ILVs (32-bit\n       \
    \    index, 32-bit length).\n   5.  FULLDATA-TLVs cannot contain an ILV.\n   6.\
    \  A FULLDATA-TLV can also contain a FULLDATA-TLV for variable-sized\n       components.\
    \  The decoding disambiguation is assumed from rule #3\n       above.\n"
- title: 7.1.9.  SET and GET Relationship
  contents:
  - "7.1.9.  SET and GET Relationship\n   It is expected that a GET-RESPONSE would\
    \ satisfy the following:\n   o   It would have exactly the same path definitions\
    \ as those sent in\n       the GET.  The only difference is that a GET-RESPONSE\
    \ will contain\n       FULLDATA-TLVs.\n   o   It should be possible to take the\
    \ same GET-RESPONSE and convert\n       it to a SET successfully by merely changing\
    \ the T in the\n       operational TLV.\n   o   There are exceptions to this rule:\n\
    \       1.  When a KEY selector is used with a path in a GET operation,\n    \
    \       that selector is not returned in the GET-RESPONSE; instead,\n        \
    \   the cooked result is returned.  Refer to the examples using\n           KEYS\
    \ to see this.\n       2.  When dumping a whole table in a GET, the GET-RESPONSE\
    \ that\n           merely edits the T to be SET will end up overwriting the\n\
    \           table.\n"
- title: 7.2.  Protocol Encoding Visualization
  contents:
  - "7.2.  Protocol Encoding Visualization\n   The figure below shows a general layout\
    \ of the PL PDU.  A main header\n   is followed by one or more LFB selections\
    \ each of which may contain\n   one or more operations.\n   main hdr (Config in\
    \ this case)\n        |\n        |\n        +--- T = LFBselect\n        |    \
    \    |\n        |        +-- LFBCLASSID\n        |        |\n        |       \
    \ |\n        |        +-- LFBInstance\n        |        |\n        |        +--\
    \ T = SET\n        |        |   |\n        |        |   +--  // one or more path\
    \ targets\n        |        |        // with their data here to be added\n   \
    \     |        |\n        |        +-- T  = DEL\n        |        .   |\n    \
    \    |        .   +--  // one or more path targets to be deleted\n        |\n\
    \        |\n        +--- T = LFBselect\n        |        |\n        |        +--\
    \ LFBCLASSID\n        |        |\n        |        |\n        |        +-- LFBInstance\n\
    \        |        |\n        |        + -- T= SET\n        |        |    .\n \
    \       |        |    .\n        |        + -- T= DEL\n        |        |    .\n\
    \        |        |    .\n        |        |\n        |        + -- T= SET\n \
    \       |        |    .\n        |        |    .\n        |\n        |\n     \
    \   +--- T = LFBselect\n                |\n                +-- LFBCLASSID\n  \
    \              |\n                +-- LFBInstance\n                .\n       \
    \         .\n                .\n                     Figure 21: PL PDU Logical\
    \ Layout\n   The figure below shows a more detailed example of the general layout\n\
    \   of the operation within a targeted LFB selection.  The idea is to\n   show\
    \ the different nesting levels a path could take to get to the\n   target path.\n\
    \        T = SET\n        |  |\n        |  +- T = Path-data\n        |       |\n\
    \        |       + -- flags\n        |       + -- IDCount\n        |       + --\
    \ IDs\n        |       |\n        |       +- T = Path-data\n        |        \
    \  |\n        |          + -- flags\n        |          + -- IDCount\n       \
    \ |          + -- IDs\n        |          |\n        |          +- T = Path-data\n\
    \        |             |\n        |             + -- flags\n        |        \
    \     + -- IDCount\n        |             + -- IDs\n        |             + --\
    \ T = KEYINFO-TLV\n        |             |    + -- KEY_ID\n        |         \
    \    |    + -- KEY_DATA\n        |             |\n        |             + -- T\
    \ = FULLDATA-TLV\n        |                  + -- data\n        |\n        |\n\
    \        T = SET\n        |  |\n        |  +- T = Path-data\n        |  |  |\n\
    \        |  |  + -- flags\n        |  |  + -- IDCount\n        |  |  + -- IDs\n\
    \        |  |  |\n        |  |  + -- T = FULLDATA-TLV\n        |  |          +\
    \ -- data\n        |  +- T = Path-data\n        |     |\n        |     + -- flags\n\
    \        |     + -- IDCount\n        |     + -- IDs\n        |     |\n       \
    \ |     + -- T = FULLDATA-TLV\n        |             + -- data\n        T = DEL\n\
    \           |\n           +- T = Path-data\n                |\n              \
    \  + -- flags\n                + -- IDCount\n                + -- IDs\n      \
    \          |\n                +- T = Path-data\n                   |\n       \
    \            + -- flags\n                   + -- IDCount\n                   +\
    \ -- IDs\n                   |\n                   +- T = Path-data\n        \
    \              |\n                      + -- flags\n                      + --\
    \ IDCount\n                      + -- IDs\n                      + -- T = KEYINFO-TLV\n\
    \                      |    + -- KEY_ID\n                      |    + -- KEY_DATA\n\
    \                      +- T = Path-data\n                           |\n      \
    \                     + -- flags\n                           + -- IDCount\n  \
    \                         + -- IDs\n                    Figure 22: Sample Operation\
    \ Layout\n   Appendix D shows a more concise set of use cases on how the data\n\
    \   encoding is done.\n"
- title: 7.3.  Core ForCES LFBs
  contents:
  - "7.3.  Core ForCES LFBs\n   There are two LFBs that are used to control the operation\
    \ of the\n   ForCES protocol and to interact with FEs and CEs:\n   o  FE Protocol\
    \ LFB\n   o  FE Object LFB\n   Although these LFBs have the same form and interface\
    \ as other LFBs,\n   they are special in many respects.  They have fixed well-known\
    \ LFB\n   Class and Instance IDs.  They are statically defined (no dynamic\n \
    \  instantiation allowed), and their status cannot be changed by the\n   protocol:\
    \ any operation to change the state of such LFBs (for\n   instance, in order to\
    \ disable the LFB) MUST result in an error.\n   Moreover, these LFBs MUST exist\
    \ before the first ForCES message can\n   be sent or received.  All components\
    \ in these LFBs MUST have pre-\n   defined default values.  Finally, these LFBs\
    \ do not have input or\n   output ports and do not integrate into the intra-FE\
    \ LFB topology.\n"
- title: 7.3.1.  FE Protocol LFB
  contents:
  - "7.3.1.  FE Protocol LFB\n   The FE Protocol LFB is a logical entity in each FE\
    \ that is used to\n   control the ForCES protocol.  The FE Protocol LFB Class\
    \ ID is\n   assigned the value 0x2.  The FE Protocol LFB Instance ID is assigned\n\
    \   the value 0x1.  There MUST be one and only one instance of the FE\n   Protocol\
    \ LFB in an FE.  The values of the components in the FE\n   Protocol LFB have\
    \ pre-defined default values that are specified here.\n   Unless explicit changes\
    \ are made to these values using Config\n   messages from the CE, these default\
    \ values MUST be used for correct\n   operation of the protocol.\n   The formal\
    \ definition of the FE Protocol Object LFB can be found in\n   Appendix B.\n"
- title: 7.3.1.1.  FE Protocol Capabilities
  contents:
  - "7.3.1.1.  FE Protocol Capabilities\n   FE Protocol capabilities are read-only.\n"
- title: 7.3.1.1.1.  SupportableVersions
  contents:
  - "7.3.1.1.1.  SupportableVersions\n   ForCES protocol version(s) supported by the\
    \ FE.\n"
- title: 7.3.1.1.2.  FE Protocol Components
  contents:
  - "7.3.1.1.2.  FE Protocol Components\n   FE Protocol components (can be read and\
    \ set).\n"
- title: 7.3.1.1.2.1.  CurrentRunningVersion
  contents:
  - "7.3.1.1.2.1.  CurrentRunningVersion\n   Current running version of the ForCES\
    \ protocol.\n"
- title: 7.3.1.1.2.2.  FEID
  contents:
  - "7.3.1.1.2.2.  FEID\n   FE unicast ID.\n"
- title: 7.3.1.1.2.3.  MulticastFEIDs
  contents:
  - "7.3.1.1.2.3.  MulticastFEIDs\n   FE multicast ID(s) list - This is a list of\
    \ multicast IDs to which\n   the FE belongs.  These IDs are configured by the\
    \ CE.\n"
- title: 7.3.1.1.2.4.  CEHBPolicy
  contents:
  - "7.3.1.1.2.4.  CEHBPolicy\n   CE heartbeat policy - This policy, along with the\
    \ parameter 'CE\n   Heartbeat Dead Interval (CE HDI)' as described below, defines\
    \ the\n   operating parameters for the FE to check the CE liveness.  The policy\n\
    \   values with meanings are listed as follows:\n   o  0 (default) - This policy\
    \ specifies that the CE will send a\n      Heartbeat message to the FE(s) whenever\
    \ the CE reaches a time\n      interval within which no other PL messages were\
    \ sent from the CE\n      to the FE(s); refer to Section 4.3.3 and Section 7.10\
    \ for details.\n      The CE HDI component as described below is tied to this\
    \ policy.\n   o  1 - The CE will not generate any HB messages.  This actually\
    \ means\n      that the CE does not want the FE to check the CE liveness.\n  \
    \ o  Others - Reserved.\n"
- title: 7.3.1.1.2.5.  CEHDI
  contents:
  - "7.3.1.1.2.5.  CEHDI\n   CE Heartbeat Dead Interval (CE HDI) - The time interval\
    \ the FE uses\n   to check the CE liveness.  If FE has not received any messages\
    \ from\n   CE within this time interval, FE deduces lost connectivity, which\n\
    \   implies that the CE is dead or the association to the CE is lost.\n   Default\
    \ value is 30 s.\n"
- title: 7.3.1.1.2.6.  FEHBPolicy
  contents:
  - "7.3.1.1.2.6.  FEHBPolicy\n   FE heartbeat policy - This policy, along with the\
    \ parameter 'FE\n   Heartbeat Interval (FE HI)', defines the operating parameters\
    \ for how\n   the FE should behave so that the CE can deduce its liveness.  The\n\
    \   policy values and the meanings are:\n   o  0 (default) - The FE should not\
    \ generate any Heartbeat messages.\n      In this scenario, the CE is responsible\
    \ for checking FE liveness\n      by setting the PL header ACK flag of the message\
    \ it sends to\n      AlwaysACK.  The FE responds to the CE whenever the CE sends\
    \ such\n      Heartbeat Request messages.  Refer to Section 7.10 and\n      Section\
    \ 4.3.3 for details.\n   o  1 - This policy specifies that the FE MUST actively\
    \ send a\n      Heartbeat message if it reaches the time interval assigned by\
    \ the\n      FE HI as long as no other messages were sent from the FE to the CE\n\
    \      during that interval as described in Section 4.3.3.\n   o  Others - Reserved.\n"
- title: 7.3.1.1.2.7.  FEHI
  contents:
  - "7.3.1.1.2.7.  FEHI\n   FE Heartbeat Interval (FE HI) - The time interval the\
    \ FE should use\n   to send HB as long as no other messages were sent from the\
    \ FE to the\n   CE during that interval as described in Section 4.3.3.  The default\n\
    \   value for an FE HI is 500 ms.\n"
- title: 7.3.1.1.2.8.  CEID
  contents:
  - "7.3.1.1.2.8.  CEID\n   Primary CEID - The CEID with which the FE is associated.\n"
- title: 7.3.1.1.2.9.  LastCEID
  contents:
  - "7.3.1.1.2.9.  LastCEID\n   Last Primary CEID - The CEID of the last CE with which\
    \ the FE\n   associated.  This CE ID is reported to the new Primary CEID.\n"
- title: 7.3.1.1.2.10.  BackupCEs
  contents:
  - "7.3.1.1.2.10.  BackupCEs\n   The list of backup CEs an FE can use as backups.\
    \  Refer to Section 8\n   for details.\n"
- title: 7.3.1.1.2.11.  CEFailoverPolicy
  contents:
  - "7.3.1.1.2.11.  CEFailoverPolicy\n   CE failover policy - This specifies the behavior\
    \ of the FE when the\n   association with the CE is lost.  There is a very tight\
    \ relation\n   between CE failover policy and Section 7.3.1.1.2.8,\n   Section\
    \ 7.3.1.1.2.10, Section 7.3.1.1.2.12, and Section 8.  When an\n   association\
    \ is lost, depending on configuration, one of the policies\n   listed below is\
    \ activated.\n   o  0 (default) - The FE should stop functioning immediately and\n\
    \      transition to FE OperDisable.\n   o  1 - The FE should continue running\
    \ and do what it can even without\n      an associated CE.  This basically requires\
    \ that the FE support CE\n      Graceful restart (and defines such support in\
    \ its capabilities).\n      If the CEFTI expires before the FE re-associates with\
    \ either the\n      primary CEID (Section 7.3.1.1.2.8) or one of possibly several\n\
    \      backup CEs (Section 7.3.1.1.2.10), the FE will go operationally\n     \
    \ down.\n   o  Others - Reserved.\n"
- title: 7.3.1.1.2.12.  CEFTI
  contents:
  - "7.3.1.1.2.12.  CEFTI\n   CE Failover Timeout Interval (CEFTI) - The time interval\
    \ associated\n   with the CE failover policy case '0' and '1'.  The default value\
    \ is\n   set to 300 seconds.  Note that it is advisable to set the CEFTI value\n\
    \   much higher than the CE Heartbeat Dead Interval (CE HDI) since the\n   effect\
    \ of expiring this parameter is devastating to the operation of\n   the FE.\n"
- title: 7.3.1.1.2.13.  FERestartPolicy
  contents:
  - "7.3.1.1.2.13.  FERestartPolicy\n   FE restart policy - This specifies the behavior\
    \ of the FE during an\n   FE restart.  The restart may be from an FE failure or\
    \ other reasons\n   that have made the FE down and then need to restart.  The\
    \ values are\n   defined as follows:\n   o  0(default)- Restart the FE from scratch.\
    \  In this case, the FE\n      should start from the pre-association phase.\n\
    \   o  Others - Reserved for future use.\n"
- title: 7.3.2.  FE Object LFB
  contents:
  - "7.3.2.  FE Object LFB\n   The FE Object LFB is a logical entity in each FE and\
    \ contains\n   components relative to the FE itself, and not to the operation\
    \ of the\n   ForCES protocol.\n   The formal definition of the FE Object LFB can\
    \ be found in [RFC5812].\n   The model captures the high-level properties of the\
    \ FE that the CE\n   needs to know to begin working with the FE.  The class ID\
    \ for this\n   LFB class is also assigned in [RFC5812].  The singular instance\
    \ of\n   this class will always exist, and will always have instance ID 0x1\n\
    \   within its class.  It is common, although not mandatory, for a CE to\n   fetch\
    \ much of the component and capability information from this LFB\n   instance\
    \ when the CE begins controlling the operation of the FE.\n"
- title: 7.4.  Semantics of Message Direction
  contents:
  - "7.4.  Semantics of Message Direction\n   Recall: The PL provides a master(CE)-slave(FE)\
    \ relationship.  The\n   LFBs reside at the FE and are controlled by CE.\n   When\
    \ messages go from the CE, the LFB selector (class and instance)\n   refers to\
    \ the destination LFB selection that resides in the FE.\n   When messages go from\
    \ the FE to the CE, the LFB selector (class and\n   instance) refers to the source\
    \ LFB selection that resides in the FE.\n"
- title: 7.5.  Association Messages
  contents:
  - "7.5.  Association Messages\n   The ForCES Association messages are used to establish\
    \ and tear down\n   associations between FEs and CEs.\n"
- title: 7.5.1.  Association Setup Message
  contents:
  - "7.5.1.  Association Setup Message\n   This message is sent by the FE to the CE\
    \ to set up a ForCES\n   association between them.\n   Message transfer direction:\n\
    \      FE to CE\n   Message header:\n      The Message Type in the header is set\
    \ to MessageType=\n      'AssociationSetup'.  The ACK flag in the header MUST\
    \ be ignored,\n      and the Association Setup message always expects to get a\
    \ response\n      from the message receiver (CE), whether or not the setup is\n\
    \      successful.  The correlator field in the header is set, so that FE\n  \
    \    can correlate the response coming back from the CE correctly.  The\n    \
    \  FE may set the source ID to 0 in the header to request that the CE\n      should\
    \ assign an FE ID for the FE in the Setup Response message.\n   Message body:\n\
    \      The Association Setup message body optionally consists of zero,\n     \
    \ one, or two LFBselect TLVs, as described in Section 7.1.5.  The\n      Association\
    \ Setup message only operates on the FE Object and FE\n      Protocol LFBs; therefore,\
    \ the LFB class ID in the LFBselect TLV\n      only points to these two kinds\
    \ of LFBs.\n      The OPER-TLV in the LFBselect TLV is defined as a 'REPORT'\n\
    \      operation.  More than one component may be announced in this\n      message\
    \ using the REPORT operation to let the FE declare its\n      configuration parameters\
    \ in an unsolicited manner.  These may\n      contain components suggesting values\
    \ such as the FE HB Interval or\n      the FEID.  The OPER-TLV used is defined\
    \ below.\n   OPER-TLV for Association Setup:\n     0                   1     \
    \              2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |    Type = REPORT              |               Length          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    PATH-DATA-TLV for REPORT                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                             Figure 23: OPER-TLV\n   Type:\n      Only one operation\
    \ type is defined for the Association Setup\n      message:\n      Type = \"REPORT\"\
    \ - This type of operation is for the FE to report\n             something to\
    \ the CE.\n   PATH-DATA-TLV for REPORT:\n      This is generically a PATH-DATA-TLV\
    \ format that has been defined\n      in Section 7 in the PATH-DATA BNF definition.\
    \  The PATH-DATA-TLV\n      for the REPORT operation MAY contain FULLDATA-TLV(s)\
    \ but SHALL NOT\n      contain any RESULT-TLV in the data format.  The RESULT-TLV\
    \ is\n      defined in Section 7.1.7 and the FULLDATA-TLV is defined in\n    \
    \  Section 7.1.8.\n   To better illustrate the above PDU format, a tree structure\
    \ for the\n   format is shown below:\n   main hdr (type =  Association Setup)\n\
    \        |\n        |\n        +--- T = LFBselect\n        |        |\n      \
    \  |        +-- LFBCLASSID = FE object\n        |        |\n        |        |\n\
    \        |        +-- LFBInstance = 0x1\n        |\n        +--- T = LFBselect\n\
    \                 |\n                 +-- LFBCLASSID = FE Protocol object\n  \
    \               |\n                 |\n                 +-- LFBInstance = 0x1\n\
    \                       |\n                       +---OPER-TLV = REPORT\n    \
    \                       |\n                           +-- Path-data to one or\
    \ more components\n            Figure 24: PDU Format for Association Setup Message\n"
- title: 7.5.2.  Association Setup Response Message
  contents:
  - "7.5.2.  Association Setup Response Message\n   This message is sent by the CE\
    \ to the FE in response to the Setup\n   message.  It indicates to the FE whether\
    \ or not the setup is\n   successful, i.e., whether an association is established.\n\
    \   Message transfer direction:\n   CE to FE\n   Message header:\n   The Message\
    \ Type in the header is set to MessageType=\n   'AssociationSetupResponse'.  The\
    \ ACK flag in the header MUST be\n   ignored, and the Setup Response message never\
    \ expects to get any more\n   responses from the message receiver (FE).  The destination\
    \ ID in the\n   header will be set to the source ID in the corresponding Association\n\
    \   Setup message, unless that source ID was 0.  If the corresponding\n   source\
    \ ID was 0, then the CE will assign an FE ID value and use that\n   value for\
    \ the destination ID.\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        Type = ASRresult       |               Length          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                  Association Setup Result                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 25: ASResult OPER-TLV\n   Type (16 bits):\n \
    \  The type of the TLV is \"ASResult\".\n   Length (16 bits):\n   Length of the\
    \ TLV including the T and L fields, in octets.\n   Association Setup result (32\
    \ bits):\n   This indicates whether the Setup message was successful or whether\n\
    \   the FE request was rejected by the CE.  The defined values are:\n       0\
    \ = success\n       1 = FE ID invalid\n       2 = permission denied\n   To better\
    \ illustrate the above PDU format, a tree structure for the\n   format is shown\
    \ below:\n   main hdr (type =  Association Setup Response)\n    |\n    |\n   \
    \ +--- T = ASResult-TLV\n      Figure 26: PDU Format for Association Setup Response\
    \ Message\n"
- title: 7.5.3.  Association Teardown Message
  contents:
  - "7.5.3.  Association Teardown Message\n   This message can be sent by the FE or\
    \ CE to any ForCES element to end\n   its ForCES association with that element.\n\
    \   Message transfer direction:\n   CE to FE, or FE to CE (or CE to CE)\n   Message\
    \ Header:\n   The Message Type in the header is set to MessageType=\n   \"AssociationTeardown\"\
    .  The ACK flag MUST be ignored.  The correlator\n   field in the header MUST\
    \ be set to zero and MUST be ignored by the\n   receiver.\n     0            \
    \       1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        Type = ASTreason       |               Length          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                      Teardown Reason                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                           Figure 27: ASTreason-TLV\n   Type (16 bits):\n   The\
    \ type of the TLV is \"ASTreason\".\n   Length (16 bits):\n   Length of the TLV\
    \ including the T and L fields, in octets.\n   Teardown reason (32 bits):\n  \
    \ This indicates the reason why the association is being terminated.\n   Several\
    \ reason codes are defined as follows.\n       0 - normal teardown by administrator\n\
    \       1 - error - loss of heartbeats\n       2 - error - out of bandwidth\n\
    \       3 - error - out of memory\n       4 - error - application crash\n    \
    \   255 - error - other or unspecified\n   To better illustrate the above PDU\
    \ format, a tree structure for the\n   format is shown below:\n   main hdr (type\
    \ =  Association Teardown)\n    |\n    |\n    +--- T = ASTreason-TLV\n      Figure\
    \ 28: PDU Format for Association Teardown Message\n"
- title: 7.6.  Configuration Messages
  contents:
  - "7.6.  Configuration Messages\n   The ForCES Configuration messages are used by\
    \ CE to configure the FEs\n   in a ForCES NE and report the results back to the\
    \ CE.\n"
- title: 7.6.1.  Config Message
  contents:
  - "7.6.1.  Config Message\n   This message is sent by the CE to the FE to configure\
    \ LFB components\n   in the FE.  This message is also used by the CE to subscribe/\n\
    \   unsubscribe to LFB events.\n   As usual, a Config message is composed of a\
    \ common header followed by\n   a message body that consists of one or more TLV\
    \ data formats.\n   Detailed description of the message is as follows:\n   Message\
    \ transfer direction:\n   CE to FE\n   Message header:\n   The Message Type in\
    \ the header is set to MessageType= 'Config'.  The\n   ACK flag in the header\
    \ can be set to any value defined in\n   Section 6.1, to indicate whether or not\
    \ a response from the FE is\n   expected by the message.\n   OPER-TLV for Config:\n\
    \     0                   1                   2                   3\n     0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          Type                 |               Length          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                        PATH-DATA-TLV                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        Figure 29: OPER-TLV for Config\n   Type:\n   The operation\
    \ type for Config message.  Two types of operations for\n   the Config message\
    \ are defined:\n       Type = \"SET\" - This operation is to set LFB components\n\
    \       Type = \"SET-PROP\" - This operation is to set LFB component\n       \
    \       properties.\n       Type = \"DEL\" - This operation is to delete some\
    \ LFB components.\n       Type = \"COMMIT\" - This operation is sent to the FE\
    \ to commit in a\n              2pc transaction.  A COMMIT TLV is an empty TLV,\
    \ i.e., it\n              has no \"V\"alue.  In other words, there is a length\
    \ of 4\n              (which is for the header only).\n       Type = \"TRCOMP\"\
    \ - This operation is sent to the FE to mark the\n              success from an\
    \ NE perspective of a 2pc transaction.  A\n              TRCOMP TLV is an empty\
    \ TLV, i.e., it has no \"V\"alue.  In\n              other words, there is a length\
    \ of 4 (which is for the\n              header only).\n   PATH-DATA-TLV:\n   This\
    \ is generically a PATH-DATA-TLV format that has been defined in\n   Section 7\
    \ in the PATH-DATA-TLV BNF definition.  The restriction on\n   the use of PATH-DATA-TLV\
    \ for SET/SET-PROP operation is that it MUST\n   contain either FULLDATA-TLV or\
    \ SPARSEDATA-TLV(s), but MUST NOT\n   contain any RESULT-TLV.  The restriction\
    \ on the use of PATH-DATA-TLV\n   for DEL operation is it MAY contain FULLDATA-TLV\
    \ or\n   SPARSEDATA-TLV(s), but MUST NOT contain any RESULT-TLV.  The\n   RESULT-TLV\
    \ is defined in Section 7.1.7 and FULLDATA-TLVs and\n   SPARSEDATA-TLVs are defined\
    \ in Section 7.1.8.\n       Note:  For Event subscription, the events will be\
    \ defined by the\n              individual LFBs.\n   To better illustrate the\
    \ above PDU format, a tree structure for the\n   format is shown below:\n   main\
    \ hdr (type = Config)\n    |\n    |\n    +--- T = LFBselect\n    .        |\n\
    \    .        +-- LFBCLASSID = target LFB class\n    .        |\n            \
    \ |\n             +-- LFBInstance = target LFB instance\n             |\n    \
    \         |\n             +-- T = operation { SET }\n             |   |\n    \
    \         |   +--  // one or more path targets\n             |      // associated\
    \ with FULLDATA-TLV or SPARSEDATA-TLV(s)\n             |\n             +-- T =\
    \ operation { DEL }\n             |   |\n             |   +--  // one or more\
    \ path targets\n             |\n             +-- T = operation { COMMIT } //A\
    \ COMMIT TLV is an empty TLV\n                      .\n                      .\n\
    \              Figure 30: PDU Format for Configuration Message\n"
- title: 7.6.2.  Config Response Message
  contents:
  - "7.6.2.  Config Response Message\n   This message is sent by the FE to the CE\
    \ in response to the Config\n   message.  It indicates whether or not the Config\
    \ was successful on\n   the FE and also gives a detailed response regarding the\
    \ configuration\n   result of each component.\n   Message transfer direction:\n\
    \   FE to CE\n   Message header:\n   The Message Type in the header is set to\
    \ MessageType= 'Config\n   Response'.  The ACK flag in the header is always ignored,\
    \ and the\n   Config Response message never expects to get any further response\n\
    \   from the message receiver (CE).\n   OPER-TLV for Config Response:\n     0\
    \                   1                   2                   3\n     0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          Type                 |               Length          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                        PATH-DATA-TLV                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 31: OPER-TLV for Config Response\n   Type:\n     \
    \     The operation type for Config Response message.  Two types of\n        \
    \  operations for the Config Response message are defined:\n       Type = \"SET-RESPONSE\"\
    \ - This operation is for the response of the\n              SET operation of\
    \ LFB components.\n       Type = \"SET-PROP-RESPONSE\" - This operation is for\
    \ the response\n              of the SET-PROP operation of LFB component properties.\n\
    \       Type = \"DEL-RESPONSE\" - This operation is for the response of the\n\
    \              DELETE operation of LFB components.\n       Type = \"COMMIT-RESPONSE\"\
    \ - This operation is sent to the CE to\n              confirm a commit success\
    \ in a 2pc transaction.  A\n              COMMIT-RESPONSE TLV MUST contain a RESULT-TLV\
    \ indicating\n              success or failure.\n   PATH-DATA-TLV:\n   This is\
    \ generically a PATH-DATA-TLV format that has been defined in\n   Section 7 in\
    \ the PATH-DATA-TLV BNF definition.  The restriction on\n   the use of PATH-DATA-TLV\
    \ for SET-RESPONSE operation is that it MUST\n   contain RESULT-TLV(s).  The restriction\
    \ on the use of PATH-DATA-TLV\n   for DEL-RESPONSE operation is it also MUST contain\
    \ RESULT-TLV(s).\n   The RESULT-TLV is defined in Section 7.1.7.\n   To better\
    \ illustrate the above PDU format, a tree structure for the\n   format is shown\
    \ below:\n    main hdr (type = ConfigResponse)\n     |\n     |\n     +--- T =\
    \ LFBselect\n     .        |\n     .        +-- LFBCLASSID = target LFB class\n\
    \     .        |\n              |\n              +-- LFBInstance = target LFB\
    \ instance\n              |\n              |\n              +-- T = operation\
    \ { SET-RESPONSE }\n              |   |\n              |   +--  // one or more\
    \ path targets\n              |        // associated with FULL or SPARSEDATA-TLV(s)\n\
    \              |\n              +-- T = operation { DEL-RESPONSE }\n         \
    \     |   |\n              |   +--  // one or more path targets\n            \
    \  |\n              +-- T = operation { COMMIT-RESPONSE }\n              |   \
    \        |\n              |           +--  RESULT-TLV\n             Figure 32:\
    \ PDU Format for Config Response Message\n"
- title: 7.7.  Query Messages
  contents:
  - "7.7.  Query Messages\n   The ForCES Query messages are used by the CE to query\
    \ LFBs in the FE\n   for information like LFB components, capabilities, statistics,\
    \ etc.\n   Query messages include the Query message and the Query Response\n \
    \  message.\n"
- title: 7.7.1.  Query Message
  contents:
  - "7.7.1.  Query Message\n   A Query message is composed of a common header and\
    \ a message body\n   that consists of one or more TLV data formats.  Detailed\
    \ description\n   of the message is as follows:\n   Message transfer direction:\n\
    \   from CE to FE\n   Message header:\n   The Message Type in the header is set\
    \ to MessageType= 'Query'.  The\n   ACK flag in the header is always ignored,\
    \ and a full response for a\n   Query message is always expected.  The Correlator\
    \ field in the header\n   is set, so that the CE can locate the response back\
    \ from FE\n   correctly.\n   OPER-TLV for Query:\n     0                   1 \
    \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |    Type = GET/GET-PROP        |               Length          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    PATH-DATA-TLV for GET/GET-PROP             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                           Figure 33: TLV for Query\n   Type:\n   The operation\
    \ type for query.  Two operation types are defined:\n       Type = \"GET\" - This\
    \ operation is to request to get LFB\n              components.\n       Type =\
    \ \"GET-PROP\" - This operation is to request to get LFB\n              component\
    \ properties.\n   PATH-DATA-TLV for GET/GET-PROP:\n   This is generically a PATH-DATA-TLV\
    \ format that has been defined in\n   Section 7 in the PATH-DATA-TLV BNF definition.\
    \  The restriction on\n   the use of PATH-DATA-TLV for GET/GET-PROP operation\
    \ is it MUST NOT\n   contain any SPARSEDATA-TLV or FULLDATA- TLV and RESULT-TLV\
    \ in the\n   data format.\n   To better illustrate the above PDU format, a tree\
    \ structure for the\n   format is shown below:\n   main hdr (type = Query)\n \
    \   |\n    |\n    +--- T = LFBselect\n    .        |\n    .        +-- LFBCLASSID\
    \ = target LFB class\n    .        |\n             |\n             +-- LFBInstance\
    \ = target LFB instance\n             |\n             |\n             +-- T =\
    \ operation { GET }\n             |   |\n             |   +--  // one or more\
    \ path targets\n             |\n             +-- T = operation { GET }\n     \
    \        .   |\n             .   +--  // one or more path targets\n          \
    \   .\n                  Figure 34: PDU Format for Query Message\n"
- title: 7.7.2.  Query Response Message
  contents:
  - "7.7.2.  Query Response Message\n   When receiving a Query message, the receiver\
    \ should process the\n   message and come up with a query result.  The receiver\
    \ sends the\n   query result back to the message sender by use of the Query Response\n\
    \   message.  The query result can be the information being queried if\n   the\
    \ query operation is successful, or can also be error codes if the\n   query operation\
    \ fails, indicating the reasons for the failure.\n   A Query Response message\
    \ is also composed of a common header and a\n   message body consisting of one\
    \ or more TLVs describing the query\n   result.  Detailed description of the message\
    \ is as follows:\n   Message transfer direction:\n   from FE to CE\n   Message\
    \ header:\n   The Message Type in the header is set to MessageType=\n   'QueryResponse'.\
    \  The ACK flag in the header is ignored.  As a\n   response itself, the message\
    \ does not expect a further response.\n   OPER-TLV for Query Response:\n     0\
    \                   1                   2                   3\n     0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |Type = GET-RESPONSE/GET-PROP-RESPONSE|    Length               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        PATH-DATA-TLV for GET-RESPONSE/GET-PROP-RESPONSE       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 35: TLV for Query Response\n   Type:\n   The operation\
    \ type for query response.  One operation type is\n   defined:\n       Type =\
    \ \"GET-RESPONSE\" - This operation is for the response of the\n             \
    \ GET operation of LFB components.\n       Type = \"GET-PROP-RESPONSE\" - This\
    \ operation is for the response\n              of the GET-PROP operation of LFB\
    \ components.\n   PATH-DATA-TLV for GET-RESPONSE/GET-PROP-RESPONSE:\n   This is\
    \ generically a PATH-DATA-TLV format that has been defined in\n   Section 7 in\
    \ the PATH-DATA-TLV BNF definition.  The PATH-DATA- TLV\n   for the GET-RESPONSE\
    \ operation MAY contain SPARSEDATA-TLV,\n   FULLDATA-TLV, and/or RESULT-TLV(s)\
    \ in the data encoding.  The\n   RESULT-TLV is defined in Section 7.1.7 and the\
    \ SPARSEDATA-TLVs and\n   FULLDATA-TLVs are defined in Section 7.1.8.\n   To better\
    \ illustrate the above PDU format, a tree structure for the\n   format is shown\
    \ below:\n   main hdr (type = QueryResponse)\n     |\n     |\n     +--- T = LFBselect\n\
    \     .        |\n     .        +-- LFBCLASSID = target LFB class\n     .    \
    \    |\n              |\n              +-- LFBInstance = target LFB instance\n\
    \              |\n              |\n              +-- T = operation { GET-RESPONSE\
    \ }\n              |   |\n              |   +--  // one or more path targets\n\
    \              |\n              +-- T = operation { GET-PROP-RESPONSE }\n    \
    \          .   |\n              .   +--  // one or more path targets\n       \
    \       .\n             Figure 36: PDU Format for Query Response Message\n"
- title: 7.8.  Event Notification Message
  contents:
  - "7.8.  Event Notification Message\n   Event Notification message is used by the\
    \ FE to asynchronously notify\n   the CE of events that happen in the FE.\n  \
    \ All events that can be generated in an FE are subscribable by the CE.\n   The\
    \ CE can subscribe to an event via a Config message with the SET-\n   PROP operation,\
    \ where the included path specifies the event, as\n   defined by the LFB Library\
    \ and described by the FE Model.\n   As usual, an Event Notification message is\
    \ composed of a common\n   header and a message body that consists of one or more\
    \ TLV data\n   formats.  Detailed description of the message is as follows:\n\
    \   Message transfer direction:\n   FE to CE\n   Message header:\n   The Message\
    \ Type in the message header is set to\n   MessageType = 'EventNotification'.\
    \  The ACK flag in the header MUST\n   be ignored by the CE, and the Event Notification\
    \ message does not\n   expect any response from the receiver.\n   OPER-TLV for\
    \ Event Notification:\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = REPORT              |               Length          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    PATH-DATA-TLV for REPORT                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 37: TLV for Event Notification\n   Type:\n   Only\
    \ one operation type is defined for the Event Notification\n   message:\n    \
    \  Type = \"REPORT\" - This type of operation is for the FE to report\n      \
    \       something to the CE.\n   PATH-DATA-TLV for REPORT:\n   This is generically\
    \ a PATH-DATA-TLV format that has been defined in\n   Section 7 in the PATH-DATA-TLV\
    \ BNF definition.  The PATH-DATA- TLV\n   for the REPORT operation MAY contain\
    \ FULLDATA-TLV or\n   SPARSEDATA-TLV(s) but MUST NOT contain any RESULT-TLV in\
    \ the data\n   format.\n   To better illustrate the above PDU format, a tree structure\
    \ for the\n   format is shown below:\n   main hdr (type = Event Notification)\n\
    \     |\n     |\n     +--- T = LFBselect\n                |\n                +--\
    \ LFBCLASSID = target LFB class\n                |\n                |\n      \
    \          +-- LFBInstance = target LFB instance\n                |\n        \
    \        |\n                +-- T = operation { REPORT }\n                |  \
    \ |\n                |   +--  // one or more path targets\n                | \
    \       // associated with FULL/SPARSE DATA TLV(s)\n                +-- T = operation\
    \ { REPORT }\n                .   |\n                .   +--  // one or more path\
    \ targets\n                .        // associated with FULL/SPARSE DATA TLV(s)\n\
    \           Figure 38: PDU Format for Event Notification Message\n"
- title: 7.9.  Packet Redirect Message
  contents:
  - "7.9.  Packet Redirect Message\n   A Packet Redirect message is used to transfer\
    \ data packets between\n   the CE and FE.  Usually, these data packets are control\
    \ packets, but\n   they may be just data path packets that need further (exception\
    \ or\n   high-touch) processing.  It is also feasible that this message\n   carries\
    \ no data packets and rather just meta data.\n   The Packet Redirect message data\
    \ format is formatted as follows:\n   Message transfer direction:\n   CE to FE\
    \ or FE to CE\n   Message header:\n   The Message Type in the header is set to\
    \ MessageType=\n   'PacketRedirect'.\n   Message body:\n   This consists of one\
    \ or more TLVs that contain or describe the packet\n   being redirected.  The\
    \ TLV is specifically a Redirect TLV (with the\n   TLV Type=\"Redirect\").  Detailed\
    \ data format of a Redirect TLV for a\n   Packet Redirect message is as follows:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Type = Redirect        |               Length          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Meta Data TLV                          |\n   .  \
    \                                                             .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Redirect Data TLV                      |\n   .  \
    \                                                             .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 39: Redirect_Data TLV\n   Meta Data TLV:\n  \
    \ This is a TLV that specifies meta data associated with followed\n   redirected\
    \ data.  The TLV is as follows:\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = METADATA-TLV        |               Length          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Meta Data ILV                          |\n   .  \
    \                                                             .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                           ...                                 ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Meta Data ILV                          |\n   .  \
    \                                                             .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                           Figure 40: METADATA-TLV\n   Meta Data ILV:\n   This\
    \ is an Identifier-Length-Value format that is used to describe\n   one meta data.\
    \  The ILV has the format as:\n    0                   1                   2 \
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Meta Data ID                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Length                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Meta Data Value                        |\n   .  \
    \                                                             .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                           Figure 41: Meta Data ILV\n   where Meta Data ID is\
    \ an identifier for the meta data, which is\n   statically assigned by the LFB\
    \ definition.\n   Redirect Data TLV:\n   This is a TLV describing one packet of\
    \ data to be directed via the\n   redirect operation.  The TLV format is as follows:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = REDIRECTDATA-TLV    |               Length          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Redirected Data                        |\n   .  \
    \                                                             .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 42: Redirect Data TLV\n   Redirected Data:\n\
    \   This field contains the packet that is to be redirected in network\n   byte\
    \ order.  The packet should be 32 bits aligned as is the data for\n   all TLVs.\
    \  The meta data infers what kind of packet is carried in\n   value field and\
    \ therefore allows for easy decoding of data\n   encapsulated.\n   To better illustrate\
    \ the above PDU format, a tree structure for the\n   format is shown below:\n\
    \   main hdr (type = PacketRedirect)\n           |\n           |\n           +---\
    \ T = Redirect\n           .        |\n           .        +-- T = METADATA-TLV\n\
    \                    |          |\n                    |          +--  Meta Data\
    \ ILV\n                    |          |\n                    |          +--  Meta\
    \ Data ILV\n                    |          .\n                    |          .\n\
    \                    |\n                    +-- T = REDIRECTDATA-TLV\n       \
    \                 |\n                        +--  // Redirected Data\n       \
    \      Figure 43: PDU Format for Packet Redirect Message\n"
- title: 7.10.  Heartbeat Message
  contents:
  - "7.10.  Heartbeat Message\n   The Heartbeat (HB) message is used for one ForCES\
    \ element (FE or CE)\n   to asynchronously notify one or more other ForCES elements\
    \ in the\n   same ForCES NE on its liveness.  Section 4.3.3 describes the traffic-\n\
    \   sensitive approach used.\n   A Heartbeat message is sent by a ForCES element\
    \ periodically.  The\n   parameterization and policy definition for heartbeats\
    \ for an FE are\n   managed as components of the FE Protocol Object LFB, and can\
    \ be set\n   by CE via a Config message.  The Heartbeat message is a little\n\
    \   different from other protocol messages in that it is only composed of\n  \
    \ a common header, with the message body left empty.  A detailed\n   description\
    \ of the message is as follows:\n   Message transfer direction:\n   FE to CE or\
    \ CE to FE\n   Message header:\n   The Message Type in the message header is set\
    \ to MessageType =\n   'Heartbeat'.  Section 4.3.3 describes the HB mechanisms\
    \ used.  The\n   ACK flag in the header MUST be set to either 'NoACK' or 'AlwaysACK'\n\
    \   when the HB is sent.\n       *   When set to 'NoACK', the HB is not soliciting\
    \ for a response.\n       *   When set to 'AlwaysACK', the HB Message sender is\
    \ always\n           expecting a response from its receiver.  According to the\
    \ HB\n           policies defined in Section 7.3.1, only the CE can send such\n\
    \           an HB message to query FE liveness.  For simplicity and\n        \
    \   because of the minimal nature of the HB message, the response\n          \
    \ to an HB message is another HB message, i.e., no specific HB\n           Response\
    \ message is defined.  Whenever an FE receives an HB\n           message marked\
    \ with 'AlwaysACK' from the CE, the FE MUST send\n           an HB message back\
    \ immediately.  The HB message sent by the\n           FE in response to the 'AlwaysACK'\
    \ MUST modify the source and\n           destination IDs so that the ID of the\
    \ FE is the source ID and\n           the CE ID of the sender is the destination\
    \ ID, and MUST\n           change the ACK information to 'NoACK'.  A CE MUST NOT\
    \ respond\n           to an HB message with 'AlwaysACK' set.\n       *   When\
    \ set to anything else other than 'NoACK' or 'AlwaysACK',\n           the HB message\
    \ is treated as if it was a 'NoACK'.\n   The correlator field in the HB message\
    \ header SHOULD be set\n   accordingly when a response is expected so that a receiver\
    \ can\n   correlate the response correctly.  The correlator field MAY be\n   ignored\
    \ if no response is expected.\n   Message body:\n   The message body is empty\
    \ for the Heartbeat message.\n"
- title: 8.  High Availability Support
  contents:
  - "8.  High Availability Support\n   The ForCES protocol provides mechanisms for\
    \ CE redundancy and\n   failover, in order to support High Availability as defined\
    \ in\n   [RFC3654].  FE redundancy and FE to FE interaction is currently out\n\
    \   of scope of this document.  There can be multiple redundant CEs and\n   FEs\
    \ in a ForCES NE.  However, at any one time only one primary CE can\n   control\
    \ the FEs though there can be multiple secondary CEs.  The FE\n   and the CE PL\
    \ are aware of the primary and secondary CEs.  This\n   information (primary,\
    \ secondary CEs) is configured in the FE and in\n   the CE PLs during pre-association\
    \ by the FEM and the CEM\n   respectively.  Only the primary CE sends control\
    \ messages to the FEs.\n"
- title: 8.1.  Relation with the FE Protocol
  contents:
  - "8.1.  Relation with the FE Protocol\n   High Availability parameterization in\
    \ an FE is driven by configuring\n   the FE Protocol Object LFB (refer to Appendix\
    \ B and Section 7.3.1).\n   The FE Heartbeat Interval, CE Heartbeat Dead Interval,\
    \ and CE\n   Heartbeat policy help in detecting connectivity problems between\
    \ an\n   FE and CE.  The CE failover policy defines the reaction on a detected\n\
    \   failure.\n   Figure 44 extends the state machine illustrated in Figure 4 to\
    \ allow\n   for new states that facilitate connection recovery.\n       (CE issues\
    \ Teardown ||    +-----------------+\n          Lost association) &&   | Pre-association\
    \ |\n         CE failover policy = 0  | (Association    |\n             +------------>-->-->|\
    \   in            +<----+\n             |                   | progress)      \
    \ |     |\n             |     CE issues     +--------+--------+     |\n      \
    \       |     Association        |                  | CFTI\n             |   \
    \    Setup            V                  | timer\n             |     ___________________+\
    \                  | expires\n             |     |                           \
    \          |\n             |     V                                     ^\n   \
    \        +-+-----------+                          +-------+-----+\n          \
    \ |             |                          |  Not        |\n           |     \
    \        |  (CE issues Teardown ||  |  Associated |\n           |            \
    \ |    Lost association) &&  |             |\n           | Associated  |  CE failover\
    \ policy = 1  | (May        |\n           |             |                    \
    \      | Continue    |\n           |             |---------->------->------>|\
    \  Forwarding)|\n           |             |                          |       \
    \      |\n           +-------------+                          +-------------+\n\
    \                ^                                         V\n               \
    \ |                                         |\n                |            CE\
    \ issues                    |\n                |            Association      \
    \            |\n                |            Setup                        |\n\
    \                +_________________________________________+\n               \
    \ Figure 44: FE State Machine Considering HA\n   Section 4.2 describes transitions\
    \ between the pre-association,\n   associated, and not associated states.\n  \
    \ When communication fails between the FE and CE (which can be caused\n   by either\
    \ the CE or link failure but not FE related), either the TML\n   on the FE will\
    \ trigger the FE PL regarding this failure or it will be\n   detected using the\
    \ HB messages between FEs and CEs.  The\n   communication failure, regardless\
    \ of how it is detected, MUST be\n   considered as a loss of association between\
    \ the CE and corresponding\n   FE.\n   If the FE's FEPO CE failover policy is\
    \ configured to mode 0 (the\n   default), it will immediately transition to the\
    \ pre-association\n   phase.  This means that if association is again established,\
    \ all FE\n   state will need to be re-established.\n   If the FE's FEPO CE failover\
    \ policy is configured to mode 1, it\n   indicates that the FE is capable of HA\
    \ restart recovery.  In such a\n   case, the FE transitions to the not associated\
    \ state and the CEFTI\n   timer is started.  The FE MAY continue to forward packets\
    \ during this\n   state.  It MAY also recycle through any configured secondary\
    \ CEs in a\n   round-robin fashion.  It first adds its primary CE to the tail\
    \ of\n   backup CEs and sets its primary CE to be the first secondary.  It\n \
    \  then attempts to associate with the CE designated as the new primary\n   CE.\
    \  If it fails to re-associate with any CE and the CEFTI expires,\n   the FE then\
    \ transitions to the pre-association state.\n   If the FE, while in the not associated\
    \ state, manages to reconnect to\n   a new primary CE before CEFTI expires, it\
    \ transitions to the\n   associated state.  Once re-associated, the FE tries to\
    \ recover any\n   state that may have been lost during the not associated state.\
    \  How\n   the FE achieves this is out of scope for this document.\n   Figure\
    \ 45 below illustrates the ForCES message sequences that the FE\n   uses to recover\
    \ the connection.\n         FE                   CE Primary        CE Secondary\n\
    \         |                       |                    |\n         |  Asso Estb,Caps\
    \ exchg |                    |\n       1 |<--------------------->|           \
    \         |\n         |                       |                    |\n       \
    \  |       All msgs        |                    |\n       2 |<--------------------->|\
    \                    |\n         |                       |                   \
    \ |\n         |                       |                    |\n         |     \
    \              FAILURE                  |\n         |                        \
    \                    |\n         |         Asso Estb,Caps exchange           \
    \ |\n       3 |<------------------------------------------>|\n         |     \
    \                                       |\n         |              Event Report\
    \ (pri CE down)    |\n       4 |------------------------------------------->|\n\
    \         |                                            |\n         |         \
    \          All Msgs                 |\n       5 |<------------------------------------------>|\n\
    \              Figure 45: CE Failover for Report Primary Mode\n   A CE-to-CE synchronization\
    \ protocol would be needed to support fast\n   failover as well as to address\
    \ some of the corner cases; however,\n   this will not be defined by the ForCES\
    \ protocol as it is out of scope\n   for this specification.\n   An explicit message\
    \ (a Config message setting primary CE component in\n   the FE Protocol Object)\
    \ from the primary CE can also be used to\n   change the primary CE for an FE\
    \ during normal protocol operation.\n   Also note that the FEs in a ForCES NE\
    \ could also use a multicast CE\n   ID, i.e., they could be associated with a\
    \ group of CEs (this assumes\n   the use of a CE-CE synchronization protocol,\
    \ which is out of scope\n   for this specification).  In this case, the loss of\
    \ association would\n   mean that communication with the entire multicast group\
    \ of CEs has\n   been lost.  The mechanisms described above will apply for this\
    \ case\n   as well during the loss of association.  If, however, the secondary\n\
    \   CE was also using the multicast CE ID that was lost, then the FE will\n  \
    \ need to form a new association using a different CE ID.  If the\n   capability\
    \ exists, the FE MAY first attempt to form a new association\n   with the original\
    \ primary CE using a different non-multicast CE ID.\n"
- title: 8.2.  Responsibilities for HA
  contents:
  - "8.2.  Responsibilities for HA\n   TML level:\n   1.  The TML controls logical\
    \ connection availability and failover.\n   2.  The TML also controls peer HA\
    \ management.\n   At this level, control of all lower layers, for example, transport\n\
    \   level (such as IP addresses, MAC addresses, etc.) and associated\n   links\
    \ going down are the role of the TML.\n   PL level:\n   All other functionality,\
    \ including configuring the HA behavior during\n   setup, the CE IDs used to identify\
    \ primary and secondary CEs,\n   protocol messages used to report CE failure (Event\
    \ Report), Heartbeat\n   messages used to detect association failure, messages\
    \ to change the\n   primary CE (Config), and other HA-related operations described\n\
    \   before, are the PL responsibility.\n   To put the two together, if a path\
    \ to a primary CE is down, the TML\n   would take care of failing over to a backup\
    \ path, if one is\n   available.  If the CE is totally unreachable, then the PL\
    \ would be\n   informed and it would take the appropriate actions described earlier.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   The ForCES framework document [RFC3746], Section\
    \ 8, goes into\n   extensive detail on a variety of security threats, the possible\n\
    \   effects of those threats on the protocol, and responses to those\n   threats.\
    \  This document does not repeat that discussion; the reader\n   is referred to\
    \ the ForCES framework document [RFC3746] for those\n   details and how the ForCES\
    \ architecture addresses them.\n   ForCES PL uses security services provided by\
    \ the ForCES TML.  The TML\n   provides security services such as endpoint authentication\
    \ service,\n   message authentication service, and confidentiality service.\n\
    \   Endpoint authentication service is invoked at the time of the pre-\n   association\
    \ connection establishment phase and message authentication\n   is performed whenever\
    \ the FE or CE receives a packet from its peer.\n   The following are the general\
    \ security mechanisms that need to be in\n   place for ForCES PL.\n   o  Security\
    \ mechanisms are session controlled -- that is, once the\n      security is turned\
    \ on depending upon the chosen security level (No\n      Security, Authentication,\
    \ Confidentiality), it will be in effect\n      for the entire duration of the\
    \ session.\n   o  An operator should configure the same security policies for\
    \ both\n      primary and backup FEs and CEs (if available).  This will ensure\n\
    \      uniform operations and avoid unnecessary complexity in policy\n      configuration.\n"
- title: 9.1.  No Security
  contents:
  - "9.1.  No Security\n   When \"No Security\" is chosen for ForCES protocol communication,\
    \ both\n   endpoint authentication and message authentication service needs to\n\
    \   be performed by ForCES PL.  Both these mechanism are weak and do not\n   involve\
    \ cryptographic operation.  An operator can choose \"No\n   Security\" level when\
    \ the ForCES protocol endpoints are within a\n   single box, for example.\n  \
    \ In order to have interoperable and uniform implementation across\n   various\
    \ security levels, each CE and FE endpoint MUST implement this\n   level.\n  \
    \ What is described below (in Section 9.1.1 and Section 9.1.2) are\n   error checks\
    \ and not security procedures.  The reader is referred to\n   Section 9.2 for\
    \ security procedures.\n"
- title: 9.1.1.  Endpoint Authentication
  contents:
  - "9.1.1.  Endpoint Authentication\n   Each CE and FE PL maintains a list of associations\
    \ as part of its\n   configuration.  This is done via the CEM and FEM interfaces.\
    \  An FE\n   MUST connect to only those CEs that are configured via the FEM;\n\
    \   similarly, a CE should accept the connection and establish\n   associations\
    \ for the FEs which are configured via the CEM.  The CE\n   should validate the\
    \ FE identifier before accepting the connections\n   during the pre-association\
    \ phase.\n"
- title: 9.1.2.  Message Authentication
  contents:
  - "9.1.2.  Message Authentication\n   When a CE or FE initiates a message, the receiving\
    \ endpoint MUST\n   validate the initiator of the message by checking the common\
    \ header\n   CE or FE identifiers.  This will ensure proper protocol functioning.\n\
    \   This extra processing step is recommended even when the underlying\n   TML\
    \ layer security services exist.\n"
- title: 9.2.  ForCES PL and TML Security Service
  contents:
  - "9.2.  ForCES PL and TML Security Service\n   This section is applicable if an\
    \ operator wishes to use the TML\n   security services.  A ForCES TML MUST support\
    \ one or more security\n   services such as endpoint authentication service, message\n\
    \   authentication service, and confidentiality service, as part of TML\n   security\
    \ layer functions.  It is the responsibility of the operator\n   to select an\
    \ appropriate security service and configure security\n   policies accordingly.\
    \  The details of such configuration are outside\n   the scope of the ForCES PL\
    \ and are dependent on the type of transport\n   protocol and the nature of the\
    \ connection.\n   All these configurations should be done prior to starting the\
    \ CE and\n   FE.\n   When certificates-based authentication is being used at the\
    \ TML, the\n   certificate can use a ForCES-specific naming structure as certificate\n\
    \   names and, accordingly, the security policies can be configured at\n   the\
    \ CE and FE.\n   The reader is asked to refer to specific TML documents for details\
    \ on\n   the security requirements specific to that TML.\n"
- title: 9.2.1.  Endpoint Authentication Service
  contents:
  - "9.2.1.  Endpoint Authentication Service\n   When TML security services are enabled,\
    \ the ForCES TML performs\n   endpoint authentication.  Security association is\
    \ established between\n   CE and FE and is transparent to the ForCES PL.\n"
- title: 9.2.2.  Message Authentication Service
  contents:
  - "9.2.2.  Message Authentication Service\n   This is a TML-specific operation and\
    \ is transparent to the ForCES PL.\n   For details, refer to Section 5.\n"
- title: 9.2.3.  Confidentiality Service
  contents:
  - "9.2.3.  Confidentiality Service\n   This is a TML-specific operation and is transparent\
    \ to the ForCES PL.\n   For details, refer to Section 5.\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   The authors of this document would like to acknowledge\
    \ and thank the\n   ForCES Working Group and especially the following: Furquan\
    \ Ansari,\n   Alex Audu, Steven Blake, Shuchi Chawla, Alan DeKok, Ellen M.\n \
    \  Deleganes, Xiaoyi Guo, Yunfei Guo, Evangelos Haleplidis, Zsolt\n   Haraszti,\
    \ Fenggen Jia, John C. Lin, Alistair Munro, Jeff Pickering,\n   T. Sridhlar, Guangming\
    \ Wang, Chaoping Wu, and Lily L. Yang, for their\n   contributions.  We would\
    \ also like to thank David Putzolu and Patrick\n   Droz for their comments and\
    \ suggestions on the protocol and for their\n   infinite patience.  We would also\
    \ like to thank Sue Hares and Alia\n   Atlas for extensive reviews of the document.\n\
    \   Alia Atlas did a wonderful job of shaping the document to make it\n   more\
    \ readable by providing the IESG feedback.\n   Ross Callon was instrumental in\
    \ getting us over major humps to\n   getting this document published.\n   The\
    \ editors have used the xml2rfc [RFC2629] tools in creating this\n   document\
    \ and are very grateful for the existence and quality of these\n   tools.  The\
    \ editor is also grateful to Elwyn Davies for his help in\n   correcting the XML\
    \ source of this document.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC2914]  Floyd, S., \"Congestion Control Principles\", BCP 41,\n\
    \              RFC 2914, September 2000.\n   [RFC5226]  Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing an\n              IANA Considerations Section in RFCs\"\
    , BCP 26, RFC 5226,\n              May 2008.\n   [RFC5390]  Rosenberg, J., \"\
    Requirements for Management of Overload in\n              the Session Initiation\
    \ Protocol\", RFC 5390, December 2008.\n   [RFC5811]  Hadi Salim, J. and K. Ogawa,\
    \ \"SCTP-Based Transport Mapping\n              Layer (TML) for the Forwarding\
    \ and Control Element\n              Separation (ForCES) Protocol\", RFC 5811,\
    \ March 2010.\n   [RFC5812]  Halpern, J. and J. Hadi Salim, \"Forwarding and Control\n\
    \              Element Separation (ForCES) Forwarding Element Model\",\n     \
    \         RFC 5812, March 2010.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [2PCREF]   Gray, J., \"Notes on database operating\
    \ systems\", in\n              \"Operating Systems: An Advanced Course\" Lecture\
    \ Notes in\n              Computer Science, Vol. 60, pp. 394-481, Springer-Verlag,\n\
    \              1978.\n   [ACID]     Haerder, T. and A. Reuter, \"Principles of\
    \ Transaction-\n              Orientated Database Recovery\", 1983.\n   [RFC2629]\
    \  Rose, M., \"Writing I-Ds and RFCs using XML\", RFC 2629,\n              June\
    \ 1999.\n   [RFC3654]  Khosravi, H. and T. Anderson, \"Requirements for Separation\n\
    \              of IP Control and Forwarding\", RFC 3654, November 2003.\n   [RFC3746]\
    \  Yang, L., Dantu, R., Anderson, T., and R. Gopal,\n              \"Forwarding\
    \ and Control Element Separation (ForCES)\n              Framework\", RFC 3746,\
    \ April 2004.\n"
- title: Appendix A.  IANA Considerations
  contents:
  - "Appendix A.  IANA Considerations\n   Following the policies outlined in \"Guidelines\
    \ for Writing an IANA\n   Considerations Section in RFCs\" (RFC 5226 [RFC5226]),\
    \ the following\n   namespaces are defined in ForCES.\n   o  Message Type Namespace,\
    \ Section 7\n   o  Operation Type Namespace, Section 7.1.6\n   o  Header Flags,\
    \ Section 6.1\n   o  TLV Type, Section 7\n   o  TLV Result Values, Section 7.1.7\n\
    \   o  LFB Class ID, Section 7.1.5 (resolved by model document,\n      [RFC5812].\n\
    \   o  Result: Association Setup Response, Section 7.5.2\n   o  Reason: Association\
    \ Teardown Message, Section 7.5.3\n"
- title: A.1.  Message Type Namespace
  contents:
  - "A.1.  Message Type Namespace\n   The Message Type is an 8-bit value.  The following\
    \ is the guideline\n   for defining the Message Type namespace:\n   Message Types\
    \ 0x00 - 0x1F\n      Message Types in this range are part of the base ForCES protocol.\n\
    \      Message Types in this range are allocated through an IETF\n      consensus\
    \ action [RFC5226].\n      Values assigned by this specification:\n       0x00\
    \               Reserved\n       0x01               AssociationSetup\n       0x02\
    \               AssociationTeardown\n       0x03               Config\n      \
    \ 0x04               Query\n       0x05               EventNotification\n    \
    \   0x06               PacketRedirect\n       0x07 - 0x0E        Reserved\n  \
    \     0x0F               Hearbeat\n       0x11               AssociationSetupResponse\n\
    \       0x12               Reserved\n       0x13               ConfigResponse\n\
    \       0x14               QueryResponse\n   Message Types 0x20 - 0x7F\n     \
    \ Message Types in this range are Specification Required [RFC5226].\n      Message\
    \ Types using this range MUST be documented in an RFC or\n      other permanent\
    \ and readily available reference.\n   Message Types 0x80 - 0xFF\n      Message\
    \ Types in this range are reserved for vendor private\n      extensions and are\
    \ the responsibility of individual vendors.  IANA\n      management of this range\
    \ of the Message Type namespace is\n      unnecessary.\n"
- title: A.2.  Operation Selection
  contents:
  - "A.2.  Operation Selection\n   The Operation Selection (OPER-TLV) namespace is\
    \ 16 bits long.  The\n   following is the guideline for managing the OPER-TLV\
    \ namespace.\n   OPER-TLV Type 0x0000-0x0FF\n      OPER-TLV Types in this range\
    \ are allocated through an IETF\n      consensus process [RFC5226].\n      Values\
    \ assigned by this specification:\n                 0x0000           Reserved\n\
    \                 0x0001           SET\n                 0x0002           SET-PROP\n\
    \                 0x0003           SET-RESPONSE\n                 0x0004     \
    \      SET-PROP-RESPONSE\n                 0x0005           DEL\n            \
    \     0x0006           DEL-RESPONSE\n                 0x0007           GET\n \
    \                0x0008           GET-PROP\n                 0x0009          \
    \ GET-RESPONSE\n                 0x000A           GET-PROP-RESPONSE\n        \
    \         0x000B           REPORT\n                 0x000C           COMMIT\n\
    \                 0x000D           COMMIT-RESPONSE\n                 0x000E  \
    \         TRCOMP\n   OPER-TLV Type 0x0100-0x7FFF\n      OPER-TLV Types using this\
    \ range MUST be documented in an RFC or\n      other permanent and readily available\
    \ reference [RFC5226].\n   OPER-TLV Type 0x8000-0xFFFF\n      OPER-TLV Types in\
    \ this range are reserved for vendor private\n      extensions and are the responsibility\
    \ of individual vendors.  IANA\n      management of this range of the OPER-TLV\
    \ Type namespace is\n      unnecessary.\n"
- title: A.3.  Header Flags
  contents:
  - "A.3.  Header Flags\n      The Header flag field is 32 bits long.  Header flags\
    \ are part of\n      the ForCES base protocol.  Header flags are allocated through\
    \ an\n      IETF consensus action [RFC5226].\n"
- title: A.4.  TLV Type Namespace
  contents:
  - "A.4.  TLV Type Namespace\n   The TLV Type namespace is 16 bits long.  The following\
    \ is the\n   guideline for managing the TLV Type namespace.\n   TLV Type 0x0000-0x01FF\n\
    \      TLV Types in this range are allocated through an IETF consensus\n     \
    \ process [RFC5226].\n      Values assigned by this specification:\n         \
    \        0x0000           Reserved\n                 0x0001           REDIRECT-TLV\n\
    \                 0x0010           ASResult-TLV\n                 0x0011     \
    \      ASTreason-TLV\n                 0x1000           LFBselect-TLV\n      \
    \           0x0110           PATH-DATA-TLV\n                 0x0111          \
    \ KEYINFO-TLV\n                 0x0112           FULLDATA-TLV\n              \
    \   0x0113           SPARSEDATA-TLV\n                 0x0114           RESULT-TLV\n\
    \                 0x0115           METADATA-TLV\n                 0x0116     \
    \      REDIRECTDATA-TLV\n   TLV Type 0x0200-0x7FFF\n      TLV Types using this\
    \ range MUST be documented in an RFC or other\n      permanent and readily available\
    \ reference [RFC5226].\n   TLV Type 0x8000-0xFFFF\n      TLV Types in this range\
    \ are reserved for vendor private extensions\n      and are the responsibility\
    \ of individual vendors.  IANA management\n      of this range of the TLV Type\
    \ namespace is unnecessary.\n"
- title: A.5.  RESULT-TLV Result Values
  contents:
  - "A.5.  RESULT-TLV Result Values\n   The RESULT-TLV RTesult Value is an 8-bit value.\n\
    \                0x00        E_SUCCESS\n                0x01        E_INVALID_HEADER\n\
    \                0x02        E_LENGTH_MISMATCH\n                0x03        E_VERSION_MISMATCH\n\
    \                0x04        E_INVALID_DESTINATION_PID\n                0x05 \
    \       E_LFB_UNKNOWN\n                0x06        E_LFB_NOT_FOUND\n         \
    \       0x07        E_LFB_INSTANCE_ID_NOT_FOUND\n                0x08        E_INVALID_PATH\n\
    \                0x09        E_COMPONENT_DOES_NOT_EXIST\n                0x0A\
    \        E_EXISTS\n                0x0B        E_NOT_FOUND\n                0x0C\
    \        E_READ_ONLY\n                0x0D        E_INVALID_ARRAY_CREATION\n \
    \               0x0E        E_VALUE_OUT_OF_RANGE\n                0x0F       \
    \ E_CONTENTS_TOO_LONG\n                0x10        E_INVALID_PARAMETERS\n    \
    \            0x11        E_INVALID_MESSAGE_TYPE\n                0x12        E_E_INVALID_FLAGS\n\
    \                0x13        E_INVALID_TLV\n                0x14        E_EVENT_ERROR\n\
    \                0x15        E_NOT_SUPPORTED\n                0x16        E_MEMORY_ERROR\n\
    \                0x17        E_INTERNAL_ERROR\n                0x18-0xFE   Reserved\n\
    \                0xFF        E_UNSPECIFIED_ERROR\n   All values not assigned in\
    \ this specification are designated as\n   Assignment by Expert Review.\n"
- title: A.6.  Association Setup Response
  contents:
  - "A.6.  Association Setup Response\n   The Association Setup Response namespace\
    \ is 32 bits long.  The\n   following is the guideline for managing the Association\
    \ Setup\n   Response namespace.\n   Association Setup Response 0x0000-0x00FF\n\
    \      Association Setup Responses in this range are allocated through an\n  \
    \    IETF consensus process [RFC5226].\n      Values assigned by this specification:\n\
    \          0x0000   Success\n          0x0001   FE ID Invalid\n          0x0002\
    \   Permission Denied\n   Association Setup Response 0x0100-0x0FFF\n      Association\
    \ Setup Responses in this range are Specification\n      Required [RFC5226]. \
    \ Values using this range MUST be documented in\n      an RFC or other permanent\
    \ and readily available reference\n      [RFC5226].\n   Association Setup Response\
    \ 0x1000-0xFFFF\n      Association Setup Responses in this range are reserved\
    \ for vendor\n      private extensions and are the responsibility of individual\n\
    \      vendors.  IANA management of this range of the Association Setup\n    \
    \  Response namespace is unnecessary.\n"
- title: A.7.  Association Teardown Message
  contents:
  - "A.7.  Association Teardown Message\n   The Association Teardown Message namespace\
    \ is 32 bits long.  The\n   following is the guideline for managing the Association\
    \ Teardown\n   Message namespace.\n   Association Teardown Message 0x00000000-0x0000FFFF\n\
    \      Association Teardown Messages in this range are allocated through\n   \
    \   an IETF consensus process [RFC5226].\n      Values assigned by this specification:\n\
    \           0x00000000        Normal - teardown by administrator\n           0x00000001\
    \        Error  - loss of heartbeats\n           0x00000002        Error  - loss\
    \ of bandwidth\n           0x00000003        Error  - out of Memory\n        \
    \   0x00000004        Error  - application crash\n           0x000000FF      \
    \  Error  - unspecified\n   Association Teardown Message 0x00010000-0x7FFFFFFF\n\
    \      Association Teardown Messages in this range are Specification\n      Required\
    \ [RFC5226].  Association Teardown Messages using this\n      range MUST be documented\
    \ in an RFC or other permanent and readily\n      available references.  [RFC5226].\n\
    \   Association Teardown Message 0x80000000-0xFFFFFFFFF\n      Association Teardown\
    \ Messages in this range are reserved for\n      vendor private extensions and\
    \ are the responsibility of individual\n      vendors.  IANA management of this\
    \ range of the Association\n      Teardown Message namespace is unnecessary.\n"
- title: Appendix B.  ForCES Protocol LFB Schema
  contents:
  - "Appendix B.  ForCES Protocol LFB Schema\n   The schema described below conforms\
    \ to the LFB schema described in\n   the ForCES model [RFC5812].\n   Section 7.3.1\
    \ describes the details of the different components\n   defined in this definition.\n\
    \   <LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\"\n     xmlns:xsi=\"\
    http://www.w3.org/2001/XMLSchema-instance\"\n       provides=\"FEPO\">\n   <!--\
    \ XXX  -->\n     <dataTypeDefs>\n        <dataTypeDef>\n           <name>CEHBPolicyValues</name>\n\
    \                  <synopsis>\n                      The possible values of CE\
    \ heartbeat policy\n                  </synopsis>\n              <atomic>\n  \
    \            <baseType>uchar</baseType>\n              <specialValues>\n     \
    \            <specialValue value=\"0\">\n                   <name>CEHBPolicy0</name>\n\
    \                   <synopsis>\n                        The CE heartbeat policy\
    \ 0\n                   </synopsis>\n                   </specialValue>\n    \
    \             <specialValue value=\"1\">\n                    <name>CEHBPolicy1</name>\n\
    \                    <synopsis>\n                         The CE heartbeat policy\
    \ 1\n                    </synopsis>\n                 </specialValue>\n     \
    \          </specialValues>\n               </atomic>\n         </dataTypeDef>\n\
    \         <dataTypeDef>\n            <name>FEHBPolicyValues</name>\n         \
    \        <synopsis>\n                     The possible values of FE heartbeat\
    \ policy\n                </synopsis>\n              <atomic>\n              <baseType>uchar</baseType>\n\
    \              <specialValues>\n                <specialValue value=\"0\">\n \
    \                 <name>FEHBPolicy0</name>\n                  <synopsis>\n   \
    \                    The FE heartbeat policy 0\n                  </synopsis>\n\
    \                </specialValue>\n                <specialValue value=\"1\">\n\
    \                   <name>FEHBPolicy1</name>\n                   <synopsis>\n\
    \                        The FE heartbeat policy 1\n                   </synopsis>\n\
    \                  </specialValue>\n               </specialValues>\n        \
    \       </atomic>\n         </dataTypeDef>\n         <dataTypeDef>\n         <name>FERestartPolicyValues</name>\n\
    \               <synopsis>\n                   The possible values of FE restart\
    \ policy\n               </synopsis>\n              <atomic>\n              <baseType>uchar</baseType>\n\
    \              <specialValues>\n                 <specialValue value=\"0\">\n\
    \                   <name>FERestartPolicy0</name>\n                   <synopsis>\n\
    \                        The FE restart policy 0\n                   </synopsis>\n\
    \                   </specialValue>\n               </specialValues>\n       \
    \        </atomic>\n         </dataTypeDef>\n         <dataTypeDef>\n        \
    \ <name>CEFailoverPolicyValues</name>\n               <synopsis>\n           \
    \        The possible values of CE failover policy\n               </synopsis>\n\
    \              <atomic>\n              <baseType>uchar</baseType>\n          \
    \    <specialValues>\n                <specialValue value=\"0\">\n           \
    \        <name>CEFailoverPolicy0</name>\n                   <synopsis>\n     \
    \                   The CE failover policy 0\n                   </synopsis>\n\
    \                 </specialValue>\n               <specialValue value=\"1\">\n\
    \                  <name>CEFailoverPolicy1</name>\n                  <synopsis>\n\
    \                       The CE failover policy 1\n                  </synopsis>\n\
    \                </specialValue>\n               </specialValues>\n          \
    \     </atomic>\n         </dataTypeDef>\n        <dataTypeDef>\n           <name>FEHACapab</name>\n\
    \                  <synopsis>\n                      The supported HA features\n\
    \                  </synopsis>\n              <atomic>\n              <baseType>uchar</baseType>\n\
    \              <specialValues>\n                 <specialValue value=\"0\">\n\
    \                   <name>GracefullRestart</name>\n                   <synopsis>\n\
    \                        The FE supports Graceful Restart\n                  \
    \ </synopsis>\n                   </specialValue>\n                 <specialValue\
    \ value=\"1\">\n                    <name>HA</name>\n                    <synopsis>\n\
    \                         The FE supports HA\n                    </synopsis>\n\
    \                 </specialValue>\n               </specialValues>\n         \
    \      </atomic>\n         </dataTypeDef>\n     </dataTypeDefs>\n     <LFBClassDefs>\n\
    \       <LFBClassDef LFBClassID=\"2\">\n         <name>FEPO</name>\n         <synopsis>\n\
    \            The FE Protocol Object\n         </synopsis>\n         <version>1.0</version>\n\
    \     <components>\n           <component componentID=\"1\" access=\"read-only\"\
    >\n               <name>CurrentRunningVersion</name>\n               <synopsis>Currently\
    \ running ForCES version</synopsis>\n               <typeRef>uchar</typeRef>\n\
    \             </component>\n           <component componentID=\"2\" access=\"\
    read-only\">\n             <name>FEID</name>\n             <synopsis>Unicast FEID</synopsis>\n\
    \             <typeRef>uint32</typeRef>\n           </component>\n           <component\
    \ componentID=\"3\" access=\"read-write\">\n              <name>MulticastFEIDs</name>\n\
    \              <synopsis>\n                 the table of all multicast IDs\n \
    \             </synopsis>\n              <array type=\"variable-size\">\n    \
    \           <typeRef>uint32</typeRef>\n              </array>\n           </component>\n\
    \           <component componentID=\"4\" access=\"read-write\">\n            \
    \ <name>CEHBPolicy</name>\n             <synopsis>\n              The CE Heartbeat\
    \ Policy\n             </synopsis>\n             <typeRef>CEHBPolicyValues</typeRef>\n\
    \           </component>\n           <component componentID=\"5\" access=\"read-write\"\
    >\n             <name>CEHDI</name>\n             <synopsis>\n               The\
    \ CE Heartbeat Dead Interval in millisecs\n             </synopsis>\n        \
    \     <typeRef>uint32</typeRef>\n           </component>\n           <component\
    \ componentID=\"6\" access=\"read-write\">\n             <name>FEHBPolicy</name>\n\
    \             <synopsis>\n               The FE Heartbeat Policy\n           \
    \  </synopsis>\n             <typeRef>FEHBPolicyValues</typeRef>\n           </component>\n\
    \           <component componentID=\"7\" access=\"read-write\">\n            \
    \ <name>FEHI</name>\n             <synopsis>\n               The FE Heartbeat\
    \ Interval in millisecs\n             </synopsis>\n             <typeRef>uint32</typeRef>\n\
    \           </component>\n           <component componentID=\"8\" access=\"read-write\"\
    >\n             <name>CEID</name>\n             <synopsis>\n                The\
    \ Primary CE this FE is associated with\n             </synopsis>\n          \
    \   <typeRef>uint32</typeRef>\n           </component>\n           <component\
    \ componentID=\"9\" access=\"read-write\">\n              <name>BackupCEs</name>\n\
    \              <synopsis>\n                 The table of all backup CEs other\
    \ than the primary\n              </synopsis>\n              <array type=\"variable-size\"\
    >\n               <typeRef>uint32</typeRef>\n              </array>\n        \
    \   </component>\n           <component componentID=\"10\" access=\"read-write\"\
    >\n             <name>CEFailoverPolicy</name>\n             <synopsis>\n     \
    \          The CE Failover Policy\n             </synopsis>\n             <typeRef>CEFailoverPolicyValues</typeRef>\n\
    \           </component>\n           <component componentID=\"11\" access=\"read-write\"\
    >\n             <name>CEFTI</name>\n             <synopsis>\n               The\
    \ CE Failover Timeout Interval in millisecs\n             </synopsis>\n      \
    \       <typeRef>uint32</typeRef>\n           </component>\n           <component\
    \ componentID=\"12\" access=\"read-write\">\n             <name>FERestartPolicy</name>\n\
    \             <synopsis>\n                The FE Restart Policy\n            \
    \ </synopsis>\n             <typeRef>FERestartPolicyValues</typeRef>\n       \
    \    </component>\n           <component componentID=\"13\" access=\"read-write\"\
    >\n             <name>LastCEID</name>\n             <synopsis>\n             \
    \   The Primary CE this FE was last associated with\n             </synopsis>\n\
    \             <typeRef>uint32</typeRef>\n           </component>\n         </components>\n\
    \        <capabilities>\n             <capability componentID=\"30\">\n      \
    \          <name>SupportableVersions</name>\n                <synopsis>\n    \
    \               the table of ForCES versions that FE supports\n              \
    \  </synopsis>\n                <array type=\"variable-size\">\n             \
    \    <typeRef>uchar</typeRef>\n                </array>\n              </capability>\n\
    \           <capability componentID=\"31\">\n              <name>HACapabilities</name>\n\
    \              <synopsis>\n                 the table of HA capabilities the FE\
    \ supports\n              </synopsis>\n              <array type=\"variable-size\"\
    >\n               <typeRef>FEHACapab</typeRef>\n              </array>\n     \
    \      </capability>\n         </capabilities>\n         <events baseID=\"61\"\
    >\n           <event eventID=\"1\">\n             <name>PrimaryCEDown</name>\n\
    \             <synopsis>\n                 The pimary CE has changed\n       \
    \      </synopsis>\n             <eventTarget>\n                 <eventField>LastCEID</eventField>\n\
    \             </eventTarget>\n             <eventChanged/>\n             <eventReports>\n\
    \                <eventReport>\n                  <eventField>LastCEID</eventField>\n\
    \                </eventReport>\n             </eventReports>\n           </event>\n\
    \         </events>\n       </LFBClassDef>\n     </LFBClassDefs>\n   </LFBLibrary>\n"
- title: B.1.  Capabilities
  contents:
  - "B.1.  Capabilities\n   Supportable Versions enumerates all ForCES versions that\
    \ an FE\n   supports.\n   FEHACapab enumerates the HA capabilities of the FE.\
    \  If the FE is not\n   capable of graceful restarts or HA, then it will not be\
    \ able to\n   participate in HA as described in Section 8.1.\n"
- title: B.2.  Components
  contents:
  - "B.2.  Components\n   All components are explained in Section 7.3.1.\n"
- title: Appendix C.  Data Encoding Examples
  contents:
  - "Appendix C.  Data Encoding Examples\n   In this section a few examples of data\
    \ encoding are discussed.  These\n   example, however, do not show any padding.\n\
    \   ==========\n   Example 1:\n   ==========\n   Structure with three fixed-lengthof,\
    \ mandatory fields.\n           struct S {\n           uint16 a\n           uint16\
    \ b\n           uint16 c\n           }\n   (a) Describing all fields using SPARSEDATA-TLV\n\
    \           PATH-DATA-TLV\n             Path to an instance of S ...\n       \
    \      SPARSEDATA-TLV\n               ComponentIDof(a), lengthof(a), valueof(a)\n\
    \               ComponentIDof(b), lengthof(b), valueof(b)\n               ComponentIDof(c),\
    \ lengthof(c), valueof(c)\n   (b) Describing a subset of fields\n           PATH-DATA-TLV\n\
    \             Path to an instance of S ...\n             SPARSEDATA-TLV\n    \
    \           ComponentIDof(a), lengthof(a), valueof(a)\n               ComponentIDof(c),\
    \ lengthof(c), valueof(c)\n   Note: Even though there are non-optional components\
    \ in structure S,\n   since one can uniquely identify components, one can selectively\
    \ send\n   components of structure S (e.g., in the case of an update from CE to\n\
    \   FE).\n   (c) Describing all fields using a FULLDATA-TLV\n           PATH-DATA-TLV\n\
    \             Path to an instance of S ...\n             FULLDATA-TLV\n      \
    \         valueof(a)\n               valueof(b)\n               valueof(c)\n \
    \  ==========\n   Example 2:\n   ==========\n   Structure with three fixed-lengthof\
    \ fields, one mandatory, two\n   optional.\n           struct T {\n          \
    \ uint16 a\n           uint16 b (optional)\n           uint16 c (optional)\n \
    \          }\n   This example is identical to example 1, as illustrated below.\n\
    \   (a) Describing all fields using SPARSEDATA-TLV\n           PATH-DATA-TLV\n\
    \             Path to an instance of S ...\n             SPARSEDATA-TLV\n    \
    \           ComponentIDof(a), lengthof(a), valueof(a)\n               ComponentIDof(b),\
    \ lengthof(b), valueof(b)\n               ComponentIDof(c), lengthof(c), valueof(c)\n\
    \   (b) Describing a subset of fields using SPARSEDATA-TLV\n           PATH-DATA-TLV\n\
    \             Path to an instance of S ...\n             SPARSEDATA-TLV\n    \
    \           ComponentIDof(a), lengthof(a), valueof(a)\n               ComponentIDof(c),\
    \ lengthof(c), valueof(c)\n   (c) Describing all fields using a FULLDATA-TLV\n\
    \           PATH-DATA-TLV\n             Path to an instance of S ...\n       \
    \      FULLDATA-TLV\n               valueof(a)\n               valueof(b)\n  \
    \             valueof(c)\n   Note: FULLDATA-TLV _cannot_ be used unless all fields\
    \ are being\n   described.\n   ==========\n   Example 3:\n   ==========\n   Structure\
    \ with a mix of fixed-lengthof and variable-lengthof fields,\n   some mandatory,\
    \ some optional.  Note in this case, b is variable\n   sized.\n           struct\
    \ U {\n           uint16 a\n           string b (optional)\n           uint16\
    \ c (optional)\n           }\n   (a) Describing all fields using SPARSEDATA-TLV\n\
    \           Path to an instance of U ...\n           SPARSEDATA-TLV\n        \
    \     ComponentIDof(a), lengthof(a), valueof(a)\n             ComponentIDof(b),\
    \ lengthof(b), valueof(b)\n             ComponentIDof(c), lengthof(c), valueof(c)\n\
    \   (b) Describing a subset of fields using SPARSEDATA-TLV\n           Path to\
    \ an instance of U ...\n           SPARSEDATA-TLV\n             ComponentIDof(a),\
    \ lengthof(a), valueof(a)\n             ComponentIDof(c), lengthof(c), valueof(c)\n\
    \   (c) Describing all fields using FULLDATA-TLV\n           Path to an instance\
    \ of U ...\n             FULLDATA-TLV\n               valueof(a)\n           \
    \    FULLDATA-TLV\n                 valueof(b)\n               valueof(c)\n  \
    \ Note: The variable-length field requires the addition of a FULLDATA-\n   TLV\
    \ within the outer FULLDATA-TLV as in the case of component b\n   above.\n   ==========\n\
    \   Example 4:\n   ==========\n   Structure containing an array of another structure\
    \ type.\n           struct V {\n           uint32 x\n           uint32 y\n   \
    \        struct U z[]\n           }\n   (a) Encoding using SPARSEDATA-TLV, with\
    \ two instances of z[], also\n   described with SPARSEDATA-TLV, assuming only\
    \ the 10th and 15th\n   subscripts of z[] are encoded.\n        path to instance\
    \ of V ...\n        SPARSEDATA-TLV\n         ComponentIDof(x), lengthof(x), valueof(x)\n\
    \         ComponentIDof(y), lengthof(y), valueof(y)\n         ComponentIDof(z),\
    \ lengthof(all below)\n           ComponentID = 10 (i.e index 10 from z[]), lengthof(all\
    \ below)\n               ComponentIDof(a), lengthof(a), valueof(a)\n         \
    \      ComponentIDof(b), lengthof(b), valueof(b)\n           ComponentID = 15\
    \ (index 15 from z[]), lengthof(all below)\n               ComponentIDof(a), lengthof(a),\
    \ valueof(a)\n               ComponentIDof(c), lengthof(c), valueof(c)\n   Note\
    \ the holes in the components of z (10 followed by 15).  Also note\n   the gap\
    \ in index 15 with only components a and c appearing but not b.\n"
- title: Appendix D.  Use Cases
  contents:
  - "Appendix D.  Use Cases\n   Assume LFB with the following components for the following\
    \ use cases.\n   foo1, type u32, ID = 1\n   foo2, type u32, ID = 2\n   table1:\
    \ type array, ID = 3\n           components are:\n           t1, type u32, ID\
    \ = 1\n           t2, type u32, ID = 2  // index into table2\n           KEY:\
    \ nhkey, ID = 1, V = t2\n   table2: type array, ID = 4\n           components\
    \ are:\n           j1, type u32, ID = 1\n           j2, type u32, ID = 2\n   \
    \        KEY: akey, ID = 1, V = { j1,j2 }\n   table3: type array, ID = 5\n   \
    \        components are:\n           someid, type u32, ID = 1\n           name,\
    \ type string variable sized, ID = 2\n   table4: type array, ID = 6\n        \
    \   components are:\n           j1, type u32, ID = 1\n           j2, type u32,\
    \ ID = 2\n           j3, type u32, ID = 3\n           j4, type u32, ID = 4\n \
    \          KEY: mykey, ID = 1, V = { j1}\n   table5: type array, ID = 7\n    \
    \       components are:\n           p1, type u32, ID = 1\n           p2, type\
    \ array, ID = 2, array components of type-X\n   Type-X:\n           x1, ID 1,\
    \ type u32\n           x2, ID2 , type u32\n                   KEY: tkey, ID =\
    \ 1, V = { x1}\n   All examples will use valueof(x) to indicate the value of the\n\
    \   referenced component x.  In the case where F_SEL** are missing (bits\n   equal\
    \ to 00) then the flags will not show any selection.\n   All the examples only\
    \ show use of FULLDATA-TLV for data encoding;\n   although SPARSEDATA-TLV would\
    \ make more sense in certain occasions,\n   the emphasis is on showing the message\
    \ layout.  Refer to Appendix C\n   for examples that show usage of both FULLDATA-TLV\
    \ and SPARSEDATA-TLV.\n   1.   To get foo1\n   OPER = GET-TLV\n           PATH-DATA-TLV:\
    \ IDCount = 1, IDs = 1\n   Result:\n   OPER = GET-RESPONSE-TLV\n           PATH-DATA-TLV:\n\
    \                   flags=0, IDCount = 1, IDs = 1\n                   FULLDATA-TLV\
    \ L = 4+4, V =  valueof(foo1)\n   2.   To set foo2 to 10\n   OPER = SET-TLV\n\
    \           PATH-DATA-TLV:\n                   flags = 0,  IDCount = 1, IDs =\
    \ 2\n                   FULLDATA-TLV: L = 4+4, V=10\n   Result:\n   OPER = SET-RESPONSE-TLV\n\
    \           PATH-DATA-TLV:\n                   flags = 0,  IDCount = 1, IDs =\
    \ 2\n                   RESULT-TLV\n   3.   To dump table2\n      OPER = GET-TLV\n\
    \           PATH-DATA-TLV:\n                   IDCount = 1, IDs = 4\n      Result:\n\
    \      OPER = GET-RESPONSE-TLV\n           PATH-DATA-TLV:\n                  \
    \ flags = 0, IDCount = 1, IDs = 4\n                   FULLDATA-TLV: L = XXX, V=\n\
    \                        a series of: index, valueof(j1), valueof(j2)\n      \
    \                  representing the entire table\n        Note:   One should be\
    \ able to take a GET-RESPONSE-TLV and\n           convert it to a SET-TLV.  If\
    \ the result in the above example\n           is sent back in a SET-TLV (instead\
    \ of a GET-RESPONSE_TLV),\n           then the entire contents of the table will\
    \ be replaced at\n           that point.\n   4.   Multiple operations example.\
    \  To create entry 0-5 of table2\n        (Error conditions are ignored)\n   OPER\
    \ = SET-TLV\n           PATH-DATA-TLV:\n                   flags = 0 , IDCount\
    \ = 1, IDs = 4\n                   PATH-DATA-TLV\n                     flags =\
    \ 0, IDCount = 1, IDs = 0\n                     FULLDATA-TLV valueof(j1), valueof(j2)\
    \ of entry 0\n                   PATH-DATA-TLV\n                     flags = 0,\
    \ IDCount = 1, IDs = 1\n                     FULLDATA-TLV valueof(j1), valueof(j2)\
    \ of entry 1\n                   PATH-DATA-TLV\n                     flags = 0,\
    \ IDCount = 1, IDs = 2\n                     FULLDATA-TLV valueof(j1), valueof(j2)\
    \ of entry 2\n                   PATH-DATA-TLV\n                     flags = 0,\
    \ IDCount = 1, IDs = 3\n                     FULLDATA-TLV valueof(j1), valueof(j2)\
    \ of entry 3\n                   PATH-DATA-TLV\n                     flags = 0,\
    \ IDCount = 1, IDs = 4\n                     FULLDATA-TLV valueof(j1), valueof(j2)\
    \ of entry 4\n                   PATH-DATA-TLV\n                     flags = 0,\
    \ IDCount = 1, IDs = 5\n                     FULLDATA-TLV valueof(j1), valueof(j2)\
    \ of entry 5\n   Result:\n   OPER = SET-RESPONSE-TLV\n           PATH-DATA-TLV:\n\
    \                   flags = 0 , IDCount = 1, IDs = 4\n                   PATH-DATA-TLV\n\
    \                       flags = 0, IDCount = 1, IDs = 0\n                    \
    \   RESULT-TLV\n                   PATH-DATA-TLV\n                       flags\
    \ = 0, IDCount = 1, IDs = 1\n                       RESULT-TLV\n             \
    \      PATH-DATA-TLV\n                       flags = 0, IDCount = 1, IDs = 2\n\
    \                       RESULT-TLV\n                   PATH-DATA-TLV\n       \
    \                flags = 0, IDCount = 1, IDs = 3\n                       RESULT-TLV\n\
    \                   PATH-DATA-TLV\n                       flags = 0, IDCount =\
    \ 1, IDs = 4\n                       RESULT-TLV\n                   PATH-DATA-TLV\n\
    \                       flags = 0, IDCount = 1, IDs = 5\n                    \
    \   RESULT-TLV\n   5.   Block operations (with holes) example.  Replace entry\
    \ 0,2 of\n        table2.\n   OPER = SET-TLV\n           PATH-DATA-TLV:\n    \
    \            flags =  0 , IDCount = 1, IDs = 4\n                PATH-DATA-TLV\n\
    \                   flags = 0, IDCount = 1, IDs = 0\n                   FULLDATA-TLV\
    \ containing valueof(j1), valueof(j2) of 0\n                PATH-DATA-TLV\n  \
    \                 flags = 0, IDCount = 1, IDs = 2\n                   FULLDATA-TLV\
    \ containing valueof(j1), valueof(j2) of 2\n   Result:\n   OPER = SET-TLV\n  \
    \         PATH-DATA-TLV:\n                flags =  0 , IDCount = 1, IDs = 4\n\
    \                PATH-DATA-TLV\n                    flags = 0, IDCount = 1, IDs\
    \ = 0\n                    RESULT-TLV\n                PATH-DATA-TLV\n       \
    \             flags = 0, IDCount = 1, IDs = 2\n                    RESULT-TLV\n\
    \   6.   Getting rows example.  Get first entry of table2.\n   OPER = GET-TLV\n\
    \           PATH-DATA-TLV:\n                   IDCount = 2, IDs = 4.0\n   Result:\n\
    \   OPER = GET-RESPONSE-TLV\n           PATH-DATA-TLV:\n                   IDCount\
    \ = 2, IDs = 4.0\n                    FULLDATA-TLV containing valueof(j1), valueof(j2)\n\
    \   7.   Get entry 0-5 of table2.\n   OPER = GET-TLV\n           PATH-DATA-TLV:\n\
    \                   flags = 0, IDCount = 1, IDs = 4\n                   PATH-DATA-TLV\n\
    \                       flags = 0, IDCount = 1, IDs = 0\n                   PATH-DATA-TLV\n\
    \                       flags = 0, IDCount = 1, IDs = 1\n                   PATH-DATA-TLV\n\
    \                       flags = 0, IDCount = 1, IDs = 2\n                   PATH-DATA-TLV\n\
    \                       flags = 0, IDCount = 1, IDs = 3\n                   PATH-DATA-TLV\n\
    \                       flags = 0, IDCount = 1, IDs = 4\n                   PATH-DATA-TLV\n\
    \                       flags = 0, IDCount = 1, IDs = 5\n   Result:\n   OPER =\
    \ GET-RESPONSE-TLV\n           PATH-DATA-TLV:\n                   flags = 0, IDCount\
    \ = 1, IDs = 4\n                   PATH-DATA-TLV\n                       flags\
    \ = 0, IDCount = 1, IDs = 0\n                       FULLDATA-TLV containing valueof(j1),\
    \ valueof(j2)\n                   PATH-DATA-TLV\n                       flags\
    \ = 0, IDCount = 1, IDs = 1\n                       FULLDATA-TLV containing valueof(j1),\
    \ valueof(j2)\n                   PATH-DATA-TLV\n                       flags\
    \ = 0, IDCount = 1, IDs = 2\n                       FULLDATA-TLV containing valueof(j1),\
    \ valueof(j2)\n                   PATH-DATA-TLV\n                       flags\
    \ = 0, IDCount = 1, IDs = 3\n                       FULLDATA-TLV containing valueof(j1),\
    \ valueof(j2)\n                   PATH-DATA-TLV\n                       flags\
    \ = 0, IDCount = 1, IDs = 4\n                       FULLDATA-TLV containing valueof(j1),\
    \ valueof(j2)\n                   PATH-DATA-TLV\n                       flags\
    \ = 0, IDCount = 1, IDs = 5\n                       FULLDATA-TLV containing valueof(j1),\
    \ valueof(j2)\n   8.   Create a row in table2, index 5.\n   OPER = SET-TLV\n \
    \          PATH-DATA-TLV:\n                flags = 0, IDCount = 2, IDs = 4.5\n\
    \                FULLDATA-TLV containing valueof(j1), valueof(j2)\n   Result:\n\
    \   OPER = SET-RESPONSE-TLV\n           PATH-DATA-TLV:\n                flags\
    \ = 0, IDCount = 1, IDs = 4.5\n                RESULT-TLV\n   9.   Dump contents\
    \ of table1.\n   OPER = GET-TLV\n           PATH-DATA-TLV:\n                 \
    \  flags = 0, IDCount = 1, IDs = 3\n   Result:\n   OPER = GET-RESPONSE-TLV\n \
    \          PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs = 3\n\
    \                   FULLDATA-TLV, Length = XXXX\n                           (depending\
    \ on size of table1)\n                           index, valueof(t1),valueof(t2)\n\
    \                           index, valueof(t1),valueof(t2)\n                 \
    \          .\n                           .\n                           .\n   10.\
    \  Using keys.  Get row entry from table4 where j1=100.  Recall, j1\n        is\
    \ a defined key for this table and its KeyID is 1.\n   OPER = GET-TLV\n      \
    \     PATH-DATA-TLV:\n                   flags = F_SELKEY  IDCount = 1, IDs =\
    \ 6\n                   KEYINFO-TLV = KeyID=1, KEY_DATA=100\n   Result:\n   If\
    \ j1=100 was at index 10\n   OPER = GET-RESPONSE-TLV\n           PATH-DATA-TLV:\n\
    \                   flags = 0, IDCount = 1, IDs = 6.10\n                   FULLDATA-TLV\
    \ containing\n                     valueof(j1), valueof(j2),valueof(j3),valueof(j4)\n\
    \   11.  Delete row with KEY match (j1=100, j2=200) in table2.  Note that\n  \
    \      the j1,j2 pair is a defined key for the table2.\n   OPER = DEL-TLV\n  \
    \         PATH-DATA-TLV:\n                   flags = F_SELKEY  IDCount = 1, IDs\
    \ = 4\n                   KEYINFO-TLV:  {KeyID =1 KEY_DATA=100,200}\n   Result:\n\
    \   If (j1=100, j2=200) was at entry 15:\n   OPER = DELETE-RESPONSE-TLV\n    \
    \       PATH-DATA-TLV:\n                   flags = 0  IDCount = 2, IDs = 4.15\n\
    \                   RESULT-TLV\n   12.  Dump contents of table3.  It should be\
    \ noted that this table has\n        a column with a component name that is variable\
    \ sized.  The\n        purpose of this use case is to show how such a component\
    \ is to\n        be encoded.\n   OPER = GET-TLV\n           PATH-DATA-TLV:\n \
    \               flags = 0 IDCount = 1, IDs = 5\n   Result:\n   OPER = GET-RESPONSE-TLV\n\
    \       PATH-DATA-TLV:\n          flags = 0  IDCount = 1, IDs = 5\n          \
    \    FULLDATA-TLV, Length = XXXX\n               index, someidv, TLV: T=FULLDATA-TLV,\
    \ L = 4+strlen(namev),\n                      V = valueof(v)\n               index,\
    \ someidv, TLV: T=FULLDATA-TLV, L = 4+strlen(namev),\n                      V\
    \ = valueof(v)\n               index, someidv, TLV: T=FULLDATA-TLV, L = 4+strlen(namev),\n\
    \                      V = valueof(v)\n               index, someidv, TLV: T=FULLDATA-TLV,\
    \ L = 4+strlen(namev),\n                      V = valueof(v)\n               \
    \   .\n                  .\n                  .\n   13.  Multiple atomic operations.\n\
    \        Note 1:   This emulates adding a new nexthop entry and then\n       \
    \    atomically updating the L3 entries pointing to an old NH to\n           point\
    \ to a new one.  The assumption is that both tables are\n           in the same\
    \ LFB.\n        Note:   Observe the two operations on the LFB instance; both are\n\
    \           SET operations.\n   //Operation 1: Add a new entry to table2 index\
    \ #20.\n   OPER = SET-TLV\n           Path-TLV:\n                   flags = 0,\
    \ IDCount = 2,  IDs = 4.20\n                   FULLDATA-TLV, V= valueof(j1),valueof(j2)\n\
    \   // Operation 2: Update table1 entry which\n   // was pointing with t2 = 10\
    \ to now point to 20\n   OPER = SET-TLV\n           PATH-DATA-TLV:\n         \
    \          flags = F_SELKEY, IDCount = 1, IDs = 3\n                   KEYINFO-TLV\
    \ = KeyID=1 KEY_DATA=10\n                   PATH-DATA-TLV\n                  \
    \         flags = 0  IDCount = 1, IDs = 2\n                           FULLDATA-TLV,\
    \ V= 20\n   Result:\n   //first operation, SET\n   OPER = SET-RESPONSE-TLV\n \
    \          PATH-DATA-TLV\n                   flags = 0 IDCount = 3, IDs = 4.20\n\
    \                   RESULT-TLV code = success\n                           FULLDATA-TLV,\
    \ V = valueof(j1),valueof(j2)\n   // second operation SET - assuming entry 16\
    \ was updated\n   OPER = SET-RESPONSE-TLV\n           PATH-DATA-TLV\n        \
    \           flags = 0 IDCount = 2, IDs = 3.16\n                   PATH-DATA-TLV\n\
    \                           flags = 0  IDCount = 1, IDs = 2\n                \
    \           RESULT-TLV code = success\n                                   FULLDATA-TLV,\
    \ Length = XXXX v=20\n   14.  Selective setting.  On table4 -- for indices 1,\
    \ 3, 5, 7, and 9.\n        Replace j1 to 100, j2 to 200, j3 to 300.  Leave j4\
    \ as is.\n   PER = SET-TLV\n       PATH-DATA-TLV\n           flags = 0, IDCount\
    \ = 1, IDs = 6\n           PATH-DATA-TLV\n               flags = 0, IDCount =\
    \ 1, IDs = 1\n               PATH-DATA-TLV\n                   flags = 0, IDCount\
    \ = 1, IDs = 1\n                   FULLDATA-TLV, Length = XXXX, V = {100}\n  \
    \             PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs =\
    \ 2\n                   FULLDATA-TLV, Length = XXXX, V = {200}\n             \
    \  PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs = 3\n       \
    \            FULLDATA-TLV, Length = XXXX, V = {300}\n           PATH-DATA-TLV\n\
    \               flags = 0, IDCount = 1, IDs = 3\n               PATH-DATA-TLV\n\
    \                   flags = 0, IDCount = 1, IDs = 1\n                   FULLDATA-TLV,\
    \ Length = XXXX, V = {100}\n               PATH-DATA-TLV\n                   flags\
    \ = 0, IDCount = 1, IDs = 2\n                   FULLDATA-TLV, Length = XXXX, V\
    \ = {200}\n               PATH-DATA-TLV\n                   flags = 0, IDCount\
    \ = 1, IDs = 3\n                   FULLDATA-TLV, Length = XXXX, V = {300}\n  \
    \         PATH-DATA-TLV\n               flags = 0, IDCount = 1, IDs = 5\n    \
    \           PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs = 1\n\
    \                   FULLDATA-TLV, Length = XXXX, V = {100}\n               PATH-DATA-TLV\n\
    \                   flags = 0, IDCount = 1, IDs = 2\n                   FULLDATA-TLV,\
    \ Length = XXXX, V = {200}\n               PATH-DATA-TLV\n                   flags\
    \ = 0, IDCount = 1, IDs = 3\n                   FULLDATA-TLV, Length = XXXX, V\
    \ = {300}\n           PATH-DATA-TLV\n               flags = 0, IDCount = 1, IDs\
    \ = 7\n               PATH-DATA-TLV\n                   flags = 0, IDCount = 1,\
    \ IDs = 1\n                   FULLDATA-TLV, Length = XXXX, V = {100}\n       \
    \        PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs = 2\n \
    \                  FULLDATA-TLV, Length = XXXX, V = {200}\n               PATH-DATA-TLV\n\
    \                   flags = 0, IDCount = 1, IDs = 3\n                   FULLDATA-TLV,\
    \ Length = XXXX, V = {300}\n           PATH-DATA-TLV\n               flags = 0,\
    \ IDCount = 1, IDs = 9\n               PATH-DATA-TLV\n                   flags\
    \ = 0, IDCount = 1, IDs = 1\n                   FULLDATA-TLV, Length = XXXX, V\
    \ = {100}\n               PATH-DATA-TLV\n                   flags = 0, IDCount\
    \ = 1, IDs = 2\n                   FULLDATA-TLV, Length = XXXX, V = {200}\n  \
    \             PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs =\
    \ 3\n                   FULLDATA-TLV, Length = XXXX, V = {300}\n   response:\n\
    \   OPER = SET-RESPONSE-TLV\n       PATH-DATA-TLV\n           flags = 0, IDCount\
    \ = 1, IDs = 6\n           PATH-DATA-TLV\n               flags = 0, IDCount =\
    \ 1, IDs = 1\n               PATH-DATA-TLV\n                   flags = 0, IDCount\
    \ = 1, IDs = 1\n                   RESULT-TLV\n               PATH-DATA-TLV\n\
    \                   flags = 0, IDCount = 1, IDs = 2\n                   RESULT-TLV\n\
    \               PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs\
    \ = 3\n                   RESULT-TLV\n           PATH-DATA-TLV\n             \
    \  flags = 0, IDCount = 1, IDs = 3\n               PATH-DATA-TLV\n           \
    \        flags = 0, IDCount = 1, IDs = 1\n                   RESULT-TLV\n    \
    \           PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs = 2\n\
    \                   RESULT-TLV\n               PATH-DATA-TLV\n               \
    \    flags = 0, IDCount = 1, IDs = 3\n                   RESULT-TLV\n        \
    \   PATH-DATA-TLV\n               flags = 0, IDCount = 1, IDs = 5\n          \
    \     PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs = 1\n    \
    \               RESULT-TLV\n               PATH-DATA-TLV\n                   flags\
    \ = 0, IDCount = 1, IDs = 2\n                   RESULT-TLV\n               PATH-DATA-TLV\n\
    \                   flags = 0, IDCount = 1, IDs = 3\n                   RESULT-TLV\n\
    \           PATH-DATA-TLV\n               flags = 0, IDCount = 1, IDs = 7\n  \
    \             PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs =\
    \ 1\n                   RESULT-TLV\n               PATH-DATA-TLV\n           \
    \        flags = 0, IDCount = 1, IDs = 2\n                   RESULT-TLV\n    \
    \           PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs = 3\n\
    \                   RESULT-TLV\n           PATH-DATA-TLV\n               flags\
    \ = 0, IDCount = 1, IDs = 9\n               PATH-DATA-TLV\n                  \
    \ flags = 0, IDCount = 1, IDs = 1\n                   RESULT-TLV\n           \
    \    PATH-DATA-TLV\n                   flags = 0, IDCount = 1, IDs = 2\n     \
    \              RESULT-TLV\n               PATH-DATA-TLV\n                   flags\
    \ = 0, IDCount = 1, IDs = 3\n                   RESULT-TLV\n   15.  Manipulation\
    \ of table of table examples.  Get x1 from table10\n        row with index 4,\
    \ inside table5 entry 10.\n   operation = GET-TLV\n           PATH-DATA-TLV\n\
    \                   flags = 0  IDCount = 5, IDs=7.10.2.4.1\n   Results:\n   operation\
    \ = GET-RESPONSE-TLV\n           PATH-DATA-TLV\n                   flags = 0 \
    \ IDCount = 5, IDs=7.10.2.4.1\n                   FULLDATA-TLV: L=XXXX, V = valueof(x1)\n\
    \   16.  From table5's row 10 table10, get X2s based on the value of x1\n    \
    \    equaling 10 (recall x1 is KeyID 1).\n   operation = GET-TLV\n           PATH-DATA-TLV\n\
    \                   flag = F_SELKEY, IDCount=3, IDS = 7.10.2\n               \
    \    KEYINFO-TLV, KeyID = 1, KEYDATA = 10\n                   PATH-DATA-TLV\n\
    \                           IDCount = 1, IDS = 2 //select x2\n   Results:\n  \
    \ If x1=10 was at entry 11:\n   operation = GET-RESPONSE-TLV\n           PATH-DATA-TLV\n\
    \                   flag = 0, IDCount=5, IDS = 7.10.2.11\n                   PATH-DATA-TLV\n\
    \                           flags = 0  IDCount = 1, IDS = 2\n                \
    \           FULLDATA-TLV: L=XXXX, V = valueof(x2)\n   17.  Further example of\
    \ manipulating a table of tables\n   Consider table6, which is defined as:\n \
    \  table6: type array, ID = 8\n           components are:\n           p1, type\
    \ u32, ID = 1\n           p2, type array, ID = 2, array components of type type-A\n\
    \   type-A:\n           a1, type u32, ID 1,\n           a2, type array ID2 ,array\
    \ components of type type-B\n   type-B:\n           b1, type u32, ID 1\n     \
    \      b2, type u32, ID 2\n   If for example one wanted to set by replacing:\n\
    \   table6.10.p1 to 111\n   table6.10.p2.20.a1 to 222\n   table6.10.p2.20.a2.30.b1\
    \ to 333\n   in one message and one operation.\n   There are two ways to do this:\n\
    \      a) using nesting\n      b) using a flat path data\n   A. Method using nesting\n\
    \      in one message with a single operation\n   operation = SET-TLV\n      \
    \     PATH-DATA-TLV\n                   flags = 0  IDCount = 2, IDs=6.10\n   \
    \                PATH-DATA-TLV\n                           flags = 0, IDCount\
    \ = 1, IDs=1\n                           FULLDATA-TLV: L=XXXX,\n             \
    \                      V = {111}\n                   PATH-DATA-TLV\n         \
    \                  flags = 0  IDCount = 2, IDs=2.20\n                        \
    \   PATH-DATA-TLV\n                                   flags = 0, IDCount = 1,\
    \ IDs=1\n                                   FULLDATA-TLV: L=XXXX,\n          \
    \                                 V = {222}\n                           PATH-DATA-TLV\
    \ :\n                                   flags = 0, IDCount = 3, IDs=2.30.1\n \
    \                                  FULLDATA-TLV: L=XXXX,\n                   \
    \                        V = {333}\n   Result:\n   operation = SET-RESPONSE-TLV\n\
    \           PATH-DATA-TLV\n                   flags = 0  IDCount = 2, IDs=6.10\n\
    \                   PATH-DATA-TLV\n                           flags = 0, IDCount\
    \ = 1, IDs=1\n                           RESULT-TLV\n                   PATH-DATA-TLV\n\
    \                           flags = 0  IDCount = 2, IDs=2.20\n               \
    \            PATH-DATA-TLV\n                                   flags = 0, IDCount\
    \ = 1, IDs=1\n                                   RESULT-TLV\n                \
    \           PATH-DATA-TLV :\n                                   flags = 0, IDCount\
    \ = 3, IDs=2.30.1\n                                   RESULT-TLV\n   B. Method\
    \ using a flat path data in\n      one message with a single operation\n   operation\
    \ = SET-TLV\n           PATH-DATA-TLV :\n                   flags = 0, IDCount\
    \ = 3, IDs=6.10.1\n                   FULLDATA-TLV: L=XXXX,\n                \
    \           V = {111}\n           PATH-DATA-TLV :\n                   flags =\
    \ 0, IDCount = 5, IDs=6.10.1.20.1\n                   FULLDATA-TLV: L=XXXX,\n\
    \                           V = {222}\n           PATH-DATA-TLV :\n          \
    \         flags = 0, IDCount = 7, IDs=6.10.1.20.1.30.1\n                   FULLDATA-TLV:\
    \ L=XXXX,\n                           V = {333}\n   Result:\n   operation = SET-TLV\n\
    \           PATH-DATA-TLV :\n                   flags = 0, IDCount = 3, IDs=6.10.1\n\
    \                   RESULT-TLV\n           PATH-DATA-TLV :\n                 \
    \  flags = 0, IDCount = 5, IDs=6.10.1.20.1\n                   RESULT-TLV\n  \
    \         PATH-DATA-TLV :\n                   flags = 0, IDCount = 7, IDs=6.10.1.20.1.30.1\n\
    \                   RESULT-TLV\n   18.  Get a whole LFB (all its components, etc.).\n\
    \        For example:   At startup a CE might well want the entire FE\n      \
    \     Object LFB.  So, in a request targeted at class 1, instance\n          \
    \ 1, one might find:\n   operation = GET-TLV\n           PATH-DATA-TLV\n     \
    \              flags = 0  IDCount = 0\n   result:\n   operation = GET-RESPONSE-TLV\n\
    \           PATH-DATA-TLV\n                   flags = 0  IDCount = 0\n       \
    \            FULLDATA-TLV encoding of the FE Object LFB\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Avri Doria (editor)\n   Lulea University of Technology\n\
    \   Rainbow Way\n   Lulea  SE-971 87\n   Sweden\n   Phone: +46 73 277 1788\n \
    \  EMail: avri@ltu.se\n   Jamal Hadi Salim (editor)\n   Znyx\n   Ottawa, Ontario\n\
    \   Canada\n   Phone:\n   EMail: hadi@mojatatu.com\n   Robert Haas (editor)\n\
    \   IBM\n   Saumerstrasse 4\n   8803 Ruschlikon\n   Switzerland\n   Phone:\n \
    \  EMail: rha@zurich.ibm.com\n   Hormuzd M Khosravi (editor)\n   Intel\n   2111\
    \ NE 25th Avenue\n   Hillsboro, OR  97124\n   USA\n   Phone: +1 503 264 0334\n\
    \   EMail: hormuzd.m.khosravi@intel.com\n   Weiming Wang  (editor)\n   Zhejiang\
    \ Gongshang University\n   18, Xuezheng Str., Xiasha University Town\n   Hangzhou\
    \  310018\n   P.R. China\n   Phone: +86-571-28877721\n   EMail: wmwang@zjgsu.edu.cn\n\
    \   Ligang Dong\n   Zhejiang Gongshang University\n   18, Xuezheng Str., Xiasha\
    \ University Town\n   Hangzhou  310018\n   P.R. China\n   Phone: +86-571-28877751\n\
    \   EMail: donglg@zjgsu.edu.cn\n   Ram Gopal\n   Nokia\n   5, Wayside Road\n \
    \  Burlington, MA  310035\n   USA\n   Phone: +1-781-993-3685\n   EMail: ram.gopal@nsn.com\n\
    \   Joel Halpern\n   P.O. Box 6049\n   Leesburg, VA  20178\n   USA\n   Phone:\
    \ +1-703-371-3043\n   EMail: jmh@joelhalpern.com\n"
