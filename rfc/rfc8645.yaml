- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                   S. Smyshlyaev, Ed.
  contents:
  - "Internet Research Task Force (IRTF)                   S. Smyshlyaev, Ed.\n  \
    \              Re-keying Mechanisms for Symmetric Keys\n"
- title: Abstract
  contents:
  - "Abstract\n   A certain maximum amount of data can be safely encrypted when\n\
    \   encryption is performed under a single key.  This amount is called\n   the\
    \ \"key lifetime\".  This specification describes a variety of\n   methods for\
    \ increasing the lifetime of symmetric keys.  It provides\n   two types of re-keying\
    \ mechanisms based on hash functions and block\n   ciphers that can be used with\
    \ modes of operations such as CTR, GCM,\n   CBC, CFB, and OMAC.\n   This document\
    \ is a product of the Crypto Forum Research Group (CFRG)\n   in the IRTF.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Research Task Force\n   (IRTF).  The IRTF publishes the results\
    \ of Internet-related research\n   and development activities.  These results\
    \ might not be suitable for\n   deployment.  This RFC represents the consensus\
    \ of the Crypto Forum\n   Research Group of the Internet Research Task Force (IRTF).\
    \  Documents\n   approved for publication by the IRSG are not candidates for any\
    \ level\n   of Internet Standard; see Section 2 of RFC 7841.\n   Information about\
    \ the current status of this document, any errata,\n   and how to provide feedback\
    \ on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8645.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Conventions Used in This Document . . . . . . . . . .\
    \ . . . .   7\n   3.  Basic Terms and Definitions . . . . . . . . . . . . . .\
    \ . . .   7\n   4.  Choosing Constructions and Security Parameters  . . . . .\
    \ . .   9\n   5.  External Re-keying Mechanisms . . . . . . . . . . . . . . .\
    \ .  11\n     5.1.  Methods of Key Lifetime Control . . . . . . . . . . . . .\
    \  14\n     5.2.  Parallel Constructions  . . . . . . . . . . . . . . . . .  14\n\
    \       5.2.1.  Parallel Construction Based on a KDF on a Block\n            \
    \   Cipher  . . . . . . . . . . . . . . . . . . . . . . .  15\n       5.2.2. \
    \ Parallel Construction Based on a KDF on a Hash\n               Function  . .\
    \ . . . . . . . . . . . . . . . . . . . .  16\n       5.2.3.  Tree-Based Construction\
    \ . . . . . . . . . . . . . . .  16\n     5.3.  Serial Constructions  . . . .\
    \ . . . . . . . . . . . . . .  17\n       5.3.1.  Serial Construction Based on\
    \ a KDF on a Block Cipher   19\n       5.3.2.  Serial Construction Based on a\
    \ KDF on a Hash Function  19\n     5.4.  Using Additional Entropy during Re-keying\
    \ . . . . . . . .  19\n   6.  Internal Re-keying Mechanisms . . . . . . . . .\
    \ . . . . . . .  20\n     6.1.  Methods of Key Lifetime Control . . . . . . .\
    \ . . . . . .  22\n     6.2.  Constructions that Do Not Require a Master Key \
    \ . . . . .  23\n       6.2.1.  ACPKM Re-keying Mechanisms  . . . . . . . . .\
    \ . . . .  23\n       6.2.2.  CTR-ACPKM Encryption Mode . . . . . . . . . . .\
    \ . . .  25\n       6.2.3.  GCM-ACPKM Authenticated Encryption Mode . . . . .\
    \ . .  26\n     6.3.  Constructions that Require a Master Key . . . . . . . .\
    \ .  29\n       6.3.1.  ACPKM-Master Key Derivation from the Master Key . . .\
    \  29\n       6.3.2.  CTR-ACPKM-Master Encryption Mode  . . . . . . . . . .  31\n\
    \       6.3.3.  GCM-ACPKM-Master Authenticated Encryption Mode  . . .  33\n  \
    \     6.3.4.  CBC-ACPKM-Master Encryption Mode  . . . . . . . . . .  37\n    \
    \   6.3.5.  CFB-ACPKM-Master Encryption Mode  . . . . . . . . . .  39\n      \
    \ 6.3.6.  OMAC-ACPKM-Master Authentication Mode . . . . . . . .  40\n   7.  Joint\
    \ Usage of External and Internal Re-keying  . . . . . . .  42\n   8.  Security\
    \ Considerations . . . . . . . . . . . . . . . . . . .  43\n   9.  IANA Considerations\
    \ . . . . . . . . . . . . . . . . . . . . .  43\n   10. References  . . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  44\n     10.1.  Normative References\
    \ . . . . . . . . . . . . . . . . . .  44\n     10.2.  Informative References\
    \ . . . . . . . . . . . . . . . . .  45\n   Appendix A.  Test Examples  . . .\
    \ . . . . . . . . . . . . . . . .  48\n     A.1.  Test Examples for External Re-keying\
    \  . . . . . . . . . .  48\n       A.1.1.  External Re-keying with a Parallel\
    \ Construction . . .  48\n       A.1.2.  External Re-keying with a Serial Construction\
    \ . . . .  49\n     A.2.  Test Examples for Internal Re-keying  . . . . . . .\
    \ . . .  52\n       A.2.1.  Internal Re-keying Mechanisms that Do Not\n      \
    \         Require a Master Key  . . . . . . . . . . . . . . . .  52\n       A.2.2.\
    \  Internal Re-keying Mechanisms with a Master Key . . .  56\n   Acknowledgments\
    \ . . . . . . . . . . . . . . . . . . . . . . . . .  69\n   Contributors  . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . .  69\n   Author's Address  .\
    \ . . . . . . . . . . . . . . . . . . . . . . .  69\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   A certain maximum amount of data can be safely encrypted\
    \ when\n   encryption is performed under a single key.  Hereinafter, this amount\n\
    \   will be referred to as the \"key lifetime\".  The need for such a\n   limitation\
    \ is dictated by the following methods of cryptanalysis:\n   1.  Methods based\
    \ on the combinatorial properties of the used block\n       cipher mode of operation\n\
    \          These methods do not depend on the underlying block cipher.\n     \
    \     Common mode restrictions derived from such methods are of\n          order\
    \ 2^{n/2}, where n is a block size defined in Section 3.\n          [Sweet32]\
    \ includes an example of an attack that is based on\n          such methods.\n\
    \   2.  Methods based on side-channel analysis issues\n          In most cases,\
    \ these methods do not depend on the used\n          encryption modes and weakly\
    \ depend on the used cipher\n          features.  Limitations resulting from these\
    \ considerations are\n          usually the most restrictive ones.  [TEMPEST]\
    \ is an example of\n          an attack that is based on such methods.\n   3.\
    \  Methods based on the properties of the used block cipher\n          The most\
    \ common methods of this type are linear and\n          differential cryptanalysis\
    \ [LDC].  In most cases, these\n          methods do not depend on the used modes\
    \ of operation.  In the\n          case of secure block ciphers, bounds resulting\
    \ from such\n          methods are roughly the same as the natural bounds of 2^n\
    \ and\n          are dominated by the other bounds above.  Therefore, they can\n\
    \          be excluded from the considerations here.\n   As a result, it is important\
    \ to replace a key when the total size of\n   the processed plaintext under that\
    \ key approaches the lifetime\n   limitation.  A specific value of the key lifetime\
    \ should be\n   determined in accordance with some safety margin for protocol\n\
    \   security and the methods outlined above.\n   Suppose L is a key lifetime limitation\
    \ in some protocol P.  For\n   simplicity, assume that all messages have the same\
    \ length m.  Hence,\n   the number of messages q that can be processed with a\
    \ single key K\n   should be such that m * q <= L.  This can be depicted graphically\
    \ as\n   a rectangle with sides m and q enclosed by area L (see Figure 1).\n \
    \                     +------------------------+\n                      |    \
    \                  L |\n                      | +--------m---------+   |\n   \
    \                   | |==================|   |\n                      | |==================|\
    \   |\n                      | q==================|   |       m * q <= L\n   \
    \                   | |==================|   |\n                      | |==================|\
    \   |\n                      | +------------------+   |\n                    \
    \  +------------------------+\n         Figure 1: Graphic Display of the Key Lifetime\
    \ Limitation\n   In practice, the amount of data that corresponds to limitation\
    \ L may\n   not be enough.  The simplest and obvious solution in this situation\n\
    \   is a regular renegotiation of an initial key after processing this\n   threshold\
    \ amount of data L.  However, this reduces the total\n   performance, since it\
    \ usually entails termination of application data\n   transmission, additional\
    \ service messages, the use of a random number\n   generator, and many other additional\
    \ calculations, including\n   resource-intensive public key cryptography.\n  \
    \ For protocols based on block ciphers or stream ciphers, a more\n   efficient\
    \ way to increase the key lifetime is to use various\n   re-keying mechanisms.\
    \  This specification considers re-keying\n   mechanisms for block ciphers only;\
    \ re-keying mechanisms typical for\n   stream ciphers (e.g., [Pietrzak2009], [FPS2012])\
    \ are beyond the scope\n   of this document.\n   Re-keying mechanisms can be applied\
    \ at the different protocol levels:\n   the block cipher level (this approach\
    \ is known as fresh re-keying and\n   is described, for instance, in [FRESHREKEYING];\
    \ the block cipher mode\n   of operation level (see Section 6); and the protocol\
    \ level above the\n   block cipher mode of operation (see Section 5).  The usage\
    \ of the\n   first approach is highly inefficient due to the key changing after\n\
    \   each message block is processed.  Moreover, fresh re-keying\n   mechanisms\
    \ can change the block cipher internal structure and,\n   consequently, can require\
    \ an additional security analysis for each\n   particular block cipher.  As a\
    \ result, this approach depends on\n   particular primitive properties and cannot\
    \ be applied to any\n   arbitrary block cipher without additional security analysis.\n\
    \   Therefore, fresh re-keying mechanisms go beyond the scope of this\n   document.\n\
    \   Thus, this document contains the list of recommended re-keying\n   mechanisms\
    \ that can be used in the symmetric encryption schemes based\n   on the block\
    \ ciphers.  These mechanisms are independent from the\n   particular block cipher\
    \ specification, and their security properties\n   rely only on the standard block\
    \ cipher security assumption.\n   This specification presents two basic approaches\
    \ to extending the\n   lifetime of a key while avoiding renegotiation, which were\
    \ introduced\n   in [AAOS2017]:\n   1.  External re-keying\n      External re-keying\
    \ is performed by a protocol, and it is\n      independent of the underlying block\
    \ cipher and the mode of\n      operation.  External re-keying can use parallel\
    \ and serial\n      constructions.  In the parallel case, data processing keys\
    \ K^1,\n      K^2, ... are generated directly from the initial key K\n      independently\
    \ of each other.  In the serial case, every data-\n      processing key depends\
    \ on the state that is updated after the\n      generation of each new data-processing\
    \ key.\n      As a generalization of external parallel re-keying, an external\n\
    \      tree-based mechanism can be considered.  It is specified in\n      Section\
    \ 5.2.3 and can be viewed as the tree generalization in\n      [GGM].  Similar\
    \ constructions are used in the one-way tree\n      mechanism ([OWT]) and [AESDUKPT]\
    \ standard.\n   2.  Internal re-keying\n      Internal re-keying is built into\
    \ the mode, and it depends heavily\n      on the properties of the mode of operation\
    \ and the block size.\n   The re-keying approaches extend the key lifetime for\
    \ a single initial\n   key by allowing the leakages to be limited (via side channels)\
    \ and by\n   improving the combinatorial properties of the used block cipher mode\n\
    \   of operation.\n   In practical applications, re-keying can be useful for protocols\
    \ that\n   need to operate in hostile environments or under restricted resource\n\
    \   conditions (e.g., those that require lightweight cryptography, where\n   ciphers\
    \ have a small block size that imposes strict combinatorial\n   limitations).\
    \  Moreover, mechanisms that use external or internal\n   re-keying may provide\
    \ some protection against possible future attacks\n   (by limiting the number\
    \ of plaintext-ciphertext pairs that an\n   adversary can collect) and some properties\
    \ of forward or backward\n   security (meaning that past or future data-processing\
    \ keys remain\n   secure even if the current key is compromised; see [AbBell]\
    \ for more\n   details).  External or internal re-keying can be used in network\n\
    \   protocols as well as in the systems for data-at-rest encryption.\n   Depending\
    \ on the concrete protocol characteristics, there might be\n   situations in which\
    \ both external and internal re-keying mechanisms\n   (see Section 7) can be applied.\
    \  For example, a similar approach was\n   used in Taha's tree construction (see\
    \ [TAHA]).\n   Note that there are key-updating (key regression) algorithms (e.g.,\n\
    \   [FKK2005] and [KMNT2003]) that are called \"re-keying\" as well, but\n   they\
    \ pursue goals other than increasing the key lifetime.  Therefore,\n   key regression\
    \ algorithms are excluded from the considerations here.\n   This document represents\
    \ the consensus of the Crypto Forum Research\n   Group (CFRG).\n"
- title: 2.  Conventions Used in This Document
  contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be\
    \ interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,\
    \ they appear in all\n   capitals, as shown here.\n"
- title: 3.  Basic Terms and Definitions
  contents:
  - "3.  Basic Terms and Definitions\n   This document uses the following terms and\
    \ definitions for the sets\n   and operations on the elements of these sets:\n\
    \   V*      the set of all bit strings of a finite length (hereinafter\n     \
    \      referred to as strings), including the empty string;\n   V_s     the set\
    \ of all bit strings of length s, where s is a\n           non-negative integer;\n\
    \   |X|     the bit length of the bit string X;\n   A | B   the concatenation\
    \ of strings A and B both belonging to V*,\n           i.e., a string in V_{|A|+|B|},\
    \ where the left substring in\n           V_|A| is equal to A and the right substring\
    \ in V_|B| is equal\n           to B;\n   (xor)   the exclusive-or of two bit\
    \ strings of the same length;\n   Z_{2^n} the ring of residues modulo 2^n;\n \
    \  Int_s: V_s -> Z_{2^s}\n           the transformation that maps the string a\
    \ = (a_s, ... , a_1)\n           in V_s into the integer Int_s(a) = 2^{s-1} *\
    \ a_s + ... + 2 *\n           a_2 + a_1 (the interpretation of the binary string\
    \ as an\n           integer);\n   Vec_s: Z_{2^s} -> V_s\n           the transformation\
    \ inverse to the mapping Int_s (the\n           interpretation of an integer as\
    \ a binary string);\n   MSB_i: V_s -> V_i\n           the transformation that\
    \ maps the string a = (a_s, ... , a_1)\n           in V_s into the string MSB_i(a)\
    \ = (a_s, ... , a_{s-i+1}) in\n           V_i (most significant bits);\n   LSB_i:\
    \ V_s -> V_i\n           the transformation that maps the string a = (a_s, ...\
    \ , a_1)\n           in V_s into the string LSB_i(a) = (a_i, ... , a_1) in V_i\n\
    \           (least significant bits);\n   Inc_c: V_s -> V_s\n           the transformation\
    \ that maps the string a = (a_s, ... , a_1)\n           in V_s into the string\
    \ Inc_c(a) = MSB_{|a|-c}(a) |\n           Vec_c(Int_c(LSB_c(a)) + 1(mod 2^c))\
    \ in V_s (incrementing the\n           least significant c bits of the bit string,\
    \ regarded as the\n           binary representation of an integer);\n   a^s  \
    \   the string in V_s that consists of s 'a' bits;\n   E_{K}: V_n -> V_n\n   \
    \        the block cipher permutation under the key K in V_k;\n   ceil(x) the\
    \ smallest integer that is greater than or equal to x;\n   floor(x)\n        \
    \   the biggest integer that is less than or equal to x;\n   k       the bit length\
    \ of the K; k is assumed to be divisible by 8;\n   n       the block size of the\
    \ block cipher (in bits); n is assumed to\n           be divisible by 8;\n   b\
    \       the number of data blocks in the plaintext P (b =\n           ceil(|P|/n));\n\
    \   N       the section size (the number of bits that are processed with\n   \
    \        one section key before this key is transformed).\n   A plaintext message\
    \ P and the corresponding ciphertext C are divided\n   into b = ceil(|P|/n) blocks,\
    \ denoted as P = P_1 | P_2 | ... | P_b and\n   C = C_1 | C_2 | ... | C_b, respectively.\
    \  The first b-1 blocks P_i\n   and C_i are in V_n for i = 1, 2, ... , b-1.  The\
    \ b-th blocks P_b and\n   C_b may be incomplete blocks, i.e., in V_r, where r\
    \ <= n if not\n   otherwise specified.\n"
- title: 4.  Choosing Constructions and Security Parameters
  contents:
  - "4.  Choosing Constructions and Security Parameters\n   External re-keying is\
    \ an approach assuming that a key is transformed\n   after encrypting a limited\
    \ number of entire messages.  The external\n   re-keying method is chosen at the\
    \ protocol level, regardless of the\n   underlying block cipher or the encryption\
    \ mode.  External re-keying\n   is recommended for protocols that process relatively\
    \ short messages\n   or protocols that have a way to divide a long message into\
    \ manageable\n   pieces.  Through external re-keying, the number of messages that\
    \ can\n   be securely processed with a single initial key K is substantially\n\
    \   increased without a loss of message length.\n   External re-keying has the\
    \ following advantages\n   1.  It increases the lifetime of an initial key by\
    \ increasing the\n       number of messages processed with this key.\n   2.  It\
    \ has minimal impact on performance when the number of messages\n       processed\
    \ under one initial key is sufficiently large.\n   3.  It provides forward and\
    \ backward security of data-processing\n       keys.\n   However, the use of external\
    \ re-keying has the following\n   disadvantage: in cases with restrictive key\
    \ lifetime limitations, the\n   message sizes can become obstructive due to the\
    \ impossibility of\n   processing sufficiently large messages, so it may be necessary\
    \ to\n   perform additional fragmentation at the protocol level.  For example,\n\
    \   if the key lifetime L is 1 GB and the message length m = 3 GB, then\n   this\
    \ message cannot be processed as a whole, and it should be divided\n   into three\
    \ fragments that will be processed separately.\n   Internal re-keying is an approach\
    \ assuming that a key is transformed\n   during each separate message processing.\
    \  Such procedures are\n   integrated into the base modes of operations, so every\
    \ internal\n   re-keying mechanism is defined for the particular operation mode\
    \ and\n   the block size of the used cipher.  Internal re-keying is recommended\n\
    \   for protocols that process long messages: the size of each single\n   message\
    \ can be substantially increased without loss in the number of\n   messages that\
    \ can be securely processed with a single initial key.\n   Internal re-keying\
    \ has the following advantages:\n   1.  It increases the lifetime of an initial\
    \ key by increasing the\n       size of the messages processed with one initial\
    \ key.\n   2.  It has minimal impact on performance.\n   3.  Internal re-keying\
    \ mechanisms without a master key do not affect\n       short-message transformation\
    \ at all.\n   4.  It is transparent (works like any mode of operation): it does\
    \ not\n       require changes of initialization vectors (IVs) and a restart of\n\
    \       MACing.\n   However, the use of internal re-keying has the following\n\
    \   disadvantages:\n   1.  a specific method must not be chosen independently\
    \ of a mode of\n       operation.\n   2.  internal re-keying mechanisms without\
    \ a master key do not provide\n       backward security of data-processing keys.\n\
    \   Any block cipher modes of operations with internal re-keying can be\n   jointly\
    \ used with any external re-keying mechanisms.  Such joint\n   usage increases\
    \ both the number of messages processed with one\n   initial key and their maximum\
    \ possible size.\n   If the adversary has access to the data-processing interface,\
    \ the use\n   of the same cryptographic primitives both for data-processing and\n\
    \   re-keying transformation decreases the code size but can lead to some\n  \
    \ possible vulnerabilities (the possibility of mounting a chosen-\n   plaintext\
    \ attack may lead to the compromise of the following keys).\n   This vulnerability\
    \ can be eliminated by using different primitives\n   for data processing and\
    \ re-keying, e.g., block cipher for data\n   processing and hash for re-keying\
    \ (see Section 5.2.2 and\n   Section 5.3.2).  However, in this case, the security\
    \ of the whole\n   scheme cannot be reduced to standard notions like a pseudorandom\n\
    \   function (PRF) or pseudorandom permutation (PRP), so security\n   estimations\
    \ become more difficult and unclear.\n   Summing up the abovementioned issues\
    \ briefly:\n   1.  If a protocol assumes processing of long records (e.g., [CMS]),\n\
    \       internal re-keying should be used.  If a protocol assumes\n       processing\
    \ of a significant number of ordered records, which can\n       be considered\
    \ as a single data stream (e.g., [TLS], [SSH]),\n       internal re-keying may\
    \ also be used.\n   2.  For protocols that allow out-of-order delivery and lost\
    \ records\n       (e.g., [DTLS], [ESP]), external re-keying should be used as,\
    \ in\n       this case, records cannot be considered as a single data stream.\n\
    \       If the records are also long enough, internal re-keying should\n     \
    \  also be used during each separate message processing.\n   For external re-keying:\n\
    \   1.  If it is desirable to separate transformations used for data\n       processing\
    \ and key updates, hash function-based re-keying should\n       be used.\n   2.\
    \  If parallel data processing is required, then parallel external\n       re-keying\
    \ should be used.\n   3.  If restrictive key lifetime limitations are present,\
    \ external\n       tree-based re-keying should be used.\n   For internal re-keying:\n\
    \   1.  If the property of forward and backward security is desirable for\n  \
    \     data-processing keys and if additional key material can be easily\n    \
    \   obtained for the data-processing stage, internal re-keying with a\n      \
    \ master key should be used.\n"
- title: 5.  External Re-keying Mechanisms
  contents:
  - "5.  External Re-keying Mechanisms\n   This section presents an approach to increasing\
    \ the initial key\n   lifetime by using a transformation of a data-processing\
    \ key (frame\n   key) after processing a limited number of entire messages (frame).\n\
    \   The approach provides external parallel and serial re-keying\n   mechanisms\
    \ (see [AbBell]).  These mechanisms use initial key K only\n   for frame key generation\
    \ and never use it directly for data\n   processing.  Such mechanisms operate\
    \ outside of the base modes of\n   operations and do not change them at all; therefore,\
    \ they are called\n   \"external re-keying\" mechanisms in this document.\n  \
    \ External re-keying mechanisms are recommended for usage in protocols\n   that\
    \ process quite small messages, since the maximum gain in\n   increasing the initial\
    \ key lifetime is achieved by increasing the\n   number of messages.\n   External\
    \ re-keying increases the initial key lifetime through the\n   following approach.\
    \  Suppose there is a protocol P with some mode of\n   operation (base encryption\
    \ or authentication mode).  Let L1 be a key\n   lifetime limitation induced by\
    \ side-channel analysis methods (side-\n   channel limitation), let L2 be a key\
    \ lifetime limitation induced by\n   methods based on the combinatorial properties\
    \ of a used mode of\n   operation (combinatorial limitation), and let q1, q2 be\
    \ the total\n   numbers of messages of length m that can be safely processed with\
    \ an\n   initial key K according to these limitations.\n   Let L = min(L1, L2),\
    \ q = min(q1, q2), and q * m <= L.  As the L1\n   limitation is usually much stronger\
    \ than the L2 limitation (L1 < L2),\n   the final key lifetime restriction is\
    \ equal to the most restrictive\n   limitation L1.  Thus, as displayed in Figure\
    \ 2, without re-keying,\n   only q1 (q1 * m <= L1) messages can be safely processed.\n\
    \                         <--------m------->\n                         +----------------+\
    \ ^ ^\n                         |================| | |\n                     \
    \    |================| | |\n                     K-->|================| q1|\n\
    \                         |================| | |\n                         |==============L1|\
    \ | |\n                         +----------------+ v |\n                     \
    \    |                |   |\n                         |                |   |\n\
    \                         |                |   q2\n                         |\
    \                |   |\n                         |                |   |\n    \
    \                     |                |   |\n                         |     \
    \           |   |\n                         |                |   |\n         \
    \                |                |   |\n                         |          \
    \      |   |\n                         |                |   |\n              \
    \           |              L2|   |\n                         +----------------+\
    \   v\n             Figure 2: Basic Principles of Message Processing\n       \
    \                 without External Re-keying\n   Suppose that the safety margin\
    \ for the protocol P is fixed and the\n   external re-keying approach is applied\
    \ to the initial key K to\n   generate the sequence of frame keys.  The frame\
    \ keys are generated in\n   such a way that the leakage of a previous frame key\
    \ does not have any\n   impact on the following one, so the side-channel limitation\
    \ L1 is\n   switched off.  Thus, the resulting key lifetime limitation of the\n\
    \   initial key K can be calculated on the basis of a new combinatorial\n   limitation\
    \ L2'.  It is proven (see [AbBell]) that the security of the\n   mode of operation\
    \ that uses external re-keying leads to an increase\n   when compared to base\
    \ mode without re-keying (thus, L2 < L2').\n   Hence, as displayed in Figure 3,\
    \ the resulting key lifetime\n   limitation if using external re-keying can be\
    \ increased up to L2'.\n                         <--------m------->\n        \
    \           K     +----------------+\n                   |     |================|\n\
    \                   v     |================|\n                  K^1--> |================|\n\
    \                   |     |================|\n                   |     |==============L1|\n\
    \                   |     +----------------+\n                   |     |================|\n\
    \                   v     |================|\n                  K^2--> |================|\n\
    \                   |     |================|\n                   |     |==============L1|\n\
    \                   |     +----------------+\n                   |     |================|\n\
    \                   v     |================|\n                  ...    |     \
    \ . . .     |\n                         |                |\n                 \
    \        |                |\n                         |              L2|\n   \
    \                      +----------------+\n                         |        \
    \        |\n                        ...              ...\n                   \
    \      |             L2'|\n                         +----------------+\n     \
    \        Figure 3: Basic Principles of Message Processing\n                  \
    \        with External Re-keying\n   Note: The key transformation process is depicted\
    \ in a simplified\n   form.  A specific approach (parallel and serial) is described\
    \ below.\n   Consider an example.  Let the message size in a protocol P be equal\n\
    \   to 1 KB.  Suppose L1 = 128 MB and L2 = 1 TB.  Thus, if an external\n   re-keying\
    \ mechanism is not used, the initial key K must be\n   renegotiated after processing\
    \ 128 MB / 1 KB = 131072 messages.\n   If an external re-keying mechanism is used,\
    \ the key lifetime\n   limitation L1 goes off.  Hence, the resulting key lifetime\
    \ limitation\n   L2' can be set to more than 1 TB.  Thus, if an external re-keying\n\
    \   mechanism is used, more than 1 TB / 1 KB = 2^30 messages can be\n   processed\
    \ before the initial key K is renegotiated.  This is 8192\n   times greater than\
    \ the number of messages that can be processed when\n   an external re-keying\
    \ mechanism is not used.\n"
- title: 5.1.  Methods of Key Lifetime Control
  contents:
  - "5.1.  Methods of Key Lifetime Control\n   Suppose L is an amount of data that\
    \ can be safely processed with one\n   frame key.  For i in {1, 2, ... , t}, the\
    \ frame key K^i (see Figures\n   4 and 6) should be transformed after processing\
    \ q_i messages, where\n   q_i can be calculated in accordance with one of the\
    \ following\n   approaches:\n   Explicit approach:\n      q_i is such that |M^{i,1}|\
    \ + ... + |M^{i,q_i}| <= L, |M^{i,1}| +\n      ... + |M^{i,q_i+1}| > L.\n    \
    \  This approach allows use of the frame key K^i in an almost optimal\n      way,\
    \ but it can be applied only when messages cannot be lost or\n      reordered\
    \ (e.g., TLS records).\n   Implicit approach:\n      q_i = L / m_max, i = 1, ...\
    \ , t.\n      The amount of data processed with one frame key K^i is calculated\n\
    \      under the assumption that every message has the maximum length\n      m_max.\
    \  Hence, this amount can be considerably less than the key\n      lifetime limitation\
    \ L.  On the other hand, this approach can be\n      applied when messages may\
    \ be lost or reordered (e.g., DTLS\n      records).\n   Dynamic key changes:\n\
    \      We can organize the key change using the Protected Point to Point\n   \
    \   ([P3]) solution by building a protected tunnel between the\n      endpoints\
    \ in which the information about frame key updating can be\n      safely passed\
    \ across.  This can be useful, for example, when we\n      want the adversary\
    \ to not detect the key change during the\n      protocol evaluation.\n"
- title: 5.2.  Parallel Constructions
  contents:
  - "5.2.  Parallel Constructions\n   External parallel re-keying mechanisms generate\
    \ frame keys K^1, K^2,\n   ... directly from the initial key K independently of\
    \ each other.\n   The main idea behind external re-keying with a parallel construction\n\
    \   is presented in Figure 4:\n   Maximum message size = m_max.\n   _____________________________________________________________\n\
    \                                   m_max\n                             <---------------->\n\
    \                   M^{1,1}   |===             |\n                   M^{1,2} \
    \  |=============== |\n         +->K^1-->   ...            ...\n         |   \
    \      M^{1,q_1} |========        |\n         |\n         |\n         |      \
    \   M^{2,1}   |================|\n         |         M^{2,2}   |=====        \
    \   |\n   K-----|->K^2-->   ...            ...\n         |         M^{2,q_2} |==========\
    \      |\n         |\n        ...\n         |         M^{t,1}   |============\
    \    |\n         |         M^{t,2}   |=============   |\n         +->K^t-->  \
    \ ...            ...\n                   M^{t,q_t} |==========      |\n   _____________________________________________________________\n\
    \             Figure 4: External Parallel Re-keying Mechanisms\n   The frame key\
    \ K^i, i = 1, ... , t - 1 is updated after processing a\n   certain number of\
    \ messages (see Section 5.1).\n"
- title: 5.2.1.  Parallel Construction Based on a KDF on a Block Cipher
  contents:
  - "5.2.1.  Parallel Construction Based on a KDF on a Block Cipher\n   The ExtParallelC\
    \ re-keying mechanism is based on the key derivation\n   function on a block cipher\
    \ and is used to generate t frame keys as\n   follows:\n      K^1 | K^2 | ...\
    \ | K^t = ExtParallelC(K, t * k) = MSB_{t *\n      k}(E_{K}(Vec_n(0)) |\n    \
    \  E_{K}(Vec_n(1)) | ... | E_{K}(Vec_n(R - 1))),\n   where R = ceil(t * k/n).\n"
- title: 5.2.2.  Parallel Construction Based on a KDF on a Hash Function
  contents:
  - "5.2.2.  Parallel Construction Based on a KDF on a Hash Function\n   The ExtParallelH\
    \ re-keying mechanism is based on the key derivation\n   function HKDF-Expand,\
    \ described in [RFC5869], and is used to generate\n   t frame keys as follows:\n\
    \      K^1 | K^2 | ... | K^t = ExtParallelH(K, t * k) = HKDF-Expand(K,\n     \
    \ label, t * k),\n   where label is a string (may be a zero-length string) that\
    \ is defined\n   by a specific protocol.\n"
- title: 5.2.3.  Tree-Based Construction
  contents:
  - "5.2.3.  Tree-Based Construction\n   The application of an external tree-based\
    \ mechanism leads to the\n   construction of the key tree with the initial key\
    \ K (root key) at the\n   0 level and the frame keys K^1, K^2, ... at the last\
    \ level, as\n   described in Figure 5.\n                            K_root = K\n\
    \                      ___________|___________\n                     |       \
    \   ...          |\n                     V                       V\n         \
    \           K{1,1}                K{1,W1}\n               ______|______      \
    \     ______|______\n              |     ...     |         |     ...     |\n \
    \             V             V         V             V\n           K{2,1}     \
    \  K{2,W2}  K{2,(W1-1)*W2+1} K{2,W1*W2}\n            __|__         __|__     __|__\
    \         __|__\n           | ... |       | ... |   | ... |       | ... |\n  \
    \         V     V       V     V   V     V       V     V\n        K{3,1}  ... \
    \    ...   ... ...   ...     ...   K{3,W1*W2*W3}\n         ...               \
    \                            ...\n        __|__                   ...        \
    \           __|__\n       | ... |                                       | ...\
    \ |\n       V     V                                       V     V\n   K{h,1} \
    \  K{h,Wh}         K{h,(W1*...*W{h-1}-1)*Wh+1}  K{h,W1*...*Wh}\n     //      \
    \ \\\\                                  //       \\\\\n   K^1       K^{Wh}   \
    \     K^{(W1*...*W{h-1}-1)*Wh+1}     K^{W1*...*Wh}\n   ____________________________________________________________________\n\
    \                  Figure 5: External Tree-Based Mechanism\n   The tree height\
    \ h and the number of keys Wj, j in {1, ... , h}, which\n   can be partitioned\
    \ from the \"parent\" key, are defined in accordance\n   with a specific protocol\
    \ and key lifetime limitations for the used\n   derivation functions.\n   Each\
    \ j-level key K{j,w}, where j in {1, ... , h}, w in {1, ... , W1 *\n   ... * Wj},\
    \ is derived from the (j-1)-level \"parent\" key K{j-1,\n   ceil(w/Wi)} (and other\
    \ appropriate input data) using the j-th level\n   derivation function.  This\
    \ function can be based on the block cipher\n   function or on the hash function\
    \ and is defined in accordance with a\n   specific protocol.\n   The i-th frame\
    \ K^i, i in {1, 2, ... , W1*...*Wh}, can be calculated\n   as follows:\n     \
    \ K^i = ExtKeyTree(K, i) = KDF_h(KDF_{h-1}(... KDF_1(K, ceil(i / (W2\n      *\
    \ ... * Wh)) ... , ceil(i / Wh)), i),\n   where KDF_j is the j-th level derivation\
    \ function that takes two\n   arguments (the parent key value and the integer\
    \ in a range from 1 to\n   W1 * ... * Wj) and outputs the j-th level key value.\n\
    \   The frame key K^i is updated after processing a certain number of\n   messages\
    \ (see Section 5.1).\n   In order to create an efficient implementation, during\
    \ frame key K^i\n   generation, the derivation functions KDF_j, j in {1, ... ,\
    \ h-1}\n   should be used only when ceil(i / (W{j+1} * ... * Wh)) != ceil((i -\n\
    \   1) / (W{j+1} * ... * Wh)); otherwise, it is necessary to use a\n   previously\
    \ generated value.  This approach also makes it possible to\n   take countermeasures\
    \ against side-channel attacks.\n   Consider an example.  Suppose h = 3, W1 =\
    \ W2 = W3 = W, and KDF_1,\n   KDF_2, KDF_3 are key derivation functions based\
    \ on the\n   KDF_GOSTR3411_2012_256 (hereafter simply KDF) function described\
    \ in\n   [RFC7836].  The resulting ExtKeyTree function can be defined as\n   follows:\n\
    \      ExtKeyTree(K, i) = KDF(KDF(KDF(K, \"level1\", ceil(i / W^2)),\n      \"\
    level2\", ceil(i / W)), \"level3\", i).\n   where i in {1, 2, ... , W^3}.\n  \
    \ A structure similar to the external tree-based mechanism can be found\n   in\
    \ Section 6 of [NISTSP800-108].\n"
- title: 5.3.  Serial Constructions
  contents:
  - "5.3.  Serial Constructions\n   External serial re-keying mechanisms generate\
    \ frame keys, each of\n   which depends on the secret state (K*_1, K*_2, ...)\
    \ that is updated\n   after the generation of each new frame key; see Figure 6.\
    \  Similar\n   approaches are used in the [SIGNAL] protocol and the [TLS] updating\n\
    \   traffic key mechanism and were proposed for use in the [U2F]\n   protocol.\n\
    \   External serial re-keying mechanisms have the obvious disadvantage of\n  \
    \ being impossible to implement in parallel, but they may be the\n   preferred\
    \ option if additional forward secrecy is desirable.  If all\n   keys are securely\
    \ deleted after usage, the compromise of a current\n   secret state at some point\
    \ does not lead to a compromise of all\n   previous secret states and frame keys.\
    \  In terms of [TLS], compromise\n   of application_traffic_secret_N does not\
    \ compromise all previous\n   application_traffic_secret_i, i < N.\n   The main\
    \ idea behind external re-keying with a serial construction is\n   presented in\
    \ Figure 6:\n   Maximum message size = m_max.\n   _____________________________________________________________\n\
    \                                        m_max\n                             \
    \     <---------------->\n                        M^{1,1}   |===             |\n\
    \                        M^{1,2}   |=============== |\n   K*_1 = K --->K^1-->\
    \    ...            ...\n     |                  M^{1,q_1} |========        |\n\
    \     |\n     |\n     |                  M^{2,1}   |================|\n     v\
    \                  M^{2,2}   |=====           |\n   K*_2 ------->K^2-->    ...\
    \            ...\n     |                  M^{2,q_2} |==========      |\n     |\n\
    \    ...\n     |                  M^{t,1}   |============    |\n     v       \
    \           M^{t,2}   |=============   |\n   K*_t ------->K^t-->    ...      \
    \      ...\n                        M^{t,q_t} |==========      |\n   _____________________________________________________________\n\
    \              Figure 6: External Serial Re-keying Mechanisms\n   The frame key\
    \ K^i, i = 1, ... , t - 1, is updated after processing a\n   certain number of\
    \ messages (see Section 5.1).\n"
- title: 5.3.1.  Serial Construction Based on a KDF on a Block Cipher
  contents:
  - "5.3.1.  Serial Construction Based on a KDF on a Block Cipher\n   The frame key\
    \ K^i is calculated using the ExtSerialC transformation\n   as follows:\n    \
    \  K^i = ExtSerialC(K, i) =\n      MSB_k(E_{K*_i}(Vec_n(0)) |E_{K*_i}(Vec_n(1))\
    \ | ... |\n      E_{K*_i}(Vec_n(J - 1))),\n   where J = ceil(k / n), i = 1, ...\
    \ , t, K*_i is calculated as follows:\n      K*_1 = K,\n      K*_{j+1} = MSB_k(E_{K*_j}(Vec_n(J))\
    \ | E_{K*_j}(Vec_n(J + 1)) |\n      ... |\n      E_{K*_j}(Vec_n(2 * J - 1))),\n\
    \   where j = 1, ... , t - 1.\n"
- title: 5.3.2.  Serial Construction Based on a KDF on a Hash Function
  contents:
  - "5.3.2.  Serial Construction Based on a KDF on a Hash Function\n   The frame key\
    \ K^i is calculated using the ExtSerialH transformation\n   as follows:\n    \
    \  K^i = ExtSerialH(K, i) = HKDF-Expand(K*_i, label1, k),\n   where i = 1, ...\
    \ , t; HKDF-Expand is the HMAC-based key derivation\n   function, as described\
    \ in [RFC5869]; and K*_i is calculated as\n   follows:\n      K*_1 = K,\n    \
    \  K*_{j+1} = HKDF-Expand(K*_j, label2, k), where j = 1, ... , t - 1,\n   where\
    \ label1 and label2 are different strings from V* that are\n   defined by a specific\
    \ protocol (see, for example, the algorithm for\n   updating traffic keys in TLS\
    \ 1.3 [TLS]).\n"
- title: 5.4.  Using Additional Entropy during Re-keying
  contents:
  - "5.4.  Using Additional Entropy during Re-keying\n   In many cases, using additional\
    \ entropy during re-keying won't\n   increase security but may give a false sense\
    \ of that.  Therefore, one\n   can rely on additional entropy only after conducting\
    \ a deep security\n   analysis.  For example, good PRF constructions do not require\n\
    \   additional entropy for the quality of keys, so, in most cases, there\n   is\
    \ no need to use additional entropy with external re-keying\n   mechanisms based\
    \ on secure KDFs.  However, in some situations, mixed-\n   in entropy can still\
    \ increase security in the case of a time-limited\n   but complete breach of the\
    \ system when an adversary can access the\n   frame-key generation interface but\
    \ cannot reveal the master keys\n   (e.g., when the master keys are stored in\
    \ a Hardware Security Module\n   (HSM)).\n   For example, an external parallel\
    \ construction based on a KDF on a\n   hash function with a mixed-in entropy can\
    \ be described as follows:\n      K^i = HKDF-Expand(K, label_i, k),\n   where\
    \ label_i is additional entropy that must be sent to the\n   recipient (e.g.,\
    \ sent jointly with an encrypted message).  The\n   entropy label_i and the corresponding\
    \ key K^i must be generated\n   directly before message processing.\n"
- title: 6.  Internal Re-keying Mechanisms
  contents:
  - "6.  Internal Re-keying Mechanisms\n   This section presents an approach to increasing\
    \ the key lifetime by\n   using a transformation of a data-processing key (section\
    \ key) during\n   each separate message processing.  Each message is processed\
    \ starting\n   with the same key (the first section key), and each section key\
    \ is\n   updated after processing N bits of the message (section).\n   This section\
    \ provides internal re-keying mechanisms called ACPKM\n   (Advanced Cryptographic\
    \ Prolongation of Key Material) and ACPKM-\n   Master that do not use a master\
    \ key and use a master key,\n   respectively.  Such mechanisms are integrated\
    \ into the base modes of\n   operation and actually form new modes of operation.\
    \  Therefore, they\n   are called \"internal re-keying\" mechanisms in this document.\n\
    \   Internal re-keying mechanisms are recommended to be used in protocols\n  \
    \ that process large single messages (e.g., CMS messages), since the\n   maximum\
    \ gain in increasing the key lifetime is achieved by increasing\n   the length\
    \ of a message, while it provides almost no increase in the\n   number of messages\
    \ that can be processed with one initial key.\n   Internal re-keying increases\
    \ the key lifetime through the following\n   approach.  Suppose protocol P uses\
    \ some base mode of operation.  Let\n   L1 and L2 be a side channel and combinatorial\
    \ limitations,\n   respectively, and for some fixed number of messages q, let\
    \ m1, m2 be\n   the lengths of messages that can be safely processed with a single\n\
    \   initial key K according to these limitations.\n   Thus, the approach without\
    \ re-keying (analogous to Section 5) yields\n   a final key lifetime restriction\
    \ equal to L1, and only q messages of\n   the length m1 can be safely processed;\
    \ see Figure 7.\n                K\n                |\n                v\n   \
    \   ^ +----------------+------------------------------------+\n      | |==============L1|\
    \                                  L2|\n      | |================|           \
    \                         |\n      q |================|                      \
    \              |\n      | |================|                                 \
    \   |\n      | |================|                                    |\n     \
    \ v +----------------+------------------------------------+\n        <-------m1------->\n\
    \        <----------------------------m2----------------------->\n           \
    \  Figure 7: Basic Principles of Message Processing\n                        without\
    \ Internal Re-keying\n   Suppose that the safety margin for the protocol P is\
    \ fixed and the\n   internal re-keying approach is applied to the base mode of\
    \ operation.\n   Suppose further that every message is processed with a section\
    \ key,\n   which is transformed after processing N bits of data, where N is a\n\
    \   parameter.  If q * N does not exceed L1, then the side-channel\n   limitation\
    \ L1 goes off, and the resulting key lifetime limitation of\n   the initial key\
    \ K can be calculated on the basis of a new\n   combinatorial limitation L2'.\
    \  The security of the mode of operation\n   that uses internal re-keying increases\
    \ when compared to the base mode\n   of operation without re-keying (thus, L2\
    \ < L2').  Hence, as displayed\n   in Figure 8, the resulting key lifetime limitation\
    \ if using internal\n   re-keying can be increased up to L2'.\n     K-----> K^1------------->\
    \ K^2 -----------> . . .\n             |                 |\n             v   \
    \              v\n   ^ +---------------+---------------+------------------+--...--+\n\
    \   | |=============L1|=============L1|======          L2|    L2'|\n   | |===============|===============|======\
    \            |       |\n   q |===============|===============|====== . . .   \
    \   |       |\n   | |===============|===============|======            |     \
    \  |\n   | |===============|===============|======            |       |\n   v\
    \ +---------------+---------------+------------------+--...--+\n     <-------N------->\n\
    \             Figure 8: Basic Principles of Message Processing\n             \
    \             with Internal Re-keying\n   Note: The key transformation process\
    \ is depicted in a simplified\n   form.  A specific approach (ACPKM and ACPKM-Master\
    \ re-keying\n   mechanisms) is described below.\n   Since the performance of encryption\
    \ can slightly decrease for rather\n   small values of N, the maximum possible\
    \ value should be selected for\n   parameter N for a particular protocol in order\
    \ to provide the\n   necessary key lifetime for the considered security models.\n\
    \   Consider an example.  Suppose L1 = 128 MB and L2 = 10 TB.  Let the\n   message\
    \ size in the protocol be large/unlimited (which may exhaust\n   the whole key\
    \ lifetime L2).  The most restrictive resulting key\n   lifetime limitation is\
    \ equal to 128 MB.\n   Thus, there is a need to put a limit on the maximum message\
    \ size\n   m_max.  For example, if m_max = 32 MB, it may happen that the\n   renegotiation\
    \ of initial key K would be required after processing\n   only four messages.\n\
    \   If an internal re-keying mechanism with section size N = 1 MB is\n   used,\
    \ more than L1 / N = 128 MB / 1 MB = 128 messages can be\n   processed before\
    \ the renegotiation of initial key K (instead of four\n   messages when an internal\
    \ re-keying mechanism is not used).  Note\n   that only one section of each message\
    \ is processed with the section\n   key K^i, and, consequently, the key lifetime\
    \ limitation L1 goes off.\n   Hence, the resulting key lifetime limitation L2'\
    \ can be set to more\n   than 10 TB (in cases when a single large message is processed\
    \ using\n   the initial key K).\n"
- title: 6.1.  Methods of Key Lifetime Control
  contents:
  - "6.1.  Methods of Key Lifetime Control\n   Suppose L is an amount of data that\
    \ can be safely processed with one\n   section key and N is a section size (fixed\
    \ parameter).  Suppose\n   M^{i}_1 is the first section of message M^{i}, i =\
    \ 1, ... , q (see\n   Figures 9 and 10); the parameter q can then be calculated\
    \ in\n   accordance with one of the following two approaches:\n   o  Explicit\
    \ approach:\n      q_i is such that |M^{1}_1| + ... + |M^{q}_1| <= L, |M^{1}_1|\
    \ + ...\n      + |M^{q+1}_1| > L\n      This approach allows use of the section\
    \ key K^i in an almost\n      optimal way, but it can be applied only when messages\
    \ cannot be\n      lost or reordered (e.g., TLS records).\n   o  Implicit approach:\n\
    \      q = L / N.\n      The amount of data processed with one section key K^i\
    \ is\n      calculated under the assumption that the length of every message\n\
    \      is equal to or greater than section size N and thus can be\n      considerably\
    \ less than the key lifetime limitation L.  On the\n      other hand, this approach\
    \ can be applied when messages may be lost\n      or reordered (e.g., DTLS records).\n"
- title: 6.2.  Constructions that Do Not Require a Master Key
  contents:
  - "6.2.  Constructions that Do Not Require a Master Key\n   This section describes\
    \ the block cipher modes that use the ACPKM\n   re-keying mechanism, which does\
    \ not use a master key; an initial key\n   is used directly for the data encryption.\n"
- title: 6.2.1.  ACPKM Re-keying Mechanisms
  contents:
  - "6.2.1.  ACPKM Re-keying Mechanisms\n   This section defines a periodical key\
    \ transformation without a master\n   key, which is called the ACPKM re-keying\
    \ mechanism.  This mechanism\n   can be applied to one of the base encryption\
    \ modes (CTR and GCM block\n   cipher modes) to get an extension of this encryption\
    \ mode that uses\n   periodical key transformation without a master key.  This\
    \ extension\n   can be considered as a new encryption mode.\n   An additional\
    \ parameter that defines the functioning of base\n   encryption modes with the\
    \ ACPKM re-keying mechanism is the section\n   size N.  The value of N is measured\
    \ in bits and is fixed within a\n   specific protocol based on the requirements\
    \ of the system capacity\n   and the key lifetime.  The section size N MUST be\
    \ divisible by the\n   block size n.\n   The main idea behind internal re-keying\
    \ without a master key is\n   presented in Figure 9:\n   Section size = const\
    \ = N,\n   maximum message size = m_max.\n   ____________________________________________________________________\n\
    \                 ACPKM       ACPKM              ACPKM\n          K^1 = K --->\
    \ K^2 ---...-> K^{l_max-1} ----> K^{l_max}\n              |          |       \
    \         |           |\n              |          |                |         \
    \  |\n              v          v                v           v\n   M^{1} |==========|==========|\
    \ ... |==========|=======:  |\n   M^{2} |==========|==========| ... |===     \
    \  |       :  |\n     .        .          .        .       .          .  :\n \
    \    :        :          :        :       :          :  :\n   M^{q} |==========|==========|\
    \ ... |==========|=====  :  |\n                      section                 \
    \          :\n                    <---------->                      m_max\n  \
    \                     N bit\n   ___________________________________________________________________\n\
    \   l_max = ceil(m_max/N).\n             Figure 9: Internal Re-keying without\
    \ a Master Key\n   During the processing of the input message M with the length\
    \ m in\n   some encryption mode that uses the ACPKM key transformation of the\n\
    \   initial key K, the message is divided into l = ceil(m / N) sections\n   (denoted\
    \ as M = M_1 | M_2 | ... | M_l, where M_i is in V_N for i in\n   {1, 2, ... ,\
    \ l - 1} and M_l is in V_r, r <= N).  The first section of\n   each message is\
    \ processed with the section key K^1 = K.  To process\n   the (i + 1)-th section\
    \ of each message, the section key K^{i+1} is\n   calculated using the ACPKM transformation\
    \ as follows:\n      K^{i+1} = ACPKM(K^i) = MSB_k(E_{K^i}(D_1) | ... | E_{K^i}(D_J)),\n\
    \   where J = ceil(k/n) and D_1, D_2, ... , D_J are in V_n and are\n   calculated\
    \ as follows:\n      D_1 | D_2 | ... | D_J = MSB_{J * n}(D),\n   where D is the\
    \ following constant in V_{1024}:\n             D = ( 80 | 81 | 82 | 83 | 84 |\
    \ 85 | 86 | 87\n                 | 88 | 89 | 8a | 8b | 8c | 8d | 8e | 8f\n   \
    \              | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97\n                 | 98\
    \ | 99 | 9a | 9b | 9c | 9d | 9e | 9f\n                 | a0 | a1 | a2 | a3 | a4\
    \ | a5 | a6 | a7\n                 | a8 | a9 | aa | ab | ac | ad | ae | af\n \
    \                | b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7\n                 | b8\
    \ | b9 | ba | bb | bc | bd | be | bf\n                 | c0 | c1 | c2 | c3 | c4\
    \ | c5 | c6 | c7\n                 | c8 | c9 | ca | cb | cc | cd | ce | cf\n \
    \                | d0 | d1 | d2 | d3 | d4 | d5 | d6 | d7\n                 | d8\
    \ | d9 | da | db | dc | dd | de | df\n                 | e0 | e1 | e2 | e3 | e4\
    \ | e5 | e6 | e7\n                 | e8 | e9 | ea | eb | ec | ed | ee | ef\n \
    \                | f0 | f1 | f2 | f3 | f4 | f5 | f6 | f7\n                 | f8\
    \ | f9 | fa | fb | fc | fd | fe | ff)\n   Note: The constant D is such that D_1,\
    \ ... , D_J are pairwise\n   different for any allowed n and k values.\n   Note:\
    \ The highest bit of each octet of the constant D is equal to 1.\n   This condition\
    \ is important as, in conjunction with a certain mode\n   message length limitation,\
    \ it allows prevention of collisions of\n   block cipher permutation inputs in\
    \ cases with key transformation and\n   message processing (for more details,\
    \ see Section 4.4 of [AAOS2017]).\n"
- title: 6.2.2.  CTR-ACPKM Encryption Mode
  contents:
  - "6.2.2.  CTR-ACPKM Encryption Mode\n   This section defines a CTR-ACPKM encryption\
    \ mode that uses the ACPKM\n   internal re-keying mechanism for the periodical\
    \ key transformation.\n   The CTR-ACPKM mode can be considered as the base encryption\
    \ mode CTR\n   (see [MODES]) extended by the ACPKM re-keying mechanism.\n   The\
    \ CTR-ACPKM encryption mode can be used with the following\n   parameters:\n \
    \  o  64 <= n <= 512.\n   o  128 <= k <= 512.\n   o  The number c of bits in a\
    \ specific part of the block to be\n      incremented is such that 32 <= c <=\
    \ 3 / 4 n, where c is a multiple\n      of 8.\n   o  The maximum message size\
    \ m_max = n * 2^{c-1}.\n   The CTR-ACPKM mode encryption and decryption procedures\
    \ are defined\n   as follows:\n   +----------------------------------------------------------------+\n\
    \   |  CTR-ACPKM-Encrypt(N, K, ICN, P)                               |\n   |----------------------------------------------------------------|\n\
    \   |  Input:                                                        |\n   | \
    \ - section size N,                                             |\n   |  - initial\
    \ key K,                                              |\n   |  - initial counter\
    \ nonce ICN in V_{n-c},                       |\n   |  - plaintext P = P_1 | ...\
    \ | P_b, |P| <= m_max.                |\n   |  Output:                       \
    \                                |\n   |  - ciphertext C.                    \
    \                           |\n   |----------------------------------------------------------------|\n\
    \   |  1. CTR_1 = ICN | 0^c                                          |\n   | \
    \ 2. For j = 2, 3, ... , b do                                   |\n   |      \
    \   CTR_{j} = Inc_c(CTR_{j-1})                             |\n   |  3. K^1 = K\
    \                                                    |\n   |  4. For i = 2, 3,\
    \ ... , ceil(|P| / N)                          |\n   |         K^i = ACPKM(K^{i-1})\
    \                                   |\n   |  5. For j = 1, 2, ... , b do     \
    \                              |\n   |         i = ceil(j * n / N),          \
    \                         |\n   |         G_j = E_{K^i}(CTR_j)               \
    \                    |\n   |  6. C = P (xor) MSB_{|P|}(G_1 | ... | G_b)      \
    \               |\n   |  7. Return C                                         \
    \          |\n   +----------------------------------------------------------------+\n\
    \   +----------------------------------------------------------------+\n   | \
    \ CTR-ACPKM-Decrypt(N, K, ICN, C)                               |\n   |----------------------------------------------------------------|\n\
    \   |  Input:                                                        |\n   | \
    \ - section size N,                                             |\n   |  - initial\
    \ key K,                                              |\n   |  - initial counter\
    \ nonce ICN in V_{n-c},                       |\n   |  - ciphertext C = C_1 |\
    \ ... | C_b, |C| <= m_max.               |\n   |  Output:                    \
    \                                   |\n   |  - plaintext P.                  \
    \                              |\n   |----------------------------------------------------------------|\n\
    \   |  1. P = CTR-ACPKM-Encrypt(N, K, ICN, C)                        |\n   | \
    \ 2. Return P                                                   |\n   +----------------------------------------------------------------+\n\
    \   The initial counter nonce (ICN) value for each message that is\n   encrypted\
    \ under the given initial key K must be chosen in a unique\n   manner.\n"
- title: 6.2.3.  GCM-ACPKM Authenticated Encryption Mode
  contents:
  - "6.2.3.  GCM-ACPKM Authenticated Encryption Mode\n   This section defines the\
    \ GCM-ACPKM authenticated encryption mode that\n   uses the ACPKM internal re-keying\
    \ mechanism for the periodical key\n   transformation.\n   The GCM-ACPKM mode\
    \ can be considered as the base authenticated\n   encryption mode GCM (see [GCM])\
    \ extended by the ACPKM re-keying\n   mechanism.\n   The GCM-ACPKM authenticated\
    \ encryption mode can be used with the\n   following parameters:\n   o  n in {128,\
    \ 256}.\n   o  128 <= k <= 512.\n   o  The number c of bits in a specific part\
    \ of the block to be\n      incremented is such that 1 / 4 n <= c <= 1 / 2 n,\
    \ c is a multiple\n      of 8.\n   o  Authentication tag length t.\n   o  The\
    \ maximum message size m_max = min{n * (2^{c-1} - 2), 2^{n/2} -\n      1}.\n \
    \  The GCM-ACPKM mode encryption and decryption procedures are defined\n   as\
    \ follows:\n   +-------------------------------------------------------------------+\n\
    \   |  GHASH(X, H)                                                      |\n  \
    \ |-------------------------------------------------------------------|\n   |\
    \  Input:                                                           |\n   |  -\
    \ bit string X = X_1 | ... | X_m, X_1, ... , X_m in V_n.         |\n   |  Output:\
    \                                                          |\n   |  - block GHASH(X,\
    \ H) in V_n.                                      |\n   |-------------------------------------------------------------------|\n\
    \   |  1. Y_0 = 0^n                                                     |\n  \
    \ |  2. For i = 1, ... , m do                                         |\n   |\
    \         Y_i = (Y_{i-1} (xor) X_i) * H                             |\n   |  3.\
    \ Return Y_m                                                    |\n   +-------------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ |  GCTR(N, K, ICB, X)                                               |\n   |-------------------------------------------------------------------|\n\
    \   |  Input:                                                           |\n  \
    \ |  - section size N,                                                |\n   |\
    \  - initial key K,                                                 |\n   |  -\
    \ initial counter block ICB,                                     |\n   |  - X\
    \ = X_1 | ... | X_b.                                           |\n   |  Output:\
    \                                                          |\n   |  - Y in V_{|X|}.\
    \                                                  |\n   |-------------------------------------------------------------------|\n\
    \   |  1. If X in V_0, then return Y, where Y in V_0                    |\n  \
    \ |  2. GCTR_1 = ICB                                                  |\n   |\
    \  3. For i = 2, ... , b do                                         |\n   |  \
    \       GCTR_i = Inc_c(GCTR_{i-1})                                |\n   |  4.\
    \ K^1 = K                                                       |\n   |  5. For\
    \ j = 2, ... , ceil(|X| / N)                                |\n   |         K^j\
    \ = ACPKM(K^{j-1})                                      |\n   |  6. For i = 1,\
    \ ... , b do                                         |\n   |         j = ceil(i\
    \ * n / N),                                      |\n   |         G_i = E_{K_j}(GCTR_i)\
    \                                     |\n   |  7. Y = X (xor) MSB_{|X|}(G_1 |\
    \ ... | G_b)                        |\n   |  8. Return Y                     \
    \                                 |\n   +-------------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ |  GCM-ACPKM-Encrypt(N, K, ICN, P, A)                               |\n   |-------------------------------------------------------------------|\n\
    \   |  Input:                                                           |\n  \
    \ |  - section size N,                                                |\n   |\
    \  - initial key K,                                                 |\n   |  -\
    \ initial counter nonce ICN in V_{n-c},                          |\n   |  - plaintext\
    \ P = P_1 | ... | P_b, |P| <= m_max,                   |\n   |  - additional authenticated\
    \ data A.                               |\n   |  Output:                     \
    \                                     |\n   |  - ciphertext C,               \
    \                                   |\n   |  - authentication tag T.         \
    \                                 |\n   |-------------------------------------------------------------------|\n\
    \   |  1. H = E_{K}(0^n)                                                |\n  \
    \ |  2. ICB_0 = ICN | 0^{c-1} | 1                                     |\n   |\
    \  3. C = GCTR(N, K, Inc_c(ICB_0), P)                               |\n   |  4.\
    \ u = n * ceil(|C| / n) - |C|                                   |\n   |     v\
    \ = n * ceil(|A| / n) - |A|                                   |\n   |  5. S =\
    \ GHASH(A | 0^v | C | 0^u | Vec_{n/2}(|A|) |                |\n   |          \
    \     | Vec_{n/2}(|C|), H)                                |\n   |  6. T = MSB_t(E_{K}(ICB_0)\
    \ (xor) S)                               |\n   |  7. Return C | T            \
    \                                      |\n   +-------------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ |  GCM-ACPKM-Decrypt(N, K, ICN, A, C, T)                            |\n   |-------------------------------------------------------------------|\n\
    \   |  Input:                                                           |\n  \
    \ |  - section size N,                                                |\n   |\
    \  - initial key K,                                                 |\n   |  -\
    \ initial counter block ICN,                                     |\n   |  - additional\
    \ authenticated data A,                               |\n   |  - ciphertext C\
    \ = C_1 | ... | C_b, |C| <= m_max,                  |\n   |  - authentication\
    \ tag T.                                          |\n   |  Output:           \
    \                                               |\n   |  - plaintext P or FAIL.\
    \                                           |\n   |-------------------------------------------------------------------|\n\
    \   |  1. H = E_{K}(0^n)                                                |\n  \
    \ |  2. ICB_0 = ICN | 0^{c-1} | 1                                     |\n   |\
    \  3. P = GCTR(N, K, Inc_c(ICB_0), C)                               |\n   |  4.\
    \ u = n * ceil(|C| / n) - |C|                                   |\n   |     v\
    \ = n * ceil(|A| / n) - |A|                                   |\n   |  5. S =\
    \ GHASH(A | 0^v | C | 0^u | Vec_{n/2}(|A|) |                |\n   |          \
    \     | Vec_{n/2}(|C|), H)                                |\n   |  6. T' = MSB_t(E_{K}(ICB_0)\
    \ (xor) S)                              |\n   |  7. If T = T', then return P;\
    \ else return FAIL                    |\n   +-------------------------------------------------------------------+\n\
    \   The * operation on (pairs of) the 2^n possible blocks corresponds to\n   the\
    \ multiplication operation for the binary Galois (finite) field of\n   2^n elements\
    \ defined by the polynomial f as follows (analogous to\n   [GCM]):\n   n = 128:\
    \  f = a^128 + a^7 + a^2 + a^1 + 1,\n   n = 256:  f = a^256 + a^10 + a^5 + a^2\
    \ + 1.\n   The initial counter nonce ICN value for each message that is\n   encrypted\
    \ under the given initial key K must be chosen in a unique\n   manner.\n   The\
    \ key for computing values E_{K}(ICB_0) and H is not updated and is\n   equal\
    \ to the initial key K.\n"
- title: 6.3.  Constructions that Require a Master Key
  contents:
  - "6.3.  Constructions that Require a Master Key\n   This section describes the\
    \ block cipher modes that use the ACPKM-\n   Master re-keying mechanism, which\
    \ use the initial key K as a master\n   key, so K is never used directly for data\
    \ processing but is used for\n   key derivation.\n"
- title: 6.3.1.  ACPKM-Master Key Derivation from the Master Key
  contents:
  - "6.3.1.  ACPKM-Master Key Derivation from the Master Key\n   This section defines\
    \ periodical key transformation with a master key,\n   which is called the ACPKM-Master\
    \ re-keying mechanism.  This mechanism\n   can be applied to one of the base modes\
    \ of operation (CTR, GCM, CBC,\n   CFB, OMAC modes) for getting an extension that\
    \ uses periodical key\n   transformation with a master key.  This extension can\
    \ be considered\n   as a new mode of operation.\n   Additional parameters that\
    \ define the functioning of modes of\n   operation that use the ACPKM-Master re-keying\
    \ mechanism are the\n   section size N, the change frequency T* of the master\
    \ keys K*_1,\n   K*_2, ... (see Figure 10), and the size d of the section key\n\
    \   material.  The values of N and T* are measured in bits and are fixed\n   within\
    \ a specific protocol based on the requirements of the system\n   capacity and\
    \ the key lifetime.  The section size N MUST be divisible\n   by the block size\
    \ n.  The master key frequency T* MUST be divisible\n   by d and by n.\n   The\
    \ main idea behind internal re-keying with a master key is\n   presented in Figure\
    \ 10:\n   Master key frequency T*,\n   section size N,\n   maximum message size\
    \ = m_max.\n   _____________________________________________________________________\n\
    \                           ACPKM                 ACPKM\n                K*_1\
    \ = K----------> K*_2 ---------...-----> K*_l_max\n               ___|___    \
    \        ___|___                 ___|___\n              |       |          | \
    \      |               |       |\n              v  ...  v          v  ...  v \
    \              v  ...  v\n            K[1]     K[t]     K[t+1]  K[2*t]  K[(l_max-1)t+1]\
    \ K[l_max*t]\n              |       |          |       |               |     \
    \  |\n              |       |          |       |               |       |\n   \
    \           v       v          v       v               v       v\n   M^{1}||======|...|======||======|...|======||...||======|...|==\
    \  : ||\n   M^{2}||======|...|======||======|...|======||...||======|...|====:\
    \ ||\n    ... ||      |   |      ||      |   |      ||   ||      |   |    : ||\n\
    \   M^{q}||======|...|======||====  |...|      ||...||      |...|    : ||\n  \
    \        section                                                   :\n       \
    \  <------>                                                   :\n           N\
    \ bit                                                  m_max\n   _____________________________________________________________________\n\
    \   |K[i]| = d,\n   t = T* / d,\n   l_max = ceil(m_max / (N * t)).\n         \
    \     Figure 10: Internal Re-keying with a Master Key\n   During the processing\
    \ of the input message M with the length m in\n   some mode of operation that\
    \ uses ACPKM-Master key transformation with\n   the initial key K and the master\
    \ key frequency T*, the message M is\n   divided into l = ceil(m / N) sections\
    \ (denoted as M = M_1 | M_2 |\n   ... | M_l, where M_i is in V_N for i in {1,\
    \ 2, ... , l - 1} and M_l\n   is in V_r, r <= N).  The j-th section of each message\
    \ is processed\n   with the key material K[j], j in {1, ... , l}, |K[j]| = d,\
    \ which is\n   calculated with the ACPKM-Master algorithm as follows:\n      K[1]\
    \ | ... | K[l] = ACPKM-Master(T*, K, d, l) = CTR-ACPKM-Encrypt\n      (T*, K,\
    \ 1^{n/2}, 0^{d*l}).\n   Note: The parameters d and l MUST be such that d * l\
    \ <= n *\n   2^{n/2-1}.\n"
- title: 6.3.2.  CTR-ACPKM-Master Encryption Mode
  contents:
  - "6.3.2.  CTR-ACPKM-Master Encryption Mode\n   This section defines a CTR-ACPKM-Master\
    \ encryption mode that uses the\n   ACPKM-Master internal re-keying mechanism\
    \ for the periodical key\n   transformation.\n   The CTR-ACPKM-Master encryption\
    \ mode can be considered as the base\n   encryption mode CTR (see [MODES]) extended\
    \ by the ACPKM-Master\n   re-keying mechanism.\n   The CTR-ACPKM-Master encryption\
    \ mode can be used with the following\n   parameters:\n   o  64 <= n <= 512.\n\
    \   o  128 <= k <= 512.\n   o  The number c of bits in a specific part of the\
    \ block to be\n      incremented is such that 32 <= c <= 3 / 4 n, c is a multiple\
    \ of 8.\n   o  The maximum message size m_max = min{N * (n * 2^{n/2-1} / k), n\
    \ *\n      2^c}.\n   The key material K[j] that is used for one-section processing\
    \ is\n   equal to K^j, where |K^j| = k bits.\n   The CTR-ACPKM-Master mode encryption\
    \ and decryption procedures are\n   defined as follows:\n   +----------------------------------------------------------------+\n\
    \   |  CTR-ACPKM-Master-Encrypt(N, K, T*, ICN, P)                    |\n   |----------------------------------------------------------------|\n\
    \   |  Input:                                                        |\n   | \
    \ - section size N,                                             |\n   |  - initial\
    \ key K,                                              |\n   |  - master key frequency\
    \ T*,                                    |\n   |  - initial counter nonce ICN\
    \ in V_{n-c},                       |\n   |  - plaintext P = P_1 | ... | P_b,\
    \ |P| <= m_max.                |\n   |  Output:                              \
    \                         |\n   |  - ciphertext C.                           \
    \                    |\n   |----------------------------------------------------------------|\n\
    \   |  1. CTR_1 = ICN | 0^c                                          |\n   | \
    \ 2. For j = 2, 3, ... , b do                                   |\n   |      \
    \   CTR_{j} = Inc_c(CTR_{j-1})                             |\n   |  3. l = ceil(|P|\
    \ / N)                                          |\n   |  4. K^1 | ... | K^l =\
    \ ACPKM-Master(T*, K, k, l)                |\n   |  5. For j = 1, 2, ... , b do\
    \                                   |\n   |         i = ceil(j * n / N),     \
    \                              |\n   |         G_j = E_{K^i}(CTR_j)          \
    \                         |\n   |  6. C = P (xor) MSB_{|P|}(G_1 | ... |G_b)  \
    \                    |\n   |  7. Return C                                    \
    \               |\n   |----------------------------------------------------------------+\n\
    \   +----------------------------------------------------------------+\n   | \
    \ CTR-ACPKM-Master-Decrypt(N, K, T*, ICN, C)                    |\n   |----------------------------------------------------------------|\n\
    \   |  Input:                                                        |\n   | \
    \ - section size N,                                             |\n   |  - initial\
    \ key K,                                              |\n   |  - master key frequency\
    \ T*,                                    |\n   |  - initial counter nonce ICN\
    \ in V_{n-c},                       |\n   |  - ciphertext C = C_1 | ... | C_b,\
    \ |C| <= m_max.               |\n   |  Output:                               \
    \                        |\n   |  - plaintext P.                             \
    \                   |\n   |----------------------------------------------------------------|\n\
    \   |  1. P = CTR-ACPKM-Master-Encrypt(N, K, T*, ICN, C)             |\n   | \
    \ 1. Return P                                                   |\n   +----------------------------------------------------------------+\n\
    \   The initial counter nonce ICN value for each message that is\n   encrypted\
    \ under the given initial key must be chosen in a unique\n   manner.\n"
- title: 6.3.3.  GCM-ACPKM-Master Authenticated Encryption Mode
  contents:
  - "6.3.3.  GCM-ACPKM-Master Authenticated Encryption Mode\n   This section defines\
    \ a GCM-ACPKM-Master authenticated encryption mode\n   that uses the ACPKM-Master\
    \ internal re-keying mechanism for the\n   periodical key transformation.\n  \
    \ The GCM-ACPKM-Master authenticated encryption mode can be considered\n   as\
    \ the base authenticated encryption mode GCM (see [GCM]) extended by\n   the ACPKM-Master\
    \ re-keying mechanism.\n   The GCM-ACPKM-Master authenticated encryption mode\
    \ can be used with\n   the following parameters:\n   o  n in {128, 256}.\n   o\
    \  128 <= k <= 512.\n   o  The number c of bits in a specific part of the block\
    \ to be\n      incremented is such that 1 / 4 n <= c <= 1 / 2 n, c is a multiple\n\
    \      of 8.\n   o  authentication tag length t.\n   o  the maximum message size\
    \ m_max = min{N * ( n * 2^{n/2-1} / k), n *\n      (2^c - 2), 2^{n/2} - 1}.\n\
    \   The key material K[j] that is used for the j-th section processing is\n  \
    \ equal to K^j, |K^j| = k bits.\n   The GCM-ACPKM-Master mode encryption and decryption\
    \ procedures are\n   defined as follows:\n   +-------------------------------------------------------------------+\n\
    \   |  GHASH(X, H)                                                      |\n  \
    \ |-------------------------------------------------------------------|\n   |\
    \  Input:                                                           |\n   |  -\
    \ bit string X = X_1 | ... | X_m, X_i in V_n for i in {1, ... ,m}|\n   |  Output:\
    \                                                          |\n   |  - block GHASH(X,\
    \ H) in V_n                                       |\n   |-------------------------------------------------------------------|\n\
    \   |  1. Y_0 = 0^n                                                     |\n  \
    \ |  2. For i = 1, ... , m do                                         |\n   |\
    \         Y_i = (Y_{i-1} (xor) X_i) * H                             |\n   |  3.\
    \ Return Y_m                                                    |\n   +-------------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ |  GCTR(N, K, T*, ICB, X)                                           |\n   |-------------------------------------------------------------------|\n\
    \   |  Input:                                                           |\n  \
    \ |  - section size N,                                                |\n   |\
    \  - initial key K,                                                 |\n   |  -\
    \ master key frequency T*,                                       |\n   |  - initial\
    \ counter block ICB,                                     |\n   |  - X = X_1 |\
    \ ... | X_b.                                           |\n   |  Output:      \
    \                                                    |\n   |  - Y in V_{|X|}.\
    \                                                  |\n   |-------------------------------------------------------------------|\n\
    \   |  1. If X in V_0, then return Y, where Y in V_0                    |\n  \
    \ |  2. GCTR_1 = ICB                                                  |\n   |\
    \  3. For i = 2, ... , b do                                         |\n   |  \
    \       GCTR_i = Inc_c(GCTR_{i-1})                                |\n   |  4.\
    \ l = ceil(|X| / N)                                             |\n   |  5. K^1\
    \ | ... | K^l = ACPKM-Master(T*, K, k, l)                   |\n   |  6. For j\
    \ = 1, ... , b do                                         |\n   |         i =\
    \ ceil(j * n / N),                                      |\n   |         G_j =\
    \ E_{K^i}(GCTR_j)                                     |\n   |  7. Y = X (xor)\
    \ MSB_{|X|}(G_1 | ... | G_b)                        |\n   |  8. Return Y     \
    \                                                 |\n   +-------------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ |  GCM-ACPKM-Master-Encrypt(N, K, T*, ICN, P, A)                    |\n   |-------------------------------------------------------------------|\n\
    \   |  Input:                                                           |\n  \
    \ |  - section size N,                                                |\n   |\
    \  - initial key K,                                                 |\n   |  -\
    \ master key frequency T*,                                       |\n   |  - initial\
    \ counter nonce ICN in V_{n-c},                          |\n   |  - plaintext\
    \ P = P_1 | ... | P_b, |P| <= m_max.                   |\n   |  - additional authenticated\
    \ data A.                               |\n   |  Output:                     \
    \                                     |\n   |  - ciphertext C,               \
    \                                   |\n   |  - authentication tag T.         \
    \                                 |\n   |-------------------------------------------------------------------|\n\
    \   |  1. K^1 = ACPKM-Master(T*, K, k, 1)                               |\n  \
    \ |  2. H = E_{K^1}(0^n)                                              |\n   |\
    \  3. ICB_0 = ICN | 0^{c-1} | 1                                     |\n   |  4.\
    \ C = GCTR(N, K, T*, Inc_c(ICB_0), P)                           |\n   |  5. u\
    \ = n * ceil(|C| / n) - |C|                                   |\n   |     v =\
    \ n * ceil(|A| / n) - |A|                                   |\n   |  6. S = GHASH(A\
    \ | 0^v | C | 0^u | Vec_{n/2}(|A|) |                |\n   |               | Vec_{n/2}(|C|),\
    \ H)                                |\n   |  7. T = MSB_t(E_{K^1}(ICB_0) (xor)\
    \ S)                             |\n   |  8. Return C | T                    \
    \                              |\n   +-------------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ |  GCM-ACPKM-Master-Decrypt(N, K, T*, ICN, A, C, T)                 |\n   |-------------------------------------------------------------------|\n\
    \   |  Input:                                                           |\n  \
    \ |  - section size N,                                                |\n   |\
    \  - initial key K,                                                 |\n   |  -\
    \ master key frequency T*,                                       |\n   |  - initial\
    \ counter nonce ICN in V_{n-c},                          |\n   |  - additional\
    \ authenticated data A.                               |\n   |  - ciphertext C\
    \ = C_1 | ... | C_b, |C| <= m_max,                  |\n   |  - authentication\
    \ tag T.                                          |\n   |  Output:           \
    \                                               |\n   |  - plaintext P or FAIL.\
    \                                           |\n   |-------------------------------------------------------------------|\n\
    \   |  1. K^1 = ACPKM-Master(T*, K, k, 1)                               |\n  \
    \ |  2. H = E_{K^1}(0^n)                                              |\n   |\
    \  3. ICB_0 = ICN | 0^{c-1} | 1                                     |\n   |  4.\
    \ P = GCTR(N, K, T*, Inc_c(ICB_0), C)                           |\n   |  5. u\
    \ = n * ceil(|C| / n) - |C|                                   |\n   |     v =\
    \ n * ceil(|A| / n) - |A|                                   |\n   |  6. S = GHASH(A\
    \ | 0^v | C | 0^u | Vec_{n/2}(|A|) |                |\n   |               | Vec_{n/2}(|C|),\
    \ H)                                |\n   |  7. T' = MSB_t(E_{K^1}(ICB_0) (xor)\
    \ S)                            |\n   |  8. If T = T', then return P; else return\
    \ FAIL.                   |\n   +-------------------------------------------------------------------+\n\
    \   The * operation on (pairs of) the 2^n possible blocks corresponds to\n   the\
    \ multiplication operation for the binary Galois (finite) field of\n   2^n elements\
    \ defined by the polynomial f as follows (by analogy with\n   [GCM]):\n   n =\
    \ 128:  f = a^128 + a^7 + a^2 + a^1 + 1,\n   n = 256:  f = a^256 + a^10 + a^5\
    \ + a^2 + 1.\n   The initial counter nonce ICN value for each message that is\n\
    \   encrypted under the given initial key must be chosen in a unique\n   manner.\n"
- title: 6.3.4.  CBC-ACPKM-Master Encryption Mode
  contents:
  - "6.3.4.  CBC-ACPKM-Master Encryption Mode\n   This section defines a CBC-ACPKM-Master\
    \ encryption mode that uses the\n   ACPKM-Master internal re-keying mechanism\
    \ for the periodical key\n   transformation.\n   The CBC-ACPKM-Master encryption\
    \ mode can be considered as the base\n   encryption mode CBC (see [MODES]) extended\
    \ by the ACPKM-Master\n   re-keying mechanism.\n   The CBC-ACPKM-Master encryption\
    \ mode can be used with the following\n   parameters:\n   o  64 <= n <= 512.\n\
    \   o  128 <= k <= 512.\n   o  The maximum message size m_max = N * (n * 2^{n/2-1}\
    \ / k).\n   In the specification of the CBC-ACPKM-Master mode, the plaintext and\n\
    \   ciphertext must be a sequence of one or more complete data blocks.\n   If\
    \ the data string to be encrypted does not initially satisfy this\n   property,\
    \ then it MUST be padded to form complete data blocks.  The\n   padding methods\
    \ are out of the scope of this document.  An example of\n   a padding method can\
    \ be found in Appendix A of [MODES].\n   The key material K[j] that is used for\
    \ the j-th section processing is\n   equal to K^j, |K^j| = k bits.\n   We use\
    \ D_{K} to denote the decryption function that is a permutation\n   inverse to\
    \ E_{K}.\n   The CBC-ACPKM-Master mode encryption and decryption procedures are\n\
    \   defined as follows:\n   +----------------------------------------------------------------+\n\
    \   |  CBC-ACPKM-Master-Encrypt(N, K, T*, IV, P)                     |\n   |----------------------------------------------------------------|\n\
    \   |  Input:                                                        |\n   | \
    \ - section size N,                                             |\n   |  - initial\
    \ key K,                                              |\n   |  - master key frequency\
    \ T*,                                    |\n   |  - initialization vector IV in\
    \ V_n,                            |\n   |  - plaintext P = P_1 | ... | P_b, |P_b|\
    \ = n, |P| <= m_max.     |\n   |  Output:                                    \
    \                   |\n   |  - ciphertext C.                                 \
    \              |\n   |----------------------------------------------------------------|\n\
    \   |  1. l = ceil(|P| / N)                                          |\n   | \
    \ 2. K^1 | ... | K^l = ACPKM-Master(T*, K, k, l)                |\n   |  3. C_0\
    \ = IV                                                   |\n   |  4. For j = 1,\
    \ 2, ... , b do                                   |\n   |         i = ceil(j *\
    \ n / N),                                   |\n   |         C_j = E_{K^i}(P_j\
    \ (xor) C_{j-1})                       |\n   |  5. Return C = C_1 | ... | C_b\
    \                                 |\n   |----------------------------------------------------------------+\n\
    \   +----------------------------------------------------------------+\n   | \
    \ CBC-ACPKM-Master-Decrypt(N, K, T*, IV, C)                     |\n   |----------------------------------------------------------------|\n\
    \   |  Input:                                                        |\n   | \
    \ - section size N,                                             |\n   |  - initial\
    \ key K,                                              |\n   |  - master key frequency\
    \ T*,                                    |\n   |  - initialization vector IV in\
    \ V_n,                            |\n   |  - ciphertext C = C_1 | ... | C_b, |C_b|\
    \ = n, |C| <= m_max.    |\n   |  Output:                                     \
    \                  |\n   |  - plaintext P.                                   \
    \             |\n   |----------------------------------------------------------------|\n\
    \   |  1. l = ceil(|C| / N)                                          |\n   | \
    \ 2. K^1 | ... | K^l = ACPKM-Master(T*, K, k, l)                |\n   |  3. C_0\
    \ = IV                                                   |\n   |  4. For j = 1,\
    \ 2, ... , b do                                   |\n   |         i = ceil(j *\
    \ n / N)                                    |\n   |         P_j = D_{K^i}(C_j)\
    \ (xor) C_{j-1}                       |\n   |  5. Return P = P_1 | ... | P_b \
    \                                |\n   +----------------------------------------------------------------+\n\
    \   The initialization vector IV for any particular execution of the\n   encryption\
    \ process must be unpredictable.\n"
- title: 6.3.5.  CFB-ACPKM-Master Encryption Mode
  contents:
  - "6.3.5.  CFB-ACPKM-Master Encryption Mode\n   This section defines a CFB-ACPKM-Master\
    \ encryption mode that uses the\n   ACPKM-Master internal re-keying mechanism\
    \ for the periodical key\n   transformation.\n   The CFB-ACPKM-Master encryption\
    \ mode can be considered as the base\n   encryption mode CFB (see [MODES]) extended\
    \ by the ACPKM-Master\n   re-keying mechanism.\n   The CFB-ACPKM-Master encryption\
    \ mode can be used with the following\n   parameters:\n   o  64 <= n <= 512.\n\
    \   o  128 <= k <= 512.\n   o  The maximum message size m_max = N * (n * 2^{n/2-1}\
    \ / k).\n   The key material K[j] that is used for the j-th section processing\
    \ is\n   equal to K^j, |K^j| = k bits.\n   The CFB-ACPKM-Master mode encryption\
    \ and decryption procedures are\n   defined as follows:\n   +-------------------------------------------------------------+\n\
    \   |  CFB-ACPKM-Master-Encrypt(N, K, T*, IV, P)                  |\n   |-------------------------------------------------------------|\n\
    \   |  Input:                                                     |\n   |  - section\
    \ size N,                                          |\n   |  - initial key K, \
    \                                          |\n   |  - master key frequency T*,\
    \                                 |\n   |  - initialization vector IV in V_n,\
    \                         |\n   |  - plaintext P = P_1 | ... | P_b, |P| <= m_max.\
    \             |\n   |  Output:                                               \
    \     |\n   |  - ciphertext C.                                            |\n\
    \   |-------------------------------------------------------------|\n   |  1.\
    \ l = ceil(|P| / N)                                       |\n   |  2. K^1 | ...\
    \ | K^l = ACPKM-Master(T*, K, k, l)             |\n   |  3. C_0 = IV         \
    \                                       |\n   |  4. For j = 1, 2, ... , b - 1\
    \ do                            |\n   |         i = ceil(j * n / N),         \
    \                       |\n   |         C_j = E_{K^i}(C_{j-1}) (xor) P_j     \
    \               |\n   |  5. C_b = MSB_{|P_b|}(E_{K^l}(C_{b-1})) (xor) P_b    \
    \       |\n   |  6. Return C = C_1 | ... | C_b                              |\n\
    \   |-------------------------------------------------------------+\n   +-------------------------------------------------------------+\n\
    \   |  CFB-ACPKM-Master-Decrypt(N, K, T*, IV, C)                  |\n   |-------------------------------------------------------------|\n\
    \   |  Input:                                                     |\n   |  - section\
    \ size N,                                          |\n   |  - initial key K, \
    \                                          |\n   |  - master key frequency T*,\
    \                                 |\n   |  - initialization vector IV in V_n,\
    \                         |\n   |  - ciphertext C = C_1 | ... | C_b, |C| <= m_max.\
    \            |\n   |  Output:                                                \
    \    |\n   |  - plaintext P.                                             |\n \
    \  |-------------------------------------------------------------|\n   |  1. l\
    \ = ceil(|C| / N)                                       |\n   |  2. K^1 | ...\
    \ | K^l = ACPKM-Master(T*, K, k, l)             |\n   |  3. C_0 = IV         \
    \                                       |\n   |  4. For j = 1, 2, ... , b - 1\
    \ do                            |\n   |         i = ceil(j * n / N),         \
    \                       |\n   |         P_j = E_{K^i}(C_{j-1}) (xor) C_j     \
    \               |\n   |  5. P_b = MSB_{|C_b|}(E_{K^l}(C_{b-1})) (xor) C_b    \
    \       |\n   |  6. Return P = P_1 | ... | P_b                              |\n\
    \   +-------------------------------------------------------------+\n   The initialization\
    \ vector IV for any particular execution of the\n   encryption process must be\
    \ unpredictable.\n"
- title: 6.3.6.  OMAC-ACPKM-Master Authentication Mode
  contents:
  - "6.3.6.  OMAC-ACPKM-Master Authentication Mode\n   This section defines an OMAC-ACPKM-Master\
    \ message authentication code\n   calculation mode that uses the ACPKM-Master\
    \ internal re-keying\n   mechanism for the periodical key transformation.\n  \
    \ The OMAC-ACPKM-Master mode can be considered as the base message\n   authentication\
    \ code calculation mode OMAC1, which is also known as\n   CMAC (see [RFC4493]),\
    \ extended by the ACPKM-Master re-keying\n   mechanism.\n   The OMAC-ACPKM-Master\
    \ message authentication code calculation mode\n   can be used with the following\
    \ parameters:\n   o  n in {64, 128, 256}.\n   o  128 <= k <= 512.\n   o  The maximum\
    \ message size m_max = N * (n * 2^{n/2-1} / (k + n)).\n   The key material K[j]\
    \ that is used for one-section processing is\n   equal to K^j | K^j_1, where |K^j|\
    \ = k bits and |K^j_1| = n bits.\n   The following is a specification of the subkey\
    \ generation process of\n   OMAC:\n   +-------------------------------------------------------------------+\n\
    \   | Generate_Subkey(K1, r)                                            |\n  \
    \ |-------------------------------------------------------------------|\n   |\
    \ Input:                                                            |\n   |  -\
    \ key K1.                                                        |\n   |  Output:\
    \                                                          |\n   |  - key SK.\
    \                                                        |\n   |-------------------------------------------------------------------|\n\
    \   |   1. If r = n, then return K1                                     |\n  \
    \ |   2. If r < n, then                                               |\n   |\
    \          if MSB_1(K1) = 0                                         |\n   |  \
    \            return K1 << 1                                       |\n   |    \
    \      else                                                     |\n   |      \
    \        return (K1 << 1) (xor) R_n                           |\n   +-------------------------------------------------------------------+\n\
    \   Here, R_n takes the following values:\n   o  n = 64: R_{64} = 0^{59} | 11011.\n\
    \   o  n = 128: R_{128} = 0^{120} | 10000111.\n   o  n = 256: R_{256} = 0^{145}\
    \ | 10000100101.\n   The OMAC-ACPKM-Master message authentication code calculation\
    \ mode is\n   defined as follows:\n   +-------------------------------------------------------------------+\n\
    \   | OMAC-ACPKM-Master(K, N, T*, M)                                    |\n  \
    \ |-------------------------------------------------------------------|\n   |\
    \ Input:                                                            |\n   |  -\
    \ section size N,                                                |\n   |  - initial\
    \ key K,                                                 |\n   |  - master key\
    \ frequency T*,                                       |\n   |  - plaintext M =\
    \ M_1 | ... | M_b, |M| <= m_max.                   |\n   |  Output:          \
    \                                                |\n   |  - message authentication\
    \ code T.                                 |\n   |-------------------------------------------------------------------|\n\
    \   | 1. C_0 = 0^n                                                      |\n  \
    \ | 2. l = ceil(|M| / N)                                              |\n   |\
    \ 3. K^1 | K^1_1 | ... | K^l | K^l_1 =                              |\n      \
    \               = ACPKM-Master(T*, K, (k + n), l)                 |\n   | 4. For\
    \ j = 1, 2, ... , b - 1 do                                   |\n   |        i\
    \ = ceil(j * n / N),                                       |\n   |        C_j\
    \ = E_{K^i}(M_j (xor) C_{j-1})                           |\n   | 5. SK = Generate_Subkey(K^l_1,\
    \ |M_b|)                             |\n   | 6. If |M_b| = n, then M*_b = M_b\
    \                                  |\n   |                  else M*_b = M_b |\
    \ 1 | 0^{n - 1 -|M_b|}           |\n   | 7. T = E_{K^l}(M*_b (xor) C_{b-1} (xor)\
    \ SK)                       |\n   | 8. Return T                              \
    \                         |\n   +-------------------------------------------------------------------+\n"
- title: 7.  Joint Usage of External and Internal Re-keying
  contents:
  - "7.  Joint Usage of External and Internal Re-keying\n   Both external re-keying\
    \ and internal re-keying have their own\n   advantages and disadvantages, which\
    \ are discussed in Section 1.  For\n   instance, using external re-keying can\
    \ essentially limit the message\n   length, while in the case of internal re-keying,\
    \ the section size,\n   which can be chosen as the maximal possible for operational\n\
    \   properties, limits the number of separate messages.  Therefore, the\n   choice\
    \ of re-keying mechanism (either external or internal) depends\n   on particular\
    \ protocol features.  However, some protocols may have\n   features that require\
    \ the advantages of both the external and\n   internal re-keying mechanisms: for\
    \ example, the protocol mainly\n   transmits short messages, but it must additionally\
    \ support processing\n   of very long messages.  In such situations, it is necessary\
    \ to use\n   external and internal re-keying jointly, since these techniques\n\
    \   negate each other's disadvantages.\n   For composition of external and internal\
    \ re-keying techniques, any\n   mechanism described in Section 5 can be used with\
    \ any mechanism\n   described in Section 6.\n   For example, consider the GCM-ACPKM\
    \ mode with external serial\n   re-keying based on a KDF on a hash function. \
    \ Denote the number of\n   messages in each frame (in the case of the implicit\
    \ approach to the\n   key lifetime control) for external re-keying as a frame\
    \ size.\n   Let L be a key lifetime limitation.  The section size N for internal\n\
    \   re-keying and the frame size q for external re-keying must be chosen\n   in\
    \ such a way that q * N must not exceed L.\n   Suppose that t messages (ICN_i,\
    \ P_i, A_i), with initial counter nonce\n   ICN_i, plaintext P_i, and additional\
    \ authenticated data A_i will be\n   processed before renegotiation.\n   For authenticated\
    \ encryption of each message (ICN_i, P_i, A_i), i =\n   1, ..., t, the following\
    \ algorithm can be applied:\n   1. j = ceil(i / q),\n   2. K^j = ExtSerialH(K,\
    \ j),\n   3. C_i | T_i = GCM-ACPKM-Encrypt(N, K^j, ICN_i, P_i, A_i).\n   Note\
    \ that nonces ICN_i that are used under the same frame key must be\n   unique\
    \ for each message.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Re-keying should be used to increase a priori\
    \ security properties of\n   ciphers in hostile environments (e.g., with side-channel\n\
    \   adversaries).  If efficient attacks on a cipher are known, the cipher\n  \
    \ must not be used.  Thus, re-keying cannot be used as a patch for\n   vulnerable\
    \ ciphers.  Base cipher properties must be well analyzed\n   because the security\
    \ of re-keying mechanisms is based on the security\n   of a block cipher as a\
    \ pseudorandom function.\n   Re-keying is not intended to solve any postquantum\
    \ security issues\n   for symmetric cryptography, since the reduction of security\
    \ caused by\n   Grover's algorithm is not connected with a size of plaintext\n\
    \   transformed by a cipher -- only a negligible (sufficient for key\n   uniqueness)\
    \ material is needed -- and the aim of re-keying is to\n   limit the size of plaintext\
    \ transformed under one initial key.\n   Re-keying can provide backward security\
    \ only if previous key material\n   is securely deleted after usage by all parties.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [CMS]      Housley, R., \"Cryptographic Message\
    \ Syntax (CMS)\", STD 70,\n              RFC 5652, DOI 10.17487/RFC5652, September\
    \ 2009,\n              <https://www.rfc-editor.org/info/rfc5652>.\n   [DTLS] \
    \    Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n              Security\
    \ Version 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n              January 2012,\
    \ <https://www.rfc-editor.org/info/rfc6347>.\n   [ESP]      Kent, S., \"IP Encapsulating\
    \ Security Payload (ESP)\",\n              RFC 4303, DOI 10.17487/RFC4303, December\
    \ 2005,\n              <https://www.rfc-editor.org/info/rfc4303>.\n   [GCM]  \
    \    Dworkin, M., \"Recommendation for Block Cipher Modes of\n              Operation:\
    \ Galois/Counter Mode (GCM) and GMAC\", NIST\n              Special Publication\
    \ 800-38D, DOI 10.6028/NIST.SP.800-38D,\n              November 2007,\n      \
    \        <http://nvlpubs.nist.gov/nistpubs/Legacy/SP/\n              nistspecialpublication800-38d.pdf>.\n\
    \   [MODES]    Dworkin, M., \"Recommendation for Block Cipher Modes of\n     \
    \         Operation: Methods and Techniques\", NIST Special\n              Publication\
    \ 800-38A, DOI 10.6028/NIST.SP.800-38A, December\n              2001.\n   [NISTSP800-108]\n\
    \              National Institute of Standards and Technology,\n             \
    \ \"Recommendation for Key Derivation Using Pseudorandom\n              Functions\"\
    , NIST Special Publication 800-108, October\n              2009, <http://nvlpubs.nist.gov/nistpubs/Legacy/SP/\n\
    \              nistspecialpublication800-108.pdf>.\n   [RFC2119]  Bradner, S.,\
    \ \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n       \
    \       <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC4493]  Song, JH., Poovendran,\
    \ R., Lee, J., and T. Iwata, \"The\n              AES-CMAC Algorithm\", RFC 4493,\
    \ DOI 10.17487/RFC4493, June\n              2006, <https://www.rfc-editor.org/info/rfc4493>.\n\
    \   [RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n \
    \             Key Derivation Function (HKDF)\", RFC 5869,\n              DOI 10.17487/RFC5869,\
    \ May 2010,\n              <https://www.rfc-editor.org/info/rfc5869>.\n   [RFC7836]\
    \  Smyshlyaev, S., Ed., Alekseev, E., Oshkin, I., Popov, V.,\n              Leontiev,\
    \ S., Podobaev, V., and D. Belyavsky, \"Guidelines\n              on the Cryptographic\
    \ Algorithms to Accompany the Usage of\n              Standards GOST R 34.10-2012\
    \ and GOST R 34.11-2012\",\n              RFC 7836, DOI 10.17487/RFC7836, March\
    \ 2016,\n              <https://www.rfc-editor.org/info/rfc7836>.\n   [RFC8174]\
    \  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119\
    \ Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,\
    \ <https://www.rfc-editor.org/info/rfc8174>.\n   [SSH]      Ylonen, T. and C.\
    \ Lonvick, Ed., \"The Secure Shell (SSH)\n              Transport Layer Protocol\"\
    , RFC 4253, DOI 10.17487/RFC4253,\n              January 2006, <https://www.rfc-editor.org/info/rfc4253>.\n\
    \   [TLS]      Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n \
    \             Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n  \
    \            <https://www.rfc-editor.org/info/rfc8446>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [AAOS2017] Ahmetzyanova, L., Alekseev, E.,\
    \ Oshkin, I., and S.\n              Smyshlyaev, \"Increasing the Lifetime of Symmetric\
    \ Keys for\n              the GCM Mode by Internal Re-keying\", Cryptology ePrint\n\
    \              Archive, Report 2017/697, 2017,\n              <https://eprint.iacr.org/2017/697.pdf>.\n\
    \   [AbBell]   Abdalla, M. and M. Bellare, \"Increasing the Lifetime of a\n  \
    \            Key: A Comparative Analysis of the Security of Re-keying\n      \
    \        Techniques\", ASIACRYPT 2000, Lecture Notes in Computer\n           \
    \   Science, Volume 1976, pp. 546-559,\n              DOI 10.1007/3-540-44448-3_42,\
    \ October 2000.\n   [AESDUKPT] American National Standards Institute, \"Retail\
    \ Financial\n              Services Symmetric Key Management - Part 3: Derived\
    \ Unique\n              Key Per Transaction\", ANSI X9.24-3-2017, October 2017.\n\
    \   [FKK2005]  Fu, K., Kamara, S., and T. Kohno, \"Key Regression:\n         \
    \     Enabling Efficient Key Distribution for Secure Distributed\n           \
    \   Storage\", November 2005, <https://homes.cs.washington.edu/\n            \
    \  ~yoshi/papers/KR/NDSS06.pdf>.\n   [FPS2012]  Faust, S., Pietrzak, K., and J.\
    \ Schipper, \"Practical\n              Leakage-Resilient Symmetric Cryptography\"\
    , Cryptographic\n              Hardware and Embedded Systems (CHES), Lecture Notes\
    \ in\n              Computer Science, Volume 7428, pp. 213-232,\n            \
    \  DOI 10.1007/978-3-642-33027-8_13, 2012,\n              <https://link.springer.com/content/\n\
    \              pdf/10.1007%2F978-3-642-33027-8_13.pdf>.\n   [FRESHREKEYING]\n\
    \              Dziembowski, S., Faust, S., Herold, G., Journault, A.,\n      \
    \        Masny, D., and F. Standaert, \"Towards Sound Fresh\n              Re-Keying\
    \ with Hard (Physical) Learning Problems\",\n              Cryptology ePrint Archive,\
    \ Report 2016/573, June 2016,\n              <https://eprint.iacr.org/2016/573>.\n\
    \   [GGM]      Goldreich, O., Goldwasser, S., and S. Micali, \"How to\n      \
    \        Construct Random Functions\", Journal of the Association\n          \
    \    for Computing Machinery, Volume 33, No. 4, pp. 792-807,\n              DOI\
    \ 10.1145/6490.6503, October 1986,\n              <https://dl.acm.org/citation.cfm?doid=6490.6503>.\n\
    \   [KMNT2003] Kim, Y., Maino, F., Narasimha, M., and G. Tsudik, \"Secure\n  \
    \            Group Services for Storage Area Networks\",\n              IEEE Communications\
    \ Magazine 41, Number 8, pp. 92-99,\n              DOI 10.1109/SISW.2002.1183514,\
    \ August 2003,\n              <https://ieeexplore.ieee.org/document/1183514>.\n\
    \   [LDC]      Heys, H., \"A Tutorial on Linear and Differential\n           \
    \   Cryptanalysis\", 2001, <https://citeseerx.ist.psu.edu/\n              viewdoc/citations?doi=10.1.1.2.2759>.\n\
    \   [OWT]      Joye, M. and S. Yen, \"One-Way Cross-Trees and Their\n        \
    \      Applications\", Public Key Cryptography (PKC), Lecture\n              Notes\
    \ in Computer Science, Volume 2274,\n              DOI 10.1007/3-540-45664-3_25,\
    \ February 2002,\n              <https://link.springer.com/content/\n        \
    \      pdf/10.1007%2F3-540-45664-3_25.pdf>.\n   [P3]       Alexander, P., \"Subject:\
    \ [Cfrg] Dynamic Key Changes on\n              Encrypted Sessions. - Draft I-D\
    \ Attached\", message to\n              the CFRG mailing list, 4 November 2017,\n\
    \              <https://mailarchive.ietf.org/arch/msg/cfrg/\n              ecTR3Hb-DFfrPCVmY0ghyYOEcxU>.\n\
    \   [Pietrzak2009]\n              Pietrzak, K., \"A Leakage-Resilient Mode of\
    \ Operation\",\n              EUROCRYPT 2009, Lecture Notes in Computer Science,\
    \ Volume\n              5479, pp. 462-482, DOI 10.1007/978-3-642-01001-9_27, April\n\
    \              2009, <https://iacr.org/archive/eurocrypt2009/\n              54790461/54790461.pdf>.\n\
    \   [SIGNAL]   Perrin, T., Ed. and M. Marlinspike, \"The Double Ratchet\n    \
    \          Algorithm\", November 2016, <https://signal.org/docs/\n           \
    \   specifications/doubleratchet/doubleratchet.pdf>.\n   [Sweet32]  Bhargavan,\
    \ K. and G. Leurent, \"On the Practical\n              (In-)Security of 64-bit\
    \ Block Ciphers: Collision Attacks\n              on HTTP over TLS and OpenVPN\"\
    , Proceedings of the 2016 ACM\n              SIGSAC Conference on Computer and\
    \ Communications\n              Security, pp. 456-467, DOI 10.1145/2976749.2978423,\n\
    \              October 2016, <https://sweet32.info/SWEET32_CCS16.pdf>.\n   [TAHA]\
    \     Taha, M. and P. Schaumont, \"Key Updating for Leakage\n              Resiliency\
    \ With Application to AES Modes of Operation\",\n              IEEE Transactions\
    \ on Information Forensics and Security,\n              DOI 10.1109/TIFS.2014.2383359,\
    \ December 2014,\n              <http://ieeexplore.ieee.org/document/6987331/>.\n\
    \   [TEMPEST]  Ramsay, C. and J. Lohuis, \"TEMPEST attacks against AES.\n    \
    \          Covertly stealing keys for 200 euro\", June 2017,\n              <https://www.fox-it.com/en/wp-content/uploads/sites/11/\n\
    \              Tempest_attacks_against_AES.pdf>.\n   [U2F]      Chang, D., Mishra,\
    \ S., Sanadhya, S., and A. Singh, \"On\n              Making U2F Protocol Leakage-Resilient\
    \ via Re-keying\",\n              Cryptology ePrint Archive, Report 2017/721,\
    \ August 2017,\n              <https://eprint.iacr.org/2017/721.pdf>.\n"
- title: Appendix A.  Test Examples
  contents:
  - 'Appendix A.  Test Examples

    '
- title: A.1.  Test Examples for External Re-keying
  contents:
  - 'A.1.  Test Examples for External Re-keying

    '
- title: A.1.1.  External Re-keying with a Parallel Construction
  contents:
  - "A.1.1.  External Re-keying with a Parallel Construction\n   External re-keying\
    \ with a parallel construction based on AES-256\n   ****************************************************************\n\
    \   k = 256\n   t = 128\n   Initial key:\n   00 01 02 03 04 05 06 07 08 09 0A\
    \ 0B 0C 0D 0E 0F\n   0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00\n   K^1:\n\
    \   51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86\n   64 7D 5C D5 1C 3D 62 98\
    \ BC 09 B1 D8 64 EC D9 B1\n   K^2:\n   6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6\
    \ 5B E0 15\n   B8 02 92 32 D8 D3 8D 73 FE DC DD C6 C8 36 78 BD\n   K^3:\n   B6\
    \ 40 24 85 A4 24 BD 35 B4 26 43 13 76 26 70 B6\n   5B F3 30 3D 3B 20 EB 14 D1\
    \ 3B B7 91 74 E3 DB EC\n   ...\n   K^126:\n   2F 3F 15 1B 53 88 23 CD 7D 03 FC\
    \ 3D FD B3 57 5E\n   23 E4 1C 4E 46 FF 6B 33 34 12 27 84 EF 5D 82 23\n   K^127:\n\
    \   8E 51 31 FB 0B 64 BB D0 BC D4 C5 7B 1C 66 EF FD\n   97 43 75 10 6C AF 5D 5E\
    \ 41 E0 17 F4 05 63 05 ED\n   K^128:\n   77 4F BF B3 22 60 C5 3B A3 8E FE B1 96\
    \ 46 76 41\n   94 49 AF 84 2D 84 65 A7 F4 F7 2C DC A4 9D 84 F9\n   External re-keying\
    \ with a parallel construction based on SHA-256\n   ****************************************************************\n\
    \   k = 256\n   t = 128\n   label:\n   SHA2label\n   Initial key:\n   00 01 02\
    \ 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n   0F 0E 0D 0C 0B 0A 09 08 07 06 05\
    \ 04 03 02 01 00\n   K^1:\n   C1 A1 4C A0 30 29 BE 43 9F 35 3C 79 1A 51 48 57\n\
    \   26 7A CD 5A E8 7D E7 D1 B2 E2 C7 AF A4 29 BD 35\n   K^2:\n   03 68 BB 74 41\
    \ 2A 98 ED C4 7B 94 CC DF 9C F4 9E\n   A9 B8 A9 5F 0E DC 3C 1E 3B D2 59 4D D1\
    \ 75 82 D4\n   K^3:\n   2F D3 68 D3 A7 8F 91 E6 3B 68 DC 2B 41 1D AC 80\n   0A\
    \ C3 14 1D 80 26 3E 61 C9 0D 24 45 2A BD B1 AE\n   ...\n   K^126:\n   55 AC 2B\
    \ 25 00 78 3E D4 34 2B 65 0E 75 E5 8B 76\n   C8 04 E9 D3 B6 08 7D C0 70 2A 99\
    \ A4 B5 85 F1 A1\n   K^127:\n   77 4D 15 88 B0 40 90 E5 8C 6A D7 5D 0F CF 0A 4A\n\
    \   6C 23 F1 B3 91 B1 EF DF E5 77 64 CD 09 F5 BC AF\n   K^128:\n   E5 81 FF FB\
    \ 0C 90 88 CD E5 F4 A5 57 B6 AB D2 2E\n   94 C3 42 06 41 AB C1 72 66 CC 2F 59\
    \ 74 9C 86 B3\n"
- title: A.1.2.  External Re-keying with a Serial Construction
  contents:
  - "A.1.2.  External Re-keying with a Serial Construction\n   External re-keying\
    \ with a serial construction based on AES-256\n   **************************************************************\n\
    \   AES 256 examples:\n   k = 256\n   t = 128\n   Initial key:\n   00 01 02 03\
    \ 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n   0F 0E 0D 0C 0B 0A 09 08 07 06 05 04\
    \ 03 02 01 00\n   K*_1:\n   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n\
    \   0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00\n   K^1:\n   66 B8 BD E5 90\
    \ 6C EC DF FA 8A B2 FD 92 84 EB F0\n   51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2\
    \ BA C3 86\n   K*_2:\n   64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1\n   6F\
    \ ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15\n   K^2:\n   66 B8 BD E5 90 6C\
    \ EC DF FA 8A B2 FD 92 84 EB F0\n   51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA\
    \ C3 86\n   K*_3:\n   64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1\n   6F ED\
    \ F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15\n   K^3:\n   66 B8 BD E5 90 6C EC\
    \ DF FA 8A B2 FD 92 84 EB F0\n   51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3\
    \ 86\n   ...\n   K*_126:\n   64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1\n\
    \   6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15\n   K^126:\n   66 B8 BD E5\
    \ 90 6C EC DF FA 8A B2 FD 92 84 EB F0\n   51 16 8A B6 C8 A8 38 65 54 85 31 A5\
    \ D2 BA C3 86\n   K*_127:\n   64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1\n\
    \   6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15\n   K^127:\n   66 B8 BD E5\
    \ 90 6C EC DF FA 8A B2 FD 92 84 EB F0\n   51 16 8A B6 C8 A8 38 65 54 85 31 A5\
    \ D2 BA C3 86\n   K*_128:\n   64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1\n\
    \   6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15\n   K^128:\n   66 B8 BD E5\
    \ 90 6C EC DF FA 8A B2 FD 92 84 EB F0\n   51 16 8A B6 C8 A8 38 65 54 85 31 A5\
    \ D2 BA C3 86\n   External re-keying with a serial construction based on SHA-256\n\
    \   **************************************************************\n   k = 256\n\
    \   t = 128\n   Initial key:\n   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E\
    \ 0F\n   0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00\n   label1:\n   SHA2label1\n\
    \   label2:\n   SHA2label2\n   K*_1:\n   00 01 02 03 04 05 06 07 08 09 0A 0B 0C\
    \ 0D 0E 0F\n   0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00\n   K^1:\n   2D\
    \ A8 D1 37 6C FD 52 7F F7 36 A4 E2 81 C6 0A 9B\n   F3 8E 66 97 ED 70 4F B5 FB\
    \ 10 33 CC EC EE D5 EC\n   K*_2:\n   14 65 5A D1 7C 19 86 24 9B D3 56 DF CC BE\
    \ 73 6F\n   52 62 4A 9D E3 CC 40 6D A9 48 DA 5C D0 68 8A 04\n   K^2:\n   2F EA\
    \ 8D 57 2B EF B8 89 42 54 1B 8C 1B 3F 8D B1\n   84 F9 56 C7 FE 01 11 99 1D FB\
    \ 98 15 FE 65 85 CF\n   K*_3:\n   18 F0 B5 2A D2 45 E1 93 69 53 40 55 43 70 95\
    \ 8D\n   70 F0 20 8C DF B0 5D 67 CD 1B BF 96 37 D3 E3 EB\n   K^3:\n   53 C7 4E\
    \ 79 AE BC D1 C8 24 04 BF F6 D7 B1 AC BF\n   F9 C0 0E FB A8 B9 48 29 87 37 E1\
    \ BA E7 8F F7 92\n   ...\n   K*_126:\n   A3 6D BF 02 AA 0B 42 4A F2 C0 46 52 68\
    \ 8B C7 E6\n   5E F1 62 C3 B3 2F DD EF E4 92 79 5D BB 45 0B CA\n   K^126:\n  \
    \ 6C 4B D6 22 DC 40 48 0F 29 C3 90 B8 E5 D7 A7 34\n   23 4D 34 65 2C CE 4A 76\
    \ 2C FE 2A 42 C8 5B FE 9A\n   K*_127:\n   84 5F 49 3D B8 13 1D 39 36 2B BE D3\
    \ 74 8F 80 A1\n   05 A7 07 37 BA 15 72 E0 73 49 C2 67 5D 0A 28 A1\n   K^127:\n\
    \   57 F0 BD 5A B8 2A F3 6B 87 33 CF F7 22 62 B4 D0\n   F0 EE EF E1 50 74 E5 BA\
    \ 13 C1 23 68 87 36 29 A2\n   K*_128:\n   52 F2 0F 56 5C 9C 56 84 AF 69 AD 45\
    \ EE B8 DA 4E\n   7A A6 04 86 35 16 BA 98 E4 CB 46 D2 E8 9A C1 09\n   K^128:\n\
    \   9B DD 24 7D F3 25 4A 75 E0 22 68 25 68 DA 9D D5\n   C1 6D 2D 2B 4F 3F 1F 2B\
    \ 5E 99 82 7F 15 A1 4F A4\n"
- title: A.2.  Test Examples for Internal Re-keying
  contents:
  - 'A.2.  Test Examples for Internal Re-keying

    '
- title: A.2.1.  Internal Re-keying Mechanisms that Do Not Require a Master Key
  contents:
  - "A.2.1.  Internal Re-keying Mechanisms that Do Not Require a Master Key\n   CTR-ACPKM\
    \ mode with AES-256\n   ***************************\n   k = 256\n   n = 128\n\
    \   c = 64\n   N = 256\n   Initial key K:\n   00000:   88 99 AA BB CC DD EE FF\
    \ 00 11 22 33 44 55 66 77\n   00010:   FE DC BA 98 76 54 32 10 01 23 45 67 89\
    \ AB CD EF\n   Plaintext P:\n   00000:   11 22 33 44 55 66 77 00 FF EE DD CC BB\
    \ AA 99 88\n   00010:   00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A\n   00020:\
    \   11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00\n   00030:   22 33 44 55 66\
    \ 77 88 99 AA BB CC EE FF 0A 00 11\n   00040:   33 44 55 66 77 88 99 AA BB CC\
    \ EE FF 0A 00 11 22\n   00050:   44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22\
    \ 33\n   00060:   55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44\n   ICN:\n \
    \  12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12\n   23 34 45 56 67 78 89 90\
    \ 12 13 14 15 16 17 18 19\n   D_1:\n   00000:   80 81 82 83 84 85 86 87 88 89\
    \ 8A 8B 8C 8D 8E 8F\n   D_2:\n   00000:   90 91 92 93 94 95 96 97 98 99 9A 9B\
    \ 9C 9D 9E 9F\n   Section_1\n   Section key K^1:\n   00000:   88 99 AA BB CC DD\
    \ EE FF 00 11 22 33 44 55 66 77\n   00010:   FE DC BA 98 76 54 32 10 01 23 45\
    \ 67 89 AB CD EF\n   Input block CTR_1:\n   00000:   12 34 56 78 90 AB CE F0 00\
    \ 00 00 00 00 00 00 00\n   Output block G_1:\n   00000:   FD 7E F8 9A D9 7E A4\
    \ B8 8D B8 B5 1C 1C 9D 6D D0\n   Input block CTR_2:\n   00000:   12 34 56 78 90\
    \ AB CE F0 00 00 00 00 00 00 00 01\n   Output block G_2:\n   00000:   19 98 C5\
    \ 71 76 37 FB 17 11 E4 48 F0 0C 0D 60 B2\n   Section_2\n   Section key K^2:\n\
    \   00000:   F6 80 D1 21 2F A4 3D F4 EC 3A 91 DE 2A B1 6F 1B\n   00010:   36 B0\
    \ 48 8A 4F C1 2E 09 98 D2 E4 A8 88 E8 4F 3D\n   Input block CTR_3:\n   00000:\
    \   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 02\n   Output block G_3:\n  \
    \ 00000:   E4 88 89 4F B6 02 87 DB 77 5A 07 D9 2C 89 46 EA\n   Input block CTR_4:\n\
    \   00000:   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 03\n   Output block\
    \ G_4:\n   00000:   BC 4F 87 23 DB F0 91 50 DD B4 06 C3 1D A9 7C A4\n   Section_3\n\
    \   Section key K^3:\n   00000:   8E B9 7E 43 27 1A 42 F1 CA 8E E2 5F 5C C7 C8\
    \ 3B\n   00010:   1A CE 9E 5E D0 6A A5 3B 57 B9 6A CF 36 5D 24 B8\n   Input block\
    \ CTR_5:\n   00000:   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 04\n   Output\
    \ block G_5:\n   00000:   68 6F 22 7D 8F B2 9C BD 05 C8 C3 7D 22 FE 3B B7\n  \
    \ Input block CTR_6:\n   00000:   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00\
    \ 05\n   Output block G_6:\n   00000:   C0 1B F9 7F 75 6E 12 2F 80 59 55 BD DE\
    \ 2D 45 87\n   Section_4\n   Section key K^4:\n   00000:   C5 71 6C C9 67 98 BC\
    \ 2D 4A 17 87 B7 8A DF 94 AC\n   00010:   E8 16 F8 0B DB BC AD 7D 60 78 12 9C\
    \ 0C B4 02 F5\n   Block number 7:\n   Input block CTR_7:\n   00000:   12 34 56\
    \ 78 90 AB CE F0 00 00 00 00 00 00 00 06\n   Output block G_7:\n   00000:   03\
    \ DE 34 74 AB 9B 65 8A 3B 54 1E F8 BD 2B F4 7D\n   The result G = G_1 | G_2 |\
    \ G_3 | G_4 | G_5 | G_6 | G_7:\n   00000:   FD 7E F8 9A D9 7E A4 B8 8D B8 B5 1C\
    \ 1C 9D 6D D0\n   00010:   19 98 C5 71 76 37 FB 17 11 E4 48 F0 0C 0D 60 B2\n \
    \  00020:   E4 88 89 4F B6 02 87 DB 77 5A 07 D9 2C 89 46 EA\n   00030:   BC 4F\
    \ 87 23 DB F0 91 50 DD B4 06 C3 1D A9 7C A4\n   00040:   68 6F 22 7D 8F B2 9C\
    \ BD 05 C8 C3 7D 22 FE 3B B7\n   00050:   C0 1B F9 7F 75 6E 12 2F 80 59 55 BD\
    \ DE 2D 45 87\n   00060:   03 DE 34 74 AB 9B 65 8A 3B 54 1E F8 BD 2B F4 7D\n \
    \  The result ciphertext C = P (xor) MSB_{|P|}(G):\n   00000:   EC 5C CB DE 8C\
    \ 18 D3 B8 72 56 68 D0 A7 37 F4 58\n   00010:   19 89 E7 42 32 62 9D 60 99 7D\
    \ E2 4B C0 E3 9F B8\n   00020:   F5 AA BA 0B E3 64 F0 53 EE F0 BC 15 C2 76 4C\
    \ EA\n   00030:   9E 7C C3 76 BD 87 19 C9 77 0F CA 2D E2 A3 7C B5\n   00040: \
    \  5B 2B 77 1B F8 3A 05 17 BE 04 2D 82 28 FE 2A 95\n   00050:   84 4E 9F 08 FD\
    \ F7 B8 94 4C B7 AA B7 DE 3C 67 B4\n   00060:   56 B8 43 FC 32 31 DE 46 D5 AB\
    \ 14 F8 AC 09 C7 39\n   GCM-ACPKM mode with AES-128\n   ***************************\n\
    \   k = 128\n   n = 128\n   c = 32\n   N = 256\n   Initial key K:\n   00000: \
    \  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n   Additional data A:\n  \
    \ 00000:   11 22 33\n   Plaintext:\n   00000:   00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00 00 00 00\n   00010:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\
    \ 00\n   00020:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n   ICN:\n \
    \  00000:   00 00 00 00 00 00 00 00 00 00 00 00\n   Number of sections: 2\n  \
    \ Section key K^1:\n   00000:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\
    \   Section key K^2:\n   00000:   15 1A 9F B0 B6 AC C5 97 6A FB 50 31 D1 DE C8\
    \ 41\n   Encrypted GCTR_1 | GCTR_2 | GCTR_3:\n   00000:   03 88 DA CE 60 B6 A3\
    \ 92 F3 28 C2 B9 71 B2 FE 78\n   00010:   F7 95 AA AB 49 4B 59 23 F7 FD 89 FF\
    \ 94 8B C1 E0\n   00020:   D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD\n \
    \  Ciphertext C:\n   00000:   03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78\n\
    \   00010:   F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0\n   00020:   D6 B3\
    \ 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD\n   GHASH input:\n   00000:   11 22\
    \ 33 00 00 00 00 00 00 00 00 00 00 00 00 00\n   00010:   03 88 DA CE 60 B6 A3\
    \ 92 F3 28 C2 B9 71 B2 FE 78\n   00020:   F7 95 AA AB 49 4B 59 23 F7 FD 89 FF\
    \ 94 8B C1 E0\n   00030:   D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD\n \
    \  00040:   00 00 00 00 00 00 00 18 00 00 00 00 00 00 01 80\n   GHASH output S:\n\
    \   00000:   E8 ED E9 94 9A DD 55 30 B0 F4 4E F5 00 FC 3E 3C\n   Authentication\
    \ tag  T:\n   00000:   B0 0F 15 5A 60 A3 65 51 86 8B 53 A2 A4 1B 7B 66\n   The\
    \ result C | T:\n   00000:   03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78\n\
    \   00010:   F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0\n   00020:   D6 B3\
    \ 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD\n   00030:   B0 0F 15 5A 60 A3 65\
    \ 51 86 8B 53 A2 A4 1B 7B 66\n"
- title: A.2.2.  Internal Re-keying Mechanisms with a Master Key
  contents:
  - "A.2.2.  Internal Re-keying Mechanisms with a Master Key\n   CTR-ACPKM-Master\
    \ mode with AES-256\n   **********************************\n   k = 256\n   n =\
    \ 128\n   c for CTR-ACPKM mode = 64\n   c for CTR-ACPKM-Master mode = 64\n   N\
    \ = 256\n   T* = 512\n   Initial key K:\n   00000:   88 99 AA BB CC DD EE FF 00\
    \ 11 22 33 44 55 66 77\n   00010:   FE DC BA 98 76 54 32 10 01 23 45 67 89 AB\
    \ CD EF\n   Initial vector ICN:\n   00000:   12 34 56 78 90 AB CE F0 A1 B2 C3\
    \ D4 E5 F0 01 12\n   Plaintext P:\n   00000:   11 22 33 44 55 66 77 00 FF EE DD\
    \ CC BB AA 99 88\n   00010:   00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A\n\
    \   00020:   11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00\n   00030:   22 33\
    \ 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11\n   00040:   33 44 55 66 77 88 99\
    \ AA BB CC EE FF 0A 00 11 22\n   00050:   44 55 66 77 88 99 AA BB CC EE FF 0A\
    \ 00 11 22 33\n   00060:   55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44\n \
    \  K^1 | K^2 | K^3 | K^4:\n   00000:   9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4\
    \ 90 74 64\n   00010:   39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60\n   00020:\
    \   77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0\n   00030:   AB 6B 59 EE 92\
    \ 49 05 B3 AB C7 A4 E3 69 65 76 C3\n   00040:   E8 76 2B 30 8B 08 EB CE 3E 93\
    \ 9A C2 C0 3E 76 D4\n   00050:   60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A\
    \ 94\n   00060:   F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9\n   00070: \
    \  2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12\n   Section_1\n   K^1:\n  \
    \ 00000:   9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64\n   00010:   39 FE\
    \ 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60\n   Input block CTR_1:\n   00000:\
    \   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 00\n   Output block G_1:\n  \
    \ 00000:   8C A2 B6 82 A7 50 65 3F 8E BF 08 E7 9F 99 4D 5C\n   Input block CTR_2:\n\
    \   00000:   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 01\n   Output block\
    \ G_2:\n   00000:   F6 A6 A5 BA 58 14 1E ED 23 DC 31 68 D2 35 89 A1\n   Section_2\n\
    \   K^2:\n   00000:   77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0\n   00010:\
    \   AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3\n   Input block CTR_3:\n \
    \  00000:   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 02\n   Output block G_3:\n\
    \   00000:   4A 07 5F 86 05 87 72 94 1D 8E 7D F8 32 F4 23 71\n   Input block CTR_4:\n\
    \   00000:   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 03\n   Output block\
    \ G_4:\n   00000:   23 35 66 AF 61 DD FE A7 B1 68 3F BA B0 52 4A D7\n   Section_3\n\
    \   K^3:\n   00000:   E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4\n   00010:\
    \   60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94\n   Input block CTR_5:\n \
    \  00000:   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 04\n   Output block G_5:\n\
    \   00000:   A8 09 6D BC E8 BB 52 FC DE 6E 03 70 C1 66 95 E8\n   Input block CTR_6:\n\
    \   00000:   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 05\n   Output block\
    \ G_6:\n   00000:   C6 E3 6E 8E 5B 82 AA C4 A6 6C 14 8D B1 F6 9B EF\n   Section_4\n\
    \   K^4:\n   00000:   F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9\n   00010:\
    \   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12\n   Input block CTR_7:\n \
    \  00000:   12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 06\n   Output block G_7:\n\
    \   00000:   82 2B E9 07 96 37 44 95 75 36 3F A7 07 F8 40 22\n   The result G\
    \ = G_1 | G_2 | G_3 | G_4 | G_5 | G_6 | G_7:\n   00000:   8C A2 B6 82 A7 50 65\
    \ 3F 8E BF 08 E7 9F 99 4D 5C\n   00010:   F6 A6 A5 BA 58 14 1E ED 23 DC 31 68\
    \ D2 35 89 A1\n   00020:   4A 07 5F 86 05 87 72 94 1D 8E 7D F8 32 F4 23 71\n \
    \  00030:   23 35 66 AF 61 DD FE A7 B1 68 3F BA B0 52 4A D7\n   00040:   A8 09\
    \ 6D BC E8 BB 52 FC DE 6E 03 70 C1 66 95 E8\n   00050:   C6 E3 6E 8E 5B 82 AA\
    \ C4 A6 6C 14 8D B1 F6 9B EF\n   00060:   82 2B E9 07 96 37 44 95 75 36 3F A7\
    \ 07 F8 40 22\n   The result ciphertext C = P (xor) MSB_{|P|}(G):\n   00000: \
    \  9D 80 85 C6 F2 36 12 3F 71 51 D5 2B 24 33 D4 D4\n   00010:   F6 B7 87 89 1C\
    \ 41 78 9A AB 45 9B D3 1E DB 76 AB\n   00020:   5B 25 6C C2 50 E1 05 1C 84 24\
    \ C6 34 DC 0B 29 71\n   00030:   01 06 22 FA 07 AA 76 3E 1B D3 F3 54 4F 58 4A\
    \ C6\n   00040:   9B 4D 38 DA 9F 33 CB 56 65 A2 ED 8F CB 66 84 CA\n   00050: \
    \  82 B6 08 F9 D3 1B 00 7F 6A 82 EB 87 B1 E7 B9 DC\n   00060:   D7 4D 9E 8F 0F\
    \ 9D FF 59 9B C9 35 A7 16 DA 73 66\n   GCM-ACPKM-Master mode with AES-256\n  \
    \ **********************************\n   k = 192\n   n = 128\n   c for the CTR-ACPKM\
    \ mode = 64\n   c for the GCM-ACPKM-Master mode = 32\n   T* = 384\n   N = 256\n\
    \   Initial key K:\n   00000:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\
    \   00010:   00 00 00 00 00 00 00 00\n   Additional data A:\n   00000:   11 22\
    \ 33\n   Plaintext:\n   00000:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\
    \ 00\n   00010:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n   00020: \
    \  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n   00030:   00 00 00 00 00\
    \ 00 00 00 00 00 00 00 00 00 00 00\n   00040:   00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00 00 00 00\n   ICN:\n   00000:   00 00 00 00 00 00 00 00 00 00 00 00\n\
    \   Number of sections: 3\n   K^1 | K^2 | K^3:\n   00000:   93 BA AF FB 35 FB\
    \ E7 39 C1 7C 6A C2 2E EC F1 8F\n   00010:   7B 89 F0 BF 8B 18 07 05 96 48 68\
    \ 9F 36 A7 65 CC\n   00020:   CD 5D AC E2 0D 47 D9 18 D7 86 D0 41 A8 3B AB 99\n\
    \   00030:   F5 F8 B1 06 D2 71 78 B1 B0 08 C9 99 0B 72 E2 87\n   00040:   5A 2D\
    \ 3C BE F1 6E 67 3C\n   Encrypted GCTR_1 | ... | GCTR_5\n   00000:   43 FA 71\
    \ 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52\n   00010:   69 9B 9E 1B 43 24 B7 52\
    \ 95 74 E7 90 F2 BE 60 E8\n   00020:   11 62 C9 90 2A 2B 77 7F D9 6A D6 1A 99\
    \ E0 C6 DE\n   00030:   4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14\n   00040:\
    \   40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08\n   Ciphertext C:\n   00000:\
    \   43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52\n   00010:   69 9B 9E 1B 43\
    \ 24 B7 52 95 74 E7 90 F2 BE 60 E8\n   00020:   11 62 C9 90 2A 2B 77 7F D9 6A\
    \ D6 1A 99 E0 C6 DE\n   00030:   4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF\
    \ 14\n   00040:   40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08\n   GHASH input:\n\
    \   00000:   11 22 33 00 00 00 00 00 00 00 00 00 00 00 00 00\n   00010:   43 FA\
    \ 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52\n   00020:   69 9B 9E 1B 43 24 B7\
    \ 52 95 74 E7 90 F2 BE 60 E8\n   00030:   11 62 C9 90 2A 2B 77 7F D9 6A D6 1A\
    \ 99 E0 C6 DE\n   00040:   4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14\n \
    \  00050:   40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08\n   00060:   00 00\
    \ 00 00 00 00 00 18 00 00 00 00 00 00 02 80\n   GHASH output S:\n   00000:   6E\
    \ A3 4B D5 6A C5 40 B7 3E 55 D5 86 D1 CC 09 7D\n   Authentication tag  T:\n  \
    \ 00050:   CC 3A BA 11 8C E7 85 FD 77 78 94 D4 B5 20 69 F8\n   The result C |\
    \ T:\n   00000:   43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52\n   00010: \
    \  69 9B 9E 1B 43 24 B7 52 95 74 E7 90 F2 BE 60 E8\n   00020:   11 62 C9 90 2A\
    \ 2B 77 7F D9 6A D6 1A 99 E0 C6 DE\n   00030:   4B 91 D4 29 E3 1A 8C 11 AF F0\
    \ BC 47 F6 80 AF 14\n   00040:   40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70\
    \ 08\n   00050:   CC 3A BA 11 8C E7 85 FD 77 78 94 D4 B5 20 69 F8\n   CBC-ACPKM-Master\
    \ mode with AES-256\n   **********************************\n   k = 256\n   n =\
    \ 128\n   c for the CTR-ACPKM mode = 64\n   N = 256\n   T* = 512\n   Initial key\
    \ K:\n   00000:   88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77\n   00010: \
    \  FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF\n   Initial vector IV:\n  \
    \ 00000:   12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12\n   Plaintext P:\n\
    \   00000:   11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88\n   00010:   00 11\
    \ 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A\n   00020:   11 22 33 44 55 66 77\
    \ 88 99 AA BB CC EE FF 0A 00\n   00030:   22 33 44 55 66 77 88 99 AA BB CC EE\
    \ FF 0A 00 11\n   00040:   33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22\n \
    \  00050:   44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33\n   00060:   55 66\
    \ 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44\n   K^1 | K^2 | K^3 | K^4:\n   00000:\
    \   9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64\n   00010:   39 FE 50 6D 4B\
    \ 86 9B 21 03 A3 B6 A4 79 28 3C 60\n   00020:   77 91 17 50 E0 D1 77 E5 9A 13\
    \ 78 2B F1 89 08 D0\n   00030:   AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76\
    \ C3\n   00040:   E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4\n   00050: \
    \  60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94\n   00060:   F2 EE 91 45 6B\
    \ DC 3D E4 91 2C 87 C3 29 CF 31 A9\n   00070:   2F 20 2E 5A C4 9A 2A 65 31 33\
    \ D6 74 8C 4F F9 12\n   Section_1\n   K^1:\n   00000:   9F 10 BB F1 3A 79 FB BD\
    \ 4A 4C A8 64 C4 90 74 64\n   00010:   39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79\
    \ 28 3C 60\n   Plaintext block P_1:\n   00000:   11 22 33 44 55 66 77 00 FF EE\
    \ DD CC BB AA 99 88\n   Input block P_1 (xor) C_0:\n   00000:   03 16 65 3C C5\
    \ CD B9 F0 5E 5C 1E 18 5E 5A 98 9A\n   Output block C_1:\n   00000:   59 CB 5B\
    \ CA C2 69 2C 60 0D 46 03 A0 C7 40 C9 7C\n   Plaintext block P_2:\n   00000: \
    \  00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A\n   Input block P_2 (xor) C_1:\n\
    \   00000:   59 DA 79 F9 86 3C 4A 17 85 DF A9 1B 0B AE 36 76\n   Output block\
    \ C_2:\n   00000:   80 B6 02 74 54 8B F7 C9 78 1F A1 05 8B F6 8B 42\n   Section_2\n\
    \   K^2:\n   00000:   77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0\n   00010:\
    \   AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3\n   Plaintext block P_3:\n\
    \   00000:   11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00\n   Input block P_3\
    \ (xor) C_2:\n   00000:   91 94 31 30 01 ED 80 41 E1 B5 1A C9 65 09 81 42\n  \
    \ Output block C_3:\n   00000:   8C 24 FB CF 68 15 B1 AF 65 FE 47 75 95 B4 97\
    \ 59\n   Plaintext block P_4:\n   00000:   22 33 44 55 66 77 88 99 AA BB CC EE\
    \ FF 0A 00 11\n   Input block P_4 (xor) C_3:\n   00000:   AE 17 BF 9A 0E 62 39\
    \ 36 CF 45 8B 9B 6A BE 97 48\n   Output block C_4:\n   00000:   19 65 A5 00 58\
    \ 0D 50 23 72 1B E9 90 E1 83 30 E9\n   Section_3\n   K^3:\n   00000:   E8 76 2B\
    \ 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4\n   00010:   60 9A AB D9 15 33 13 D3\
    \ CF D3 94 E7 75 DF 3A 94\n   Plaintext block P_5:\n   00000:   33 44 55 66 77\
    \ 88 99 AA BB CC EE FF 0A 00 11 22\n   Input block P_5 (xor) C_4:\n   00000: \
    \  2A 21 F0 66 2F 85 C9 89 C9 D7 07 6F EB 83 21 CB\n   Output block C_5:\n   00000:\
    \   56 D8 34 F4 6F 0F 4D E6 20 53 A9 5C B5 F6 3C 14\n   Plaintext block P_6:\n\
    \   00000:   44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33\n   Input block P_6\
    \ (xor) C_5:\n   00000:   12 8D 52 83 E7 96 E7 5D EC BD 56 56 B5 E7 1E 27\n  \
    \ Output block C_6:\n   00000:   66 68 2B 8B DD 6E B2 7E DE C7 51 D6 2F 45 A5\
    \ 45\n   Section_4\n   K^4:\n   00000:   F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29\
    \ CF 31 A9\n   00010:   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12\n   Plaintext\
    \ block P_7:\n   00000:   55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44\n  \
    \ Input block P_7 (xor) C_6:\n   00000:   33 0E 5C 03 44 C4 09 B2 30 38 5B D6\
    \ 3E 67 96 01\n   Output block C_7:\n   00000:   7F 4D 87 F9 CA E9 56 09 79 C4\
    \ FA FE 34 0B 45 34\n   Ciphertext C:\n   00000:   59 CB 5B CA C2 69 2C 60 0D\
    \ 46 03 A0 C7 40 C9 7C\n   00010:   80 B6 02 74 54 8B F7 C9 78 1F A1 05 8B F6\
    \ 8B 42\n   00020:   8C 24 FB CF 68 15 B1 AF 65 FE 47 75 95 B4 97 59\n   00030:\
    \   19 65 A5 00 58 0D 50 23 72 1B E9 90 E1 83 30 E9\n   00040:   56 D8 34 F4 6F\
    \ 0F 4D E6 20 53 A9 5C B5 F6 3C 14\n   00050:   66 68 2B 8B DD 6E B2 7E DE C7\
    \ 51 D6 2F 45 A5 45\n   00060:   7F 4D 87 F9 CA E9 56 09 79 C4 FA FE 34 0B 45\
    \ 34\n   CFB-ACPKM-Master mode with AES-256\n   **********************************\n\
    \   k = 256\n   n = 128\n   c for the CTR-ACPKM mode = 64\n   N = 256\n   T* =\
    \ 512\n   Initial key K:\n   00000:   88 99 AA BB CC DD EE FF 00 11 22 33 44 55\
    \ 66 77\n   00010:   FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF\n   Initial\
    \ vector IV:\n   00000:   12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12\n  \
    \ Plaintext P:\n   00000:   11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88\n\
    \   00010:   00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A\n   00020:   11 22\
    \ 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00\n   00030:   22 33 44 55 66 77 88\
    \ 99 AA BB CC EE FF 0A 00 11\n   00040:   33 44 55 66 77 88 99 AA BB CC EE FF\
    \ 0A 00 11 22\n   00050:   44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33\n \
    \  00060:   55 66 77 88 99 AA BB CC\n   K^1 | K^2 | K^3 | K^4\n   00000:   9F\
    \ 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64\n   00010:   39 FE 50 6D 4B 86\
    \ 9B 21 03 A3 B6 A4 79 28 3C 60\n   00020:   77 91 17 50 E0 D1 77 E5 9A 13 78\
    \ 2B F1 89 08 D0\n   00030:   AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3\n\
    \   00040:   E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4\n   00050:   60 9A\
    \ AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94\n   00060:   F2 EE 91 45 6B DC 3D\
    \ E4 91 2C 87 C3 29 CF 31 A9\n   00070:   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74\
    \ 8C 4F F9 12\n   Section_1\n   K^1:\n   00000:   9F 10 BB F1 3A 79 FB BD 4A 4C\
    \ A8 64 C4 90 74 64\n   00010:   39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C\
    \ 60\n   Plaintext block P_1:\n   00000:   11 22 33 44 55 66 77 00 FF EE DD CC\
    \ BB AA 99 88\n   Encrypted block E_{K^1}(C_0):\n   00000:   1C 39 9D 59 F8 5D\
    \ 91 91 A9 D2 12 9F 63 15 90 03\n   Output block C_1 = E_{K^1}(C_0) (xor) P_1:\n\
    \   00000:   0D 1B AE 1D AD 3B E6 91 56 3C CF 53 D8 BF 09 8B\n   Plaintext block\
    \ P_2:\n   00000:   00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A\n   Encrypted\
    \ block E_{K^1}(C_1):\n   00000:   6B A2 C5 42 52 69 C6 0B 15 14 06 87 90 46 F6\
    \ 2E\n   Output block C_2 = E_{K^1}(C_1) (xor) P_2:\n   00000:   6B B3 E7 71 16\
    \ 3C A0 7C 9D 8D AC 3C 5C A8 09 24\n   Section_2\n   K^2:\n   00000:   77 91 17\
    \ 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0\n   00010:   AB 6B 59 EE 92 49 05 B3\
    \ AB C7 A4 E3 69 65 76 C3\n   Plaintext block P_3:\n   00000:   11 22 33 44 55\
    \ 66 77 88 99 AA BB CC EE FF 0A 00\n   Encrypted block E_{K^2}(C_2):\n   00000:\
    \   95 45 5F DB C3 9E 0A 13 9F CB 10 F5 BD 79 A3 88\n   Output block C_3 = E_{K^2}(C_2)\
    \ (xor) P_3:\n   00000:   84 67 6C 9F 96 F8 7D 9B 06 61 AB 39 53 86 A9 88\n  \
    \ Plaintext block P_4:\n   00000:   22 33 44 55 66 77 88 99 AA BB CC EE FF 0A\
    \ 00 11\n   Encrypted block E_{K^2}(C_3):\n   00000:   E0 AA 32 5D 80 A4 47 95\
    \ BA 42 BF 63 F8 4A C8 B2\n   Output block C_4 = E_{K^2}(C_3) (xor) P_4:\n   00000:\
    \   C2 99 76 08 E6 D3 CF 0C 10 F9 73 8D 07 40 C8 A3\n   Section_3\n   K^3:\n \
    \  00000:   E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4\n   00010:   60 9A\
    \ AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94\n   Plaintext block P_5:\n   00000:\
    \   33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22\n   Encrypted block E_{K^3}(C_4):\n\
    \   00000:   FE 42 8C 70 C2 51 CE 13 36 C1 BF 44 F8 49 66 89\n   Output block\
    \ C_5 = E_{K^3}(C_4) (xor) P_5:\n   00000:   CD 06 D9 16 B5 D9 57 B9 8D 0D 51\
    \ BB F2 49 77 AB\n   Plaintext block P_6:\n   00000:   44 55 66 77 88 99 AA BB\
    \ CC EE FF 0A 00 11 22 33\n   Encrypted block E_{K^3}(C_5):\n   00000:   01 24\
    \ 80 87 86 18 A5 43 11 0A CC B5 0A E5 02 A3\n   Output block C_6 = E_{K^3}(C_5)\
    \ (xor) P_6:\n   00000:   45 71 E6 F0 0E 81 0F F8 DD E4 33 BF 0A F4 20 90\n  \
    \ Section_4\n   K^4:\n   00000:   F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31\
    \ A9\n   00010:   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12\n   Plaintext\
    \ block P_7:\n   00000:   55 66 77 88 99 AA BB CC\n   Encrypted block MSB_{|P_7|}(E_{K^4}(C_6)):\n\
    \   00000:   97 5C 96 37 55 1E 8C 7F\n   Output block C_7 = MSB_{|P_7|}(E_{K^4}(C_6))\
    \ (xor) P_7\n   00000:   C2 3A E1 BF CC B4 37 B3\n   Ciphertext C:\n   00000:\
    \   0D 1B AE 1D AD 3B E6 91 56 3C CF 53 D8 BF 09 8B\n   00010:   6B B3 E7 71 16\
    \ 3C A0 7C 9D 8D AC 3C 5C A8 09 24\n   00020:   84 67 6C 9F 96 F8 7D 9B 06 61\
    \ AB 39 53 86 A9 88\n   00030:   C2 99 76 08 E6 D3 CF 0C 10 F9 73 8D 07 40 C8\
    \ A3\n   00040:   CD 06 D9 16 B5 D9 57 B9 8D 0D 51 BB F2 49 77 AB\n   00050: \
    \  45 71 E6 F0 0E 81 0F F8 DD E4 33 BF 0A F4 20 90\n   00060:   C2 3A E1 BF CC\
    \ B4 37 B3\n   OMAC-ACPKM-Master mode with AES-256\n   ***********************************\n\
    \   k = 256\n   n = 128\n   c for the CTR-ACPKM mode = 64\n   N = 256\n   T* =\
    \ 768\n   Initial key K:\n   00000:   88 99 AA BB CC DD EE FF 00 11 22 33 44 55\
    \ 66 77\n   00010:   FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF\n   Plaintext\
    \ M:\n   00000:   11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88\n   00010: \
    \  00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A\n   00020:   11 22 33 44 55\
    \ 66 77 88 99 AA BB CC EE FF 0A 00\n   00030:   22 33 44 55 66 77 88 99 AA BB\
    \ CC EE FF 0A 00 11\n   00040:   33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11\
    \ 22\n   K^1 | K^1_1 | K^2 | K^2_1 | K^3 | K^3_1:\n   00000:   9F 10 BB F1 3A\
    \ 79 FB BD 4A 4C A8 64 C4 90 74 64\n   00010:   39 FE 50 6D 4B 86 9B 21 03 A3\
    \ B6 A4 79 28 3C 60\n   00020:   77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08\
    \ D0\n   00030:   AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3\n   00040: \
    \  9D CC 66 42 0D FF 45 5B 21 F3 93 F0 D4 D6 6E 67\n   00050:   BB 1B 06 0B 87\
    \ 66 6D 08 7A 9D A7 49 55 C3 5B 48\n   00060:   F2 EE 91 45 6B DC 3D E4 91 2C\
    \ 87 C3 29 CF 31 A9\n   00070:   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9\
    \ 12\n   00080:   78 21 C7 C7 6C BD 79 63 56 AC F8 8E 69 6A 00 07\n   Section_1\n\
    \   K^1:\n   00000:   9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64\n   00010:\
    \   39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60\n   K^1_1:\n   00000:   77\
    \ 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0\n   Plaintext block M_1:\n   00000:\
    \   11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88\n   Input block M_1 (xor)\
    \ C_0:\n   00000:   11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88\n   Output\
    \ block C_1:\n   00000:   0B A5 89 BF 55 C1 15 42 53 08 89 76 A0 FE 24 3E\n  \
    \ Plaintext block M_2:\n   00000:   00 11 22 33 44 55 66 77 88 99 AA BB CC EE\
    \ FF 0A\n   Input block M_2 (xor) C_1:\n   00000:   0B B4 AB 8C 11 94 73 35 DB\
    \ 91 23 CD 6C 10 DB 34\n   Output block C_2:\n   00000:   1C 53 DD A3 6D DC E1\
    \ 17 ED 1F 14 09 D8 6A F3 2C\n   Section_2\n   K^2:\n   00000:   AB 6B 59 EE 92\
    \ 49 05 B3 AB C7 A4 E3 69 65 76 C3\n   00010:   9D CC 66 42 0D FF 45 5B 21 F3\
    \ 93 F0 D4 D6 6E 67\n   K^2_1:\n   00000:   BB 1B 06 0B 87 66 6D 08 7A 9D A7 49\
    \ 55 C3 5B 48\n   Plaintext block M_3:\n   00000:   11 22 33 44 55 66 77 88 99\
    \ AA BB CC EE FF 0A 00\n   Input block M_3 (xor) C_2:\n   00000:   0D 71 EE E7\
    \ 38 BA 96 9F 74 B5 AF C5 36 95 F9 2C\n   Output block C_3:\n   00000:   4E D4\
    \ BC A6 CE 6D 6D 16 F8 63 85 13 E0 48 59 75\n   Plaintext block M_4:\n   00000:\
    \   22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11\n   Input block M_4 (xor)\
    \ C_3:\n   00000:   6C E7 F8 F3 A8 1A E5 8F 52 D8 49 FD 1F 42 59 64\n   Output\
    \ block C_4:\n   00000:   B6 83 E3 96 FD 30 CD 46 79 C1 8B 24 03 82 1D 81\n  \
    \ Section_3\n   K^3:\n   00000:   F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31\
    \ A9\n   00010:   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12\n   K^3_1:\n\
    \   00000:   78 21 C7 C7 6C BD 79 63 56 AC F8 8E 69 6A 00 07\n   MSB1(K1) == 0\
    \ -> K2 = K1 << 1\n   K1:\n   00000:   78 21 C7 C7 6C BD 79 63 56 AC F8 8E 69\
    \ 6A 00 07\n   K2:\n   00000:   F0 43 8F 8E D9 7A F2 C6 AD 59 F1 1C D2 D4 00 0E\n\
    \   Plaintext M_5:\n   00000:   33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22\n\
    \   Using K1, padding is not required\n   Input block M_5 (xor) C_4:\n   00000:\
    \   FD E6 71 37 E6 05 2D 8F 94 A1 9D 55 60 E8 0C A4\n   Output block C_5:\n  \
    \ 00000:   B3 AD B8 92 18 32 05 4C 09 21 E7 B8 08 CF A0 B8\n   Message authentication\
    \ code T:\n   00000:   B3 AD B8 92 18 32 05 4C 09 21 E7 B8 08 CF A0 B8\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   We thank Mihir Bellare, Scott Fluhrer, Dorothy Cooley, Yoav\
    \ Nir, Jim\n   Schaad, Paul Hoffman, Dmitry Belyavsky, Yaron Sheffer, Alexey\n\
    \   Melnikov, and Spencer Dawkins for their useful comments.\n"
- title: Contributors
  contents:
  - "Contributors\n   Russ Housley\n   Vigil Security, LLC\n   housley@vigilsec.com\n\
    \   Evgeny Alekseev\n   CryptoPro\n   alekseev@cryptopro.ru\n   Ekaterina Smyshlyaeva\n\
    \   CryptoPro\n   ess@cryptopro.ru\n   Shay Gueron\n   University of Haifa, Israel\n\
    \   Intel Corporation, Israel Development Center, Israel\n   shay.gueron@gmail.com\n\
    \   Daniel Fox Franke\n   Akamai Technologies\n   dfoxfranke@gmail.com\n   Lilia\
    \ Ahmetzyanova\n   CryptoPro\n   lah@cryptopro.ru\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Stanislav Smyshlyaev (editor)\n   CryptoPro\n   18, Suschevskiy\
    \ val\n   Moscow  127018\n   Russian Federation\n   Phone: +7 (495) 995-48-20\n\
    \   Email: svs@cryptopro.ru\n"
