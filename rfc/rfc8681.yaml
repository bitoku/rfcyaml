- contents:
  - ''
  title: __initial_text__
- contents:
  - "Sliding Window Random Linear Code (RLC) Forward Erasure Correction (FEC)\n                          Schemes
    for FECFRAME\n"
  title: Sliding Window Random Linear Code (RLC) Forward Erasure Correction (FEC)
- contents:
  - "Abstract\n   This document describes two fully specified Forward Erasure\n   Correction
    (FEC) Schemes for Sliding Window Random Linear Codes\n   (RLC), one for RLC over
    the Galois Field (a.k.a., Finite Field)\n   GF(2), a second one for RLC over the
    Galois Field GF(2^(8)), each\n   time with the possibility of controlling the
    code density.  They can\n   protect arbitrary media streams along the lines defined
    by FECFRAME\n   extended to Sliding Window FEC Codes.  These Sliding Window FEC
    Codes\n   rely on an encoding window that slides over the source symbols,\n   generating
    new repair symbols whenever needed.  Compared to block FEC\n   codes, these Sliding
    Window FEC Codes offer key advantages with real-\n   time flows in terms of reduced
    FEC-related latency while often\n   providing improved packet erasure recovery
    capabilities.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8681.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction\n     1.1.  Limits of Block Codes with
    Real-Time Flows\n     1.2.  Lower Latency and Better Protection of Real-Time Flows
    with\n           the Sliding Window RLC Codes\n     1.3.  Small Transmission Overheads
    with the Sliding Window RLC\n           FEC Scheme\n     1.4.  Document Organization\n
    \  2.  Definitions and Abbreviations\n   3.  Common Procedures\n     3.1.  Codec
    Parameters\n     3.2.  ADU, ADUI, and Source Symbols Mappings\n     3.3.  Encoding
    Window Management\n     3.4.  Source Symbol Identification\n     3.5.  Pseudorandom
    Number Generator (PRNG)\n     3.6.  Coding Coefficients Generation Function\n
    \    3.7.  Finite Field Operations\n       3.7.1.  Finite Field Definitions\n
    \      3.7.2.  Linear Combination of Source Symbol Computation\n   4.  Sliding
    Window RLC FEC Scheme over GF(2^(8)) for Arbitrary\n           Packet Flows\n
    \    4.1.  Formats and Codes\n       4.1.1.  FEC Framework Configuration Information\n
    \      4.1.2.  Explicit Source FEC Payload ID\n       4.1.3.  Repair FEC Payload
    ID\n     4.2.  Procedures\n   5.  Sliding Window RLC FEC Scheme over GF(2) for
    Arbitrary Packet\n           Flows\n     5.1.  Formats and Codes\n       5.1.1.
    \ FEC Framework Configuration Information\n       5.1.2.  Explicit Source FEC
    Payload ID\n       5.1.3.  Repair FEC Payload ID\n     5.2.  Procedures\n   6.
    \ FEC Code Specification\n     6.1.  Encoding Side\n     6.2.  Decoding Side\n
    \  7.  Security Considerations\n     7.1.  Attacks Against the Data Flow\n       7.1.1.
    \ Access to Confidential Content\n       7.1.2.  Content Corruption\n     7.2.
    \ Attacks Against the FEC Parameters\n     7.3.  When Several Source Flows are
    to be Protected Together\n     7.4.  Baseline Secure FEC Framework Operation\n
    \    7.5.  Additional Security Considerations for Numerical\n           Computations\n
    \  8.  Operations and Management Considerations\n     8.1.  Operational Recommendations:
    Finite Field GF(2) Versus\n           GF(2^(8))\n     8.2.  Operational Recommendations:
    Coding Coefficients Density\n           Threshold\n   9.  IANA Considerations\n
    \  10. References\n     10.1.  Normative References\n     10.2.  Informative References\n
    \  Appendix A.  TinyMT32 Validation Criteria (Normative)\n   Appendix B.  Assessing
    the PRNG Adequacy (Informational)\n   Appendix C.  Possible Parameter Derivation
    (Informational)\n     C.1.  Case of a CBR Real-Time Flow\n     C.2.  Other Types
    of Real-Time Flow\n     C.3.  Case of a Non-Real-Time Flow\n   Appendix D.  Decoding
    Beyond Maximum Latency Optimization\n           (Informational)\n   Acknowledgments\n
    \  Authors' Addresses\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Application-Level Forward Erasure Correction (AL-FEC) codes,
    or\n   simply FEC codes, are a key element of communication systems.  They\n   are
    used to recover from packet losses (or erasures) during content\n   delivery sessions
    to a potentially large number of receivers\n   (multicast/broadcast transmissions).
    \ This is the case with the File\n   Delivery over Unidirectional Transport (FLUTE)/Asynchronous
    Layered\n   Coding (ALC) protocol [RFC6726] when used for reliable file transfers\n
    \  over lossy networks, and the FECFRAME protocol [RFC6363] when used\n   for
    reliable continuous media transfers over lossy networks.\n   The present document
    only focuses on the FECFRAME protocol, which is\n   used in multicast/broadcast
    delivery mode, particularly for content\n   that features stringent real-time
    constraints: each source packet has\n   a maximum validity period after which
    it will not be considered by\n   the destination application.\n"
  - contents:
    - "1.1.  Limits of Block Codes with Real-Time Flows\n   With FECFRAME, there is
      a single FEC encoding point (either an end\n   host/server (source) or a middlebox)
      and a single FEC decoding point\n   per receiver (either an end host (receiver)
      or middlebox).  In this\n   context, currently standardized AL-FEC codes for
      FECFRAME like Reed-\n   Solomon [RFC6865], LDPC-Staircase [RFC6816], or Raptor/RaptorQ\n
      \  [RFC6681], are all linear block codes: they require the data flow to\n   be
      segmented into blocks of a predefined maximum size.\n   To define this block
      size, it is required to find an appropriate\n   balance between robustness and
      decoding latency: the larger the block\n   size, the higher the robustness (e.g.,
      in case of long packet erasure\n   bursts), but also the higher the maximum
      decoding latency (i.e., the\n   maximum time required to recover a lost (erased)
      packet thanks to FEC\n   protection).  Therefore, with a multicast/broadcast
      session where\n   different receivers experience different packet loss rates,
      the block\n   size should be chosen by considering the worst communication\n
      \  conditions one wants to support, but without exceeding the desired\n   maximum
      decoding latency.  This choice then impacts the FEC-related\n   latency of all
      receivers, even those experiencing a good\n   communication quality, since no
      FEC encoding can happen until all the\n   source data of the block is available
      at the sender, which directly\n   depends on the block size.\n"
    title: 1.1.  Limits of Block Codes with Real-Time Flows
  - contents:
    - "1.2.  Lower Latency and Better Protection of Real-Time Flows with the\n      Sliding
      Window RLC Codes\n   This document introduces two fully specified FEC schemes
      that do not\n   follow the block code approach: the Sliding Window Random Linear\n
      \  Codes (RLC) over either Galois Fields (a.k.a., Finite Fields) GF(2)\n   (the
      \"binary case\") or GF(2^(8)), each time with the possibility of\n   controlling
      the code density.  These FEC schemes are used to protect\n   arbitrary media
      streams along the lines defined by FECFRAME extended\n   to Sliding Window FEC
      Codes [RFC8680].  These FEC schemes and, more\n   generally, Sliding Window
      FEC Codes are recommended, for instance,\n   with media that feature real-time
      constraints sent within a\n   multicast/broadcast session [Roca17].\n   The
      RLC codes belong to the broad class of Sliding Window AL-FEC\n   Codes (a.k.a.,
      convolutional codes) [RFC8406].  The encoding process\n   is based on an encoding
      window that slides over the set of source\n   packets (in fact source symbols
      as we will see in Section 3.2), this\n   window being either of fixed size or
      variable size (a.k.a., an\n   elastic window).  Repair symbols are generated
      on-the-fly, by\n   computing a random linear combination of the source symbols
      present\n   in the current encoding window, and passed to the transport layer.\n
      \  At the receiver, a linear system is managed from the set of received\n   source
      and repair packets.  New variables (representing source\n   symbols) and equations
      (representing the linear combination carried\n   by each repair symbol received)
      are added upon receiving new packets.\n   Variables and the equations they are
      involved in are removed when\n   they are too old with respect to their validity
      period (real-time\n   constraints).  Lost source symbols are then recovered
      thanks to this\n   linear system whenever its rank permits to solve it (at least\n
      \  partially).\n   The protection of any multicast/broadcast session needs to
      be\n   dimensioned by considering the worst communication conditions one\n   wants
      to support.  This is also true with RLC (more generally, any\n   sliding window)
      code.  However, the receivers experiencing a good to\n   medium communication
      quality will observe a reduced FEC-related\n   latency compared to block codes
      [Roca17] since an isolated lost\n   source packet is quickly recovered with
      the following repair packet.\n   On the opposite, with a block code, recovering
      an isolated lost\n   source packet always requires waiting for the first repair
      packet to\n   arrive after the end of the block.  Additionally, under certain\n
      \  situations (e.g., with a limited FEC-related latency budget and with\n   constant
      bitrate transmissions after FECFRAME encoding), Sliding\n   Window Codes can
      more efficiently achieve a target transmission\n   quality (e.g., measured by
      the residual loss after FEC decoding) by\n   sending fewer repair packets (i.e.,
      higher code rate) than block\n   codes.\n"
    title: 1.2.  Lower Latency and Better Protection of Real-Time Flows with the
  - contents:
    - "1.3.  Small Transmission Overheads with the Sliding Window RLC FEC\n      Scheme\n
      \  The Sliding Window RLC FEC scheme is designed to limit the packet\n   header
      overhead.  The main requirement is that each repair packet\n   header must enable
      a receiver to reconstruct the set of source\n   symbols plus the associated
      coefficients used during the encoding\n   process.  In order to minimize packet
      overhead, the set of source\n   symbols in the encoding window as well as the
      set of coefficients\n   over GF(2^(m)) (where m is 1 or 8, depending on the
      FEC scheme) used\n   in the linear combination are not individually listed in
      the repair\n   packet header.  Instead, each FEC Repair Packet header contains:\n
      \  *  the Encoding Symbol Identifier (ESI) of the first source symbol in\n      the
      encoding window as well as the number of symbols (since this\n      number may
      vary with a variable size, elastic window).  These two\n      pieces of information
      enable each receiver to reconstruct the set\n      of source symbols considered
      during encoding, the only constraint\n      being that there cannot be any gap;\n
      \  *  the seed and density threshold parameters used by a coding\n      coefficients
      generation function (Section 3.6).  These two pieces\n      of information enable
      each receiver to generate the same set of\n      coding coefficients over GF(2^(m))
      as the sender;\n   Therefore, no matter the number of source symbols present
      in the\n   encoding window, each FEC Repair Packet features a fixed 64-bit long\n
      \  header, called Repair FEC Payload ID (Figure 8).  Similarly, each FEC\n   Source
      Packet features a fixed 32-bit long trailer, called Explicit\n   Source FEC
      Payload ID (Figure 6), that contains the ESI of the first\n   source symbol
      (Section 3.2).\n"
    title: 1.3.  Small Transmission Overheads with the Sliding Window RLC FEC
  - contents:
    - "1.4.  Document Organization\n   This fully-specified FEC scheme follows the
      structure required by\n   [RFC6363], Section 5.6 (\"FEC Scheme Requirements\"),
      namely:\n   3.  Procedures: This section describes procedures specific to this\n
      \      FEC scheme, namely: RLC parameters derivation, ADUI and source\n       symbols
      mapping, pseudorandom number generator, and coding\n       coefficients generation
      function;\n   4.  Formats and Codes: This section defines the Source FEC Payload
      ID\n       and Repair FEC Payload ID formats, carrying the signaling\n       information
      associated to each source or repair symbol.  It also\n       defines the FEC
      Framework Configuration Information (FFCI)\n       carrying signaling information
      for the session;\n   5.  FEC Code Specification: Finally this section provides
      the code\n       specification.\n"
    title: 1.4.  Document Organization
  title: 1.  Introduction
- contents:
  - "2.  Definitions and Abbreviations\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
    RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
    as described in BCP\n   14 [RFC2119] [RFC8174] when, and only when, they appear
    in all\n   capitals, as shown here.\n   This document uses the following definitions
    and abbreviations:\n   a^(b)  a to the power of b\n   GF(q)  denotes a finite
    field (also known as the Galois Field) with q\n      elements.  We assume that
    q = 2^(m) in this document\n   m  defines the length of the elements in the finite
    field, in bits.\n      In this document, m is equal to 1 or 8\n   ADU:  Application
    Data Unit\n   ADUI:  Application Data Unit Information (includes the F, L and\n
    \     padding fields in addition to the ADU)\n   E:  size of an encoding symbol
    (i.e., source or repair symbol),\n      assumed fixed (in bytes)\n   br_in:  transmission
    bitrate at the input of the FECFRAME sender,\n      assumed fixed (in bits/s)\n
    \  br_out:  transmission bitrate at the output of the FECFRAME sender,\n      assumed
    fixed (in bits/s)\n   max_lat:  maximum FEC-related latency within FECFRAME (a
    decimal\n      number expressed in seconds)\n   cr:  RLC coding rate, ratio between
    the total number of source\n      symbols and the total number of source plus
    repair symbols\n   ew_size:  encoding window current size at a sender (in symbols)\n
    \  ew_max_size:  encoding window maximum size at a sender (in symbols)\n   dw_max_size:
    \ decoding window maximum size at a receiver (in symbols)\n   ls_max_size:  linear
    system maximum size (or width) at a receiver (in\n      symbols)\n   WSR:  window
    size ratio parameter used to derive ew_max_size\n      (encoder) and ls_max_size
    (decoder).\n   PRNG:  pseudorandom number generator\n   TinyMT32:  PRNG used in
    this specification.\n   DT:  coding coefficients density threshold, an integer
    between 0 and\n      15 (inclusive) the controls the fraction of coefficients
    that are\n      nonzero\n"
  title: 2.  Definitions and Abbreviations
- contents:
  - "3.  Common Procedures\n   This section introduces the procedures that are used
    by these FEC\n   schemes.\n"
  - contents:
    - "3.1.  Codec Parameters\n   A codec implementing the Sliding Window RLC FEC
      scheme relies on\n   several parameters:\n   Maximum FEC-related latency budget,
      max_lat (a decimal number\n   expressed in seconds) with real-time flows:\n
      \     a source ADU flow can have real-time constraints, and therefore\n      any
      FECFRAME related operation should take place within the\n      validity period
      of each ADU (Appendix D describes an exception to\n      this rule).  When there
      are multiple flows with different real-\n      time constraints, we consider
      the most stringent constraints (see\n      item 6 in Section 10.2 of [RFC6363],
      for recommendations when\n      several flows are globally protected).  The
      maximum FEC-related\n      latency budget, max_lat, accounts for all sources
      of latency added\n      by FEC encoding (at a sender) and FEC decoding (at a
      receiver).\n      Other sources of latency (e.g., added by network communications)\n
      \     are out of scope and must be considered separately (said\n      differently,
      they have already been deducted from max_lat).\n      max_lat can be regarded
      as the latency budget permitted for all\n      FEC-related operations.  This
      is an input parameter that enables a\n      FECFRAME sender to derive other
      internal parameters (see\n      Appendix C);\n   Encoding window current (resp.
      maximum) size, ew_size (resp.\n   ew_max_size) (in symbols):\n      at a FECFRAME
      sender, during FEC encoding, a repair symbol is\n      computed as a linear
      combination of the ew_size source symbols\n      present in the encoding window.
      \ The ew_max_size is the maximum\n      size of this window, while ew_size is
      the current size.  For\n      example, in the common case at session start,
      upon receiving new\n      source ADUs, the ew_size progressively increases until
      it reaches\n      its maximum value, ew_max_size.  We have:\n         0 < ew_size
      <= ew_max_size\n   Decoding window maximum size, dw_max_size (in symbols):\n
      \     at a FECFRAME receiver, dw_max_size is the maximum number of\n      received
      or lost source symbols that are still within their\n      latency budget;\n
      \  Linear system maximum size, ls_max_size (in symbols):\n      at a FECFRAME
      receiver, the linear system maximum size,\n      ls_max_size, is the maximum
      number of received or lost source\n      symbols in the linear system (i.e.,
      the variables).  It SHOULD NOT\n      be smaller than dw_max_size since it would
      mean that, even after\n      receiving a sufficient number of FEC Repair Packets,
      a lost ADU\n      may not be recovered just because the associated source symbols\n
      \     have been prematurely removed from the linear system, which is\n      usually
      counter-productive.  On the opposite, the linear system\n      MAY grow beyond
      the dw_max_size (Appendix D);\n   Symbol size, E (in bytes):\n      the E parameter
      determines the source and repair symbol sizes\n      (necessarily equal).  This
      is an input parameter that enables a\n      FECFRAME sender to derive other
      internal parameters, as explained\n      below.  An implementation at a sender
      MUST fix the E parameter and\n      MUST communicate it as part of the FEC Scheme-Specific
      Information\n      (Section 4.1.1.2).\n   Code rate, cr:\n      The code rate
      parameter determines the amount of redundancy added\n      to the flow.  More
      precisely the cr is the ratio between the total\n      number of source symbols
      and the total number of source plus\n      repair symbols and by definition:
      0 < cr <= 1.  This is an input\n      parameter that enables a FECFRAME sender
      to derive other internal\n      parameters, as explained below.  However, there
      is no need to\n      communicate the cr parameter per see (it's not required
      to process\n      a repair symbol at a receiver).  This code rate parameter
      can be\n      static.  However, in specific use-cases (e.g., with unicast\n
      \     transmissions in presence of a feedback mechanism that estimates\n      the
      communication quality, out of scope of FECFRAME), the code\n      rate may be
      adjusted dynamically.\n   Appendix C proposes non-normative techniques to derive
      those\n   parameters, depending on the use-case specificities.\n"
    title: 3.1.  Codec Parameters
  - contents:
    - "3.2.  ADU, ADUI, and Source Symbols Mappings\n   At a sender, an ADU coming
      from the application is not directly\n   mapped to source symbols.  When multiple
      source flows (e.g., media\n   streams) are mapped onto the same FECFRAME instance,
      each flow is\n   assigned its own Flow ID value (see below).  This Flow ID is
      then\n   prepended to each ADU before FEC encoding.  This way, FEC decoding
      at\n   a receiver also recovers this Flow ID and the recovered ADU can be\n
      \  assigned to the right source flow (note that the 5-tuple used to\n   identify
      the right source flow of a received ADU is absent with a\n   recovered ADU since
      it is not FEC protected).\n   Additionally, since ADUs are of variable size,
      padding is needed so\n   that each ADU (with its flow identifier) contribute
      to an integral\n   number of source symbols.  This requires adding the original
      ADU\n   length to each ADU before doing FEC encoding.  Because of these\n   requirements,
      an intermediate format, the ADUI, or ADU Information,\n   is considered [RFC6363].\n
      \  For each incoming ADU, an ADUI MUST be created as follows.  First of\n   all,
      3 bytes are prepended (Figure 1):\n   Flow ID (F) (8-bit field):  this unsigned
      byte contains the integer\n      identifier associated to the source ADU flow
      to which this ADU\n      belongs.  It is assumed that a single byte is sufficient,
      which\n      implies that no more than 256 flows will be protected by a single\n
      \     FECFRAME session instance.\n   Length (L) (16-bit field):  this unsigned
      integer contains the length\n      of this ADU, in network byte order (i.e.,
      big endian).  This\n      length is for the ADU itself and does not include
      the F, L, or Pad\n      fields.\n   Then, zero padding is added to the ADU if
      needed:\n   Padding (Pad) (variable size field):  this field contains zero\n
      \     padding to align the F, L, ADU and padding up to a size that is\n      multiple
      of E bytes (i.e., the source and repair symbol length).\n   The data unit resulting
      from the ADU and the F, L, and Pad fields is\n   called ADUI.  Since ADUs can
      have different sizes, this is also the\n   case for ADUIs.  However, an ADUI
      always contributes to an integral\n   number of source symbols.\n      symbol
      length, E              E                     E\n   |F| L|                     ADU
      \                    |     Pad     |\n     Figure 1: ADUI Creation Example,
      Resulting in Three Source Symbols\n   Note that neither the initial 3 bytes
      nor the optional padding are\n   sent over the network.  However, they are considered
      during FEC\n   encoding, and a receiver that lost a certain FEC Source Packet
      (e.g.,\n   the UDP datagram containing this FEC Source Packet when UDP is used\n
      \  as the transport protocol) will be able to recover the ADUI if FEC\n   decoding
      succeeds.  Thanks to the initial 3 bytes, this receiver will\n   get rid of
      the padding (if any) and identify the corresponding ADU\n   flow.\n"
    title: 3.2.  ADU, ADUI, and Source Symbols Mappings
  - contents:
    - "3.3.  Encoding Window Management\n   Source symbols and the corresponding ADUs
      are removed from the\n   encoding window:\n   *  when the sliding encoding window
      has reached its maximum size,\n      ew_max_size.  In that case the oldest symbol
      MUST be removed\n      before adding a new symbol, so that the current encoding
      window\n      size always remains inferior or equal to the maximum size: ew_size\n
      \     <= ew_max_size;\n   *  when an ADU has reached its maximum validity duration
      in case of a\n      real-time flow.  When this happens, all source symbols\n
      \     corresponding to the ADUI that expired SHOULD be removed from the\n      encoding
      window;\n   Source symbols are added to the sliding encoding window each time
      a\n   new ADU arrives, once the ADU-to-source symbols mapping has been\n   performed
      (Section 3.2).  The current size of the encoding window,\n   ew_size, is updated
      after adding new source symbols.  This process\n   may require to remove old
      source symbols so that: ew_size <=\n   ew_max_size.\n   Note that a FEC codec
      may feature practical limits in the number of\n   source symbols in the encoding
      window (e.g., for computational\n   complexity reasons).  This factor may further
      limit the ew_max_size\n   value, in addition to the maximum FEC-related latency
      budget\n   (Section 3.1).\n"
    title: 3.3.  Encoding Window Management
  - contents:
    - "3.4.  Source Symbol Identification\n   Each source symbol is identified by
      an Encoding Symbol ID (ESI), an\n   unsigned integer.  The ESI of source symbols
      MUST start with value 0\n   for the first source symbol and MUST be managed
      sequentially.\n   Wrapping to zero happens after reaching the maximum value
      made\n   possible by the ESI field size (this maximum value is FEC scheme\n
      \  dependent, for instance, 2^(32)-1 with FEC schemes 9 and 10).\n   No such
      consideration applies to repair symbols.\n"
    title: 3.4.  Source Symbol Identification
  - contents:
    - "3.5.  Pseudorandom Number Generator (PRNG)\n   In order to compute coding coefficients
      (see Section 3.6), the RLC\n   FEC schemes rely on the TinyMT32 PRNG defined
      in [RFC8682] with two\n   additional functions defined in this section.\n   This
      PRNG MUST first be initialized with a 32-bit unsigned integer,\n   used as a
      seed, with:\n      void   tinymt32_init (tinymt32_t * s, uint32_t seed);\n   With
      the FEC schemes defined in this document, the seed is in\n   practice restricted
      to a value between 0 and 0xFFFF inclusive (note\n   that this PRNG accepts a
      seed value equal to 0), since this is the\n   Repair_Key 16-bit field value
      of the Repair FEC Payload ID\n   (Section 4.1.3).  In practice, how to manage
      the seed and Repair_Key\n   values (both are equal) is left to the implementer,
      using a\n   monotonically increasing counter being one possibility (Section
      6.1).\n   In addition to the seed, this function takes as parameter a pointer\n
      \  to an instance of a tinymt32_t structure that is used to keep the\n   internal
      state of the PRNG.\n   Then, each time a new pseudorandom integer between 0
      and 15 inclusive\n   (4-bit pseudorandom integer) is needed, the following function
      is\n   used:\n      uint32_t   tinymt32_rand16 (tinymt32_t * s);\n   This function
      takes as parameter a pointer to the same tinymt32_t\n   structure (that is left
      unchanged between successive calls to the\n   function).\n   Similarly, each
      time a new pseudorandom integer between 0 and 255\n   inclusive (8-bit pseudorandom
      integer) is needed, the following\n   function is used:\n      uint32_t   tinymt32_rand256
      (tinymt32_t * s);\n   These two functions keep respectively the 4 or 8 less
      significant\n   bits of the 32-bit pseudorandom number generated by the\n   tinymt32_generate_uint32()
      function of [RFC8682].  This is done by\n   computing the result of a binary
      AND between the\n   tinymt32_generate_uint32() output and respectively the 0xF
      or 0xFF\n   constants, using 32-bit unsigned integer operations.  Figure 2 shows\n
      \  a possible implementation.  This is a C language implementation,\n   written
      for C99 [C99].  Test results discussed in Appendix B show\n   that this simple
      technique, applied to this PRNG, is in line with the\n   RLC FEC schemes needs.\n
      \  <CODE BEGINS>\n   /**\n    * This function outputs a pseudorandom integer
      in [0 .. 15] range.\n    *\n    * @param s     pointer to tinymt internal state.\n
      \   * @return      unsigned integer between 0 and 15 inclusive.\n    */\n   uint32_t
      tinymt32_rand16(tinymt32_t *s)\n   {\n       return (tinymt32_generate_uint32(s)
      & 0xF);\n   }\n   /**\n    * This function outputs a pseudorandom integer in
      [0 .. 255] range.\n    *\n    * @param s     pointer to tinymt internal state.\n
      \   * @return      unsigned integer between 0 and 255 inclusive.\n    */\n   uint32_t
      tinymt32_rand256(tinymt32_t *s)\n   {\n       return (tinymt32_generate_uint32(s)
      & 0xFF);\n   }\n   <CODE ENDS>\n          Figure 2: 4-bit and 8-bit Mapping
      Functions for TinyMT32\n   Any implementation of this PRNG MUST have the same
      output as that\n   provided by the reference implementation of [RFC8682].  In
      order to\n   increase the compliance confidence, three criteria are proposed:
      the\n   one described in [RFC8682] (for the TinyMT32 32-bit unsigned integer\n
      \  generator), and the two others detailed in Appendix A (for the\n   mapping
      to 4-bit and 8-bit intervals).  Because of the way the\n   mapping functions
      work, it is unlikely that an implementation that\n   fulfills the first criterion
      fails to fulfill the two others.\n"
    title: 3.5.  Pseudorandom Number Generator (PRNG)
  - contents:
    - "3.6.  Coding Coefficients Generation Function\n   The coding coefficients used
      during the encoding process are\n   generated at the RLC encoder by the generate_coding_coefficients()\n
      \  function each time a new repair symbol needs to be produced.  The\n   fraction
      of coefficients that are nonzero (i.e., the density) is\n   controlled by the
      DT (Density Threshold) parameter.  DT has values\n   between 0 (the minimum
      value) and 15 (the maximum value), and the\n   average probability of having
      a nonzero coefficient equals (DT + 1) /\n   16.  In particular, when DT equals
      15 the function guaranties that\n   all coefficients are nonzero (i.e., maximum
      density).\n   These considerations apply to both the RLC over GF(2) and RLC
      over\n   GF(2^(8)), the only difference being the value of the m parameter.\n
      \  With the RLC over GF(2) FEC scheme (Section 5), m is equal to 1.\n   With
      RLC over GF(2^(8)) FEC scheme (Section 4), m is equal to 8.\n   Figure 3 shows
      the reference generate_coding_coefficients()\n   implementation.  This is a
      C language implementation, written for C99\n   [C99].\n   <CODE BEGINS>\n   #include
      <string.h>\n   /*\n    * Fills in the table of coding coefficients (of the right
      size)\n    * provided with the appropriate number of coding coefficients to\n
      \   * use for the repair symbol key provided.\n    *\n    * (in) repair_key
      \   key associated to this repair symbol. This\n    *                    parameter
      is ignored (useless) if m=1 and dt=15\n    * (in/out) cc_tab    pointer to a
      table of the right size to store\n    *                    coding coefficients.
      All coefficients are\n    *                    stored as bytes, regardless of
      the m parameter,\n    *                    upon return of this function.\n    *
      (in) cc_nb         number of entries in the cc_tab table. This\n    *                    value
      is equal to the current encoding window\n    *                    size.\n    *
      (in) dt            integer between 0 and 15 (inclusive) that\n    *                    controls
      the density. With value 15, all\n    *                    coefficients are guaranteed
      to be nonzero\n    *                    (i.e., equal to 1 with GF(2) and equal
      to a\n    *                    value in {1,... 255} with GF(2^^8)), otherwise\n
      \   *                    a fraction of them will be 0.\n    * (in) m             Finite
      Field GF(2^^m) parameter. In this\n    *                    document only values
      1 and 8 are considered.\n    * (out)              returns 0 in case of success,
      an error code\n    *                    different than 0 otherwise.\n    */\n
      \  int generate_coding_coefficients (uint16_t  repair_key,\n   {\n       uint32_t
      \     i;\n       tinymt32_t    s;    /* PRNG internal state */\n       if (dt
      > 15) {\n           return -1; /* error, bad dt parameter */\n       }\n       switch
      (m) {\n       case 1:\n           if (dt == 15) {\n               /* all coefficients
      are 1 */\n               memset(cc_tab, 1, cc_nb);\n           } else {\n               /*
      here coefficients are either 0 or 1 */\n               tinymt32_init(&s, repair_key);\n
      \              for (i = 0 ; i < cc_nb ; i++) {\n                   cc_tab[i]
      = (tinymt32_rand16(&s) <= dt) ? 1 : 0;\n               }\n           }\n           break;\n
      \      case 8:\n           tinymt32_init(&s, repair_key);\n           if (dt
      == 15) {\n               /* coefficient 0 is avoided here in order to include\n
      \               * all the source symbols */\n               for (i = 0 ; i <
      cc_nb ; i++) {\n                   do {\n                       cc_tab[i] =
      (uint8_t) tinymt32_rand256(&s);\n                   } while (cc_tab[i] == 0);\n
      \              }\n           } else {\n               /* here a certain number
      of coefficients should be 0 */\n               for (i = 0 ; i < cc_nb ; i++)
      {\n                   if (tinymt32_rand16(&s) <= dt) {\n                       do
      {\n                           cc_tab[i] = (uint8_t) tinymt32_rand256(&s);\n
      \                      } while (cc_tab[i] == 0);\n                   } else
      {\n                       cc_tab[i] = 0;\n                   }\n               }\n
      \          }\n           break;\n       default:\n           return -2; /* error,
      bad parameter m */\n       }\n       return 0; /* success */\n   }\n   <CODE
      ENDS>\n       Figure 3: Reference Implementation of the Coding Coefficients\n
      \                           Generation Function\n"
    title: 3.6.  Coding Coefficients Generation Function
  - contents:
    - '3.7.  Finite Field Operations

      '
    - contents:
      - "3.7.1.  Finite Field Definitions\n   The two RLC FEC schemes specified in
        this document reuse the Finite\n   Fields defined in [RFC5510], Section 8.1.
        \ More specifically, the\n   elements of the field GF(2^(m)) are represented
        by polynomials with\n   binary coefficients (i.e., over GF(2)) and degree
        lower or equal to\n   m-1.  The addition between two elements is defined as
        the addition of\n   binary polynomials in GF(2), which is equivalent to a
        bitwise XOR\n   operation on the binary representation of these elements.\n
        \  With GF(2^(8)), multiplication between two elements is the\n   multiplication
        modulo a given irreducible polynomial of degree 8.\n   The following irreducible
        polynomial is used for GF(2^(8)):\n      x^(8) + x^(4) + x^(3) + x^(2) + 1\n
        \  With GF(2), multiplication corresponds to a logical AND operation.\n"
      title: 3.7.1.  Finite Field Definitions
    - contents:
      - "3.7.2.  Linear Combination of Source Symbol Computation\n   The two RLC FEC
        schemes require the computation of a linear\n   combination of source symbols,
        using the coding coefficients produced\n   by the generate_coding_coefficients()
        function and stored in the\n   cc_tab[] array.\n   With the RLC over GF(2^(8))
        FEC scheme, a linear combination of the\n   ew_size source symbol present
        in the encoding window, say src_0 to\n   src_ew_size_1, in order to generate
        a repair symbol, is computed as\n   follows.  For each byte of position i
        in each source and the repair\n   symbol, where i belongs to [0; E-1], compute:\n
        \     repair[i] = cc_tab[0] * src_0[i] XOR cc_tab[1] * src_1[i] XOR ...\n
        \     XOR cc_tab[ew_size - 1] * src_ew_size_1[i]\n   where * is the multiplication
        over GF(2^(8)).  In practice various\n   optimizations need to be used in
        order to make this computation\n   efficient (see in particular [PGM13]).\n
        \  With the RLC over GF(2) FEC scheme (binary case), a linear\n   combination
        is computed as follows.  The repair symbol is the XOR sum\n   of all the source
        symbols corresponding to a coding coefficient\n   cc_tab[j] equal to 1 (i.e.,
        the source symbols corresponding to zero\n   coding coefficients are ignored).
        \ The XOR sum of the byte of\n   position i in each source is computed and
        stored in the corresponding\n   byte of the repair symbol, where i belongs
        to [0; E-1].  In practice,\n   the XOR sums will be computed several bytes
        at a time (e.g., on 64\n   bit words, or on arrays of 16 or more bytes when
        using SIMD CPU\n   extensions).\n   With both FEC schemes, the details of
        how to optimize the computation\n   of these linear combinations are of high
        practical importance but out\n   of scope of this document.\n"
      title: 3.7.2.  Linear Combination of Source Symbol Computation
    title: 3.7.  Finite Field Operations
  title: 3.  Common Procedures
- contents:
  - "4.  Sliding Window RLC FEC Scheme over GF(2^(8)) for Arbitrary Packet\n    Flows\n
    \  This fully-specified FEC scheme defines the Sliding Window Random\n   Linear
    Codes (RLC) over GF(2^(8)).\n"
  - contents:
    - '4.1.  Formats and Codes

      '
    - contents:
      - "4.1.1.  FEC Framework Configuration Information\n   Following the guidelines
        of Section 5.6 of [RFC6363], this section\n   provides the FEC Framework Configuration
        Information (or FFCI).  This\n   FCCI needs to be shared (e.g., using SDP)
        between the FECFRAME sender\n   and receiver instances in order to synchronize
        them.  It includes a\n   FEC Encoding ID, mandatory for any FEC scheme specification,
        plus\n   scheme-specific elements.\n"
      - contents:
        - "4.1.1.1.  FEC Encoding ID\n   FEC Encoding ID:  the value assigned to this
          fully specified FEC\n      scheme MUST be 10, as assigned by IANA (Section
          9).\n   When SDP is used to communicate the FFCI, this FEC Encoding ID is\n
          \  carried in the 'encoding-id' parameter.\n"
        title: 4.1.1.1.  FEC Encoding ID
      - contents:
        - "4.1.1.2.  FEC Scheme-Specific Information\n   The FEC Scheme-Specific Information
          (FSSI) includes elements that are\n   specific to the present FEC scheme.
          \ More precisely:\n   Encoding symbol size (E):  a non-negative integer
          that indicates the\n      size of each encoding symbol in bytes;\n   Window
          Size Ratio (WSR) parameter:  a non-negative integer between 0\n      and
          255 (both inclusive) used to initialize window sizes.  A value\n      of
          0 indicates this parameter is not considered (e.g., a fixed\n      encoding
          window size may be chosen).  A value between 1 and 255\n      inclusive
          is required by certain of the parameter derivation\n      techniques described
          in Appendix C;\n   This element is required both by the sender (RLC encoder)
          and the\n   receiver(s) (RLC decoder).\n   When SDP is used to communicate
          the FFCI, this FEC Scheme-Specific\n   Information is carried in the 'fssi'
          parameter in textual\n   representation as specified in [RFC6364].  For
          instance:\n      fssi=E:1400,WSR:191\n   In that case the name values \"E\"
          and \"WSR\" are used to convey the E\n   and WSR parameters respectively.\n
          \  If another mechanism requires the FSSI to be carried as an opaque\n   octet
          string, the encoding format consists of the following three\n   octets,
          where the E field is carried in \"big-endian\" or \"network\n   order\"
          format, that is, most significant byte first:\n      Encoding symbol length
          (E): 16-bit field;\n      Window Size Ratio Parameter (WSR): 8-bit field.\n
          \  These three octets can be communicated as such, or for instance, be\n
          \  subject to an additional Base64 encoding.\n    0                   1
          \                  2\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3\n   |   Encoding Symbol Length (E)  |      WSR      |\n                       Figure
          4: FSSI Encoding Format\n"
        title: 4.1.1.2.  FEC Scheme-Specific Information
      title: 4.1.1.  FEC Framework Configuration Information
    - contents:
      - "4.1.2.  Explicit Source FEC Payload ID\n   A FEC Source Packet MUST contain
        an Explicit Source FEC Payload ID\n   that is appended to the end of the packet
        as illustrated in Figure 5.\n   |           IP Header            |\n   |        Transport
        Header        |\n   |              ADU               |\n   | Explicit Source
        FEC Payload ID |\n       Figure 5: Structure of an FEC Source Packet with
        the Explicit\n                           Source FEC Payload ID\n   More precisely,
        the Explicit Source FEC Payload ID is composed of the\n   following field,
        carried in \"big-endian\" or \"network order\" format,\n   that is, most significant
        byte first (Figure 6):\n   Encoding Symbol ID (ESI) (32-bit field):  this
        unsigned integer\n      identifies the first source symbol of the ADUI corresponding
        to\n      this FEC Source Packet.  The ESI is incremented for each new\n      source
        symbol, and after reaching the maximum value (2^(32)-1),\n      wrapping to
        zero occurs.\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   |
        \                  Encoding Symbol ID (ESI)                    |\n              Figure
        6: Source FEC Payload ID Encoding Format\n"
      title: 4.1.2.  Explicit Source FEC Payload ID
    - contents:
      - "4.1.3.  Repair FEC Payload ID\n   A FEC Repair Packet MAY contain one or
        more repair symbols.  When\n   there are several repair symbols, all of them
        MUST have been\n   generated from the same encoding window, using Repair_Key
        values that\n   are managed as explained below.  A receiver can easily deduce
        the\n   number of repair symbols within a FEC Repair Packet by comparing the\n
        \  received FEC Repair Packet size (equal to the UDP payload size when\n   UDP
        is the underlying transport protocol) and the symbol size, E,\n   communicated
        in the FFCI.\n   A FEC Repair Packet MUST contain a Repair FEC Payload ID
        that is\n   prepended to the repair symbol as illustrated in Figure 7.\n   |
        \          IP Header            |\n   |        Transport Header        |\n
        \  |     Repair FEC Payload ID      |\n   |         Repair Symbol          |\n
        \     Figure 7: Structure of an FEC Repair Packet with the Repair FEC\n   More
        precisely, the Repair FEC Payload ID is composed of the\n   following fields
        where all integer fields are carried in \"big-endian\"\n   or \"network order\"
        format, that is, most significant byte first\n   (Figure 8):\n   Repair_Key
        (16-bit field):  this unsigned integer is used as a seed\n      by the coefficient
        generation function (Section 3.6) in order to\n      generate the desired
        number of coding coefficients.  This repair\n      key may be a monotonically
        increasing integer value that loops\n      back to 0 after reaching 65535
        (see Section 6.1).  When a FEC\n      Repair Packet contains several repair
        symbols, this repair key\n      value is that of the first repair symbol.
        \ The remaining repair\n      keys can be deduced by incrementing by 1 this
        value, up to a\n      maximum value of 65535 after which it loops back to
        0.\n   Density Threshold for the coding coefficients, DT (4-bit field):\n
        \     this unsigned integer carries the Density Threshold (DT) used by\n      the
        coding coefficient generation function Section 3.6.  More\n      precisely,
        it controls the probability of having a nonzero coding\n      coefficient,
        which equals (DT+1) / 16.  When a FEC Repair Packet\n      contains several
        repair symbols, the DT value applies to all of\n      them;\n   Number of
        Source Symbols in the encoding window, NSS (12-bit\n   field):\n      this
        unsigned integer indicates the number of source symbols in\n      the encoding
        window when this repair symbol was generated.  When a\n      FEC Repair Packet
        contains several repair symbols, this NSS value\n      applies to all of them;\n
        \  ESI of First Source Symbol in the encoding window, FSS_ESI (32-bit\n   field):\n
        \     this unsigned integer indicates the ESI of the first source symbol\n
        \     in the encoding window when this repair symbol was generated.\n      When
        a FEC Repair Packet contains several repair symbols, this\n      FSS_ESI value
        applies to all of them;\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   |
        \      Repair_Key              |  DT   |NSS (# src symb in ew) |\n              Figure
        8: Repair FEC Payload ID Encoding Format\n"
      title: 4.1.3.  Repair FEC Payload ID
    title: 4.1.  Formats and Codes
  - contents:
    - "4.2.  Procedures\n   All the procedures of Section 3 apply to this FEC scheme.\n"
    title: 4.2.  Procedures
  title: 4.  Sliding Window RLC FEC Scheme over GF(2^(8)) for Arbitrary Packet
- contents:
  - "5.  Sliding Window RLC FEC Scheme over GF(2) for Arbitrary Packet Flows\n   This
    fully-specified FEC scheme defines the Sliding Window Random\n   Linear Codes
    (RLC) over GF(2) (binary case).\n"
  - contents:
    - '5.1.  Formats and Codes

      '
    - contents:
      - '5.1.1.  FEC Framework Configuration Information

        '
      - contents:
        - "5.1.1.1.  FEC Encoding ID\n   FEC Encoding ID:  the value assigned to this
          fully specified FEC\n      scheme MUST be 9, as assigned by IANA (Section
          9).\n   When SDP is used to communicate the FFCI, this FEC Encoding ID is\n
          \  carried in the 'encoding-id' parameter.\n"
        title: 5.1.1.1.  FEC Encoding ID
      - contents:
        - "5.1.1.2.  FEC Scheme-Specific Information\n   All the considerations of
          Section 4.1.1.2 apply here.\n"
        title: 5.1.1.2.  FEC Scheme-Specific Information
      title: 5.1.1.  FEC Framework Configuration Information
    - contents:
      - "5.1.2.  Explicit Source FEC Payload ID\n   All the considerations of Section
        4.1.2 apply here.\n"
      title: 5.1.2.  Explicit Source FEC Payload ID
    - contents:
      - "5.1.3.  Repair FEC Payload ID\n   All the considerations of Section 4.1.3
        apply here, with the only\n   exception that the Repair_Key field is useless
        if DT = 15 (indeed, in\n   that case all the coefficients are necessarily
        equal to 1 and the\n   coefficient generation function does not use any PRNG).
        \ When DT = 15\n   the FECFRAME sender MUST set the Repair_Key field to zero
        on\n   transmission and a receiver MUST ignore it on receipt.\n"
      title: 5.1.3.  Repair FEC Payload ID
    title: 5.1.  Formats and Codes
  - contents:
    - "5.2.  Procedures\n   All the procedures of Section 3 apply to this FEC scheme.\n"
    title: 5.2.  Procedures
  title: 5.  Sliding Window RLC FEC Scheme over GF(2) for Arbitrary Packet Flows
- contents:
  - '6.  FEC Code Specification

    '
  - contents:
    - "6.1.  Encoding Side\n   This section provides a high level description of a
      Sliding Window\n   RLC encoder.\n   Whenever a new FEC Repair Packet is needed,
      the RLC encoder instance\n   first gathers the ew_size source symbols currently
      in the sliding\n   encoding window.  Then it chooses a repair key, which can
      be a\n   monotonically increasing integer value, incremented for each repair\n
      \  symbol up to a maximum value of 65535 (as it is carried within a\n   16-bit
      field) after which it loops back to 0.  This repair key is\n   communicated
      to the coefficient generation function (Section 3.6) in\n   order to generate
      ew_size coding coefficients.  Finally, the FECFRAME\n   sender computes the
      repair symbol as a linear combination of the\n   ew_size source symbols using
      the ew_size coding coefficients\n   (Section 3.7).  When E is small and when
      there is an incentive to\n   pack several repair symbols within the same FEC
      Repair Packet, the\n   appropriate number of repair symbols are computed.  In
      that case the\n   repair key for each of them MUST be incremented by 1, keeping
      the\n   same ew_size source symbols, since only the first repair key will be\n
      \  carried in the Repair FEC Payload ID.  The FEC Repair Packet can then\n   be
      passed to the transport layer for transmission.  The source versus\n   repair
      FEC packet transmission order is out of scope of this document\n   and several
      approaches exist that are implementation-specific.\n   Other solutions are possible
      to select a repair key value when a new\n   FEC Repair Packet is needed, for
      instance, by choosing a random\n   integer between 0 and 65535.  However, selecting
      the same repair key\n   as before (which may happen in case of a random process)
      is only\n   meaningful if the encoding window has changed, otherwise the same
      FEC\n   Repair Packet will be generated.  In any case, choosing the repair\n
      \  key is entirely at the discretion of the sender, since it is\n   communicated
      to the receiver(s) in each Repair FEC Payload ID.  A\n   receiver should not
      make any assumption on the way the repair key is\n   managed.\n"
    title: 6.1.  Encoding Side
  - contents:
    - "6.2.  Decoding Side\n   This section provides a high level description of a
      Sliding Window\n   RLC decoder.\n   A FECFRAME receiver needs to maintain a
      linear system whose variables\n   are the received and lost source symbols.
      \ Upon receiving a FEC\n   Repair Packet, a receiver first extracts all the
      repair symbols it\n   contains (in case several repair symbols are packed together).
      \ For\n   each repair symbol, when at least one of the corresponding source\n
      \  symbols it protects has been lost, the receiver adds an equation to\n   the
      linear system (or no equation if this repair packet does not\n   change the
      linear system rank).  This equation of course re-uses the\n   ew_size coding
      coefficients that are computed by the same coefficient\n   generation function
      (Section 3.6), using the repair key and encoding\n   window descriptions carried
      in the Repair FEC Payload ID.  Whenever\n   possible (i.e., when a sub-system
      covering one or more lost source\n   symbols is of full rank), decoding is performed
      in order to recover\n   lost source symbols.  Gaussian elimination is one possible
      algorithm\n   to solve this linear system.  Each time an ADUI can be totally\n
      \  recovered, padding is removed (thanks to the Length field, L, of the\n   ADUI)
      and the ADU is assigned to the corresponding application flow\n   (thanks to
      the Flow ID field, F, of the ADUI).  This ADU is finally\n   passed to the corresponding
      upper application.  Received FEC Source\n   Packets, containing an ADU, MAY
      be passed to the application either\n   immediately or after some time to guaranty
      an ordered delivery to the\n   application.  This document does not mandate
      any approach as this is\n   an operational and management decision.\n   With
      real-time flows, a lost ADU that is decoded after the maximum\n   latency or
      an ADU received after this delay has no value to the\n   application.  This
      raises the question of deciding whether or not an\n   ADU is late.  This decision
      MAY be taken within the FECFRAME receiver\n   (e.g., using the decoding window,
      see Section 3.1) or within the\n   application (e.g., using RTP timestamps within
      the ADU).  Deciding\n   which option to follow and whether or not to pass all
      ADUs, including\n   those assumed late, to the application are operational decisions
      that\n   depend on the application and are therefore out of scope of this\n
      \  document.  Additionally, Appendix D discusses a backward compatible\n   optimization
      whereby late source symbols MAY still be used within the\n   FECFRAME receiver
      in order to improve transmission robustness.\n"
    title: 6.2.  Decoding Side
  title: 6.  FEC Code Specification
- contents:
  - "7.  Security Considerations\n   The FEC Framework document [RFC6363] provides
    a fairly comprehensive\n   analysis of security considerations applicable to FEC
    schemes.\n   Therefore, the present section follows the security considerations\n
    \  section of [RFC6363] and only discusses specific topics.\n"
  - contents:
    - '7.1.  Attacks Against the Data Flow

      '
    - contents:
      - "7.1.1.  Access to Confidential Content\n   The Sliding Window RLC FEC scheme
        specified in this document does not\n   change the recommendations of [RFC6363].
        \ To summarize, if\n   confidentiality is a concern, it is RECOMMENDED that
        one of the\n   solutions mentioned in [RFC6363] is used with special considerations\n
        \  to the way this solution is applied (e.g., is encryption applied\n   before
        or after FEC protection, within the end system or in a\n   middlebox), to
        the operational constraints (e.g., performing FEC\n   decoding in a protected
        environment may be complicated or even\n   impossible) and to the threat model.\n"
      title: 7.1.1.  Access to Confidential Content
    - contents:
      - "7.1.2.  Content Corruption\n   The Sliding Window RLC FEC scheme specified
        in this document does not\n   change the recommendations of [RFC6363].  To
        summarize, it is\n   RECOMMENDED that one of the solutions mentioned in [RFC6363]
        is used\n   on both the FEC Source and Repair Packets.\n"
      title: 7.1.2.  Content Corruption
    title: 7.1.  Attacks Against the Data Flow
  - contents:
    - "7.2.  Attacks Against the FEC Parameters\n   The FEC scheme specified in this
      document defines parameters that can\n   be the basis of attacks.  More specifically,
      the following parameters\n   of the FFCI may be modified by an attacker who
      targets receivers\n   (Section 4.1.1.2):\n   FEC Encoding ID:  changing this
      parameter leads a receiver to\n      consider a different FEC scheme.  The consequences
      are severe, the\n      format of the Explicit Source FEC Payload ID and Repair
      FEC\n      Payload ID of received packets will probably differ, leading to\n
      \     various malfunctions.  Even if the original and modified FEC\n      schemes
      share the same format, FEC decoding will either fail or\n      lead to corrupted
      decoded symbols.  This will happen if an\n      attacker turns value 9 (i.e.,
      RLC over GF(2)) to value 10 (RLC\n      over GF(2^(8))), an additional consequence
      being a higher\n      processing overhead at the receiver.  In any case, the
      attack\n      results in a form of Denial of Service (DoS) or corrupted content.\n
      \  Encoding symbol length (E):  setting this E parameter to a different\n      value
      will confuse a receiver.  If the size of a received FEC\n      Repair Packet
      is no longer multiple of the modified E value, a\n      receiver quickly detects
      a problem and SHOULD reject the packet.\n      If the new E value is a sub-multiple
      of the original E value\n      (e.g., half the original value), then receivers
      may not detect the\n      problem immediately.  For instance, a receiver may
      think that a\n      received FEC Repair Packet contains more repair symbols
      (e.g.,\n      twice as many if E is reduced by half), leading to malfunctions\n
      \     whose nature depends on implementation details.  Here also, the\n      attack
      always results in a form of DoS or corrupted content.\n   It is therefore RECOMMENDED
      that security measures be taken to\n   guarantee the FFCI integrity, as specified
      in [RFC6363].  How to\n   achieve this depends on the way the FFCI is communicated
      from the\n   sender to the receiver, which is not specified in this document.\n
      \  Similarly, attacks are possible against the Explicit Source FEC\n   Payload
      ID and Repair FEC Payload ID.  More specifically, in case of\n   a FEC Source
      Packet, the following value can be modified by an\n   attacker who targets receivers:\n
      \  Encoding Symbol ID (ESI):  changing the ESI leads a receiver to\n      consider
      a wrong ADU, resulting in severe consequences, including\n      corrupted content
      passed to the receiving application;\n   And in case of a FEC Repair Packet:\n
      \  Repair Key:  changing this value leads a receiver to generate a wrong\n      coding
      coefficient sequence, and therefore any source symbol\n      decoded using the
      repair symbols contained in this packet will be\n      corrupted;\n   DT:  changing
      this value also leads a receiver to generate a wrong\n      coding coefficient
      sequence, and therefore any source symbol\n      decoded using the repair symbols
      contained in this packet will be\n      corrupted.  In addition, if the DT value
      is significantly\n      increased, it will generate a higher processing overhead
      at a\n      receiver.  In case of very large encoding windows, this may impact\n
      \     the terminal performance;\n   NSS:  changing this value leads a receiver
      to consider a different\n      set of source symbols, and therefore any source
      symbol decoded\n      using the repair symbols contained in this packet will
      be\n      corrupted.  In addition, if the NSS value is significantly\n      increased,
      it will generate a higher processing overhead at a\n      receiver, which may
      impact the terminal performance;\n   FSS_ESI:  changing this value also leads
      a receiver to consider a\n      different set of source symbols and therefore
      any source symbol\n      decoded using the repair symbols contained in this
      packet will be\n      corrupted.\n   It is therefore RECOMMENDED that security
      measures are taken to\n   guarantee the FEC Source and Repair Packets as stated
      in [RFC6363].\n"
    title: 7.2.  Attacks Against the FEC Parameters
  - contents:
    - "7.3.  When Several Source Flows are to be Protected Together\n   The Sliding
      Window RLC FEC scheme specified in this document does not\n   change the recommendations
      of [RFC6363].\n"
    title: 7.3.  When Several Source Flows are to be Protected Together
  - contents:
    - "7.4.  Baseline Secure FEC Framework Operation\n   The Sliding Window RLC FEC
      scheme specified in this document does not\n   change the recommendations of
      [RFC6363] concerning the use of the\n   IPsec/Encapsulating Security Payload
      (ESP) security protocol as a\n   mandatory-to-implement (but not mandatory-to-use)
      security scheme.\n   This is well suited to situations where the only insecure
      domain is\n   the one over which the FEC Framework operates.\n"
    title: 7.4.  Baseline Secure FEC Framework Operation
  - contents:
    - "7.5.  Additional Security Considerations for Numerical Computations\n   In
      addition to the above security considerations, inherited from\n   [RFC6363],
      the present document introduces several formulae, in\n   particular in Appendix
      C.1.  It is RECOMMENDED to check that the\n   computed values stay within reasonable
      bounds since numerical\n   overflows, caused by an erroneous implementation
      or an erroneous\n   input value, may lead to hazardous behaviors.  However,
      what\n   \"reasonable bounds\" means is use-case and implementation dependent\n
      \  and is not detailed in this document.\n   Appendix C.2 also mentions the
      possibility of \"using the timestamp\n   field of an RTP packet header\" when
      applicable.  A malicious attacker\n   may deliberately corrupt this header field
      in order to trigger\n   hazardous behaviors at a FECFRAME receiver.  Protection
      against this\n   type of content corruption can be addressed with the above\n
      \  recommendations on a baseline secure operation.  In addition, it is\n   also
      RECOMMENDED to check that the timestamp value be within\n   reasonable bounds.\n"
    title: 7.5.  Additional Security Considerations for Numerical Computations
  title: 7.  Security Considerations
- contents:
  - "8.  Operations and Management Considerations\n   The FEC Framework document [RFC6363]
    provides a fairly comprehensive\n   analysis of operations and management considerations
    applicable to\n   FEC schemes.  Therefore, the present section only discusses
    specific\n   topics.\n"
  - contents:
    - "8.1.  Operational Recommendations: Finite Field GF(2) Versus GF(2^(8))\n   The
      present document specifies two FEC schemes that differ on the\n   Finite Field
      used for the coding coefficients.  It is expected that\n   the RLC over GF(2^(8))
      FEC scheme will be mostly used since it\n   warrants a higher packet loss protection.
      \ In case of small encoding\n   windows, the associated processing overhead
      is not an issue (e.g., we\n   measured decoding speeds between 745 Mbps and
      2.8 Gbps on an ARM\n   Cortex-A15 embedded board in [Roca17] depending on the
      code rate and\n   the channel conditions, using an encoding window of size 18
      or 23\n   symbols; see the above article for the details).  Of course the CPU\n
      \  overhead will increase with the encoding window size, because more\n   operations
      in the GF(2^(8)) finite field will be needed.\n   The RLC over GF(2) FEC scheme
      offers an alternative.  In that case\n   operations symbols can be directly
      XOR-ed together which warrants\n   high bitrate encoding and decoding operations,
      and can be an\n   advantage with large encoding windows.  However, packet loss\n
      \  protection is significantly reduced by using this FEC scheme.\n"
    title: '8.1.  Operational Recommendations: Finite Field GF(2) Versus GF(2^(8))'
  - contents:
    - "8.2.  Operational Recommendations: Coding Coefficients Density Threshold\n
      \  In addition to the choice of the Finite Field, the two FEC schemes\n   define
      a coding coefficient density threshold (DT) parameter.  This\n   parameter enables
      a sender to control the code density, i.e., the\n   proportion of coefficients
      that are nonzero on average.  With RLC\n   over GF(2^(8)), it is usually appropriate
      that small encoding windows\n   be associated to a density threshold equal to
      15, the maximum value,\n   in order to warrant a high loss protection.\n   On
      the opposite, with larger encoding windows, it is usually\n   appropriate that
      the density threshold be reduced.  With large\n   encoding windows, an alternative
      can be to use RLC over GF(2) and a\n   density threshold equal to 7 (i.e., an
      average density equal to 1/2)\n   or smaller.\n   Note that using a density
      threshold equal to 15 with RLC over GF(2)\n   is equivalent to using an XOR
      code that computes the XOR sum of all\n   the source symbols in the encoding
      window.  In that case: (1) only a\n   single repair symbol can be produced for
      any encoding window, and (2)\n   the repair_key parameter becomes useless (the
      coding coefficients\n   generation function does not rely on the PRNG).\n"
    title: '8.2.  Operational Recommendations: Coding Coefficients Density Threshold'
  title: 8.  Operations and Management Considerations
- contents:
  - "9.  IANA Considerations\n   This document registers two values in the \"FEC Framework
    (FECFRAME)\n   FEC Encoding IDs\" registry [RFC6363] as follows:\n   *  9 refers
    to the Sliding Window Random Linear Codes (RLC) over\n      GF(2) FEC Scheme for
    Arbitrary Packet Flows, as defined in\n      Section 5 of this document.\n   *
    \ 10 refers to the Sliding Window Random Linear Codes (RLC) over\n      GF(2^(8))
    FEC Scheme for Arbitrary Packet Flows, as defined in\n      Section 4 of this
    document.\n"
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [C99]      International Organization for Standardization,\n
      \             \"Programming languages - C: C99, correction 3:2007\", ISO/\n
      \             IEC 9899:1999/Cor 3:2007, November 2007.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC6363]  Watson, M., Begen, A., and V. Roca, \"Forward Error\n              Correction
      (FEC) Framework\", RFC 6363,\n              DOI 10.17487/RFC6363, October 2011,\n
      \             <https://www.rfc-editor.org/info/rfc6363>.\n   [RFC6364]  Begen,
      A., \"Session Description Protocol Elements for the\n              Forward Error
      Correction (FEC) Framework\", RFC 6364,\n              DOI 10.17487/RFC6364,
      October 2011,\n              <https://www.rfc-editor.org/info/rfc6364>.\n   [RFC8174]
      \ Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8680]  Roca, V. and A. Begen,
      \"Forward Error Correction (FEC)\n              Framework Extension to Sliding
      Window Codes\", RFC 8680,\n              DOI 10.17487/RFC8680, January 2020,\n
      \             <https://www.rfc-editor.org/info/rfc8680>.\n   [RFC8682]  Saito,
      M., Matsumoto, M., Roca, V., Ed., and E. Baccelli,\n              \"TinyMT32
      Pseudorandom Number Generator (PRNG)\", RFC 8682,\n              DOI 10.17487/RFC8682,
      January 2020,\n              <https://www.rfc-editor.org/info/rfc8682>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [PGM13]    Plank, J., Greenan, K., and E.
      Miller, \"A Complete\n              Treatment of Software Implementations of
      Finite Field\n              Arithmetic for Erasure Coding Applications\", University
      of\n              Tennessee Technical Report UT-CS-13-717, October 2013,\n              <http://web.eecs.utk.edu/~plank/plank/papers/UT-CS-\n
      \             13-717.html>.\n   [RFC5170]  Roca, V., Neumann, C., and D. Furodet,
      \"Low Density Parity\n              Check (LDPC) Staircase and Triangle Forward
      Error\n              Correction (FEC) Schemes\", RFC 5170, DOI 10.17487/RFC5170,\n
      \             June 2008, <https://www.rfc-editor.org/info/rfc5170>.\n   [RFC5510]
      \ Lacan, J., Roca, V., Peltotalo, J., and S. Peltotalo,\n              \"Reed-Solomon
      Forward Error Correction (FEC) Schemes\",\n              RFC 5510, DOI 10.17487/RFC5510,
      April 2009,\n              <https://www.rfc-editor.org/info/rfc5510>.\n   [RFC6681]
      \ Watson, M., Stockhammer, T., and M. Luby, \"Raptor Forward\n              Error
      Correction (FEC) Schemes for FECFRAME\", RFC 6681,\n              DOI 10.17487/RFC6681,
      August 2012,\n              <https://www.rfc-editor.org/info/rfc6681>.\n   [RFC6726]
      \ Paila, T., Walsh, R., Luby, M., Roca, V., and R. Lehtonen,\n              \"FLUTE
      - File Delivery over Unidirectional Transport\",\n              RFC 6726, DOI
      10.17487/RFC6726, November 2012,\n              <https://www.rfc-editor.org/info/rfc6726>.\n
      \  [RFC6816]  Roca, V., Cunche, M., and J. Lacan, \"Simple Low-Density\n              Parity
      Check (LDPC) Staircase Forward Error Correction\n              (FEC) Scheme
      for FECFRAME\", RFC 6816,\n              DOI 10.17487/RFC6816, December 2012,\n
      \             <https://www.rfc-editor.org/info/rfc6816>.\n   [RFC6865]  Roca,
      V., Cunche, M., Lacan, J., Bouabdallah, A., and K.\n              Matsuzono,
      \"Simple Reed-Solomon Forward Error Correction\n              (FEC) Scheme for
      FECFRAME\", RFC 6865,\n              DOI 10.17487/RFC6865, February 2013,\n
      \             <https://www.rfc-editor.org/info/rfc6865>.\n   [RFC8406]  Adamson,
      B., Adjih, C., Bilbao, J., Firoiu, V., Fitzek,\n              F., Ghanem, S.,
      Lochin, E., Masucci, A., Montpetit, M-J.,\n              Pedersen, M., Peralta,
      G., Roca, V., Ed., Saxena, P., and\n              S. Sivakumar, \"Taxonomy of
      Coding Techniques for Efficient\n              Network Communications\", RFC
      8406, DOI 10.17487/RFC8406,\n              June 2018, <https://www.rfc-editor.org/info/rfc8406>.\n
      \  [Roca16]   Roca, V., Teibi, B., Burdinat, C., Tran-Thai, T., and C.\n              Thienot,
      \"Block or Convolutional AL-FEC Codes? A\n              Performance Comparison
      for Robust Low-Latency\n              Communications\", HAL ID hal-01395937v2,
      February 2017,\n              <https://hal.inria.fr/hal-01395937/en/>.\n   [Roca17]
      \  Roca, V., Teibi, B., Burdinat, C., Tran, T., and C.\n              Thienot,
      \"Less Latency and Better Protection with AL-FEC\n              Sliding Window
      Codes: a Robust Multimedia CBR Broadcast\n              Case Study\", 13th IEEE
      International Conference on\n              Wireless and Mobile Computing, Networking
      and\n              Communications (WiMob17), HAL ID hal-01571609, October\n
      \             2017, <https://hal.inria.fr/hal-01571609v1/en/>.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  TinyMT32 Validation Criteria (Normative)\n   PRNG determinism, for
    a given seed, is a requirement.  Consequently,\n   in order to validate an implementation
    of the TinyMT32 PRNG, the\n   following criteria MUST be met.\n   The first criterion
    focuses on the tinymt32_rand256(), where the\n   32-bit integer of the core TinyMT32
    PRNG is scaled down to an 8-bit\n   integer.  Using a seed value of 1, the first
    50 values returned by:\n   tinymt32_rand256() as 8-bit unsigned integers MUST
    be equal to values\n   provided in Figure 9, to be read line by line.\n           37
    \       225        177        176         21\n          246         54        139
    \       168        237\n          211        187         62        190        104\n
    \         135        210         99        176         11\n          207         35
    \        40        113        179\n          214        254        101        212
    \       211\n          226         41        234        232        203\n           29
    \       194        211        112        107\n          217        104        197
    \       135         23\n           89        210        252        109        166\n
    \   Figure 9: First 50 decimal values (to be read per line) returned by\n   tinymt32_rand256()
    as 8-bit unsigned integers, with a seed value of 1\n   The second criterion focuses
    on the tinymt32_rand16(), where the\n   32-bit integer of the core TinyMT32 PRNG
    is scaled down to a 4-bit\n   integer.  Using a seed value of 1, the first 50
    values returned by:\n   tinymt32_rand16() as 4-bit unsigned integers MUST be equal
    to values\n   provided in Figure 10, to be read line by line.\n            5          1
    \         1          0          5\n            6          6         11          8
    \        13\n            3         11         14         14          8\n            7
    \         2          3          0         11\n           15          3          8
    \         1          3\n            6         14          5          4          3\n
    \           2          9         10          8         11\n           13          2
    \         3          0         11\n            9          8          5          7
    \         7\n            9          2         12         13          6\n    Figure
    10: First 50 decimal values (to be read per line) returned by\n    tinymt32_rand16()
    as 4-bit unsigned integers, with a seed value of 1\n"
  title: Appendix A.  TinyMT32 Validation Criteria (Normative)
- contents:
  - "Appendix B.  Assessing the PRNG Adequacy (Informational)\n   This annex discusses
    the adequacy of the TinyMT32 PRNG and the\n   tinymt32_rand16() and tinymt32_rand256()
    functions, to the RLC FEC\n   schemes.  The goal is to assess the adequacy of
    these two functions\n   in producing coding coefficients that are sufficiently
    different from\n   one another, across various repair symbols with repair key
    values in\n   sequence (we can expect this approach to be commonly used by\n   implementers,
    see Section 6.1).  This section is purely informational\n   and does not claim
    to be a solid evaluation.\n   The two RLC FEC schemes use the PRNG to produce
    pseudorandom coding\n   coefficients (Section 3.6), each time a new repair symbol
    is needed.\n   A different repair key is used for each repair symbol, usually
    by\n   incrementing the repair key value (Section 6.1).  For each repair\n   symbol,
    a limited number of pseudorandom numbers is needed, depending\n   on the DT and
    encoding window size (Section 3.6), using either\n   tinymt32_rand16() or tinymt32_rand256().
    \ Therefore, we are more\n   interested in the randomness of small sequences of
    random numbers\n   mapped to 4-bit or 8-bit integers, than in the randomness of
    a very\n   large sequence of random numbers which is not representative of the\n
    \  usage of the PRNG.\n   Evaluation of tinymt32_rand16(): We first generate a
    huge number\n   (1,000,000,000) of small sequences (20 pseudorandom numbers per\n
    \  sequence), increasing the seed value for each sequence, and perform\n   statistics
    on the number of occurrences of each of the 16 possible\n   values across all
    sequences.  In this first test we consider 32-bit\n   seed values in order to
    assess the PRNG quality after output\n   truncation to 4 bits.\n                 |
    Value | Occurrences | Percentage (%) |\n                 | 0     | 1250036799
    \ | 6.2502         |\n                 | 1     | 1249995831  | 6.2500         |\n
    \                | 2     | 1250038674  | 6.2502         |\n                 |
    3     | 1250000881  | 6.2500         |\n                 | 4     | 1250023929
    \ | 6.2501         |\n                 | 5     | 1249986320  | 6.2499         |\n
    \                | 6     | 1249995587  | 6.2500         |\n                 |
    7     | 1250020363  | 6.2501         |\n                 | 8     | 1249995276
    \ | 6.2500         |\n                 | 9     | 1249982856  | 6.2499         |\n
    \                | 10    | 1249984111  | 6.2499         |\n                 |
    11    | 1250009551  | 6.2500         |\n                 | 12    | 1249955768
    \ | 6.2498         |\n                 | 13    | 1249994654  | 6.2500         |\n
    \                | 14    | 1250000569  | 6.2500         |\n                 |
    15    | 1249978831  | 6.2499         |\n                        Table 1: tinymt32_rand16()\n
    \                         Occurrence Statistics\n   Evaluation of tinymt32_rand16():
    We first generate a huge number\n   (1,000,000,000) of small sequences (20 pseudorandom
    numbers per\n   sequence), increasing the seed value for each sequence, and perform\n
    \  statistics on the number of occurrences of each of the 16 possible\n   values
    across the 20,000,000,000 numbers of all sequences.  In this\n   first test, we
    consider 32-bit seed values in order to assess the\n   PRNG quality after output
    truncation to 4 bits.\n   The results (Table 1) show that all possible values
    are almost\n   equally represented, or said differently, that the tinymt32_rand16()\n
    \  output converges to a uniform distribution where each of the 16\n   possible
    values would appear exactly 1 / 16 * 100 = 6.25% of times.\n   Since the RLC FEC
    schemes use of this PRNG will be limited to 16-bit\n   seed values, we carried
    out the same test for the first 2^(16) seed\n   values only.  The distribution
    (not shown) is of course less uniform,\n   with value occurrences ranging between
    6.2121% (i.e., 81,423\n   occurrences out of a total of 65536*20=1,310,720) and
    6.2948% (i.e.,\n   82,507 occurrences).  However, we do not believe it significantly\n
    \  impacts the RLC FEC scheme behavior.\n   Other types of biases may exist that
    may be visible with smaller\n   tests, for instance to evaluate the convergence
    speed to a uniform\n   distribution.  We therefore perform 200 tests, each of
    them producing\n   200 sequences, keeping only the first value of each sequence.
    \ We use\n   non-overlapping repair keys for each sequence, starting with value
    0\n   and increasing it after each use.\n    | Value | Min Occurrences | Max Occurrences
    | Average Occurrences |\n    | 0     | 4               | 21              | 6.3675
    \             |\n    | 1     | 4               | 22              | 6.0200              |\n
    \   | 2     | 4               | 20              | 6.3125              |\n    |
    3     | 5               | 23              | 6.1775              |\n    | 4     |
    5               | 24              | 6.1000              |\n    | 5     | 4               |
    21              | 6.5925              |\n    | 6     | 5               | 30              |
    6.3075              |\n    | 7     | 6               | 22              | 6.2225
    \             |\n    | 8     | 5               | 26              | 6.1750              |\n
    \   | 9     | 3               | 21              | 5.9425              |\n    |
    10    | 5               | 24              | 6.3175              |\n    | 11    |
    4               | 22              | 6.4300              |\n    | 12    | 5               |
    21              | 6.1600              |\n    | 13    | 5               | 22              |
    6.3100              |\n    | 14    | 4               | 26              | 6.3950
    \             |\n    | 15    | 4               | 21              | 6.1700              |\n
    \             Table 2: tinymt32_rand16() Occurrence Statistics\n   Table 2 shows
    across all 200 tests, for each of the 16 possible\n   pseudorandom number values,
    the minimum (resp. maximum) number of\n   times it appeared in a test, as well
    as the average number of\n   occurrences across the 200 tests.  Although the distribution
    is not\n   perfect, there is no major bias.  On the contrary, in the same\n   conditions,
    the Park-Miller linear congruential PRNG of [RFC5170]\n   with a result scaled
    down to 4-bit values, using seeds in sequence\n   starting from 1, systematically
    returns 0 as the first value during\n   some time.  Then, after a certain repair
    key value threshold, it\n   systematically returns 1, etc.\n   Evaluation of tinymt32_rand256():
    The same approach is used here.\n   Results (not shown) are similar: occurrences
    vary between 7,810,3368\n   (i.e., 0.3905%) and 7,814,7952 (i.e., 0.3907%).  Here
    also we see a\n   convergence to the theoretical uniform distribution where each
    of the\n   256 possible values would appear exactly 1 / 256 * 100 = 0.390625%
    of\n   times.\n"
  title: Appendix B.  Assessing the PRNG Adequacy (Informational)
- contents:
  - "Appendix C.  Possible Parameter Derivation (Informational)\n   Section 3.1 defines
    several parameters to control the encoder or\n   decoder.  This annex proposes
    techniques to derive these parameters\n   according to the target use-case.  This
    annex is informational, in\n   the sense that using a different derivation technique
    will not\n   prevent the encoder and decoder to interoperate: a decoder can still\n
    \  recover an erased source symbol without any error.  However, in case\n   of
    a real-time flow, an inappropriate parameter derivation may lead\n   to the decoding
    of erased source packets after their validity period,\n   making them useless
    to the target application.  This annex proposes\n   an approach to reduce this
    risk, among other things.\n   The FEC schemes defined in this document can be
    used in various\n   manners, depending on the target use-case:\n   *  the source
    ADU flow they protect may or may not have real-time\n      constraints;\n   *
    \ the source ADU flow may be a Constant Bitrate (CBR) or Variable\n      Bitrate
    (VBR) flow;\n   *  with a VBR source ADU flow, the flow's minimum and maximum\n
    \     bitrates may or may not be known;\n   *  and the communication path between
    encoder and decoder may be a\n      CBR communication path (e.g., as with certain
    LTE-based broadcast\n      channels) or not (general case, e.g., with Internet).\n
    \  The parameter derivation technique should be suited to the use-case,\n   as
    described in the following sections.\n"
  - contents:
    - "C.1.  Case of a CBR Real-Time Flow\n   In the following, we consider a real-time
      flow with max_lat latency\n   budget.  The encoding symbol size, E, is constant.
      \ The code rate,\n   cr, is also constant, its value depending on the expected\n
      \  communication loss model (this choice is out of scope of this\n   document).\n
      \  In a first configuration, the source ADU flow bitrate at the input of\n   the
      FECFRAME sender is fixed and equal to br_in (in bits/s), and this\n   value
      is known by the FECFRAME sender.  It follows that the\n   transmission bitrate
      at the output of the FECFRAME sender will be\n   higher, depending on the added
      repair flow overhead.  In order to\n   comply with the maximum FEC-related latency
      budget, we have:\n      dw_max_size = (max_lat * br_in) / (8 * E)\n   assuming
      that the encoding and decoding times are negligible with\n   respect to the
      target max_lat.  This is a reasonable assumption in\n   many situations (e.g.,
      see Section 8.1 in case of small window\n   sizes).  Otherwise the max_lat parameter
      should be adjusted in order\n   to avoid the problem.  In any case, interoperability
      will never be\n   compromised by choosing a too large value.\n   In a second
      configuration, the FECFRAME sender generates a fixed\n   bitrate flow, equal
      to the CBR communication path bitrate equal to\n   br_out (in bits/s), and this
      value is known by the FECFRAME sender,\n   as in [Roca17].  The maximum source
      flow bitrate needs to be such\n   that, with the added repair flow overhead,
      the total transmission\n   bitrate remains inferior or equal to br_out.  We
      have:\n      dw_max_size = (max_lat * br_out * cr) / (8 * E)\n   assuming here
      also that the encoding and decoding times are\n   negligible with respect to
      the target max_lat.\n   For decoding to be possible within the latency budget,
      it is required\n   that the encoding window maximum size be smaller than or
      at most\n   equal to the decoding window maximum size.  The ew_max_size is the\n
      \  main parameter at a FECFRAME sender, but its exact value has no\n   impact
      on the FEC-related latency budget.  The ew_max_size parameter\n   is computed
      as follows:\n      ew_max_size = dw_max_size * WSR / 255\n   In line with [Roca17],
      WSR = 191 is considered as a reasonable value\n   (the resulting encoding to
      decoding window size ratio is then close\n   to 0.75), but other values between
      1 and 255 inclusive are possible,\n   depending on the use-case.\n   The dw_max_size
      is computed by a FECFRAME sender but not explicitly\n   communicated to a FECFRAME
      receiver.  However, a FECFRAME receiver\n   can easily evaluate the ew_max_size
      by observing the maximum Number\n   of Source Symbols (NSS) value contained
      in the Repair FEC Payload ID\n   of received FEC Repair Packets (Section 4.1.3).
      \ A receiver can then\n   easily compute dw_max_size:\n      dw_max_size = max_NSS_observed
      * 255 / WSR\n   A receiver can then choose an appropriate linear system maximum
      size:\n      ls_max_size >= dw_max_size\n   It is good practice to use a larger
      value for ls_max_size as\n   explained in Appendix D, which does not impact
      maximum latency nor\n   interoperability.\n   In any case, for a given use-case
      (i.e., for target encoding and\n   decoding devices and desired protection levels
      in front of\n   communication impairments) and for the computed ew_max_size,\n
      \  dw_max_size and ls_max_size values, it is RECOMMENDED to check that\n   the
      maximum encoding time and maximum memory requirements at a\n   FECFRAME sender,
      and maximum decoding time and maximum memory\n   requirements at a FECFRAME
      receiver, stay within reasonable bounds.\n   When assuming that the encoding
      and decoding times are negligible\n   with respect to the target max_lat, this
      should be verified as well,\n   otherwise the max_lat SHOULD be adjusted accordingly.\n
      \  The particular case of session start needs to be managed\n   appropriately
      since the ew_size, starting at zero, increases each\n   time a new source ADU
      is received by the FECFRAME sender, until it\n   reaches the ew_max_size value.
      \ Therefore, a FECFRAME receiver SHOULD\n   continuously observe the received
      FEC Repair Packets, since the NSS\n   value carried in the Repair FEC Payload
      ID will increase too, and\n   adjust its ls_max_size accordingly if need be.
      \ With a CBR flow,\n   session start is expected to be the only moment when
      the encoding\n   window size will increase.  Similarly, with a CBR real-time
      flow, the\n   session end is expected to be the only moment when the encoding\n
      \  window size will progressively decrease.  No adjustment of the\n   ls_max_size
      is required at the FECFRAME receiver in that case.\n"
    title: C.1.  Case of a CBR Real-Time Flow
  - contents:
    - "C.2.  Other Types of Real-Time Flow\n   In the following, we consider a real-time
      source ADU flow with a\n   max_lat latency budget and a variable bitrate (VBR)
      measured at the\n   entry of the FECFRAME sender.  A first approach consists
      in\n   considering the smallest instantaneous bitrate of the source ADU\n   flow,
      when this parameter is known, and to reuse the derivation of\n   Appendix C.1.
      \ Considering the smallest bitrate means that the\n   encoding and decoding
      window maximum size estimations are\n   pessimistic: these windows have the
      smallest size required to enable\n   on-time decoding at a FECFRAME receiver.
      \ If the instantaneous\n   bitrate is higher than this smallest bitrate, this
      approach leads to\n   an encoding window that is unnecessarily small, which
      reduces\n   robustness in front of long erasure bursts.\n   Another approach
      consists in using ADU timing information (e.g.,\n   using the timestamp field
      of an RTP packet header, or registering the\n   time upon receiving a new ADU).
      \ From the global FEC-related latency\n   budget, the FECFRAME sender can derive
      a practical maximum latency\n   budget for encoding operations, max_lat_for_encoding.
      \ For the FEC\n   schemes specified in this document, this latency budget SHOULD
      be\n   computed with:\n      max_lat_for_encoding = max_lat * WSR / 255\n   It
      follows that any source symbols associated to an ADU that has\n   timed-out
      with respect to max_lat_for_encoding SHOULD be removed from\n   the encoding
      window.  With this approach there is no pre-determined\n   ew_size value: this
      value fluctuates over the time according to the\n   instantaneous source ADU
      flow bitrate.  For practical reasons, a\n   FECFRAME sender may still require
      that ew_size does not increase\n   beyond a maximum value (Appendix C.3).\n
      \  With both approaches, and no matter the choice of the FECFRAME\n   sender,
      a FECFRAME receiver can still easily evaluate the ew_max_size\n   by observing
      the maximum Number of Source Symbols (NSS) value\n   contained in the Repair
      FEC Payload ID of received FEC Repair\n   Packets.  A receiver can then compute
      dw_max_size and derive an\n   appropriate ls_max_size as explained in Appendix
      C.1.\n   When the observed NSS fluctuates significantly, a FECFRAME receiver\n
      \  may want to adapt its ls_max_size accordingly.  In particular when\n   the
      NSS is significantly reduced, a FECFRAME receiver may want to\n   reduce the
      ls_max_size too in order to limit computation complexity.\n   A balance must
      be found between using an ls_max_size \"too large\"\n   (which increases computation
      complexity and memory requirements) and\n   the opposite (which reduces recovery
      performance).\n"
    title: C.2.  Other Types of Real-Time Flow
  - contents:
    - "C.3.  Case of a Non-Real-Time Flow\n   Finally there are configurations where
      a source ADU flow has no real-\n   time constraints.  FECFRAME and the FEC schemes
      defined in this\n   document can still be used.  The choice of appropriate parameter\n
      \  values can be directed by practical considerations.  For instance, it\n   can
      derive from an estimation of the maximum memory amount that could\n   be dedicated
      to the linear system at a FECFRAME receiver, or the\n   maximum computation
      complexity at a FECFRAME receiver, both of them\n   depending on the ls_max_size
      parameter.  The same considerations also\n   apply to the FECFRAME sender, where
      the maximum memory amount and\n   computation complexity depend on the ew_max_size
      parameter.\n   Here also, the NSS value contained in FEC Repair Packets is used
      by a\n   FECFRAME receiver to determine the current coding window size and\n
      \  ew_max_size by observing its maximum value over the time.\n"
    title: C.3.  Case of a Non-Real-Time Flow
  title: Appendix C.  Possible Parameter Derivation (Informational)
- contents:
  - "Appendix D.  Decoding Beyond Maximum Latency Optimization\n             (Informational)\n
    \  This annex introduces non-normative considerations.  It is provided\n   as
    suggestions, without any impact on interoperability.  For more\n   information
    see [Roca16].\n   With a real-time source ADU flow, it is possible to improve
    the\n   decoding performance of Sliding Window Codes without impacting\n   maximum
    latency, at the cost of extra memory and CPU overhead.  The\n   optimization consists,
    for a FECFRAME receiver, to extend the linear\n   system beyond the decoding window
    maximum size, by keeping a certain\n   number of old source symbols whereas their
    associated ADUs timed-out:\n      ls_max_size > dw_max_size\n   Usually the following
    choice is a good trade-off between decoding\n   performance and extra CPU overhead:\n
    \     ls_max_size = 2 * dw_max_size\n   When the dw_max_size is very small, it
    may be preferable to keep a\n   minimum ls_max_size value (e.g., LS_MIN_SIZE_DEFAULT
    = 40 symbols).\n   Going below this threshold will not save a significant amount
    of\n   memory nor CPU cycles.  Therefore:\n      ls_max_size = max(2 * dw_max_size,
    LS_MIN_SIZE_DEFAULT)\n   Finally, it is worth noting that a receiver that benefits
    from an FEC\n   protection significantly higher than what is required to recover
    from\n   packet losses, can choose to reduce the ls_max_size.  In that case\n
    \  lost ADUs will be recovered without relying on this optimization.\n           late
    source symbols\n    (pot. decoded but not delivered)            dw_max_size\n
    \  src0 src1 src2 src3 src4 src5 src6 src7 src8 src9 src10 src11 src12\n        Figure
    11: Relationship between Parameters to Decode beyond\n                              Maximum
    Latency\n   It means that source symbols, and therefore ADUs, may be decoded even\n
    \  if the added latency exceeds the maximum value permitted by the\n   application
    (the \"late source symbols\" of Figure 11).  It follows\n   that the corresponding
    ADUs will not be useful to the application.\n   However, decoding these \"late
    symbols\" significantly improves the\n   global robustness in bad reception conditions
    and is therefore\n   recommended for receivers experiencing bad communication
    conditions\n   [Roca16].  In any case whether or not to use this optimization
    and\n   what exact value to use for the ls_max_size parameter are local\n   decisions
    made by each receiver independently, without any impact on\n   the other receivers
    nor on the source.\n"
  title: Appendix D.  Decoding Beyond Maximum Latency Optimization
- contents:
  - "Acknowledgments\n   The authors would like to thank the three TSVWG chairs, Wesley
    Eddy\n   (our shepherd), David Black, and Gorry Fairhurst; as well as Spencer\n
    \  Dawkins, our responsible AD; and all those who provided comments --\n   namely
    (in alphabetical order), Alan DeKok, Jonathan Detchart, Russ\n   Housley, Emmanuel
    Lochin, Marie-Jose Montpetit, and Greg Skinner.\n   Last but not least, the authors
    are really grateful to the IESG\n   members, in particular Benjamin Kaduk, Mirja
    Kuehlewind, Eric\n   Rescorla, Adam Roach, and Roman Danyliw for their highly
    valuable\n   feedback that greatly contributed to improving this specification.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Vincent Roca\n   INRIA\n   Univ. Grenoble Alpes\n   France\n
    \  Email: vincent.roca@inria.fr\n   Belkacem Teibi\n   INRIA\n   Univ. Grenoble
    Alpes\n"
  title: Authors' Addresses
