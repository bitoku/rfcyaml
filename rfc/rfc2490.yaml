- title: __initial_text__
  contents:
  - '             A Simulation Model for IP Multicast with RSVP

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a detailed model of IPv4 multicast with\
    \ RSVP\n   that has been developed using the OPNET simulation package [4], with\n\
    \   protocol procedures defined in the C language.  The model was\n   developed\
    \ to allow investigation of performance constraints on\n   routing but should\
    \ have wide applicability in the Internet\n   multicast/resource reservation community.\
    \  We are making this model\n   publicly available with the intention that it\
    \ can be used to provide\n   expanded studies of resource-reserved multicasting.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Background                                         \
    \         2\n   2. The OPNET Simulation Environment                          \
    \  3\n   3. IP Multicast Model                                          3\n  \
    \         3.1 Address Format                                     3\n         \
    \  3.2 Network Layer                                      4\n           3.3 Node\
    \ layer                                         5\n   4. RSVP Model          \
    \                                       13\n           4.1 RSVP Application  \
    \                                13\n           4.2 RSVP on Routers          \
    \                         14\n           4.3 RSVP on Hosts                   \
    \                  17\n   5. Multicast Routing Model Interface               \
    \           19\n           5.1 Creation of multicast routing processor node  \
    \    19\n           5.2 Interfacing processor nodes                       19\n\
    \           5.3 Interrupt Generation                              21\n       \
    \    5.4 Modifications of modules in the process model     22\n   6. OSPF and\
    \ MOSPF Models                                      23\n           6.1 Init  \
    \                                            23\n           6.2 Idle         \
    \                                     23\n           6.3 BCOspfLsa           \
    \                              23\n           6.4 BCMospfLsa                 \
    \                       23\n           6.5 Arr                               \
    \                23\n           6.6 Hello_pks                                \
    \         24\n           6.7 Mospfspfcalc                                    \
    \  24\n           6.8 Ospfspfcalc                                       25\n \
    \          6.9 UpstrNode                                         25\n        \
    \   6.10 DABRA                                            25\n   7. DVMRP Model\
    \                                                26\n           7.1 Init     \
    \                                         26\n           7.2 Idle            \
    \                                  26\n           7.3 Probe_Send State       \
    \                           26\n           7.4 Report_Send                   \
    \                    26\n           7.5 Prune _Send                          \
    \             26\n           7.6 Graft_send                                  \
    \      27\n           7.7 Arr_Pkt                                           27\n\
    \           7.8 Route_Calc                                        28\n       \
    \    7.9 Timer                                             28\n   8. Simulation\
    \ performance                                     28\n   9. Future Work      \
    \                                          29\n   10. Security Considerations\
    \                                   29\n   11. References                    \
    \                            29\n   Authors' Addresses                       \
    \                     30\n   Full Copyright Statement                        \
    \              31\n"
- title: 1. Background
  contents:
  - "1. Background\n   The successful deployment of IP multicasting [1] and its availability\n\
    \   in the Mbone has led to continuing increase in real-time multimedia\n   Internet\
    \ applications.  Because the Internet has traditionally\n   supported only a best-effort\
    \ quality of service, there is\n   considerable interest to create mechanisms\
    \ that will allow adequate\n   resources to be reserved in networks using the\
    \ Internet protocol\n   suite, such that the quality of real-time traffic such\
    \ as video,\n   voice, and distributed simulation can be sustained at specified\n\
    \   levels.  The RSVP protocol [2] has been developed for this purpose\n   and\
    \ is the subject of ongoing implementation efforts. Although the\n   developers\
    \ of RSVP have used simulation in their design process, no\n   simulation of IPmc\
    \ with RSVP has been generally available for\n   analysis of the performance and\
    \ prediction of the behavior of these\n   protocols.  The simulation model described\
    \ here was developed to fill\n   this gap, and is explicitly intended to be made\
    \ available to the IETF\n   community.\n"
- title: 2.  The OPNET Simulation Environment
  contents:
  - "2.  The OPNET Simulation Environment\n   The Optimized Network Engineering Tools\
    \ (OPNET) is a commercial\n   simulation product of the MIL3 company of Arlington,\
    \ VA.  It employs\n   a Discrete Event Simulation approach that allows large numbers\
    \ of\n   closely-spaced events in a sizable network to be represented\n   accurately\
    \ and efficiently. OPNET uses a modeling approach where\n   networks are built\
    \ of components interconnected by perfect links that\n   can be degraded at will.\
    \  Each component's behavior is modeled as a\n   state-transition diagram.  The\
    \ process that takes place in each state\n   is described by a program in the\
    \ C language. We believe this makes\n   the OPNET-based models relatively easy\
    \ to port to other modeling\n   environments. This family of models is compatible\
    \ with OPNET 3.5.\n   The following sections describe the state-transition models\
    \ and\n   process code for the IPmc and RSVP models we have created using\n  \
    \ OPNET. Please note that an OPNET layer is not necessarily equivalent\n   to\
    \ a layer in a network stack, but shares with a stack layer the\n   property that\
    \ it is a highly modular software element with well\n   defined interfaces.\n"
- title: 3.  IP Multicast Model
  contents:
  - "3.  IP Multicast Model\n   The following processing takes place in the indicated\
    \ modules. Each\n   subsection below describes in detail a layer in the host and\
    \ the\n   router that can be simulated with the help of the corresponding OPNET\n\
    \   network layer or node layer or the process layer, starting from\n   physical\
    \ layer.\n"
- title: 3.1 Address format
  contents:
  - "3.1 Address format\n   The OPNET IP model has only one type of addressing denoted\
    \ by \"X.Y\"\n   where X is 24 bits long and Y is 8 bits long, corresponding to\
    \ an\n   IPv4 Class C network.  The X indicates the destination or the source\n\
    \   network number and Y indicates the destination or the source node\n   number.\
    \  In our model X = 500 is reserved for multicast traffic.  For\n   multicast\
    \ traffic the value of Y indicates the group to which the\n   packet belongs.\n"
- title: 3.2 Network Layer
  contents:
  - "3.2 Network Layer\n   Figure 1 describes an example network topology built using\
    \ the OPNET\n   network editor.  This network consists of two backbone routers\
    \ BBR1,\n   BBR2, three area border routers ABR1, ABR2,  ABR3 and six subnets\
    \ F1,\n   through F6.  As OPNET has no full duplex link model, each connecting\n\
    \   link is modeled as two simplex links enabling bidirectional traffic.\n   \
    \              [Figure 1: Network Layer of Debug Model]\n"
- title: 3.2.1 Attributes
  contents:
  - "3.2.1 Attributes\n   The attributes of the elements of the network layer are:\n\
    \   a. Area Border Routers and Backbone Routers\n     1. IP address of each active\
    \ interface of each router\n        (network_id.node_id)\n     2. Service rate\
    \ of the IP layer (packets/sec)\n     3. Transmission speeds of each active interface\
    \ (bits/sec)\n   b. Subnets\n     1. IP address of each active interface of the\
    \ router in the subnet\n     2. IP address of the hosts in each of the subnet.\n\
    \     3. Service rate of the IP layer in the subnet router and the hosts.\n  \
    \ c. Simplex links\n     1. Propagation delay in the links\n     2. The process\
    \ model to be used for simulating the simplex links\n        (this means whether\
    \ animation is included or not).\n"
- title: 3.2.2 LAN Subnets
  contents:
  - "3.2.2 LAN Subnets\n   Figure 2 shows the FDDI ring as used in a subnet. The subnet\
    \ will\n   have one router and one or more hosts.  The router in the subnet is\n\
    \   included to route the traffic between the FDDI ring or Ethernet in\n   the\
    \ corresponding subnet and the external network.  The subnet router\n   is connected\
    \ on one end to Ethernet or FDDI ring and normally also is\n   connected to an\
    \ area border router on another interface (the area\n   border routers may be\
    \ connected to more than one backbone router). In\n   the Ethernet all the hosts\
    \ are connected to the bus, while in FDDI\n   the hosts are interconnected in\
    \ a ring as illustrated in Figure 2.\n                    [Figure 2: FDDI Ring\
    \ Subnet Layer]\n   FDDI provides general purpose networking at 100 Mb/sec transmission\n\
    \   rates for large numbers of communicating stations configured in a\n   ring\
    \ topology.  Use of ring bandwidth is controlled through a timed\n   token rotation\
    \ protocol, wherein stations must receive a token and\n   meet with a set of timing\
    \ and priority criteria before transmitting\n   frames.  In order to accommodate\
    \ network applications in which\n   response times are critical,  FDDI provides\
    \ for deterministic\n   availability of ring bandwidth by defining a synchronous\
    \ transmission\n   service. Asynchronous frame transmission requests dynamically\
    \ share\n   the remaining ring bandwidth.\n   Ethernet is a bus-based local area\
    \ network (LAN) technology.  The\n   operation of the LAN is managed by a media\
    \ access protocol (MAC)\n   following the IEEE 802.3 standard, providing Carrier\
    \ Sense Multiple\n   Access with Collision Detection (CSMA/CD) for the LAN channel.\n"
- title: 3.3 Node layer
  contents:
  - "3.3 Node layer\n   This section discusses the internal structure of hosts and\
    \ routers\n   with the help of node level illustrations built using the Node editor\n\
    \   of OPNET.\n"
- title: 3.3.1 Basic OPNET elements
  contents:
  - "3.3.1 Basic OPNET elements\n   The basic elements of a node level illustration\
    \ are\n   a. Processor nodes: Processor nodes are used for processing incoming\n\
    \   packets and generating packets with a specified packet format.\n   b. Queue\
    \ node: Queue nodes are a superset of processor nodes. In\n   addition to the\
    \ capabilities of processor nodes,  queue nodes also\n   have capability to store\
    \ packets in one or more queues.\n   c. Transmitter and Receiver nodes: Transmitters\
    \ simulate the link\n   behavior effect of packet transmission and Receivers simulate\
    \ the\n   receiving effects of packet reception.  The transmission rate is an\n\
    \   attribute of the transmitter and receiving rate is an attribute of\n   the\
    \ receiver. These values together decide the transmission delay of\n   a packet.\n\
    \   d. Packet streams: Packet streams are used to interconnect the above\n   described\
    \ nodes.\n   e. Statistic streams:  Statistic streams are used to convey\n   information\
    \ between the different nodes: Processor, Queue,\n   Transmitters and Receivers\
    \ nodes respectively.\n"
- title: 3.3.2 Host description
  contents:
  - "3.3.2 Host description\n   The host model built using OPNET has a layered structure.\
    \ Different\n   from the OPNET layers (Network, Node and Process layer) that describe\n\
    \   the network at different levels, protocol stack elements are\n   implemented\
    \ at OPNET nodes. Figure 3 shows the node level structure\n   of a FDDI host.\n\
    \                      [Figure 3: Node Level of Host]\n   a. MAC queue node: The\
    \ MAC interfaces on one side to the physical\n   layer through the transmitter\
    \ (phy_tx) and receiver (phy_rx) and also\n   provides services to the IP layer.\
    \  Use of ring bandwidth is\n   controlled through a timed token rotation protocol,\
    \ wherein hosts\n   must receive a token and meet with a set of timing and priority\n\
    \   criteria before transmitting frames.  When a frame arrives at the MAC\n  \
    \ node, the node performs one of the following actions:\n     1. If the owner\
    \ of the frame is this MAC, the MAC layer destroys\n        the frame since the\
    \ frame has finished circulating through the\n        FDDI ring.\n     2. if the\
    \ frame is destined for this host, the MAC layer makes a\n        copy of the\
    \ frame, decapsulates the frame and sends the\n        descapsulated frame (packet)\
    \ to the IP layer.  The original\n        frame is transmitted to the next host\
    \ in the FDDI ring\n     3. if the owner of the frame is any other host and the\
    \ frame is not\n        destined for this host, the frame is forwarded to the\
    \ adjacent\n        host.\n   b. ADDR_TRANS processor node: The next layer above\
    \ the MAC layer is\n   the addr_trans processor node. This layer provides service\
    \ to the IP\n   layer by carrying out the function of translating the IP address\
    \ to\n   physical interface address.  This layer accepts packets from the IP\n\
    \   layer with the next node information, maps the next node information\n   to\
    \ a physical address and forwards the packet for transmission.  This\n   service\
    \ is required only in one direction from the IP layer to the\n   MAC layer.  Since\
    \ queuing is not done at this level, a processor node\n   is used to accomplish\
    \ the address translation function, from IP to\n   MAC address (ARP).\n   c. IP\
    \ queue node: Network routing/forwarding in the hierarchy is\n   implemented here.\
    \ IP layer provides service for the layers above\n   which are the different higher\
    \ level protocols by utilizing the\n   services provided by the MAC layer.  For\
    \ packets arriving from the\n   MAC layer, the IP layer decapsulates the packet\
    \ and forwards the\n   information to an upper layer protocol based upon the value\
    \ of the\n   protocol ID in the IP header.  For packets arriving from upper layer\n\
    \   protocols,  the IP layer obtains the destination address,  calculates\n  \
    \ the next node address from the routing table, encapsulates it with a\n   IP\
    \ header and forwards the packet to the addr_trans node with the\n   next node\
    \ information.\n   The IP node is a queue node. It is in this layer that packets\
    \ incur\n   delay which simulates the processing capability of a host and\n  \
    \ queueing for use of the outgoing link.  A packet arrival to the IP\n   layer\
    \ will be queued and experience delay when it finds another\n   packet already\
    \ being transmitted, plus possibly other packets queued\n   for transmission.\
    \  The packets arriving at the IP layer are queued\n   and operate with a first-in\
    \ first-out (FIFO) discipline.  The queue\n   size, service rate of the IP layer\
    \ are both promoted attributes,\n   specified at the simulation run level by the\
    \ environment file.\n   d. IGMP processor node: The models described above are\
    \ standard\n   components available in OPNET libraries.  We have added to these\
    \ the\n   host multicast protocol model IGMP_host, the router multicast model\n\
    \   IGMP_gwy, and the unicast best-effort protocol model UBE.\n   The IGMP_host\
    \ node (Figure 4) is a process node.  Packets are not\n   queued in this layer.\
    \  IGMP_host provides unique group management\n   services for the multicast applications\
    \ utilizing the services\n   provided by the IP layer. IGMP_host maintains a single\
    \ table which\n   consists of group membership information of the application\
    \ above the\n   IGMP layer.  The function performed by the IGMP_host layer depends\n\
    \   upon the type of the packet received and the source of the packet.\n     \
    \                [Figure 4: IGMP process on hosts]\n   The IGMP_host layer expects\
    \ certain type of packets from the\n   application layer and from the network:\n\
    \   1. Accept join group requests from the application layer (which can\n    \
    \  be one or more applications):  IGMP_host maintains a table which\n      consists\
    \ of the membership information for each group.  When a\n      application sends\
    \ a  join request,  it requests to join a specific\n      group N.  The membership\
    \ information is updated.  This new group\n      membership information has to\
    \ be conveyed to the nearest router\n      and to the MAC layer.  If the IGMP_host\
    \ is already a member ofthis\n      group (i.e. if another application above the\
    \ IGMP_host is a member\n      of the group N), the IGMP_host does not have to\
    \ send a message to\n      the router or indicate to the MAC layer.  If the IGMP_host\
    \ is not\n      a member currently,  the IGMP_host generates a join request for\n\
    \      the group N (this is called a \"response\" in RFC 1112) and forwards\n\
    \      it to the IP layer to be sent to the nearest router.  In addition\n   \
    \   the IGMP_host also conveys this membership information to the MAC\n      layer\
    \ interfacing to the physical layer through the OPNET\n      \"statistic wire\"\
    \ connected from the IGMP_host to the MAC layer, so\n      that the MAC layer\
    \ knows the membership information immediately\n      and begins to accept the\
    \ frames destined for the group N. (An\n      OPNET statistic wire is a virtual\
    \ path to send information between\n      OPNET models.)\n   2. Accept queries\
    \ arriving from the nearest router and send responses\n      based on the membership\
    \ information in the multicast table at the\n      IGMP_host layer:  A query is\
    \ a message from a router inquiring\n      each host on the router's interface\
    \ about group membership\n      information. When the IGMP_host receives a query,\
    \ it looks up the\n      multicast group membership table, to determine if any\
    \ of the\n      host's applications are registered for any  group.  If any\n \
    \     registration exists, the IGMP_host schedules an event to generate\n    \
    \  a response after a random amount of time corresponding to each\n      active\
    \ group.  The Ethernet example in Figure 5 and the\n      description in the following\
    \ section describes the scenario.\n                   ---------------------------------------\n\
    \                        |        |         |         |\n                    \
    \    |        |         |         |\n                      +---+    +---+    \
    \ +---+     +---+\n                      | H1|    | H2|     | H3|     | R |\n\
    \                      +---+    +---+     +---+     +---+\n           Figure 5:\
    \ An Ethernet example of IGMP response schedule\n      The router R interfaces\
    \ with the subnet on one interface I1 and to\n      reach the hosts.  To illustrate\
    \ this let us assume that hosts H1\n      and H3 are members of group N1 and H2\
    \ is a  member of group N2.\n      When the router sends a query, all the hosts\
    \ receive the query at\n      the same time t0.  IGMP_host in H1 schedules an\
    \ event to generate\n      a response at a randomly generated time t1 (t1 >= t0)\
    \ which will\n      indicate the host H1 is a member of group N1.  Similarly H2\
    \ will\n      schedule an event to generate a response at t2 (t2 >= t0)to\n  \
    \    indicate membership in group N2 and H3 at t3 (t3 >= t0) to\n      indicate\
    \ membership in group N3.  When the responses are\n      generated, the responses\
    \ are sent with destination address set to\n      the multicast group address.\
    \  Thus all member hosts of a group\n      will receive the responses sent by\
    \ the other hosts in the subnet\n      who are members of the same group.\n  \
    \    In the above example if t1 < t3,  IGMP_host in H1 will generate a\n     \
    \ response to update the membership in group N1 before H3 does and\n      H3 will\
    \ also receive this response in addition to the router. When\n      IGMP_host\
    \ in H3 receives the response sent by H1,  IGMP_host in H3\n      cancels the\
    \ event scheduled at time t3, since a response for that\n      group has been\
    \ sent to the router.  To make this work, the events\n      to generate response\
    \ to queries are scheduled randomly, and the\n      interval for scheduling the\
    \ above described event is forced to be\n      less than the interval at which\
    \ router sends the queries.\n   3. Accept responses sent by the other hosts in\
    \ the subnet if any\n      application layer is a member of the group to which\
    \ the packet is\n      destined.\n   4. Accept terminate group requests from the\
    \ Application layer. These\n      requests are generated by application layer\
    \ when a application\n      decides to leave a group. The IGMP_host updates the\
    \ group\n      information table and subsequently will not send any response\n\
    \      corresponding to this group (unless another application is a\n      member\
    \ of this group).  When a router does not receive any\n      response for a group\
    \ in certain amount of time on a specific\n      interface, membership of that\
    \ interface is canceled in that group.\n   e. Unicast best-effort (UBE) processor\
    \ node: This node is used to\n   generate a best effort traffic in the Internet\
    \ based on the User\n   Datagram Protocol (UDP).  The objective of this node is\
    \ to model the\n   background traffic in a network. This traffic does not use\
    \ the\n   services provided by RSVP. UBE node aims to create the behaviors\n \
    \  observed in a network which has one type of application using the\n   services\
    \ provided by RSVP to achieve specific levels of QoS and the\n   best effort traffic\
    \ which uses the services provided by only the\n   underlying IP.\n   The UBE\
    \ node generates traffic to a randomly generated IP address so\n   as to model\
    \ competing traffic in the network from applications such\n   as FTP. The packets\
    \ generated are sent to the IP layer which routes\n   the packet based upon the\
    \ information in the routing table. The\n   attributes of the UBE node are:\n\
    \   1. Session InterArrival Time (IAT): is the variable used to schedule\n   \
    \   an event to begin a session. The UBE node generates an\n      exponentially\
    \ distributed random variable with mean Session IAT\n      and begins to generate\
    \ data traffic at that time.\n   2. Data IAT: When the UBE generates data traffic,\
    \ the interarrival\n      times between data packets is Data IAT. A decrease in\
    \ the value of\n      Data IAT increases the severity of congestion in the network.\n\
    \   3. Session-min and Session-max: When the UBE node starts generating\n    \
    \  data traffic it remains in that session for a random period which\n      is\
    \ uniformly distributed between Session-min and Session-max.\n   f. Multicast\
    \ Application processor node: The application layer\n   consists of one or more\
    \ application nodes which are process nodes.\n   These nodes use the services\
    \ provided by lower layer protocols IGMP,\n   RSVP and IP.  The Application layer\
    \ models the requests and traffic\n   generated by Application layer programs.\
    \ Attributes of the\n   application layer are:\n   1. Session IAT: is the variable\
    \ used to schedule an event to begin a\n      session.  The Application node generates\
    \ an exponentially\n      distributed random variable with mean Session IAT and\
    \ begins to\n      generate information for a specific group at that time and\
    \ also\n      accept packets belonging to that group.\n   2. Data IAT: When Application\
    \ node generates data traffic, the inter\n      arrival time between the packets\
    \ uses Data IAT variable as the\n      argument.  The distribution can be any\
    \ of the available\n      distribution functions in OPNET.\n   3. Session-min\
    \ and Session-max: When an application joins a session\n      the duration for\
    \ which the application stays in that session is\n      bounded by Session-min\
    \ and Session-max.  A uniformly distributed\n      random variable between Session-min\
    \ and Session-max is generated\n      for this purpose. At any given time each\
    \ node will have zero or\n      one flow(s) of data.\n   4. NGRPS: This variable\
    \ is used by the application generating\n      multicast traffic to bound the\
    \ value of the group to which an\n      application requests  the IGMP to join.\
    \  The group is selected at\n      random from the range [0,NGRPS-1].\n      \
    \                [Figure 6: Node Level of Gateway]\n"
- title: 3.3.3 Router description
  contents:
  - "3.3.3 Router description\n      There are two types of routers in the model,\
    \ a router serving a\n      subnet and a backbone router.  A subnet router has\
    \ all the\n      functions of a backbone router and in addition also has a\n \
    \     interface to the underlying subnet which can be either a FDDI\n      network\
    \ or a Ethernet subnet. In the following section the subnet\n      router will\
    \ be discussed in detail.\n      Figure 6 shows the node level model of a subnet\
    \ router.\n      a. The queueing technique implemented in the router is a\n  \
    \    combination of input and output queueing.  The nodes rx1 to rx10\n      are\
    \ the receivers connected to incoming links.  The router in\n      Figure 6 has\
    \ a physical interface to the FDDI ring or Ethernet,\n      which consists of\
    \ the queue node MAC, transmitter phy_tx, and the\n      receiver phy_rx.  The\
    \ backbone routers will not have a MAC layer.\n      The services provided and\
    \ the functions of the MAC layer are the\n      same as the MAC layer in the host\
    \ discussed above.\n      There is one major difference between the MAC node in\
    \ a subnet\n      router and that in a host.  The MAC node in a subnet router\n\
    \      accepts all arriving multicast packets unlike the MAC in a host\n     \
    \ which accepts only the multicast packets for groups of which the\n      host\
    \ is a member. For this reason the statistic wire from the IGMP\n      to MAC\
    \ layer does not exist in a router (also because a subnet\n      router does not\
    \ have an application layer).\n      b. Addr_trans: The link layer in the router\
    \ hierarchy is the\n      addr_trans processor node which provides the service\
    \ of\n      translating the IP address to a physical address. The addr_trans\n\
    \      node was described above under the host model.\n      c. IP layer: The\
    \ router IP layer which provides services to the\n      upper layer transport\
    \ protocols and also performs routing based\n      upon the information in the\
    \ routing table. The IP layer maintains\n      two routing tables and one group\
    \ membership table.\n      The tables used by the router model are:\n      1.\
    \ Unicast routing table: This table is an single array of one\n      dimension,\
    \ which is used to route packets generated by the UDP\n      process node in the\
    \ hosts.  If no route is known to a particular\n      IP address, the corresponding\
    \ entry is set to a default route.\n   2. Multicast routing table: This table\
    \ is a N by I array where N is\n      the maximum number of multicast groups in\
    \ the model and I is the\n      number of interfaces in the router.  This table\
    \ is used to route\n      multicast packets. The routing table in a router is\
    \ set by an\n      upper layer routing protocol (see section 4 below). When the\
    \ IP\n      layer receives a multicast packet with a session_id corresponding\n\
    \      to a session which is utilizing the MOSFP, it looks up the\n      multicast\
    \ routing table to obtain the next hop.\n   3. Group membership table: This table\
    \ is used to maintain group\n      membership information of all the interfaces\
    \ of the router.  This\n      table  which is also an N by I array is set by the\
    \ IGMP layer\n      protocol.  The routing protocols use this information in the\
    \ group\n      membership table to calculate and set the routes in the Multicast\n\
    \      routing table.\n   Sub-queues: The IP node has three subqueues, which implement\
    \ queuing\n   based upon the priority of arriving packets from the neighboring\n\
    \   routers or the underlying subnet. The queue with index 0 has the\n   highest\
    \ priority.  When a packet arrives at the IP node, the packets\n   are inserted\
    \ into the appropriate sub-queue based on the priority of\n   their traffic category:\
    \ control traffic, resource- reserved traffic,\n   or best effort traffic.  A\
    \ non-preemptive priority is used in\n   servicing the packets.  After the servicing,\
    \ packets are sent to the\n   one of the output queues or the MAC. The packets\
    \ progress through\n   these queues until the transmitter becomes available.\n\
    \   Attributes of the IP node are:\n   1. Unique IP address for each interface\
    \ (a set of transmitter and\n      receiver constitute an interface).\n   2. Service\
    \ rate: the rate with which packets are serviced at the\n      router.\n   3.\
    \ Queue size: size of each of the sub queues used to store incoming\n      packets\
    \ based on the priority can be specified individually\n   d. Output queues: The\
    \ output queues perform the function of queueing\n   the packets received by the\
    \ IP layer when the transmitter is busy. A\n   significant amount of queuing takes\
    \ place in the output queues only\n   if the throughput of the IP node approaches\
    \ the transmission capacity\n   of the links.  The only attribute of the queue\
    \ node is:\n   Queue size: size of the queue in each queue node.  If the queue\
    \ is\n   full when a packet is received, that packet is dropped.\n   e. IGMP Node:\
    \ Also modeled in the router is the IGMP for implementing\n   multicasting, the\
    \ routing protocol, and RSVP for providing specific\n   QoS setup.\n   The IGMP\
    \ node implements the IGMP protocol as defined in RFC 1112.\n   The IGMP node\
    \ at a router (Figure 7) is different from the one at a\n   host. The functions\
    \ of the IGMP node at a router are:\n   1. IGMP node at a router sends queries\
    \ at regular intervals on all\n      its interfaces.\n   2. When IGMP receives\
    \ a response to the queries sent, IGMP updates\n      the multicast Group membership\
    \ table in the IP node and triggers\n      on MOSPF LSA update.\n   3. Every time\
    \ the IGMP sends a query, it also updates the multicast\n      group membership\
    \ table in the IP node if no response has been\n      received on for the group\
    \ on any interface,  indicating that a\n      interface is no longer a member\
    \ of that group.  This update is\n      done only on entries which indicate an\
    \ active membership for a\n      group on a interface where the router has not\
    \ received a response\n      for the last query sent.\n   4. The routing protocol\
    \ (see ection 4 below) uses the information in\n      the group membership table\
    \ to calculate the routes and update the\n      multicast routing table.\n   5.\
    \ When the IGMP receives a query (an IGMP at router can receive a\n      query\
    \ from a directly connected neighboring router), the IGMP node\n      creates\
    \ a response for each of the groups it is a member of on all\n      the interfaces\
    \ except the one through which the query was\n      received.\n   6. The IGMP\
    \ node on a backbone router is disabled, because IGMP is\n      only used when\
    \ a router has hosts on its subnet.\n                     [Figure 7: IGMP process\
    \ on routers]\n"
- title: 4.  RSVP model
  contents:
  - "4.  RSVP model\n   The current version of the RSVP model supports only fixed-filter\n\
    \   reservation style. The following processing takes place in the\n   indicated\
    \ modules. The model is current with [2].\n"
- title: 4.1 RSVP APPLICATION
  contents:
  - '4.1 RSVP APPLICATION

    '
- title: 4.1.1  Init
  contents:
  - "4.1.1  Init\n   Initializes all variables and loads the distribution functions\
    \ for\n   Multicast Group IDs, Data, termination of the session. Transit to\n\
    \   Idle state after completing all the initializations.\n"
- title: 4.1.2  Idle
  contents:
  - "4.1.2  Idle\n   This state has transitions to two states, Join and Data_Send.\
    \ It\n   transit to Join state at the time that the application is scheduled\n\
    \   to join a session or terminate the current session, transit to\n   Data_Send\
    \ state when the application is going to send data.\n"
- title: 4.1.3  Join
  contents:
  - "4.1.3  Join\n   The Application will send a session call to local RSVP daemon.\
    \ In\n   response it receives the session Id from the Local daemon. This makes\n\
    \   a sender or receiver call. The multicast group id is selected\n   randomly\
    \ from a uniform distribution.  While doing a sender call the\n   application\
    \ will write all its sender information in a global session\n   directory.\n \
    \  If the application is acting as a receiver it will check for the\n   sender\
    \ information in the session directory for the multicast group\n   that it wants\
    \ to join to and make a receive call to the local RSVP\n   daemon.  Along with\
    \ the session and receive calls, it makes an IGMP\n   join call.\n   If the application\
    \ chooses to terminate the session to which it was\n   registered, it will send\
    \ a release call to the local RSVP daemon and\n   a terminate call to IGMP daemon.\
    \  After completing these functions it\n   will return to the idle state.\n  \
    \                  [Figure 8: RSVP process on routers]\n"
- title: 4.1.4 Data_Send
  contents:
  - "4.1.4 Data_Send\n   Creates a data packet and sends it to a multicast destination\
    \ that it\n   selects. It update a counter to keep track of how many packets that\n\
    \   it has sent. This state on default returns to Idle state.\n"
- title: 4.2 RSVP on Routers
  contents:
  - "4.2 RSVP on Routers\n   Figure 8 shows the process model of RSVP on routers.\n"
- title: 4.2.1 Init
  contents:
  - "4.2.1 Init\n   This state calls a function called RouterInitialize which will\n\
    \   initialize all the router variables. This state will go to Idle state\n  \
    \ after completing these functions.\n"
- title: 4.2.2 Idle
  contents:
  - "4.2.2 Idle\n   Idle state transit to Arr state upon receiving a packet.\n"
- title: 4.2.3 Arr
  contents:
  - "4.2.3 Arr\n   This state checks for the type of the packet arrived and calls\
    \ the\n   appropriate function depending on the type of message received.\n  \
    \ a. PathMsgPro: This function was invoked by the Arr state when a path\n   message\
    \ is received. Before it was called, OSPF routing had been\n   recomputed to get\
    \ the latest routing table for forwarding the Path\n   Message.\n   1. It first\
    \ checks for a Path state block which has a matching\n      destination address\
    \ and if the sender port or sender address or\n      destination port does not\
    \ match the values of the Session object\n      of the Path state block, it sends\
    \ an path error message and\n      returns. (At present the application does not\
    \ send any error\n      messages, we print this error message on the console.)\n\
    \   2. If a PSB is found whose Session Object and Sender Template Object\n   \
    \   matches with that of the path message received, the current PSB\n      becomes\
    \ the forwarding PSB.\n   3. Search for the PSB whose session and sender template\
    \ matches the\n      corresponding objects in the path message and whose incoming\n\
    \      interface matches the IncInterface. If such a PSB is found and the\n  \
    \    if the Previous Hop Address, Next Hop Address, and SenderTspec\n      Object\
    \ doesn't match that of path message then the values of path\n      message is\
    \ copied into the path state block and Path Refresh\n      Needed flag is turned\
    \ on. If the Previous Hop Address, Next Hop\n      Address of PSB differs from\
    \ the path message then the Resv Refresh\n      Needed flag is also turned on,\
    \ and the Current PSB is made equal\n      to this PSB.\n   4. If a matching PSB\
    \ is not found then a new PSB is created and and\n      Path Refresh Needed Flag\
    \ is turned on, and the Current PSB is made\n      equal to this PSB.\n   5. If\
    \ Path Refresh Needed Flag is on, Current PSB is copied into\n      forwarding\
    \ PSB and Path Refresh Sequence is executed. To execute\n      this function called\
    \ PathRefresh is used.  Path Refresh is sent to\n      every interface that is\
    \ in the outgoing interfaces list of\n      forwarding path state block.\n   6.\
    \ Search for a Reservation State Block whose filter spec object\n      matches\
    \ with the Sender Template Object of the forwarding PSB and\n      whose Outgoing\
    \ Interface matches one of the entry in the\n      forwarding PSB's outgoing interface\
    \ list. If found then a Resv\n      Refresh message to the Previous Hop Address\
    \ in the forwarding PSB\n      and execute the Update Traffic Control sequence.\n\
    \   b. PathRefresh: This function is called from PathMsgPro. It creates\n   the\
    \ Path message sends the message through the outgoing interface\n   that is specified\
    \ by the PathMsgPro.\n   c. ResvMsgPro: This function was invoked by the Arr state\
    \ when a Resv\n   message is received.\n   1. Determine the outgoing interface\
    \ and check for the PSB whose\n      Source Address and Session Objects match\
    \ the ones in the Resv\n      message.\n   2. If such a PSB is not found then\
    \ send a ResvErr message saying that\n      No Path Information is available.\
    \ (We have not implemented this\n      message, we only print an error message\
    \ on the console.)\n   3. Check for incompatible styles and process the flow descriptor\
    \ list\n      to make reservations, checking the PSB list for the sender\n   \
    \   information. If no sender information is available through the PSB\n     \
    \ list then send an Error message saying that No Sender information.\n      For\
    \ all the matching PSBs found, if the Refresh PHOP list doesn't\n      have the\
    \ Previous Hop Address of the PSB then add the Previous Hop\n      Address to\
    \ the Refresh PHOP list.\n   4. Check for matching Reservation State Block (RSB)\
    \ whose Session and\n      Filter Spec Object matches that of Resv message. If\
    \ no such RSB is\n      found then create a new RSB from the Resv Message and\
    \ set the\n      NeworMod flag On. Call this RSB as activeRSB. Turn on the Resv\n\
    \      Refresh Needed Flag.\n   5. If a matching RSB is found, call this as activeRSB\
    \ and if the\n      FlowSpec and Scope objects of this RSB differ from that of\
    \ Resv\n      Message copy the Resv message Flowspec and Scope objects to the\n\
    \      ActiveRSB and set the NeworMod flag On.\n   6. Call the Update Traffic\
    \ Control Sequence. This is done by calling\n      the function UpdateTrafficControl\n\
    \   7. If Resv Refresh Needed Flag is On then send a ResvRefresh message\n   \
    \   for each Previous Hop in the Refresh PHOP List. This is done by\n      calling\
    \ the ResvRefresh function for every Previous Hop in the\n      Refresh PHOP List.\n\
    \   d. ResvRefresh: this function is called by both PathMsgPro and\n   ResvMsgPro\
    \ with RSB and Previous Hop as input. The function\n   constructs the Resv Message\
    \ from the RSB and sends the message to the\n   Previous Hop.\n   e. PathTearPro:\
    \ This function is invoked by the Arr state when a\n   PathTear message is received.\n\
    \   1. Search for PSB whose Session Object and Sender Template Object\n      matches\
    \ that of the arrived PathTear message.\n   2. If such a PSB is not found do nothing\
    \ and return.\n   3. If a matching PSB is  found, a PathTear message is sent to\
    \ all the\n      outgoing interfaces that are listed in the Outgoing Interface\
    \ list\n      of the PSB.\n   4. Search for all the RSB whose Filter Spec Object\
    \ matches the Sender\n      Template Object of the PSB and if the Outgoing Interface\
    \ of this\n      RSB is listed in the PSB's Outgoing interface list delete the\
    \ RSB.\n   5. Delete the PSB and return.\n   f. ResvTearPro: This function is\
    \ invoked by the Arr state when a\n   ResvTear message is received.\n   1. Determine\
    \ the Outgoing Interface.\n   2. Process the flow descriptor list of the arrived\
    \ ResvTear message.\n   3. Check for the RSB whose Session Object, Filter Spec\
    \ Object matches\n      that of ResvTear message and if there is no such RSB return.\n\
    \   4. If such an RSB is found and Resv Refresh Needed Flag is on send\n     \
    \ ResvTear message to all the Previous Hops that are in Refresh PHOP\n      List.\n\
    \   5. Finally delete the RSB.\n   g. ResvConfPro: This function is invoked by\
    \ the Arr state when a\n   ResvConf message is received. The Resv Confirm is forwarded\
    \ to the IP\n   address that was in the Resv Confirm Object of the received ResvConf\n\
    \   message.\n   h. UpdateTrafficControl: This function is called by PathMsgPro\
    \ and\n   ResvMsgPro and input to this function is RSB.\n   1. The RSB list is\
    \ searched for a matching RSB that matches the\n      Session Object, and Filter\
    \ Spec Object with the input RSB.\n   2. Effective Kernel TC_Flowspec are computed\
    \ for all these RSB's.\n   3. If the Filter Spec Object of the RSB doesn't match\
    \ the one of the\n      Filter Spec Object in the TC Filter Spec List then add\
    \ the Filter\n      Spec Object to the TC Filter Spec List.\n   4. If the FlowSpec\
    \ Object of the input RSB is greater than the\n      TC_Flowspec then turn on\
    \ the Is_Biggest flag.\n   5. Search for the matching Traffic Control State Block(TCSB)\
    \ whose\n      Session Object, Outgoing Interface, and Filter Spec Object matches\n\
    \      with those of the Input RSB.\n   6. If such a TCSB is not found create\
    \ a new TCSB.\n   7. If matching TCSB is found modify the reservations.\n   8.\
    \ If Is_Biggest flag is on turn on the Resv Refresh Needed Flag\n      flag, else\
    \ send a ResvConf Message to the IP address in the\n      ResvConfirm Object of\
    \ the input RSB.\n"
- title: '4.2.4 pathmsg: The functions to be done by this state are done through'
  contents:
  - "4.2.4 pathmsg: The functions to be done by this state are done through\n   the\
    \ function call PathMsgPro described above.\n"
- title: '4.2.5 resvmsg: The functions that would be done by this state are done'
  contents:
  - "4.2.5 resvmsg: The functions that would be done by this state are done\n   through\
    \ the function call ResvMsgPro described above.\n"
- title: '4.2.6 ptearmsg: The functions that would be done by this state are done'
  contents:
  - "4.2.6 ptearmsg: The functions that would be done by this state are done\n   through\
    \ the function call PathTearPro described above.\n"
- title: '4.2.7 rtearmsg: The functions that would be done by this state are done'
  contents:
  - "4.2.7 rtearmsg: The functions that would be done by this state are done\n  through\
    \ the function call ResvTearPro described above.\n"
- title: '4.2.8 rconfmsg: The functions that would be done by this state are done'
  contents:
  - "4.2.8 rconfmsg: The functions that would be done by this state are done\n  through\
    \ the function call ResvConfPro described above.\n"
- title: 4.3 RSVP on Hosts
  contents:
  - "4.3 RSVP on Hosts\n   Figure 9 shows the process of RSVP on hosts.\n"
- title: 4.3.1  Init
  contents:
  - "4.3.1  Init\n   Initializes all the variables. Default transition to idle state.\n\
    \                     [Figure 9: RSVP process on hosts]\n"
- title: 4.3.2  idle
  contents:
  - "4.3.2  idle\n   This state transit to the Arr state on packet arrival.\n"
- title: 4.3.3  Arr
  contents:
  - "4.3.3  Arr\n   This state calls the appropriate functions depending on the type\
    \ of\n   message received. Default transition to idle state.\n   a. MakeSessionCall:\
    \ This function is called from the Arr state\n   whenever a Session call is received\
    \ from the local application.\n   1. Search for the Session Information.\n   2.\
    \ If one is found return the corresponding Session Id.\n   3. If the session information\
    \ is not found assign a new session Id to\n      the session to the corresponding\
    \ session.\n   4. Make an UpCall to the local application with this Session Id.\n\
    \   b. MakeSenderCall: This function is called from the Arr state\n   whenever\
    \ a Sender call is received from the local application.\n   1. Get the information\
    \ corresponding to the Session Id and create a\n      Path message corresponding\
    \ to this session.\n   2. A copy of the packet is buffered and used by the host\
    \ to send the\n      PATH message periodically.\n   3. This packet is sent to\
    \ the IP layer.\n   c. MakeReserveCall: This function is called from the Arr state\n\
    \   whenever a Reserve call is received from the local application. This\n   function\
    \ will create and send a Resv message. Also, the packet is\n   buffered for later\
    \ use.\n   d. MakeReleaseCall: This function is called from the Arr state\n  \
    \ whenever a Release call is received from the local application. This\n   function\
    \ will generate a PathTear message if the local application is\n   sender or generates\
    \ a ResvTear message if the local application is\n   receiver.\n"
- title: 4.3.4  Session                  This state's function is performed by
  contents:
  - "4.3.4  Session                  This state's function is performed by\n   the\
    \ MakeSessionCall function.\n"
- title: 4.3.5  Sender
  contents:
  - "4.3.5  Sender\n   This state's function is han by the MakeSenderCall function.\n"
- title: 4.3.6  Reserve
  contents:
  - "4.3.6  Reserve\n                                                   This state's\
    \ function\n   is performed by the MakeReserveCall function.\n"
- title: 4.3.7  Release
  contents:
  - "4.3.7  Release\n   This state's function is performed by the MakeReleaseCall\
    \ function.\n"
- title: 5. Multicast Routing Model Interface
  contents:
  - "5. Multicast Routing Model Interface\n   Because this set of models was intended\
    \ particularly to enable\n   evaluation by simulation of various multicast routing\
    \ protocols, we\n   give particular attention in this section to the steps necessary\
    \ to\n   interface a routing protocol model to the other models.  We have\n  \
    \ available implementations of DVMRP and OSPF, which we will describe\n   below.\
    \  Instructions for invoking these models are contained in a\n   separate User's\
    \ Guide for the models.\n"
- title: 5.1  Creation of multicast routing processor node
  contents:
  - "5.1  Creation of multicast routing processor node\n   Interfacing a multicast\
    \ routing protocol using the OPNET Simulation\n   package requires the creation\
    \ of a new routing processor node in the\n   node editor and linking it via packet\
    \ streams.  Packet streams are\n   unidirectional links used to interconnect processor\
    \ nodes, queue\n   nodes, transmitters and receiver nodes.  A duplex connection\
    \ between\n   two nodes is represented by using two unidirectional links to connect\n\
    \   the two nodes to and from each other.\n   A multicast routing processor node\
    \ is created in the node editor and\n   links are created to and from the processors(duplex\
    \ connection) that\n   interact with this module, the IGMP processor node and\
    \ the IP\n   processor node.  Within the node editor, a new processor node can\
    \ be\n   created by selecting the button for processor creation (plain gray\n\
    \   node on the node editor control panel) and by clicking on the desired\n  \
    \ location in the node editor to place the node.  Upon creation of the\n   processor\
    \ node, the name of the processor can be specified by right\n   clicking on the\
    \ mouse button and entering the name value on the\n   attribute box presented.\
    \  Links to and from this node are generated\n   by selecting the packet stream\
    \ button (represented by two gray nodes\n   connected with a solid green arrow\
    \ on the node editor control panel),\n   left clicking on the mouse button to\
    \ specify the source of the link\n   and right clicking on the mouse button to\
    \ mark the destination of the\n   link.\n"
- title: 5.2  Interfacing processor nodes
  contents:
  - "5.2  Interfacing processor nodes\n   The multicast routing processor node is\
    \ linked to the IP processor\n   node and the IGMP processor node each with a\
    \ duplex connection. A\n   duplex connection between two nodes is represented\
    \ by two uni-\n   directional links interconnecting them providing a bidirectional\
    \ flow\n   of information or interrupts, as shown in Figure 6.  The IP processor\n\
    \   node (in the subnet router) interfaces with the multicast routing\n   processor\
    \ node, the unicast routing processor node, the Resource\n   Reservation processor\
    \ node(RSVP), the ARP processor node( only on\n   subnet routers and hosts), the\
    \ IGMP processor node, and finally the\n   MAC processor node (only on subnet\
    \ routers and hosts) each with a\n   duplex connection with exceptions for ARP\
    \ and MAC nodes.\n"
- title: 5.2.1  Interfacing ARP and MAC processor nodes
  contents:
  - "5.2.1  Interfacing ARP and MAC processor nodes\n   The service of the ARP node\
    \ is required only in the direction from\n   the IP layer to the MAC layer(requiring\
    \ only a unidirectional link\n   from IP processor node to ARP processor node).\
    \  The MAC processor\n   node on the subnet router receives multicast packets\
    \ destined for all\n   multicast groups in the subnet, in contrast to the MAC\
    \ node on subnet\n   hosts which only receives multicast packets destined specifically\
    \ for\n   its multicast group.  The MAC node connects to the IP processor node\n\
    \   with a single uni-directional link from it to the IP node.\n"
- title: 5.2.2  Interfacing IGMP, IP, and multicast routing processor nodes
  contents:
  - "5.2.2  Interfacing IGMP, IP, and multicast routing processor nodes\n   The IGMP\
    \ processor node interacts with the multicast routing\n   processor node, unicast\
    \ routing processor node, and the IP processor\n   node. Because the IGMP node\
    \ is linked to the IP node, it is thus able\n   to update the group membership\
    \ table(in this model, the group\n   membership table is represented by the local\
    \ interface(interface 0)\n   of the multicast routing table data structure) within\
    \ the IP node.\n   This update triggers a signal to the multicast routing processor\
    \ node\n   from the IGMP node causing it to reassess the multicast routing table\n\
    \   within the IP node.  If the change in the group membership table\n   warrants\
    \ a modification of the multicast routing table, the multicast\n   routing processor\
    \ node interacts with the IP node to modify the\n   current multicast routing\
    \ table according to the new group membership\n   information updated by IGMP.\n"
- title: 5.2.2.1  Modification of group membership table
  contents:
  - "5.2.2.1  Modification of group membership table\n   The change in the group membership\
    \ occurs with the decision at a host\n   to leave or join a particular multicast\
    \ group.  The IGMP process on\n   the gateway periodically sends out queries to\
    \ the IGMP processes on\n   hosts within the subnet in an attempt to determine\
    \ which hosts\n   currently are receiving packets from particular groups.  Not\n\
    \   receiving a response for a pending IGMP host query specific to a\n   group\
    \ indicates to the gateway IGMP that no host belonging to the\n   particular group\
    \ exists in the subnet.  This occurs when the last\n   remaining member of a multicast\
    \ group in the subnet leaves.  In this\n   case the IGMP processor node updates\
    \ the group membership able and\n   triggers a modification of the multicast routing\
    \ table by alerting\n   the multicast routing processor node.  A prune message\
    \ specific to\n   the group is initiated and propagated upward establishing a\
    \  prune\n   state for the interface leading to the present subnet, effectively\n\
    \   removing this subnet from the group-specific multicast spanning tree\n   and\
    \ potentially leading to additional pruning of spanning tree edges\n   as the\
    \ prune message travels higher up the tree.  Joining a multicast\n   group is\
    \ also managed by the IGMP process which updates the group\n   membership table\
    \ leading to a possible modification of the multicast\n   routing table.\n"
- title: 5.2.2.2  Dependency on unicast routing protocol
  contents:
  - "5.2.2.2  Dependency on unicast routing protocol\n   The multicast routing protocol\
    \ is dependent on a unicast routing\n   protocol (RIP or OSPF) to handle  multicast\
    \ routing.  The next hop\n   interface to the source of the packet received, or\
    \ the upstream\n   interface, is determined using the unicast routing protocol\
    \ to trace\n   the reverse path back to the source of the packet.  If the packet\n\
    \   received arrived on this upstream interface, then the packet can be\n   propagated\
    \ downstream through its downstream interfaces (excluding\n   the interface in\
    \ which the packet was received). Otherwise, the\n   packet is deemed to be a\
    \ duplicate and dropped, halting the\n   propagation of the packet downstream.\
    \  This repeated reverse path\n   checking and broadcasting eventually generates\
    \ the spanning tree for\n   multicast routing of packets.  To determine the reverse\
    \ path forward\n   interface of a received multicast packet propagated up from\
    \ the IP\n   layer, the multicast routing processor node retrieves a copy of the\n\
    \   unicast routing table from the IP processor node and uses it to\n   recalculate\
    \ the multicast routing table in the IP processor node.\n"
- title: 5.3  Interrupt Generation
  contents:
  - "5.3  Interrupt Generation\n   Using the OPNET tools, interrupts to the multicast\
    \ routing processor\n   node are generated in several ways.  One is the arrival\
    \ of a\n   multicast packet along a packet stream (at the multicast routing\n\
    \   processor node) when the packet is received by the MAC node and\n   propagated\
    \ up the IP node where upon discarding the IP header\n   determination is made\
    \ as to which upper layer protocol to send the\n   packet.  A second type of interrupt\
    \ generation occurs by remote\n   interrupts from the IGMP process alerting the\
    \ multicast routing\n   process of an update in the group membership table.  A\
    \ third occurs\n   when the specific source/group (S,G) entry for a multicast\
    \ packet\n   received at the IP node does not exist in the current multicast\n\
    \   routing table and a new entry needs to be created.  The IP node\n   generates\
    \ an interrupt to the multicast routing processor node\n   informing it to create\
    \ a new source/group entry on the multicast\n   routing table.\n"
- title: 5.3.1  Types of interrupts
  contents:
  - "5.3.1  Types of interrupts\n   The process interrupts generated within the OPNET\
    \ model can be\n   handled by specifying the types of interrupts and the conditions\
    \ for\n   the interrupts using the interrupt code, integer number representing\n\
    \   the condition for a specific interrupt.  The conditions for\n   interrupts\
    \ are specified on the interrupt stream linking the\n   interrupt generating state\
    \ and the state resulting from the\n   interrupt.  For self-interrupts (interrupts\
    \ occurring among states\n   within the same process), interrupts of type OPC_INTRPT_SELF\
    \ are\n   used.  For remote interrupts (interprocess interrupts), the\n   conditions\
    \ for specific interrupts are specified from the idle state\n   to the state resulting\
    \ from the interrupt within the remote process.\n   The remote interrupts are\
    \ of type, OPC_INTRPT_REMOTE.  A third type\n   of interrupt is the OPC_INTRPT_STRM,\
    \ which is triggered when packets\n   arrive via a packet stream, indicating its\
    \ arrival.  The condition of\n   this interrupt is also specified from the idle\
    \ state to the resultant\n   state by the interrupt condition stream defined by\
    \ a unique interrupt\n   code.  For all of these interrupts, the interrupt code\
    \ is provided\n   within the header block (written in C language) of the interrupted\n\
    \   process.  When the condition for the interrupt becomes true, a\n   transition\
    \ is made to the resultant state specified by the interrupt\n   stream.\n"
- title: 5.3.2  Conditions for interrupts
  contents:
  - "5.3.2  Conditions for interrupts\n   Several interrupt connections exist to interface\
    \ the IGMP processor\n   node, IP processor node , and the multicast routing processor\
    \ node\n   with each other in the present OPNET Simulation Model.  Also, the IP\n\
    \   processor node interfaces with the unicast routing protocol which\n   interfaces\
    \ with the IGMP processor node.  An OPC_INTRPT_STRM\n   interrupt is generated\
    \ when a multicast packet arrives via a packet\n   stream from the IP processor\
    \ node to the multicast routing processor\n   node.  A remote interrupt of type,\
    \ OPC_INTRPT_REMOTE, is generated\n   from the IGMP process to the IP process\
    \ when a member of a group\n   relinquishes membership from a particular group\
    \ or a new member is\n   added to a group.  This new membership is updated in\
    \ the group\n   membership table located in the IP node by the IGMP process which\n\
    \   also generates a remote interrupt to the multicast routing protocol\n   process,\
    \ causing a recalculation of the multicast routing table in\n   the IP module.\n"
- title: 5.4  Modifications of modules in the process model
  contents:
  - "5.4  Modifications of modules in the process model\n   Modifications of routing\
    \ protocol modules (in fact all of the modules\n   in the process model) are made\
    \ transparently throughout the network\n   using the OPNET Simulation tools. \
    \ An addition or modification of a\n   routing module in any subnet will reflect\
    \ on all the subnets.\n"
- title: 6.  OSPF and MOSPF Models
  contents:
  - "6.  OSPF and MOSPF Models\n   OSPF and MOSPF models [5] are implemented in the\
    \ OSPF model\n   containing fourteen states. They only exist on routers. Figure\
    \ 10\n   shows the process model. The following processing takes place in the\n\
    \   indicated modules.\n"
- title: 6.1 init
  contents:
  - "6.1 init\n   This state initializes all the router variables. Default transition\n\
    \   to idle state.\n"
- title: 6.2 idle
  contents:
  - "6.2 idle\n   This state has several transitions. If a packet arrives it transits\n\
    \   to arr state. Depending on interrupts received it will transit to\n   BCOspfLsa,\
    \ BCMospfLsa, hello_pks state. In future versions, links\n   coming up or down\
    \ will also cause a transition.\n"
- title: 6.3 BCOspfLsa
  contents:
  - "6.3 BCOspfLsa\n   Transition to this state from idle state is executed whenever\
    \ the\n   condition send_ospf_lsa is true, which happens when the network is\n\
    \   being initialized, and when ospf_lsa_refresh_timout occurs. This\n   state\
    \ will create Router, Network, Summary Link State Advertisements\n   and pack\
    \ all of them into an Link State Update packet. The Link State\n   Update Packet\
    \ is sent to the IP layer with a destination address of\n   AllSPFRouters.\n \
    \          [Figure 10: OSPF and MOSPF process model on routers]\n"
- title: 6.4 BCMospfLsa
  contents:
  - "6.4 BCMospfLsa\n   Transition to this state from idle state is executed whenever\
    \ the\n   condition send_mospf_lsa is true. This state will create Group\n   Membership\
    \ Link State Advertisement and pack them into Mospf Link\n   State Update Packet.\
    \ This Mospf Link State Update Packet is sent to\n   IP layer with a destination\
    \ address of AllSPFRouters.\n"
- title: 6.5 arr
  contents:
  - "6.5 arr\n   The arr state checks the type of packet that is received upon a\n\
    \   packet arrival. It calls the following functions depending on the\n   protocol\
    \ Id of the packet received.\n   a. OspfPkPro: Depending on the type of OSPF/MOSPF\
    \ packet received the\n   function calls the following functions.\n   1. HelloPk_pro:\
    \ This function is called whenever a hello packet is\n      received. This function\
    \ updates the router's neighbor information,\n      which is later used while\
    \ sending the different LSAs.\n   2. OspfLsUpdatePk_pro: This function is called\
    \ when an OSPF LSA\n      update packet is received (router LSA, network LSA,\
    \ or summary\n      LSA). If the Router is an Area Border Router or if the LSA\
    \ belongs\n      to the Area whose Area Id is the Routers Area Id, then it is\n\
    \      searched to determine whether this LSA already exists in the Link\n   \
    \   State database. If it exists and if the existing LSA's LS Sequence\n     \
    \ Number is less than the received LSA's LS Sequence Number the\n      existing\
    \ LSA was replaced with the received one. The function\n      processes the Network\
    \ LSA only if it is a designated router or\n      Area Border Router.  It processes\
    \ the Summary LSA only if the\n      router is a Area Border Router.  The function\
    \ also turns on the\n      trigger ospfspfcalc which is the condition for the\
    \ transition from\n      arr state to ospfspfcalc.\n   3. MospfLsUpdatePk_pro:\
    \ This function is called when a MOSPF LSA\n      update packet is received. It\
    \ updates the group membership link\n      state database of the router.\n"
- title: 6.6 hello_pks
  contents:
  - "6.6 hello_pks\n   Hello packets are created and sent with destination address\
    \ of\n   AllSPFRouters. Default transition to idle state.\n"
- title: 6.7 mospfspfcalc
  contents:
  - "6.7 mospfspfcalc\n   The following functions are used to calculate the shortest\
    \ path tree\n   and routing table. This state transit to upstr_node upon detupstrnode\n\
    \   condition.\n   a. CandListInit: Depending upon the SourceNet of the datagram,\
    \ the\n   candidate lists are initialized.\n   b. MospfCandAddPro: The vertex\
    \ link is examined and if the other end\n   of the link is not a stub network\
    \ and is not already in the candidate\n   list it is added to the candidate list\
    \ after calculating the cost to\n   that vertex. If this other end of the link\
    \ is already on the shortest\n   path tree and the calculated cost is less than\
    \ the one that shows in\n   the shortest path tree entry update the shortest path\
    \ tree to show\n   the calculated cost.\n   c. MospfSPFTreeCalc: The vertex that\
    \ is closest to the root that is\n   in the candidate list is added to the shortest\
    \ path tree and its link\n   is considered for possible inclusions in the candidate\
    \ list.\n   d. MCRoutetableCalc: Multicast routing table is calculated using the\n\
    \   information of the MOSPF shortest Path tree.\n"
- title: 6.8 ospfspfcalc
  contents:
  - "6.8 ospfspfcalc\n   The following functions are used in this state to calculate\
    \ the\n   shortest path tree and using this information the routing table.\n \
    \  Transition to ospfspfcalc state on ospfcalc condition. This is set to\n   one\
    \ after processing all functions in the state.\n   a. OspfCandidateAddPro: This\
    \ function initializes the candidate list\n   by examining the link state advertisement\
    \ of the Router. For each\n   link in this advertisement, if the other end of\
    \ the link is a router\n   or transit network and if it is not already in the\
    \ shortest-path tree\n   then calculate the distance between these vertices. If\
    \ the other end\n   of this link is not already on the candidate list or if the\
    \ distance\n   calculated is less than the value that appears for this other end\
    \ add\n   the other end of the link to candidate list.\n   b. OspfSPTreeBuild:\
    \ This function pulls each vertex from the\n   candidate list that is closest\
    \ to the root and adds it to the\n   shortest path tree.  In doing so it deletes\
    \ the vertex from the\n   candidate list. This function continues to do this until\
    \ the\n   candidate list is empty.\n   c. OspfStubLinkPro: In this procedure the\
    \ stub networks are added to\n   shortest path tree.\n   d. OspfSummaryLinkPro:\
    \ If the router is an Area Border Router the\n   summary links that it has received\
    \ is examined. The route to the Area\n   border router advertising this summary\
    \ LSA is examined in the routing\n   table. If one is found a routing table update\
    \ is done by adding the\n   route to the network specified in the summary LSA\
    \ and the cost to\n   this route is sum of the cost to area border router advertising\
    \ this\n   and the cost to reach this network from that area border router.\n\
    \   e. RoutingTableCalc: This function updates the routing table by\n   examining\
    \ the shortest path tree data structure.\n"
- title: 6.9 upstr_node
  contents:
  - "6.9 upstr_node\n   This state does not do anything in the present model. It transitions\n\
    \   to DABRA state.\n"
- title: 6.10 DABRA
  contents:
  - "6.10 DABRA\n   If the router is an Area Border Router and the area is the source\n\
    \   area then a DABRA message is constructed and send to all the\n   downstream\
    \ areas. Default transition to idle state.\n"
- title: 7. DVMRP Model
  contents:
  - "7. DVMRP Model\n   The DVMRP model is implemented based on reference [6], DVMRP\
    \ version\n   3. There are nine states. The DVMRP process only exists on Routers.\n\
    \   Figure 11 shows the states of the DVMRP process.\n"
- title: 7.1 Init
  contents:
  - "7.1 Init\n   Initialize all variables, routing table and forwarding table and\
    \ load\n   the simulation parameters. It will transit to the Idle state after\n\
    \   completing all the initializations.\n"
- title: 7.2 Idle
  contents:
  - "7.2 Idle\n   The simulation waits for the next scheduled event or remotely invoked\n\
    \   event in the Idle State and transit to the state accordingly. In the\n   DVMRP\
    \ model, Idle State has transitions to Probe_Send, Report_Send,\n   Prune_Send,\
    \ Graft_Send, Arr_Pkt, Route_Calc and Timer states.\n                   [Figure\
    \ 11. DVMRP process on routers]\n"
- title: 7.3 Probe_Send State
  contents:
  - "7.3 Probe_Send State\n   A DVMRP router sends Probe messages periodically to\
    \ inform other\n   DVMRP routers that it is operational. A DVMRP router lists\
    \ all its\n   known neighbors' addresses in the Probe message and sends it to\
    \ All-\n   DVMRP-Routers address. The routers will not process any message that\n\
    \   comes from an unknown neighbor.\n"
- title: 7.4 Report_Send
  contents:
  - "7.4 Report_Send\n   To avoid sending Report at the same time for all DVMRP routers,\
    \ the\n   interval between two Report messages is uniformly distributed with\n\
    \   average 60 seconds. The router lists source router's address,\n   upstream\
    \ router's address and metric of all sources into the Report\n   message and sends\
    \ it to All-DVMRP-Routers address.\n"
- title: 7.5 Prune_Send
  contents:
  - "7.5 Prune_Send\n   The transition to this state is triggered by the local IGMP\
    \ process.\n   When a host on the subnetwork drops from a group, the IGMP process\n\
    \   asks DVMRP to see if the branch should be pruned.\n   The router obtains the\
    \ group number from IGMP and checks the IP\n   Multicast membership table to find\
    \ out if there is any group member\n   that is still in the group. If the router\
    \ determines that the last\n   host has resigned, it goes through the entire forwarding\
    \ table to\n   locate all sources for that group. The router sends Prune message,\n\
    \   containing source address, group address and prune lifetime,\n   separately\
    \ for each (source, group) pair and records the row as\n   pruned in the forwarding\
    \ table.\n"
- title: 7.6 Graft_Send
  contents:
  - "7.6 Graft_Send\n   The transition to this state is triggered by the local IGMP\
    \ process.\n   Once a multicast delivery has been pruned, Graft messages are\n\
    \   necessary when a host in the local subnetwork joins into the group. A\n  \
    \ Graft message sent to the upstream router should be acknowledged hop\n   by\
    \ hop to the root of the tree guaranteeing end-to-end delivery.\n   The router\
    \ obtains the group number from IGMP and go through the\n   forwarding table to\
    \ locate all traffic sources for that group. A\n   Graft message will be sent\
    \ to the upstream router with the source\n   address and group address for each\
    \ (source, group) pair. The router\n   also setups a timer for each Graft message\
    \ waiting for an\n   acknowledgement.\n"
- title: 7.7 Arr_Pkt
  contents:
  - "7.7 Arr_Pkt\n   All DVMRP control messages will be sent up to DVMRP layer by\
    \ IP. The\n   function performed by the DVMRP layer depends upon the type of the\n\
    \   message received.\n   a. Probe message: The router checks the neighbors' list\
    \ in Probe\n   message, update its their status to indicate the availability of\
    \ its\n   neighbors.\n   b. Report message: Based on exchanging report messages,\
    \ the routers\n   can build the Multicast delivery tree rooted at each source.\
    \ A\n   function called ReportPkPro will be called to handle all possible\n  \
    \ situations when receiving a report message. If the message is a\n   poison reverse\
    \ report and not coming from one of the dependent\n   downstreams, the incoming\
    \ interface should be added to the router's\n   downstream list. If the message\
    \ is not a poison reverse report but it\n   came from one of the downstreams,\
    \ this interface should be deleted\n   from the downstreams list. And then, the\
    \ router compared the metric\n   got from the message with the metric of the current\
    \ upstream, if the\n   new metric is less than the older one, the router's upstream\n\
    \   interface should be updated.\n   c. Prune message: The router extracts the\
    \ source address, group\n   address and prune lifetime, marks the incoming interface\
    \ as pruned in\n   the dependent downstream list of the (source, group) pair.\
    \ If all\n   downstream interfaces have been pruned, the router will send a prune\n\
    \   message to its upstream.\n   d. Graft message: The router extracts the source\
    \ and group address,\n   active the incoming interface in the dependent downstream\
    \ list of the\n   (source, group) pair. If the (source, group) pair has been pruned,\n\
    \   the router will reconnect the branch by sending a graft message to\n   its\
    \ upstream interface.\n   e. Graft Acknowledge message: The router extracts the\
    \ source and\n   group address, clear the graft message timer of the (source,\
    \ group)\n   pair in the forwarding table.\n"
- title: 7.8 Route_Calc
  contents:
  - "7.8 Route_Calc\n   The transition to this state is triggered by the local IP\
    \ process.\n   Once the IP receives a packet, it will fire a remote interrupt\
    \ to the\n   DVMRP and ask the DVMRP to prepare the outgoing interfaces for the\n\
    \   packet. The DVMRP process obtains the packet's source address and\n   group\
    \ address from the IP and checks the (source, group) pairs in the\n   forwarding\
    \ table to decide the branches that have the group members\n   on the Multicast\
    \ delivery tree. The Group Membership Table on IP will\n   be updated based on\
    \ this knowledge.\n"
- title: 7.9 Timer
  contents:
  - "7.9 Timer\n   This state is activated once every second. It checks the forwarding\n\
    \   table, if the Graft message acknowledgment timer is expired, The\n   router\
    \ will retransmit the Graft message to the upstream. If the\n   prune state lifetime\
    \ timer is expired, the router will graft this\n   interface so that the downstream\
    \ router can receive the packets to\n   the group again. The router also checks\
    \ if the (source, group) pair\n   is pruned by the upstream router, if so, it\
    \ will send a graft message\n   to the upstream interface.\n"
- title: 8. Simulation performance
  contents:
  - "8. Simulation performance\n   Our simulations of three network models with MOSPF\
    \ routing have\n   showed good Scalability of the protocol. The running platform\
    \ we used\n   is a SGI Octane Station with 512 MB main memory and MIPS R10000\
    \ CPU,\n   Rev 2.7. Here we list the real running time of each model along with\n\
    \   its major elements and the packet inter-arrival times for the streams\n  \
    \ generated in the hosts.\n"
- title: Simulated      Debug Model       Intermediate Model      Large Model
  contents:
  - "Simulated      Debug Model       Intermediate Model      Large Model\n  time\
    \         11 Routers           42 routers           86 routers\n             \
    \   12 Hosts             48 hosts             96 hosts\n              Reserve\
    \ Data         Reserve Data         Reserve Data\n                 0.01s     \
    \           0.02s                 0.02s\n           Best-effort Data      Best-effort\
    \ Data      Best-effort Data\n                 0.01s                0.025s   \
    \            0.025s\n  100 s        3 hours               14 hours           \
    \  30 hours\n  200 s        7 hours               30 hours               - - -\n"
- title: 9.  Future work
  contents:
  - "9.  Future work\n   We hope to receive assistance from the IPmc/RSVP development\n\
    \   community within the IETF in validating and refining this model.  We\n   believe\
    \ it will be a useful tool for predicting the behavior of\n   RSVP-capable systems.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   This RFC raises no security considerations.\n"
- title: 11.  References
  contents:
  - "11.  References\n   [1] Deering, S., \"Host Requirements for IP Multicasting\"\
    , STD 5,\n       RFC 1112, August 1989.\n   [2] Braden, R., Zhang, L., Berson,\
    \ S., Herzog, S. and S. Jamin,\n       \"Resource Reservation Protocol (RSVP)\
    \ -- Version 1 Functional\n       Specification\", RFC 2205, September 1997.\n\
    \   [3] Wroclawski, J., \"The Use of RSVP with IETF Integrated Services\",\n \
    \      RFC 2210, September 1997.\n   [4] MIL3 Inc., \"OPNET Modeler Tutorial Version\
    \ 3\", Washington, DC,\n       1997\n   [5] Moy, J., \"Multicast Extensions to\
    \ OSPF\", RFC 1584, March 1994.\n   [6] Pusateri, T., \"Distance Vector Multicast\
    \ Routing Protocol\", Work\n       in Progress.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   J. Mark Pullen\n   C3I Center/Computer Science\n   Mail\
    \ Stop 4A5\n   George Mason University\n   Fairfax, VA 22032\n   EMail: mpullen@gmu.edu\n\
    \   Ravi Malghan\n   3141 Fairview Park Drive, Suite 700\n   Falls Church VA 22042\n\
    \   EMail: rmalghan@bacon.gmu.edu\n   Lava K. Lavu\n   Bay Networks\n   600 Technology\
    \ Park Dr.\n   Billerica, MA 01821\n   EMail: llavu@bacon.gmu.edu\n   Gang Duan\n\
    \   Oracle Co.\n   Redwood Shores, CA 94065\n   EMail: gduan@us.oracle.com\n \
    \  Jiemei Ma\n   Newbridge Networks Inc.\n   593 Herndon Parkway\n   Herndon,\
    \ VA 20170\n   EMail: jma@newbridge.com\n   Hoon Nah\n   C3I Center\n   Mail Stop\
    \ 4B5\n   George Mason University\n   Fairfax, VA 22030\n   EMail: hnah@bacon.gmu.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
