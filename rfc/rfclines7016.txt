Abstract This memo describes Adobe's Secure Real Time Media Flow Protocol (RTMFP), an endpoint to endpoint communication protocol designed to securely transport parallel flows of real time video, audio, and data messages, as well as bulk data, over IP networks.
RTMFP has features that make it effective for peer to peer (P2P) as well as client  server communications, even when Network Address Translators (NATs) are used.
This document represents technology developed outside the processes of the IETF and the IETF community has determined that it is useful to publish it as an RFC in its current form.
It is a product of the IETF only in that it has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG), but the content of the document does not represent a consensus of the IETF.
Introduction Adobe's Secure Real Time Media Flow Protocol (RTMFP) is intended for use as a general purpose endpoint to endpoint data transport service in IP networks.
It has features that make it well suited to the transport of real time media (such as low delay video, audio, and data) as well as bulk data, and for client server as well as peer to  peer (P2P) communication.
These features include independent parallel message flows that may have different delivery priorities, variable message reliability (from TCP like full reliability to UDP like best effort), multi point congestion control, and built in security.
Session multiplexing and facilities to support UDP hole punching simplify
Network Address Translator (NAT) traversal in peer to peer systems.
RTMFP is implemented in Flash Player, Adobe Integrated Runtime (AIR), and Adobe Media Server (AMS, formerly Flash Media Server or FMS), all from Adobe Systems Incorporated, and is used as the foundation transport protocol for real time video, audio, and data communication, both client server and P2P, in those products.
At the time of writing, the Adobe Flash Player runtime is installed on more than one billion end user desktop computers.
RTMFP was developed by Adobe Systems Incorporated and is not the product of an IETF activity.
This memo describes the syntax and operation of the Secure Real Time Media Flow Protocol.
This memo describes a general security framework that, when combined with an application specific Cryptography Profile, can be used to establish a confidential and authenticated session between endpoints.
The application specific Cryptography Profile, not defined herein, would detail the specific cryptographic algorithms, data formats, and semantics to be used within this framework.
Interoperation between applications of RTMFP requires common or compatible Cryptography Profiles.
Note to implementers: at the time of writing, the Cryptography Profile used by the above mentioned Adobe products is not publicly described by Adobe.
Implementers should investigate the availability of documentation of that Cryptography Profile prior to implementing RTMFP for the purpose of interoperation with the above mentioned Adobe products.
Design Highlights of RTMFP Between any pair of communicating endpoints is a single, bidirectional, secured, congestion controlled session.
Unidirectional flows convey messages from one end to the other within the session.
An endpoint can have concurrent sessions with multiple other far endpoints.
Design highlights of RTMFP include the following:  The security framework is an inherent part of the basic protocol.
The application designer chooses the cryptographic formats and algorithms to suit the needs of the application, and may update them as the state of the security arts progresses.
Cryptographic Endpoint Discriminators can resist port scanning.
All header, control, and framing information, except for network addressing information and a session identifier, is encrypted according to the Cryptography Profile.
There is a single session and associated congestion control state between a pair of endpoints.
Each session may have zero or more unidirectional message oriented flows in each direction.
All of a session's sending flows share the session's congestion control state.
Return Flow Association (Section 2.3.11.1.2) generalizes bidirectional communication to arbitrarily complex trees of flows.
Messages in flows can be arbitrarily large and are fragmented for transmission.
Messages of any size may be sent with full, partial, or no reliability (sender's choice).
Messages may be delivered to the receiving user in original queuing order or network arrival order (receiver's choice).
Flows are named with arbitrary, user defined metadata (Section 2.3.11.1.1) rather than port or stream numbers.
The sequence numbers of each flow are independent of all other flows and are not permanently bound to a session wide transmission ordering.
This allows real time priority decisions to be made at transmission or retransmission time.
Each flow has its own receive window and, therefore, independent flow control.
Round trips are expensive and are minimized or eliminated when possible.
After a session is established, flows begin by sending the flow's messages with no additional handshake (and associated round trips).
Transmitting bytes on the network is much more expensive than moving bytes in a CPU or memory.
Wasted bytes are minimized or eliminated when possible and practical, and variable length encodings are used, even at the expense of breaking 32 bit alignment and making the text diagrams in this specification look awkward.
P2P lookup and peer introduction (including UDP hole punching for NAT and firewall traversal) are supported directly by the session startup handshake.
Session identifiers allow an endpoint to multiplex many sessions over a single local transport address while allowing sessions to survive changes in transport address (as may happen in mobile or wireless deployments).
The syntax of the protocol is detailed in Section 2.
The operation of the protocol is detailed in Section 3.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
Syntax Definitions of types and structures in this specification use traditional text diagrams paired with procedural descriptions using a C like syntax.
The C like procedural descriptions SHALL be construed as definitive.
Structures are packed to take only as many bytes as explicitly indicated.
There is no 32 bit alignment constraint, and fields are not padded for alignment unless explicitly indicated or described.
Text diagrams may include a bit ruler across the top; this is a convenience for counting bits in individual fields and does not necessarily imply field alignment on a multiple of the ruler width.
Unless specified otherwise, reserved fields SHOULD be set to 0 by a sender and MUST be ignored by a receiver.
The procedural syntax of this specification defines correct and error free encoded inputs to a parser.
The procedural syntax does not describe a fully featured parser, including error detection and handling.
Implementations MUST include means to identify error circumstances, including truncations causing elementary or composed types to not fit inside containing structures, fields, or elements.
Unless specified otherwise, an error circumstance SHALL abort the parsing and processing of an element and its enclosing elements, up to the containing packet.
This section lists types and structures that are used throughout this specification.
This section lists the elementary types and constructs out of which all of the following sections' definitions are built.
uint8 t var; An unsigned integer 8 bits (one byte) in length and byte aligned.
uint16 t var; An unsigned integer 16 bits in length, in network byte order ("big endian") and byte aligned.
uint32 t var; An unsigned integer 32 bits in length, in network byte order and byte aligned.
uint128 t var; An unsigned integer 128 bits in length, in network byte order and byte aligned.
bitsize; An unsigned integer of any other size, potentially not byte aligned.
Its size in bits is specified explicitly by bitsize.
A boolean flag having the value true (1 or set) or false (0 or clear) and being one bit in length.
type var[num]; A packed array of type with length num sizeof(type) 8 bits.
Its size in bits is specified by bitsize.
remainder(); The number of bytes from the current offset to the end of the enclosing structure.
Note that a bitsize of "variable" indicates that the size of the structure is determined by the sizes of its interior components.
A bitsize of "n 8" indicates that the size of the structure is a whole number of bytes and is byte aligned.
Variable Length Unsigned Integer (VLU)
A VLU encodes any finite non negative integer into one or more bytes.
For each encoded byte, if the high bit is set, the next byte is also part of the VLU.
If the high bit is clear, this is the final byte of the VLU.
The remaining bits encode the number, seven bits at a time, from most significant to least significant. 0
1 2 3 4 5 6 7
zero or more    struct vlu t { value   0
; do { bool t  more  :1;
uintn t digit :7; value
(value   128)   digit; } while(more)
/  Figure 1: VLU Depiction in Following Diagrams Unless stated otherwise in this specification
, implementations SHOULD handle VLUs encoding unsigned integers at least 64 bits in length (that is, encoding a maximum value of at least 2^64 1).
An Option is a Length Type Value triplet.
Length and Type are encoded in VLU format.
Length is the number of bytes of payload following the Length field.
The payload comprises the Type and Value fields.
Type identifies the kind of option this is.
The syntax of the Value field is determined by the type of option.
An Option can have a length of zero, in which case it has no type and no value and is empty.
An empty Option is called a "Marker".
An Option List is a sequence of zero or more non empty Options terminated by a Marker.
(empty Option) struct optionList t { do { option t option :
When communicating an Internet socket address (a combination of a 32 bit IPv4 [RFC0791] or 128 bit IPv6 [RFC2460] address and a 16 bit port number) to another RTMFP, this encoding is used.
This encoding additionally allows an address to be tagged with an origin type, which an RTMFP MAY use to modify the use or disposition of the address.
If set, the Internet address is a 128 bit IPv6 address.
If clear, the Internet address is a 32 bit IPv4 address.
The origin tag of this address.
Address was reported by the origin as a local, directly attached interface address 2:
Address was observed to be the source address from which a packet was received (a "reflexive transport address" in the terminology of [RFC5389])
Address is a relay, proxy, or introducer (a Redirector and/or Forwarder) ipAddress:  The Internet address, in network byte order.
The 16 bit port number, in network byte order.
Encapsulation RTMFP Multiplex packets are usually carried in UDP [RFC0768] datagrams so that they may transit commonly deployed NATs and firewalls, and so that RTMFP may be implemented on commonly deployed operating systems without special privileges or permissions.
RTMFP Multiplex packets MAY be carried by any suitable datagram transport or encapsulation where endpoints are addressed by an Internet socket address (that is, an IPv4 or IPv6 address and a 16 bit port number).
The choice of port numbers is not mandated by this specification.
Higher protocol layers or the application define the port numbers used.
Multiplex 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6
as if it were end padded with 0s for the following:
The 32 bit Scrambled Session ID is the 32 bit session ID modified by performing a bitwise exclusive or with the bitwise exclusive or of the first two 32 bit words of the encrypted packet.
The session ID is a 32 bit value that the receiver has requested to be used by the sender when sending packets to this receiver (Sections 2.3.7 and 2.3.8).
The session ID identifies the session to which this packet belongs and the decryption key to be used to decrypt the encrypted packet.
Session ID 0 (prior to scrambling) denotes the startup pseudo  session and implies the Default Session Key.
Note: If the encrypted packet is less than 8 bytes long, then for the scrambling operation, perform the exclusive or as though the encrypted packet were end padded with enough 0 bytes to bring its length to 8. 2.2.3.
Encryption RTMFP packets are encrypted according to a Cryptography Profile.
This specification doesn't define a Cryptography Profile or mandate a particular choice of cryptography.
The application defines the cryptographic syntax and algorithms.
Packet encryption is RECOMMENDED to be a block cipher operating in Cipher Block Chaining [CBC] or similar mode.
Encrypted packets MUST be decipherable without inter packet dependency, since packets may be lost, duplicated, or reordered in the network.
The packet encryption layer is responsible for data integrity and authenticity of packets, for example by means of a checksum or cryptographic message authentication code.
To mitigate replay attacks, data integrity SHOULD comprise duplicate packet detection, for example by means of a session wide packet sequence number.
The packet encryption layer SHALL discard a received packet that does not pass integrity or authenticity tests.
Note that the structures described below are of plain, unencrypted packets.
Encrypted packets MUST be decrypted according to the Session Key associated with the Multiplex Session ID before being interpreted according to this specification.
The Cryptography Profile defines a well known Default Session Key that is used at session startup, during which per session key(s) are negotiated by the two endpoints.
A session ID of zero denotes use of the Default Session Key.
The Default Session Key is also used with non zero session IDs during the latter phases of session startup (Sections 2.3.6 and 2.3.8).
See Security Considerations (Section 5) for more about the Default Session Key.
RTMFP packet consists of a variable sized common header, zero or more chunks, and padding.
Padding can be inserted by the encryption layer of the sender to meet cipher block size constraints and is ignored by the receiver.
A sender's encryption layer MAY pad the end of a packet with bytes with value
such that the resulting packet is a natural and appropriate size for the cipher.
Alternatively, the Cryptography Profile MAY define its own framing and padding scheme, if needed, such that decrypted packets are compatible with the syntax defined in this section.
0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7    T T  r  T T
If set, indicates that this packet contains real time user data.
timeCriticalReverse:  Time Critical Reverse Notification.
If set, indicates that the sender is currently receiving packets on other sessions that have the timeCritical flag set.
If set, indicates that the timestamp field is present.
If clear, there is no timestamp field.
If set, indicates that the timestamp echo field is present.
If clear, there is no timestamp echo field.
The mode of this packet.
See below for additional discussion of packet modes.
Startup timestamp:  If the timestampPresent flag is set, this field is present and contains the low 16 bits of the sender's 250 Hz clock (4 milliseconds per tick) at transmit time.
The sender's clock MAY have its origin at any time in the past.
timestampEcho:  If the timestampEchoPresent flag is set, this field is present and contains the sender's estimate of what the timestamp field of a packet received from the other end would be at the time this packet was transmitted, using the method described in Section 3.5.2.2.
Zero or more chunks follow the header.
It is RECOMMENDED that a packet contain at least one chunk.
Zero or more bytes of padding follow the chunks.
The chunkLength field of what would be the current chunk header indicates that the hypothetical chunk payload wouldn't fit in the remaining bytes of the packet.
Packet mode 0 is not allowed.
Packets marked with this mode are invalid and MUST be discarded.
The original initiator of a session MUST mark all non startup packets it sends in that session with packet mode 1 ("Initiator Mark").
It SHOULD ignore any packet received in that session with packet mode 1.
The original responder of a session MUST mark all non startup packets it sends in that session with packet mode 2 ("Responder Mark").
It SHOULD ignore any packet received in that session with packet mode 2.
Packet mode 3 is for session startup.
Session startup chunks are only allowed in packets with this mode.
Chunks that are not for session startup are only allowed in packets with modes 1 or 2. 2.3.
Chunks 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
The size, in bytes, of the chunk payload.
The type specific payload of this chunk, chunkLength bytes in length (may be empty).
Defined chunk types are enumerated here in the order they might be encountered in the course of a typical session.
The following chunk type codes are defined:
0x7f:  Packet Fragment (Section 2.3.1) 0x30:  Initiator
0x70:  Responder Hello (Section 2.3.4)
0x71:  Responder Redirect (Section 2.3.5)
0x79:  RHello Cookie Change (Section 2.3.6
) 0x38:  Initiator Initial Keying (Section 2.3.7)
0x78:  Responder Initial Keying (Section 2.3.8)
0x10:  User Data (Section 2.3.11)
Next User Data (Section 2.3.12) 0x50:
Data Acknowledgement Bitmap (Section 2.3.13)
0x51:  Data Acknowledgement Ranges (Section 2.3.14)
0x18:  Buffer Probe (Section 2.3.15)
Flow Exception Report (Section 2.3.16)
0x0c:  Session Close Request (Section 2.3.17)
0x4c:  Session Close Acknowledgement (Section 2.3.18)
A receiver MUST ignore a chunk having an unrecognized chunk type code.
A receiver MUST ignore a chunk appearing in a packet having a mode inappropriate to that chunk type.
Unless specified otherwise, if a chunk has a syntax or processing error (for example, the chunk's payload field is not long enough to contain the specified syntax elements), the chunk SHALL be ignored as though it was not present in the packet, and parsing and processing
SHALL commence with the next chunk in the packet, if any.
This chunk is used to divide a plain RTMFP packet (Section 2.2.4) that is unavoidably larger than the path MTU (such as session startup packets containing Responder Hello (Section 2.3.4) or Initiator Initial Keying (Section 2.3.7) chunks with large certificates) into segments that do not exceed the path MTU, and to allow the segments to be sent through the network at a moderated rate to avoid jamming interfaces, links, or paths. 0
1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
fragmentChunkPayload t { bool t  moreFragments
If clear, this fragment is the final fragment of the packet.
VLU, the identifier of this segmented packet.
All fragments of the same packet have the same packetID.
VLU, the index of this fragment of the indicated packet.
The first fragment of the packet MUST be index 0.
The bytes of the indicated segment of the indicated original plain RTMFP packet.
A packetFragment MUST NOT be empty.
The use of this mechanism is detailed in Section 3.4.
This chunk is sent by the initiator of a new session to begin the startup handshake.
This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
{ vlu t   epdLength :variable 8; uint8 t endpointDiscriminator[epdLength];
The Endpoint Discriminator for the identity with which the initiator wants to communicate.
Initiator provided data to be returned in a Responder Hello's tagEcho field.
The tag/tagEcho is used to match Responder Hellos to the initiator's session startup state independent of the responder's address.
The use of IHello is detailed in Section 3.5.1.
Forwarded Initiator Hello Chunk (FIHello)
This chunk is sent on behalf of an initiator by a Forwarder.
It is only allowed in packets of an established session having packet mode 1 or 2.
A receiver MAY treat this chunk as though it was an Initiator Hello received directly from replyAddress.
Alternatively, if the receiver is selected by the Endpoint Discriminator, it MAY respond to replyAddress with an Implied Redirect (Section 2.3.5).
0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
uint8 t   endpointDiscriminator[epdLength]; address t replyAddress :variable 8;
The Endpoint Discriminator for the identity with which the original initiator wants to communicate, copied from the original Initiator
Address format (Section 2.1.5), the address that
the forwarding node derived from the received Initiator Hello, to which the receiver should respond.
Copied from the original Initiator
The use of FIHello is detailed in Section 3.5.1.5.
This chunk is sent by a responder in response to an Initiator Hello or Forwarded Initiator Hello if the Endpoint Discriminator indicates the responder's identity.
This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
; vlu t   cookieLength :variable 8; uint8 t cookie[cookieLength]
The tag from the Initiator Hello, unaltered.
VLU, the length of the following cookie field in bytes.
Responder created state data to authenticate a future Initiator Initial Keying message (in order to prevent denial of  service attacks).
Note: This specification doesn't mandate a specific choice of certificate format.
The Cryptography Profile determines the syntax, algorithms, and interpretation of the responderCertificate.
The use of RHello is detailed in Section 3.5.1.
This chunk is sent in response to an Initiator Hello or Forwarded Initiator
Hello to indicate that the requested endpoint can be reached at one or more of the indicated addresses.
A receiver can add none, some, or all of the indicated addresses to the set of addresses to which it is sending Initiator Hello messages for the opening session associated with tagEcho.
This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
The tag from the Initiator Hello, unaltered.
Address format (Section 2.1.5) addresses to add to the opening set for the indicated session.
If this chunk lists zero redirectDestination addresses, then this is an Implied Redirect, and the indicated address is the address from which the packet containing this chunk was received.
The use of Redirect is detailed in Sections 3.5.1.1.1, 3.5.1.1.2, and 3.5.1.4.
This chunk SHOULD be sent by a responder to an initiator in response to an Initiator Initial Keying if that chunk's cookie appears to have been created by the responder but the cookie is incorrect (for example, it includes a hash of the initiator's address, but the initiator's address is different than the one that elicited the Responder Hello containing the original cookie).
This chunk is only allowed in a packet encrypted with the Default Session Key and having packet mode 3, and with the session ID indicated in the initiatorSessionID field of the Initiator Initial Keying to which this is a response. 0
oldCookieLen:  VLU, the length of the following oldCookie field in bytes.
The cookie that was sent in a previous Responder Hello and Initiator Initial Keying.
The new cookie that the responder would like sent (and signed) in a replacement Initiator Initial Keying.
The old and new cookies need not have the same lengths.
On receipt of this chunk, the initiator SHOULD compute, sign, and send a new Initiator Initial Keying having newCookie in place of oldCookie.
The use of this chunk is detailed in Section 3.5.1.2.
Initiator Initial Keying Chunk (IIKeying)
This chunk is sent by an initiator to establish a session with a responder.
The initiator MUST have obtained a valid cookie to use with the responder, typically by receiving a Responder Hello from it.
This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
/ struct iikeyingChunkPayload t { struct { uint32 t initiatorSessionID;
variable 8; uint8 t  cookieEcho[cookieLength]; vlu t    certLength :variable 8; uint8 t  initiatorCertificate[certLength]; vlu t    skicLength
The session ID to be used by the responder when sending packets to the initiator.
VLU, the length of the following cookieEcho field in bytes.
The cookie from the Responder Hello, unaltered.
VLU, the length of the following initiatorCertificate field in bytes.
VLU, the length of the following sessionKeyInitiatorComponent field in bytes.
The initiator's portion of the session key negotiation according to the Cryptography Profile.
The payload portion of this chunk up to the signature field.
The initiator's digital signature of the initiatorSignedParameters according to the Cryptography Profile.
Note: This specification doesn't mandate a specific choice of cryptography.
The Cryptography Profile determines the syntax, algorithms, and interpretation of the initiatorCertificate, responderCertificate, sessionKeyInitiatorComponent, sessionKeyResponderComponent, and signature, and how the sessionKeyInitiatorComponent and sessionKeyResponderComponent are combined to derive the session keys.
The use of IIKeying is detailed in Section 3.5.1.
Responder Initial Keying Chunk (RIKeying)
This chunk is sent by a responder in response to an Initiator Initial Keying as the final phase of session startup.
This chunk is only allowed in a packet encrypted with the Default Session Key, having packet mode 3 (Startup), and sent to the initiator with the session ID specified by the initiatorSessionID field from the Initiator Initial Keying. 0
t { struct { uint32 t responderSessionID;
vlu t    skrcLength :variable 8;
responderSessionID:  The session ID to be used by the initiator when sending packets to the responder.
skrcLength:  VLU, the length of the following sessionKeyResponderComponent field in bytes.
The responder's portion of the session key negotiation according to the Cryptography Profile.
The payload portion of this chunk up to the signature field.
The responder's digital signature of the responderSignedParameters (see below) according to the Cryptography Profile.
The concatenation of the responderSignedParametersPortion (the payload portion of this chunk up to the signature field) and the sessionKeyInitiatorComponent from the Initiator Initial Keying to which this chunk is a response.
Note: This specification doesn't mandate a specific choice of cryptography.
The Cryptography Profile determines the syntax, algorithms, and interpretation of the initiatorCertificate, responderCertificate, sessionKeyInitiatorComponent, sessionKeyResponderComponent, and signature, and how the sessionKeyInitiatorComponent and sessionKeyResponderComponent are combined to derive the session keys.
Once the responder has computed the sessionKeyResponderComponent, it has all of the information and state necessary for an established session with the initiator.
Once the responder has sent this chunk to the initiator, the session is established and ready to carry flows of user data.
Once the initiator receives, verifies, and processes this chunk, it has all of the information and state necessary for an established session with the responder.
The session is established and ready to carry flows of user data.
The use of RIKeying is detailed in Section 3.5.1.
This chunk is sent in order to elicit a Ping Reply from the receiver.
It is only allowed in a packet belonging to an established session and having packet mode 1 or 2. 0
The receiver of this chunk SHOULD reply as immediately as is practical with a Ping Reply.
Ping and the expected Ping Reply are typically used for session keepalive, endpoint address change verification, and path MTU discovery.
See Section 3.5.4 for details.
This chunk is sent in response to a Ping chunk.
It is only allowed in a packet belonging to an established session and having packet mode 1 or 2. 0
1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
The message from the Ping to which this is a response, unaltered.
This chunk is the basic unit of transmission for the user messages of a flow.
A user message comprises one or more fragments.
Each fragment is carried in its own chunk and has a unique sequence number in its flow.
It is only allowed in a packet belonging to an established session and having packet mode 1 or 2. 0
A F   P s  R
vlu t   sequenceNumber :variable 8
sequenceNumber fsnOffset; if(optionsPresent) optionList t options :variable 8;
; optionsPresent:  If set, indicates the presence of an option list before the user data.
If clear, there is no option list in this chunk.
Indicates how this fragment is assembled, potentially with others, into a complete user message.
This fragment is a complete message.
This fragment is the first of a multi fragment message.
This fragment is the last of a multi fragment message.
This fragment is in the middle of a multi fragment message.
A single fragment user message has a fragment control of "0 whole".
When a message has more than one fragment, the first fragment has a fragment control of "1 begin", then zero or more "3 middle" fragments, and finally a "2 end" fragment.
The sequence numbers of a multi fragment message MUST be contiguous.
If set, this sequence number has been abandoned by the sender.
The userData, if any, MUST be ignored.
If set, this is the last sequence number of the flow.
VLU, the sequence number of this fragment.
Fragments are assigned contiguous increasing sequence numbers in a flow.
The first sequence number of a flow SHOULD be 1.
The first sequence number of a flow MUST be greater than zero.
Sequence numbers are unbounded and do not wrap.
fsnOffset:  VLU, the difference between the sequence number and the Forward Sequence Number.
This field MUST NOT be zero if the abandon flag is not set.
This field MUST NOT be greater than sequenceNumber.
The flow sender will not send (or resend)
any fragment with a sequence number less than or equal to the Forward Sequence Number.
If the optionsPresent flag is set, a list of zero or more Options terminated by a Marker is present.
See Section 2.3.11.1 for defined options.
userData:  The actual user data for this fragment.
The use of User Data is detailed in Section 3.6.2.
This section lists options that may appear in User Data option lists.
A conforming implementation MUST support the options in this section.
A flow receiver MUST reject a flow containing a flow option that is not understood if the option type is less than 8192 (0x2000).
A flow receiver MUST ignore any flow option that is not understood if the option type is 8192 or greater.
The following option type codes are defined for User Data:
User's Per Flow Metadata (Section 2.3.11.1.1) 0x0a:  Return Flow Association (Section 2.3.11.1.2)
This option conveys the user's per flow metadata for the flow to which it's attached.
The metadata does not change over the life of the flow.
Every flow MUST have metadata.
A flow sender MUST send this option with the first User Data chunk for this flow in each packet until an acknowledgement for this flow is received.
A flow sender SHOULD NOT send this option more than once for each flow in any one packet.
A flow sender SHOULD NOT send this option for a flow once the flow has been acknowledged.
This specification doesn't mandate the encoding, syntax, or interpretation of the user's per flow metadata; this is determined by the application.
The userMetadata SHOULD NOT exceed 512 bytes.
The userMetadata MAY be 0 bytes in length.
A new flow can be considered to be in return (or response) to a flow sent by the other endpoint.
This option encodes the receive flow identifier to which this new sending flow is a response.
} :variable 8; Consider endpoints A and B.  Endpoint A begins a flow with identifier 5 to endpoint
B.  A is the flow sender for A's flowID 5, and B is the flow receiver for A's flowID 5.
B begins a return flow with identifier 7 to A in response to A's flowID 5.
B is the flow sender for B's flowID 7, and A is the flow receiver for B's flowID 7.
B sends this option with flowID set to 5 to indicate that B's flowID 7 is in response to and associated with A's flowID 5.
If there is a return association, the flow sender MUST send this option with the first User Data chunk for this flow in each packet until an acknowledgement for this flow is received.
A flow sender SHOULD NOT send this option more than once for each flow in any one packet.
A flow sender SHOULD NOT send this option for a flow once the flow has been acknowledged.
A flow MUST NOT indicate more than one return association.
A flow MUST indicate its return association, if any, upon its first transmission of a User Data chunk.
A return association can't be added to a sending flow after it begins.
A flow receiver MUST reject a new receiving flow having a return flow association that does not indicate an F OPEN sending flow.
This chunk is equivalent to the User Data chunk for purposes of sending the user messages of a flow.
When used, it MUST follow a User Data chunk or another Next User Data chunk in the same packet. 0
A F   P s  R
I   T v  A   v
; This chunk is considered to be for the same flowID as the most recently preceding User Data or Next User Data chunk in the same packet, having the same Forward Sequence Number, and having the next sequence number.
The optionsPresent, fragmentControl, abandon, and final flags, and the options (if present), have the same interpretation as for the User Data chunk.
10 00 07    User Data chunk, length
OPT 0, FRA 0 "whole", ABN 0, FIN 0
02 05 03    flowID 2, seq# 5, fsn (5 3) 2 00
01 02    data 3 bytes: 00, 01, 02    11 00 04
OPT 0, FRA 0 "whole", ABN 0, FIN 0   flowID 2, seq# 6, fsn 2 03 04 05    data 3 bytes: 03, 04, 05
Next User Data chunk, length
OPT 0, FRA 0 "whole", ABN 0, FIN 0   flowID 2, seq# 7, fsn 2 06
07 08    data 3 bytes: 06, 07, 08    Figure 3:
Sequential Messages in One Packet Using Next User Data
The use of Next User Data is detailed in Section 3.6.2.3.2.
Data Acknowledgement Bitmap Chunk (Bitmap Ack)
This chunk is sent by the flow receiver to indicate to the flow sender the User Data fragment sequence numbers that have been received for one flow.
It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
The flow receiver can choose to acknowledge User Data with this chunk or with a Range Ack.
It SHOULD choose whichever format has the most compact encoding of the sequence numbers received. 0
7 6 5 4 3 2 1 0 5 4 3 2 1 0
struct dataAckBitmapChunkPayload t { vlu t flowID :variable 8;
vlu t bufferBlocksAvailable :variable 8; //
"bufAvail" vlu t cumulativeAck :variable 8
VLU, the number of 1024 byte blocks of User Data that the receiver is currently able to accept.
Section 3.6.3.5 describes how to calculate this value.
VLU, the acknowledgement of every fragment sequence number in this flow that is less than or equal to this value.
This MUST NOT be less than the highest Forward Sequence Number received in this flow.
A sequence of zero or more bytes representing a bit field of received fragment sequence numbers after the cumulative acknowledgement, least significant bit first.
A set bit indicates receipt of a sequence number.
A clear bit indicates that sequence number was not received.
The least significant bit of the first byte is the second sequence number following the cumulative acknowledgement, the next bit is the third sequence number following, and so on.
Figure 4 shows an example Bitmap Ack indicating acknowledgement of fragment sequence numbers 0 through 16, 18, 21 through 24, 27, and 28.
50 00 05    Bitmap Ack, length 5 bytes 05 7f 10
flowID 5, bufAvail 127 1024 bytes, cumAck 0..
This chunk is sent by the flow receiver to indicate to the flow sender the User Data fragment sequence numbers that have been received for one flow.
It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
The flow receiver can choose to acknowledge User Data with this chunk or with a Bitmap Ack.
It SHOULD choose whichever format has the most compact encoding of the sequence numbers received. 0
struct dataAckRangesChunkPayload t { vlu t flowID :variable 8;
vlu t bufferBlocksAvailable :variable 8; //
"bufAvail" vlu t cumulativeAck :variable 8
acknowledge(0 through cumulativeAck); ackCursor   cumulativeAck; while(remainder()
#recv 1" ackCursor ; rangeFrom
VLU, the number of 1024 byte blocks of User Data that the receiver is currently able to accept.
Section 3.6.3.5 describes how to calculate this value.
VLU, the acknowledgement of every fragment sequence number in this flow that is less than or equal to this value.
This MUST NOT be less than the highest Forward Sequence Number received in this flow.
/ receivedMinusOne:  Zero or more acknowledgement ranges, run length encoded.
Runs are encoded as zero or more pairs of VLUs indicating the number (minus one) of missing sequence numbers followed by the number (minus one) of received sequence numbers, starting at the cumulative acknowledgement.
If a parser syntax error is encountered here (that is, if the chunk is truncated such that not enough bytes remain to completely encode both VLUs of the acknowledgement range), then treat and process this chunk as though it was properly formed up to the last completely encoded range.
Figure 5 shows an example Range Ack indicating acknowledgement of fragment sequence numbers 0 through 16, 18, 21, 22, 23, and 24.
51 00 07    Range Ack, length
7 05 7f 10    flowID 5, bufAvail 127 1024 bytes, cumAck 0..
Example Range Ack Figure 6 shows an example Range Ack indicating acknowledgement of fragment sequence numbers 0 through 16 and 18, with a truncated last range.
Note that the truncation and parse error does not abort the entire chunk in this case.
51 00 07    Range Ack, length 9 05 7f 10    flowID 5, bufAvail 127 1024 bytes, cumAck 0..
Example Truncated Range Ack 2.3.15.
This chunk is sent by the flow sender in order to request the current available receive buffer (in the form of a Data Acknowledgement) for a flow.
It is only allowed in a packet belonging to an established session and having packet mode 1 or 2. 0
; flowID:  VLU, the flow identifier.
The receiver of this chunk SHOULD reply as immediately as is practical with a Data Acknowledgement.
This chunk is sent by the flow receiver to indicate that it is not (or is no longer) interested in the flow and would like the flow sender to close the flow.
This chunk SHOULD precede every Data Acknowledgement chunk for the same flow in this condition.
This chunk is only allowed in a packet belonging to an established session and having packet mode 1 or 2. 0
1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
struct flowExceptionReportChunkPayload t { vlu t flowID :variable 8;
VLU, the application defined exception code being reported.
A receiving RTMFP might reject a flow automatically, for example if it is missing metadata, or if an invalid return association is specified.
In circumstances where an RTMFP rejects a flow automatically, the exception code MUST be 0.
The application can specify any exception code, including 0, when rejecting a flow.
All non zero exception codes are reserved for the application.
Session Close Request Chunk (Close)
This chunk is sent to cleanly terminate a session.
It is only allowed in a packet belonging to an established or closing session and having packet mode 1 or 2. 0
1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
This chunk has no payload.
The use of Close is detailed in Section 3.5.5.
Session Close Acknowledgement Chunk (Close Ack)
This chunk is sent in response to a Session Close Request to indicate that the sender has terminated the session.
It is only allowed in a packet belonging to an established or closing session and having packet mode 1 or 2. 0
1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
This chunk has no payload.
The use of Close Ack is detailed in Section 3.5.5.
S E S S I
S E S S I
Sessions between Pairs of Communicating Endpoints Between any pair of communicating endpoints is a single, bidirectional, secured, congestion controlled session.
Unidirectional flows convey messages from one end to the other within the session.
An endpoint initiates a session to a far end when communication is desired.
An initiator begins with one or more candidate destination socket addresses, and it may learn and try more candidate addresses during startup handshaking.
Eventually, a first suitable response is received, and that endpoint is selected.
Startup proceeds to the selected endpoint.
In the case of session startup glare, one endpoint is the prevailing initiator and the other assumes the role of responder.
Encryption keys and session identifiers are negotiated between the endpoints, and the session is established.
Each endpoint may begin sending message flows to the other end.
For each flow, the far end may accept it and deliver its messages to the user, or it may reject the flow and transmit an exception to the sender.
The flow receiver may close and reject a flow at a later time, after first accepting it.
The flow receiver acknowledges all data sent to it, regardless of whether the flow was accepted.
Acknowledgements drive a congestion control mechanism.
An endpoint may have concurrent sessions with other far endpoints.
The multiple sessions are distinguished by a session identifier rather than by socket address.
This allows an endpoint's address to change mid session without having to tear down and re establish a session.
The existing cryptographic state for a session can be used to verify a change of address while protecting against session hijacking or denial of service.
A sender may indicate to a receiver that some user messages are of a time critical or real time nature.
A receiver may indicate to senders on concurrent sessions that it is receiving time critical messages from another endpoint.
The other senders SHOULD modify their congestion control parameters to yield capacity to the session carrying time critical messages.
A sender may close a flow.
The flow is completed when the receiver has no outstanding gaps before the final fragment of the flow.
The sender and receiver reserve
a completed flow's identifier for a time to allow in flight messages to drain from the network.
Eventually, neither end will have any flows open to the other.
The session will be idle and quiescent.
Either end may reliably close the session to recover its resources.
In certain circumstances, an endpoint may be ceasing operation and not have time to wait for acknowledgement of a reliable session close.
In this case, the halting endpoint may send an abrupt session close to advise the far end that it is halting immediately.
Each RTMFP endpoint has an identity.
The identity is encoded in a certificate.
This specification doesn't mandate any particular certificate format, cryptographic algorithms, or cryptographic properties for certificates.
An endpoint is named by an Endpoint Discriminator.
This specification doesn't mandate any particular format for Endpoint Discriminators.
An Endpoint Discriminator MAY select more than one identity and MAY match more than one distinct certificate.
Multiple distinct Endpoint Discriminators MAY match one certificate.
It is RECOMMENDED that multiple endpoints not have the same identity.
Entities with the same identity are indistinguishable during session startup; this situation could be undesirable in some applications.
An endpoint MAY have more than one address.
The Cryptography Profile implements the following functions for identities, certificates, and Endpoint Discriminators, whose operation MUST be deterministic:
Test whether a given certificate is authentic.
Authenticity can comprise verifying an issuer signature chain in a public key infrastructure.
Test whether a given Endpoint Discriminator selects a given certificate.
Test whether a given Endpoint Discriminator selects the local endpoint.
Generate a Canonical Endpoint Discriminator for a given certificate.
Canonical Endpoint Discriminators for distinct identities SHOULD be distinct.
If two distinct identities have the same Canonical Endpoint Discriminator, an initiator might abort a new opening session to the second identity (Section 3.5.1.1.1); this behavior might not be desirable.
Given a certificate, a message, and a digital signature over the message, test whether the signature is valid and generated by the owner of the certificate.
Generate a digital signature for a given message corresponding to the near identity.
Given the near identity and a far certificate, determine which one shall prevail as Initiator and which shall assume the Responder role in the case of startup glare.
The far end MUST arrive at the same conclusion.
A comparison function can comprise performing a lexicographic ordering of the binary certificates, declaring the far identity the prevailing endpoint if the far certificate is ordered before the near certificate, and otherwise declaring the near identity to be the prevailing endpoint.
Given a first certificate and a second certificate, test whether a new incoming session from the second shall override an existing session with the first.
It is RECOMMENDED that the test comprise testing whether the certificates are bitwise identical.
All other semantics for certificates and Endpoint Discriminators are determined by the Cryptography Profile and the application.
An RTMFP typically has one or more interfaces through which it communicates with other RTMFP endpoints.
RTMFP can communicate with multiple distinct other RTMFP endpoints through each local interface.
Session multiplexing over a shared interface can facilitate peer to  peer communications through a NAT, by enabling third party endpoints such as Forwarders (Section 3.5.1.5) and Redirectors (Section 3.5.1.4) to observe the translated public address and inform peers of the translation.
An interface is typically a UDP socket (Section 2.2.1) but MAY be any suitable datagram transport service where endpoints can be addressed by IPv4 or IPv6 socket addresses.
RTMFP uses a session ID to multiplex and demultiplex communications with distinct endpoints (Section 2.2.2), in addition to the endpoint socket address.
This allows an RTMFP to detect a far end address change (as might happen, for example, in mobile and wireless scenarios) and allows communication sessions to survive address changes.
This also allows an RTMFP to act as a Forwarder or Redirector for an endpoint with which it has an active session, by distinguishing startup packets from those of the active session.
On receiving a packet, an RTMFP decodes the session ID to look up the corresponding session information context and decryption key.
Session ID 0 is reserved for session startup and MUST NOT be used for an active session.
A packet for Session ID 0 uses the Default Session Key as defined by the Cryptography Profile.
When an RTMFP packet (Section 2.2.4) is unavoidably larger than the path MTU (such as a startup packet containing an RHello (Section 2.3.4) or IIKeying (Section 2.3.7) chunk with a large certificate), it can be fragmented into segments that do not exceed the path MTU by using the Packet Fragment chunk (Section 2.3.1).
The packet fragmentation mechanism SHOULD be used only to segment unavoidably large packets.
Accordingly, this mechanism SHOULD be employed only during session startup with Session ID 0.
This mechanism MUST NOT be used instead of the natural fragmentation mechanism of the User Data (Section 2.3.11) and Next User Data (Section 2.3.12) chunks for dividing the messages of the user's data flows into segments that do not exceed the path MTU.
A fragmented plain RTMFP packet is reassembled by concatenating the packetFragment fields of the fragments for the packet in contiguous ascending order, starting from index 0 through and including the final fragment.
When reassembling packets for Session ID 0, a receiver SHOULD identify the packets by the socket address from which the packet containing the fragment was received, as well as the indicated packetID.
A receiver SHOULD allow up to 60 seconds to completely receive a fragmented packet for which progress is being made.
A packet is progressing if at least one new fragment for it was received in the last second.
A receiver MUST discard a Packet Fragment chunk having an empty packetFragment field.
The mode of each packet containing Packet Fragments for the same fragmented packet MUST match the mode of the fragmented packet.
A receiver MUST discard any new Packet Fragment chunk received in a packet with a mode different from the mode of the packet containing the first received fragment.
A receiver MUST discard any reassembled packet with a mode different than the packets containing its fragments.
In order to avoid jamming the network, the sender MUST rate limit packet transmission.
In the absence of specific path capacity information (for instance, during session startup), a sender SHOULD NOT send more than 4380 bytes nor more than four packets per distinct endpoint every 200 ms.
To avoid resource exhaustion, a receiver SHOULD limit the number of concurrent packet reassembly buffers and the size of each buffer.
Limits can depend, for example, on the expected size of reassembled packets, on the rate at which fragmented packets are expected to be received, on the expected degree of interleaving, and on the expected function of the receiver.
Limits can depend on the available resources of the receiver.
There can be different limits for packets with Session ID 0 and packets for established sessions.
For example, a busy server might need to allow for several hundred concurrent packet reassembly buffers to accommodate hundreds of connection requests per second with potentially interleaved fragments, but a client device with constrained resources could allow just a few reassembly buffers.
In the absence of specific information regarding the expected size of reassembled packets, a receiver should set the limit for each packet reassembly buffer to 65536 bytes.
A session is the protocol relationship between a pair of communicating endpoints, comprising the shared and endpoint specific information context necessary to carry out the communication.
The session context at each end includes at least:
the last timestamp received from the far end;  TS RX TIME: the time at which TS RX was first observed to be different than its previous value;  TS ECHO
TX: the last timestamp echo sent to the far end;
MRTO: the measured retransmission timeout;  ERTO: the effective retransmission timeout;  Cryptographic keys for encrypting and decrypting packets, and for verifying the validity of packets, according to the Cryptography Profile;  Cryptographic near and far nonces according to the Cryptography Profile, where the near nonce is the far end's far nonce, and vice versa;
The certificate of the far end;  The receive session identifier, used by the far end when sending packets to this end;  The send session identifier to use when sending packets to the far end;  DESTADDR: the destination socket address to use when sending packets to the far end;
The set of all sending flow contexts (Section 3.6.2);
The set of all receiving flow contexts (Section 3.6.3);
The transmission budget, which controls the rate at which data is sent into the network (for example, a congestion window);  S OUTSTANDING BYTES: the total amount of user message data outstanding, or in flight, in the network
that is, the sum of the F OUTSTANDING BYTES of each sending flow in the session;  RX DATA PACKETS: a count of the number of received packets containing at least one User Data chunk since the last acknowledgement was sent, initially 0;
ACK NOW: a boolean flag indicating whether an acknowledgement should be sent immediately, initially false;  DELACK ALARM: an alarm to trigger an acknowledgement after a delay, initially unset;  The state, at any time being one of the following values: the opening states S IHELLO SENT and S KEYING SENT, the open state S OPEN, the closing states S NEARCLOSE and S FARCLOSE LINGER, and the closed states S CLOSED and S OPEN FAILED; and
The role   either Initiator or Responder   of this end of the session.
Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.
Figure 8: Session State Diagram 3.5.1.
Normal Handshake RTMFP sessions are established with a 4 way handshake in two round trips.
The initiator begins by sending an IHello to one or more candidate addresses for the desired destination endpoint.
A responder statelessly sends an RHello in response.
The first correct RHello received at the initiator is selected; all others are ignored.
The initiator computes its half of the session keying and sends an IIKeying.
The responder receives the IIKeying and, if it is acceptable, computes its half of the session keying, at which point it can also compute the shared session keying and session nonces.
The responder creates a new S OPEN session with the initiator and sends an RIKeying.
The initiator receives the RIKeying and, if it is acceptable, computes the shared session keying and session nonces.
The initiator's session is now S OPEN. .
S E S S I
In the following sections, the handshake is detailed from the perspectives of the initiator and responder.
The initiator determines that a session is needed for an Endpoint Discriminator.
The initiator creates state for a new opening session and begins with a candidate endpoint address set containing at least one address.
The new session is placed in the S IHELLO SENT state.
If the session does not move to the S OPEN state before an ultimate open timeout, the session has failed and moves to the S OPEN FAILED state.
The RECOMMENDED ultimate open timeout is 95 seconds.
The initiator chooses a new, unique tag not used by any currently opening session.
It is RECOMMENDED that the tag be cryptographically pseudorandom and be at least 8 bytes in length, so that it is hard to guess.
The initiator constructs an IHello chunk (Section 2.3.2) with the Endpoint Discriminator and the tag.
While the initiator is in the S IHELLO SENT state, it sends the IHello to each candidate endpoint address in the set, on a backoff schedule.
The backoff SHOULD NOT be less than multiplicative, with not less than 1.5 seconds added to the interval between each attempt.
The backoff SHOULD be scheduled separately for each candidate address, since new candidates can be added over time.
If the initiator receives a Redirect chunk (Section 2.3.5) with a tag echo matching this session, AND this session is in the S IHELLO SENT state, then for each redirect destination indicated in the Redirect: if the candidate endpoint address set contains fewer than REDIRECT THRESHOLD addresses, add the indicated redirect destination to the candidate endpoint address set.
REDIRECT THRESHOLD SHOULD NOT be more than 24.
If the initiator receives an RHello chunk (Section 2.3.4) with a tag echo matching this session, AND this session is in the S IHELLO SENT state, AND the responder certificate matches the desired Endpoint Discriminator, AND the certificate is authentic according to the Cryptography Profile, then: 1.
If the Canonical Endpoint Discriminator for the responder certificate matches the Canonical Endpoint Discriminator of another existing session in the S KEYING
SENT or S OPEN states, AND
the certificate of the other opening session matches the desired Endpoint Discriminator, then this session is a duplicate and SHOULD be aborted in favor of the other existing session;
Move to the S KEYING SENT state.
Set DESTADDR, the far end address for the session, to the address from which this RHello was received.
The initiator chooses a new, unique receive session ID, not used by any other session, for the responder to use when sending packets to the initiator.
It computes a Session Key Initiator Component appropriate to the responder's certificate according to the Cryptography Profile.
Using this data and the cookie from the RHello, the initiator constructs and signs an IIKeying chunk (Section 2.3.7).
While the initiator is in the S KEYING SENT state, it sends the IIKeying to DESTADDR on a backoff schedule.
The backoff SHOULD NOT be less than multiplicative, with not less than 1.5 seconds added to the interval between each attempt.
If the initiator receives an RIKeying chunk (Section 2.3.8) in a packet with this session's receive session identifier, AND this session is in the S KEYING SENT state, AND the signature in the chunk is authentic according to the far end's certificate (from the RHello), AND the Session Key Responder Component successfully combines with the Session Key Initiator Component and the near and far certificates to form the shared session keys and nonces according to the Cryptography Profile, then the session has opened successfully.
The session moves to the S OPEN state.
The send session identifier is set from the RIKeying.
Packet encryption, decryption, and verification now use the newly computed shared session keys, and the session nonces are available for application  layer cryptographic challenges.
On receipt of an IHello chunk (Section 2.3.2) with an Endpoint Discriminator that selects its identity, an endpoint SHOULD construct an RHello chunk (Section 2.3.4) and send it to the address from which the IHello was received.
To avoid a potential resource exhaustion denial of service, the endpoint SHOULD NOT create any persistent state associated with the IHello.
The endpoint MUST generate the cookie for the RHello in such a way that it can be recognized as authentic and valid when echoed in an IIKeying.
The endpoint SHOULD use the address from which the IHello was received as part of the cookie generation formula.
Cookies SHOULD be valid only for a limited time; that lifetime SHOULD NOT be less than 95 seconds (the recommended ultimate session open timeout).
On receipt of an FIHello chunk (Section 2.3.3) from a Forwarder (Section 3.5.1.5) where the Endpoint Discriminator selects its identity, an endpoint SHOULD do one of the following: 1.  Compute, construct, and send an RHello as though the FIHello was an IHello received from the indicated reply address; or 2.
Construct and send an Implied Redirect (Section 2.3.5) to the FIHello's reply address; or 3.
On receipt of an IIKeying chunk (Section 2.3.7), if the cookie is not authentic or if it has expired, ignore this IIKeying; otherwise, On receipt of an IIKeying chunk, if the cookie appears authentic but does not match the address from which the IIKeying's packet was received, perform the special processing at Cookie Change (Section 3.5.1.2); otherwise, On receipt of an IIKeying with an authentic and valid cookie, if the certificate is authentic according to the Cryptography Profile, AND the signature in the chunk is authentic according to the far end's certificate and the Cryptography Profile, AND the Session Key Initiator Component is acceptable, then: 1.
If the address from which this IIKeying was received corresponds to an opening session in the S IHELLO SENT or
S KEYING SENT state, perform the special processing at Glare (Section 3.5.1.3); otherwise, 2.
If the address from which this IIKeying was received corresponds to a session in the S OPEN state, then: 1.
If the receiver was the Responder for the S OPEN session and the session identifier, certificate, and
Session Key Initiator Component are identical to those of the S OPEN session, this IIKeying is a retransmission, so resend the S OPEN session's RIKeying using the Default Session Key as specified below; otherwise, 2.
If the certificate from this IIKeying does not override the certificate of the S OPEN session, ignore this IIKeying; otherwise, 3.
The certificate from this IIKeying overrides the certificate of the S OPEN session; this is a new opening session from the same identity, and the existing S OPEN session is stale.
Move the existing S OPEN session to S CLOSED and abort all of its flows (signaling exceptions to the user), then continue processing this IIKeying.
Compute a Session Key Responder Component and choose a new, unique receive session ID not used by any other session for the initiator to use when sending packets to the responder.
Using this data, construct and, with the Session Key Initiator Component, sign an RIKeying chunk (Section 2.3.8).
Using the Session Key Initiator and Responder Components and the near and far certificates, the responder combines and computes the shared session keys and nonces according to the Cryptography Profile.
The responder creates a new session in the S OPEN state, with the far endpoint address DESTADDR taken from the source address of the packet containing the IIKeying and the send session identifier taken from the IIKeying.
The responder sends the RIKeying to the initiator using the Default Session Key and the requested send session identifier.
Packet encryption, decryption, and verification of all future packets for this session use the newly computed keys, and the session nonces are available for application layer cryptographic challenges.
In some circumstances, the responder may generate an RHello cookie for an initiator's address that isn't the address the initiator would use when sending packets directly to the responder.
This can happen, for example, when the initiator has multiple local addresses and uses one address to reach a Forwarder (Section 3.5.1.5) but another to reach the responder.
S E S S I
The initiator has two network interfaces: a first preferred interface with address
Ix   192.0.2.100:50000, and a second with address
The responder has one interface with address
Ry   198.51.100.200:51000, on the same network as the initiator's second interface.
The initiator uses its first interface to reach a Forwarder.
The Forwarder observes the initiator's address of Ix and sends a Forwarded IHello (Section 2.3.3) to the responder.
The responder treats this as if it were an IHello from Ix, calculates a corresponding cookie, and sends an RHello to Ix.
The initiator receives this RHello from Ry and selects that address as the destination for the session.
It then sends an IIKeying, copying the cookie from the RHello.
However, since the source of the RHello is Ry, on a network to which the initiator is directly connected, the initiator uses its second interface Iy to send the IIKeying.
The responder, on receiving the IIKeying, will compare the cookie to the expected value based on the source address of the packet, and since the IIKeying source doesn't match the IHello source used to generate the cookie, the responder will reject the IIKeying.
If the responder determines that it generated the cookie in the IIKeying
but the cookie doesn't match the sender's address
(for example, if the cookie is in two parts, with a first part generated independently of the initiator's address and a second part dependent on the address), the responder SHOULD generate a new cookie based on the address from which the IIKeying was received and send an RHello Cookie Change chunk (Section 2.3.6) to the source of the IIKeying, using the session ID from the IIKeying and the Default Session Key.
If the initiator receives an RHello Cookie Change chunk for a session in the S KEYING SENT state, AND the old cookie matches the one originally sent to the responder, then the initiator adopts the new cookie, constructs and signs a new IIKeying chunk, and sends the new IIKeying to the responder.
The initiator SHOULD NOT change the cookie for a session more than once.
Glare Glare occurs when two endpoints attempt to initiate sessions to each other concurrently.
Glare is detected by receipt of a valid and authentic IIKeying from an endpoint address that is a destination for an opening session.
Only one session is allowed between a pair of endpoints.
Glare is resolved by comparing the certificate in the received IIKeying with the near end's certificate.
The Cryptography Profile defines a certificate comparison function to determine the prevailing endpoint when there is glare.
If the near end prevails, discard and ignore the received IIKeying.
The far end will abort its opening session on receipt of IIKeying from the near end.
Otherwise, the far end prevails: 1.
If the certificate in the IIKeying overrides the certificate associated with the near opening session according to the Cryptography Profile, then abort and destroy the near opening session.
Continue with normal Responder IIKeying processing (Section 3.5.1.1.2).
Redirector A Redirector acts like a name server for Endpoint Discriminators.
An initiator MAY use a Redirector to discover additional candidate endpoint addresses for a desired endpoint.
On receipt of an IHello chunk with an Endpoint Discriminator that does not select the Redirector's identity, the Redirector constructs and sends back to the initiator a Responder Redirect chunk (Section 2.3.5) containing one or more additional candidate addresses for the indicated endpoint.
S E S S I
Handshake Using a Redirector Deployment Design Note:
Redirectors SHOULD NOT initiate new sessions to endpoints that might use the Redirector's address as a candidate for another endpoint, since the far end might interpret the Redirector's IIKeying as glare for the far end's initiation to the other endpoint.
Forwarder A responder might be behind a NAT or firewall that doesn't allow inbound packets to reach the endpoint until it first sends an outbound packet for a particular far endpoint address.
A Forwarder's endpoint address MAY be a candidate address for another endpoint.
A responder MAY use a Forwarder to receive FIHello chunks sent on behalf of an initiator.
On receipt of an IHello chunk with an Endpoint Discriminator that does not select the Forwarder's identity, if the Forwarder has an S OPEN session with an endpoint whose certificate matches the desired Endpoint Discriminator, the Forwarder constructs and sends an FIHello chunk (Section 2.3.3) to the selected endpoint over the S OPEN session, using the tag and Endpoint Discriminator from the IHello chunk and the source address of the packet containing the IHello for the corresponding fields of the FIHello.
On receipt of an FIHello chunk, a responder might send an RHello or Implied Redirect to the original source of the IHello (Section 3.5.1.1.2), potentially allowing future packets to flow directly between the initiator and responder through the NAT or firewall.
S E S S I
Forwarder Handshake where Responder Sends an RHello Initiator
Forwarder Handshake where Responder Sends an Implied Redirect 3.5.1.6.
Redirector and Forwarder with NAT
An initiator and responder might each be behind distinct NATs or firewalls that don't allow inbound packets to reach the respective endpoints until each first sends an outbound packet for a particular far endpoint address.
An introduction service comprising Redirector and Forwarder functions may facilitate direct communication between endpoints each behind a NAT.
The responder is registered with the introduction service via an S OPEN session to it.
The service observes and records the responder's public NAT address as the DESTADDR of the S OPEN session.
The service MAY record other addresses for the responder
, for example addresses that the responder self reports as being directly attached.
The initiator begins with an address of the introduction service as an initial candidate.
The Redirector portion of the service sends to the initiator a Responder Redirect containing at least the responder's public NAT address as previously recorded.
The Forwarder portion of the service sends to the responder a Forwarded IHello containing the initiator's public NAT address as observed to be the source of the IHello.
The responder sends an RHello to the initiator's public NAT address in response to the FIHello.
This will allow inbound packets to the responder through its NAT from the initiator's public NAT address.
The initiator sends an IHello to the responder's public NAT address in response to the Responder Redirect.
This will allow inbound packets to the initiator through its NAT from the responder's public NAT address.
With transit paths created in both NATs, normal session startup can proceed.
S E S S I
Handshake with Redirector and Forwarder
If it arrives before, it may be dropped by the NAT.
If it arrives after, it will transit the NAT and trigger keying without waiting for another round trip time.
The timing of this race depends, among other factors, on the relative distances of the initiator and responder from each other and from the introduction service.
Parallel Open to Multiple Endpoints
As specified in Section 3.2, more than one endpoint is allowed to be selected by one Endpoint Discriminator.
This will typically be the case for a set of servers, any of which could accommodate a connecting client.
As specified in Section 3.5.1.1.1, an initiator is allowed to use multiple candidate endpoint addresses when starting a session, and the sender of the first acceptable RHello chunk to be received is selected to complete the session, with later responses ignored.
An initiator can start with the multiple candidate endpoint addresses, or it may learn them during startup from one or more Redirectors (Section 3.5.1.4).
Parallel open to multiple endpoints for the same Endpoint Discriminator, combined with selection by earliest RHello, can be used for load distribution and fault tolerance.
The cost at each endpoint that is not selected is limited to receiving and processing an IHello, and generating and sending an RHello.
In one circumstance, multiple servers of similar processing and networking capacity may be located in near proximity to each other, such as in a data center.
In this circumstance, a less heavily loaded server can respond to an IHello more quickly than more heavily loaded servers and will tend to be selected by a client.
In another circumstance, multiple servers may be located in different physical locations, such as different data centers.
In this circumstance, a server that is located nearer (in terms of network distance) to the client can respond earlier than more distant servers and will tend to be selected by the client.
Multiple servers, in proximity or distant from one another, can form a redundant pool of servers.
A client can perform a parallel open to the multiple servers.
In normal operation, the multiple servers will all respond, and the client will select one of them as described above.
If one of the multiple servers fails, other servers in the pool can still respond to the client, allowing the client to succeed to an S OPEN session with one of them.
An RTMFP MUST implement congestion control and avoidance algorithms that are "TCP compatible", in accordance with Internet best current practice [RFC2914].
The algorithms SHOULD NOT be more aggressive in sending data than those described in "TCP Congestion Control" [RFC5681] and MUST NOT be more aggressive in sending data than the "slow start algorithm" described in Section 3.1 of RFC 5681.
An endpoint maintains a transmission budget in the session information context of each S OPEN session (Section 3.5), controlling the rate at which the endpoint sends data into the network.
For window based congestion control and avoidance algorithms, the transmission budget is the congestion window, which is the amount of user data that is allowed to be outstanding, or in flight, in the network.
Transmission is allowed when S OUTSTANDING BYTES (Section 3.5) is less than the congestion window (Section 3.6.2.3).
See Appendix A for an experimental window based congestion control algorithm for real time and bulk data.
An endpoint avoids sending large bursts of data or packets into the network (Section 3.5.2.3).
A sending endpoint increases and decreases its transmission budget in response to acknowledgements (Section 3.6.2.4) and loss according to the congestion control and avoidance algorithms.
Loss is detected by negative acknowledgement (Section 3.6.2.5) and timeout (Section 3.6.2.6).
Timeout is determined by the Effective Retransmission Timeout (ERTO) (Section 3.5.2.2).
The ERTO is measured using the Timestamp and Timestamp Echo packet header fields (Section 2.2.4).
A receiving endpoint acknowledges all received data (Section 3.6.3.4) to enable the sender to measure receipt of data, or lack thereof.
A receiving endpoint may be receiving time critical (or real time) data from a first sender while receiving data from other senders.
The receiving endpoint can signal its other senders (Section 2.2.4) to cause them to decrease the aggressiveness of their congestion control and avoidance algorithms, in order to yield network capacity to the time critical data (Section 3.5.2.1).
A sender can increase its transmission budget at a rate compatible with (but not exceeding) the "slow start algorithm" specified in RFC 5681 (with which the transmission rate is doubled every round trip when beginning or restarting transmission, until loss is detected).
However, a sender MUST behave as though the slow start threshold SSTHRESH is clamped to 0 (disabling the slow start algorithm's exponential increase behavior) on a session where a Time Critical Reverse Notification (
Section 2.2.4) indication has been received from the far end within the last 800 milliseconds, unless the sender is itself currently sending time critical data to the far end.
During each round trip, a sender SHOULD NOT increase the transmission budget by more than 0.5% or by 384 bytes per round trip (whichever is greater) on a session where a Time Critical Reverse Notification indication has been received from the far end within the last 800 milliseconds, unless the sender is itself currently sending time critical data to the far end.
Retransmission Timeout RTMFP uses the ERTO to detect when a user data fragment has been lost in the network.
The ERTO is typically calculated in a manner similar to that specified in "Requirements for Internet Hosts Communication Layers" [RFC1122] and is a function of round trip time measurements and persistent timeout behavior.
The ERTO SHOULD be at least 250 milliseconds and SHOULD allow for the receiver to delay sending an acknowledgement for up to 200 milliseconds (Section 3.6.3.4.4).
The ERTO MUST NOT be less than the round trip time.
To facilitate round trip time measurement, an endpoint MUST implement the Timestamp Echo facility:
On a session entering the S OPEN state, initialize TS RX TIME to negative infinity, and initialize TS RX and TS ECHO TX to have no value.
On receipt of a packet in an S OPEN session with the timestampPresent (Section 2.2.4) flag set, if the timestamp field in the packet is different than TS RX, set TS RX to the value of the timestamp field in the packet, and set TS RX TIME to the current time.
When sending a packet to the far end in an S OPEN session: 1.
If TS RX ELAPSED is more than 128 seconds, then set TS RX and TS ECHO TX to have no value, and do not include a timestamp echo;
Calculate TS RX ELAPSED TICKS to be the number of whole 4 millisecond periods in TS RX ELAPSED; then 3.
(TS RX   TS RX ELAPSED TICKS)
If TS ECHO is not equal to TS ECHO TX, then set TS ECHO TX to TS ECHO, set the timestampEchoPresent flag, and set the timestampEcho field to TS ECHO TX.
The remainder of this section describes an OPTIONAL method for calculating the ERTO.
Real time applications and P2P mesh applications often require knowing the round trip time and RTT variance.
This section additionally describes a method for measuring the round trip time and RTT variance, and calculating a smoothed round trip time.
Let the session information context contain additional variables:
TS TX: the last timestamp sent to the far end, initialized to have no value;  TS ECHO RX: the last timestamp echo received from the far end, initialized to have no value;
SRTT: the smoothed round trip time, initialized to have no value;
RTTVAR: the round trip time variance, initialized to 0.
Initialize MRTO to 250 milliseconds.
Initialize ERTO to 3 seconds.
On sending a packet to the far end of an S OPEN session, if the current send timestamp is not equal to TS TX, then set TS TX to the current send timestamp, set the timestampPresent flag in the packet header, and set the timestamp field to TS TX.
On receipt of a packet from the far end of an S OPEN session, if the timestampEchoPresent flag is set in the packet header, AND the timestampEcho field is not equal to TS ECHO RX, then: 1.
Set TS ECHO RX to timestampEcho;
(current send timestamp timestampEcho) MODULO 65536; 3.
If RTT TICKS is greater than 32767, the measurement is invalid, so discard this measurement; otherwise, 4.
RTT   RTT TICKS   4 milliseconds; 5.
If SRTT has a value, then calculate new values of RTTVAR and SRTT:
RTT DELTA) / 4; 3.
If SRTT has no value, then set SRTT   RTT and RTTVAR   RTT / 2; 7.
Set ERTO to MRTO or 250 milliseconds, whichever is greater.
A retransmission timeout occurs when the most recently transmitted user data fragment has remained outstanding in the network for ERTO.
When this timeout occurs, increase ERTO on an exponential backoff with an ultimate backoff cap of 10 seconds: 1.
; 2.  Calculate ERTO CAPPED to be ERTO BACKOFF or 10 seconds, whichever is less; 3.
Set ERTO to ERTO CAPPED or MRTO, whichever is greater.
An application's sending patterns may cause the transmission budget to grow to a large value, but at times its sending patterns will result in a comparatively small amount of data outstanding in the network.
In this circumstance, especially with a window based congestion avoidance algorithm, if the application then has a large amount of new data to send (for example, a new bulk data transfer), it could send data into the network all at once to fill the window.
This kind of transmission burst is undesirable, however, because it can jam interfaces, links, and buffers.
Accordingly, in any session, an endpoint SHOULD NOT send more than six packets containing user data between receiving any acknowledgements or retransmission timeouts.
The following describes an OPTIONAL method to avoid bursting large numbers of packets into the network
: Let the session information context contain an additional variable DATA PACKET COUNT, initialized to 0.
Transmission of a user data fragment on this session is not allowed if DATA PACKET COUNT is greater than or equal to 6, regardless of any other allowance of the congestion control algorithm.
On transmission of a packet containing at least one User Data chunk (Section 2.3.11), set DATA PACKET COUNT
On receipt of an acknowledgement chunk (Sections 2.3.13 and 2.3.14), set DATA PACKET COUNT to 0.
On a retransmission timeout, set DATA PACKET COUNT to 0.
Address Mobility Sessions are demultiplexed with a 32 bit session ID, rather than by endpoint address.
This allows an endpoint's address to change during an S OPEN session.
This can happen, for example, when switching from a wireless to a wired network, or when moving from one wireless base station to another, or when a NAT restarts.
If the near end receives a valid packet for an S OPEN session from a source address that doesn't match DESTADDR, the far end might have changed addresses.
The near end SHOULD verify that the far end is definitively at the new address before changing DESTADDR.
A suggested verification method is described in Section 3.5.4.2.
If an endpoint receives a Ping chunk (Section 2.3.9) in a session in the S OPEN state, it SHOULD construct and send a Ping Reply chunk (Section 2.3.10) in response if possible, copying the message unaltered.
The Ping Reply SHOULD be sent as quickly as possible following receipt of a Ping.
The semantics of a Ping's message is reserved for the sender; a receiver SHOULD NOT interpret the Ping's message.
Endpoints can use the mechanism of the Ping chunk and the expected Ping Reply for any purpose.
This specification doesn't mandate any specific constraints on the format or semantics of a Ping message.
A Ping Reply MUST be sent only as a response to a Ping.
Receipt of a Ping Reply implies live bidirectional connectivity.
This specification doesn't mandate any other semantics for a Ping Reply.
An endpoint can use a Ping to test for live bidirectional connectivity, to test that the far end of a session is still in the S OPEN state, to keep NAT translations alive, and to keep firewall holes open.
An endpoint can use a Ping to hasten detection of a near end address change by the far end.
An endpoint may declare a session to be defunct and dead after a persistent failure by the far end to return Ping Replies in response to Pings.
If used for these purposes, a Keepalive Ping SHOULD have an empty message.
A Keepalive Ping SHOULD NOT be sent more often than once per ERTO.
If a corresponding Ping Reply is not received within ERTO of sending the Ping, ERTO SHOULD be increased according to Section 3.5.2 ("Congestion Control").
This section describes an OPTIONAL but suggested method for processing and verifying a far end address change.
Let the session context contain additional variables MOB TX TS, MOB RX TS, and MOB SECRET.
MOB TX TS and MOB RX TS have initial values of negative infinity.
MOB SECRET should be a cryptographically pseudorandom value not less than 128 bits in length and known only to this end.
On receipt of a packet for an S OPEN session, after processing all chunks in the packet: if the session is still in the S OPEN state, AND the source address of the packet does not match DESTADDR, AND MOB TX TS is at least one second in the past, then: 1.
Set MOB TX TS to the current time; 2.
Construct a Ping message comprising the following: a marking to indicate (to this end when returned in a Ping Reply) that it is a mobility check (for example, the first byte being ASCII 'M' for "Mobility"), a timestamp set to MOB TX TS, and a cryptographic hash over the following: the preceding items, the address from which the packet was received, and MOB SECRET; and 3.
Send this Ping to the address from which the packet was received, instead of DESTADDR.
On receipt of a Ping Reply in an S OPEN session, if the Ping Reply's message satisfies all of these conditions:
it has this end's expected marking to indicate that it is a mobility check, and  the timestamp in the message is not more than 120 seconds in the past, and  the timestamp in the message is greater than MOB RX TS, and  the cryptographic hash matches the expected value according to the contents of the message plus the source address of the packet containing this Ping Reply and MOB SECRET, then: 1.
Set MOB RX TS to the timestamp in the message; and 2.
Set DESTADDR to the source address of the packet containing this Ping Reply.
Path MTU Discovery "Packetization Layer Path MTU Discovery" [RFC4821] describes a method for measuring the path MTU between communicating endpoints.
An RTMFP SHOULD perform path MTU discovery.
The method described in RFC 4821 can be adapted for use in RTMFP by sending a probe packet comprising one of the Padding chunk types (type 0x00 or 0xff) and a Ping.
The Ping chunk SHOULD come after the Padding chunk, to guard against a false positive response in case the probe packet is truncated.
Close An endpoint may close a session at any time.
Typically, an endpoint will close a session when there have been no open flows in either direction for a time.
In another circumstance, an endpoint may be ceasing operation and will close all of its sessions even if they have open flows.
To close an S OPEN session in a reliable and orderly fashion, an endpoint moves the session to the S NEARCLOSE state.
On a session transitioning from S OPEN to S NEARCLOSE and every 5 seconds thereafter while still in the S NEARCLOSE state, send a Session Close Request chunk (Section 2.3.17).
A session that has been in the S NEARCLOSE state for at least 90 seconds (allowing time to retransmit the Session Close Request multiple times) SHOULD move to the S CLOSED state.
On a session transitioning from S OPEN to the S NEARCLOSE, S FARCLOSE LINGER or S CLOSED state, immediately abort and terminate all open or closing flows.
Flows only exist in S OPEN sessions.
To close an S OPEN session abruptly, send a Session Close Acknowledgement chunk (Section 2.3.18), then move to the S CLOSED state.
On receipt of a Session Close Request chunk for a session in the S OPEN, S NEARCLOSE, or S FARCLOSE LINGER states, send a Session Close Acknowledgement chunk; then, if the session is in the S OPEN state, move to the S FARCLOSE LINGER state.
A session that has been in the S FARCLOSE LINGER state for at least 19 seconds (allowing time to answer 3 retransmissions of a Session Close Request) SHOULD move to the S CLOSED state.
On receipt of a Session Close Acknowledgement chunk for a session in the S OPEN, S NEARCLOSE, or S FARCLOSE LINGER states, move to the S CLOSED state.
A flow is a unidirectional communication channel in a session for transporting a correlated series of user messages from a sender to a receiver.
Each end of a session may have zero or more sending flows to the other end.
Each sending flow at one end has a corresponding receiving flow at the other end.
Identity Flows are multiplexed in a session by a flow identifier.
Each end of a session chooses its sending flow identifiers independently of the other end.
The choice of similar flow identifiers by both ends does not imply an association.
A sender MAY choose any identifier for any flow; therefore, a flow receiver MUST NOT ascribe any semantic meaning, role, or name to a flow based only on its identifier.
There are no "well known" or reserved flow identifiers.
Bidirectional flow association is indicated at flow startup with the Return Flow Association option (Section 2.3.11.1.2).
An endpoint can indicate that a new sending flow is in return (or response) to a receiving flow from the other end.
A sending flow MUST NOT indicate more than one return association.
A receiving flow can be specified as the return association for any number of sending flows.
The return flow association, if any, is fixed for the lifetime of the sending flow.
Closure of one flow in an association does not automatically close other flows in the association, except as specified in Section 3.6.3.1.
Flows are named with arbitrary user metadata.
This specification doesn't mandate any particular encoding, syntax, or semantics for the user metadata, except for the encoded size (Section 2.3.11.1.1); the user metadata is entirely reserved for the application.
The user metadata is fixed for the lifetime of the flow.
Messages and Sequencing Flows provide message oriented framing.
Large messages are fragmented for transport in the network.
Receivers reassemble fragmented messages and only present complete messages to the user.
A sender queues messages on a sending flow one after another.
A receiver can recover the original queuing order of the messages, even when they are reordered in transit by the network or as a result of loss and retransmission, by means of the messages' fragment sequence numbers.
Flows are the basic units of message sequencing; each flow is sequenced independently of all other flows; inter flow message arrival and delivery sequencing are not guaranteed.
Independent flow sequencing allows a sender to prioritize the transmission or retransmission of the messages of one flow over those of other flows in a session, allocating capacity from the transmission budget according to priority.
RTMFP is designed for flows to be the basic unit of prioritization.
In any flow, fragment sequence numbers are unique and monotonically increasing; that is, the fragment sequence numbers for any message MUST be greater than the fragment sequence numbers of all messages previously queued in that flow.
Receipt of fragments out of sequence number order within a flow creates discontiguous gaps at the receiver, causing it to send an acknowledgement for every packet and also causing the size of the encoded acknowledgements to grow.
Therefore, for any flow, the sender SHOULD send lower sequence numbers first.
A sender can abandon a queued message at any time, even if some fragments of that message have been received by the other end.
A receiver MUST be able to detect a gap in the flow when a message is abandoned; therefore, each message SHOULD take at least one sequence number from the sequence space even if no fragments for that message are ever sent.
The sender will transmit the fragments of all messages not abandoned, and retransmit any lost fragments of all messages not abandoned, until all the fragments of all messages not abandoned are acknowledged by the receiver.
A sender indicates a Forward Sequence Number (FSN) to instruct the receiver that sequence numbers less than or equal to the FSN will not be transmitted or retransmitted.
This allows the receiver to move forward over gaps and continue sequenced delivery of completely received messages to the user.
Any incomplete messages missing fragments with sequence numbers less than or equal to the FSN were abandoned by the sender and will never be completed.
A gap indication MUST be communicated to the receiving user.
Lifetime A sender begins a flow by sending user message fragments to the other end, and including the user metadata and, if any, the return flow association.
The sender continues to include the user metadata and return flow association until the flow is acknowledged by the far end, at which point the sender knows that the receiver has received the user metadata and, if any, the return flow association.
After that point, the flow identifier alone is sufficient.
Flow receivers SHOULD acknowledge all sequence numbers received for any flow, whether the flow is accepted or rejected.
Flow receivers MUST NOT acknowledge sequence numbers higher than the FSN that were not received.
Acknowledgements drive the congestion control and avoidance algorithms and therefore must be accurate.
An endpoint can reject a receiving flow at any time in the flow's lifetime.
To reject the flow, the receiving endpoint sends a Flow Exception Report chunk (Section 2.3.16) immediately preceding every acknowledgement chunk for the rejected receiving flow.
An endpoint may eventually conclude and close a sending flow.
The last sequence number of the flow is marked with the Final flag.
The sending flow is complete when all sequence numbers of the flow, including the final sequence number, have been cumulatively acknowledged by the receiver.
The receiving flow is complete when every sequence number from the FSN to the final sequence number has been received.
The sending flow and corresponding receiving flow at the respective ends hold the flow identifier of a completed flow in reserve for a time to allow delayed or duplicated fragments and acknowledgements to drain from the network without erroneously initiating a new receiving flow or erroneously acknowledging a new sending flow.
If a flow sender receives a Flow Exception indication from the other end, the flow sender SHOULD close the flow and abandon all of the undelivered queued messages.
The flow sender SHOULD indicate an exception to the user.
Each sending flow comprises the flow specific information context necessary to transfer that flow's messages to the other end.
Each sending flow context includes at least:
F FLOW ID: this flow's identifier;  STARTUP OPTIONS: the set of options to send to the receiver until this flow is acknowledged, including the User's Per Flow Metadata and, if set, the Return Flow Association;  SEND QUEUE:
the unacknowledged message fragments queued in this flow, initially empty; each message fragment entry comprising the following:
a boolean flag indicating whether this fragment has been abandoned;
F OUTSTANDING BYTES: the sum of the TRANSMIT SIZE of each entry in SEND QUEUE where entry.
RX BUFFER SIZE: the most recent available buffer advertisement from the other end
(Sections 2.3.13 and 2.3.14), initially 65536 bytes;  NEXT SN: the next sequence number to assign to a message fragment, initially 1;  F FINAL SN: the sequence number assigned to the final message fragment of the flow, initially having no value;  EXCEPTION:
a boolean flag indicating whether an exception has been reported by the receiver, initially false;  The state, at any time being one of the following values: the open state F OPEN; the closing states F CLOSING and F COMPLETE LINGER; and the closed state F CLOSED.
Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.
Flow Exception   v    F CLOSING
The application opens a new sending flow to the other end in an S OPEN session.
The implementation chooses a new flow ID that is not assigned to any other sending flow in that session in the F OPEN, F CLOSING, or F COMPLETE LINGER states.
The flow starts in the F OPEN state.
The STARTUP OPTIONS for the new flow is set with the User's Per Flow Metadata (Section 2.3.11.1.1).
If this flow is in return (or response) to a receiving flow from the other end, that flow's ID is encoded in a Return Flow Association (Section 2.3.11.1.2) option and added to STARTUP OPTIONS.
A new sending flow SHOULD NOT be opened in response to a receiving flow from the other end that is not in the RF OPEN state when the sending flow is opened.
At this point, the flow exists in the sender but not in the receiver.
The flow begins when user data fragments are transmitted to the receiver.
A sender can begin a flow in the absence of immediate user data by sending a Forward Sequence Number Update (Section 3.6.2.7.1), by queuing and transmitting a user data fragment that is already abandoned.
The application queues messages in an F OPEN sending flow for transmission to the far end.
The implementation divides each message into one or more fragments for transmission in User Data chunks (Section 2.3.11).
Each fragment MUST be small enough so that, if assembled into a packet (Section 2.2.4) with a maximum size common header, User Data chunk header, and, if not empty,
this flow's STARTUP OPTIONS, the packet will not exceed the path MTU (Section 3.5.4.3).
For each fragment, create a fragment entry and set fragmentEntry.
NEXT SN, and increment flow.
FRA according to the encoding in User Data chunks: 0
: This fragment is a complete message.
1: This fragment is the first of a multi fragment message.
2: This fragment is the last of a multi fragment message.
This fragment is in the middle of a multi fragment message.
Data A sending flow is ready to transmit if the SEND QUEUE contains at least one entry that is eligible to send, and if either RX BUFFER SIZE is greater than F OUTSTANDING BYTES or EXCEPTION is set to true.
A SEND QUEUE entry is eligible to send if it is not IN FLIGHT, AND at least one of the following conditions holds:
The entry is not ABANDONED; or  The entry is the first one in the SEND QUEUE; or  The entry's SEQUENCE NUMBER is equal to flow.
If the session's transmission budget allows, a flow that is ready to transmit is selected for transmission according to the implementation's prioritization scheme.
The manner of flow prioritization is not mandated by this specification.
Trim abandoned messages from the front of the queue, and find the Forward Sequence Number (FSN): 1.
While the SEND QUEUE contains at least two entries, AND the first entry is not IN FLIGHT, AND the first entry is ABANDONED, remove and discard the first entry from the SEND QUEUE; 2.
If the first entry in the SEND QUEUE is not abandoned, set FSN to entry.
If the first entry in the SEND QUEUE is IN FLIGHT, AND entry.
ABANDONED is false, set FSN to entry.
The first entry in the SEND QUEUE is abandoned and either is not IN FLIGHT or was already abandoned when sent; set FSN to entry.
The FSN MUST NOT be greater than any sequence number currently outstanding.
The FSN MUST NOT be equal to any sequence number currently outstanding that was not abandoned when sent.
Assemble user data chunks for this flow into a packet to send to the receiver.
While enough space remains in the packet and the flow is ready to transmit: 1.
Starting at the head of the SEND QUEUE, find the first eligible fragment entry; 2.
Encode the entry into a User Data chunk (Section 2.3.11)
or, if possible (Section 3.6.2.3.2), a Next User Data chunk (Section 2.3.12); 3.
If present, set chunk.flowID to flow.
If present, set chunk.sequenceNumber to entry.
If present, set chunk.fsnOffset to entry.
F FINAL SN, set chunk.final to true; else set chunk.final to false;
If any options are being sent with this chunk, set chunk.optionsPresent to true, assemble the options into the chunk, and assemble a Marker to terminate the option list; 10.
ABANDONED is true, set chunk.userData to empty; otherwise, set chunk.userData to entry.
If adding the assembled chunk to the packet would cause the packet to exceed the path MTU, do not assemble this chunk into the packet; enough space no longer remains in the packet; stop.
IN FLIGHT to true; 13.
EVER SENT to true; 14.
NAK COUNT to 0; 15.
TRANSMIT SIZE to the size of the assembled chunk, including the chunk header; 17.
Assemble this chunk into the packet; and 18.
If this flow or entry is considered Time Critical (real time), set the timeCritical flag in the packet header (Section 2.2.4).
Complete any other appropriate packet processing, and transmit the packet to the far end.
If STARTUP OPTIONS is not empty, then when assembling the FIRST User Data chunk for this flow into a packet, add the encoded STARTUP OPTIONS to that chunk's option list.
The Next User Data chunk (Section 2.3.12) is a compact encoding for a user message fragment when multiple contiguous fragments are assembled into one packet.
Using this chunk where possible can conserve space in a packet, potentially reducing transmission overhead or allowing additional information to be sent in a packet.
If, after assembling a user message fragment of a flow into a packet (Section 3.6.2.3), the next eligible fragment to be selected for assembly into that packet belongs to the same flow, AND its sequence number is one greater than that of the fragment
just assembled, it is RECOMMENDED that an implementation encode a Next User Data chunk instead of a User Data chunk.
The FIRST fragment of a flow assembled into a packet MUST be encoded as a User Data chunk.
Negative Acknowledgement and Loss A negative acknowledgement is inferred for an outstanding fragment if an acknowledgement is received for any other fragments sent after it in the same session.
An implementation SHOULD consider a fragment to be lost once that fragment receives three negative acknowledgements.
A lost fragment is no longer outstanding in the network.
The following describes an OPTIONAL method for detecting negative acknowledgements.
Let the session track the order in which fragments are transmitted across all its sending flows by way of a monotonically increasing Transmission Sequence Number (TSN) recorded with each fragment queue entry each time that fragment is transmitted.
Let the session information context contain additional variables:
NEXT TSN: the next TSN to record with a fragment's queue entry when it is transmitted, initially 1;
MAX TSN ACK: the highest acknowledged TSN, initially 0.
Let each fragment queue entry contain an additional variable TSN, initially 0, to track its transmission order.
On transmission of a message fragment into the network, set its entry.
NEXT TSN, and increment session.
On acknowledgement of an outstanding fragment, if its entry.
TSN is greater than session.
MAX TSN ACK, set session.
MAX TSN ACK to entry.
After processing all acknowledgements in a packet containing at least one acknowledgement, then for each sending flow in that session, for each entry in that flow's SEND QUEUE, if entry.
IN FLIGHT is true and entry.
TSN is less than session.
MAX TSN ACK, increment entry.
NAK COUNT and notify the congestion control and avoidance algorithms that a negative acknowledgement was detected in this packet.
For each sending flow in that session, for each entry in that flow's SEND QUEUE, if entry.
IN FLIGHT is true and entry.
NAK COUNT is at least 3, that fragment was lost in the network and is no longer considered to be in flight.
Notify the congestion control and avoidance algorithms of the loss.
A fragment is considered lost and no longer in flight in the network if it has remained outstanding for at least ERTO.
The following describes an OPTIONAL method to manage transmission timeouts.
This method REQUIRES that either burst avoidance (Section 3.5.2.3) is implemented or the implementation's congestion control and avoidance algorithms will eventually stop sending new fragments into the network if acknowledgements are persistently not received.
Let the session information context contain an alarm TIMEOUT ALARM, initially unset.
On sending a packet containing at least one User Data chunk, set or reset TIMEOUT ALARM to fire in ERTO.
On receiving a packet containing at least one acknowledgement, reset TIMEOUT ALARM (if already set) to fire in ERTO.
When TIMEOUT ALARM fires: 1.
Set WAS LOSS   false; 2.
For each sending flow in the session, and for each entry in that flow's SEND QUEUE: 1.
IN FLIGHT is true, set
WAS LOSS   true; and 2.
If WAS LOSS is true, perform ERTO backoff (Section 3.5.2.2); and 4.
Notify the congestion control and avoidance algorithms of the timeout
and, if WAS LOSS is true, that there was loss.
The application can abandon queued messages at any time and for any reason.
Example reasons include (but are not limited to)
the following: one or more fragments of a message have remained in the SEND QUEUE for longer than a specified message lifetime; a fragment has been retransmitted more than a specified retransmission limit; a prior message on which this message depends (such as a key frame in a prediction chain) was abandoned and not delivered.
To abandon a message fragment, set its SEND QUEUE entry's ABANDON flag to true.
When abandoning a message fragment, abandon all fragments of the message to which it belongs.
An abandoned fragment MUST NOT be un abandoned.
Forward Sequence Number Update Abandoned data may leave gaps in the sequence number space of a flow.
Gaps may cause the receiver to hold completely received messages for ordered delivery to allow for retransmission of the missing fragments.
User Data chunks (Section 2.3.11) encode a Forward Sequence Number (FSN) to instruct the receiver that fragments with sequence numbers less than or equal to the FSN will not be transmitted or retransmitted.
When the receiver has gaps in the received sequence number space and no non abandoned message fragments remain in the SEND QUEUE, the sender SHOULD transmit a Forward Sequence Number Update (FSN Update) comprising a User Data chunk marked abandoned, whose sequence number is the FSN and whose fsnOffset is 0.
An FSN Update allows the receiver to skip gaps that will not be repaired and deliver received messages to the user.
An FSN Update may be thought of as a transmission or retransmission of abandoned sequence numbers without actually sending the data.
The method described in Section 3.6.2.3 ("Sending Data") generates FSN Updates when appropriate.
Ack  ID 3, seq:0 30, 32
Ack  ID 3, seq:0 30, 32, 34 35 (
seq# 47, fsnOff 15 (fsn 32, abandon 31)
Ack  ID 3, seq:0 59, 61
33 is retransmitted; 31 and 60 are abandoned.
Note that line 25 is a Forward Sequence Number Update (Section 3.6.2.7.1).
The flow receiver advertises the amount of new data
it's willing to accept from the flow sender with the bufferBytesAvailable derived field of an acknowledgement
The flow sender MUST NOT send new data into the network if flow.
F OUTSTANDING BYTES is greater than or equal to the most recently received buffer advertisement, unless flow.
EXCEPTION is true (Section 3.6.2.3).
The flow sender is suspended if the most recently received buffer advertisement is zero and the flow hasn't been rejected by the receiver
that is, while RX BUFFER SIZE is zero AND EXCEPTION is false.
To guard against potentially lost acknowledgements that might reopen the receive window, a suspended flow sender SHOULD send a packet comprising a Buffer Probe chunk (Section 2.3.15) for this flow from time to time.
If the receive window advertisement transitions from non zero to zero, the flow sender MAY send a Buffer Probe immediately and SHOULD send a probe within one second.
The initial period between Buffer Probes SHOULD be at least one second or ERTO, whichever is greater.
The period between probes SHOULD increase over time, but the period between probes SHOULD NOT be more than one minute or ERTO, whichever is greater.
The flow sender SHOULD stop sending Buffer Probes if it is no longer suspended.
The flow receiver can reject the flow at any time and for any reason.
The flow receiver sends a Flow Exception Report (Section 2.3.16) when it has rejected a flow.
On receiving a Flow Exception Report for a sending flow: 1.
If the flow is F OPEN, close the flow (Section 3.6.2.11) and notify the user that the far end reported an exception with the encoded exception code; 2.
Set the EXCEPTION flag to true; and 3.
For each entry in SEND QUEUE, set entry.
Close A sending flow is closed by the user or as a result of an exception.
To close an F OPEN flow: 1.
Move to the F CLOSING state; 2.
If the SEND QUEUE is not empty, AND the tail entry of the SEND QUEUE has a sequence number of NEXT SN 1, AND the tail entry.
EVER SENT is false, set F FINAL SN to entry.
The SEND QUEUE is empty, OR the tail entry does not have a sequence number of NEXT SN 1, OR the tail entry.
EVER SENT is true: enqueue a new SEND QUEUE entry with entry.
F FINAL SN to entry.
An F CLOSING sending flow is complete when its SEND QUEUE transitions to empty, indicating that all sequence numbers, including the FINAL SN, have been acknowledged by the other end.
When an F CLOSING sending flow becomes complete, move to the F COMPLETE LINGER state.
A sending flow MUST remain in the F COMPLETE LINGER state for at least 130 seconds.
After at least 130 seconds, move to the F CLOSED state.
The sending flow is now closed, its resources can be reclaimed, and its F FLOW ID MAY be used for a new sending flow.
Each receiving flow comprises the flow specific information context necessary to receive that flow's messages from the sending end and deliver completed messages to the user.
Each receiving flow context includes at least:  RF FLOW ID: this flow's identifier;  SEQUENCE
SET: the set of all fragment sequence numbers seen in this receiving flow, whether received or abandoned, initially empty;  RF FINAL SN: the final fragment sequence number of the flow, initially having no value;  RECV BUFFER:
the message fragments waiting to be delivered to the user, sorted by sequence number in ascending order, initially empty; each message fragment entry comprising the following:
this fragment's user data; and    FRA: the fragment control value for this message fragment,
having one of the values enumerated for that purpose in Section 2.3.11 ("User Data Chunk").
BUFFERED SIZE: the sum of the lengths of each fragment in RECV BUFFER plus any additional storage overhead for the fragments incurred by the implementation, in bytes;  BUFFER CAPACITY:
the desired maximum size for the receive buffer, in bytes;  PREV RWND:
the most recent receive window advertisement sent in an acknowledgement, in 1024 byte blocks, initially having no value;  SHOULD
ACK: whether or not an acknowledgement should be sent for this flow, initially false;  EXCEPTION CODE:
the exception code to report to the sender when the flow has been rejected, initially 0;
The state, at any time being one of the following values: the open state RF OPEN; the closing states RF REJECTED and RF COMPLETE LINGER; and the closed state RF CLOSED.
Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.
120 seconds v    RF CLOSED    Figure 22: Receiving Flow State Diagram 3.6.3.1.
Startup A new receiving flow starts on receipt of a User Data chunk (Section 2.3.11) encoding a flow ID not belonging to any other receiving flow in the same session in the RF OPEN, RF REJECTED, or RF COMPLETE LINGER states.
On receipt of such a User Data chunk: 1.
temporary variables METADATA, ASSOCIATED FLOWID, and ASSOCIATION to each have no value;
Create a new receiving flow context in this session, setting its RF FLOW ID to the flow ID encoded in the opening User Data chunk, and set to the RF OPEN state; 3.
If the opening User Data chunk encodes a User's Per Flow
Metadata option (Section 2.3.11.1.1), set METADATA to option.userMetadata; 4.
If the opening User Data chunk encodes a Return Flow Association option (Section 2.3.11.1.2), set ASSOCIATED FLOWID to option.flowID; 5.
If METADATA has no value, the receiver MUST reject the flow (Section 3.6.3.7), moving it to the RF REJECTED state;
If ASSOCIATED FLOWID has a value, then if there is no sending flow in the same session with a flow ID of ASSOCIATED FLOWID, the receiver MUST reject the flow, moving it to the RF REJECTED state; otherwise, set ASSOCIATION to the indicated sending flow; 7.
If ASSOCIATION indicates a sending flow, AND that sending flow's state is not F OPEN, the receiver MUST reject this receiving flow, moving it to the RF REJECTED state; 8.
If the opening User Data chunk encodes any unrecognized option with a type code less than 8192 (Section 2.3.11.1), the receiver MUST reject the flow, moving it to the RF REJECTED state;
If this new receiving flow is still RF OPEN, then notify the user that a new receiving flow has opened, including the METADATA
and, if present, the ASSOCIATION, and set flow.
according to the user; 10.
Perform the normal data processing (Section 3.6.3.2) for the opening User Data chunk; and 11.
Set this session's ACK NOW to true.
Receiving Data A User Data chunk (Section 2.3.11) or a Next User Data chunk (Section 2.3.12) encodes one fragment of a user data message of a flow, as well as the flow's Forward Sequence Number and potentially optional parameters (Section 2.3.11.1).
On receipt of a User Data or Next User Data chunk: 1.
If chunk.flowID doesn't indicate an existing receiving flow in the same session in the RF OPEN, RF REJECTED, or RF COMPLETE LINGER state, perform the steps of Section 3.6.3.1 ("Startup") to start a new receiving flow; 2.
Retrieve the receiving flow context for the flow indicated by chunk.flowID; 3.
SHOULD ACK to true; 4.
If the flow is RF OPEN, AND the chunk encodes any unrecognized option with a type code less than 8192 (Section 2.3.11.1), the flow MUST be rejected: notify the user of an exception, and reject the flow (Section 3.6.3.7), moving it to the RF REJECTED state; 5.
If the flow is not in the RF OPEN state, set session.
ACK NOW to true; 6.
PREV RWND has a value and that value is less than 2 blocks, set session.
ACK NOW to true; 7.
If chunk.abandon is true, set session.
ACK NOW to true; 8.
SEQUENCE SET has any gaps (that is, if it doesn't contain every sequence number from 0 through and including the highest sequence number in the set), set session.
ACK NOW to true; 9.
SET contains chunk.sequenceNumber, then this chunk is a duplicate: set session.
ACK NOW to true; 10.
SEQUENCE SET doesn't contain chunk.sequenceNumber, AND chunk.final is true, AND flow.
RF FINAL SN has no value, then set flow.
RF FINAL SN to chunk.sequenceNumber, and set session.
ACK NOW to true; 11.
If the flow is in the RF OPEN state, AND flow.
SEQUENCE SET doesn't contain chunk.sequenceNumber, AND chunk.abandon is false, then create a new RECV BUFFER entry for this chunk's data and set entry.
SEQUENCE NUMBER to chunk.sequenceNumber, entry.
DATA to chunk.userData, and entry.
FRA to chunk.fragmentControl, and insert this new entry into flow.
SEQUENCE SET the range of sequence numbers from 0 through and including the chunk.forwardSequenceNumber derived field; 13.
SEQUENCE SET now has any gaps, set session.
ACK NOW to true; 15.
ACK NOW is false and session.
DELACK ALARM is not set, set session.
DELACK ALARM to fire in 200 milliseconds; and 16.
Attempt delivery of completed messages in this flow's RECV BUFFER to the user (Section 3.6.3.3).
After processing all chunks in a packet containing at least one User Data chunk, increment session.
RX DATA PACKETS by one.
RX DATA PACKETS is at least two, set session.
A receiving flow that is not in the RF CLOSED state is ready to send an acknowledgement if its SHOULD ACK flag is set.
Acknowledgements for receiving flows that are ready are sent either opportunistically by piggybacking on a packet that's already sending user data or an acknowledgement (Section 3.6.3.4.6), or when the session's ACK NOW flag is set (Section 3.6.3.4.5).
Data A receiving flow's information context contains a RECV BUFFER for reordering, reassembling, and holding the user data messages of the flow.
Only complete messages are delivered to the user; an implementation MUST NOT deliver partially received messages, except by special arrangement with the user.
Let the Cumulative Acknowledgement Sequence Number (CSN) be the highest number in the contiguous range of numbers in SEQUENCE SET starting with 0.
For example, if SEQUENCE SET contains {0, 1, 2, 3, 5, 6}, the contiguous range starting with 0 is 0
..3, so the CSN is 3.
A message is complete if all of its fragments are present in the RECV BUFFER.
The fragments of one message have contiguous sequence numbers.
A message can be either a single fragment, whose fragment control value is 0 whole, or two or more fragments where the first's fragment control value is 1 begin, followed by zero or more fragments with control value 3 middle, and terminated by a last fragment with control value 2 end.
An incomplete message segment is a contiguous sequence of one or more fragments that do not form a complete message   that is, a 1 begin followed by zero or more 3 middle fragments but with no 2 end, or zero or more 3 middle fragments followed by a 2 end but with no 1 begin, or one or more 3 middle fragments with neither a 1 begin nor a 2 end.
Incomplete message segments can either be in progress or abandoned.
An incomplete segment is abandoned in the following cases:
The sequence number of the segment's first fragment is less than or equal to the CSN, AND that fragment's control value is not 1 begin; or  The sequence number of the segment's last fragment is less than the CSN.
Abandoned message segments will never be completed, so they SHOULD be removed from the RECV BUFFER to make room in the advertised receive window and the receiver's memory for messages that can be completed.
The user can suspend delivery of a flow's messages.
A suspended receiving flow holds completed messages in its RECV BUFFER until the user resumes delivery.
A suspended flow can cause the receive window advertisement to go to zero even when the BUFFER CAPACITY is non zero; this is described in detail in Section 3.6.3.5 ("Flow Control").
When the receiving flow is not suspended, the original queuing order of the messages is recovered by delivering, in ascending sequence number order, complete messages in the RECV BUFFER whose sequence numbers are less than or equal to the CSN.
The following describes a method for discarding abandoned message segments and delivering complete messages in original queuing order when the receiving flow is not suspended.
While the first fragment entry in the RECV BUFFER has a sequence number less than or equal to the CSN and delivery is still possible: 1.
FRA is 0 whole, deliver entry.
DATA to the user, and remove this entry from RECV BUFFER; otherwise, 2.
FRA is 2 end or 3 middle, this entry belongs to an abandoned segment, so remove and discard this entry from RECV BUFFER;
Let LAST ENTRY be the last RECV BUFFER entry that is part of this message segment
(LAST ENTRY can be entry if the segment has only one fragment so far).
If LAST ENTRY.FRA is 2 end, this segment is a complete message, so concatenate the DATA fields of each fragment entry of this segment in ascending sequence number order and deliver the complete message to the user, then remove the entries for this complete message from RECV BUFFER; otherwise, 2.
If LAST ENTRY.SEQUENCE NUMBER is less than CSN, this segment is incomplete and abandoned, so remove and discard the entries for this segment from RECV BUFFER; otherwise, 3.
LAST ENTRY.SEQUENCE NUMBER is equal to CSN and LAST ENTRY.FRA is not 2 end: this segment is incomplete but still in progress.
Ordered delivery is no longer possible until at least one more fragment is received.
RF FINAL SN has a value and is equal to the CSN, AND RECV BUFFER is empty, all complete messages have been delivered to the user, so notify the user that the flow is complete.
Acknowledging Data A flow receiver SHOULD acknowledge all user data fragment sequence numbers seen in that flow.
Acknowledgements drive the sender's congestion control and avoidance algorithms, clear data from the sender's buffers, and in some sender implementations clock new data into the network; therefore, the acknowledgements must be accurate and timely.
For reasons similar to those discussed in Section 4.2.3.2 of RFC 1122 [RFC1122], it is advantageous to delay sending acknowledgements for a short time, so that multiple data fragments can be acknowledged in a single transmission.
However, it is also advantageous for a sender to receive timely notification about the receiver's disposition of the flow, particularly in unusual or exceptional circumstances, so that the circumstances can be addressed if possible.
Therefore, a flow receiver SHOULD send an acknowledgement for a flow as soon as is practical in any of the following circumstances:  On receipt of a User Data chunk that starts a new flow;  On receipt of a User Data or Next User Data chunk if the flow is not in the RF OPEN state;  On receipt of a User Data chunk where, before processing the chunk, the SEQUENCE SET of the indicated flow does not contain every sequence number between 0 and the highest sequence number in the set (that is, if there was a sequence number gap before processing the chunk);  On receipt of a User Data chunk where, after processing the chunk, the flow's SEQUENCE SET does not contain every sequence number between 0 and the highest sequence number in the set (that is, if this chunk causes a sequence number gap);  On receipt of a Buffer Probe for the flow;  On receipt of a User Data chunk if the last acknowledgement sent for the flow indicated fewer than two bufferBlocksAvailable;
On receipt of a User Data or Next User Data chunk for the flow if, after processing the chunk, the flow's BUFFER CAPACITY is not at least 1024 bytes greater than BUFFERED SIZE;
On receipt of a User Data or Next User Data chunk for any sequence number that was already seen (that is, on receipt of a duplicate);  On the first receipt of the final sequence number of the flow;  On receipt of two packets in the session that contain user data for any flows since an acknowledgement was last sent, the new acknowledgements being for the flows having any User Data chunks in the received packets (that is, for every second packet containing user data);  After receipt of a User Data chunk for the flow, if an acknowledgement for any other flow is being sent (that is, consolidate acknowledgements);  After receipt of a User Data chunk for the flow, if any user data for a sending flow is being sent in a packet and if there is space available in the same packet (that is, attempt to piggyback an acknowledgement with user data if possible);  No longer than 200 milliseconds after receipt of a User Data chunk for the flow.
Size and Truncation Including an encoded acknowledgement in a packet might cause the packet to exceed the path MTU.
In that case:  If the packet is being sent primarily to send an acknowledgement, AND this is the first acknowledgement in the packet, truncate the acknowledgement so that the packet does not exceed the path MTU; otherwise,  The acknowledgement is being piggybacked in a packet with user data or with an acknowledgement for another flow: do not include this acknowledgement in the packet, and send it later.
Constructing The Data Acknowledgement Bitmap chunk (Section 2.3.13) and Data Acknowledgement Ranges chunk (Section 2.3.14) encode a receiving flow's SEQUENCE SET and its receive window advertisement.
The two chunks are semantically equivalent; implementations SHOULD send whichever provides the most compact encoding of the SEQUENCE SET.
When assembling an acknowledgement for a receiving flow: 1.
If the flow's state is RF REJECTED, first assemble a Flow Exception Report chunk (Section 2.3.16) for flow.flowID;
Choose the acknowledgement chunk type that most compactly encodes flow.
Use the method described in Section 3.6.3.5 ("Flow Control") to determine the value for the acknowledgement chunk's bufferBlocksAvailable field.
Example Figure 23 shows an example flow with sequence numbers 31 and 33 lost in transit; 31 is abandoned, and 33 is retransmitted.
fsnOff 12 (fsn 22) 7
Flow Example with Loss 3.6.3.5.
The flow receiver maintains a buffer for reassembling and reordering messages for delivery to the user (Section 3.6.3.3).
The implementation and the user may wish to limit the amount of resources (including buffer memory) that a flow is allowed to use.
RTMFP provides a means for each receiving flow to govern the amount of data sent by the sender, by way of the bufferBytesAvailable derived field of acknowledgement chunks (Sections 2.3.13 and 2.3.14).
This derived field indicates the amount of data that the sender is allowed to have outstanding in the network, until instructed otherwise.
This amount is also called the receive window.
The flow receiver can suspend the sender by advertising a closed (zero length) receive window.
The user can suspend delivery of messages from the receiving flow (Section 3.6.3.3).
This can cause the receive buffer to fill.
In order for progress to be made on completing a fragmented message or repairing a gap for sequenced delivery in a flow, the flow receiver MUST advertise at least one buffer block in an acknowledgement if it is not suspended, even if the amount of data in the buffer exceeds the buffer capacity, unless the buffer capacity is 0.
Otherwise, deadlock can occur, as the receive buffer will stay full and won't drain because of a gap or incomplete message, and the gap or incomplete message can't be repaired or completed because the sender is suspended.
The receive window is advertised in units of 1024 byte blocks.
For example, advertisements for 1 byte, 1023 bytes, and 1024 bytes each require one block.
An advertisement for 1025 bytes requires two blocks.
The following describes the RECOMMENDED method of calculating the bufferBlocksAvailable field of an acknowledgement chunk for a receiving flow: 1.
If BUFFERED SIZE is greater than or equal to BUFFER CAPACITY, set ADVERTISE BYTES to 0; 2.
If BUFFERED SIZE is less than BUFFER CAPACITY, set ADVERTISE BYTES to BUFFER CAPACITY BUFFERED SIZE; 3.
Set ADVERTISE BLOCKS to CEIL(ADVERTISE BYTES / 1024); 4.
If ADVERTISE BLOCKS is 0, AND BUFFER CAPACITY is greater than 0, AND delivery to the user is not suspended, set ADVERTISE BLOCKS to 1; and 5.
Set the acknowledgement's bufferBlocksAvailable field to ADVERTISE BLOCKS.
Receiving a Buffer Probe A Buffer Probe chunk (Section 2.3.15) is sent by the flow sender (Section 3.6.2.9.1) to request the current receive window advertisement (in the form of an acknowledgement) from the flow receiver.
On receipt of a Buffer Probe chunk: 1.
If chunk.flowID doesn't belong to a receiving flow in the same session in the RF OPEN, RF REJECTED, or RF COMPLETE LINGER state, ignore this Buffer Probe; otherwise, 2.
Retrieve the receiving flow context for the flow indicated by chunk.flowID
SHOULD ACK to true; and 4.
A receiver can reject an RF OPEN flow at any time and for any reason.
To reject a receiving flow in the RF OPEN state: 1.
Move to the RF REJECTED state; 2.
Discard all entries in flow.
RECV BUFFER, as they are no longer relevant; 3.
If the user rejected the flow, set flow.
EXCEPTION CODE to the exception code indicated by the user; otherwise, the flow was rejected automatically by the implementation, so the exception code is 0;
SHOULD ACK to true; and 5.
The receiver indicates that it has rejected a flow by sending a Flow Exception Report chunk (Section 2.3.16) with every acknowledgement (Section 3.6.3.4.3) for a flow in the RF REJECTED state.
Close A receiving flow is complete when every sequence number from 0 through and including the final sequence number has been received   that is, when flow.
RF FINAL SN has a value and flow.
SET contains every sequence number from 0 through flow.
When an RF OPEN or RF REJECTED receiving flow becomes complete, move to the RF COMPLETE LINGER state, set flow.
SHOULD ACK to true, and set session.
A receiving flow SHOULD remain in the RF COMPLETE LINGER state for 120 seconds.
After 120 seconds, move to the RF CLOSED state.
The receiving flow is now closed, and its resources can be reclaimed once all complete messages in flow.
RECV BUFFER have been delivered to the user (Section 3.6.3.3).
The same flow ID might be used for a new flow by the sender after this point.
The flow sender detects that the flow is complete on receiving an acknowledgement of all fragment sequence numbers of the flow.
This can't happen until after the receiver has detected that the flow is complete and acknowledged all of the sequence numbers.
The receiver's RF COMPLETE LINGER period is two minutes (one Maximum Segment Lifetime (MSL)); this period allows any in flight packets to drain from the network without being misidentified and gives the sender an opportunity to retransmit any sequence numbers if the completing acknowledgement is lost.
The sender's F COMPLETE LINGER period is at least two minutes plus 10 seconds and doesn't begin until the completing acknowledgement is received; therefore, the same flow identifier won't be reused by the flow sender for a new sending flow for at least 10 seconds after the flow receiver has closed the receiving flow context.
This ensures correct operation independent of network delay, even when the sender's clock runs up to 8 percent faster than the receiver's.
This memo specifies chunk type code values (Section 2.3) and User Data option type code values (Section 2.3.11.1).
These type code values are assigned and maintained by Adobe.
Therefore, this memo has no IANA actions.
This memo specifies a general framework that can be used to establish a confidential and authenticated session between endpoints.
A Cryptography Profile, not specified herein, defines the cryptographic algorithms, data formats, and semantics as used within this framework.
Designing a Cryptography Profile to ensure that communications are protected to the degree required by the application specific threat model is outside the scope of this specification.
A block cipher in CBC mode is RECOMMENDED for packet encryption (Section 2.2.3).
An attacker can predict the values of some fields from one plain RTMFP packet to the next or predict that some fields may be the same from one packet to the next.
This SHOULD be considered in choosing and implementing a packet encryption cipher and mode.
The well known Default Session Key of a Cryptography Profile serves multiple purposes, including the scrambling of session startup packets to protect interior fields from undesirable modification by middleboxes such as NATs, increasing the effort required for casual passive observation of startup packets, and allowing different applications of RTMFP using different Default Session Keys to (intentionally or not) share network transport addresses without interference.
The Default Session Key, being well known, MUST NOT be construed to contribute to the security of session startup; session startup is essentially in the clear.
Section 3.5.4.2 describes an OPTIONAL method for processing a change of network address of a communicating peer.
Securely processing address mobility using that method, or any substantially similar method, REQUIRES at least that the packet encryption function of the Cryptography Profile (Section 2.2.3) employs a cryptographic verification mechanism comprising secret information known only to the two endpoints.
Without this constraint, that method, or any substantially similar method, becomes "session hijacking support".
Flows and packet fragmentation imply semantics that could cause unbounded resource utilization in receivers, causing a denial of service.
Implementations SHOULD guard against unbounded or excessive resource use and abort sessions that appear abusive.
A rogue but popular Redirector (Section 3.5.1.4) could direct session initiators to flood a victim address or network with Initiator Hello packets, potentially causing a denial of service.
An attacker that can passively observe an IHello and that possesses a certificate matching the Endpoint Discriminator (without having to know the private key, if any, associated with it) can deny the initiator access to the desired responder by sending an RHello before the desired responder does, since only the first received RHello is selected by the initiator.
The attacker needn't forge the desired responder's source address, since the RHello is selected based on the tag echo and not the packet's source address.
This can simplify the attack in some network or host configurations.
An attacker that can passively observe and record the packets of an established session can use traffic analysis techniques to infer the start and completion of flows without decrypting the packets.
The User Data fragments of flows have unique sequence numbers, so flows are immune to replay while they are open.
However, once a flow has completed and the linger period has concluded, the attacker could replay the recorded packets, opening a new flow in the receiver and duplicating the flow's data; this replay might have undesirable effects on the receiver's application.
The attacker could also infer that a new flow has begun reusing the recorded flow's identifier and replay the final sequence number or any of the other fragments in the flow, potentially denying or interfering with legitimate traffic to the receiver.
Therefore, the data integrity aspect of packet encryption SHOULD comprise anti replay measures.
Appendix A.  Example Congestion Control Algorithm
As mandated in Section 3.5.2, an RTMFP is required to use TCP  compatible congestion control, but flexibility in exact implementation is allowed, within certain limits.
This section describes an experimental window based congestion control algorithm that is appropriate for real time and bulk data transport in RTMFP.
The algorithm includes slow start and congestion avoidance phases, including modified increase and decrease parameters.
These parameters are further adjusted according to whether real time data is being sent and whether Time Critical Reverse Notifications are received.
Discussion RFC 5681 defines the standard window based congestion control algorithms for TCP.
These algorithms are appropriate for delay  insensitive bulk data transport but have undesirable behaviors for delay  and loss sensitive applications.
Among the undesirable behaviors are the cutting of the congestion window in half during a loss event, and the rapidity of the slow start algorithm's exponential growth.
Cutting the congestion window in half requires a large channel headroom to support a real time application and can cause a large amount of jitter from sender side buffering.
Doubling the congestion window during the slow start phase can lead to the congestion window temporarily growing to twice the size it should be, causing a period of excessive loss in the path.
We found that a number of deployed TCP implementations use the method of equation (3) from Section 3.1 of RFC 5681; this method, when combined with the recommended behavior of acknowledging every other packet, causes the congestion window to grow at approximately half the rate that the recommended method specifies.
In order to compete fairly with these deployed TCPs, we choose 768 bytes per round trip as the increment during the normal congestion avoidance phase; this is approximately half of the typical maximum segment size of 1500 bytes and is also easily subdivided.
The sender may be sending real time data to the far end.
When sending real time data, a smoother response to congestion is desired while still competing with reasonable fairness to other flows in the Internet.
In order to scale the sending rate quickly, the slow start algorithm is desired, but slow start's normal rate of increase can cause excessive loss in the last round trip.
Accordingly, slow start's exponential increase rate is adjusted to double approximately every 3 round trips instead of every round trip.
The multiplicative decrease cuts the congestion window by one eighth on loss to maintain a smoother sending rate.
The additive increase is done at half the normal rate (incrementing at 384 bytes per round trip), to both compensate for the less aggressive loss response and probe the path capacity more gently.
The far end may report that it is receiving real time data from other peers, or the sender may be sending real time data to other far ends.
In these circumstances (if not sending real time data to this far end), it is desirable to respond differently than the standard TCP algorithms specify, to both yield capacity to the real time flows and avoid excessive losses while probing the path capacity.
Slow start's exponential increase is disabled, and the additive increase is done at half the normal rate (incrementing at 384 bytes per round trip).
Multiplicative decrease is left at the normal rate (cutting by half) to yield to other flows.
Since real time messages may be small, and sent regularly, it is advantageous to spread congestion window increases out across the round trip time instead of doing them all at once.
We divide the round trip into 16 segments with an additive increase of a useful size (48 bytes) per segment.
Scalable TCP [ScalableTCP] describes experimental methods of modifying the additive increase and multiplicative decrease of the congestion window in large delay bandwidth scenarios.
The congestion window is increased by 1% each round trip and decreased by one eighth on loss in the congestion avoidance phase in certain circumstances (specifically, when a 1% increase is larger than the normal additive  increase amount).
Those methods are adapted here.
The scalable increase amount is 48 bytes for every 4800 bytes acknowledged, to spread the increase out over the round trip.
The congestion window is decreased by one eighth on loss when it is at least 67200 bytes per round trip, which is seven eighths of 76800 (the point at which 1% is greater than 768 bytes per round trip).
When sending real time data to the far end, the scalable increase is 1% or 384 bytes per round trip, whichever is greater.
Otherwise, when notified that the far end is receiving real time data from other peers, the scaled increase is adjusted to 0.5% or 384 bytes per round trip, whichever is greater.
Algorithm Let SMSS denote the Sender Maximum Segment Size [RFC5681], for example 1460 bytes.
Let CWND INIT denote the Initial Congestion Window (IW) according to Section 3.1 of RFC 5681, for example 4380 bytes.
Let CWND TIMEDOUT denote the congestion window after a timeout indicating lost data, being 1 SMSS (for example, 1460 bytes).
Let the session information context contain additional variables:
CWND: the congestion window, initialized to CWND INIT;  SSTHRESH: the slow start threshold, initialized to positive infinity;  ACKED BYTES ACCUMULATOR: a count of acknowledged bytes, initialized to 0;  ACKED BYTES
THIS PACKET: a count of acknowledged bytes observed in the current packet;  PRE ACK OUTSTANDING: the number of bytes outstanding in the network before processing any acknowledgements in the current packet;  ANY LOSS: an indication of whether any loss has been detected in the current packet;  ANY NAKS: an indication of whether any negative acknowledgements have been detected in the current packet;  ANY ACKS: an indication of whether any acknowledgement chunks have been received in the current packet.
Let FASTGROW ALLOWED indicate whether the congestion window is allowed to grow at the normal rate versus a slower rate, being false if a Time Critical Reverse Notification has been received on this session within the last 800 milliseconds (Sections 2.2.4 and 3.5.2.1) or if a Time Critical Forward Notification has been sent on ANY session in the last 800 milliseconds, and otherwise being true.
Let TC SENT indicate whether a Time Critical Forward Notification has been sent on this session within the last 800 milliseconds.
Implement the method described in Section 3.6.2.6 to manage transmission timeouts, including setting the TIMEOUT ALARM.
On being notified that the TIMEOUT ALARM has fired, perform the function shown in Figure 24: on TimeoutNotification(WAS LOSS): set SSTHRESH to MAX(SSTHRESH, CWND   3/4).
set ACKED BYTES ACCUMULATOR to 0.
if WAS LOSS is true: set CWND to CWND TIMEDOUT.
else: set CWND to CWND INIT.
Figure 24: Pseudocode for Handling a Timeout Notification
Before processing each received packet in this session: 1.
Set ANY LOSS to false; 2.
Set ANY NAKS to false; 3.
THIS PACKET to 0; and 4.
PRE ACK OUTSTANDING to S OUTSTANDING BYTES.
On notification of loss (Section 3.6.2.5), set ANY LOSS to true.
On notification of negative acknowledgement (Section 3.6.2.5), set ANY NAKS to true.
On notification of acknowledgement of data (Section 3.6.2.4), set ANY ACKS to true, and add the count of acknowledged bytes to ACKED BYTES THIS PACKET.
After processing all chunks in each received packet for this session, perform the function shown in Figure 25: if ANY LOSS is true: if (TC SENT is true) OR (PRE ACK OUTSTANDING > 67200 AND
\ FASTGROW ALLOWED is true)
: set SSTHRESH to MAX(PRE ACK OUTSTANDING   7/8, CWND INIT).
else: set SSTHRESH to MAX(PRE ACK OUTSTANDING   1/2, CWND INIT).
set ACKED BYTES ACCUMULATOR to 0.
else if (ANY ACKS is true) AND (ANY NAKS is false) AND \ (PRE ACK OUTSTANDING >  CWND):
set var INCREASE to 0.
if FASTGROW ALLOWED is true: if CWND < SSTHRESH: set INCREASE to ACKED BYTES THIS PACKET.
else: add ACKED BYTES THIS PACKET to ACKED BYTES ACCUMULATOR.
set AITHRESH to MIN(MAX(CWND / 16, 64), 4800).
while ACKED BYTES ACCUMULATOR >
: subtract AITHRESH from ACKED BYTES ACCUMULATOR.
else FASTGROW ALLOWED is false: if CWND < SSTHRESH AND TC SENT is true: set INCREASE to CEIL(ACKED BYTES THIS PACKET / 4).
if TC SENT is true: set AITHRESH CAP to 2400.
else: set AITHRESH CAP to 4800.
THIS PACKET to ACKED BYTES ACCUMULATOR.
set AITHRESH to MIN(MAX(CWND / 16, 64), AITHRESH CAP).
while ACKED BYTES ACCUMULATOR >
: subtract AITHRESH from ACKED BYTES ACCUMULATOR.
set CWND to MAX(CWND   MIN(INCREASE, SMSS), CWND INIT).
Figure 25: Pseudocode for Congestion Window Adjustment after Processing a Packet
