- contents:
  - '             Kerberized Internet Negotiation of Keys (KINK)

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes the Kerberized Internet Negotiation of Keys\n
    \  (KINK) protocol.  KINK defines a low-latency, computationally\n   inexpensive,
    easily managed, and cryptographically sound protocol to\n   establish and maintain
    security associations using the Kerberos\n   authentication system.  KINK reuses
    the Quick Mode payloads of the\n   Internet Key Exchange (IKE), which should lead
    to substantial reuse\n   of existing IKE implementations.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Conventions Used in This Document ..........................3\n   2.
    Protocol Overview ...............................................4\n   3. Message
    Flows ...................................................4\n      3.1. GETTGT
    Message Flow ........................................5\n      3.2. CREATE Message
    Flow ........................................6\n           3.2.1. CREATE Key Derivation
    Considerations ................7\n      3.3. DELETE Message Flow ........................................8\n
    \     3.4. STATUS Message Flow ........................................9\n      3.5.
    Reporting Errors ...........................................9\n      3.6. Rekeying
    Security Associations ............................10\n      3.7. Dead Peer Detection
    .......................................10\n           3.7.1. Coping with Dead
    User-to-User Peers ................12\n   4. KINK Message Format ............................................13\n
    \     4.1. KINK Alignment Rules ......................................15\n      4.2.
    KINK Payloads .............................................16\n           4.2.1.
    KINK_AP_REQ Payload ................................17\n           4.2.2. KINK_AP_REP
    Payload ................................18\n           4.2.3. KINK_KRB_ERROR Payload
    .............................19\n           4.2.4. KINK_TGT_REQ Payload ...............................20\n
    \          4.2.5. KINK_TGT_REP Payload ...............................21\n           4.2.6.
    KINK_ISAKMP Payload ................................21\n           4.2.7. KINK_ENCRYPT
    Payload ...............................22\n           4.2.8. KINK_ERROR Payload
    .................................23\n   5. Differences from IKE Quick Mode ................................25\n
    \     5.1. Security Association Payloads .............................26\n      5.2.
    Proposal and Transform Payloads ...........................26\n      5.3. Identification
    Payloads ...................................26\n      5.4. Nonce Payloads ............................................26\n
    \     5.5. Notify Payloads ...........................................27\n      5.6.
    Delete Payloads ...........................................28\n      5.7. KE Payloads
    ...............................................28\n   6. Message Construction
    and Constraints for IPsec DOI .............28\n      6.1. REPLY Message .............................................28\n
    \     6.2. ACK Message ...............................................28\n      6.3.
    CREATE Message ............................................29\n      6.4. DELETE
    Message ............................................30\n      6.5. STATUS Message
    ............................................31\n      6.6. GETTGT Message ............................................32\n
    \  7. ISAKMP Key Derivation ..........................................32\n   8.
    Key Usage Numbers for Kerberos Key Derivation ..................33\n   9. Transport
    Considerations .......................................33\n   10. Security Considerations
    .......................................34\n   11. IANA Considerations ...........................................35\n
    \  12. Forward Compatibility Considerations ..........................35\n      12.1.
    New Versions of Quick Mode ...............................36\n      12.2. New
    DOI ..................................................36\n   13. Related Work
    ..................................................36\n   14. Acknowledgements
    ..............................................37\n   15. References ....................................................37\n
    \     15.1. Normative References .....................................37\n      15.2.
    Informative References ...................................38\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   KINK is designed to provide a secure, scalable mechanism
    for\n   establishing keys between communicating entities within a centrally\n
    \  managed environment in which it is important to maintain consistent\n   security
    policy.  The security goals of KINK are to provide privacy,\n   authentication,
    and replay protection of key management messages and\n   to avoid denial of service
    vulnerabilities whenever possible.  The\n   performance goals of the protocol
    are to have a low computational\n   cost, low latency, and a small footprint.
    \ It is also to avoid or\n   minimize the use of public key operations.  In particular,
    the\n   protocol provides the capability to establish IPsec security\n   associations
    (SAs) in two messages with minimal computational effort.\n   These requirements
    are described in RFC 3129 [REQ4KINK].\n   Kerberos [KERBEROS] provides an efficient
    authentication mechanism\n   for clients and servers using a trusted third-party
    model.  Kerberos\n   also provides a mechanism for cross-realm authentication
    natively.  A\n   client obtains a ticket from an online authentication server,
    the Key\n   Distribution Center (KDC).  The ticket is then used to construct a\n
    \  credential for authenticating the client to the server.  As a result\n   of
    this authentication operation, the server will also share a secret\n   key with
    the client.  KINK uses this property as the basis of\n   distributing keys for
    IPsec.\n   The central key management provided by Kerberos is efficient because\n
    \  it limits computational cost and limits complexity versus IKE's\n   necessity
    of using public key cryptography [IKE].  Initial\n   authentication to the KDC
    may be performed using either symmetric\n   keys, or asymmetric keys using the
    Public Key Cryptography for\n   Initial Authentication in Kerberos [PKINIT]; however,
    subsequent\n   requests for tickets as well as authenticated exchanges between
    the\n   client and servers always utilize symmetric cryptography.  Therefore,\n
    \  public key operations (if any) are limited and are amortized over the\n   lifetime
    of the credentials acquired in the initial authentication\n   operation to the
    KDC.  For example, a client may use a single public\n   key exchange with the
    KDC to efficiently establish multiple SAs with\n   many other servers in the realm
    of the KDC.  Kerberos also scales\n   better than direct peer-to-peer keying when
    symmetric keys are used.\n   The reason is that since the keys are stored in the
    KDC, the number\n   of principal keys is O(n+m) rather than O(n*m), where \"n\"
    is the\n   number of clients and \"m\" is the number of servers.\n"
  - contents:
    - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
      as described in [RFC2119].\n   It is assumed that the readers are familiar with
      the terms and\n   concepts described in Kerberos Version 5 [KERBEROS], IPsec
      [IPSEC],\n   and IKE [IKE].\n"
    title: 1.1.  Conventions Used in This Document
  title: 1.  Introduction
- contents:
  - "2.  Protocol Overview\n   KINK is a command/response protocol that can create,
    delete, and\n   maintain IPsec SAs.  Each command or response contains a common\n
    \  header along with a set of type-length-value payloads.  The type of a\n   command
    or a response constrains the payloads sent in the messages of\n   the exchange.
    \ KINK itself is a stateless protocol in that each\n   command or response does
    not require storage of hard state for KINK.\n   This is in contrast to IKE, which
    uses Main Mode to first establish\n   an Internet Security Association and Key
    Management Protocol (ISAKMP)\n   SA followed by subsequent Quick Mode exchanges.\n
    \  KINK uses Kerberos mechanisms to provide mutual authentication and\n   replay
    protection.  For establishing SAs, KINK provides\n   confidentiality for the payloads
    that follow the Kerberos AP-REQ\n   payload.  The design of KINK mitigates denial
    of service attacks by\n   requiring authenticated exchanges before the use of
    any public key\n   operations and the installation of any state.  KINK also provides
    a\n   means of using Kerberos User-to-User mechanisms when there is not a\n   key
    shared between the server and the KDC.  This is typically, but\n   not limited
    to, the case with IPsec peers using PKINIT for initial\n   authentication.\n   KINK
    directly reuses Quick Mode payloads defined in section 5.5 of\n   [IKE], with
    some minor changes and omissions.  In most cases, KINK\n   exchanges are a single
    command and its response.  An optional third\n   message is required when creating
    SAs, only if the responder rejects\n   the first proposal from the initiator or
    wants to contribute the\n   keying materials.  KINK also provides rekeying and
    dead peer\n   detection.\n"
  title: 2.  Protocol Overview
- contents:
  - "3.  Message Flows\n   All KINK message flows follow the same pattern between
    the two peers:\n   a command, a response, and an optional acknowledgement in a
    CREATE\n   flow.  A command is a GETTGT, CREATE, DELETE, or STATUS message; a\n
    \  response is a REPLY message; and an acknowledgement is an ACK\n   message.\n
    \  KINK uses Kerberos as the authentication mechanism; therefore, a KINK\n   host
    needs to get a service ticket for each peer before actual key\n   negotiations.
    \ This is basically a pure Kerberos exchange and the\n   actual KDC traffic here
    is for illustrative purposes only.  In\n   practice, when a principal obtains
    various tickets is a subject of\n   Kerberos and local policy consideration.  As
    an exception, the GETTGT\n   message flow of KINK (described in section 3.1) is
    used when a User-\n   to-User authentication is required.  In this flow, we assume
    that\n   both A and B have ticket-granting tickets (TGTs) from their KDCs.\n   After
    a service ticket is obtained, KINK uses the CREATE message flow\n   (section 3.2),
    DELETE message flow (section 3.3), and STATUS message\n   flow (section 3.4) to
    manage SAs.  In these flows, we assume that A\n   has a service ticket for B.\n"
  - contents:
    - "3.1.  GETTGT Message Flow\n   This flow is used to retrieve a TGT from the
      remote peer in User-to-\n   User authentication mode.\n   If the initiator determines
      that it will not be able to get a normal\n   (non-User-to-User) service ticket
      for the responder, it can try a\n   User-to-User authentication.  In this case,
      it first fetches a TGT\n   from the responder in order to get a User-to-User
      service ticket:\n       A                        B                       KDC\n
      \    ------                  ------                     ---\n    1  GETTGT+KINK_TGT_REQ------>\n
      \   2  <-------REPLY+KINK_TGT_REP\n    3  TGS-REQ+TGT(B)------------------------------------>\n
      \   4  <-------------------------------------------TGS-REP\n                       Figure
      1: GETTGT Message Flow\n   The initiator MAY support the following events as
      triggers to go to\n   the User-to-User path.  Note that the two errors described
      below will\n   not be authenticated, and how to act on them depends on the policy.\n
      \       o    The local policy says that the responder requires a User-\n             to-User
      authentication.\n        o    A KRB_AP_ERR_USER_TO_USER_REQUIRED error is returned
      from\n             the responder.\n        o    A KDC_ERR_MUST_USE_USER2USER
      error is returned from the\n             KDC.\n"
    title: 3.1.  GETTGT Message Flow
  - contents:
    - "3.2.  CREATE Message Flow\n   This flow creates SAs.  The CREATE command takes
      an \"optimistic\"\n   approach, where SAs are initially created on the expectation
      that the\n   responder will choose the initial proposed payload.  The optimistic\n
      \  proposal is placed in the first transform payload(s) of the first\n   proposal.
      \ The initiator MUST check to see if the optimistic proposal\n   was selected
      by comparing all transforms and attributes, which MUST\n   be identical to those
      in the initiator's optimistic proposal with the\n   exceptions of LIFE_KILOBYTES
      and LIFE_SECONDS.  Each of these\n   attributes MAY be set to a lower value
      by the responder and still\n   expect optimistic keying, but MUST NOT be set
      to a higher value that\n   MUST generate a NO-PROPOSAL-CHOSEN error.  The initiator
      MUST use the\n   shorter lifetime.\n   When a CREATE command contains an existing
      Security Parameter Index\n   (SPI), the responder MUST reject it and SHOULD
      return an ISAKMP\n   notification with INVALID-SPI.\n   When a key exchange
      (KE) payload is sent from the initiator but the\n   responder does not support
      it, the responder MUST reject it with an\n   ISAKMP notification of INVALID-PAYLOAD-TYPE
      containing a KE payload\n   type as its notification data.  When the initiator
      receives this\n   error, it MAY retry without a KE payload (as another transaction)
      if\n   its policy allows that.\n       A                        B                       KDC\n
      \    ------                  ------                     ---\n       A creates
      an optimistic inbound SA (B->A) unless using a KE.\n    1  CREATE+ISAKMP------------>\n
      \      B creates an inbound SA (A->B).\n       B creates an outbound SA (B->A)
      if optimistic and not using a KE.\n    2  <-------------REPLY+ISAKMP\n       A
      creates an outbound SA (A->B).\n       A replaces an inbound SA (B->A) if non-optimistic.\n
      \      A creates an inbound SA (B->A) if using a KE.\n    3 [ ACK--------------------->
      \                           ]\n      [ B creates an outbound SA (B->A).                     ]\n
      \                      Figure 2: CREATE Message Flow\n   Creating SAs has two
      modes:  2-way handshake and 3-way handshake.\n   The initiator usually begins
      a negotiation expecting a 2-way\n   handshake.  When the optimistic proposal
      is not chosen by the\n   responder, the negotiation is switched to a 3-way handshake.
      \ When\n   and only when the initiator uses a KE payload, 3-way handshake is\n
      \  expected from the beginning.\n   A 2-way handshake is performed in the following
      steps:\n      1) The host A creates an inbound SA (B->A) in its SA database\n
      \        using the optimistic proposal in the ISAKMP SA proposal.  It is\n         then
      ready to receive any messages from B.\n      2) A then sends the CREATE message
      to B.\n      3) If B agrees to A's optimistic proposal, B creates an inbound
      SA\n         (A->B) and an outbound SA (B->A) in its database.  If B does\n
      \        not choose the first proposal or wants to add a Nonce payload,\n         switch
      to step 3 of the 3-way handshake described below.\n      4) B then sends a REPLY
      to A without a Nonce payload and without\n         requesting an ACK.\n      5)
      Upon receipt of the REPLY, A creates an outbound SA (A->B).\n   A 3-way handshake
      is performed in the following steps:\n      1) The host A sends the CREATE message
      to B without creating any\n         SA.\n      2) B chooses one proposal according
      to its policy.\n      3) B creates an inbound SA (A->B) and sends the actual
      choice in\n         the REPLY.  It SHOULD send the optional Nonce payload (as
      it\n         does not increase message count and generally increases entropy\n
      \        sources) and MUST request that the REPLY be acknowledged.\n      4)
      Upon receipt of the REPLY, A creates the inbound SA (B->A) (or\n         modifies
      it as necessary, if switched from 2-way), and the\n         outbound SA (A->B).\n
      \     5) A now sends the ACK message.\n      6) Upon receipt of the ACK, B installs
      the final outbound SA\n         (B->A).\n   If B does not choose the first proposal,
      adds a nonce, or accepts the\n   KE exchange, then it MUST request an ACK (i.e.,
      set the ACKREQ bit)\n   so that it can install the final outbound SA.  The initiator
      MUST\n   always generate an ACK if the ACKREQ bit is set in the KINK header,\n
      \  even if it believes that the responder was in error.\n"
    - contents:
      - "3.2.1.  CREATE Key Derivation Considerations\n   The CREATE command's optimistic
        approach allows an SA to be created\n   in two messages rather than three.
        \ The implication of a two-message\n   exchange is that B will not contribute
        to the key since A must set up\n   the inbound SA before it receives any additional
        keying material from\n   B.  This may be suspect under normal circumstances;
        however, KINK\n   takes advantage of the fact that the KDC provides a reliable
        source\n   of randomness which is used in key derivation.  In many cases,
        this\n   will provide an adequate session key so that B will not require an\n
        \  acknowledgement.  Since B is always at liberty to contribute to the\n   keying
        material, this is strictly a trade-off between the key\n   strength versus
        the number of messages, which KINK implementations\n   may decide as a matter
        of policy.\n"
      title: 3.2.1.  CREATE Key Derivation Considerations
    title: 3.2.  CREATE Message Flow
  - contents:
    - "3.3.  DELETE Message Flow\n   The DELETE command deletes existing SAs.  The
      domain of\n   interpretation (DOI)-specific payloads describe the actual SA
      to be\n   deleted.  For the IPsec DOI, those payloads will include an ISAKMP\n
      \  payload containing the list of the SPIs to be deleted.\n       A                        B
      \                      KDC\n     ------                  ------                     ---\n
      \      A deletes outbound SA to B.\n    1  DELETE+ISAKMP------------>\n       B
      deletes inbound and outbound SA to A.\n    2  <-------------REPLY+ISAKMP\n       A
      deletes inbound SA to B.\n                       Figure 3: DELETE Message Flow\n
      \  The DELETE command takes a \"pessimistic\" approach, which does not\n   delete
      inbound SAs until it receives acknowledgement that the other\n   host has received
      the DELETE.  The exception to the pessimistic\n   approach is if the initiator
      wants to immediately cease all activity\n   on an inbound SA.  In this case,
      it MAY delete the inbound SA as well\n   in step 1, above.\n   The ISAKMP payload
      contains ISAKMP Delete payload(s) that indicate\n   the inbound SA(s) for the
      initiator of this flow.  KINK does not\n   allow half-open SAs; thus, when the
      responder receives a DELETE\n   command, it MUST delete SAs of both directions,
      and MUST reply with\n   ISAKMP Delete payload(s) that indicate the inbound SA(s)
      for the\n   responder of this flow.  If the responder cannot find an appropriate\n
      \  SPI to be deleted, it MUST return an ISAKMP notification with\n   INVALID_SPI,
      which also serves to inform the initiator that it can\n   delete the inbound
      SA.\n   A race condition with the DELETE flow exists.  Due to network\n   reordering,
      etc., packets in flight while the DELETE operation is\n   taking place may arrive
      after the diagrams above, which recommend\n   deleting the inbound SA.  A KINK
      implementation SHOULD implement a\n   grace timer that SHOULD be set to a period
      of at least two times the\n   average round-trip time, or to a configurable
      value.  A KINK\n   implementation MAY choose to set the grace period to zero
      at\n   appropriate times to delete an SA ungracefully.  The behavior\n   described
      here is referred from the behavior of the TCP [RFC793]\n   flags FIN and RST.\n"
    title: 3.3.  DELETE Message Flow
  - contents:
    - "3.4.  STATUS Message Flow\n   This flow is used to send any information to
      a peer or to elicit any\n   information from a peer.  An initiator may send
      a STATUS command to\n   the responder at any time, optionally with DOI-specific
      ISAKMP\n   payloads.  In the case of the IPsec DOI, these are generally in the\n
      \  form of ISAKMP Notification payloads.  A STATUS command is also used\n   as
      a means of dead peer detection described in section 3.7.\n       A                        B
      \                      KDC\n     ------                  ------                     ---\n
      \   1  STATUS[+ISAKMP]---------->\n    2  <-----------REPLY[+ISAKMP]\n                       Figure
      4: STATUS Message Flow\n"
    title: 3.4.  STATUS Message Flow
  - contents:
    - "3.5.  Reporting Errors\n   When the responder detects an error in a received
      command, it can\n   send a DOI-specific payload to indicate the error in a REPLY
      message.\n   There are three types of payloads that can indicate errors:\n   KINK_KRB_ERROR
      payloads for Kerberos errors, KINK_ERROR payloads for\n   KINK errors, and KINK_ISAKMP
      payloads for ISAKMP errors.  Details are\n   described in sections 4.2.3, 4.2.8,
      and 4.2.6, respectively.\n   If the initiator detects an error in a received
      reply, there is no\n   means to report it back to the responder.  The initiator
      SHOULD log\n   the event and MAY take a remedial action by reinitiating the
      initial\n   command.\n   If the server clock and the client clock are off by
      more than the\n   policy-determined clock skew limit (usually 5 minutes), the
      server\n   MUST return a KRB_AP_ERR_SKEW.  The optional client's time in the\n
      \  KRB-ERROR SHOULD be filled out.  If the server protects the error by\n   adding
      the Cksum field and returning the correct client's time, the\n   client SHOULD
      compute the difference (in seconds) between the two\n   clocks based upon the
      client and server time contained in the\n   KRB-ERROR message.  The client SHOULD
      store this clock difference and\n   use it to adjust its clock in subsequent
      messages.  If the error is\n   not protected, the client MUST NOT use the difference
      to adjust\n   subsequent messages, because doing so would allow an attacker
      to\n   construct authenticators that can be used to mount replay attacks.\n"
    title: 3.5.  Reporting Errors
  - contents:
    - "3.6.  Rekeying Security Associations\n   KINK expects the initiator of an SA
      to be responsible for rekeying\n   the SA for two reasons.  The first reason
      is to prevent needless\n   duplication of SAs as the result of collisions due
      to an initiator\n   and responder both trying to renew an existing SA.  The
      second reason\n   is due to the client/server nature of Kerberos exchanges,
      which\n   expects the client to get and maintain tickets.  While KINK expects\n
      \  that a KINK host is able to get and maintain tickets, in practice it\n   is
      often advantageous for servers to wait for clients to initiate\n   sessions
      so that they do not need to maintain a large ticket cache.\n   There are no
      special semantics for rekeying SAs in KINK.  That is, in\n   order to rekey
      an existing SA, the initiator must CREATE a new SA\n   followed by either deleting
      the old SA with the DELETE flow or\n   letting it time out.  When identical
      flow selectors are available on\n   different SAs, KINK implementations SHOULD
      choose the SA most\n   recently created.  It should be noted that KINK avoids
      most of the\n   problems of [IKE] rekeying by having a reliable delete mechanism.\n
      \  Normally, a KINK implementation that rekeys existing SAs will try to\n   rekey
      the SA ahead of an SA termination, which may include the hard\n   lifetime in
      time/bytecount or the overflow of the sequence number\n   counter.  We call
      this time \"soft lifetime\".  The soft lifetime MUST\n   be randomized to avoid
      synchronization with similar implementations.\n   In the case of the lifetime
      in time, one reasonable approach to\n   determine the soft lifetime is picking
      a random time between T-rekey\n   and T-retrans and subtracting it from the
      hard lifetime.  Here,\n   T-rekey is the reasonable maximum rekeying margin,
      and T-retrans is\n   the amount of time it would take to go through a full retransmission\n
      \  cycle.  T-rekey SHOULD be at least twice as high as T-retrans.\n"
    title: 3.6.  Rekeying Security Associations
  - contents:
    - "3.7.  Dead Peer Detection\n   In order to determine that a KINK peer has lost
      its security database\n   information, KINK peers MUST record the current epoch
      for which they\n   have valid SA information for a peer and reflect that epoch
      in each\n   AP-REQ and AP-REP message.  When a KINK peer creates state for a\n
      \  given SA, it MUST also record the principal's epoch.  If it discovers\n   on
      a subsequent message that the principal's epoch has changed, it\n   MUST consider
      all SAs created by that principal as invalid, and take\n   some action such
      as tearing those SAs down.\n   While a KINK peer SHOULD use feedback from routing
      (in the form of\n   ICMP messages) as a trigger to check whether or not the
      peer is still\n   alive, a KINK peer MUST NOT conclude the peer is dead simply
      based on\n   unprotected routing information (said ICMP messages).\n   If there
      is suspicion that a peer may be dead (based on any\n   information available
      to the KINK peer, including lack of IPsec\n   traffic, etc.), the KINK STATUS
      message SHOULD be used to coerce an\n   acknowledgement out of the peer.  Since
      nothing is negotiated about\n   dead peer detection in KINK, each peer can decide
      its own metric for\n   \"suspicion\" and also what timeouts to use before declaring
      a peer\n   dead due to lack of response to the STATUS message.  This is\n   desirable,
      and does not break interoperability.\n   The STATUS message has a twofold effect.
      \ First, it elicits a\n   cryptographically secured (and replay-protected) response
      from the\n   peer, which tells us whether or not the peer is reachable/alive.\n
      \  Second, it carries the epoch number of the peer, so we know whether\n   or
      not the peer has rebooted and lost all state.  This is crucial to\n   the KINK
      protocol: In IKE, if a peer reboots, we lose all\n   cryptographic context,
      and no cryptographically secure communication\n   is possible without renegotiating
      keys.  In KINK, due to Kerberos\n   tickets, we can communicate securely with
      a peer, even if the peer\n   rebooted, as the shared cryptographic key used
      is carried in the\n   Kerberos ticket.  Thus, active cryptographic communication
      is not an\n   indication that the peer has not rebooted and lost all state,
      and the\n   epoch is needed.\n   Assume a Peer A sending a STATUS and a peer
      B sending the REPLY (see\n   section 3.4).  Peer B MAY assume that the sender
      is alive, and the\n   epoch in the STATUS message will indicate whether or not
      the peer A\n   has lost state.  Peer B MUST acknowledge the STATUS message with
      a\n   REPLY message, as described in section 3.4.\n   The REPLY message will
      indicate to peer A that the peer is alive, and\n   the epoch in the REPLY will
      indicate whether peer B has lost its\n   state or not.  If peer A does not receive
      a REPLY message from peer B\n   in a suitable timeout, peer A MAY send another
      STATUS message.  It is\n   up to peer A to decide how aggressively to declare
      peer B dead.  The\n   level of aggressiveness may depend on many factors such
      as rapid fail\n   over versus number of messages sent by nodes with large numbers
      of\n   SAs.\n   Note that peer B MUST NOT make any inferences about a lack of
      STATUS\n   message from peer A.  Peer B MAY use a STATUS message from peer A
      as\n   an indication of A's aliveness, but peer B MUST NOT expect another\n
      \  STATUS message at any time (i.e., dead peer detection is not periodic\n   keepalives).\n
      \  Strategies for sending STATUS messages are the following: Peer A may\n   decide
      to send a STATUS message only after a prolonged period where\n   no traffic
      was sent in either direction over the IPsec SAs with the\n   peer.  Once there
      is traffic, peer A may want to know if the traffic\n   is going into a black
      hole, and send a STATUS message.\n   Alternatively, peer A may use an idle timer
      to detect lack of traffic\n   with the peer, and send STATUS messages in the
      quiet phase to make\n   sure the peer is still alive for when traffic needs
      to finally be\n   sent.\n"
    - contents:
      - "3.7.1.  Coping with Dead User-to-User Peers\n   When an initiator uses a
        User-to-User ticket and a responder has lost\n   its previous TGT, the usual
        dead peer detection (DPD) mechanism does\n   not work, because the responder
        cannot decrypt the ticket with its\n   new TGT.  In this case, the following
        actions are taken.\n     o    When the responder receives a KINK command with
        a User-to-User\n          ticket that cannot be decrypted with its TGT, it
        returns a\n          REPLY with a KINK_TGT_REP payload containing the TGT.\n
        \    o    When the initiator receives a KINK_TGT_REP, it retrieves a new\n
        \         service ticket with the TGT and retries the command.\n   This does
        not directly define a method to detect a dead User-to-User\n   peer, but to
        recover from the situation that the responder does not\n   have an appropriate
        TGT to decrypt a service ticket sent from the\n   initiator.  After recovery,
        they can exchange their epochs, and usual\n   DPD mechanism will detect a
        dead peer if it really has been dead.\n   The initiator MUST NOT think the
        peer has been dead on the receipt of\n   a KINK_TGT_REP because of two reasons.
        \ One is that the message is\n   not authenticated, and the other is that
        losing a TGT does not\n   necessarily mean losing the SA database information.
        \ The initiator\n   SHOULD NOT forget the previous service ticket until the
        new one is\n   successfully obtained in order to reduce the cost when a forged\n
        \  KINK_TGT_REP is received.\n"
      title: 3.7.1.  Coping with Dead User-to-User Peers
    title: 3.7.  Dead Peer Detection
  title: 3.  Message Flows
- contents:
  - "4.  KINK Message Format\n   All values in KINK are formatted in network byte
    order (most\n   significant byte first).  The RESERVED fields MUST be set to zero
    (0)\n   when a packet is sent.  The receiver MUST ignore these fields.\n     0
    \                  1                   2                   3\n     0 1 2 3 4 5
    6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \   |   Type        | MjVer |RESRVED|            Length             |\n    +---------------+---------------+---------------+---------------+\n
    \   |                 Domain of Interpretation (DOI)                |\n    +-------------------------------+-------------------------------+\n
    \   |                      Transaction ID (XID)                     |\n    +---------------+-+-------------+-------------------------------+\n
    \   |  NextPayload  |A|  RESERVED2  |           CksumLen            |\n    +---------------+-+-------------+-------------------------------+\n
    \   |                                                               |\n    ~                      A
    series of payloads                     ~\n    |                                                               |\n
    \   +-------------------------------+-------------------------------+\n    |                                                               |\n
    \   ~                       Cksum (variable)                        ~\n    |                                                               |\n
    \   +-------------------------------+-------------------------------+\n                    Figure
    5:  Format of a KINK Message\n   Fields:\n     o    Type (1 octet) -- The type
    of this message.\n              Type              Value\n              -----             -----\n
    \             RESERVED            0\n              CREATE              1\n              DELETE
    \             2\n              REPLY               3\n              GETTGT              4\n
    \             ACK                 5\n              STATUS              6\n              RESERVED
    TO IANA    7 - 127\n              Private Use       128 - 255\n     o    MjVer
    (4 bits) -- Major protocol version number.  This MUST be\n          set to 1.\n
    \    o    RESRVED (4 bits) -- Reserved and MUST be zero when sent, MUST\n          be
    ignored when received.\n     o    Length (2 octets) -- Length of the message in
    octets.  It is\n          not forbidden in KINK that there are unnecessary data
    after\n          the message, but the Length field MUST represent the actual\n
    \         length of the message.\n     o    DOI (4 octets) -- The domain of interpretation.
    \ All DOIs must\n          be registered with the IANA in the ISAKMP Domain of\n
    \         Interpretation section of the isakmp-registry [ISAKMP-REG].\n          The
    IANA Assigned Number for the Internet IP Security DOI\n          [IPDOI] is one
    (1).  This field defines the context of all\n          sub-payloads in this message.
    \ If sub-payloads have a DOI\n          field (e.g., Security Association Payload),
    then the DOI in\n          that sub-payload MUST be checked against the DOI in
    this\n          header, and the values MUST be the same.\n     o    XID (4 octets)
    -- The transaction ID.  A KINK transaction is\n          bound together by a transaction
    ID, which is created by the\n          command initiator and replicated in subsequent
    messages in the\n          transaction.  A transaction is defined as a command,
    a reply,\n          and an optional acknowledgement.  Transaction IDs are used
    by\n          the initiator to discriminate between multiple outstanding\n          requests
    to a responder.  It is not used for replay protection\n          because that
    functionality is provided by Kerberos.  The value\n          of XID is chosen
    by the initiator and MUST be unique with all\n          outstanding transactions.
    \ XIDs MAY be constructed by using a\n          monotonic counter or random number
    generator.\n     o    NextPayload (1 octet) -- Indicates the type of the first\n
    \         payload after the message header.\n     o    A, or ACKREQ (1 bit) --
    ACK Request.  Set to one if the\n          responder requires an explicit acknowledgement
    that a REPLY\n          was received.  An initiator MUST NOT set this flag, nor
    should\n          a responder except for a REPLY to a CREATE when the optimistic\n
    \         proposal is chosen.\n     o    RESERVED2 (7 bits) -- Reserved and MUST
    be zero on send, MUST\n          be ignored by a receiver.\n     o    CksumLen
    (2 octets) -- CksumLen is the length in octets of the\n          cryptographic
    checksum of the message.  A CksumLen of zero\n          implies that the message
    is unauthenticated.\n     o    Cksum (variable) -- Kerberos keyed checksum over
    the entire\n          message excluding the Cksum field itself.  When any padding\n
    \         bytes are required between the last payload and the Cksum\n          field,
    they MUST be included in the calculation.  This field\n          MUST always be
    present whenever a key is available via an\n          AP-REQ or AP-REP payload.
    \ The key used MUST be the session\n          key in the ticket.  When a key is
    not available, this field is\n          not present, and the CksumLen field is
    set to zero.  The\n          content of this field is the output of the Kerberos
    5 get_mic\n          function [KCRYPTO].  The get_mic function used is specified
    by\n          a checksum type, which is a \"required checksum mechanism\" of\n
    \         the etype for the Kerberos session key in the Kerberos ticket.\n          If
    the checksum type is not a keyed algorithm, the message\n          MUST be rejected.\n
    \         To compute the checksum, the CksumLen field is zeroed out and\n          the
    Length field is filled with the total packet length\n          without the checksum.
    \ Then, the packet is passed to the\n          get_mic function and its output
    is appended to the packet.\n          Any KINK padding after the Cksum field is
    not allowed, except\n          the Kerberos internal one, which may be included
    in the output\n          of the get_mic function.  Finally, the CksumLen field
    is\n          filled with the checksum length and the Length field is filled\n
    \         with the total packet length including the checksum.\n          To verify
    the checksum, a length-without-checksum is\n          calculated from the value
    of Length field, subtracting the\n          CksumLen.  The Length field is filled
    with the length-\n          without-checksum value and the CksumLen field is zeroed
    out.\n          Then, the packet without checksum (offset from 0 to length-\n
    \         without-checksum minus 1 of the received packet) and the\n          checksum
    (offset from length-without-checksum to the last) are\n          passed to the
    verify_mic function.  If verification fails, the\n          message MUST be dropped.\n
    \  The KINK header is followed immediately by a series of\n   Type/Length/Value
    fields, defined in section 4.2.\n"
  - contents:
    - "4.1.  KINK Alignment Rules\n   KINK has the following rules regarding alignment
      and padding:\n     o    All length fields MUST reflect the actual number of
      octets in\n          the structure; i.e., they do not account for padding bytes\n
      \         required by KINK alignments.\n     o    KINK headers, payloads, and
      the Cksum field MUST be aligned on\n          4-octet boundaries.\n     o    Variable
      length fields (except the Cksum field) MUST always\n          start immediately
      after the last octet of the previous field.\n          That is, they are not
      aligned to 4-octet boundaries.\n"
    title: 4.1.  KINK Alignment Rules
  - contents:
    - "4.2.  KINK Payloads\n   Immediately following the header, there is a list of\n
      \  Type/Length/Value (TLV) payloads.  There can be any number of\n   payloads
      following the header.  Each payload MUST begin with a\n   payload header.  Each
      payload header is built on the generic payload\n   header.  Any data immediately
      follows the generic header.  Payloads\n   are all implicitly aligned to 4-octet
      boundaries, though the payload\n   length field MUST accurately reflect the
      actual number of octets in\n   the payload.\n     0                   1                   2
      \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n    +---------------+---------------+---------------+---------------+\n
      \   | Next Payload  |   RESERVED    |         Payload Length        |\n    +---------------+---------------+---------------+---------------+\n
      \   |                      value (variable)                         |\n    +---------------+---------------+---------------+---------------+\n
      \                   Figure 6:  Format of a KINK Payload\n   Fields:\n     o
      \   Next Payload (1 octet) -- The type of the next payload.\n              NextPayload
      \      Value\n              ----              -----\n              KINK_DONE
      \          0\n              KINK_AP_REQ         1\n              KINK_AP_REP
      \        2\n              KINK_KRB_ERROR      3\n              KINK_TGT_REQ
      \       4\n              KINK_TGT_REP        5\n              KINK_ISAKMP         6\n
      \             KINK_ENCRYPT        7\n              KINK_ERROR          8\n              RESERVED
      TO IANA    9 - 127\n              Private Use       128 - 255\n          Next
      Payload type KINK_DONE denotes that the current payload\n          is the final
      payload in the message.\n     o    RESERVED (1 octet) -- Reserved and MUST be
      set to zero by a\n          sender, MUST be ignored by a receiver.\n     o    Payload
      Length (2 octets) -- The length of this payload,\n          including the type
      and length fields.\n     o    Value (variable) -- This value of this field depends
      on the\n          type.\n"
    - contents:
      - "4.2.1.  KINK_AP_REQ Payload\n   The KINK_AP_REQ payload relays a Kerberos
        AP-REQ to the responder.\n   The AP-REQ MUST request mutual authentication.\n
        \  This document does not specify how to generate the principal name.\n   That
        is, complete principal names may be stored in local policy,\n   Fully Qualified
        Domain Names (FQDNs) may be converted to principal\n   names, IP addresses
        may be converted to principal names by secure\n   name services, etc., but
        see the first paragraph of the Security\n   Considerations section.\n   If
        the peer's principal name for the KINK service is generated from\n   an FQDN,
        the principal name, which the initiator starts from, will be\n   \"kink/fqdn@REALM\";
        where \"kink\" is a literal string for the KINK\n   IPsec service, \"fqdn\"
        is the fully qualified domain name of the\n   service host, and \"REALM\"
        is the Kerberos realm of the service.  A\n   principal name is case sensitive,
        and \"fqdn\" part MUST be lowercase\n   as described in [KERBEROS].\n   The
        value field of this payload has the following format:\n     0                   1
        \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +---------------+---------------+---------------+---------------+\n
        \   | Next Payload  |   RESERVED    |         Payload Length        |\n    +---------------+---------------+---------------+---------------+\n
        \   |                         EPOCH                                 |\n    +---------------------------------------------------------------+\n
        \   |                                                               |\n    ~
        \                       AP-REQ                                 ~\n    |                                                               |\n
        \   +---------------------------------------------------------------+\n                      Figure
        7:  KINK_AP_REQ Payload\n   Fields:\n     o    Next Payload, RESERVED, Payload
        Length -- Defined in the\n          beginning of this section.\n     o    EPOCH
        -- The absolute time at which the creator of the AP-REQ\n          has valid
        SA information.  Typically, this is when the KINK\n          keying daemon
        started if it does not retain SA information\n          across restarts.  The
        value in this field is the least\n          significant 4 octets of so-called
        POSIX time, which is the\n          elapsed seconds (but without counting
        leap seconds) from\n          1970-01-01T00:00:00 UTC.  For example, 2038-01-19T03:14:07
        UTC\n          is represented as 0x7fffffff.\n     o    AP-REQ -- The value
        field of this payload contains a raw\n          Kerberos AP-REQ.\n"
      title: 4.2.1.  KINK_AP_REQ Payload
    - contents:
      - "4.2.2.  KINK_AP_REP Payload\n   The KINK_AP_REP payload relays a Kerberos
        AP-REP to the initiator.\n   The AP-REP MUST be checked for freshness as described
        in [KERBEROS].\n   The value field of this payload has the following format:\n
        \    0                   1                   2                   3\n     0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +---------------+---------------+---------------+---------------+\n
        \   | Next Payload  |   RESERVED    |         Payload Length        |\n    +---------------+---------------+---------------+---------------+\n
        \   |                         EPOCH                                 |\n    +---------------------------------------------------------------+\n
        \   |                                                               |\n    ~
        \                       AP-REP                                 ~\n    |                                                               |\n
        \   +---------------------------------------------------------------+\n                      Figure
        8:  KINK_AP_REP Payload\n   Fields:\n     o    Next Payload, RESERVED, Payload
        Length -- Defined in the\n          beginning of this section.\n     o    EPOCH
        -- The absolute time at which the creator of the AP-REP\n          has valid
        SA information.  Typically, this is when the KINK\n          keying daemon
        started if it does not retain SA information\n          across restarts.  The
        value in this field is the least\n          significant 4 octets of so-called
        POSIX time, which is the\n          elapsed seconds (but without counting
        leap seconds) from\n          1970-01-01T00:00:00 UTC.  For example, 2038-01-19T03:14:07
        UTC\n          is represented as 0x7fffffff.\n     o    AP-REP -- The value
        field of this payload contains a raw\n          Kerberos AP-REP.\n"
      title: 4.2.2.  KINK_AP_REP Payload
    - contents:
      - "4.2.3.  KINK_KRB_ERROR Payload\n   The KINK_KRB_ERROR payload relays Kerberos
        type errors back to the\n   initiator.  The initiator MUST be prepared to
        receive any valid\n   Kerberos error type [KERBEROS].\n   KINK implementations
        SHOULD make use of a KINK Cksum field when\n   returning KINK_KRB_ERROR and
        the appropriate service key is\n   available.  Especially in the case of clock
        skew errors, protecting\n   the error at the server creates a better user
        experience because it\n   does not require clocks to be synchronized.  However,
        many Kerberos\n   implementations do not make it easy to obtain the session
        key in\n   order to protect error packets.  For unauthenticated Kerberos errors,\n
        \  the initiator MAY choose to act on them, but SHOULD take precautions\n
        \  against make-work kinds of attacks.\n   Note that KINK does not make use
        of the text or e_data field of the\n   Kerberos error message, though a compliant
        KINK implementation MUST\n   be prepared to receive them and MAY log them.\n
        \  The value field of this payload has the following format:\n     0                   1
        \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +---------------+---------------+---------------+---------------+\n
        \   | Next Payload  |   RESERVED    |         Payload Length        |\n    +---------------+---------------+---------------+---------------+\n
        \   |                                                               |\n    ~
        \                     KRB-ERROR                                ~\n    |                                                               |\n
        \   +---------------------------------------------------------------+\n                     Figure
        9:  KINK_KRB_ERROR Payload\n   Fields:\n     o    Next Payload, RESERVED,
        Payload Length -- Defined in the\n          beginning of this section.\n     o
        \   KRB-ERROR -- The value field of this payload contains a raw\n          Kerberos
        KRB-ERROR.\n"
      title: 4.2.3.  KINK_KRB_ERROR Payload
    - contents:
      - "4.2.4.  KINK_TGT_REQ Payload\n   The KINK_TGT_REQ payload provides a means
        to get a TGT from the peer\n   in order to obtain a User-to-User service ticket
        from the KDC.\n   The value field of this payload has the following format:\n
        \    0                   1                   2                   3\n     0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +---------------+---------------+---------------+---------------+\n
        \   | Next Payload  |   RESERVED    |         Payload Length        |\n    +---------------+---------------+---------------+---------------+\n
        \   |                                                               |\n    ~
        \                    PrincName (variable)                      ~\n    |                                                               |\n
        \   +---------------------------------------------------------------+\n                     Figure
        10:  KINK_TGT_REQ Payload\n   Fields:\n     o    Next Payload, RESERVED, Payload
        Length -- Defined in the\n          beginning of this section.\n     o    PrincName
        -- The name of the principal that the initiator\n          wants to communicate
        with.  It is assumed that the initiator\n          knows the responder's principal
        name (including the realm\n          name) in the same way as the non-User-to-User
        case.  The TGT\n          returned MUST NOT be an inter-realm TGT and its
        cname and\n          crealm MUST match the requested principal name, so that
        the\n          initiator can rendezvous with the responder at the responder's\n
        \         realm.\n          PrincName values are octet string representations
        of a\n          principal and realm name formatted just like the octet string\n
        \         used in the \"NAME\" component of Generic Security Service\n          Application
        Program Interface (GSS-API) [RFC2743] exported\n          name token for the
        Kerberos V5 GSS-API mechanism [RFC1964].\n          See RFC 1964, section
        2.1.3.\n   If the responder is not the requested principal and is unable to
        get\n   a TGT for the name, it MAY return a KRB_AP_ERR_NOT_US.  If the\n   administrative
        policy prohibits returning a TGT, it MAY return a\n   KINK_U2UDENIED.\n"
      title: 4.2.4.  KINK_TGT_REQ Payload
    - contents:
      - "4.2.5.  KINK_TGT_REP Payload\n   The value field of this payload contains
        the TGT requested in a\n   previous KINK_TGT_REQ payload of a GETTGT command.\n
        \    0                   1                   2                   3\n     0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +---------------+---------------+---------------+---------------+\n
        \   | Next Payload  |   RESERVED    |         Payload Length        |\n    +---------------+---------------+---------------+---------------+\n
        \   |                                                               |\n    ~
        \                       TGT (variable)                         ~\n    |                                                               |\n
        \   +---------------------------------------------------------------+\n                     Figure
        11:  KINK_TGT_REP Payload\n   Fields:\n     o    Next Payload, RESERVED, Payload
        Length -- Defined in the\n          beginning of this section.\n     o    TGT
        -- The Distinguished Encoding Rules (DER)-encoded TGT of\n          the responder.\n"
      title: 4.2.5.  KINK_TGT_REP Payload
    - contents:
      - "4.2.6.  KINK_ISAKMP Payload\n   The value field of this payload has the following
        format:\n     0                   1                   2                   3\n
        \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +---------------+---------------+---------------+---------------+\n
        \   | Next Payload  |   RESERVED    |         Payload Length        |\n    +---------------+-------+-------+---------------+---------------+\n
        \   | InnerNextPload| QMMaj | QMMin |            RESERVED           |\n    +---------------+-------+-------+---------------+---------------+\n
        \   |                Quick Mode Payloads (variable)                 |\n    +---------------+---------------+---------------+---------------+\n
        \                     Figure 12:  KINK_ISAKMP Payload\n   Fields:\n     o
        \   Next Payload, RESERVED, Payload Length -- Defined in the\n          beginning
        of this section.\n     o    InnerNextPload -- First payload type of the inner
        series of\n          ISAKMP payloads.\n     o    QMMaj -- The major version
        of the inner payloads.  MUST be set\n          to 1.\n     o    QMMin -- The
        minor version of the inner payloads.  MUST be set\n          to 0.\n   The
        KINK_ISAKMP payload encapsulates the IKE Quick Mode (phase 2)\n   payloads
        to take the appropriate action dependent on the KINK\n   command.  There may
        be any number of KINK_ISAKMP payloads within a\n   single KINK message.  While
        [IKE] is somewhat fuzzy about whether\n   multiple different SAs may be created
        within a single IKE message,\n   KINK explicitly requires that a new ISAKMP
        header be used for each\n   discrete SA operation.  In other words, a KINK
        implementation MUST\n   NOT send multiple Quick Mode transactions within a
        single KINK_ISAKMP\n   payload.\n   The purpose of the Quick Mode version
        is to allow backward\n   compatibility with IKE and ISAKMP if there are subsequent
        revisions.\n   At the present time, the Quick Mode major and minor versions
        are set\n   to one and zero (1.0), respectively.  These versions do not\n
        \  correspond to the ISAKMP version in the ISAKMP header.  A compliant\n   KINK
        implementation MUST support receipt of 1.0 payloads.  It MAY\n   support subsequent
        versions (both sending and receiving), and SHOULD\n   provide a means to resort
        back to Quick Mode version 1.0 if the KINK\n   peer is unable to process future
        versions.  A compliant KINK\n   implementation MUST NOT mix Quick Mode versions
        in any given\n   transaction.\n"
      title: 4.2.6.  KINK_ISAKMP Payload
    - contents:
      - "4.2.7.  KINK_ENCRYPT Payload\n   The KINK_ENCRYPT payload encapsulates other
        KINK payloads and is\n   encrypted using the session key and the algorithm
        specified by its\n   etype.  This payload MUST be the final one in the outer
        payload chain\n   of the message.  The KINK_ENCRYPT payload MUST be encrypted
        before\n   the final KINK checksum is applied.\n     0                   1
        \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +---------------+---------------+---------------+---------------+\n
        \   | Next Payload  |   RESERVED    |         Payload Length        |\n    +---------------+---------------+---------------+---------------+\n
        \   | InnerNextPload|                   RESERVED2                   |\n    +---------------+---------------+---------------+---------------+\n
        \   |                         Payload (variable)                    |\n    +---------------+---------------+---------------+---------------+\n
        \                    Figure 13:  KINK_ENCRYPT Payload\n   Fields:\n     o
        \   Next Payload, RESERVED, Payload Length -- Defined in the\n          beginning
        of this section.  This payload is the last one in a\n          message, and
        accordingly, the Next Payload field must be\n          KINK_DONE (0).\n     o
        \   InnerNextPload -- First payload type of the inner series of\n          encrypted
        KINK payloads.\n     o    RESERVED2 -- Reserved and MUST be zero when sent,
        MUST be\n          ignored when received.\n   The coverage of the encrypted
        data begins at InnerNextPload so that\n   the first payload's type is kept
        confidential.  Thus, the number of\n   encrypted octets is PayloadLength -
        4.\n   The format of the encryption payload follows the normal Kerberos\n
        \  semantics.  Its content is the output of an encrypt function defined\n
        \  in the Encryption Algorithm Profile section of [KCRYPTO].  Parameters\n
        \  such as encrypt function itself, specific-key, and initial state are\n
        \  defined with the etype.  The encrypt function may have padding in\n   itself
        and there may be some garbage data at the end of the decrypted\n   plaintext.
        \ A KINK implementation MUST be prepared to ignore such\n   padding after
        the last sub-payload inside the KINK_ENCRYPT payload.\n   Note that each encrypt
        function has its own integrity protection\n   mechanism.  It is redundant
        with the checksum in the KINK header, but\n   this is unavoidable because
        it is not always possible to remove the\n   integrity protection part from
        the encrypt function.\n"
      title: 4.2.7.  KINK_ENCRYPT Payload
    - contents:
      - "4.2.8.  KINK_ERROR Payload\n   The KINK_ERROR payload type provides a protocol-level
        mechanism of\n   returning an error condition.  This payload should not be
        used for\n   either Kerberos-generated errors or DOI-specific errors that
        have\n   their own payloads defined.  The error code is in network order.\n
        \    0                   1                   2                   3\n     0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +---------------+---------------+---------------+---------------+\n
        \   | Next Payload  |   RESERVED    |         Payload Length        |\n    +---------------+---------------+---------------+---------------+\n
        \   |                           ErrorCode                           |\n    +---------------+---------------+---------------+---------------+\n
        \                     Figure 14:  KINK_ERROR Payload\n   Fields:\n     o    Next
        Payload, RESERVED, Payload Length -- Defined in the\n          beginning of
        this section.\n     o    ErrorCode -- One of the following values in the network
        byte\n          order:\n          ErrorCode          Value             Purpose\n
        \         ---------          -----       -------------------\n          KINK_OK
        \             0         No error detected\n          KINK_PROTOERR        1
        \        The message was malformed\n          KINK_INVDOI          2         Invalid
        DOI\n          KINK_INVMAJ          3         Invalid Major Version\n          RESERVED
        \            4\n          KINK_INTERR          5         An unrecoverable
        internal error\n          KINK_BADQMVERS       6         Unsupported Quick
        Mode Version\n          KINK_U2UDENIED       7         Returning a TGT is
        prohibited\n          RESERVED TO IANA     8 - 8191\n          Private Use
        \      8192 - 16383\n          RESERVED         16384 -\n   The responder
        MUST NOT return KINK_OK.  When received, the initiator\n   MAY act as if the
        specific KINK_ERROR payload were not present.  If\n   the initiator supports
        multiple Quick Mode versions or DOIs,\n   KINK_BADQMVERS or KINK_INVDOI is
        received, and the Cksum is verified,\n   then it MAY retry with another version
        or DOI.  A responder SHOULD\n   return a KINK error with KINK_INVMAJ, when
        it receives an unsupported\n   KINK version number in the header.  When KINK_U2UDENIED
        is received,\n   the initiator MAY retry with the non-User-to-User mode (if
        it has not\n   yet been tried).\n   In general, the responder MAY choose to
        return these errors in reply\n   to unauthenticated commands, but SHOULD take
        care to avoid being\n   involved in denial of service attacks.  Similarly,
        the initiator MAY\n   choose to act on unauthenticated errors, but SHOULD
        take care to\n   avoid denial of service attacks.\n"
      title: 4.2.8.  KINK_ERROR Payload
    title: 4.2.  KINK Payloads
  title: 4.  KINK Message Format
- contents:
  - "5.  Differences from IKE Quick Mode\n   KINK directly uses ISAKMP payloads to
    negotiate SAs.  In particular,\n   KINK uses IKE phase 2 payload types (aka Quick
    Mode).  In general,\n   there should be very few changes necessary to an IKE implementation\n
    \  to establish the SAs, and unless there is a note to the contrary in\n   the
    memo, all capabilities and requirements in [IKE] MUST be\n   supported.  IKE phase
    1 payloads MUST NOT be sent.\n   Unlike IKE, KINK defines specific commands for
    creation, deletion,\n   and status of SAs, mainly to facilitate predictable SA\n
    \  creation/deletion (see sections 3.2 and 3.3).  As such, KINK places\n   certain
    restrictions on what payloads may be sent with which\n   commands, and some additional
    restrictions and semantics of some of\n   the payloads.  Implementors should refer
    to [IKE] and [ISAKMP] for\n   the actual format and semantics.  If a particular
    IKE phase 2 payload\n   is not mentioned here, it means that there are no differences
    in its\n   use.\n     o   The Security Association Payload header for IP is defined
    in\n         section 4.6.1 of [IPDOI].  For this memo, the Domain of\n         Interpretation
    MUST be set to 1 (IPsec) and the Situation\n         bitmap MUST be set to 1 (SIT_IDENTITY_ONLY).
    \ All other fields\n         are omitted (because SIT_IDENTITY_ONLY is set).\n
    \    o   KINK also expands the semantics of IKE in that it defines an\n         optimistic
    proposal for CREATE commands to allow SA creation to\n         complete in two
    messages.\n     o   IKE Quick Mode (phase 2) uses the hash algorithm used in main\n
    \        mode (phase 1) to generate the keying material.  For this\n         purpose,
    KINK MUST use a pseudo-random function determined by\n         the etype of the
    session key.\n     o   KINK does not use the HASH payload at all.\n     o   KINK
    allows the Nonce payload Nr to be optional to facilitate\n         optimistic
    keying.\n"
  - contents:
    - "5.1.  Security Association Payloads\n   KINK supports the following SA attributes
      from [IPDOI]:\n   class                     value           type\n   -------------------------------------------------\n
      \  SA Life Type                1               B\n   SA Life Duration            2
      \              V\n   Encapsulation Mode          4               B\n   Authentication
      Algorithm    5               B\n   Key Length                  6               B\n
      \  Key Rounds                  7               B\n   Refer to [IPDOI] for the
      actual definitions of these attributes.\n"
    title: 5.1.  Security Association Payloads
  - contents:
    - "5.2.  Proposal and Transform Payloads\n   KINK directly uses the Proposal and
      Transform payloads with no\n   differences.  KINK, however, places additional
      relevance to the first\n   proposal and first transform of each conjugate for
      optimistic keying.\n"
    title: 5.2.  Proposal and Transform Payloads
  - contents:
    - "5.3.  Identification Payloads\n   The Identification payload carries information
      that is used to\n   identify the traffic that is to be protected by the SA that
      will be\n   established.  KINK restricts the ID types, which are defined in\n
      \  section 4.6.2.1 of [IPDOI], to the following values:\n      ID Type                  Value\n
      \     -------                  -----\n      ID_IPV4_ADDR               1\n      ID_IPV4_ADDR_SUBNET
      \       4\n      ID_IPV6_ADDR               5\n      ID_IPV6_ADDR_SUBNET        6\n
      \     ID_IPV4_ADDR_RANGE         7\n      ID_IPV6_ADDR_RANGE         8\n"
    title: 5.3.  Identification Payloads
  - contents:
    - "5.4.  Nonce Payloads\n   The Nonce payload contains random data that MUST be
      used in key\n   generation.  It MUST be sent by the initiating KINK peer, and
      MAY be\n   sent by the responding KINK peer.  See section 7 for the discussion\n
      \  of its use in key generation.\n"
    title: 5.4.  Nonce Payloads
  - contents:
    - "5.5.  Notify Payloads\n   Notify payloads are used to transmit several informational
      data, such\n   as error conditions and state transitions to a peer.  For example,\n
      \  notification information transmit can be error messages specifying\n   why
      an SA could not be established.  It can also be status data that\n   a process
      managing an SA database wishes to communicate with a peer\n   process.\n   Types
      in the range 0 - 16383 are intended for reporting errors\n   [ISAKMP].  An implementation
      receiving a type in this range that it\n   does not recognize in a response
      MUST assume that the corresponding\n   request has failed entirely.  Unrecognized
      error types in a request\n   and status types in a request or response MUST
      be ignored, and they\n   SHOULD be logged.  Notify payloads with status types
      MAY be added to\n   any message and MUST be ignored if not recognized.  They
      are intended\n   to indicate capabilities, and as part of SA negotiation are
      used to\n   negotiate non-cryptographic parameters.\n   The table below lists
      the Notification messages and their\n   corresponding values.  PAYLOAD-MALFORMED
      denotes some error types\n   defined by [ISAKMP].  Hence INVALID-PROTOCOL-ID,
      for example, is not\n   used in this document.  INVALID-MAJOR-VERSION and INVALID-MINOR-\n
      \  VERSION are not used because KINK_BADQMVERS is used to tell the\n   initiator
      that the version of IKE is not supported.\n   NOTIFY MESSAGES - ERROR TYPES
      \          Value\n   -----------------------------           -----\n   INVALID-PAYLOAD-TYPE
      \                     1\n      Sent if the ISAKMP payload type is not recognized.
      \ It is also\n      sent when the KE payload is not supported by the responder.\n
      \     Notification Data MUST contains the one-octet payload type.\n   INVALID-SPI
      \                             11\n      Sent if the responder has an SPI indicated
      by the initiator in\n      case of CREATE flow, or if the responder does not
      have an SPI\n      indicated by the initiator in case of DELETE flow.\n   NO-PROPOSAL-CHOSEN
      \                      14\n      Sent if none of the proposals in the SA payload
      was\n      acceptable.\n   PAYLOAD-MALFORMED                        16\n      Sent
      if the KINK_ISAKMP payload received was invalid because\n      some type, length,
      or value was out of range.  It is also sent\n      when the request was rejected
      for reason that was not matched\n      with other error types.\n"
    title: 5.5.  Notify Payloads
  - contents:
    - "5.6.  Delete Payloads\n   KINK directly uses ISAKMP Delete payloads with no
      changes.\n"
    title: 5.6.  Delete Payloads
  - contents:
    - "5.7.  KE Payloads\n   IKE requires that perfect forward secrecy (PFS) be supported
      through\n   the use of the KE payload.  KINK retains the ability to use PFS,
      but\n   relaxes the requirement from must implement to SHOULD implement.  The\n
      \  reasons are described in the Security Considerations section.\n"
    title: 5.7.  KE Payloads
  title: 5.  Differences from IKE Quick Mode
- contents:
  - "6.  Message Construction and Constraints for IPsec DOI\n   All commands, responses,
    and acknowledgements are bound together by\n   the XID field of the message header.
    \ The XID is normally a\n   monotonically incrementing field, and is used by the
    initiator to\n   differentiate between outstanding requests to a responder.  The
    XID\n   field does not provide replay protection as that functionality is\n   provided
    by the Kerberos mechanisms.  In addition, commands and\n   responses MUST use
    a cryptographic checksum over the entire message\n   if the two peers share a
    key via a ticket exchange.\n   In all cases in this section, if a message contains
    a KINK_AP_REQ or\n   KINK_AP_REP payload, other KINK payloads MAY be encapsulated
    in a\n   KINK_ENCRYPT payload.\n"
  - contents:
    - "6.1.  REPLY Message\n   The REPLY message is a generic reply that MUST contain
      either a\n   KINK_AP_REP, a KINK_KRB_ERROR, or a KINK_ERROR payload.  REPLY\n
      \  messages MAY contain additional DOI-specific payloads such as ISAKMP\n   payloads
      that are defined in the following sections.\n"
    title: 6.1.  REPLY Message
  - contents:
    - "6.2.  ACK Message\n   ACKs are sent only when the ACKREQ bit is set in a REPLY
      message.  An\n   ACK message MUST contain an AP-REQ payload and no other payload.\n"
    title: 6.2.  ACK Message
  - contents:
    - "6.3.  CREATE Message\n   This message initiates an establishment of new security\n
      \  association(s).  The CREATE message must contain an AP-REQ payload\n   and
      any DOI-specific payloads.\n   CREATE KINK Header\n     KINK_AP_REQ\n     [KINK_ENCRYPT]\n
      \       KINK_ISAKMP payloads\n            SA Payload\n                 Proposal
      Payloads\n                      Transform Payloads\n            Nonce Payload
      (Ni)\n            [KE]\n            [IDci, IDcr]\n            [Notification
      Payloads]\n   Replies are of the following forms:\n   REPLY KINK Header\n     KINK_AP_REP\n
      \    [KINK_ENCRYPT]\n        KINK_ISAKMP payloads\n            SA Payload\n
      \                Proposal Payloads\n                      Transform Payload\n
      \           [Nonce Payload (Nr)]\n            [KE]\n            [IDci, IDcr]\n
      \           [Notification Payloads]\n   Note that there MUST be at least a single
      proposal payload and a\n   single transform payload in REPLY messages.  There
      will be multiple\n   proposal payloads only when an SA bundle is negotiated.
      \ Also: unlike\n   IKE, the Nonce payload Nr is not required, and if it exists,
      an\n   acknowledgement must be requested to indicate that the initiator's\n
      \  outgoing SAs must be modified.  If any of the first proposals are not\n   chosen
      by the recipient, it SHOULD include the Nonce payload.\n   KINK, like IKE, allows
      the creation of many SAs in one create\n   command.  If any of the optimistic
      proposals are not chosen by the\n   responder, it MUST request an ACK.\n   If
      an IPsec DOI-specific error is encountered, the responder must\n   reply with
      a Notify payload describing the error:\n   REPLY KINK Header\n     KINK_AP_REP\n
      \    [KINK_ENCRYPT]\n        [KINK_ERROR]\n        KINK_ISAKMP payloads\n            [Notification
      Payloads]\n   If the responder finds a Kerberos error for which it can produce
      a\n   valid authenticator, the REPLY takes the following form:\n   REPLY KINK
      Header\n     KINK_AP_REP\n     [KINK_ENCRYPT]\n        KINK_KRB_ERROR\n   Finally,
      if the responder finds a Kerberos or KINK type of error for\n   which it cannot
      create an AP-REP, it MUST reply with a lone\n   KINK_KRB_ERROR or KINK_ERROR
      payload:\n   REPLY KINK Header\n     [KINK_KRB_ERROR]\n     [KINK_ERROR]\n"
    title: 6.3.  CREATE Message
  - contents:
    - "6.4.  DELETE Message\n   This message indicates that the sending peer has deleted
      or will\n   shortly delete Security Association(s) with the other peer.\n   DELETE
      KINK Header\n     KINK_AP_REQ\n     [KINK_ENCRYPT]\n        KINK_ISAKMP payloads\n
      \           Delete Payloads\n            [Notification Payloads]\n   There are
      three forms of replies for a DELETE.  The normal form is:\n   REPLY KINK Header\n
      \    KINK_AP_REP\n     [KINK_ENCRYPT]\n        [KINK_ERROR]\n        KINK_ISAKMP
      payloads\n            Delete Payloads\n            [Notification Payloads]\n
      \  If an IPsec DOI-specific error is encountered, the responder must\n   reply
      with a Notify payload describing the error:\n   REPLY KINK Header\n     KINK_AP_REP\n
      \    [KINK_ENCRYPT]\n        [KINK_ERROR]\n        KINK_ISAKMP payloads\n            [Notification
      Payloads]\n   If the responder finds a Kerberos error for which it can produce
      a\n   valid authenticator, the REPLY takes the following form:\n   REPLY KINK
      Header\n     KINK_AP_REP\n     [KINK_ENCRYPT]\n        KINK_KRB_ERROR\n   If
      the responder finds a KINK or Kerberos type of error, it MUST\n   reply with
      a lone KINK_KRB_ERROR or KINK_ERROR payload:\n   REPLY KINK Header\n     [KINK_KRB_ERROR]\n
      \    [KINK_ERROR]\n"
    title: 6.4.  DELETE Message
  - contents:
    - "6.5.  STATUS Message\n   The STATUS command is used in two ways:\n     1)  As
      a means to relay an ISAKMP Notification message.\n     2)  As a means of probing
      a peer whether its epoch has changed for\n         dead peer detection.\n   STATUS
      contains the following payloads:\n     KINK Header\n     KINK_AP_REQ\n     [[KINK_ENCRYPT]\n
      \       KINK_ISAKMP payload\n            [Notification Payloads]]\n   There
      are three forms of replies for a STATUS.  The normal form is:\n   REPLY KINK
      Header\n     KINK_AP_REP\n     [[KINK_ENCRYPT]\n        [KINK_ERROR]\n        KINK_ISAKMP
      payload\n            [Notification Payloads]]\n   If the responder finds a Kerberos
      error for which it can produce a\n   valid authenticator, the REPLY takes the
      following form:\n   REPLY KINK Header\n     KINK_AP_REP\n     [KINK_ENCRYPT]\n
      \       KINK_KRB_ERROR\n   If the responder finds a KINK or Kerberos type of
      error, it MUST\n   reply with a lone KINK_KRB_ERROR or KINK_ERROR payload:\n
      \  REPLY KINK Header\n     [KINK_KRB_ERROR]\n     [KINK_ERROR]\n"
    title: 6.5.  STATUS Message
  - contents:
    - "6.6.  GETTGT Message\n   A GETTGT command is only used to carry a Kerberos
      TGT and is not\n   related to SA management; therefore, it contains only KINK_TGT_REQ\n
      \  payload and does not contain any DOI-specific payload.\n   There are two
      forms of replies for a GETTGT.  In the normal form,\n   where the responder
      is allowed to return its TGT, the REPLY contains\n   KINK_TGT_REP payload.  If
      the responder is not allowed to return its\n   TGT, it MUST reply with a KINK_ERROR
      payload.\n"
    title: 6.6.  GETTGT Message
  title: 6.  Message Construction and Constraints for IPsec DOI
- contents:
  - "7.  ISAKMP Key Derivation\n   KINK uses the same key derivation mechanisms defined
    in section 5.5\n   of [IKE], which is:\n   KEYMAT = prf(SKEYID_d, [g(qm)^xy |]
    protocol | SPI | Ni_b [| Nr_b])\n   The following differences apply:\n     o    prf
    is the pseudo-random function corresponding to the session\n          key's etype.
    \ They are defined in [KCRYPTO].\n     o    SKEYID_d is the session key in the
    Kerberos service ticket\n          from the AP-REQ.  Note that subkeys are not
    used in KINK and\n          MUST be ignored if received.\n     o    Both Ni_b
    and Nr_b are the part of the Nonce payloads (Ni and\n          Nr, respectively)
    as described in section 3.2 of [IKE].  Nr_b\n          is optional, which means
    that Nr_b is treated as if a zero\n          length value was supplied when the
    responder's nonce (Nr) does\n          not exist.  When Nr exists, Nr_b MUST be
    included in the\n          calculation.\n   Note that g(qm)^xy refers to the keying
    material generated when KE\n   payloads are supplied using Diffie-Hellman key
    agreement.  This is\n   explained in section 5.5 of [IKE].\n   The rest of the
    key derivation (e.g., how to expand KEYMAT) follows\n   IKE.  How to use derived
    keying materials is up to each service\n   (e.g., section 4.5.2 of [IPSEC]).\n"
  title: 7.  ISAKMP Key Derivation
- contents:
  - "8.  Key Usage Numbers for Kerberos Key Derivation\n   Kerberos encrypt/decrypt
    functions and get_mic/verify_mic functions\n   require \"key usage numbers\".
    \ They are used to generate specific keys\n   for cryptographic operations so
    that different keys are used for\n   different purposes/objects.  KINK uses two
    usage numbers, listed\n   below.\n      Purpose                                   Usage
    number\n      -------                                   ------------\n      KINK_ENCRYPT
    payload (for encryption)      39\n      Cksum field (for checksum)                 40\n"
  title: 8.  Key Usage Numbers for Kerberos Key Derivation
- contents:
  - "9.  Transport Considerations\n   KINK uses UDP on port 910 to transport its messages.
    \ There is one\n   timer T which SHOULD take into consideration round-trip\n   considerations
    and MUST implement a truncated exponential back-off\n   mechanism.  The state
    machine is simple: any message that expects a\n   response MUST retransmit the
    request using timer T.  Since Kerberos\n   requires that messages be retransmitted
    with new times for replay\n   protection, the message MUST be re-created each
    time including the\n   checksum of the message.  Both commands and replies with
    the ACKREQ\n   bit set are kept on retransmit timers.  When a KINK initiator\n
    \  receives a REPLY with the ACKREQ bit set, it MUST retain the ability\n   to
    regenerate the ACK message for the transaction for a minimum of\n   its full retransmission
    timeout cycle or until it notices that\n   packets have arrived on the newly constructed
    SA, whichever comes\n   first.\n   When a KINK peer retransmits a message, it
    MUST create a new Kerberos\n   authenticator for the AP-REQ so that the peer can
    differentiate\n   between replays and dropped packets.  This results in a potential\n
    \  race condition when a retransmission occurs before an in-flight reply\n   is
    received/processed.  To counter this race condition, the\n   retransmitting party
    SHOULD keep a list of valid authenticators that\n   are outstanding for any particular
    transaction.\n   When a KINK peer retransmits a command, it MUST use the same
    ticket\n   within the retransmissions.  This is to avoid race conditions on\n
    \  using different keys, which result in different KEYMATs between an\n   initiator
    and a responder.  For this reason, (1) an initiator MUST\n   obtain a ticket whose
    lifetime is greater than the initiator's\n   maximum transaction time including
    timeouts, or (2) it MUST continue\n   to use the same ticket within a set of retransmissions,
    and iff it\n   receives an error (most likely KRB_AP_ERR_TKT_EXPIRED) from the\n
    \  responder, it starts a new transaction with a new ticket.\n"
  title: 9.  Transport Considerations
- contents:
  - "10.  Security Considerations\n   The principal names are the identities of the
    KINK services, but the\n   traffic protected by SAs are identified by DOI-specific
    selectors (IP\n   addresses, port numbers, etc.).  This may lead to a breakaway
    of\n   SA-protected data from authentication.  For example, if two different\n
    \  hosts claim that they have the same IP address, it may be impossible\n   to
    predict which principal's key protects the data.  Thus, an\n   implementation
    must take care for the binding between principal names\n   and the SA selectors.\n
    \  Sending errors without cryptographic protection must be handled very\n   carefully.
    \ There is a trade-off between wanting to be helpful in\n   diagnosing a problem
    and wanting to avoid being a dupe in a denial of\n   service attack.\n   KINK
    cobbles together and reuses many parts of both Kerberos and IKE,\n   the latter
    which in turn is cobbled together from many other memos.\n   As such, KINK inherits
    many of the weaknesses and considerations of\n   each of its components.  However,
    KINK uses only IKE phase 2 payloads\n   to create and delete SAs; the security
    considerations which pertain\n   to IKE phase 1 may be safely ignored.  However,
    being able to ignore\n   IKE's authentication phase necessarily means that KINK
    inherits all\n   of the security considerations of Kerberos authentication as
    outlined\n   in [KERBEROS].  For one, a KDC, like an Authentication,\n   Authorization,
    and Accounting (AAA) server, is a point of attack and\n   all that implies.  Much
    has been written about various shortcomings\n   and mitigations of Kerberos, and
    they should be evaluated for any\n   deployment.\n   KINK's use of Kerberos presents
    a couple of considerations.  First,\n   KINK explicitly expects that the KDC will
    provide adequate entropy\n   when it generates session keys.  Second, Kerberos
    is used as a user\n   authentication protocol with the possibility of dictionary
    attacks on\n   user passwords.  This memo does not describe a particular method
    to\n   avoid these pitfalls, but recommends that suitable randomly generated\n
    \  keys should be used for the service principals such as using the\n   -randomkey
    option with MIT's \"kadmin addprinc\" command as well as for\n   clients when
    that is practical.\n   Kerberos does not currently provide perfect forward secrecy
    in\n   general.  KINK with the KE payload can provide PFS for a service key\n
    \  from a Kerberos key, but the KE is not mandatory because of the\n   computational
    cost.  This is a trade-off and operators can choose the\n   PFS over the cost,
    and vice versa.  KINK itself should be secure from\n   offline analysis from compromised
    principal passphrases if PFS is\n   used, but from an overall system's standpoint,
    the existence of other\n   Kerberized services that do not provide PFS makes this
    a less than\n   optimal situation.\n"
  title: 10.  Security Considerations
- contents:
  - "11.  IANA Considerations\n   The IANA has assigned a well-known port number for
    KINK.\n   The IANA has created a new registry for KINK parameters, and has\n   registered
    the following identifiers.\n      KINK Message Types (section 4)\n      KINK Next
    Payload Types (section 4.2)\n      KINK Error Codes (section 4.2.8)\n   Changes
    and additions to this registry follow the policies described\n   below.  Their
    meanings are described in [BCP26].\n     o    Using the numbers in the \"Private
    Use\" range is Private Use.\n     o    Assignment from the \"RESERVED TO IANA\"
    range needs Standards\n          Action, or non-standards-track RFCs with Expert
    Review.\n          (Though the full specification may be a public and permanent\n
    \         document of a standards body other than IETF, an RFC referring\n          it
    is needed.)\n     o    Other change requires Standards Action.\n"
  title: 11.  IANA Considerations
- contents:
  - "12.  Forward Compatibility Considerations\n   KINK can accommodate future versions
    of Quick Mode through the use of\n   the version field in the ISAKMP payload as
    well as new domains of\n   interpretation.  In this memo, the only supported Quick
    Mode version\n   is 1.0, which corresponds to [IKE].  Likewise, the only DOI supported\n
    \  is the IPsec domain of interpretation [IPDOI].  New Quick Mode\n   versions
    and DOIs MUST be described in subsequent memos.\n   KINK implementations MUST
    reject ISAKMP versions that are greater\n   than the highest currently supported
    version with a KINK_BADQMVERS\n   error type.  A KINK implementation that receives
    a KINK_BADQMVERS\n   message SHOULD be capable of reverting back to version 1.0.\n"
  - contents:
    - "12.1.  New Versions of Quick Mode\n   The IPsec working group is defining the
      next-generation IKE protocol\n   [IKEv2], which does not use Quick Mode, but
      it is similar to the one\n   in IKEv1.  The difference between the two is summarized
      in Appendix A\n   of [IKEv2].  Each of them must be considered in order to use
      IKEv2\n   with KINK.\n"
    title: 12.1.  New Versions of Quick Mode
  - contents:
    - "12.2.  New DOI\n   The KINK message header contains a field called \"Domain
      of\n   Interpretation (DOI)\" to allow other domains of interpretation to use\n
      \  KINK as a secure transport mechanism for keying.\n   As one example of a
      new DOI, the MSEC working group defined the Group\n   Domain of Interpretation
      [GDOI], which defines a few new messages,\n   which look like ISAKMP messages,
      but are not defined in ISAKMP.\n   In order to carry GDOI messages in KINK,
      the DOI field in the KINK\n   header would indicate that GDOI is being used,
      instead of IPSEC-DOI,\n   and the KINK_ISAKMP payload would contain the payloads
      defined in the\n   GDOI document rather than the payloads used by [IKE] Quick
      Mode.  The\n   version number in the KINK_ISAKMP header is related to the DOI
      in the\n   KINK header, so a maj.min version 1.0 under DOI GDOI is different\n
      \  from a maj.min version 1.0 under DOI IPSEC-DOI.\n"
    title: 12.2.  New DOI
  title: 12.  Forward Compatibility Considerations
- contents:
  - "13.  Related Work\n   The IPsec working group has defined a number of protocols
    that\n   provide the ability to create and maintain cryptographically secure\n
    \  SAs at layer three (i.e., the IP layer).  This effort has produced\n   two
    distinct protocols:\n     o    a mechanism for encrypting and authenticating IP
    datagram\n          payloads that assumes a shared secret between the sender and\n
    \         receiver\n     o    a mechanism for IPsec peers to perform mutual authentication\n
    \         and exchange keying material\n   The IPsec working group has defined
    a peer-to-peer authentication and\n   keying mechanism, IKE (RFC 2409).  One of
    the drawbacks of a peer-\n   to-peer protocol is that each peer must know and
    implement a site's\n   security policy, which in practice can be quite complex.
    \ In\n   addition, the peer-to-peer nature of IKE requires the use of Diffie-\n
    \  Hellman (DH) to establish a shared secret.  DH, unfortunately, is\n   computationally
    quite expensive and prone to denial of service\n   attacks.  IKE also relies on
    X.509 certificates to realize scalable\n   authentication of peers.  Digital signatures
    are also computationally\n   expensive, and certificate-based trust models are
    difficult to deploy\n   in practice.  While IKE does allow for a pre-shared key,
    key\n   distribution is required between all peers -- an O(n^2) problem --\n   which
    is problematic for large deployments.\n"
  title: 13.  Related Work
- contents:
  - "14.  Acknowledgements\n   Many have contributed to the KINK effort, including
    our working group\n   chairs Derek Atkins and Jonathan Trostle.  The original
    inspiration\n   came from CableLab's PacketCable effort, which defined a simplified\n
    \  version of Kerberized IPsec, including Sasha Medvinsky, Mike Froh,\n   and
    Matt Hur and David McGrew.  The inspiration for wholly reusing\n   IKE phase 2
    is the result of Tero Kivinen's document suggesting\n   grafting Kerberos authentication
    onto Quick Mode.\n"
  title: 14.  Acknowledgements
- contents:
  - '15.  References

    '
  - contents:
    - "15.1.  Normative References\n   [BCP26]       Narten, T. and H. Alvestrand,
      \"Guidelines for Writing\n                 an IANA Considerations Section in
      RFCs\", BCP 26, RFC\n                 2434, October 1998.\n   [IKE]         Harkins,
      D. and D. Carrel, \"The Internet Key Exchange\n                 (IKE)\", RFC
      2409, November 1998.\n   [IPDOI]       Piper, D., \"The Internet IP Security
      Domain of\n                 Interpretation for ISAKMP\", RFC 2407, November
      1998.\n   [IPSEC]       Kent, S. and K. Seo, \"Security Architecture for the\n
      \                Internet Protocol\", RFC 4301, December 2005.\n   [ISAKMP]
      \     Maughan,  D., Schertler, M., Schneider, M., and J.\n                 Turner,
      \"Internet Security Association and Key\n                 Management Protocol
      (ISAKMP)\", RFC 2408, November 1998.\n   [ISAKMP-REG]  IANA, \"Internet Security
      Association and Key Management\n                 Protocol (ISAKMP) Identifiers\",\n
      \                <http://www.iana.org/assignments/isakmp-registry>.\n   [KCRYPTO]
      \    Raeburn, K., \"Encryption and Checksum Specifications\n                 for
      Kerberos 5\", RFC 3961, February 2005.\n   [KERBEROS]    Neuman, C., Yu, T.,
      Hartman, S., and K. Raeburn, \"The\n                 Kerberos Network Authentication
      Service (V5)\", RFC\n                 4120, July 2005.\n   [RFC1964]     Linn,
      J., \"The Kerberos Version 5 GSS-API Mechanism\",\n                 RFC 1964,
      June 1996.\n   [RFC2119]     Bradner, S., \"Key words for use in RFCs to Indicate\n
      \                Requirement Levels\", BCP 14, RFC 2119, March 1997.\n"
    title: 15.1.  Normative References
  - contents:
    - "15.2.  Informative References\n   [GDOI]        Baugher, M., Weis, B., Hardjono,
      T., and H. Harney,\n                 \"The Group Domain of Interpretation\",
      RFC 3547, July\n                 2003.\n   [IKEv2]       Kaufman, C., \"Internet
      Key Exchange (IKEv2) Protocol\",\n                 RFC 4306, December 2005.\n
      \  [PKINIT]      Zhu, L. and B. Tung, \"Public Key Cryptography for\n                 Initial
      Authentication in Kerberos\", Work in Progress,\n                 February 2006.\n
      \  [REQ4KINK]    Thomas, M., \"Requirements for Kerberized Internet\n                 Negotiation
      of Keys\", RFC 3129, June 2001.\n   [RFC793]      Postel, J., \"Transmission
      Control Protocol\", STD 7, RFC\n                 793, September 1981.\n   [RFC2743]
      \    Linn, J., \"Generic Security Service Application Program\n                 Interface
      Version 2, Update 1\", RFC 2743, January 2000.\n"
    title: 15.2.  Informative References
  title: 15.  References
- contents:
  - "Authors' Addresses\n   Shoichi Sakane\n   Yokogawa Electric Corporation\n   2-9-32
    Nakacho, Musashino-shi,\n   Tokyo 180-8750 Japan\n   EMail: Shouichi.Sakane@jp.yokogawa.com\n
    \  Ken'ichi Kamada\n   Yokogawa Electric Corporation\n   2-9-32 Nakacho, Musashino-shi,\n
    \  Tokyo 180-8750 Japan\n   EMail: Ken-ichi.Kamada@jp.yokogawa.com\n   Michael
    Thomas\n   Cisco Systems\n   170 West Tasman Drive\n   San Jose, CA 95134\n   EMail:
    mat@cisco.com\n   Jan Vilhuber\n   Cisco Systems\n   170 West Tasman Drive\n   San
    Jose, CA 95134\n   EMail: vilhuber@cisco.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n
    \  Administrative Support Activity (IASA).\n"
  title: Acknowledgement
