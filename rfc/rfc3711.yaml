- contents:
  - '             The Secure Real-time Transport Protocol (SRTP)

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes the Secure Real-time Transport Protocol\n
    \  (SRTP), a profile of the Real-time Transport Protocol (RTP), which\n   can
    provide confidentiality, message authentication, and replay\n   protection to
    the RTP traffic and to the control traffic for RTP, the\n   Real-time Transport
    Control Protocol (RTCP).\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n       1.1.  Notational Conventions . . . . . . . . . . . . .
    . . . .  3\n   2.  Goals and Features . . . . . . . . . . . . . . . . . . . .
    . .  4\n       2.1.  Features . . . . . . . . . . . . . . . . . . . . . . . .
    \ 5\n   3.  SRTP Framework . . . . . . . . . . . . . . . . . . . . . . . .  5\n
    \      3.1.  Secure RTP . . . . . . . . . . . . . . . . . . . . . . .  6\n       3.2.
    \ SRTP Cryptographic Contexts. . . . . . . . . . . . . . .  7\n             3.2.1.
    \ Transform-independent parameters . . . . . . . .  8\n             3.2.2.  Transform-dependent
    parameters . . . . . . . . . 10\n             3.2.3.  Mapping SRTP Packets to
    Cryptographic Contexts . 10\n       3.3.  SRTP Packet Processing . . . . . . .
    . . . . . . . . . . 11\n             3.3.1.  Packet Index Determination, and ROC,
    s_l Update. 13\n             3.3.2.  Replay Protection. . . . . . . . . . . .
    . . . . 15\n      3.4.  Secure RTCP . . . . . . . . . . . . . . . . . . . . .
    . . 15\n   4.  Pre-Defined Cryptographic Transforms . . . . . . . . . . . . .
    19\n       4.1.  Encryption . . . . . . . . . . . . . . . . . . . . . . . 19\n
    \            4.1.1.  AES in Counter Mode. . . . . . . . . . . . . . . 21\n             4.1.2.
    \ AES in f8-mode . . . . . . . . . . . . . . . . . 22\n             4.1.3.  NULL
    Cipher. . . . . . . . . . . . . . . . . . . 25\n       4.2.  Message Authentication
    and Integrity . . . . . . . . . . 25\n             4.2.1.  HMAC-SHA1. . . . .
    . . . . . . . . . . . . . . . 25\n       4.3.  Key Derivation . . . . . . . .
    . . . . . . . . . . . . . 26\n             4.3.1.  Key Derivation Algorithm .
    . . . . . . . . . . . 26\n             4.3.2.  SRTCP Key Derivation . . . . .
    . . . . . . . . . 28\n             4.3.3.  AES-CM PRF . . . . . . . . . . . .
    . . . . . . . 28\n   5.  Default and mandatory-to-implement Transforms. . . .
    . . . . . 28\n       5.1.  Encryption: AES-CM and NULL. . . . . . . . . . . .
    . . . 29\n       5.2.  Message Authentication/Integrity: HMAC-SHA1. . . . . .
    . 29\n       5.3.  Key Derivation: AES-CM PRF . . . . . . . . . . . . . . . 29\n
    \  6.  Adding SRTP Transforms . . . . . . . . . . . . . . . . . . . . 29\n   7.
    \ Rationale. . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n       7.1.
    \ Key derivation . . . . . . . . . . . . . . . . . . . . . 30\n       7.2.  Salting
    key. . . . . . . . . . . . . . . . . . . . . . . 30\n       7.3.  Message Integrity
    from Universal Hashing . . . . . . . . 31\n       7.4.  Data Origin Authentication
    Considerations. . . . . . . . 31\n       7.5.  Short and Zero-length Message Authentication
    . . . . . . 32\n   8.  Key Management Considerations. . . . . . . . . . . . .
    . . . . 33\n       8.1.  Re-keying  . . . . . . . . . . . . . . . . . . . . .
    . . 34\n             8.1.1.  Use of the <From, To> for re-keying. . . . . . .
    34\n       8.2.  Key Management parameters. . . . . . . . . . . . . . . . 35\n
    \  9.  Security Considerations. . . . . . . . . . . . . . . . . . . . 37\n       9.1.
    \ SSRC collision and two-time pad. . . . . . . . . . . . . 37\n       9.2.  Key
    Usage. . . . . . . . . . . . . . . . . . . . . . . . 38\n       9.3.  Confidentiality
    of the RTP Payload . . . . . . . . . . . 39\n       9.4.  Confidentiality of the
    RTP Header. . . . . . . . . . . . 40\n       9.5.  Integrity of the RTP payload
    and header. . . . . . . . . 40\n             9.5.1. Risks of Weak or Null Message
    Authentication. . . 42\n             9.5.2.  Implicit Header Authentication .
    . . . . . . . . 43\n   10.  Interaction with Forward Error Correction mechanisms.
    . . . . 43\n   11.  Scenarios . . . . . . . . . . . . . . . . . . . . . . . .
    . . 43\n       11.1. Unicast. . . . . . . . . . . . . . . . . . . . . . . . .
    43\n       11.2. Multicast (one sender) . . . . . . . . . . . . . . . . . 44\n
    \      11.3. Re-keying and access control . . . . . . . . . . . . . . 45\n       11.4.
    Summary of basic scenarios . . . . . . . . . . . . . . . 46\n   12. IANA Considerations.
    . . . . . . . . . . . . . . . . . . . . . 46\n   13. Acknowledgements . . . .
    . . . . . . . . . . . . . . . . . . . 47\n   14. References . . . . . . . . .
    . . . . . . . . . . . . . . . . . 47\n       14.1. Normative References . . .
    . . . . . . . . . . . . . . . 47\n       14.2. Informative References . . . .
    . . . . . . . . . . . . . 48\n   Appendix A: Pseudocode for Index Determination
    . . . . . . . . . . 51\n   Appendix B: Test Vectors . . . . . . . . . . . . .
    . . . . . . . . 51\n       B.1.  AES-f8 Test Vectors. . . . . . . . . . . . .
    . . . . . . 51\n       B.2.  AES-CM Test Vectors. . . . . . . . . . . . . . .
    . . . . 52\n       B.3.  Key Derivation Test Vectors. . . . . . . . . . . . .
    . . 53\n   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . .
    55\n   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 56\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document describes the Secure Real-time Transport Protocol\n
    \  (SRTP), a profile of the Real-time Transport Protocol (RTP), which\n   can
    provide confidentiality, message authentication, and replay\n   protection to
    the RTP traffic and to the control traffic for RTP,\n   RTCP (the Real-time Transport
    Control Protocol) [RFC3350].\n   SRTP provides a framework for encryption and
    message authentication\n   of RTP and RTCP streams (Section 3).  SRTP defines
    a set of default\n   cryptographic transforms (Sections 4 and 5), and it allows
    new\n   transforms to be introduced in the future (Section 6).  With\n   appropriate
    key management (Sections 7 and 8), SRTP is secure\n   (Sections 9) for unicast
    and multicast RTP applications (Section 11).\n   SRTP can achieve high throughput
    and low packet expansion.  SRTP\n   proves to be a suitable protection for heterogeneous
    environments\n   (mix of wired and wireless networks).  To get such features,
    default\n   transforms are described, based on an additive stream cipher for\n
    \  encryption, a keyed-hash based function for message authentication,\n   and
    an \"implicit\" index for sequencing/synchronization based on the\n   RTP sequence
    number for SRTP and an index number for Secure RTCP\n   (SRTCP).\n"
  - contents:
    - "1.1.  Notational Conventions\n   The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].  The\n   terminology conforms to [RFC2828] with the following exception.
      \ For\n   simplicity we use the term \"random\" throughout the document to denote\n
      \  randomly or pseudo-randomly generated values.  Large amounts of\n   random
      bits may be difficult to obtain, and for the security of SRTP,\n   pseudo-randomness
      is sufficient [RFC1750].\n   By convention, the adopted representation is the
      network byte order,\n   i.e., the left most bit (octet) is the most significant
      one.  By XOR\n   we mean bitwise addition modulo 2 of binary strings, and ||
      denotes\n   concatenation.  In other words, if C = A || B, then the most\n   significant
      bits of C are the bits of A, and the least significant\n   bits of C equal the
      bits of B.  Hexadecimal numbers are prefixed by\n   0x.\n   The word \"encryption\"
      includes also use of the NULL algorithm (which\n   in practice does leave the
      data in the clear).\n   With slight abuse of notation, we use the terms \"message\n
      \  authentication\" and \"authentication tag\" as is common practice, even\n
      \  though in some circumstances, e.g., group communication, the service\n   provided
      is actually only integrity protection and not data origin\n   authentication.\n"
    title: 1.1.  Notational Conventions
  title: 1.  Introduction
- contents:
  - "2.  Goals and Features\n   The security goals for SRTP are to ensure:\n   *  the
    confidentiality of the RTP and RTCP payloads, and\n   *  the integrity of the
    entire RTP and RTCP packets, together with\n      protection against replayed
    packets.\n   These security services are optional and independent from each other,\n
    \  except that SRTCP integrity protection is mandatory (malicious or\n   erroneous
    alteration of RTCP messages could otherwise disrupt the\n   processing of the
    RTP stream).\n   Other, functional, goals for the protocol are:\n   *  a framework
    that permits upgrading with new cryptographic\n      transforms,\n   *  low bandwidth
    cost, i.e., a framework preserving RTP header\n      compression efficiency,\n
    \  and, asserted by the pre-defined transforms:\n   *  a low computational cost,\n
    \  *  a small footprint (i.e., small code size and data memory for\n      keying
    information and replay lists),\n   *  limited packet expansion to support the
    bandwidth economy goal,\n   *  independence from the underlying transport, network,
    and physical\n      layers used by RTP, in particular high tolerance to packet
    loss\n      and re-ordering.\n   These properties ensure that SRTP is a suitable
    protection scheme for\n   RTP/RTCP in both wired and wireless scenarios.\n"
  - contents:
    - "2.1.  Features\n   Besides the above mentioned direct goals, SRTP provides
      for some\n   additional features.  They have been introduced to lighten the
      burden\n   on key management and to further increase security.  They include:\n
      \  *  A single \"master key\" can provide keying material for\n      confidentiality
      and integrity protection, both for the SRTP stream\n      and the corresponding
      SRTCP stream.  This is achieved with a key\n      derivation function (see Section
      4.3), providing \"session keys\"\n      for the respective security primitive,
      securely derived from the\n      master key.\n   *  In addition, the key derivation
      can be configured to periodically\n      refresh the session keys, which limits
      the amount of ciphertext\n      produced by a fixed key, available for an adversary
      to\n      cryptanalyze.\n   *  \"Salting keys\" are used to protect against
      pre-computation and\n      time-memory tradeoff attacks [MF00] [BS00].\n   Detailed
      rationale for these features can be found in Section 7.\n"
    title: 2.1.  Features
  title: 2.  Goals and Features
- contents:
  - "3.  SRTP Framework\n   RTP is the Real-time Transport Protocol [RFC3550].  We
    define SRTP as\n   a profile of RTP.  This profile is an extension to the RTP\n
    \  Audio/Video Profile [RFC3551].  Except where explicitly noted, all\n   aspects
    of that profile apply, with the addition of the SRTP security\n   features.  Conceptually,
    we consider SRTP to be a \"bump in the stack\"\n   implementation which resides
    between the RTP application and the\n   transport layer.  SRTP intercepts RTP
    packets and then forwards an\n   equivalent SRTP packet on the sending side, and
    intercepts SRTP\n   packets and passes an equivalent RTP packet up the stack on
    the\n   receiving side.\n   Secure RTCP (SRTCP) provides the same security services
    to RTCP as\n   SRTP does to RTP.  SRTCP message authentication is MANDATORY and\n
    \  thereby protects the RTCP fields to keep track of membership, provide\n   feedback
    to RTP senders, or maintain packet sequence counters.  SRTCP\n   is described
    in Section 3.4.\n"
  - contents:
    - "3.1.  Secure RTP\n      The format of an SRTP packet is illustrated in Figure
      1.\n        0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n
      \    |V=2|P|X|  CC   |M|     PT      |       sequence number         | |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |\n     |                           timestamp                           | |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n     |
      \          synchronization source (SSRC) identifier            | |\n     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      |\n     |            contributing source (CSRC) identifiers             | |\n
      \    |                               ....                            | |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |\n     |                   RTP extension (OPTIONAL)                    | |\n
      \  +>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n   |
      |                          payload  ...                         | |\n   | |
      \                              +-------------------------------+ |\n   | |                               |
      RTP padding   | RTP pad count | |\n   +>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n
      \  | ~                     SRTP MKI (OPTIONAL)                       ~ |\n   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n   | :
      \                authentication tag (RECOMMENDED)              : |\n   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |\n   |                                                                   |\n
      \  +- Encrypted Portion*                      Authenticated Portion ---+\n   Figure
      1.  The format of an SRTP packet.  *Encrypted Portion is the\n   same size as
      the plaintext for the Section 4 pre-defined transforms.\n   The \"Encrypted
      Portion\" of an SRTP packet consists of the encryption\n   of the RTP payload
      (including RTP padding when present) of the\n   equivalent RTP packet.  The
      Encrypted Portion MAY be the exact size\n   of the plaintext or MAY be larger.
      \ Figure 1 shows the RTP payload\n   including any possible padding for RTP
      [RFC3550].\n   None of the pre-defined encryption transforms uses any padding;
      for\n   these, the RTP and SRTP payload sizes match exactly.  New transforms\n
      \  added to SRTP (following Section 6) may require padding, and may\n   hence
      produce larger payloads.  RTP provides its own padding format\n   (as seen in
      Fig. 1), which due to the padding indicator in the RTP\n   header has merits
      in terms of compactness relative to paddings using\n   prefix-free codes.  This
      RTP padding SHALL be the default method for\n   transforms requiring padding.
      \ Transforms MAY specify other padding\n   methods, and MUST then specify the
      amount, format, and processing of\n   their padding.  It is important to note
      that encryption transforms\n   that use padding are vulnerable to subtle attacks,
      especially when\n   message authentication is not used [V02].  Each specification
      for a\n   new encryption transform needs to carefully consider and describe
      the\n   security implications of the padding that it uses.  Message\n   authentication
      codes define their own padding, so this default does\n   not apply to authentication
      transforms.\n   The OPTIONAL MKI and the RECOMMENDED authentication tag are
      the only\n   fields defined by SRTP that are not in RTP.  Only 8-bit alignment
      is\n   assumed.\n      MKI (Master Key Identifier): configurable length, OPTIONAL.
      \ The\n              MKI is defined, signaled, and used by key management.  The\n
      \             MKI identifies the master key from which the session\n              key(s)
      were derived that authenticate and/or encrypt the\n              particular
      packet.  Note that the MKI SHALL NOT identify\n              the SRTP cryptographic
      context, which is identified\n              according to Section 3.2.3.  The
      MKI MAY be used by key\n              management for the purposes of re-keying,
      identifying a\n              particular master key within the cryptographic
      context\n              (Section 3.2.1).\n      Authentication tag: configurable
      length, RECOMMENDED.  The\n              authentication tag is used to carry
      message authentication\n              data.  The Authenticated Portion of an
      SRTP packet\n              consists of the RTP header followed by the Encrypted\n
      \             Portion of the SRTP packet.  Thus, if both encryption and\n              authentication
      are applied, encryption SHALL be applied\n              before authentication
      on the sender side and conversely on\n              the receiver side.  The
      authentication tag provides\n              authentication of the RTP header
      and payload, and it\n              indirectly provides replay protection by
      authenticating\n              the sequence number.  Note that the MKI is not
      integrity\n              protected as this does not provide any extra protection.\n"
    title: 3.1.  Secure RTP
  - contents:
    - "3.2.  SRTP Cryptographic Contexts\n   Each SRTP stream requires the sender
      and receiver to maintain\n   cryptographic state information.  This information
      is called the\n   \"cryptographic context\".\n   SRTP uses two types of keys:
      session keys and master keys.  By a\n   \"session key\", we mean a key which
      is used directly in a\n   cryptographic transform (e.g., encryption or message
      authentication),\n   and by a \"master key\", we mean a random bit string (given
      by the key\n   management protocol) from which session keys are derived in a\n
      \  cryptographically secure way.  The master key(s) and other parameters\n   in
      the cryptographic context are provided by key management\n   mechanisms external
      to SRTP, see Section 8.\n"
    - contents:
      - "3.2.1.  Transform-independent parameters\n   Transform-independent parameters
        are present in the cryptographic\n   context independently of the particular
        encryption or authentication\n   transforms that are used.  The transform-independent
        parameters of\n   the cryptographic context for SRTP consist of:\n   *  a
        32-bit unsigned rollover counter (ROC), which records how many\n      times
        the 16-bit RTP sequence number has been reset to zero after\n      passing
        through 65,535.  Unlike the sequence number (SEQ), which\n      SRTP extracts
        from the RTP packet header, the ROC is maintained by\n      SRTP as described
        in Section 3.3.1.\n      We define the index of the SRTP packet corresponding
        to a given\n      ROC and RTP sequence number to be the 48-bit quantity\n
        \           i = 2^16 * ROC + SEQ.\n   *  for the receiver only, a 16-bit sequence
        number s_l, which can be\n      thought of as the highest received RTP sequence
        number (see\n      Section 3.3.1 for its handling), which SHOULD be authenticated\n
        \     since message authentication is RECOMMENDED,\n   *  an identifier for
        the encryption algorithm, i.e., the cipher and\n      its mode of operation,\n
        \  *  an identifier for the message authentication algorithm,\n   *  a replay
        list, maintained by the receiver only (when\n      authentication and replay
        protection are provided), containing\n      indices of recently received and
        authenticated SRTP packets,\n   *  an MKI indicator (0/1) as to whether an
        MKI is present in SRTP and\n      SRTCP packets,\n   *  if the MKI indicator
        is set to one, the length (in octets) of the\n      MKI field, and (for the
        sender) the actual value of the currently\n      active MKI (the value of
        the MKI indicator and length MUST be kept\n      fixed for the lifetime of
        the context),\n   *  the master key(s), which MUST be random and kept secret,\n
        \  *  for each master key, there is a counter of the number of SRTP\n      packets
        that have been processed (sent) with that master key\n      (essential for
        security, see Sections 3.3.1 and 9),\n   *  non-negative integers n_e, and
        n_a, determining the length of the\n      session keys for encryption, and
        message authentication.\n   In addition, for each master key, an SRTP stream
        MAY use the\n   following associated values:\n   *  a master salt, to be used
        in the key derivation of session keys.\n      This value, when used, MUST
        be random, but MAY be public.  Use of\n      master salt is strongly RECOMMENDED,
        see Section 9.2.  A \"NULL\"\n      salt is treated as 00...0.\n   *  an integer
        in the set {1,2,4,...,2^24}, the \"key_derivation_rate\",\n      where an
        unspecified value is treated as zero.  The constraint to\n      be a power
        of 2 simplifies the session-key derivation\n      implementation, see Section
        4.3.\n   *  an MKI value,\n   *  <From, To> values, specifying the lifetime
        for a master key,\n      expressed in terms of the two 48-bit index values
        inside whose\n      range (including the range end-points) the master key
        is valid.\n      For the use of <From, To>, see Section 8.1.1.  <From, To>
        is an\n      alternative to the MKI and assumes that a master key is in one-\n
        \     to-one correspondence with the SRTP session key on which the\n      <From,
        To> range is defined.\n   SRTCP SHALL by default share the crypto context
        with SRTP, except:\n   *  no rollover counter and s_l-value need to be maintained
        as the\n      RTCP index is explicitly carried in each SRTCP packet,\n   *
        \ a separate replay list is maintained (when replay protection is\n      provided),\n
        \  *  SRTCP maintains a separate counter for its master key (even if the\n
        \     master key is the same as that for SRTP, see below), as a means to\n
        \     maintain a count of the number of SRTCP packets that have been\n      processed
        with that key.\n   Note in particular that the master key(s) MAY be shared
        between SRTP\n   and the corresponding SRTCP, if the pre-defined transforms
        (including\n   the key derivation) are used but the session key(s) MUST NOT
        be so\n   shared.\n   In addition, there can be cases (see Sections 8 and
        9.1) where\n   several SRTP streams within a given RTP session, identified
        by their\n   synchronization source (SSRCs, which is part of the RTP header),\n
        \  share most of the crypto context parameters (including possibly\n   master
        and session keys).  In such cases, just as in the normal\n   SRTP/SRTCP parameter
        sharing above, separate replay lists and packet\n   counters for each stream
        (SSRC) MUST still be maintained.  Also,\n   separate SRTP indices MUST then
        be maintained.\n   A summary of parameters, pre-defined transforms, and default
        values\n   for the above parameters (and other SRTP parameters) can be found
        in\n   Sections 5 and 8.2.\n"
      title: 3.2.1.  Transform-independent parameters
    - contents:
      - "3.2.2.  Transform-dependent parameters\n   All encryption, authentication/integrity,
        and key derivation\n   parameters are defined in the transforms section (Section
        4).\n   Typical examples of such parameters are block size of ciphers,\n   session
        keys, data for the Initialization Vector (IV) formation, etc.\n   Future SRTP
        transform specifications MUST include a section to list\n   the additional
        cryptographic context's parameters for that transform,\n   if any.\n"
      title: 3.2.2.  Transform-dependent parameters
    - contents:
      - "3.2.3.  Mapping SRTP Packets to Cryptographic Contexts\n   Recall that an
        RTP session for each participant is defined [RFC3550]\n   by a pair of destination
        transport addresses (one network address\n   plus a port pair for RTP and
        RTCP), and that a multimedia session is\n   defined as a collection of RTP
        sessions.  For example, a particular\n   multimedia session could include
        an audio RTP session, a video RTP\n   session, and a text RTP session.\n   A
        cryptographic context SHALL be uniquely identified by the triplet\n   context
        identifier:\n   context id = <SSRC, destination network address, destination\n
        \  transport port number>\n   where the destination network address and the
        destination transport\n   port are the ones in the SRTP packet.  It is assumed
        that, when\n   presented with this information, the key management returns
        a context\n   with the information as described in Section 3.2.\n   As noted
        above, SRTP and SRTCP by default share the bulk of the\n   parameters in the
        cryptographic context.  Thus, retrieving the crypto\n   context parameters
        for an SRTCP stream in practice may imply a\n   binding to the correspondent
        SRTP crypto context.  It is up to the\n   implementation to assure such binding,
        since the RTCP port may not be\n   directly deducible from the RTP port only.
        \ Alternatively, the key\n   management may choose to provide separate SRTP-
        and SRTCP- contexts,\n   duplicating the common parameters (such as master
        key(s)).  The\n   latter approach then also enables SRTP and SRTCP to use,
        e.g.,\n   distinct transforms, if so desired.  Similar considerations arise\n
        \  when multiple SRTP streams, forming part of one single RTP session,\n   share
        keys and other parameters.\n   If no valid context can be found for a packet
        corresponding to a\n   certain context identifier, that packet MUST be discarded.\n"
      title: 3.2.3.  Mapping SRTP Packets to Cryptographic Contexts
    title: 3.2.  SRTP Cryptographic Contexts
  - contents:
    - "3.3.  SRTP Packet Processing\n   The following applies to SRTP.  SRTCP is described
      in Section 3.4.\n   Assuming initialization of the cryptographic context(s)
      has taken\n   place via key management, the sender SHALL do the following to\n
      \  construct an SRTP packet:\n   1. Determine which cryptographic context to
      use as described in\n      Section 3.2.3.\n   2. Determine the index of the
      SRTP packet using the rollover counter,\n      the highest sequence number in
      the cryptographic context, and the\n      sequence number in the RTP packet,
      as described in Section 3.3.1.\n   3. Determine the master key and master salt.
      \ This is done using the\n      index determined in the previous step or the
      current MKI in the\n      cryptographic context, according to Section 8.1.\n
      \  4. Determine the session keys and session salt (if they are used by\n      the
      transform) as described in Section 4.3, using master key,\n      master salt,
      key_derivation_rate, and session key-lengths in the\n      cryptographic context
      with the index, determined in Steps 2 and 3.\n   5. Encrypt the RTP payload
      to produce the Encrypted Portion of the\n      packet (see Section 4.1, for
      the defined ciphers).  This step uses\n      the encryption algorithm indicated
      in the cryptographic context,\n      the session encryption key and the session
      salt (if used) found in\n      Step 4 together with the index found in Step
      2.\n   6. If the MKI indicator is set to one, append the MKI to the packet.\n
      \  7. For message authentication, compute the authentication tag for the\n      Authenticated
      Portion of the packet, as described in Section 4.2.\n      This step uses the
      current rollover counter, the authentication\n      algorithm indicated in the
      cryptographic context, and the session\n      authentication key found in Step
      4.  Append the authentication tag\n      to the packet.\n   8. If necessary,
      update the ROC as in Section 3.3.1, using the packet\n      index determined
      in Step 2.\n   To authenticate and decrypt an SRTP packet, the receiver SHALL
      do the\n   following:\n   1. Determine which cryptographic context to use as
      described in\n      Section 3.2.3.\n   2. Run the algorithm in Section 3.3.1
      to get the index of the SRTP\n      packet.  The algorithm uses the rollover
      counter and highest\n      sequence number in the cryptographic context with
      the sequence\n      number in the SRTP packet, as described in Section 3.3.1.\n
      \  3. Determine the master key and master salt.  If the MKI indicator in\n      the
      context is set to one, use the MKI in the SRTP packet,\n      otherwise use
      the index from the previous step, according to\n      Section 8.1.\n   4. Determine
      the session keys, and session salt (if used by the\n      transform) as described
      in Section 4.3, using master key, master\n      salt, key_derivation_rate and
      session key-lengths in the\n      cryptographic context with the index, determined
      in Steps 2 and 3.\n   5. For message authentication and replay protection, first
      check if\n      the packet has been replayed (Section 3.3.2), using the Replay\n
      \     List and the index as determined in Step 2.  If the packet is\n      judged
      to be replayed, then the packet MUST be discarded, and the\n      event SHOULD
      be logged.\n      Next, perform verification of the authentication tag, using
      the\n      rollover counter from Step 2, the authentication algorithm\n      indicated
      in the cryptographic context, and the session\n      authentication key from
      Step 4.  If the result is \"AUTHENTICATION\n      FAILURE\" (see Section 4.2),
      the packet MUST be discarded from\n      further processing and the event SHOULD
      be logged.\n   6. Decrypt the Encrypted Portion of the packet (see Section 4.1,
      for\n      the defined ciphers), using the decryption algorithm indicated in\n
      \     the cryptographic context, the session encryption key and salt (if\n      used)
      found in Step 4 with the index from Step 2.\n   7. Update the rollover counter
      and highest sequence number, s_l, in\n      the cryptographic context as in
      Section 3.3.1, using the packet\n      index estimated in Step 2.  If replay
      protection is provided, also\n      update the Replay List as described in Section
      3.3.2.\n   8. When present, remove the MKI and authentication tag fields from\n
      \     the packet.\n"
    - contents:
      - "3.3.1.  Packet Index Determination, and ROC, s_l Update\n   SRTP implementations
        use an \"implicit\" packet index for sequencing,\n   i.e., not all of the
        index is explicitly carried in the SRTP packet.\n   For the pre-defined transforms,
        the index i is used in replay\n   protection (Section 3.3.2), encryption (Section
        4.1), message\n   authentication (Section 4.2), and for the key derivation
        (Section\n   4.3).\n   When the session starts, the sender side MUST set the
        rollover\n   counter, ROC, to zero.  Each time the RTP sequence number, SEQ,
        wraps\n   modulo 2^16, the sender side MUST increment ROC by one, modulo 2^32\n
        \  (see security aspects below).  The sender's packet index is then\n   defined
        as\n      i = 2^16 * ROC + SEQ.\n   Receiver-side implementations use the
        RTP sequence number to\n   determine the correct index of a packet, which
        is the location of the\n   packet in the sequence of all SRTP packets.  A
        robust approach for\n   the proper use of a rollover counter requires its
        handling and use to\n   be well defined.  In particular, out-of-order RTP
        packets with\n   sequence numbers close to 2^16 or zero must be properly handled.\n
        \  The index estimate is based on the receiver's locally maintained ROC\n
        \  and s_l values.  At the setup of the session, the ROC MUST be set to\n
        \  zero.  Receivers joining an on-going session MUST be given the\n   current
        ROC value using out-of-band signaling such as key-management\n   signaling.
        \ Furthermore, the receiver SHALL initialize s_l to the RTP\n   sequence number
        (SEQ) of the first observed SRTP packet (unless the\n   initial value is provided
        by out of band signaling such as key\n   management).\n   On consecutive SRTP
        packets, the receiver SHOULD estimate the index\n   as\n         i = 2^16
        * v + SEQ,\n   where v is chosen from the set { ROC-1, ROC, ROC+1 } (modulo
        2^32)\n   such that i is closest (in modulo 2^48 sense) to the value 2^16
        * ROC\n   + s_l (see Appendix A for pseudocode).\n   After the packet has
        been processed and authenticated (when enabled\n   for SRTP packets for the
        session), the receiver MUST use v to\n   conditionally update its s_l and
        ROC variables as follows.  If\n   v=(ROC-1) mod 2^32, then there is no update
        to s_l or ROC.  If v=ROC,\n   then s_l is set to SEQ if and only if SEQ is
        larger than the current\n   s_l; there is no change to ROC.  If v=(ROC+1)
        mod 2^32, then s_l is\n   set to SEQ and ROC is set to v.\n   After a re-keying
        occurs (changing to a new master key), the rollover\n   counter always maintains
        its sequence of values, i.e., it MUST NOT be\n   reset to zero.\n   As the
        rollover counter is 32 bits long and the sequence number is 16\n   bits long,
        the maximum number of packets belonging to a given SRTP\n   stream that can
        be secured with the same key is 2^48 using the pre-\n   defined transforms.
        \ After that number of SRTP packets have been sent\n   with a given (master
        or session) key, the sender MUST NOT send any\n   more packets with that key.
        \ (There exists a similar limit for SRTCP,\n   which in practice may be more
        restrictive, see Section 9.2.)  This\n   limitation enforces a security benefit
        by providing an upper bound on\n   the amount of traffic that can pass before
        cryptographic keys are\n   changed.  Re-keying (see Section 8.1) MUST be triggered,
        before this\n   amount of traffic, and MAY be triggered earlier, e.g., for
        increased\n   security and access control to media.  Recurring key derivation
        by\n   means of a non-zero key_derivation_rate (see Section 4.3), also gives\n
        \  stronger security but does not change the above absolute maximum\n   value.\n
        \  On the receiver side, there is a caveat to updating s_l and ROC: if\n   message
        authentication is not present, neither the initialization of\n   s_l, nor
        the ROC update can be made completely robust.  The\n   receiver's \"implicit
        index\" approach works for the pre-defined\n   transforms as long as the reorder
        and loss of the packets are not too\n   great and bit-errors do not occur
        in unfortunate ways.  In\n   particular, 2^15 packets would need to be lost,
        or a packet would\n   need to be 2^15 packets out of sequence before synchronization
        is\n   lost.  Such drastic loss or reorder is likely to disrupt the RTP\n
        \  application itself.\n   The algorithm for the index estimate and ROC update
        is a matter of\n   implementation, and should take into consideration the
        environment\n   (e.g., packet loss rate) and the cases when synchronization
        is likely\n   to be lost, e.g., when the initial sequence number (randomly
        chosen\n   by RTP) is not known in advance (not sent in the key management\n
        \  protocol) but may be near to wrap modulo 2^16.\n   A more elaborate and
        more robust scheme than the one given above is\n   the handling of RTP's own
        \"rollover counter\", see Appendix A.1 of\n   [RFC3550].\n"
      title: 3.3.1.  Packet Index Determination, and ROC, s_l Update
    - contents:
      - "3.3.2.  Replay Protection\n   Secure replay protection is only possible when
        integrity protection\n   is present.  It is RECOMMENDED to use replay protection,
        both for RTP\n   and RTCP, as integrity protection alone cannot assure security\n
        \  against replay attacks.\n   A packet is \"replayed\" when it is stored
        by an adversary, and then\n   re-injected into the network.  When message
        authentication is\n   provided, SRTP protects against such attacks through
        a Replay List.\n   Each SRTP receiver maintains a Replay List, which conceptually\n
        \  contains the indices of all of the packets which have been received\n   and
        authenticated.  In practice, the list can use a \"sliding window\"\n   approach,
        so that a fixed amount of storage suffices for replay\n   protection.  Packet
        indices which lag behind the packet index in the\n   context by more than
        SRTP-WINDOW-SIZE can be assumed to have been\n   received, where SRTP-WINDOW-SIZE
        is a receiver-side, implementation-\n   dependent parameter and MUST be at
        least 64, but which MAY be set to\n   a higher value.\n   The receiver checks
        the index of an incoming packet against the\n   replay list and the window.
        \ Only packets with index ahead of the\n   window, or, inside the window but
        not already received, SHALL be\n   accepted.\n   After the packet has been
        authenticated (if necessary the window is\n   first moved ahead), the replay
        list SHALL be updated with the new\n   index.\n   The Replay List can be efficiently
        implemented by using a bitmap to\n   represent which packets have been received,
        as described in the\n   Security Architecture for IP [RFC2401].\n"
      title: 3.3.2.  Replay Protection
    title: 3.3.  SRTP Packet Processing
  - contents:
    - "3.4.  Secure RTCP\n   Secure RTCP follows the definition of Secure RTP.  SRTCP
      adds three\n   mandatory new fields (the SRTCP index, an \"encrypt-flag\", and
      the\n   authentication tag) and one optional field (the MKI) to the RTCP\n   packet
      definition.  The three mandatory fields MUST be appended to an\n   RTCP packet
      in order to form an equivalent SRTCP packet.  The added\n   fields follow any
      other profile-specific extensions.\n   According to Section 6.1 of [RFC3550],
      there is a REQUIRED packet\n   format for compound packets.  SRTCP MUST be given
      packets according\n   to that requirement in the sense that the first part MUST
      be a sender\n   report or a receiver report.  However, the RTCP encryption prefix
      (a\n   random 32-bit quantity) specified in that Section MUST NOT be used\n
      \  since, as is stated there, it is only applicable to the encryption\n   method
      specified in [RFC3550] and is not needed by the cryptographic\n   mechanisms
      used in SRTP.\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n
      \    |V=2|P|    RC   |   PT=SR or RR   |             length          | |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |\n     |                         SSRC of sender                        | |\n
      \  +>+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n   |
      ~                          sender info                          ~ |\n   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |\n   | ~                         report block 1                        ~ |\n
      \  | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n   |
      ~                         report block 2                        ~ |\n   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |\n   | ~                              ...                              ~ |\n
      \  | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n   |
      |V=2|P|    SC   |  PT=SDES=202  |             length            | |\n   | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      |\n   | |                          SSRC/CSRC_1                          | |\n
      \  | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n   |
      ~                           SDES items                          ~ |\n   | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      |\n   | ~                              ...                              ~ |\n
      \  +>+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n   |
      |E|                         SRTCP index                         | |\n   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n
      \  | ~                     SRTCP MKI (OPTIONAL)                      ~ |\n   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n   | :
      \                    authentication tag                        : |\n   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |\n   |                                                                   |\n
      \  +-- Encrypted Portion                    Authenticated Portion -----+\n   Figure
      2.  An example of the format of a Secure RTCP packet,\n   consisting of an underlying
      RTCP compound packet with a Sender Report\n   and SDES packet.\n   The Encrypted
      Portion of an SRTCP packet consists of the encryption\n   (Section 4.1) of the
      RTCP payload of the equivalent compound RTCP\n   packet, from the first RTCP
      packet, i.e., from the ninth (9) octet to\n   the end of the compound packet.
      \ The Authenticated Portion of an\n   SRTCP packet consists of the entire equivalent
      (eventually compound)\n   RTCP packet, the E flag, and the SRTCP index (after
      any encryption\n   has been applied to the payload).\n   The added fields are:\n
      \  E-flag: 1 bit, REQUIRED\n            The E-flag indicates if the current
      SRTCP packet is\n            encrypted or unencrypted.  Section 9.1 of [RFC3550]
      allows\n            the split of a compound RTCP packet into two lower-layer\n
      \           packets, one to be encrypted and one to be sent in the\n            clear.
      \ The E bit set to \"1\" indicates encrypted packet, and\n            \"0\"
      indicates non-encrypted packet.\n   SRTCP index: 31 bits, REQUIRED\n            The
      SRTCP index is a 31-bit counter for the SRTCP packet.\n            The index
      is explicitly included in each packet, in contrast\n            to the \"implicit\"
      index approach used for SRTP.  The SRTCP\n            index MUST be set to zero
      before the first SRTCP packet is\n            sent, and MUST be incremented
      by one, modulo 2^31, after\n            each SRTCP packet is sent.  In particular,
      after a re-key,\n            the SRTCP index MUST NOT be reset to zero again.\n
      \  Authentication Tag: configurable length, REQUIRED\n            The authentication
      tag is used to carry message\n            authentication data.\n   MKI: configurable
      length, OPTIONAL\n            The MKI is the Master Key Indicator, and functions
      according\n            to the MKI definition in Section 3.\n   SRTCP uses the
      cryptographic context parameters and packet processing\n   of SRTP by default,
      with the following changes:\n   *  The receiver does not need to \"estimate\"
      the index, as it is\n      explicitly signaled in the packet.\n   *  Pre-defined
      SRTCP encryption is as specified in Section 4.1, but\n      using the definition
      of the SRTCP Encrypted Portion given in this\n      section, and using the SRTCP
      index as the index i.  The encryption\n      transform and related parameters
      SHALL by default be the same\n      selected for the protection of the associated
      SRTP stream(s),\n      while the NULL algorithm SHALL be applied to the RTCP
      packets not\n      to be encrypted.  SRTCP may have a different encryption transform\n
      \     than the one used by the corresponding SRTP.  The expected use for\n      this
      feature is when the former has NULL-encryption and the latter\n      has a non
      NULL-encryption.\n   The E-flag is assigned a value by the sender depending
      on whether the\n   packet was encrypted or not.\n   *  SRTCP decryption is performed
      as in Section 4, but only if the E\n      flag is equal to 1.  If so, the Encrypted
      Portion is decrypted,\n      using the SRTCP index as the index i.  In case
      the E-flag is 0,\n      the payload is simply left unmodified.\n   *  SRTCP
      replay protection is as defined in Section 3.3.2, but using\n      the SRTCP
      index as the index i and a separate Replay List that is\n      specific to SRTCP.\n
      \  *  The pre-defined SRTCP authentication tag is specified as in\n      Section
      4.2, but with the Authenticated Portion of the SRTCP\n      packet given in
      this section (which includes the index).  The\n      authentication transform
      and related parameters (e.g., key size)\n      SHALL by default be the same
      as selected for the protection of the\n      associated SRTP stream(s).\n   *
      \ In the last step of the processing, only the sender needs to\n      update
      the value of the SRTCP index by incrementing it modulo 2^31\n      and for security
      reasons the sender MUST also check the number of\n      SRTCP packets processed,
      see Section 9.2.\n   Message authentication for RTCP is REQUIRED, as it is the
      control\n   protocol (e.g., it has a BYE packet) for RTP.\n   Precautions must
      be taken so that the packet expansion in SRTCP (due\n   to the added fields)
      does not cause SRTCP messages to use more than\n   their share of RTCP bandwidth.
      \ To avoid this, the following two\n   measures MUST be taken:\n   1. When initializing
      the RTCP variable \"avg_rtcp_size\" defined in\n      chapter 6.3 of [RFC3550],
      it MUST include the size of the fields\n      that will be added by SRTCP (index,
      E-bit, authentication tag, and\n      when present, the MKI).\n   2. When updating
      the \"avg_rtcp_size\" using the variable \"packet_size\"\n      (section 6.3.3
      of [RFC3550]), the value of \"packet_size\" MUST\n      include the size of
      the additional fields added by SRTCP.\n   With these measures in place the SRTCP
      messages will not use more\n   than the allotted bandwidth.  The effect of the
      size of the added\n   fields on the SRTCP traffic will be that messages will
      be sent with\n   longer packet intervals.  The increase in the intervals will
      be\n   directly proportional to size of the added fields.  For the pre-\n   defined
      transforms, the size of the added fields will be at least 14\n   octets, and
      upper bounded depending on MKI and the authentication tag\n   sizes.\n"
    title: 3.4.  Secure RTCP
  title: 3.  SRTP Framework
- contents:
  - "4.  Pre-Defined Cryptographic Transforms\n   While there are numerous encryption
    and message authentication\n   algorithms that can be used in SRTP, below we define
    default\n   algorithms in order to avoid the complexity of specifying the\n   encodings
    for the signaling of algorithm and parameter identifiers.\n   The defined algorithms
    have been chosen as they fulfill the goals\n   listed in Section 2.  Recommendations
    on how to extend SRTP with new\n   transforms are given in Section 6.\n"
  - contents:
    - "4.1.  Encryption\n   The following parameters are common to both pre-defined,
      non-NULL,\n   encryption transforms specified in this section.\n   *  BLOCK_CIPHER-MODE
      indicates the block cipher used and its mode of\n      operation\n   *  n_b
      is the bit-size of the block for the block cipher\n   *  k_e is the session
      encryption key\n   *  n_e is the bit-length of k_e\n   *  k_s is the session
      salting key\n   *  n_s is the bit-length of k_s\n   *  SRTP_PREFIX_LENGTH is
      the octet length of the keystream prefix, a\n      non-negative integer, specified
      by the message authentication code\n      in use.\n   The distinct session keys
      and salts for SRTP/SRTCP are by default\n   derived as specified in Section
      4.3.\n   The encryption transforms defined in SRTP map the SRTP packet index\n
      \  and secret key into a pseudo-random keystream segment.  Each\n   keystream
      segment encrypts a single RTP packet.  The process of\n   encrypting a packet
      consists of generating the keystream segment\n   corresponding to the packet,
      and then bitwise exclusive-oring that\n   keystream segment onto the payload
      of the RTP packet to produce the\n   Encrypted Portion of the SRTP packet.  In
      case the payload size is\n   not an integer multiple of n_b bits, the excess
      (least significant)\n   bits of the keystream are simply discarded.  Decryption
      is done the\n   same way, but swapping the roles of the plaintext and ciphertext.\n
      \  +----+   +------------------+---------------------------------+\n   | KG
      |-->| Keystream Prefix |          Keystream Suffix       |---+\n   +----+   +------------------+---------------------------------+
      \  |\n                                                                     |\n
      \                              +---------------------------------+   v\n                               |
      \    Payload of RTP Packet       |->(*)\n                               +---------------------------------+
      \  |\n                                                                     |\n
      \                              +---------------------------------+   |\n                               |
      Encrypted Portion of SRTP Packet|<--+\n                               +---------------------------------+\n
      \  Figure 3: Default SRTP Encryption Processing.  Here KG denotes the\n   keystream
      generator, and (*) denotes bitwise exclusive-or.\n   The definition of how the
      keystream is generated, given the index,\n   depends on the cipher and its mode
      of operation.  Below, two such\n   keystream generators are defined.  The NULL
      cipher is also defined,\n   to be used when encryption of RTP is not required.\n
      \  The SRTP definition of the keystream is illustrated in Figure 3.  The\n   initial
      octets of each keystream segment MAY be reserved for use in a\n   message authentication
      code, in which case the keystream used for\n   encryption starts immediately
      after the last reserved octet.  The\n   initial reserved octets are called the
      \"keystream prefix\" (not to be\n   confused with the \"encryption prefix\"
      of [RFC3550, Section 6.1]), and\n   the remaining octets are called the \"keystream
      suffix\".  The\n   keystream prefix MUST NOT be used for encryption.  The process
      is\n   illustrated in Figure 3.\n   The number of octets in the keystream prefix
      is denoted as\n   SRTP_PREFIX_LENGTH.  The keystream prefix is indicated by
      a positive,\n   non-zero value of SRTP_PREFIX_LENGTH.  This means that, even
      if\n   confidentiality is not to be provided, the keystream generator output\n
      \  may still need to be computed for packet authentication, in which\n   case
      the default keystream generator (mode) SHALL be used.\n   The default cipher
      is the Advanced Encryption Standard (AES) [AES],\n   and we define two modes
      of running AES, (1) Segmented Integer Counter\n   Mode AES and (2) AES in f8-mode.
      \ In the remainder of this section,\n   let E(k,x) be AES applied to key k and
      input block x.\n"
    - contents:
      - "4.1.1.  AES in Counter Mode\n   Conceptually, counter mode [AES-CTR] consists
        of encrypting\n   successive integers.  The actual definition is somewhat
        more\n   complicated, in order to randomize the starting point of the integer\n
        \  sequence.  Each packet is encrypted with a distinct keystream\n   segment,
        which SHALL be computed as follows.\n   A keystream segment SHALL be the concatenation
        of the 128-bit output\n   blocks of the AES cipher in the encrypt direction,
        using key k = k_e,\n   in which the block indices are in increasing order.
        \ Symbolically,\n   each keystream segment looks like\n      E(k, IV) || E(k,
        IV + 1 mod 2^128) || E(k, IV + 2 mod 2^128) ...\n   where the 128-bit integer
        value IV SHALL be defined by the SSRC, the\n   SRTP packet index i, and the
        SRTP session salting key k_s, as below.\n      IV = (k_s * 2^16) XOR (SSRC
        * 2^64) XOR (i * 2^16)\n   Each of the three terms in the XOR-sum above is
        padded with as many\n   leading zeros as needed to make the operation well-defined,\n
        \  considered as a 128-bit value.\n   The inclusion of the SSRC allows the
        use of the same key to protect\n   distinct SRTP streams within the same RTP
        session, see the security\n   caveats in Section 9.1.\n   In the case of SRTCP,
        the SSRC of the first header of the compound\n   packet MUST be used, i SHALL
        be the 31-bit SRTCP index and k_e, k_s\n   SHALL be replaced by the SRTCP
        encryption session key and salt.\n   Note that the initial value, IV, is fixed
        for each packet and is\n   formed by \"reserving\" 16 zeros in the least significant
        bits for the\n   purpose of the counter.  The number of blocks of keystream
        generated\n   for any fixed value of IV MUST NOT exceed 2^16 to avoid keystream\n
        \  re-use, see below.  The AES has a block size of 128 bits, so 2^16\n   output
        blocks are sufficient to generate the 2^23 bits of keystream\n   needed to
        encrypt the largest possible RTP packet (except for IPv6\n   \"jumbograms\"
        [RFC2675], which are not likely to be used for RTP-based\n   multimedia traffic).
        \ This restriction on the maximum bit-size of the\n   packet that can be encrypted
        ensures the security of the encryption\n   method by limiting the effectiveness
        of probabilistic attacks [BDJR].\n   For a particular Counter Mode key, each
        IV value used as an input\n   MUST be distinct, in order to avoid the security
        exposure of a two-\n   time pad situation (Section 9.1).  To satisfy this
        constraint, an\n   implementation MUST ensure that the combination of the
        SRTP packet\n   index of ROC || SEQ, and the SSRC used in the construction
        of the IV\n   are distinct for any particular key.  The failure to ensure
        this\n   uniqueness could be catastrophic for Secure RTP.  This is in contrast\n
        \  to the situation for RTP itself, which may be able to tolerate such\n   failures.
        \ It is RECOMMENDED that, if a dedicated security module is\n   present, the
        RTP sequence numbers and SSRC either be generated or\n   checked by that module
        (i.e., sequence-number and SSRC processing in\n   an SRTP system needs to
        be protected as well as the key).\n"
      title: 4.1.1.  AES in Counter Mode
    - contents:
      - "4.1.2.  AES in f8-mode\n   To encrypt UMTS (Universal Mobile Telecommunications
        System, as 3G\n   networks) data, a solution (see [f8-a] [f8-b]) known as
        the f8-\n   algorithm has been developed.  On a high level, the proposed scheme\n
        \  is a variant of Output Feedback Mode (OFB) [HAC], with a more\n   elaborate
        initialization and feedback function.  As in normal OFB,\n   the core consists
        of a block cipher.  We also define here the use of\n   AES as a block cipher
        to be used in what we shall call \"f8-mode of\n   operation\" RTP encryption.
        \ The AES f8-mode SHALL use the same\n   default sizes for session key and
        salt as AES counter mode.\n   Figure 4 shows the structure of block cipher,
        E, running in f8-mode.\n                    IV\n                    |\n                    v\n
        \               +------+\n                |      |\n           +--->|  E   |\n
        \          |    +------+\n           |        |\n     m -> (*)       +-----------+-------------+--
        \ ...     ------+\n           |    IV' |           |             |                  |\n
        \          |        |   j=1 -> (*)    j=2 -> (*)   ...  j=L-1 ->(*)\n           |
        \       |           |             |                  |\n           |        |
        \     +-> (*)       +-> (*)   ...      +-> (*)\n           |        |      |
        \   |        |    |             |    |\n           |        v      |    v
        \       |    v             |    v\n           |    +------+   | +------+    |
        +------+         | +------+\n    k_e ---+--->|  E   |   | |  E   |    | |
        \ E   |         | |  E   |\n                |      |   | |      |    | |      |
        \        | |      |\n                +------+   | +------+    | +------+         |
        +------+\n                    |      |    |        |    |             |    |\n
        \                   +------+    +--------+    +--  ...  ----+    |\n                    |
        \          |             |                  |\n                    v           v
        \            v                  v\n                   S(0)        S(1)          S(2)
        \ . . .       S(L-1)\n   Figure 4.  f8-mode of operation (asterisk, (*), denotes
        bitwise XOR).\n   The figure represents the KG in Figure 3, when AES-f8 is
        used.\n"
      - contents:
        - "4.1.2.1.  f8 Keystream Generation\n   The Initialization Vector (IV) SHALL
          be determined as described in\n   Section 4.1.2.2 (and in Section 4.1.2.3
          for SRTCP).\n   Let IV', S(j), and m denote n_b-bit blocks.  The keystream,\n
          \  S(0) ||... || S(L-1), for an N-bit message SHALL be defined by\n   setting
          IV' = E(k_e XOR m, IV), and S(-1) = 00..0.  For\n   j = 0,1,..,L-1 where
          L = N/n_b (rounded up to nearest integer if it\n   is not already an integer)
          compute\n            S(j) = E(k_e, IV' XOR j XOR S(j-1))\n   Notice that
          the IV is not used directly.  Instead it is fed through E\n   under another
          key to produce an internal, \"masked\" value (denoted\n   IV') to prevent
          an attacker from gaining known input/output pairs.\n   The role of the internal
          counter, j, is to prevent short keystream\n   cycles.  The value of the
          key mask m SHALL be\n           m = k_s || 0x555..5,\n   i.e., the session
          salting key, appended by the binary pattern 0101..\n   to fill out the entire
          desired key size, n_e.\n   The sender SHOULD NOT generate more than 2^32
          blocks, which is\n   sufficient to generate 2^39 bits of keystream.  Unlike
          counter mode,\n   there is no absolute threshold above (below) which f8
          is guaranteed\n   to be insecure (secure).  The above bound has been chosen
          to limit,\n   with sufficient security margin, the probability of degenerative\n
          \  behavior in the f8 keystream generation.\n"
        title: 4.1.2.1.  f8 Keystream Generation
      - contents:
        - "4.1.2.2.  f8 SRTP IV Formation\n   The purpose of the following IV formation
          is to provide a feature\n   which we call implicit header authentication
          (IHA), see Section 9.5.\n   The SRTP IV for 128-bit block AES-f8 SHALL be
          formed in the following\n   way:\n        IV = 0x00 || M || PT || SEQ ||
          TS || SSRC || ROC\n   M, PT, SEQ, TS, SSRC SHALL be taken from the RTP header;
          ROC is from\n   the cryptographic context.\n   The presence of the SSRC
          as part of the IV allows AES-f8 to be used\n   when a master key is shared
          between multiple streams within the same\n   RTP session, see Section 9.1.\n"
        title: 4.1.2.2.  f8 SRTP IV Formation
      - contents:
        - "4.1.2.3.  f8 SRTCP IV Formation\n   The SRTCP IV for 128-bit block AES-f8
          SHALL be formed in the\n   following way:\n   IV= 0..0 || E || SRTCP index
          || V || P || RC || PT || length || SSRC\n   where V, P, RC, PT, length,
          SSRC SHALL be taken from the first header\n   in the RTCP compound packet.
          \ E and SRTCP index are the 1-bit and\n   31-bit fields added to the packet.\n"
        title: 4.1.2.3.  f8 SRTCP IV Formation
      title: 4.1.2.  AES in f8-mode
    - contents:
      - "4.1.3.  NULL Cipher\n   The NULL cipher is used when no confidentiality for
        RTP/RTCP is\n   requested.  The keystream can be thought of as \"000..0\",
        i.e., the\n   encryption SHALL simply copy the plaintext input into the ciphertext\n
        \  output.\n"
      title: 4.1.3.  NULL Cipher
    title: 4.1.  Encryption
  - contents:
    - "4.2.  Message Authentication and Integrity\n   Throughout this section, M will
      denote data to be integrity\n   protected.  In the case of SRTP, M SHALL consist
      of the Authenticated\n   Portion of the packet (as specified in Figure 1) concatenated
      with\n   the ROC, M = Authenticated Portion || ROC; in the case of SRTCP, M\n
      \  SHALL consist of the Authenticated Portion (as specified in Figure 2)\n   only.\n
      \  Common parameters:\n   *  AUTH_ALG is the authentication algorithm\n   *
      \ k_a is the session message authentication key\n   *  n_a is the bit-length
      of the authentication key\n   *  n_tag is the bit-length of the output authentication
      tag\n   *  SRTP_PREFIX_LENGTH is the octet length of the keystream prefix as\n
      \     defined above, a parameter of AUTH_ALG\n   The distinct session authentication
      keys for SRTP/SRTCP are by\n   default derived as specified in Section 4.3.\n
      \  The values of n_a, n_tag, and SRTP_PREFIX_LENGTH MUST be fixed for\n   any
      particular fixed value of the key.\n   We describe the process of computing
      authentication tags as follows.\n   The sender computes the tag of M and appends
      it to the packet.  The\n   SRTP receiver verifies a message/authentication tag
      pair by computing\n   a new authentication tag over M using the selected algorithm
      and key,\n   and then compares it to the tag associated with the received message.\n
      \  If the two tags are equal, then the message/tag pair is valid;\n   otherwise,
      it is invalid and the error audit message \"AUTHENTICATION\n   FAILURE\" MUST
      be returned.\n"
    - contents:
      - "4.2.1.  HMAC-SHA1\n   The pre-defined authentication transform for SRTP is
        HMAC-SHA1\n   [RFC2104].  With HMAC-SHA1, the SRTP_PREFIX_LENGTH (Figure 3)
        SHALL\n   be 0.  For SRTP (respectively SRTCP), the HMAC SHALL be applied
        to\n   the session authentication key and M as specified above, i.e.,\n   HMAC(k_a,
        M).  The HMAC output SHALL then be truncated to the n_tag\n   left-most bits.\n"
      title: 4.2.1.  HMAC-SHA1
    title: 4.2.  Message Authentication and Integrity
  - contents:
    - '4.3.  Key Derivation

      '
    - contents:
      - "4.3.1.  Key Derivation Algorithm\n   Regardless of the encryption or message
        authentication transform that\n   is employed (it may be an SRTP pre-defined
        transform or newly\n   introduced according to Section 6), interoperable SRTP\n
        \  implementations MUST use the SRTP key derivation to generate session\n
        \  keys.  Once the key derivation rate is properly signaled at the start\n
        \  of the session, there is no need for extra communication between the\n
        \  parties that use SRTP key derivation.\n                         packet
        index ---+\n                                         |\n                                         v\n
        \              +-----------+ master  +--------+ session encr_key\n               |
        ext       | key     |        |---------->\n               | key mgmt  |-------->|
        \ key   | session auth_key\n               | (optional |         | deriv  |---------->\n
        \              | rekey)    |-------->|        | session salt_key\n               |
        \          | master  |        |---------->\n               +-----------+ salt
        \   +--------+\n   Figure 5: SRTP key derivation.\n   At least one initial
        key derivation SHALL be performed by SRTP, i.e.,\n   the first key derivation
        is REQUIRED.  Further applications of the\n   key derivation MAY be performed,
        according to the\n   \"key_derivation_rate\" value in the cryptographic context.
        \ The key\n   derivation function SHALL initially be invoked before the first\n
        \  packet and then, when r > 0, a key derivation is performed whenever\n   index
        mod r equals zero.  This can be thought of as \"refreshing\" the\n   session
        keys.  The value of \"key_derivation_rate\" MUST be kept fixed\n   for the
        lifetime of the associated master key.\n   Interoperable SRTP implementations
        MAY also derive session salting\n   keys for encryption transforms, as is
        done in both of the pre-\n   defined transforms.\n   Let m and n be positive
        integers.  A pseudo-random function family is\n   a set of keyed functions
        {PRF_n(k,x)} such that for the (secret)\n   random key k, given m-bit x, PRF_n(k,x)
        is an n-bit string,\n   computationally indistinguishable from random n-bit
        strings, see\n   [HAC].  For the purpose of key derivation in SRTP, a secure
        PRF with\n   m = 128 (or more) MUST be used, and a default PRF transform is\n
        \  defined in Section 4.3.3.\n   Let \"a DIV t\" denote integer division of
        a by t, rounded down, and\n   with the convention that \"a DIV 0 = 0\" for
        all a.  We also make the\n   convention of treating \"a DIV t\" as a bit string
        of the same length\n   as a, and thus \"a DIV t\" will in general have leading
        zeros.\n   Key derivation SHALL be defined as follows in terms of <label>,
        an\n   8-bit constant (see below), master_salt and key_derivation_rate, as\n
        \  determined in the cryptographic context, and index, the packet index\n
        \  (i.e., the 48-bit ROC || SEQ for SRTP):\n   *  Let r = index DIV key_derivation_rate
        (with DIV as defined above).\n   *  Let key_id = <label> || r.\n   *  Let
        x = key_id XOR master_salt, where key_id and master_salt are\n      aligned
        so that their least significant bits agree (right-\n      alignment).\n   <label>
        MUST be unique for each type of key to be derived.  We\n   currently define
        <label> 0x00 to 0x05 (see below), and future\n   extensions MAY specify new
        values in the range 0x06 to 0xff for other\n   purposes.  The n-bit SRTP key
        (or salt) for this packet SHALL then be\n   derived from the master key, k_master
        as follows:\n      PRF_n(k_master, x).\n   (The PRF may internally specify
        additional formatting and padding of\n   x, see e.g., Section 4.3.3 for the
        default PRF.)\n   The session keys and salt SHALL now be derived using:\n
        \  - k_e (SRTP encryption): <label> = 0x00, n = n_e.\n   - k_a (SRTP message
        authentication): <label> = 0x01, n = n_a.\n   - k_s (SRTP salting key): <label>
        = 0x02, n = n_s.\n   where n_e, n_s, and n_a are from the cryptographic context.\n
        \  The master key and master salt MUST be random, but the master salt\n   MAY
        be public.\n   Note that for a key_derivation_rate of 0, the application of
        the key\n   derivation SHALL take place exactly once.\n   The definition of
        DIV above is purely for notational convenience.\n   For a non-zero t among
        the set of allowed key derivation rates, \"a\n   DIV t\" can be implemented
        as a right-shift by the base-2 logarithm of\n   t.  The derivation operation
        is further facilitated if the rates are\n   chosen to be powers of 256, but
        that granularity was considered too\n   coarse to be a requirement of this
        specification.\n   The upper limit on the number of packets that can be secured
        using\n   the same master key (see Section 9.2) is independent of the key\n
        \  derivation.\n"
      title: 4.3.1.  Key Derivation Algorithm
    - contents:
      - "4.3.2.  SRTCP Key Derivation\n   SRTCP SHALL by default use the same master
        key (and master salt) as\n   SRTP.  To do this securely, the following changes
        SHALL be done to\n   the definitions in Section 4.3.1 when applying session
        key derivation\n   for SRTCP.\n   Replace the SRTP index by the 32-bit quantity:
        0 || SRTCP index\n   (i.e., excluding the E-bit, replacing it with a fixed
        0-bit), and use\n   <label> = 0x03 for the SRTCP encryption key, <label> =
        0x04 for the\n   SRTCP authentication key, and, <label> = 0x05 for the SRTCP
        salting\n   key.\n"
      title: 4.3.2.  SRTCP Key Derivation
    - contents:
      - "4.3.3.  AES-CM PRF\n   The currently defined PRF, keyed by 128, 192, or 256
        bit master key,\n   has input block size m = 128 and can produce n-bit outputs
        for n up\n   to 2^23.  PRF_n(k_master,x) SHALL be AES in Counter Mode as described\n
        \  in Section 4.1.1, applied to key k_master, and IV equal to (x*2^16),\n
        \  and with the output keystream truncated to the n first (left-most)\n   bits.
        \ (Requiring n/128, rounded up, applications of AES.)\n"
      title: 4.3.3.  AES-CM PRF
    title: 4.3.  Key Derivation
  title: 4.  Pre-Defined Cryptographic Transforms
- contents:
  - "5.  Default and mandatory-to-implement Transforms\n   The default transforms
    also are mandatory-to-implement transforms in\n   SRTP.  Of course, \"mandatory-to-implement\"
    does not imply\n   \"mandatory-to-use\".  Table 1 summarizes the pre-defined transforms.\n
    \  The default values below are valid for the pre-defined transforms.\n                         mandatory-to-impl.
    \  optional     default\n   encryption            AES-CM, NULL         AES-f8
    \      AES-CM\n   message integrity     HMAC-SHA1              -          HMAC-SHA1\n
    \  key derivation (PRF)  AES-CM                 -          AES-CM\n   Table 1:
    Mandatory-to-implement, optional and default transforms in\n   SRTP and SRTCP.\n"
  - contents:
    - "5.1.  Encryption: AES-CM and NULL\n   AES running in Segmented Integer Counter
      Mode, as defined in Section\n   4.1.1, SHALL be the default encryption algorithm.
      \ The default key\n   lengths SHALL be 128-bit for the session encryption key
      (n_e).  The\n   default session salt key-length (n_s) SHALL be 112 bits.\n   The
      NULL cipher SHALL also be mandatory-to-implement.\n"
    title: '5.1.  Encryption: AES-CM and NULL'
  - contents:
    - "5.2.  Message Authentication/Integrity: HMAC-SHA1\n   HMAC-SHA1, as defined
      in Section 4.2.1, SHALL be the default message\n   authentication code.  The
      default session authentication key-length\n   (n_a) SHALL be 160 bits, the default
      authentication tag length\n   (n_tag) SHALL be 80 bits, and the SRTP_PREFIX_LENGTH
      SHALL be zero\n   for HMAC-SHA1.  In addition, for SRTCP, the pre-defined HMAC-SHA1\n
      \  MUST NOT be applied with a value of n_tag, nor n_a, that are smaller\n   than
      these defaults.  For SRTP, smaller values are NOT RECOMMENDED,\n   but MAY be
      used after careful consideration of the issues in Section\n   7.5 and 9.5.\n"
    title: '5.2.  Message Authentication/Integrity: HMAC-SHA1'
  - contents:
    - "5.3.  Key Derivation: AES-CM PRF\n   The AES Counter Mode based key derivation
      and PRF defined in Sections\n   4.3.1 to 4.3.3, using a 128-bit master key,
      SHALL be the default\n   method for generating session keys.  The default master
      salt length\n   SHALL be 112 bits and the default key-derivation rate SHALL
      be zero.\n"
    title: '5.3.  Key Derivation: AES-CM PRF'
  title: 5.  Default and mandatory-to-implement Transforms
- contents:
  - "6.  Adding SRTP Transforms\n   Section 4 provides examples of the level of detail
    needed for\n   defining transforms.  Whenever a new transform is to be added to\n
    \  SRTP, a companion standard track RFC MUST be written to exactly\n   define
    how the new transform can be used with SRTP (and SRTCP).  Such\n   a companion
    RFC SHOULD avoid overlap with the SRTP protocol document.\n   Note however, that
    it MAY be necessary to extend the SRTP or SRTCP\n   cryptographic context definition
    with new parameters (including fixed\n   or default values), add steps to the
    packet processing, or even add\n   fields to the SRTP/SRTCP packets.  The companion
    RFC SHALL explain\n   any known issues regarding interactions between the transform
    and\n   other aspects of SRTP.\n   Each new transform document SHOULD specify
    its key attributes, e.g.,\n   size of keys (minimum, maximum, recommended), format
    of keys,\n   recommended/required processing of input keying material,\n   requirements/recommendations
    on key lifetime, re-keying and key\n   derivation, whether sharing of keys between
    SRTP and SRTCP is allowed\n   or not, etc.\n   An added message integrity transform
    SHOULD define a minimum\n   acceptable key/tag size for SRTCP, equivalent in strength
    to the\n   minimum values as defined in Section 5.2.\n"
  title: 6.  Adding SRTP Transforms
- contents:
  - "7.  Rationale\n   This section explains the rationale behind several important
    features\n   of SRTP.\n"
  - contents:
    - "7.1.  Key derivation\n   Key derivation reduces the burden on the key establishment.
      \ As many\n   as six different keys are needed per crypto context (SRTP and
      SRTCP\n   encryption keys and salts, SRTP and SRTCP authentication keys), but\n
      \  these are derived from a single master key in a cryptographically\n   secure
      way.  Thus, the key management protocol needs to exchange only\n   one master
      key (plus master salt when required), and then SRTP itself\n   derives all the
      necessary session keys (via the first, mandatory\n   application of the key
      derivation function).\n   Multiple applications of the key derivation function
      are optional,\n   but will give security benefits when enabled.  They prevent
      an\n   attacker from obtaining large amounts of ciphertext produced by a\n   single
      fixed session key.  If the attacker was able to collect a\n   large amount of
      ciphertext for a certain session key, he might be\n   helped in mounting certain
      attacks.\n   Multiple applications of the key derivation function provide\n
      \  backwards and forward security in the sense that a compromised\n   session
      key does not compromise other session keys derived from the\n   same master
      key.  This means that the attacker who is able to recover\n   a certain session
      key, is anyway not able to have access to messages\n   secured under previous
      and later session keys (derived from the same\n   master key).  (Note that,
      of course, a leaked master key reveals all\n   the session keys derived from
      it.)\n   Considerations arise with high-rate key refresh, especially in large\n
      \  multicast settings, see Section 11.\n"
    title: 7.1.  Key derivation
  - contents:
    - "7.2.  Salting key\n   The master salt guarantees security against off-line
      key-collision\n   attacks on the key derivation that might otherwise reduce
      the\n   effective key size [MF00].\n   The derived session salting key used
      in the encryption, has been\n   introduced to protect against some attacks on
      additive stream\n   ciphers, see Section 9.2.  The explicit inclusion method
      of the salt\n   in the IV has been selected for ease of hardware implementation.\n"
    title: 7.2.  Salting key
  - contents:
    - "7.3.  Message Integrity from Universal Hashing\n   The particular definition
      of the keystream given in Section 4.1 (the\n   keystream prefix) is to give
      provision for particular universal hash\n   functions, suitable for message
      authentication in the Wegman-Carter\n   paradigm [WC81].  Such functions are
      provably secure, simple, quick,\n   and especially appropriate for Digital Signal
      Processors and other\n   processors with a fast multiply operation.\n   No authentication
      transforms are currently provided in SRTP other\n   than HMAC-SHA1.  Future
      transforms, like the above mentioned\n   universal hash functions, MAY be added
      following the guidelines in\n   Section 6.\n"
    title: 7.3.  Message Integrity from Universal Hashing
  - contents:
    - "7.4.  Data Origin Authentication Considerations\n   Note that in pair-wise
      communications, integrity and data origin\n   authentication are provided together.
      \ However, in group scenarios\n   where the keys are shared between members,
      the MAC tag only proves\n   that a member of the group sent the packet, but
      does not prevent\n   against a member impersonating another.  Data origin authentication\n
      \  (DOA) for multicast and group RTP sessions is a hard problem that\n   needs
      a solution; while some promising proposals are being\n   investigated [PCST1]
      [PCST2], more work is needed to rigorously\n   specify these technologies.  Thus
      SRTP data origin authentication in\n   groups is for further study.\n   DOA
      can be done otherwise using signatures.  However, this has high\n   impact in
      terms of bandwidth and processing time, therefore we do not\n   offer this form
      of authentication in the pre-defined packet-integrity\n   transform.\n   The
      presence of mixers and translators does not allow data origin\n   authentication
      in case the RTP payload and/or the RTP header are\n   manipulated.  Note that
      these types of middle entities also disrupt\n   end-to-end confidentiality (as
      the IV formation depends e.g., on the\n   RTP header preservation).  A certain
      trust model may choose to trust\n   the mixers/translators to decrypt/re-encrypt
      the media (this would\n   imply breaking the end-to-end security, with related
      security\n   implications).\n"
    title: 7.4.  Data Origin Authentication Considerations
  - contents:
    - "7.5.  Short and Zero-length Message Authentication\n   As shown in Figure 1,
      the authentication tag is RECOMMENDED in SRTP.\n   A full 80-bit authentication-tag
      SHOULD be used, but a shorter tag or\n   even a zero-length tag (i.e., no message
      authentication) MAY be used\n   under certain conditions to support either of
      the following two\n   application environments.\n      1. Strong authentication
      can be impractical in environments where\n         bandwidth preservation is
      imperative.  An important special\n         case is wireless communication systems,
      in which bandwidth is a\n         scarce and expensive resource.  Studies have
      shown that for\n         certain applications and link technologies, additional
      bytes\n         may result in a significant decrease in spectrum efficiency\n
      \        [SWO].  Considerable effort has been made to design IP header\n         compression
      techniques to improve spectrum efficiency\n         [RFC3095].  A typical voice
      application produces 20 byte\n         samples, and the RTP, UDP and IP headers
      need to be jointly\n         compressed to one or two bytes on average in order
      to obtain\n         acceptable wireless bandwidth economy [RFC3095].  In this
      case,\n         strong authentication would impose nearly fifty percent\n         overhead.\n
      \     2. Authentication is impractical for applications that use data\n         links
      with fixed-width fields that cannot accommodate the\n         expansion due
      to the authentication tag.  This is the case for\n         some important existing
      wireless channels.  For example, zero-\n         byte header compression is
      used to adapt EVRC/SMV voice with\n         the legacy IS-95 bearer channel
      in CDMA2000 VoIP services.  It\n         was found that not a single additional
      octet could be added to\n         the data, which motivated the creation of
      a zero-byte profile\n         for ROHC [RFC3242].\n   A short tag is secure
      for a restricted set of applications.  Consider\n   a voice telephony application,
      for example, such as a G.729 audio\n   codec with a 20-millisecond packetization
      interval, protected by a\n   32-bit message authentication tag.  The likelihood
      of any given\n   packet being successfully forged is only one in 2^32.  Thus
      an\n   adversary can control no more than 20 milliseconds of audio output\n
      \  during a 994-day period, on average.  In contrast, the effect of a\n   single
      forged packet can be much larger if the application is\n   stateful.  A codec
      that uses relative or predictive compression\n   across packets will propagate
      the maliciously generated state,\n   affecting a longer duration of output.\n
      \  Certainly not all SRTP or telephony applications meet the criteria\n   for
      short or zero-length authentication tags.  Section 9.5.1\n   discusses the risks
      of weak or no message authentication, and section\n   9.5 describes the circumstances
      when it is acceptable and when it is\n   unacceptable.\n"
    title: 7.5.  Short and Zero-length Message Authentication
  title: 7.  Rationale
- contents:
  - "8.  Key Management Considerations\n   There are emerging key management standards
    [MIKEY] [KEYMGT] [SDMS]\n   for establishing an SRTP cryptographic context (e.g.,
    an SRTP master\n   key).  Both proprietary and open-standard key management methods
    are\n   likely to be used for telephony applications [MIKEY] [KINK] and\n   multicast
    applications [GDOI].  This section provides guidance for\n   key management systems
    that service SRTP session.\n   For initialization, an interoperable SRTP implementation
    SHOULD be\n   given the SSRC and MAY be given the initial RTP sequence number
    for\n   the RTP stream by key management (thus, key management has a\n   dependency
    on RTP operational parameters).  Sending the RTP sequence\n   number in the key
    management may be useful e.g., when the initial\n   sequence number is close to
    wrapping (to avoid synchronization\n   problems), and to communicate the current
    sequence number to a\n   joining endpoint (to properly initialize its replay list).\n
    \  If the pre-defined transforms are used, SRTP allows sharing of the\n   same
    master key between SRTP/SRTCP streams belonging to the same RTP\n   session.\n
    \  First, sharing between SRTP streams belonging to the same RTP session\n   is
    secure if the design of the synchronization mechanism, i.e., the\n   IV, avoids
    keystream re-use (the two-time pad, Section 9.1).  This is\n   taken care of by
    the fact that RTP provides for unique SSRCs for\n   streams belonging to the same
    RTP session.  See Section 9.1 for\n   further discussion.\n   Second, sharing
    between SRTP and the corresponding SRTCP is secure.\n   The fact that an SRTP
    stream and its associated SRTCP stream both\n   carry the same SSRC does not constitute
    a problem for the two-time\n   pad due to the key derivation.  Thus, SRTP and
    SRTCP corresponding to\n   one RTP session MAY share master keys (as they do by
    default).\n   Note that message authentication also has a dependency on SSRC\n
    \  uniqueness that is unrelated to the problem of keystream reuse: SRTP\n   streams
    authenticated under the same key MUST have a distinct SSRC in\n   order to identify
    the sender of the message.  This requirement is\n   needed because the SSRC is
    the cryptographically authenticated field\n   used to distinguish between different
    SRTP streams.  Were two streams\n   to use identical SSRC values, then an adversary
    could substitute\n   messages from one stream into the other without detection.\n
    \  SRTP/SRTCP MUST NOT share master keys under any other circumstances\n   than
    the ones given above, i.e., between SRTP and its corresponding\n   SRTCP, and,
    between streams belonging to the same RTP session.\n"
  - contents:
    - "8.1.  Re-keying\n   The recommended way for a particular key management system
      to provide\n   re-key within SRTP is by associating a master key in a crypto
      context\n   with an MKI.\n   This provides for easy master key retrieval (see
      Scenarios in Section\n   11), but has the disadvantage of adding extra bits
      to each packet.\n   As noted in Section 7.5, some wireless links do not cater
      for added\n   bits, therefore SRTP also defines a more economic way of triggering\n
      \  re-keying, via use of <From, To>, which works in some specific,\n   simple
      scenarios (see Section 8.1.1).\n   SRTP senders SHALL count the amount of SRTP
      and SRTCP traffic being\n   used for a master key and invoke key management
      to re-key if needed\n   (Section 9.2).  These interactions are defined by the
      key management\n   interface to SRTP and are not defined by this protocol specification.\n"
    - contents:
      - "8.1.1.  Use of the <From, To> for re-keying\n   In addition to the use of
        the MKI, SRTP defines another optional\n   mechanism for master key retrieval,
        the <From, To>.  The <From, To>\n   specifies the range of SRTP indices (a
        pair of sequence number and\n   ROC) within which a certain master key is
        valid, and is (when used)\n   part of the crypto context.  By looking at the
        48-bit SRTP index of\n   the current SRTP packet, the corresponding master
        key can be found by\n   determining which From-To interval it belongs to.
        \ For SRTCP, the\n   most recently observed/used SRTP index (which can be
        obtained from\n   the cryptographic context) is used for this purpose, even
        though\n   SRTCP has its own (31-bit) index (see caveat below).\n   This method,
        compared to the MKI, has the advantage of identifying\n   the master key and
        defining its lifetime without adding extra bits to\n   each packet.  This
        could be useful, as already noted, for some\n   wireless links that do not
        cater for added bits.  However, its use\n   SHOULD be limited to specific,
        very simple scenarios.  We recommend\n   to limit its use when the RTP session
        is a simple unidirectional or\n   bi-directional stream.  This is because
        in case of multiple streams,\n   it is difficult to trigger the re-key based
        on the <From, To> of a\n   single RTP stream. For example, if several streams
        share a master\n   key, there is no simple one-to-one correspondence between
        the index\n   sequence space of a certain stream, and the index sequence space
        on\n   which the <From, To> values are based.  Consequently, when a master\n
        \  key is shared between streams, one of these streams MUST be\n   designated
        by key management as the one whose index space defines the\n   re-keying points.
        \ Also, the re-key triggering on SRTCP is based on\n   the correspondent SRTP
        stream, i.e., when the SRTP stream changes the\n   master key, so does the
        correspondent SRTCP.  This becomes obviously\n   more and more complex with
        multiple streams.\n   The default values for the <From, To> are \"from the
        first observed\n   packet\" and \"until further notice\".  However, the maximum
        limit of\n   SRTP/SRTCP packets that are sent under each given master/session
        key\n   (Section 9.2) MUST NOT be exceeded.\n   In case the <From, To> is
        used as key retrieval, then the MKI is not\n   inserted in the packet (and
        its indicator in the crypto context is\n   zero).  However, using the MKI
        does not exclude using <From, To> key\n   lifetime simultaneously.  This can
        for instance be useful to signal\n   at the sender side at which point in
        time an MKI is to be made\n   active.\n"
      title: 8.1.1.  Use of the <From, To> for re-keying
    title: 8.1.  Re-keying
  - contents:
    - "8.2.  Key Management parameters\n   The table below lists all SRTP parameters
      that key management can\n   supply.  For reference, it also provides a summary
      of the default and\n   mandatory-to-support values for an SRTP implementation
      as described\n   in Section 5.\n   Parameter                     Mandatory-to-support
      \   Default\n   ---------                     --------------------    -------\n
      \  SRTP and SRTCP encr transf.       AES_CM, NULL         AES_CM\n   (Other
      possible values: AES_f8)\n   SRTP and SRTCP auth transf.       HMAC-SHA1           HMAC-SHA1\n
      \  SRTP and SRTCP auth params:\n     n_tag (tag length)                 80                 80\n
      \    SRTP prefix_length                  0                  0\n   Key derivation
      PRF                 AES_CM              AES_CM\n   Key material params\n   (for
      each master key):\n     master key length                 128                128\n
      \    n_e (encr session key length)     128                128\n     n_a (auth
      session key length)     160                160\n     master salt key\n     length
      of the master salt         112                112\n     n_s (session salt key
      length)     112                112\n     key derivation rate                 0
      \                 0\n     key lifetime\n        SRTP-packets-max-lifetime      2^48
      \              2^48\n        SRTCP-packets-max-lifetime     2^31               2^31\n
      \       from-to-lifetime <From, To>\n     MKI indicator                       0
      \                0\n     length of the MKI                   0                 0\n
      \    value of the MKI\n   Crypto context index params:\n     SSRC value\n     ROC\n
      \    SEQ\n     SRTCP Index\n     Transport address\n     Port number\n   Relation
      to other RTP profiles:\n     sender's order between FEC and SRTP FEC-SRTP      FEC-SRTP\n
      \    (see Section 10)\n"
    title: 8.2.  Key Management parameters
  title: 8.  Key Management Considerations
- contents:
  - '9. Security Considerations

    '
  - contents:
    - "9.1.  SSRC collision and two-time pad\n   Any fixed keystream output, generated
      from the same key and index\n   MUST only be used to encrypt once.  Re-using
      such keystream (jokingly\n   called a \"two-time pad\" system by cryptographers),
      can seriously\n   compromise security.  The NSA's VENONA project [C99] provides
      a\n   historical example of such a compromise.  It is REQUIRED that\n   automatic
      key management be used for establishing and maintaining\n   SRTP and SRTCP keying
      material; this requirement is to avoid\n   keystream reuse, which is more likely
      to occur with manual key\n   management.  Furthermore, in SRTP, a \"two-time
      pad\" is avoided by\n   requiring the key, or some other parameter of cryptographic\n
      \  significance, to be unique per RTP/RTCP stream and packet.  The pre-\n   defined
      SRTP transforms accomplish packet-uniqueness by including the\n   packet index
      and stream-uniqueness by inclusion of the SSRC.\n   The pre-defined transforms
      (AES-CM and AES-f8) allow master keys to\n   be shared across streams belonging
      to the same RTP session by the\n   inclusion of the SSRC in the IV.  A master
      key MUST NOT be shared\n   among different RTP sessions.\n   Thus, the SSRC
      MUST be unique between all the RTP streams within the\n   same RTP session that
      share the same master key.  RTP itself provides\n   an algorithm for detecting
      SSRC collisions within the same RTP\n   session.  Thus, temporary collisions
      could lead to temporary two-time\n   pad, in the unfortunate event that SSRCs
      collide at a point in time\n   when the streams also have identical sequence
      numbers (occurring with\n   probability roughly 2^(-48)).  Therefore, the key
      management SHOULD\n   take care of avoiding such SSRC collisions by including
      the SSRCs to\n   be used in the session as negotiation parameters, proactively\n
      \  assuring their uniqueness.  This is a strong requirements in\n   scenarios
      where for example, there are multiple senders that can\n   start to transmit
      simultaneously, before SSRC collision are detected\n   at the RTP level.\n   Note
      also that even with distinct SSRCs, extensive use of the same\n   key might
      improve chances of probabilistic collision and time-\n   memory-tradeoff attacks
      succeeding.\n   As described, master keys MAY be shared between streams belonging
      to\n   the same RTP session, but it is RECOMMENDED that each SSRC have its\n
      \  own master key.  When master keys are shared among SSRC participants\n   and
      SSRCs are managed by a key management module as recommended\n   above, the RECOMMENDED
      policy for an SSRC collision error is for the\n   participant to leave the SRTP
      session as it is a sign of malfunction.\n"
    title: 9.1.  SSRC collision and two-time pad
  - contents:
    - "9.2.  Key Usage\n   The effective key size is determined (upper bounded) by
      the size of\n   the master key and, for encryption, the size of the salting
      key.  Any\n   additive stream cipher is vulnerable to attacks that use statistical\n
      \  knowledge about the plaintext source to enable key collision and\n   time-memory
      tradeoff attacks [MF00] [H80] [BS00].  These attacks take\n   advantage of commonalities
      among plaintexts, and provide a way for a\n   cryptanalyst to amortize the computational
      effort of decryption over\n   many keys, or over many bytes of output, thus
      reducing the effective\n   key size of the cipher.  A detailed analysis of these
      attacks and\n   their applicability to the encryption of Internet traffic is
      provided\n   in [MF00].  In summary, the effective key size of SRTP when used
      in a\n   security system in which m distinct keys are used, is equal to the\n
      \  key size of the cipher less the logarithm (base two) of m.\n   Protection
      against such attacks can be provided simply by increasing\n   the size of the
      keys used, which here can be accomplished by the use\n   of the salting key.
      \ Note that the salting key MUST be random but MAY\n   be public.  A salt size
      of (the suggested) size 112 bits protects\n   against attacks in scenarios where
      at most 2^112 keys are in use.\n   This is sufficient for all practical purposes.\n
      \  Implementations SHOULD use keys that are as large as possible.\n   Please
      note that in many cases increasing the key size of a cipher\n   does not affect
      the throughput of that cipher.\n   The use of the SRTP and SRTCP indices in
      the pre-defined transforms\n   fixes the maximum number of packets that can
      be secured with the same\n   key.  This limit is fixed to 2^48 SRTP packets
      for an SRTP stream,\n   and 2^31 SRTCP packets, when SRTP and SRTCP are considered\n
      \  independently.  Due to for example re-keying, reaching this limit may\n   or
      may not coincide with wrapping of the indices, and thus the sender\n   MUST
      keep packet counts.  However, when the session keys for related\n   SRTP and
      SRTCP streams are derived from the same master key (the\n   default behavior,
      Section 4.3), the upper bound that has to be\n   considered is in practice the
      minimum of the two quantities.  That\n   is, when 2^48 SRTP packets or 2^31
      SRTCP packets have been secured\n   with the same key (whichever occurs before),
      the key management MUST\n   be called to provide new master key(s) (previously
      stored and used\n   keys MUST NOT be used again), or the session MUST be terminated.
      \ If\n   a sender of RTCP discovers that the sender of SRTP (or SRTCP) has not\n
      \  updated the master or session key prior to sending 2^48 SRTP (or 2^31\n   SRTCP)
      packets belonging to the same SRTP (SRTCP) stream, it is up to\n   the security
      policy of the RTCP sender how to behave, e.g., whether\n   an RTCP BYE-packet
      should be sent and/or if the event should be\n   logged.\n   Note: in most typical
      applications (assuming at least one RTCP packet\n   for every 128,000 RTP packets),
      it will be the SRTCP index that first\n   reaches the upper limit, although
      the time until this occurs is very\n   long: even at 200 SRTCP packets/sec,
      the 2^31 index space of SRTCP is\n   enough to secure approximately 4 months
      of communication.\n   Note that if the master key is to be shared between SRTP
      streams\n   within the same RTP session (Section 9.1), although the above bounds\n
      \  are on a per stream (i.e., per SSRC) basis, the sender MUST base re-\n   key
      decision on the stream whose sequence number space is the first\n   to be exhausted.\n
      \  Key derivation limits the amount of plaintext that is encrypted with\n   a
      fixed session key, and made available to an attacker for analysis,\n   but key
      derivation does not extend the master key's lifetime.  To see\n   this, simply
      consider our requirements to avoid two-time pad:  two\n   distinct packets MUST
      either be processed with distinct IVs, or with\n   distinct session keys, and
      both the distinctness of IV and of the\n   session keys are (for the pre-defined
      transforms) dependent on the\n   distinctness of the packet indices.\n   Note
      that with the key derivation, the effective key size is at most\n   that of
      the master key, even if the derived session key is\n   considerably longer.
      \ With the pre-defined authentication transform,\n   the session authentication
      key is 160 bits, but the master key by\n   default is only 128 bits.  This design
      choice was made to comply with\n   certain recommendations in [RFC2104] so that
      an existing HMAC\n   implementation can be plugged into SRTP without problems.
      \ Since the\n   default tag size is 80 bits, it is, for the applications in
      mind,\n   also considered acceptable from security point of view.  Users having\n
      \  concerns about this are RECOMMENDED to instead use a 192 bit master\n   key
      in the key derivation.  It was, however, chosen not to mandate\n   192-bit keys
      since existing AES implementations to be used in the\n   key-derivation may
      not always support key-lengths other than 128\n   bits.  Since AES is not defined
      (or properly analyzed) for use with\n   160 bit keys it is NOT RECOMMENDED that
      ad-hoc key-padding schemes\n   are used to pad shorter keys to 192 or 256 bits.\n"
    title: 9.2.  Key Usage
  - contents:
    - "9.3.  Confidentiality of the RTP Payload\n   SRTP's pre-defined ciphers are
      \"seekable\" stream ciphers, i.e.,\n   ciphers able to efficiently seek to arbitrary
      locations in their\n   keystream (so that the encryption or decryption of one
      packet does\n   not depend on preceding packets).  By using seekable stream
      ciphers,\n   SRTP avoids the denial of service attacks that are possible on
      stream\n   ciphers that lack this property.  It is important to be aware that,\n
      \  as with any stream cipher, the exact length of the payload is\n   revealed
      by the encryption.  This means that it may be possible to\n   deduce certain
      \"formatting bits\" of the payload, as the length of the\n   codec output might
      vary due to certain parameter settings etc.  This,\n   in turn, implies that
      the corresponding bit of the keystream can be\n   deduced.  However, if the
      stream cipher is secure (counter mode and\n   f8 are provably secure under certain
      assumptions [BDJR] [KSYH] [IK]),\n   knowledge of a few bits of the keystream
      will not aid an attacker in\n   predicting subsequent keystream bits.  Thus,
      the payload length (and\n   information deducible from this) will leak, but
      nothing else.\n   As some RTP packet could contain highly predictable data,
      e.g., SID,\n   it is important to use a cipher designed to resist known plaintext\n
      \  attacks (which is the current practice).\n"
    title: 9.3.  Confidentiality of the RTP Payload
  - contents:
    - "9.4.  Confidentiality of the RTP Header\n   In SRTP, RTP headers are sent in
      the clear to allow for header\n   compression.  This means that data such as
      payload type,\n   synchronization source identifier, and timestamp are available
      to an\n   eavesdropper.  Moreover, since RTP allows for future extensions of\n
      \  headers, we cannot foresee what kind of possibly sensitive\n   information
      might also be \"leaked\".\n   SRTP is a low-cost method, which allows header
      compression to reduce\n   bandwidth.  It is up to the endpoints' policies to
      decide about the\n   security protocol to employ.  If one really needs to protect
      headers,\n   and is allowed to do so by the surrounding environment, then one\n
      \  should also look at alternatives, e.g., IPsec [RFC2401].\n"
    title: 9.4.  Confidentiality of the RTP Header
  - contents:
    - "9.5.  Integrity of the RTP payload and header\n   SRTP messages are subject
      to attacks on their integrity and source\n   identification, and these risks
      are discussed in Section 9.5.1.  To\n   protect against these attacks, each
      SRTP stream SHOULD be protected\n   by HMAC-SHA1 [RFC2104] with an 80-bit output
      tag and a 160-bit key,\n   or a message authentication code with equivalent
      strength.  Secure\n   RTP SHOULD NOT be used without message authentication,
      except under\n   the circumstances described in this section.  It is important
      to note\n   that encryption algorithms, including AES Counter Mode and f8, do
      not\n   provide message authentication.  SRTCP MUST NOT be used with weak (or\n
      \  NULL) authentication.\n   SRTP MAY be used with weak authentication (e.g.,
      a 32-bit\n   authentication tag), or with no authentication (the NULL\n   authentication
      algorithm).  These options allow SRTP to be used to\n   provide confidentiality
      in situations where\n    * weak or null authentication is an acceptable security
      risk, and\n    * it is impractical to provide strong message authentication.\n
      \  These conditions are described below and in Section 7.5.  Note that\n   both
      conditions MUST hold in order for weak or null authentication to\n   be used.
      \ The risks associated with exercising the weak or null\n   authentication options
      need to be considered by a security audit\n   prior to their use for a particular
      application or environment given\n   the risks, which are discussed in Section
      9.5.1.\n   Weak authentication is acceptable when the RTP application is such\n
      \  that the effect of a small fraction of successful forgeries is\n   negligible.
      \ If the application is stateless, then the effect of a\n   single forged RTP
      packet is limited to the decoding of that\n   particular packet.  Under this
      condition, the size of the\n   authentication tag MUST ensure that only a negligible
      fraction of the\n   packets passed to the RTP application by the SRTP receiver
      can be\n   forgeries.  This fraction is negligible when an adversary, if given\n
      \  control of the forged packets, is not able to make a significant\n   impact
      on the output of the RTP application (see the example of\n   Section 7.5).\n
      \  Weak or null authentication MAY be acceptable when it is unlikely\n   that
      an adversary can modify ciphertext so that it decrypts to an\n   intelligible
      value.  One important case is when it is difficult for\n   an adversary to acquire
      the RTP plaintext data, since for many\n   codecs, an adversary that does not
      know the input signal cannot\n   manipulate the output signal in a controlled
      way.  In many cases it\n   may be difficult for the adversary to determine the
      actual value of\n   the plaintext.  For example, a hidden snooping device might
      be\n   required in order to know a live audio or video signal.  The\n   adversary's
      signal must have a quality equivalent to or greater than\n   that of the signal
      under attack, since otherwise the adversary would\n   not have enough information
      to encode that signal with the codec used\n   by the victim.  Plaintext prediction
      may also be especially difficult\n   for an interactive application such as
      a telephone call.\n   Weak or null authentication MUST NOT be used when the
      RTP application\n   makes data forwarding or access control decisions based
      on the RTP\n   data.  In such a case, an attacker may be able to subvert\n   confidentiality
      by causing the receiver to forward data to an\n   attacker.  See Section 3 of
      [B96] for a real-life example of such\n   attacks.\n   Null authentication MUST
      NOT be used when a replay attack, in which\n   an adversary stores packets then
      replays them later in the session,\n   could have a non-negligible impact on
      the receiver.  An example of a\n   successful replay attack is the storing of
      the output of a\n   surveillance camera for a period of time, later followed
      by the\n   injection of that output to the monitoring station to avoid\n   surveillance.
      \ Encryption does not protect against this attack, and\n   non-null authentication
      is REQUIRED in order to defeat it.\n   If existential message forgery is an
      issue, i.e., when the accuracy\n   of the received data is of non-negligible
      importance, null\n   authentication MUST NOT be used.\n"
    - contents:
      - "9.5.1.  Risks of Weak or Null Message Authentication\n   During a security
        audit considering the use of weak or null\n   authentication, it is important
        to keep in mind the following attacks\n   which are possible when no message
        authentication algorithm is used.\n   An attacker who cannot predict the plaintext
        is still always able to\n   modify the message sent between the sender and
        the receiver so that\n   it decrypts to a random plaintext value, or to send
        a stream of bogus\n   packets to the receiver that will decrypt to random
        plaintext values.\n   This attack is essentially a denial of service attack,
        though in the\n   absence of message authentication, the RTP application will
        have\n   inputs that are bit-wise correlated with the true value.  Some\n
        \  multimedia codecs and common operating systems will crash when such\n   data
        are accepted as valid video data.  This denial of service attack\n   may be
        a much larger threat than that due to an attacker dropping,\n   delaying,
        or re-ordering packets.\n   An attacker who cannot predict the plaintext can
        still replay a\n   previous message with certainty that the receiver will
        accept it.\n   Applications with stateless codecs might be robust against
        this type\n   of attack, but for other, more complex applications these attacks
        may\n   be far more grave.\n   An attacker who can predict the plaintext can
        modify the ciphertext\n   so that it will decrypt to any value of her choosing.
        \ With an\n   additive stream cipher, an attacker will always be able to change\n
        \  individual bits.\n   An attacker may be able to subvert confidentiality
        due to the lack of\n   authentication when a data forwarding or access control
        decision is\n   made on decrypted but unauthenticated plaintext.  This is
        because the\n   receiver may be fooled into forwarding data to an attacker,
        leading\n   to an indirect breach of confidentiality (see Section 3 of [B96]).\n
        \  This is because data-forwarding decisions are made on the decrypted\n   plaintext;
        information in the plaintext will determine to what subnet\n   (or process)
        the plaintext is forwarded in ESP [RFC2401] tunnel mode\n   (respectively,
        transport mode).  When Secure RTP is used without\n   message authentication,
        it should be verified that the application\n   does not make data forwarding
        or access control decisions based on\n   the decrypted plaintext.\n   Some
        cipher modes of operation that require padding, e.g., standard\n   cipher
        block chaining (CBC) are very sensitive to attacks on\n   confidentiality
        if certain padding types are used in the absence of\n   integrity.  The attack
        [V02] shows that this is indeed the case for\n   the standard RTP padding
        as discussed in reference to Figure 1, when\n   used together with CBC mode.
        \ Later transform additions to SRTP MUST\n   therefore carefully consider
        the risk of using this padding without\n   proper integrity protection.\n"
      title: 9.5.1.  Risks of Weak or Null Message Authentication
    - contents:
      - "9.5.2.  Implicit Header Authentication\n   The IV formation of the f8-mode
        gives implicit authentication (IHA)\n   of the RTP header, even when message
        authentication is not used.\n   When IHA is used, an attacker that modifies
        the value of the RTP\n   header will cause the decryption process at the receiver
        to produce\n   random plaintext values.  While this protection is not equivalent
        to\n   message authentication, it may be useful for some applications.\n"
      title: 9.5.2.  Implicit Header Authentication
    title: 9.5.  Integrity of the RTP payload and header
  title: 9. Security Considerations
- contents:
  - "10.  Interaction with Forward Error Correction mechanisms\n   The default processing
    when using Forward Error Correction (e.g., RFC\n   2733) processing with SRTP
    SHALL be to perform FEC processing prior\n   to SRTP processing on the sender
    side and to perform SRTP processing\n   prior to FEC processing on the receiver
    side.  Any change to this\n   ordering (reversing it, or, placing FEC between
    SRTP encryption and\n   SRTP authentication) SHALL be signaled out of band.\n"
  title: 10.  Interaction with Forward Error Correction mechanisms
- contents:
  - "11.  Scenarios\n   SRTP can be used as security protocol for the RTP/RTCP traffic
    in\n   many different scenarios.  SRTP has a number of configuration\n   options,
    in particular regarding key usage, and can have impact on\n   the total performance
    of the application according to the way it is\n   used.  Hence, the use of SRTP
    is dependent on the kind of scenario\n   and application it is used with.  In
    the following, we briefly\n   illustrate some use cases for SRTP, and give some
    guidelines for\n   recommended setting of its options.\n"
  - contents:
    - "11.1.  Unicast\n   A typical example would be a voice call or video-on-demand\n
      \  application.\n   Consider one bi-directional RTP stream, as one RTP session.
      \ It is\n   possible for the two parties to share the same master key in the
      two\n   directions according to the principles of Section 9.1.  The first\n
      \  round of the key derivation splits the master key into any or all of\n   the
      following session keys (according to the provided security\n   functions):\n
      \  SRTP_encr_key, SRTP_auth_key, SRTCP_encr_key, and SRTCP_auth key.\n   (For
      simplicity, we omit discussion of the salts, which are also\n   derived.)  In
      this scenario, it will in most cases suffice to have a\n   single master key
      with the default lifetime.  This guarantees\n   sufficiently long lifetime of
      the keys and a minimum set of keys in\n   place for most practical purposes.
      \ Also, in this case RTCP\n   protection can be applied smoothly.  Under these
      assumptions, use of\n   the MKI can be omitted.  As the key-derivation in combination
      with\n   large difference in the packet rate in the respective directions may\n
      \  require simultaneous storage of several session keys, if storage is\n   an
      issue, we recommended to use low-rate key derivation.\n   The same considerations
      can be extended to the unicast scenario with\n   multiple RTP sessions, where
      each session would have a distinct\n   master key.\n"
    title: 11.1.  Unicast
  - contents:
    - "11.2.  Multicast (one sender)\n   Just as with (unprotected) RTP, a scalability
      issue arises in big\n   groups due to the possibly very large amount of SRTCP
      Receiver\n   Reports that the sender might need to process.  In SRTP, the sender\n
      \  may have to keep state (the cryptographic context) for each receiver,\n   or
      more precisely, for the SRTCP used to protect Receiver Reports.\n   The overhead
      increases proportionally to the size of the group.  In\n   particular, re-keying
      requires special concern, see below.\n   Consider first a small group of receivers.
      \ There are a few possible\n   setups with the distribution of master keys among
      the receivers.\n   Given a single RTP session, one possibility is that the receivers\n
      \  share the same master key as per Section 9.1 to secure all their\n   respective
      RTCP traffic.  This shared master key could then be the\n   same one used by
      the sender to protect its outbound SRTP traffic.\n   Alternatively, it could
      be a master key shared only among the\n   receivers and used solely for their
      SRTCP traffic.  Both alternatives\n   require the receivers to trust each other.\n
      \  Considering SRTCP and key storage, it is recommended to use low-rate\n   (or
      zero) key_derivation (except the mandatory initial one), so that\n   the sender
      does not need to store too many session keys (each SRTCP\n   stream might otherwise
      have a different session key at a given point\n   in time, as the SRTCP sources
      send at different times).  Thus, in\n   case key derivation is wanted for SRTP,
      the cryptographic context for\n   SRTP can be kept separate from the SRTCP crypto
      context, so that it\n   is possible to have a key_derivation_rate of 0 for SRTCP
      and a non-\n   zero value for SRTP.\n   Use of the MKI for re-keying is RECOMMENDED
      for most applications\n   (see Section 8.1).\n   If there are more than one
      SRTP/SRTCP stream (within the same RTP\n   session) that share the master key,
      the upper limit of 2^48 SRTP\n   packets / 2^31 SRTCP packets means that, before
      one of the streams\n   reaches its maximum number of packets, re-keying MUST
      be triggered on\n   ALL streams sharing the master key.  (From strict security
      point of\n   view, only the stream reaching the maximum would need to be re-keyed,\n
      \  but then the streams would no longer be sharing master key, which is\n   the
      intention.)  A local policy at the sender side should force\n   rekeying in
      a way that the maximum packet limit is not reached on any\n   of the streams.
      \ Use of the MKI for re-keying is RECOMMENDED.\n   In large multicast with one
      sender, the same considerations as for\n   the small group multicast hold.  The
      biggest issue in this scenario\n   is the additional load placed at the sender
      side, due to the state\n   (cryptographic contexts) that has to be maintained
      for each receiver,\n   sending back RTCP Receiver Reports.  At minimum, a replay
      window\n   might need to be maintained for each RTCP source.\n"
    title: 11.2.  Multicast (one sender)
  - contents:
    - "11.3.  Re-keying and access control\n   Re-keying may occur due to access control
      (e.g., when a member is\n   removed during a multicast RTP session), or for
      pure cryptographic\n   reasons (e.g., the key is at the end of its lifetime).
      \ When using\n   SRTP default transforms, the master key MUST be replaced before
      any\n   of the index spaces are exhausted for any of the streams protected by\n
      \  one and the same master key.\n   How key management re-keys SRTP implementations
      is out of scope, but\n   it is clear that there are straightforward ways to
      manage keys for a\n   multicast group.  In one-sender multicast, for example,
      it is\n   typically the responsibility of the sender to determine when a new\n
      \  key is needed.  The sender is the one entity that can keep track of\n   when
      the maximum number of packets has been sent, as receivers may\n   join and leave
      the session at any time, there may be packet loss and\n   delay etc.  In scenarios
      other than one-sender multicast, other\n   methods can be used.  Here, one must
      take into consideration that key\n   exchange can be a costly operation, taking
      several seconds for a\n   single exchange.  Hence, some time before the master
      key is\n   exhausted/expires, out-of-band key management is initiated, resulting\n
      \  in a new master key that is shared with the receiver(s).  In any\n   event,
      to maintain synchronization when switching to the new key,\n   group policy
      might choose between using the MKI and the <From, To>,\n   as described in Section
      8.1.\n   For access control purposes, the <From, To> periods are set at the\n
      \  desired granularity, dependent on the packet rate.  High rate re-\n   keying
      can be problematic for SRTCP in some large-group scenarios.\n   As mentioned,
      there are potential problems in using the SRTP index,\n   rather than the SRTCP
      index, for determining the master key.  In\n   particular, for short periods
      during switching of master keys, it may\n   be the case that SRTCP packets are
      not under the current master key\n   of the correspondent SRTP.  Therefore,
      using the MKI for re-keying in\n   such scenarios will produce better results.\n"
    title: 11.3.  Re-keying and access control
  - contents:
    - "11.4.  Summary of basic scenarios\n   The description of these scenarios highlights
      some recommendations on\n   the use of SRTP, mainly related to re-keying and
      large scale\n   multicast:\n   - Do not use fast re-keying with the <From, To>
      feature.  It may, in\n     particular, give problems in retrieving the correct
      SRTCP key, if\n     an SRTCP packet arrives close to the re-keying time.  The
      MKI\n     SHOULD be used in this case.\n   - If multiple SRTP streams in the
      same RTP session share the same\n     master key, also moderate rate re-keying
      MAY have the same\n     problems, and the MKI SHOULD be used.\n   - Though offering
      increased security, a non-zero key_derivation_rate\n     is NOT RECOMMENDED
      when trying to minimize the number of keys in\n     use with multiple streams.\n"
    title: 11.4.  Summary of basic scenarios
  title: 11.  Scenarios
- contents:
  - "12.  IANA Considerations\n   The RTP specification establishes a registry of
    profile names for use\n   by higher-level control protocols, such as the Session
    Description\n   Protocol (SDP), to refer to transport methods.  This profile\n
    \  registers the name \"RTP/SAVP\".\n   SRTP uses cryptographic transforms which
    a key management protocol\n   signals.  It is the task of each particular key
    management protocol\n   to register the cryptographic transforms or suites of
    transforms with\n   IANA.  The key management protocol conveys these protocol
    numbers,\n   not SRTP, and each key management protocol chooses the numbering\n
    \  scheme and syntax that it requires.\n   Specification of a key management protocol
    for SRTP is out of scope\n   here.  Section 8.2, however, provides guidance on
    the parameters that\n   need to be defined for the default and mandatory transforms.\n"
  title: 12.  IANA Considerations
- contents:
  - "13.  Acknowledgements\n   David Oran (Cisco) and Rolf Blom (Ericsson) are co-authors
    of this\n   document but their valuable contributions are acknowledged here to\n
    \  keep the length of the author list down.\n   The authors would in addition
    like to thank Magnus Westerlund, Brian\n   Weis, Ghyslain Pelletier, Morgan Lindqvist,
    Robert Fairlie-\n   Cuninghame, Adrian Perrig, the AVT WG and in particular the
    chairmen\n   Colin Perkins and Stephen Casner, the Transport and Security Area\n
    \  Directors, and Eric Rescorla for their reviews and support.\n"
  title: 13.  Acknowledgements
- contents:
  - '14.  References

    '
  - contents:
    - "14.1.  Normative References\n   [AES]     NIST, \"Advanced Encryption Standard
      (AES)\", FIPS PUB 197,\n             http://www.nist.gov/aes/\n   [RFC2104]
      Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC:  Keyed-\n             Hashing
      for Message Authentication\", RFC 2104, February\n             1997.\n   [RFC2119]
      Bradner, S., \"Key words for use in RFCs to Indicate\n             Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2401] Kent, S. and R. Atkinson,
      \"Security Architecture for\n             Internet Protocol\", RFC 2401, November
      1998.\n   [RFC2828] Shirey, R., \"Internet Security Glossary\", FYI 36, RFC
      2828,\n             May 2000.\n   [RFC3550] Schulzrinne, H., Casner, S., Frederick,
      R. and V. Jacobson,\n             \"RTP: A Transport Protocol for Real-time
      Applications\", RFC\n             3550, July 2003.\n   [RFC3551] Schulzrinne,
      H. and S. Casner, \"RTP Profile for Audio and\n             Video Conferences
      with Minimal Control\",  RFC 3551, July\n             2003.\n"
    title: 14.1.  Normative References
  - contents:
    - "14.2.  Informative References\n   [AES-CTR] Lipmaa, H., Rogaway, P. and D.
      Wagner, \"CTR-Mode\n             Encryption\", NIST, http://csrc.nist.gov/encryption/modes/\n
      \            workshop1/papers/lipmaa-ctr.pdf\n   [B96]     Bellovin, S., \"Problem
      Areas for the IP Security\n             Protocols,\" in Proceedings of the Sixth
      Usenix Unix\n             Security Symposium, pp. 1-16, San Jose, CA, July 1996\n
      \            (http://www.research.att.com/~smb/papers/index.html).\n   [BDJR]
      \   Bellare, M., Desai, A., Jokipii, E. and P. Rogaway, \"A\n             Concrete
      Treatment of Symmetric Encryption: Analysis of DES\n             Modes of Operation\",
      Proceedings 38th IEEE FOCS, pp. 394-\n             403, 1997.\n   [BS00]    Biryukov,
      A. and A. Shamir, \"Cryptanalytic Time/Memory/Data\n             Tradeoffs for
      Stream Ciphers\", Proceedings, ASIACRYPT 2000,\n             LNCS 1976, pp.
      1-13, Springer Verlag.\n   [C99]     Crowell, W. P., \"Introduction to the VENONA
      Project\",\n             http://www.nsa.gov:8080/docs/venona/index.html.\n   [CTR]
      \    Dworkin, M., NIST Special Publication 800-38A,\n             \"Recommendation
      for Block Cipher Modes of Operation:\n             Methods and Techniques\",
      2001.\n             http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-\n
      \            38a.pdf.\n   [f8-a]    3GPP TS 35.201 V4.1.0 (2001-12) Technical
      Specification 3rd\n             Generation Partnership Project; Technical Specification\n
      \            Group Services and System Aspects; 3G Security;\n             Specification
      of the 3GPP Confidentiality and Integrity\n             Algorithms; Document
      1: f8 and f9 Specification (Release\n             4).\n   [f8-b]    3GPP TR
      33.908 V4.0.0 (2001-09) Technical Report 3rd\n             Generation Partnership
      Project; Technical Specification\n             Group Services and System Aspects;
      3G Security; General\n             Report on the Design, Specification and Evaluation
      of 3GPP\n             Standard Confidentiality and Integrity Algorithms (Release\n
      \            4).\n   [GDOI]    Baugher, M., Weis, B., Hardjono, T. and H. Harney,
      \"The\n             Group Domain of Interpretation, RFC 3547, July 2003.\n   [HAC]
      \    Menezes, A., Van Oorschot, P. and  S. Vanstone, \"Handbook\n             of
      Applied Cryptography\", CRC Press, 1997, ISBN 0-8493-\n             8523-7.\n
      \  [H80]     Hellman, M. E., \"A cryptanalytic time-memory trade-off\",\n             IEEE
      Transactions on Information Theory, July 1980, pp.\n             401-406.\n
      \  [IK]      T. Iwata and T. Kohno: \"New Security Proofs for the 3GPP\n             Confidentiality
      and Integrity Algorithms\", Proceedings of\n             FSE 2004.\n   [KINK]
      \   Thomas, M. and J. Vilhuber, \"Kerberized Internet\n             Negotiation
      of Keys (KINK)\", Work in Progress.\n   [KEYMGT]  Arrko, J., et al., \"Key Management
      Extensions for Session\n             Description Protocol (SDP) and Real Time
      Streaming Protocol\n             (RTSP)\", Work in Progress.\n   [KSYH]    Kang,
      J-S., Shin, S-U., Hong, D. and O. Yi, \"Provable\n             Security of KASUMI
      and 3GPP Encryption Mode f8\",\n             Proceedings Asiacrypt 2001, Springer
      Verlag LNCS 2248, pp.\n             255-271, 2001.\n   [MIKEY]   Arrko, J.,
      et. al., \"MIKEY: Multimedia Internet KEYing\",\n             Work in Progress.\n
      \  [MF00]    McGrew, D. and S. Fluhrer, \"Attacks on Encryption of\n             Redundant
      Plaintext and Implications on Internet Security\",\n             the Proceedings
      of the Seventh Annual Workshop on Selected\n             Areas in Cryptography
      (SAC 2000), Springer-Verlag.\n   [PCST1]   Perrig, A., Canetti, R., Tygar, D.
      and D.  Song, \"Efficient\n             and Secure Source Authentication for
      Multicast\", in Proc.\n             of Network and Distributed System Security
      Symposium NDSS\n             2001, pp. 35-46, 2001.\n   [PCST2]   Perrig, A.,
      Canetti, R., Tygar, D. and D. Song, \"Efficient\n             Authentication
      and Signing of Multicast Streams over Lossy\n             Channels\", in Proc.
      of IEEE Security and Privacy Symposium\n             S&P2000, pp. 56-73, 2000.\n
      \  [RFC1750] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness\n             Recommendations
      for Security\", RFC 1750, December 1994.\n   [RFC2675] Borman, D., Deering,
      S. and R. Hinden, \"IPv6 Jumbograms\",\n             RFC 2675, August 1999.\n
      \  [RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukuhsima, H.,\n             Hannu,
      H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K.,\n             Liu, Z.,
      Martensson, A., Miyazaki, A., Svanbro, K., Wiebke,\n             T., Yoshimura,
      T. and H. Zheng, \"RObust Header Compression:\n             Framework and Four
      Profiles: RTP, UDP, ESP, and\n             uncompressed (ROHC)\", RFC 3095,
      July 2001.\n   [RFC3242] Jonsson, L-E. and G. Pelletier, \"RObust Header Compression\n
      \            (ROHC): A Link-Layer Assisted Profile for IP/UDP/RTP \", RFC\n
      \            3242, April 2002.\n   [SDMS]    Andreasen, F., Baugher, M. and
      D. Wing, \"Session\n             Description Protocol Security Descriptions
      for Media\n             Streams\", Work in Progress.\n   [SWO]     Svanbro,
      K., Wiorek, J. and B. Olin, \"Voice-over-IP-over-\n             wireless\",
      Proc.  PIMRC 2000, London, Sept. 2000.\n   [V02]     Vaudenay, S., \"Security
      Flaws Induced by CBC Padding -\n             Application to SSL, IPsec, WTLS...\",
      Advances in\n             Cryptology, EUROCRYPT'02, LNCS 2332, pp. 534-545.\n
      \  [WC81]    Wegman, M. N., and  J.L. Carter, \"New Hash Functions and\n             Their
      Use in Authentication and Set Equality\", JCSS 22,\n             265-279, 1981.\n"
    title: 14.2.  Informative References
  title: 14.  References
- contents:
  - "Appendix A: Pseudocode for Index Determination\n   The following is an example
    of pseudo-code for the algorithm to\n   determine the index i of an SRTP packet
    with sequence number SEQ.  In\n   the following, signed arithmetic is assumed.\n
    \        if (s_l < 32,768)\n            if (SEQ - s_l > 32,768)\n               set
    v to (ROC-1) mod 2^32\n            else\n               set v to ROC\n            endif\n
    \        else\n            if (s_l - 32,768 > SEQ)\n               set v to (ROC+1)
    mod 2^32\n            else\n               set v to ROC\n            endif\n         endif\n
    \        return SEQ + v*65,536\n"
  title: 'Appendix A: Pseudocode for Index Determination'
- contents:
  - "Appendix B: Test Vectors\n   All values are in hexadecimal.\n"
  - contents:
    - "B.1.  AES-f8 Test Vectors\n   SRTP PREFIX LENGTH  :   0\n   RTP packet header
      \  :   806e5cba50681de55c621599\n   RTP packet payload  :   70736575646f72616e646f6d6e657373\n
      \                          20697320746865206e65787420626573\n                           74207468696e67\n
      \  ROC                 :   d462564a\n   key                 :   234829008467be186c3de14aae72d62c\n
      \  salt key            :   32f2870d\n   key-mask (m)        :   32f2870d555555555555555555555555\n
      \  key XOR key-mask    :   11baae0dd132eb4d3968b41ffb278379\n   IV                  :
      \  006e5cba50681de55c621599d462564a\n   IV'                 :   595b699bbd3bc0df26062093c1ad8f73\n
      \  j = 0\n   IV' xor j           :   595b699bbd3bc0df26062093c1ad8f73\n   S(-1)
      \              :   00000000000000000000000000000000\n   IV' xor S(-1) xor j
      :   595b699bbd3bc0df26062093c1ad8f73\n   S(0)                :   71ef82d70a172660240709c7fbb19d8e\n
      \  plaintext           :   70736575646f72616e646f6d6e657373\n   ciphertext          :
      \  019ce7a26e7854014a6366aa95d4eefd\n   j = 1\n   IV' xor j           :   595b699bbd3bc0df26062093c1ad8f72\n
      \  S(0)                :   71ef82d70a172660240709c7fbb19d8e\n   IV' xor S(0)
      xor j  :   28b4eb4cb72ce6bf020129543a1c12fc\n   S(1)                :   3abd640a60919fd43bd289a09649b5fc\n
      \  plaintext           :   20697320746865206e65787420626573\n   ciphertext          :
      \  1ad4172a14f9faf455b7f1d4b62bd08f\n   j = 2\n   IV' xor j           :   595b699bbd3bc0df26062093c1ad8f71\n
      \  S(1)                :   3abd640a60919fd43bd289a09649b5fc\n   IV' xor S(1)
      xor j  :   63e60d91ddaa5f0b1dd4a93357e43a8d\n   S(2)                :   220c7a8715266565b09ecc8a2a62b11b\n
      \  plaintext           :   74207468696e67\n   ciphertext          :   562c0eef7c4802\n"
    title: B.1.  AES-f8 Test Vectors
  - contents:
    - "B.2.  AES-CM Test Vectors\n    Keystream segment length: 1044512 octets (65282
      AES blocks)\n    Session Key:      2B7E151628AED2A6ABF7158809CF4F3C\n    Rollover
      Counter: 00000000\n    Sequence Number:  0000\n    SSRC:             00000000\n
      \   Session Salt:     F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000 (already shifted)\n    Offset:
      \          F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000\n    Counter                            Keystream\n
      \   F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000   E03EAD0935C95E80E166B16DD92B4EB4\n    F0F1F2F3F4F5F6F7F8F9FAFBFCFD0001
      \  D23513162B02D0F72A43A2FE4A5F97AB\n    F0F1F2F3F4F5F6F7F8F9FAFBFCFD0002   41E95B3BB0A2E8DD477901E4FCA894C0\n
      \   ...                                ...\n    F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF
      \  EC8CDF7398607CB0F2D21675EA9EA1E4\n    F0F1F2F3F4F5F6F7F8F9FAFBFCFDFF00   362B7C3C6773516318A077D7FC5073AE\n
      \   F0F1F2F3F4F5F6F7F8F9FAFBFCFDFF01   6A2CC3787889374FBEB4C81B17BA6C44\n   Nota
      Bene: this test case is contrived so that the latter part of the\n   keystream
      segment coincides with the test case in Section F.5.1 of\n   [CTR].\n"
    title: B.2.  AES-CM Test Vectors
  - contents:
    - "B.3.  Key Derivation Test Vectors\n   This section provides test data for the
      default key derivation\n   function, which uses AES-128 in Counter Mode.  In
      the following, we\n   walk through the initial key derivation for the AES-128
      Counter Mode\n   cipher, which requires a 16 octet session encryption key and
      a 14\n   octet session salt, and an authentication function which requires a\n
      \  94-octet session authentication key.  These values are called the\n   cipher
      key, the cipher salt, and the auth key in the following.\n   Since this is the
      initial key derivation and the key derivation rate\n   is equal to zero, the
      value of (index DIV key_derivation_rate) is\n   zero (actually, a six-octet
      string of zeros).  In the following, we\n   shorten key_derivation_rate to kdr.\n
      \  The inputs to the key derivation function are the 16 octet master key\n   and
      the 14 octet master salt:\n      master key:  E1F97A0D3E018BE0D64FA32C06DE4139\n
      \     master salt: 0EC675AD498AFEEBB6960B3AABE6\n   We first show how the cipher
      key is generated.  The input block for\n   AES-CM is generated by exclusive-oring
      the master salt with the\n   concatenation of the encryption key label 0x00
      with (index DIV kdr),\n   then padding on the right with two null octets (which
      implements the\n   multiply-by-2^16 operation, see Section 4.3.3).  The resulting
      value\n   is then AES-CM- encrypted using the master key to get the cipher key.\n
      \     index DIV kdr:                 000000000000\n      label:                       00\n
      \     master salt:   0EC675AD498AFEEBB6960B3AABE6\n      -----------------------------------------------\n
      \     xor:           0EC675AD498AFEEBB6960B3AABE6     (x, PRF input)\n      x*2^16:
      \       0EC675AD498AFEEBB6960B3AABE60000 (AES-CM input)\n      cipher key:    C61E7A93744F39EE10734AFE3FF7A087
      (AES-CM output)\n   Next, we show how the cipher salt is generated.  The input
      block for\n   AES-CM is generated by exclusive-oring the master salt with the\n
      \  concatenation of the encryption salt label.  That value is padded and\n   encrypted
      as above.\n      index DIV kdr:                 000000000000\n      label:                       02\n
      \     master salt:   0EC675AD498AFEEBB6960B3AABE6\n      ----------------------------------------------\n
      \     xor:           0EC675AD498AFEE9B6960B3AABE6     (x, PRF input)\n      x*2^16:
      \       0EC675AD498AFEE9B6960B3AABE60000 (AES-CM input)\n                     30CBBC08863D8C85D49DB34A9AE17AC6
      (AES-CM ouptut)\n      cipher salt:   30CBBC08863D8C85D49DB34A9AE1\n   We now
      show how the auth key is generated.  The input block for AES-\n   CM is generated
      as above, but using the authentication key label.\n      index DIV kdr:                   000000000000\n
      \     label:                         01\n      master salt:     0EC675AD498AFEEBB6960B3AABE6\n
      \     -----------------------------------------------\n      xor:             0EC675AD498AFEEAB6960B3AABE6
      \    (x, PRF input)\n      x*2^16:          0EC675AD498AFEEAB6960B3AABE60000
      (AES-CM input)\n   Below, the auth key is shown on the left, while the corresponding
      AES\n   input blocks are shown on the right.\n   auth key                           AES
      input blocks\n   CEBE321F6FF7716B6FD4AB49AF256A15   0EC675AD498AFEEAB6960B3AABE60000\n
      \  6D38BAA48F0A0ACF3C34E2359E6CDBCE   0EC675AD498AFEEAB6960B3AABE60001\n   E049646C43D9327AD175578EF7227098
      \  0EC675AD498AFEEAB6960B3AABE60002\n   6371C10C9A369AC2F94A8C5FBCDDDC25   0EC675AD498AFEEAB6960B3AABE60003\n
      \  6D6E919A48B610EF17C2041E47403576   0EC675AD498AFEEAB6960B3AABE60004\n   6B68642C59BBFC2F34DB60DBDFB2
      \      0EC675AD498AFEEAB6960B3AABE60005\n"
    title: B.3.  Key Derivation Test Vectors
  title: 'Appendix B: Test Vectors'
- contents:
  - "Authors' Addresses\n   Questions and comments should be directed to the authors
    and\n   avt@ietf.org:\n   Mark Baugher\n   Cisco Systems, Inc.\n   5510 SW Orchid
    Street\n   Portland, OR 97219 USA\n   Phone:  +1 408-853-4418\n   EMail:  mbaugher@cisco.com\n
    \  Elisabetta Carrara\n   Ericsson Research\n   SE-16480 Stockholm\n   Sweden\n
    \  Phone:  +46 8 50877040\n   EMail:  elisabetta.carrara@ericsson.com\n   David
    A. McGrew\n   Cisco Systems, Inc.\n   San Jose, CA 95134-1706\n   USA\n   Phone:
    \ +1 301-349-5815\n   EMail:  mcgrew@cisco.com\n   Mats Naslund\n   Ericsson Research\n
    \  SE-16480 Stockholm\n   Sweden\n   Phone:  +46 8 58533739\n   EMail:  mats.naslund@ericsson.com\n
    \  Karl Norrman\n   Ericsson Research\n   SE-16480 Stockholm\n   Sweden\n   Phone:
    \ +46 8 4044502\n   EMail:  karl.norrman@ericsson.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).  This
    document is subject\n   to the rights, licenses and restrictions contained in
    BCP 78 and\n   except as set forth therein, the authors retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
