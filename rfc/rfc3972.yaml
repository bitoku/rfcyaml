- title: __initial_text__
  contents:
  - '              Cryptographically Generated Addresses (CGA)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a method for binding a public signature\
    \ key\n   to an IPv6 address in the Secure Neighbor Discovery (SEND) protocol.\n\
    \   Cryptographically Generated Addresses (CGA) are IPv6 addresses for\n   which\
    \ the interface identifier is generated by computing a\n   cryptographic one-way\
    \ hash function from a public key and auxiliary\n   parameters.  The binding between\
    \ the public key and the address can\n   be verified by re-computing the hash\
    \ value and by comparing the hash\n   with the interface identifier.  Messages\
    \ sent from an IPv6 address\n   can be protected by attaching the public key and\
    \ auxiliary parameters\n   and by signing the message with the corresponding private\
    \ key.  The\n   protection works without a certification authority or any security\n\
    \   infrastructure.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  CGA Format . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   3.  CGA Parameters and Hash Values . . . . . . . . . . . .\
    \ . . . .  5\n   4.  CGA Generation . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  6\n   5.  CGA Verification . . . . . . . . . . . . . . . . . . . . .\
    \ . .  9\n   6.  CGA Signatures . . . . . . . . . . . . . . . . . . . . . . .\
    \ . 10\n   7.  Security Considerations  . . . . . . . . . . . . . . . . . . .\
    \ 12\n       7.1.  Security Goals and Limitations . . . . . . . . . . . . . 12\n\
    \       7.2.  Hash Extension . . . . . . . . . . . . . . . . . . . . . 13\n  \
    \     7.3.  Privacy Considerations . . . . . . . . . . . . . . . . . 15\n    \
    \   7.4.  Related Protocols  . . . . . . . . . . . . . . . . . . . 15\n   8. \
    \ IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 16\n   9.  References\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n       9.1.  Normative\
    \ References . . . . . . . . . . . . . . . . . . 17\n       9.2.  Informative\
    \ References . . . . . . . . . . . . . . . . . 18\n   Appendices . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . 20\n       A.  Example of CGA Generation.\
    \ . . . . . . . . . . . . . . . . 20\n       B.  Acknowledgements . . . . . .\
    \ . . . . . . . . . . . . . . . 21\n   Author's Address . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . 21\n   Full Copyright Statements. . . . . . . .\
    \ . . . . . . . . . . . . . 22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies a method for securely associating\
    \ a\n   cryptographic public key with an IPv6 address in the Secure Neighbor\n\
    \   Discovery (SEND) protocol [RFC3971].  The basic idea is to generate\n   the\
    \ interface identifier (i.e., the rightmost 64 bits) of the IPv6\n   address by\
    \ computing a cryptographic hash of the public key.  The\n   resulting IPv6 address\
    \ is called a cryptographically generated\n   address (CGA).  The corresponding\
    \ private key can then be used to\n   sign messages sent from the address.  An\
    \ introduction to CGAs and\n   their application to SEND can be found in [Aura03]\
    \ and [AAKMNR02].\n   This document specifies:\n   o  how to generate a CGA from\
    \ the cryptographic hash of a public key\n      and auxiliary parameters,\n  \
    \ o  how to verify the association between the public key and the CGA,\n     \
    \ and\n   o  how to sign a message sent from the CGA, and how to verify the\n\
    \      signature.\n   To verify the association between the address and the public\
    \ key, the\n   verifier needs to know the address itself, the public key, and\
    \ the\n   values of the auxiliary parameters.  The verifier can then go on to\n\
    \   verify messages signed by the owner of the public key (i.e., the\n   address\
    \ owner).  No additional security infrastructure, such as a\n   public key infrastructure\
    \ (PKI), certification authorities, or other\n   trusted servers, is needed.\n\
    \   Note that because CGAs themselves are not certified, an attacker can\n   create\
    \ a new CGA from any subnet prefix and its own (or anyone\n   else's) public key.\
    \  However, the attacker cannot take a CGA created\n   by someone else and send\
    \ signed messages that appear to come from the\n   owner of that address.\n  \
    \ The address format and the CGA parameter format are defined in\n   Sections\
    \ 2 and 3.  Detailed algorithms for generating addresses and\n   for verifying\
    \ them are given in Sections 4 and 5, respectively.\n   Section 6 defines the\
    \ procedures for generating and verifying CGA\n   signatures.  The security considerations\
    \ in Section 7 include\n   limitations of CGA-based security, the reasoning behind\
    \ the hash\n   extension technique that enables effective hash lengths above the\n\
    \   64-bit limit of the interface identifier, the implications of CGAs on\n  \
    \ privacy, and protection against related-protocol attacks.\n   In this document,\
    \ the key words MUST, MUST NOT, REQUIRED, SHALL,\n   SHALL NOT, SHOULD, SHOULD\
    \ NOT, RECOMMENDED, MAY, and OPTIONAL are to\n   be interpreted as described in\
    \ [RFC2119].\n"
- title: 2.  CGA Format
  contents:
  - "2.  CGA Format\n   When talking about addresses, this document refers to IPv6\
    \ addresses\n   in which the leftmost 64 bits of a 128-bit address form the subnet\n\
    \   prefix and the rightmost 64 bits of the address form the interface\n   identifier\
    \ [RFC3513].  We number the bits of the interface identifier\n   starting from\
    \ bit zero on the left.\n   A cryptographically generated address (CGA) has a\
    \ security parameter\n   (Sec) that determines its strength against brute-force\
    \ attacks.  The\n   security parameter is a three-bit unsigned integer, and it\
    \ is encoded\n   in the three leftmost bits (i.e., bits 0 - 2) of the interface\n\
    \   identifier.  This can be written as follows:\n      Sec = (interface identifier\
    \ & 0xe000000000000000) >> 61\n   The CGA is associated with a set of parameters\
    \ that consist of a\n   public key and auxiliary parameters.  Two hash values\
    \ Hash1 (64 bits)\n   and Hash2 (112 bits) are computed from the parameters. \
    \ The formats\n   of the public key and auxiliary parameters, and the way to compute\n\
    \   the hash values, are defined in Section 3.\n   A cryptographically generated\
    \ address is defined as an IPv6 address\n   that satisfies the following two conditions:\n\
    \   o  The first hash value, Hash1, equals the interface identifier of\n     \
    \ the address.  Bits 0, 1, 2, 6, and 7 (i.e., the bits that encode\n      the\
    \ security parameter Sec and the \"u\" and \"g\" bits from the\n      standard\
    \ IPv6 address architecture format of interface identifiers\n      [RFC3513])\
    \ are ignored in the comparison.\n   o  The 16*Sec leftmost bits of the second\
    \ hash value, Hash2, are\n      zero.\n   The above definition can be stated in\
    \ terms of the following two bit\n   masks:\n      Mask1 (64 bits)  = 0x1cffffffffffffff\n\
    \      Mask2 (112 bits) = 0x0000000000000000000000000000  if Sec=0,\n        \
    \                 0xffff000000000000000000000000  if Sec=1,\n                \
    \         0xffffffff00000000000000000000  if Sec=2,\n                        \
    \ 0xffffffffffff0000000000000000  if Sec=3,\n                         0xffffffffffffffff000000000000\
    \  if Sec=4,\n                         0xffffffffffffffffffff00000000  if Sec=5,\n\
    \                         0xffffffffffffffffffffffff0000  if Sec=6, and\n    \
    \                     0xffffffffffffffffffffffffffff  if Sec=7\n   A cryptographically\
    \ generated address is an IPv6 address for which\n   the following two equations\
    \ hold:\n      Hash1 & Mask1  ==  interface identifier & Mask1\n      Hash2 &\
    \ Mask2  ==  0x0000000000000000000000000000\n"
- title: 3.  CGA Parameters and Hash Values
  contents:
  - "3.  CGA Parameters and Hash Values\n   Each CGA is associated with a CGA Parameters\
    \ data structure, which\n   has the following format:\n    0                 \
    \  1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        Modifier (16 octets)                     +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                  Subnet Prefix (8 octets)                   +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Collision Count|                                               |\n   +-+-+-+-+-+-+-+-+\
    \                                               |\n   |                      \
    \                                         |\n   ~                  Public Key\
    \ (variable length)                 ~\n   |                                  \
    \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \         Extension Fields (optional, variable length)        ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Modifier\n      This field contains a 128-bit unsigned integer, which can\
    \ be any\n      value.  The modifier is used during CGA generation to implement\n\
    \      the hash extension and to enhance privacy by adding randomness to\n   \
    \   the address.\n   Subnet Prefix\n      This field contains the 64-bit subnet\
    \ prefix of the CGA.\n   Collision Count\n      This is an eight-bit unsigned\
    \ integer that MUST be 0, 1, or 2.\n      The collision count is incremented during\
    \ CGA generation to\n      recover from an address collision detected by duplicate\
    \ address\n      detection.\n   Public Key\n      This is a variable-length field\
    \ containing the public key of the\n      address owner.  The public key MUST\
    \ be formatted as a DER-encoded\n      [ITU.X690.2002] ASN.1 structure of the\
    \ type SubjectPublicKeyInfo,\n      defined in the Internet X.509 certificate\
    \ profile [RFC3280].  SEND\n      SHOULD use an RSA public/private key pair. \
    \ When RSA is used, the\n      algorithm identifier MUST be rsaEncryption, which\
    \ is\n      1.2.840.113549.1.1.1, and the RSA public key MUST be formatted by\n\
    \      using the RSAPublicKey type as specified in Section 2.3.1 of RFC\n    \
    \  3279 [RFC3279].  The RSA key length SHOULD be at least 384 bits.\n      Other\
    \ public key types are undesirable in SEND, as they may result\n      in incompatibilities\
    \ between implementations.  The length of this\n      field is determined by the\
    \ ASN.1 encoding.\n   Extension Fields\n      This is an optional variable-length\
    \ field that is not used in the\n      current specification.  Future versions\
    \ of this specification may\n      use this field for additional data items that\
    \ need to be included\n      in the CGA Parameters data structure.  IETF standards\
    \ action is\n      required to specify the use of the extension fields.\n    \
    \  Implementations MUST ignore the value of any unrecognized\n      extension\
    \ fields.\n   The two hash values MUST be computed as follows.  The SHA-1 hash\n\
    \   algorithm [FIPS.180-1.1995] is applied to the CGA Parameters.  When\n   Hash1\
    \ is computed, the input to the SHA-1 algorithm is the CGA\n   Parameters data\
    \ structure.  The 64-bit Hash1 is obtained by taking\n   the leftmost 64 bits\
    \ of the 160-bit SHA-1 hash value.  When Hash2 is\n   computed, the input is the\
    \ same CGA Parameters data structure except\n   that the subnet prefix and collision\
    \ count are set to zero.  The\n   112-bit Hash2 is obtained by taking the leftmost\
    \ 112 bits of the\n   160-bit SHA-1 hash value.  Note that the hash values are\
    \ computed\n   over the entire CGA Parameters data structure, including any\n\
    \   unrecognized extension fields.\n"
- title: 4.  CGA Generation
  contents:
  - "4.  CGA Generation\n   The process of generating a new CGA takes three input\
    \ values: a\n   64-bit subnet prefix, the public key of the address owner as a\n\
    \   DER-encoded ASN.1 structure of the type SubjectPublicKeyInfo, and the\n  \
    \ security parameter Sec, which is an unsigned three-bit integer.  The\n   cost\
    \ of generating a new CGA depends exponentially on the security\n   parameter\
    \ Sec, which can have values from 0 to 7.\n   A CGA and associated parameters\
    \ SHOULD be generated as follows:\n   1. Set the modifier to a random or pseudo-random\
    \ 128-bit value.\n   2. Concatenate from left to right the modifier, 9 zero octets,\
    \ the\n      encoded public key, and any optional extension fields.  Execute\n\
    \      the SHA-1 algorithm on the concatenation.  Take the 112 leftmost\n    \
    \  bits of the SHA-1 hash value.  The result is Hash2.\n   3. Compare the 16*Sec\
    \ leftmost bits of Hash2 with zero.  If they are\n      all zero (or if Sec=0),\
    \ continue with step 4.  Otherwise,\n      increment the modifier by one and go\
    \ back to step 2.\n   4. Set the 8-bit collision count to zero.\n   5. Concatenate\
    \ from left to right the final modifier value, the\n      subnet prefix, the collision\
    \ count, the encoded public key, and\n      any optional extension fields.  Execute\
    \ the SHA-1 algorithm on the\n      concatenation.  Take the 64 leftmost bits\
    \ of the SHA-1 hash value.\n      The result is Hash1.\n   6. Form an interface\
    \ identifier from Hash1 by writing the value of\n      Sec into the three leftmost\
    \ bits and by setting bits 6 and 7\n      (i.e., the \"u\" and \"g\" bits) to\
    \ zero.\n   7. Concatenate the 64-bit subnet prefix and the 64-bit interface\n\
    \      identifier to form a 128-bit IPv6 address with the subnet prefix\n    \
    \  to the left and interface identifier to the right, as in a\n      standard\
    \ IPv6 address [RFC3513].\n   8. Perform duplicate address detection if required,\
    \ as per [RFC3971].\n      If an address collision is detected, increment the\
    \ collision count\n      by one and go back to step 5.  However, after three collisions,\n\
    \      stop and report the error.\n   9. Form the CGA Parameters data structure\
    \ by concatenating from left\n      to right the final modifier value, the subnet\
    \ prefix, the final\n      collision count value, the encoded public key, and\
    \ any optional\n      extension fields.\n   The output of the address generation\
    \ algorithm is a new CGA and a CGA\n   Parameters data structure.\n   The initial\
    \ value of the modifier in step 1 SHOULD be chosen randomly\n   to make addresses\
    \ generated from the same public key unlinkable,\n   which enhances privacy (see\
    \ Section 7.3).  The quality of the random\n   number generator does not affect\
    \ the strength of the binding between\n   the address and the public key.  Implementations\
    \ that have no strong\n   random numbers available MAY use a non-cryptographic\
    \ pseudo-random\n   number generator initialized with the current time of day.\n\
    \   For Sec=0, the above algorithm is deterministic and relatively fast.\n   Nodes\
    \ that implement CGA generation MAY always use the security\n   parameter value\
    \ Sec=0.  If Sec=0, steps 2 - 3 of the generation\n   algorithm can be skipped.\n\
    \   For Sec values greater than zero, the above algorithm is not\n   guaranteed\
    \ to terminate after a certain number of iterations.  The\n   brute-force search\
    \ in steps 2 - 3 takes O(2^(16*Sec)) iterations to\n   complete.  The algorithm\
    \ has been intentionally designed so that the\n   generation of CGAs with high\
    \ Sec values is infeasible with current\n   technology.\n   Implementations MAY\
    \ use optimized or otherwise modified versions of\n   the above algorithm for\
    \ CGA generation.  However, the output of any\n   modified versions MUST fulfill\
    \ the following two requirements.\n   First, the resulting CGA and CGA Parameters\
    \ data structure MUST be\n   formatted as specified in Sections 2 - 3.  Second,\
    \ the CGA\n   verification procedure defined in Section 5 MUST succeed when invoked\n\
    \   on the output of the CGA generation algorithm.  Note that some\n   optimizations\
    \ involve trade-offs between privacy and the cost of\n   address generation.\n\
    \   One optimization is particularly important.  If the subnet prefix of\n   the\
    \ address changes but the address owner's public key does not, the\n   old modifier\
    \ value MAY be reused.  If it is reused, the algorithm\n   SHOULD be started from\
    \ step 4.  This optimization avoids repeating\n   the expensive search for an\
    \ acceptable modifier value but may, in\n   some situations, make it easier for\
    \ an observer to link two addresses\n   to each other.\n   Note that this document\
    \ does not specify whether duplicate address\n   detection should be performed\
    \ and how the detection is done.  Step 8\n   only defines what to do if some form\
    \ of duplicate address detection\n   is performed and an address collision is\
    \ detected.\n   Future versions of this specification may specify additional inputs\n\
    \   to the CGA generation algorithm that are concatenated as extension\n   fields\
    \ to the end of the CGA Parameters data structure.  No such\n   extension fields\
    \ are defined in this document.\n"
- title: 5.  CGA Verification
  contents:
  - "5.  CGA Verification\n   CGA verification takes an IPv6 address and a CGA Parameters\
    \ data\n   structure as input.  The CGA Parameters consist of the concatenated\n\
    \   modifier, subnet prefix, collision count, public key, and optional\n   extension\
    \ fields.  The verification either succeeds or fails.\n   The CGA MUST be verified\
    \ with the following steps:\n   1. Check that the collision count in the CGA Parameters\
    \ data\n      structure is 0, 1, or 2.  The CGA verification fails if the\n  \
    \    collision count is out of the valid range.\n   2. Check that the subnet prefix\
    \ in the CGA Parameters data structure\n      is equal to the subnet prefix (i.e.,\
    \ the leftmost 64 bits) of the\n      address.  The CGA verification fails if\
    \ the prefix values differ.\n   3. Execute the SHA-1 algorithm on the CGA Parameters\
    \ data structure.\n      Take the 64 leftmost bits of the SHA-1 hash value.  The\
    \ result is\n      Hash1.\n   4. Compare Hash1 with the interface identifier (i.e.,\
    \ the rightmost\n      64 bits) of the address.  Differences in the three leftmost\
    \ bits\n      and in bits 6 and 7 (i.e., the \"u\" and \"g\" bits) are ignored.\
    \  If\n      the 64-bit values differ (other than in the five ignored bits),\n\
    \      the CGA verification fails.\n   5. Read the security parameter Sec from\
    \ the three leftmost bits of\n      the 64-bit interface identifier of the address.\
    \  (Sec is an\n      unsigned 3-bit integer.)\n   6. Concatenate from left to\
    \ right the modifier, 9 zero octets, the\n      public key, and any extension\
    \ fields that follow the public key in\n      the CGA Parameters data structure.\
    \  Execute the SHA-1 algorithm on\n      the concatenation.  Take the 112 leftmost\
    \ bits of the SHA-1 hash\n      value.  The result is Hash2.\n   7. Compare the\
    \ 16*Sec leftmost bits of Hash2 with zero.  If any one\n      of them is not zero,\
    \ the CGA verification fails.  Otherwise, the\n      verification succeeds.  (If\
    \ Sec=0, the CGA verification never\n      fails at this step.)\n   If the verification\
    \ fails at any step, the execution of the algorithm\n   MUST be stopped immediately.\
    \  On the other hand, if the verification\n   succeeds, the verifier knows that\
    \ the public key in the CGA\n   Parameters is the authentic public key of the\
    \ address owner.  The\n   verifier can extract the public key by removing 25 octets\
    \ from the\n   beginning of the CGA Parameters and by decoding the following\n\
    \   SubjectPublicKeyInfo data structure.\n   Note that the values of bits 6 and\
    \ 7 (the \"u\" and \"g\" bits) of the\n   interface identifier are ignored during\
    \ CGA verification.  In the\n   SEND protocol, after the verification succeeds,\
    \ the verifier SHOULD\n   process all CGAs in the same way regardless of the Sec,\
    \ modifier, and\n   collision count values.  In particular, the verifier in the\
    \ SEND\n   protocol SHOULD NOT have any security policy that differentiates\n\
    \   between addresses based on the value of Sec.  That way, the address\n   generator\
    \ is free to choose any value of Sec.\n   All nodes that implement CGA verification\
    \ MUST be able to process all\n   security parameter values Sec = 0, 1, 2, 3,\
    \ 4, 5, 6, 7.  The\n   verification procedure is relatively fast and always requires\
    \ at most\n   two computations of the SHA-1 hash function.  If Sec=0, the\n  \
    \ verification never fails in steps 6 - 7 and these steps can be\n   skipped.\n\
    \   Nodes that implement CGA verification for SEND SHOULD be able to\n   process\
    \ RSA public keys that have the algorithm identifier\n   rsaEncryption and, key\
    \ length between 384 and 2,048 bits.\n   Implementations MAY support longer keys.\
    \  Future versions of this\n   specification may recommend support for longer\
    \ keys.\n   Implementations of CGA verification MUST ignore the value of any\n\
    \   unrecognized extension fields that follow the public key in the CGA\n   Parameters\
    \ data structure.  However, implementations MUST include any\n   such unrecognized\
    \ data in the hash input when computing Hash1 in step\n   3 and Hash2 in step\
    \ 6 of the CGA verification algorithm.  This is\n   important to ensure upward\
    \ compatibility with future extensions.\n"
- title: 6.  CGA Signatures
  contents:
  - "6.  CGA Signatures\n   This section defines the procedures for generating and\
    \ verifying CGA\n   signatures.  To sign a message, a node needs the CGA, the\
    \ associated\n   CGA Parameters data structure, the message, and the private\n\
    \   cryptographic key that corresponds to the public key in the CGA\n   Parameters.\
    \  The node also must have a 128-bit type tag for the\n   message from the CGA\
    \ Message Type name space.\n   To sign a message, a node SHOULD do the following:\n\
    \   o  Concatenate the 128-bit type tag (in network byte order) and the\n    \
    \  message with the type tag to the left and the message to the\n      right.\
    \  The concatenation is the message to be signed in the next\n      step.\n  \
    \ o  Generate the RSA signature by using the RSASSA-PKCS1-v1_5\n      [RFC3447]\
    \ signature algorithm with the SHA-1 hash algorithm.  The\n      private key and\
    \ the concatenation created above are the inputs to\n      the generation operation.\n\
    \   The SEND protocol specification [RFC3971] defines several messages\n   that\
    \ contain a signature in the Signature Option.  The SEND protocol\n   specification\
    \ also defines a type tag from the CGA Message Type name\n   space.  The same\
    \ type tag is used for all the SEND messages that have\n   the Signature Option.\
    \  This type tag is an IANA-allocated 128 bit\n   integer that has been chosen\
    \ at random to prevent an accidental type\n   collision with messages of other\
    \ protocols that use the same public\n   key but that may or may not use IANA-allocated\
    \ type tags.\n   The CGA, the CGA Parameters data structure, the message, and\
    \ the\n   signature are sent to the verifier.  The SEND protocol specification\n\
    \   defines how these data items are sent in SEND protocol messages.\n   Note\
    \ that the 128-bit type tag is not included in the SEND protocol\n   messages\
    \ because the verifier knows its value implicitly from the\n   ICMP message type\
    \ field in the SEND message.  See the SEND\n   specification [RFC3971] for precise\
    \ information about how SEND\n   handles the type tag.\n   To verify a signature,\
    \ the verifier needs the CGA, the associated CGA\n   Parameters data structure,\
    \ the message, and the signature.  The\n   verifier also needs to have the 128-bit\
    \ type tag for the message.\n   To verify the signature, a node SHOULD do the\
    \ following:\n   o  Verify the CGA as defined in Section 5.  The inputs to the\
    \ CGA\n      verification are the CGA and the CGA Parameters data structure.\n\
    \   o  Concatenate the 128-bit type tag and the message with the type tag\n  \
    \    to the left and the message to the right.  The concatenation is\n      the\
    \ message whose signature is to be verified in the next step.\n   o  Verify the\
    \ RSA signature by using the RSASSA-PKCS1-v1_5 [RFC3447]\n      algorithm with\
    \ the SHA-1 hash algorithm.  The inputs to the\n      verification operation are\
    \ the public key (i.e., the RSAPublicKey\n      structure from the SubjectPublicKeyInfo\
    \ structure that is a part\n      of the CGA Parameters data structure), the concatenation\
    \ created\n      above, and the signature.\n   The verifier MUST accept the signature\
    \ as authentic only if both the\n   CGA verification and the signature verification\
    \ succeed.\n"
- title: 7.  Security Considerations
  contents:
  - '7.  Security Considerations

    '
- title: 7.1.  Security Goals and Limitations
  contents:
  - "7.1.  Security Goals and Limitations\n   The purpose of CGAs is to prevent stealing\
    \ and spoofing of existing\n   IPv6 addresses.  The public key of the address\
    \ owner is bound\n   cryptographically to the address.  The address owner can\
    \ use the\n   corresponding private key to assert its ownership and to sign SEND\n\
    \   messages sent from the address.\n   It is important to understand that an\
    \ attacker can create a new\n   address from an arbitrary subnet prefix and its\
    \ own (or someone\n   else's) public key because CGAs are not certified.  However,\
    \ the\n   attacker cannot impersonate somebody else's address.  This is because\n\
    \   the attacker would have to find a collision of the cryptographic hash\n  \
    \ value Hash1.  (The property of the hash function needed here is\n   called second\
    \ pre-image resistance [MOV97].)\n   For each valid CGA Parameters data structure,\
    \ there are 4*(Sec+1)\n   different CGAs that match the value.  This is because\
    \ decrementing\n   the Sec value in the three leftmost bits of the interface identifier\n\
    \   does not invalidate the address, and the verifier ignores the values\n   of\
    \ the \"u\" and \"g\" bits.  In SEND, this does not have any security or\n   implementation\
    \ implications.\n   Another limitation of CGAs is that there is no mechanism for\
    \ proving\n   that an address is not a CGA.  Thus, an attacker could take someone\n\
    \   else's CGA and present it as a non-cryptographically generated\n   address\
    \ (e.g., as an RFC 3041 address [RFC3041]).  An attacker does\n   not benefit\
    \ from this because although SEND nodes accept both signed\n   and unsigned messages\
    \ from every address, they give priority to the\n   information in the signed\
    \ messages.\n   The minimum RSA key length required for SEND is only 384 bits.\
    \  So\n   short keys are vulnerable to integer-factoring attacks and cannot be\n\
    \   used for strong authentication or secrecy.  On the other hand, the\n   cost\
    \ of factoring 384-bit keys is currently high enough to prevent\n   most denial-of-service\
    \ attacks.  Implementations that initially use\n   short RSA keys SHOULD be prepared\
    \ to switch to longer keys when\n   denial-of-service attacks arising from integer\
    \ factoring become a\n   problem.\n   The impact of a key compromise on CGAs depends\
    \ on the application for\n   which they are used.  In SEND, it is not a major\
    \ concern.  If the\n   private signature key is compromised because the SEND node\
    \ has itself\n   been compromised, the attacker does not need to spoof SEND messages\n\
    \   from the node.  When it is discovered that a node has been\n   compromised,\
    \ a new signature key and a new CGA SHOULD be generated.\n   On the other hand,\
    \ if the RSA key is compromised because integer-\n   factoring attacks for the\
    \ chosen key length have become practical,\n   the key has to be replaced with\
    \ a longer one, as explained above.  In\n   either case, the address change effectively\
    \ revokes the old public\n   key.  It is not necessary to have any additional\
    \ key revocation\n   mechanism or to limit the lifetimes of the signature keys.\n"
- title: 7.2.  Hash Extension
  contents:
  - "7.2.  Hash Extension\n   As computers become faster, the 64 bits of the interface\
    \ identifier\n   will not be sufficient to prevent attackers from searching for\
    \ hash\n   collisions.  It helps somewhat that we include the subnet prefix of\n\
    \   the address in the hash input.  This prevents the attacker from using\n  \
    \ a single pre-computed database to attack addresses with different\n   subnet\
    \ prefixes.  The attacker needs to create a separate database\n   for each subnet\
    \ prefix.  Link-local addresses are, however, left\n   vulnerable because the\
    \ same prefix is used by all IPv6 nodes.\n   To prevent the CGA technology from\
    \ becoming outdated as computers\n   become faster, the hash technique used to\
    \ generate CGAs must be\n   extended somehow.  The chosen extension technique\
    \ is to increase the\n   cost of both address generation and brute-force attacks\
    \ by the same\n   parameterized factor while keeping the cost of address use and\n\
    \   verification constant.  This also provides protection for link-local\n   addresses.\
    \  Introduction of the hash extension is the main difference\n   between this\
    \ document and earlier CGA proposals [OR01][Nik01][MC02].\n   To achieve the effective\
    \ extension of the hash length, the input to\n   the second hash function, Hash2,\
    \ is modified (by changing the\n   modifier value) until the leftmost 16*Sec bits\
    \ of the hash value are\n   zero.  This increases the cost of address generation\
    \ approximately by\n   a factor of 2^(16*Sec).  It also increases the cost of\
    \ brute-force\n   attacks by the same factor.  That is, the cost of creating a\
    \ CGA\n   Parameters data structure that binds the attacker's public key with\n\
    \   somebody else's address is increased from O(2^59) to\n   O(2^(59+16*Sec)).\
    \  The address generator may choose the security\n   parameter Sec depending on\
    \ its own computational capacity, the\n   perceived risk of attacks, and the expected\
    \ lifetime of the address.\n   Currently, Sec values between 0 and 2 are sufficient\
    \ for most IPv6\n   nodes.  As computers become faster, higher Sec values will\
    \ slowly\n   become useful.\n   Theoretically, if no hash extension is used (i.e.,\
    \ Sec=0) and a\n   typical attacker is able to tap into N local networks at the\
    \ same\n   time, an attack against link-local addresses is N times as efficient\n\
    \   as an attack against addresses of a specific network.  The effect\n   could\
    \ be countered by using a slightly higher Sec value for link-\n   local addresses.\
    \  When higher Sec values (such that 2^(16*Sec) > N)\n   are used for all addresses,\
    \ the relative advantage of attacking\n   link-local addresses becomes insignificant.\n\
    \   The effectiveness of the hash extension depends on the assumption\n   that\
    \ the computational capacities of the attacker and the address\n   generator will\
    \ grow at the same (potentially exponential) rate.  This\n   is not necessarily\
    \ true if the addresses are generated on low-end\n   mobile devices, for which\
    \ the main design goals are to lower cost and\n   decrease size, rather than increase\
    \ computing power.  But there is no\n   reason for doing so.  The expensive part\
    \ of the address generation\n   (steps 1 - 3 of the generation algorithm) may\
    \ be delegated to a more\n   powerful computer.  Moreover, this work can be done\
    \ in advance or\n   offline, rather than in real time, when a new address is needed.\n\
    \   To make it possible for mobile nodes whose subnet prefixes change\n   frequently\
    \ to use Sec values greater than zero, we have decided not\n   to include the\
    \ subnet prefix in the input of Hash2.  The result is\n   weaker than it would\
    \ be if the subnet prefix were included in the\n   input of both hashes.  On the\
    \ other hand, our scheme is at least as\n   strong as using the hash extension\
    \ technique without including the\n   subnet prefix in either hash.  It is also\
    \ at least as strong as not\n   using the hash extension but including the subnet\
    \ prefix.  This\n   trade-off was made because mobile nodes frequently move to\
    \ insecure\n   networks, where they are at the risk of denial-of-service (DoS)\n\
    \   attacks (for example, during the duplicate address detection\n   procedure).\n\
    \   In most networks, the goal of Secure Neighbor Discovery and CGA\n   signatures\
    \ is to prevent denial-of-service attacks.  Therefore, it is\n   usually sensible\
    \ to start by using a low Sec value and to replace\n   addresses with stronger\
    \ ones only when denial-of-service attacks\n   based on brute-force search become\
    \ a significant problem.  If CGAs\n   were used as a part of a strong authentication\
    \ or secrecy mechanism,\n   it might be necessary to start with higher Sec values.\n\
    \   The collision count value is used to modify the input to Hash1 if\n   there\
    \ is an address collision.  It is important not to allow\n   collision count values\
    \ higher than 2.  First, it is extremely\n   unlikely that three collisions would\
    \ occur and the reason is certain\n   to be either a configuration or implementation\
    \ error or a denial-of-\n   service attack.  (When the SEND protocol is used,\
    \ deliberate\n   collisions caused by a DoS attacker are detected and ignored.)\n\
    \   Second, an attacker doing a brute-force search to match a given CGA\n   can\
    \ try all different values of a collision count without repeating\n   the brute-force\
    \ search for the modifier value.  Thus, if higher\n   values are allowed for the\
    \ collision count, the hash extension\n   technique becomes less effective in\
    \ preventing brute force attacks.\n"
- title: 7.3.  Privacy Considerations
  contents:
  - "7.3.  Privacy Considerations\n   CGAs can give the same level of pseudonymity\
    \ as the IPv6 address\n   privacy extensions defined in RFC 3041 [RFC3041].  An\
    \ IP host can\n   generate multiple pseudo-random CGAs by executing the CGA generation\n\
    \   algorithm of Section 4 multiple times and by using a different random\n  \
    \ or pseudo-random initial value for the modifier every time.  The host\n   should\
    \ change its address periodically as in [RFC3041].  When privacy\n   protection\
    \ is needed, the (pseudo)random number generator used in\n   address generation\
    \ SHOULD be strong enough to produce unpredictable\n   and unlinkable values.\
    \  Advice on random number generation can be\n   found in [RFC1750].\n   There\
    \ are two apparent limitations to this privacy protection.\n   However, as will\
    \ be explained below, neither is very serious.\n   First, the high cost of address\
    \ generation may prevent hosts that use\n   a high Sec value from changing their\
    \ address frequently.  This\n   problem is mitigated because the expensive part\
    \ of the address\n   generation may be done in advance or offline, as explained\
    \ in the\n   previous section.  It should also be noted that the nodes that\n\
    \   benefit most from high Sec values (e.g., DNS servers, routers, and\n   data\
    \ servers) usually do not require pseudonymity, and the nodes that\n   have high\
    \ privacy requirements (e.g., client PCs and mobile hosts)\n   are unlikely targets\
    \ for expensive brute-force DoS attacks and can\n   make do with lower Sec values.\n\
    \   Second, the public key of the address owner is revealed in the signed\n  \
    \ SEND messages.  This means that if the address owner wants to be\n   pseudonymous\
    \ toward the nodes in the local links that it accesses, it\n   should generate\
    \ not only a new address but also a new public key.\n   With typical local-link\
    \ technologies, however, a node's link-layer\n   address is a unique identifier\
    \ for the node.  As long as the node\n   keeps using the same link-layer address,\
    \ it makes little sense to\n   change the public key for privacy reasons.\n"
- title: 7.4.  Related Protocols
  contents:
  - "7.4.  Related Protocols\n   Although this document defines CGAs only for the\
    \ purposes of Secure\n   Neighbor Discovery, other protocols could be defined\
    \ elsewhere that\n   use the same addresses and public keys.  This raises the\
    \ possibility\n   of related-protocol attacks in which a signed message from one\n\
    \   protocol is replayed in another protocol.  This means that other\n   protocols\
    \ (perhaps even those designed without an intimate knowledge\n   of SEND) could\
    \ endanger the security of SEND.  What makes this threat\n   even more significant\
    \ is that the attacker could create a CGA from\n   someone else's public key and\
    \ then replay signed messages from a\n   protocol that has nothing to do with\
    \ CGAs or IP addresses.\n   To prevent the related-protocol attacks, a type tag\
    \ is prepended to\n   every message before it is signed.  The type tags are 128-bit\n\
    \   randomly chosen values, which prevents accidental type collisions\n   with\
    \ even poorly designed protocols that do not use any type tags.\n   Moreover,\
    \ the SEND protocol includes the sender's CGA address in all\n   signed messages.\
    \  This makes it even more difficult for an attacker\n   to take signed messages\
    \ from some other context and to replay them as\n   SEND messages.\n   Finally,\
    \ a strong cautionary note has to be made about using CGA\n   signatures for purposes\
    \ other than SEND.  First, the other protocols\n   MUST include a type tag and\
    \ the sender address in all signed messages\n   in the same way that SEND does.\
    \  Each protocol MUST define its own\n   type tag values as explained in Section\
    \ 8.  Moreover, because of the\n   possibility of related-protocol attacks, the\
    \ public key MUST be used\n   only for signing, and it MUST NOT be used for encryption.\
    \  Second,\n   the minimum RSA key length of 384 bits may be too short for many\n\
    \   applications and the impact of key compromise on the particular\n   protocol\
    \ must be evaluated.  Third, CGA-based authorization is\n   particularly suitable\
    \ for securing neighbor discovery [RFC2461] and\n   duplicate address detection\
    \ [RFC2462] because these are network-layer\n   signaling protocols for which\
    \ IPv6 addresses are natural endpoint\n   identifiers.  In any protocol that uses\
    \ other identifiers, such as\n   DNS names, CGA signatures alone are not a sufficient\
    \ security\n   mechanism.  There must also be a secure way of mapping the other\n\
    \   identifiers to IPv6 addresses.  If the goal is not to verify claims\n   about\
    \ IPv6 addresses, CGA signatures are probably not the right\n   solution.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document defines a new CGA Message Type name\
    \ space for use as\n   type tags in messages that may be signed by using CGA signatures.\n\
    \   The values in this name space are 128-bit unsigned integers.  Values\n   in\
    \ this name space are allocated on a First Come First Served basis\n   [RFC2434].\
    \  IANA assigns new 128-bit values directly without a\n   review.\n   The requester\
    \ SHOULD generate the new values with a strong random-\n   number generator. \
    \ Continuous ranges of at most 256 values can be\n   requested provided that the\
    \ 120 most significant bits of the values\n   have been generated with a strong\
    \ random-number generator.\n   IANA does not generate random values for the requester.\
    \  IANA\n   allocates requested values without verifying the way in which they\n\
    \   have been generated.  The name space is essentially unlimited, and\n   any\
    \ number of individual values and ranges of at most 256 values can\n   be allocated.\n\
    \   CGA Message Type values for private use MAY be generated with a\n   strong\
    \ random-number generator without IANA allocation.\n   This document does not\
    \ define any new values in any name space.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC3971]         Arkko, J., Ed., Kempf, J., Sommerfeld,\
    \ B., Zill,\n                     B., and P. Nikander, \"SEcure Neighbor Discovery\n\
    \                     (SEND)\", RFC 3971, March 2005.\n   [RFC3279]         Bassham,\
    \ L., Polk, W., and R. Housley, \"Algorithms\n                     and Identifiers\
    \ for the Internet X.509 Public Key\n                     Infrastructure Certificate\
    \ and Certificate\n                     Revocation List (CRL) Profile\", RFC 3279,\
    \ April\n                     2002.\n   [RFC2119]         Bradner, S., \"Key words\
    \ for use in RFCs to Indicate\n                     Requirement Levels\", BCP\
    \ 14, RFC 2119, March 1997.\n   [RFC3513]         Hinden, R. and S. Deering, \"\
    Internet Protocol\n                     Version 6 (IPv6) Addressing Architecture\"\
    , RFC\n                     3513, April 2003.\n   [RFC3280]         Housley, R.,\
    \ Polk, W., Ford, W., and D. Solo,\n                     \"Internet X.509 Public\
    \ Key Infrastructure\n                     Certificate and Certificate Revocation\
    \ List (CRL)\n                     Profile\", RFC 3280, April 2002.\n   [ITU.X690.2002]\
    \   International Telecommunications Union,\n                     \"Information\
    \ Technology - ASN.1 encoding rules:\n                     Specification of Basic\
    \ Encoding Rules (BER),\n                     Canonical Encoding Rules (CER) and\
    \ Distinguished\n                     Encoding Rules (DER)\", ITU-T Recommendation\
    \ X.690,\n                     July 2002.\n   [RFC3447]         Jonsson, J. and\
    \ B. Kaliski, \"Public-Key\n                     Cryptography Standards (PKCS)\
    \ #1: RSA Cryptography\n                     Specifications Version 2.1\", RFC\
    \ 3447, February\n                     2003.\n   [RFC2434]         Narten, T.\
    \ and H. Alvestrand, \"Guidelines for\n                     Writing an IANA Considerations\
    \ Section in RFCs\",\n                     BCP 26, RFC 2434, October 1998.\n \
    \  [FIPS.180-1.1995] National Institute of Standards and Technology,\n       \
    \              \"Secure Hash Standard\", Federal Information\n               \
    \      Processing Standards Publication FIPS PUB 180-1,\n                    \
    \ April 1995,\n                     <http://www.itl.nist.gov/fipspubs/fip180-1.htm>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [AAKMNR02]        Arkko, J., Aura, T., Kempf,\
    \ J., Mantyla, V.,\n                     Nikander, P., and M. Roe, \"Securing\
    \ IPv6 neighbor\n                     discovery and router discovery\", ACM Workshop\
    \ on\n                     Wireless Security (WiSe 2002), Atlanta, GA USA ,\n\
    \                     September 2002.\n   [Aura03]          Aura, T., \"Cryptographically\
    \ Generated Addresses\n                     (CGA)\", 6th Information Security\
    \ Conference\n                     (ISC'03), Bristol, UK, October 2003.\n   [RFC1750]\
    \         Eastlake, D., Crocker, S., and J. Schiller,\n                     \"\
    Randomness Recommendations for Security\", RFC\n                     1750, December\
    \ 1994.\n   [MOV97]           Menezes, A., van Oorschot, P., and S. Vanstone,\n\
    \                     \"Handbook of Applied Cryptography\", CRC Press ,\n    \
    \                 1997.\n   [MC02]            Montenegro, G. and C. Castelluccia,\
    \ \"Statistically\n                     unique and cryptographically verifiable\
    \ identifiers\n                     and addresses\", ISOC Symposium on Network\
    \ and\n                     Distributed System Security (NDSS 2002), San Diego,\n\
    \                     CA USA , February 2002.\n   [RFC3041]         Narten, T.\
    \ and R. Draves, \"Privacy Extensions for\n                     Stateless Address\
    \ Autoconfiguration in IPv6\", RFC\n                     3041, January 2001.\n\
    \   [RFC2461]         Narten, T., Nordmark, E., and W. Simpson, \"Neighbor\n \
    \                    Discovery for IP Version 6 (IPv6)\", RFC 2461,\n        \
    \             December 1998.\n   [Nik01]           Nikander, P., \"A scaleable\
    \ architecture for IPv6\n                     address ownership\", draft-nikander-addr-ownership-\n\
    \                     00 (work in progress), March 2001.\n   [OR01]          \
    \  O'Shea, G. and M. Roe, \"Child-proof authentication\n                     for\
    \ MIPv6 (CAM)\", ACM Computer Communications\n                     Review 31(2),\
    \ April 2001.\n   [RFC2462]         Thomson, S. and T. Narten, \"IPv6 Stateless\
    \ Address\n                     Autoconfiguration\", RFC 2462, December 1998.\n"
- title: Appendix A.  Example of CGA Generation
  contents:
  - "Appendix A.  Example of CGA Generation\n   We generate a CGA with Sec=1 from\
    \ the subnet prefix fe80:: and the\n   following public key:\n   305c 300d 0609\
    \ 2a86 4886 f70d 0101 0105 0003 4b00 3048 0241\n   00c2 c2f1 3730 5454 f10b d9ce\
    \ a368 44b5 30e9 211a 4b26 2b16\n   467c b7df ba1f 595c 0194 f275 be5a 4d38 6f2c\
    \ 3c23 8250 8773\n   c786 7f9b 3b9e 63a0 9c7b c48f 7a54 ebef af02 0301 0001\n\
    \   The modifier is initialized to a random value 89a8 a8b2 e858 d8b8\n   f263\
    \ 3f44 d2d4 ce9a.  The input to Hash2 is:\n   89a8 a8b2 e858 d8b8 f263 3f44 d2d4\
    \ ce9a 0000 0000 0000 0000 00\n   305c 300d 0609 2a86 4886 f70d 0101 0105 0003\
    \ 4b00 3048 0241\n   00c2 c2f1 3730 5454 f10b d9ce a368 44b5 30e9 211a 4b26 2b16\n\
    \   467c b7df ba1f 595c 0194 f275 be5a 4d38 6f2c 3c23 8250 8773\n   c786 7f9b\
    \ 3b9e 63a0 9c7b c48f 7a54 ebef af02 0301 0001\n   The 112 first bits of the SHA-1\
    \ hash value computed from the above\n   input are Hash2=436b 9a70 dbfd dbf1 926e\
    \ 6e66 29c0.  This does not\n   begin with 16*Sec=16 zero bits.  Thus, we must\
    \ increment the modifier\n   by one and recompute the hash.  The new input to\
    \ Hash2 is:\n   89a8 a8b2 e858 d8b8 f263 3f44 d2d4 ce9b 0000 0000 0000 0000 00\n\
    \   305c 300d 0609 2a86 4886 f70d 0101 0105 0003 4b00 3048 0241\n   00c2 c2f1\
    \ 3730 5454 f10b d9ce a368 44b5 30e9 211a 4b26 2b16\n   467c b7df ba1f 595c 0194\
    \ f275 be5a 4d38 6f2c 3c23 8250 8773\n   c786 7f9b 3b9e 63a0 9c7b c48f 7a54 ebef\
    \ af02 0301 0001\n   The new hash value is Hash2=0000 01ca 680b 8388 8d09 12df\
    \ fcce.  The\n   16 leftmost bits of Hash2 are all zero.  Thus, we found a suitable\n\
    \   modifier.  (We were very lucky to find it so soon.)\n   The input to Hash1\
    \ is:\n   89a8 a8b2 e858 d8b8 f263 3f44 d2d4 ce9b fe80 0000 0000 0000 00\n   305c\
    \ 300d 0609 2a86 4886 f70d 0101 0105 0003 4b00 3048 0241\n   00c2 c2f1 3730 5454\
    \ f10b d9ce a368 44b5 30e9 211a 4b26 2b16\n   467c b7df ba1f 595c 0194 f275 be5a\
    \ 4d38 6f2c 3c23 8250 8773\n   c786 7f9b 3b9e 63a0 9c7b c48f 7a54 ebef af02 0301\
    \ 0001\n   The 64 first bits of the SHA-1 hash value of the above input are\n\
    \   Hash1=fd4a 5bf6 ffb4 ca6c.  We form an interface identifier from this\n  \
    \ by writing Sec=1 into the three leftmost bits and by setting bits 6\n   and\
    \ 7 (the \"u\" and \"g\" bits) to zero.  The new interface identifier\n   is 3c4a:5bf6:ffb4:ca6c.\n\
    \   Finally, we form the IPv6 address fe80::3c4a:5bf6:ffb4:ca6c.  This is\n  \
    \ the new CGA.  No address collisions were detected this time.\n   (Collisions\
    \ are very rare.)  The CGA Parameters data structure\n   associated with the address\
    \ is the same as the input to Hash1 above.\n"
- title: Appendix B.  Acknowledgements
  contents:
  - "Appendix B.  Acknowledgements\n   The author gratefully acknowledges the contributions\
    \ of Jari Arkko,\n   Francis Dupont, Pasi Eronen, Christian Huitema, James Kempf,\
    \ Pekka\n   Nikander, Michael Roe, Dave Thaler, and other participants of the\n\
    \   SEND working group.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Tuomas Aura\n   Microsoft Research\n   Roger Needham Building\n\
    \   7 JJ Thomson Avenue\n   Cambridge  CB3 0FB\n   United Kingdom\n   Phone: +44\
    \ 1223 479708\n   EMail: tuomaura@microsoft.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
