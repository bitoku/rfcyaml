- contents:
  - '             OAuth 2.0 Dynamic Client Registration Protocol

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This specification defines mechanisms for dynamically registering\n
    \  OAuth 2.0 clients with authorization servers.  Registration requests\n   send
    a set of desired client metadata values to the authorization\n   server.  The
    resulting registration responses return a client\n   identifier to use at the
    authorization server and the client metadata\n   values registered for the client.
    \ The client can then use this\n   registration information to communicate with
    the authorization server\n   using the OAuth 2.0 protocol.  This specification
    also defines a set\n   of common client metadata fields and values for clients
    to use during\n   registration.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7591.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n     1.1.  Notational Conventions  . . . . . . . . . . . . . .
    . . .   4\n     1.2.  Terminology . . . . . . . . . . . . . . . . . . . . . .
    .   4\n     1.3.  Protocol Flow . . . . . . . . . . . . . . . . . . . . . .   7\n
    \  2.  Client Metadata . . . . . . . . . . . . . . . . . . . . . . .   8\n     2.1.
    \ Relationship between Grant Types and Response Types . . .  12\n     2.2.  Human-Readable
    Client Metadata  . . . . . . . . . . . . .  13\n     2.3.  Software Statement
    \ . . . . . . . . . . . . . . . . . . .  14\n   3.  Client Registration Endpoint
    \ . . . . . . . . . . . . . . . .  15\n     3.1.  Client Registration Request
    . . . . . . . . . . . . . . .  16\n       3.1.1.  Client Registration Request
    Using a Software\n               Statement . . . . . . . . . . . . . . . . . .
    . . . .  18\n     3.2.  Responses . . . . . . . . . . . . . . . . . . . . . .
    . .  19\n       3.2.1.  Client Information Response . . . . . . . . . . . . .
    \ 19\n       3.2.2.  Client Registration Error Response  . . . . . . . . .  21\n
    \  4.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  23\n     4.1.
    \ OAuth Dynamic Client Registration Metadata Registry . . .  22\n       4.1.1.
    \ Registration Template . . . . . . . . . . . . . . . .  24\n       4.1.2.  Initial
    Registry Contents . . . . . . . . . . . . . .  24\n     4.2.  OAuth Token Endpoint
    Authentication Methods Registry  . .  27\n       4.2.1.  Registration Template
    . . . . . . . . . . . . . . . .  28\n       4.2.2.  Initial Registry Contents
    . . . . . . . . . . . . . .  28\n   5.  Security Considerations . . . . . . .
    . . . . . . . . . . . .  28\n   6.  Privacy Considerations  . . . . . . . . .
    . . . . . . . . . .  32\n   7.  References  . . . . . . . . . . . . . . . . .
    . . . . . . . .  33\n     7.1.  Normative References  . . . . . . . . . . . .
    . . . . . .  33\n     7.2.  Informative References  . . . . . . . . . . . . .
    . . . .  35\n   Appendix A.  Use Cases  . . . . . . . . . . . . . . . . . . .
    . .  33\n     A.1.  Open versus Protected Dynamic Client Registration . . . .
    \ 34\n       A.1.1.  Open Dynamic Client Registration  . . . . . . . . . .  34\n
    \      A.1.2.  Protected Dynamic Client Registration . . . . . . . .  34\n     A.2.
    \ Registration without or with Software Statements  . . . .  34\n       A.2.1.
    \ Registration without a Software Statement . . . . . .  34\n       A.2.2.  Registration
    with a Software Statement  . . . . . . .  34\n     A.3.  Registration by the Client
    or Developer . . . . . . . . .  34\n       A.3.1.  Registration by the Client
    \ . . . . . . . . . . . . .  35\n       A.3.2.  Registration by the Developer
    . . . . . . . . . . . .  35\n     A.4.  Client ID per Client Instance or per Client
    Software  . .  35\n       A.4.1.  Client ID per Client Software Instance  . .
    . . . . .  35\n       A.4.2.  Client ID Shared among All Instances of Client\n
    \              Software  . . . . . . . . . . . . . . . . . . . . . .  35\n     A.5.
    \ Stateful or Stateless Registration  . . . . . . . . . . .  35\n       A.5.1.
    \ Stateful Client Registration  . . . . . . . . . . . .  36\n       A.5.2.  Stateless
    Client Registration . . . . . . . . . . . .  36\n   Acknowledgments . . . . .
    . . . . . . . . . . . . . . . . . . . .  36\n   Authors' Addresses  . . . . .
    . . . . . . . . . . . . . . . . . .  36\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   In order for an OAuth 2.0 [RFC6749] client to utilize an
    OAuth 2.0\n   authorization server, the client needs specific information to\n
    \  interact with the server, including an OAuth 2.0 client identifier to\n   use
    at that server.  This specification describes how an OAuth 2.0\n   client can
    be dynamically registered with an authorization server to\n   obtain this information.\n
    \  As part of the registration process, this specification also defines\n   a
    mechanism for the client to present the authorization server with a\n   set of
    metadata, such as a set of valid redirection URIs.  This\n   metadata can either
    be communicated in a self-asserted fashion or as\n   a set of metadata called
    a software statement, which is digitally\n   signed or protected with a Message
    Authentication Code (MAC); in the\n   case of a software statement, the issuer
    is vouching for the validity\n   of the data about the client.\n   Traditionally,
    registration of a client with an authorization server\n   is performed manually.
    \ The mechanisms defined in this specification\n   can be used either for a client
    to dynamically register itself with\n   authorization servers or for a client
    developer to programmatically\n   register the client with authorization servers.
    \ Multiple\n   applications using OAuth 2.0 have previously developed mechanisms
    for\n   accomplishing such registrations.  This specification generalizes the\n
    \  registration mechanisms defined by \"OpenID Connect Dynamic Client\n   Registration
    1.0\" [OpenID.Registration] and used by \"User Managed\n   Access (UMA) Profile
    of OAuth 2.0\" [UMA-Core] in a way that is\n   compatible with both, while being
    applicable to a wider set of OAuth\n   2.0 use cases.\n"
  - contents:
    - "1.1.  Notational Conventions\n   The key words 'MUST', 'MUST NOT', 'REQUIRED',
      'SHALL', 'SHALL NOT',\n   'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and
      'OPTIONAL' in this\n   document are to be interpreted as described in [RFC2119].\n
      \  Unless otherwise noted, all the protocol parameter names and values\n   are
      case sensitive.\n"
    title: 1.1.  Notational Conventions
  - contents:
    - "1.2.  Terminology\n   This specification uses the terms \"access token\", \"authorization\n
      \  code\", \"authorization endpoint\", \"authorization grant\",\n   \"authorization
      server\", \"client\", \"client identifier\", \"client\n   secret\", \"grant
      type\", \"protected resource\", \"redirection URI\",\n   \"refresh token\",
      \"resource owner\", \"resource server\", \"response\n   type\", and \"token
      endpoint\" defined by OAuth 2.0 [RFC6749] and uses\n   the term \"Claim\" defined
      by JSON Web Token (JWT) [RFC7519].\n   This specification defines the following
      terms:\n   Client Software\n      Software implementing an OAuth 2.0 client.\n
      \  Client Instance\n      A deployed instance of a piece of client software.\n
      \  Client Developer\n      The person or organization that builds a client software
      package\n      and prepares it for distribution.  At the time the client is\n
      \     built, the developer is often not aware of who the deploying\n      service
      provider organizations will be.  Client developers will\n      need to use dynamic
      registration when they are unable to predict\n      aspects of the software,
      such as the deployment URLs, at compile\n      time.  For instance, this can
      occur when the software API\n      publisher and the deploying organization
      are not the same.\n   Client Registration Endpoint\n      OAuth 2.0 endpoint
      through which a client can be registered at an\n      authorization server.
      \ The means by which the URL for this\n      endpoint is obtained are out of
      scope for this specification.\n   Initial Access Token\n      OAuth 2.0 access
      token optionally issued by an authorization\n      server to a developer or
      client and used to authorize calls to the\n      client registration endpoint.
      \ The type and format of this token\n      are likely service specific and are
      out of scope for this\n      specification.  The means by which the authorization
      server issues\n      this token as well as the means by which the registration
      endpoint\n      validates this token are out of scope for this specification.
      \ Use\n      of an initial access token is required when the authorization\n
      \     server limits the parties that can register a client.\n   Deployment Organization\n
      \     An administrative security domain under which a software API\n      (service)
      is deployed and protected by an OAuth 2.0 framework.  In\n      some OAuth scenarios,
      the deployment organization and the software\n      API publisher are the same.
      \ In these cases, the deploying\n      organization will often have a close
      relationship with client\n      software developers.  In many other cases, the
      definer of the\n      service may be an independent third-party publisher or
      a standards\n      organization.  When working to a published specification
      for an\n      API, the client software developer is unable to have a prior\n
      \     relationship with the potentially many deployment organizations\n      deploying
      the software API (service).\n   Software API Deployment\n      A deployed instance
      of a software API that is protected by OAuth\n      2.0 (a protected resource)
      in a particular deployment organization\n      domain.  For any particular software
      API, there may be one or more\n      deployments.  A software API deployment
      typically has an\n      associated OAuth 2.0 authorization server as well as
      a client\n      registration endpoint.  The means by which endpoints are obtained\n
      \     are out of scope for this specification.\n   Software API Publisher\n
      \     The organization that defines a particular web-accessible API that\n      may
      be deployed in one or more deployment environments.  A\n      publisher may
      be any standards body, commercial, public, private,\n      or open source organization
      that is responsible for publishing and\n      distributing software and API
      specifications that may be protected\n      via OAuth 2.0.  In some cases, a
      software API publisher and a\n      client developer may be the same organization.
      \ At the time of\n      publication of a web-accessible API, the software publisher
      often\n      does not have a prior relationship with the deploying\n      organizations.\n
      \  Software Statement\n      A digitally signed or MACed JSON Web Token (JWT)
      [RFC7519] that\n      asserts metadata values about the client software.  In
      some cases,\n      a software statement will be issued directly by the client\n
      \     developer.  In other cases, a software statement will be issued by\n      a
      third-party organization for use by the client developer.  In\n      both cases,
      the trust relationship the authorization server has\n      with the issuer of
      the software statement is intended to be used\n      as an input to the evaluation
      of whether the registration request\n      is accepted.  A software statement
      can be presented to an\n      authorization server as part of a client registration
      request.\n"
    title: 1.2.  Terminology
  - contents:
    - "1.3.  Protocol Flow\n        +--------(A)- Initial Access Token (OPTIONAL)\n
      \       |\n        |   +----(B)- Software Statement (OPTIONAL)\n        |   |\n
      \       v   v\n    +-----------+                                      +---------------+\n
      \   |           |--(C)- Client Registration Request -->|    Client     |\n    |
      Client or |                                      | Registration  |\n    | Developer
      |<-(D)- Client Information Response ---|   Endpoint    |\n    |           |
      \       or Client Error Response      +---------------+\n    +-----------+\n
      \  Figure 1: Abstract Dynamic Client Registration Flow\n   The abstract OAuth
      2.0 client dynamic registration flow illustrated\n   in Figure 1 describes the
      interaction between the client or developer\n   and the endpoint defined in
      this specification.  This figure does not\n   demonstrate error conditions.
      \ This flow includes the following\n   steps:\n   (A)   Optionally, the client
      or developer is issued an initial access\n         token giving access to the
      client registration endpoint.  The\n         method by which the initial access
      token is issued to the\n         client or developer is out of scope for this
      specification.\n   (B)   Optionally, the client or developer is issued a software\n
      \        statement for use with the client registration endpoint.  The\n         method
      by which the software statement is issued to the client\n         or developer
      is out of scope for this specification.\n   (C)   The client or developer calls
      the client registration endpoint\n         with the client's desired registration
      metadata, optionally\n         including the initial access token from (A) if
      one is required\n         by the authorization server.\n   (D)   The authorization
      server registers the client and returns:\n         *  the client's registered
      metadata,\n         *  a client identifier that is unique at the server, and\n
      \        *  a set of client credentials such as a client secret, if\n            applicable
      for this client.\n   Examples of different configurations and usages are included
      in\n   Appendix A.\n"
    title: 1.3.  Protocol Flow
  title: 1.  Introduction
- contents:
  - "2.  Client Metadata\n   Registered clients have a set of metadata values associated
    with\n   their client identifier at an authorization server, such as the list\n
    \  of valid redirection URIs or a display name.\n   These client metadata values
    are used in two ways:\n   o  as input values to registration requests, and\n   o
    \ as output values in registration responses.\n   The following client metadata
    fields are defined by this\n   specification.  The implementation and use of all
    client metadata\n   fields is OPTIONAL, unless stated otherwise.  All data member
    types\n   (strings, arrays, numbers) are defined in terms of their JSON\n   [RFC7159]
    representations.\n   redirect_uris\n      Array of redirection URI strings for
    use in redirect-based flows\n      such as the authorization code and implicit
    flows.  As required by\n      Section 2 of OAuth 2.0 [RFC6749], clients using
    flows with\n      redirection MUST register their redirection URI values.\n      Authorization
    servers that support dynamic registration for\n      redirect-based flows MUST
    implement support for this metadata\n      value.\n   token_endpoint_auth_method\n
    \     String indicator of the requested authentication method for the\n      token
    endpoint.  Values defined by this specification are:\n      *  \"none\": The client
    is a public client as defined in OAuth 2.0,\n         Section 2.1, and does not
    have a client secret.\n      *  \"client_secret_post\": The client uses the HTTP
    POST parameters\n         as defined in OAuth 2.0, Section 2.3.1.\n      *  \"client_secret_basic\":
    The client uses HTTP Basic as defined in\n         OAuth 2.0, Section 2.3.1.\n
    \     Additional values can be defined via the IANA \"OAuth Token\n      Endpoint
    Authentication Methods\" registry established in\n      Section 4.2.  Absolute
    URIs can also be used as values for this\n      parameter without being registered.
    \ If unspecified or omitted,\n      the default is \"client_secret_basic\", denoting
    the HTTP Basic\n      authentication scheme as specified in Section 2.3.1 of OAuth
    2.0.\n   grant_types\n      Array of OAuth 2.0 grant type strings that the client
    can use at\n      the token endpoint.  These grant types are defined as follows:\n
    \     *  \"authorization_code\": The authorization code grant type defined\n         in
    OAuth 2.0, Section 4.1.\n      *  \"implicit\": The implicit grant type defined
    in OAuth 2.0,\n         Section 4.2.\n      *  \"password\": The resource owner
    password credentials grant type\n         defined in OAuth 2.0, Section 4.3.\n
    \     *  \"client_credentials\": The client credentials grant type defined\n         in
    OAuth 2.0, Section 4.4.\n      *  \"refresh_token\": The refresh token grant type
    defined in OAuth\n         2.0, Section 6.\n      *  \"urn:ietf:params:oauth:grant-type:jwt-bearer\":
    The JWT Bearer\n         Token Grant Type defined in OAuth JWT Bearer Token Profiles\n
    \        [RFC7523].\n      *  \"urn:ietf:params:oauth:grant-type:saml2-bearer\":
    The SAML 2.0\n         Bearer Assertion Grant defined in OAuth SAML 2 Bearer Token\n
    \        Profiles [RFC7522].\n      If the token endpoint is used in the grant
    type, the value of this\n      parameter MUST be the same as the value of the
    \"grant_type\"\n      parameter passed to the token endpoint defined in the grant
    type\n      definition.  Authorization servers MAY allow for other values as\n
    \     defined in the grant type extension process described in OAuth\n      2.0,
    Section 4.5.  If omitted, the default behavior is that the\n      client will
    use only the \"authorization_code\" Grant Type.\n   response_types\n      Array
    of the OAuth 2.0 response type strings that the client can\n      use at the authorization
    endpoint.  These response types are\n      defined as follows:\n      *  \"code\":
    The authorization code response type defined in OAuth\n         2.0, Section 4.1.\n
    \     *  \"token\": The implicit response type defined in OAuth 2.0,\n         Section
    4.2.\n      If the authorization endpoint is used by the grant type, the value\n
    \     of this parameter MUST be the same as the value of the\n      \"response_type\"
    parameter passed to the authorization endpoint\n      defined in the grant type
    definition.  Authorization servers MAY\n      allow for other values as defined
    in the grant type extension\n      process is described in OAuth 2.0, Section
    4.5.  If omitted, the\n      default is that the client will use only the \"code\"
    response type.\n   client_name\n      Human-readable string name of the client
    to be presented to the\n      end-user during authorization.  If omitted, the
    authorization\n      server MAY display the raw \"client_id\" value to the end-user\n
    \     instead.  It is RECOMMENDED that clients always send this field.\n      The
    value of this field MAY be internationalized, as described in\n      Section 2.2.\n
    \  client_uri\n      URL string of a web page providing information about the
    client.\n      If present, the server SHOULD display this URL to the end-user
    in\n      a clickable fashion.  It is RECOMMENDED that clients always send\n      this
    field.  The value of this field MUST point to a valid web\n      page.  The value
    of this field MAY be internationalized, as\n      described in Section 2.2.\n
    \  logo_uri\n      URL string that references a logo for the client.  If present,
    the\n      server SHOULD display this image to the end-user during approval.\n
    \     The value of this field MUST point to a valid image file.  The\n      value
    of this field MAY be internationalized, as described in\n      Section 2.2.\n
    \  scope\n      String containing a space-separated list of scope values (as\n
    \     described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client\n      can
    use when requesting access tokens.  The semantics of values in\n      this list
    are service specific.  If omitted, an authorization\n      server MAY register
    a client with a default set of scopes.\n   contacts\n      Array of strings representing
    ways to contact people responsible\n      for this client, typically email addresses.
    \ The authorization\n      server MAY make these contact addresses available to
    end-users for\n      support requests for the client.  See Section 6 for information
    on\n      Privacy Considerations.\n   tos_uri\n      URL string that points to
    a human-readable terms of service\n      document for the client that describes
    a contractual relationship\n      between the end-user and the client that the
    end-user accepts when\n      authorizing the client.  The authorization server
    SHOULD display\n      this URL to the end-user if it is provided.  The value of
    this\n      field MUST point to a valid web page.  The value of this field MAY\n
    \     be internationalized, as described in Section 2.2.\n   policy_uri\n      URL
    string that points to a human-readable privacy policy document\n      that describes
    how the deployment organization collects, uses,\n      retains, and discloses
    personal data.  The authorization server\n      SHOULD display this URL to the
    end-user if it is provided.  The\n      value of this field MUST point to a valid
    web page.  The value of\n      this field MAY be internationalized, as described
    in Section 2.2.\n   jwks_uri\n      URL string referencing the client's JSON Web
    Key (JWK) Set\n      [RFC7517] document, which contains the client's public keys.
    \ The\n      value of this field MUST point to a valid JWK Set document.  These\n
    \     keys can be used by higher-level protocols that use signing or\n      encryption.
    \ For instance, these keys might be used by some\n      applications for validating
    signed requests made to the token\n      endpoint when using JWTs for client authentication
    [RFC7523].  Use\n      of this parameter is preferred over the \"jwks\" parameter,
    as it\n      allows for easier key rotation.  The \"jwks_uri\" and \"jwks\"\n
    \     parameters MUST NOT both be present in the same request or\n      response.\n
    \  jwks\n      Client's JSON Web Key Set [RFC7517] document value, which contains\n
    \     the client's public keys.  The value of this field MUST be a JSON\n      object
    containing a valid JWK Set.  These keys can be used by\n      higher-level protocols
    that use signing or encryption.  This\n      parameter is intended to be used
    by clients that cannot use the\n      \"jwks_uri\" parameter, such as native clients
    that cannot host\n      public URLs.  The \"jwks_uri\" and \"jwks\" parameters
    MUST NOT both\n      be present in the same request or response.\n   software_id\n
    \     A unique identifier string (e.g., a Universally Unique Identifier\n      (UUID))
    assigned by the client developer or software publisher\n      used by registration
    endpoints to identify the client software to\n      be dynamically registered.
    \ Unlike \"client_id\", which is issued by\n      the authorization server and
    SHOULD vary between instances, the\n      \"software_id\" SHOULD remain the same
    for all instances of the\n      client software.  The \"software_id\" SHOULD remain
    the same across\n      multiple updates or versions of the same piece of software.
    \ The\n      value of this field is not intended to be human readable and is\n
    \     usually opaque to the client and authorization server.\n   software_version\n
    \     A version identifier string for the client software identified by\n      \"software_id\".
    \ The value of the \"software_version\" SHOULD change\n      on any update to
    the client software identified by the same\n      \"software_id\".  The value
    of this field is intended to be compared\n      using string equality matching
    and no other comparison semantics\n      are defined by this specification.  The
    value of this field is\n      outside the scope of this specification, but it
    is not intended to\n      be human readable and is usually opaque to the client
    and\n      authorization server.  The definition of what constitutes an\n      update
    to client software that would trigger a change to this\n      value is specific
    to the software itself and is outside the scope\n      of this specification.\n
    \  Extensions and profiles of this specification can expand this list\n   with
    metadata names and descriptions registered in accordance with\n   the IANA Considerations
    in Section 4 of this document.  The\n   authorization server MUST ignore any client
    metadata sent by the\n   client that it does not understand (for instance, by
    silently\n   removing unknown metadata from the client's registration record\n
    \  during processing).  The authorization server MAY reject any\n   requested
    client metadata values by replacing requested values with\n   suitable defaults
    as described in Section 3.2.1 or by returning an\n   error response as described
    in Section 3.2.2.\n   Client metadata values can be either communicated directly
    in the\n   body of a registration request, as described in Section 3.1, or\n   included
    as claims in a software statement, as described in\n   Section 2.3; a mixture
    of both is also possible.  If the same client\n   metadata name is present in
    both locations and the software statement\n   is trusted by the authorization
    server, the value of a claim in the\n   software statement MUST take precedence.\n"
  - contents:
    - "2.1.  Relationship between Grant Types and Response Types\n   The \"grant_types\"
      and \"response_types\" values described above are\n   partially orthogonal,
      as they refer to arguments passed to different\n   endpoints in the OAuth protocol.
      \ However, they are related in that\n   the \"grant_types\" available to a client
      influence the\n   \"response_types\" that the client is allowed to use, and
      vice versa.\n   For instance, a \"grant_types\" value that includes\n   \"authorization_code\"
      implies a \"response_types\" value that includes\n   \"code\", as both values
      are defined as part of the OAuth 2.0\n   authorization code grant.  As such,
      a server supporting these fields\n   SHOULD take steps to ensure that a client
      cannot register itself into\n   an inconsistent state, for example, by returning
      an\n   \"invalid_client_metadata\" error response to an inconsistent\n   registration
      request.\n   The correlation between the two fields is listed in the table below.\n
      \  +-----------------------------------------------+-------------------+\n   |
      grant_types value includes:                   | response_types    |\n   |                                               |
      value includes:   |\n   +-----------------------------------------------+-------------------+\n
      \  | authorization_code                            | code              |\n   |
      implicit                                      | token             |\n   | password
      \                                     | (none)            |\n   | client_credentials
      \                           | (none)            |\n   | refresh_token                                 |
      (none)            |\n   | urn:ietf:params:oauth:grant-type:jwt-bearer   | (none)
      \           |\n   | urn:ietf:params:oauth:grant-type:saml2-bearer | (none)            |\n
      \  +-----------------------------------------------+-------------------+\n   Extensions
      and profiles of this document that introduce new values to\n   either the \"grant_types\"
      or \"response_types\" parameter MUST document\n   all correspondences between
      these two parameter types.\n"
    title: 2.1.  Relationship between Grant Types and Response Types
  - contents:
    - "2.2.  Human-Readable Client Metadata\n   Human-readable client metadata values
      and client metadata values that\n   reference human-readable values MAY be represented
      in multiple\n   languages and scripts.  For example, the values of fields such
      as\n   \"client_name\", \"tos_uri\", \"policy_uri\", \"logo_uri\", and \"client_uri\"\n
      \  might have multiple locale-specific values in some client\n   registrations
      to facilitate use in different locations.\n   To specify the languages and scripts,
      BCP 47 [RFC5646] language tags\n   are added to client metadata member names,
      delimited by a \"#\"\n   character.  Since JSON [RFC7159] member names are case
      sensitive, it\n   is RECOMMENDED that language tag values used in Claim Names
      be\n   spelled using the character case with which they are registered in\n
      \  the \"IANA Language Subtag\" registry [IANA.Language].  In particular,\n
      \  normally language names are spelled with lowercase characters, region\n   names
      are spelled with uppercase characters, and languages are\n   spelled with mixed-case
      characters.  However, since BCP 47 language\n   tag values are case-insensitive,
      implementations SHOULD interpret the\n   language tag values supplied in a case
      insensitive manner.  Per the\n   recommendations in BCP 47, language tag values
      used in metadata\n   member names should only be as specific as necessary.  For
      instance,\n   using \"fr\" might be sufficient in many contexts, rather than
      \"fr-CA\"\n   or \"fr-FR\".\n   For example, a client could represent its name
      in English as\n   \"client_name#en\": \"My Client\" and its name in Japanese
      as\n   \"client_name#ja-Jpan-JP\":\n   \"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8\\u540D\"
      within the same\n   registration request.  The authorization server MAY display
      any or\n   all of these names to the resource owner during the authorization\n
      \  step, choosing which name to display based on system configuration,\n   user
      preferences or other factors.\n   If any human-readable field is sent without
      a language tag, parties\n   using it MUST NOT make any assumptions about the
      language, character\n   set, or script of the string value, and the string value
      MUST be used\n   as is wherever it is presented in a user interface.  To facilitate\n
      \  interoperability, it is RECOMMENDED that clients and servers use a\n   human-readable
      field without any language tags in addition to any\n   language-specific fields,
      and it is RECOMMENDED that any human-\n   readable fields sent without language
      tags contain values suitable\n   for display on a wide variety of systems.\n
      \  Implementer's Note: Many JSON libraries make it possible to reference\n   members
      of a JSON object as members of an object construct in the\n   native programming
      environment of the library.  However, while the\n   \"#\" character is a valid
      character inside of a JSON object's member\n   names, it is not a valid character
      for use in an object member name\n   in many programming environments.  Therefore,
      implementations will\n   need to use alternative access forms for these claims.
      \ For instance,\n   in JavaScript, if one parses the JSON as follows, \"var
      j =\n   JSON.parse(json);\", then as a workaround the member\n   \"client_name#en-us\"
      can be accessed using the JavaScript syntax\n   \"j[\"client_name#en-us\"]\".\n"
    title: 2.2.  Human-Readable Client Metadata
  - contents:
    - "2.3.  Software Statement\n   A software statement is a JSON Web Token (JWT)
      [RFC7519] that asserts\n   metadata values about the client software as a bundle.
      \ A set of\n   claims that can be used in a software statement are defined in\n
      \  Section 2.  When presented to the authorization server as part of a\n   client
      registration request, the software statement MUST be digitally\n   signed or
      MACed using JSON Web Signature (JWS) [RFC7515] and MUST\n   contain an \"iss\"
      (issuer) claim denoting the party attesting to the\n   claims in the software
      statement.  It is RECOMMENDED that software\n   statements be digitally signed
      using the \"RS256\" signature algorithm,\n   although particular applications
      MAY specify the use of different\n   algorithms.  It is RECOMMENDED that software
      statements contain the\n   \"software_id\" claim to allow authorization servers
      to correlate\n   different instances of software using the same software statement.\n
      \  For example, a software statement could contain the following claims:\n     {\n
      \     \"software_id\": \"4NRB1-0XZABZI9E6-5SM3R\",\n      \"client_name\": \"Example
      Statement-based Client\",\n      \"client_uri\": \"https://client.example.net/\"\n
      \    }\n   The following non-normative example JWT includes these claims and
      has\n   been asymmetrically signed using \"RS256\" (with line breaks for\n   display
      purposes only):\n     eyJhbGciOiJSUzI1NiJ9.\n     eyJzb2Z0d2FyZV9pZCI6IjROUkIxLTBYWkFCWkk5RTYtNVNNM1IiLCJjbGll\n
      \    bnRfbmFtZSI6IkV4YW1wbGUgU3RhdGVtZW50LWJhc2VkIENsaWVudCIsImNs\n     aWVudF91cmkiOiJodHRwczovL2NsaWVudC5leGFtcGxlLm5ldC8ifQ.\n
      \    GHfL4QNIrQwL18BSRdE595T9jbzqa06R9BT8w409x9oIcKaZo_mt15riEXHa\n     zdISUvDIZhtiyNrSHQ8K4TvqWxH6uJgcmoodZdPwmWRIEYbQDLqPNxREtYn0\n
      \    5X3AR7ia4FRjQ2ojZjk5fJqJdQ-JcfxyhK-P8BAWBd6I2LLA77IG32xtbhxY\n     fHX7VhuU5ProJO8uvu3Ayv4XRhLZJY4yKfmyjiiKiPNe-Ia4SMy_d_QSWxsk\n
      \    U5XIQl5Sa2YRPMbDRXttm2TfnZM1xx70DoYi8g6czz-CPGRi4SW_S2RKHIJf\n     IjoI3zTJ0Y2oe0_EJAiXbL6OyF9S5tKxDXV8JIndSA\n
      \  The software statement is typically distributed with all instances of\n   a
      client application.  The means by which a client or developer\n   obtains a
      software statement are outside the scope of this\n   specification.  Some common
      methods could include a client developer\n   generating a client-specific JWT
      by registering with a software API\n   publisher to obtain a software statement
      for a class of clients.\n   The criteria by which authorization servers determine
      whether to\n   trust and utilize the information in a software statement are
      outside\n   the scope of this specification.\n   In some cases, authorization
      servers MAY choose to accept a software\n   statement value directly as a client
      identifier in an authorization\n   request, without a prior dynamic client registration
      having been\n   performed.  The circumstances under which an authorization server\n
      \  would do so, and the specific software statement characteristics\n   required
      in this case, are outside the scope of this specification.\n"
    title: 2.3.  Software Statement
  title: 2.  Client Metadata
- contents:
  - "3.  Client Registration Endpoint\n   The client registration endpoint is an OAuth
    2.0 endpoint defined in\n   this document that is designed to allow a client to
    be registered\n   with the authorization server.  The client registration endpoint
    MUST\n   accept HTTP POST messages with request parameters encoded in the\n   entity
    body using the \"application/json\" format.  The client\n   registration endpoint
    MUST be protected by a transport-layer security\n   mechanism, as described in
    Section 5.\n   The client registration endpoint MAY be an OAuth 2.0 [RFC6749]\n
    \  protected resource and it MAY accept an initial access token in the\n   form
    of an OAuth 2.0 access token to limit registration to only\n   previously authorized
    parties.  The method by which the initial\n   access token is obtained by the
    client or developer is generally out\n   of band and is out of scope for this
    specification.  The method by\n   which the initial access token is verified and
    validated by the\n   client registration endpoint is out of scope for this specification.\n
    \  To support open registration and facilitate wider interoperability,\n   the
    client registration endpoint SHOULD allow registration requests\n   with no authorization
    (which is to say, with no initial access token\n   in the request).  These requests
    MAY be rate-limited or otherwise\n   limited to prevent a denial-of-service attack
    on the client\n   registration endpoint.\n"
  - contents:
    - "3.1.  Client Registration Request\n   This operation registers a client with
      the authorization server.  The\n   authorization server assigns this client
      a unique client identifier,\n   optionally assigns a client secret, and associates
      the metadata\n   provided in the request with the issued client identifier.
      \ The\n   request includes any client metadata parameters being specified for\n
      \  the client during the registration.  The authorization server MAY\n   provision
      default values for any items omitted in the client\n   metadata.\n   To register,
      the client or developer sends an HTTP POST to the client\n   registration endpoint
      with a content type of \"application/json\".  The\n   HTTP Entity Payload is
      a JSON [RFC7159] document consisting of a JSON\n   object and all requested
      client metadata values as top-level members\n   of that JSON object.\n   For
      example, if the server supports open registration (with no\n   initial access
      token), the client could send the following\n   registration request to the
      client registration endpoint.\n   The following is a non-normative example request
      not using an initial\n   access token:\n     POST /register HTTP/1.1\n     Content-Type:
      application/json\n     Accept: application/json\n     Host: server.example.com\n
      \    {\n      \"redirect_uris\": [\n        \"https://client.example.org/callback\",\n
      \       \"https://client.example.org/callback2\"],\n      \"client_name\": \"My
      Example Client\",\n      \"client_name#ja-Jpan-JP\":\n         \"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8\\u540D\",\n
      \     \"token_endpoint_auth_method\": \"client_secret_basic\",\n      \"logo_uri\":
      \"https://client.example.org/logo.png\",\n      \"jwks_uri\": \"https://client.example.org/my_public_keys.jwks\",\n
      \     \"example_extension_parameter\": \"example_value\"\n     }\n   Alternatively,
      if the server supports authorized registration, the\n   developer or the client
      will be provisioned with an initial access\n   token.  (The method by which
      the initial access token is obtained is\n   out of scope for this specification.)
      \ The developer or client sends\n   the following authorized registration request
      to the client\n   registration endpoint.  Note that the initial access token
      sent in\n   this example as an OAuth 2.0 Bearer Token [RFC6750], but any OAuth\n
      \  2.0 token type could be used by an authorization server.\n   The following
      is a non-normative example request using an initial\n   access token and registering
      a JWK Set by value (with line breaks\n   within values for display purposes
      only):\n     POST /register HTTP/1.1\n     Content-Type: application/json\n
      \    Accept: application/json\n     Authorization: Bearer ey23f2.adfj230.af32-developer321\n
      \    Host: server.example.com\n     {\n      \"redirect_uris\": [\"https://client.example.org/callback\",\n
      \        \"https://client.example.org/callback2\"],\n      \"client_name\":
      \"My Example Client\",\n      \"client_name#ja-Jpan-JP\":\n         \"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8\\u540D\",\n
      \     \"token_endpoint_auth_method\": \"client_secret_basic\",\n      \"policy_uri\":
      \"https://client.example.org/policy.html\",\n      \"jwks\": {\"keys\": [{\n
      \        \"e\": \"AQAB\",\n         \"n\": \"nj3YJwsLUFl9BmpAbkOswCNVx17Eh9wMO-_AReZwBqfaWFcfG\n
      \  HrZXsIV2VMCNVNU8Tpb4obUaSXcRcQ-VMsfQPJm9IzgtRdAY8NN8Xb7PEcYyk\n   lBjvTtuPbpzIaqyiUepzUXNDFuAOOkrIol3WmflPUUgMKULBN0EUd1fpOD70p\n
      \  RM0rlp_gg_WNUKoW1V-3keYUJoXH9NztEDm_D2MQXj9eGOJJ8yPgGL8PAZMLe\n   2R7jb9TxOCPDED7tY_TU4nFPlxptw59A42mldEmViXsKQt60s1SLboazxFKve\n
      \  qXC_jpLUt22OC6GUG63p-REw-ZOr3r845z50wMuzifQrMI9bQ\",\n         \"kty\": \"RSA\"\n
      \     }]},\n      \"example_extension_parameter\": \"example_value\"\n     }\n"
    - contents:
      - "3.1.1.  Client Registration Request Using a Software Statement\n   In addition
        to JSON elements, client metadata values MAY also be\n   provided in a software
        statement, as described in Section 2.3.  The\n   authorization server MAY
        ignore the software statement if it does not\n   support this feature.  If
        the server supports software statements,\n   client metadata values conveyed
        in the software statement MUST take\n   precedence over those conveyed using
        plain JSON elements.\n   Software statements are included in the requesting
        JSON object using\n   this OPTIONAL member:\n   software_statement\n      A
        software statement containing client metadata values about the\n      client
        software as claims.  This is a string value containing the\n      entire signed
        JWT.\n   In the following example, some registration parameters are conveyed\n
        \  as claims in a software statement from the example in Section 2.3,\n   while
        some values specific to the client instance are conveyed as\n   regular parameters
        (with line breaks within values for display\n   purposes only):\n     POST
        /register HTTP/1.1\n     Content-Type: application/json\n     Accept: application/json\n
        \    Host: server.example.com\n     {\n       \"redirect_uris\": [\n         \"https://client.example.org/callback\",\n
        \        \"https://client.example.org/callback2\"\n       ],\n       \"software_statement\":
        \"eyJhbGciOiJSUzI1NiJ9.\n   eyJzb2Z0d2FyZV9pZCI6IjROUkIxLTBYWkFCWkk5RTYtNVNNM1IiLCJjbGll\n
        \  bnRfbmFtZSI6IkV4YW1wbGUgU3RhdGVtZW50LWJhc2VkIENsaWVudCIsImNs\n   aWVudF91cmkiOiJodHRwczovL2NsaWVudC5leGFtcGxlLm5ldC8ifQ.\n
        \  GHfL4QNIrQwL18BSRdE595T9jbzqa06R9BT8w409x9oIcKaZo_mt15riEXHa\n   zdISUvDIZhtiyNrSHQ8K4TvqWxH6uJgcmoodZdPwmWRIEYbQDLqPNxREtYn0\n
        \  5X3AR7ia4FRjQ2ojZjk5fJqJdQ-JcfxyhK-P8BAWBd6I2LLA77IG32xtbhxY\n   fHX7VhuU5ProJO8uvu3Ayv4XRhLZJY4yKfmyjiiKiPNe-Ia4SMy_d_QSWxsk\n
        \  U5XIQl5Sa2YRPMbDRXttm2TfnZM1xx70DoYi8g6czz-CPGRi4SW_S2RKHIJf\n   IjoI3zTJ0Y2oe0_EJAiXbL6OyF9S5tKxDXV8JIndSA\",\n
        \      \"scope\": \"read write\",\n       \"example_extension_parameter\":
        \"example_value\"\n     }\n"
      title: 3.1.1.  Client Registration Request Using a Software Statement
    title: 3.1.  Client Registration Request
  - contents:
    - "3.2.  Responses\n   Upon a successful registration request, the authorization
      server\n   returns a client identifier for the client.  The server responds
      with\n   an HTTP 201 Created status code and a body of type \"application/json\"\n
      \  with content as described in Section 3.2.1.\n   Upon an unsuccessful registration
      request, the authorization server\n   responds with an error, as described in
      Section 3.2.2.\n"
    - contents:
      - "3.2.1.  Client Information Response\n   The response contains the client
        identifier as well as the client\n   secret, if the client is a confidential
        client.  The response MAY\n   contain additional fields as specified by extensions
        to this\n   specification.\n   client_id\n      REQUIRED.  OAuth 2.0 client
        identifier string.  It SHOULD NOT be\n      currently valid for any other
        registered client, though an\n      authorization server MAY issue the same
        client identifier to\n      multiple instances of a registered client at its
        discretion.\n   client_secret\n      OPTIONAL.  OAuth 2.0 client secret string.
        \ If issued, this MUST\n      be unique for each \"client_id\" and SHOULD
        be unique for multiple\n      instances of a client using the same \"client_id\".
        \ This value is\n      used by confidential clients to authenticate to the
        token\n      endpoint, as described in OAuth 2.0 [RFC6749], Section 2.3.1.\n
        \  client_id_issued_at\n      OPTIONAL.  Time at which the client identifier
        was issued.  The\n      time is represented as the number of seconds from\n
        \     1970-01-01T00:00:00Z as measured in UTC until the date/time of\n      issuance.\n
        \  client_secret_expires_at\n      REQUIRED if \"client_secret\" is issued.
        \ Time at which the client\n      secret will expire or 0 if it will not expire.
        \ The time is\n      represented as the number of seconds from 1970-01-01T00:00:00Z
        as\n      measured in UTC until the date/time of expiration.\n   Additionally,
        the authorization server MUST return all registered\n   metadata about this
        client, including any fields provisioned by the\n   authorization server itself.
        \ The authorization server MAY reject or\n   replace any of the client's requested
        metadata values submitted\n   during the registration and substitute them
        with suitable values.\n   The client or developer can check the values in
        the response to\n   determine if the registration is sufficient for use (e.g.,
        the\n   registered \"token_endpoint_auth_method\" is supported by the client\n
        \  software) and determine a course of action appropriate for the client\n
        \  software.  The response to such a situation is out of scope for this\n
        \  specification but could include filing a report with the application\n
        \  developer or authorization server provider, attempted re-registration\n
        \  with different metadata values, or various other methods.  For\n   instance,
        if the server also supports a registration management\n   mechanism such as
        that defined in [RFC7592], the client or developer\n   could attempt to update
        the registration with different metadata\n   values.  This process could also
        be aided by a service discovery\n   protocol, such as [OpenID.Discovery],
        which can list a server's\n   capabilities, allowing a client to make a more
        informed registration\n   request.  The use of any such management or discovery
        system is\n   optional and outside the scope of this specification.\n   The
        successful registration response uses an HTTP 201 Created status\n   code
        with a body of type \"application/json\" consisting of a single\n   JSON object
        [RFC7159] with all parameters as top-level members of the\n   object.\n   If
        a software statement was used as part of the registration, its\n   value MUST
        be returned unmodified in the response along with other\n   metadata using
        the \"software_statement\" member name.  Client metadata\n   elements used
        from the software statement MUST also be returned\n   directly as top-level
        client metadata values in the registration\n   response (possibly with different
        values, since the values requested\n   and the values used may differ).\n
        \  The following is a non-normative example response of a successful\n   registration:\n
        \    HTTP/1.1 201 Created\n     Content-Type: application/json\n     Cache-Control:
        no-store\n     Pragma: no-cache\n     {\n      \"client_id\": \"s6BhdRkqt3\",\n
        \     \"client_secret\": \"cf136dc3c1fc93f31185e5885805d\",\n      \"client_id_issued_at\":
        2893256800,\n      \"client_secret_expires_at\": 2893276800,\n      \"redirect_uris\":
        [\n        \"https://client.example.org/callback\",\n        \"https://client.example.org/callback2\"],\n
        \     \"grant_types\": [\"authorization_code\", \"refresh_token\"],\n      \"client_name\":
        \"My Example Client\",\n      \"client_name#ja-Jpan-JP\":\n         \"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8\\u540D\",\n
        \     \"token_endpoint_auth_method\": \"client_secret_basic\",\n      \"logo_uri\":
        \"https://client.example.org/logo.png\",\n      \"jwks_uri\": \"https://client.example.org/my_public_keys.jwks\",\n
        \     \"example_extension_parameter\": \"example_value\"\n     }\n"
      title: 3.2.1.  Client Information Response
    - contents:
      - "3.2.2.  Client Registration Error Response\n   When an OAuth 2.0 error condition
        occurs, such as the client\n   presenting an invalid initial access token,
        the authorization server\n   returns an error response appropriate to the
        OAuth 2.0 token type.\n   When a registration error condition occurs, the
        authorization server\n   returns an HTTP 400 status code (unless otherwise
        specified) with\n   content type \"application/json\" consisting of a JSON
        object [RFC7159]\n   describing the error in the response body.\n   Two members
        are defined for inclusion in the JSON object:\n   error\n      REQUIRED.  Single
        ASCII error code string.\n   error_description\n      OPTIONAL.  Human-readable
        ASCII text description of the error used\n      for debugging.\n   Other members
        MAY also be included and, if they are not understood,\n   they MUST be ignored.\n
        \  This specification defines the following error codes:\n   invalid_redirect_uri\n
        \     The value of one or more redirection URIs is invalid.\n   invalid_client_metadata\n
        \     The value of one of the client metadata fields is invalid and the\n
        \     server has rejected this request.  Note that an authorization\n      server
        MAY choose to substitute a valid value for any requested\n      parameter
        of a client's metadata.\n   invalid_software_statement\n      The software
        statement presented is invalid.\n   unapproved_software_statement\n      The
        software statement presented is not approved for use by this\n      authorization
        server.\n   The following is a non-normative example of an error response\n
        \  resulting from a redirection URI that has been blacklisted by the\n   authorization
        server (with line breaks within values for display\n   purposes only):\n     HTTP/1.1
        400 Bad Request\n     Content-Type: application/json\n     Cache-Control:
        no-store\n     Pragma: no-cache\n     {\n      \"error\": \"invalid_redirect_uri\",\n
        \     \"error_description\": \"The redirection URI\n        http://sketchy.example.com
        is not allowed by this server.\"\n     }\n   The following is a non-normative
        example of an error response\n   resulting from an inconsistent combination
        of \"response_types\" and\n   \"grant_types\" values (with line breaks within
        values for display\n   purposes only):\n     HTTP/1.1 400 Bad Request\n     Content-Type:
        application/json\n     Cache-Control: no-store\n     Pragma: no-cache\n     {\n
        \     \"error\": \"invalid_client_metadata\",\n      \"error_description\":
        \"The grant type 'authorization_code' must be\n        registered along with
        the response type 'code' but found only\n       'implicit' instead.\"\n     }\n"
      title: 3.2.2.  Client Registration Error Response
    title: 3.2.  Responses
  title: 3.  Client Registration Endpoint
- contents:
  - '4.  IANA Considerations

    '
  - contents:
    - "4.1.  OAuth Dynamic Client Registration Metadata Registry\n   This specification
      establishes the \"OAuth Dynamic Client Registration\n   Metadata\" registry.\n
      \  OAuth registration client metadata names and descriptions are\n   registered
      with a Specification Required ([RFC5226]) after a two-week\n   review period
      on the oauth-ext-review@ietf.org mailing list, on the\n   advice of one or more
      Designated Experts.  However, to allow for the\n   allocation of names prior
      to publication, the Designated Experts may\n   approve registration once they
      are satisfied that such a\n   specification will be published, per [RFC7120].\n
      \  Registration requests sent to the mailing list for review should use\n   an
      appropriate subject (e.g., \"Request to register OAuth Dynamic\n   Client Registration
      Metadata name: example\").\n   Within the review period, the Designated Experts
      will either approve\n   or deny the registration request, communicating this
      decision to the\n   review list and IANA.  Denials should include an explanation
      and, if\n   applicable, suggestions as to how to make the request successful.\n
      \  IANA must only accept registry updates from the Designated Experts\n   and
      should direct all requests for registration to the review mailing\n   list.\n"
    - contents:
      - "4.1.1.  Registration Template\n   Client Metadata Name:\n      The name requested
        (e.g., \"example\").  This name is case\n      sensitive.  Names that match
        other registered names in a case-\n      insensitive manner SHOULD NOT be
        accepted.\n   Client Metadata Description:\n      Brief description of the
        metadata value (e.g., \"Example\n      description\").\n   Change Controller:\n
        \     For Standards Track RFCs, list \"IESG\".  For others, give the name\n
        \     of the responsible party.  Other details (e.g., postal address,\n      email
        address, home page URI) may also be included.\n   Specification Document(s):\n
        \     Reference to the document or documents that specify the client\n      metadata
        definition, preferably including a URI that can be used\n      to retrieve
        a copy of the documents.  An indication of the\n      relevant sections may
        also be included but is not required.\n"
      title: 4.1.1.  Registration Template
    - contents:
      - "4.1.2.  Initial Registry Contents\n   The initial contents of the \"OAuth
        Dynamic Client Registration\n   Metadata\" registry are:\n   o  Client Metadata
        Name: \"redirect_uris\"\n   o  Client Metadata Description: Array of redirection
        URIs for use in\n      redirect-based flows\n   o  Change Controller: IESG\n
        \  o  Specification Document(s): RFC 7591\n   o  Client Metadata Name: \"token_endpoint_auth_method\"\n
        \  o  Client Metadata Description: Requested authentication method for\n      the
        token endpoint\n   o  Change Controller: IESG\n   o  Specification Document(s):
        RFC 7591\n   o  Client Metadata Name: \"grant_types\"\n   o  Client Metadata
        Description: Array of OAuth 2.0 grant types that\n      the client may use\n
        \  o  Change Controller: IESG\n   o  Specification Document(s): RFC 7591\n
        \  o  Client Metadata Name: \"response_types\"\n   o  Client Metadata Description:
        Array of the OAuth 2.0 response types\n      that the client may use\n   o
        \ Change Controller: IESG\n   o  Specification Document(s): RFC 7591\n   o
        \ Client Metadata Name: \"client_name\"\n   o  Client Metadata Description:
        Human-readable name of the client to\n      be presented to the user\n   o
        \ Change Controller: IESG\n   o  Specification Document(s): RFC 7591\n   o
        \ Client Metadata Name: \"client_uri\"\n   o  Client Metadata Description:
        URL of a web page providing\n      information about the client\n   o  Change
        Controller: IESG\n   o  Specification Document(s): RFC 7591\n   o  Client
        Metadata Name: \"logo_uri\"\n   o  Client Metadata Description: URL that references
        a logo for the\n      client\n   o  Change Controller: IESG\n   o  Specification
        Document(s): RFC 7591\n   o  Client Metadata Name: \"scope\"\n   o  Client
        Metadata Description: Space-separated list of OAuth 2.0\n      scope values\n
        \  o  Change Controller: IESG\n   o  Specification Document(s): RFC 7591\n
        \  o  Client Metadata Name: \"contacts\"\n   o  Client Metadata Description:
        Array of strings representing ways to\n      contact people responsible for
        this client, typically email\n      addresses\n   o  Change Controller: IESG\n
        \  o  Specification Document(s): RFC 7591\n   o  Client Metadata Name: \"tos_uri\"\n
        \  o  Client Metadata Description: URL that points to a human-readable\n      terms
        of service document for the client\n   o  Change Controller: IESG\n   o  Specification
        Document(s): RFC 7591\n   o  Client Metadata Name: \"policy_uri\"\n   o  Client
        Metadata Description: URL that points to a human-readable\n      policy document
        for the client\n   o  Change Controller: IESG\n   o  Specification Document(s):
        RFC 7591\n   o  Client Metadata Name: \"jwks_uri\"\n   o  Client Metadata
        Description: URL referencing the client's JSON Web\n      Key Set [RFC7517]
        document representing the client's public keys\n   o  Change Controller: IESG\n
        \  o  Specification Document(s): RFC 7591\n   o  Client Metadata Name: \"jwks\"\n
        \  o  Client Metadata Description: Client's JSON Web Key Set [RFC7517]\n      document
        representing the client's public keys\n   o  Change Controller: IESG\n   o
        \ Specification Document(s): RFC 7591\n   o  Client Metadata Name: \"software_id\"\n
        \  o  Client Metadata Description: Identifier for the software that\n      comprises
        a client\n   o  Change Controller: IESG\n   o  Specification Document(s):
        RFC 7591\n   o  Client Metadata Name: \"software_version\"\n   o  Client Metadata
        Description: Version identifier for the software\n      that comprises a client\n
        \  o  Change Controller: IESG\n   o  Specification Document(s): RFC 7591\n
        \  o  Client Metadata Name: \"client_id\"\n   o  Client Metadata Description:
        Client identifier\n   o  Change Controller: IESG\n   o  Specification Document(s):
        RFC 7591\n   o  Client Metadata Name: \"client_secret\"\n   o  Client Metadata
        Description: Client secret\n   o  Change Controller: IESG\n   o  Specification
        Document(s): RFC 7591\n   o  Client Metadata Name: \"client_id_issued_at\"\n
        \  o  Client Metadata Description: Time at which the client identifier\n      was
        issued\n   o  Change Controller: IESG\n   o  Specification Document(s): RFC
        7591\n   o  Client Metadata Name: \"client_secret_expires_at\"\n   o  Client
        Metadata Description: Time at which the client secret will\n      expire\n
        \  o  Change Controller: IESG\n   o  Specification Document(s): RFC 7591\n"
      title: 4.1.2.  Initial Registry Contents
    title: 4.1.  OAuth Dynamic Client Registration Metadata Registry
  - contents:
    - "4.2.  OAuth Token Endpoint Authentication Methods Registry\n   This specification
      establishes the \"OAuth Token Endpoint\n   Authentication Methods\" registry.\n
      \  Additional values for use as \"token_endpoint_auth_method\" values are\n
      \  registered with a Specification Required ([RFC5226]) after a two-week\n   review
      period on the oauth-ext-review@ietf.org mailing list, on the\n   advice of one
      or more Designated Experts.  However, to allow for the\n   allocation of values
      prior to publication, the Designated Experts may\n   approve registration once
      they are satisfied that such a\n   specification will be published, per [RFC7120].\n
      \  Registration requests must be sent to the oauth-ext-review@ietf.org\n   mailing
      list for review and comment, with an appropriate subject\n   (e.g., \"Request
      to register token_endpoint_auth_method value:\n   example\").\n   Within the
      review period, the Designated Experts will either approve\n   or deny the registration
      request, communicating this decision to the\n   review list and IANA.  Denials
      should include an explanation and, if\n   applicable, suggestions as to how
      to make the request successful.\n   IANA must only accept registry updates from
      the Designated Experts\n   and should direct all requests for registration to
      the review mailing\n   list.\n"
    - contents:
      - "4.2.1.  Registration Template\n   Token Endpoint Authentication Method Name:\n
        \     The name requested (e.g., \"example\").  This name is case\n      sensitive.
        \ Names that match other registered names in a case-\n      insensitive manner
        SHOULD NOT be accepted.\n   Change Controller:\n      For Standards Track
        RFCs, list \"IESG\".  For others, give the name\n      of the responsible
        party.  Other details (e.g., postal address,\n      email address, home page
        URI) may also be included.\n   Specification Document(s):\n      Reference
        to the document or documents that specify the token\n      endpoint authentication
        method, preferably including a URI that\n      can be used to retrieve a copy
        of the document or documents.  An\n      indication of the relevant sections
        may also be included but is\n      not required.\n"
      title: 4.2.1.  Registration Template
    - contents:
      - "4.2.2.  Initial Registry Contents\n   The initial contents of the \"OAuth
        Token Endpoint Authentication\n   Methods\" registry are:\n   o  Token Endpoint
        Authentication Method Name: \"none\"\n   o  Change Controller: IESG\n   o
        \ Specification Document(s): RFC 7591\n   o  Token Endpoint Authentication
        Method Name: \"client_secret_post\"\n   o  Change Controller: IESG\n   o  Specification
        Document(s): RFC 7591\n   o  Token Endpoint Authentication Method Name: \"client_secret_basic\"\n
        \  o  Change Controller: IESG\n   o  Specification Document(s): RFC 7591\n"
      title: 4.2.2.  Initial Registry Contents
    title: 4.2.  OAuth Token Endpoint Authentication Methods Registry
  title: 4.  IANA Considerations
- contents:
  - "5.  Security Considerations\n   Since requests to the client registration endpoint
    result in the\n   transmission of clear-text credentials (in the HTTP request
    and\n   response), the authorization server MUST require the use of a\n   transport-layer
    security mechanism when sending requests to the\n   registration endpoint.  The
    server MUST support TLS 1.2 [RFC5246] and\n   MAY support additional transport-layer
    security mechanisms meeting\n   its security requirements.  When using TLS, the
    client MUST perform a\n   TLS/SSL server certificate check, per RFC 6125 [RFC6125].\n
    \  Implementation security considerations can be found in\n   Recommendations
    for Secure Use of TLS and DTLS [BCP195].\n   For clients that use redirect-based
    grant types such as\n   \"authorization_code\" and \"implicit\", authorization
    servers MUST\n   require clients to register their redirection URI values.  This
    can\n   help mitigate attacks where rogue actors inject and impersonate a\n   validly
    registered client and intercept its authorization code or\n   tokens through an
    invalid redirection URI or open redirector.\n   Additionally, in order to prevent
    hijacking of the return values of\n   the redirection, registered redirection
    URI values MUST be one of:\n   o  A remote web site protected by TLS\n      (e.g.,
    https://client.example.com/oauth_redirect)\n   o  A web site hosted on the local
    machine using an HTTP URI\n      (e.g., http://localhost:8080/oauth_redirect)\n
    \  o  A non-HTTP application-specific URL that is available only to the\n      client
    application\n      (e.g., exampleapp://oauth_redirect)\n   Public clients MAY
    register with an authorization server using this\n   protocol, if the authorization
    server's policy allows them.  Public\n   clients use a \"none\" value for the
    \"token_endpoint_auth_method\"\n   metadata field and are generally used with
    the \"implicit\" grant type.\n   Often these clients will be short-lived in-browser
    applications\n   requesting access to a user's resources and access is tied to
    a\n   user's active session at the authorization server.  Since such\n   clients
    often do not have long-term storage, it is possible that such\n   clients would
    need to re-register every time the browser application\n   is loaded.  To avoid
    the resulting proliferation of dead client\n   identifiers, an authorization server
    MAY decide to expire\n   registrations for existing clients meeting certain criteria
    after a\n   period of time has elapsed.  Alternatively, such clients could be\n
    \  registered on the server where the in-browser application's code is\n   served
    from, and the client's configuration could be pushed to the\n   browser alongside
    the code.\n   Since different OAuth 2.0 grant types have different security and\n
    \  usage properties, an authorization server MAY require separate\n   registrations
    for a piece of software to support multiple grant\n   types.  For instance, an
    authorization server might require that all\n   clients using the \"authorization_code\"
    grant type make use of a\n   client secret for the \"token_endpoint_auth_method\"
    but any clients\n   using the \"implicit\" grant type not use any authentication
    at the\n   token endpoint.  In such a situation, a server MAY disallow clients\n
    \  from registering for both the \"authorization_code\" and \"implicit\"\n   grant
    types simultaneously.  Similarly, the \"authorization_code\"\n   grant type is
    used to represent access on behalf of an end-user, but\n   the \"client_credentials\"
    grant type represents access on behalf of\n   the client itself.  For security
    reasons, an authorization server\n   could require that different scopes be used
    for these different use\n   cases, and, as a consequence, it MAY disallow these
    two grant types\n   from being registered together by the same client.  In all
    of these\n   cases, the authorization server would respond with an\n   \"invalid_client_metadata\"
    error response.\n   Unless used as a claim in a software statement, the authorization\n
    \  server MUST treat all client metadata as self-asserted.  For\n   instance,
    a rogue client might use the name and logo of a legitimate\n   client that it
    is trying to impersonate.  Additionally, a rogue\n   client might try to use the
    software identifier or software version\n   of a legitimate client to attempt
    to associate itself on the\n   authorization server with instances of the legitimate
    client.  To\n   counteract this, an authorization server MUST take appropriate
    steps\n   to mitigate this risk by looking at the entire registration request\n
    \  and client configuration.  For instance, an authorization server\n   could
    issue a warning if the domain/site of the logo doesn't match\n   the domain/site
    of redirection URIs.  An authorization server could\n   also refuse registration
    requests from a known software identifier\n   that is requesting different redirection
    URIs or a different client\n   URI.  An authorization server can also present
    warning messages to\n   end-users about dynamically registered clients in all
    cases,\n   especially if such clients have been recently registered or have not\n
    \  been trusted by any users at the authorization server before.\n   In a situation
    where the authorization server is supporting open\n   client registration, it
    must be extremely careful with any URL\n   provided by the client that will be
    displayed to the user (e.g.,\n   \"logo_uri\", \"tos_uri\", \"client_uri\", and
    \"policy_uri\").  For\n   instance, a rogue client could specify a registration
    request with a\n   reference to a drive-by download in the \"policy_uri\", enticing
    the\n   user to click on it during the authorization.  The authorization\n   server
    SHOULD check to see if the \"logo_uri\", \"tos_uri\",\n   \"client_uri\", and
    \"policy_uri\" have the same host and scheme as the\n   those defined in the array
    of \"redirect_uris\" and that all of these\n   URIs resolve to valid web pages.
    \ Since these URI values that are\n   intended to be displayed to the user at
    the authorization page, the\n   authorization server SHOULD protect the user from
    malicious content\n   hosted at the URLs where possible.  For instance, before
    presenting\n   the URLs to the user at the authorization page, the authorization\n
    \  server could download the content hosted at the URLs, check the\n   content
    against a malware scanner and blacklist filter, determine\n   whether or not there
    is mixed secure and non-secure content at the\n   URL, and other possible server-side
    mitigations.  Note that the\n   content in these URLs can change at any time and
    the authorization\n   server cannot provide complete confidence in the safety
    of the URLs,\n   but these practices could help.  To further mitigate this kind
    of\n   threat, the authorization server can also warn the user that the URL\n
    \  links have been provided by a third party, should be treated with\n   caution,
    and are not hosted by the authorization server itself.  For\n   instance, instead
    of providing the links directly in an HTML anchor,\n   the authorization server
    can direct the user to an interstitial\n   warning page before allowing the user
    to continue to the target URL.\n   Clients MAY use both the direct JSON object
    and the JWT-encoded\n   software statement to present client metadata to the authorization\n
    \  server as part of the registration request.  A software statement is\n   cryptographically
    protected and represents claims made by the issuer\n   of the statement, while
    the JSON object represents the self-asserted\n   claims made by the client or
    developer directly.  If the software\n   statement is valid and signed by an acceptable
    authority (such as the\n   software API publisher), the values of client metadata
    within the\n   software statement MUST take precedence over those metadata values\n
    \  presented in the plain JSON object, which could have been intercepted\n   and
    modified.\n   Like all metadata values, the software statement is an item that
    is\n   self-asserted by the client, even though its contents have been\n   digitally
    signed or MACed by the issuer of the software statement.\n   As such, presentation
    of the software statement is not sufficient in\n   most cases to fully identify
    a piece of client software.  An initial\n   access token, in contrast, does not
    necessarily contain information\n   about a particular piece of client software
    but instead represents\n   authorization to use the registration endpoint.  An
    authorization\n   server MUST consider the full registration request, including
    the\n   software statement, initial access token, and JSON client metadata\n   values,
    when deciding whether to honor a given registration request.\n   If an authorization
    server receives a registration request for a\n   client that is not intended to
    have multiple instances registered\n   simultaneously and the authorization server
    can infer a duplication\n   of registration (e.g., it uses the same \"software_id\"
    and\n   \"software_version\" values as another existing client), the server\n
    \  SHOULD treat the new registration as being suspect and reject the\n   registration.
    \ It is possible that the new client is trying to\n   impersonate the existing
    client in order to trick users into\n   authorizing it, or that the original registration
    is no longer valid.\n   The details of managing this situation are specific to
    the\n   authorization server deployment and outside the scope of this\n   specification.\n
    \  Since a client identifier is a public value that can be used to\n   impersonate
    a client at the authorization endpoint, an authorization\n   server that decides
    to issue the same client identifier to multiple\n   instances of a registered
    client needs to be very particular about\n   the circumstances under which this
    occurs.  For instance, the\n   authorization server can limit a given client identifier
    to clients\n   using the same redirect-based flow and the same redirection URIs.
    \ An\n   authorization server SHOULD NOT issue the same client secret to\n   multiple
    instances of a registered client, even if they are issued\n   the same client
    identifier, or else the client secret could be\n   leaked, allowing malicious
    impostors to impersonate a confidential\n   client.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  Privacy Considerations\n   As the protocol described in this specification
    deals almost\n   exclusively with information about software and not people, there
    are\n   very few privacy concerns for its use.  The notable exception is the\n
    \  \"contacts\" field as defined in Section 2, which contains contact\n   information
    for the developers or other parties responsible for the\n   client software.  These
    values are intended to be displayed to end-\n   users and will be available to
    the administrators of the\n   authorization server.  As such, the developer may
    wish to provide an\n   email address or other contact information expressly dedicated
    to the\n   purpose of supporting the client instead of using their personal or\n
    \  professional addresses.  Alternatively, the developer may wish to\n   provide
    a collective email address for the client to allow for\n   continuing contact
    and support of the client software after the\n   developer moves on and someone
    else takes over that responsibility.\n   In general, the metadata for a client,
    such as the client name and\n   software identifier, are common across all instances
    of a piece of\n   client software and therefore pose no privacy issues for end-users.\n
    \  Client identifiers, on the other hand, are often unique to a specific\n   instance
    of a client.  For clients such as web sites that are used by\n   many users, there
    may not be significant privacy concerns regarding\n   the client identifier, but
    for clients such as native applications\n   that are installed on a single end-user's
    device, the client\n   identifier could be uniquely tracked during OAuth 2.0 transactions\n
    \  and its use tied to that single end-user.  However, as the client\n   software
    still needs to be authorized by a resource owner through an\n   OAuth 2.0 authorization
    grant, this type of tracking can occur\n   whether or not the client identifier
    is unique by correlating the\n   authenticated resource owner with the requesting
    client identifier.\n   Note that clients are forbidden by this specification from
    creating\n   their own client identifier.  If the client were able to do so, an\n
    \  individual client instance could be tracked across multiple colluding\n   authorization
    servers, leading to privacy and security issues.\n   Additionally, client identifiers
    are generally issued uniquely per\n   registration request, even for the same
    instance of software.  In\n   this way, an application could marginally improve
    privacy by\n   registering multiple times and appearing to be completely separate\n
    \  applications.  However, this technique does incur significant\n   usability
    cost in the form of requiring multiple authorizations per\n   resource owner and
    is therefore unlikely to be used in practice.\n"
  title: 6.  Privacy Considerations
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [BCP195]   Sheffer, Y., Holz, R., and P. Saint-Andre,\n
      \             \"Recommendations for Secure Use of Transport Layer\n              Security
      (TLS) and Datagram Transport Layer Security\n              (DTLS)\", BCP 195,
      RFC 7525, May 2015,\n              <http://www.rfc-editor.org/info/bcp195>.\n
      \  [IANA.Language]\n              IANA, \"Language Subtag Registry\",\n              <http://www.iana.org/assignments/\n
      \             language-subtag-registry>.\n   [RFC2119]  Bradner, S., \"Key words
      for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC
      2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA
      Considerations Section in RFCs\", BCP 26, RFC 5226,\n              DOI 10.17487/RFC5226,
      May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC5246]
      \ Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5646]
      \ Phillips, A., Ed. and M. Davis, Ed., \"Tags for Identifying\n              Languages\",
      BCP 47, RFC 5646, DOI 10.17487/RFC5646,\n              September 2009, <http://www.rfc-editor.org/info/rfc5646>.\n
      \  [RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification
      of Domain-Based Application Service Identity\n              within Internet
      Public Key Infrastructure Using X.509\n              (PKIX) Certificates in
      the Context of Transport Layer\n              Security (TLS)\", RFC 6125, DOI
      10.17487/RFC6125, March\n              2011, <http://www.rfc-editor.org/info/rfc6125>.\n
      \  [RFC6749]  Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\",\n              RFC
      6749, DOI 10.17487/RFC6749, October 2012,\n              <http://www.rfc-editor.org/info/rfc6749>.\n
      \  [RFC6750]  Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization\n              Framework:
      Bearer Token Usage\", RFC 6750,\n              DOI 10.17487/RFC6750, October
      2012,\n              <http://www.rfc-editor.org/info/rfc6750>.\n   [RFC7120]
      \ Cotton, M., \"Early IANA Allocation of Standards Track Code\n              Points\",
      BCP 100, RFC 7120, DOI 10.17487/RFC7120, January\n              2014, <http://www.rfc-editor.org/info/rfc7120>.\n
      \  [RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n
      \             Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March\n
      \             2014, <http://www.rfc-editor.org/info/rfc7159>.\n   [RFC7515]
      \ Jones, M., Bradley, J., and N. Sakimura, \"JSON Web\n              Signature
      (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May\n              2015, <http://www.rfc-editor.org/info/rfc7515>.\n
      \  [RFC7517]  Jones, M., \"JSON Web Key (JWK)\", RFC 7517,\n              DOI
      10.17487/RFC7517, May 2015,\n              <http://www.rfc-editor.org/info/rfc7517>.\n
      \  [RFC7519]  Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token\n              (JWT)\",
      RFC 7519, DOI 10.17487/RFC7519, May 2015,\n              <http://www.rfc-editor.org/info/rfc7519>.\n
      \  [RFC7522]  Campbell, B., Mortimore, C., and M. Jones, \"Security\n              Assertion
      Markup Language (SAML) 2.0 Profile for OAuth 2.0\n              Client Authentication
      and Authorization Grants\", RFC 7522,\n              DOI 10.17487/RFC7522, May
      2015,\n              <http://www.rfc-editor.org/info/rfc7522>.\n   [RFC7523]
      \ Jones, M., Campbell, B., and C. Mortimore, \"JSON Web Token\n              (JWT)
      Profile for OAuth 2.0 Client Authentication and\n              Authorization
      Grants\", RFC 7523, DOI 10.17487/RFC7523, May\n              2015, <http://www.rfc-editor.org/info/rfc7523>.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [OpenID.Discovery]\n              Sakimura,
      N., Bradley, J., Jones, M., and E. Jay, \"OpenID\n              Connect Discovery
      1.0\", November 2014,\n              <http://openid.net/specs/\n              openid-connect-discovery-1_0.html>.\n
      \  [OpenID.Registration]\n              Sakimura, N., Bradley, J., and M. Jones,
      \"OpenID Connect\n              Dynamic Client Registration 1.0\", November
      2014,\n              <http://openid.net/specs/\n              openid-connect-registration-1_0.html>.\n
      \  [RFC7592]  Richer, J., Jones, M., Bradley, J., and M. Machulak,\n              \"OAuth
      2.0 Dynamic Client Registration Management\n              Protocol\", RFC 7592,
      DOI 10.17487/RFC7592, July 2015,\n              <http://www.rfc-editor.org/info/rfc7592>.\n
      \  [UMA-Core]\n              Hardjono, T., Maler, E., Machulak, M., and D. Catalano,\n
      \             \"User-Managed Access (UMA) Profile of OAuth 2.0\", Work in\n
      \             Progress, draft-hardjono-oauth-umacore-13, April 2015.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "Appendix A.  Use Cases\n   This appendix describes different ways that this specification
    can be\n   utilized, including describing some of the choices that may need to\n
    \  be made.  Some of the choices are independent and can be used in\n   combination,
    whereas some of the choices are interrelated.\n"
  - contents:
    - 'A.1.  Open versus Protected Dynamic Client Registration

      '
    - contents:
      - "A.1.1.  Open Dynamic Client Registration\n   Authorization servers that support
        open registration allow\n   registrations to be made with no initial access
        token.  This allows\n   all client software to register with the authorization
        server.\n"
      title: A.1.1.  Open Dynamic Client Registration
    - contents:
      - "A.1.2.  Protected Dynamic Client Registration\n   Authorization servers that
        support protected registration require\n   that an initial access token be
        used when making registration\n   requests.  While the method by which a client
        or developer receives\n   this initial access token and the method by which
        the authorization\n   server validates this initial access token are out of
        scope for this\n   specification, a common approach is for the developer to
        use a manual\n   preregistration portal at the authorization server that issues
        an\n   initial access token to the developer.\n"
      title: A.1.2.  Protected Dynamic Client Registration
    title: A.1.  Open versus Protected Dynamic Client Registration
  - contents:
    - 'A.2.  Registration without or with Software Statements

      '
    - contents:
      - "A.2.1.  Registration without a Software Statement\n   When a software statement
        is not used in the registration request,\n   the authorization server must
        be willing to use client metadata\n   values without them being digitally
        signed or MACed (and thereby\n   attested to) by any authority.  (Note that
        this choice is independent\n   of the Open versus Protected choice, and that
        an initial access token\n   is another possible form of attestation.)\n"
      title: A.2.1.  Registration without a Software Statement
    - contents:
      - "A.2.2.  Registration with a Software Statement\n   A software statement can
        be used in a registration request to provide\n   attestation by an authority
        for a set of client metadata values.\n   This can be useful when the authorization
        server wants to restrict\n   registration to client software attested to by
        a set of authorities\n   or when it wants to know that multiple registration
        requests refer to\n   the same piece of client software.\n"
      title: A.2.2.  Registration with a Software Statement
    title: A.2.  Registration without or with Software Statements
  - contents:
    - 'A.3.  Registration by the Client or Developer

      '
    - contents:
      - "A.3.1.  Registration by the Client\n   In some use cases, client software
        will dynamically register itself\n   with an authorization server to obtain
        a client identifier and other\n   information needed to interact with the
        authorization server.  In\n   this case, no client identifier for the authorization
        server is\n   packaged with the client software.\n"
      title: A.3.1.  Registration by the Client
    - contents:
      - "A.3.2.  Registration by the Developer\n   In some cases, the developer (or
        development software being used by\n   the developer) will preregister the
        client software with the\n   authorization server or a set of authorization
        servers.  In this\n   case, the client identifier value(s) for the authorization
        server(s)\n   can be packaged with the client software.\n"
      title: A.3.2.  Registration by the Developer
    title: A.3.  Registration by the Client or Developer
  - contents:
    - 'A.4.  Client ID per Client Instance or per Client Software

      '
    - contents:
      - "A.4.1.  Client ID per Client Software Instance\n   In some cases, each deployed
        instance of a piece of client software\n   will dynamically register and obtain
        distinct client identifier\n   values.  This can be advantageous, for instance,
        if the code flow is\n   being used, as it also enables each client instance
        to have its own\n   client secret.  This can be useful for native clients,
        which cannot\n   maintain the secrecy of a client secret value packaged with
        the\n   software, but which may be able to maintain the secrecy of a per-\n
        \  instance client secret.\n"
      title: A.4.1.  Client ID per Client Software Instance
    - contents:
      - "A.4.2.  Client ID Shared among All Instances of Client Software\n   In some
        cases, each deployed instance of a piece of client software\n   will share
        a common client identifier value.  For instance, this is\n   often the case
        for in-browser clients using the implicit flow, when\n   no client secret
        is involved.  Particular authorization servers might\n   choose, for instance,
        to maintain a mapping between software\n   statement values and client identifier
        values, and return the same\n   client identifier value for all registration
        requests for a\n   particular piece of software.  The circumstances under
        which an\n   authorization server would do so, and the specific software statement\n
        \  characteristics required in this case, are beyond the scope of this\n   specification.\n"
      title: A.4.2.  Client ID Shared among All Instances of Client Software
    title: A.4.  Client ID per Client Instance or per Client Software
  - contents:
    - 'A.5.  Stateful or Stateless Registration

      '
    - contents:
      - "A.5.1.  Stateful Client Registration\n   In some cases, authorization servers
        will maintain state about\n   registered clients, typically indexing this
        state using the client\n   identifier value.  This state would typically include
        the client\n   metadata values associated with the client registration, and
        possibly\n   other state specific to the authorization server's implementation.\n
        \  When stateful registration is used, operations to support retrieving\n
        \  and/or updating this state may be supported.  One possible set of\n   operations
        upon stateful registrations is described in [RFC7592].\n"
      title: A.5.1.  Stateful Client Registration
    - contents:
      - "A.5.2.  Stateless Client Registration\n   In some cases, authorization servers
        will be implemented in a manner\n   the enables them to not maintain any local
        state about registered\n   clients.  One means of doing this is to encode
        all the registration\n   state in the returned client identifier value, and
        possibly\n   encrypting the state to the authorization server to maintain
        the\n   confidentiality and integrity of the state.\n"
      title: A.5.2.  Stateless Client Registration
    title: A.5.  Stateful or Stateless Registration
  title: Appendix A.  Use Cases
- contents:
  - "Acknowledgments\n   The authors thank the OAuth Working Group, the User-Managed
    Access\n   Working Group, and the OpenID Connect Working Group participants for\n
    \  their input to this document.  In particular, the following\n   individuals
    have been instrumental in their review and contribution\n   to various draft versions
    of this document: Amanda Anganes, Derek\n   Atkins, Tim Bray, Domenico Catalano,
    Donald Coffin, Vladimir\n   Dzhuvinov, George Fletcher, Thomas Hardjono, William
    Kim, Torsten\n   Lodderstedt, Eve Maler, Josh Mandel, Nov Matake, Tony Nadalin,
    Nat\n   Sakimura, Christian Scholz, and Hannes Tschofenig.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Justin Richer (editor)\n   Email: ietf@justin.richer.org\n
    \  Michael B. Jones\n   Microsoft\n   Email: mbj@microsoft.com\n   URI:   http://self-issued.info/\n
    \  John Bradley\n   Ping Identity\n   Email: ve7jtb@ve7jtb.com\n   Maciej Machulak\n
    \  Newcastle University\n   Email: maciej.machulak@gmail.com\n   Phil Hunt\n   Oracle
    Corporation\n   Email: phil.hunt@yahoo.com\n"
  title: Authors' Addresses
