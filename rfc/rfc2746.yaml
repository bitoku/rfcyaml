- contents:
  - '                     RSVP Operation Over IP Tunnels

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes an approach for providing RSVP protocol\n
    \  services over IP tunnels. We briefly describe the problem, the\n   characteristics
    of possible solutions, and the design goals of our\n   approach. We then present
    the details of an implementation which\n   meets our design goals.\n"
  title: Abstract
- contents:
  - "1.  Introduction\n   IP-in-IP \"tunnels\" have become a widespread mechanism
    to transport\n   datagrams in the Internet. Typically, a tunnel is used to route\n
    \  packets through portions of the network which do not directly\n   implement
    the desired service (e.g. IPv6), or to augment and modify\n   the behavior of
    the deployed routing architecture (e.g. multicast\n   routing, mobile IP, Virtual
    Private Net).\n   Many IP-in-IP tunneling protocols exist today.  [IP4INIP4] details
    a\n   method of tunneling using an additional IPv4 header.  [MINENC]\n   describes
    a way to reduce the size of the \"inner\" IP header used in\n   [IP4INIP4] when
    the original datagram is not fragmented.  The generic\n   tunneling method in
    [IPV6GEN] can be used to tunnel either IPv4 or\n   IPv6 packets within IPv6.  [RFC1933]
    describes how to tunnel IPv6\n   datagrams through IPv4 networks.  [RFC1701] describes
    a generic\n   routing encapsulation, while [RFC1702] applies this encapsulation
    to\n   IPv4.  Finally, [ESP] describes a mechanism that can be used to\n   tunnel
    an encrypted IP datagram.\n   From the perspective of traditional best-effort
    IP packet delivery, a\n   tunnel behaves as any other link. Packets enter one
    end of the\n   tunnel, and are delivered to the other end unless resource overload\n
    \  or error causes them to be lost.\n   The RSVP setup protocol [RFC2205] is one
    component of a framework\n   designed to extend IP to support multiple, controlled
    classes of\n   service over a wide variety of link-level technologies. To deploy\n
    \  this technology with maximum flexibility, it is desirable for tunnels\n   to
    act as RSVP-controllable links within the network.\n   A tunnel, and in fact any
    sort of link, may participate in an RSVP-\n   aware network in one of three ways,
    depending on the capabilities of\n   the equipment from which the tunnel is constructed
    and the desires of\n   the operator.\n      1. The (logical) link may not support
    resource reservation or QoS\n         control at all. This is a best-effort link.
    We refer to this as\n         a best-effort or type 1 tunnel in this note.\n      2.
    The (logical) link may be able to promise that some overall\n         level of
    resources is available to carry traffic, but not to\n         allocate resources
    specifically to individual data flows.  A\n         configured resource allocation
    over a tunnel is an example of\n         this.  We refer to this case as a type
    2 tunnel in this note.\n      3. The (logical) link may be able to make reservations
    for\n         individual end-to-end data flows.  We refer to this case as a\n
    \        type 3 tunnel. Note that the key feature that distinguishes\n         type
    3 tunnels from type 2 tunnels is that in the type 3 tunnel\n         new tunnel
    reservations are created and torn down dynamically\n         as end-to-end reservations
    come and go.\n   Type 1 tunnels exist when at least one of the routers comprising
    the\n   tunnel endpoints does not support the scheme we describe here. In\n   this
    case, the tunnel acts as a best-effort link. Our goal is simply\n   to make sure
    that RSVP messages traverse the link correctly, and the\n   presence of the non-controlled
    link is detected, as required by the\n   integrated services framework.\n   When
    the two end points of the tunnel are capable of supporting RSVP\n   over tunnels,
    we would like to have proper resources reserved along\n   the tunnel.  Depending
    on the requirements of the situation, this\n   might mean that  one client's data
    flow is placed into a larger\n   aggregate reservation  (type 2 tunnels) or that
    possibly a new,\n   separate reservation is made for the data flow (type 3 tunnels).\n
    \  Note that an RSVP reservation between the two tunnel end points does\n   not
    necessarily mean that all the intermediate routers along the\n   tunnel path support
    RSVP, this is equivalent to the case of an\n   existing end-to-end RSVP session
    transparently passing through non-\n   RSVP cloud.\n   Currently, however, RSVP
    signaling over tunnels is not possible.\n   RSVP packets entering the tunnel are
    encapsulated with an outer IP\n   header that has a protocol number other than
    46 (e.g. it is 4 for\n   IP-in-IP encapsulation) and do not carry the Router-Alert
    option,\n   making them virtually \"invisible\" to RSVP routers between the two\n
    \  tunnel endpoints.  Moreover, the current IP-in-IP encapsulation\n   scheme
    adds only an IP header as the external wrapper. It is\n   impossible to distinguish
    between packets that use reservations and\n   those that don't, or to differentiate
    packets belonging to different\n   RSVP Sessions while they are in the tunnel,
    because no distinguishing\n   information such as a UDP port is available in the
    encapsulation.\n   This document describes an IP tunneling enhancement mechanism
    that\n   allows RSVP to make  reservations across all IP-in-IP tunnels. This\n
    \  mechanism is capable of supporting both type 2 and type 3 tunnels, as\n   described
    above, and requires minimal changes to both RSVP and other\n   parts of the integrated
    services framework.\n"
  title: 1.  Introduction
- contents:
  - '2.  The Design

    '
  - contents:
    - "2.1.  Design Goals\n   Our design choices are motivated by several goals.\n
      \     * Co-existing with most, if not all, current IP-in-IP tunneling\n        schemes.\n
      \     * Limiting the changes to the RSVP spec to the minimum possible.\n      *
      Limiting the necessary changes to only the two end points of a\n        tunnel.
      \ This requirement leads to simpler deployment, lower\n        overhead in the
      intermediate routers, and less chance of failure\n        when the set of intermediate
      routers is modified due to routing\n        changes.\n      * Supporting correct
      inter-operation with RSVP routers that have\n        not been upgraded to handle
      RSVP over tunnels and with non-RSVP\n        tunnel endpoint routers. In these
      cases, the tunnel behaves as a\n        non-RSVP link.\n"
    title: 2.1.  Design Goals
  - contents:
    - "2.2.  Basic Approach\n   The basic idea of the method described in this document
      is to\n   recursively apply RSVP over the tunnel portion of the path. In this\n
      \  new session, the tunnel entry point Rentry sends PATH messages and\n   the
      tunnel exit point Rexit sends RESV messages to reserve resources\n   for the
      end-to-end sessions over the tunnel.\n   We discuss next two different aspects
      of the design: how to enhance\n   an IP-in-IP tunnel with RSVP capability, and
      how to map end-to-end\n   RSVP sessions to a tunnel session.\n"
    - contents:
      - "2.2.1.  Design Decisions\n   To establish a RSVP reservation over a unicast
        IP-in-IP tunnel, we\n   made the following design decisions:\n   One or more
        Fixed-Filter style unicast reservations between the two\n   end points of
        the tunnel will be used to reserve resources for\n   packets traversing the
        tunnel. In the type 2 case, these reservations\n   will be configured statically
        by a management interface. In the type\n   3 case, these reservations will
        be created and torn down on demand,\n   as end-to-end reservation requests
        come and go.\n   Packets that do not require reservations are encapsulated
        in the\n   normal way, e. g. being wrapped with an IP header only, specifying\n
        \  the tunnel entry point as source and the exit point as destination.\n   Data
        packets that require resource reservations within a tunnel must\n   have some
        attribute other than the IP addresses visible to the\n   intermediate routers,
        so that the routers may map the packet to an\n   appropriate reservation.
        \ To allow intermediate routers to use\n   standard RSVP filterspec handling,
        we choose to encapsulate such data\n   packets by prepending an IP and a UDP
        header, and to use UDP port\n   numbers to distinguish packets of different
        RSVP sessions. The\n   protocol number in the outer IP header in this case
        will be UDP.\n   Figure 1 shows RSVP operating over a tunnel. Rentry is the
        tunnel\n   entry router which encapsulates data into the tunnel.  Some number
        of\n   intermediate routers forward the data across the network based upon\n
        \  the encapsulating IP header added by Rentry.  Rexit is the endpoint\n   of
        the tunnel.  It decapsulates the data and forwards it based upon\n   the original,
        \"inner\" IP header.\n     ...........             ...............            .............\n
        \              :   _______   :             :   _____    :\n               :
        \ |       |  :             :  |     |   :\n     Intranet  :--| Rentry|===================|Rexit|___:Intranet\n
        \              :  |_______|  :             :  |_____|   :\n     ..........:
        \            :   Internet  :            :...........\n                             :..............\n
        \                         |___________________|\n                 Figure 1.
        \ An example IP Tunnel\n"
      title: 2.2.1.  Design Decisions
    - contents:
      - "2.2.2.  Mapping between End-to-End and Tunnel Sessions\n   Figure 2 shows
        a simple topology with a tunnel and a few hosts. The\n   sending hosts H1
        and H3 may be one or multiple IP hops away from\n   Rentry; the receiving
        hosts H2 and H4 may also be either one or\n   multiple IP hops away from Rexit.\n
        \            H1                                          H2\n             :
        \                                           :\n             :                                            :\n
        \        +--------+     +---+     +---+     +---+     +-------+\n         |
        \       |     |   |     |   |     |   |     |       |\n   H3... | Rentry |===================================|
        Rexit |.....  H4\n         |        |     |   |     |   |     |   |     |
        \      |\n         +--------+     +---+     +---+     +---+     +-------+\n
        \           Figure 2: An example end-to-end path with\n                      a
        tunnel in the middle.\n   An RSVP session may be in place between endpoints
        at hosts H1 and H2.\n   We refer to this session as the \"end-to-end\" (E2E
        for short) or\n   \"original\" session, and to its PATH and RESV messages
        as the end-to-\n   end messages.  One or more RSVP sessions may be in place
        between\n   Rentry and Rexit to provide resource reservation over the tunnel.
        We\n   refer to these as the tunnel RSVP sessions, and to their PATH and\n
        \  RESV messages as the tunnel or tunneling messages.  A tunnel RSVP\n   session
        may exist independently from any end-to-end sessions.  For\n   example through
        network management interface one may create a RSVP\n   session over the tunnel
        to provide QoS support for data flow from H3\n   to H4, although there is
        no end-to-end RSVP session between H3 and\n   H4.\n   When an end-to-end RSVP
        session crosses a RSVP-capable tunnel, there\n   are two cases to consider
        in designing mechanisms to support an end-\n   to-end reservation over the
        tunnel: mapping the E2E session to an\n   existing tunnel RSVP session (type
        2 tunnel), and dynamically\n   creating a new tunnel RSVP session for each
        end-to-end session (type\n   3 tunnel).  In either case, the picture looks
        like a recursive\n   application of RSVP.  The tunnel RSVP session views the
        two tunnel\n   endpoints as two end hosts with a unicast Fixed-Filter style\n
        \  reservation in between.  The original, end-to-end RSVP session views\n
        \  the tunnel as a single (logical) link on the path between the\n   source(s)
        and destination(s).\n   Note that in practice a tunnel may combine type 2
        and type 3\n   characteristics. Some end-to-end RSVP sessions may trigger
        the\n   creation of new tunnel sessions, while others may be mapped into an\n
        \  existing tunnel RSVP session. The choice of how an end-to-end session\n
        \  is treated at the tunnel is a matter of local policy.\n   When an end-to-end
        RSVP session crosses a RSVP-capable tunnel, it is\n   necessary to coordinate
        the actions of the two RSVP sessions, to\n   determine whether or when the
        tunnel RSVP session should be created\n   and torn down, and to correctly
        transfer error and ADSPEC information\n   between the two RSVP sessions.  We
        made the following design\n   decision:\n      * End-to-end RSVP control messages
        being forwarded through a\n        tunnel are encapsulated in the same way
        as normal IP packets,\n        e.g. being wrapped with the tunnel IP header
        only, specifying\n        the tunnel entry point as source and the exit point
        as\n        destination.\n"
      title: 2.2.2.  Mapping between End-to-End and Tunnel Sessions
    title: 2.2.  Basic Approach
  - contents:
    - "2.3.  Major Issues\n   As IP-in-IP tunnels are being used more widely for network
      traffic\n   management purposes, it is clear we must support type 2 tunnels\n
      \  (tunnel reservation for aggregate end-to-end sessions).  Furthermore,\n   these
      type 2 tunnels should allow more than one (configurable,\n   static) reservation
      to be used at once, to support different traffic\n   classes within the tunnel.
      Whether it is necessary to support type 3\n   tunnels (dynamic per end-to-end
      session tunnel reservation) is a\n   policy issue that should be left open.
      \ Our design supports both\n   cases.\n   If there is only one RSVP session
      configured over a tunnel, then all\n   the end-to-end RSVP sessions (that are
      allowed to use this tunnel\n   session) will be bound to this configured tunnel
      session.  However\n   when more than one RSVP session is in use over an IP tunnel,
      a second\n   design issue is how the association, or binding, between an original\n
      \  RSVP reservation and a tunnel reservation is created and conveyed\n   from
      one end of the tunnel to the other. The entry router Rentry and\n   the exit
      router Rexit must agree on these associations so that\n   changes in the original
      reservation state can be correctly mapped\n   into changes in the tunnel reservation
      state, and that errors\n   reported by intermediate routers to the tunnel end
      points can be\n   correctly transformed into errors reported by the tunnel endpoints
      to\n   the end-to-end RSVP session.\n   We require that this same association
      mechanism work for both the\n   case of bundled reservation over a tunnel (type
      2 tunnel), and the\n   case of one-to-one mapping between original and tunnel
      reservations\n   (type 3 tunnel). In our scheme the association is created when
      a\n   tunnel entry point first sees an end-to-end session's RESV message\n   and
      either sets up a new tunnel session, or adds to an existing\n   tunnel session.
      \ This new association must be conveyed to Rexit, so\n   that Rexit can reserve
      resources for the end-to-end sessions inside\n   the tunnel. This information
      includes the identifier and certain\n   parameters of the tunnel session, and
      the identifier of the end-to-\n   end session to which the tunnel session is
      being bound. In our\n   scheme, all RSVP sessions between the same two routers
      Rentry and\n   Rexit will have identical values for source IP address, destination\n
      \  IP address, and destination UDP port number. An individual session is\n   identified
      primarily by the source port value.\n   We identified three possible choices
      for a binding mechanism:\n      1. Define a new RSVP message that is exchanged
      only between two\n         tunnel end points to convey the binding information.\n
      \     2. Define a new RSVP object to be attached to end-to-end PATH\n         messages
      at Rentry, associating the end-to-end session with one\n         of the tunnel
      sessions. This new object is interpreted by Rexit\n         associating the
      end-to-end session with one of the tunnel\n         sessions generated at Rentry.\n
      \     3. Apply the same UDP encapsulation to the end-to-end PATH\n         messages
      as to data packets of the session.  When Rexit\n         decapsulates the PATH
      message, it deduces the relation between\n         the source UDP port used
      in the encapsulation and the RSVP\n         session that is specified in the
      original PATH message.\n   The last approach above does not require any new
      design.  However it\n   requires additional resources to be reserved for PATH
      messages (since\n   they are now subject to the tunnel reservation).  It also
      requires a\n   priori knowledge of whether Rexit supports RSVP over tunnels
      by UDP\n   encapsulation.  If Rentry encapsulates all the end-to-end PATH\n
      \  messages with the UDP encapsulation, but Rexit does not understand\n   this
      encapsulation, then the encapsulated PATH messages will be lost\n   at Rexit.\n
      \  On the other hand, options (1) and (2) can handle this case\n   transparently.
      \ They allow Rexit to pass on end-to-end PATHs received\n   via the tunnel (because
      they are decapsulated normally), while\n   throwing away the tunnel PATHs, all
      without any additional\n   configuration.  We chose Option (2) because it is
      simpler.  We\n   describe this object in the following section.\n   Packet exchanges
      must follow the following constraints:\n      1. Rentry encapsulates and sends
      end-to-end PATH messages over the\n         tunnel to Rexit where they get decapsulated
      and forwarded\n         downstream.\n      2. When a corresponding end-to-end
      RESV message arrives at Rexit,\n         Rexit encapsulates it and sends it
      to Rentry.\n      3. Based on some or all of the information in the end-to-end
      PATH\n         messages, the flowspec in the end-to-end RESV message and local\n
      \        policies, Rentry decides if and how to map the end-to-end\n         session
      to a tunnel session.\n      4. If the end-to-end session should be mapped to
      a tunnel session,\n         Rentry either sends a PATH message for a new tunnel
      session or\n         updates an existing one.\n      5. Rentry sends a E2E Path
      containing a SESSION_ASSOC object\n         associating the end-to-end session
      with the tunnel session\n         above.  Rexit records the association and
      removes the object\n         before forwarding the Path message further.\n      6.
      Rexit responds to the tunnel PATH message by sending a tunnel\n         RESV
      message, reserving resources inside the tunnel.\n      7. Rentry UDP-encapsulates
      arriving packets only if a\n         corresponding tunnel session reservation
      is actually in place\n         for the packets.\n"
    - contents:
      - "2.3.1.  SESSION_ASSOC Object\n   The new object, called SESSION_ASSOC, is
        defined with the following\n   format:\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |          length               |  class        |     c-type    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                                                               |\n    |
        \         SESSION object  (for the end-to-end session)         |\n    |                                                               |\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
        \                                                              |\n    |           Sender
        FILTER-SPEC (for the tunnel session)         |\n    |                                                               |\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                           SESSION_ASSOC
        Object\n   Length\n      This field contains the size of the SESSION_ASSOC
        object in bytes.\n   Class\n      Should be 192.\n   Ctype\n      Should be
        sent as zero and ignored on receipt.\n   SESSION object\n      The end-to-end
        SESSION contained in the object is to be mapped to\n      the tunnel session
        described by the Sender FILTER-SPEC defined\n      below.\n   Sender FILTER-SPEC\n
        \     This is the tunnel session that the above mentioned end-to-end\n      session
        maps to over the tunnel. As we mentioned above, a tunnel\n      session is
        identified primarily by source port. This is why we use\n      a Sender Filter-Spec
        for the tunnel session, in the place of a\n      SESSION object.\n"
      title: 2.3.1.  SESSION_ASSOC Object
    - contents:
      - "2.3.2.  NODE_CHAR Object\n   There has to be a way (other than through configuration)
        for Rexit to\n   communicate to Rentry the fact that it is a tunnel endpoint\n
        \  supporting the scheme described in this document. We have defined for\n
        \  this reason a new object, called NODE_CHAR, carrying this\n   information.
        If a node receives this object but does not understand\n   it, it should drop
        it without producing any error report. Objects\n   with Class-Num = 10bbbbbb
        (`b' represents a bit), as defined in the\n   RSVP specification [RFC2205],
        have the characteristics we need. While\n   for now this object only carries
        one bit of information, it can be\n   used in the future to describe other
        characteristics of an RSVP\n   capable node that are not part of the original
        RSVP specification.\n   The object NODE_CHAR has the following format:\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |          length               |  class        |     c-type    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                         Reserved                            |T|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Length\n      This field contains the size of the NODE_CHAR object in bytes.
        It\n      should be set to eight.\n   Class\n      An appropriate value should
        be assigned by the IANA. We propose\n      this value to be 128.\n   Ctype\n
        \     Should be sent as zero and ignored on receipt.\n   T bit\n      This
        bit shows that the node is a RSVP-tunnel capable node.\n   When Rexit receives
        an end-to-end reservation, it appends a NODE_CHAR\n   object with the T bit
        set, to the RESV object, it encapsulates it and\n   sends it to Rentry. When
        Rentry receives this RESV message it deduces\n   that Rexit implements the
        mechanism described here and so it creates\n   or adjusts a tunnel session
        and associates the tunnel session to the\n   end-to-end session via a SESSION_ASSOC
        object. Rentry should remove\n   the NODE_CHAR object, before forwarding the
        RESV message upstream. If\n   on the other hand, Rentry does not support the
        RSVP Tunnels mechanism\n   it would simply ignore the NODE_CHAR object and
        not forward it\n   further upstream.\n"
      title: 2.3.2.  NODE_CHAR Object
    title: 2.3.  Major Issues
  title: 2.  The Design
- contents:
  - "3.  Implementation\n   In this section we discuss several cases separately, starting
    from\n   the simplest scenario and moving to the more complex ones.\n"
  - contents:
    - "3.1.  Single Configured RSVP Session over an IP-in-IP Tunnel\n   Treating the
      two tunnel endpoints as a source and destination host,\n   one easily sets up
      a FF-style reservation in between.  Now the\n   question is what kind of filterspec
      to use for the tunnel\n   reservation, which directly relates to how packets
      get encapsulated\n   over the tunnel.  We discuss two cases below.\n"
    - contents:
      - "3.1.1.  In the Absence of End-to-End RSVP Session\n   In the case where all
        the packets traversing a tunnel use the\n   reserved resources, the current
        IP-in-IP encapsulation could be used.\n   The RSVP session over the tunnel
        would simply specify a FF style\n   reservation (with zero port number) with
        Rentry as the source address\n   and Rexit as the destination address.\n   However
        if only some of the packets traversing the tunnel should\n   benefit from
        the reservation, we must encapsulate the qualified\n   packets in IP and UDP.
        This allows intermediate routers to use\n   standard RSVP filterspec handling,
        without having to know about the\n   existence of tunnels.\n   Rather than
        supporting both cases we choose to simplify\n   implementations by requiring
        all data packets using reservations to\n   be encapsulated with an outer IP
        and UDP header. This reduces special\n   case checking and handling.\n"
      title: 3.1.1.  In the Absence of End-to-End RSVP Session
    - contents:
      - "3.1.2.  In the Presence of End-to-End RSVP Session(s)\n   According to the
        tunnel control policies, installed through some\n   management interface,
        some or all end-to-end RSVP sessions may be\n   allowed to map to the single
        RSVP session over the tunnel.  In this\n   case there is no need to provide
        dynamic binding information between\n   end-to-end sessions and the tunnel
        session, given that the tunnel\n   session is unique and pre-configured, and
        therefore well-known.\n   Binding multiple end-to-end sessions to one tunnel
        session, however,\n   raises a new question of when and how the size of the
        tunnel\n   reservation should be adjusted to accommodate the end-to-end sessions\n
        \  mapped onto it.  Again the tunnel manager makes such policy decision.\n
        \  Several scenarios are possible. In the first, the tunnel reservation\n
        \  is never adjusted. This makes the tunnel the rough equivalent of a\n   fixed-capacity
        hardware link. In the second, the tunnel reservation\n   is adjusted whenever
        a new end-to-end reservation arrives or an old\n   one is torn down. In the
        third, the tunnel reservation is adjusted\n   upwards or downwards occasionally,
        whenever the end-to-end\n   reservation level has changed enough to warrant
        the adjustment. This\n   trades off extra resource usage in the tunnel for
        reduced control\n   traffic and overhead.\n   We call a tunnel whose reservation
        cannot be adjusted a \"hard pipe\",\n   as opposed to a \"soft pipe\" where
        the amount of resources allocated\n   is adjustable. Section 5.2 explains
        how the adjustment can be carried\n   out for soft pipes.\n"
      title: 3.1.2.  In the Presence of End-to-End RSVP Session(s)
    title: 3.1.  Single Configured RSVP Session over an IP-in-IP Tunnel
  - contents:
    - "3.2.  Multiple Configured RSVP Sessions over an IP-in-IP Tunnel\n   It is straightforward
      to build on the case of a single configured\n   RSVP session over a tunnel by
      setting up multiple FF-style\n   reservations between the two tunnel endpoints
      using a management\n   interface.  In this case Rentry must carefully encapsulate
      data\n   packets with the proper UDP port numbers, so that packets belonging\n
      \  to different tunnel sessions will be distinguished by the\n   intermediate
      RSVP routers.  Note that this case and the one described\n   before describe
      what we call type 2 tunnels.\n"
    - contents:
      - "3.2.1.  In the Absence of End-to-End RSVP Session\n   Nothing more needs
        to be said in this case. Rentry classifies the\n   packets and encapsulates
        them accordingly. Packets with no\n   reservations are encapsulated with an
        outer IP header only, while\n   packets qualified for reservations are encapsulated
        with a UDP header\n   as well as an IP header. The UDP source port value should
        be properly\n   set to map to the corresponding tunnel reservation the packet
        is\n   supposed to use.\n"
      title: 3.2.1.  In the Absence of End-to-End RSVP Session
    - contents:
      - "3.2.2.  In the Presence of End-to-End RSVP Session(s)\n   Since in this case,
        there is more than one RSVP session operating\n   over the tunnel, one must
        explicitly bind each end-to-end RSVP\n   session to its corresponding tunnel
        session.  As discussed\n   previously, this binding will be provided by the
        new SESSION_ASSOC\n   object carried by the end-to-end PATH messages.\n"
      title: 3.2.2.  In the Presence of End-to-End RSVP Session(s)
    title: 3.2.  Multiple Configured RSVP Sessions over an IP-in-IP Tunnel
  - contents:
    - "3.3.  Dynamically Created Tunnel RSVP Sessions\n   This is the case of a type
      3 tunnel. The only differences between\n   this case and that of Section 4.2
      are that:\n      - The tunnel session is created when a new end-to-end session\n
      \       shows up.\n      - There is a one-to-one mapping between the end-to-end
      and tunnel\n        RSVP sessions, as opposed to possibly many-to-one mapping
      that\n        is allowed in the case described in Section 4.2.\n"
    title: 3.3.  Dynamically Created Tunnel RSVP Sessions
  title: 3.  Implementation
- contents:
  - '4.  RSVP Messages handling over an IP-in-IP Tunnel

    '
  - contents:
    - "4.1.  RSVP Messages for Configured Session(s) Over A Tunnel\n   Here one or
      more RSVP sessions are set up over a tunnel through a\n   management interface.
      \ The session reservation parameters never\n   change for a \"hard pipe\" tunnel.
      The reservation parameters may\n   change for a \"soft pipe\" tunnel. Tunnel
      session PATH messages\n   generated by Rentry are addressed to Rexit, where
      they are processed\n   and deleted.\n"
    title: 4.1.  RSVP Messages for Configured Session(s) Over A Tunnel
  - contents:
    - '4.2.  Handling of RSVP Messages at Tunnel Endpoints

      '
    - contents:
      - "4.2.1.  Handling End-to-End PATH Messages at Rentry\n   When forwarding an
        end-to-end PATH message, a router acting as the\n   tunnel entry point, Rentry,
        takes the following actions depending on\n   the end-to-end session mentioned
        in the PATH message. There are two\n   possible cases:\n      1. The end-to-end
        PATH message is a refresh of a previously known\n         end-to-end session.\n
        \     2. The end-to-end PATH message is from a new end-to-end session.\n   If
        the PATH message is a refresh of a previously known end-to-end\n   session,
        then Rentry refreshes the Path state of the end-to-end\n   session and checks
        to see if this session is mapped to a tunnel\n   session. If this is the case,
        then when Rentry refreshes the end-to-\n   end session, it includes in the
        end-to-end PATH message a\n   SESSION_ASSOC object linking this session to
        its corresponding tunnel\n   session It then encapsulates the end-to-end PATH
        message and sends it\n   over the tunnel to Rexit. If the tunnel session was
        dynamically\n   created, the end-to-end PATH message serves as a refresh for
        the\n   local tunnel state at Rentry as well as for the end-to-end session.\n
        \  Otherwise, if the PATH message is from a new end-to-end session that\n
        \  has not yet been mapped to a tunnel session, Rentry creates Path\n   state
        for this new session setting the outgoing interface to be the\n   tunnel interface.
        After that, Rentry encapsulates the PATH message\n   and sends it to Rexit
        without adding a SESSION_ASSOC message.\n   When an end-to-end PATH TEAR is
        received by Rentry, this node\n   encapsulates and forwards the message to
        Rexit. If this end-to-end\n   session has a one-to-one mapping to a tunnel
        session or if this is\n   the last one of the many end-to-end sessions mapping
        to a tunnel\n   session, Rentry tears down the tunnel session by sending a
        PATH TEAR\n   for that session to Rexit. If, on the other hand, there are
        remaining\n   end-to-end sessions mapping to the tunnel session, then Rentry
        sends\n   a tunnel PATH message adjusting the Tspec of the tunnel session.\n"
      title: 4.2.1.  Handling End-to-End PATH Messages at Rentry
    - contents:
      - "4.2.2.  Handling End-to-End PATH Messages at Rexit\n   Encapsulated end-to-end
        PATH messages are decapsulated and processed\n   at Rexit. Depending on whether
        the end-to-end PATH message contains a\n   SESSION_ASSOC object or not, Rexit
        takes the following steps:\n      1. If the end-to-end PATH message does not
        contain a SESSION_ASSOC\n         object, then Rentry sets the Non_RSVP flag
        at the Path state\n         stored for this end-to-end sender, sets the global
        break bit in\n         the ADSPEC and forwards the packets downstream. Alternatively,\n
        \        if tunnel sessions exist and none of them has the Non_RSVP flag\n
        \        set, Rexit can pick the worst-case Path ADSPEC params from the\n
        \        existing tunnel sessions and update the end-to-end ADSPEC using\n
        \        these values. This is a conservative estimation of the composed\n
        \        ADSPEC but it has the benefit of avoiding to set the break bit\n
        \        in the end-to-end ADSPEC before mapping information is\n         available.
        In this case the Non_RSVP flag at the end-to-end\n         Path state is not
        set.\n      2. If the PATH message contains a SESSION_ASSOC object and no\n
        \        association for this end-to-end session already exists, then\n         Rexit
        records the association between the end-to-end session\n         and the tunnel
        session described by the object. If the end-to-\n         end PATH arrives
        early before the tunnel PATH message arrives\n         then it creates PATH
        state at Rexit for the tunnel session.\n         When the actual PATH message
        for the tunnel session arrives it\n         is treated as an update of the
        existing PATH state and it\n         updates any information missing. We believe
        that this situation\n         is another transient along with the others existing
        in RSVP and\n         that it does not have any long-term effects on the correct\n
        \        operation of the mechanism described here.\n         Before further
        forwarding the message to the next hop along the\n         path to the destination,
        Rexit finds the corresponding tunnel\n         session's recorded state and
        turns on Non_RSVP flag in the\n         end-to-end Path state if the Non_RSVP
        bit was turned on for the\n         tunnel session.  If the end-to-end PATH
        message carries an\n         ADSPEC object, Rexit performs composition of
        the\n         characterization parameters contained in the ADSPEC. It does\n
        \        this by considering the tunnel session's overall (composed)\n         characterization
        parameters as the local parameters for the\n         logical link implemented
        by the tunnel, and composing these\n         parameters with those in the
        end-to-end ADSPEC by executing\n         each parameter's defined composition
        function. In the logical\n         link's characterization parameters, the
        minimum path latency\n         may take into account the encapsulation/decapsulation
        delay and\n         the bandwidth estimate can represent the decrease in available\n
        \        bandwidth caused by the addition of the extra UDP header.\n         ADSPECs
        and composition functions are discussed in great detail\n         in [RFC2210].\n
        \        If the end-to-end session has reservation state, while no\n         reservation
        state for the matching tunnel session exists, Rexit\n         send a tunnel
        RESV message to Rentry matching the reservation\n         in the end-to-end
        session.\n   If Rentry does not support RSVP tunneling, then Rexit will have
        no\n   PATH state for the tunnel. In this case Rexit simply turns on the\n
        \  global break bit in the decapsulated end-to-end PATH message and\n   forwards
        it.\n"
      title: 4.2.2.  Handling End-to-End PATH Messages at Rexit
    - contents:
      - "4.2.3.  Handling End-to-End RESV Messages at Rexit\n   When forwarding a
        RESV message upstream, a router serving as the exit\n   router, Rexit, may
        discover that one of the upstream interfaces is a\n   tunnel.  In this case
        the router performs a number of tests.\n   Step 1: Rexit must determine if
        there is a tunnel session bound to\n   the end-to-end session given in the
        RESV message.  If not, the tunnel\n   is treated as a non-RSVP link, Rexit
        appends a NODE_CHAR object with\n   the T bit set, to the RESV message and
        forwards it over the tunnel\n   interface (where it is encapsulated as a normal
        IP datagram and\n   forwarded towards Rentry).\n   Step 2: If a bound tunnel
        session is found, Rexit checks to see if a\n   reservation is already in place
        for the tunnel session bound to the\n   end-to-end session given in the RESV
        message. If the arriving end-\n   to-end RESV message is a refresh of existing
        RESV state, then Rexit\n   sends the original RESV through tunnel interface
        (after adding the\n   NODE_CHAR object). For dynamic tunnel sessions, the
        end-to-end RESV\n   message acts as a refresh for the tunnel session reservation
        state,\n   while for configured tunnel sessions, reservation state never\n
        \  expires.\n   If the arriving end-to-end RESV message causes a change in
        the end-\n   to-end RESV flowspec parameters, it may also trigger an attempt
        to\n   change the tunnel session's flowspec parameters.  In this case Rexit\n
        \  sends a tunnel session RESV, including a RESV_CONFIRM object.\n   In the
        case of a \"hard pipe\" tunnel, a new end-to-end reservation or\n   change
        in the level of resources requested by an existing reservation\n   may cause
        the total resource level needed by the end-to-end\n   reservations to exceed
        the level of resources reserved by the tunnel\n   reservation. This event
        should be treated as an admission control\n   failure, identically to the
        case where RSVP requests exceed the level\n   of resources available over
        a hardware link. A RESV_ERR message with\n   Error Code set to 01 (Admission
        Control failure), should be sent back\n   to the originator of the end-to-end
        RESV message.\n   If a RESV CONFIRM response arrives, the original RESV is
        encapsulated\n   and sent through the tunnel. If the updated tunnel reservation
        fails,\n   Rexit must send a RESV ERR to the originator of the end-to-end
        RESV\n   message, using the error code and value fields from the ERROR_SPEC\n
        \  object of the received tunnel session RESV ERR message. Note that the\n
        \  pre-existing reservations through the tunnel stay in place. Rexit\n   continues
        refreshing the tunnel RESV using the old flowspec.\n   Tunnel session state
        for a \"soft pipe\" may also be adjusted when an\n   end-to-end reservation
        is deleted.  The tunnel session gets reduced\n   whenever one of the end-to-end
        sessions using the tunnel goes away\n   (or gets reduced itself). However
        even when the last end-to-end\n   session bound to that tunnel goes away,
        the configured tunnel session\n   remains active, perhaps with a configured
        minimal flowspec.\n   Note that it will often be appropriate to use some hysteresis
        in the\n   adjustment of the tunnel reservation parameters, rather than\n
        \  adjusting the tunnel reservation up and down with each arriving or\n   departing
        end-to-end reservation.  Doing this will require the tunnel\n   exit router
        to keep track of the resources allocated to the tunnel\n   (the tunnel flowspec)
        and the resources actually in use by end-to-end\n   reservations (the sum
        or statistical sum of the end-to-end\n   reservation flowspecs) separately.\n
        \  When an end-to-end RESV TEAR is received by Rexit, it encapsulates\n   and
        forwards the message to Rentry. If the end-to-end session had\n   created
        a dynamic tunnel session, then a RESV TEAR for the\n   corresponding tunnel
        session is send by Rexit.\n"
      title: 4.2.3.  Handling End-to-End RESV Messages at Rexit
    - contents:
      - "4.2.4.  Handling of End-to-End RESV Messages at Rentry.\n   If the RESV message
        received is a refresh of an existing reservation\n   then Rentry updates the
        reservation state and forwards the message\n   upstream. On the other hand,
        if this is the first RESV message for\n   this end-to-end session and a NODE_CHAR
        object with the T bit set is\n   present, Rentry should initiate the mapping
        between this end-to-end\n   session and some (possibly new) tunnel session.
        This mapping is based\n   on some or all of the contents of the end-to-end
        PATH message, the\n   contents of the end-to-end RESV message, and local policies.
        For\n   example, there could be different tunnel sessions based on the\n   bandwidth
        or delay requirements of end-to-end sessions)\n   If Rentry decides that this
        end-to-end session should be mapped to an\n   existing configured tunnel session,
        it binds this end-to-end session\n   to that tunnel session.\n   If this end-to-end
        RSVP session is allowed to set up a new tunnel\n   session, Rentry sets up
        tunnel session PATH state as if it were a\n   source of data by starting to
        send tunnel-session PATH messages to\n   Rexit, which is treated as the unicast
        destination of the data. The\n   Tspec in this new PATH message is computed
        from the original PATH\n   message by adjusting the Tspec parameters to include
        the tunnel\n   overhead of the encapsulation of data packets. In this case
        Rentry\n   should also send a PATH message from the end-to-end session this
        time\n   containing the SESSION_ASSOC object linking the two sessions. The\n
        \  receipt of this PATH message by Rexit will trigger an update of the\n   end-to-end
        Path state which in turn will have the effect of Rexit\n   sending a tunnel
        RESV message, allocating resources inside the\n   tunnel.\n   The last case
        is when the end-to-end session is not allowed to use\n   the tunnel resources.
        In this case no association is created between\n   this end-to-end session
        and a tunnel session and no new tunnel\n   session is created.\n   One limitation
        of our scheme is that the first RESV message of an\n   end-to-end session
        determines the mapping between that end-to-end\n   session and its corresponding
        session over the tunnel. Moreover as\n   long as the reservation is active
        this mapping cannot change.\n"
      title: 4.2.4.  Handling of End-to-End RESV Messages at Rentry.
    title: 4.2.  Handling of RSVP Messages at Tunnel Endpoints
  title: 4.  RSVP Messages handling over an IP-in-IP Tunnel
- contents:
  - "5.  Forwarding Data\n   When data packets arrive at the tunnel entry point Rentry,
    Rentry\n   must decide whether to forward the packets using the normal IP-in-IP\n
    \  tunnel encapsulation or the IP+UDP encapsulation expected by the\n   tunnel
    session.  This decision is made by determining whether there\n   is a resource
    reservation (not just PATH state) actually in place for\n   the tunnel session
    bound to the arriving packet, that is, whether the\n   packet matches any active
    filterspec.\n   If a reservation is in place, it means that both Rentry and Rexit
    are\n   RSVP-tunneling aware routers, and the data will be correctly\n   decapsulated
    at Rexit.\n   If no tunnel session reservation is in place, the data should be\n
    \  encapsulated in the tunnel's normal format, regardless of whether\n   end-to-end
    PATH state covering the data is present.\n"
  title: 5.  Forwarding Data
- contents:
  - '6.  Details

    '
  - contents:
    - "6.1.  Selecting UDP port numbers\n   There may be multiple end-to-end RSVP
      sessions between the two end\n   points Rentry and Rexit. These sessions are
      distinguished by the\n   source UDP port. Other components of the session ID,
      the source and\n   destination IP addresses and the destination UDP port, are
      identical\n   for all such sessions.\n   The source UDP port is chosen by the
      tunnel entry point Rentry when\n   it establishes the initial PATH state for
      a new tunnel session. The\n   source UDP port associated with the new session
      is then conveyed to\n   Rexit by the SESSION_ASSOC object.\n   The destination
      UDP port used in tunnel sessions should the one\n   assigned by IANA (363).\n"
    title: 6.1.  Selecting UDP port numbers
  - contents:
    - "6.2.  Error Reporting\n   When a tunnel session PATH message encounters an
      error, it is\n   reported back to Rentry. Rentry must relay the error report
      back to\n   the original source of the end-to-end session.\n   When a tunnel
      session RESV request fails, an error message is\n   returned to Rexit. Rexit
      must treat this as an error in crossing the\n   logical link (the tunnel) and
      forward the error message back to the\n   end host.\n"
    title: 6.2.  Error Reporting
  - contents:
    - "6.3.  MTU Discovery\n   Since the UDP encapsulated packets should not be fragmented,
      tunnel\n   entry routers must support tunnel MTU discovery as discussed in\n
      \  section 5.1 of [IP4INIP4]. Alternatively, the Path MTU Discovery\n   mechanism
      discussed in RFC 2210 [RFC2210] can be used.\n"
    title: 6.3.  MTU Discovery
  - contents:
    - "6.4.  Tspec and Flowspec Calculations\n   As multiple End-to-End sessions can
      be mapped to a single tunnel\n   session, there is the need to compute the aggregate
      Tspec of all the\n   senders of those End-to-End sessions. This aggregate Tspec
      will the\n   Tspec of the representative tunnel session. The same operation
      needs\n   to be performed for flowspecs of End-to-End reservations arriving
      at\n   Rexit.\n   The semantics of these operations are not addressed here.
      \ The\n   simplest way to do them is to compute a sum of the end-to-end Tspecs,\n
      \  as is defined in the specifications of the Controlled-Load and\n   Guaranteed
      services (found at [RFC2211] and [RFC2212] respectively).\n   However, it may
      also be appropriate to compute the aggregate\n   reservation level for the tunnel
      using a more sophisticated\n   statistical or measurement-based computation.\n"
    title: 6.4.  Tspec and Flowspec Calculations
  title: 6.  Details
- contents:
  - "7.  IPSEC Tunnels\n   In the case where the IP-in-IP tunnel supports IPSEC (especially
    ESP\n   in Tunnel-Mode with or without AH) then the Tunnel Session uses the\n
    \  GPI SESSION and GPI SENDER_TEMPLATE/FILTER_SPEC as defined in\n   [RSVPESP]
    for the PATH and RESV messages.\n   Data packets are not encapsulated with a UDP
    header since the SPI can\n   be used by the intermediate nodes for classification
    purposes.\n   Notice that user oriented keying must be used between Rentry and\n
    \  Rexit, so that different SPIs are assigned to data packets that have\n   reservation
    and \"best effort\" packets, as well as packets that belong\n   to different Tunnel
    Sessions if those are supported.\n"
  title: 7.  IPSEC Tunnels
- contents:
  - "8.  RSVP Support for Multicast and Multipoint Tunnels\n   The mechanisms described
    above are useful for unicast tunnels.\n   Unicast tunnels provide logical point-to-point
    links in the IP\n   infrastructure, though they may encapsulate and carry either
    unicast\n   or multicast traffic between those points.\n   Two other types of
    tunnels may be imagined.  The first of these is a\n   \"multicast\" tunnel.  In
    this type of tunnel, packets arriving at an\n   entry point are encapsulated and
    transported (multicast) to -all- of\n   the exit points.  This sort of tunnel
    might prove useful for\n   implementing a hierarchical multicast distribution
    network, or for\n   emulating efficiently some portion of a native multicast distribution\n
    \  tree.\n   A second possible type of tunnel is the \"multipoint\" tunnel. In
    this\n   type of tunnel, packets arriving at an entry point are normally\n   encapsulated
    and transported to -one- of the exit points, according\n   to some route selection
    algorithm.\n   This type of tunnel differs from all previous types in that the
    '\n   shape' of the usual data distribution path does not match the 'shape'\n
    \  of the tunnel.  The topology of the tunnel does not by itself define\n   the
    data transmission function that the tunnel performs.  Instead,\n   the tunnel
    becomes a way to express some shared property of the set\n   of connected tunnel
    endpoints.  For example, the \"tunnel\" may be used\n   to create and embed a
    logical shared broadcast network within some\n   larger network.  In this case
    the tunnel endpoints are the nodes\n   connected to the logical shared broadcast
    network.  Data traffic may\n   be unicast between two such nodes, broadcast to
    all connected nodes,\n   or multicast between some subset of the connected nodes.
    \ The tunnel\n   itself is used to define a domain in which to manage routing
    and\n   resource management - essentially a virtual private network.\n   Note
    that while a VPN of this form can always be implemented using a\n   multicast
    tunnel to emulate the broadcast medium, this approach will\n   be very inefficient
    in the case of wide area VPNs, and a multipoint\n   tunnel with appropriate control
    mechanisms will be preferable.\n   The following paragraphs provide some brief
    commentary on the use of\n   RSVP in these situations. Future versions of this
    note will provide\n   more concrete details and specifications.\n   Using RSVP
    to provide resource management over a multicast tunnel is\n   relatively straightforward.
    As in the unicast case, one or more RSVP\n   sessions may be used, and end-to-end
    RSVP sessions may be mapped onto\n   tunnel RSVP sessions on a many-to-one or
    one-to-one basis. Unlike the\n   unicast, case, however, the mapping is complicated
    by RSVP's\n   heterogeneity semantics. If different receivers have made different\n
    \  reservation requests, it may be that the RESV messages arriving at\n   the
    tunnel would logically map the receiver's requests to different\n   tunnel sessions.
    Since the data can actually be placed into only one\n   session, the choice of
    session must be reconciled (merged) to select\n   the one that will meet the needs
    of all applications. This requires a\n   relatively simple extension to the session
    mapping mechanism.\n   Use of RSVP to support multipoint tunnels is somewhat more
    difficult.\n   In this case, the goal is to give the tunnel as a whole a specific\n
    \  level of resources. For example, we may wish to emulate a \"logical\n   shared
    10 megabit Ethernet\" rather than a \"logical shared Ethernet\".\n   However,
    the problem is complicated by the fact that in this type of\n   tunnel the data
    does not always go to all tunnel endpoints. This\n   implies that we cannot use
    the destination address of the\n   encapsulated packets as part of the packet
    classification filter,\n   because the destination address will vary for different
    packets\n   within the tunnel.\n   This implies the need for an extension to current
    RSVP session\n   semantics in which the Session ID (destination IP address) is
    used\n   -only- to identify the session state within network nodes, but is not\n
    \  used to classify packets.  Other than this, the use of RSVP for\n   multipoint
    tunnels follows that of multicast tunnels. A multicast\n   group is created to
    represent the set of nodes that are tunnel\n   endpoints, and one or more tunnel
    RSVP sessions are created to\n   reserve resources for the encapsulated packets.
    In the case of a\n   tunnel implementing a simple VPN, it is most likely that
    there will\n   be one session to reserve resources for the whole VPN. Each tunnel\n
    \  endpoint will participate both as a source of PATH messages and a\n   source
    of (FF or SE) RESV messages for this single session,\n   effectively creating
    a single shared reservation for the entire\n   logical shared medium. Tunnel endpoints
    MUST NOT make wildcard\n   reservations over multipoint tunnels.\n"
  title: 8.  RSVP Support for Multicast and Multipoint Tunnels
- contents:
  - "9.  Extensions to the RSVP/Routing Interface\n   The RSVP specification [RFC2205]
    states that through the RSVP/Routing\n   Interface, the RSVP daemon must be able
    to learn the list of local\n   interfaces along with their IP addresses. In the
    RSVP Tunnels case,\n   the RSVP daemon needs also to learn which of the local
    interface(s)\n   is (are) IP-in-IP tunnel(s) having the capabilities described
    here.\n   The RSVP daemon can acquire this information, either by directly\n   querying
    the underlying network and physical layers or by using any\n   existing interface
    between RSVP and the routing protocol properly\n   extended to provide this information.\n"
  title: 9.  Extensions to the RSVP/Routing Interface
- contents:
  - "10.  Security Considerations\n   The introduction of RSVP Tunnels raises no new
    security issues other\n   than those associated with the use of RSVP and tunnels.
    Regarding\n   RSVP, the major issue is the need to control and authenticate access\n
    \  to enhanced qualities of service. This requirement is discussed\n   further
    in [RFC2205]. [RSVPCRYPTO] describes the mechanism used to\n   protect the integrity
    of RSVP messages carrying the information\n   described here.  The security issues
    associated with IP-in-IP tunnels\n   are discussed in [IPINIP4] and [IPV6GEN].\n"
  title: 10.  Security Considerations
- contents:
  - "11.  IANA Considerations\n   IANA should assign a Class number for the NODE_CHAR
    object defined in\n   Section 3.3.2. This number should be in the 10bbbbbb range.
    The\n   suggested value is 128.\n"
  title: 11.  IANA Considerations
- contents:
  - "12.  Acknowledgments\n   We thank Bob Braden for his insightful comments that
    helped us to\n   produce this updated version of the document.\n"
  title: 12.  Acknowledgments
- contents:
  - "13.  References\n   [ESP]        Atkinson, R., \"IP Encapsulating Security Payload
    (ESP)\",\n                RFC 1827, August 1995.\n   [IP4INIP4]   Perkins, C.,
    \"IP Encapsulation within IP\", RFC 2003,\n                October 1996.\n   [IPV6GEN]
    \   Conta, A. and S. Deering, \"Generic Packet Tunneling in\n                IPv6
    Specification\", RFC 2473, December 1998.\n   [MINENC]     Perkins, C., \"Minimal
    Encapsulation within IP\", RFC\n                2004, October 1996.\n   [RFC1701]
    \   Hanks, S., Li, T., Farinacci, D. and P. Traina, \"Generic\n                Routing
    Encapsulation (GRE)\", RFC 1701, October 1994.\n   [RFC1702]    Hanks, S., Li,
    T., Farinacci, D. and P. Traina, \"Generic\n                Routing Encapsulation
    over IPv4 Networks\", RFC 1702,\n                October 1994.\n   [RFC1933]    Gilligan,
    R. and E. Nordmark, \"Transition Mechanisms for\n                IPv6 Hosts and
    Routers\", RFC 1933, April 1996.\n   [RFC2210]    Wroclawski, J., \"The Use of
    RSVP with IETF Integrated\n                Services\", RFC 2210, September 1997.\n
    \  [RFC2211]    Wroclawski, J., \"Specification of the Controlled-Load\n                Network
    Element Service\", RFC 2211, September 1997.\n   [RFC2212]    Shenker, S., Partridge,
    C. and R. Guerin, \"Specification\n                of the Guaranteed Quality of
    Service\", RFC 2212,\n                September 1997.\n   [RFC2205]    Braden,
    R., Zhang, L., Berson, S., Herzog, S. and S.\n                Jamin, \"Resource
    ReSerVation Protocol (RSVP) -- Version\n                1 Functional Specification\",
    RFC 2205, September 1997.\n   [RSVPESP]    Berger, L. and T. O'Malley, \"RSVP
    Extensions for IPSEC\n                Data Flows\", RFC 2207, September 1997.\n
    \  [RSVPCRYPTO] Baker, F., Lindell, B. and M. Talwar, \"RSVP\n                Cryptographic
    Authentication\", RFC 2747, January 2000.\n"
  title: 13.  References
- contents:
  - "14.  Authors' Addresses\n   John Krawczyk\n   ArrowPoint Communications\n   50
    Nagog Park\n   Acton, MA 01720\n   Phone: 978-206-3027\n   EMail:  jj@arrowpoint.com\n
    \  John Wroclawski\n   MIT Laboratory for Computer Science\n   545 Technology
    Sq.\n   Cambridge, MA  02139\n   Phone: 617-253-7885\n   Fax:   617-253-2673\n
    \  EMail: jtw@lcs.mit.edu\n   Lixia Zhang\n   UCLA\n   4531G Boelter Hall\n   Los
    Angeles, CA  90095\n   Phone: 310-825-2695\n   EMail: lixia@cs.ucla.edu\n   Andreas
    Terzis\n   UCLA\n   4677 Boelter Hall\n   Los Angeles, CA 90095\n   Phone: 310-267-2190\n
    \  EMail: terzis@cs.ucla.edu\n"
  title: 14.  Authors' Addresses
- contents:
  - "15.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 15.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
