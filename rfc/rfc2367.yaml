- title: __initial_text__
  contents:
  - '                  PF_KEY Key Management API, Version 2

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   A generic key management API that can be used not only for IP\n\
    \   Security [Atk95a] [Atk95b] [Atk95c] but also for other network\n   security\
    \ services is presented in this document.  Version 1 of this\n   API was implemented\
    \ inside 4.4-Lite BSD as part of the U. S. Naval\n   Research Laboratory's freely\
    \ distributable and usable IPv6 and IPsec\n   implementation[AMPMC96].  It is\
    \ documented here for the benefit of\n   others who might also adopt and use the\
    \ API, thus providing increased\n   portability of key management applications\
    \ (e.g. a manual keying\n   application, an ISAKMP daemon, a GKMP daemon [HM97a][HM97b],\
    \ a\n   Photuris daemon, or a SKIP certificate discovery protocol daemon).\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1      Introduction .............................................\
    \  3\n   1.1    Terminology ..............................................  3\n\
    \   1.2    Conceptual Model .........................................  4\n   1.3\
    \    PF_KEY Socket Definition .................................  8\n   1.4   \
    \ Overview of PF_KEY Messaging Behavior ....................  8\n   1.5    Common\
    \ PF_KEY Operations .................................  9\n   1.6    Differences\
    \ Between PF_KEY and PF_ROUTE .................. 10\n   1.7    Name Space ...............................................\
    \ 11\n   1.8    On Manual Keying ..........................................11\n\
    \   2      PF_KEY Message Format .................................... 11\n   2.1\
    \    Base Message Header Format ............................... 12\n   2.2   \
    \ Alignment of Headers and Extension Headers ............... 14\n   2.3    Additional\
    \ Message Fields ................................ 14\n   2.3.1  Association Extension\
    \ .................................... 15\n   2.3.2  Lifetime Extension .......................................\
    \ 16\n   2.3.3  Address Extension ........................................ 18\n\
    \   2.3.4  Key Extension ............................................ 19\n   2.3.5\
    \  Identity Extension ....................................... 21\n   2.3.6  Sensitivity\
    \ Extension .................................... 21\n   2.3.7  Proposal Extension\
    \ ....................................... 22\n   2.3.8  Supported Algorithms Extension\
    \ ........................... 25\n   2.3.9  SPI Range Extension ......................................\
    \ 26\n   2.4    Illustration of Message Layout ........................... 27\n\
    \   3      Symbolic Names ........................................... 30\n   3.1\
    \    Message Types ............................................ 31\n   3.1.1 \
    \ SADB_GETSPI .............................................. 32\n   3.1.2  SADB_UPDATE\
    \ .............................................. 33\n   3.1.3  SADB_ADD .................................................\
    \ 34\n   3.1.4  SADB_DELETE .............................................. 35\n\
    \   3.1.5  SADB_GET ................................................. 36\n   3.1.6\
    \  SADB_ACQUIRE ............................................. 36\n   3.1.7  SADB_REGISTER\
    \ ............................................ 38\n   3.1.8  SADB_EXPIRE ..............................................\
    \ 39\n   3.1.9  SADB_FLUSH ............................................... 40\n\
    \   3.1.10 SADB_DUMP ................................................ 40\n   3.2\
    \    Security Association Flags ............................... 41\n   3.3   \
    \ Security Association States .............................. 41\n   3.4    Security\
    \ Association Types ............................... 41\n   3.5    Algorithm Types\
    \ .......................................... 42\n   3.6    Extension Header Values\
    \ .................................. 43\n   3.7    Identity Extension Values ................................\
    \ 44\n   3.8    Sensitivity Extension Values ............................. 45\n\
    \   3.9    Proposal Extension Values ................................ 45\n   4\
    \      Future Directions ........................................ 45\n   5   \
    \   Examples ................................................. 45\n   5.1    Simple\
    \ IP Security Example ............................... 46\n   5.2    Proxy IP Security\
    \ Example ................................ 47\n   5.3    OSPF Security Example\
    \ .................................... 50\n   5.4    Miscellaneous ............................................\
    \ 50\n   6      Security Considerations .................................. 51\n\
    \          Acknowledgments ............,............................. 52\n   \
    \       References ............................................... 52\n      \
    \    Disclaimer ............................................... 54\n         \
    \ Authors' Addresses ....................................... 54\n   A      Promiscuous\
    \ Send/Receive Extension ....................... 55\n   B      Passive Change\
    \ Message Extension ......................... 57\n   C      Key Management Private\
    \ Data Extension .................... 58\n   D      Sample Header File .......................................\
    \ 59\n   E      Change Log ............................................... 64\n\
    \   F      Full Copyright Statement ................................. 68\n"
- title: 1 Introduction
  contents:
  - "1 Introduction\n   PF_KEY is a new socket protocol family used by trusted privileged\
    \ key\n   management applications to communicate with an operating system's key\n\
    \   management internals (referred to here as the \"Key Engine\" or the\n   Security\
    \ Association Database (SADB)).  The Key Engine and its\n   structures incorporate\
    \ the required security attributes for a session\n   and are instances of the\
    \ \"Security Association\" (SA) concept\n   described in [Atk95a].  The names\
    \ PF_KEY and Key Engine thus refer to\n   more than cryptographic keys and are\
    \ retained for consistency with\n   the traditional phrase, \"Key Management\"\
    .\n   PF_KEY is derived in part from the BSD routing socket, PF_ROUTE.\n   [Skl91]\
    \ This document describes Version 2 of PF_KEY. Version 1 was\n   implemented in\
    \ the first five alpha test versions of the NRL\n   IPv6+IPsec Software Distribution\
    \ for 4.4-Lite BSD UNIX and the Cisco\n   ISAKMP/Oakley key management daemon.\
    \  Version 2 extends and refines\n   this interface. Theoretically, the messages\
    \ defined in this document\n   could be used in a non-socket context (e.g.  between\
    \ two directly\n   communicating user-level processes), but this document will\
    \ not\n   discuss in detail such possibilities.\n   Security policy is deliberately\
    \ omitted from this interface. PF_KEY\n   is not a mechanism for tuning systemwide\
    \ security policy, nor is it\n   intended to enforce any sort of key management\
    \ policy. The developers\n   of PF_KEY believe that it is important to separate\
    \ security\n   mechanisms (such as PF_KEY) from security policies.  This permits\
    \ a\n   single mechanism to more easily support multiple policies.\n"
- title: 1.1 Terminology
  contents:
  - "1.1 Terminology\n   Even though this document is not intended to be an actual\
    \ Internet\n   standard, the words that are used to define the significance of\n\
    \   particular features of this interface are usually capitalized.  Some\n   of\
    \ these words, including MUST, MAY, and SHOULD, are detailed in\n   [Bra97].\n\
    \   - CONFORMANCE and COMPLIANCE\n   Conformance to this specification has the\
    \ same meaning as compliance\n   to this specification.  In either case, the mandatory-to-implement,\n\
    \   or MUST, items MUST be fully implemented as specified here.  If any\n   mandatory\
    \ item is not implemented as specified here, that\n   implementation is not conforming\
    \ and not compliant with this\n   specification.\n   This specification also uses\
    \ many terms that are commonly used in the\n   context of network security.  Other\
    \ documents provide more\n   definitions and background information on these [VK83,\
    \ HA94, Atk95a].\n   Two terms deserve special mention:\n   - (Encryption/Authentication)\
    \ Algorithm\n   For PF_KEY purposes, an algorithm, whether encryption or\n   authentication,\
    \ is the set of operations performed on a packet to\n   complete authentication\
    \ or encryption as indicated by the SA type.  A\n   PF_KEY algorithm MAY consist\
    \ of more than one cryptographic\n   algorithm. Another possibility is that the\
    \ same basic cryptographic\n   algorithm may be applied with different modes of\
    \ operation or some\n   other implementation difference. These differences, henceforth\
    \ called\n   _algorithm differentiators_, distinguish between different PF_KEY\n\
    \   algorithms, and options to the same algorithm.  Algorithm\n   differentiators\
    \ will often cause fundamentally different security\n   properties.\n   For example,\
    \ both DES and 3DES use the same cryptographic algorithm,\n   but they are used\
    \ differently and have different security properties.\n   The triple-application\
    \ of DES is considered an algorithm\n   differentiator.  There are therefore separate\
    \ PF_KEY algorithms for\n   DES and 3DES. Keyed-MD5 and HMAC-MD5 use the same\
    \ hash function, but\n   construct their message authentication codes differently.\
    \ The use of\n   HMAC is an algorithm differentiator.  DES-ECB and DES-CBC are\
    \ the\n   same cryptographic algorithm, but use a different mode. Mode (e.g.,\n\
    \   chaining vs. code-book) is an algorithm differentiator. Blowfish with\n  \
    \ a 128-bit key, however, is similar to Blowfish with a 384-bit key,\n   because\
    \ the algorithm's workings are otherwise the same and therefore\n   the key length\
    \ is not an algorithm differentiator.\n   In terms of IP Security, a general rule\
    \ of thumb is that whatever\n   might be labeled the \"encryption\" part of an\
    \ ESP transform is\n   probably a PF_KEY encryption algorithm. Whatever might\
    \ be labelled\n   the \"authentication\" part of an AH or ESP transform is probably\
    \ a\n   PF_KEY authentication algorithm.\n"
- title: 1.2 Conceptual Model
  contents:
  - "1.2 Conceptual Model\n   This section describes the conceptual model of an operating\
    \ system\n   that implements the PF_KEY key management application programming\n\
    \   interface. This section is intended to provide background material\n   useful\
    \ to understand the rest of this document.  Presentation of this\n   conceptual\
    \ model does not constrain a PF_KEY implementation to\n   strictly adhere to the\
    \ conceptual components discussed in this\n   subsection.\n   Key management is\
    \ most commonly implemented in whole or in part at\n   the application layer.\
    \  For example, the ISAKMP/Oakley, GKMP, and\n   Photuris proposals for IPsec\
    \ key management are all application-layer\n   protocols.  Manual keying is also\
    \ done at the application layer.\n   Even parts of the SKIP IP-layer keying proposal\
    \ can be implemented at\n   the application layer.  Figure 1 shows the relationship\
    \ between a Key\n   Management daemon and PF_KEY.  Key management daemons use\
    \ PF_KEY to\n   communicate with the Key Engine and use PF_INET (or PF_INET6 in\
    \ the\n   case of IPv6) to communicate, via the network, with a remote key\n \
    \  management entity.\n   The \"Key Engine\" or \"Security Association Database\
    \ (SADB)\" is a\n   logical entity in the kernel that stores, updates, and deletes\n\
    \   Security Association data for various security protocols.  There are\n   logical\
    \ interfaces within the kernel (e.g.  getassocbyspi(),\n   getassocbysocket())\
    \ that security protocols inside the kernel (e.g.\n   IP Security, aka IPsec)\
    \ use to request and obtain Security\n   Associations.\n   In the case of IPsec,\
    \ if by policy a particular outbound packet needs\n   processing, then the IPsec\
    \ implementation requests an appropriate\n   Security Association from the Key\
    \ Engine via the kernel-internal\n   interface.  If the Key Engine has an appropriate\
    \ SA, it allocates the\n   SA to this session (marking it as used) and returns\
    \ the SA to the\n   IPsec implementation for use.  If the Key Engine has no such\
    \ SA but a\n   key management application has previously indicated (via a PF_KEY\n\
    \   SADB_REGISTER message) that it can obtain such SAs, then the Key\n   Engine\
    \ requests that such an SA be created (via a PF_KEY SADB_ACQUIRE\n   message).\
    \  When the key management daemon creates a new SA, it places\n   it into the\
    \ Key Engine for future use.\n                     +---------------+\n       \
    \              |Key Mgmt Daemon|\n                     +---------------+\n   \
    \                    |           |\n                       |           |\n   \
    \                    |           |                   Applications\n          \
    \     ======[PF_KEY]====[PF_INET]==========================\n                \
    \       |           |                   OS Kernel\n               +------------+\
    \   +-----------------+\n               | Key Engine |   | TCP/IP,         |\n\
    \               |  or  SADB  |---| including IPsec |\n               +------------+\
    \   |                 |\n                                +-----------------+\n\
    \                                       |\n                                  \
    \ +-----------+\n                                   | Network   |\n          \
    \                         | Interface |\n                                   +-----------+\n\
    \              Figure 1: Relationship of Key Mgmt to PF_KEY\n   For performance\
    \ reasons, some security protocols (e.g. IP Security)\n   are usually implemented\
    \ inside the operating system kernel.  Other\n   security protocols (e.g.  OSPFv2\
    \ Cryptographic Authentication) are\n   implemented in trusted privileged applications\
    \ outside the kernel.\n   Figure 2 shows a trusted, privileged routing daemon\
    \ using PF_INET to\n   communicate routing information with a remote routing daemon\
    \ and\n   using PF_KEY to request, obtain, and delete Security Associations\n\
    \   used with a routing protocol.\n                     +---------------+\n  \
    \                   |Routing  Daemon|\n                     +---------------+\n\
    \                       |           |\n                       |           |\n\
    \                       |           |                   Applications\n       \
    \        ======[PF_KEY]====[PF_INET]==========================\n             \
    \          |           |                   OS Kernel\n               +------------+\
    \   +---------+\n               | Key Engine |   | TCP/IP  |\n               |\
    \  or  SADB  |---|         |\n               +------------+   +---------+\n  \
    \                                     |\n                                   +-----------+\n\
    \                                   | Network   |\n                          \
    \         | Interface |\n                                   +-----------+\n  \
    \      Figure 2: Relationship of Trusted Application to PF_KEY\n   When a trusted\
    \ privileged application is using the Key Engine but\n   implements the security\
    \ protocol within itself, then operation varies\n   slightly.  In this case, the\
    \ application needing an SA sends a PF_KEY\n   SADB_ACQUIRE message down to the\
    \ Key Engine, which then either\n   returns an error or sends a similar SADB_ACQUIRE\
    \ message up to one or\n   more key management applications capable of creating\
    \ such SAs.  As\n   before, the key management daemon stores the SA into the Key\
    \ Engine.\n   Then, the trusted privileged application uses an SADB_GET message\
    \ to\n   obtain the SA from the Key Engine.\n   In some implementations, policy\
    \ may be implemented in user-space,\n   even though the actual cryptographic processing\
    \ takes place in the\n   kernel.  Such policy communication between the kernel\
    \ mechanisms and\n   the user-space policy MAY be implemented by PF_KEY extensions,\
    \ or\n   other such mechanism.  This document does not specify such\n   extensions.\
    \  A PF_KEY implementation specified by the memo does NOT\n   have to support\
    \ configuring systemwide policy using PF_KEY.\n   Untrusted clients, for example\
    \ a user's web browser or telnet client,\n   do not need to use PF_KEY.  Mechanisms\
    \ not specified here are used by\n   such untrusted client applications to request\
    \ security services (e.g.\n   IPsec) from an operating system.  For security reasons,\
    \ only trusted,\n   privileged applications are permitted to open a PF_KEY socket.\n"
- title: 1.3 PF_KEY Socket Definition
  contents:
  - "1.3 PF_KEY Socket Definition\n   The PF_KEY protocol family (PF_KEY) symbol is\
    \ defined in\n   <sys/socket.h> in the same manner that other protocol families\
    \ are\n   defined.  PF_KEY does not use any socket addresses.  Applications\n\
    \   using PF_KEY MUST NOT depend on the availability of a symbol named\n   AF_KEY,\
    \ but kernel implementations are encouraged to define that\n   symbol for completeness.\n\
    \     The key management socket is created as follows:\n     #include <sys/types.h>\n\
    \     #include <sys/socket.h>\n     #include <net/pfkeyv2.h>\n     int s;\n  \
    \   s = socket(PF_KEY, SOCK_RAW, PF_KEY_V2);\n   The PF_KEY domain currently supports\
    \ only the SOCK_RAW socket type.\n   The protocol field MUST be set to PF_KEY_V2,\
    \ or else EPROTONOSUPPORT\n   will be returned.  Only a trusted, privileged process\
    \ can create a\n   PF_KEY socket.  On conventional UNIX systems, a privileged\
    \ process is\n   a process with an effective userid of zero.  On non-MLS proprietary\n\
    \   operating systems, the notion of a \"privileged process\" is\n   implementation-defined.\
    \  On Compartmented Mode Workstations (CMWs) or\n   other systems that claim to\
    \ provide Multi-Level Security (MLS), a\n   process MUST have the \"key management\
    \ privilege\" in order to open a\n   PF_KEY socket[DIA].  MLS systems that don't\
    \ currently have such a\n   specific privilege MUST add that special privilege\
    \ and enforce it\n   with PF_KEY in order to comply and conform with this specification.\n\
    \   Some systems, most notably some popular personal computers, do not\n   have\
    \ the concept of an unprivileged user.  These systems SHOULD take\n   steps to\
    \ restrict the programs allowed to access the PF_KEY API.\n"
- title: 1.4 Overview of PF_KEY Messaging Behavior
  contents:
  - "1.4 Overview of PF_KEY Messaging Behavior\n   A process interacts with the key\
    \ engine by sending and receiving\n   messages using the PF_KEY socket.  Security\
    \ association information\n   can be inserted into and retrieved from the kernel's\
    \ security\n   association table using a set of predefined messages.  In the normal\n\
    \   case, all properly-formed messages sent to the kernel are returned to\n  \
    \ all open PF_KEY sockets, including the sender.  Improperly formed\n   messages\
    \ will result in errors, and an implementation MUST check for\n   a properly formed\
    \ message before returning it to the appropriate\n   listeners. Unlike the routing\
    \ socket, most errors are sent in reply\n   messages, not the errno field when\
    \ write() or send() fails. PF_KEY\n   message delivery is not guaranteed, especially\
    \ in cases where kernel\n   or socket buffers are exhausted and messages are dropped.\n\
    \   Some messages are generated by the operating system to indicate that\n   actions\
    \ need to be taken, and are not necessarily in response to any\n   message sent\
    \ down by the user.  Such messages are not received by all\n   PF_KEY sockets,\
    \ but by sockets which have indicated that kernel-\n   originated messages are\
    \ to be received.  These messages are special\n   because of the expected frequency\
    \ at which they will occur.  Also, an\n   implementation may further wish to restrict\
    \ return messages from the\n   kernel, in cases where not all PF_KEY sockets are\
    \ in the same trust\n   domain.\n   Many of the normal BSD socket calls have undefined\
    \ behavior on PF_KEY\n   sockets.  These include: bind(), connect(), socketpair(),\
    \ accept(),\n   getpeername(), getsockname(), ioctl(), and listen().\n"
- title: 1.5 Common PF_KEY Operations
  contents:
  - "1.5 Common PF_KEY Operations\n   There are two basic ways to add a new Security\
    \ Association into the\n   kernel.  The simplest is to send a single SADB_ADD\
    \ message,\n   containing all of the SA information, from the application into\
    \ the\n   kernel's Key Engine.  This approach works particularly well with\n \
    \  manual key management, which is required for IPsec, and other\n   security\
    \ protocols.\n   The second approach to add a new Security Association into the\
    \ kernel\n   is for the application to first request a Security Parameters Index\n\
    \   (SPI) value from the kernel using the SADB_GETSPI message and then\n   send\
    \ an SADB_UPDATE message with the complete Security Association\n   data.  This\
    \ second approach works well with key management daemons\n   when the SPI values\
    \ need to be known before the entire Security\n   Association data is known (e.g.\
    \ so the SPI value can be indicated to\n   the remote end of the key management\
    \ session).\n   An individual Security Association can be deleted using the\n\
    \   SADB_DELETE message.  Categories of SAs or the entire kernel SA table\n  \
    \ can be deleted using the SADB_FLUSH message.\n   The SADB_GET message is used\
    \ by a trusted application-layer process\n   (e.g.  routed(8) or gated(8)) to\
    \ retrieve an SA (e.g. RIP SA or OSPF\n   SA) from the kernel's Key Engine.\n\
    \   The kernel or an application-layer can use the SADB_ACQUIRE message\n   to\
    \ request that a Security Association be created by some\n   application-layer\
    \ key management process that has registered with the\n   kernel via an SADB_REGISTER\
    \ message.  This ACQUIRE message will have\n   a sequence number associated with\
    \ it.  This sequence number MUST be\n   used by followup SADB_GETSPI, SADB_UPDATE,\
    \ and SADB_ADD messages, in\n   order to keep track of which request gets its\
    \ keying material.  The\n   sequence number (described below) is similar to a\
    \ transaction ID in a\n   remote procedure call.\n   The SADB_EXPIRE message is\
    \ sent from the kernel to key management\n   applications when the \"soft lifetime\"\
    \ or \"hard lifetime\" of a\n   Security Association has expired.  Key management\
    \ applications should\n   use receipt of a soft lifetime SADB_EXPIRE message as\
    \ a hint to\n   negotiate a replacement SA so the replacement SA will be ready\
    \ and in\n   the kernel before it is needed.\n   A SADB_DUMP message is also defined,\
    \ but this is primarily intended\n   for PF_KEY implementor debugging and is not\
    \ used in ordinary\n   operation of PF_KEY.\n"
- title: 1.6 Differences Between PF_KEY and PF_ROUTE
  contents:
  - "1.6 Differences Between PF_KEY and PF_ROUTE\n   The following bullets are points\
    \ of difference between the routing\n   socket and PF_KEY.  Programmers who are\
    \ used to the routing socket\n   semantics will find some differences in PF_KEY.\n\
    \   * PF_KEY message errors are usually returned in PF_KEY messages\n     instead\
    \ of causing write() operations to fail and returning the\n     error number in\
    \ errno. This means that other listeners on a PF_KEY\n     socket can be aware\
    \ that requests from another process failed,\n     which can be useful for auditing\
    \ purposes. This also means that\n     applications that fail to read PF_KEY messages\
    \ cannot do error\n     checking.\n     An implementation MAY return the errors\
    \ EINVAL, ENOMEM, and ENOBUFS\n     by causing write() operations to fail and\
    \ returning the error\n     number in errno.  This is an optimization for common\
    \ error cases in\n     which it does not make sense for any other process to receive\
    \ the\n     error.  An application MUST NOT depend on such errors being set by\n\
    \     the write() call, but it SHOULD check for such errors, and handle\n    \
    \ them in an appropriate manner.\n   * The entire message isn't always reflected\
    \ in the reply. A SADB_ADD\n     message is an example of this.\n   * The PID\
    \ is not set by the kernel.  The process that originates the\n     message MUST\
    \ set the sadb_msg_pid to its own PID.  If the kernel\n     ORIGINATES a message,\
    \ it MUST set the sadb_msg_pid to 0.  A reply\n     to an original message SHOULD\
    \ have the pid of the original message.\n     (E.g. the kernel's response to an\
    \ SADB_ADD SHOULD have its pid set\n     to the pid value of the original SADB_ADD\
    \ message.)\n"
- title: 1.7 Name Space
  contents:
  - "1.7 Name Space\n   All PF_KEYv2 preprocessor symbols and structure definitions\
    \ are\n   defined as a result of including the header file <net/pfkeyv2.h>.\n\
    \   There is exactly one exception to this rule: the symbol \"PF_KEY\" (two\n\
    \   exceptions if \"AF_KEY\" is also counted), which is defined as a result\n\
    \   of including the header file <sys/socket.h>.  All PF_KEYv2\n   preprocessor\
    \ symbols start with the prefix \"SADB_\" and all structure\n   names start with\
    \ \"sadb_\". There are exactly two exceptions to this\n   rule: the symbol \"\
    PF_KEY_V2\" and the symbol \"PFKEYV2_REVISION\".\n   The symbol \"PFKEYV2_REVISION\"\
    \ is a date-encoded value not unlike\n   certain values defined by POSIX and X/Open.\
    \  The current value for\n   PFKEYV2_REVISION is 199806L, where 1998 is the year\
    \ and 06 is the\n   month.\n   Inclusion of the file <net/pfkeyv2.h> MUST NOT\
    \ define symbols or\n   structures in the PF_KEYv2 name space that are not described\
    \ in this\n   document without the explicit prior permission of the authors. \
    \ Any\n   symbols or structures in the PF_KEYv2 name space that are not\n   described\
    \ in this document MUST start with \"SADB_X_\" or \"sadb_x_\". An\n   implementation\
    \ that fails to obey these rules IS NOT COMPLIANT WITH\n   THIS SPECIFICATION\
    \ and MUST NOT make any claim to be.  These rules\n   also apply to any files\
    \ that might be included as a result of\n   including the file <net/pfkeyv2.h>.\
    \ This rule provides implementors\n   with some assurance that they will not encounter\
    \ namespace-related\n   surprises.\n"
- title: 1.8 On Manual Keying
  contents:
  - "1.8 On Manual Keying\n   Not unlike the 4.4-Lite BSD PF_ROUTE socket, this interface\
    \ allows an\n   application full-reign over the security associations in a kernel\n\
    \   that implements PF_KEY.  A PF_KEY implementation MUST have some sort\n   of\
    \ manual interface to PF_KEY, which SHOULD allow all of the\n   functionality\
    \ of the programmatic interface described here.\n"
- title: 2. PF_KEY Message Format
  contents:
  - "2. PF_KEY Message Format\n   PF_KEY messages consist of a base header followed\
    \ by additional data\n   fields, some of which may be optional.  The format of\
    \ the additional\n   data is dependent on the type of message.\n   PF_KEY messages\
    \ currently do not mandate any specific ordering for\n   non-network multi-octet\
    \ fields.  Unless otherwise specified (e.g. SPI\n   values), fields MUST be in\
    \ host-specific byte order.\n"
- title: 2.1 Base Message Header Format
  contents:
  - "2.1 Base Message Header Format\n   PF_KEY messages consist of the base message\
    \ header followed by\n   security association specific data whose types and lengths\
    \ are\n   specified by a generic type-length encoding.\n   This base header is\
    \ shown below, using POSIX types.  The fields are\n   arranged primarily for alignment,\
    \ and where possible, for reasons of\n   clarity.\n           struct sadb_msg\
    \ {\n                   uint8_t sadb_msg_version;\n                   uint8_t\
    \ sadb_msg_type;\n                   uint8_t sadb_msg_errno;\n               \
    \    uint8_t sadb_msg_satype;\n                   uint16_t sadb_msg_len;\n   \
    \                uint16_t sadb_msg_reserved;\n                   uint32_t sadb_msg_seq;\n\
    \                   uint32_t sadb_msg_pid;\n           };\n           /* sizeof(struct\
    \ sadb_msg) == 16 */\n   sadb_msg_version\n                   The version field\
    \ of this PF_KEY message. This MUST\n                   be set to PF_KEY_V2. If\
    \ this is not set to PF_KEY_V2,\n                   the write() call MAY fail\
    \ and return EINVAL.\n                   Otherwise, the behavior is undetermined,\
    \ given that\n                   the application might not understand the formatting\n\
    \                   of the messages arriving from the kernel.\n   sadb_msg_type\
    \   Identifies the type of message. The valid message\n                   types\
    \ are described later in this document.\n   sadb_msg_errno  Should be set to zero\
    \ by the sender. The responder\n                   stores the error code in this\
    \ field if an error has\n                   occurred. This includes the case where\
    \ the responder\n                   is in user space. (e.g. user-space negotiation\n\
    \                   fails, an errno can be returned.)\n   sadb_msg_satype Indicates\
    \ the type of security association(s). Valid\n                   Security Association\
    \ types are declared in the file\n                   <net/pfkeyv2.h>. The current\
    \ set of Security\n                   Association types is enumerated later in\
    \ this\n                   document.\n   sadb_msg_len    Contains the total length,\
    \ in 64-bit words, of all\n                   data in the PF_KEY message including\
    \ the base header\n                   length and additional data after the base\
    \ header, if\n                   any. This length includes any padding or extra\
    \ space\n                   that might exist. Unless otherwise stated, all other\n\
    \                   length fields are also measured in 64-bit words.\n       \
    \            On user to kernel messages, this field MUST be\n                \
    \   verified against the length of the inbound message.\n                   EMSGSIZE\
    \ MUST be returned if the verification fails.\n                   On kernel to\
    \ user messages, a size mismatch is most\n                   likely the result\
    \ of the user not providing a large\n                   enough buffer for the\
    \ message. In these cases, the\n                   user application SHOULD drop\
    \ the message, but it MAY\n                   try and extract what information\
    \ it can out of the\n                   message.\n   sadb_msg_reserved\n     \
    \              Reserved value. It MUST be zeroed by the sender. All\n        \
    \           fields labeled reserved later in the document have\n             \
    \      the same semantics as this field.\n   sadb_msg_seq    Contains the sequence\
    \ number of this message. This\n                   field, along with sadb_msg_pid,\
    \ MUST be used to\n                   uniquely identify requests to a process.\
    \ The sender\n                   is responsible for filling in this field. This\n\
    \                   responsibility also includes matching the\n              \
    \     sadb_msg_seq of a request (e.g. SADB_ACQUIRE).\n                   This\
    \ field is similar to a transaction ID in a\n                   remote procedure\
    \ call implementation.\n   sadb_msg_pid    Identifies the process which originated\
    \ this message,\n                   or which process a message is bound for. \
    \ For\n                   example, if process id 2112 sends an SADB_UPDATE\n \
    \                  message to the kernel, the process MUST set this\n        \
    \           field to 2112 and the kernel will set this field\n               \
    \    to 2112 in its reply to that SADB_UPDATE\n                   message. This\
    \ field, along with sadb_msg_seq, can\n                   be used to uniquely\
    \ identify requests to a\n                   process.\n                   It is\
    \ currently assumed that a 32-bit quantity will\n                   hold an operating\
    \ system's process ID space.\n"
- title: 2.2 Alignment of Headers and Extension Headers
  contents:
  - "2.2 Alignment of Headers and Extension Headers\n   The base message header is\
    \ a multiple of 64 bits and fields after it\n   in memory will be 64 bit aligned\
    \ if the base itself is 64 bit\n   aligned.  Some of the subsequent extension\
    \ headers have 64 bit fields\n   in them, and as a consequence need to be 64 bit\
    \ aligned in an\n   environment where 64 bit quantities need to be 64 bit aligned.\n\
    \   The basic unit of alignment and length in PF_KEY Version 2 is 64\n   bits.\
    \ Therefore:\n     * All extension headers, inclusive of the sadb_ext overlay\
    \ fields,\n       MUST be a multiple of 64 bits long.\n     * All variable length\
    \ data MUST be padded appropriately such that\n       its length in a message\
    \ is a multiple of 64 bits.\n     * All length fields are, unless otherwise specified,\
    \ in units of\n       64 bits.\n     * Implementations may safely access quantities\
    \ of between 8 and 64\n       bits directly within a message without risk of alignment\
    \ faults.\n   All PF_KEYv2 structures are packed and already have all intended\n\
    \   padding.  Implementations MUST NOT insert any extra fields, including\n  \
    \ hidden padding, into any structure in this document.  This forbids\n   implementations\
    \ from \"extending\" or \"enhancing\" existing headers\n   without changing the\
    \ extension header type. As a guard against such\n   insertion of silent padding,\
    \ each structure in this document is\n   labeled with its size in bytes. The size\
    \ of these structures in an\n   implementation MUST match the size listed.\n"
- title: 2.3 Additional Message Fields
  contents:
  - "2.3 Additional Message Fields\n   The additional data following the base header\
    \ consists of various\n   length-type-values fields.  The first 32-bits are of\
    \ a constant form:\n           struct sadb_ext {\n                   uint16_t\
    \ sadb_ext_len;\n                   uint16_t sadb_ext_type;\n           };\n \
    \          /* sizeof(struct sadb_ext) == 4 */\n   sadb_ext_len    Length of the\
    \ extension header in 64 bit words,\n                   inclusive.\n   sadb_ext_type\
    \   The type of extension header that follows. Values for\n                  \
    \ this field are detailed later. The value zero is\n                   reserved.\n\
    \   Types of extension headers include: Association, Lifetime(s),\n   Address(s),\
    \ Key(s), Identity(ies), Sensitivity, Proposal, and\n   Supported. There MUST\
    \ be only one instance of a extension type in a\n   message.  (e.g.  Base, Key,\
    \ Lifetime, Key is forbidden).  An EINVAL\n   will be returned if there are duplicate\
    \ extensions within a message.\n   Implementations MAY enforce ordering of extensions\
    \ in the order\n   presented in the EXTENSION HEADER VALUES section.\n   If an\
    \ unknown extension type is encountered, it MUST be ignored.\n   Applications\
    \ using extension headers not specified in this document\n   MUST be prepared\
    \ to work around other system components not\n   processing those headers.  Likewise,\
    \ if an application encounters an\n   unknown extension from the kernel, it must\
    \ be prepared to work around\n   it.  Also, a kernel that generates extra extension\
    \ header types MUST\n   NOT _depend_ on applications also understanding extra\
    \ extension\n   header types.\n   All extension definitions include these two\
    \ fields (len and exttype)\n   because they are instances of a generic extension\
    \ (not unlike\n   sockaddr_in and sockaddr_in6 are instances of a generic sockaddr).\n\
    \   The sadb_ext header MUST NOT ever be present in a message without at\n   least\
    \ four bytes of extension header data following it, and,\n   therefore, there\
    \ is no problem with it being only four bytes long.\n   All extensions documented\
    \ in this section MUST be implemented by a\n   PF_KEY implementation.\n"
- title: 2.3.1 Association Extension
  contents:
  - "2.3.1 Association Extension\n   The Association extension specifies data specific\
    \ to a single\n   security association. The only times this extension is not present\
    \ is\n   when control messages (e.g. SADB_FLUSH or SADB_REGISTER) are being\n\
    \   passed and on the SADB_ACQUIRE message.\n           struct sadb_sa {\n   \
    \                uint16_t sadb_sa_len;\n                   uint16_t sadb_sa_exttype;\n\
    \                   uint32_t sadb_sa_spi;\n                   uint8_t sadb_sa_replay;\n\
    \                   uint8_t sadb_sa_state;\n                   uint8_t sadb_sa_auth;\n\
    \                   uint8_t sadb_sa_encrypt;\n                   uint32_t sadb_sa_flags;\n\
    \           };\n           /* sizeof(struct sadb_sa) == 16 */\n   sadb_sa_spi\
    \     The Security Parameters Index value for the security\n                 \
    \  association. Although this is a 32-bit field, some\n                   types\
    \ of security associations might have an SPI or\n                   key identifier\
    \ that is less than 32-bits long. In\n                   this case, the smaller\
    \ value shall be stored in the\n                   least significant bits of this\
    \ field and the unneeded\n                   bits shall be zero. This field MUST\
    \ be in network\n                   byte order.\n   sadb_sa_replay  The size of\
    \ the replay window, if not zero. If zero,\n                   then no replay\
    \ window is in use.\n   sadb_sa_state   The state of the security association.\
    \ The currently\n                   defined states are described later in this\
    \ document.\n   sadb_sa_auth    The authentication algorithm to be used with this\n\
    \                   security association. The valid authentication\n         \
    \          algorithms are described later in this document. A\n              \
    \     value of zero means that no authentication is used\n                   for\
    \ this security association.\n   sadb_sa_encrypt The encryption algorithm to be\
    \ used with this\n                   security association. The valid encryption\
    \ algorithms\n                   are described later in this document. A value\
    \ of zero\n                   means that no encryption is used for this security\n\
    \                   association.\n   sadb_sa_flags   A bitmap of options defined\
    \ for the security\n                   association. The currently defined flags\
    \ are\n                   described later in this document.\n   The kernel MUST\
    \ check these values where appropriate. For example,\n   IPsec AH with no authentication\
    \ algorithm is probably an error.\n   When used with some messages, the values\
    \ in some fields in this\n   header should be ignored.\n"
- title: 2.3.2 Lifetime Extension
  contents:
  - "2.3.2 Lifetime Extension\n   The Lifetime extension specifies one or more lifetime\
    \ variants for\n   this security association.  If no Lifetime extension is present\
    \ the\n   association has an infinite lifetime.  An association SHOULD have a\n\
    \   lifetime of some sort associated with it.  Lifetime variants come in\n   three\
    \ varieties, HARD - indicating the hard-limit expiration, SOFT -\n   indicating\
    \ the soft-limit expiration, and CURRENT - indicating the\n   current state of\
    \ a given security association.  The Lifetime\n   extension looks like:\n    \
    \       struct sadb_lifetime {\n                   uint16_t sadb_lifetime_len;\n\
    \                   uint16_t sadb_lifetime_exttype;\n                   uint32_t\
    \ sadb_lifetime_allocations;\n                   uint64_t sadb_lifetime_bytes;\n\
    \                   uint64_t sadb_lifetime_addtime;\n                   uint64_t\
    \ sadb_lifetime_usetime;\n           };\n           /* sizeof(struct sadb_lifetime)\
    \ == 32 */\n   sadb_lifetime_allocations\n                   For CURRENT, the\
    \ number of different connections,\n                   endpoints, or flows that\
    \ the association has been\n                   allocated towards. For HARD and\
    \ SOFT, the number of\n                   these the association may be allocated\
    \ towards\n                   before it expires. The concept of a connection,\n\
    \                   flow, or endpoint is system specific.\n   sadb_lifetime_bytes\n\
    \                   For CURRENT, how many bytes have been processed\n        \
    \           using this security association. For HARD and SOFT,\n            \
    \       the number of bytes that may be processed using\n                   this\
    \ security association before it expires.\n   sadb_lifetime_addtime\n        \
    \           For CURRENT, the time, in seconds, when the\n                   association\
    \ was created. For HARD and SOFT, the\n                   number of seconds after\
    \ the creation of the\n                   association until it expires.\n    \
    \               For such time fields, it is assumed that 64-bits is\n        \
    \           sufficiently large to hold the POSIX time_t value.\n             \
    \      If this assumption is wrong, this field will have to\n                \
    \   be revisited.\n   sadb_lifetime_usetime\n                   For CURRENT, the\
    \ time, in seconds, when association\n                   was first used. For HARD\
    \ and SOFT, the number of\n                   seconds after the first use of the\
    \ association until\n                   it expires.\n   The semantics of lifetimes\
    \ are inclusive-OR, first-to-expire.  This\n   means that if values for bytes\
    \ and time, or multiple times, are\n   passed in, the first of these values to\
    \ be reached will cause a\n   lifetime expiration.\n"
- title: 2.3.3 Address Extension
  contents:
  - "2.3.3 Address Extension\n   The Address extension specifies one or more addresses\
    \ that are\n   associated with a security association. Address extensions for\
    \ both\n   source and destination MUST be present when an Association extension\n\
    \   is present. The format of an Address extension is:\n           struct sadb_address\
    \ {\n                   uint16_t sadb_address_len;\n                   uint16_t\
    \ sadb_address_exttype;\n                   uint8_t sadb_address_proto;\n    \
    \               uint8_t sadb_address_prefixlen;\n                   uint16_t sadb_address_reserved;\n\
    \           };\n           /* sizeof(struct sadb_address) == 8 */\n          \
    \ /* followed by some form of struct sockaddr */\n   The sockaddr structure SHOULD\
    \ conform to the sockaddr structure of\n   the system implementing PF_KEY. If\
    \ the system has an sa_len field, so\n   SHOULD the sockaddrs in the message.\
    \ If the system has NO sa_len\n   field, the sockaddrs SHOULD NOT have an sa_len\
    \ field. All non-address\n   information in the sockaddrs, such as sin_zero for\
    \ AF_INET sockaddrs,\n   and sin6_flowinfo for AF_INET6 sockaddrs, MUST be zeroed\
    \ out.  The\n   zeroing of ports (e.g. sin_port and sin6_port) MUST be done for\
    \ all\n   messages except for originating SADB_ACQUIRE messages, which SHOULD\n\
    \   fill them in with ports from the relevant TCP or UDP session which\n   generates\
    \ the ACQUIRE message.  If the ports are non-zero, then the\n   sadb_address_proto\
    \ field, normally zero, MUST be filled in with the\n   transport protocol's number.\
    \  If the sadb_address_prefixlen is non-\n   zero, then the address has a prefix\
    \ (often used in KM access control\n   decisions), with length specified in sadb_address_prefixlen.\
    \  These\n   additional fields may be useful to KM applications.\n   The SRC and\
    \ DST addresses for a security association MUST be in the\n   same protocol family\
    \ and MUST always be present or absent together in\n   a message.  The PROXY address\
    \ MAY be in a different protocol family,\n   and for most security protocols,\
    \ represents an actual originator of a\n   packet.  (For example, the inner-packets's\
    \ source address in a\n   tunnel.)\n   The SRC address MUST be a unicast or unspecified\
    \ (e.g., INADDR_ANY)\n   address.  The DST address can be any valid destination\
    \ address\n   (unicast, multicast, or even broadcast). The PROXY address SHOULD\
    \ be\n   a unicast address (there are experimental security protocols where\n\
    \   PROXY semantics may be different than described above).\n"
- title: 2.3.4 Key Extension
  contents:
  - "2.3.4 Key Extension\n   The Key extension specifies one or more keys that are\
    \ associated with\n   a security association.  A Key extension will not always\
    \ be present\n   with messages, because of security risks.  The format of a Key\n\
    \   extension is:\n           struct sadb_key {\n                   uint16_t sadb_key_len;\n\
    \                   uint16_t sadb_key_exttype;\n                   uint16_t sadb_key_bits;\n\
    \                   uint16_t sadb_key_reserved;\n           };\n           /*\
    \ sizeof(struct sadb_key) == 8 */\n           /* followed by the key data */\n\
    \   sadb_key_bits   The length of the valid key data, in bits. A value of\n  \
    \                 zero in sadb_key_bits MUST cause an error.\n   The key extension\
    \ comes in two varieties. The AUTH version is used\n   with authentication keys\
    \ (e.g. IPsec AH, OSPF MD5) and the ENCRYPT\n   version is used with encryption\
    \ keys (e.g. IPsec ESP).  PF_KEY deals\n   only with fully formed cryptographic\
    \ keys, not with \"raw key\n   material\". For example, when ISAKMP/Oakley is\
    \ in use, the key\n   management daemon is always responsible for transforming\
    \ the result\n   of the Diffie-Hellman computation into distinct fully formed\
    \ keys\n   PRIOR to sending those keys into the kernel via PF_KEY.  This rule\
    \ is\n   made because PF_KEY is designed to support multiple security\n   protocols\
    \ (not just IP Security) and also multiple key management\n   schemes including\
    \ manual keying, which does not have the concept of\n   \"raw key material\".\
    \  A clean, protocol-independent interface is\n   important for portability to\
    \ different operating systems as well as\n   for portability to different security\
    \ protocols.\n   If an algorithm defines its key to include parity bits (e.g.\
    \  DES)\n   then the key used with PF_KEY MUST also include those parity bits.\n\
    \   For example, this means that a single DES key is always a 64-bit\n   quantity.\n\
    \   When a particular security protocol only requires one authentication\n   and/or\
    \ one encryption key, the fully formed key is transmitted using\n   the appropriate\
    \ key extension.  When a particular security protocol\n   requires more than one\
    \ key for the same function (e.g. Triple-DES\n   using 2 or 3 keys, and asymmetric\
    \ algorithms), then those two fully\n   formed keys MUST be concatenated together\
    \ in the order used for\n   outbound packet processing. In the case of multiple\
    \ keys, the\n   algorithm MUST be able to determine the lengths of the individual\n\
    \   keys based on the information provided.  The total key length (when\n   combined\
    \ with knowledge of the algorithm in use) usually provides\n   sufficient information\
    \ to make this determination.\n   Keys are always passed through the PF_KEY interface\
    \ in the order that\n   they are used for outbound packet processing. For inbound\
    \ processing,\n   the correct order that keys are used might be different from\
    \ this\n   canonical concatenation order used with the PF_KEY interface. It is\n\
    \   the responsibility of the implementation to use the keys in the\n   correct\
    \ order for both inbound and outbound processing.\n   For example, consider a\
    \ pair of nodes communicating unicast using an\n   ESP three-key Triple-DES Security\
    \ Association. Both the outbound SA\n   on the sender node, and the inbound SA\
    \ on the receiver node will\n   contain key-A, followed by key-B, followed by\
    \ key-C in their\n   respective ENCRYPT key extensions. The outbound SA will use\
    \ key-A\n   first, followed by key-B, then key-C when encrypting. The inbound\
    \ SA\n   will use key-C, followed by key-B, then key-A when decrypting.\n   (NOTE:\
    \ We are aware that 3DES is actually encrypt-decrypt-encrypt.)\n   The canonical\
    \ ordering of key-A, key-B, key-C is used for 3DES, and\n   should be documented.\
    \  The order of \"encryption\" is the canonical\n   order for this example. [Sch96]\n\
    \   The key data bits are arranged most-significant to least significant.\n  \
    \ For example, a 22-bit key would take up three octets, with the least\n   significant\
    \ two bits not containing key material. Five additional\n   octets would then\
    \ be used for padding to the next 64-bit boundary.\n   While not directly related\
    \ to PF_KEY, there is a user interface issue\n   regarding odd-digit hexadecimal\
    \ representation of keys.  Consider the\n   example of the 16-bit number:\n  \
    \         0x123\n   That will require two octets of storage. In the absence of\
    \ other\n   information, however, unclear whether the value shown is stored as:\n\
    \           01 23           OR              12 30\n   It is the opinion of the\
    \ authors that the former (0x123 == 0x0123) is\n   the better way to interpret\
    \ this ambiguity. Extra information (for\n   example, specifying 0x0123 or 0x1230,\
    \ or specifying that this is only\n   a twelve-bit number) would solve this problem.\n"
- title: 2.3.5 Identity Extension
  contents:
  - "2.3.5 Identity Extension\n   The Identity extension contains endpoint identities.\
    \  This\n   information is used by key management to select the identity\n   certificate\
    \ that is used in negotiations. This information may also\n   be provided by a\
    \ kernel to network security aware applications to\n   identify the remote entity,\
    \ possibly for access control purposes.  If\n   this extension is not present,\
    \ key management MUST assume that the\n   addresses in the Address extension are\
    \ the only identities for this\n   Security Association. The Identity extension\
    \ looks like:\n           struct sadb_ident {\n                   uint16_t sadb_ident_len;\n\
    \                   uint16_t sadb_ident_exttype;\n                   uint16_t\
    \ sadb_ident_type;\n                   uint16_t sadb_ident_reserved;\n       \
    \            uint64_t sadb_ident_id;\n           };\n           /* sizeof(struct\
    \ sadb_ident) == 16 */\n           /* followed by the identity string, if present\
    \ */\n   sadb_ident_type The type of identity information that follows.\n    \
    \               Currently defined identity types are described later\n       \
    \            in this document.\n   sadb_ident_id   An identifier used to aid in\
    \ the construction of an\n                   identity string if none is present.\
    \  A POSIX user id\n                   value is one such identifier that will\
    \ be used in this\n                   field.  Use of this field is described later\
    \ in this\n                   document.\n   A C string containing a textual representation\
    \ of the identity\n   information optionally follows the sadb_ident extension.\
    \  The format\n   of this string is determined by the value in sadb_ident_type,\
    \ and is\n   described later in this document.\n"
- title: 2.3.6 Sensitivity Extension
  contents:
  - "2.3.6 Sensitivity Extension\n   The Sensitivity extension contains security labeling\
    \ information for\n   a security association.  If this extension is not present,\
    \ no\n   sensitivity-related data can be obtained from this security\n   association.\
    \  If this extension is present, then the need for\n   explicit security labeling\
    \ on the packet is obviated.\n           struct sadb_sens {\n                \
    \   uint16_t sadb_sens_len;\n                   uint16_t sadb_sens_exttype;\n\
    \                   uint32_t sadb_sens_dpd;\n                   uint8_t sadb_sens_sens_level;\n\
    \                   uint8_t sadb_sens_sens_len;\n                   uint8_t sadb_sens_integ_level;\n\
    \                   uint8_t sadb_sens_integ_len;\n                   uint32_t\
    \ sadb_sens_reserved;\n           };\n           /* sizeof(struct sadb_sens) ==\
    \ 16 */\n           /* followed by:\n                   uint64_t sadb_sens_bitmap[sens_len];\n\
    \                   uint64_t sadb_integ_bitmap[integ_len]; */\n   sadb_sens_dpd\
    \   Describes the protection domain, which allows\n                   interpretation\
    \ of the levels and compartment\n                   bitmaps.\n   sadb_sens_sens_level\n\
    \                   The sensitivity level.\n   sadb_sens_sens_len\n          \
    \         The length, in 64 bit words, of the sensitivity\n                  \
    \ bitmap.\n   sadb_sens_integ_level\n                   The integrity level.\n\
    \   sadb_sens_integ_len\n                   The length, in 64 bit words, of the\
    \ integrity\n                   bitmap.\n   This sensitivity extension is designed\
    \ to support the Bell-LaPadula\n   [BL74] security model used in compartmented-mode\
    \ or multi-level\n   secure systems, the Clark-Wilson [CW87] commercial security\
    \ model,\n   and/or the Biba integrity model [Biba77]. These formal models can\
    \ be\n   used to implement a wide variety of security policies. The definition\n\
    \   of a particular security policy is outside the scope of this\n   document.\
    \  Each of the bitmaps MUST be padded to a 64-bit boundary if\n   they are not\
    \ implicitly 64-bit aligned.\n"
- title: 2.3.7 Proposal Extension
  contents:
  - "2.3.7 Proposal Extension\n   The Proposal extension contains a \"proposed situation\"\
    \ of algorithm\n   preferences.  It looks like:\n           struct sadb_prop {\n\
    \                   uint16_t sadb_prop_len;\n                   uint16_t sadb_prop_exttype;\n\
    \                   uint8_t sadb_prop_replay;\n                   uint8_t sadb_prop_reserved[3];\n\
    \           };\n           /* sizeof(struct sadb_prop) == 8 */\n           /*\
    \ followed by:\n              struct sadb_comb sadb_combs[(sadb_prop_len *\n \
    \                 sizeof(uint64_t) - sizeof(struct sadb_prop)) /\n           \
    \       sizeof(struct sadb_comb)]; */\n   Following the header is a list of proposed\
    \ parameter combinations in\n   preferential order.  The values in these fields\
    \ have the same\n   definition as the fields those values will move into if the\n\
    \   combination is chosen.\n       NOTE: Some algorithms in some security protocols\
    \ will have\n             variable IV lengths per algorithm.  Variable length\
    \ IVs\n             are not supported by PF_KEY v2.  If they were, however,\n\
    \             proposed IV lengths would go in the Proposal Extension.\n   These\
    \ combinations look like:\n           struct sadb_comb {\n                   uint8_t\
    \ sadb_comb_auth;\n                   uint8_t sadb_comb_encrypt;\n           \
    \        uint16_t sadb_comb_flags;\n                   uint16_t sadb_comb_auth_minbits;\n\
    \                   uint16_t sadb_comb_auth_maxbits;\n                   uint16_t\
    \ sadb_comb_encrypt_minbits;\n                   uint16_t sadb_comb_encrypt_maxbits;\n\
    \                   uint32_t sadb_comb_reserved;\n                   uint32_t\
    \ sadb_comb_soft_allocations;\n                   uint32_t sadb_comb_hard_allocations;\n\
    \                   uint64_t sadb_comb_soft_bytes;\n                   uint64_t\
    \ sadb_comb_hard_bytes;\n                   uint64_t sadb_comb_soft_addtime;\n\
    \                   uint64_t sadb_comb_hard_addtime;\n                   uint64_t\
    \ sadb_comb_soft_usetime;\n                   uint64_t sadb_comb_hard_usetime;\n\
    \           };\n           /* sizeof(struct sadb_comb) == 72 */\n   sadb_comb_auth\
    \  If this combination is accepted, this will be the\n                   value\
    \ of sadb_sa_auth.\n   sadb_comb_encrypt\n                   If this combination\
    \ is accepted, this will be the\n                   value of sadb_sa_encrypt.\n\
    \   sadb_comb_auth_minbits;\n   sadb_comb_auth_maxbits;\n                   The\
    \ minimum and maximum acceptable authentication\n                   key lengths,\
    \ respectably, in bits. If sadb_comb_auth\n                   is zero, both of\
    \ these values MUST be zero. If\n                   sadb_comb_auth is nonzero,\
    \ both of these values MUST\n                   be nonzero. If this combination\
    \ is accepted, a value\n                   between these (inclusive) will be stored\
    \ in the\n                   sadb_key_bits field of KEY_AUTH. The minimum MUST\n\
    \                   NOT be greater than the maximum.\n   sadb_comb_encrypt_minbits;\n\
    \   sadb_comb_encrypt_maxbits;\n                   The minimum and maximum acceptable\
    \ encryption key\n                   lengths, respectably, in bits. If sadb_comb_encrypt\n\
    \                   is zero, both of these values MUST be zero. If\n         \
    \          sadb_comb_encrypt is nonzero, both of these values\n              \
    \     MUST be nonzero. If this combination is accepted, a\n                  \
    \ value between these (inclusive) will be stored in\n                   the sadb_key_bits\
    \ field of KEY_ENCRYPT. The minimum\n                   MUST NOT be greater than\
    \ the maximum.\n   sadb_comb_soft_allocations\n   sadb_comb_hard_allocations\n\
    \                   If this combination is accepted, these are proposed\n    \
    \               values of sadb_lifetime_allocations in the SOFT and\n        \
    \           HARD lifetimes, respectively.\n   sadb_comb_soft_bytes\n   sadb_comb_hard_bytes\n\
    \                   If this combination is accepted, these are proposed\n    \
    \               values of sadb_lifetime_bytes in the SOFT and HARD\n         \
    \          lifetimes, respectively.\n   sadb_comb_soft_addtime\n   sadb_comb_hard_addtime\n\
    \                   If this combination is accepted, these are proposed\n    \
    \               values of sadb_lifetime_addtime in the SOFT and HARD\n       \
    \            lifetimes, respectively.\n   sadb_comb_soft_usetime\n   sadb_comb_hard_usetime\n\
    \                   If this combination is accepted, these are proposed\n    \
    \               values of sadb_lifetime_usetime in the SOFT and HARD\n       \
    \            lifetimes, respectively.\n   Each combination has an authentication\
    \ and encryption algorithm,\n   which may be 0, indicating none.  A combination's\
    \ flags are the same\n   as the flags in the Association extension.  The minimum\
    \ and maximum\n   key lengths (which are in bits) are derived from possible a\
    \ priori\n   policy decisions, along with basic properties of the algorithm.\n\
    \   Lifetime attributes are also included in a combination, as some\n   algorithms\
    \ may know something about their lifetimes and can suggest\n   lifetime limits.\n"
- title: 2.3.8 Supported Algorithms Extension
  contents:
  - "2.3.8 Supported Algorithms Extension\n   The Supported Algorithms extension contains\
    \ a list of all algorithms\n   supported by the system. This tells key management\
    \ what algorithms it\n   can negotiate. Available authentication algorithms are\
    \ listed in the\n   SUPPORTED_AUTH extension and available encryption algorithms\
    \ are\n   listed in the SUPPORTED_ENCRYPT extension. The format of these\n   extensions\
    \ is:\n           struct sadb_supported {\n                   uint16_t sadb_supported_len;\n\
    \                   uint16_t sadb_supported_exttype;\n                   uint32_t\
    \ sadb_supported_reserved;\n           };\n           /* sizeof(struct sadb_supported)\
    \ == 8 */\n           /* followed by:\n              struct sadb_alg sadb_algs[(sadb_supported_len\
    \ *\n                  sizeof(uint64_t) - sizeof(struct sadb_supported)) /\n \
    \                 sizeof(struct sadb_alg)]; */\n     This header is followed by\
    \ one or more algorithm  descriptions.  An\n   algorithm description looks like:\n\
    \           struct sadb_alg {\n                   uint8_t sadb_alg_id;\n     \
    \              uint8_t sadb_alg_ivlen;\n                   uint16_t sadb_alg_minbits;\n\
    \                   uint16_t sadb_alg_maxbits;\n                   uint16_t sadb_alg_reserved;\n\
    \           };\n           /* sizeof(struct sadb_alg) == 8 */\n   sadb_alg_id\
    \    The algorithm identification value for this\n                  algorithm.\
    \ This is the value that is stored in\n                  sadb_sa_auth or sadb_sa_encrypt\
    \ if this algorithm is\n                  selected.\n   sadb_alg_ivlen The length\
    \ of the initialization vector to be used\n                  for the algorithm.\
    \ If an IV is not needed, this\n                  value MUST be set to zero.\n\
    \   sadb_alg_minbits\n                   The minimum acceptable key length, in\
    \ bits. A value\n                   of zero is invalid.\n   sadb_alg_maxbits\n\
    \                   The maximum acceptable key length, in bits. A value\n    \
    \               of zero is invalid. The minimum MUST NOT be greater\n        \
    \           than the maximum.\n"
- title: 2.3.9 SPI Range Extension
  contents:
  - "2.3.9 SPI Range Extension\n   One PF_KEY message, SADB_GETSPI, might need a range\
    \ of acceptable SPI\n   values.  This extension performs such a function.\n  \
    \         struct sadb_spirange {\n                   uint16_t sadb_spirange_len;\n\
    \                   uint16_t sadb_spirange_exttype;\n                   uint32_t\
    \ sadb_spirange_min;\n                   uint32_t sadb_spirange_max;\n       \
    \            uint32_t sadb_spirange_reserved;\n           };\n           /* sizeof(struct\
    \ sadb_spirange) == 16 */\n   sadb_spirange_min\n                   The minimum\
    \ acceptable SPI value.\n   sadb_spirange_max\n                   The maximum\
    \ acceptable SPI value. The maximum MUST\n                   be greater than or\
    \ equal to the minimum.\n"
- title: 2.4 Illustration of Message Layout
  contents:
  - "2.4 Illustration of Message Layout\n   The following shows how the octets are\
    \ laid out in a PF_KEY message.\n   Optional fields are indicated as such.\n \
    \  The base header is as follows:\n     0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2\
    \ 3 4 5 6 7 0 1 2 3 4 5 6 7\n    +---------------+---------------+---------------+---------------+\n\
    \    |  ...version   | sadb_msg_type | sadb_msg_errno| ...msg_satype |\n    +---------------+---------------+---------------+---------------+\n\
    \    |          sadb_msg_len         |       sadb_msg_reserved       |\n    +---------------+---------------+---------------+---------------+\n\
    \    |                         sadb_msg_seq                          |\n    +---------------+---------------+---------------+---------------+\n\
    \    |                         sadb_msg_pid                          |\n    +---------------+---------------+---------------+---------------+\n\
    \   The base header may be followed by one or more of the following\n   extension\
    \ fields, depending on the values of various base header\n   fields.  The following\
    \ fields are ordered such that if they appear,\n   they SHOULD appear in the order\
    \ presented below.\n   An extension field MUST not be repeated.  If there is a\
    \ situation\n   where an extension MUST be repeated, it should be brought to the\n\
    \   attention of the authors.\n   The Association extension\n       0 1 2 3 4\
    \ 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7\n       +---------------+---------------+---------------+---------------+\n\
    \       |          sadb_sa_len          |        sadb_sa_exttype        |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |                          sadb_sa_spi                          |\n      \
    \ +---------------+---------------+---------------+---------------+\n       |\
    \   ...replay   | sadb_sa_state | sadb_sa_auth  |sadb_sa_encrypt|\n       +---------------+---------------+---------------+---------------+\n\
    \       |                         sadb_sa_flags                         |\n  \
    \     +---------------+---------------+---------------+---------------+\n   The\
    \ Lifetime extension\n       +---------------+---------------+---------------+---------------+\n\
    \       |         sadb_lifetime_len     |    sadb_lifetime_exttype      |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |                   sadb_lifetime_allocations                   |\n      \
    \ +---------------+---------------+---------------+---------------+\n       +---------------+---------------+---------------+---------------+\n\
    \       |                    sadb_lifetime_bytes                        |\n  \
    \     |                           (64 bits)                           |\n    \
    \   +---------------+---------------+---------------+---------------+\n      \
    \ |                    sadb_lifetime_addtime                      |\n       |\
    \                           (64 bits)                           |\n       +---------------+---------------+---------------+---------------+\n\
    \       |                    sadb_lifetime_usetime                      |\n  \
    \     |                           (64 bits)                           |\n    \
    \   +---------------+---------------+---------------+---------------+\n   The\
    \ Address extension\n       +---------------+---------------+---------------+---------------+\n\
    \       |       sadb_address_len        |     sadb_address_exttype      |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   | _address_proto| ..._prefixlen |     sadb_address_reserved     |\n      \
    \ +---------------+---------------+---------------+---------------+\n       >\
    \     Some form of 64-bit aligned struct sockaddr goes here.    <\n       +---------------+---------------+---------------+---------------+\n\
    \   The Key extension\n       +---------------+---------------+---------------+---------------+\n\
    \       |         sadb_key_len          |         sadb_key_exttype      |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |        sadb_key_bits          |        sadb_key_reserved      |\n      \
    \ +---------------+---------------+---------------+---------------+\n       >\
    \    A key, padded to 64-bits, most significant bits to least.  >\n       +---------------+---------------+---------------+---------------+\n\
    \   The Identity extension\n       +---------------+---------------+---------------+---------------+\n\
    \       |        sadb_ident_len         |      sadb_ident_exttype       |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |        sadb_ident_type        |      sadb_ident_reserved      |\n      \
    \ +---------------+---------------+---------------+---------------+\n       |\
    \                         sadb_ident_id                         |\n       |  \
    \                         (64 bits)                           |\n       +---------------+---------------+---------------+---------------+\n\
    \       >  A null-terminated C-string which MUST be padded out for      >\n  \
    \     <  64-bit alignment.                                            <\n    \
    \   +---------------+---------------+---------------+---------------+\n   The\
    \ Sensitivity extension\n       +---------------+---------------+---------------+---------------+\n\
    \       |         sadb_sens_len         |      sadb_sens_exttype        |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |                         sadb_sens_dpd                         |\n      \
    \ +---------------+---------------+---------------+---------------+\n       |\
    \ ...sens_level | ...sens_len   |..._integ_level| ..integ_len   |\n       +---------------+---------------+---------------+---------------+\n\
    \       |                       sadb_sens_reserved                      |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   >    The sensitivity bitmap, followed immediately by the        <\n      \
    \ <    integrity bitmap, each is an array of uint64_t.            >\n       +---------------+---------------+---------------+---------------+\n\
    \   The Proposal extension\n       +---------------+---------------+---------------+---------------+\n\
    \       |         sadb_prop_len         |       sadb_prop_exttype       |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |...prop_replay |           sadb_prop_reserved                  |\n      \
    \ +---------------+---------------+---------------+---------------+\n       >\
    \     One or more combinations, specified as follows...         <\n       +---------------+---------------+---------------+---------------+\n\
    \       Combination\n       +---------------+---------------+---------------+---------------+\n\
    \       |sadb_comb_auth |sadb_comb_encr |        sadb_comb_flags        |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |    sadb_comb_auth_minbits     |     sadb_comb_auth_maxbits    |\n      \
    \ +---------------+---------------+---------------+---------------+\n       |\
    \   sadb_comb_encrypt_minbits   |    sadb_comb_encrypt_maxbits  |\n       +---------------+---------------+---------------+---------------+\n\
    \       |                       sadb_comb_reserved                      |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |                   sadb_comb_soft_allocations                  |\n      \
    \ +---------------+---------------+---------------+---------------+\n       |\
    \                   sadb_comb_hard_allocations                  |\n       +---------------+---------------+---------------+---------------+\n\
    \       |                      sadb_comb_soft_bytes                     |\n  \
    \     |                           (64 bits)                           |\n    \
    \   +---------------+---------------+---------------+---------------+\n      \
    \ |                      sadb_comb_hard_bytes                     |\n       |\
    \                           (64 bits)                           |\n       +---------------+---------------+---------------+---------------+\n\
    \       |                     sadb_comb_soft_addtime                    |\n  \
    \     |                           (64 bits)                           |\n    \
    \   +---------------+---------------+---------------+---------------+\n      \
    \ +---------------+---------------+---------------+---------------+\n       |\
    \                     sadb_comb_hard_addtime                    |\n       |  \
    \                         (64 bits)                           |\n       +---------------+---------------+---------------+---------------+\n\
    \       |                     sadb_comb_soft_usetime                    |\n  \
    \     |                           (64 bits)                           |\n    \
    \   +---------------+---------------+---------------+---------------+\n      \
    \ |                     sadb_comb_hard_usetime                    |\n       |\
    \                           (64 bits)                           |\n       +---------------+---------------+---------------+---------------+\n\
    \   The Supported Algorithms extension\n       +---------------+---------------+---------------+---------------+\n\
    \       |      sadb_supported_len       |     sadb_supported_exttype    |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |                    sadb_supported_reserved                    |\n      \
    \ +---------------+---------------+---------------+---------------+\n      Followed\
    \ by one or more Algorithm Descriptors\n       +---------------+---------------+---------------+---------------+\n\
    \       |  sadb_alg_id  | sadb_alg_ivlen|       sadb_alg_minbits        |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |        sadb_alg_maxbits       |       sadb_alg_reserved       |\n      \
    \ +---------------+---------------+---------------+---------------+\n   The SPI\
    \ Range extension\n       +---------------+---------------+---------------+---------------+\n\
    \       |       sadb_spirange_len       |     sadb_spirange_exttype     |\n  \
    \     +---------------+---------------+---------------+---------------+\n    \
    \   |                      sadb_spirange_min                        |\n      \
    \ +---------------+---------------+---------------+---------------+\n       |\
    \                      sadb_spirange_max                        |\n       +---------------+---------------+---------------+---------------+\n\
    \       |                    sadb_spirange_reserved                     |\n  \
    \     +---------------+---------------+---------------+---------------+\n"
- title: 3 Symbolic Names
  contents:
  - "3 Symbolic Names\n   This section defines various symbols used with PF_KEY and\
    \ the\n   semantics associated with each symbol.  Applications MUST use the\n\
    \   symbolic names in order to be portable.  The numeric definitions\n   shown\
    \ are for illustrative purposes, unless explicitly stated\n   otherwise.  The\
    \ numeric definition MAY vary on other systems.  The\n   symbolic name MUST be\
    \ kept the same for all conforming\n   implementations.\n"
- title: 3.1 Message Types
  contents:
  - "3.1 Message Types\n   The following message types are used with PF_KEY.  These\
    \ are defined\n   in the file <net/pfkeyv2.h>.\n           #define SADB_RESERVED\
    \    0\n           #define SADB_GETSPI      1\n           #define SADB_UPDATE\
    \      2\n           #define SADB_ADD         3\n           #define SADB_DELETE\
    \      4\n           #define SADB_GET         5\n           #define SADB_ACQUIRE\
    \     6\n           #define SADB_REGISTER    7\n           #define SADB_EXPIRE\
    \      8\n           #define SADB_FLUSH       9\n           #define SADB_DUMP\
    \        10   /* not used normally */\n           #define SADB_MAX         10\n\
    \   Each message has a behavior.  A behavior is defined as where the\n   initial\
    \ message travels (e.g. user to kernel), and what subsequent\n   actions are expected\
    \ to take place.  Contents of messages are\n   illustrated as:\n   <base, REQUIRED\
    \ EXTENSION, REQ., (OPTIONAL EXT.,) (OPT)>\n   The SA extension is sometimes used\
    \ only for its SPI field.  If all\n   other fields MUST be ignored, this is represented\
    \ by \"SA(*)\".\n   The lifetime extensions are represented with one to three\
    \ letters\n   after the word \"lifetime,\" representing (H)ARD, (S)OFT, and\n\
    \   (C)URRENT.\n   The address extensions are represented with one to three letters\n\
    \   after the word \"address,\" representing (S)RC, (D)ST, (P)ROXY.\n       NOTE:\
    \ Some security association types do not use a source\n              address for\
    \ SA identification, where others do.  This may\n              cause EEXIST errors\
    \ for some SA types where others do not\n              report collisions.  It\
    \ is expected that application\n              authors know enough about the underlying\
    \ security\n              association types to understand these differences.\n\
    \   The key extensions are represented with one or two letters after the\n   word\
    \ \"key,\" representing (A)UTH and (E)NCRYPT.\n   The identity extensions are\
    \ represented with one or two letters after\n   the word \"identity,\" representing\
    \ (S)RC and (D)ST.\n   In the case of an error, only the base header is returned.\n\
    \   Note that any standard error could be returned for any message.\n   Typically,\
    \ they will be either one of the errors specifically listed\n   in the description\
    \ for a message or one of the following:\n           EINVAL  Various message improprieties,\
    \ including SPI ranges\n                   that are malformed.\n           ENOMEM\
    \  Needed memory was not available.\n           ENOBUFS Needed memory was not\
    \ available.\n           EMSGSIZ The message exceeds the maximum length allowed.\n"
- title: 3.1.1 SADB_GETSPI
  contents:
  - "3.1.1 SADB_GETSPI\n   The SADB_GETSPI message allows a process to obtain a unique\
    \ SPI value\n   for given security association type, source address, and destination\n\
    \   address.  This message followed by an SADB_UPDATE is one way to\n   create\
    \ a security association (SADB_ADD is the other method).  The\n   process specifies\
    \ the type in the base header, the source and\n   destination address in address\
    \ extension.  If the SADB_GETSPI message\n   is in response to a kernel-generated\
    \ SADB_ACQUIRE, the sadb_msg_seq\n   MUST be the same as the SADB_ACQUIRE message.\
    \  The application may\n   also specify the SPI.  This is done by having the kernel\
    \ select\n   within a range of SPI values by using the SPI range extension.  To\n\
    \   specify a single SPI value to be verified, the application sets the\n   high\
    \ and low values to be equal.  Permitting range specification is\n   important\
    \ because the kernel can allocate an SPI value based on what\n   it knows about\
    \ SPI values already in use.  The kernel returns the\n   same message with the\
    \ allocated SPI value stored in the spi field of\n   an association extension.\
    \  The allocate SPI (and destination address)\n   refer to a LARVAL security association.\
    \  An SADB_UPDATE message can\n   later be used to add an entry with the requested\
    \ SPI value.\n   It is recommended that associations that are created with SADB_GETSPI\n\
    \   SHOULD be automatically deleted within a fixed amount of time if they\n  \
    \ are not updated by an SADB_UPDATE message.  This allows SA storage\n   not to\
    \ get cluttered with larval associations.\n     The message behavior of the SADB_GETSPI\
    \ message is:\n        Send an SADB_GETSPI message from a user process to the\
    \ kernel.\n        <base, address, SPI range>\n        The kernel returns the\
    \ SADB_GETSPI message to all listening\n        processes.\n        <base, SA(*),\
    \ address(SD)>\n     Errors:\n        EEXIST  Requested SPI or SPI range is not\
    \ available or already\n                used.\n"
- title: 3.1.2 SADB_UPDATE Message
  contents:
  - "3.1.2 SADB_UPDATE Message\n   The SADB_UPDATE message allows a process to update\
    \ the information in\n   an existing Security Association.  Since SADB_GETSPI\
    \ does not allow\n   setting of certain parameters, this message is needed to\
    \ fully form\n   the SADB_SASTATE_LARVAL security association created with\n \
    \  SADB_GETSPI.  The format of the update message is a base header,\n   followed\
    \ by an association header and possibly by several extension\n   headers. The\
    \ kernel searches for the security association with the\n   same type, spi, source\
    \ address and destination address specified in\n   the message and updates the\
    \ Security Association information using\n   the content of the SADB_UPDATE message.\n\
    \   The kernel MAY disallow SADB_UPDATE to succeed unless the message is\n   issued\
    \ from the same socket that created the security association.\n   Such enforcement\
    \ significantly reduces the chance of accidental\n   changes to an in-use security\
    \ association.  Malicious trusted parties\n   could still issue an SADB_FLUSH\
    \ or SADB_DELETE message, but deletion\n   of associations is more easily detected\
    \ and less likely to occur\n   accidentally than an erroneous SADB_UPDATE. The\
    \ counter argument to\n   supporting this behavior involves the case where a user-space\
    \ key\n   management application fails and is restarted.  The new instance of\n\
    \   the application will not have the same socket as the creator of the\n   security\
    \ association.\n   The kernel MUST sanity check all significant values submitted\
    \ in an\n   SADB_UPDATE message before changing the SA in its database and MUST\n\
    \   return EINVAL if any of the values are invalid.  Examples of checks\n   that\
    \ should be performed are DES key parity bits, key length\n   checking, checks\
    \ for keys known to be weak for the specified\n   algorithm, and checks for flags\
    \ or parameters known to be\n   incompatible with the specified algorithm.\n \
    \  Only SADB_SASTATE_MATURE SAs may be submitted in an SADB_UPDATE\n   message.\
    \  If the original SA is an SADB_SASTATE_LARVAL SA, then any\n   value in the\
    \ SA may be changed except for the source address,\n   destination address, and\
    \ SPI.  If the original SA is an\n   SADB_SASTATE_DEAD SA, any attempt to perform\
    \ an SADB_UPDATE on the SA\n   MUST return EINVAL.  It is not valid for established\
    \ keying or\n   algorithm information to change without the SPI changing, which\
    \ would\n   require creation of a new SA rather than a change to an existing SA.\n\
    \   Once keying and algorithm information is negotiated, address and\n   identity\
    \ information is fixed for the SA. Therefore, if the original\n   SA is an SADB_SASTATE_MATURE\
    \ or DYING SA, only the sadb_sa_state\n   field in the SA header and lifetimes\
    \ (hard, soft, and current) may be\n   changed and any attempt to change other\
    \ values MUST result in an\n   error return of EINVAL.\n     The message behavior\
    \ of the SADB_UPDATE message is:\n        Send an SADB_UPDATE message from a user\
    \ process to the kernel.\n        <base, SA, (lifetime(HSC),) address(SD), (address(P),)\n\
    \          key(AE), (identity(SD),) (sensitivity)>\n        The kernel returns\
    \ the SADB_UPDATE message to all listening\n        processes.\n        <base,\
    \ SA, (lifetime(HSC),) address(SD), (address(P),)\n          (identity(SD),) (sensitivity)>\n\
    \   The keying material is not returned on the message from the kernel to\n  \
    \ listening sockets because listeners might not have the privileges to\n   see\
    \ such keying material.\n     Errors:\n         ESRCH   The security association\
    \ to be updated was not found.\n         EINVAL  In addition to other possible\
    \ causes, this error is\n                 returned if sanity checking on the SA\
    \ values (such\n                 as the keys) fails.\n         EACCES  Insufficient\
    \ privilege to update entry. The socket\n                 issuing the SADB_UPDATE\
    \ is not creator of the entry\n                     to be updated.\n"
- title: 3.1.3 SADB_ADD
  contents:
  - "3.1.3 SADB_ADD\n   The SADB_ADD message is nearly identical to the SADB_UPDATE\
    \ message,\n   except that it does not require a previous call to SADB_GETSPI.\
    \  The\n   SADB_ADD message is used in manual keying applications, and in other\n\
    \   cases where the uniqueness of the SPI is known immediately.\n   An SADB_ADD\
    \ message is also used when negotiation is finished, and\n   the second of a pair\
    \ of associations is added.  The SPI for this\n   association was determined by\
    \ the peer machine.  The sadb_msg_seq\n   MUST be set to the value set in a kernel-generated\
    \ SADB_ACQUIRE so\n   that both associations in a pair are bound to the same ACQUIRE\n\
    \   request.\n   The kernel MUST sanity check all used fields in the SA submitted\
    \ in\n   an SADB_ADD message before adding the SA to its database and MUST\n \
    \  return EINVAL if any of the values are invalid.\n   Only SADB_SASTATE_MATURE\
    \ SAs may be submitted in an SADB_ADD message.\n   SADB_SASTATE_LARVAL SAs are\
    \ created by SADB_GETSPI and it is not\n   sensible to add a new SA in the DYING\
    \ or SADB_SASTATE_DEAD state.\n   Therefore, the sadb_sa_state field of all submitted\
    \ SAs MUST be\n   SADB_SASTATE_MATURE and the kernel MUST return an error if this\
    \ is\n   not true.\n     The message behavior of the SADB_ADD message is:\n  \
    \      Send an SADB_ADD message from a user process to the kernel.\n        <base,\
    \ SA, (lifetime(HS),) address(SD), (address(P),)\n          key(AE), (identity(SD),)\
    \ (sensitivity)>\n        The kernel returns the SADB_ADD message to all listening\n\
    \        processes.\n        <base, SA, (lifetime(HS),) address(SD), (identity(SD),)\n\
    \          (sensitivity)>\n   The keying material is not returned on the message\
    \ from the kernel to\n   listening sockets because listeners may not have the\
    \ privileges to\n   see such keying material.\n     Errors:\n        EEXIST  The\
    \ security association that was to be added already\n                exists.\n\
    \        EINVAL  In addition to other possible causes, this error is\n       \
    \         returned if sanity checking on the SA values (such\n               \
    \ as the keys) fails.\n"
- title: 3.1.4 SADB_DELETE
  contents:
  - "3.1.4 SADB_DELETE\n   The SADB_DELETE message causes the kernel to delete a Security\n\
    \   Association from the key table.  The delete message consists of the\n   base\
    \ header followed by the association, and the source and\n   destination sockaddrs\
    \ in the address extension.  The kernel deletes\n   the security association matching\
    \ the type, spi, source address, and\n   destination address in the message.\n\
    \     The message behavior for SADB_DELETE is as follows:\n        Send an SADB_DELETE\
    \ message from a user process to the kernel.\n        <base, SA(*), address(SD)>\n\
    \        The kernel returns the SADB_DELETE message to all listening\n       \
    \ processes.\n        <base, SA(*), address(SD)>\n"
- title: 3.1.5 SADB_GET
  contents:
  - "3.1.5 SADB_GET\n   The SADB_GET message allows a process to retrieve a copy of\
    \ a\n   Security Association from the kernel's key table.  The get message\n \
    \  consists of the base header follows by the relevant extension fields.\n   The\
    \ Security Association matching the type, spi, source address, and\n   destination\
    \ address is returned.\n      The message behavior of the SADB_GET message is:\n\
    \         Send an SADB_GET message from a user process to the kernel.\n      \
    \   <base, SA(*), address(SD)>\n         The kernel returns the SADB_GET message\
    \ to the socket that sent\n         the SADB_GET message.\n         <base, SA,\
    \ (lifetime(HSC),) address(SD), (address(P),) key(AE),\n           (identity(SD),)\
    \ (sensitivity)>\n     Errors:\n         ESRCH   The sought security association\
    \ was not found.\n"
- title: 3.1.6 SADB_ACQUIRE
  contents:
  - "3.1.6 SADB_ACQUIRE\n   The SADB_ACQUIRE message is typically sent only by the\
    \ kernel to key\n   socket listeners who have registered their key socket (see\n\
    \   SADB_REGISTER message).  SADB_ACQUIRE messages can be sent by\n   application-level\
    \ consumers of security associations (such as an\n   OSPFv2 implementation that\
    \ uses OSPF security).  The SADB_ACQUIRE\n   message is a base header along with\
    \ an address extension, possibly an\n   identity extension, and a proposal extension.\
    \ The proposed situation\n   contains a list of desirable algorithms that can\
    \ be used if the\n   algorithms in the base header are not available.  The values\
    \ for the\n   fields in the base header and in the security association data which\n\
    \   follows the base header indicate the properties of the Security\n   Association\
    \ that the listening process should attempt to acquire.  If\n   the message originates\
    \ from the kernel (i.e. the sadb_msg_pid is 0),\n   the sadb_msg_seq number MUST\
    \ be used by a subsequent SADB_GETSPI and\n   SADB_UPDATE, or subsequent SADB_ADD\
    \ message to bind a security\n   association to the request.  This avoids the\
    \ race condition of two\n   TCP connections between two IP hosts that each require\
    \ unique\n   associations, and having one steal another's security association.\n\
    \   The sadb_msg_errno and sadb_msg_state fields should be ignored by the\n  \
    \ listening process.\n   The SADB_ACQUIRE message is typically triggered by an\
    \ outbound packet\n   that needs security but for which there is no applicable\
    \ Security\n   Association existing in the key table.  If the packet can be\n\
    \   sufficiently protected by more than one algorithm or combination of\n   options,\
    \ the SADB_ACQUIRE message MUST order the preference of\n   possibilities in the\
    \ Proposal extension.\n   There are three messaging behaviors for SADB_ACQUIRE.\
    \  The first is\n   where the kernel needs a security association (e.g. for IPsec).\n\
    \     The kernel sends an SADB_ACQUIRE message to registered sockets.\n      \
    \  <base, address(SD), (address(P)), (identity(SD),) (sensitivity,)\n        \
    \  proposal>\n        NOTE:   The address(SD) extensions MUST have the port fields\n\
    \                filled in with the port numbers of the session requiring\n  \
    \              keys if appropriate.\n   The second is when, for some reason, key\
    \ management fails, it can\n   send an ACQUIRE message with the same sadb_msg_seq\
    \ as the initial\n   ACQUIRE with a non-zero errno.\n        Send an SADB_ACQUIRE\
    \ to indicate key management failure.\n        <base>\n   The third is where an\
    \ application-layer consumer of security\n   associations (e.g.  an OSPFv2 or\
    \ RIPv2 daemon) needs a security\n   association.\n        Send an SADB_ACQUIRE\
    \ message from a user process to the kernel.\n        <base, address(SD), (address(P),)\
    \ (identity(SD),) (sensitivity,)\n          proposal>\n        The kernel returns\
    \ an SADB_ACQUIRE message to registered\n          sockets.\n        <base, address(SD),\
    \ (address(P),) (identity(SD),) (sensitivity,)\n          proposal>\n        The\
    \ user-level consumer waits for an SADB_UPDATE or SADB_ADD\n        message for\
    \ its particular type, and then can use that\n        association by using SADB_GET\
    \ messages.\n   Errors:\n       EINVAL  Invalid acquire request.\n       EPROTONOSUPPORT\
    \   No KM application has registered with the Key\n               Engine as being\
    \ able to obtain the requested SA type, so\n               the requested SA cannot\
    \ be acquired.\n"
- title: 3.1.7 SADB_REGISTER
  contents:
  - "3.1.7 SADB_REGISTER\n   The SADB_REGISTER message allows an application to register\
    \ its key\n   socket as able to acquire new security associations for the kernel.\n\
    \   SADB_REGISTER allows a socket to receive SADB_ACQUIRE messages for\n   the\
    \ type of security association specified in sadb_msg_satype.  The\n   application\
    \ specifies the type of security association that it can\n   acquire for the kernel\
    \ in the type field of its register message.  If\n   an application can acquire\
    \ multiple types of security association, it\n   MUST register each type in a\
    \ separate message. Only the base header\n   is needed for the register message.\
    \  Key management applications MAY\n   register for a type not known to the kernel,\
    \ because the consumer may\n   be in user-space (e.g. OSPFv2 security).\n   The\
    \ reply of the SADB_REGISTER message contains a supported algorithm\n   extension.\
    \  That field contains an array of supported algorithms, one\n   per octet.  This\
    \ allows key management applications to know what\n   algorithm are supported\
    \ by the kernel.\n   In an environment where algorithms can be dynamically loaded\
    \ and\n   unloaded, an asynchronous SADB_REGISTER reply MAY be generated.  The\n\
    \   list of supported algorithms MUST be a complete list, so the\n   application\
    \ can make note of omissions or additions.\n     The messaging behavior of the\
    \ SADB_REGISTER message is:\n        Send an SADB_REGISTER message from a user\
    \ process to the kernel.\n        <base>\n        The kernel returns an SADB_REGISTER\
    \ message to registered\n        sockets, with algorithm types supported by the\
    \ kernel being\n        indicated in the supported algorithms field.\n       \
    \ NOTE:  This message may arrive asynchronously due to an\n               algorithm\
    \ being loaded or unloaded into a dynamically\n               linked kernel.\n\
    \        <base, supported>\n"
- title: 3.1.8 SADB_EXPIRE Message
  contents:
  - "3.1.8 SADB_EXPIRE Message\n   The operating system kernel is responsible for\
    \ tracking SA\n   expirations for security protocols that are implemented inside\
    \ the\n   kernel.  If the soft limit or hard limit of a Security Association\n\
    \   has expired for a security protocol implemented inside the kernel,\n   then\
    \ the kernel MUST issue an SADB_EXPIRE message to all key socket\n   listeners.\
    \  If the soft limit or hard limit of a Security Association\n   for a user-level\
    \ security protocol has expired, the user-level\n   protocol SHOULD issue an SADB_EXPIRE\
    \ message.\n   The base header will contain the security association information\n\
    \   followed by the source sockaddr, destination sockaddr, (and, if\n   present,\
    \ internal sockaddr,) (and, if present, one or both\n   compartment bitmaps).\n\
    \   The lifetime extension of an SADB_EXPIRE message is important to\n   indicate\
    \ which lifetime expired.  If a HARD lifetime extension is\n   included, it indicates\
    \ that the HARD lifetime expired.  This means\n   the association MAY be deleted\
    \ already from the SADB.  If a SOFT\n   lifetime extension is included, it indicates\
    \ that the SOFT lifetime\n   expired.  The CURRENT lifetime extension will indicate\
    \ the current\n   status, and comparisons to the HARD or SOFT lifetime will indicate\n\
    \   which limit was reached.  HARD lifetimes MUST take precedence over\n   SOFT\
    \ lifetimes, meaning if the HARD and SOFT lifetimes are the same,\n   the HARD\
    \ lifetime will appear on the EXPIRE message.  The\n   pathological case of HARD\
    \ lifetimes being shorter than SOFT lifetimes\n   is handled such that the SOFT\
    \ lifetime will never expire.\n     The messaging behavior of the SADB_EXPIRE\
    \ message is:\n           The kernel sends an SADB_EXPIRE message to all listeners\
    \ when\n           the soft limit of a security association has been expired.\n\
    \           <base, SA, lifetime(C and one of HS), address(SD)>\n   Note that the\
    \ SADB_EXPIRE message is ONLY sent by the kernel to the\n   KMd.  It is a one-way\
    \ informational message that does not have a\n   reply.\n"
- title: 3.1.9 SADB_FLUSH
  contents:
  - "3.1.9 SADB_FLUSH\n   The SADB_FLUSH message causes the kernel to delete all entries\
    \ in its\n   key table for a certain sadb_msg_satype.  Only the base header is\n\
    \   required for a flush message.  If sadb_msg_satype is filled in with a\n  \
    \ specific value, only associations of that type are deleted.  If it is\n   filled\
    \ in with SADB_SATYPE_UNSPEC, ALL associations are deleted.\n     The messaging\
    \ behavior for SADB_FLUSH is:\n           Send an SADB_FLUSH message from a user\
    \ process to the kernel.\n           <base>\n           The kernel will return\
    \ an SADB_FLUSH message to all listening\n           sockets.\n           <base>\n\
    \           The reply message happens only after the actual flushing\n       \
    \    of security associations has been attempted.\n"
- title: 3.1.10 SADB_DUMP
  contents:
  - "3.1.10 SADB_DUMP\n   The SADB_DUMP message causes the kernel to dump the operating\n\
    \   system's entire Key Table to the requesting key socket. As in\n   SADB_FLUSH,\
    \ if a sadb_msg_satype value is in the message, only\n   associations of that\
    \ type will be dumped. If SADB_SATYPE_UNSPEC is\n   specified, all associations\
    \ will be dumped. Each Security Association\n   is returned in its own SADB_DUMP\
    \ message.  A SADB_DUMP message with a\n   sadb_seq field of zero indicates the\
    \ end of the dump transaction. The\n   dump message is used for debugging purposes\
    \ only and is not intended\n   for production use.\n   Support for the dump message\
    \ MAY be discontinued in future versions\n   of PF_KEY.  Key management applications\
    \ MUST NOT depend on this\n   message for basic operation.\n     The messaging\
    \ behavior for SADB_DUMP is:\n           Send an SADB_DUMP message from a user\
    \ process to the kernel.\n           <base>\n           Several SADB_DUMP messages\
    \ will return from the kernel to the\n           sending socket.\n           <base,\
    \ SA, (lifetime (HSC),) address(SD), (address(P),)\n             key(AE), (identity(SD),)\
    \ (sensitivity)>\n"
- title: 3.2 Security Association Flags
  contents:
  - "3.2 Security Association Flags\n   The Security Association's flags are a bitmask\
    \ field.  These flags\n   also appear in a combination that is part of a PROPOSAL\
    \ extension.\n   The related symbolic definitions below should be used in order\
    \ that\n   applications will be portable:\n     #define SADB_SAFLAGS_PFS 1   \
    \ /* perfect forward secrecy */\n   The SADB_SAFLAGS_PFS flag indicates to key\
    \ management that this\n   association should have perfect forward secrecy in\
    \ its key.  (In\n   other words, any given session key cannot be determined by\n\
    \   cryptanalysis of previous session keys or some master key.)\n"
- title: 3.3 Security Association States
  contents:
  - "3.3 Security Association States\n   The security association state field is an\
    \ integer that describes the\n   states of a security association.  They are:\n\
    \     #define SADB_SASTATE_LARVAL   0\n     #define SADB_SASTATE_MATURE   1\n\
    \     #define SADB_SASTATE_DYING    2\n     #define SADB_SASTATE_DEAD     3\n\
    \     #define SADB_SASTATE_MAX      3\n   A SADB_SASTATE_LARVAL security association\
    \ is one that was created by\n   the SADB_GETSPI message.  A SADB_SASTATE_MATURE\
    \ association is one\n   that was updated with the SADB_UPDATE message or added\
    \ with the\n   SADB_ADD message.  A DYING association is one whose soft lifetime\
    \ has\n   expired.  A SADB_SASTATE_DEAD association is one whose hard lifetime\n\
    \   has expired, but hasn't been reaped by system garbage collection.  If\n  \
    \ a consumer of security associations has to extend an association\n   beyond\
    \ its normal lifetime (e.g. OSPF Security) it MUST only set the\n   soft lifetime\
    \ for an association.\n"
- title: 3.4 Security Association Types
  contents:
  - "3.4 Security Association Types\n   This defines the type of Security Association\
    \ in this message.  The\n   symbolic names are always the same, even on different\n\
    \   implementations.  Applications SHOULD use the symbolic name in order\n   to\
    \ have maximum portability across different implementations.  These\n   are defined\
    \ in the file <net/pfkeyv2.h>.\n     #define SADB_SATYPE_UNSPEC        0\n   \
    \  #define SADB_SATYPE_AH            2  /* RFC-1826 */\n     #define SADB_SATYPE_ESP\
    \           3  /* RFC-1827 */\n     #define SADB_SATYPE_RSVP          5  /* RSVP\
    \ Authentication */\n     #define SADB_SATYPE_OSPFV2        6  /* OSPFv2 Authentication\
    \ */\n     #define SADB_SATYPE_RIPV2         7  /* RIPv2 Authentication */\n \
    \    #define SADB_SATYPE_MIP           8  /* Mobile IP Auth. */\n     #define\
    \ SADB_SATYPE_MAX           8\n   SADB_SATYPE_UNSPEC is defined for completeness\
    \ and means no specific\n   type of security association.  This type is never\
    \ used with PF_KEY\n   SAs.\n   SADB_SATYPE_AH is for the IP Authentication Header\
    \ [Atk95b].\n   SADB_SATYPE_ESP  is  for  the  IP  Encapsulating   Security  \
    \ Payload\n   [Atk95c].\n   SADB_SATYPE_RSVP is for the RSVP Integrity Object.\n\
    \   SADB_SATYPE_OSPFV2 is for OSPFv2 Cryptographic authentication\n   [Moy98].\n\
    \   SADB_SATYPE_RIPV2 is for RIPv2 Cryptographic authentication [BA97].\n   SADB_SATYPE_MIP\
    \ is for Mobile IP's authentication extensions [Per97].\n   SADB_SATYPE_MAX is\
    \ always set to the highest valid numeric value.\n"
- title: 3.5 Algorithm Types
  contents:
  - "3.5 Algorithm Types\n   The algorithm type is interpreted in the context of the\
    \ Security\n   Association type defined above.  The numeric value might vary between\n\
    \   implementations, but the symbolic name MUST NOT vary between\n   implementations.\
    \  Applications should use the symbolic name in order\n   to have maximum portability\
    \ to various implementations.\n   Some of the algorithm types defined below might\
    \ not be standardized\n   or might be deprecated in the future.  To obtain an\
    \ assignment for a\n   symbolic name, contact the authors.\n     The symbols below\
    \ are defined in <net/pfkeyv2.h>.\n           /* Authentication algorithms */\n\
    \           #define SADB_AALG_NONE          0\n           #define SADB_AALG_MD5HMAC\
    \       2\n           #define SADB_AALG_SHA1HMAC      3\n           #define SADB_AALG_MAX\
    \           3\n           /* Encryption algorithms */\n           #define SADB_EALG_NONE\
    \          0\n           #define SADB_EALG_DESCBC        2\n           #define\
    \ SADB_EALG_3DESCBC       3\n           #define SADB_EALG_NULL          11\n \
    \          #define SADB_EALG_MAX           11\n   The algorithm for SADB_AALG_MD5_HMAC\
    \ is defined in [MG98a].  The\n   algorithm for SADB_AALG_SHA1HMAC is defined\
    \ in [MG98b].  The\n   algorithm for SADB_EALG_DESCBC is defined in [MD98].  SADB_EALG_NULL\n\
    \   is the NULL encryption algorithm, defined in [GK98].  The\n   SADB_EALG_NONE\
    \ value is not to be used in any security association\n   except those which have\
    \ no possible encryption algorithm in them\n   (e.g. IPsec AH).\n"
- title: 3.6 Extension Header Values
  contents:
  - "3.6 Extension Header Values\n   To briefly recap the extension header values:\n\
    \           #define SADB_EXT_RESERVED          0\n           #define SADB_EXT_SA\
    \                1\n           #define SADB_EXT_LIFETIME_CURRENT  2\n        \
    \   #define SADB_EXT_LIFETIME_HARD     3\n           #define SADB_EXT_LIFETIME_SOFT\
    \     4\n           #define SADB_EXT_ADDRESS_SRC       5\n           #define SADB_EXT_ADDRESS_DST\
    \       6\n           #define SADB_EXT_ADDRESS_PROXY     7\n           #define\
    \ SADB_EXT_KEY_AUTH          8\n           #define SADB_EXT_KEY_ENCRYPT      \
    \ 9\n           #define SADB_EXT_IDENTITY_SRC      10\n           #define SADB_EXT_IDENTITY_DST\
    \      11\n           #define SADB_EXT_SENSITIVITY       12\n           #define\
    \ SADB_EXT_PROPOSAL          13\n           #define SADB_EXT_SUPPORTED_AUTH  \
    \  14\n           #define SADB_EXT_SUPPORTED_ENCRYPT 15\n           #define SADB_EXT_SPIRANGE\
    \          16\n           #define SADB_EXT_MAX               16\n"
- title: 3.7 Identity Extension Values
  contents:
  - "3.7 Identity Extension Values\n   Each identity can have a certain type.\n  \
    \         #define SADB_IDENTTYPE_RESERVED  0\n           #define SADB_IDENTTYPE_PREFIX\
    \    1\n           #define SADB_IDENTTYPE_FQDN      2\n           #define SADB_IDENTTYPE_USERFQDN\
    \  3\n           #define SADB_IDENTTYPE_MAX       3\n   The PREFIX identity string\
    \ consists of a network address followed by a\n   forward slash and a prefix length.\
    \ The network address is in a\n   printable numeric form appropriate for the protocol\
    \ family.  The\n   prefix length is a decimal number greater than or equal to\
    \ zero and\n   less than the number of bits in the network address. It indicates\
    \ the\n   number of bits in the network address that are significant; all bits\n\
    \   in the network address that are not significant MUST be set to zero.\n   Note\
    \ that implementations MUST parse the contents of the printable\n   address into\
    \ a binary form for comparison purposes because multiple\n   printable strings\
    \ are valid representations of the same address in\n   many protocol families\
    \ (for example, some allow leading zeros and some\n   have letters that are case\
    \ insensitive). Examples of PREFIX identities\n   are \"199.33.248.64/27\" and\
    \ \"3ffe::1/128\". If the source or destination\n   identity is a PREFIX identity,\
    \ the source or destination address for\n   the SA (respectively) MUST be within\
    \ that prefix.  The sadb_ident_id\n   field is zeroed for these identity types.\n\
    \   The FQDN identity string contains a fully qualified domain name. An\n   example\
    \ FQDN identity is \"ministry-of-truth.inner.net\".  The\n   sadb_ident_id field\
    \ is zeroed for these identity types.\n   The UserFQDN identity consists of a\
    \ text string in the format commonly\n   used for Internet-standard electronic\
    \ mail. The syntax is the text\n   username, followed by the \"@\" character,\
    \ followed in turn by the\n   appropriate fully qualified domain name.  This identity\
    \ specifies both\n   a username and an associated FQDN. There is no requirement\
    \ that this\n   string specify a mailbox valid for SMTP or other electronic mail\n\
    \   use. This identity is useful with protocols supporting user-oriented\n   keying.\
    \  It is a convenient identity form because the DNS Security\n   extensions can\
    \ be used to distribute signed public key values by\n   associating KEY and SIG\
    \ records with an appropriate MB DNS record. An\n   example UserFQDN identity\
    \ is \"julia@ministry-of-love.inner.net\".  The\n   sadb_ident_id field is used\
    \ to contain a POSIX user id in the absence\n   of an identity string itself so\
    \ that a user-level application can use\n   the getpwuid{,_r}() routine to obtain\
    \ a textual user login id.  If a\n   string is present, it SHOULD match the numeric\
    \ value in the\n   sadb_ident_id field.  If it does not match, the string SHOULD\
    \ override\n   the numeric value.\n"
- title: 3.8 Sensitivity Extension Values
  contents:
  - "3.8 Sensitivity Extension Values\n   The only field currently defined in the\
    \ sensitivity extension is the\n   sadb_sens_dpd, which represents the data protection\
    \ domain.  The other\n   data in the sensitivity extension is based off the sadb_sens_dpd\n\
    \   value.\n   The DP/DOI is defined to be the same as the \"Labeled Domain Identifier\n\
    \   Value\" of the IP Security DOI specification [Pip98]. As noted in that\n \
    \  specification, values in the range 0x80000000 to 0xffffffff\n   (inclusive)\
    \ are reserved for private use and values in the range\n   0x00000001 through\
    \ 0x7fffffff are assigned by IANA.  The all-zeros\n   DP/DOI value is permanently\
    \ reserved to mean that \"no DP/DOI is in\n   use\".\n"
- title: 3.9 Proposal Extension Values
  contents:
  - "3.9 Proposal Extension Values\n   These are already mentioned in the Algorithm\
    \ Types and Security\n   Association Flags sections.\n"
- title: 4 Future Directions
  contents:
  - "4 Future Directions\n   While the current specification for the Sensitivity and\
    \ Integrity\n   Labels is believed to be general enough, if a case should arise\
    \ that\n   can't work with the current specification then this might cause a\n\
    \   change in a future version of PF_KEY.\n   Similarly, PF_KEY might need extensions\
    \ to work with other kinds of\n   Security Associations in future.  It is strongly\
    \ desirable for such\n   extensions to be made in a backwards-compatible manner\
    \ should they be\n   needed.\n   When more experience is gained with certificate\
    \ management, it is\n   possible that the IDENTITY extension will have to be revisited\
    \ to\n   allow a finer grained selection of certificate identities.\n"
- title: 5. Examples
  contents:
  - "5. Examples\n   The following examples illustrate how PF_KEY is used.  The first\n\
    \   example is an IP Security example, where the consumer of the security\n  \
    \ associations is inside an operating system kernel. The second example\n   is\
    \ an OSPF Security example, which illustrates a user-level consumer\n   of security\
    \ associations.  The third example covers things not\n   mentioned by the first\
    \ two examples.  A real system may closely\n   conform to one of these examples,\
    \ or take parts of them.  These\n   examples are purely illustrative, and are\
    \ not intended to mandate a\n   particular implementation method.\n"
- title: 5.1 Simple IP Security Example
  contents:
  - "5.1 Simple IP Security Example\n                     +---------------+    +-------------+\n\
    \                     |Key Mgmt Daemon|    | Application |\n                 \
    \    +---------------+    +-------------+\n                       |          \
    \ |     /\n                       |           |    /\n                       |\
    \           |    |              Applications\n               ======[PF_KEY]====[PF_INET]==========================\n\
    \                       |           |    |              OS Kernel\n          \
    \     +------------+   +-----------------+\n               | Key Engine |   |\
    \ TCP/IP,         |\n               |  or  SADB  |---| including IPsec |\n   \
    \            +------------+   |                 |\n                          \
    \      +-----------------+\n   When the Key Management daemon (KMd) begins.  It\
    \ must tell PF_KEY\n   that it is willing to accept message for the two IPsec\
    \ services, AH\n   and ESP.  It does this by sending down two SADB_REGISTER messages.\n\
    \     KMd->Kernel:         SADB_REGISTER for ESP\n     Kernel->Registered:  SADB_REGISTER\
    \ for ESP, Supported Algorithms\n     KMd->Kernel:         SADB_REGISTER for AH\n\
    \     Kernel->Registered:  SADB_REGISTER for AH, Supported Algorithms\n   Each\
    \ REGISTER message will cause a reply to go to all PF_KEY sockets\n   registered\
    \ for ESP and AH respectively (including the requester).\n   Assume that no security\
    \ associations currently exist for IPsec to\n   use.  Consider when a network\
    \ application begins transmitting data\n   (e.g. a TCP SYN).  Because of policy,\
    \ or the application's request,\n   the kernel IPsec module needs an AH security\
    \ association for this\n   data.  Since there is not one present, the following\
    \ message is\n   generated:\n     Kernel->Registered:  SADB_ACQUIRE for AH, addrs,\
    \ ID, sens,\n                          proposals\n   The KMd reads the ACQUIRE\
    \ message, especially the sadb_msg_seq\n   number.  Before it begins the negotiation,\
    \ it sends down an\n   SADB_GETSPI message with the sadb_msg_seq number equal\
    \ to the one\n   received in the ACQUIRE.  The kernel returns the results of the\n\
    \   GETSPI to all listening sockets.\n     KMd->Kernel:         SADB_GETSPI for\
    \ AH, addr, SPI range\n     Kernel->All:         SADB_GETSPI for AH, assoc, addrs\n\
    \   The KMd may perform a second GETSPI operation if it needs both\n   directions\
    \ of IPsec SPI values.  Now that the KMd has an SPI for at\n   least one of the\
    \ security associations, it begins negotiation.  After\n   deriving keying material,\
    \ and negotiating other parameters, it sends\n   down one (or more) SADB_UPDATE\
    \ messages with the same value in\n   sadb_msg_seq.\n   If a KMd has any error\
    \ at all during its negotiation, it can send\n   down:\n     KMd->Kernel:    \
    \     SADB_ACQUIRE for AH, assoc (with an error)\n     Kernel->All:         SADB_ACQUIRE\
    \ for AH, assoc (same error)\n   but if it succeeds, it can instead:\n     KMd->Kernel:\
    \         SADB_UPDATE for AH, assoc, addrs, keys,\n                          <etc.>\n\
    \     Kernel->All:         SADB_UPDATE for AH, assoc, addrs, <etc.>\n   The results\
    \ of the UPDATE (minus the actual keys) are sent to all\n   listening sockets.\
    \  If only one SPI value was determined locally, the\n   other SPI (since IPsec\
    \ SAs are unidirectional) must be added with an\n   SADB_ADD message.\n     KMd->Kernel:\
    \         SADB_ADD for AH, assoc, addrs, keys, <etc.>\n     Kernel->All:     \
    \    SADB_ADD for AH, assoc, addrs, <etc.>\n   If one of the extensions passed\
    \ down was a Lifetime extension, it is\n   possible at some point an SADB_EXPIRE\
    \ message will arrive when one of\n   the lifetimes has expired.\n     Kernel->All:\
    \         SADB_EXPIRE for AH, assoc, addrs,\n                          Hard or\
    \ Soft, Current, <etc.>\n   The KMd can use this as a clue to begin negotiation,\
    \ or, if it has\n   some say in policy, send an SADB_UPDATE down with a lifetime\n\
    \   extension.\n"
- title: 5.2 Proxy IP Security Example
  contents:
  - "5.2 Proxy IP Security Example\n   Many people are interested in using IP Security\
    \ in a \"proxy\" or\n   \"firewall\" configuration in which an intermediate system\
    \ provides\n   security services for \"inside\" hosts.  In these environments,\
    \ the\n   intermediate systems can use PF_KEY to communicate with key\n   management\
    \ applications almost exactly as they would if they were the\n   actual endpoints.\
    \ The messaging behavior of PF_KEY in these cases is\n   exactly the same as the\
    \ previous example, but the address information\n   is slightly different.\n \
    \    Consider this case:\n                     A ========= B --------- C\n   \
    \  Key:\n               A           \"outside\" host that implements IPsec\n \
    \              B           \"firewall\" that implements IPsec\n              \
    \ C           \"inside\" host that does not implement IPsec\n               ===\
    \         IP_{A<->B} ESP [ IP_{A<->C} ULP ]\n               ---         IP_{A<->C}\
    \ ULP\n   A is a single system that wishes to communicate with the \"inside\"\n\
    \   system C.  B is a \"firewall\" between C and the outside world that\n   will\
    \ do ESP and tunneling on C's behalf.  A discovers that it needs\n   to send traffic\
    \ to C via B through methods not described here (Use of\n   the DNS' KX record\
    \ might be one method for discovering this).\n   For packets that flow from left\
    \ to right, A and B need an IPsec\n   Security Association with:\n           SA\
    \ type of ESP tunnel-mode\n           Source Identity that dominates A (e.g. A's\
    \ address)\n           Destination Identity that dominates B (e.g. B's address)\n\
    \           Source Address of A\n           Destination Address of B\n   For packets\
    \ to flow from right to left, A and B need an IPsec\n   Security Association with:\n\
    \           SA type of ESP tunnel-mode\n           Source Identity that dominates\
    \ C\n           Destination Identity that dominates A\n           Source Address\
    \ of B\n           Destination Address of A\n           Proxy Address of C\n \
    \  For this second SA (for packets flowing from C towards A), node A\n   MUST\
    \ verify that the inner source address is dominated by the Source\n   Identity\
    \ for the SA used with those packets.  If node A does not do\n   this, an adversary\
    \ could forge packets with an arbitrary Source\n   Identity and defeat the packet\
    \ origin protections provided by IPsec.\n     Now consider a slightly more complex\
    \ case:\n               A_1 --|                  |-- D_1\n                   \
    \  |--- B ====== C ---|\n               A_2 --|                  |-- D_2\n   \
    \  Key:\n               A_n     \"inside\" host on net 1 that does not do IPsec.\n\
    \               B       \"firewall\" for net 1 that supports IPsec.\n        \
    \       C       \"firewall\" for net 2 that supports IPsec.\n               D_n\
    \     \"inside\" host on net 2 that does not do IPsec.\n               ===   \
    \  IP_{B<->C} ESP [ IP_{A<->C} ULP ]\n               ---     IP_{A<->C} ULP\n\
    \           For A_1 to send a packet to D_1, B and C need an SA with:\n      \
    \             SA Type of ESP\n                   Source Identity that dominates\
    \ A_1\n                   Destination Identity that dominates C\n            \
    \       Source Address of B\n                   Destination Address of C\n   \
    \                Proxy Address of A_1\n           For D_1 to send a packet to\
    \ A_1, C and B need an SA with:\n                   SA Type of ESP Tunnel-mode\n\
    \                   Source Identity that dominates D_1\n                   Destination\
    \ Identity that dominates B\n                   Source Address of C\n        \
    \           Destination Address of B\n                   Proxy Address of D_1\n\
    \   Note that A_2 and D_2 could be substituted for A_1 and D_1\n   (respectively)\
    \ here; the association of an SA with a particular pair\n   of ends or group of\
    \ those pairs is a policy decision on B and/or C\n   and not necessarily a function\
    \ of key management.  The same check of\n   the Source Identity against the inner\
    \ source IP address MUST also be\n   performed in this case for the same reason.\n\
    \   For a more detailed discussion of the use of IP Security in complex\n   cases,\
    \ please see [Atk97].\n     NOTE: The notion of identity domination might be unfamiliar.\
    \  Let H\n     represent some node. Let Hn represent H's fully qualified domain\n\
    \     name. Let Ha represent the IP address of H. Let Hs represent the IP\n  \
    \   subnet containing Ha. Let Hd represent a fully qualified domain\n     name\
    \ that is a parent of the fully qualified domain name of H. Let\n     M be a UserFQDN\
    \ identity that whose right-hand part is Hn or Ha.\n     Any of M, Hn, Ha, Hs,\
    \ and Hd is considered to dominate H in the\n     example above. Hs dominates\
    \ any node having an IP address within\n     the IP address range represented\
    \ by Hs. Hd dominates any node\n     having a fully qualified domain name within\
    \ underneath Hd.\n"
- title: 5.3 OSPF Security Example
  contents:
  - "5.3 OSPF Security Example\n           +---------------+    +-------------+\n\
    \           |Key Mgmt Daemon|    | OSPF daemon |\n           +---------------+\
    \    +-------------+\n             |           |     /    /        |\n       \
    \      |    /------|----+    /         |\n             |   /       |    +---+\
    \          |           Applications\n     ======[PF_KEY]====[PF_INET]===========[PF_ROUTE]================\n\
    \             |           |    |              |           OS Kernel\n     +------------+\
    \   +-----------------+  +---------+\n     | Key Engine |   | TCP/IP,        \
    \ |  | Routing |\n     |  or  SADB  |---| including IPsec |--| Table   |\n   \
    \  +------------+   |                 |  +---------+\n                      +-----------------+\n\
    \   As in the previous examples, the KMd registers itself with the Key\n   Engine\
    \ via PF_KEY.  Even though the consumer of the security\n   associations is in\
    \ user-space, the PF_KEY and Key Engine\n   implementation knows enough to store\
    \ SAs and to relay messages.\n   When the OSPF daemon needs to communicate securely\
    \ with its peers, it\n   would perform an SADB_GET message and retrieve the appropriate\n\
    \   association:\n     OSPFd->Kernel:       SADB_GET of OSPF, assoc, addrs\n \
    \    Kernel->OSPFd:       SADB_GET of OSPF, assoc, addrs, keys, <etc.>\n   If\
    \ this GET fails, the OSPFd may need to acquire a new security\n   association.\
    \  This interaction is as follows:\n     OSPFd->Kernel:       SADB_ACQUIRE of\
    \ OSPF, addrs, <ID, sens,>\n                          proposal\n     Kernel->Registered:\
    \  SADB_ACQUIRE of OSPF, <same as sent message>\n   The KMd sees this and performs\
    \ actions similar to the previous\n   example.  One difference, however, is that\
    \ when the UPDATE message\n   comes back, the OSPFd will then perform a GET of\
    \ the updated SA to\n   retrieve all of its parameters.\n"
- title: 5.4 Miscellaneous
  contents:
  - "5.4 Miscellaneous\n   Some messages work well only in system maintenance programs,\
    \ for\n   debugging, or for auditing.  In a system panic situation, such as a\n\
    \   detected compromise, an SADB_FLUSH message should be issued for a\n   particular\
    \ SA type, or for ALL SA types.\n     Program->Kernel:     SADB_FLUSH for ALL\n\
    \     <Kernel then flushes all internal SAs>\n     Kernel->All:         SADB_FLUSH\
    \ for ALL\n   Some SAs may need to be explicitly deleted, either by a KMd, or\
    \ by a\n   system maintenance program.\n     Program->Kernel:     SADB_DELETE\
    \ for AH, association, addrs\n     Kernel->All:         SADB_DELETE for AH, association,\
    \ addrs\n   Common usage of the SADB_DUMP message is discouraged.  For debugging\n\
    \   purposes, however, it can be quite useful.  The output of a DUMP\n   message\
    \ should be read quickly, in order to avoid socket buffer\n   overflows.\n   \
    \  Program->Kernel:     SADB_DUMP for ESP\n     Kernel->Program:     SADB_DUMP\
    \ for ESP, association, <all fields>\n     Kernel->Program:     SADB_DUMP for\
    \ ESP, association, <all fields>\n     Kernel->Program:     SADB_DUMP for ESP,\
    \ association, <all fields>\n     <ad nauseam...>\n"
- title: 6 Security Considerations
  contents:
  - "6 Security Considerations\n   This memo discusses a method for creating, reading,\
    \ modifying, and\n   deleting Security Associations from an operating system.\
    \  Only\n   trusted, privileged users and processes should be able to perform\
    \ any\n   of these operations.  It is unclear whether this mechanism provides\n\
    \   any security when used with operating systems not having the concept\n   of\
    \ a trusted, privileged user.\n   If an unprivileged user is able to perform any\
    \ of these operations,\n   then the operating system cannot actually provide the\
    \ related\n   security services.  If an adversary knows the keys and algorithms\
    \ in\n   use, then cryptography cannot provide any form of protection.\n   This\
    \ mechanism is not a panacea, but it does provide an important\n   operating system\
    \ component that can be useful in creating a secure\n   internetwork.\n   Users\
    \ need to understand that the quality of the security provided by\n   an implementation\
    \ of this specification depends completely upon the\n   overall security of the\
    \ operating system, the correctness of the\n   PF_KEY implementation, and upon\
    \ the security and correctness of the\n   applications that connect to PF_KEY.\
    \  It is appropriate to use high\n   assurance development techniques when implementing\
    \ PF_KEY and the\n   related security association components of the operating\
    \ system.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors of this document are listed primarily in alphabetical\n\
    \   order.  Randall Atkinson and Ron Lee provided useful feedback on\n   earlier\
    \ versions of this document.\n   At one time or other, all of the authors worked\
    \ at the Center for\n   High Assurance Computer Systems at the U.S.  Naval Research\n\
    \   Laboratory. This work was sponsored by the Information Security\n   Program\
    \ Office (PMW-161), U.S.  Space and Naval Warfare Systems\n   Command (SPAWAR)\
    \ and the Computing Systems Technology Office, Defense\n   Advanced Research Projects\
    \ Agency (DARPA/CSTO). We really appreciate\n   their sponsorship of our efforts\
    \ and their continued support of\n   PF_KEY development. Without that support,\
    \ PF_KEY would not exist.\n   The \"CONFORMANCE and COMPLIANCE\" wording was taken\
    \ from [MSST98].\n   Finally, the authors would like to thank those who sent in\
    \ comments\n   and questions on the various iterations of this document. This\n\
    \   specification and implementations of it are discussed on the PF_KEY\n   mailing\
    \ list. If you would like to be added to this list, send a note\n   to <pf_key-request@inner.net>.\n"
- title: References
  contents:
  - "References\n   [AMPMC96] Randall J. Atkinson, Daniel L. McDonald, Bao G. Phan,\
    \ Craig\n   W. Metz, and Kenneth C. Chin, \"Implementation of IPv6 in 4.4-Lite\n\
    \   BSD\", Proceedings of the 1996 USENIX Conference, San Diego, CA,\n   January\
    \ 1996, USENIX Association.\n   [Atk95a] Atkinson, R., \"IP Security Architecture\"\
    , RFC 1825, August\n   1995.\n   [Atk95b] Atkinson, R., \"IP Authentication Header\"\
    , RFC 1826, August\n   1995.\n   [Atk95c] Atkinson, R., \"IP Encapsulating Security\
    \ Payload\", RFC 1827,\n   August 1995.\n   [Atk97] Atkinson, R., \"Key Exchange\
    \ Delegation Record for the Domain\n   Name System\", RFC 2230, October 1997.\n\
    \   [BA97] Baker, F., and R. Atkinson, \"RIP-2 MD5 Authentication\", RFC\n   2082,\
    \ January 1997.\n   [Biba77] K. J. Biba, \"Integrity Considerations for Secure\
    \ Computer\n   Systems\", MTR-3153, The MITRE Corporation, June 1975; ESD-TR-76-372,\n\
    \   April 1977.\n   [BL74] D. Elliot Bell and Leonard J. LaPadula, \"Secure Computer\n\
    \   Systems: Unified Exposition and Multics Interpretation\", MTR 2997,\n   The\
    \ MITRE Corporation, April 1974. (AD/A 020 445)\n   [Bra97] Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n   Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [CW87] D. D. Clark and D. R. Wilson, \"A Comparison of Commercial\
    \ and\n   Military Computer Security Policies\", Proceedings of the 1987\n   Symposium\
    \ on Security and Privacy, pp. 184-195, IEEE Computer\n   Society, Washington,\
    \ D.C., 1987.\n   [DIA] US Defense Intelligence Agency (DIA), \"Compartmented\
    \ Mode\n   Workstation Specification\", Technical Report DDS-2600-6243-87.\n \
    \  [GK98] Glenn, R., and S. Kent, \"The NULL Encryption Algorithm and Its\n  \
    \ Use with IPsec\", Work in Progress.\n   [HM97a] Harney, H., and C. Muckenhirn,\
    \ \"Group Key Management Protocol\n   (GKMP) Specification\", RFC 2093, July 1997.\n\
    \   [HM97b] Harney, H., and C. Muckenhirn, \"Group Key Management Protocol\n \
    \  (GKMP) Architecture\", RFC 2094, July 1997.\n   [MD98] Madsen, C., and N. Doraswamy,\
    \ \"The ESP DES-CBC Cipher\n   Algorithm With Explicit IV\", Work in Progress.\n\
    \   [MG98a] Madsen, C., and R. Glenn, \"The Use of HMAC-MD5-96 within ESP\n  \
    \ and AH\", Work in Progress.\n   [MG98b] Madsen, C., and R. Glenn, \"The Use\
    \ of HMAC-SHA-1-96 within\n   ESP and AH\", Work in Progress.\n   [MSST98] Maughan,\
    \ D., Schertler, M., Schneider, M., and J. Turner,\n   \"Internet Security Association\
    \ and Key Management Protocol (ISAKMP)\",\n   Work in Progress.\n   [Moy98] Moy,\
    \ J., \"OSPF Version 2\", STD 54, RFC 2328, April 1998.\n   [Per97] Perkins, C.,\
    \ \"IP Mobility Support\", RFC 2002, October 1996.\n   [Pip98] Piper, D., \"The\
    \ Internet IP Security Domain of Interpretation\n   for ISAKMP\", Work in Progress.\n\
    \   [Sch96] Bruce Schneier, Applied Cryptography, p. 360, John Wiley &\n   Sons,\
    \ Inc., 1996.\n   [Skl91] Keith Sklower, \"A Tree-based Packet Routing Table for\n\
    \   Berkeley UNIX\", Proceedings of the Winter 1991 USENIX Conference,\n   Dallas,\
    \ TX, USENIX Association. 1991.  pp. 93-103.\n"
- title: Disclaimer
  contents:
  - "Disclaimer\n   The views and specification here are those of the editors and\
    \ are not\n   necessarily those of their employers.  The employers have not passed\n\
    \   judgment on the merits, if any, of this work.  The editors and their\n   employers\
    \ specifically disclaim responsibility for any problems\n   arising from correct\
    \ or incorrect implementation or use of this\n   specification.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Daniel L. McDonald\n   Sun Microsystems, Inc.\n   901\
    \ San Antonio Road, MS UMPK17-202\n   Palo Alto, CA 94303\n   Phone: +1 650 786\
    \ 6815\n   EMail: danmcd@eng.sun.com\n   Craig Metz\n   (for Code 5544)\n   U.S.\
    \ Naval Research Laboratory\n   4555 Overlook Ave. SW\n   Washington, DC 20375\n\
    \   Phone: (DSN) 754-8590\n   EMail: cmetz@inner.net\n   Bao G. Phan\n   U. S.\
    \ Naval Research Laboratory\n   EMail: phan@itd.nrl.navy.mil\n"
- title: 'Appendix A: Promiscuous Send/Receive Message Type'
  contents:
  - "Appendix A: Promiscuous Send/Receive Message Type\n   A kernel supporting PF_KEY\
    \ MAY implement the following extension for\n   development and debugging purposes.\
    \ If it does, it MUST implement the\n   extension as specified here. An implementation\
    \ MAY require an\n   application to have additional privileges to perform promiscuous\
    \ send\n   and/or receive operations.\n   The SADB_X_PROMISC message allows an\
    \ application to send and receive\n   messages in a \"promiscuous mode.\" There\
    \ are two forms of this\n   message: control and data. The control form consists\
    \ of only a\n   message header.  This message is used to toggle the promiscuous-\n\
    \   receive function. A value of one in the sadb_msg_satype field enables\n  \
    \ promiscuous message reception for this socket, while a value of zero\n   in\
    \ that field disables it.\n   The second form of this message is the data form.\
    \ This is used to\n   send or receive messages in their raw form. Messages in\
    \ the data form\n   consist of a message header followed by an entire new message.\
    \  There\n   will be two message headers in a row: one for the SADB_X_PROMISC\n\
    \   message, and one for the payload message.\n   Data messages sent from the\
    \ application are sent to either the PF_KEY\n   socket of a single process identified\
    \ by a nonzero sadb_msg_seq or to\n   all PF_KEY sockets if sadb_msg_seq is zero.\
    \  These messages are sent\n   without any processing of their contents by the\
    \ PF_KEY interface\n   (including sanity checking).  This promiscuous-send capability\
    \ allows\n   an application to send messages as if it were the kernel. This also\n\
    \   allows it to send erroneous messages.\n   If the promiscuous-receive function\
    \ has been enabled, a copy of any\n   message sent via PF_KEY by another application\
    \ or by the kernel is\n   sent to the promiscuous application.  This is done before\
    \ any\n   processing of the message's contents by the PF_KEY interface (again,\n\
    \   including sanity checking).  This promiscuous-receive capability\n   allows\
    \ an application to receive all messages sent by other parties\n   using PF_KEY.\n\
    \     The messaging behavior of the SADB_X_PROMISC message is:\n         Send\
    \ a control-form SADB_X_PROMISC message from a user process\n         to the kernel.\n\
    \         <base>\n         The kernel returns the SADB_X_PROMISC message to all\
    \ listening\n         processes.\n         <base>\n         Send a data-form SADB_X_PROMISC\
    \ message from a user process to\n         the kernel.\n         <base, base(,\
    \ others)>\n         The kernel sends the encapsulated message to the target\n\
    \         process(s).\n         <base(, others)>\n         If promiscuous-receive\
    \ is enabled, the kernel will encapsulate\n         and send copies of all messages\
    \ sent via the PF_KEY interface.\n         <base, base(, others)>\n     Errors:\n\
    \         EPERM Additional privileges are required to perform the\n          \
    \     requested operations.\n         ESRCH (Data form, sending) The target process\
    \ in sadb_msg_seq\n               does not exist or does not have an open PF_KEY\
    \ Version 2\n               socket.\n"
- title: 'Appendix B: Passive Change Message Type'
  contents:
  - "Appendix B: Passive Change Message Type\n   The SADB_X_PCHANGE message is a passive-side\
    \ (aka.  the \"listener\" or\n   \"receiver\") counterpart to the SADB_ACQUIRE\
    \ message.  It is useful\n   for when key management applications wish to more\
    \ effectively handle\n   incoming key management requests for passive-side sessions\
    \ that\n   deviate from systemwide default security services.  If a passive\n\
    \   session requests that only certain levels of security service be\n   allowed,\
    \ the SADB_X_PCHANGE message expresses this change to any\n   registered PF_KEY\
    \ sockets.  Unlike SADB_ACQUIRE, this message is\n   purely informational, and\
    \ demands no other PF_KEY interaction.\n   The SADB_X_PCHANGE message is typically\
    \ triggered by either a change\n   in an endpoint's requested security services,\
    \ or when an endpoint\n   that made a special request disappears.  In the former\
    \ case, an\n   SADB_X_PCHANGE looks like an SADB_ACQUIRE, complete with an\n \
    \  sadb_proposal extension indicating the preferred algorithms,\n   lifetimes,\
    \ and other attributes.  When a passive session either\n   disappears, or reverts\
    \ to a default behavior, an SADB_X_PCHANGE will\n   be issued with _no_ sadb_proposal\
    \ extension, indicating that the\n   exception to systemwide default behavior\
    \ has disappeared.\n   There are two messaging behaviors for SADB_X_PCHANGE. \
    \ The first is\n   the kernel-originated case:\n        The kernel sends an SADB_X_PCHANGE\
    \ message to registered\n        sockets.\n        <base, address(SD), (identity(SD),)\
    \ (sensitivity,) (proposal)>\n        NOTE:  The address(SD) extensions MUST have\
    \ the port fields\n               filled in with the port numbers of the session\n\
    \               requiring keys if appropriate.\n   The second is for a user-level\
    \ consumer of SAs.\n        Send an SADB_X_PCHANGE message from a user process\
    \ to the\n        kernel.\n        <base, address(SD), (identity(SD),) (sensitivity,)\
    \ (proposal)>\n        The kernel returns an SADB_X_PCHANGE message to registered\n\
    \        sockets.\n        <base, address(SD), (identity(SD),) (sensitivity,)\
    \ (proposal)>\n"
- title: 'Appendix C: Key Management Private Data Extension'
  contents:
  - "Appendix C: Key Management Private Data Extension\n   The Key Management Private\
    \ Data extension is attached to either an\n   SADB_ADD or an SADB_UPDATE message.\
    \  It attaches a single piece of\n   arbitrary data to a security association.\
    \  It may be useful for key\n   managment applications that could use an SADB_DUMP\
    \ or SADB_GET\n   message to obtain additional state if it needs to restart or\
    \ recover\n   after a crash.  The format of this extension is:\n           #define\
    \ SADB_X_EXT_KMPRIVATE 17\n           struct sadb_x_kmprivate {\n            \
    \       uint16_t sadb_x_kmprivate_len;\n                   uint16_t sadb_x_kmprivate_exttype;\n\
    \                   uint32_t sadb_x_kmprivate_reserved;\n           };\n     \
    \      /* sizeof(struct sadb_x_kmprivate) == 8 */\n           /* followed by arbitrary\
    \ data */\n   The data following the sadb_x_kmprivate extension can be anything.\n\
    \   It will be stored with the actual security association in the kernel.\n  \
    \ Like all data, it must be padded to an eight byte boundary.\n"
- title: 'Appendix D: Sample Header File'
  contents:
  - "Appendix D: Sample Header File\n   /*\n   This file defines structures and symbols\
    \ for the PF_KEY Version 2\n   key management interface. It was written at the\
    \ U.S. Naval Research\n   Laboratory. This file is in the public domain. The authors\
    \ ask that\n   you leave this credit intact on any copies of this file.\n   */\n\
    \   #ifndef __PFKEY_V2_H\n   #define __PFKEY_V2_H 1\n   #define PF_KEY_V2 2\n\
    \   #define PFKEYV2_REVISION        199806L\n   #define SADB_RESERVED    0\n \
    \  #define SADB_GETSPI      1\n   #define SADB_UPDATE      2\n   #define SADB_ADD\
    \         3\n   #define SADB_DELETE      4\n   #define SADB_GET         5\n  \
    \ #define SADB_ACQUIRE     6\n   #define SADB_REGISTER    7\n   #define SADB_EXPIRE\
    \      8\n   #define SADB_FLUSH       9\n   #define SADB_DUMP        10\n   #define\
    \ SADB_X_PROMISC   11\n   #define SADB_X_PCHANGE   12\n   #define SADB_MAX   \
    \      12\n   struct sadb_msg {\n     uint8_t sadb_msg_version;\n     uint8_t\
    \ sadb_msg_type;\n     uint8_t sadb_msg_errno;\n     uint8_t sadb_msg_satype;\n\
    \     uint16_t sadb_msg_len;\n     uint16_t sadb_msg_reserved;\n     uint32_t\
    \ sadb_msg_seq;\n     uint32_t sadb_msg_pid;\n   };\n   struct sadb_ext {\n  \
    \   uint16_t sadb_ext_len;\n     uint16_t sadb_ext_type;\n   };\n   struct sadb_sa\
    \ {\n     uint16_t sadb_sa_len;\n     uint16_t sadb_sa_exttype;\n     uint32_t\
    \ sadb_sa_spi;\n     uint8_t sadb_sa_replay;\n     uint8_t sadb_sa_state;\n  \
    \   uint8_t sadb_sa_auth;\n     uint8_t sadb_sa_encrypt;\n     uint32_t sadb_sa_flags;\n\
    \   };\n   struct sadb_lifetime {\n     uint16_t sadb_lifetime_len;\n     uint16_t\
    \ sadb_lifetime_exttype;\n     uint32_t sadb_lifetime_allocations;\n     uint64_t\
    \ sadb_lifetime_bytes;\n     uint64_t sadb_lifetime_addtime;\n     uint64_t sadb_lifetime_usetime;\n\
    \   };\n   struct sadb_address {\n     uint16_t sadb_address_len;\n     uint16_t\
    \ sadb_address_exttype;\n     uint8_t sadb_address_proto;\n     uint8_t sadb_address_prefixlen;\n\
    \     uint16_t sadb_address_reserved;\n   };\n   struct sadb_key {\n     uint16_t\
    \ sadb_key_len;\n     uint16_t sadb_key_exttype;\n     uint16_t sadb_key_bits;\n\
    \     uint16_t sadb_key_reserved;\n   };\n   struct sadb_ident {\n     uint16_t\
    \ sadb_ident_len;\n     uint16_t sadb_ident_exttype;\n     uint16_t sadb_ident_type;\n\
    \     uint16_t sadb_ident_reserved;\n     uint64_t sadb_ident_id;\n   };\n   struct\
    \ sadb_sens {\n     uint16_t sadb_sens_len;\n     uint16_t sadb_sens_exttype;\n\
    \     uint32_t sadb_sens_dpd;\n     uint8_t sadb_sens_sens_level;\n     uint8_t\
    \ sadb_sens_sens_len;\n     uint8_t sadb_sens_integ_level;\n     uint8_t sadb_sens_integ_len;\n\
    \     uint32_t sadb_sens_reserved;\n   };\n   struct sadb_prop {\n     uint16_t\
    \ sadb_prop_len;\n     uint16_t sadb_prop_exttype;\n     uint8_t sadb_prop_replay;\n\
    \     uint8_t sadb_prop_reserved[3];\n   };\n   struct sadb_comb {\n     uint8_t\
    \ sadb_comb_auth;\n     uint8_t sadb_comb_encrypt;\n     uint16_t sadb_comb_flags;\n\
    \     uint16_t sadb_comb_auth_minbits;\n     uint16_t sadb_comb_auth_maxbits;\n\
    \     uint16_t sadb_comb_encrypt_minbits;\n     uint16_t sadb_comb_encrypt_maxbits;\n\
    \     uint32_t sadb_comb_reserved;\n     uint32_t sadb_comb_soft_allocations;\n\
    \     uint32_t sadb_comb_hard_allocations;\n     uint64_t sadb_comb_soft_bytes;\n\
    \     uint64_t sadb_comb_hard_bytes;\n     uint64_t sadb_comb_soft_addtime;\n\
    \     uint64_t sadb_comb_hard_addtime;\n     uint64_t sadb_comb_soft_usetime;\n\
    \     uint64_t sadb_comb_hard_usetime;\n   };\n   struct sadb_supported {\n  \
    \   uint16_t sadb_supported_len;\n     uint16_t sadb_supported_exttype;\n    \
    \ uint32_t sadb_supported_reserved;\n   };\n   struct sadb_alg {\n     uint8_t\
    \ sadb_alg_id;\n     uint8_t sadb_alg_ivlen;\n     uint16_t sadb_alg_minbits;\n\
    \     uint16_t sadb_alg_maxbits;\n     uint16_t sadb_alg_reserved;\n   };\n  \
    \ struct sadb_spirange {\n     uint16_t sadb_spirange_len;\n     uint16_t sadb_spirange_exttype;\n\
    \     uint32_t sadb_spirange_min;\n     uint32_t sadb_spirange_max;\n     uint32_t\
    \ sadb_spirange_reserved;\n   };\n   struct sadb_x_kmprivate {\n     uint16_t\
    \ sadb_x_kmprivate_len;\n     uint16_t sadb_x_kmprivate_exttype;\n     uint32_t\
    \ sadb_x_kmprivate_reserved;\n   };\n   #define SADB_EXT_RESERVED            \
    \ 0\n   #define SADB_EXT_SA                   1\n   #define SADB_EXT_LIFETIME_CURRENT\
    \     2\n   #define SADB_EXT_LIFETIME_HARD        3\n   #define SADB_EXT_LIFETIME_SOFT\
    \        4\n   #define SADB_EXT_ADDRESS_SRC          5\n   #define SADB_EXT_ADDRESS_DST\
    \          6\n   #define SADB_EXT_ADDRESS_PROXY        7\n   #define SADB_EXT_KEY_AUTH\
    \             8\n   #define SADB_EXT_KEY_ENCRYPT          9\n   #define SADB_EXT_IDENTITY_SRC\
    \         10\n   #define SADB_EXT_IDENTITY_DST         11\n   #define SADB_EXT_SENSITIVITY\
    \          12\n   #define SADB_EXT_PROPOSAL             13\n   #define SADB_EXT_SUPPORTED_AUTH\
    \       14\n   #define SADB_EXT_SUPPORTED_ENCRYPT    15\n   #define SADB_EXT_SPIRANGE\
    \             16\n   #define SADB_X_EXT_KMPRIVATE          17\n   #define SADB_EXT_MAX\
    \                  17\n   #define SADB_SATYPE_UNSPEC    0\n   #define SADB_SATYPE_AH\
    \        2\n   #define SADB_SATYPE_ESP       3\n   #define SADB_SATYPE_RSVP  \
    \    5\n   #define SADB_SATYPE_OSPFV2    6\n   #define SADB_SATYPE_RIPV2     7\n\
    \   #define SADB_SATYPE_MIP       8\n   #define SADB_SATYPE_MAX       8\n   #define\
    \ SADB_SASTATE_LARVAL   0\n   #define SADB_SASTATE_MATURE   1\n   #define SADB_SASTATE_DYING\
    \    2\n   #define SADB_SASTATE_DEAD     3\n   #define SADB_SASTATE_MAX      3\n\
    \   #define SADB_SAFLAGS_PFS      1\n   #define SADB_AALG_NONE        0\n   #define\
    \ SADB_AALG_MD5HMAC     2\n   #define SADB_AALG_SHA1HMAC    3\n   #define SADB_AALG_MAX\
    \         3\n   #define SADB_EALG_NONE        0\n   #define SADB_EALG_DESCBC \
    \     2\n   #define SADB_EALG_3DESCBC     3\n   #define SADB_EALG_NULL       \
    \ 11\n   #define SADB_EALG_MAX         11\n   #define SADB_IDENTTYPE_RESERVED\
    \   0\n   #define SADB_IDENTTYPE_PREFIX     1\n   #define SADB_IDENTTYPE_FQDN\
    \       2\n   #define SADB_IDENTTYPE_USERFQDN   3\n   #define SADB_IDENTTYPE_MAX\
    \        3\n   #define SADB_KEY_FLAGS_MAX 0\n   #endif /* __PFKEY_V2_H */\n"
- title: 'Appendix E: Change Log'
  contents:
  - "Appendix E: Change Log\n   The following changes were made between 05 and 06:\n\
    \   * Last change before becoming an informational RFC.  Removed all\n     Internet-Draft\
    \ references.  Also standardized citation strings.\n     Now cite RFC 2119 for\
    \ MUST, etc.\n   * New appendix on optional KM private data extension.\n   * Fixed\
    \ example to indicate the ACQUIRE messages with errno mean\n     KM failure.\n\
    \   * Added SADB_EALG_NULL.\n   * Clarified proxy examples to match definition\
    \ of PROXY address being\n     the inner packet's source address.  (Basically\
    \ a sign-flip.  The\n     example still shows how to protect against policy vulnerabilities\n\
    \     in tunnel endpoints.)\n   * Loosened definition of a destination address\
    \ to include broadcast.\n   * Recommended that LARVAL security associations have\
    \ implicit short\n     lifetimes.\n   The following changes were made between\
    \ 04 and 05:\n   * New appendix on Passive Change message.\n   * New sadb_address_prefixlen\
    \ field.\n   * Small clarifications on sadb_ident_id usage.\n   * New PFKEYV2_REVISION\
    \ value.\n   * Small clarification on what a PROXY address is.\n   * Corrected\
    \ sadb_spirange_{min,max} language.\n   * In ADD messages that are in response\
    \ to an ACQUIRE, the\n     sadb_msg_seq MUST be the same as that of the originating\
    \ ACQUIRE.\n   * Corrected ACQUIRE message behavior, ACQUIRE message SHOULD send\
    \ up\n     PROXY addresses when it needs them.\n   * Clarification on SADB_EXPIRE\
    \ and user-level security protocols.\n   The following changes were made between\
    \ 03 and 04:\n   * Stronger language about manual keying.\n   * PFKEYV2_REVISION,\
    \ ala POSIX.\n   * Put in language about sockaddr ports in ACQUIRE messages.\n\
    \   * Mention of asymmetric algorithms.\n   * New sadb_ident_id field for easier\
    \ construction of USER_FQDN\n     identity strings.\n   * Caveat about source\
    \ addresses not always used for collision\n     detection. (e.g. IPsec)\n   The\
    \ following changes were made between 02 and 03:\n   * Formatting changes.\n \
    \  * Many editorial cleanups, rewordings, clarifications.\n   * Restrictions that\
    \ prevent many strange and invalid cases.\n   * Added definitions section.\n \
    \  * Removed connection identity type (this will reappear when it is\n     more\
    \ clear what it should look like).\n   * Removed 5.2.1 (Why involve the kernel?).\n\
    \   * Removed INBOUND, OUTBOUND, and FORWARD flags; they can be computed\n   \
    \  from src, dst, and proxy and you had to anyway for sanity checking.\n   * Removed\
    \ REPLAY flag; sadb_sa_replay==0 means the same thing.\n   * Renamed bit lengths\
    \ to \"bits\" to avoid potential confusion.\n   * Explicitly listed lengths for\
    \ structures.\n   * Reworked identities to always use a string format.\n   * Removed\
    \ requirements for support of shutdown() and SO_USELOOPBACK.\n   * 64 bit alignment\
    \ and 64 bit lengths instead of 32 bit.\n   * time_t replaced with uint64 in lifetimes.\n\
    \   * Inserted Appendix A (SADB_X_PROMISC) and Appendix B (SAMPLE HEADER\n   \
    \  FILE).\n   * Explicit error if PF_KEY_V2 not set at socket() call.\n   * More\
    \ text on SO_USELOOPBACK.\n   * Made fields names and symbol names more consistent.\n\
    \   * Explicit error if PF_KEY_V2 is not in sadb_msg_version field.\n   * Bytes\
    \ lifetime field now a 64-bit quantity.\n   * Explicit len/exttype wording.\n\
    \   * Flattening out of extensions (LIFETIME_HARD, LIFETIME_SOFT, etc.)\n   *\
    \ UI example (0x123 == 0x1230 or 0x0123).\n   * Cleaned up and fixed some message\
    \ behavior examples.\n   The following changes were made between 01 and 02:\n\
    \   * Mentioned that people COULD use these same messages between user\n     progs.\
    \ (Also mentioned why you still might want to use the actual\n     socket.)\n\
    \   * Various wordsmithing changes.\n   * Took out netkey/ directory, and make\
    \ net/pfkeyv2.h\n   * Inserted PF_KEY_V2 proto argument per C. Metz.\n   * Mentioned\
    \ other socket calls and how their PF_KEY behavior is\n     undefined.\n   * SADB_EXPIRE\
    \ now communicates both hard and soft lifetime expires.\n   * New \"association\"\
    \ extension, even smaller base header.\n   * Lifetime extension improvements.\n\
    \   * Length now first in extensions.\n   * Errors can be sent from kernel to\
    \ user, also.\n   * Examples section inserted.\n   * Some bitfield cleanups, including\
    \ STATE and SA_OPTIONS cleanup.\n   * Key splitting now only across auth algorithm\
    \ and encryption\n     algorithm. Thanks for B. Sommerfeld for clues here.\n \
    \  The following changes were made between 00 and 01:\n   * Added this change\
    \ log.\n   * Simplified TLV header syntax.\n   * Splitting of algorithms. This\
    \ may be controversial, but it allows\n     PF_KEY to be used for more than just\
    \ IPsec. It also allows some\n     kinds of policies to be placed in the KMd easier.\n\
    \   * Added solid definitions and formats for certificate identities,\n     multiple\
    \ keys, etc.\n   * Specified how keys are to be layed out (most-to-least bits).\n\
    \   * Changed sequence number semantics to be like an RPC transaction ID\n   \
    \  number.\n"
- title: F.  Full Copyright Statement
  contents:
  - "F.  Full Copyright Statement\n   Copyright (C) The Internet Society (1998). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
