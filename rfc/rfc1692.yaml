- title: __initial_text__
  contents:
  - '                 Transport Multiplexing Protocol (TMux)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   One of the problems with the use of terminal servers is the large\n\
    \   number of small packets they can generate. Frequently, most of these\n   packets\
    \ are destined for only one or two hosts.  TMux is a protocol\n   which allows\
    \ multiple short transport segments, independent of\n   application type, to be\
    \ combined between a server and host pair.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   This specification is the result of the merger of two documents:\
    \ the\n   original TMux proposal which was the result of several discussions\n\
    \   and related initiatives through IETF working groups; and IEN 90 [1]\n   originally\
    \ proposed by Danny Cohen and Jon Postel in May 1979.\n"
- title: Applicability Statement
  contents:
  - "Applicability Statement\n   The TMux protocol is intended to optimize the transmission\
    \ of large\n   numbers of small data packets that are generated in situations\
    \ where\n   many interactive Telnet and Rlogin sessions are connected to a few\n\
    \   hosts on the network.  In these situations, TMux can improve both\n   network\
    \ and host performance.  TMux is not intended for multiplexing\n   long streams\
    \ composed of large blocks of data that are typically\n   transmitted by such\
    \ applications as FTP.\n   The TMux protocol may be applicable to other situations\
    \ where small\n   packets are generated, but this was not considered in the design.\n\
    \   The use of the TMux protocol in any other situation may require some\n   modification.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   When network designers consider which protocols generate\
    \ the most\n   load, they naturally tend to consider protocols which transfer\
    \ large\n   blocks of data (e.g., FTP, NFS).  What is often not considered is\
    \ the\n   load generated by Telnet and Rlogin because of the assumption that\n\
    \   users type slowly and the packets are very small.  This is a grave\n   underestimation\
    \ of the load on networks and hosts which have many\n   Telnet and Rlogin ports\
    \ on multiple terminal servers.\n   The problem stems from the fact that the work\
    \ a host must do to\n   process a 1-octet packet is very nearly as much as the\
    \ work it must\n   do to process a 1500-octet packet.  That is, it is the overhead\
    \ of\n   processing a packet which consumes a host's resources, not the\n   processing\
    \ of the data.\n   In particular, communication load is not measured only in bits\
    \ per\n   seconds but also in packets per seconds, and in many situation the\n\
    \   latter is the true performance limit, not the former.  The proposed\n   multiplexing\
    \ is aimed at alleviating this situation.\n   If one assumes that most users connected\
    \ to a terminal server will be\n   connecting to only a few hosts, then it should\
    \ be obvious that the\n   network and host load could be greatly reduced if traffic\
    \ from\n   multiple users, destined for the same host, could be sent in the same\n\
    \   packet.\n   TMux is designed to improve network utilization and reduce the\n\
    \   interrupt load on hosts which conduct multiple sessions involving\n   many\
    \ short packets.  It does this by multiplexing transport traffic\n   onto a single\
    \ IP datagram [2], thereby resulting in fewer, larger\n   packets.  TMux is highly\
    \ constrained in its method of accomplishing\n   this task, seeking simplicity\
    \ rather than sophistication.\n"
- title: 2. Protocol Design
  contents:
  - "2. Protocol Design\n   IP hosts may engage in the use of TMux transparently,\
    \ and may even\n   switch back and forth between use of TMux and carriage of transport\n\
    \   segments in the usual, independent IP datagrams.\n   TMux operates by placing\
    \ a set of transport segments into the same IP\n   datagram.  Each segment is\
    \ preceded by a TMux mini-header which\n   specifies the segment length and the\
    \ actual segment transport\n   protocol.  The receiving host demultiplexes the\
    \ individual transport\n   segments and presents them to the transport layer as\
    \ if they had been\n   received in the usual IP/transport packaging.  The transport\
    \ layer\n   is, therefore, unaware of the special encapsulation which was used.\n\
    \   Hence, a TMux message appears as:\n     | IP hdr | TM hdr | Tport segment\
    \ | TM hdr | Tport segment| ...|\n   Where:\n   TM hdr         is a TMux mini-header\
    \ and specifies the following\n                  Tport segment.\n   Tport segment\
    \  refers to the entire transport segment, including\n                  transport\
    \ headers.\n   The TMux Protocol is defined to allow the combining of transmission\n\
    \   units of different higher level protocols in one transmission unit of\n  \
    \ a lower level protocol. Only segments with the same Internet Protocol\n   (IP)\
    \ header, (with the possible exception of the protocol and check-\n   sum fields)\
    \ may be combined. For example, the segment (H1, B1) and\n   the segment (H2,\
    \ B2), where Hi and Bi are the headers and the bodies\n   of the segment, respectively,\
    \ may be combined (multiplexed) only if\n   H=H1=H2. The combined TMux message\
    \ is either (H, B1, B2) or (H, B2,\n   B1).\n   The receiver of this combined\
    \ message should treat it as if the two\n   original segments, (H,B1), and (H,B2),\
    \ arrived separately.  It is\n   recommended, though not a requirement, that the\
    \ segments in the TMux\n   message should be processed in the same order that\
    \ they are in the\n   TMux message.\n   The multiplexing is achieved by combining\
    \ the individual segments,\n   (H,B1) through (H,Bn), into a single message. \
    \ This single message\n   has an IP header which is equal to H, but having in\
    \ the PROTOCOL\n   field the value 18 which is the protocol number of the TMux\
    \ protocol.\n   This IP header is followed by all the segments, B1 through Bn.\
    \  Each\n   segment, Bi, is preceded by a 4 octet TMux mini header. This contains\n\
    \   the number of the protocol to which this segment is addressed. It\n   also\
    \ contains the total length of this segment, including this mini\n   header. Since\
    \ this mini header is not otherwise protected by a check-\n   sum, it also includes\
    \ a checksum field which just covers this mini\n   header.\n"
- title: 2.1. IP Protocol field value
  contents:
  - "2.1. IP Protocol field value\n   TMux is indicated in an IP datagram by the Protocol\
    \ (ID) value of 18\n   (22 octal), see [3].\n"
- title: 2.2. Header Format
  contents:
  - "2.2. Header Format\n   Each 4 octet TMux mini-header has the following general\
    \ format:\n                     +-------------------------------+\n          \
    \           |         Length high           |\n                     +-------------------------------+\n\
    \                     |          Length low           |\n                    \
    \ +-------------------------------+\n                     |         Protocol ID\
    \           |\n                     +-------------------------------+\n      \
    \               |          Checksum             |\n                     +-------------------------------+\n\
    \                     |      Transport segment        |\n                    \
    \ |       ...                     |\n                     |       ...        \
    \             |\n   The LENGTH field specifies the octet count for this mini header\
    \ and\n   the following transport segment, from 0-65535 octets.  Hence, the\n\
    \   length field has a minimum value of 4.  For segments that are larger\n   than\
    \ the maximum allowed for TMux (see section 5.1), individual IP\n   datagrams\
    \ should be sent.\n   The Protocol ID field contains the value that would normally\
    \ have\n   been placed in the IP header Protocol field.\n   The 'Checksum' field\
    \ is the XOR of the first 3 octets.\n   To ensure that TCP, UDP and other segments\
    \ keep their 32 bit\n   alignment, where the segments being multiplexed are not\
    \ a multiple of\n   32 bits long, extra octets will be added to re-align the end\
    \ of the\n   segment, and hence the next segment.  These octets will be ignored\
    \ on\n   input.  This padding will not affect the LENGTH field, it will still\n\
    \   contain the real length of the segment.\n"
- title: 2.3. Sending Data
  contents:
  - "2.3. Sending Data\n   Host endpoints may choose to use TMux at any time and in\
    \ either (or\n   both) directions.  They also may switch back and forth between\
    \ use of\n   TMux packaging and the usual individual IP datagrams for individual\n\
    \   transport associations.  The only barrier to the use of TMux is for\n   the\
    \ sender to know whether TMux is supported by the receiver.  This\n   is important,\
    \ since early use of TMux is likely to be limited.\n   The easiest way to detect\
    \ TMUX support is to only send TMux messages\n   to hosts from which a valid TMux\
    \ message has already been received.\n   This then leaves the problem of one host\
    \ starting the TMux\n   connection.  This is most easily accomplished by the host\
    \ sending an\n   IP datagram with no data (i.e., with the IP total length field\
    \ of\n   20), but with an IP Protocol field value of 18 for TMux.  This is\n \
    \  referred to as a TMux ENQ (enquiry) message.  The host receiving this\n   message\
    \ then knows that the originator supports TMux, and can start\n   to send TMux\
    \ messages. This will in turn cause the originator of the\n   ENQ message to start\
    \ to use TMux.  If for any reason the receiver\n   does not intend to send TMux\
    \ messages to the originator, but is\n   prepared to accept them, then it can\
    \ reply with another ENQ message.\n   If an ENQ message does not get a response,\
    \ then it is reasonable to\n   resend the ENQ a while later in case the original\
    \ ENQ message was\n   lost.  If this again is lost, the ENQ may be repeated as\
    \ often as\n   needed, but the time between requests should increase exponentially\n\
    \   up to a limit of about 1 hour.  Suitable times between ENQs would be\n   15\
    \ seconds, 30 seconds, 60 seconds, 120 seconds etc.\n   Note that this checking\
    \ process does not need to impede any of the\n   transport (user) data, which\
    \ may be sent as convenient, albeit in its\n   less-efficient IP datagram form.\n\
    \   The only problem with this scheme is that a host which supports TMux\n   may\
    \ stop supporting it, as might happen when the host is re-booted.\n   Other hosts\
    \ need to learn of this change.  The solution to this is to\n   maintain a Time\
    \ To Live (TTL) value for hosts from which TMux\n   messages have been received.\
    \  This TTL is a timed TTL, rather than a\n   count as used in the IP TTL field,\
    \ and this time stamp is updated\n   every time a TMux message is received.  This\
    \ can then be used to\n   expire the information held by TMux on the host after\
    \ a suitable\n   time, e.g., 1 minute.\n   This TTL time stamp is used as follows.\
    \ When TMux is passed a segment\n   to be sent to a host, a check is made to see\
    \ if the time to live has\n   expired.  If the TTL has not expired, the segment\
    \ is sent in a TMux\n   message as normal.  If the TTL has expired, the host is\
    \ marked as\n   being unable to TMux, but the segment is STILL sent as a TMux\
    \ message\n   (i.e., with the normal delay to allow other segments to be\n   multiplexed).\
    \  If the host is really unable to TMux anymore (a rare\n   occurrence) then this\
    \ segment will be timed out and retried by the\n   transport provider i.e., TCP.\
    \  Because the host was marked as not\n   able to TMux, the retry will be sent\
    \ as a normal IP datagram.  If the\n   remote host is still able to TMux then\
    \ it should send back TMux\n   traffic (even if it has been rebooted), typically\
    \ a TCP window\n   update, and the local host will mark it as able to TMux again.\
    \ This\n   way of operating removes any performance problem caused by\n   continually\
    \ dropping out of TMuxing and having to send probe\n   messages.  If the IP datagram\
    \ to be sent is from UDP, then the remote\n   host may not send anything in reply.\
    \ So for UDP this scheme will not\n   be any better than just stopping sending\
    \ TMux messages to the host,\n   but it is also no worse.\n"
- title: 3.  Protocol Behavior
  contents:
  - '3.  Protocol Behavior

    '
- title: 3.1. Transport Flow Control
  contents:
  - "3.1. Transport Flow Control\n   TMux operates as an extension to the IP datagram\
    \ protocol.  Hence, it\n   has no impact on most flow control mechanisms, since\
    \ they operate at\n   the transport layer -- above TMux.\n"
- title: 3.2. Connection Management
  contents:
  - "3.2. Connection Management\n   The concept of a connection pertains to certain\
    \ transport protocols,\n   but not to IP or to TMux.  Hence, when connection management\
    \ is\n   required by a transport protocol using TMux, it occurs in the same\n\
    \   fashion as it does for IP.  In fact, the transport protocol is not to\n  \
    \ be aware that TMux is being used.\n"
- title: 3.3 Multiplexed Message Construction
  contents:
  - "3.3 Multiplexed Message Construction\n   When a transport provider (e.g., TCP\
    \ or UDP) sends a segment, TMux\n   first removes the IP header (if present) and\
    \ adds a TMux mini-header\n   and the segment to the Multiplexed Message under\
    \ construction for the\n   host specified by the destination address of the segment.\n\
    \   When the first message to be transmitted is placed into the\n   Multiplexed\
    \ Message under construction, a timer is started.  When the\n   timer expires,\
    \ the Multiplexed Message under construction is\n   transmitted. This ensures\
    \ that all segments available for sending\n   before the timer expires are sent\
    \ in a single Multiplexed Message.\n   If, during construction of the Multiplexed\
    \ Message, the buffer\n   holding the message fills, the Multiplexed Message is\
    \ transmitted\n   immediately.\n   The delay time should be user configurable;\
    \ a reasonable time is 20\n   to 30 milliseconds.  The time period should be large\
    \ enough to give a\n   reasonable probability of sending multiple segments but\
    \ not so large\n   that the echo response time becomes a problem.  This suggests\
    \ that\n   the upper limit for the timer is probably 1/10th second.  As the cost\n\
    \   of using timeouts on many systems is quite large, it is recommended\n   that\
    \ a single timer be used and that all TMux messages under\n   construction are\
    \ sent when the timer expires.\n   Additionally, configuration options may limit\
    \ the number of included\n   data segments or the maximum size of the Multiplexed\
    \ Message before\n   it is transmitted.  It is also suggested that larger segments\
    \ (e.g.,\n   those over 700 octets) should be sent as standard IP datagrams, and\n\
    \   not multiplexed.  This is to ensure that the delay caused by the TMux\n  \
    \ timer does not put a delay on those segments for which it is\n   inadvisable.\
    \  The size of the largest segments to be multiplexed\n   should (if possible)\
    \ be configurable.\n"
- title: 4. Protocol Example
  contents:
  - "4. Protocol Example\n   This example shows a TMux message consisting of three\
    \ multiplexed\n   segments:\n   A TCP segment consisting of a 20 octet TCP header,\
    \ 5 octets of data\n   and 3 octets of padding.  Thus the length field is\n  \
    \           Mini header + TCP header + data\n           =     4       +     20\
    \     +  5\n           =     29\n   The padding is NOT included in the length.\n\
    \   A TCP segment consisting of a 20 octet TCP header, 4 octets of data.\n   This\
    \ segment does not require padding.\n   A UDP segment consisting of a 4 octet\
    \ UDP header, 41 octets of data\n   and 3 octets of padding.\n               \
    \      +-------------------------------+\n                     |         Length\
    \ = 29           |\n                     |         (2 octets)            |\n \
    \                    +-------------------------------+\n                     |\
    \     Protocol ID = 6 (TCP)     |\n                     +-------------------------------+\n\
    \                     |          Checksum             |\n                    \
    \ +-------------------------------+\n                     |         TCP Header\
    \            |\n                     |        (20 octets)            |\n     \
    \                +-------------------------------+\n                     |   \
    \       TCP data             |\n                     |         (5 octets)    \
    \        |\n                     +-------------------------------+\n         \
    \            |          Padding              |\n                     |       \
    \  (3 octets)            |\n                     +-------------------------------+\n\
    \                     |         Length = 28           |\n                    \
    \ |         (2 octets)            |\n                     +-------------------------------+\n\
    \                     |     Protocol ID = 6 (TCP)     |\n                    \
    \ +-------------------------------+\n                     |          Checksum\
    \             |\n                     +-------------------------------+\n    \
    \                 |         TCP Header            |\n                     |  \
    \      (20 octets)            |\n                     +-------------------------------+\n\
    \                     |          TCP data             |\n                    \
    \ |         (4 octets)            |\n                     +-------------------------------+\n\
    \                     |         Length = 49           |\n                    \
    \ |         (2 octets)            |\n                     +-------------------------------+\n\
    \                     |    Protocol ID = 17 (UDP)     |\n                    \
    \ +-------------------------------+\n                     |          Checksum\
    \             |\n                     +-------------------------------+\n    \
    \                 |         UDP Header            |\n                     |  \
    \       (4 octets)            |\n                     +-------------------------------+\n\
    \                     |          UDP data             |\n                    \
    \ |         (41 octets)           |\n                     +-------------------------------+\n\
    \                     |          Padding              |\n                    \
    \ |         (3 octets)            |\n                     +-------------------------------+\n"
- title: 5. Implementation Suggestion
  contents:
  - '5. Implementation Suggestion

    '
- title: 5.1 Maximum TMux Message Size
  contents:
  - "5.1 Maximum TMux Message Size\n   In section 3.3, a note is made about sending\
    \ messages immediately if\n   the limit on TMux message size is reached.  On systems\
    \ where Path MTU\n   Discovery (as per RFC 1191 [4]) has been implemented this\
    \ should be\n   used to discover the maximum message size that can be transmitted,\n\
    \   and this should be used as the maximum TMux message size.\n"
- title: 5.2 Deciding Which Segments to Multiplex
  contents:
  - "5.2 Deciding Which Segments to Multiplex\n   It is the responsibility of the\
    \ sender to decide which segments\n   should be TMux'd and which should not. \
    \ For example, segments sent by\n   FTP should not normally be multiplexed.  In\
    \ many situations, it may\n   be sensible to restrict the sessions that can be\
    \ multiplexed to just\n   those involved in interactive traffic (Telnet and Rlogin)\
    \ by\n   examining the source and destination TCP port numbers.  However, if a\n\
    \   segment that would not normally be multiplexed is to be sent and a\n   TMux\
    \ message is already under construction, then the extra segment\n   can be added\
    \ to the TMux message under construction, and this\n   complete message should\
    \ be sent immediately, rather than waiting for\n   the timer to expire.\n"
- title: 6. Implementation notes
  contents:
  - "6. Implementation notes\n   The following notes are the result of experience\
    \ gained during the\n   testing of early implementations of TMux.  Whilst they\
    \ do not form\n   part of the actual standard, they should be followed if possible\
    \ to\n   ensure compatibility with other implementations.\n   Because the TMux\
    \ mini-header does not contain a TOS field, only\n   segments with the same IP\
    \ TOS field should be contained in a single\n   TMux message.  As most systems\
    \ do not use the TOS feature, this is\n   not a major restriction.  Where the\
    \ TOS field is used, it may be\n   desirable to hold several messages under construction\
    \ for a host, one\n   for each TOS value.\n   Segments containing IP options should\
    \ not be multiplexed.\n   Only unicast addresses should be considered for multiplexing.\n\
    \   Segments addressed to the loopback address (127.0.0.1) are not\n   candidates\
    \ for multiplexing.\n   Only segments with a source or destination port that is\
    \ for an\n   interactive session (i.e., Telnet and Rlogin) should be considered\n\
    \   for multiplexing using TMux.\n   If an error is discovered in a checksum of\
    \ a TMux header, the rest of\n   the message, starting there, is ignored.  If\
    \ an unknown PROTOCOL\n   field is discovered in any TMux header, this segment,\
    \ and only this\n   one, is ignored.\n   If the TMux implementation is continually\
    \ sending TMux messages\n   containing exactly one segment (because is there is\
    \ little traffic to\n   multiplex), then TMux may be turned off.  This implies\
    \ that TMux may\n   be switched off when there is no congestion.\n   To prevent\
    \ intermediate nodes from fragmenting and reconstructing\n   TMux frames, implementations\
    \ may want to set the \"do not fragment\"\n   flag in the IP datagram of TMux\
    \ messages.\n   If host B receives a TMux ENQ message from host A, but does not\
    \ have\n   any data for host A, then it may also send back an ENQ message.\n \
    \  However, host A may send another ENQ message in response to this, so\n   causing\
    \ B to respond and so on.  Thus if this facility is used, code\n   must be included\
    \ to prevent this looping behavior happening.  Sending\n   an ENQ in response\
    \ to an ENQ is not recommended, except in special\n   circumstances.\n   It is\
    \ recommended that the following aspects of the TMux protocol be\n   user configurable:\n\
    \      The maximum size of a segment that can be multiplexed by TMux.\n      The\
    \ delay between the first segment being placed into the message\n      under construction\
    \ and the message being sent.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   Because TMux is effectively an extension to IP,\
    \ it does not have any\n   more impact on site security than does IP.  Security\
    \ should be dealt\n   with by upper layer protocols.\n   Because some routers\
    \ filter packets on the TCP port numbers, any\n   segments sent using TMux will\
    \ not be subject to this filtering as it\n   will obscure the TCP port number\
    \ However, larger segments for the\n   same TCP connection will still be sent\
    \ as IP datagrams, and so will\n   be subject to filtering, thus giving rise to\
    \ a potential problem.\n   For this reason, any routers that do not support TMux,\
    \ but which do\n   support this type of filtering should not allow TMux messages\
    \ through\n   (in either direction).  This will cause both hosts to think the\
    \ other\n   does not support TMux, so all segments will be sent as IP datagrams,\n\
    \   thus eliminating this problem.\n   A better solution to this problem, is for\
    \ routers to understand the\n   TMux protocol, and to inspect each of the multiplexed\
    \ segments and\n   remove those segments that fail the filtering.\n"
- title: 8. References
  contents:
  - "8. References\n   [1] Cohen, D., and Postel, J., \"Multiplexing Protocol\", IEN\
    \ 90,\n       USC/Information Sciences Institute,, May 1979.\n   [2] Postel, J.,\
    \ \"Internet Protocol\", STD 5, RFC 791, USC/Information\n       Sciences Institute,\
    \ September 1981.\n   [3] Reynolds, J. and J. Postel, \"Assigned Numbers\", STD\
    \ 2, RFC 1340,\n       USC/Information Sciences Institute, March 1990.\n   [4]\
    \ Mogul, J., and S. Deering, \"Path MTU discovery\", RFC 1191, DECWRL\n      \
    \ and Stanford University, November 1990.\n"
- title: 9. Authors' Addresses
  contents:
  - "9. Authors' Addresses\n       Peter Cameron\n       Xylogics International, Ltd.\n\
    \       Featherstone Rd.\n       Wolverton Mill\n       Milton Keynes\n      \
    \ MK12 5RD\n       United Kingdom\n       Phone: +44  908 222112\n       Fax:\
    \   +44  908 222115\n       EMail: cameron@xylint.co.uk\n       David Crocker\n\
    \       Silicon Graphics, Inc.\n       2011 N. Shoreline Blvd.\n       P.O. Box\
    \ 7311\n       Mountain View, CA 94039-7311\n       USA\n       Phone: +1 415\
    \ 390 1804\n       Fax:   +1 415 962 8404\n       EMail: dcrocker@sgi.com\n  \
    \     Danny Cohen\n       Myricom\n       325 N. Santa Anita Ave.\n       Arcadia,\
    \ CA 91006\n       USA\n       Phone: +1 818 821 5555\n       EMail: Cohen@myricom.com\n\
    \       Jon Postel\n       USC/Information Sciences Institute\n       4676 Admiralty\
    \ Way\n       Marina del Rey, CA  90292-6695\n       USA\n       Phone: +1 310\
    \ 822 1511\n       Fax:   +1 310 823 6714\n       EMail: Postel@ISI.EDU\n"
- title: 10. Discussion List
  contents:
  - "10. Discussion List\n       There is a discussion list for this protocol, which\
    \ for\n       historical reasons is called:\n           cmp-id@xylint.co.uk\n\
    \   Requests to join the list should be sent to:\n           cmp-id-request@xylint.co.uk\n"
