- title: __initial_text__
  contents:
  - "      Application Bridging for Federated Access Beyond Web (ABFAB)\n        \
    \                      Architecture\n"
- title: Abstract
  contents:
  - "Abstract\n   Over the last decade, a substantial amount of work has occurred\
    \ in\n   the space of federated access management.  Most of this effort has\n\
    \   focused on two use cases: network access and web-based access.\n   However,\
    \ the solutions to these use cases that have been proposed and\n   deployed tend\
    \ to have few building blocks in common.\n   This memo describes an architecture\
    \ that makes use of extensions to\n   the commonly used security mechanisms for\
    \ both federated and non-\n   federated access management, including the Remote\
    \ Authentication\n   Dial-In User Service (RADIUS), the Generic Security Service\n\
    \   Application Program Interface (GSS-API), the Extensible\n   Authentication\
    \ Protocol (EAP), and the Security Assertion Markup\n   Language (SAML).  The\
    \ architecture addresses the problem of federated\n   access management to primarily\
    \ non-web-based services, in a manner\n   that will scale to large numbers of\
    \ Identity Providers, Relying\n   Parties, and federations.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7831.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Terminology ................................................5\n  \
    \         1.1.1. Channel Binding .....................................6\n    \
    \  1.2. An Overview of Federation ..................................8\n      1.3.\
    \ Challenges for Contemporary Federation ....................11\n      1.4. An\
    \ Overview of ABFAB-Based Federation .....................11\n      1.5. Design\
    \ Goals ..............................................14\n   2. Architecture ...................................................15\n\
    \      2.1. Relying Party to Identity Provider ........................16\n  \
    \         2.1.1. AAA, RADIUS, and Diameter ..........................17\n    \
    \       2.1.2. Discovery and Rules Determination ..................19\n      \
    \     2.1.3. Routing and Technical Trust ........................20\n        \
    \   2.1.4. AAA Security .......................................21\n          \
    \ 2.1.5. SAML Assertions ....................................22\n      2.2. Client\
    \ to Identity Provider ...............................24\n           2.2.1. Extensible\
    \ Authentication Protocol (EAP) ...........24\n           2.2.2. EAP Channel Binding\
    \ ................................26\n      2.3. Client to Relying Party ...................................26\n\
    \           2.3.1. GSS-API ............................................27\n  \
    \         2.3.2. Protocol Transport .................................28\n    \
    \       2.3.3. Re-authentication ..................................29\n   3. Application\
    \ Security Services ..................................29\n      3.1. Authentication\
    \ ............................................29\n      3.2. GSS-API Channel Binding\
    \ ...................................31\n      3.3. Host-Based Service Names ..................................32\n\
    \      3.4. Additional GSS-API Services ...............................33\n  \
    \ 4. Privacy Considerations .........................................34\n    \
    \  4.1. Entities and Their Roles ..................................35\n      4.2.\
    \ Privacy Aspects of ABFAB Communication Flows ..............36\n           4.2.1.\
    \ Client to RP .......................................36\n           4.2.2. Client\
    \ to IdP (via Federation Substrate) ...........37\n           4.2.3. IdP to RP\
    \ (via Federation Substrate) ...............38\n      4.3. Relationship between\
    \ User and Entities ....................39\n      4.4. Accounting Information\
    \ ....................................39\n      4.5. Collection and Retention\
    \ of Data and Identifiers ..........39\n      4.6. User Participation ........................................40\n\
    \   5. Security Considerations ........................................40\n  \
    \ 6. References .....................................................41\n    \
    \  6.1. Normative References ......................................41\n      6.2.\
    \ Informative References ....................................42\n   Acknowledgments\
    \ ...................................................46\n   Authors' Addresses\
    \ ................................................46\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Numerous security mechanisms have been deployed on the Internet\
    \ to\n   manage access to various resources.  These mechanisms have been\n   generalized\
    \ and scaled over the last decade through mechanisms such\n   as the Simple Authentication\
    \ and Security Layer (SASL) with the\n   Generic Security Server Application Program\
    \ Interface (GSS-API)\n   (known as the GS2 family) [RFC5801]; the Security Assertion\
    \ Markup\n   Language (SAML) [OASIS.saml-core-2.0-os]; and the Authentication,\n\
    \   Authorization, and Accounting (AAA) architecture as embodied in\n   RADIUS\
    \ [RFC2865] and Diameter [RFC6733].\n   A Relying Party (RP) is the entity that\
    \ manages access to some\n   resource.  The entity that is requesting access to\
    \ that resource is\n   often described as the client.  Many security mechanisms\
    \ are\n   manifested as an exchange of information between these entities.\n \
    \  The RP is therefore able to decide whether the client is authorized\n   or\
    \ not.\n   Some security mechanisms allow the RP to delegate aspects of the\n\
    \   access management decision to an entity called the Identity Provider\n   (IdP).\
    \  This delegation requires technical signaling, trust, and a\n   common understanding\
    \ of semantics between the RP and IdP.  These\n   aspects are generally managed\
    \ within a relationship known as a\n   \"federation\".  This style of access management\
    \ is accordingly\n   described as \"federated access management\".\n   Federated\
    \ access management has evolved over the last decade through\n   specifications\
    \ like SAML [OASIS.saml-core-2.0-os], OpenID\n   (http://www.openid.net), OAuth\
    \ [RFC6749], and WS-Trust [WS-TRUST].\n   The benefits of federated access management\
    \ include:\n   Single or simplified sign-on:\n      An Internet service can delegate\
    \ access management, and the\n      associated responsibilities such as identity\
    \ management and\n      credentialing, to an organization that already has a long-term\n\
    \      relationship with the client.  This is often attractive, as RPs\n     \
    \ frequently do not want these responsibilities.  The client also\n      requires\
    \ fewer credentials, which is also desirable.\n   Data minimization and user participation:\n\
    \      Often, an RP does not need to know the identity of a client to\n      reach\
    \ an access management decision.  It is frequently only\n      necessary for the\
    \ RP to know specific attributes about the client\n      -- for example, that\
    \ the client is affiliated with a particular\n      organization or has a certain\
    \ role or entitlement.  Sometimes, the\n      RP only needs to know a pseudonym\
    \ of the client.\n      Prior to the release of attributes to the RP from the\
    \ IdP, the IdP\n      will check configuration and policy to determine if the\
    \ attributes\n      are to be released.  There is currently no direct client\n\
    \      participation in this decision.\n   Provisioning:\n      Sometimes, an\
    \ RP needs, or would like, to know more about a client\n      than an affiliation\
    \ or a pseudonym.  For example, an RP may want\n      the client's email address\
    \ or name.  Some federated access\n      management technologies provide the ability\
    \ for the IdP to supply\n      this information, either on request by the RP or\
    \ unsolicited.\n   This memo describes the Application Bridging for Federated\
    \ Access\n   Beyond web (ABFAB) architecture.  This architecture addresses the\n\
    \   problem of federated access management primarily for non-web-based\n   services.\
    \  This architecture makes use of extensions to the commonly\n   used security\
    \ mechanisms for both federated and non-federated access\n   management, including\
    \ RADIUS, the Generic Security Service (GSS), the\n   Extensible Authentication\
    \ Protocol (EAP), and SAML.  The architecture\n   should be extended to use Diameter\
    \ in the future.  It does so in a\n   manner that is designed to scale to large\
    \ numbers of IdPs, RPs, and\n   federations.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   This document uses identity management and privacy terminology\
    \ from\n   [RFC6973].  In particular, this document uses the terms\n   \"identity\
    \ provider\", \"relying party\", \"identifier\", \"pseudonymity\",\n   \"unlinkability\"\
    , and \"anonymity\".\n   In this architecture, the IdP consists of the following\
    \ components:\n   an EAP server, a RADIUS server, and, optionally, a SAML Assertion\n\
    \   service.\n   This document uses the term \"Network Access Identifier\" (NAI)\
    \ as\n   defined in [RFC7542].  An NAI consists of a realm identifier, which\n\
    \   is associated with a AAA server, and thus an IdP and a username, that\n  \
    \ are associated with a specific client of the IdP.\n   One of the problems some\
    \ people have found with reading this document\n   is that the terminology sometimes\
    \ appears to be inconsistent.  This\n   is because the various standards that\
    \ we refer to use different terms\n   for the same concept.  In general, this\
    \ document uses either the\n   ABFAB term or the term associated with the standard\
    \ under discussion,\n   as appropriate.  For reference, we include Table 1 below,\
    \ which\n   provides a mapping for these different terms.  (Note that items\n\
    \   marked \"N/A\" (not applicable) indicate that there is no name that\n   represents\
    \ the entity.)\n   +----------+-----------+--------------------+-----------------------+\n\
    \   | Protocol | Client    | Relying Party      | Identity Provider     |\n  \
    \ +----------+-----------+--------------------+-----------------------+\n   |\
    \ ABFAB    | N/A       | Relying Party (RP) | Identity Provider     |\n   |  \
    \        |           |                    | (IdP)                 |\n   |    \
    \      |           |                    |                       |\n   |      \
    \    | Initiator | Acceptor           | N/A                   |\n   |        \
    \  |           |                    |                       |\n   |          |\
    \ Client    | Server             | N/A                   |\n   |          |  \
    \         |                    |                       |\n   | SAML     | Subject\
    \   | Service provider   | Issuer                |\n   |          |          \
    \ |                    |                       |\n   | GSS-API  | Initiator |\
    \ Acceptor           | N/A                   |\n   |          |           |  \
    \                  |                       |\n   | EAP      | EAP peer  | EAP\
    \ authenticator  | EAP server            |\n   |          |           |      \
    \              |                       |\n   | AAA      | N/A       | AAA client\
    \         | AAA server            |\n   |          |           |             \
    \       |                       |\n   | RADIUS   | user      | NAS           \
    \     | N/A                   |\n   |          |           |                 \
    \   |                       |\n   |          | N/A       | RADIUS client     \
    \ | RADIUS server         |\n   +----------+-----------+--------------------+-----------------------+\n\
    \                           Table 1: Terminology\n"
- title: 1.1.1.  Channel Binding
  contents:
  - "1.1.1.  Channel Binding\n   This document uses the term \"channel binding\" in\
    \ two different\n   contexts; this term has a different meaning in each of these\n\
    \   contexts.\n   EAP channel binding is used to implement GSS-API naming semantics.\n\
    \   EAP channel binding sends a set of attributes from the peer to the\n   EAP\
    \ server either as part of the EAP conversation or as part of a\n   secure association\
    \ protocol.  In addition, attributes are sent in the\n   back-end protocol from\
    \ the EAP authenticator to the EAP server.  The\n   EAP server confirms the consistency\
    \ of these attributes and provides\n   the confirmation back to the peer.  In\
    \ this document, channel binding\n   without qualification refers to EAP channel\
    \ binding.\n   GSS-API channel binding provides protection against man-in-the-middle\n\
    \   attacks when GSS-API is used for authentication inside of some\n   tunnel;\
    \ it is similar to a facility called \"cryptographic binding\" in\n   EAP.  The\
    \ binding works by each side deriving a cryptographic value\n   from the tunnel\
    \ itself and then using that cryptographic value to\n   prove to the other side\
    \ that it knows the value.\n   See [RFC5056] for a discussion of the differences\
    \ between these two\n   facilities.  These differences can be summarized as follows:\n\
    \   o  GSS-API channel binding specifies that there is nobody between the\n  \
    \    client and the EAP authenticator.\n   o  EAP channel binding allows the client\
    \ to have knowledge of such\n      EAP authenticator attributes as the EAP authenticator's\
    \ name.\n   Typically, when considering both EAP and GSS-API channel binding,\n\
    \   people think of channel binding in combination with mutual\n   authentication.\
    \  This is sufficiently common that, without additional\n   qualification, channel\
    \ binding should be assumed to imply mutual\n   authentication.  In GSS-API, without\
    \ mutual authentication, only the\n   acceptor has authenticated the initiator.\
    \  Similarly, in EAP, only\n   the EAP server has authenticated the peer.  Sometimes,\
    \ one-way\n   authentication is useful.  Consider, for example, a user who wishes\n\
    \   to access a protected resource for a shared whiteboard in a\n   conference\
    \ room.  The whiteboard is the acceptor; it knows that the\n   initiator is authorized\
    \ to give it a presentation, and the user can\n   validate that the whiteboard\
    \ got the correct presentation by visual\n   means.  (The presentation should\
    \ not be confidential in this case.)\n   If channel binding is used without mutual\
    \ authentication, it is\n   effectively a request to disclose the resource in\
    \ the context of a\n   particular channel.  Such an authentication would be similar\
    \ in\n   concept to a holder-of-key SAML Assertion.  However, note also that\n\
    \   although it is not happening in the protocol, mutual authentication\n   is\
    \ happening in the overall system: the user is able to visually\n   authenticate\
    \ the content.  This is consistent with all uses of\n   channel binding without\
    \ protocol-level mutual authentication found\n   so far.\n"
- title: 1.2.  An Overview of Federation
  contents:
  - "1.2.  An Overview of Federation\n   In the previous section, we introduced the\
    \ following entities:\n   o  the client,\n   o  the IdP, and\n   o  the RP.\n\
    \   The final entity that needs to be introduced is the Individual.  An\n   Individual\
    \ is a human being that is using the client.  In any given\n   situation, an Individual\
    \ may or may not exist.  Clients can act as\n   front ends for Individuals, or\
    \ clients may be independent entities\n   that are set up and allowed to run autonomously.\
    \  An example of such\n   an independent entity can be found in the Trust Router\
    \ Protocol\n   (https://www.ietf.org/proceedings/86/slides/slides-86-rtgarea-0.pdf),\n\
    \   where the routers use ABFAB to authenticate to each other.\n   These entities\
    \ and their relationships are illustrated graphically in\n   Figure 1.\n     \
    \        ,----------\\                        ,---------\\\n             | Identity\
    \ |       Federation       | Relying |\n             | Provider + <-------------------->\
    \ + Party   |\n             `----------'                        '---------'\n\
    \                    <\n                     \\\n                      \\ Authentication\n\
    \                       \\\n                        \\\n                     \
    \    \\\n                          \\\n                           \\  +---------+\n\
    \                            \\ |         |  O\n                             v|\
    \ Client  | \\|/ Individual\n                              |         |  |\n  \
    \                            +---------+ / \\\n                Figure 1: Entities\
    \ and Their Relationships\n   The relationships between the entities in Figure\
    \ 1 are as follows:\n   Federation\n      The IdP and the RPs are part of a federation.\
    \  The relationship\n      may be direct (they have an explicit trust relationship)\
    \ or\n      transitive (the trust relationship is mediated by one or more\n  \
    \    entities).  The federation relationship is governed by a\n      federation\
    \ agreement.  Within a single federation, there may be\n      multiple IdPs as\
    \ well as multiple RPs.\n   Authentication\n      There is a direct relationship\
    \ between the client and the IdP.\n      This relationship provides the means\
    \ by which they trust each\n      other and can securely authenticate each other.\n\
    \   A federation agreement typically encompasses operational\n   specifications\
    \ and legal rules:\n   Operational Specifications:\n      The goal of operational\
    \ specifications is to provide enough\n      definition that the system works\
    \ and interoperability is possible.\n      These include the technical specifications\
    \ (e.g., protocols used\n      to communicate between the three parties), process\
    \ standards,\n      policies, identity proofing, credential and authentication\n\
    \      algorithm requirements, performance requirements, assessment and\n    \
    \  audit criteria, etc.\n   Legal Rules:\n      The legal rules take the legal\
    \ framework into consideration and\n      provide contractual obligations for\
    \ each entity.  The rules define\n      the responsibilities of each party and\
    \ provide further\n      clarification of the operational specifications.  These\
    \ legal\n      rules regulate the operational specifications, make operational\n\
    \      specifications legally binding to the participants, and define and\n  \
    \    govern the rights and responsibilities of the participants.  The\n      legal\
    \ rules may, for example, describe liability for losses,\n      termination rights,\
    \ enforcement mechanisms, measures of damage,\n      dispute resolution, warranties,\
    \ etc.\n   The operational specifications can demand the usage of a specific\n\
    \   technical infrastructure, including requirements on the message\n   routing\
    \ intermediaries, to offer the required technical\n   functionality.  In other\
    \ environments, the operational specifications\n   require fewer technical components\
    \ in order to meet the required\n   technical functionality.\n   The legal rules\
    \ include many non-technical aspects of federation,\n   such as business practices\
    \ and legal arrangements, which are outside\n   the scope of the IETF.  The legal\
    \ rules can still have an impact on\n   the architectural setup or on how to ensure\
    \ the dynamic establishment\n   of trust.\n   While a federation agreement is\
    \ often discussed within the context of\n   formal relationships, such as between\
    \ an enterprise and an employee\n   or between a government and a citizen, a federation\
    \ agreement does\n   not have to require any particular level of formality.  For\
    \ an IdP\n   and a client, it is sufficient for a relationship to be established\n\
    \   by something as simple as using a web form and confirmation email.\n   For\
    \ an IdP and an RP, it is sufficient for the IdP to publish contact\n   information\
    \ along with a public key and for the RP to use that data.\n   Within the framework\
    \ of ABFAB, it will generally be required that a\n   mechanism exist for the IdP\
    \ to be able to trust the identity of the\n   RP; if this is not present, then\
    \ the IdP cannot provide the\n   assurances to the client that the identity of\
    \ the RP has been\n   established.\n   The nature of federation dictates that\
    \ there exists some form of\n   relationship between the IdP and the RP.  This\
    \ is particularly\n   important when the RP wants to use information obtained\
    \ from the IdP\n   for access management decisions and when the IdP does not want\
    \ to\n   release information to every RP (or only under certain conditions).\n\
    \   While it is possible to have a bilateral agreement between every IdP\n   and\
    \ every RP, on an Internet scale, this setup requires the\n   introduction of\
    \ the multilateral federation concept, as the\n   management of such pair-wise\
    \ relationships would otherwise prove\n   burdensome.\n   The IdP will typically\
    \ have a long-term relationship with the client.\n   This relationship typically\
    \ involves the IdP positively identifying\n   and credentialing the client (for\
    \ example, at the time of employment\n   within an organization).  When dealing\
    \ with Individuals, this process\n   is called \"identity proofing\" [NIST-SP.800-63-2].\
    \  The relationship\n   will often be instantiated within an agreement between\
    \ the IdP and\n   the client (for example, within an employment contract or terms\
    \ of\n   use that stipulate the appropriate use of credentials and so forth).\n\
    \   The nature and quality of the relationship between the client and the\n  \
    \ IdP are important contributors to the level of trust that an RP may\n   assign\
    \ to an assertion describing a client made by an IdP.  This is\n   sometimes described\
    \ as the level of assurance [NIST-SP.800-63-2].\n   Federation does not require\
    \ an a priori relationship or a long-term\n   relationship between the RP and\
    \ the client; it is this property of\n   federation that yields many of its benefits.\
    \  However, federation\n   does not preclude the possibility of a pre-existing\
    \ relationship\n   between the RP and the client or the possibility that the RP\
    \ and\n   client may use the introduction to create a new long-term\n   relationship\
    \ independent of the federation.\n   Finally, it is important to reiterate that\
    \ in some scenarios there\n   might indeed be an Individual behind the client\
    \ and in other cases\n   the client may be autonomous.\n"
- title: 1.3.  Challenges for Contemporary Federation
  contents:
  - "1.3.  Challenges for Contemporary Federation\n   As federated IdPs and RPs (services)\
    \ proliferate, the role of an\n   Individual can become ambiguous in certain circumstances.\
    \  For\n   example, a school might provide online access for a student's grades\n\
    \   to their parents for review and to the student's teacher for\n   modification.\
    \  A teacher who is also a parent must clearly\n   distinguish their role upon\
    \ access.\n   Similarly, as federations proliferate, it becomes increasingly\n\
    \   difficult to discover which IdP(s) a user is associated with.  This\n   is\
    \ true for both the web and non-web case but is particularly acute\n   for the\
    \ latter, as many non-web authentication systems are not\n   semantically rich\
    \ enough on their own to allow for such ambiguities.\n   For instance, in the\
    \ case of an email provider, SMTP and IMAP do not\n   have the ability for the\
    \ server to request information from the\n   client, beyond the client NAI, that\
    \ the server would then use to\n   decide between the multiple federations it\
    \ is associated with.\n   However, the building blocks do exist to add this functionality.\n"
- title: 1.4.  An Overview of ABFAB-Based Federation
  contents:
  - "1.4.  An Overview of ABFAB-Based Federation\n   The previous section described\
    \ the general model of federation and\n   the application of access management\
    \ within the federation.  This\n   section provides a brief overview of ABFAB\
    \ in the context of this\n   model.\n   In this example, a client is attempting\
    \ to connect to a server in\n   order to either get access to some data or perform\
    \ some type of\n   transaction.  In order for the client to mutually authenticate\
    \ with\n   the server, the following steps are taken in an ABFAB architecture\
    \ (a\n   graphical view of the steps can be found in Figure 2):\n   1.   Client\
    \ configuration: The client is configured with an NAI\n        assigned by the\
    \ IdP.  It is also configured with any keys,\n        certificates, passwords,\
    \ or other secret and public information\n        needed to run the EAP protocols\
    \ between it and the IdP.\n   2.   Authentication mechanism selection: The client\
    \ is configured to\n        use the GSS-EAP GSS-API mechanism for authentication/\n\
    \        authorization.\n   3.   Client provides an NAI to RP: The client sets\
    \ up a transport to\n        the RP and begins GSS-EAP authentication.  In response,\
    \ the RP\n        sends an EAP request message (nested in GSS-EAP) asking for\
    \ the\n        client's name.  The client sends an EAP response with an NAI\n\
    \        name form that, at a minimum, contains the realm portion of its\n   \
    \     full NAI.\n   4.   Discovery of federated IdP: The RP uses preconfigured\n\
    \        information or a federation proxy to determine what IdP to use,\n   \
    \     based on policy and the realm portion of the provided client\n        NAI.\
    \  This is discussed in detail below (Section 2.1.2).\n   5.   Request from RP\
    \ to IdP: Once the RP knows who the IdP is, it (or\n        its agent) will send\
    \ a RADIUS request to the IdP.  The RADIUS\n        Access-Request encapsulates\
    \ the EAP response.  At this stage,\n        the RP will likely have no idea who\
    \ the client is.  The RP sends\n        its identity to the IdP in AAA attributes,\
    \ and it may send a\n        SAML request in a AAA attribute.  The AAA network\
    \ checks to see\n        that the identity claimed by the RP is valid.\n   6.\
    \   IdP begins EAP with the client: The IdP sends an EAP message to\n        the\
    \ client with an EAP method to be used.  The IdP should not\n        re-request\
    \ the client's name in this message, but clients need\n        to be able to handle\
    \ it.  In this case, the IdP must accept a\n        realm only in order to protect\
    \ the client's name from the RP.\n        The available and appropriate methods\
    \ are discussed below\n        (Section 2.2.1).\n   7.   EAP is run: A bunch of\
    \ EAP messages are passed between the\n        client (EAP peer) and the IdP (EAP\
    \ server), until the result of\n        the authentication protocol is determined.\
    \  The number and\n        content of those messages depend on the EAP method\
    \ selected.  If\n        the IdP is unable to authenticate the client, the IdP\
    \ sends an\n        EAP failure message to the RP.  As part of the EAP method,\
    \ the\n        client sends an EAP channel-binding message to the IdP\n      \
    \  (Section 2.2.2).  In the channel-binding message, the client\n        identifies,\
    \ among other things, the RP to which it is attempting\n        to authenticate.\
    \  The IdP checks the channel-binding data from\n        the client against the\
    \ data provided by the RP via the AAA\n        protocol.  If the bindings do not\
    \ match, the IdP sends an EAP\n        failure message to the RP.\n   8.   Successful\
    \ EAP authentication: At this point, the IdP (EAP\n        server) and client\
    \ (EAP peer) have mutually authenticated each\n        other.  As a result, the\
    \ client and the IdP hold two\n        cryptographic keys: a Master Session Key\
    \ (MSK) and an Extended\n        MSK (EMSK).  At this point, the client has a\
    \ level of assurance\n        regarding the identity of the RP, based on the name\
    \ checking the\n        IdP has done, using the RP naming information from the\
    \ AAA\n        framework and from the client (by the channel-binding data).\n\
    \   9.   Local IdP policy check: At this stage, the IdP checks local\n       \
    \ policy to determine whether the RP and client are authorized for\n        a\
    \ given transaction/service and, if so, what attributes, if any,\n        will\
    \ be released to the RP.  If the IdP gets a policy failure,\n        it sends\
    \ an EAP failure message to the RP and client.  (The RP\n        will have done\
    \ its policy checks during the discovery process.)\n   10.  IdP provides the RP\
    \ with the MSK: The IdP sends a success result\n        EAP to the RP, along with\
    \ an optional set of AAA attributes\n        associated with the client (usually\
    \ as one or more SAML\n        Assertions).  In addition, the EAP MSK is returned\
    \ to the RP.\n   11.  RP processes results: When the RP receives the result from\
    \ the\n        IdP, it should have enough information to either grant or refuse\n\
    \        a resource Access-Request.  It may have information that\n        associates\
    \ the client with specific authorization identities.\n        If additional attributes\
    \ are needed from the IdP, the RP may\n        make a new SAML request to the\
    \ IdP.  It will apply these results\n        in an application-specific way.\n\
    \   12.  RP returns results to client: Once the RP has a response, it\n      \
    \  must inform the client of the result.  If all has gone well, all\n        are\
    \ authenticated, and the application proceeds with appropriate\n        authorization\
    \ levels.  The client can now complete the\n        authentication of the RP by\
    \ using the EAP MSK value.\n        Relying         Client         Identity\n\
    \        Party                          Provider\n        |              (1) \
    \            | Client configuration\n        |               |              |\n\
    \        |<-----(2)----->|              | Mechanism selection\n        |     \
    \          |              |\n        |<-----(3)-----<|              | NAI transmitted\
    \ to RP\n        |               |              |\n        |<=====(4)====================>|\
    \ IdP Discovery\n        |               |              |\n        |>=====(5)====================>|\
    \ Access-Request from RP to IdP\n        |               |              |\n  \
    \      |               |< - - (6) - -<| EAP method to client\n        |      \
    \         |              |\n        |               |< - - (7) - ->| EAP exchange\
    \ to authenticate\n        |               |              | client\n        |\
    \               |              |\n        |               |           (8 & 9)\
    \ Local policy check\n        |               |              |\n        |<====(10)====================<|\
    \ Results to RP\n        |               |              |\n      (11)        \
    \      |              | RP processes results\n        |               |      \
    \        |\n        |>----(12)----->|              | Results to client\n     \
    \   Legend:\n          -----: Between client and RP\n          =====: Between\
    \ RP and IdP\n          - - -: Between client and IdP (via RP)\n             \
    \      Figure 2: ABFAB Authentication Steps\n"
- title: 1.5.  Design Goals
  contents:
  - "1.5.  Design Goals\n   Our key design goals are as follows:\n   o  Each party\
    \ in a transaction will be authenticated, although\n      perhaps not identified,\
    \ and the client will be authorized for\n      access to a specific resource.\n\
    \   o  The means of authentication is decoupled from the application\n      protocol\
    \ so as to allow for multiple authentication methods with\n      minimal changes\
    \ to the application.\n   o  The architecture requires no sharing of long-term\
    \ private keys\n      between clients and RPs.\n   o  The system will scale to\
    \ large numbers of IdPs, RPs, and users.\n   o  The system will be designed primarily\
    \ for non-web-based\n      authentication.\n   o  The system will build upon existing\
    \ standards, components, and\n      operational practices.\n   Designing new three-party\
    \ authentication and authorization protocols\n   is difficult and fraught with\
    \ the risk of cryptographic flaws.\n   Achieving widespread deployment is even\
    \ more difficult.  A lot of\n   attention on federated access has been devoted\
    \ to the web.  This\n   document instead focuses on a non-web-based environment\
    \ and focuses\n   on those protocols where HTTP is not used.  Despite the growing\
    \ trend\n   to layer every protocol on top of HTTP, there are still a number of\n\
    \   protocols available that do not use HTTP-based transports.  Many of\n   these\
    \ protocols are lacking a native authentication and authorization\n   framework\
    \ of the style shown in Figure 1.\n"
- title: 2.  Architecture
  contents:
  - "2.  Architecture\n   We have already introduced the federated access architecture,\
    \ with\n   the illustration of the different actors that need to interact.  This\n\
    \   section expands on the specifics of providing support for\n   non-web-based\
    \ applications and provides motivations for design\n   decisions.  The main theme\
    \ of the work described in this document is\n   focused on reusing existing building\
    \ blocks that have been deployed\n   already and to rearrange them in a novel\
    \ way.\n   Although this architecture assumes updates to the RP, the client, and\n\
    \   the IdP, those changes are kept at a minimum.  A mechanism that can\n   demonstrate\
    \ deployment benefits (based on ease of updates to existing\n   software, low\
    \ implementation effort, etc.) is preferred, and there\n   may be a need to specify\
    \ multiple mechanisms to support the range of\n   different deployment scenarios.\n\
    \   There are a number of ways to encapsulate EAP into an application\n   protocol.\
    \  For ease of integration with a wide range of non-web-based\n   application\
    \ protocols, GSS-API was chosen.  The technical\n   specification of GSS-EAP can\
    \ be found in [RFC7055].\n   The architecture consists of several building blocks,\
    \ as shown\n   graphically in Figure 3.  In the following sections, we discuss\
    \ the\n   data flow between each of the entities, the protocols used for that\n\
    \   data flow, and some of the trade-offs made in choosing the protocols.\n  \
    \                                  +--------------+\n                        \
    \            |   Identity   |\n                                    |   Provider\
    \   |\n                                    |    (IdP)     |\n                \
    \                    +-^----------^-+\n                                      *\
    \ EAP      o RADIUS\n                                      *          o\n    \
    \                                --v----------v--\n                          \
    \       ///                \\\\\\\n                               //         \
    \             \\\\\n                              |        Federation        |\n\
    \                              |        Substrate         |\n                \
    \               \\\\                      //\n                               \
    \  \\\\\\                ///\n                                    --^----------^--\n\
    \                                      * EAP      o RADIUS\n                 \
    \                     *          o\n   +-------------+                  +-v----------v--+\n\
    \   |             |                  |               |\n   | Client      |  EAP/EAP\
    \ Method  | Relying Party |\n   | Application |<****************>|     (RP)  \
    \    |\n   |             |  GSS-API         |               |\n   |          \
    \   |<---------------->|               |\n   |             |  Application    \
    \ |               |\n   |             |  Protocol        |               |\n \
    \  |             |<================>|               |\n   +-------------+    \
    \              +---------------+\n   Legend:\n     <****>: Client-to-IdP Exchange\n\
    \     <---->: Client-to-RP Exchange\n     <oooo>: RP-to-IdP Exchange\n     <====>:\
    \ Protocol through which GSS-API/GS2 exchanges are tunneled\n                \
    \  Figure 3: ABFAB Protocol Instantiation\n"
- title: 2.1.  Relying Party to Identity Provider
  contents:
  - "2.1.  Relying Party to Identity Provider\n   Communication between the RP and\
    \ the IdP is done by the Federation\n   Substrate.  This communication channel\
    \ is responsible for:\n   o  Establishing the trust relationship between the RP\
    \ and the IdP.\n   o  Determining the rules governing the relationship.\n   o\
    \  Conveying authentication packets from the client to the IdP\n      and back.\n\
    \   o  Providing the means of establishing a trust relationship between\n    \
    \  the RP and the client.\n   o  Providing a means for the RP to obtain attributes\
    \ about the client\n      from the IdP.\n   The ABFAB working group has chosen\
    \ the AAA framework for the messages\n   transported between the RP and IdP. \
    \ The AAA framework supports the\n   requirements stated above, as follows:\n\
    \   o  The AAA backbone supplies the trust relationship between the RP\n     \
    \ and the IdP.\n   o  The agreements governing a specific AAA backbone contain\
    \ the rules\n      governing the relationships within the AAA federation.\n  \
    \ o  A method exists for carrying EAP packets within RADIUS [RFC3579]\n      and\
    \ Diameter [RFC4072].\n   o  The use of EAP channel binding [RFC6677] along with\
    \ the core ABFAB\n      protocol provide the pieces necessary to establish the\
    \ identities\n      of the RP and the client, while EAP provides the cryptographic\n\
    \      methods for the RP and the client to validate that they are\n      talking\
    \ to each other.\n   o  A method exists for carrying SAML packets within RADIUS\
    \ [RFC7833];\n      this method allows the RP to query attributes about the client\n\
    \      from the IdP.\n   Protocols that support the same framework but do different\
    \ routing\n   are expected to be defined and used in the future.  One such effort,\n\
    \   called the Trust Router, is to set up a framework that creates a\n   trusted\
    \ point-to-point channel on the fly\n   (https://www.ietf.org/proceedings/86/slides/slides-86-rtgarea-0.pdf).\n"
- title: 2.1.1.  AAA, RADIUS, and Diameter
  contents:
  - "2.1.1.  AAA, RADIUS, and Diameter\n   The usage of the AAA framework with RADIUS\
    \ [RFC2865] and Diameter\n   [RFC6733] for network access authentication has been\
    \ successful from\n   a deployment point of view.  To map the terminology used\
    \ in Figure 1\n   to the AAA framework, the IdP corresponds to the AAA server;\
    \ the RP\n   corresponds to the AAA client; and the technical building blocks\
    \ of a\n   federation are AAA proxies, relays, and redirect agents (particularly\n\
    \   if they are operated by third parties, such as AAA brokers and\n   clearinghouses).\
    \  In the case of network access authentication, the\n   front end, i.e., the\
    \ communication path between the end host and the\n   AAA client, is offered by\
    \ link-layer protocols that forward\n   authentication protocol exchanges back\
    \ and forth.  An example of a\n   large-scale RADIUS-based federation is eduroam\n\
    \   (https://www.eduroam.org).\n   By using the AAA framework, ABFAB can be built\
    \ on the federation\n   agreements that already exist; the agreements can then\
    \ merely be\n   expanded to cover the ABFAB architecture.  The AAA framework has\n\
    \   already addressed some of the problems outlined above.  For example,\n   o\
    \  It already has a method for routing requests based on a domain.\n   o  It already\
    \ has an extensible architecture allowing for new\n      attributes to be defined\
    \ and transported.\n   o  Pre-existing relationships can be reused.\n   The astute\
    \ reader will notice that RADIUS and Diameter have\n   substantially similar characteristics.\
    \  Why not pick one?  RADIUS and\n   Diameter are deployed in different environments.\
    \  RADIUS can often be\n   found in enterprise and university networks; RADIUS\
    \ is also used by\n   operators of fixed networks.  Diameter, on the other hand,\
    \ is\n   deployed by operators of mobile networks.  Another key difference is\n\
    \   that today RADIUS is largely transported over UDP.  The decision\n   regarding\
    \ which protocol will be appropriate to deploy is left to\n   implementers.  The\
    \ protocol defines all the necessary new AAA\n   attributes as RADIUS attributes.\
    \  A future document could define the\n   same AAA attributes for a Diameter environment.\
    \  We also note that\n   there exist proxies that convert from RADIUS to Diameter\
    \ and back.\n   This makes it possible for both to be deployed in a single Federation\n\
    \   Substrate.\n   Through the integrity-protection mechanisms in the AAA framework,\
    \ the\n   IdP can establish technical trust that messages are being sent by the\n\
    \   appropriate RP.  Any given interaction will be associated with one\n   federation\
    \ at the policy level.  The legal or business relationship\n   defines what statements\
    \ the IdP is trusted to make and how these\n   statements are interpreted by the\
    \ RP.  The AAA framework also permits\n   the RP or elements between the RP and\
    \ IdP to make statements about\n   the RP.\n   The AAA framework provides transport\
    \ for attributes.  Statements made\n   about the client by the IdP, statements\
    \ made about the RP, and other\n   information are transported as attributes.\n\
    \   One demand that the AAA substrate makes of the upper layers is that\n   they\
    \ must properly identify the endpoints of the communication.  It\n   must be possible\
    \ for the AAA client at the RP to determine where to\n   send each RADIUS or Diameter\
    \ message.  Without this requirement, it\n   would be the RP's responsibility\
    \ to determine the identity of the\n   client on its own, without the assistance\
    \ of an IdP.  This\n   architecture makes use of the Network Access Identifier\
    \ (NAI), where\n   the IdP is indicated by the realm component [RFC7542].  The\
    \ NAI is\n   represented and consumed by the GSS-API layer as GSS_C_NT_USER_NAME,\n\
    \   as specified in [RFC2743].  The GSS-API EAP mechanism includes the\n   NAI\
    \ in the EAP Response/Identity message.\n   At the time of this writing, no profiles\
    \ for the use of Diameter have\n   been created.\n"
- title: 2.1.2.  Discovery and Rules Determination
  contents:
  - "2.1.2.  Discovery and Rules Determination\n   While we are using the AAA protocols\
    \ to communicate with the IdP, the\n   RP may have multiple Federation Substrates\
    \ to select from.  The RP\n   has a number of criteria that it will use in selecting\
    \ which of the\n   different federations to use.  The federation selected must\n\
    \   o  be able to communicate with the IdP.\n   o  match the business rules and\
    \ technical policies required for the\n      RP security requirements.\n   The\
    \ RP needs to discover which federation will be used to contact the\n   IdP. \
    \ The first selection criterion used during discovery is going to\n   be the name\
    \ of the IdP to be contacted.  The second selection\n   criterion used during\
    \ discovery is going to be the set of business\n   rules and technical policies\
    \ governing the relationship; this is\n   called \"rules determination\".  The\
    \ RP also needs to establish\n   technical trust in the communications with the\
    \ IdP.\n   Rules determination covers a broad range of decisions about the\n \
    \  exchange.  One of these is whether the given RP is permitted to talk\n   to\
    \ the IdP using a given federation at all, so rules determination\n   encompasses\
    \ the basic authorization decision.  Other factors are\n   included, such as what\
    \ policies govern release of information about\n   the client to the RP and what\
    \ policies govern the RP's use of this\n   information.  While rules determination\
    \ is ultimately a business\n   function, it has a significant impact on the technical\
    \ exchanges.\n   The protocols need to communicate the result of authorization.\
    \  When\n   multiple sets of rules are possible, the protocol must disambiguate\n\
    \   which set of rules are in play.  Some rules have technical\n   enforcement\
    \ mechanisms; for example, in some federations,\n   intermediaries validate information\
    \ that is being communicated within\n   the federation.\n   At the time of this\
    \ writing, no protocol mechanism has been specified\n   to allow a AAA client\
    \ to determine whether a AAA proxy will indeed be\n   able to route AAA requests\
    \ to a specific IdP.  The AAA routing is\n   impacted by business rules and technical\
    \ policies that may be quite\n   complex; at the present time, the route selection\
    \ is based on manual\n   configuration.\n"
- title: 2.1.3.  Routing and Technical Trust
  contents:
  - "2.1.3.  Routing and Technical Trust\n   Several approaches to having messages\
    \ routed through the Federation\n   Substrate are possible.  These routing methods\
    \ can most easily be\n   classified based on the mechanism for technical trust\
    \ that is used.\n   The choice of technical trust mechanism constrains how rules\n\
    \   determination is implemented.  Regardless of what deployment strategy\n  \
    \ is chosen, it is important that the technical trust mechanism be able\n   to\
    \ validate the identities of both parties to the exchange.  The\n   trust mechanism\
    \ must ensure that the entity acting as the IdP for a\n   given NAI is permitted\
    \ to be the IdP for that realm and that any\n   service name claimed by the RP\
    \ is permitted to be claimed by that\n   entity.  Here are the categories of technical\
    \ trust determination:\n   AAA Proxy:\n      The simplest model is that an RP\
    \ is a AAA client and can send the\n      request directly to a AAA proxy.  The\
    \ hop-by-hop integrity\n      protection of the AAA fabric provides technical\
    \ trust.  An RP can\n      submit a request directly to the correct federation.\n\
    \      Alternatively, a federation disambiguation fabric can be used.\n      Such\
    \ a fabric takes information about what federations the RP is\n      part of and\
    \ what federations the IdP is part of, and it routes a\n      message to the appropriate\
    \ federation.  The routing of messages\n      across the fabric, plus attributes\
    \ added to requests and\n      responses, together provide rules determination.\
    \  For example,\n      when a disambiguation fabric routes a message to a given\n\
    \      federation, that federation's rules are chosen.  Name validation\n    \
    \  is enforced as messages travel across the fabric.  The entities\n      near\
    \ the RP confirm its identity and validate names it claims.\n      The fabric\
    \ routes the message towards the appropriate IdP,\n      validating the name of\
    \ the IdP in the process.  The routing can be\n      statically configured.  Alternatively,\
    \ a routing protocol could be\n      developed to exchange reachability information\
    \ about a given IdP\n      and to apply policy across the AAA fabric.  Such a\
    \ routing\n      protocol could flood naming constraints to the appropriate points\n\
    \      in the fabric.\n   Trust Broker:\n      Instead of routing messages through\
    \ AAA proxies, some trust broker\n      could establish keys between entities\
    \ near the RP and entities\n      near the IdP.  The advantage of this approach\
    \ is efficiency of\n      message handling.  Fewer entities are needed to be involved\
    \ for\n      each message.  Security may be improved by sending individual\n \
    \     messages over fewer hops.  Rules determination involves decisions\n    \
    \  made by trust brokers about what keys to grant.  Also, associated\n      with\
    \ each credential is context about rules and about other\n      aspects of technical\
    \ trust, including names that may be claimed.\n      A routing protocol similar\
    \ to the one for AAA proxies is likely to\n      be useful to trust brokers in\
    \ flooding rules and naming\n      constraints.\n   Global Credential:\n     \
    \ A global credential such as a public key and certificate in a\n      public\
    \ key infrastructure can be used to establish technical\n      trust.  A directory\
    \ or distributed database such as the Domain\n      Name System is used by the\
    \ RP to discover the endpoint to contact\n      for a given NAI.  Either the database\
    \ or certificates can provide\n      a place to store information about rules\
    \ determination and naming\n      constraints.  Provided that no intermediates\
    \ are required (or\n      appear to be required) and that the RP and IdP are sufficient\
    \ to\n      enforce and determine rules, rules determination is reasonably\n \
    \     simple.  However, applying certain rules is likely to be quite\n      complex.\
    \  For example, if multiple sets of rules are possible\n      between an IdP and\
    \ RP, confirming that the correct set is used may\n      be difficult.  This is\
    \ particularly true if intermediates are\n      involved in making the decision.\
    \  Also, to the extent that\n      directory information needs to be trusted,\
    \ rules determination may\n      be more complex.\n   Real-world deployments are\
    \ likely to be mixtures of these basic\n   approaches.  For example, it will be\
    \ quite common for an RP to route\n   traffic to a AAA proxy within an organization.\
    \  That proxy could then\n   use any of the above three methods to get closer\
    \ to the IdP.  It is\n   also likely that, rather than being directly reachable,\
    \ the IdP may\n   have a proxy on the edge of its organization.  Federations will\n\
    \   likely provide a traditional AAA proxy interface even if they also\n   provide\
    \ another mechanism for increased efficiency or security.\n"
- title: 2.1.4.  AAA Security
  contents:
  - "2.1.4.  AAA Security\n   For the AAA framework, there are two different places\
    \ where security\n   needs to be examined.  The first is the security that is\
    \ in place for\n   the links in the AAA backbone being used.  The second are the\
    \ nodes\n   that form the AAA backbone.\n   The default link security for RADIUS\
    \ is showing its age, as it uses\n   MD5 and a shared secret to both obfuscate\
    \ passwords and provide\n   integrity on the RADIUS messages.  While some EAP\
    \ methods include the\n   ability to protect the client authentication credentials,\
    \ the MSK\n   returned from the IdP to the RP is protected only by RADIUS security.\n\
    \   In many environments, this is considered to be insufficient,\n   especially\
    \ as not all attributes are obfuscated and can thus leak\n   information to a\
    \ passive eavesdropper.  The use of RADIUS with\n   Transport Layer Security (TLS)\
    \ [RFC6614] and/or Datagram Transport\n   Layer Security (DTLS) [RFC7360] addresses\
    \ these attacks.  The same\n   level of security is included in the base Diameter\
    \ specifications.\n"
- title: 2.1.5.  SAML Assertions
  contents:
  - "2.1.5.  SAML Assertions\n   For the traditional use of AAA frameworks, i.e.,\
    \ granting access to a\n   network, an affirmative response from the IdP is sufficient.\
    \  In the\n   ABFAB world, the RP may need to get significantly more additional\n\
    \   information about the client before granting access.  ABFAB therefore\n  \
    \ has a requirement that it can transport an arbitrary set of\n   attributes about\
    \ the client from the IdP to the RP.\n   The Security Assertion Markup Language\
    \ (SAML)\n   [OASIS.saml-core-2.0-os] was designed in order to carry an extensible\n\
    \   set of attributes about a subject.  Since SAML is extensible in the\n   attribute\
    \ space, ABFAB has no immediate needs to update the core SAML\n   specifications\
    \ for our work.  It will be necessary to update IdPs\n   that need to return SAML\
    \ Assertions to RPs and for both the IdP and\n   the RP to implement a new SAML\
    \ profile designed to carry SAML\n   Assertions in AAA.  The new profile can be\
    \ found in [RFC7833].  As\n   SAML statements will frequently be large, RADIUS\
    \ servers and clients\n   that deal with SAML statements will need to implement\
    \ [RFC7499].\n   There are several issues that need to be highlighted:\n   o \
    \ The security of SAML Assertions.\n   o  Namespaces and mapping of SAML attributes.\n\
    \   o  Subject naming of entities.\n   o  Making multiple queries about the subject(s).\n\
    \   o  Level of assurance for authentication.\n   SAML Assertions have an optional\
    \ signature that can be used to\n   protect and provide the origination of the\
    \ assertion.  These\n   signatures are normally based on asymmetric key operations\
    \ and\n   require that the verifier be able to check not only the cryptographic\n\
    \   operation but also the binding of the originator's name and the\n   public\
    \ key.  In a federated environment, it will not always be\n   possible for the\
    \ RP to validate the binding; for this reason, the\n   technical trust established\
    \ in the federation is used as an alternate\n   method of validating the origination\
    \ and integrity of the SAML\n   Assertion.\n   Attributes in a SAML Assertion\
    \ are identified by a name string.  The\n   name string is either assigned by\
    \ the SAML issuer context or scoped\n   by a namespace (for example, a URI or\
    \ object identifier (OID)).  This\n   means that the same attribute can have different\
    \ name strings used to\n   identify it.  In many cases, but not all, the federation\
    \ agreements\n   will determine what attributes and names can be used in a SAML\n\
    \   statement.  This means that the RP needs to map from the SAML issuer\n   or\
    \ federation name, type, and semantic to the name, type, and\n   semantics that\
    \ the policies of the RP are written in.  In other\n   cases, the Federation Substrate,\
    \ in the form of proxies, will modify\n   the SAML Assertions in transit to do\
    \ the necessary name, type, and\n   value mappings as the assertion crosses boundaries\
    \ in the federation.\n   If the proxies are modifying the SAML Assertion, then\
    \ they will\n   remove any signatures on the SAML Assertion, as changing the content\n\
    \   of the SAML Assertion would invalidate the signature.  In this case,\n   the\
    \ technical trust is the required mechanism for validating the\n   integrity of\
    \ the assertion.  (The proxy could re-sign the SAML\n   Assertion, but the same\
    \ issues of establishing trust in the proxy\n   would still exist.)  Finally,\
    \ the attributes may still be in the\n   namespace of the originating IdP.  When\
    \ this occurs, the RP will need\n   to get the required mapping operations from\
    \ the federation agreements\n   and do the appropriate mappings itself.\n   [RFC7833]\
    \ has defined a new SAML name format that corresponds to the\n   NAI name form\
    \ defined by [RFC7542].  This allows for easy name\n   matching in many cases,\
    \ as the name form in the SAML statement and\n   the name form used in RADIUS\
    \ or Diameter will be the same.  In\n   addition to the NAI name form, [RFC7833]\
    \ also defines a pair of\n   implicit name forms corresponding to the client and\
    \ the client's\n   machine.  These implicit name forms are based on the Identity-Type\n\
    \   enumeration defined in the Tunnel Extensible Authentication Protocol\n   (TEAP)\
    \ specification [RFC7170].  If the name form returned in a SAML\n   statement\
    \ is not based on the NAI, then it is a requirement on the\n   EAP server that\
    \ it validate that the subject of the SAML Assertion,\n   if any, is equivalent\
    \ to the subject identified by the NAI used in\n   the RADIUS or Diameter session.\n\
    \   RADIUS has the ability to deal with multiple SAML queries for those\n   EAP\
    \ servers that follow [RFC5080].  In this case, a State attribute\n   will always\
    \ be returned with the Access-Accept.  The EAP client can\n   then send a new\
    \ Access-Request with the State attribute and the new\n   SAML request.  Multiple\
    \ SAML queries can then be done by making a new\n   Access-Request, using the\
    \ State attribute returned in the last\n   Access-Accept to link together the\
    \ different RADIUS sessions.\n   Some RPs need to ensure that specific criteria\
    \ are met during the\n   authentication process.  This need is met by using levels\
    \ of\n   assurance.  A level of assurance is communicated to the RP from the\n\
    \   EAP server by using a SAML Authentication Request, using the\n   Authentication\
    \ Profile described in [RFC7833].  When crossing\n   boundaries between different\
    \ federations, (1) the policy specified\n   will need to be shared between the\
    \ two federations, (2) the policy\n   will need to be mapped by the proxy server\
    \ on the boundary, or\n   (3) the proxy server on the boundary will need to supply\
    \ information\n   to the EAP server so that the EAP server can do the required\
    \ mapping.\n   If this mapping is not done, then the EAP server will not be able\
    \ to\n   enforce the desired level of assurance, as it will not understand the\n\
    \   policy requirements.\n"
- title: 2.2.  Client to Identity Provider
  contents:
  - "2.2.  Client to Identity Provider\n   Looking at the communications between the\
    \ client and the IdP, the\n   following items need to be dealt with:\n   o  The\
    \ client and the IdP need to mutually authenticate each other.\n   o  The client\
    \ and the IdP need to mutually agree on the identity of\n      the RP.\n   ABFAB\
    \ selected EAP for the purposes of mutual authentication and\n   assisted in creating\
    \ some new EAP channel-binding documents for\n   dealing with determining the\
    \ identity of the RP.  A framework for the\n   channel-binding mechanism has been\
    \ defined in [RFC6677] that allows\n   the IdP to check the identity of the RP\
    \ provided by the AAA framework\n   against the identity provided by the client.\n"
- title: 2.2.1.  Extensible Authentication Protocol (EAP)
  contents:
  - "2.2.1.  Extensible Authentication Protocol (EAP)\n   Traditional web federation\
    \ does not describe how a client interacts\n   with an IdP for authentication.\
    \  As a result, this communication is\n   not standardized.  There are several\
    \ disadvantages to this approach.\n   Since the communication is not standardized,\
    \ it is difficult for\n   machines to recognize which entity is going to do the\
    \ authentication,\n   and thus which credentials to use and where in the authentication\n\
    \   form the credentials are to be entered.  It is much easier for humans\n  \
    \ to correctly deal with these problems.  The use of browsers for\n   authentication\
    \ restricts the deployment of more secure forms of\n   authentication beyond plaintext\
    \ usernames and passwords known by the\n   server.  In a number of cases, the\
    \ authentication interface may be\n   presented before the client has adequately\
    \ validated that they are\n   talking to the intended server.  By giving control\
    \ of the\n   authentication interface to a potential attacker, the security of\
    \ the\n   system may be reduced, and opportunities for phishing may be\n   introduced.\n\
    \   As a result, it is desirable to choose some standardized approach for\n  \
    \ communication between the client's end host and the IdP.  There are a\n   number\
    \ of requirements this approach must meet, as noted below.\n   Experience has\
    \ taught us one key security and scalability\n   requirement: it is important\
    \ that the RP not get possession of the\n   long-term secret of the client.  Aside\
    \ from a valuable secret being\n   exposed, a synchronization problem can develop\
    \ when the client\n   changes keys with the IdP.\n   Since there is no single\
    \ authentication mechanism that will be used\n   everywhere, another associated\
    \ requirement is that the authentication\n   framework must allow for the flexible\
    \ integration of authentication\n   mechanisms.  For instance, some IdPs require\
    \ hardware tokens, while\n   others use passwords.  A service provider wants to\
    \ provide support\n   for both authentication methods and also for other methods\
    \ from IdPs\n   not yet seen.\n   These requirements can be met by utilizing standardized\
    \ and\n   successfully deployed technology, namely the EAP framework [RFC3748].\n\
    \   Figure 3 illustrates the integration graphically.\n   EAP is an end-to-end\
    \ framework; it provides for two-way communication\n   between a peer (i.e., client\
    \ or Individual) through the EAP\n   authenticator (i.e., RP) to the back end\
    \ (i.e., IdP).  This is\n   precisely -- and conveniently -- the communication\
    \ path that is\n   needed for federated identity.  Although EAP support is already\n\
    \   integrated in AAA systems (see [RFC3579] and [RFC4072]), several\n   challenges\
    \ remain:\n   o  The first is how to carry EAP payloads from the end host to\n\
    \      the RP.\n   o  Another is to verify statements the RP has made to the client,\n\
    \      confirm that these statements are consistent with statements made\n   \
    \   to the IdP, and confirm that all of the above are consistent with\n      the\
    \ federation and any federation-specific policy or\n      configuration.\n   o\
    \  Another challenge is choosing which IdP to use for which service.\n   The EAP\
    \ method used for ABFAB needs to meet the following\n   requirements:\n   o  It\
    \ needs to provide mutual authentication of the client and IdP.\n   o  It needs\
    \ to support channel binding.\n   As of this writing, the only EAP method that\
    \ meets these criteria is\n   TEAP [RFC7170], either alone (if client certificates\
    \ are used) or\n   with an inner EAP method that does mutual authentication.\n"
- title: 2.2.2.  EAP Channel Binding
  contents:
  - "2.2.2.  EAP Channel Binding\n   EAP channel binding is easily confused with a\
    \ facility in GSS-API\n   that is also called \"channel binding\".  GSS-API channel\
    \ binding\n   provides protection against man-in-the-middle attacks when GSS-API\
    \ is\n   used for authentication inside of some tunnel; it is similar to a\n \
    \  facility called \"cryptographic binding\" in EAP.  See [RFC5056] for a\n  \
    \ discussion of the differences between these two facilities.\n   The client knows,\
    \ in theory, the name of the RP that it attempted to\n   connect to; however,\
    \ in the event that an attacker has intercepted\n   the protocol, the client and\
    \ the IdP need to be able to detect this\n   situation.  A general overview of\
    \ the problem, along with a\n   recommended way to deal with the channel-binding\
    \ issues, can be found\n   in [RFC6677].\n   Since the time that [RFC6677] was\
    \ published, a number of possible\n   attacks were found.  Methods to address\
    \ these attacks have been\n   outlined in [RFC7029].\n"
- title: 2.3.  Client to Relying Party
  contents:
  - "2.3.  Client to Relying Party\n   The final set of interactions between the parties\
    \ to consider are\n   those between the client and the RP.  In some ways, this\
    \ is the most\n   complex set, since at least part of it is outside the scope\
    \ of the\n   ABFAB work.  The interactions between these parties include:\n  \
    \ o  Running the protocol that implements the service that is provided\n     \
    \ by the RP and desired by the client.\n   o  Authenticating the client to the\
    \ RP and the RP to the client.\n   o  Providing the necessary security services\
    \ to the service protocol\n      that it needs, beyond authentication.\n   o \
    \ Dealing with client re-authentication where desired.\n"
- title: 2.3.1.  GSS-API
  contents:
  - "2.3.1.  GSS-API\n   One of the remaining layers is responsible for integration\
    \ of\n   federated authentication with the application.  Applications have\n \
    \  adopted a number of approaches for providing security, so multiple\n   strategies\
    \ for integration of federated authentication with\n   applications may be needed.\
    \  To this end, we start with a strategy\n   that provides integration with a\
    \ large number of application\n   protocols.\n   Many applications, such as Secure\
    \ Shell (SSH) [RFC4462], NFS\n   [RFC7530], DNS [RFC3645], and several non-IETF\
    \ applications, support\n   GSS-API [RFC2743].  Many applications, such as IMAP,\
    \ SMTP, the\n   Extensible Messaging and Presence Protocol (XMPP), and the\n \
    \  Lightweight Directory Access Protocol (LDAP), support the Simple\n   Authentication\
    \ and Security Layer (SASL) [RFC4422] framework.  These\n   two approaches work\
    \ together nicely: by creating a GSS-API mechanism,\n   SASL integration is also\
    \ addressed.  In effect, using a GSS-API\n   mechanism with SASL simply requires\
    \ placing some headers before the\n   mechanism's messages and constraining certain\
    \ GSS-API options.\n   GSS-API is specified in terms of an abstract set of operations\
    \ that\n   can be mapped into a programming language to form an API.  When\n \
    \  people are first introduced to GSS-API, they focus on it as an API.\n   However,\
    \ from the perspective of authentication for non-web\n   applications, GSS-API\
    \ should be thought of as a protocol as well as\n   an API.  When looked at as\
    \ a protocol, it consists of abstract\n   operations such as the initial context\
    \ exchange, which includes two\n   sub-operations (GSS_Init_sec_context and GSS_Accept_sec_context)\n\
    \   [RFC2743].  An application defines which abstract operations it is\n   going\
    \ to use and where messages produced by these operations fit into\n   the application\
    \ architecture.  A GSS-API mechanism will define what\n   actual protocol messages\
    \ result from that abstract message for a\n   given abstract operation.  So, since\
    \ this work is focusing on a\n   particular GSS-API mechanism, we generally focus\
    \ on protocol elements\n   rather than the API view of GSS-API.\n   The API view\
    \ of GSS-API does have significant value as well; since\n   the abstract operations\
    \ are well defined, the information that a\n   mechanism gets from the application\
    \ is well defined.  Also, the set\n   of assumptions the application is permitted\
    \ to make is generally well\n   defined.  As a result, an application protocol\
    \ that supports GSS-API\n   or SASL is very likely to be usable with a new approach\
    \ to\n   authentication, including the authentication mechanism defined in\n \
    \  this document, with no required modifications.  In some cases,\n   support\
    \ for a new authentication mechanism has been added using\n   plugin interfaces\
    \ to applications without the application being\n   modified at all.  Even when\
    \ modifications are required, they can\n   often be limited to supporting a new\
    \ naming and authorization model.\n   For example, this work focuses on privacy;\
    \ an application that\n   assumes that it will always obtain an identifier for\
    \ the client will\n   need to be modified to support anonymity, unlinkability,\
    \ or\n   pseudonymity.\n   So, we use GSS-API and SASL because a number of the\
    \ application\n   protocols we wish to federate support these strategies for security\n\
    \   integration.  What does this mean from a protocol standpoint, and how\n  \
    \ does this relate to other layers?  This means that we need to design\n   a concrete\
    \ GSS-API mechanism.  We have chosen to use a GSS-API\n   mechanism that encapsulates\
    \ EAP authentication.  So, GSS-API (and\n   SASL) encapsulates EAP between the\
    \ end host and the service.  The AAA\n   framework encapsulates EAP between the\
    \ RP and the IdP.  The GSS-API\n   mechanism includes rules about how initiators\
    \ and services are named\n   as well as per-message security and other facilities\
    \ required by the\n   applications we wish to support.\n"
- title: 2.3.2.  Protocol Transport
  contents:
  - "2.3.2.  Protocol Transport\n   The transport of data between the client and the\
    \ RP is not provided\n   by GSS-API.  GSS-API creates and consumes messages, but\
    \ it does not\n   provide the transport itself; instead, the protocol using GSS-API\n\
    \   needs to provide the transport.  In many cases, HTTP or HTTPS is used\n  \
    \ for this transport, but other transports are perfectly acceptable.\n   The core\
    \ GSS-API document [RFC2743] provides some details on what\n   requirements exist.\n\
    \   In addition, we highlight the following:\n   o  The transport does not need\
    \ to provide either confidentiality or\n      integrity.  After GSS-EAP has finished\
    \ negotiation, GSS-API can be\n      used to provide both services.  If the negotiation\
    \ process itself\n      needs protection from eavesdroppers, then the transport\
    \ would need\n      to provide the necessary services.\n   o  The transport needs\
    \ to provide reliable transport of the messages.\n   o  The transport needs to\
    \ ensure that tokens are delivered in order\n      during the negotiation process.\n\
    \   o  GSS-API messages need to be delivered atomically.  If the\n      transport\
    \ breaks up a message, it must also reassemble the message\n      before delivery.\n"
- title: 2.3.3.  Re-authentication
  contents:
  - "2.3.3.  Re-authentication\n   There are circumstances where the RP will want\
    \ to have the client\n   re-authenticate itself.  These include very long sessions,\
    \ where the\n   original authentication is time limited or cases where in order\
    \ to\n   complete an operation a different authentication is required.\n   GSS-EAP\
    \ does not have any mechanism for the server to initiate a\n   re-authentication,\
    \ as all authentication operations start from the\n   client.  If a protocol using\
    \ GSS-EAP needs to support\n   re-authentication that is initiated by the server,\
    \ then a request\n   from the server to the client for the re-authentication to\
    \ start\n   needs to be placed in the protocol.\n   Clients can reuse the existing\
    \ secure connection established by\n   GSS-API, and run the new authentication\
    \ in that connection, by\n   calling GSS_Init_sec_context.  At this point, a full\n\
    \   re-authentication will be done.\n"
- title: 3.  Application Security Services
  contents:
  - "3.  Application Security Services\n   One of the key goals is to integrate federated\
    \ authentication with\n   existing application protocols and, where possible,\
    \ existing\n   implementations of these protocols.  Another goal is to perform\
    \ this\n   integration while meeting the best security practices of the\n   technologies\
    \ used to perform the integration.  This section describes\n   security services\
    \ and properties required by the EAP GSS-API\n   mechanism in order to meet these\
    \ goals.  This information could be\n   viewed as specific to that mechanism.\
    \  However, other future\n   application integration strategies are very likely\
    \ to need similar\n   services.  So, it is likely that these services will be\
    \ expanded\n   across application integration strategies if new application\n\
    \   integration strategies are adopted.\n"
- title: 3.1.  Authentication
  contents:
  - "3.1.  Authentication\n   GSS-API provides an optional security service called\
    \ \"mutual\n   authentication\".  This service means that in addition to the\n\
    \   initiator providing (potentially anonymous or pseudonymous) identity\n   to\
    \ the acceptor, the acceptor confirms its identity to the initiator.\n   In the\
    \ context of ABFAB in particular, the naming of this service is\n   confusing.\
    \  We still say that mutual authentication is provided when\n   the identity of\
    \ an acceptor is strongly authenticated to an anonymous\n   initiator.\n   Unfortunately,\
    \ [RFC2743] does not explicitly talk about what mutual\n   authentication means.\
    \  Within this document, we therefore define\n   mutual authentication as follows:\n\
    \   o  If a target name is configured for the initiator, then the\n      initiator\
    \ trusts that the supplied target name describes the\n      acceptor.  This implies\
    \ that (1) appropriate cryptographic\n      exchanges took place for the initiator\
    \ to make such a trust\n      decision and (2) after evaluating the results of\
    \ these exchanges,\n      the initiator's policy trusts that the target name is\
    \ accurate.\n   o  If no target name is configured for the initiator, then the\n\
    \      initiator trusts that the acceptor name, supplied by the acceptor,\n  \
    \    correctly names the entity it is communicating with.\n   o  Both the initiator\
    \ and acceptor have the same key material for\n      per-message keys, and both\
    \ parties have confirmed that they\n      actually have the key material.  In\
    \ EAP terms, there is a\n      protected indication of success.\n   Mutual authentication\
    \ is an important defense against certain aspects\n   of phishing.  Intuitively,\
    \ clients would like to assume that if some\n   party asks for their credentials\
    \ as part of authentication,\n   successfully gaining access to the resource means\
    \ that they are\n   talking to the expected party.  Without mutual authentication,\
    \ the\n   server could \"grant access\" regardless of what credentials are\n \
    \  supplied.  Mutual authentication better matches this user intuition.\n   It\
    \ is important, therefore, that the GSS-EAP mechanism implement\n   mutual authentication.\
    \  That is, an initiator needs to be able to\n   request mutual authentication.\
    \  When mutual authentication is\n   requested, only EAP methods capable of providing\
    \ the necessary\n   service can be used, and appropriate steps need to be taken\
    \ to\n   provide mutual authentication.  While a broader set of EAP methods\n\
    \   could be supported by not requiring mutual authentication, it was\n   decided\
    \ that the client needs to always have the ability to request\n   it.  In some\
    \ cases, the IdP and the RP will not support mutual\n   authentication; however,\
    \ the client will always be able to detect\n   this and make an appropriate security\
    \ decision.\n   The AAA infrastructure may hide the initiator's identity from\
    \ the\n   GSS-API acceptor, providing anonymity between the initiator and the\n\
    \   acceptor.  At this time, whether the identity is disclosed is\n   determined\
    \ by EAP server policy rather than by an indication from the\n   initiator.  Also,\
    \ initiators are unlikely to be able to determine\n   whether anonymous communication\
    \ will be provided.  For this reason,\n   initiators are unlikely to set the anonymous\
    \ return flag from\n   GSS_Init_sec_context (Section 2.2.1 of [RFC2743]).\n"
- title: 3.2.  GSS-API Channel Binding
  contents:
  - "3.2.  GSS-API Channel Binding\n   [RFC5056] defines a concept of channel binding\
    \ that is used to\n   prevent man-in-the-middle attacks.  This type of channel\
    \ binding\n   works by taking a cryptographic value from the transport security\n\
    \   layer and checks to see that both sides of the GSS-API conversation\n   know\
    \ this value.  Transport Layer Security (TLS) [RFC5246] is the\n   most common\
    \ transport security layer used for this purpose.\n   It needs to be stressed\
    \ that channel binding as described in\n   [RFC5056] (also called \"GSS-API channel\
    \ binding\" when GSS-API is\n   involved) is not the same thing as EAP channel\
    \ binding.  GSS-API\n   channel binding is used for detecting man-in-the-middle\
    \ attacks.  EAP\n   channel binding is used for mutual authentication and acceptor\
    \ naming\n   checks.  See [RFC7055] for details.  A more detailed description\
    \ of\n   the differences between the facilities can be found in [RFC5056].\n \
    \  The use of TLS can provide both encryption and integrity on the\n   channel.\
    \  It is common to provide SASL and GSS-API with these other\n   security services.\n\
    \   One of the benefits that the use of TLS provides is that a client has\n  \
    \ the ability to validate the name of the server.  However, this\n   validation\
    \ is predicated on a couple of things.  The TLS session\n   needs to be using\
    \ certificates and not be an anonymous session.  The\n   client and the TLS server\
    \ need to share a common trust point for the\n   certificate used in validating\
    \ the server.  TLS provides its own\n   server authentication.  However, there\
    \ are a variety of situations\n   where, for policy or usability reasons, this\
    \ authentication is not\n   checked.  When the TLS authentication is checked,\
    \ if the trust\n   infrastructure behind the TLS authentication is different from\
    \ the\n   trust infrastructure behind the GSS-API mutual authentication, then\n\
    \   confirming the endpoints using both trust infrastructures is likely\n   to\
    \ enhance security.  If the endpoints of the GSS-API authentication\n   are different\
    \ than the endpoints of the lower layer, this is a strong\n   indication of a\
    \ problem, such as a man-in-the-middle attack.  Channel\n   binding provides a\
    \ facility to determine whether these endpoints are\n   the same.\n   The GSS-EAP\
    \ mechanism needs to support channel binding.  When an\n   application provides\
    \ channel-binding data, the mechanism needs to\n   confirm that this is the same\
    \ on both sides, consistent with the\n   GSS-API specification.\n"
- title: 3.3.  Host-Based Service Names
  contents:
  - "3.3.  Host-Based Service Names\n   IETF security mechanisms typically take a\
    \ host name and perhaps a\n   service, entered by a user, and make some trust\
    \ decision about\n   whether the remote party in the interaction is the intended\
    \ party.\n   This decision can be made via the use of certificates, preconfigured\n\
    \   key information, or a previous leap of trust.  GSS-API has defined a\n   relatively\
    \ flexible naming convention; however, most of the IETF\n   applications that\
    \ use GSS-API (including SSH, NFS, IMAP, LDAP, and\n   XMPP) have chosen to use\
    \ a more restricted naming convention based on\n   the host name.  The GSS-EAP\
    \ mechanism needs to support host-based\n   service names in order to work with\
    \ existing IETF protocols.\n   The use of host-based service names leads to a\
    \ challenging trust\n   delegation problem.  Who is allowed to decide whether\
    \ a particular\n   host name maps to a specific entity?  Possible solutions to\
    \ this\n   problem have been looked at.\n   o  The Public Key Infrastructure (PKI)\
    \ used by the web has chosen to\n      have a number of trust anchors (root certificate\
    \ authorities),\n      each of which can map any host name to a public key.\n\
    \   o  A number of GSS-API mechanisms, such as Kerberos [RFC1964], have\n    \
    \  split the problem into two parts.  [RFC1964] introduced a new\n      concept\
    \ called a realm; the realm is responsible for host mapping\n      within itself.\
    \  The mechanism then decides what realm is\n      responsible for a given name.\
    \  This is the approach adopted by\n      ABFAB.\n   GSS-EAP defines a host naming\
    \ convention that takes into account the\n   host name, the realm, the service,\
    \ and the service parameters.  An\n   example of a GSS-API service name is \"\
    xmpp/foo@example.com\".  This\n   identifies the XMPP service on the host foo\
    \ in the realm example.com.\n   Any of the components, except for the service\
    \ name, may be omitted\n   from a name.  When omitted, a local default would be\
    \ used for that\n   component of the name.\n   While there is no requirement that\
    \ realm names map to Fully Qualified\n   Domain Names (FQDNs) within DNS, in practice\
    \ this is normally true.\n   Doing so allows the realm portion of service names\
    \ and the portion of\n   NAIs to be the same.  It also allows for the use of DNS\
    \ in locating\n   the host of a service while establishing the transport channel\n\
    \   between the client and the RP.\n   It is the responsibility of the application\
    \ to determine the server\n   that it is going to communicate with; GSS-API has\
    \ the ability to help\n   confirm that the server is the desired server but not\
    \ to determine\n   the name of the server to use.  It is also the responsibility\
    \ of the\n   application to determine how much of the information identifying\
    \ the\n   service needs to be validated by the ABFAB system.  The information\n\
    \   that needs to be validated is used to construct the service name\n   passed\
    \ into the GSS-EAP mechanism.  What information is to be\n   validated will depend\
    \ on (1) what information was provided by the\n   client and (2) what information\
    \ is considered significant.  If the\n   client only cares about getting a specific\
    \ service, then it does not\n   need to validate the host and realm that provides\
    \ the service.\n   Applications may retrieve information about providers of services\n\
    \   from DNS.  Service Records (SRVs) [RFC2782] and Naming Authority\n   Pointer\
    \ (NAPTR) [RFC3401] records are used to help find a host that\n   provides a service;\
    \ however, the necessity of having DNSSEC on the\n   queries depends on how the\
    \ information is going to be used.  If the\n   host name returned is not going\
    \ to be validated by EAP channel\n   binding because only the service is being\
    \ validated, then DNSSEC\n   [RFC4033] is not required.  However, if the host\
    \ name is going to be\n   validated by EAP channel binding, then DNSSEC needs\
    \ to be used to\n   ensure that the correct host name is validated.  In general,\
    \ if the\n   information that is returned from the DNS query is to be validated,\n\
    \   then it needs to be obtained in a secure manner.\n   Another issue that needs\
    \ to be addressed for host-based service names\n   is that they do not work ideally\
    \ when different instances of a\n   service are running on different ports.  If\
    \ the services are\n   equivalent, then it does not matter.  However, if there\
    \ are\n   substantial differences in the quality of the service, that\n   information\
    \ needs to be part of the validation process.  If one has\n   just a host name\
    \ and not a port in the information being validated,\n   then this is not going\
    \ to be a successful strategy.\n"
- title: 3.4.  Additional GSS-API Services
  contents:
  - "3.4.  Additional GSS-API Services\n   GSS-API provides per-message security services\
    \ that can provide\n   confidentiality and/or integrity.  Some IETF protocols,\
    \ such as NFS\n   and SSH, take advantage of these services.  As a result, GSS-EAP\n\
    \   needs to support these services.  As with mutual authentication,\n   per-message\
    \ security services will limit the set of EAP methods that\n   can be used to\
    \ those that generate a Master Session Key (MSK).  Any\n   EAP method that produces\
    \ an MSK is able to support per-message\n   security services as described in\
    \ [RFC2743].\n   GSS-API provides a pseudorandom function.  This function generates\
    \ a\n   pseudorandom sequence using the shared session key as the seed for\n \
    \  the bytes generated.  This provides an algorithm that both the\n   initiator\
    \ and acceptor can run in order to arrive at the same key\n   value.  The use\
    \ of this feature allows an application to generate\n   keys or other shared secrets\
    \ for use in other places in the protocol.\n   In this regard, it is similar in\
    \ concept to the mechanism (formerly\n   known as \"TLS Extractors\") described\
    \ in [RFC5705].  While no current\n   IETF protocols require this feature, non-IETF\
    \ protocols are expected\n   to take advantage of it in the near future.  Additionally,\
    \ a number\n   of protocols have found the mechanism described in [RFC5705] to\
    \ be\n   useful in this regard, so it is highly probable that IETF protocols\n\
    \   may also start using this feature.\n"
- title: 4.  Privacy Considerations
  contents:
  - "4.  Privacy Considerations\n   As an architecture designed to enable federated\
    \ authentication and\n   allow for the secure transmission of identity information\
    \ between\n   entities, ABFAB obviously requires careful consideration regarding\n\
    \   privacy and the potential for privacy violations.\n   This section examines\
    \ the privacy-related information presented in\n   this document, summarizing\
    \ the entities that are involved in ABFAB\n   communications and what exposure\
    \ they have to identity information.\n   In discussing these privacy considerations\
    \ in this section, we use\n   terminology and ideas from [RFC6973].\n   Note that\
    \ the ABFAB architecture uses at its core several existing\n   technologies and\
    \ protocols; detailed privacy discussion regarding\n   these topics is not examined.\
    \  This section instead focuses on\n   privacy considerations specifically related\
    \ to the overall\n   architecture and usage of ABFAB.\n      +--------+      \
    \ +---------------+       +--------------+\n      | Client | <---> |      RP \
    \      | <---> | AAA Client   |\n      +--------+       +---------------+    \
    \   +--------------+\n                                                     ^\n\
    \                                                     |\n                    \
    \                                 v\n                       +---------------+\
    \       +----------------+\n                       | SAML Server   |       | AAA\
    \ Proxy      |\n                       +---------------+       | (or Proxies)\
    \   |\n                                ^              +----------------+\n   \
    \                             |                       ^\n                    \
    \            |                       |\n                                v    \
    \                   v\n      +------------+       +---------------+       +--------------+\n\
    \      | EAP Server | <---> |   IdP         | <---> | AAA Server   |\n      +------------+\
    \       +---------------+       +--------------+\n                     Figure\
    \ 4: Entities and Data Flow\n"
- title: 4.1.  Entities and Their Roles
  contents:
  - "4.1.  Entities and Their Roles\n   Categorizing the ABFAB entities shown in Figure\
    \ 4 according to the\n   taxonomy of terms from [RFC6973] is somewhat complicated,\
    \ as the\n   roles of each entity will change during the various phases of ABFAB\n\
    \   communications.  The three main phases of relevance are the\n   client-to-RP\
    \ communication phase, the client-to-IdP (via the\n   Federation Substrate) communication\
    \ phase, and the IdP-to-RP (via the\n   Federation Substrate) communication phase.\n\
    \   In the client-to-RP communication phase, we have:\n   Initiator:  Client.\n\
    \   Observers:  Client, RP.\n   Recipient:  RP.\n   In the client-to-IdP (via\
    \ the Federation Substrate) communication\n   phase, we have:\n   Initiator: \
    \ Client.\n   Observers:  Client, RP, AAA Client, AAA Proxy (or Proxies), AAA\n\
    \      Server, IdP.\n   Recipient:  IdP\n   In the IdP-to-RP (via the Federation\
    \ Substrate) communication phase,\n   we have:\n   Initiator:  RP.\n   Observers:\
    \  IdP, AAA Server, AAA Proxy (or Proxies), AAA Client, RP.\n   Recipient:  IdP\n\
    \   Eavesdroppers and attackers can reside on any or all communication\n   links\
    \ between the entities shown in Figure 4.\n   The various entities in the system\
    \ might also collude or be coerced\n   into colluding.  Some of the significant\
    \ collusions to look at are as\n   follows:\n   o  If two RPs are colluding, they\
    \ have the information available to\n      both nodes.  This can be analyzed as\
    \ if a single RP were offering\n      multiple services.\n   o  If an RP and a\
    \ AAA proxy are colluding, then the trust of the\n      system is broken, as the\
    \ RP would be able to lie about its own\n      identity to the IdP.  There is\
    \ no known way to deal with this\n      situation.\n   o  If multiple AAA proxies\
    \ are colluding, they can be treated as a\n      single node for analysis.\n \
    \  The Federation Substrate consists of all of the AAA entities.  In\n   some\
    \ cases, the AAA proxies may not exist, as the AAA client can talk\n   directly\
    \ to the AAA server.  Specifications such as the Trust Router\n   Protocol (https://www.ietf.org/proceedings/86/slides/\n\
    \   slides-86-rtgarea-0.pdf) and RADIUS dynamic discovery [RFC7585] can\n   be\
    \ used to shorten the path between the AAA client and the AAA server\n   (and\
    \ thus stop these AAA proxies from being observers); however, even\n   in these\
    \ circumstances, there may be AAA proxies in the path.\n   In Figure 4, the IdP\
    \ has been divided into multiple logical pieces;\n   in actual implementations,\
    \ these pieces will frequently be tightly\n   coupled.  The links between these\
    \ pieces provide the greatest\n   opportunity for attackers and eavesdroppers\
    \ to acquire information;\n   however, as they are all under the control of a\
    \ single entity, they\n   are also the easiest to have tightly secured.\n"
- title: 4.2.  Privacy Aspects of ABFAB Communication Flows
  contents:
  - "4.2.  Privacy Aspects of ABFAB Communication Flows\n   In the ABFAB architecture,\
    \ there are a few different types of data\n   and identifiers in use.  The best\
    \ way to understand them, and their\n   potential privacy impacts, is to look\
    \ at each phase of communication\n   in ABFAB.\n"
- title: 4.2.1.  Client to RP
  contents:
  - "4.2.1.  Client to RP\n   The flow of data between the client and the RP is divided\
    \ into two\n   parts.  The first part consists of all of the data exchanged as\
    \ part\n   of the ABFAB authentication process.  The second part consists of all\n\
    \   of the data exchanged after the authentication process has been\n   finished.\n\
    \   During the initial communication phase, the client sends an NAI (see\n   [RFC7542])\
    \ to the RP.  Many EAP methods (but not all) allow the\n   client to disclose\
    \ an NAI to the RP in a form that includes only a\n   realm component during this\
    \ communication phase.  This is the minimum\n   amount of identity information\
    \ necessary for ABFAB to work -- it\n   indicates an IdP that the principal has\
    \ a relationship with.  EAP\n   methods that do not allow this will necessarily\
    \ also reveal an\n   identifier for the principal in the IdP realm (e.g., a username).\n\
    \   The data shared during the initial communication phase may be\n   protected\
    \ by a channel protocol such as TLS.  This will prevent the\n   leakage of information\
    \ to passive eavesdroppers; however, an active\n   attacker may still be able\
    \ to set itself up as a man-in-the-middle.\n   The client may not be able to validate\
    \ the certificates (if any)\n   provided by the service, deferring the check of\
    \ the identity of the\n   RP until the completion of the ABFAB authentication\
    \ protocol (using\n   EAP channel binding rather than certificates).\n   The data\
    \ exchanged after the authentication process can have privacy\n   and authentication\
    \ using the GSS-API services.  If the overall\n   application protocol allows\
    \ for the process of re-authentication,\n   then the same privacy implications\
    \ as those discussed in previous\n   paragraphs apply.\n"
- title: 4.2.2.  Client to IdP (via Federation Substrate)
  contents:
  - "4.2.2.  Client to IdP (via Federation Substrate)\n   This phase includes a secure\
    \ TLS tunnel set up between the client and\n   the IdP via the RP and Federation\
    \ Substrate.  The process is\n   initiated by the RP using the realm information\
    \ given to it by the\n   client.  Once set up, the tunnel is used to send credentials\
    \ to the\n   IdP to authenticate.\n   Various operational information is transported\
    \ between the RP and the\n   IdP over the AAA infrastructure -- for example, using\
    \ RADIUS headers.\n   As no end-to-end security is provided by AAA, all AAA entities\
    \ on the\n   path between the RP and IdP have the ability to eavesdrop on this\n\
    \   information.  Some of this information may form identifiers or\n   explicit\
    \ identity information:\n   o  The RP knows the IP address of the client.  It\
    \ is possible that\n      the RP could choose to expose this IP address by including\
    \ it in a\n      RADIUS header (e.g., using the Calling-Station-Id).  This is\
    \ a\n      privacy consideration to take into account for the application\n  \
    \    protocol.\n   o  The EAP MSK is transported between the IdP and the RP over\
    \ the AAA\n      infrastructure -- for example, through RADIUS headers.  This\
    \ is a\n      particularly important privacy consideration, as any AAA proxy\n\
    \      that has access to the EAP MSK is able to decrypt and eavesdrop on\n  \
    \    any traffic encrypted using that EAP MSK (i.e., all communications\n    \
    \  between the client and RP).  This problem can be mitigated if the\n      application\
    \ protocol sets up a secure tunnel between the client\n      and the RP and performs\
    \ a cryptographic binding between the tunnel\n      and EAP MSK.\n   o  Related\
    \ to the bullet point above, the AAA server has access to\n      the material\
    \ necessary to derive the session key; thus, the AAA\n      server can observe\
    \ any traffic encrypted between the client and\n      RP.  This \"feature\" was\
    \ chosen as a simplification and to make\n      performance faster; if it was\
    \ decided that this trade-off was not\n      desirable for privacy and security\
    \ reasons, then extensions to\n      ABFAB that make use of techniques such as\
    \ Diffie-Hellman key\n      exchange would mitigate this.\n   The choice of EAP\
    \ method used has other potential privacy\n   implications.  For example, if the\
    \ EAP method in use does not\n   support mutual authentication, then there are\
    \ no guarantees that the\n   IdP is who it claims to be, and thus the full NAI,\
    \ including a\n   username and a realm, might be sent to any entity masquerading\
    \ as a\n   particular IdP.\n   Note that ABFAB has not specified any AAA accounting\
    \ requirements.\n   Implementations that use the accounting portion of AAA should\n\
    \   consider privacy appropriately when designing this aspect.\n"
- title: 4.2.3.  IdP to RP (via Federation Substrate)
  contents:
  - "4.2.3.  IdP to RP (via Federation Substrate)\n   In this phase, the IdP communicates\
    \ with the RP, informing it as to\n   the success or failure of authentication\
    \ of the user and, optionally,\n   the sending of identity information about the\
    \ principal.\n   As in the previous flow (client to IdP), various operation\n\
    \   information is transported between the IdP and RP over the AAA\n   infrastructure,\
    \ and the same privacy considerations apply.  However,\n   in this flow, explicit\
    \ identity information about the authenticated\n   principal can be sent from\
    \ the IdP to the RP.  This information can\n   be sent through RADIUS headers,\
    \ or using SAML [RFC7833].  This can\n   include protocol-specific identifiers,\
    \ such as SAML NameIDs, as well\n   as arbitrary attribute information about the\
    \ principal.  What\n   information will be released is controlled by policy on\
    \ the IdP.  As\n   before, when sending this information through RADIUS headers,\
    \ all AAA\n   entities on the path between the RP and IdP have the ability to\n\
    \   eavesdrop, unless additional security measures are taken (such as the\n  \
    \ use of TLS for RADIUS [RFC6614]).  However, when sending this\n   information\
    \ using SAML as specified in [RFC7833], confidentiality of\n   the information\
    \ should be guaranteed, as [RFC7833] requires the use\n   of TLS for RADIUS.\n"
- title: 4.3.  Relationship between User and Entities
  contents:
  - "4.3.  Relationship between User and Entities\n   o  Between user and IdP - The\
    \ IdP is an entity the user will have a\n      direct relationship with, created\
    \ when the organization that\n      operates the entity provisioned and exchanged\
    \ the user's\n      credentials.  Privacy and data protection guarantees may form\
    \ a\n      part of this relationship.\n   o  Between user and RP - The RP is an\
    \ entity the user may or may not\n      have a direct relationship with, depending\
    \ on the service in\n      question.  Some services may only be offered to those\
    \ users where\n      such a direct relationship exists (for particularly sensitive\n\
    \      services, for example), while some may not require this and would\n   \
    \   instead be satisfied with basic federation trust guarantees\n      between\
    \ themselves and the IdP.  This may well include the option\n      that the user\
    \ stays anonymous with respect to the RP (though,\n      obviously, never anonymous\
    \ to the IdP).  If attempting to preserve\n      privacy via data minimization\
    \ (Section 1), then the only attribute\n      information about Individuals exposed\
    \ to the RP should be\n      attribute information that is strictly necessary\
    \ for the operation\n      of the service.\n   o  Between user and Federation\
    \ Substrate - The user is highly likely\n      to have no knowledge of, or relationship\
    \ with, any entities\n      involved with the Federation Substrate (not that the\
    \ IdP and/or RP\n      may, however).  Knowledge of attribute information about\n\
    \      Individuals for these entities is not necessary, and thus such\n      information\
    \ should be protected in such a way as to prevent the\n      possibility of access\
    \ to this information.\n"
- title: 4.4.  Accounting Information
  contents:
  - "4.4.  Accounting Information\n   Alongside the core authentication and authorization\
    \ that occur in AAA\n   communications, accounting information about resource\
    \ consumption may\n   be delivered as part of the accounting exchange during the\
    \ lifetime\n   of the granted application session.\n"
- title: 4.5.  Collection and Retention of Data and Identifiers
  contents:
  - "4.5.  Collection and Retention of Data and Identifiers\n   In cases where RPs\
    \ are not required to identify a particular\n   Individual when an Individual\
    \ wishes to make use of their service,\n   the ABFAB architecture enables anonymous\
    \ or pseudonymous access.\n   Thus, data and identifiers other than pseudonyms\
    \ and unlinkable\n   attribute information need not be stored and retained.\n\
    \   However, in cases where RPs require the ability to identify a\n   particular\
    \ Individual (e.g., so they can link this identity\n   information to a particular\
    \ account in their service, or where\n   identity information is required for\
    \ audit purposes), the service\n   will need to collect and store such information,\
    \ and to retain it for\n   as long as they require.  The de-provisioning of such\
    \ accounts and\n   information is out of scope for ABFAB, but for privacy protection,\
    \ it\n   is obvious that any identifiers collected should be deleted when they\n\
    \   are no longer needed.\n"
- title: 4.6.  User Participation
  contents:
  - "4.6.  User Participation\n   In the ABFAB architecture, by its very nature users\
    \ are active\n   participants in the sharing of their identifiers, as they initiate\n\
    \   the communications exchange every time they wish to access a server.\n   They\
    \ are, however, not involved in the control of information related\n   to them\
    \ that is transmitted from the IdP to the RP for authorization\n   purposes; rather,\
    \ this is under the control of policy on the IdP.\n   Due to the nature of the\
    \ AAA communication flows, with the current\n   ABFAB architecture there is no\
    \ place for a process of gaining user\n   consent for the information to be released\
    \ from the IdP to the RP.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This document describes the architecture for\
    \ Application Bridging for\n   Federated Access Beyond web (ABFAB), and security\
    \ is therefore the\n   main focus.  Many of the items that are security considerations\
    \ have\n   already been discussed in Section 4 (\"Privacy Considerations\").\n\
    \   Readers should be sure to read that section as well.\n   There are many places\
    \ in this document where TLS is used.  While in\n   some places (e.g., client\
    \ to RP) anonymous connections can be used,\n   it is very important that TLS\
    \ connections within the AAA\n   infrastructure and between the client and the\
    \ IdP be fully\n   authenticated and, if using certificates, that revocation be\
    \ checked\n   as well.  When using anonymous connections between the client and\
    \ the\n   RP, all messages and data exchanged between those two entities will\n\
    \   be visible to an active attacker.  In situations where the client is\n   not\
    \ yet on the network, the status_request extension [RFC6066] can be\n   used to\
    \ obtain revocation-checking data inside of the TLS protocol.\n   Clients also\
    \ need to get the trust anchor for the IdP configured\n   correctly in order to\
    \ prevent attacks; this is a difficult problem in\n   general and is going to\
    \ be even more difficult for kiosk\n   environments.\n   Selection of the EAP\
    \ methods to be permitted by clients and IdPs is\n   important.  The use of a\
    \ tunneling method such as TEAP [RFC7170]\n   allows other EAP methods to be used\
    \ while hiding the contents of\n   those EAP exchanges from the RP and the AAA\
    \ framework.  When\n   considering inner EAP methods, the considerations outlined\
    \ in\n   [RFC7029] about binding the inner and outer EAP methods need to be\n\
    \   taken into account.  Finally, one wants to have the ability to\n   support\
    \ channel binding in those cases where the client needs to\n   validate that it\
    \ is talking to the correct RP.\n   In those places where SAML statements are\
    \ used, RPs will generally be\n   unable to validate signatures on the SAML statement,\
    \ either because\n   the signature has been stripped off by the IdP or because\
    \ the RP is\n   unable to validate the binding between the signer, the key used\
    \ to\n   sign, and the realm represented by the IdP.  For these reasons, it is\n\
    \   required that IdPs do the necessary trust checking on the SAML\n   statements\
    \ and that RPs can trust the AAA infrastructure to keep the\n   SAML statements\
    \ valid.\n   When a pseudonym is generated as a unique long-term identifier for\
    \ a\n   client by an IdP, care must be taken in the algorithm that it cannot\n\
    \   easily be reverse-engineered by the service provider.  If it can be\n   reverse-engineered,\
    \ then the service provider can consult an oracle\n   to determine if a given\
    \ unique long-term identifier is associated\n   with a different known identifier.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [RFC2743]  Linn, J., \"Generic Security Service\
    \ Application Program\n              Interface Version 2, Update 1\", RFC 2743,\n\
    \              DOI 10.17487/RFC2743, January 2000,\n              <http://www.rfc-editor.org/info/rfc2743>.\n\
    \   [RFC2865]  Rigney, C., Willens, S., Rubens, A., and W. Simpson,\n        \
    \      \"Remote Authentication Dial In User Service (RADIUS)\",\n            \
    \  RFC 2865, DOI 10.17487/RFC2865, June 2000,\n              <http://www.rfc-editor.org/info/rfc2865>.\n\
    \   [RFC3579]  Aboba, B. and P. Calhoun, \"RADIUS (Remote Authentication\n   \
    \           Dial In User Service) Support For Extensible\n              Authentication\
    \ Protocol (EAP)\", RFC 3579,\n              DOI 10.17487/RFC3579, September 2003,\n\
    \              <http://www.rfc-editor.org/info/rfc3579>.\n   [RFC3748]  Aboba,\
    \ B., Blunk, L., Vollbrecht, J., Carlson, J., and H.\n              Levkowetz,\
    \ Ed., \"Extensible Authentication Protocol\n              (EAP)\", RFC 3748,\
    \ DOI 10.17487/RFC3748, June 2004,\n              <http://www.rfc-editor.org/info/rfc3748>.\n\
    \   [RFC4072]  Eronen, P., Ed., Hiller, T., and G. Zorn, \"Diameter\n        \
    \      Extensible Authentication Protocol (EAP) Application\",\n             \
    \ RFC 4072, DOI 10.17487/RFC4072, August 2005,\n              <http://www.rfc-editor.org/info/rfc4072>.\n\
    \   [RFC6677]  Hartman, S., Ed., Clancy, T., and K. Hoeper, \"Channel-\n     \
    \         Binding Support for Extensible Authentication Protocol\n           \
    \   (EAP) Methods\", RFC 6677, DOI 10.17487/RFC6677, July 2012,\n            \
    \  <http://www.rfc-editor.org/info/rfc6677>.\n   [RFC7055]  Hartman, S., Ed.,\
    \ and J. Howlett, \"A GSS-API Mechanism for\n              the Extensible Authentication\
    \ Protocol\", RFC 7055,\n              DOI 10.17487/RFC7055, December 2013,\n\
    \              <http://www.rfc-editor.org/info/rfc7055>.\n   [RFC7542]  DeKok,\
    \ A., \"The Network Access Identifier\", RFC 7542,\n              DOI 10.17487/RFC7542,\
    \ May 2015,\n              <http://www.rfc-editor.org/info/rfc7542>.\n   [RFC7833]\
    \  Howlett, J., Hartman, S., and A. Perez-Mendez, Ed., \"A\n              RADIUS\
    \ Attribute, Binding, Profiles, Name Identifier\n              Format, and Confirmation\
    \ Methods for the Security\n              Assertion Markup Language (SAML)\",\
    \ RFC 7833,\n              DOI 10.17487/RFC7833, May 2016,\n              <http://www.rfc-editor.org/info/rfc7833>.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [NIST-SP.800-63-2]\n              Burr, W.,\
    \ Dodson, D., Newton, E., Perlner, R., Polk, W.,\n              Gupta, S., and\
    \ E. Nabbus, \"Electronic Authentication\n              Guideline\", NIST Special\
    \ Publication 800-63-2,\n              August 2013, <http://dx.doi.org/10.6028/NIST.SP.800-63-2>.\n\
    \   [OASIS.saml-core-2.0-os]\n              Cantor, S., Kemp, J., Philpott, R.,\
    \ and E. Maler,\n              \"Assertions and Protocols for the OASIS Security\n\
    \              Assertion Markup Language (SAML) V2.0\", OASIS\n              Standard\
    \ saml-core-2.0-os, March 2005,\n              <http://docs.oasis-open.org/security/saml/v2.0/\n\
    \              saml-core-2.0-os.pdf>.\n   [RFC1964]  Linn, J., \"The Kerberos\
    \ Version 5 GSS-API Mechanism\",\n              RFC 1964, DOI 10.17487/RFC1964,\
    \ June 1996,\n              <http://www.rfc-editor.org/info/rfc1964>.\n   [RFC2782]\
    \  Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for\n              specifying\
    \ the location of services (DNS SRV)\", RFC 2782,\n              DOI 10.17487/RFC2782,\
    \ February 2000,\n              <http://www.rfc-editor.org/info/rfc2782>.\n  \
    \ [RFC3401]  Mealling, M., \"Dynamic Delegation Discovery System (DDDS)\n    \
    \          Part One: The Comprehensive DDDS\", RFC 3401,\n              DOI 10.17487/RFC3401,\
    \ October 2002,\n              <http://www.rfc-editor.org/info/rfc3401>.\n   [RFC3645]\
    \  Kwan, S., Garg, P., Gilroy, J., Esibov, L., Westhead, J.,\n              and\
    \ R. Hall, \"Generic Security Service Algorithm for\n              Secret Key\
    \ Transaction Authentication for DNS (GSS-TSIG)\",\n              RFC 3645, DOI\
    \ 10.17487/RFC3645, October 2003,\n              <http://www.rfc-editor.org/info/rfc3645>.\n\
    \   [RFC4033]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n     \
    \         Rose, \"DNS Security Introduction and Requirements\",\n            \
    \  RFC 4033, DOI 10.17487/RFC4033, March 2005,\n              <http://www.rfc-editor.org/info/rfc4033>.\n\
    \   [RFC4422]  Melnikov, A., Ed., and K. Zeilenga, Ed., \"Simple\n           \
    \   Authentication and Security Layer (SASL)\", RFC 4422,\n              DOI 10.17487/RFC4422,\
    \ June 2006,\n              <http://www.rfc-editor.org/info/rfc4422>.\n   [RFC4462]\
    \  Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch,\n              \"\
    Generic Security Service Application Program Interface\n              (GSS-API)\
    \ Authentication and Key Exchange for the Secure\n              Shell (SSH) Protocol\"\
    , RFC 4462, DOI 10.17487/RFC4462,\n              May 2006, <http://www.rfc-editor.org/info/rfc4462>.\n\
    \   [RFC5056]  Williams, N., \"On the Use of Channel Bindings to Secure\n    \
    \          Channels\", RFC 5056, DOI 10.17487/RFC5056, November 2007,\n      \
    \        <http://www.rfc-editor.org/info/rfc5056>.\n   [RFC5080]  Nelson, D. and\
    \ A. DeKok, \"Common Remote Authentication\n              Dial In User Service\
    \ (RADIUS) Implementation Issues and\n              Suggested Fixes\", RFC 5080,\
    \ DOI 10.17487/RFC5080,\n              December 2007, <http://www.rfc-editor.org/info/rfc5080>.\n\
    \   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n  \
    \            (TLS) Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246,\
    \ August 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5705]\
    \  Rescorla, E., \"Keying Material Exporters for Transport\n              Layer\
    \ Security (TLS)\", RFC 5705, DOI 10.17487/RFC5705,\n              March 2010,\
    \ <http://www.rfc-editor.org/info/rfc5705>.\n   [RFC5801]  Josefsson, S. and N.\
    \ Williams, \"Using Generic Security\n              Service Application Program\
    \ Interface (GSS-API) Mechanisms\n              in Simple Authentication and Security\
    \ Layer (SASL): The\n              GS2 Mechanism Family\", RFC 5801, DOI 10.17487/RFC5801,\n\
    \              July 2010, <http://www.rfc-editor.org/info/rfc5801>.\n   [RFC6066]\
    \  Eastlake 3rd, D., \"Transport Layer Security (TLS)\n              Extensions:\
    \ Extension Definitions\", RFC 6066,\n              DOI 10.17487/RFC6066, January\
    \ 2011,\n              <http://www.rfc-editor.org/info/rfc6066>.\n   [RFC6614]\
    \  Winter, S., McCauley, M., Venaas, S., and K. Wierenga,\n              \"Transport\
    \ Layer Security (TLS) Encryption for RADIUS\",\n              RFC 6614, DOI 10.17487/RFC6614,\
    \ May 2012,\n              <http://www.rfc-editor.org/info/rfc6614>.\n   [RFC6733]\
    \  Fajardo, V., Ed., Arkko, J., Loughney, J., and G. Zorn,\n              Ed.,\
    \ \"Diameter Base Protocol\", RFC 6733,\n              DOI 10.17487/RFC6733, October\
    \ 2012,\n              <http://www.rfc-editor.org/info/rfc6733>.\n   [RFC6749]\
    \  Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\",\n              RFC\
    \ 6749, DOI 10.17487/RFC6749, October 2012,\n              <http://www.rfc-editor.org/info/rfc6749>.\n\
    \   [RFC6973]  Cooper, A., Tschofenig, H., Aboba, B., Peterson, J.,\n        \
    \      Morris, J., Hansen, M., and R. Smith, \"Privacy\n              Considerations\
    \ for Internet Protocols\", RFC 6973,\n              DOI 10.17487/RFC6973, July\
    \ 2013,\n              <http://www.rfc-editor.org/info/rfc6973>.\n   [RFC7029]\
    \  Hartman, S., Wasserman, M., and D. Zhang, \"Extensible\n              Authentication\
    \ Protocol (EAP) Mutual Cryptographic\n              Binding\", RFC 7029, DOI\
    \ 10.17487/RFC7029, October 2013,\n              <http://www.rfc-editor.org/info/rfc7029>.\n\
    \   [RFC7170]  Zhou, H., Cam-Winget, N., Salowey, J., and S. Hanna,\n        \
    \      \"Tunnel Extensible Authentication Protocol (TEAP)\n              Version\
    \ 1\", RFC 7170, DOI 10.17487/RFC7170, May 2014,\n              <http://www.rfc-editor.org/info/rfc7170>.\n\
    \   [RFC7360]  DeKok, A., \"Datagram Transport Layer Security (DTLS) as a\n  \
    \            Transport Layer for RADIUS\", RFC 7360,\n              DOI 10.17487/RFC7360,\
    \ September 2014,\n              <http://www.rfc-editor.org/info/rfc7360>.\n \
    \  [RFC7499]  Perez-Mendez, A., Ed., Marin-Lopez, R., Pereniguez-Garcia,\n   \
    \           F., Lopez-Millan, G., Lopez, D., and A. DeKok, \"Support of\n    \
    \          Fragmentation of RADIUS Packets\", RFC 7499,\n              DOI 10.17487/RFC7499,\
    \ April 2015,\n              <http://www.rfc-editor.org/info/rfc7499>.\n   [RFC7530]\
    \  Haynes, T., Ed., and D. Noveck, Ed., \"Network File System\n              (NFS)\
    \ Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530,\n              March 2015,\
    \ <http://www.rfc-editor.org/info/rfc7530>.\n   [RFC7585]  Winter, S. and M. McCauley,\
    \ \"Dynamic Peer Discovery for\n              RADIUS/TLS and RADIUS/DTLS Based\
    \ on the Network Access\n              Identifier (NAI)\", RFC 7585, DOI 10.17487/RFC7585,\n\
    \              October 2015, <http://www.rfc-editor.org/info/rfc7585>.\n   [WS-TRUST]\
    \ Lawrence, K., Kaler, C., Nadalin, A., Goodner, M., Gudgin,\n              M.,\
    \ Turner, D., Barbir, A., and H. Granqvist,\n              \"WS-Trust 1.4\", OASIS\
    \ Standard ws-trust-2012-04,\n              April 2012, <http://docs.oasis-open.org/ws-sx/ws-trust/\n\
    \              v1.4/ws-trust.html>.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   We would like to thank Mayutan Arumaithurai, Klaas Wierenga,\
    \ and Rhys\n   Smith for their feedback.  Additionally, we would like to thank\
    \ Eve\n   Maler, Nicolas Williams, Bob Morgan, Scott Cantor, Jim Fenton, Paul\n\
    \   Leach, and Luke Howard for their feedback on the federation\n   terminology\
    \ question.\n   Furthermore, we would like to thank Klaas Wierenga for his review\
    \ of\n   the first draft version of this document.  We also thank Eliot Lear\n\
    \   for his work on early draft versions of this document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Josh Howlett\n   Jisc\n   Lumen House, Library Avenue,\
    \ Harwell\n   Oxford  OX11 0SG\n   United Kingdom\n   Phone: +44 1235 822363\n\
    \   Email: Josh.Howlett@ja.net\n   Sam Hartman\n   Painless Security\n   Email:\
    \ hartmans-ietf@mit.edu\n   Hannes Tschofenig\n   ARM Ltd.\n   110 Fulbourn Road\n\
    \   Cambridge  CB1 9NJ\n   United Kingdom\n   Email: Hannes.tschofenig@gmx.net\n\
    \   URI:   http://www.tschofenig.priv.at\n   Jim Schaad\n   August Cellars\n \
    \  Email: ietf@augustcellars.com\n"
