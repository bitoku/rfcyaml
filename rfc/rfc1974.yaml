- title: __initial_text__
  contents:
  - '                   PPP Stac LZS Compression Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Point-to-Point Protocol (PPP) [1] provides a standard method\
    \ for\n   transporting multi-protocol datagrams over point-to-point links.\n \
    \  The PPP Compression Control Protocol [2] provides a method to\n   negotiate\
    \ and utilize compression protocols over PPP encapsulated\n   links.\n   This\
    \ document describes the use of the Stac LZS data compression\n   algorithm, with\
    \ single or multiple compression histories, for\n   compressing PPP encapsulated\
    \ packets.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n                 2.5.3.3.1  History Synchronization with Sequence\n\
    \           2.5.4  History Synchronization Procedure ...............   10\n  \
    \         2.5.5  Compressed Data .................................   11\n    \
    \ 3.     Sending Compressed Datagrams ..........................   12\n      \
    \  3.1       Transmitter Process .............................   12\n        3.2\
    \       Receiver Process ................................   12\n        3.3  \
    \     History Maintenance .............................   13\n        3.4    \
    \   History Resynchronization Mechanism .............   14\n     4.     Configuration\
    \ Option Format ...........................   14\n     5.     Definition of Extended\
    \ Mode ...........................   16\n        5.1       Extended Mode Packet\
    \ Format .....................   16\n        5.2       Extended Mode Transmitter\
    \ Process ...............   18\n        5.3       Extended Mode Receiver Process\
    \ ..................   18\n        5.4       Extended Mode Synchronization ...................\
    \   19\n     SECURITY CONSIDERATIONS ......................................  \
    \ 19\n     REFERENCES ...................................................   20\n\
    \     CHAIR'S ADDRESS    ...........................................   20\n  \
    \   AUTHORS' ADDRESSES............................................   20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Starting with a sliding window compression history, similar\
    \ to LZ1\n   [3], Stac Electronics developed a new, enhanced compression algorithm\n\
    \   identified as Stac LZS.  The LZS algorithm is optimized to compress\n   all\
    \ file types as efficiently as possible.  Even string matches as\n   short as\
    \ two octets are effectively compressed.\n   The Stac LZS compression algorithm\
    \ supports both single compression\n   history communication and multiple compression\
    \ history communication.\n   A single compression history will require the minimum\
    \ amount of\n   memory to implement, but may not provide as much compression as\
    \ a\n   multiple history implementation.\n   Often, many streams of information\
    \ are interleaved over the same\n   link.  Each virtual link will transmit data\
    \ that is independent of\n   other virtual links.  Using multiple compression\
    \ histories can\n   improve the compression ratio of a communication link by associating\n\
    \   separate compression histories with separate virtual links of\n   communication.\n"
- title: 1.1.  Licensing
  contents:
  - "1.1.  Licensing\n   Source and object licenses are available on a non-discriminatory\n\
    \   basis.  Hardware implementations are also available.  Contact Stac\n   Electronics\
    \ at the address and phone number listed with the author's\n   address for further\
    \ information.\n"
- title: 1.2.  Specification of Requirements
  contents:
  - "1.2.  Specification of Requirements\n   In this document, several words are used\
    \ to signify the requirements\n   of the specification.  These words are often\
    \ capitalized.\n   MUST      This word, or the adjective \"required\", means that\
    \ the\n             definition is an absolute requirement of the specification.\n\
    \   MUST NOT  This phrase means that the definition is an absolute\n         \
    \    prohibition of the specification.\n   SHOULD    This word, or the adjective\
    \ \"recommended\", means that there\n             may exist valid reasons in particular\
    \ circumstances to\n             ignore this item, but the full implications MUST\
    \ be\n             understood and carefully weighed before choosing a\n      \
    \       different course.\n   MAY       This word, or the adjective \"optional\"\
    , means that this\n             item is one of an allowed set of alternatives.\
    \  An\n             implementation which does not include this option MUST be\n\
    \             prepared to interoperate with another implementation which\n   \
    \          does include the option.\n"
- title: 2.  LZS Packets
  contents:
  - "2.  LZS Packets\n   Before any LZS packets may be communicated, PPP must reach\
    \ the\n   Network-Layer Protocol phase.\n   When the Compression Control Protocol\
    \ (CCP) has reached the Opened\n   state, and LZS is negotiated as the primary\
    \ compression algorithm,\n   exactly one Stac LZS datagram is encapsulated in\
    \ the PPP Information\n   field, where the PPP Protocol field indicates type hex\
    \ 00FD\n   (compressed datagram) or type hex 00FB (Individual link compressed\n\
    \   datagram).  Type hex 00FD is used when compression is negotiated over\n  \
    \ a single physical link or when compression is negotiated over a\n   single bundle\
    \ consisting of multiple physical links.  Type hex 00FB\n   is used when compression\
    \ is negotiated separately over individual\n   physical links to the same destination.\
    \  For more information, please\n   refer to PPP Compression Control Protocol.\n\
    \   When CCP has not successfully reached the Opened state, or LZS is not\n  \
    \ the primary compression algorithm, exactly one LZS datagram is\n   encapsulated\
    \ in the PPP Information field, where the PPP Protocol\n   field indicates type\
    \ hex 4021 (Stac LZS).\n      Note that in the latter case, use of LZS is terminated\
    \ by the PPP\n      LCP Protocol-Reject.  The default format is used: a single\
    \ history\n      with no History Number field and no Check Value field (as if\
    \ the\n      negotiated history count were 1).\n   The maximum length of the Stac\
    \ LZS datagram transmitted over a PPP\n   link is the same as the maximum length\
    \ of the Information field of a\n   PPP encapsulated packet.\n   Prior to compression,\
    \ the uncompressed data begins with the PPP\n   Protocol ID Field.  Protocol-Field-Compression\
    \ MAY be used on this\n   value, if it has been successfully negotiated for the\
    \ link.\n   The PPP Protocol ID Field is followed by the original Information\n\
    \   field. The length of the uncompressed data field is limited only by\n   the\
    \ allowed size of the compressed data field and the higher protocol\n   layers.\n\
    \   PPP Link Control Protocol packets MUST NOT be sent within Stac LZS\n   packets.\
    \  PPP Network Control Protocol packets MUST NOT be sent\n   within Stac LZS packets.\n"
- title: 2.1.  Padding
  contents:
  - "2.1.  Padding\n   The LZS Information field always ends with the last compressed\
    \ data\n   byte (also known as the <end marker>), which is used to disambiguate\n\
    \   padding.  This allows trailing bits as well as octets to be\n   considered\
    \ padding.\n"
- title: 2.2  Zero Deletion/Insertion
  contents:
  - "2.2  Zero Deletion/Insertion\n   When the sender does not add Padding [1], any\
    \ trailing zero octets\n   MAY be removed prior to transmission.  A single trailing\
    \ zero octet\n   MUST be appended upon receipt, after removal of any framing FCS.\n"
- title: 2.3.  Reliability and Sequencing
  contents:
  - "2.3.  Reliability and Sequencing\n   When no Compression History is kept, the\
    \ algorithm does not depend on\n   a reliable link, and does not require that\
    \ packets be delivered in\n   sequence.  However, per packet compression results\
    \ in a lower\n   compression ratio than it could be on a stream.\n   Some reasons\
    \ for resetting the history on a per packet basis include:\n      -  The link\
    \ has a high error rate.\n      -  The resources of the transmitter or receiver\
    \ limit the ability\n         to maintain a compression history between packets.\n\
    \   When more than 1 Compression History is negotiated, the packet\n   sequence\
    \ MUST be preserved within specific History Numbers.  There is\n   no sequence\
    \ requirement between different History Numbers.\n   When one or more compression\
    \ histories is negotiated on the link, the\n   implementation MUST implement either\
    \ a lower layer reliable link\n   protocol, or keep the compressor and decompressor\
    \ histories in\n   synchronization, or both.\n   To maintain history synchronization,\
    \ the implementation MUST use the\n   Reset-Request and Reset-Ack messages of\
    \ the Compression Control\n   Protocol and MUST use an Option 17 check mode value\
    \ of sequence\n   numbers (and MAY implement other check mode values other than\
    \ none).\n   In this case the Data field of the CCP Reset-Request and Reset-Ack\n\
    \   MUST contain the two octet History Number to be reset, most\n   significant\
    \ octet first.\n   If neither of these conditions are met on the data link, then\
    \ the\n   compression histories MUST be reset after transmitting each datagram.\n\
    \   The transmitter MAY clear a Compression History at any time.  The\n   receiver\
    \ is implicitly notified of this event, and the decompression\n   history will\
    \ automatically be affected.\n   The transmitter MUST reset a history after a\
    \ CCP Reset-Request for\n   the given History Number.\n   2.3.1  Reset-Request\
    \ and Reset-Ack Packet Formats\n      A summary of the CCP Reset-Request and Reset-Ack\
    \ packet formats\n      for Stac LZS compressed links are shown below.  The fields\
    \ are\n      transmitted from left to right.\n    0                   1      \
    \             2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Code      |  Identifier   |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              Data             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Code\n      14 for Reset-Request;\n      15 for Reset-Ack.\n   Identifier\n\
    \      On transmission, the Identifier field MUST be changed whenever the\n  \
    \    content of the Data field changes, and whenever a valid reply has\n     \
    \ been received for a previous request.  For retransmissions, the\n      Identifier\
    \ MAY remain unchanged.\n      On reception, the Identifier field of the Reset-Request\
    \ is copied\n      into the Identifier field of the Reset-Ack packet.\n   Data\n\
    \      The Data field contains the two octet History Number of the\n      compression\
    \ history that is to be reset, most significant octet\n      first.  This History\
    \ Number value is 1 when no history number is\n      present.\n"
- title: 2.4.  Data Expansion
  contents:
  - "2.4.  Data Expansion\n   The maximum expansion of Stac LZS is 12.5%.\n   A Maximum\
    \ Receive Unit (MRU) MAY be negotiated that is 12.5% larger\n   than the size\
    \ of a normal packet.  Then, packets can always be sent\n   compressed regardless\
    \ of expansion.\n   When the expansion plus compression header exceeds the size\
    \ of the\n   peer's MRU for the link, the PPP packet MUST be sent without\n  \
    \ compression, in the original PPP packet form with the \"native\" PPP\n   Protocol\
    \ ID number.  The transmitter MUST reset the affected history.\n   If it is detected\
    \ that most packets are expanding (for example, due\n   to the use of already\
    \ compressed data), then the transmitter SHOULD\n   stop sending compressed packets,\
    \ and reset the appropriate history.\n   Data compression MAY be resumed on this\
    \ data link later.\n"
- title: 2.5.  Packet Format
  contents:
  - "2.5.  Packet Format\n   A summary of the Stac LZS packet format is shown below.\
    \  The fields\n   are transmitted from left to right.\n    0                 \
    \  1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         PPP Protocol          |       (History Number*)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        (Check Value*)         |       Compressed Data ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    * Note: these fields are variable length fields as described below.\n   2.5.1.\
    \  PPP Protocol\n      The PPP Protocol field is a 2 octet field described in\
    \ the Point-\n      to-Point Protocol Encapsulation [1].\n      When the Stac\
    \ LZS compression protocol is successfully negotiated\n      by the PPP Compression\
    \ Control Protocol [2], the value is 00FD hex\n      or 00FB hex as described\
    \ in section 2.  This value MAY be\n      compressed when Protocol-Field-Compression\
    \ is negotiated.\n   2.5.2.  History Number\n      The history number field comprises\
    \ 0, 1, or 2 octets.\n      The number of the compression history which was used,\
    \ ranging from\n      2 to the negotiated History Count.  By default a History\
    \ Count of\n      value 1 is supported and this field is not present.\n      If\
    \ the negotiated History Count is less than 2, this field is\n      removed. \
    \ There is no need for the field when no history is kept,\n      or only a single\
    \ history is kept.\n      If the negotiated History Count is 2 or more, but less\
    \ than\n      256,this field is 1 octet.  If 256 or more histories are\n     \
    \ negotiated, this field is 2 octets, most significant octet first.\n   2.5.3.\
    \  Check Value\n      The check value field comprises 0, 1, or 2 octets.  By default,\n\
    \      sequence number check is added to the packet (the field comprises\n   \
    \   1 octet).\n      2.5.3.1.  LCB\n         A simple one octet Longitudinal Check\
    \ Byte (LCB) MAY be used,\n         after successful negotiation of the LCB option.\
    \  The LCB is the\n         Exclusive-OR of FF(hex) and each octet of the uncompressed\n\
    \         datagram (prior to the compression operation).  On receipt, the\n  \
    \       receiver computes the Exclusive-OR of FF(hex) and each octet of\n    \
    \     the decompressed packet.  If this value does not match the\n         received\
    \ LCB, then a receive failure for that history has\n         occurred.  The receive\
    \ failure is handled according to the\n         history synchronization procedure\
    \ in section 2.5.4.\n      2.5.3.2.  CRC\n         A two octet Cyclic Redundancy\
    \ Check (CRC) MAY be used, instead\n         of the LCB, after successful negotiation\
    \ of the CRC option.\n         The transmitter MUST initialize the CRC value to\
    \ FFFF(hex) at\n         the beginning of each packet.  The CRC computation is\
    \ based on\n         the HDLC FCS-16 polynomial:\n            x**16 + x**12 +\
    \ x**5 + 1\n         The ones complement of the CRC is transmitted least significant\n\
    \         octet first, which contains the coefficient of the highest\n       \
    \  term. On receipt, the receiver initializes the CRC to FFFF\n         (hex),\
    \ and computes the CRC based on the formula above for each\n         octet of\
    \ the decompressed packet.  If the received CRC value\n         does not match\
    \ the transmitted CRC value, then a receive\n         failure for that history\
    \ has occurred.  The receive failure is\n         handled according to the history\
    \ synchronization procedure in\n         section 2.5.4.\n      2.5.3.3.  Sequence\
    \ Number\n         A one octet Sequence Number MAY be used, instead of a LCB or\n\
    \         CRC, after successful negotiation of the Sequence Number\n         option.\
    \  After CCP has reached the open state, the transmitter\n         MUST set the\
    \ value of the sequence number field (the sequence\n         number of the packet)\
    \ to \"1\" and increment modulo 256 on\n         successive packets that contain\
    \ data fields.  The sequence\n         number is relative to the history number\
    \ used.\n         After CCP has reached the open state, the receiver MUST set\
    \ its\n         internal reference value of the next expected sequence number\n\
    \         (the sequence number of next packet to be received) to \"1\".\n    \
    \     After a packet is received, the receiver MUST set the value of\n       \
    \  its internal reference value of the next expected sequence\n         number\
    \ for that history to the value of the sequence number\n         field of the\
    \ received packet plus 1 modulo 256.\n         If the sequence number of the received\
    \ packet is not equal to\n         the internal reference value of the expected\
    \ sequence number\n         for the same history, a receive failure for that history\
    \ has\n         occurred.  The receiver MUST silently discard the out of order\n\
    \         packet, and handle the failure according to the history\n         synchronization\
    \ procedure in section 2.5.4.\n         The sequence number MUST NOT be reset\
    \ by the transmitter when a\n         packet containing a Reset-Req is received.\
    \ The receiver MUST\n         always maintain its sequence number references for\
    \ all\n         supported histories.\n      2.5.3.3.1  History Synchronization\
    \ with Sequence Numbers Example\n      Compressing Sender                Decompressing\
    \ Receiver\n      ....                              ....\n      send seq 101 \
    \    ----------->     recv seq 101\n                                        is\
    \ 101 == 101?  Ok.\n                                        forward packet for\
    \ processing\n                                        set internal reference to\
    \ 102\n      send seq 102     ----------->     recv seq 102\n                \
    \                        is 102 == 102?  Ok.\n                               \
    \         forward packet for processing\n                                    \
    \    set internal reference to 103\n      send seq 103     ------X          (packet\
    \ lost)\n      send seq 104     ----------->     recv seq 104\n              \
    \                          is 104 == 103?  Send reset req!\n                 \
    \                       silently discard packet\n                            \
    \            set internal reference to 105\n      (packet lost)        X-------\
    \     send reset request (ID=200)\n                                        post-increment\
    \ the identifier.\n      send seq 105     ----------->     recv seq 105\n    \
    \                                    is 105 == 105?  Ok.\n                   \
    \                     was reset ack received?  No!\n                         \
    \               silently discard packet\n                                    \
    \    set internal reference to 106\n                       <-----------     send\
    \ reset request again(ID=200)\n                                        (e.g. reset-ack\
    \ time out)\n      send seq 106     ------X          (packet lost)\n      recv\
    \ reset req   <-----------\n      (after line delay)\n         (ID=200)\n    \
    \  reset compression\n         history\n      send reset ack   ----------->  \
    \   recv reset ack (ID=200)\n         (ID=200)\n      send seq 107     ----------->\
    \     recv seq 107\n                                        is 107 == 106?  Send\
    \ reset req!\n                                        silently discard packet\n\
    \                                        set internal reference to 108\n     \
    \ recv reset req   <-----------     send reset request (ID=201)\n         (ID=201)\
    \                       post-increment the identifier.\n      send seq 108   \
    \  ----------->     recv seq 108\n                                        is 108\
    \ == 108?  Ok.\n                                        was reset ack received?\
    \  No!\n                                        silently discard packet\n    \
    \                                    set internal reference to 109\n      send\
    \ seq 109     ----------->     recv seq 109\n                                \
    \        is 109 == 109?  Ok.\n                                        was reset\
    \ ack received?  No!\n                                        silently discard\
    \ packet\n                                        set internal reference to 110\n\
    \      reset compression\n         history\n      send reset ack   ----------->\
    \     recv reset ack (ID=201)\n         (ID=201)\n      send seq 110     ----------->\
    \     recv seq 110\n                                        is 110 == 110?  Ok.\n\
    \                                        forward packet for processing\n     \
    \                                   set internal reference to 111\n      send\
    \ seq 111     ----------->     recv seq 111\n                                \
    \        is 111 == 111?  Ok.\n                                        forward\
    \ packet for processing\n                                        set internal\
    \ reference to 112\n      ....                              ....\n   2.5.4.  History\
    \ Synchronization Procedure\n      On receipt, if Sequence Number one (1) follows\
    \ any other number\n      than zero (0), or is otherwise out of sequence, or the\
    \ LCB or CRC\n      is invalid, a CCP Reset-Request MUST be sent, containing the\
    \ two\n      octet History Number (most significant octet first, and which is\n\
    \      the value 1 when no History Number is present), with a CCP\n      Identifier.\
    \  Identifiers are incremented on each occurrence of an\n      out of sequence\
    \ packet.\n      Upon receipt of the Reset-Request, the transmitter MUST reset\
    \ the\n      affected compression history, and transmit a CCP Reset-Ack packet\n\
    \      with the Identifier field and data (history number) field set to\n    \
    \  the corresponding values of the Reset-Request.  However, the\n      Sequence\
    \ Number (if implemented) is not reset.\n      For each packet that generates\
    \ a receive failure, the receiver\n      MUST increment the Identifier and transmit\
    \ a CCP Reset-Request.\n      For re-transmissions of existing receive failures,\
    \ the Identifier\n      MUST NOT be incremented.\n      After transmitting the\
    \ Reset-Request packet, the receiver MUST\n      continue silently discarding\
    \ valid compressed packets for the\n      corresponding history, until the correct\
    \ CCP Reset-Ack Identifier\n      (corresponding to the Reset-Request) for that\
    \ History Number is\n      received.  Note that if sequence numbers are used,\
    \ the receiver\n      MUST process the sequence number of a received packet according\
    \ to\n      the procedures in section 2.5.4.\n   2.5.5.  Compressed Data\n   \
    \   The data field MUST contain only one datagram in compressed form.\n      The\
    \ length of this field is always an integer number of octets.\n      There MUST\
    \ BE only one end marker per block of compressed data.\n      The form of the\
    \ data field is one block of compressed data as\n      defined in 3.2 of X3.241-1994,\
    \ and is repeated here for\n      informational purposes ONLY.\n   <Compressed\
    \ Stream> := [<Compressed String>] <End Marker>\n   <Compressed String> := 0 <Raw\
    \ Byte> | 1 <Compressed Bytes>\n   <Raw Byte> := <b><b><b><b><b><b><b><b>    \
    \      (8-bit byte)\n   <Compressed Bytes> := <Offset> <Length>\n   <Offset> :=\
    \ 1 <b><b><b><b><b><b><b> |           (7-bit offset)\n               0 <b><b><b><b><b><b><b><b><b><b><b>\
    \ (11-bit offset)\n   <End Marker> := 110000000\n"
- title: <b> := 1 | 0
  contents:
  - "<b> := 1 | 0\n   <Length> :=\n   00        = 2     1111 0110      = 14\n   01\
    \        = 3     1111 0111      = 15\n   10        = 4     1111 1000      = 16\n\
    \   1100      = 5     1111 1001      = 17\n   1101      = 6     1111 1010    \
    \  = 18\n   1110      = 7     1111 1011      = 19\n   1111 0000 = 8     1111 1100\
    \      = 20\n   1111 0001 = 9     1111 1101      = 21\n   1111 0010 = 10    1111\
    \ 1110      = 22\n   1111 0011 = 11    1111 1111 0000 = 23\n   1111 0100 = 12\
    \    1111 1111 0001 = 24\n   1111 0101 = 13     ...\n"
- title: 3.  Sending Compressed Datagrams
  contents:
  - "3.  Sending Compressed Datagrams\n   The reliable and efficient transport of\
    \ datagrams on the data link\n   depends on the following processes.\n"
- title: 3.1.  Transmitter Process
  contents:
  - "3.1.  Transmitter Process\n   When a network datagram is received, it is assigned\
    \ to a particular\n   history buffer and processed according to ANSI X3.241-1994\
    \ to form\n   compressed data.  Prior to the compression operation, if a Reset-\n\
    \   Request is outstanding for the history buffer to be used or if the\n   negotiated\
    \ history count for this data link is 0, the history buffer\n   is cleared.\n\
    \   Uncompressed data MUST be sent (in the original PPP packet form with\n   the\
    \ \"native\" PPP Protocol ID number) if compression causes enough\n   expansion\
    \ to cause the data compression datagram size to exceed the\n   Information field's\
    \ MRU.  In this case, since the compressor has\n   modified the history buffer\
    \ before sending an uncompressed datagram,\n   the history buffer MUST be cleared\
    \ before the next datagram is\n   processed.\n   The output of the compression\
    \ operation is placed in the information\n   field of the datagram.  If the sequence\
    \ number field is present\n   according the value of the check mode field, the\
    \ sequence number\n   counter for the applicable history number MUST be incremented\
    \ and its\n   value placed in the sequence number field.  If the LCB field is\n\
    \   present according the value of the check mode field, the LCB value\n   MUST\
    \ be computed as specified in section 2.5.3.1. and the resultant\n   value placed\
    \ in the LCB field.  If the CRC field is present according\n   the value of the\
    \ check mode field, the CRC value MUST be computed as\n   specified in section\
    \ 2.5.3.2.  and the resultant value placed in the\n   LCB field.  Upon reception\
    \ of a CCP Reset-Request packet, the\n   transmitting compressor MUST be cleared\
    \ to an initial state, which\n   includes clearing the history buffer.  In addition\
    \ to the reset of\n   the compressor, a CCP Reset-Ack packet MUST be transmitted.\
    \  The data\n   field of this packet MUST be filled with the corresponding two\
    \ octet\n   history number, most significant octet first.\n"
- title: 3.2.  Receiver Process
  contents:
  - "3.2.  Receiver Process\n   If a CCP Reset-Request packet is received, the local\
    \ compression\n   engine MUST be signaled that a Reset-Request has been received\
    \ for\n   the history number specified in the data field.  If a CCP Reset-Ack\n\
    \   packet is received, any outstanding receive failure for the specified\n  \
    \ history MUST be cleared.  If no receive failure is outstanding, and\n   the\
    \ sequence number field is present, its value is checked.  If a\n   receive failure\
    \ has occurred, it MUST be handled according to the\n   history resynchronization\
    \ mechanism described below, and the\n   remainder of the datagram is discarded.\n\
    \   If no receive failure is detected, the data is assigned to the\n   indicated\
    \ decompression history buffer and the compressed data block\n   MUST be decompressed\
    \ according to ANSI X3.241-1994.  If the LCB or\n   CRC fields are present on\
    \ the received datagram, an LCB or CRC for\n   the uncompressed data MUST be computed\
    \ and checked against the\n   received LCB or CRC according to sections 2.5.3.1.\
    \ or 2.5.3.2.,\n   respectively.  If a receive failure has occurred, it MUST be\
    \ handled\n   according to the History Resynchronization Mechanism described in\n\
    \   section 3.4.\n   If a CCP Reset-Ack packet is received, the receiving decompressor's\n\
    \   corresponding history MAY be reset to an initial state.  (However,\n   due\
    \ to the characteristics of the Stac LZS algorithm, a decompressor\n   history\
    \ reset is not required).  After reset, any compressed or\n   uncompressed data\
    \ contained in the packet is processed.\n   On the occurrence of a receive failure,\
    \ an implementation MUST\n   transmit a CCP Reset-Request packet with the data\
    \ field containing\n   the two octet history number (most significant octet first)\
    \ matching\n   the history that had the failure.  Once a receive failure has\n\
    \   occurred, the data in any subsequent packets received for that\n   history\
    \ MUST be discarded until a CCP Reset-Ack packet containing a\n   valid Identifier\
    \ matching the Identifier that was sent with the last\n   CCP Reset-Request packet\
    \ is received.  It is the responsibility of\n   the receiver to ensure the reliability\
    \ of the Reset-Request/Ack\n   mechanism.  This may require the transmission of\
    \ additional CCP\n   Reset-Request packets before a CCP Reset-Ack packet is received.\n"
- title: 3.3.  History Maintenance
  contents:
  - "3.3.  History Maintenance\n   The History Count field determines the number of\
    \ history buffers to\n   be maintained for the compression protocol.  For example,\
    \ each\n   history buffer could represent a separate logical connection between\n\
    \   the data compression peers.  When maintaining a history, the peers\n   MUST\
    \ use link error detection and signaling to ensure that both the\n   compressor\
    \ and decompressor copies of each history buffer are always\n   identical.\n \
    \  Setting the History Count field to the value \"0\" indicates that the\n   compression\
    \ is to be on a connectionless basis.  In this case, a\n   single history buffer\
    \ is used and MUST be cleared at the beginning of\n   every datagram.\n   When\
    \ the History Count field is set to the value \"1\", a single\n   history buffer\
    \ is maintained by each of the data compression peers.\n   (A single logical connection.)\n\
    \   When the History Count field is set to a value greater than \"1\",\n   separate\
    \ history buffers, error detection states, and signaling\n   states are maintained\
    \ by the decompressing entity for each history.\n   The compressing peer may transmit\
    \ data on any number of separate\n   histories, up to the value of the History\
    \ Count field.\n"
- title: 3.4.  History Resynchronization Mechanism
  contents:
  - "3.4.  History Resynchronization Mechanism\n   The Stac LZS protocol utilizes\
    \ CCP Reset-Request/Reset-Ack mechanism\n   in order to provide a mechanism for\
    \ indicating a receiver failure in\n   one direction of a compressed link without\
    \ affecting traffic in the\n   other direction.  A receive failure is determined\
    \ using the LCB, CRC,\n   or sequence number mechanisms, according to the value\
    \ of the check\n   mode field.\n   Reset-Requests and Reset-Acks are specific\
    \ to the history number of\n   the packet containing them.\n   Reset-Request/Reset-Ack\
    \ history synchronization signaling is provided\n   to recover from a loss of\
    \ synchronization between peers, especially\n   in unreliable transport layers.\
    \  As with all compression algorithms,\n   the decompressor can not recover from\
    \ dropped, erroneous, or mis-\n   ordered datagrams, and will propagate errors\
    \ catastrophically until\n   both peers are reset to an initial state.\n   The\
    \ Stac LZS protocol provides a means to detect these error\n   conditions: LCB\
    \ or CRC for erroneous datagrams, and sequence number\n   for dropped or mis-ordered\
    \ datagrams.  There is a means for\n   correcting a loss of synchronization: clear\
    \ both the failing\n   compression and decompression histories, and follow the\
    \ transmitter\n   and receiver processes in sections 3.1. and 3.2.\n"
- title: 4.  Configuration Option Format
  contents:
  - '4.  Configuration Option Format

    '
- title: Description
  contents:
  - "Description\n      The CCP Stac LZS Configuration Option negotiates the use of\n\
    \      Stac LZS on the link.  By ultimate disagreement, no compression is\n  \
    \    used.\n      All implementations must support the default values.\n   A summary\
    \ of the Stac LZS Configuration Option format is shown\n   below.  The fields\
    \ are transmitted from left to right.\n    0                   1             \
    \      2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Type      |    Length     |        History Count          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Check Mode  |\n   +-+-+-+-+-+-+-+-+\n   Type\n      17\n   Length\n  \
    \    5\n   History Count\n      The History Count field is two octets, most significant\
    \ octet\n      first, and specifies the maximum number of Compression Histories.\n\
    \      The value 0 indicates that the implementation expects the peer to\n   \
    \   clear the Compression History at the beginning of every packet.\n      The\
    \ value 1 is the default value, and is used to indicate that\n      only one history\
    \ is maintained.\n      Other valid values range from 2 to 65535.  The peer is\
    \ not\n      required to send as many histories as the implementation indicates\n\
    \      that it can accept.  However, it should be noted that resources\n     \
    \ are allocated in each peer to support the number of negotiated\n      histories\
    \ in this field.\n   Check Mode\n      The Check Mode field indicates support\
    \ of LCB, CRC or Sequence\n      checking, and other future extensions to this\
    \ standard.  This\n      field comprises 2 sub-fields, and is considered to be\
    \ bit-mapped.\n      The 3 least significant bits comprise 5 mutually exclusive\
    \ values.\n      The upper 5 bits are all \"Reserved\" bit locations must be set\
    \ to\n      \"0\" to allow for future backward-compatible extensions to this\n\
    \      standard.\n      For compatibility, Sequence Numbers MUST be implemented;\
    \ the other\n      four check modes MAY be implemented.\n"
- title: 'Defined values:'
  contents:
  - "Defined values:\n         0    None             (MAY be implemented; however,\
    \ MUST\n                                implement history count of zero)\n   \
    \      1    LCB              (MAY be implemented)\n         2    CRC         \
    \     (MAY be implemented)\n         3    Sequence Number  (MUST be implemented)\n\
    \         4    Extended Mode    (MAY be implemented)\n          0       1    \
    \    2        3     4     5     6     7\n      +-------+-------+----------+-----+-----+-----+-----+-----+\n\
    \      |    LCB/CRC/Seq#/Ext'd    | Res | Res | Res | Res | Res |\n      +-------+-------+----------+-----+-----+-----+-----+-----+\n"
- title: 5. Definition of Extended Mode
  contents:
  - "5. Definition of Extended Mode\n   When Check Mode 4 (Extended Mode) is successfully\
    \ negotiated, the\n   packet format is different from the format described above.\
    \ The\n   Extended Mode format is described below.  Extended Mode only supports\n\
    \   a history count of 1.\n"
- title: 5.1. Extended Mode Packet Format
  contents:
  - "5.1. Extended Mode Packet Format\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         PPP Protocol          |A|B|C|D| Coherency Count       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Compressed Data...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PPP Protocol\n      The PPP Protocol field is described in the Point-to-Point\
    \ Protocol\n      Encapsulation [1].\n      When a compression protocol is successfully\
    \ negotiated by\n      the PPP Compression Control Protocol [2], the value is\
    \ hex 00FD.\n      Protocol-Field-Compression MUST NOT be used on this value when\n\
    \      extended mode is negotiated on the link, even if Protocol-Field-\n    \
    \  Compression was successfully negotiated before data compression.\n   Bit A\
    \ - PACKET_FLUSHED\n      This bit indicates that the history buffer has just\
    \ been reset\n      before this packet was generated.  Thus, this packet can ALWAYS\n\
    \      be decompressed because it is not based on any previous history.\n    \
    \  This bit is typically sent to inform the peer that it has reset\n      its\
    \ history buffer and that the peer can accept this packet\n      and re-synchronize.\n\
    \   Bit B\n      This bit is not used with Stac LZS compression.\n   Bit C - PACKET_COMPRESSED\n\
    \      This bit is used to indicate that the packet is compressed.  A\n      value\
    \ of 0 indicates uncompressed data, and a value of 1 indicates\n      compressed\
    \ data.\n   Bit D\n      This bit is not used with Stac LZS compression.\n   Coherency\
    \ Count\n      The coherency count is used to assure that the packets are sent\
    \ in\n      proper order and that no packet has been dropped.  This count is\n\
    \      initialized to the value 0x000, and is always increased by 1 after\n  \
    \    each PPP packet is sent.  When all bits are 1, the count returns\n      to\
    \ 0.\n      The coherency count is 12 bits so the decompressor must handle the\n\
    \      rollover case.\n   Compressed Data\n      The compressed data begins with\
    \ the protocol field.  For example,\n      an IP packet may contain 0021 followed\
    \ by an IP header. The\n      compressor will first try to compress the 0021 protocol\
    \ field and\n      then move on to the IP header.\n      Protocol-Field-Compression\
    \ MUST NOT be used on this value when\n      extended mode is negotiated on the\
    \ link, even if Protocol-Field-\n      Compression was successfully negotiated\
    \ before data compression.\n      Zero deletion/insertion described in section\
    \ 2.2 MUST NOT be\n      performed when extended mode is negotiated.\n"
- title: 5.2. Extended Mode Transmitter Process
  contents:
  - "5.2. Extended Mode Transmitter Process\n   When a network datagram is received,\
    \ it is processed according to\n   ANSI X3.241-1994 to form compressed data. \
    \ If a CCP Reset-Request has\n   been received from the decompressor, the compressor\
    \ must clear its\n   history buffer before sending the next packet.\n   Uncompressed\
    \ data MUST be sent if the compression operation causes\n   the compressed datagram\
    \ to expand.  In this case, since the\n   compressor has modified the history\
    \ buffer before sending an\n   uncompressed datagram, the history buffer MUST\
    \ be cleared before the\n   next datagram is processed.  The uncompressed data\
    \ is placed in the\n   information field of the datagram, and Bit-A MUST be set\
    \ (indicating\n   the history was cleared) and Bit-C MUST be clear (indicating\n\
    \   uncompressed data) in the current packet's header. The value of the\n   coherency\
    \ counter is placed in the coherency count field and then the\n   coherency counter\
    \ is incremented.\n   If the compression operation does not cause the compressed\
    \ datagram\n   to expand and if a received Reset-Request is outstanding, then\
    \ the\n   output of the compression operation is placed in the information\n \
    \  field of the datagram, and Bit-A MUST be set (indicating the history\n   was\
    \ cleared) and Bit-C MUST be set (indicating compressed data) in\n   the current\
    \ packet's header. The value of the coherency counter is\n   placed in the coherency\
    \ count field and then the coherency counter is\n   incremented.\n   If the compression\
    \ operation does not cause the compressed datagram\n   to expand and there is\
    \ not a Reset-Request outstanding, then the\n   output of the compression operation\
    \ is placed in the information\n   field of the datagram, and Bit-A MUST be clear\
    \ (indicating the\n   history was not cleared) and Bit-C MUST be set (indicating\
    \ compressed\n   data) in the current packet's header. The value of the coherency\n\
    \   counter is placed in the coherency count field and then the coherency\n  \
    \ counter is incremented.\n   Upon reception of a CCP Reset-Request packet, the\
    \ transmitting\n   compressor MUST be cleared to an initial state, which includes\n\
    \   clearing the history buffer.  In addition to the reset of the\n   compressor,\
    \ the PACKET_FLUSHED bit MUST be set in the header of the\n   next transmitted\
    \ data packet.\n"
- title: 5.3. Extended Mode Receiver Process
  contents:
  - "5.3. Extended Mode Receiver Process\n   When a data compression datagram is received\
    \ from the peer, Bit-A and\n   Bit-C MUST be checked.  Prior to the decompression\
    \ operation, if\n   Bit-A is set, then the coherency count MUST be resynchronized\
    \ to the\n   received value in the coherency count field of the received packet,\n\
    \   and the receiving decompressor's corresponding history MAY be reset\n   to\
    \ an initial state.  (However, due to the characteristics of the\n   Stac LZS\
    \ algorithm, a decompressor history reset is not required).\n   After reset, any\
    \ compressed or uncompressed data contained in the\n   packet is processed, depending\
    \ on the state of Bit-C.\n   Prior to the decompression operation, if Bit-C is\
    \ clear (indicating\n   uncompressed data), then the decompression history buffer\
    \ must not be\n   modified and the decompressor is not involved with deencapsulation.\n\
    \   If Bit-C is set (indicating compressed data) then the received packet\n  \
    \ is decompressed according to ANSI X3.241-1994.\n   If the received packet is\
    \ corrupt, then a Reset-Request is sent and\n   this packet is discarded.  If\
    \ the received packet contains an\n   incorrect coherency count, a Reset-Request\
    \ is sent and this packet is\n   discarded.\n"
- title: 5.4. Extended Mode Synchronization
  contents:
  - "5.4. Extended Mode Synchronization\n   Packets may be lost during transfer. If\
    \ the decompressor maintained\n   coherency count does not match the coherency\
    \ count received in the\n   compressed packet or if the decompressor detects that\
    \ a received\n   packet is corrupted, the decompressor drops the packet and sends\
    \ a\n   CCP Reset-Request packet. The compressor on receiving this packet\n  \
    \ resets the history buffer and sets the PACKET_FLUSHED bit in the next\n   frame\
    \ it sends. The decompressor on receiving a packet with its\n   PACKET_FLUSHED\
    \ bit set, resets its history buffer and sets its\n   coherency count to the one\
    \ shipped by the compressor in that packet.\n   Thus synchronization is achieved\
    \ without a Reset-Ack packet.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: References
  contents:
  - "References\n   [1]   Simpson, W., Editor, \"The Point-to-Point Protocol (PPP)\"\
    , STD\n         51, RFC 1661, Daydreamer, July 1994.\n   [2]   Rand, D., \"The\
    \ PPP Compression Control Protocol (CCP)\", RFC\n         1962, July 1996.\n \
    \  [3]   Lempel, A. and Ziv, J., \"A Universal Algorithm for Sequential\n    \
    \     Data Compression\", IEEE Transactions On Information Theory,\n         Vol.\
    \ IT-23, No. 3, May 1977.\n   [4]   Rand, D., \"PPP Reliable Transmission\", RFC\
    \ 1663, Novell, July\n         1994.\n"
- title: Chair's Address
  contents:
  - "Chair's Address\n   The working group can be contacted via the current chair:\n\
    \      Karl F. Fox\n      Ascend Communications\n      3518 Riverside Dr., Suite\
    \ 101\n      Columbus, Ohio  43221\n      (614) 451-1883\n      EMail: karl@ascend.Com\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Questions about this memo can also be directed to:\n \
    \     Robert Friend\n      Stac Technology\n      12636 High Bluff Drive\n   \
    \   San Diego, CA  92130\n      (619) 794-4542\n      EMail: rfriend@stac.com\n\
    \      William Allen Simpson\n      Daydreamer\n      Computer Systems Consulting\
    \ Services\n      1384 Fontaine\n      Madison Heights, Michigan  48071\n    \
    \  Bill.Simpson@um.cc.umich.edu\n          bsimpson@MorningStar.com (preferred)\n"
