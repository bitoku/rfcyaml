- title: __initial_text__
  contents:
  - '               Multiprotocol Label Switching Architecture

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies the architecture for Multiprotocol Label\n\
    \   Switching (MPLS).\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1          Specification  ......................................\
    \   3\n   2          Introduction to MPLS  ...............................   3\n\
    \   2.1        Overview  ...........................................   4\n   2.2\
    \        Terminology  ........................................   6\n   2.3   \
    \     Acronyms and Abbreviations  .........................   9\n   2.4      \
    \  Acknowledgments  ....................................   9\n   3          MPLS\
    \ Basics  ........................................   9\n   3.1        Labels \
    \ .............................................   9\n   3.2        Upstream and\
    \ Downstream LSRs  .......................  10\n   3.3        Labeled Packet \
    \ .....................................  11\n   3.4        Label Assignment and\
    \ Distribution  ..................  11\n   3.5        Attributes of a Label Binding\
    \  ......................  11\n   3.6        Label Distribution Protocols  .......................\
    \  11\n   3.7        Unsolicited Downstream vs. Downstream-on-Demand  ....  12\n\
    \   3.8        Label Retention Mode  ...............................  12\n   3.9\
    \        The Label Stack  ....................................  13\n   3.10  \
    \     The Next Hop Label Forwarding Entry (NHLFE)  ........  13\n   3.11     \
    \  Incoming Label Map (ILM)  ...........................  14\n   3.12       FEC-to-NHLFE\
    \ Map (FTN)  .............................  14\n   3.13       Label Swapping \
    \ .....................................  15\n   3.14       Scope and Uniqueness\
    \ of Labels  .....................  15\n   3.15       Label Switched Path (LSP),\
    \ LSP Ingress, LSP Egress  .  16\n   3.16       Penultimate Hop Popping  ............................\
    \  18\n   3.17       LSP Next Hop  .......................................  20\n\
    \   3.18       Invalid Incoming Labels  ............................  20\n   3.19\
    \       LSP Control: Ordered versus Independent  ............  20\n   3.20   \
    \    Aggregation  ........................................  21\n   3.21      \
    \ Route Selection  ....................................  23\n   3.22       Lack\
    \ of Outgoing Label  .............................  24\n   3.23       Time-to-Live\
    \ (TTL)  .................................  24\n   3.24       Loop Control  .......................................\
    \  25\n   3.25       Label Encodings  ....................................  26\n\
    \   3.25.1     MPLS-specific Hardware and/or Software  .............  26\n   3.25.2\
    \     ATM Switches as LSRs  ...............................  26\n   3.25.3   \
    \  Interoperability among Encoding Techniques  .........  28\n   3.26       Label\
    \ Merging  ......................................  28\n   3.26.1     Non-merging\
    \ LSRs  ...................................  29\n   3.26.2     Labels for Merging\
    \ and Non-Merging LSRs  ............  30\n   3.26.3     Merge over ATM  .....................................\
    \  31\n   3.26.3.1   Methods of Eliminating Cell Interleave  .............  31\n\
    \   3.26.3.2   Interoperation: VC Merge, VP Merge, and Non-Merge  ..  31\n   3.27\
    \       Tunnels and Hierarchy  ..............................  32\n   3.27.1 \
    \    Hop-by-Hop Routed Tunnel  ...........................  32\n   3.27.2    \
    \ Explicitly Routed Tunnel  ...........................  33\n   3.27.3     LSP\
    \ Tunnels  ........................................  33\n   3.27.4     Hierarchy:\
    \ LSP Tunnels within LSPs  .................  33\n   3.27.5     Label Distribution\
    \ Peering and Hierarchy  ...........  34\n   3.28       Label Distribution Protocol\
    \ Transport  ..............  35\n   3.29       Why More than one Label Distribution\
    \ Protocol?  .....  36\n   3.29.1     BGP and LDP  ........................................\
    \  36\n   3.29.2     Labels for RSVP Flowspecs  ..........................  36\n\
    \   3.29.3     Labels for Explicitly Routed LSPs  ..................  36\n   3.30\
    \       Multicast  ..........................................  37\n   4      \
    \    Some Applications of MPLS  ..........................  37\n   4.1       \
    \ MPLS and Hop by Hop Routed Traffic  .................  37\n   4.1.1      Labels\
    \ for Address Prefixes  ........................  37\n   4.1.2      Distributing\
    \ Labels for Address Prefixes  ...........  37\n   4.1.2.1    Label Distribution\
    \ Peers for an Address Prefix  .....  37\n   4.1.2.2    Distributing Labels  ................................\
    \  38\n   4.1.3      Using the Hop by Hop path as the LSP  ...............  39\n\
    \   4.1.4      LSP Egress and LSP Proxy Egress  ....................  39\n   4.1.5\
    \      The Implicit NULL Label  ............................  40\n   4.1.6   \
    \   Option: Egress-Targeted Label Assignment  ...........  40\n   4.2        MPLS\
    \ and Explicitly Routed LSPs  ....................  42\n   4.2.1      Explicitly\
    \ Routed LSP Tunnels  ......................  42\n   4.3        Label Stacks and\
    \ Implicit Peering  ..................  43\n   4.4        MPLS and Multi-Path\
    \ Routing  ........................  44\n   4.5        LSP Trees as Multipoint-to-Point\
    \ Entities  ..........  44\n   4.6        LSP Tunneling between BGP Border Routers\
    \  ...........  45\n   4.7        Other Uses of Hop-by-Hop Routed LSP Tunnels\
    \  ........  47\n   4.8        MPLS and Multicast  .................................\
    \  47\n   5          Label Distribution Procedures (Hop-by-Hop)  .........  47\n\
    \   5.1        The Procedures for Advertising and Using labels  ....  48\n   5.1.1\
    \      Downstream LSR: Distribution Procedure  .............  48\n   5.1.1.1 \
    \   PushUnconditional  ..................................  49\n   5.1.1.2    PushConditional\
    \  ....................................  49\n   5.1.1.3    PulledUnconditional\
    \  ................................  49\n   5.1.1.4    PulledConditional  ..................................\
    \  50\n   5.1.2      Upstream LSR: Request Procedure  ....................  51\n\
    \   5.1.2.1    RequestNever  .......................................  51\n   5.1.2.2\
    \    RequestWhenNeeded  ..................................  51\n   5.1.2.3   \
    \ RequestOnRequest  ...................................  51\n   5.1.3      Upstream\
    \ LSR: NotAvailable Procedure  ...............  52\n   5.1.3.1    RequestRetry\
    \  .......................................  52\n   5.1.3.2    RequestNoRetry \
    \ .....................................  52\n   5.1.4      Upstream LSR: Release\
    \ Procedure  ....................  52\n   5.1.4.1    ReleaseOnChange  ....................................\
    \  52\n   5.1.4.2    NoReleaseOnChange  ..................................  53\n\
    \   5.1.5      Upstream LSR: labelUse Procedure  ...................  53\n   5.1.5.1\
    \    UseImmediate  .......................................  53\n   5.1.5.2   \
    \ UseIfLoopNotDetected  ...............................  53\n   5.1.6      Downstream\
    \ LSR: Withdraw Procedure  .................  53\n   5.2        MPLS Schemes:\
    \ Supported Combinations of Procedures  .  54\n   5.2.1      Schemes for LSRs\
    \ that Support Label Merging  ........  55\n   5.2.2      Schemes for LSRs that\
    \ do not Support Label Merging  .  56\n   5.2.3      Interoperability Considerations\
    \  ....................  57\n   6          Security Considerations  ............................\
    \  58\n   7          Intellectual Property  ..............................  58\n\
    \   8          Authors' Addresses  .................................  59\n   9\
    \          References  .........................................  59\n   10  \
    \       Full Copyright Statement  ...........................  61\n"
- title: 1. Specification
  contents:
  - "1. Specification\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119.\n"
- title: 2. Introduction to MPLS
  contents:
  - "2. Introduction to MPLS\n   This document specifies the architecture for Multiprotocol\
    \ Label\n   Switching (MPLS).\n   Note that the use of MPLS for multicast is left\
    \ for further study.\n"
- title: 2.1. Overview
  contents:
  - "2.1. Overview\n   As a packet of a connectionless network layer protocol travels\
    \ from\n   one router to the next, each router makes an independent forwarding\n\
    \   decision for that packet.  That is, each router analyzes the packet's\n  \
    \ header, and each router runs a network layer routing algorithm.  Each\n   router\
    \ independently chooses a next hop for the packet, based on its\n   analysis of\
    \ the packet's header and the results of running the\n   routing algorithm.\n\
    \   Packet headers contain considerably more information than is needed\n   simply\
    \ to choose the next hop.  Choosing the next hop can therefore\n   be thought\
    \ of as the composition of two functions.  The first\n   function partitions the\
    \ entire set of possible packets into a set of\n   \"Forwarding Equivalence Classes\
    \ (FECs)\".  The second maps each FEC to\n   a next hop.  Insofar as the forwarding\
    \ decision is concerned,\n   different packets which get mapped into the same\
    \ FEC are\n   indistinguishable.  All packets which belong to a particular FEC\
    \ and\n   which travel from a particular node will follow the same path (or if\n\
    \   certain kinds of multi-path routing are in use, they will all follow\n   one\
    \ of a set of paths associated with the FEC).\n   In conventional IP forwarding,\
    \ a particular router will typically\n   consider two packets to be in the same\
    \ FEC if there is some address\n   prefix X in that router's routing tables such\
    \ that X is the \"longest\n   match\" for each packet's destination address. \
    \ As the packet\n   traverses the network, each hop in turn reexamines the packet\
    \ and\n   assigns it to a FEC.\n   In MPLS, the assignment of a particular packet\
    \ to a particular FEC is\n   done just once, as the packet enters the network.\
    \  The FEC to which\n   the packet is assigned is encoded as a short fixed length\
    \ value known\n   as a \"label\".  When a packet is forwarded to its next hop,\
    \ the label\n   is sent along with it; that is, the packets are \"labeled\" before\
    \ they\n   are forwarded.\n   At subsequent hops, there is no further analysis\
    \ of the packet's\n   network layer header.  Rather, the label is used as an index\
    \ into a\n   table which specifies the next hop, and a new label.  The old label\n\
    \   is replaced with the new label, and the packet is forwarded to its\n   next\
    \ hop.\n   In the MPLS forwarding paradigm, once a packet is assigned to a FEC,\n\
    \   no further header analysis is done by subsequent routers; all\n   forwarding\
    \ is driven by the labels.  This has a number of advantages\n   over conventional\
    \ network layer forwarding.\n      -  MPLS forwarding can be done by switches\
    \ which are capable of\n         doing label lookup and replacement, but are either\
    \ not capable\n         of analyzing the network layer headers, or are not capable\
    \ of\n         analyzing the network layer headers at adequate speed.\n      -\
    \  Since a packet is assigned to a FEC when it enters the network,\n         the\
    \ ingress router may use, in determining the assignment, any\n         information\
    \ it has about the packet, even if that information\n         cannot be gleaned\
    \ from the network layer header.  For example,\n         packets arriving on different\
    \ ports may be assigned to\n         different FECs.  Conventional forwarding,\
    \ on the other hand,\n         can only consider information which travels with\
    \ the packet in\n         the packet header.\n      -  A packet that enters the\
    \ network at a particular router can be\n         labeled differently than the\
    \ same packet entering the network\n         at a different router, and as a result\
    \ forwarding decisions\n         that depend on the ingress router can be easily\
    \ made.  This\n         cannot be done with conventional forwarding, since the\
    \ identity\n         of a packet's ingress router does not travel with the packet.\n\
    \      -  The considerations that determine how a packet is assigned to a\n  \
    \       FEC can become ever more and more complicated, without any\n         impact\
    \ at all on the routers that merely forward labeled\n         packets.\n     \
    \ -  Sometimes it is desirable to force a packet to follow a\n         particular\
    \ route which is explicitly chosen at or before the\n         time the packet\
    \ enters the network, rather than being chosen by\n         the normal dynamic\
    \ routing algorithm as the packet travels\n         through the network.  This\
    \ may be done as a matter of policy,\n         or to support traffic engineering.\
    \  In conventional forwarding,\n         this requires the packet to carry an\
    \ encoding of its route\n         along with it (\"source routing\").  In MPLS,\
    \ a label can be used\n         to represent the route, so that the identity of\
    \ the explicit\n         route need not be carried with the packet.\n   Some routers\
    \ analyze a packet's network layer header not merely to\n   choose the packet's\
    \ next hop, but also to determine a packet's\n   \"precedence\" or \"class of\
    \ service\".  They may then apply different\n   discard thresholds or scheduling\
    \ disciplines to different packets.\n   MPLS allows (but does not require) the\
    \ precedence or class of service\n   to be fully or partially inferred from the\
    \ label.  In this case, one\n   may say that the label represents the combination\
    \ of a FEC and a\n   precedence or class of service.\n   MPLS stands for \"Multiprotocol\"\
    \ Label Switching, multiprotocol\n   because its techniques are applicable to\
    \ ANY network layer protocol.\n   In this document, however, we focus on the use\
    \ of IP as the network\n   layer protocol.\n   A router which supports MPLS is\
    \ known as a \"Label Switching Router\",\n   or LSR.\n"
- title: 2.2. Terminology
  contents:
  - "2.2. Terminology\n   This section gives a general conceptual overview of the\
    \ terms used in\n   this document.  Some of these terms are more precisely defined\
    \ in\n   later sections of the document.\n      DLCI                      a label\
    \ used in Frame Relay networks to\n                                identify frame\
    \ relay circuits\n      forwarding equivalence class   a group of IP packets which\
    \ are\n                                     forwarded in the same manner (e.g.,\n\
    \                                     over the same path, with the same\n    \
    \                                 forwarding treatment)\n      frame merge   \
    \            label merging, when it is applied to\n                          \
    \      operation over frame based media, so\n                                that\
    \ the potential problem of cell\n                                interleave is\
    \ not an issue.\n      label                     a short fixed length physically\n\
    \                                contiguous identifier which is used to\n    \
    \                            identify a FEC, usually of local\n              \
    \                  significance.\n      label merging             the replacement\
    \ of multiple incoming\n                                labels for a particular\
    \ FEC with a\n                                single outgoing label\n      label\
    \ swap                the basic forwarding operation\n                       \
    \         consisting of looking up an incoming\n                             \
    \   label to determine the outgoing label,\n                                encapsulation,\
    \ port, and other data\n                                handling information.\n\
    \      label swapping            a forwarding paradigm allowing\n            \
    \                    streamlined forwarding of data by using\n               \
    \                 labels to identify classes of data\n                       \
    \         packets which are treated\n                                indistinguishably\
    \ when forwarding.\n      label switched hop        the hop between two MPLS nodes,\
    \ on which\n                                forwarding is done using labels.\n\
    \      label switched path       The path through one or more LSRs at one\n  \
    \                              level of the hierarchy followed by a\n        \
    \                        packets in a particular FEC.\n      label switching router\
    \    an MPLS node which is capable of\n                                forwarding\
    \ native L3 packets\n      layer 2                   the protocol layer under\
    \ layer 3 (which\n                                therefore offers the services\
    \ used by\n                                layer 3).  Forwarding, when done by\
    \ the\n                                swapping of short fixed length labels,\n\
    \                                occurs at layer 2 regardless of whether\n   \
    \                             the label being examined is an ATM\n           \
    \                     VPI/VCI, a frame relay DLCI, or an MPLS\n              \
    \                  label.\n      layer 3                   the protocol layer\
    \ at which IP and its\n                                associated routing protocols\
    \ operate\n                                link layer synonymous with layer 2\n\
    \      loop detection            a method of dealing with loops in which\n   \
    \                             loops are allowed to be set up, and data\n     \
    \                           may be transmitted over the loop, but\n          \
    \                      the loop is later detected\n      loop prevention     \
    \      a method of dealing with loops in which\n                             \
    \   data is never transmitted over a loop\n      label stack               an\
    \ ordered set of labels\n      merge point               a node at which label\
    \ merging is done\n      MPLS domain               a contiguous set of nodes which\
    \ operate\n                                MPLS routing and forwarding and which\n\
    \                                are also in one Routing or\n                \
    \                Administrative Domain\n      MPLS edge node            an MPLS\
    \ node that connects an MPLS\n                                domain with a node\
    \ which is outside of\n                                the domain, either because\
    \ it does not\n                                run MPLS, and/or because it is\
    \ in a\n                                different domain.  Note that if an LSR\n\
    \                                has a neighboring host which is not\n       \
    \                         running MPLS, that that LSR is an MPLS\n           \
    \                     edge node.\n      MPLS egress node          an MPLS edge\
    \ node in its role in\n                                handling traffic as it\
    \ leaves an MPLS\n                                domain\n      MPLS ingress node\
    \         an MPLS edge node in its role in\n                                handling\
    \ traffic as it enters an MPLS\n                                domain\n     \
    \ MPLS label                a label which is carried in a packet\n           \
    \                     header, and which represents the\n                     \
    \           packet's FEC\n      MPLS node                 a node which is running\
    \ MPLS.  An MPLS\n                                node will be aware of MPLS control\n\
    \                                protocols, will operate one or more L3\n    \
    \                            routing protocols, and will be capable\n        \
    \                        of forwarding packets based on labels.\n            \
    \                    An MPLS node may optionally be also\n                   \
    \             capable of forwarding native L3 packets.\n      MultiProtocol Label\
    \ Switching  an IETF working group and the\n                                 \
    \    effort associated with the working\n                                    \
    \ group\n      network layer             synonymous with layer 3\n      stack\
    \                     synonymous with label stack\n      switched path       \
    \      synonymous with label switched path\n      virtual circuit           a\
    \ circuit used by a connection-oriented\n                                layer\
    \ 2 technology such as ATM or Frame\n                                Relay, requiring\
    \ the maintenance of\n                                state information in layer\
    \ 2 switches.\n      VC merge                  label merging where the MPLS label\
    \ is\n                                carried in the ATM VCI field (or\n     \
    \                           combined VPI/VCI field), so as to allow\n        \
    \                        multiple VCs to merge into one single VC\n      VP merge\
    \                  label merging where the MPLS label is\n                   \
    \             carried din the ATM VPI field, so as to\n                      \
    \          allow multiple VPs to be merged into one\n                        \
    \        single VP.  In this case two cells would\n                          \
    \      have the same VCI value only if they\n                                originated\
    \ from the same node.  This\n                                allows cells from\
    \ different sources to\n                                be distinguished via the\
    \ VCI.\n      VPI/VCI                   a label used in ATM networks to identify\n\
    \                                circuits\n"
- title: 2.3. Acronyms and Abbreviations
  contents:
  - "2.3. Acronyms and Abbreviations\n   ATM                       Asynchronous Transfer\
    \ Mode\n   BGP                       Border Gateway Protocol\n   DLCI        \
    \              Data Link Circuit Identifier\n   FEC                       Forwarding\
    \ Equivalence Class\n   FTN                       FEC to NHLFE Map\n   IGP   \
    \                    Interior Gateway Protocol\n   ILM                       Incoming\
    \ Label Map\n   IP                        Internet Protocol\n   LDP          \
    \             Label Distribution Protocol\n   L2                        Layer\
    \ 2 L3                        Layer 3\n   LSP                       Label Switched\
    \ Path\n   LSR                       Label Switching Router\n   MPLS         \
    \             MultiProtocol Label Switching\n   NHLFE                     Next\
    \ Hop Label Forwarding Entry\n   SVC                       Switched Virtual Circuit\n\
    \   SVP                       Switched Virtual Path\n   TTL                  \
    \     Time-To-Live\n   VC                        Virtual Circuit\n   VCI     \
    \                  Virtual Circuit Identifier\n   VP                        Virtual\
    \ Path\n   VPI                       Virtual Path Identifier\n"
- title: 2.4. Acknowledgments
  contents:
  - "2.4. Acknowledgments\n   The ideas and text in this document have been collected\
    \ from a number\n   of sources and comments received.  We would like to thank\
    \ Rick\n   Boivie, Paul Doolan, Nancy Feldman, Yakov Rekhter, Vijay Srinivasan,\n\
    \   and George Swallow for their inputs and ideas.\n"
- title: 3. MPLS Basics
  contents:
  - "3. MPLS Basics\n   In this section, we introduce some of the basic concepts of\
    \ MPLS and\n   describe the general approach to be used.\n"
- title: 3.1. Labels
  contents:
  - "3.1. Labels\n   A label is a short, fixed length, locally significant identifier\n\
    \   which is used to identify a FEC.  The label which is put on a\n   particular\
    \ packet represents the Forwarding Equivalence Class to\n   which that packet\
    \ is assigned.\n   Most commonly, a packet is assigned to a FEC based (completely\
    \ or\n   partially) on its network layer destination address.  However, the\n\
    \   label is never an encoding of that address.\n   If Ru and Rd are LSRs, they\
    \ may agree that when Ru transmits a packet\n   to Rd, Ru will label with packet\
    \ with label value L if and only if\n   the packet is a member of a particular\
    \ FEC F.  That is, they can\n   agree to a \"binding\" between label L and FEC\
    \ F for packets moving\n   from Ru to Rd.  As a result of such an agreement, L\
    \ becomes Ru's\n   \"outgoing label\" representing FEC F, and L becomes Rd's \"\
    incoming\n   label\" representing FEC F.\n   Note that L does not necessarily\
    \ represent FEC F for any packets\n   other than those which are being sent from\
    \ Ru to Rd.  L is an\n   arbitrary value whose binding to F is local to Ru and\
    \ Rd.\n   When we speak above of packets \"being sent\" from Ru to Rd, we do not\n\
    \   imply either that the packet originated at Ru or that its destination\n  \
    \ is Rd.  Rather, we mean to include packets which are \"transit\n   packets\"\
    \ at one or both of the LSRs.\n   Sometimes it may be difficult or even impossible\
    \ for Rd to tell, of\n   an arriving packet carrying label L, that the label L\
    \ was placed in\n   the packet by Ru, rather than by some other LSR.  (This will\n\
    \   typically be the case when Ru and Rd are not direct neighbors.)  In\n   such\
    \ cases, Rd must make sure that the binding from label to FEC is\n   one-to-one.\
    \  That is, Rd MUST NOT agree with Ru1 to bind L to FEC F1,\n   while also agreeing\
    \ with some other LSR Ru2 to bind L to a different\n   FEC F2, UNLESS Rd can always\
    \ tell, when it receives a packet with\n   incoming label L, whether the label\
    \ was put on the packet by Ru1 or\n   whether it was put on by Ru2.\n   It is\
    \ the responsibility of each LSR to ensure that it can uniquely\n   interpret\
    \ its incoming labels.\n"
- title: 3.2. Upstream and Downstream LSRs
  contents:
  - "3.2. Upstream and Downstream LSRs\n   Suppose Ru and Rd have agreed to bind label\
    \ L to FEC F, for packets\n   sent from Ru to Rd.  Then with respect to this binding,\
    \ Ru is the\n   \"upstream LSR\", and Rd is the \"downstream LSR\".\n   To say\
    \ that one node is upstream and one is downstream with respect\n   to a given\
    \ binding means only that a particular label represents a\n   particular FEC in\
    \ packets travelling from the upstream node to the\n   downstream node.  This\
    \ is NOT meant to imply that packets in that FEC\n   would actually be routed\
    \ from the upstream node to the downstream\n   node.\n"
- title: 3.3. Labeled Packet
  contents:
  - "3.3. Labeled Packet\n   A \"labeled packet\" is a packet into which a label has\
    \ been encoded.\n   In some cases, the label resides in an encapsulation header\
    \ which\n   exists specifically for this purpose.  In other cases, the label may\n\
    \   reside in an existing data link or network layer header, as long as\n   there\
    \ is a field which is available for that purpose.  The particular\n   encoding\
    \ technique to be used must be agreed to by both the entity\n   which encodes\
    \ the label and the entity which decodes the label.\n"
- title: 3.4. Label Assignment and Distribution
  contents:
  - "3.4. Label Assignment and Distribution\n   In the MPLS architecture, the decision\
    \ to bind a particular label L\n   to a particular FEC F is made by the LSR which\
    \ is DOWNSTREAM with\n   respect to that binding.  The downstream LSR then informs\
    \ the\n   upstream LSR of the binding.  Thus labels are \"downstream-assigned\"\
    ,\n   and label bindings are distributed in the \"downstream to upstream\"\n \
    \  direction.\n   If an LSR has been designed so that it can only look up labels\
    \ that\n   fall into a certain numeric range, then it merely needs to ensure\n\
    \   that it only binds labels that are in that range.\n"
- title: 3.5. Attributes of a Label Binding
  contents:
  - "3.5. Attributes of a Label Binding\n   A particular binding of label L to FEC\
    \ F, distributed by Rd to Ru,\n   may have associated \"attributes\".  If Ru,\
    \ acting as a downstream LSR,\n   also distributes a binding of a label to FEC\
    \ F, then under certain\n   conditions, it may be required to also distribute\
    \ the corresponding\n   attribute that it received from Rd.\n"
- title: 3.6. Label Distribution Protocols
  contents:
  - "3.6. Label Distribution Protocols\n   A label distribution protocol is a set\
    \ of procedures by which one LSR\n   informs another of the label/FEC bindings\
    \ it has made.  Two LSRs\n   which use a label distribution protocol to exchange\
    \ label/FEC binding\n   information are known as \"label distribution peers\"\
    \ with respect to\n   the binding information they exchange.  If two LSRs are\
    \ label\n   distribution peers, we will speak of there being a \"label\n   distribution\
    \ adjacency\" between them.\n   (N.B.: two LSRs may be label distribution peers\
    \ with respect to some\n   set of bindings, but not with respect to some other\
    \ set of bindings.)\n   The label distribution protocol also encompasses any negotiations\
    \ in\n   which two label distribution peers need to engage in order to learn\n\
    \   of each other's MPLS capabilities.\n   THE ARCHITECTURE DOES NOT ASSUME THAT\
    \ THERE IS ONLY A SINGLE LABEL\n   DISTRIBUTION PROTOCOL.  In fact, a number of\
    \ different label\n   distribution protocols are being standardized.  Existing\
    \ protocols\n   have been extended so that label distribution can be piggybacked\
    \ on\n   them (see, e.g., [MPLS-BGP], [MPLS-RSVP-TUNNELS]).  New protocols\n \
    \  have also been defined for the explicit purpose of distributing\n   labels\
    \ (see, e.g., [MPLS-LDP], [MPLS-CR-LDP].\n   In this document, we try to use the\
    \ acronym \"LDP\" to refer\n   specifically to the protocol defined in [MPLS-LDP];\
    \ when speaking of\n   label distribution protocols in general, we try to avoid\
    \ the acronym.\n"
- title: 3.7. Unsolicited Downstream vs. Downstream-on-Demand
  contents:
  - "3.7. Unsolicited Downstream vs. Downstream-on-Demand\n   The MPLS architecture\
    \ allows an LSR to explicitly request, from its\n   next hop for a particular\
    \ FEC, a label binding for that FEC.  This is\n   known as \"downstream-on-demand\"\
    \ label distribution.\n   The MPLS architecture also allows an LSR to distribute\
    \ bindings to\n   LSRs that have not explicitly requested them.  This is known\
    \ as\n   \"unsolicited downstream\" label distribution.\n   It is expected that\
    \ some MPLS implementations will provide only\n   downstream-on-demand label distribution,\
    \ and some will provide only\n   unsolicited downstream label distribution, and\
    \ some will provide\n   both.  Which is provided may depend on the characteristics\
    \ of the\n   interfaces which are supported by a particular implementation.\n\
    \   However, both of these label distribution techniques may be used in\n   the\
    \ same network at the same time.  On any given label distribution\n   adjacency,\
    \ the upstream LSR and the downstream LSR must agree on\n   which technique is\
    \ to be used.\n"
- title: 3.8. Label Retention Mode
  contents:
  - "3.8. Label Retention Mode\n   An LSR Ru may receive (or have received) a label\
    \ binding for a\n   particular FEC from an LSR Rd, even though Rd is not Ru's\
    \ next hop\n   (or is no longer Ru's next hop) for that FEC.\n   Ru then has the\
    \ choice of whether to keep track of such bindings, or\n   whether to discard\
    \ such bindings.  If Ru keeps track of such\n   bindings, then it may immediately\
    \ begin using the binding again if Rd\n   eventually becomes its next hop for\
    \ the FEC in question.  If Ru\n   discards such bindings, then if Rd later becomes\
    \ the next hop, the\n   binding will have to be reacquired.\n   If an LSR supports\
    \ \"Liberal Label Retention Mode\", it maintains the\n   bindings between a label\
    \ and a FEC which are received from LSRs which\n   are not its next hop for that\
    \  FEC.  If an LSR supports \"Conservative\n   Label Retention Mode\", it discards\
    \ such bindings.\n   Liberal label retention mode allows for quicker adaptation\
    \ to routing\n   changes, but conservative label retention mode though requires\
    \ an LSR\n   to maintain many fewer labels.\n"
- title: 3.9. The Label Stack
  contents:
  - "3.9. The Label Stack\n   So far, we have spoken as if a labeled packet carries\
    \ only a single\n   label.  As we shall see, it is useful to have a more general\
    \ model in\n   which a labeled packet carries a number of labels, organized as\
    \ a\n   last-in, first-out stack.  We refer to this as a \"label stack\".\n  \
    \ Although, as we shall see, MPLS supports a hierarchy, the processing\n   of\
    \ a labeled packet is completely independent of the level of\n   hierarchy.  The\
    \ processing is always based on the top label, without\n   regard for the possibility\
    \ that some number of other labels may have\n   been \"above it\" in the past,\
    \ or that some number of other labels may\n   be below it at present.\n   An unlabeled\
    \ packet can be thought of as a packet whose label stack\n   is empty (i.e., whose\
    \ label stack has depth 0).\n   If a packet's label stack is of depth m, we refer\
    \ to the label at the\n   bottom of the stack as the level 1 label, to the label\
    \ above it (if\n   such exists) as the level 2 label, and to the label at the\
    \ top of the\n   stack as the level m label.\n   The utility of the label stack\
    \ will become clear when we introduce\n   the notion of LSP Tunnel and the MPLS\
    \ Hierarchy (section 3.27).\n"
- title: 3.10. The Next Hop Label Forwarding Entry (NHLFE)
  contents:
  - "3.10. The Next Hop Label Forwarding Entry (NHLFE)\n   The \"Next Hop Label Forwarding\
    \ Entry\" (NHLFE) is used when forwarding\n   a labeled packet.  It contains the\
    \ following information:\n   1. the packet's next hop\n   2. the operation to\
    \ perform on the packet's label stack; this is one\n      of the following operations:\n\
    \      a) replace the label at the top of the label stack with a\n         specified\
    \ new label\n      b) pop the label stack\n      c) replace the label at the top\
    \ of the label stack with a\n         specified new label, and then push one or\
    \ more specified new\n         labels onto the label stack.\n   It may also contain:\n\
    \      d) the data link encapsulation to use when transmitting the packet\n  \
    \    e) the way to encode the label stack when transmitting the packet\n     \
    \ f) any other information needed in order to properly dispose of\n         the\
    \ packet.\n   Note that at a given LSR, the packet's \"next hop\" might be that\
    \ LSR\n   itself.  In this case, the LSR would need to pop the top level label,\n\
    \   and then \"forward\" the resulting packet to itself.  It would then\n   make\
    \ another forwarding decision, based on what remains after the\n   label stacked\
    \ is popped.  This may still be a labeled packet, or it\n   may be the native\
    \ IP packet.\n   This implies that in some cases the LSR may need to operate on\
    \ the IP\n   header in order to forward the packet.\n   If the packet's \"next\
    \ hop\" is the current LSR, then the label stack\n   operation MUST be to \"pop\
    \ the stack\".\n"
- title: 3.11. Incoming Label Map (ILM)
  contents:
  - "3.11. Incoming Label Map (ILM)\n   The \"Incoming Label Map\" (ILM) maps each\
    \ incoming label to a set of\n   NHLFEs.  It is used when forwarding packets that\
    \ arrive as labeled\n   packets.\n   If the ILM maps a particular label to a set\
    \ of NHLFEs that contains\n   more than one element, exactly one element of the\
    \ set must be chosen\n   before the packet is forwarded.  The procedures for choosing\
    \ an\n   element from the set are beyond the scope of this document.  Having\n\
    \   the ILM map a label to a set containing more than one NHLFE may be\n   useful\
    \ if, e.g., it is desired to do load balancing over multiple\n   equal-cost paths.\n"
- title: 3.12. FEC-to-NHLFE Map (FTN)
  contents:
  - "3.12. FEC-to-NHLFE Map (FTN)\n   The \"FEC-to-NHLFE\" (FTN) maps each FEC to\
    \ a set of NHLFEs.  It is\n   used when forwarding packets that arrive unlabeled,\
    \ but which are to\n   be labeled before being forwarded.\n   If the FTN maps\
    \ a particular label to a set of NHLFEs that contains\n   more than one element,\
    \ exactly one element of the set must be chosen\n   before the packet is forwarded.\
    \  The procedures for choosing an\n   element from the set are beyond the scope\
    \ of this document.  Having\n   the FTN map a label to a set containing more than\
    \ one NHLFE may be\n   useful if, e.g., it is desired to do load balancing over\
    \ multiple\n   equal-cost paths.\n"
- title: 3.13. Label Swapping
  contents:
  - "3.13. Label Swapping\n   Label swapping is the use of the following procedures\
    \ to forward a\n   packet.\n   In order to forward a labeled packet, a LSR examines\
    \ the label at the\n   top of the label stack.  It uses the ILM to map this label\
    \ to an\n   NHLFE.  Using the information in the NHLFE, it determines where to\n\
    \   forward the packet, and performs an operation on the packet's label\n   stack.\
    \  It then encodes the new label stack into the packet, and\n   forwards the result.\n\
    \   In order to forward an unlabeled packet, a LSR analyzes the network\n   layer\
    \ header, to determine the packet's FEC.  It then uses the FTN to\n   map this\
    \ to an NHLFE.  Using the information in the NHLFE, it\n   determines where to\
    \ forward the packet, and performs an operation on\n   the packet's label stack.\
    \  (Popping the label stack would, of course,\n   be illegal in this case.)  It\
    \ then encodes the new label stack into\n   the packet, and forwards the result.\n\
    \   IT IS IMPORTANT TO NOTE THAT WHEN LABEL SWAPPING IS IN USE, THE NEXT\n   HOP\
    \ IS ALWAYS TAKEN FROM THE NHLFE; THIS MAY IN SOME CASES BE\n   DIFFERENT FROM\
    \ WHAT THE NEXT HOP WOULD BE IF MPLS WERE NOT IN USE.\n"
- title: 3.14. Scope and Uniqueness of Labels
  contents:
  - "3.14. Scope and Uniqueness of Labels\n   A given LSR Rd may bind label L1 to\
    \ FEC F, and distribute that\n   binding to label distribution peer Ru1.  Rd may\
    \ also bind label L2 to\n   FEC F, and distribute that binding to label distribution\
    \ peer Ru2.\n   Whether or not L1 == L2 is not determined by the architecture;\
    \ this\n   is a local matter.\n   A given LSR Rd may bind label L to FEC F1, and\
    \ distribute that\n   binding to label distribution peer Ru1.  Rd may also bind\
    \ label L to\n   FEC F2, and distribute that binding to label distribution peer\
    \ Ru2.\n   IF (AND ONLY IF) RD CAN TELL, WHEN IT RECEIVES A PACKET WHOSE TOP\n\
    \   LABEL IS L, WHETHER THE LABEL WAS PUT THERE BY RU1 OR BY RU2, THEN\n   THE\
    \ ARCHITECTURE DOES NOT REQUIRE THAT F1 == F2.  In such cases, we\n   may say\
    \ that Rd is using a different \"label space\" for the labels it\n   distributes\
    \ to Ru1 than for the labels it distributes to Ru2.\n   In general, Rd can only\
    \ tell whether it was Ru1 or Ru2 that put the\n   particular label value L at\
    \ the top of the label stack if the\n   following conditions hold:\n      -  Ru1\
    \ and Ru2 are the only label distribution peers to which Rd\n         distributed\
    \ a binding of label value L, and\n      -  Ru1 and Ru2 are each directly connected\
    \ to Rd via a point-to-\n         point interface.\n   When these conditions hold,\
    \ an LSR may use labels that have \"per\n   interface\" scope, i.e., which are\
    \ only unique per interface.  We may\n   say that the LSR is using a \"per-interface\
    \ label space\".  When these\n   conditions do not hold, the labels must be unique\
    \ over the LSR which\n   has assigned them, and we may say that the LSR is using\
    \ a \"per-\n   platform label space.\"\n   If a particular LSR Rd is attached\
    \ to a particular LSR Ru over two\n   point-to-point interfaces, then Rd may distribute\
    \ to Ru a binding of\n   label L to FEC F1, as well as a binding of label L to\
    \ FEC F2, F1 !=\n   F2, if and only if each binding is valid only for packets\
    \ which Ru\n   sends to Rd over a particular one of the interfaces.  In all other\n\
    \   cases, Rd MUST NOT distribute to Ru bindings of the same label value\n   to\
    \ two different FECs.\n   This prohibition holds even if the bindings are regarded\
    \ as being at\n   different \"levels of hierarchy\".  In MPLS, there is no notion\
    \ of\n   having a different label space for different levels of the hierarchy;\n\
    \   when interpreting a label, the level of the label is irrelevant.\n   The question\
    \ arises as to whether it is possible for an LSR to use\n   multiple per-platform\
    \ label spaces, or to use multiple per-interface\n   label spaces for the same\
    \ interface.  This is not prohibited by the\n   architecture.  However, in such\
    \ cases the LSR must have some means,\n   not specified by the architecture, of\
    \ determining, for a particular\n   incoming label, which label space that label\
    \ belongs to.  For\n   example, [MPLS-SHIM] specifies that a different label space\
    \ is used\n   for unicast packets than for multicast packets, and uses a data\
    \ link\n   layer codepoint to distinguish the two label spaces.\n"
- title: 3.15. Label Switched Path (LSP), LSP Ingress, LSP Egress
  contents:
  - "3.15. Label Switched Path (LSP), LSP Ingress, LSP Egress\n   A \"Label Switched\
    \ Path (LSP) of level m\" for a particular packet P is\n   a sequence of routers,\n\
    \                               <R1, ..., Rn>\n   with the following properties:\n\
    \      1. R1, the \"LSP Ingress\", is an LSR which pushes a label onto P's\n \
    \        label stack, resulting in a label stack of depth m;\n      2. For all\
    \ i, 1<i<n, P has a label stack of depth m when received\n         by LSR Ri;\n\
    \      3. At no time during P's transit from R1 to R[n-1] does its label\n   \
    \      stack ever have a depth of less than m;\n      4. For all i, 1<i<n: Ri\
    \ transmits P to R[i+1] by means of MPLS,\n         i.e., by using the label at\
    \ the top of the label stack (the\n         level m label) as an index into an\
    \ ILM;\n      5. For all i, 1<i<n: if a system S receives and forwards P after\
    \ P\n         is transmitted by Ri but before P is received by R[i+1] (e.g.,\n\
    \         Ri and R[i+1] might be connected via a switched data link\n        \
    \ subnetwork, and S might be one of the data link switches), then\n         S's\
    \ forwarding decision is not based on the level m label, or\n         on the network\
    \ layer header.  This may be because:\n         a) the decision is not based on\
    \ the label stack or the network\n            layer header at all;\n         b)\
    \ the decision is based on a label stack on which additional\n            labels\
    \ have been pushed (i.e., on a level m+k label, where\n            k>0).\n   In\
    \ other words, we can speak of the level m LSP for Packet P as the\n   sequence\
    \ of routers:\n      1. which begins with an LSR (an \"LSP Ingress\") that pushes\
    \ on a\n         level m label,\n      2. all of whose intermediate LSRs make\
    \ their forwarding decision\n         by label Switching on a level m label,\n\
    \      3. which ends (at an \"LSP Egress\") when a forwarding decision is\n  \
    \       made by label Switching on a level m-k label, where k>0, or\n        \
    \ when a forwarding decision is made by \"ordinary\", non-MPLS\n         forwarding\
    \ procedures.\n   A consequence (or perhaps a presupposition) of this is that\
    \ whenever\n   an LSR pushes a label onto an already labeled packet, it needs\
    \ to\n   make sure that the new label corresponds to a FEC whose LSP Egress is\n\
    \   the LSR that assigned the label which is now second in the stack.\n   We will\
    \ call a sequence of LSRs the \"LSP for a particular FEC F\" if\n   it is an LSP\
    \ of level m for a particular packet P when P's level m\n   label is a label corresponding\
    \ to FEC F.\n   Consider the set of nodes which may be LSP ingress nodes for FEC\
    \ F.\n   Then there is an LSP for FEC F which begins with each of those nodes.\n\
    \   If a number of those LSPs have the same LSP egress, then one can\n   consider\
    \ the set of such LSPs to be a tree, whose root is the LSP\n   egress.  (Since\
    \ data travels along this tree towards the root, this\n   may be called a multipoint-to-point\
    \ tree.)  We can thus speak of the\n   \"LSP tree\" for a particular FEC F.\n"
- title: 3.16. Penultimate Hop Popping
  contents:
  - "3.16. Penultimate Hop Popping\n   Note that according to the definitions of section\
    \ 3.15, if <R1, ...,\n   Rn> is a level m LSP for packet P, P may be transmitted\
    \ from R[n-1]\n   to Rn with a label stack of depth m-1.  That is, the label stack\
    \ may\n   be popped at the penultimate LSR of the LSP, rather than at the LSP\n\
    \   Egress.\n   From an architectural perspective, this is perfectly appropriate.\n\
    \   The purpose of the level m label is to get the packet to Rn.  Once\n   R[n-1]\
    \ has decided to send the packet to Rn, the label no longer has\n   any function,\
    \ and need no longer be carried.\n   There is also a practical advantage to doing\
    \ penultimate hop popping.\n   If one does not do this, then when the LSP egress\
    \ receives a packet,\n   it first looks up the top label, and determines as a\
    \ result of that\n   lookup that it is indeed the LSP egress.  Then it must pop\
    \ the stack,\n   and examine what remains of the packet.  If there is another\
    \ label on\n   the stack, the egress will look this up and forward the packet\
    \ based\n   on this lookup.  (In this case, the egress for the packet's level\
    \ m\n   LSP is also an intermediate node for its level m-1 LSP.)  If there is\n\
    \   no other label on the stack, then the packet is forwarded according\n   to\
    \ its network layer destination address.  Note that this would\n   require the\
    \ egress to do TWO lookups, either two label lookups or a\n   label lookup followed\
    \ by an address lookup.\n   If, on the other hand, penultimate hop popping is\
    \ used, then when the\n   penultimate hop looks up the label, it determines:\n\
    \      -  that it is the penultimate hop, and\n      -  who the next hop is.\n\
    \   The penultimate node then pops the stack, and forwards the packet\n   based\
    \ on the information gained by looking up the label that was\n   previously at\
    \ the top of the stack.  When the LSP egress receives the\n   packet, the label\
    \ which is now at the top of the stack will be the\n   label which it needs to\
    \ look up in order to make its own forwarding\n   decision.  Or, if the packet\
    \ was only carrying a single label, the\n   LSP egress will simply see the network\
    \ layer packet, which is just\n   what it needs to see in order to make its forwarding\
    \ decision.\n   This technique allows the egress to do a single lookup, and also\n\
    \   requires only a single lookup by the penultimate node.\n   The creation of\
    \ the forwarding \"fastpath\" in a label switching\n   product may be greatly\
    \ aided if it is known that only a single lookup\n   is ever required:\n     \
    \ -  the code may be simplified if it can assume that only a single\n        \
    \ lookup is ever needed\n      -  the code can be based on a \"time budget\" that\
    \ assumes that only\n         a single lookup is ever needed.\n   In fact, when\
    \ penultimate hop popping is done, the LSP Egress need\n   not even be an LSR.\n\
    \   However, some hardware switching engines may not be able to pop the\n   label\
    \ stack, so this cannot be universally required.  There may also\n   be some situations\
    \ in which penultimate hop popping is not desirable.\n   Therefore the penultimate\
    \ node pops the label stack only if this is\n   specifically requested by the\
    \ egress node, OR if the next node in the\n   LSP does not support MPLS.  (If\
    \ the next node in the LSP does support\n   MPLS, but does not make such a request,\
    \ the penultimate node has no\n   way of knowing that it in fact is the penultimate\
    \ node.)\n   An LSR which is capable of popping the label stack at all MUST do\n\
    \   penultimate hop popping when so requested by its downstream label\n   distribution\
    \ peer.\n   Initial label distribution protocol negotiations MUST allow each LSR\n\
    \   to determine whether its neighboring LSRS are capable of popping the\n   label\
    \ stack.  A LSR MUST NOT request a label distribution peer to pop\n   the label\
    \ stack unless it is capable of doing so.\n   It may be asked whether the egress\
    \ node can always interpret the top\n   label of a received packet properly if\
    \ penultimate hop popping is\n   used.  As long as the uniqueness and scoping\
    \ rules of section 3.14\n   are obeyed, it is always possible to interpret the\
    \ top label of a\n   received packet unambiguously.\n"
- title: 3.17. LSP Next Hop
  contents:
  - "3.17. LSP Next Hop\n   The LSP Next Hop for a particular labeled packet in a\
    \ particular LSR\n   is the LSR which is the next hop, as selected by the NHLFE\
    \ entry used\n   for forwarding that packet.\n   The LSP Next Hop for a particular\
    \ FEC is the next hop as selected by\n   the NHLFE entry indexed by a label which\
    \ corresponds to that FEC.\n   Note that the LSP Next Hop may differ from the\
    \ next hop which would\n   be chosen by the network layer routing algorithm. \
    \ We will use the\n   term \"L3 next hop\" when we refer to the latter.\n"
- title: 3.18. Invalid Incoming Labels
  contents:
  - "3.18. Invalid Incoming Labels\n   What should an LSR do if it receives a labeled\
    \ packet with a\n   particular incoming label, but has no binding for that label?\
    \  It is\n   tempting to think that the labels can just be removed, and the packet\n\
    \   forwarded as an unlabeled IP packet.  However, in some cases, doing\n   so\
    \ could cause a loop.  If the upstream LSR thinks the label is bound\n   to an\
    \ explicit route, and the downstream LSR doesn't think the label\n   is bound\
    \ to anything, and if the hop by hop routing of the unlabeled\n   IP packet brings\
    \ the packet back to the upstream LSR, then a loop is\n   formed.\n   It is also\
    \ possible that the label was intended to represent a route\n   which cannot be\
    \ inferred from the IP header.\n   Therefore, when a labeled packet is received\
    \ with an invalid incoming\n   label, it MUST be discarded, UNLESS it is determined\
    \ by some means\n   (not within the scope of the current document) that forwarding\
    \ it\n   unlabeled cannot cause any harm.\n"
- title: '3.19. LSP Control: Ordered versus Independent'
  contents:
  - "3.19. LSP Control: Ordered versus Independent\n   Some FECs correspond to address\
    \ prefixes which are distributed via a\n   dynamic routing algorithm.  The setup\
    \ of the LSPs for these FECs can\n   be done in one of two ways: Independent LSP\
    \ Control or Ordered LSP\n   Control.\n   In Independent LSP Control, each LSR,\
    \ upon noting that it recognizes\n   a particular FEC, makes an independent decision\
    \ to bind a label to\n   that FEC and to distribute that binding to its label\
    \ distribution\n   peers.  This corresponds to the way that conventional IP datagram\n\
    \   routing works; each node makes an independent decision as to how to\n   treat\
    \ each packet, and relies on the routing algorithm to converge\n   rapidly so\
    \ as to ensure that each datagram is correctly delivered.\n   In Ordered LSP Control,\
    \ an LSR only binds a label to a particular FEC\n   if it is the egress LSR for\
    \ that FEC, or if it has already received a\n   label binding for that FEC from\
    \ its next hop for that FEC.\n   If one wants to ensure that traffic in a particular\
    \ FEC follows a\n   path with some specified set of properties (e.g., that the\
    \ traffic\n   does not traverse any node twice, that a specified amount of\n \
    \  resources are available to the traffic, that the traffic follows an\n   explicitly\
    \ specified path, etc.)  ordered control must be used.  With\n   independent control,\
    \ some LSRs may begin label switching a traffic in\n   the FEC before the LSP\
    \ is completely set up, and thus some traffic in\n   the FEC may follow a path\
    \ which does not have the specified set of\n   properties.  Ordered control also\
    \ needs to be used if the recognition\n   of the FEC is a consequence of the setting\
    \ up of the corresponding\n   LSP.\n   Ordered LSP setup may be initiated either\
    \ by the ingress or the\n   egress.\n   Ordered control and independent control\
    \ are fully interoperable.\n   However, unless all LSRs in an LSP are using ordered\
    \ control, the\n   overall effect on network behavior is largely that of independent\n\
    \   control, since one cannot be sure that an LSP is not used until it is\n  \
    \ fully set up.\n   This architecture allows the choice between independent control\
    \ and\n   ordered control to be a local matter.  Since the two methods\n   interwork,\
    \ a given LSR need support only one or the other.  Generally\n   speaking, the\
    \ choice of independent versus ordered control does not\n   appear to have any\
    \ effect on the label distribution mechanisms which\n   need to be defined.\n"
- title: 3.20. Aggregation
  contents:
  - "3.20. Aggregation\n   One way of partitioning traffic into FECs is to create\
    \ a separate FEC\n   for each address prefix which appears in the routing table.\
    \  However,\n   within a particular MPLS domain, this may result in a set of FECs\n\
    \   such that all traffic in all those FECs follows the same route.  For\n   example,\
    \ a set of distinct address prefixes might all have the same\n   egress node,\
    \ and label swapping might be used only to get the the\n   traffic to the egress\
    \ node.  In this case, within the MPLS domain,\n   the union of those FECs is\
    \ itself a FEC.  This creates a choice:\n   should a distinct label be bound to\
    \ each component FEC, or should a\n   single label be bound to the union, and\
    \ that label applied to all\n   traffic in the union?\n   The procedure of binding\
    \ a single label to a union of FECs which is\n   itself a FEC (within some domain),\
    \ and of applying that label to all\n   traffic in the union, is known as \"aggregation\"\
    .  The MPLS\n   architecture allows aggregation.  Aggregation may reduce the number\n\
    \   of labels which are needed to handle a particular set of packets, and\n  \
    \ may also reduce the amount of label distribution control traffic\n   needed.\n\
    \   Given a set of FECs which are \"aggregatable\" into a single FEC, it is\n\
    \   possible to (a) aggregate them into a single FEC, (b) aggregate them\n   into\
    \ a set of FECs, or (c) not aggregate them at all.  Thus we can\n   speak of the\
    \ \"granularity\" of aggregation, with (a) being the\n   \"coarsest granularity\"\
    , and (c) being the \"finest granularity\".\n   When order control is used, each\
    \ LSR should adopt, for a given set of\n   FECs, the granularity used by its next\
    \ hop for those FECs.\n   When independent control is used, it is possible that\
    \ there will be\n   two adjacent LSRs, Ru and Rd, which aggregate some set of\
    \ FECs\n   differently.\n   If Ru has finer granularity than Rd, this does not\
    \ cause a problem.\n   Ru distributes more labels for that set of FECs than Rd\
    \ does.  This\n   means that when Ru needs to forward labeled packets in those\
    \ FECs to\n   Rd, it may need to map n labels into m labels, where n > m.  As\
    \ an\n   option, Ru may withdraw the set of n labels that it has distributed,\n\
    \   and then distribute a set of m labels, corresponding to Rd's level of\n  \
    \ granularity.  This is not necessary to ensure correct operation, but\n   it\
    \ does result in a reduction of the number of labels distributed by\n   Ru, and\
    \ Ru is not gaining any particular advantage by distributing\n   the larger number\
    \ of labels.  The decision whether to do this or not\n   is a local matter.\n\
    \   If Ru has coarser granularity than Rd (i.e., Rd has distributed n\n   labels\
    \ for the set of FECs, while Ru has distributed m, where n > m),\n   it has two\
    \ choices:\n      -  It may adopt Rd's finer level of granularity.  This would\n\
    \         require it to withdraw the m labels it has distributed, and\n      \
    \   distribute n labels.  This is the preferred option.\n      -  It may simply\
    \ map its m labels into a subset of Rd's n labels,\n         if it can determine\
    \ that this will produce the same routing.\n         For example, suppose that\
    \ Ru applies a single label to all\n         traffic that needs to pass through\
    \ a certain egress LSR,\n         whereas Rd binds a number of different labels\
    \ to such traffic,\n         depending on the individual destination addresses\
    \ of the\n         packets.  If Ru knows the address of the egress router, and\
    \ if\n         Rd has bound a label to the FEC which is identified by that\n \
    \        address, then Ru can simply apply that label.\n   In any event, every\
    \ LSR needs to know (by configuration) what\n   granularity to use for labels\
    \ that it assigns.  Where ordered control\n   is used, this requires each node\
    \ to know the granularity only for\n   FECs which leave the MPLS network at that\
    \ node.  For independent\n   control, best results may be obtained by ensuring\
    \ that all LSRs are\n   consistently configured to know the granularity for each\
    \ FEC.\n   However, in many cases this may be done by using a single level of\n\
    \   granularity which applies to all FECs (such as \"one label per IP\n   prefix\
    \ in the forwarding table\", or \"one label per egress node\").\n"
- title: 3.21. Route Selection
  contents:
  - "3.21. Route Selection\n   Route selection refers to the method used for selecting\
    \ the LSP for a\n   particular FEC.  The proposed MPLS protocol architecture supports\
    \ two\n   options for Route Selection: (1) hop by hop routing, and (2) explicit\n\
    \   routing.\n   Hop by hop routing allows each node to independently choose the\
    \ next\n   hop for each FEC.  This is the usual mode today in existing IP\n  \
    \ networks.  A \"hop by hop routed LSP\" is an LSP whose route is\n   selected\
    \ using hop by hop routing.\n   In an explicitly routed LSP, each LSR does not\
    \ independently choose\n   the next hop; rather, a single LSR, generally the LSP\
    \ ingress or the\n   LSP egress, specifies several (or all) of the LSRs in the\
    \ LSP.  If a\n   single LSR specifies the entire LSP, the LSP is \"strictly\"\
    \ explicitly\n   routed.  If a single LSR specifies only some of the LSP, the\
    \ LSP is\n   \"loosely\" explicitly routed.\n   The sequence of LSRs followed\
    \ by an explicitly routed LSP may be\n   chosen by configuration, or may be selected\
    \ dynamically by a single\n   node (for example, the egress node may make use\
    \ of the topological\n   information learned from a link state database in order\
    \ to compute\n   the entire path for the tree ending at that egress node).\n \
    \  Explicit routing may be useful for a number of purposes, such as\n   policy\
    \ routing or traffic engineering.  In MPLS, the explicit route\n   needs to be\
    \ specified at the time that labels are assigned, but the\n   explicit route does\
    \ not have to be specified with each IP packet.\n   This makes MPLS explicit routing\
    \ much more efficient than the\n   alternative of IP source routing.\n   The procedures\
    \ for making use of explicit routes, either strict or\n   loose, are beyond the\
    \ scope of this document.\n"
- title: 3.22. Lack of Outgoing Label
  contents:
  - "3.22. Lack of Outgoing Label\n   When a labeled packet is traveling along an\
    \ LSP, it may occasionally\n   happen that it reaches an LSR at which the ILM\
    \ does not map the\n   packet's incoming label into an NHLFE, even though the\
    \ incoming label\n   is itself valid.  This can happen due to transient conditions,\
    \ or due\n   to an error at the LSR which should be the packet's next hop.\n \
    \  It is tempting in such cases to strip off the label stack and attempt\n   to\
    \ forward the packet further via conventional forwarding, based on\n   its network\
    \ layer header.  However, in general this is not a safe\n   procedure:\n     \
    \ -  If the packet has been following an explicitly routed LSP, this\n       \
    \  could result in a loop.\n      -  The packet's network header may not contain\
    \ enough information\n         to enable this particular LSR to forward it correctly.\n\
    \   Unless it can be determined (through some means outside the scope of\n   this\
    \ document) that neither of these situations obtains, the only\n   safe procedure\
    \ is to discard the packet.\n"
- title: 3.23. Time-to-Live (TTL)
  contents:
  - "3.23. Time-to-Live (TTL)\n   In conventional IP forwarding, each packet carries\
    \ a \"Time To Live\"\n   (TTL) value in its header.  Whenever a packet passes\
    \ through a\n   router, its TTL gets decremented by 1; if the TTL reaches 0 before\n\
    \   the packet has reached its destination, the packet gets discarded.\n   This\
    \ provides some level of protection against forwarding loops that\n   may exist\
    \ due to misconfigurations, or due to failure or slow\n   convergence of the routing\
    \ algorithm.  TTL is sometimes used for\n   other functions as well, such as multicast\
    \ scoping, and supporting\n   the \"traceroute\" command.  This implies that there\
    \ are two TTL-\n   related issues that MPLS needs to deal with: (i) TTL as a way\
    \ to\n   suppress loops; (ii) TTL as a way to accomplish other functions, such\n\
    \   as limiting the scope of a packet.\n   When a packet travels along an LSP,\
    \ it SHOULD emerge with the same\n   TTL value that it would have had if it had\
    \ traversed the same\n   sequence of routers without having been label switched.\
    \  If the\n   packet travels along a hierarchy of LSPs, the total number of LSR-\n\
    \   hops traversed SHOULD be reflected in its TTL value when it emerges\n   from\
    \ the hierarchy of LSPs.\n   The way that TTL is handled may vary depending upon\
    \ whether the MPLS\n   label values are carried in an MPLS-specific \"shim\" header\
    \ [MPLS-\n   SHIM], or if the MPLS labels are carried in an L2 header, such as\
    \ an\n   ATM header [MPLS-ATM] or a frame relay header [MPLS-FRMRLY].\n   If the\
    \ label values are encoded in a \"shim\" that sits between the\n   data link and\
    \ network layer headers, then this shim MUST have a TTL\n   field that SHOULD\
    \ be initially loaded from the network layer header\n   TTL field, SHOULD be decremented\
    \ at each LSR-hop, and SHOULD be\n   copied into the network layer header TTL\
    \ field when the packet\n   emerges from its LSP.\n   If the label values are\
    \ encoded in a data link layer header (e.g.,\n   the VPI/VCI field in ATM's AAL5\
    \ header), and the labeled packets are\n   forwarded by an L2 switch (e.g., an\
    \ ATM switch), and the data link\n   layer (like ATM) does not itself have a TTL\
    \ field, then it will not\n   be possible to decrement a packet's TTL at each\
    \ LSR-hop.  An LSP\n   segment which consists of a sequence of LSRs that cannot\
    \ decrement a\n   packet's TTL will be called a \"non-TTL LSP segment\".\n   When\
    \ a packet emerges from a non-TTL LSP segment, it SHOULD however\n   be given\
    \ a TTL that reflects the number of LSR-hops it traversed.  In\n   the unicast\
    \ case, this can be achieved by propagating a meaningful\n   LSP length to ingress\
    \ nodes, enabling the ingress to decrement the\n   TTL value before forwarding\
    \ packets into a non-TTL LSP segment.\n   Sometimes it can be determined, upon\
    \ ingress to a non-TTL LSP\n   segment, that a particular packet's TTL will expire\
    \ before the packet\n   reaches the egress of that non-TTL LSP segment.  In this\
    \ case, the\n   LSR at the ingress to the non-TTL LSP segment must not label switch\n\
    \   the packet.  This means that special procedures must be developed to\n   support\
    \ traceroute functionality, for example, traceroute packets may\n   be forwarded\
    \ using conventional hop by hop forwarding.\n"
- title: 3.24. Loop Control
  contents:
  - "3.24. Loop Control\n   On a non-TTL LSP segment, by definition, TTL cannot be\
    \ used to\n   protect against forwarding loops.  The importance of loop control\
    \ may\n   depend on the particular hardware being used to provide the LSR\n  \
    \ functions along the non-TTL LSP segment.\n   Suppose, for instance, that ATM\
    \ switching hardware is being used to\n   provide MPLS switching functions, with\
    \ the label being carried in the\n   VPI/VCI field.  Since ATM switching hardware\
    \ cannot decrement TTL,\n   there is no protection against loops.  If the ATM\
    \ hardware is capable\n   of providing fair access to the buffer pool for incoming\
    \ cells\n   carrying different VPI/VCI values, this looping may not have any\n\
    \   deleterious effect on other traffic.  If the ATM hardware cannot\n   provide\
    \ fair buffer access of this sort, however, then even transient\n   loops may\
    \ cause severe degradation of the LSR's total performance.\n   Even if fair buffer\
    \ access can be provided, it is still worthwhile to\n   have some means of detecting\
    \ loops that last \"longer than possible\".\n   In addition, even where TTL and/or\
    \ per-VC fair queuing provides a\n   means for surviving loops, it still may be\
    \ desirable where practical\n   to avoid setting up LSPs which loop.  All LSRs\
    \ that may attach to\n   non-TTL LSP segments will therefore be required to support\
    \ a common\n   technique for loop detection; however, use of the loop detection\n\
    \   technique is optional.  The loop detection technique is specified in\n   [MPLS-ATM]\
    \ and [MPLS-LDP].\n"
- title: 3.25. Label Encodings
  contents:
  - "3.25. Label Encodings\n   In order to transmit a label stack along with the packet\
    \ whose label\n   stack it is, it is necessary to define a concrete encoding of\
    \ the\n   label stack.  The architecture supports several different encoding\n\
    \   techniques; the choice of encoding technique depends on the\n   particular\
    \ kind of device being used to forward labeled packets.\n"
- title: 3.25.1. MPLS-specific Hardware and/or Software
  contents:
  - "3.25.1. MPLS-specific Hardware and/or Software\n   If one is using MPLS-specific\
    \ hardware and/or software to forward\n   labeled packets, the most obvious way\
    \ to encode the label stack is to\n   define a new protocol to be used as a \"\
    shim\" between the data link\n   layer and network layer headers.  This shim would\
    \ really be just an\n   encapsulation of the network layer packet; it would be\
    \ \"protocol-\n   independent\" such that it could be used to encapsulate any\
    \ network\n   layer.  Hence we will refer to it as the \"generic MPLS\n   encapsulation\"\
    .\n   The generic MPLS encapsulation would in turn be encapsulated in a\n   data\
    \ link layer protocol.\n   The MPLS generic encapsulation is specified in [MPLS-SHIM].\n"
- title: 3.25.2. ATM Switches as LSRs
  contents:
  - "3.25.2. ATM Switches as LSRs\n   It will be noted that MPLS forwarding procedures\
    \ are similar to those\n   of legacy \"label swapping\" switches such as ATM switches.\
    \  ATM\n   switches use the input port and the incoming VPI/VCI value as the\n\
    \   index into a \"cross-connect\" table, from which they obtain an output\n \
    \  port and an outgoing VPI/VCI value.  Therefore if one or more labels\n   can\
    \ be encoded directly into the fields which are accessed by these\n   legacy switches,\
    \ then the legacy switches can, with suitable software\n   upgrades, be used as\
    \ LSRs.  We will refer to such devices as \"ATM-\n   LSRs\".\n   There are three\
    \ obvious ways to encode labels in the ATM cell header\n   (presuming the use\
    \ of AAL5):\n      1. SVC Encoding\n         Use the VPI/VCI field to encode the\
    \ label which is at the top\n         of the label stack.  This technique can\
    \ be used in any network.\n         With this encoding technique, each LSP is\
    \ realized as an ATM\n         SVC, and the label distribution protocol becomes\
    \ the ATM\n         \"signaling\" protocol.  With this encoding technique, the\
    \ ATM-\n         LSRs cannot perform \"push\" or \"pop\" operations on the label\n\
    \         stack.\n      2. SVP Encoding\n         Use the VPI field to encode\
    \ the label which is at the top of\n         the label stack, and the VCI field\
    \ to encode the second label\n         on the stack, if one is present.  This\
    \ technique some\n         advantages over the previous one, in that it permits\
    \ the use of\n         ATM \"VP-switching\".  That is, the LSPs are realized as\
    \ ATM\n         SVPs, with the label distribution protocol serving as the ATM\n\
    \         signaling protocol.\n         However, this technique cannot always\
    \ be used.  If the network\n         includes an ATM Virtual Path through a non-MPLS\
    \ ATM network,\n         then the VPI field is not necessarily available for use\
    \ by\n         MPLS.\n         When this encoding technique is used, the ATM-LSR\
    \ at the egress\n         of the VP effectively does a \"pop\" operation.\n  \
    \    3. SVP Multipoint Encoding\n         Use the VPI field to encode the label\
    \ which is at the top of\n         the label stack, use part of the VCI field\
    \ to encode the second\n         label on the stack, if one is present, and use\
    \ the remainder of\n         the VCI field to identify the LSP ingress.  If this\
    \ technique\n         is used, conventional ATM VP-switching capabilities can\
    \ be used\n         to provide multipoint-to-point VPs.  Cells from different\n\
    \         packets will then carry different VCI values.  As we shall see\n   \
    \      in section 3.26, this enables us to do label merging, without\n       \
    \  running into any cell interleaving problems, on ATM switches\n         which\
    \ can provide multipoint-to-point VPs, but which do not\n         have the VC\
    \ merge capability.\n         This technique depends on the existence of a capability\
    \ for\n         assigning 16-bit VCI values to each ATM switch such that no\n\
    \         single VCI value is assigned to two different switches.  (If an\n  \
    \       adequate number of such values could be assigned to each\n         switch,\
    \ it would be possible to also treat the VCI value as the\n         second label\
    \ in the stack.)\n   If there are more labels on the stack than can be encoded\
    \ in the ATM\n   header, the ATM encodings must be combined with the generic\n\
    \   encapsulation.\n"
- title: 3.25.3. Interoperability among Encoding Techniques
  contents:
  - "3.25.3. Interoperability among Encoding Techniques\n   If <R1, R2, R3> is a segment\
    \ of a LSP, it is possible that R1 will\n   use one encoding of the label stack\
    \ when transmitting packet P to R2,\n   but R2 will use a different encoding when\
    \ transmitting a packet P to\n   R3.  In general, the MPLS architecture supports\
    \ LSPs with different\n   label stack encodings used on different hops.  Therefore,\
    \ when we\n   discuss the procedures for processing a labeled packet, we speak\
    \ in\n   abstract terms of operating on the packet's label stack.  When a\n  \
    \ labeled packet is received, the LSR must decode it to determine the\n   current\
    \ value of the label stack, then must operate on the label\n   stack to determine\
    \ the new value of the stack, and then encode the\n   new value appropriately\
    \ before transmitting the labeled packet to its\n   next hop.\n   Unfortunately,\
    \ ATM switches have no capability for translating from\n   one encoding technique\
    \ to another.  The MPLS architecture therefore\n   requires that whenever it is\
    \ possible for two ATM switches to be\n   successive LSRs along a level m LSP\
    \ for some packet, that those two\n   ATM switches use the same encoding technique.\n\
    \   Naturally there will be MPLS networks which contain a combination of\n   ATM\
    \ switches operating as LSRs, and other LSRs which operate using an\n   MPLS shim\
    \ header.  In such networks there may be some LSRs which have\n   ATM interfaces\
    \ as well as \"MPLS Shim\" interfaces.  This is one\n   example of an LSR with\
    \ different label stack encodings on different\n   hops.  Such an LSR may swap\
    \ off an ATM encoded label stack on an\n   incoming interface and replace it with\
    \ an MPLS shim header encoded\n   label stack on the outgoing interface.\n"
- title: 3.26. Label Merging
  contents:
  - "3.26. Label Merging\n   Suppose that an LSR has bound multiple incoming labels\
    \ to a\n   particular FEC.  When forwarding packets in that FEC, one would like\n\
    \   to have a single outgoing label which is applied to all such packets.\n  \
    \ The fact that two different packets in the FEC arrived with different\n   incoming\
    \ labels is irrelevant; one would like to forward them with\n   the same outgoing\
    \ label.  The capability to do so is known as \"label\n   merging\".\n   Let us\
    \ say that an LSR is capable of label merging if it can receive\n   two packets\
    \ from different incoming interfaces, and/or with different\n   labels, and send\
    \ both packets out the same outgoing interface with\n   the same label.  Once\
    \ the packets are transmitted, the information\n   that they arrived from different\
    \ interfaces and/or with different\n   incoming labels is lost.\n   Let us say\
    \ that an LSR is not capable of label merging if, for any\n   two packets which\
    \ arrive from different interfaces, or with different\n   labels, the packets\
    \ must either be transmitted out different\n   interfaces, or must have different\
    \ labels.  ATM-LSRs using the SVC or\n   SVP Encodings cannot perform label merging.\
    \  This is discussed in\n   more detail in the next section.\n   If a particular\
    \ LSR cannot perform label merging, then if two packets\n   in the same FEC arrive\
    \ with different incoming labels, they must be\n   forwarded with different outgoing\
    \ labels.  With label merging, the\n   number of outgoing labels per FEC need\
    \ only be 1; without label\n   merging, the number of outgoing labels per FEC\
    \ could be as large as\n   the number of nodes in the network.\n   With label\
    \ merging, the number of incoming labels per FEC that a\n   particular LSR needs\
    \ is never be larger than the number of label\n   distribution adjacencies.  Without\
    \ label merging, the number of\n   incoming labels per FEC that a particular LSR\
    \ needs is as large as\n   the number of upstream nodes which forward traffic\
    \ in the FEC to the\n   LSR in question.  In fact, it is difficult for an LSR\
    \ to even\n   determine how many such incoming labels it must support for a\n\
    \   particular FEC.\n   The MPLS architecture accommodates both merging and non-merging\
    \ LSRs,\n   but allows for the fact that there may be LSRs which do not support\n\
    \   label merging.  This leads to the issue of ensuring correct\n   interoperation\
    \ between merging LSRs and non-merging LSRs.  The issue\n   is somewhat different\
    \ in the case of datagram media versus the case\n   of ATM.  The different media\
    \ types will therefore be discussed\n   separately.\n"
- title: 3.26.1. Non-merging LSRs
  contents:
  - "3.26.1. Non-merging LSRs\n   The MPLS forwarding procedures is very similar to\
    \ the forwarding\n   procedures used by such technologies as ATM and Frame Relay.\
    \  That\n   is, a unit of data arrives, a label (VPI/VCI or DLCI) is looked up\
    \ in\n   a \"cross-connect table\", on the basis of that lookup an output port\n\
    \   is chosen, and the label value is rewritten.  In fact, it is possible\n  \
    \ to use such technologies for MPLS forwarding; a label distribution\n   protocol\
    \ can be used as the \"signalling protocol\" for setting up the\n   cross-connect\
    \ tables.\n   Unfortunately, these technologies do not necessarily support the\n\
    \   label merging capability.  In ATM, if one attempts to perform label\n   merging,\
    \ the result may be the interleaving of cells from various\n   packets.  If cells\
    \ from different packets get interleaved, it is\n   impossible to reassemble the\
    \ packets.  Some Frame Relay switches use\n   cell switching on their backplanes.\
    \  These switches may also be\n   incapable of supporting label merging, for the\
    \ same reason -- cells\n   of different packets may get interleaved, and there\
    \ is then no way to\n   reassemble the packets.\n   We propose to support two\
    \ solutions to this problem.  First, MPLS\n   will contain procedures which allow\
    \ the use of non-merging LSRs.\n   Second, MPLS will support procedures which\
    \ allow certain ATM switches\n   to function as merging LSRs.\n   Since MPLS supports\
    \ both merging and non-merging LSRs, MPLS also\n   contains procedures to ensure\
    \ correct interoperation between them.\n"
- title: 3.26.2. Labels for Merging and Non-Merging LSRs
  contents:
  - "3.26.2. Labels for Merging and Non-Merging LSRs\n   An upstream LSR which supports\
    \ label merging needs to be sent only\n   one label per FEC.  An upstream neighbor\
    \ which does not support label\n   merging needs to be sent multiple labels per\
    \ FEC.  However, there is\n   no way of knowing a priori how many labels it needs.\
    \  This will\n   depend on how many LSRs are upstream of it with respect to the\
    \ FEC in\n   question.\n   In the MPLS architecture, if a particular upstream\
    \ neighbor does not\n   support label merging, it is not sent any labels for a\
    \ particular FEC\n   unless it explicitly asks for a label for that FEC.  The\
    \ upstream\n   neighbor may make multiple such requests, and is given a new label\n\
    \   each time.  When a downstream neighbor receives such a request from\n   upstream,\
    \ and the downstream neighbor does not itself support label\n   merging, then\
    \ it must in turn ask its downstream neighbor for another\n   label for the FEC\
    \ in question.\n   It is possible that there may be some nodes which support label\n\
    \   merging, but can only merge a limited number of incoming labels into\n   a\
    \ single outgoing label.  Suppose for example that due to some\n   hardware limitation\
    \ a node is capable of merging four incoming labels\n   into a single outgoing\
    \ label.  Suppose however, that this particular\n   node has six incoming labels\
    \ arriving at it for a particular FEC.  In\n   this case, this node may merge\
    \ these into two outgoing labels.\n   Whether label merging is applicable to explicitly\
    \ routed LSPs is for\n   further study.\n"
- title: 3.26.3. Merge over ATM
  contents:
  - '3.26.3. Merge over ATM

    '
- title: 3.26.3.1. Methods of Eliminating Cell Interleave
  contents:
  - "3.26.3.1. Methods of Eliminating Cell Interleave\n   There are several methods\
    \ that can be used to eliminate the cell\n   interleaving problem in ATM, thereby\
    \ allowing ATM switches to support\n   stream merge:\n      1. VP merge, using\
    \ the SVP Multipoint Encoding\n         When VP merge is used, multiple virtual\
    \ paths are merged into a\n         virtual path, but packets from different sources\
    \ are\n         distinguished by using different VCIs within the VP.\n      2.\
    \ VC merge\n         When VC merge is used, switches are required to buffer cells\n\
    \         from one packet until the entire packet is received (this may\n    \
    \     be determined by looking for the AAL5 end of frame indicator).\n   VP merge\
    \ has the advantage that it is compatible with a higher\n   percentage of existing\
    \ ATM switch implementations.  This makes it\n   more likely that VP merge can\
    \ be used in existing networks.  Unlike\n   VC merge, VP merge does not incur\
    \ any delays at the merge points and\n   also does not impose any buffer requirements.\
    \  However, it has the\n   disadvantage that it requires coordination of the VCI\
    \ space within\n   each VP.  There are a number of ways that this can be accomplished.\n\
    \   Selection of one or more methods is for further study.\n   This tradeoff between\
    \ compatibility with existing equipment versus\n   protocol complexity and scalability\
    \ implies that it is desirable for\n   the MPLS protocol to support both VP merge\
    \ and VC merge.  In order to\n   do so each ATM switch participating in MPLS needs\
    \ to know whether its\n   immediate ATM neighbors perform VP merge, VC merge,\
    \ or no merge.\n"
- title: '3.26.3.2. Interoperation: VC Merge, VP Merge, and Non-Merge'
  contents:
  - "3.26.3.2. Interoperation: VC Merge, VP Merge, and Non-Merge\n   The interoperation\
    \ of the various forms of merging over ATM is most\n   easily described by first\
    \ describing the interoperation of VC merge\n   with non-merge.\n   In the case\
    \ where VC merge and non-merge nodes are interconnected the\n   forwarding of\
    \ cells is based in all cases on a VC (i.e., the\n   concatenation of the VPI\
    \ and VCI).  For each node, if an upstream\n   neighbor is doing VC merge then\
    \ that upstream neighbor requires only\n   a single VPI/VCI for a particular stream\
    \ (this is analogous to the\n   requirement for a single label in the case of\
    \ operation over frame\n   media).  If the upstream neighbor is not doing merge,\
    \ then the\n   neighbor will require a single VPI/VCI per stream for itself, plus\n\
    \   enough VPI/VCIs to pass to its upstream neighbors.  The number\n   required\
    \ will be determined by allowing the upstream nodes to request\n   additional\
    \ VPI/VCIs from their downstream neighbors (this is again\n   analogous to the\
    \ method used with frame merge).\n   A similar method is possible to support nodes\
    \ which perform VP merge.\n   In this case the VP merge node, rather than requesting\
    \ a single\n   VPI/VCI or a number of VPI/VCIs from its downstream neighbor, instead\n\
    \   may request a single VP (identified by a VPI) but several VCIs within\n  \
    \ the VP.  Furthermore, suppose that a non-merge node is downstream\n   from two\
    \ different VP merge nodes.  This node may need to request one\n   VPI/VCI (for\
    \ traffic originating from itself) plus two VPs (one for\n   each upstream node),\
    \ each associated with a specified set of VCIs (as\n   requested from the upstream\
    \ node).\n   In order to support all of VP merge, VC merge, and non-merge, it\
    \ is\n   therefore necessary to allow upstream nodes to request a combination\n\
    \   of zero or more VC identifiers (consisting of a VPI/VCI), plus zero\n   or\
    \ more VPs (identified by VPIs) each containing a specified number\n   of VCs\
    \ (identified by a set of VCIs which are significant within a\n   VP).  VP merge\
    \ nodes would therefore request one VP, with a contained\n   VCI for traffic that\
    \ it originates (if appropriate) plus a VCI for\n   each VC requested from above\
    \ (regardless of whether or not the VC is\n   part of a containing VP).  VC merge\
    \ node would request only a single\n   VPI/VCI (since they can merge all upstream\
    \ traffic into a single VC).\n   Non-merge nodes would pass on any requests that\
    \ they get from above,\n   plus request a VPI/VCI for traffic that they originate\
    \ (if\n   appropriate).\n"
- title: 3.27. Tunnels and Hierarchy
  contents:
  - "3.27. Tunnels and Hierarchy\n   Sometimes a router Ru takes explicit action to\
    \ cause a particular\n   packet to be delivered to another router Rd, even though\
    \ Ru and Rd\n   are not consecutive routers on the Hop-by-hop path for that packet,\n\
    \   and Rd is not the packet's ultimate destination.  For example, this\n   may\
    \ be done by encapsulating the packet inside a network layer packet\n   whose\
    \ destination address is the address of Rd itself.  This creates\n   a \"tunnel\"\
    \ from Ru to Rd.  We refer to any packet so handled as a\n   \"Tunneled Packet\"\
    .\n"
- title: 3.27.1. Hop-by-Hop Routed Tunnel
  contents:
  - "3.27.1. Hop-by-Hop Routed Tunnel\n   If a Tunneled Packet follows the Hop-by-hop\
    \ path from Ru to Rd, we\n   say that it is in an \"Hop-by-Hop Routed Tunnel\"\
    \ whose \"transmit\n   endpoint\" is Ru and whose \"receive endpoint\" is Rd.\n"
- title: 3.27.2. Explicitly Routed Tunnel
  contents:
  - "3.27.2. Explicitly Routed Tunnel\n   If a Tunneled Packet travels from Ru to\
    \ Rd over a path other than the\n   Hop-by-hop path, we say that it is in an \"\
    Explicitly Routed Tunnel\"\n   whose \"transmit endpoint\" is Ru and whose \"\
    receive endpoint\" is Rd.\n   For example, we might send a packet through an Explicitly\
    \ Routed\n   Tunnel by encapsulating it in a packet which is source routed.\n"
- title: 3.27.3. LSP Tunnels
  contents:
  - "3.27.3. LSP Tunnels\n   It is possible to implement a tunnel as a LSP, and use\
    \ label\n   switching rather than network layer encapsulation to cause the packet\n\
    \   to travel through the tunnel.  The tunnel would be a LSP <R1, ...,\n   Rn>,\
    \ where R1 is the transmit endpoint of the tunnel, and Rn is the\n   receive endpoint\
    \ of the tunnel.  This is called a \"LSP Tunnel\".\n   The set of packets which\
    \ are to be sent though the LSP tunnel\n   constitutes a FEC, and each LSR in\
    \ the tunnel must assign a label to\n   that FEC (i.e., must assign a label to\
    \ the tunnel).  The criteria for\n   assigning a particular packet to an LSP tunnel\
    \ is a local matter at\n   the tunnel's transmit endpoint.  To put a packet into\
    \ an LSP tunnel,\n   the transmit endpoint pushes a label for the tunnel onto\
    \ the label\n   stack and sends the labeled packet to the next hop in the tunnel.\n\
    \   If it is not necessary for the tunnel's receive endpoint to be able\n   to\
    \ determine which packets it receives through the tunnel, as\n   discussed earlier,\
    \ the label stack may be popped at the penultimate\n   LSR in the tunnel.\n  \
    \ A \"Hop-by-Hop Routed LSP Tunnel\" is a Tunnel that is implemented as\n   an\
    \ hop-by-hop routed LSP between the transmit endpoint and the\n   receive endpoint.\n\
    \   An \"Explicitly Routed LSP Tunnel\" is a LSP Tunnel that is also an\n   Explicitly\
    \ Routed LSP.\n"
- title: '3.27.4. Hierarchy: LSP Tunnels within LSPs'
  contents:
  - "3.27.4. Hierarchy: LSP Tunnels within LSPs\n   Consider a LSP <R1, R2, R3, R4>.\
    \  Let us suppose that R1 receives\n   unlabeled packet P, and pushes on its label\
    \ stack the label to cause\n   it to follow this path, and that this is in fact\
    \ the Hop-by-hop path.\n   However, let us further suppose that R2 and R3 are\
    \ not directly\n   connected, but are \"neighbors\" by virtue of being the endpoints\
    \ of an\n   LSP tunnel.  So the actual sequence of LSRs traversed by P is <R1,\n\
    \   R2, R21, R22, R23, R3, R4>.\n   When P travels from R1 to R2, it will have\
    \ a label stack of depth 1.\n   R2, switching on the label, determines that P\
    \ must enter the tunnel.\n   R2 first replaces the Incoming label with a label\
    \ that is meaningful\n   to R3.  Then it pushes on a new label.  This level 2\
    \ label has a\n   value which is meaningful to R21.  Switching is done on the\
    \ level 2\n   label by R21, R22, R23.  R23, which is the penultimate hop in the\n\
    \   R2-R3 tunnel, pops the label stack before forwarding the packet to\n   R3.\
    \  When R3 sees packet P, P has only a level 1 label, having now\n   exited the\
    \ tunnel.  Since R3 is the penultimate hop in P's level 1\n   LSP, it pops the\
    \ label stack, and R4 receives P unlabeled.\n   The label stack mechanism allows\
    \ LSP tunneling to nest to any depth.\n"
- title: 3.27.5. Label Distribution Peering and Hierarchy
  contents:
  - "3.27.5. Label Distribution Peering and Hierarchy\n   Suppose that packet P travels\
    \ along a Level 1 LSP <R1, R2, R3, R4>,\n   and when going from R2 to R3 travels\
    \ along a Level 2 LSP <R2, R21,\n   R22, R3>.  From the perspective of the Level\
    \ 2 LSP, R2's label\n   distribution peer is R21.  From the perspective of the\
    \ Level 1 LSP,\n   R2's label distribution peers are R1 and R3.  One can have\
    \ label\n   distribution peers at each layer of hierarchy.  We will see in\n \
    \  sections 4.6 and 4.7 some ways to make use of this hierarchy.  Note\n   that\
    \ in this example, R2 and R21 must be IGP neighbors, but R2 and R3\n   need not\
    \ be.\n   When two LSRs are IGP neighbors, we will refer to them as \"local\n\
    \   label distribution peers\".  When two LSRs may be label distribution\n   peers,\
    \ but are not IGP neighbors, we will refer to them as \"remote\n   label distribution\
    \ peers\".  In the above example, R2 and R21 are\n   local label distribution\
    \ peers, but R2 and R3 are remote label\n   distribution peers.\n   The MPLS architecture\
    \ supports two ways to distribute labels at\n   different layers of the hierarchy:\
    \ Explicit Peering and Implicit\n   Peering.\n   One performs label distribution\
    \ with one's local label distribution\n   peer by sending label distribution protocol\
    \ messages which are\n   addressed to the peer.  One can perform label distribution\
    \ with one's\n   remote label distribution peers in one of two ways:\n      1.\
    \ Explicit Peering\n         In explicit peering, one distributes labels to a\
    \ peer by\n         sending label distribution protocol messages which are\n \
    \        addressed to the peer, exactly as one would do for local label\n    \
    \     distribution peers.  This technique is most useful when the\n         number\
    \ of remote label distribution peers is small, or the\n         number of higher\
    \ level label bindings is large, or the remote\n         label distribution peers\
    \ are in distinct routing areas or\n         domains.  Of course, one needs to\
    \ know which labels to\n         distribute to which peers; this is addressed\
    \ in section 4.1.2.\n         Examples of the use of explicit peering is found\
    \ in sections\n         4.2.1 and 4.6.\n      2. Implicit Peering\n         In\
    \ Implicit Peering, one does not send label distribution\n         protocol messages\
    \ which are addressed to one's peer.  Rather,\n         to distribute higher level\
    \ labels to ones remote label\n         distribution peers, one encodes a higher\
    \ level label as an\n         attribute of a lower level label, and then distributes\
    \ the\n         lower level label, along with this attribute, to one's local\n\
    \         label distribution peers.  The local label distribution peers\n    \
    \     then propagate the information to their local label\n         distribution\
    \ peers.  This process continues till the\n         information reaches the remote\
    \ peer.\n         This technique is most useful when the number of remote label\n\
    \         distribution peers is large.  Implicit peering does not require\n  \
    \       an n-square peering mesh to distribute labels to the remote\n        \
    \ label distribution peers because the information is piggybacked\n         through\
    \ the local label distribution peering.  However,\n         implicit peering requires\
    \ the intermediate nodes to store\n         information that they might not be\
    \ directly interested in.\n         An example of the use of implicit peering\
    \ is found in section\n         4.3.\n"
- title: 3.28. Label Distribution Protocol Transport
  contents:
  - "3.28. Label Distribution Protocol Transport\n   A label distribution protocol\
    \ is used between nodes in an MPLS\n   network to establish and maintain the label\
    \ bindings.  In order for\n   MPLS to operate correctly, label distribution information\
    \ needs to be\n   transmitted reliably, and the label distribution protocol messages\n\
    \   pertaining to a particular FEC need to be transmitted in sequence.\n   Flow\
    \ control is also desirable, as is the capability to carry\n   multiple label\
    \ messages in a single datagram.\n   One way to meet these goals is to use TCP\
    \ as the underlying\n   transport, as is done in [MPLS-LDP] and [MPLS-BGP].\n"
- title: 3.29. Why More than one Label Distribution Protocol?
  contents:
  - "3.29. Why More than one Label Distribution Protocol?\n   This architecture does\
    \ not establish hard and fast rules for choosing\n   which label distribution\
    \ protocol to use in which circumstances.\n   However, it is possible to point\
    \ out some of the considerations.\n"
- title: 3.29.1. BGP and LDP
  contents:
  - "3.29.1. BGP and LDP\n   In many scenarios, it is desirable to bind labels to\
    \ FECs which can\n   be identified with routes to address prefixes (see section\
    \ 4.1).  If\n   there is a standard, widely deployed routing algorithm which\n\
    \   distributes those routes, it can be argued that label distribution is\n  \
    \ best achieved by piggybacking the label distribution on the\n   distribution\
    \ of the routes themselves.\n   For example, BGP distributes such routes, and\
    \ if a BGP speaker needs\n   to also distribute labels to its BGP peers, using\
    \ BGP to do the label\n   distribution (see [MPLS-BGP]) has a number of advantages.\
    \  In\n   particular, it permits BGP route reflectors to distribute labels,\n\
    \   thus providing a significant scalability advantage over using LDP to\n   distribute\
    \ labels between BGP peers.\n"
- title: 3.29.2. Labels for RSVP Flowspecs
  contents:
  - "3.29.2. Labels for RSVP Flowspecs\n   When RSVP is used to set up resource reservations\
    \ for particular\n   flows, it can be desirable to label the packets in those\
    \ flows, so\n   that the RSVP filterspec does not need to be applied at each hop.\
    \  It\n   can be argued that having RSVP distribute the labels as part of its\n\
    \   path/reservation setup process is the most efficient method of\n   distributing\
    \ labels for this purpose.\n"
- title: 3.29.3. Labels for Explicitly Routed LSPs
  contents:
  - "3.29.3. Labels for Explicitly Routed LSPs\n   In some applications of MPLS, particularly\
    \ those related to traffic\n   engineering, it is desirable to set up an explicitly\
    \ routed path,\n   from ingress to egress.  It is also desirable to apply resource\n\
    \   reservations along that path.\n   One can imagine two approaches to this:\n\
    \      -  Start with an existing protocol that is used for setting up\n      \
    \   resource reservations, and extend it to support explicit\n         routing\
    \ and label distribution.\n      -  Start with an existing protocol that is used\
    \ for label\n         distribution, and extend it to support explicit routing\
    \ and\n         resource reservations.\n   The first approach has given rise to\
    \ the protocol specified in\n   [MPLS-RSVP-TUNNELS], the second to the approach\
    \ specified in [MPLS-\n   CR-LDP].\n"
- title: 3.30. Multicast
  contents:
  - "3.30. Multicast\n   This section is for further study\n"
- title: 4. Some Applications of MPLS
  contents:
  - '4. Some Applications of MPLS

    '
- title: 4.1. MPLS and Hop by Hop Routed Traffic
  contents:
  - "4.1. MPLS and Hop by Hop Routed Traffic\n   A number of uses of MPLS require\
    \ that packets with a certain label be\n   forwarded along the same hop-by-hop\
    \ routed path that would be used\n   for forwarding a packet with a specified\
    \ address in its network layer\n   destination address field.\n"
- title: 4.1.1. Labels for Address Prefixes
  contents:
  - "4.1.1. Labels for Address Prefixes\n   In general, router R determines the next\
    \ hop for packet P by finding\n   the address prefix X in its routing table which\
    \ is the longest match\n   for P's destination address.  That is, the packets\
    \ in a given FEC are\n   just those packets which match a given address prefix\
    \ in R's routing\n   table.  In this case, a FEC can be identified with an address\
    \ prefix.\n   Note that a packet P may be assigned to FEC F, and FEC F may be\n\
    \   identified with address prefix X, even if P's destination address\n   does\
    \ not match X.\n"
- title: 4.1.2. Distributing Labels for Address Prefixes
  contents:
  - '4.1.2. Distributing Labels for Address Prefixes

    '
- title: 4.1.2.1. Label Distribution Peers for an Address Prefix
  contents:
  - "4.1.2.1. Label Distribution Peers for an Address Prefix\n   LSRs R1 and R2 are\
    \ considered to be label distribution peers for\n   address prefix X if and only\
    \ if one of the following conditions\n   holds:\n      1. R1's route to X is a\
    \ route which it learned about via a\n         particular instance of a particular\
    \ IGP, and R2 is a neighbor\n         of R1 in that instance of that IGP\n   \
    \   2. R1's route to X is a route which it learned about by some\n         instance\
    \ of routing algorithm A1, and that route is\n         redistributed into an instance\
    \ of routing algorithm A2, and R2\n         is a neighbor of R1 in that instance\
    \ of A2\n      3. R1 is the receive endpoint of an LSP Tunnel that is within\n\
    \         another LSP, and R2 is a transmit endpoint of that tunnel, and\n   \
    \      R1 and R2 are participants in a common instance of an IGP, and\n      \
    \   are in the same IGP area (if the IGP in question has areas),\n         and\
    \ R1's route to X was learned via that IGP instance, or is\n         redistributed\
    \ by R1 into that IGP instance\n      4. R1's route to X is a route which it learned\
    \ about via BGP, and\n         R2 is a BGP peer of R1\n   In general, these rules\
    \ ensure that if the route to a particular\n   address prefix is distributed via\
    \ an IGP, the label distribution\n   peers for that address prefix are the IGP\
    \ neighbors.  If the route to\n   a particular address prefix is distributed via\
    \ BGP, the label\n   distribution peers for that address prefix are the BGP peers.\
    \  In\n   other cases of LSP tunneling, the tunnel endpoints are label\n   distribution\
    \ peers.\n"
- title: 4.1.2.2. Distributing Labels
  contents:
  - "4.1.2.2. Distributing Labels\n   In order to use MPLS for the forwarding of packets\
    \ according to the\n   hop-by-hop route corresponding to any address prefix, each\
    \ LSR MUST:\n      1. bind one or more labels to each address prefix that appears\
    \ in\n         its routing table;\n      2. for each such address prefix X, use\
    \ a label distribution\n         protocol to distribute the binding of a label\
    \ to X to each of\n         its label distribution peers for X.\n   There is also\
    \ one circumstance in which an LSR must distribute a\n   label binding for an\
    \ address prefix, even if it is not the LSR which\n   bound that label to that\
    \ address prefix:\n      3. If R1 uses BGP to distribute a route to X, naming\
    \ some other\n         LSR R2 as the BGP Next Hop to X, and if R1 knows that R2\
    \ has\n         assigned label L to X, then R1 must distribute the binding\n \
    \        between L and X to any BGP peer to which it distributes that\n      \
    \   route.\n   These rules ensure that labels corresponding to address prefixes\n\
    \   which correspond to BGP routes are distributed to IGP neighbors if\n   and\
    \ only if the BGP routes are distributed into the IGP.  Otherwise,\n   the labels\
    \ bound to BGP routes are distributed only to the other BGP\n   speakers.\n  \
    \ These rules are intended only to indicate which label bindings must\n   be distributed\
    \ by a given LSR to which other LSRs.\n"
- title: 4.1.3. Using the Hop by Hop path as the LSP
  contents:
  - "4.1.3. Using the Hop by Hop path as the LSP\n   If the hop-by-hop path that packet\
    \ P needs to follow is <R1, ...,\n   Rn>, then <R1, ..., Rn> can be an LSP as\
    \ long as:\n      1. there is a single address prefix X, such that, for all i,\n\
    \         1<=i<n, X is the longest match in Ri's routing table for P's\n     \
    \    destination address;\n      2. for all i, 1<i<n, Ri has assigned a label\
    \ to X and distributed\n         that label to R[i-1].\n   Note that a packet's\
    \ LSP can extend only until it encounters a router\n   whose forwarding tables\
    \ have a longer best match address prefix for\n   the packet's destination address.\
    \  At that point, the LSP must end\n   and the best match algorithm must be performed\
    \ again.\n   Suppose, for example, that packet P, with destination address\n \
    \  10.2.153.178 needs to go from R1 to R2 to R3.  Suppose also that R2\n   advertises\
    \ address prefix 10.2/16 to R1, but R3 advertises\n   10.2.153/23, 10.2.154/23,\
    \ and 10.2/16 to R2.  That is, R2 is\n   advertising an \"aggregated route\" to\
    \ R1.  In this situation, packet P\n   can be label Switched until it reaches\
    \ R2, but since R2 has performed\n   route aggregation, it must execute the best\
    \ match algorithm to find\n   P's FEC.\n"
- title: 4.1.4. LSP Egress and LSP Proxy Egress
  contents:
  - "4.1.4. LSP Egress and LSP Proxy Egress\n   An LSR R is considered to be an \"\
    LSP Egress\" LSR for address prefix X\n   if and only if one of the following\
    \ conditions holds:\n      1. R has an address Y, such that X is the address prefix\
    \ in R's\n         routing table which is the longest match for Y, or\n      2.\
    \ R contains in its routing tables one or more address prefixes Y\n         such\
    \ that X is a proper initial substring of Y, but R's \"LSP\n         previous\
    \ hops\" for X do not contain any such address prefixes\n         Y; that is,\
    \ R is a \"deaggregation point\" for address prefix X.\n   An LSR R1 is considered\
    \ to be an \"LSP Proxy Egress\" LSR for address\n   prefix X if and only if:\n\
    \      1. R1's next hop for X is R2, and R1 and R2 are not label\n         distribution\
    \ peers with respect to X (perhaps because R2 does\n         not support MPLS),\
    \ or\n      2. R1 has been configured to act as an LSP Proxy Egress for X\n  \
    \ The definition of LSP allows for the LSP Egress to be a node which\n   does\
    \ not support MPLS; in this case the penultimate node in the LSP\n   is the Proxy\
    \ Egress.\n"
- title: 4.1.5. The Implicit NULL Label
  contents:
  - "4.1.5. The Implicit NULL Label\n   The Implicit NULL label is a label with special\
    \ semantics which an\n   LSR can bind to an address prefix.  If LSR Ru, by consulting\
    \ its ILM,\n   sees that labeled packet P must be forwarded next to Rd, but that\
    \ Rd\n   has distributed a binding of Implicit NULL to the corresponding\n   address\
    \ prefix, then instead of replacing the value of the label on\n   top of the label\
    \ stack, Ru pops the label stack, and then forwards\n   the resulting packet to\
    \ Rd.\n   LSR Rd distributes a binding between Implicit NULL and an address\n\
    \   prefix X to LSR Ru if and only if:\n      1. the rules of Section 4.1.2 indicate\
    \ that Rd distributes to Ru a\n         label binding for X, and\n      2. Rd\
    \ knows that Ru can support the Implicit NULL label (i.e.,\n         that it can\
    \ pop the label stack), and\n      3. Rd is an LSP Egress (not proxy egress) for\
    \ X.\n   This causes the penultimate LSR on a LSP to pop the label stack.\n  \
    \ This is quite appropriate; if the LSP Egress is an MPLS Egress for X,\n   then\
    \ if the penultimate LSR does not pop the label stack, the LSP\n   Egress will\
    \ need to look up the label, pop the label stack, and then\n   look up the next\
    \ label (or look up the L3 address, if no more labels\n   are present).  By having\
    \ the penultimate LSR pop the label stack, the\n   LSP Egress is saved the work\
    \ of having to look up two labels in order\n   to make its forwarding decision.\n\
    \   However, if the penultimate LSR is an ATM switch, it may not have the\n  \
    \ capability to pop the label stack.  Hence a binding of Implicit NULL\n   may\
    \ be distributed only to LSRs which can support that function.\n   If the penultimate\
    \ LSR in an LSP for address prefix X is an LSP Proxy\n   Egress, it acts just\
    \ as if the LSP Egress had distributed a binding\n   of Implicit NULL for X.\n"
- title: '4.1.6. Option: Egress-Targeted Label Assignment'
  contents:
  - "4.1.6. Option: Egress-Targeted Label Assignment\n   There are situations in which\
    \ an LSP Ingress, Ri, knows that packets\n   of several different FECs must all\
    \ follow the same LSP, terminating\n   at, say, LSP Egress Re.  In this case,\
    \ proper routing can be achieved\n   by using a single label for all such FECs;\
    \ it is not necessary to\n   have a distinct label for each FEC.  If (and only\
    \ if) the following\n   conditions hold:\n      1. the address of LSR Re is itself\
    \ in the routing table as a \"host\n         route\", and\n      2. there is some\
    \ way for Ri to determine that Re is the LSP egress\n         for all packets\
    \ in a particular set of FECs\n   Then Ri may bind a single label to all FECS\
    \ in the set.  This is\n   known as \"Egress-Targeted Label Assignment.\"\n  \
    \ How can LSR Ri determine that an LSR Re is the LSP Egress for all\n   packets\
    \ in a particular FEC?  There are a number of possible ways:\n      -  If the\
    \ network is running a link state routing algorithm, and\n         all nodes in\
    \ the area support MPLS, then the routing algorithm\n         provides Ri with\
    \ enough information to determine the routers\n         through which packets\
    \ in that FEC must leave the routing domain\n         or area.\n      -  If the\
    \ network is running BGP, Ri may be able to determine that\n         the packets\
    \ in a particular FEC must leave the network via some\n         particular router\
    \ which is the \"BGP Next Hop\" for that FEC.\n      -  It is possible to use\
    \ the label distribution protocol to pass\n         information about which address\
    \ prefixes are \"attached\" to\n         which egress LSRs.  This method has the\
    \ advantage of not\n         depending on the presence of link state routing.\n\
    \   If egress-targeted label assignment is used, the number of labels\n   that\
    \ need to be supported throughout the network may be greatly\n   reduced.  This\
    \ may be significant if one is using legacy switching\n   hardware to do MPLS,\
    \ and the switching hardware can support only a\n   limited number of labels.\n\
    \   One possible approach would be to configure the network to use\n   egress-targeted\
    \ label assignment by default, but to configure\n   particular LSRs to NOT use\
    \ egress-targeted label assignment for one\n   or more of the address prefixes\
    \ for which it is an LSP egress.  We\n   impose the following rule:\n      - \
    \ If a particular LSR is NOT an LSP Egress for some set of\n         address prefixes,\
    \ then it should assign labels to the address\n         prefixes in the same way\
    \ as is done by its LSP next hop for\n         those address prefixes.  That is,\
    \ suppose Rd is Ru's LSP next\n         hop for address prefixes X1 and X2.  If\
    \ Rd assigns the same\n         label to X1 and X2, Ru should as well.  If Rd\
    \ assigns different\n         labels to X1 and X2, then Ru should as well.\n \
    \  For example, suppose one wants to make egress-targeted label\n   assignment\
    \ the default, but to assign distinct labels to those\n   address prefixes for\
    \ which there are multiple possible LSP egresses\n   (i.e., for those address\
    \ prefixes which are multi-homed.)  One can\n   configure all LSRs to use egress-targeted\
    \ label assignment, and then\n   configure a handful of LSRs to assign distinct\
    \ labels to those\n   address prefixes which are multi-homed.  For a particular\
    \ multi-homed\n   address prefix X, one would only need to configure this in LSRs\
    \ which\n   are either LSP Egresses or LSP Proxy Egresses for X.\n   It is important\
    \ to note that if Ru and Rd are adjacent LSRs in an LSP\n   for X1 and X2, forwarding\
    \ will still be done correctly if Ru assigns\n   distinct labels to X1 and X2\
    \ while Rd assigns just one label to the\n   both of them.  This just means that\
    \ R1 will map different incoming\n   labels to the same outgoing label, an ordinary\
    \ occurrence.\n   Similarly, if Rd assigns distinct labels to X1 and X2, but Ru\
    \ assigns\n   to them both the label corresponding to the address of their LSP\n\
    \   Egress or Proxy Egress, forwarding will still be done correctly.  Ru\n   will\
    \ just map the incoming label to the label which Rd has assigned\n   to the address\
    \ of that LSP Egress.\n"
- title: 4.2. MPLS and Explicitly Routed LSPs
  contents:
  - "4.2. MPLS and Explicitly Routed LSPs\n   There are a number of reasons why it\
    \ may be desirable to use explicit\n   routing instead of hop by hop routing.\
    \  For example, this allows\n   routes to be based on administrative policies,\
    \ and allows the routes\n   that LSPs take to be carefully designed to allow traffic\
    \ engineering\n   [MPLS-TRFENG].\n"
- title: 4.2.1. Explicitly Routed LSP Tunnels
  contents:
  - "4.2.1. Explicitly Routed LSP Tunnels\n   In some situations, the network administrators\
    \ may desire to forward\n   certain classes of traffic along certain pre-specified\
    \ paths, where\n   these paths differ from the Hop-by-hop path that the traffic\
    \ would\n   ordinarily follow.  This can be done in support of policy routing,\
    \ or\n   in support of traffic engineering.  The explicit route may be a\n   configured\
    \ one, or it may be determined dynamically by some means,\n   e.g., by constraint-based\
    \ routing.\n   MPLS allows this to be easily done by means of Explicitly Routed\
    \ LSP\n   Tunnels.  All that is needed is:\n      1. A means of selecting the\
    \ packets that are to be sent into the\n         Explicitly Routed LSP Tunnel;\n\
    \      2. A means of setting up the Explicitly Routed LSP Tunnel;\n      3. A\
    \ means of ensuring that packets sent into the Tunnel will not\n         loop\
    \ from the receive endpoint back to the transmit endpoint.\n   If the transmit\
    \ endpoint of the tunnel wishes to put a labeled packet\n   into the tunnel, it\
    \ must first replace the label value at the top of\n   the stack with a label\
    \ value that was distributed to it by the\n   tunnel's receive endpoint.  Then\
    \ it must push on the label which\n   corresponds to the tunnel itself, as distributed\
    \ to it by the next\n   hop along the tunnel.  To allow this, the tunnel endpoints\
    \ should be\n   explicit label distribution peers.  The label bindings they need\
    \ to\n   exchange are of no interest to the LSRs along the tunnel.\n"
- title: 4.3. Label Stacks and Implicit Peering
  contents:
  - "4.3. Label Stacks and Implicit Peering\n   Suppose a particular LSR Re is an\
    \ LSP proxy egress for 10 address\n   prefixes, and it reaches each address prefix\
    \ through a distinct\n   interface.\n   One could assign a single label to all\
    \ 10 address prefixes.  Then Re\n   is an LSP egress for all 10 address prefixes.\
    \  This ensures that\n   packets for all 10 address prefixes get delivered to\
    \ Re.  However, Re\n   would then have to look up the network layer address of\
    \ each such\n   packet in order to choose the proper interface to send the packet\
    \ on.\n   Alternatively, one could assign a distinct label to each interface.\n\
    \   Then Re is an LSP proxy egress for the 10 address prefixes.  This\n   eliminates\
    \ the need for Re to look up the network layer addresses in\n   order to forward\
    \ the packets.  However, it can result in the use of a\n   large number of labels.\n\
    \   An alternative would be to bind all 10 address prefixes to the same\n   level\
    \ 1 label (which is also bound to the address of the LSR itself),\n   and then\
    \ to bind each address prefix to a distinct level 2 label.\n   The level 2 label\
    \ would be treated as an attribute of the level 1\n   label binding, which we\
    \ call the \"Stack Attribute\".  We impose the\n   following rules:\n      - \
    \ When LSR Ru initially labels a hitherto unlabeled packet, if\n         the longest\
    \ match for the packet's destination address is X,\n         and Ru's LSP next\
    \ hop for X is Rd, and Rd has distributed to Ru\n         a binding of label L1\
    \ to X, along with a stack attribute of L2,\n         then\n         1. Ru must\
    \ push L2 and then L1 onto the packet's label stack,\n            and then forward\
    \ the packet to Rd;\n         2. When Ru distributes label bindings for X to its\
    \ label\n            distribution peers, it must include L2 as the stack\n   \
    \         attribute.\n         3. Whenever the stack attribute changes (possibly\
    \ as a result\n            of a change in Ru's LSP next hop for X), Ru must distribute\n\
    \            the new stack attribute.\n   Note that although the label value bound\
    \ to X may be different at\n   each hop along the LSP, the stack attribute value\
    \ is passed\n   unchanged, and is set by the LSP proxy egress.\n   Thus the LSP\
    \ proxy egress for X becomes an \"implicit peer\" with each\n   other LSR in the\
    \ routing area or domain.  In this case, explicit\n   peering would be too unwieldy,\
    \ because the number of peers would\n   become too large.\n"
- title: 4.4. MPLS and Multi-Path Routing
  contents:
  - "4.4. MPLS and Multi-Path Routing\n   If an LSR supports multiple routes for a\
    \ particular stream, then it\n   may assign multiple labels to the stream, one\
    \ for each route.  Thus\n   the reception of a second label binding from a particular\
    \ neighbor\n   for a particular address prefix should be taken as meaning that\n\
    \   either label can be used to represent that address prefix.\n   If multiple\
    \ label bindings for a particular address prefix are\n   specified, they may have\
    \ distinct attributes.\n"
- title: 4.5. LSP Trees as Multipoint-to-Point Entities
  contents:
  - "4.5. LSP Trees as Multipoint-to-Point Entities\n   Consider the case of packets\
    \ P1 and P2, each of which has a\n   destination address whose longest match,\
    \ throughout a particular\n   routing domain, is address prefix X.  Suppose that\
    \ the Hop-by-hop\n   path for P1 is <R1, R2, R3>, and the Hop-by-hop path for\
    \ P2 is <R4,\n   R2, R3>.   Let's suppose that R3 binds label L3 to X, and distributes\n\
    \   this binding to R2.  R2 binds label L2 to X, and distributes this\n   binding\
    \ to both R1 and R4.  When R2 receives packet P1, its incoming\n   label will\
    \ be L2.  R2 will overwrite L2 with L3, and send P1 to R3.\n   When R2 receives\
    \ packet P2, its incoming label will also be L2.  R2\n   again overwrites L2 with\
    \ L3, and send P2 on to R3.\n   Note then that when P1 and P2 are traveling from\
    \ R2 to R3, they carry\n   the same label, and as far as MPLS is concerned, they\
    \ cannot be\n   distinguished.  Thus instead of talking about two distinct LSPs,\
    \ <R1,\n   R2, R3> and <R4, R2, R3>, we might talk of a single \"Multipoint-to-\n\
    \   Point LSP Tree\", which we might denote as <{R1, R4}, R2, R3>.\n   This creates\
    \ a difficulty when we attempt to use conventional ATM\n   switches as LSRs. \
    \ Since conventional ATM switches do not support\n   multipoint-to-point connections,\
    \ there must be procedures to ensure\n   that each LSP is realized as a point-to-point\
    \ VC.  However, if ATM\n   switches which do support multipoint-to-point VCs are\
    \ in use, then\n   the LSPs can be most efficiently realized as multipoint-to-point\
    \ VCs.\n   Alternatively, if the SVP Multipoint Encoding (section 3.25.2) can\
    \ be\n   used, the LSPs can be realized as multipoint-to-point SVPs.\n"
- title: 4.6. LSP Tunneling between BGP Border Routers
  contents:
  - "4.6. LSP Tunneling between BGP Border Routers\n   Consider the case of an Autonomous\
    \ System, A, which carries transit\n   traffic between other Autonomous Systems.\
    \  Autonomous System A will\n   have a number of BGP Border Routers, and a mesh\
    \ of BGP connections\n   among them, over which BGP routes are distributed.  In\
    \ many such\n   cases, it is desirable to avoid distributing the BGP routes to\n\
    \   routers which are not BGP Border Routers.  If this can be avoided,\n   the\
    \ \"route distribution load\" on those routers is significantly\n   reduced. \
    \ However, there must be some means of ensuring that the\n   transit traffic will\
    \ be delivered from Border Router to Border Router\n   by the interior routers.\n\
    \   This can easily be done by means of LSP Tunnels.  Suppose that BGP\n   routes\
    \ are distributed only to BGP Border Routers, and not to the\n   interior routers\
    \ that lie along the Hop-by-hop path from Border\n   Router to Border Router.\
    \  LSP Tunnels can then be used as follows:\n      1. Each BGP Border Router distributes,\
    \ to every other BGP Border\n         Router in the same Autonomous System, a\
    \ label for each address\n         prefix that it distributes to that router via\
    \ BGP.\n      2. The IGP for the Autonomous System maintains a host route for\n\
    \         each BGP Border Router.  Each interior router distributes its\n    \
    \     labels for these host routes to each of its IGP neighbors.\n      3. Suppose\
    \ that:\n         a) BGP Border Router B1 receives an unlabeled packet P,\n  \
    \       b) address prefix X in B1's routing table is the longest match\n     \
    \       for the destination address of P,\n         c) the route to X is a BGP\
    \ route,\n         d) the BGP Next Hop for X is B2,\n         e) B2 has bound\
    \ label L1 to X, and has distributed this binding\n            to B1,\n      \
    \   f) the IGP next hop for the address of B2 is I1,\n         g) the address\
    \ of B2 is in B1's and I1's IGP routing tables as\n            a host route, and\n\
    \         h) I1 has bound label L2 to the address of B2, and distributed\n   \
    \         this binding to B1.\n         Then before sending packet P to I1, B1\
    \ must create a label\n         stack for P, then push on label L1, and then push\
    \ on label L2.\n      4. Suppose that BGP Border Router B1 receives a labeled\
    \ Packet P,\n         where the label on the top of the label stack corresponds\
    \ to an\n         address prefix, X, to which the route is a BGP route, and that\n\
    \         conditions 3b, 3c, 3d, and 3e all hold.  Then before sending\n     \
    \    packet P to I1, B1 must replace the label at the top of the\n         label\
    \ stack with L1, and then push on label L2.\n   With these procedures, a given\
    \ packet P follows a level 1 LSP all of\n   whose members are BGP Border Routers,\
    \ and between each pair of BGP\n   Border Routers in the level 1 LSP, it follows\
    \ a level 2 LSP.\n   These procedures effectively create a Hop-by-Hop Routed LSP\
    \ Tunnel\n   between the BGP Border Routers.\n   Since the BGP border routers\
    \ are exchanging label bindings for\n   address prefixes that are not even known\
    \ to the IGP routing, the BGP\n   routers should become explicit label distribution\
    \ peers with each\n   other.\n   It is sometimes possible to create Hop-by-Hop\
    \ Routed LSP Tunnels\n   between two BGP Border Routers, even if they are not\
    \ in the same\n   Autonomous System.  Suppose, for example, that B1 and B2 are\
    \ in AS 1.\n   Suppose that B3 is an EBGP neighbor of B2, and is in AS2.  Finally,\n\
    \   suppose that B2 and B3 are on some network which is common to both\n   Autonomous\
    \ Systems (a \"Demilitarized Zone\").  In this case, an LSP\n   tunnel can be\
    \ set up directly between B1 and B3 as follows:\n      -  B3 distributes routes\
    \ to B2 (using EBGP), optionally assigning\n         labels to address prefixes;\n\
    \      -  B2 redistributes those routes to B1 (using IBGP), indicating\n     \
    \    that the BGP next hop for each such route is B3.  If B3 has\n         assigned\
    \ labels to address prefixes, B2 passes these labels\n         along, unchanged,\
    \ to B1.\n      -  The IGP of AS1 has a host route for B3.\n"
- title: 4.7. Other Uses of Hop-by-Hop Routed LSP Tunnels
  contents:
  - "4.7. Other Uses of Hop-by-Hop Routed LSP Tunnels\n   The use of Hop-by-Hop Routed\
    \ LSP Tunnels is not restricted to tunnels\n   between BGP Next Hops.  Any situation\
    \ in which one might otherwise\n   have used an encapsulation tunnel is one in\
    \ which it is appropriate\n   to use a Hop-by-Hop Routed LSP Tunnel.  Instead\
    \ of encapsulating the\n   packet with a new header whose destination address\
    \ is the address of\n   the tunnel's receive endpoint, the label corresponding\
    \ to the address\n   prefix which is the longest match for the address of the\
    \ tunnel's\n   receive endpoint is pushed on the packet's label stack.  The packet\n\
    \   which is sent into the tunnel may or may not already be labeled.\n   If the\
    \ transmit endpoint of the tunnel wishes to put a labeled packet\n   into the\
    \ tunnel, it must first replace the label value at the top of\n   the stack with\
    \ a label value that was distributed to it by the\n   tunnel's receive endpoint.\
    \  Then it must push on the label which\n   corresponds to the tunnel itself,\
    \ as distributed to it by the next\n   hop along the tunnel.  To allow this, the\
    \ tunnel endpoints should be\n   explicit label distribution peers.  The label\
    \ bindings they need to\n   exchange are of no interest to the LSRs along the\
    \ tunnel.\n"
- title: 4.8. MPLS and Multicast
  contents:
  - "4.8. MPLS and Multicast\n   Multicast routing proceeds by constructing multicast\
    \ trees.  The tree\n   along which a particular multicast packet must get forwarded\
    \ depends\n   in general on the packet's source address and its destination\n\
    \   address.  Whenever a particular LSR is a node in a particular\n   multicast\
    \ tree, it binds a label to that tree.  It then distributes\n   that binding to\
    \ its parent on the multicast tree.  (If the node in\n   question is on a LAN,\
    \ and has siblings on that LAN, it must also\n   distribute the binding to its\
    \ siblings.  This allows the parent to\n   use a single label value when multicasting\
    \ to all children on the\n   LAN.)\n   When a multicast labeled packet arrives,\
    \ the NHLFE corresponding to\n   the label indicates the set of output interfaces\
    \ for that packet, as\n   well as the outgoing label.  If the same label encoding\
    \ technique is\n   used on all the outgoing interfaces, the very same packet can\
    \ be sent\n   to all the children.\n"
- title: 5. Label Distribution Procedures (Hop-by-Hop)
  contents:
  - "5. Label Distribution Procedures (Hop-by-Hop)\n   In this section, we consider\
    \ only label bindings that are used for\n   traffic to be label switched along\
    \ its hop-by-hop routed path.  In\n   these cases, the label in question will\
    \ correspond to an address\n   prefix in the routing table.\n"
- title: 5.1. The Procedures for Advertising and Using labels
  contents:
  - "5.1. The Procedures for Advertising and Using labels\n   There are a number of\
    \ different procedures that may be used to\n   distribute label bindings.  Some\
    \ are executed by the downstream LSR,\n   and some by the upstream LSR.\n   The\
    \ downstream LSR must perform:\n      -  The Distribution Procedure, and\n   \
    \   -  the Withdrawal Procedure.\n   The upstream LSR must perform:\n      - \
    \ The Request Procedure, and\n      -  the NotAvailable Procedure, and\n     \
    \ -  the Release Procedure, and\n      -  the labelUse Procedure.\n   The MPLS\
    \ architecture supports several variants of each procedure.\n   However, the MPLS\
    \ architecture does not support all possible\n   combinations of all possible\
    \ variants.  The set of supported\n   combinations will be described in section\
    \ 5.2, where the\n   interoperability between different combinations will also\
    \ be\n   discussed.\n"
- title: '5.1.1. Downstream LSR: Distribution Procedure'
  contents:
  - "5.1.1. Downstream LSR: Distribution Procedure\n   The Distribution Procedure\
    \ is used by a downstream LSR to determine\n   when it should distribute a label\
    \ binding for a particular address\n   prefix to its label distribution peers.\
    \  The architecture supports\n   four different distribution procedures.\n   Irrespective\
    \ of the particular procedure that is used, if a label\n   binding for a particular\
    \ address prefix has been distributed by a\n   downstream LSR Rd to an upstream\
    \ LSR Ru, and if at any time the\n   attributes (as defined above) of that binding\
    \ change, then Rd must\n   inform Ru of the new attributes.\n   If an LSR is maintaining\
    \ multiple routes to a particular address\n   prefix, it is a local matter as\
    \ to whether that LSR binds multiple\n   labels to the address prefix (one per\
    \ route), and hence distributes\n   multiple bindings.\n"
- title: 5.1.1.1. PushUnconditional
  contents:
  - "5.1.1.1. PushUnconditional\n   Let Rd be an LSR.  Suppose that:\n      1. X is\
    \ an address prefix in Rd's routing table\n      2. Ru is a label distribution\
    \ peer of Rd with respect to X\n   Whenever these conditions hold, Rd must bind\
    \ a label to X and\n   distribute that binding to Ru.  It is the responsibility\
    \ of Rd to\n   keep track of the bindings which it has distributed to Ru, and\
    \ to\n   make sure that Ru always has these bindings.\n   This procedure would\
    \ be used by LSRs which are performing unsolicited\n   downstream label assignment\
    \ in the Independent LSP Control Mode.\n"
- title: 5.1.1.2. PushConditional
  contents:
  - "5.1.1.2. PushConditional\n   Let Rd be an LSR.  Suppose that:\n      1. X is\
    \ an address prefix in Rd's routing table\n      2. Ru is a label distribution\
    \ peer of Rd with respect to X\n      3. Rd is either an LSP Egress or an LSP\
    \ Proxy Egress for X, or\n         Rd's L3 next hop for X is Rn, where Rn is distinct\
    \ from Ru, and\n         Rn has bound a label to X and distributed that binding\
    \ to Rd.\n   Then as soon as these conditions all hold, Rd should bind a label\
    \ to\n   X and distribute that binding to Ru.\n   Whereas PushUnconditional causes\
    \ the distribution of label bindings\n   for all address prefixes in the routing\
    \ table, PushConditional causes\n   the distribution of label bindings only for\
    \ those address prefixes\n   for which one has received label bindings from one's\
    \ LSP next hop, or\n   for which one does not have an MPLS-capable L3 next hop.\n\
    \   This procedure would be used by LSRs which are performing unsolicited\n  \
    \ downstream label assignment in the Ordered LSP Control Mode.\n"
- title: 5.1.1.3. PulledUnconditional
  contents:
  - "5.1.1.3. PulledUnconditional\n   Let Rd be an LSR.  Suppose that:\n      1. X\
    \ is an address prefix in Rd's routing table\n      2. Ru is a label distribution\
    \ peer of Rd with respect to X\n      3. Ru has explicitly requested that Rd bind\
    \ a label to X and\n         distribute the binding to Ru\n   Then Rd should bind\
    \ a label to X and distribute that binding to Ru.\n   Note that if X is not in\
    \ Rd's routing table, or if Rd is not a label\n   distribution peer of Ru with\
    \ respect to X, then Rd must inform Ru\n   that it cannot provide a binding at\
    \ this time.\n   If Rd has already distributed a binding for address prefix X\
    \ to Ru,\n   and it receives a new request from Ru for a binding for address\n\
    \   prefix X, it will bind a second label, and distribute the new binding\n  \
    \ to Ru.  The first label binding remains in effect.\n   This procedure would\
    \ be used by LSRs performing downstream-on-demand\n   label distribution using\
    \ the Independent LSP Control Mode.\n"
- title: 5.1.1.4. PulledConditional
  contents:
  - "5.1.1.4. PulledConditional\n   Let Rd be an LSR.  Suppose that:\n      1. X is\
    \ an address prefix in Rd's routing table\n      2. Ru is a label distribution\
    \ peer of Rd with respect to X\n      3. Ru has explicitly requested that Rd bind\
    \ a label to X and\n         distribute the binding to Ru\n      4. Rd is either\
    \ an LSP Egress or an LSP Proxy Egress for X, or\n         Rd's L3 next hop for\
    \ X is Rn, where Rn is distinct from Ru, and\n         Rn has bound a label to\
    \ X and distributed that binding to Rd\n   Then as soon as these conditions all\
    \ hold, Rd should bind a label to\n   X and distribute that binding to Ru.  Note\
    \ that if X is not in Rd's\n   routing table and a binding for X is not obtainable\
    \ via Rd's next hop\n   for X, or if Rd is not a label distribution peer of Ru\
    \ with respect\n   to X, then Rd must inform Ru that it cannot provide a binding\
    \ at this\n   time.\n   However, if the only condition that fails to hold is that\
    \ Rn has not\n   yet provided a label to Rd, then Rd must defer any response to\
    \ Ru\n   until such time as it has receiving a binding from Rn.\n   If Rd has\
    \ distributed a label binding for address prefix X to Ru, and\n   at some later\
    \ time, any attribute of the label binding changes, then\n   Rd must redistribute\
    \ the label binding to Ru, with the new attribute.\n   It must do this even though\
    \ Ru does not issue a new Request.\n   This procedure would be used by LSRs that\
    \ are performing downstream-\n   on-demand label allocation in the Ordered LSP\
    \ Control Mode.\n   In section 5.2, we  will discuss how to choose the particular\n\
    \   procedure to be used at any given time, and how to ensure\n   interoperability\
    \ among LSRs that choose different procedures.\n"
- title: '5.1.2. Upstream LSR: Request Procedure'
  contents:
  - "5.1.2. Upstream LSR: Request Procedure\n   The Request Procedure is used by the\
    \ upstream LSR for an address\n   prefix to determine when to explicitly request\
    \ that the downstream\n   LSR bind a label to that prefix and distribute the binding.\
    \  There\n   are three possible procedures that can be used.\n"
- title: 5.1.2.1. RequestNever
  contents:
  - "5.1.2.1. RequestNever\n   Never make a request.  This is useful if the downstream\
    \ LSR uses the\n   PushConditional procedure or the PushUnconditional procedure,\
    \ but is\n   not useful if the downstream LSR uses the PulledUnconditional\n \
    \  procedure or the the PulledConditional procedures.\n   This procedure would\
    \ be used by an LSR when unsolicited downstream\n   label distribution and Liberal\
    \ Label Retention Mode are being used.\n"
- title: 5.1.2.2. RequestWhenNeeded
  contents:
  - "5.1.2.2. RequestWhenNeeded\n   Make a request whenever the L3 next hop to the\
    \ address prefix\n   changes, or when a new address prefix is learned, and one\
    \ doesn't\n   already have a label binding from that next hop for the given address\n\
    \   prefix.\n   This procedure would be used by an LSR whenever Conservative Label\n\
    \   Retention Mode is being used.\n"
- title: 5.1.2.3. RequestOnRequest
  contents:
  - "5.1.2.3. RequestOnRequest\n   Issue a request whenever a request is received,\
    \ in addition to\n   issuing a request when needed (as described in section 5.1.2.2).\
    \  If\n   Ru is not capable of being an LSP ingress, it may issue a request\n\
    \   only when it receives a request from upstream.\n   If Rd receives such a request\
    \ from Ru, for an address prefix for\n   which Rd has already distributed Ru a\
    \ label, Rd shall assign a new\n   (distinct) label, bind it to X, and distribute\
    \ that binding.\n   (Whether Rd can distribute this binding to Ru immediately\
    \ or not\n   depends on the Distribution Procedure being used.)\n   This procedure\
    \ would be used by an LSR which is doing downstream-on-\n   demand label distribution,\
    \ but is not doing label merging, e.g., an\n   ATM-LSR which is not capable of\
    \ VC merge.\n"
- title: '5.1.3. Upstream LSR: NotAvailable Procedure'
  contents:
  - "5.1.3. Upstream LSR: NotAvailable Procedure\n   If Ru and Rd are respectively\
    \ upstream and downstream label\n   distribution peers for address prefix X, and\
    \ Rd is Ru's L3 next hop\n   for X, and Ru requests a binding for X from Rd, but\
    \ Rd replies that\n   it cannot provide a binding at this time, because it has\
    \ no next hop\n   for X, then the NotAvailable procedure determines how Ru responds.\n\
    \   There are two possible procedures governing Ru's behavior:\n"
- title: 5.1.3.1. RequestRetry
  contents:
  - "5.1.3.1. RequestRetry\n   Ru should issue the request again at a later time.\
    \  That is, the\n   requester is responsible for trying again later to obtain\
    \ the needed\n   binding.  This procedure would be used when downstream-on-demand\n\
    \   label distribution is used.\n"
- title: 5.1.3.2. RequestNoRetry
  contents:
  - "5.1.3.2. RequestNoRetry\n   Ru should never reissue the request, instead assuming\
    \ that Rd will\n   provide the binding automatically when it is available.  This\
    \ is\n   useful if Rd uses the PushUnconditional procedure or the\n   PushConditional\
    \ procedure, i.e., if unsolicited downstream label\n   distribution is used.\n\
    \   Note that if Rd replies that it cannot provide a binding to Ru,\n   because\
    \ of some error condition, rather than because Rd has no next\n   hop, the behavior\
    \ of Ru will be governed by the error recovery\n   conditions of the label distribution\
    \ protocol, rather than by the\n   NotAvailable procedure.\n"
- title: '5.1.4. Upstream LSR: Release Procedure'
  contents:
  - "5.1.4. Upstream LSR: Release Procedure\n   Suppose that Rd is an LSR which has\
    \ bound a label to address prefix\n   X, and has distributed that binding to LSR\
    \ Ru.  If Rd does not happen\n   to be Ru's L3 next hop for address prefix X,\
    \ or has ceased to be Ru's\n   L3 next hop for address prefix X, then Ru will\
    \ not be using the\n   label.  The Release Procedure determines how Ru acts in\
    \ this case.\n   There are two possible procedures governing Ru's behavior:\n"
- title: 5.1.4.1. ReleaseOnChange
  contents:
  - "5.1.4.1. ReleaseOnChange\n   Ru should release the binding, and inform Rd that\
    \ it has done so.\n   This procedure would be used to implement Conservative Label\n\
    \   Retention Mode.\n"
- title: 5.1.4.2. NoReleaseOnChange
  contents:
  - "5.1.4.2. NoReleaseOnChange\n   Ru should maintain the binding, so that it can\
    \ use it again\n   immediately if Rd later  becomes Ru's L3 next hop for X.  This\n\
    \   procedure would be used to implement Liberal Label Retention Mode.\n"
- title: '5.1.5. Upstream LSR: labelUse Procedure'
  contents:
  - "5.1.5. Upstream LSR: labelUse Procedure\n   Suppose Ru is an LSR which has received\
    \ label binding L for address\n   prefix X from LSR Rd, and Ru is upstream of\
    \ Rd with respect to X, and\n   in fact Rd is Ru's L3 next hop for X.\n   Ru will\
    \ make use of the binding if Rd is Ru's L3 next hop for X.  If,\n   at the time\
    \ the binding is received by Ru, Rd is NOT Ru's L3 next hop\n   for X, Ru does\
    \ not make any use of the binding at that time.  Ru may\n   however start using\
    \ the binding at some later time, if Rd becomes\n   Ru's L3 next hop for X.\n\
    \   The labelUse Procedure determines just how Ru makes use of Rd's\n   binding.\n\
    \   There are two procedures which Ru may use:\n"
- title: 5.1.5.1. UseImmediate
  contents:
  - "5.1.5.1. UseImmediate\n   Ru may put the binding into use immediately.  At any\
    \ time when Ru has\n   a binding for X from Rd, and Rd is Ru's L3 next hop for\
    \ X, Rd will\n   also be Ru's LSP next hop for X.  This procedure is used when\
    \ loop\n   detection is not in use.\n"
- title: 5.1.5.2. UseIfLoopNotDetected
  contents:
  - "5.1.5.2. UseIfLoopNotDetected\n   This procedure is the same as UseImmediate,\
    \ unless Ru has detected a\n   loop in the LSP.  If a loop has been detected,\
    \ Ru will discontinue\n   the use of label L for forwarding packets to Rd.\n \
    \  This procedure is used when loop detection is in use.\n   This will continue\
    \ until the next hop for X changes, or until the\n   loop is no longer detected.\n"
- title: '5.1.6. Downstream LSR: Withdraw Procedure'
  contents:
  - "5.1.6. Downstream LSR: Withdraw Procedure\n   In this case, there is only a single\
    \ procedure.\n   When LSR Rd decides to break the binding between label L and\
    \ address\n   prefix X, then this unbinding must be distributed to all LSRs to\n\
    \   which the binding was distributed.\n   It is required that the unbinding of\
    \ L from X be distributed by Rd to\n   a LSR Ru before Rd distributes to Ru any\
    \ new binding of L to any\n   other address prefix Y, where X != Y.  If Ru were\
    \ to learn of the new\n   binding of L to Y before it learned of the unbinding\
    \ of L from X, and\n   if packets matching both X and Y were forwarded by Ru to\
    \ Rd, then for\n   a period of time, Ru would label both packets matching X and\
    \ packets\n   matching Y with label L.\n   The distribution and withdrawal of\
    \ label bindings is done via a label\n   distribution protocol.  All label distribution\
    \ protocols require that\n   a label distribution adjacency be established between\
    \ two label\n   distribution peers (except implicit peers).  If LSR R1 has a label\n\
    \   distribution adjacency to LSR R2, and has received label bindings\n   from\
    \ LSR R2 via that adjacency, then if adjacency is brought down by\n   either peer\
    \ (whether as a result of failure or as a matter of normal\n   operation), all\
    \ bindings received over that adjacency must be\n   considered to have been withdrawn.\n\
    \   As long as the relevant label distribution adjacency remains in\n   place,\
    \ label bindings that are withdrawn must always be withdrawn\n   explicitly. \
    \ If a second label is bound to an address prefix, the\n   result is not to implicitly\
    \ withdraw the first label, but to bind\n   both labels; this is needed to support\
    \ multi-path routing.  If a\n   second address prefix is bound to a label, the\
    \ result is not to\n   implicitly withdraw the binding of that label to the first\
    \ address\n   prefix, but to use that label for both address prefixes.\n"
- title: '5.2. MPLS Schemes: Supported Combinations of Procedures'
  contents:
  - "5.2. MPLS Schemes: Supported Combinations of Procedures\n   Consider two LSRs,\
    \ Ru and Rd, which are label distribution peers with\n   respect to some set of\
    \ address prefixes, where Ru is the upstream\n   peer and Rd is the downstream\
    \ peer.\n   The MPLS scheme which governs the interaction of Ru and Rd can be\n\
    \   described as a quintuple of procedures: <Distribution Procedure,\n   Request\
    \ Procedure, NotAvailable Procedure, Release Procedure,\n   labelUse Procedure>.\
    \  (Since there is only one Withdraw Procedure, it\n   need not be mentioned.)\
    \  A \"*\" appearing in one of the positions is a\n   wild-card, meaning that\
    \ any procedure in that category may be\n   present; an \"N/A\" appearing in a\
    \ particular position indicates that\n   no procedure in that category is needed.\n\
    \   Only the MPLS schemes which are specified below are supported by the\n   MPLS\
    \ Architecture.  Other schemes may be added in the future, if a\n   need for them\
    \ is shown.\n"
- title: 5.2.1. Schemes for LSRs that Support Label Merging
  contents:
  - "5.2.1. Schemes for LSRs that Support Label Merging\n   If Ru and Rd are label\
    \ distribution peers, and both support label\n   merging, one of the following\
    \ schemes must be used:\n      1. <PushUnconditional, RequestNever, N/A, NoReleaseOnChange,\n\
    \         UseImmediate>\n         This is unsolicited downstream label distribution\
    \ with\n         independent control, liberal label retention mode, and no loop\n\
    \         detection.\n      2. <PushUnconditional, RequestNever, N/A, NoReleaseOnChange,\n\
    \         UseIfLoopNotDetected>\n         This is unsolicited downstream label\
    \ distribution with\n         independent control, liberal label retention, and\
    \ loop\n         detection.\n      3. <PushConditional, RequestWhenNeeded, RequestNoRetry,\n\
    \         ReleaseOnChange, *>\n         This is unsolicited downstream label distribution\
    \ with ordered\n         control (from the egress) and conservative label retention\n\
    \         mode.  Loop detection is optional.\n      4. <PushConditional, RequestNever,\
    \ N/A, NoReleaseOnChange, *>\n         This is unsolicited downstream label distribution\
    \ with ordered\n         control (from the egress) and liberal label retention\
    \ mode.\n         Loop detection is optional.\n      5. <PulledConditional, RequestWhenNeeded,\
    \ RequestRetry,\n         ReleaseOnChange, *>\n         This is downstream-on-demand\
    \ label distribution with ordered\n         control (initiated by the ingress),\
    \ conservative label\n         retention mode, and optional loop detection.\n\
    \      6. <PulledUnconditional, RequestWhenNeeded, N/A, ReleaseOnChange,\n   \
    \      UseImmediate>\n         This is downstream-on-demand label distribution\
    \ with\n         independent control and conservative label retention mode,\n\
    \         without loop detection.\n      7. <PulledUnconditional, RequestWhenNeeded,\
    \ N/A, ReleaseOnChange,\n         UseIfLoopNotDetected>\n         This is downstream-on-demand\
    \ label distribution with\n         independent control and conservative label\
    \ retention mode, with\n         loop detection.\n"
- title: 5.2.2. Schemes for LSRs that do not Support Label Merging
  contents:
  - "5.2.2. Schemes for LSRs that do not Support Label Merging\n   Suppose that R1,\
    \ R2, R3, and R4 are ATM switches which do not support\n   label merging, but\
    \ are being used as LSRs.  Suppose further that the\n   L3 hop-by-hop path for\
    \ address prefix X is <R1, R2, R3, R4>, and that\n   packets destined for X can\
    \ enter the network at any of these LSRs.\n   Since there is no multipoint-to-point\
    \ capability, the LSPs must be\n   realized as point-to-point VCs, which means\
    \ that there needs to be\n   three such VCs for address prefix X: <R1, R2, R3,\
    \ R4>, <R2, R3, R4>,\n   and <R3, R4>.\n   Therefore, if R1 and R2 are MPLS peers,\
    \ and either is an LSR which is\n   implemented using conventional ATM switching\
    \ hardware (i.e., no cell\n   interleave suppression), or is otherwise incapable\
    \ of performing\n   label merging, the MPLS scheme in use between R1 and R2 must\
    \ be one\n   of the following:\n      1. <PulledConditional, RequestOnRequest,\
    \ RequestRetry,\n         ReleaseOnChange, *>\n         This is downstream-on-demand\
    \ label distribution with ordered\n         control (initiated by the ingress),\
    \ conservative label\n         retention mode, and optional loop detection.\n\
    \         The use of the RequestOnRequest procedure will cause R4 to\n       \
    \  distribute three labels for X to R3; R3 will distribute 2\n         labels\
    \ for X to R2, and R2 will distribute one label for X to\n         R1.\n     \
    \ 2. <PulledUnconditional, RequestOnRequest, N/A, ReleaseOnChange,\n         UseImmediate>\n\
    \         This is downstream-on-demand label distribution with\n         independent\
    \ control and conservative label retention mode,\n         without loop detection.\n\
    \      3. <PulledUnconditional, RequestOnRequest, N/A, ReleaseOnChange,\n    \
    \     UseIfLoopNotDetected>\n         This is downstream-on-demand label distribution\
    \ with\n         independent control and conservative label retention mode, with\n\
    \         loop detection.\n"
- title: 5.2.3. Interoperability Considerations
  contents:
  - "5.2.3. Interoperability Considerations\n   It is easy to see that certain quintuples\
    \ do NOT yield viable MPLS\n   schemes.  For example:\n      -  <PulledUnconditional,\
    \ RequestNever, *, *, *>\n         <PulledConditional, RequestNever, *, *, *>\n\
    \         In these MPLS schemes, the downstream LSR Rd distributes label\n   \
    \      bindings to upstream LSR Ru only upon request from Ru, but Ru\n       \
    \  never makes any such requests.  Obviously, these schemes are\n         not\
    \ viable, since they will not result in the proper\n         distribution of label\
    \ bindings.\n         -  <*, RequestNever, *, *, ReleaseOnChange>\n         In\
    \ these MPLS schemes, Rd releases bindings when it isn't using\n         them,\
    \ but it never asks for them again, even if it later has a\n         need for\
    \ them.  These schemes thus do not ensure that label\n         bindings get properly\
    \ distributed.\n   In this section, we specify rules to prevent a pair of label\n\
    \   distribution peers from adopting procedures which lead to infeasible\n   MPLS\
    \ Schemes.  These rules require either the exchange of information\n   between\
    \ label distribution peers during the initialization of the\n   label distribution\
    \ adjacency, or a priori knowledge of the\n   information (obtained through a\
    \ means outside the scope of this\n   document).\n      1. Each must state whether\
    \ it supports label merging.\n      2. If Rd does not support label merging, Rd\
    \ must choose either the\n         PulledUnconditional procedure or the PulledConditional\n\
    \         procedure.  If Rd chooses PulledConditional, Ru is forced to\n     \
    \    use the RequestRetry procedure.\n         That is, if the downstream LSR\
    \ does not support label merging,\n         its preferences take priority when\
    \ the MPLS scheme is chosen.\n      3. If Ru does not support label merging, but\
    \ Rd does, Ru must\n         choose either the RequestRetry or RequestNoRetry\
    \ procedure.\n         This forces Rd to use the PulledConditional or\n      \
    \   PulledUnConditional procedure respectively.\n         That is, if only one\
    \ of the LSRs doesn't support label merging,\n         its preferences take priority\
    \ when the MPLS scheme is chosen.\n      4. If both Ru and Rd both support label\
    \ merging, then the choice\n         between liberal and conservative label retention\
    \ mode belongs\n         to Ru.  That is, Ru gets to choose either to use\n  \
    \       RequestWhenNeeded/ReleaseOnChange (conservative) , or to use\n       \
    \  RequestNever/NoReleaseOnChange (liberal).  However, the choice\n         of\
    \ \"push\" vs. \"pull\" and \"conditional\" vs. \"unconditional\"\n         belongs\
    \ to Rd.  If Ru chooses liberal label retention mode, Rd\n         can choose\
    \ either PushUnconditional or PushConditional.  If Ru\n         chooses conservative\
    \ label retention mode, Rd can choose\n         PushConditional, PulledConditional,\
    \ or PulledUnconditional.\n         These choices together determine the MPLS\
    \ scheme in use.\n"
- title: 6. Security Considerations
  contents:
  - "6. Security Considerations\n   Some routers may implement security procedures\
    \ which depend on the\n   network layer header being in a fixed place relative\
    \ to the data link\n   layer header.  The MPLS generic encapsulation inserts a\
    \ shim between\n   the data link layer header and the network layer header.  This\
    \ may\n   cause any such security procedures to fail.\n   An MPLS label has its\
    \ meaning by virtue of an agreement between the\n   LSR that puts the label in\
    \ the label stack (the \"label writer\"), and\n   the LSR that interprets that\
    \ label (the \"label reader\").  If labeled\n   packets are accepted from untrusted\
    \ sources, or if a particular\n   incoming label is accepted from an LSR to which\
    \ that label has not\n   been distributed, then packets may be routed in an illegitimate\n\
    \   manner.\n"
- title: 7. Intellectual Property
  contents:
  - "7. Intellectual Property\n   The IETF has been notified of intellectual property\
    \ rights claimed in\n   regard to some or all of the specification contained in\
    \ this\n   document.  For more information consult the online list of claimed\n\
    \   rights.\n"
- title: 8. Authors' Addresses
  contents:
  - "8. Authors' Addresses\n   Eric C. Rosen\n   Cisco Systems, Inc.\n   250 Apollo\
    \ Drive\n   Chelmsford, MA, 01824\n   EMail: erosen@cisco.com\n   Arun Viswanathan\n\
    \   Force10 Networks, Inc.\n   1440 McCarthy Blvd.\n   Milpitas, CA 95035-7438\n\
    \   EMail: arun@force10networks.com\n   Ross Callon\n   Juniper Networks, Inc.\n\
    \   1194 North Mathilda Avenue\n   Sunnyvale, CA 94089 USA\n   EMail: rcallon@juniper.net\n"
- title: 9. References
  contents:
  - "9. References\n   [MPLS-ATM]          Davie, B., Lawrence, J., McCloghrie, K.,\
    \ Rekhter,\n                       Y., Rosen, E., Swallow, G. and P. Doolan, \"\
    MPLS\n                       using LDP and ATM VC Switching\", RFC 3035,\n   \
    \                    January 2001.\n   [MPLS-BGP]          \"Carrying Label Information\
    \ in BGP-4\", Rekhter,\n                       Rosen, Work in Progress.\n   [MPLS-CR-LDP]\
    \       \"Constraint-Based LSP Setup using LDP\", Jamoussi,\n                \
    \       Editor, Work in Progress.\n   [MPLS-FRMRLY]       Conta, A., Doolan, P.\
    \ and A. Malis, \"Use of Label\n                       Switching on Frame Relay\
    \ Networks Specification\",\n                       RFC 3034, January 2001.\n\
    \   [MPLS-LDP]          Andersson, L., Doolan, P., Feldman, N., Fredette,\n  \
    \                     A. and B. Thomas, \"LDP Specification\", RFC 3036,\n   \
    \                    January 2001.\n   [MPLS-RSVP-TUNNELS] \"Extensions to RSVP\
    \ for LSP Tunnels\", Awduche,\n                       Berger, Gan, Li, Swallow,\
    \ Srinvasan, Work in\n                       Progress.\n   [MPLS-SHIM]       \
    \  Rosen, E., Rekhter, Y., Tappan, D., Fedorkow, G.,\n                       Farinacci,\
    \ D. and A. Conta, \"MPLS Label Stack\n                       Encoding\", RFC\
    \ 3032, January 2001.\n   [MPLS-TRFENG]       Awduche, D., Malcolm, J., Agogbua,\
    \ J., O'Dell, M.\n                       and J. McManus, \"Requirements for Traffic\n\
    \                       Engineering Over MPLS\", RFC 2702, September 1999.\n"
- title: 10. Full Copyright Statement
  contents:
  - "10. Full Copyright Statement\n   Copyright (C) The Internet Society (2001). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
