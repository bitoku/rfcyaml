- title: __initial_text__
  contents:
  - "    Generic Security Service Application Program Interface (GSS-API)\n  Authentication\
    \ and Key Exchange for the Secure Shell (SSH) Protocol\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   The Secure Shell protocol (SSH) is a protocol for secure remote\
    \ login\n   and other secure network services over an insecure network.\n   The\
    \ Generic Security Service Application Program Interface (GSS-API)\n   provides\
    \ security services to callers in a mechanism-independent\n   fashion.\n   This\
    \ memo describes methods for using the GSS-API for authentication\n   and key\
    \ exchange in SSH.  It defines an SSH user authentication\n   method that uses\
    \ a specified GSS-API mechanism to authenticate a\n   user, and a family of SSH\
    \ key exchange methods that use GSS-API to\n   authenticate a Diffie-Hellman key\
    \ exchange.\n   This memo also defines a new host public key algorithm that can\
    \ be\n   used when no operations are needed using a host's public key, and a\n\
    \   new user authentication method that allows an authorization name to\n   be\
    \ used in conjunction with any authentication that has already\n   occurred as\
    \ a side-effect of GSS-API-based key exchange.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. SSH Terminology ............................................3\n  \
    \    1.2. Key Words ..................................................3\n   2.\
    \ GSS-API-Authenticated Diffie-Hellman Key Exchange ...............3\n      2.1.\
    \ Generic GSS-API Key Exchange ...............................4\n      2.2. Group\
    \ Exchange ............................................10\n      2.3. gss-group1-sha1-*\
    \ .........................................11\n      2.4. gss-group14-sha1-* ........................................12\n\
    \      2.5. gss-gex-sha1-* ............................................12\n  \
    \    2.6. Other GSS-API Key Exchange Methods ........................12\n   3.\
    \ GSS-API User Authentication ....................................13\n      3.1.\
    \ GSS-API Authentication Overview ...........................13\n      3.2. Initiating\
    \ GSS-API Authentication .........................13\n      3.3. Initial Server\
    \ Response ...................................14\n      3.4. GSS-API Session ...........................................15\n\
    \      3.5. Binding Encryption Keys ...................................16\n  \
    \    3.6. Client Acknowledgement ....................................16\n    \
    \  3.7. Completion ................................................17\n      3.8.\
    \ Error Status ..............................................17\n      3.9. Error\
    \ Token ...............................................18\n   4. Authentication\
    \ Using GSS-API Key Exchange ......................19\n   5. Null Host Key Algorithm\
    \ ........................................20\n   6. Summary of Message Numbers\
    \ .....................................21\n   7. GSS-API Considerations .........................................22\n\
    \      7.1. Naming Conventions ........................................22\n  \
    \    7.2. Channel Bindings ..........................................22\n    \
    \  7.3. SPNEGO ....................................................23\n   8. IANA\
    \ Considerations ............................................24\n   9. Security\
    \ Considerations ........................................24\n   10. Acknowledgements\
    \ ..............................................25\n   11. References ....................................................26\n\
    \      11.1. Normative References .....................................26\n  \
    \    11.2. Informative References ...................................27\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes the methods used to perform key\
    \ exchange and\n   user authentication in the Secure Shell protocol using the\
    \ GSS-API.\n   To do this, it defines a family of key exchange methods, two user\n\
    \   authentication methods, and a new host key algorithm.  These\n   definitions\
    \ allow any GSS-API mechanism to be used with the Secure\n   Shell protocol.\n\
    \   This document should be read only after reading the documents\n   describing\
    \ the SSH protocol architecture [SSH-ARCH], transport layer\n   protocol [SSH-TRANSPORT],\
    \ and user authentication protocol\n   [SSH-USERAUTH].  This document freely uses\
    \ terminology and notation\n   from the architecture document without reference\
    \ or further\n   explanation.\n"
- title: 1.1.  SSH Terminology
  contents:
  - "1.1.  SSH Terminology\n   The data types used in the packets are defined in the\
    \ SSH\n   architecture document [SSH-ARCH].  It is particularly important to\n\
    \   note the definition of string allows binary content.\n   The SSH_MSG_USERAUTH_REQUEST\
    \ packet refers to a service; this service\n   name is an SSH service name and\
    \ has no relationship to GSS-API\n   service names.  Currently, the only defined\
    \ service name is\n   \"ssh-connection\", which refers to the SSH connection protocol\n\
    \   [SSH-CONNECT].\n"
- title: 1.2.  Key Words
  contents:
  - "1.2.  Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [KEYWORDS].\n"
- title: 2.  GSS-API-Authenticated Diffie-Hellman Key Exchange
  contents:
  - "2.  GSS-API-Authenticated Diffie-Hellman Key Exchange\n   This section defines\
    \ a class of key exchange methods that combine the\n   Diffie-Hellman key exchange\
    \ from Section 8 of [SSH-TRANSPORT] with\n   mutual authentication using GSS-API.\n\
    \   Since the GSS-API key exchange methods described in this section do\n   not\
    \ require the use of public key signature or encryption algorithms,\n   they MAY\
    \ be used with any host key algorithm, including the \"null\"\n   algorithm described\
    \ in Section 5.\n"
- title: 2.1.  Generic GSS-API Key Exchange
  contents:
  - "2.1.  Generic GSS-API Key Exchange\n   The following symbols are used in this\
    \ description:\n   o  C is the client, and S is the server\n   o  p is a large\
    \ safe prime, g is a generator for a subgroup of GF(p),\n      and q is the order\
    \ of the subgroup\n   o  V_S is S's version string, and V_C is C's version string\n\
    \   o  I_C is C's KEXINIT message, and I_S is S's KEXINIT message\n   1.  C generates\
    \ a random number x (1 < x < q) and computes e = g^x\n       mod p.\n   2.  C\
    \ calls GSS_Init_sec_context(), using the most recent reply token\n       received\
    \ from S during this exchange, if any.  For this call, the\n       client MUST\
    \ set mutual_req_flag to \"true\" to request that mutual\n       authentication\
    \ be performed.  It also MUST set integ_req_flag to\n       \"true\" to request\
    \ that per-message integrity protection be\n       supported for this context.\
    \  In addition, deleg_req_flag MAY be\n       set to \"true\" to request access\
    \ delegation, if requested by the\n       user.  Since the key exchange process\
    \ authenticates only the\n       host, the setting of anon_req_flag is immaterial\
    \ to this process.\n       If the client does not support the \"gssapi-keyex\"\
    \ user\n       authentication method described in Section 4, or does not intend\n\
    \       to use that method in conjunction with the GSS-API context\n       established\
    \ during key exchange, then anon_req_flag SHOULD be set\n       to \"true\". \
    \ Otherwise, this flag MAY be set to true if the client\n       wishes to hide\
    \ its identity.  Since the key exchange process will\n       involve the exchange\
    \ of only a single token once the context has\n       been established, it is\
    \ not necessary that the GSS-API context\n       support detection of replayed\
    \ or out-of-sequence tokens.  Thus,\n       replay_det_req_flag and sequence_req_flag\
    \ need not be set for\n       this process.  These flags SHOULD be set to \"false\"\
    .\n       *  If the resulting major_status code is GSS_S_COMPLETE and the\n  \
    \        mutual_state flag is not true, then mutual authentication has\n     \
    \     not been established, and the key exchange MUST fail.\n       *  If the\
    \ resulting major_status code is GSS_S_COMPLETE and the\n          integ_avail\
    \ flag is not true, then per-message integrity\n          protection is not available,\
    \ and the key exchange MUST fail.\n       *  If the resulting major_status code\
    \ is GSS_S_COMPLETE and both\n          the mutual_state and integ_avail flags\
    \ are true, the resulting\n          output token is sent to S.\n       *  If\
    \ the resulting major_status code is GSS_S_CONTINUE_NEEDED,\n          the output_token\
    \ is sent to S, which will reply with a new\n          token to be provided to\
    \ GSS_Init_sec_context().\n       *  The client MUST also include \"e\" with the\
    \ first message it\n          sends to the server during this process; if the\
    \ server\n          receives more than one \"e\" or none at all, the key exchange\n\
    \          fails.\n       *  It is an error if the call does not produce a token\
    \ of non-\n          zero length to be sent to the server.  In this case, the\
    \ key\n          exchange MUST fail.\n   3.  S calls GSS_Accept_sec_context(),\
    \ using the token received from\n       C.\n       *  If the resulting major_status\
    \ code is GSS_S_COMPLETE and the\n          mutual_state flag is not true, then\
    \ mutual authentication has\n          not been established, and the key exchange\
    \ MUST fail.\n       *  If the resulting major_status code is GSS_S_COMPLETE and\
    \ the\n          integ_avail flag is not true, then per-message integrity\n  \
    \        protection is not available, and the key exchange MUST fail.\n      \
    \ *  If the resulting major_status code is GSS_S_COMPLETE and both\n         \
    \ the mutual_state and integ_avail flags are true, then the\n          security\
    \ context has been established, and processing\n          continues with step\
    \ 4.\n       *  If the resulting major_status code is GSS_S_CONTINUE_NEEDED,\n\
    \          then the output token is sent to C, and processing continues\n    \
    \      with step 2.\n       *  If the resulting major_status code is GSS_S_COMPLETE,\
    \ but a\n          non-zero-length reply token is returned, then that token is\n\
    \          sent to the client.\n   4.  S generates a random number y (0 < y <\
    \ q) and computes f = g^y\n       mod p.  It computes K = e ^ y mod p, and H =\
    \ hash(V_C || V_S ||\n       I_C || I_S || K_S || e || f || K).  It then calls\
    \ GSS_GetMIC() to\n       obtain a GSS-API message integrity code for H.  S then\
    \ sends f\n       and the message integrity code (MIC) to C.\n   5.  This step\
    \ is performed only (1) if the server's final call to\n       GSS_Accept_sec_context()\
    \ produced a non-zero-length final reply\n       token to be sent to the client\
    \ and (2) if no previous call by the\n       client to GSS_Init_sec_context()\
    \ has resulted in a major_status\n       of GSS_S_COMPLETE.  Under these conditions,\
    \ the client makes an\n       additional call to GSS_Init_sec_context() to process\
    \ the final\n       reply token.  This call is made exactly as described above.\n\
    \       However, if the resulting major_status is anything other than\n      \
    \ GSS_S_COMPLETE, or a non-zero-length token is returned, it is an\n       error\
    \ and the key exchange MUST fail.\n   6.  C computes K = f^x mod p, and H = hash(V_C\
    \ || V_S || I_C || I_S\n       || K_S || e || f || K).  It then calls GSS_VerifyMIC()\
    \ to verify\n       that the MIC sent by S matches H.  If the MIC is not successfully\n\
    \       verified, the key exchange MUST fail.\n   Either side MUST NOT send or\
    \ accept e or f values that are not in the\n   range [1, p-1].  If this condition\
    \ is violated, the key exchange\n   fails.\n   If any call to GSS_Init_sec_context()\
    \ or GSS_Accept_sec_context()\n   returns a major_status other than GSS_S_COMPLETE\
    \ or\n   GSS_S_CONTINUE_NEEDED, or any other GSS-API call returns a\n   major_status\
    \ other than GSS_S_COMPLETE, the key exchange fails.  In\n   this case, several\
    \ mechanisms are available for communicating error\n   information to the peer\
    \ before terminating the connection as required\n   by [SSH-TRANSPORT]:\n   o\
    \  If the key exchange fails due to any GSS-API error on the server\n      (including\
    \ errors returned by GSS_Accept_sec_context()), the\n      server MAY send a message\
    \ informing the client of the details of\n      the error.  In this case, if an\
    \ error token is also sent (see\n      below), then this message MUST be sent\
    \ before the error token.\n   o  If the key exchange fails due to a GSS-API error\
    \ returned from the\n      server's call to GSS_Accept_sec_context(), and an \"\
    error token\" is\n      also returned, then the server SHOULD send the error token\
    \ to the\n      client to allow completion of the GSS security exchange.\n   o\
    \  If the key exchange fails due to a GSS-API error returned from the\n      client's\
    \ call to GSS_Init_sec_context(), and an \"error token\" is\n      also returned,\
    \ then the client SHOULD send the error token to the\n      server to allow completion\
    \ of the GSS security exchange.\n   As noted in Section 9, it may be desirable\
    \ under site security policy\n   to obscure information about the precise nature\
    \ of the error; thus,\n   it is RECOMMENDED that implementations provide a method\
    \ to suppress\n   these messages as a matter of policy.\n   This is implemented\
    \ with the following messages.  The hash algorithm\n   for computing the exchange\
    \ hash is defined by the method name, and is\n   called HASH.  The group used\
    \ for Diffie-Hellman key exchange and the\n   underlying GSS-API mechanism are\
    \ also defined by the method name.\n   After the client's first call to GSS_Init_sec_context(),\
    \ it sends the\n   following:\n           byte      SSH_MSG_KEXGSS_INIT\n    \
    \       string    output_token (from GSS_Init_sec_context())\n           mpint\
    \     e\n   Upon receiving the SSH_MSG_KEXGSS_INIT message, the server MAY send\n\
    \   the following message, prior to any other messages, to inform the\n   client\
    \ of its host key.\n           byte      SSH_MSG_KEXGSS_HOSTKEY\n           string\
    \    server public host key and certificates (K_S)\n   Since this key exchange\
    \ method does not require the host key to be\n   used for any encryption operations,\
    \ this message is OPTIONAL.  If the\n   \"null\" host key algorithm described\
    \ in Section 5 is used, this\n   message MUST NOT be sent.  If this message is\
    \ sent, the server public\n   host key(s) and/or certificate(s) in this message\
    \ are encoded as a\n   single string, in the format specified by the public key\
    \ type in use\n   (see [SSH-TRANSPORT], Section 6.6).\n   In traditional SSH deployments,\
    \ host keys are normally expected to\n   change infrequently, and there is often\
    \ no mechanism for validating\n   host keys not already known to the client. \
    \ As a result, the use of a\n   new host key by an already-known host is usually\
    \ considered an\n   indication of a possible man-in-the-middle attack, and clients\
    \ often\n   present strong warnings and/or abort the connection in such cases.\n\
    \   By contrast, when GSS-API-based key exchange is used, host keys sent\n   via\
    \ the SSH_MSG_KEXGSS_HOSTKEY message are authenticated as part of\n   the GSS-API\
    \ key exchange, even when previously unknown to the client.\n   Further, in environments\
    \ in which GSS-API-based key exchange is used\n   heavily, it is possible and\
    \ even likely that host keys will change\n   much more frequently and/or without\
    \ advance warning.\n   Therefore, when a new key for an already-known host is\
    \ received via\n   the SSH_MSG_KEXGSS_HOSTKEY message, clients SHOULD NOT issue\
    \ strong\n   warnings or abort the connection, provided the GSS-API-based key\n\
    \   exchange succeeds.\n   In order to facilitate key re-exchange after the user's\
    \ GSS-API\n   credentials have expired, client implementations SHOULD store host\n\
    \   keys received via SSH_MSG_KEXGSS_HOSTKEY for the duration of the\n   session,\
    \ even when such keys are not stored for long-term use.\n   Each time the server's\
    \ call to GSS_Accept_sec_context() returns a\n   major_status code of GSS_S_CONTINUE_NEEDED,\
    \ it sends the following\n   reply to the client:\n           byte      SSH_MSG_KEXGSS_CONTINUE\n\
    \           string    output_token (from GSS_Accept_sec_context())\n   If the\
    \ client receives this message after a call to\n   GSS_Init_sec_context() has\
    \ returned a major_status code of\n   GSS_S_COMPLETE, a protocol error has occurred\
    \ and the key exchange\n   MUST fail.\n   Each time the client receives the message\
    \ described above, it makes\n   another call to GSS_Init_sec_context().  It then\
    \ sends the following:\n           byte      SSH_MSG_KEXGSS_CONTINUE\n       \
    \    string    output_token (from GSS_Init_sec_context())\n   The server and client\
    \ continue to trade these two messages as long as\n   the server's calls to GSS_Accept_sec_context()\
    \ result in major_status\n   codes of GSS_S_CONTINUE_NEEDED.  When a call results\
    \ in a\n   major_status code of GSS_S_COMPLETE, it sends one of two final\n  \
    \ messages.\n   If the server's final call to GSS_Accept_sec_context() (resulting\
    \ in\n   a major_status code of GSS_S_COMPLETE) returns a non-zero-length\n  \
    \ token to be sent to the client, it sends the following:\n           byte   \
    \   SSH_MSG_KEXGSS_COMPLETE\n           mpint     f\n           string    per_msg_token\
    \ (MIC of H)\n           boolean   TRUE\n           string    output_token (from\
    \ GSS_Accept_sec_context())\n   If the client receives this message after a call\
    \ to\n   GSS_Init_sec_context() has returned a major_status code of\n   GSS_S_COMPLETE,\
    \ a protocol error has occurred and the key exchange\n   MUST fail.\n   If the\
    \ server's final call to GSS_Accept_sec_context() (resulting in\n   a major_status\
    \ code of GSS_S_COMPLETE) returns a zero-length token or\n   no token at all,\
    \ it sends the following:\n           byte      SSH_MSG_KEXGSS_COMPLETE\n    \
    \       mpint     f\n           string    per_msg_token (MIC of H)\n         \
    \  boolean   FALSE\n   If the client receives this message when no call to\n \
    \  GSS_Init_sec_context() has yet resulted in a major_status code of\n   GSS_S_COMPLETE,\
    \ a protocol error has occurred and the key exchange\n   MUST fail.\n   If either\
    \ the client's call to GSS_Init_sec_context() or the server's\n   call to GSS_Accept_sec_context()\
    \ returns an error status and produces\n   an output token (called an \"error\
    \ token\"), then the following SHOULD\n   be sent to convey the error information\
    \ to the peer:\n           byte      SSH_MSG_KEXGSS_CONTINUE\n           string\
    \    error_token\n   If a server sends both this message and an SSH_MSG_KEXGSS_ERROR\n\
    \   message, the SSH_MSG_KEXGSS_ERROR message MUST be sent first, to\n   allow\
    \ clients to record and/or display the error information before\n   processing\
    \ the error token.  This is important because a client\n   processing an error\
    \ token will likely disconnect without reading any\n   further messages.\n   In\
    \ the event of a GSS-API error on the server, the server MAY send\n   the following\
    \ message before terminating the connection:\n           byte      SSH_MSG_KEXGSS_ERROR\n\
    \           uint32    major_status\n           uint32    minor_status\n      \
    \     string    message\n           string    language tag\n   The message text\
    \ MUST be encoded in the UTF-8 encoding described in\n   [UTF8].  Language tags\
    \ are those described in [LANGTAG].  Note that\n   the message text may contain\
    \ multiple lines separated by carriage\n   return-line feed (CRLF) sequences.\
    \  Application developers should\n   take this into account when displaying these\
    \ messages.\n   The hash H is computed as the HASH hash of the concatenation of\
    \ the\n   following:\n           string    V_C, the client's version string (CR,\
    \ NL excluded)\n           string    V_S, the server's version string (CR, NL\
    \ excluded)\n           string    I_C, the payload of the client's SSH_MSG_KEXINIT\n\
    \           string    I_S, the payload of the server's SSH_MSG_KEXINIT\n     \
    \      string    K_S, the host key\n           mpint     e, exchange value sent\
    \ by the client\n           mpint     f, exchange value sent by the server\n \
    \          mpint     K, the shared secret\n   This value is called the exchange\
    \ hash, and it is used to\n   authenticate the key exchange.  The exchange hash\
    \ SHOULD be kept\n   secret.  If no SSH_MSG_KEXGSS_HOSTKEY message has been sent\
    \ by the\n   server or received by the client, then the empty string is used in\n\
    \   place of K_S when computing the exchange hash.\n   The GSS_GetMIC call MUST\
    \ be applied over H, not the original data.\n"
- title: 2.2.  Group Exchange
  contents:
  - "2.2.  Group Exchange\n   This section describes a modification to the generic\
    \ GSS-API-\n   authenticated Diffie-Hellman key exchange to allow the negotiation\
    \ of\n   the group to be used, using a method based on that described in\n   [GROUP-EXCHANGE].\n\
    \   The server keeps a list of safe primes and corresponding generators\n   that\
    \ it can select from.  These are chosen as described in Section 3\n   of [GROUP-EXCHANGE].\
    \  The client requests a modulus from the server,\n   indicating the minimum,\
    \ maximum, and preferred sizes; the server\n   responds with a suitable modulus\
    \ and generator.  The exchange then\n   proceeds as described in Section 2.1 above.\n\
    \   This description uses the following symbols, in addition to those\n   defined\
    \ above:\n   o  n is the size of the modulus p in bits that the client would like\n\
    \      to receive from the server\n   o  min and max are the minimal and maximal\
    \ sizes of p in bits that\n      are acceptable to the client\n   1.  C sends\
    \ \"min || n || max\" to S, indicating the minimal acceptable\n       group size,\
    \ the preferred size of the group, and the maximal\n       group size in bits\
    \ the client will accept.\n   2.  S finds a group that best matches the client's\
    \ request, and sends\n       \"p || g\" to C.\n   3.  The exchange proceeds as\
    \ described in Section 2.1 above,\n       beginning with step 1, except that the\
    \ exchange hash is computed\n       as described below.\n   Servers and clients\
    \ SHOULD support groups with a modulus length of k\n   bits, where 1024 <= k <=\
    \ 8192.  The recommended values for min and\n   max are 1024 and 8192, respectively.\n\
    \   This is implemented using the following messages, in addition to\n   those\
    \ described above:\n   First, the client sends:\n           byte      SSH_MSG_KEXGSS_GROUPREQ\n\
    \           uint32    min, minimal size in bits of an acceptable group\n     \
    \      uint32    n, preferred size in bits of the group the server\n         \
    \            should send\n           uint32    max, maximal size in bits of an\
    \ acceptable group\n   The server responds with:\n           byte      SSH_MSG_KEXGSS_GROUP\n\
    \           mpint     p, safe prime\n           mpint     g, generator for subgroup\
    \ in GF(p)\n   This is followed by the message exchange described above in\n \
    \  Section 2.1, except that the exchange hash H is computed as the HASH\n   hash\
    \ of the concatenation of the following:\n           string    V_C, the client's\
    \ version string (CR, NL excluded)\n           string    V_S, the server's version\
    \ string (CR, NL excluded)\n           string    I_C, the payload of the client's\
    \ SSH_MSG_KEXINIT\n           string    I_S, the payload of the server's SSH_MSG_KEXINIT\n\
    \           string    K_S, the host key\n           uint32    min, minimal size\
    \ in bits of an acceptable group\n           uint32    n, preferred size in bits\
    \ of the group the server\n                     should send\n           uint32\
    \    max, maximal size in bits of an acceptable group\n           mpint     p,\
    \ safe prime\n           mpint     g, generator for subgroup in GF(p)\n      \
    \     mpint     e, exchange value sent by the client\n           mpint     f,\
    \ exchange value sent by the server\n           mpint     K, the shared secret\n"
- title: 2.3.  gss-group1-sha1-*
  contents:
  - "2.3.  gss-group1-sha1-*\n   Each of these methods specifies GSS-API-authenticated\
    \ Diffie-Hellman\n   key exchange as described in Section 2.1 with SHA-1 as HASH,\
    \ and the\n   group defined in Section 8.1 of [SSH-TRANSPORT].  The method name\
    \ for\n   each method is the concatenation of the string \"gss-group1-sha1-\"\n\
    \   with the Base64 encoding of the MD5 hash [MD5] of the ASN.1\n   Distinguished\
    \ Encoding Rules (DER) encoding [ASN1] of the underlying\n   GSS-API mechanism's\
    \ Object Identifier (OID).  Base64 encoding is\n   described in Section 6.8 of\
    \ [MIME].\n   Each and every such key exchange method is implicitly registered\
    \ by\n   this specification.  The IESG is considered to be the owner of all\n\
    \   such key exchange methods; this does NOT imply that the IESG is\n   considered\
    \ to be the owner of the underlying GSS-API mechanism.\n"
- title: 2.4.  gss-group14-sha1-*
  contents:
  - "2.4.  gss-group14-sha1-*\n   Each of these methods specifies GSS-API authenticated\
    \ Diffie-Hellman\n   key exchange as described in Section 2.1 with SHA-1 as HASH,\
    \ and the\n   group defined in Section 8.2 of [SSH-TRANSPORT].  The method name\
    \ for\n   each method is the concatenation of the string \"gss-group14-sha1-\"\
    \n   with the Base64 encoding of the MD5 hash [MD5] of the ASN.1 DER\n   encoding\
    \ [ASN1] of the underlying GSS-API mechanism's OID.  Base64\n   encoding is described\
    \ in Section 6.8 of [MIME].\n   Each and every such key exchange method is implicitly\
    \ registered by\n   this specification.  The IESG is considered to be the owner\
    \ of all\n   such key exchange methods; this does NOT imply that the IESG is\n\
    \   considered to be the owner of the underlying GSS-API mechanism.\n"
- title: 2.5.  gss-gex-sha1-*
  contents:
  - "2.5.  gss-gex-sha1-*\n   Each of these methods specifies GSS-API-authenticated\
    \ Diffie-Hellman\n   key exchange as described in Section 2.2 with SHA-1 as HASH.\
    \  The\n   method name for each method is the concatenation of the string \"gss-\n\
    \   gex-sha1-\" with the Base64 encoding of the MD5 hash [MD5] of the\n   ASN.1\
    \ DER encoding [ASN1] of the underlying GSS-API mechanism's OID.\n   Base64 encoding\
    \ is described in Section 6.8 of [MIME].\n   Each and every such key exchange\
    \ method is implicitly registered by\n   this specification.  The IESG is considered\
    \ to be the owner of all\n   such key exchange methods; this does NOT imply that\
    \ the IESG is\n   considered to be the owner of the underlying GSS-API mechanism.\n"
- title: 2.6.  Other GSS-API Key Exchange Methods
  contents:
  - "2.6.  Other GSS-API Key Exchange Methods\n   Key exchange method names starting\
    \ with \"gss-\" are reserved for key\n   exchange methods that conform to this\
    \ document; in particular, for\n   those methods that use the GSS-API-authenticated\
    \ Diffie-Hellman key\n   exchange algorithm described in Section 2.1, including\
    \ any future\n   methods that use different groups and/or hash functions.  The\
    \ intent\n   is that the names for any such future methods be defined in a similar\n\
    \   manner to that used in Section 2.3.\n"
- title: 3.  GSS-API User Authentication
  contents:
  - "3.  GSS-API User Authentication\n   This section describes a general-purpose\
    \ user authentication method\n   based on [GSSAPI].  It is intended to be run\
    \ over the SSH user\n   authentication protocol [SSH-USERAUTH].\n   The authentication\
    \ method name for this protocol is \"gssapi-with-\n   mic\".\n"
- title: 3.1.  GSS-API Authentication Overview
  contents:
  - "3.1.  GSS-API Authentication Overview\n   GSS-API authentication must maintain\
    \ a context.  Authentication\n   begins when the client sends an SSH_MSG_USERAUTH_REQUEST,\
    \ which\n   specifies the mechanism OIDs the client supports.\n   If the server\
    \ supports any of the requested mechanism OIDs, the\n   server sends an SSH_MSG_USERAUTH_GSSAPI_RESPONSE\
    \ message containing\n   the mechanism OID.\n   After the client receives SSH_MSG_USERAUTH_GSSAPI_RESPONSE,\
    \ the\n   client and server exchange SSH_MSG_USERAUTH_GSSAPI_TOKEN packets\n \
    \  until the authentication mechanism either succeeds or fails.\n   If at any\
    \ time during the exchange the client sends a new\n   SSH_MSG_USERAUTH_REQUEST\
    \ packet, the GSS-API context is completely\n   discarded and destroyed, and any\
    \ further GSS-API authentication MUST\n   restart from the beginning.\n   If the\
    \ authentication succeeds and a non-empty user name is presented\n   by the client,\
    \ the SSH server implementation verifies that the user\n   name is authorized\
    \ based on the credentials exchanged in the GSS-API\n   exchange.  If the user\
    \ name is not authorized, then the\n   authentication MUST fail.\n"
- title: 3.2.  Initiating GSS-API Authentication
  contents:
  - "3.2.  Initiating GSS-API Authentication\n   The GSS-API authentication method\
    \ is initiated when the client sends\n   an SSH_MSG_USERAUTH_REQUEST:\n      \
    \     byte      SSH_MSG_USERAUTH_REQUEST\n           string    user name (in ISO-10646\
    \ UTF-8 encoding)\n           string    service name (in US-ASCII)\n         \
    \  string    \"gssapi-with-mic\" (US-ASCII method name)\n           uint32   \
    \ n, the number of mechanism OIDs client supports\n           string[n] mechanism\
    \ OIDs\n   Mechanism OIDs are encoded according to the ASN.1 Distinguished\n \
    \  Encoding Rules (DER), as described in [ASN1] and in Section 3.1 of\n   [GSSAPI].\
    \  The mechanism OIDs MUST be listed in order of preference,\n   and the server\
    \ must choose the first mechanism OID on the list that\n   it supports.\n   The\
    \ client SHOULD send GSS-API mechanism OIDs only for mechanisms\n   that are of\
    \ the same priority, compared to non-GSS-API authentication\n   methods.  Otherwise,\
    \ authentication methods may be executed out of\n   order.  Thus, the client could\
    \ first send an SSH_MSG_USERAUTH_REQUEST\n   for one GSS-API mechanism, then try\
    \ public key authentication, and\n   then try another GSS-API mechanism.\n   If\
    \ the server does not support any of the specified OIDs, the server\n   MUST fail\
    \ the request by sending an SSH_MSG_USERAUTH_FAILURE packet.\n   The user name\
    \ may be an empty string if it can be deduced from the\n   results of the GSS-API\
    \ authentication.  If the user name is not\n   empty, and the requested user does\
    \ not exist, the server MAY\n   disconnect or MAY send a bogus list of acceptable\
    \ authentications but\n   never accept any.  This makes it possible for the server\
    \ to avoid\n   disclosing information about which accounts exist.  In any case,\
    \ if\n   the user does not exist, the authentication request MUST NOT be\n   accepted.\n\
    \   Note that the 'user name' value is encoded in ISO-10646 UTF-8.  It is\n  \
    \ up to the server how it interprets the user name and determines\n   whether\
    \ the client is authorized based on his GSS-API credentials.\n   In particular,\
    \ the encoding used by the system for user names is a\n   matter for the ssh server\
    \ implementation.  However, if the client\n   reads the user name in some other\
    \ encoding (e.g., ISO 8859-1 - ISO\n   Latin1), it MUST convert the user name\
    \ to ISO-10646 UTF-8 before\n   transmitting, and the server MUST convert the\
    \ user name to the\n   encoding used on that system for user names.\n   Any normalization\
    \ or other preparation of names is done by the ssh\n   server based on the requirements\
    \ of the system, and is outside the\n   scope of SSH.  SSH implementations which\
    \ maintain private user\n   databases SHOULD prepare user names as described by\
    \ [SASLPREP].\n   The client MAY at any time continue with a new\n   SSH_MSG_USERAUTH_REQUEST\
    \ message, in which case the server MUST\n   abandon the previous authentication\
    \ attempt and continue with the new\n   one.\n"
- title: 3.3.  Initial Server Response
  contents:
  - "3.3.  Initial Server Response\n   The server responds to the SSH_MSG_USERAUTH_REQUEST\
    \ with either an\n   SSH_MSG_USERAUTH_FAILURE if none of the mechanisms are supported\
    \ or\n   with an SSH_MSG_USERAUTH_GSSAPI_RESPONSE as follows:\n           byte\
    \        SSH_MSG_USERAUTH_GSSAPI_RESPONSE\n           string      selected mechanism\
    \ OID\n   The mechanism OID must be one of the OIDs sent by the client in the\n\
    \   SSH_MSG_USERAUTH_REQUEST packet.\n"
- title: 3.4.  GSS-API Session
  contents:
  - "3.4.  GSS-API Session\n   Once the mechanism OID has been selected, the client\
    \ will then\n   initiate an exchange of one or more pairs of\n   SSH_MSG_USERAUTH_GSSAPI_TOKEN\
    \ packets.  These packets contain the\n   tokens produced from the 'GSS_Init_sec_context()'\
    \ and\n   'GSS_Accept_sec_context()' calls.  The actual number of packets\n  \
    \ exchanged is determined by the underlying GSS-API mechanism.\n           byte\
    \        SSH_MSG_USERAUTH_GSSAPI_TOKEN\n           string      data returned from\
    \ either GSS_Init_sec_context()\n                       or GSS_Accept_sec_context()\n\
    \   If an error occurs during this exchange on server side, the server\n   can\
    \ terminate the method by sending an SSH_MSG_USERAUTH_FAILURE\n   packet.  If\
    \ an error occurs on client side, the client can terminate\n   the method by sending\
    \ a new SSH_MSG_USERAUTH_REQUEST packet.\n   When calling GSS_Init_sec_context(),\
    \ the client MUST set\n   integ_req_flag to \"true\" to request that per-message\
    \ integrity\n   protection be supported for this context.  In addition,\n   deleg_req_flag\
    \ MAY be set to \"true\" to request access delegation, if\n   requested by the\
    \ user.\n   Since the user authentication process by its nature authenticates\n\
    \   only the client, the setting of mutual_req_flag is not needed for\n   this\
    \ process.  This flag SHOULD be set to \"false\".\n   Since the user authentication\
    \ process will involve the exchange of\n   only a single token once the context\
    \ has been established, it is not\n   necessary that the context support detection\
    \ of replayed or out-of-\n   sequence tokens.  Thus, the setting of replay_det_req_flag\
    \ and\n   sequence_req_flag are not needed for this process.  These flags\n  \
    \ SHOULD be set to \"false\".\n   Additional SSH_MSG_USERAUTH_GSSAPI_TOKEN messages\
    \ are sent if and\n   only if the calls to the GSS-API routines produce send tokens\
    \ of non-\n   zero length.\n   Any major status code other than GSS_S_COMPLETE\
    \ or\n   GSS_S_CONTINUE_NEEDED SHOULD be a failure.\n"
- title: 3.5.  Binding Encryption Keys
  contents:
  - "3.5.  Binding Encryption Keys\n   In some cases, it is possible to obtain improved\
    \ security by allowing\n   access only if the client sends a valid message integrity\
    \ code (MIC)\n   binding the GSS-API context to the keys used for encryption and\n\
    \   integrity protection of the SSH session.  With this extra level of\n   protection,\
    \ a \"man-in-the-middle\" attacker who has convinced a client\n   of his authenticity\
    \ cannot then relay user authentication messages\n   between the real client and\
    \ server, thus gaining access to the real\n   server.  This additional protection\
    \ is available when the negotiated\n   GSS-API context supports per-message integrity\
    \ protection, as\n   indicated by the setting of the integ_avail flag on successful\
    \ return\n   from GSS_Init_sec_context() or GSS_Accept_sec_context().\n   When\
    \ the client's call to GSS_Init_sec_context() returns\n   GSS_S_COMPLETE with\
    \ the integ_avail flag set, the client MUST\n   conclude the user authentication\
    \ exchange by sending the following\n   message:\n           byte      SSH_MSG_USERAUTH_GSSAPI_MIC\n\
    \           string    MIC\n   This message MUST be sent only if GSS_Init_sec_context()\
    \ returned\n   GSS_S_COMPLETE.  If a token is also returned, then the\n   SSH_MSG_USERAUTH_GSSAPI_TOKEN\
    \ message MUST be sent before this one.\n   The contents of the MIC field are\
    \ obtained by calling GSS_GetMIC()\n   over the following, using the GSS-API context\
    \ that was just\n   established:\n           string    session identifier\n  \
    \         byte      SSH_MSG_USERAUTH_REQUEST\n           string    user name\n\
    \           string    service\n           string    \"gssapi-with-mic\"\n   If\
    \ this message is received by the server before the GSS-API context\n   is fully\
    \ established, the server MUST fail the authentication.\n   If this message is\
    \ received by the server when the negotiated GSS-API\n   context does not support\
    \ per-message integrity protection, the server\n   MUST fail the authentication.\n"
- title: 3.6.  Client Acknowledgement
  contents:
  - "3.6.  Client Acknowledgement\n   Some servers may wish to permit user authentication\
    \ to proceed even\n   when the negotiated GSS-API context does not support per-message\n\
    \   integrity protection.  In such cases, it is possible for the server\n   to\
    \ successfully complete the GSS-API method, while the client's last\n   call to\
    \ GSS_Init_sec_context() fails.  If the server simply assumed\n   success on the\
    \ part of the client and completed the authentication\n   service, it is possible\
    \ that the client would fail to complete the\n   authentication method, but not\
    \ be able to retry other methods because\n   the server had already moved on.\
    \  To protect against this, a final\n   message is sent by the client to indicate\
    \ it has completed\n   authentication.\n   When the client's call to GSS_Init_sec_context()\
    \ returns\n   GSS_S_COMPLETE with the integ_avail flag not set, the client MUST\n\
    \   conclude the user authentication exchange by sending the following\n   message:\n\
    \           byte      SSH_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE\n   This message\
    \ MUST be sent only if GSS_Init_sec_context() returned\n   GSS_S_COMPLETE.  If\
    \ a token is also returned, then the\n   SSH_MSG_USERAUTH_GSSAPI_TOKEN message\
    \ MUST be sent before this one.\n   If this message is received by the server\
    \ before the GSS-API context\n   is fully established, the server MUST fail the\
    \ authentication.\n   If this message is received by the server when the negotiated\
    \ GSS-API\n   context supports per-message integrity protection, the server MUST\n\
    \   fail the authentication.\n   It is a site policy decision for the server whether\
    \ or not to permit\n   authentication using GSS-API mechanisms and/or contexts\
    \ that do not\n   support per-message integrity protection.  The server MAY fail\
    \ the\n   otherwise valid gssapi-with-mic authentication if per-message\n   integrity\
    \ protection is not supported.\n"
- title: 3.7.  Completion
  contents:
  - "3.7.  Completion\n   As with all SSH authentication methods, successful completion\
    \ is\n   indicated by an SSH_MSG_USERAUTH_SUCCESS if no other authentication\n\
    \   is required, or an SSH_MSG_USERAUTH_FAILURE with the partial success\n   flag\
    \ set if the server requires further authentication.  This packet\n   SHOULD be\
    \ sent immediately following receipt of the\n   SSH_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE\
    \ packet.\n"
- title: 3.8.  Error Status
  contents:
  - "3.8.  Error Status\n   In the event that a GSS-API error occurs on the server\
    \ during context\n   establishment, the server MAY send the following message\
    \ to inform\n   the client of the details of the error before sending an\n   SSH_MSG_USERAUTH_FAILURE\
    \ message:\n           byte      SSH_MSG_USERAUTH_GSSAPI_ERROR\n           uint32\
    \    major_status\n           uint32    minor_status\n           string    message\n\
    \           string    language tag\n   The message text MUST be encoded in the\
    \ UTF-8 encoding described in\n   [UTF8].  Language tags are those described in\
    \ [LANGTAG].  Note that\n   the message text may contain multiple lines separated\
    \ by carriage\n   return-line feed (CRLF) sequences.  Application developers should\n\
    \   take this into account when displaying these messages.\n   Clients receiving\
    \ this message MAY log the error details and/or\n   report them to the user. \
    \ Any server sending this message MUST ignore\n   any SSH_MSG_UNIMPLEMENTED sent\
    \ by the client in response.\n"
- title: 3.9.  Error Token
  contents:
  - "3.9.  Error Token\n   In the event that, during context establishment, a client's\
    \ call to\n   GSS_Init_sec_context() or a server's call to GSS_Accept_sec_context()\n\
    \   returns a token along with an error status, the resulting \"error\n   token\"\
    \ SHOULD be sent to the peer using the following message:\n           byte   \
    \     SSH_MSG_USERAUTH_GSSAPI_ERRTOK\n           string      error token\n   This\
    \ message implies that the authentication is about to fail, and is\n   defined\
    \ to allow the error token to be communicated without losing\n   synchronization.\n\
    \   When a server sends this message, it MUST be followed by an\n   SSH_MSG_USERAUTH_FAILURE\
    \ message, which is to be interpreted as\n   applying to the same authentication\
    \ request.  A client receiving this\n   message SHOULD wait for the following\
    \ SSH_MSG_USERAUTH_FAILURE\n   message before beginning another authentication\
    \ attempt.\n   When a client sends this message, it MUST be followed by a new\n\
    \   authentication request or by terminating the connection.  A server\n   receiving\
    \ this message MUST NOT send an SSH_MSG_USERAUTH_FAILURE in\n   reply, since such\
    \ a message might otherwise be interpreted by a\n   client as a response to the\
    \ following authentication sequence.\n   Any server sending this message MUST\
    \ ignore any SSH_MSG_UNIMPLEMENTED\n   sent by the client in response.  If a server\
    \ sends both this message\n   and an SSH_MSG_USERAUTH_GSSAPI_ERROR message, the\n\
    \   SSH_MSG_USERAUTH_GSSAPI_ERROR message MUST be sent first, to allow\n   the\
    \ client to store and/or display the error status before processing\n   the error\
    \ token.\n"
- title: 4.  Authentication Using GSS-API Key Exchange
  contents:
  - "4.  Authentication Using GSS-API Key Exchange\n   This section describes a user\
    \ authentication method building on the\n   framework described in [SSH-USERAUTH].\
    \  This method performs user\n   authentication by making use of an existing GSS-API\
    \ context\n   established during key exchange.\n   The authentication method name\
    \ for this protocol is \"gssapi-keyex\".\n   This method may be used only if the\
    \ initial key exchange was\n   performed using a GSS-API-based key exchange method\
    \ defined in\n   accordance with Section 2.  The GSS-API context used with this\
    \ method\n   is always that established during an initial GSS-API-based key\n\
    \   exchange.  Any context established during key exchange for the\n   purpose\
    \ of rekeying MUST NOT be used with this method.\n   The server SHOULD include\
    \ this user authentication method in the list\n   of methods that can continue\
    \ (in an SSH_MSG_USERAUTH_FAILURE) if the\n   initial key exchange was performed\
    \ using a GSS-API-based key exchange\n   method and provides information about\
    \ the user's identity that is\n   useful to the server.  It MUST NOT include this\
    \ method if the initial\n   key exchange was not performed using a GSS-API-based\
    \ key exchange\n   method defined in accordance with Section 2.\n   The client\
    \ SHOULD attempt to use this method if it is advertised by\n   the server, initial\
    \ key exchange was performed using a GSS-API-based\n   key exchange method, and\
    \ this method has not already been tried.  The\n   client SHOULD NOT try this\
    \ method more than once per session.  It\n   MUST NOT try this method if initial\
    \ key exchange was not performed\n   using a GSS-API-based key exchange method\
    \ defined in accordance with\n   Section 2.\n   If a server receives a request\
    \ for this method when initial key\n   exchange was not performed using a GSS-API-based\
    \ key exchange method\n   defined in accordance with Section 2, it MUST return\n\
    \   SSH_MSG_USERAUTH_FAILURE.\n   This method is defined as a single message:\n\
    \           byte        SSH_MSG_USERAUTH_REQUEST\n           string      user\
    \ name\n           string      service\n           string      \"gssapi-keyex\"\
    \n           string      MIC\n   The contents of the MIC field are obtained by\
    \ calling GSS_GetMIC over\n   the following, using the GSS-API context that was\
    \ established during\n   initial key exchange:\n           string      session\
    \ identifier\n           byte        SSH_MSG_USERAUTH_REQUEST\n           string\
    \      user name\n           string      service\n           string      \"gssapi-keyex\"\
    \n   Upon receiving this message when initial key exchange was performed\n   using\
    \ a GSS-API-based key exchange method, the server uses\n   GSS_VerifyMIC() to\
    \ verify that the MIC received is valid.  If the MIC\n   is not valid, the user\
    \ authentication fails, and the server MUST\n   return SSH_MSG_USERAUTH_FAILURE.\n\
    \   If the MIC is valid and the server is satisfied as to the user's\n   credentials,\
    \ it MAY return either SSH_MSG_USERAUTH_SUCCESS or\n   SSH_MSG_USERAUTH_FAILURE\
    \ with the partial success flag set, depending\n   on whether additional authentications\
    \ are needed.\n"
- title: 5.  Null Host Key Algorithm
  contents:
  - "5.  Null Host Key Algorithm\n   The \"null\" host key algorithm has no associated\
    \ host key material and\n   provides neither signature nor encryption algorithms.\
    \  Thus, it can\n   be used only with key exchange methods that do not require\
    \ any\n   public-key operations and do not require the use of host public key\n\
    \   material.  The key exchange methods described in Section 2 are\n   examples\
    \ of such methods.\n   This algorithm is used when, as a matter of configuration,\
    \ the host\n   does not have or does not wish to use a public key.  For example,\
    \ it\n   can be used when the administrator has decided as a matter of policy\n\
    \   to require that all key exchanges be authenticated using Kerberos\n   [KRB5],\
    \ and thus the only permitted key exchange method is the\n   GSS-API-authenticated\
    \ Diffie-Hellman exchange described above, with\n   Kerberos V5 as the underlying\
    \ GSS-API mechanism.  In such a\n   configuration, the server implementation supports\
    \ the \"ssh-dss\" key\n   algorithm (as required by [SSH-TRANSPORT]), but could\
    \ be prohibited\n   by configuration from using it.  In this situation, the server\
    \ needs\n   some key exchange algorithm to advertise; the \"null\" algorithm fills\n\
    \   this purpose.\n   Note that the use of the \"null\" algorithm in this way\
    \ means that the\n   server will not be able to interoperate with clients that\
    \ do not\n   support this algorithm.  This is not a significant problem, since\
    \ in\n   the configuration described, it will also be unable to interoperate\n\
    \   with implementations that do not support the GSS-API-authenticated\n   key\
    \ exchange and Kerberos.\n   Any implementation supporting at least one key exchange\
    \ method that\n   conforms to Section 2 MUST also support the \"null\" host key\n\
    \   algorithm.  Servers MUST NOT advertise the \"null\" host key algorithm\n \
    \  unless it is the only algorithm advertised.\n"
- title: 6.  Summary of Message Numbers
  contents:
  - "6.  Summary of Message Numbers\n   The following message numbers have been defined\
    \ for use with GSS-\n   API-based key exchange methods:\n          #define SSH_MSG_KEXGSS_INIT\
    \                       30\n          #define SSH_MSG_KEXGSS_CONTINUE        \
    \           31\n          #define SSH_MSG_KEXGSS_COMPLETE                   32\n\
    \          #define SSH_MSG_KEXGSS_HOSTKEY                    33\n          #define\
    \ SSH_MSG_KEXGSS_ERROR                      34\n          #define SSH_MSG_KEXGSS_GROUPREQ\
    \                   40\n          #define SSH_MSG_KEXGSS_GROUP               \
    \       41\n   The numbers 30-49 are specific to key exchange and may be redefined\n\
    \   by other kex methods.\n   The following message numbers have been defined\
    \ for use with the\n   'gssapi-with-mic' user authentication method:\n       \
    \   #define SSH_MSG_USERAUTH_GSSAPI_RESPONSE          60\n          #define SSH_MSG_USERAUTH_GSSAPI_TOKEN\
    \             61\n          #define SSH_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE\
    \ 63\n          #define SSH_MSG_USERAUTH_GSSAPI_ERROR             64\n       \
    \   #define SSH_MSG_USERAUTH_GSSAPI_ERRTOK            65\n          #define SSH_MSG_USERAUTH_GSSAPI_MIC\
    \               66\n   The numbers 60-79 are specific to user authentication and\
    \ may be\n   redefined by other user auth methods.  Note that in the method\n\
    \   described in this document, message number 62 is unused.\n"
- title: 7.  GSS-API Considerations
  contents:
  - '7.  GSS-API Considerations

    '
- title: 7.1.  Naming Conventions
  contents:
  - "7.1.  Naming Conventions\n   In order to establish a GSS-API security context,\
    \ the SSH client\n   needs to determine the appropriate targ_name to use in identifying\n\
    \   the server when calling GSS_Init_sec_context().  For this purpose,\n   the\
    \ GSS-API mechanism-independent name form for host-based services\n   is used,\
    \ as described in Section 4.1 of [GSSAPI].\n   In particular, the targ_name to\
    \ pass to GSS_Init_sec_context() is\n   obtained by calling GSS_Import_name()\
    \ with an input_name_type of\n   GSS_C_NT_HOSTBASED_SERVICE, and an input_name_string\
    \ consisting of\n   the string \"host@\" concatenated with the hostname of the\
    \ SSH server.\n   Because the GSS-API mechanism uses the targ_name to authenticate\
    \ the\n   server's identity, it is important that it be determined in a secure\n\
    \   fashion.  One common way to do this is to construct the targ_name\n   from\
    \ the hostname as typed by the user; unfortunately, because some\n   GSS-API mechanisms\
    \ do not canonicalize hostnames, it is likely that\n   this technique will fail\
    \ if the user has not typed a fully-qualified,\n   canonical hostname.  Thus,\
    \ implementers may wish to use other\n   methods, but should take care to ensure\
    \ they are secure.  For\n   example, one should not rely on an unprotected DNS\
    \ record to map a\n   host alias to the primary name of a server, or an IP address\
    \ to a\n   hostname, since an attacker can modify the mapping and impersonate\n\
    \   the server.\n   Implementations of mechanisms conforming to this document\
    \ MUST NOT\n   use the results of insecure DNS queries to construct the targ_name.\n\
    \   Clients MAY make use of a mapping provided by local configuration or\n   use\
    \ other secure means to determine the targ_name to be used.  If a\n   client system\
    \ is unable to securely determine which targ_name to use,\n   then it SHOULD NOT\
    \ use this mechanism.\n"
- title: 7.2.  Channel Bindings
  contents:
  - "7.2.  Channel Bindings\n   This document recommends that channel bindings SHOULD\
    \ NOT be\n   specified in the calls during context establishment.  This document\n\
    \   does not specify any standard data to be used as channel bindings,\n   and\
    \ the use of network addresses as channel bindings may break SSH in\n   environments\
    \ where it is most useful.\n"
- title: 7.3.  SPNEGO
  contents:
  - "7.3.  SPNEGO\n   The use of the Simple and Protected GSS-API Negotiation Mechanism\n\
    \   [SPNEGO] in conjunction with the authentication and key exchange\n   methods\
    \ described in this document is both unnecessary and\n   undesirable.  As a result,\
    \ mechanisms conforming to this document\n   MUST NOT use SPNEGO as the underlying\
    \ GSS-API mechanism.\n   Since SSH performs its own negotiation of authentication\
    \ and key\n   exchange methods, the negotiation capability of SPNEGO alone does\
    \ not\n   provide any added benefit.  In fact, as described below, it has the\n\
    \   potential to result in the use of a weaker method than desired.\n   Normally,\
    \ SPNEGO provides the added benefit of protecting the GSS-API\n   mechanism negotiation.\
    \  It does this by having the server compute a\n   MIC of the list of mechanisms\
    \ proposed by the client, and then\n   checking that value at the client.  In\
    \ the case of key exchange, this\n   protection is not needed because the key\
    \ exchange methods described\n   here already perform an equivalent operation;\
    \ namely, they generate a\n   MIC of the SSH exchange hash, which is a hash of\
    \ several items\n   including the lists of key exchange mechanisms supported by\
    \ both\n   sides.  In the case of user authentication, the protection is not\n\
    \   needed because the negotiation occurs over a secure channel, and the\n   host's\
    \ identity has already been proved to the user.\n   The use of SPNEGO combined\
    \ with GSS-API mechanisms used without\n   SPNEGO can lead to interoperability\
    \ problems.  For example, a client\n   that supports key exchange using the Kerberos\
    \ V5 GSS-API mechanism\n   [KRB5-GSS] only underneath SPNEGO will not interoperate\
    \ with a server\n   that supports key exchange only using the Kerberos V5 GSS-API\n\
    \   mechanism directly.  As a result, allowing GSS-API mechanisms to be\n   used\
    \ both with and without SPNEGO is undesirable.\n   If a client's policy is to\
    \ first prefer GSS-API-based key exchange\n   method X, then non-GSS-API method\
    \ Y, then GSS-API-based method Z, and\n   if a server supports mechanisms Y and\
    \ Z but not X, then an attempt to\n   use SPNEGO to negotiate a GSS-API mechanism\
    \ might result in the use\n   of method Z when method Y would have been preferable.\
    \  As a result,\n   the use of SPNEGO could result in the subversion of the negotiation\n\
    \   algorithm for key exchange methods as described in Section 7.1 of\n   [SSH-TRANSPORT]\
    \ and/or the negotiation algorithm for user\n   authentication methods as described\
    \ in [SSH-USERAUTH].\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   Consistent with Section 8 of [SSH-ARCH] and Section\
    \ 4.6 of\n   [SSH-NUMBERS], this document makes the following registrations:\n\
    \      The family of SSH key exchange method names beginning with \"gss-\n   \
    \   group1-sha1-\" and not containing the at-sign ('@'), to name the\n      key\
    \ exchange methods defined in Section 2.3.\n      The family of SSH key exchange\
    \ method names beginning with \"gss-\n      gex-sha1-\" and not containing the\
    \ at-sign ('@'), to name the key\n      exchange methods defined in Section 2.5.\n\
    \      All other SSH key exchange method names beginning with \"gss-\" and\n \
    \     not containing the at-sign ('@'), to be reserved for future key\n      exchange\
    \ methods defined in conformance with this document, as\n      noted in Section\
    \ 2.6.\n      The SSH host public key algorithm name \"null\", to name the NULL\n\
    \      host key algorithm defined in Section 5.\n      The SSH user authentication\
    \ method name \"gssapi-with-mic\", to name\n      the GSS-API user authentication\
    \ method defined in Section 3.\n      The SSH user authentication method name\
    \ \"gssapi-keyex\", to name\n      the GSS-API user authentication method defined\
    \ in Section 4.\n      The SSH user authentication method name \"gssapi\" is to\
    \ be\n      reserved, in order to avoid conflicts with implementations\n     \
    \ supporting an earlier version of this specification.\n      The SSH user authentication\
    \ method name \"external-keyx\" is to be\n      reserved, in order to avoid conflicts\
    \ with implementations\n      supporting an earlier version of this specification.\n\
    \   This document creates no new registries.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This document describes authentication and key-exchange\
    \ protocols.\n   As such, security considerations are discussed throughout.\n\
    \   This protocol depends on the SSH protocol itself, the GSS-API, any\n   underlying\
    \ GSS-API mechanisms that are used, and any protocols on\n   which such mechanisms\
    \ might depend.  Each of these components plays a\n   part in the security of\
    \ the resulting connection, and each will have\n   its own security considerations.\n\
    \   The key exchange method described in Section 2 depends on the\n   underlying\
    \ GSS-API mechanism to provide both mutual authentication\n   and per-message\
    \ integrity services.  If either of these features is\n   not supported by a particular\
    \ GSS-API mechanism, or by a particular\n   implementation of a GSS-API mechanism,\
    \ then the key exchange is not\n   secure and MUST fail.\n   In order for the\
    \ \"external-keyx\" user authentication method to be\n   used, it MUST have access\
    \ to user authentication information obtained\n   as a side-effect of the key\
    \ exchange.  If this information is\n   unavailable, the authentication MUST fail.\n\
    \   Revealing information about the reason for an authentication failure\n   may\
    \ be considered by some sites to be an unacceptable security risk\n   for a production\
    \ environment.  However, having that information\n   available can be invaluable\
    \ for debugging purposes.  Thus, it is\n   RECOMMENDED that implementations provide\
    \ a means for controlling, as\n   a matter of policy, whether to send SSH_MSG_USERAUTH_GSSAPI_ERROR,\n\
    \   SSH_MSG_USERAUTH_GSSAPI_ERRTOK, and SSH_MSG_KEXGSS_ERROR messages,\n   and\
    \ SSH_MSG_KEXGSS_CONTINUE messages containing a GSS-API error\n   token.\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   The authors would like to thank the following individuals\
    \ for their\n   invaluable assistance and contributions to this document:\n  \
    \ o  Sam Hartman\n   o  Love Hornquist-Astrand\n   o  Joel N. Weber II\n   o \
    \ Simon Wilkinson\n   o  Nicolas Williams\n   Much of the text describing DH group\
    \ exchange was borrowed from\n   [GROUP-EXCHANGE], by Markus Friedl, Niels Provos,\
    \ and William A.\n   Simpson.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [ASN1]            ISO/IEC, \"ASN.1 Encoding Rules:\
    \ Specification of\n                     Basic Encoding Rules (BER), Canonical\
    \ Encoding\n                     Rules (CER) and Distinguished Encoding Rules\n\
    \                     (DER)\", ITU-T Recommendation X.690 (1997), ISO/\n     \
    \                IEC 8825-1:1998, November 1998.\n   [GROUP-EXCHANGE]  Friedl,\
    \ M., Provos, N., and W. Simpson, \"Diffie-\n                     Hellman Group\
    \ Exchange for the Secure Shell (SSH)\n                     Transport Layer Protocol\"\
    , RFC 4419, March 2006.\n   [GSSAPI]          Linn, J., \"Generic Security Service\
    \ Application\n                     Program Interface Version 2, Update 1\", RFC\
    \ 2743,\n                     January 2000.\n   [KEYWORDS]        Bradner, S.,\
    \ \"Key words for use in RFCs to Indicate\n                     Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [LANGTAG]         Alvestrand, H., \"Tags for\
    \ the Identification of\n                     Languages\", BCP 47, RFC 3066, January\
    \ 2001.\n   [MD5]             Rivest, R., \"The MD5 Message-Digest Algorithm\"\
    , RFC\n                     1321, April 1992.\n   [MIME]            Freed, N.\
    \ and N. Borenstein, \"Multipurpose Internet\n                     Mail Extensions\
    \ (MIME) Part One: Format of Internet\n                     Message Bodies\",\
    \ RFC 2045, November 1996.\n   [SSH-ARCH]        Ylonen, T. and C. Lonvick, \"\
    The Secure Shell (SSH)\n                     Protocol Architecture\", RFC 4251,\
    \ January 2006.\n   [SSH-CONNECT]     Ylonen, T. and C. Lonvick, \"The Secure\
    \ Shell (SSH)\n                     Connection Protocol\", RFC 4254, January 2006.\n\
    \   [SSH-NUMBERS]     Lehtinen, S. and C. Lonvick, \"The Secure Shell\n      \
    \               (SSH) Protocol Assigned Numbers\", RFC 4250, January\n       \
    \              2006.\n   [SSH-TRANSPORT]   Ylonen, T. and C. Lonvick, \"The Secure\
    \ Shell (SSH)\n                     Transport Layer Protocol\", RFC 4253, January\
    \ 2006.\n   [SSH-USERAUTH]    Ylonen, T. and C. Lonvick, \"The Secure Shell (SSH)\n\
    \                     Authentication Protocol\", RFC 4252, January 2006.\n   [UTF8]\
    \            Yergeau, F., \"UTF-8, a transformation format of ISO\n          \
    \           10646\", STD 63, RFC 3629, November 2003.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [KRB5]            Neuman, C., Yu, T., Hartman,\
    \ S., and K. Raeburn,\n                     \"The Kerberos Network Authentication\
    \ Service (V5)\",\n                     RFC 4120, July 2005.\n   [KRB5-GSS]  \
    \      Zhu, L., Jaganathan, K., and S. Hartman, \"The\n                     Kerberos\
    \ Version 5 Generic Security Service\n                     Application Program\
    \ Interface (GSS-API) Mechanism:\n                     Version 2\", RFC 4121,\
    \ July 2005.\n   [SASLPREP]        Zeilenga, K., \"SASLprep: Stringprep Profile\
    \ for\n                     User Names and Passwords\", RFC 4013, February 2005.\n\
    \   [SPNEGO]          Zhu, L., Leach, P., Jaganathan, K., and W.\n           \
    \          Ingersoll, \"The Simple and Protected Generic\n                   \
    \  Security Service Application Program Interface\n                     (GSS-API)\
    \ Negotiation Mechanism\", RFC 4178, October\n                     2005.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jeffrey Hutzelman\n   Carnegie Mellon University\n   5000\
    \ Forbes Ave\n   Pittsburgh, PA  15213\n   US\n   Phone: +1 412 268 7225\n   EMail:\
    \ jhutz+@cmu.edu\n   URI:   http://www.cs.cmu.edu/~jhutz/\n   Joseph Salowey\n\
    \   Cisco Systems\n   2901 Third Avenue\n   Seattle, WA  98121\n   US\n   Phone:\
    \ +1 206 256 3380\n   EMail: jsalowey@cisco.com\n   Joseph Galbraith\n   Van Dyke\
    \ Technologies, Inc.\n   4848 Tramway Ridge Dr. NE\n   Suite 101\n   Albuquerque,\
    \ NM  87111\n   US\n   EMail: galb@vandyke.com\n   Von Welch\n   University of\
    \ Chicago & Argonne National Laboratory\n   Distributed Systems Laboratory\n \
    \  701 E. Washington\n   Urbana, IL  61801\n   US\n   EMail: welch@mcs.anl.gov\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
