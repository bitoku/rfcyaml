- title: __initial_text__
  contents:
  - "     Obtaining and Using Globally Routable User Agent URIs (GRUUs)\n        \
    \        in the Session Initiation Protocol (SIP)\n"
- title: Abstract
  contents:
  - "Abstract\n   Several applications of the Session Initiation Protocol (SIP) require\n\
    \   a user agent (UA) to construct and distribute a URI that can be used\n   by\
    \ anyone on the Internet to route a call to that specific UA\n   instance.  A\
    \ URI that routes to a specific UA instance is called a\n   Globally Routable\
    \ UA URI (GRUU).  This document describes an\n   extension to SIP for obtaining\
    \ a GRUU from a registrar and for\n   communicating a GRUU to a peer within a\
    \ dialog.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the BSD License.\n   This document may\
    \ contain material from IETF Documents or IETF\n   Contributions published or\
    \ made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  5\n   3.  Overview of Operation  . . . . . . . . . . . . . . . .\
    \ . . . .  5\n     3.1.  Structure of GRUUs . . . . . . . . . . . . . . . . .\
    \ . . .  5\n       3.1.1.  GRUUs That Expose the Underlying AOR . . . . . . .\
    \ . .  6\n       3.1.2.  GRUUs That Hide the Underlying AOR . . . . . . . . .\
    \ .  6\n     3.2.  Obtaining a GRUU . . . . . . . . . . . . . . . . . . . . .\
    \  7\n     3.3.  Using a GRUU . . . . . . . . . . . . . . . . . . . . . . .  8\n\
    \     3.4.  Dereferencing a GRUU . . . . . . . . . . . . . . . . . . .  8\n  \
    \ 4.  User Agent Behavior  . . . . . . . . . . . . . . . . . . . . .  9\n    \
    \ 4.1.  Generating a REGISTER Request  . . . . . . . . . . . . . .  9\n     4.2.\
    \  Learning GRUUs from REGISTER Responses . . . . . . . . . . 10\n     4.3.  Constructing\
    \ a Self-Made GRUU  . . . . . . . . . . . . . . 11\n     4.4.  Using One's Own\
    \ GRUUs  . . . . . . . . . . . . . . . . . . 12\n       4.4.1.  Considerations\
    \ for Multiple AORs . . . . . . . . . . . 13\n     4.5.  Dereferencing a GRUU\
    \ . . . . . . . . . . . . . . . . . . . 14\n     4.6.  Rendering GRUUs on a User\
    \ Interface  . . . . . . . . . . . 14\n   5.  Registrar Behavior . . . . . . .\
    \ . . . . . . . . . . . . . . . 14\n     5.1.  Processing a REGISTER Request \
    \ . . . . . . . . . . . . . . 14\n     5.2.  Generating a REGISTER Response .\
    \ . . . . . . . . . . . . . 16\n     5.3.  Timing Out a Registration  . . . .\
    \ . . . . . . . . . . . . 16\n     5.4.  Creation of a GRUU . . . . . . . . .\
    \ . . . . . . . . . . . 17\n     5.5.  Registration Event Support . . . . . .\
    \ . . . . . . . . . . 19\n   6.  Proxy Behavior . . . . . . . . . . . . . . .\
    \ . . . . . . . . . 19\n     6.1.  Request Targeting  . . . . . . . . . . . .\
    \ . . . . . . . . 19\n     6.2.  Record-Routing . . . . . . . . . . . . . . .\
    \ . . . . . . . 21\n   7.  Grammar  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 23\n   8.  Requirements . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . 23\n   9.  Example Call Flow  . . . . . . . . . . . . . . . . . .\
    \ . . . . 24\n   10. Security Considerations  . . . . . . . . . . . . . . . .\
    \ . . . 29\n     10.1. Outside Attacks  . . . . . . . . . . . . . . . . . . .\
    \ . . 29\n     10.2. Inside Attacks . . . . . . . . . . . . . . . . . . . . .\
    \ . 30\n     10.3. Privacy Considerations . . . . . . . . . . . . . . . . . .\
    \ 31\n   11. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 33\n\
    \     11.1. Header Field Parameter . . . . . . . . . . . . . . . . . . 33\n  \
    \   11.2. URI Parameter  . . . . . . . . . . . . . . . . . . . . . . 33\n    \
    \ 11.3. SIP Option Tag . . . . . . . . . . . . . . . . . . . . . . 33\n   12.\
    \ Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 34\n   13. References\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n     13.1. Normative\
    \ References . . . . . . . . . . . . . . . . . . . 34\n     13.2. Informative\
    \ References . . . . . . . . . . . . . . . . . . 35\n   Appendix A.  Example GRUU\
    \ Construction Algorithms  . . . . . . . . 37\n     A.1.  Public GRUU  . . . .\
    \ . . . . . . . . . . . . . . . . . . . 37\n     A.2.  Temporary GRUU . . . .\
    \ . . . . . . . . . . . . . . . . . . 37\n   Appendix B.  Network Design Considerations\
    \ . . . . . . . . . . . . 39\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In the Session Initiation Protocol (SIP), RFC 3261 [1],\
    \ the basic\n   unit of reference is the Address of Record (AOR).  However, in\
    \ SIP\n   systems a single user can have a number of user agents (handsets,\n\
    \   softphones, voicemail accounts, etc.) that are all referenced by the\n   same\
    \ AOR.  There are a number of contexts in which it is desirable to\n   have an\
    \ identifier that addresses a single user agent rather than the\n   group of user\
    \ agents indicated by an AOR.\n   As an example, consider a blind transfer application\
    \ (see RFC 5589\n   [19]).  User A is talking to user B.  User A wants to transfer\
    \ the\n   call to user C.  So, user A sends a REFER to user C.  That REFER\n \
    \  looks like, in part:\n       REFER sip:C@example.com SIP/2.0\n       From:\
    \ sip:A@example.com;tag=99asd\n       To: sip:C@example.com\n       Refer-To:\
    \ (URI that identifies B's UA)\n   The Refer-To header field needs to contain\
    \ a URI that can be used by\n   user C to place a call to user B.  However, this\
    \ call needs to route\n   to the specific UA instance that user B is using to\
    \ talk to user A.\n   If it doesn't, the transfer service will not execute properly.\
    \  For\n   example, if A provides C with B's AOR, the call might be routed to\n\
    \   B's voicemail rather than B's current handset.\n   In order to enable this\
    \ functionality, user B provides an instance-\n   specific URI to user A in the\
    \ Contact header of their SIP exchange.\n   This URI refers to the user agent\
    \ B is currently using, and it can be\n   dereferenced by C's user agent.  Because\
    \ user B doesn't know in\n   advance who user A will transfer the call to, the\
    \ URI has to be\n   usable by anyone.\n   Many current clients attempt to meet\
    \ the need for an instance-\n   specific identifier by using explicit IP addresses\
    \ in the values they\n   provide in the Contact header field.  However, this interacts\
    \ poorly\n   with NATs and firewalls, and as a practical matter, these URIs cannot\n\
    \   be used by arbitrary external clients.  Usage of hostnames has proven\n  \
    \ problematic for similar reasons.  In addition, many SIP clients do\n   not have\
    \ or cannot obtain a hostname for themselves at all.\n   This specification describes\
    \ a mechanism for providing a unique user-\n   agent identifier which is still\
    \ globally routable.  This identifier\n   is called a Globally Routable User Agent\
    \ (UA) URI (GRUU).\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [4].\n   This specification defines the following additional terms:\n \
    \  contact:  The term \"contact\", when used in all lowercase, refers to a\n \
    \     URI that is bound to an AOR and GRUU by means of a registration.\n     \
    \ A contact is usually a SIP URI, and is bound to the AOR and GRUU\n      through\
    \ a REGISTER request by appearing as a value of the Contact\n      header field.\
    \  The contact URI identifies a specific UA.\n   remote target:  The term \"remote\
    \ target\" refers to a URI that a user\n      agent uses to identify itself for\
    \ receipt of both mid-dialog and\n      out-of-dialog requests.  A remote target\
    \ is established by placing\n      a URI in the Contact header field of a dialog-forming\
    \ request or\n      response and is updated by target refresh requests or responses.\n\
    \   Contact header field:  The term \"Contact header field\", with a\n      capitalized\
    \ C, refers to the header field that can appear in\n      REGISTER requests and\
    \ responses, redirects, or dialog-creating\n      requests and responses.  Depending\
    \ on the semantics, the Contact\n      header field sometimes conveys a contact,\
    \ and sometimes conveys a\n      remote target.\n"
- title: 3.  Overview of Operation
  contents:
  - "3.  Overview of Operation\n   The basic idea behind a GRUU is simple.  GRUUs\
    \ are issued by SIP\n   domains and always route back to a proxy in that domain.\
    \  In turn,\n   the domain maintains the binding between the GRUU and the particular\n\
    \   UA instance.  When a GRUU is dereferenced while sending a SIP\n   request,\
    \ that request arrives at the proxy.  It maps the GRUU to the\n   contact for\
    \ the particular UA instance, and sends the request there.\n"
- title: 3.1.  Structure of GRUUs
  contents:
  - "3.1.  Structure of GRUUs\n   A GRUU is a SIP URI that has two properties:\n \
    \  o  It routes to a specific UA instance.\n   o  It can be successfully dereferenced\
    \ by any user agent on the\n      Internet, not just ones in the same domain or\
    \ IP network as the UA\n      instance to which the GRUU points.\n   In principle,\
    \ a GRUU can be constructed in any way the domain\n   chooses, as long as it meets\
    \ the criteria above.  However, all GRUUs\n   contain the \"gr\" URI parameter\
    \ (either with or without a value), so\n   that a recipient of a GRUU can tell\
    \ that it has these two properties.\n   In practice, there are two different types\
    \ of GRUUs:\n   1.  GRUUs that expose the underlying AOR\n   2.  GRUUs that hide\
    \ the underlying AOR\n"
- title: 3.1.1.  GRUUs That Expose the Underlying AOR
  contents:
  - "3.1.1.  GRUUs That Expose the Underlying AOR\n   In many cases, it is desirable\
    \ to construct the GRUU in such a way\n   that the mapping to the AOR is apparent.\
    \  For example, many user\n   agents retain call logs, which keep track of incoming\
    \ and outgoing\n   call attempts.  If the UA had made a call to a GRUU (perhaps\
    \ as a\n   consequence of a transfer request), the call log will contain the\n\
    \   GRUU.  Since the call log is rendered to the user, it would be useful\n  \
    \ to be able to present the user with the AOR instead, since the AOR is\n   meaningful\
    \ to users as an identifier.\n   This type of GRUU is called a public GRUU.  It\
    \ is constructed by\n   taking the AOR, and adding the \"gr\" URI parameter with\
    \ a value chosen\n   by the registrar in the domain.  The value of the \"gr\"\
    \ URI parameter\n   contains a representation of the UA instance.  For instance,\
    \ if the\n   AOR was \"sip:alice@example.com\", the GRUU might be:\n       sip:alice@example.com;gr=kjh29x97us97d\n\
    \   If a UA removes the \"gr\" URI parameter, the result is the AOR.  Since\n\
    \   many systems ignore unknown parameters anyway, a public GRUU will\n   \"look\"\
    \ like the AOR to those systems.\n"
- title: 3.1.2.  GRUUs That Hide the Underlying AOR
  contents:
  - "3.1.2.  GRUUs That Hide the Underlying AOR\n   In other cases, it is desirable\
    \ to construct a GRUU that obfuscates\n   the AOR such that it cannot be extracted\
    \ by a recipient of the GRUU.\n   Such a GRUU is called a temporary GRUU.  The\
    \ most obvious reason to\n   do this is to protect the user's privacy.  In such\
    \ cases, the GRUU\n   can have any content, provided that it meets the requirements\
    \ in\n   Sections 3.1 and 5.4, and the AOR cannot be readily determined from\n\
    \   the GRUU.  The GRUU will have the \"gr\" URI parameter, either with or\n \
    \  without a value.  In order to avoid creating excessive state in the\n   registrar,\
    \ it is often desirable to construct cryptographically\n   protected \"stateless\"\
    \ GRUUs using an algorithm like that described in\n   Appendix A.\n   An example\
    \ of a temporary GRUU constructed using a stateful algorithm\n   would be:\n \
    \      sip:asd887f9dfkk76690@example.com;gr\n"
- title: 3.2.  Obtaining a GRUU
  contents:
  - "3.2.  Obtaining a GRUU\n   A user agent can obtain a GRUU in one of several ways:\n\
    \   o  As part of its REGISTER transaction.\n   o  By constructing one locally,\
    \ using the IP address or hostname of\n      the user agent instance as the domain\
    \ part of the URI.  These are\n      called self-made GRUUs, and are only really\
    \ GRUUs when constructed\n      by UAs that know they are globally reachable using\
    \ their IP\n      address or hostname.\n   o  Via some locally specified administrative\
    \ mechanism.\n   A UA that wants to obtain a GRUU via its REGISTER request does\
    \ so by\n   providing an instance ID in the \"+sip.instance\" Contact header field\n\
    \   parameter, defined in RFC 5626 [14].  For example:\n        Contact: <sip:callee@192.0.2.2>\n\
    \        ;+sip.instance=\"<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>\"\n\
    \   The registrar detects this header field parameter and provides two\n   GRUUs\
    \ in the REGISTER response.  One of these is a temporary GRUU,\n   and the other\
    \ is the public GRUU.  These two GRUUs are returned in\n   the \"temp-gruu\" and\
    \ \"pub-gruu\" Contact header field parameters in the\n   response, respectively.\
    \  For example:\n   <allOneLine>\n   Contact: <sip:callee@192.0.2.2>\n   ;pub-gruu=\"\
    sip:callee@example.com;gr=urn:\n   uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"\
    \n   ;temp-gruu=\"sip:tgruu.7hs==\n   jd7vnzga5w7fajsc7-ajd6fabz0f8g5@example.com;gr\"\
    \n   ;+sip.instance=\"<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>\"\n   ;expires=3600\n\
    \   </allOneLine>\n   Note that the <allOneLine> tag is used as defined in [17].\n\
    \   When a user agent refreshes this registration prior to its\n   expiration,\
    \ the registrar will return back the same public GRUU, but\n   will create a new\
    \ temporary GRUU.  Despite the fact that each refresh\n   provides the UA with\
    \ a new temporary GRUU, all of the temporary GRUUs\n   learned from previous REGISTER\
    \ responses during the lifetime of a\n   contact remain valid as long as (1) a\
    \ contact with that instance ID\n   remains registered, and (2) the UA doesn't\
    \ change the Call-ID in its\n   REGISTER request compared to previous ones for\
    \ the same reg-id [14].\n   When the last contact for the instance expires, either\
    \ through\n   explicit de-registration or timeout, all of the temporary GRUUs\n\
    \   become invalidated.  Similarly, if a register refresh for a contact\n   (or,\
    \ if RFC 5626 is being used, for a reg-id) changes the Call-ID\n   compared to\
    \ previous register refreshes, all of the previous\n   temporary GRUUs are invalidated.\
    \  When the user agent later creates a\n   new registration with the same instance\
    \ ID, the public GRUU is the\n   same.  The temporary GRUU will be new (as it\
    \ is with refreshes), and\n   it will be the only valid temporary GRUU for the\
    \ instance until the\n   next refresh, at which point a second one becomes valid\
    \ too.\n   Consequently, temporary GRUUs \"accumulate\" during the lifetime of\
    \ a\n   registration.\n"
- title: 3.3.  Using a GRUU
  contents:
  - "3.3.  Using a GRUU\n   Once a user agent obtains GRUUs from the registrar, it\
    \ uses them in\n   several ways.  First, it uses them as the contents of the Contact\n\
    \   header field in non-REGISTER requests and responses that it emits\n   (for\
    \ example, an INVITE request and 200 OK response).  According to\n   RFC 3261\
    \ [1], the Contact header field is supposed to contain a URI\n   that routes to\
    \ that user agent.  Prior to this specification, there\n   hasn't been a way to\
    \ really meet that requirement.  The user agent\n   would use one of its temporary\
    \ GRUUs for anonymous calls, and use its\n   public GRUU otherwise.\n   Second,\
    \ the UA can use the GRUU in any other place it needs to use a\n   URI that resolves\
    \ to itself, such as a webpage.\n"
- title: 3.4.  Dereferencing a GRUU
  contents:
  - "3.4.  Dereferencing a GRUU\n   Because a GRUU is simply a URI, a UA dereferences\
    \ it in exactly the\n   same way as it would any other URI.  However, once the\
    \ request has\n   been routed to the appropriate proxy, the behavior is slightly\n\
    \   different.  The proxy will map the GRUU to the AOR and determine the\n   set\
    \ of contacts that the particular UA instance has registered.  The\n   GRUU is\
    \ then mapped to those contacts, and the request is routed\n   towards the UA.\n"
- title: 4.  User Agent Behavior
  contents:
  - "4.  User Agent Behavior\n   This section defines the normative behavior for user\
    \ agents.\n"
- title: 4.1.  Generating a REGISTER Request
  contents:
  - "4.1.  Generating a REGISTER Request\n   When a UA compliant to this specification\
    \ generates a REGISTER\n   request (initial or refresh), it MUST include the Supported\
    \ header\n   field in the request.  The value of that header field MUST include\n\
    \   \"gruu\" as one of the option tags.  This alerts the registrar for the\n \
    \  domain that the UA supports the GRUU mechanism.\n   Furthermore, for each contact\
    \ for which the UA desires to obtain a\n   GRUU, the UA MUST include a \"sip.instance\"\
    \ media feature tag (see RFC\n   5626 [14]) as a UA characteristic (see [7]),\
    \ whose value MUST be the\n   instance ID that identifies the UA instance being\
    \ registered.  Each\n   such Contact header field SHOULD NOT contain a \"pub-gruu\"\
    \ or \"temp-\n   gruu\" header field.  The contact URI MUST NOT be equivalent,\
    \ based on\n   the URI equality rules in RFC 3261 [1], to the AOR in the To header\n\
    \   field.  If the contact URI is a GRUU, it MUST NOT be a GRUU for the\n   AOR\
    \ in the To header field.\n   As in RFC 3261 [1], the Call-ID in a REGISTER refresh\
    \ SHOULD be\n   identical to the Call-ID used to previously register a contact.\
    \  With\n   GRUU, an additional consideration applies.  If the Call-ID changes\
    \ in\n   a register refresh, the server will invalidate all temporary GRUUs\n\
    \   associated with that UA instance; the only valid one will be the new\n   one\
    \ returned in that REGISTER response.  When RFC 5626 is in use,\n   this rule\
    \ applies to the reg-ids: If the Call-ID changes for the\n   registration refresh\
    \ for a particular reg-id, the server will\n   invalidate all temporary GRUUs\
    \ associated with that UA instance as a\n   whole.  Consequently, if a UA wishes\
    \ its previously obtained\n   temporary GRUUs to remain valid, it MUST utilize\
    \ the same Call-ID in\n   REGISTER refreshes.  However, it MAY change the Call-ID\
    \ in a refresh\n   if invalidation is the desired objective.\n   Note that, if\
    \ any dialogs are in progress that utilize a temporary\n   GRUU as a remote target,\
    \ and a UA performs a registration refresh\n   with a change in Call-ID, those\
    \ temporary GRUUs become invalid, and\n   the UA will not be reachable for subsequent\
    \ mid-dialog messages.\n   If a UA instance is trying to register multiple contacts\
    \ for the same\n   instance for the purposes of redundancy, it MUST use the procedures\n\
    \   defined in RFC 5626 [14].\n      A UA utilizing GRUUs can still perform third-party\
    \ registrations\n      and can include contacts that omit the \"+sip.instance\"\
    \ Contact\n      header field parameter.\n   If a UA wishes to guarantee that\
    \ the REGISTER request is not\n   processed unless the domain supports and uses\
    \ this extension, it MAY\n   include a Require header field in the request with\
    \ a value that\n   contains the \"gruu\" option tag.  This is in addition to the\
    \ presence\n   of the Supported header field, also containing the \"gruu\" option\
    \ tag.\n   The use of Proxy-Require is not necessary and is NOT RECOMMENDED.\n"
- title: 4.2.  Learning GRUUs from REGISTER Responses
  contents:
  - "4.2.  Learning GRUUs from REGISTER Responses\n   If the REGISTER response is\
    \ a 2xx, each Contact header field that\n   contains the \"+sip.instance\" Contact\
    \ header field parameter can also\n   contain a \"pub-gruu\" and \"temp-gruu\"\
    \ Contact header field parameter.\n   These header field parameters convey the\
    \ public and a temporary GRUU\n   for the UA instance, respectively.  A UA MUST\
    \ be prepared for a\n   Contact header field to contain just a \"pub-gruu\", just\
    \ a \"temp-\n   gruu\", neither, or both.  The temporary GRUU will be valid for\
    \ the\n   duration of the registration (that is, through refreshes), while the\n\
    \   public GRUU persists across registrations.  The UA will receive a new\n  \
    \ temporary GRUU in each successful REGISTER response, while the public\n   GRUU\
    \ will typically be the same.  However, a UA MUST be prepared for\n   the public\
    \ GRUU to change from a previous one, since the persistence\n   property is not\
    \ guaranteed with complete certainty.  If a UA changed\n   its Call-ID in this\
    \ REGISTER request compared to a previous REGISTER\n   request for the same contact\
    \ or reg-id, the UA MUST discard all\n   temporary GRUUs learned through prior\
    \ REGISTER responses.  A UA MAY\n   retain zero, one, some, or all of the temporary\
    \ GRUUs that it is\n   provided during the time over which at least one contact\
    \ or reg-id\n   remains continuously registered.  If a UA stores any temporary\
    \ GRUUs\n   for use during its registration, it needs to be certain that the\n\
    \   registration does not accidentally lapse due to clock skew between\n   the\
    \ UA and registrar.  Consequently, the UA MUST refresh its\n   registration such\
    \ that the REGISTER refresh transaction will either\n   complete or timeout prior\
    \ to the expiration of the registration.  For\n   default transaction timers,\
    \ this would be at least 32 seconds prior\n   to expiration, assuming the registration\
    \ expiration is larger than 64\n   seconds.  If the registration expiration is\
    \ less than 64 seconds, the\n   UA SHOULD refresh its registration halfway prior\
    \ to expiration.\n   Note that, when [14] is in use, and the UA is utilizing multiple\n\
    \   flows for purposes of redundancy, the temporary GRUUs remain valid as\n  \
    \ long as at least one flow is registered.  Thus, even if the\n   registration\
    \ of one flow expires, the temporary GRUUs learned\n   previously remain valid.\n\
    \   In cases where registrars forcefully shorten registration intervals,\n   the\
    \ registration event package, RFC 3680 [24], is used by user agents\n   to learn\
    \ of these changes.  A user agent implementing both RFC 3680\n   [24] and GRUU\
    \ MUST also implement the extensions to RFC 3680 [24] for\n   conveying information\
    \ on GRUU, as defined in RFC 5628 [28], as these\n   are necessary to keep the\
    \ set of temporary GRUUs synchronized between\n   the UA and the registrar.  More\
    \ generally, the utility of temporary\n   GRUUs depends on the UA and registrar\
    \ being in sync on the set of\n   valid temporary GRUUs at any time.  Without\
    \ support of RFC 3680 [24]\n   and its extension for GRUU, the client will remain\
    \ in sync only as\n   long as it always re-registers well before the registration\n\
    \   expiration.  Besides forceful de-registrations, other events (such as\n  \
    \ network outages, connection failures, and short refresh intervals)\n   can lead\
    \ to potential inconsistencies in the set of valid temporary\n   GRUUs.  For this\
    \ reason, it is RECOMMENDED that a UA that utilizes\n   temporary GRUUs implement\
    \ RFC 3680 [24] and RFC 5628 [28].\n   A non-2xx response to the REGISTER request\
    \ has no impact on any\n   existing GRUUs previously provided to the UA.  Specifically,\
    \ if a\n   previously successful REGISTER request provided the UA with a GRUU,\
    \ a\n   subsequent failed request does not remove, delete, or otherwise\n   invalidate\
    \ the GRUU.\n   The user and host parts of the GRUU learned by the UA in the REGISTER\n\
    \   response MUST be treated opaquely by the UA.  That is, the UA MUST\n   NOT\
    \ modify them in any way.  A UA MUST NOT modify or remove URI\n   parameters it\
    \ does not recognize.  Furthermore, the UA MUST NOT add,\n   remove, or modify\
    \ URI parameters relevant for receipt and processing\n   of request at the proxy,\
    \ including the transport, lr, maddr, ttl,\n   user, and comp (see RFC 3486 [25])\
    \ URI parameters.  The other URI\n   parameter defined in RFC 3261 [1], method,\
    \ would not typically be\n   present in a GRUU delivered from a registrar, and\
    \ a UA MAY add a\n   method URI parameter to the GRUU before handing it out to\
    \ another\n   entity.  Similarly, the URI parameters defined in RFC 4240 [26]\
    \ and\n   RFC 4458 [27] are meant for consumption by the UA.  These would not\n\
    \   be included in the GRUU returned by a registrar and MAY be added by a\n  \
    \ UA wishing to provide services associated with those URI parameters.\n   Note,\
    \ however, that should another UA dereference the GRUU, the\n   parameters will\
    \ be lost at the proxy when the Request-URI is\n   translated into the registered\
    \ contact, unless some other means is\n   provided for the attributes to be delivered\
    \ to the UA.  Mechanisms\n   for such delivery are currently the subject of future\
    \ standardization\n   activity (see \"Delivery of Request-URI Targets to User\
    \ Agents\" [29]).\n"
- title: 4.3.  Constructing a Self-Made GRUU
  contents:
  - "4.3.  Constructing a Self-Made GRUU\n   Many user agents (such as gateways to\
    \ the Public Switched Telephone\n   Network (PSTN), conferencing servers, and\
    \ media servers) do not\n   perform registrations, and cannot obtain GRUUs through\
    \ that\n   mechanism.  These types of user agents can be publicly reachable.\n\
    \   This would mean that the policy of the domain is that requests can\n   come\
    \ from anywhere on the public Internet and be delivered to the\n   user agent\
    \ without requiring processing by intervening proxies within\n   the domain. \
    \ Furthermore, firewall and NAT policies administered by\n   the domain would\
    \ allow such requests into the network.  When a user\n   agent is certain that\
    \ these conditions are met, a UA MAY construct a\n   self-made GRUU.  Of course,\
    \ a user agent that does REGISTER, but for\n   whom these conditions are met regardless,\
    \ MAY also construct a self-\n   made GRUU.  However, usage of GRUUs obtained\
    \ by the registrar is\n   RECOMMENDED instead.\n   A self-made GRUU is one whose\
    \ domain part equals the IP address or\n   hostname of the user agent.  The user\
    \ part of the SIP URI is chosen\n   arbitrarily by the user agent.  Like all other\
    \ GRUUs, the URI MUST\n   contain the \"gr\" URI parameter, with or without a\
    \ value, indicating\n   it is a GRUU.\n   If a user agent does not register, but\
    \ is not publicly reachable, it\n   would need to obtain a GRUU through some other\
    \ means.  Typically, the\n   UA would be configured with a GRUU, the GRUU would\
    \ be configured into\n   the proxy, and the proxy will be configured with a mapping\
    \ from the\n   GRUU to the IP address (or hostname) and port of the UA.\n"
- title: 4.4.  Using One's Own GRUUs
  contents:
  - "4.4.  Using One's Own GRUUs\n   A UA SHOULD use a GRUU when populating the Contact\
    \ header field of\n   dialog-forming and target refresh requests and responses.\
    \  In other\n   words, a UA compliant to this specification SHOULD use one of\
    \ its\n   GRUUs as its remote target.  This includes:\n   o  the INVITE request\n\
    \   o  a 2xx or 18x response to an INVITE which contains a To tag\n   o  the SUBSCRIBE\
    \ request (see [5])\n   o  a 2xx response to a SUBSCRIBE which contains a To tag\n\
    \   o  the NOTIFY request\n   o  the REFER request (see [6])\n   o  a 2xx response\
    \ to NOTIFY\n   o  the UPDATE request\n   o  a 2xx response to NOTIFY\n   The\
    \ only reason not to use a GRUU would be privacy considerations;\n   see Section\
    \ 10.3.\n   When using a GRUU obtained through registrations, a UA MUST have an\n\
    \   active registration prior to using a GRUU, and MUST use a GRUU\n   learned\
    \ through that registration.  It MUST NOT reuse a GRUU learned\n   through a previous\
    \ registration that has lapsed (in other words, one\n   obtained when registering\
    \ a contact that has expired).  The UA MAY\n   use either the public or one of\
    \ its temporary GRUUs provided by its\n   registrar.  A UA MUST NOT use a temporary\
    \ GRUU learned in a REGISTER\n   response whose Call-ID differs from the one in\
    \ the most recent\n   REGISTER request generated by the UA for the same AOR and\
    \ instance ID\n   (and, if RFC 5626 [14] is in use, reg-id).  When a UA wishes\
    \ to\n   construct an anonymous request as described in RFC 3323 [15], it\n  \
    \ SHOULD use a temporary GRUU.  See Section 10.3 for a more complete\n   discussion\
    \ on the level of privacy afforded by temporary GRUUs.\n   As per RFC 3261 [1],\
    \ a UA SHOULD include a Supported header with the\n   option tag \"gruu\" in requests\
    \ and responses it generates.\n"
- title: 4.4.1.  Considerations for Multiple AORs
  contents:
  - "4.4.1.  Considerations for Multiple AORs\n   In some SIP networks, a user agent\
    \ can have a multiplicity of AORs,\n   either in different domains or within the\
    \ same domain.  In such\n   cases, additional considerations apply.\n   When a\
    \ UA sends a request, the request will be sent 'using' one of\n   its AORs.  This\
    \ AOR will typically show up in the From header field\n   of the request, and\
    \ credentials unique to that AOR will be used to\n   authenticate the request.\
    \  The GRUU placed into the Contact header\n   field of such a request SHOULD\
    \ be one that is associated with the AOR\n   used to send the request.  In cases\
    \ where the UA uses a tel URI (as\n   defined in [11]) to populate the From header\
    \ field, the UA typically\n   has a SIP AOR that is treated as an alias for the\
    \ tel URI.  The GRUU\n   associated with that SIP AOR SHOULD be used in the Contact\
    \ header\n   field.\n   When a UA receives a request, the GRUU placed into the\
    \ Contact header\n   field of a 2xx response SHOULD be the one associated with\
    \ the AOR or\n   GRUU to which the request was most recently targeted.  There\
    \ are\n   several ways to determine the AOR or GRUU to which a request was\n \
    \  sent.  For example, if a UA registered a different contact to each\n   AOR\
    \ (by using a different user part of the URI), the Request-URI\n   (which contains\
    \ that contact) will indicate the AOR.\n"
- title: 4.5.  Dereferencing a GRUU
  contents:
  - "4.5.  Dereferencing a GRUU\n   A GRUU is identified by the presence of the \"\
    gr\" URI parameter, and\n   this URI parameter might or might not have a value.\
    \  A UA that wishes\n   to send a request to a URI that contains a GRUU knows\
    \ that the\n   request will be delivered to a specific UA instance without further\n\
    \   action on the part of the requestor.\n   Some UAs implement non-standard URI-handling\
    \ mechanisms that\n   compensate for the fact that heretofore many contact URIs\
    \ have not\n   been globally routable.  Since any URI containing the \"gr\" URI\n\
    \   parameter is known to be globally routable, a UA SHOULD NOT apply\n   such\
    \ mechanisms when a contact URI contains the \"gr\" URI parameter.\n      Because\
    \ the instance ID is a callee capabilities parameter, a UA\n      might be tempted\
    \ to send a request to the AOR of a user, and\n      include an Accept-Contact\
    \ header field (defined in [12]) that\n      indicates a preference for routing\
    \ the request to a UA with a\n      specific instance ID.  Although this would\
    \ appear to have the same\n      effect as sending a request to the GRUU, it does\
    \ not.  The caller\n      preferences expressed in the Accept-Contact header field\
    \ are just\n      preferences.  Their efficacy depends on a UA constructing an\n\
    \      Accept-Contact header field that interacts with domain-processing\n   \
    \   logic for an AOR, to cause a request to route to a particular\n      instance.\
    \  Given the variability in routing logic in a domain (for\n      example, time-based\
    \ routing to only selected contacts), this\n      doesn't work for many domain-routing\
    \ policies.  However, this\n      specification does not forbid a client from\
    \ attempting such a\n      request, as there can be cases where the desired operation\
    \ truly\n      is a preferential routing request.\n"
- title: 4.6.  Rendering GRUUs on a User Interface
  contents:
  - "4.6.  Rendering GRUUs on a User Interface\n   When rendering a GRUU to a user\
    \ through a user interface, it is\n   RECOMMENDED that the \"gr\" URI parameter\
    \ be removed.  For public\n   GRUUs, this will produce the AOR, as desired.  For\
    \ temporary GRUUs,\n   the resulting URI will be seemingly random.  Future work\
    \ might\n   provide improved mechanisms that would allow an automaton to know\n\
    \   that a URI is anonymized, and therefore inappropriate to render.\n"
- title: 5.  Registrar Behavior
  contents:
  - '5.  Registrar Behavior

    '
- title: 5.1.  Processing a REGISTER Request
  contents:
  - "5.1.  Processing a REGISTER Request\n   A REGISTER request might contain a Require\
    \ header field with the\n   \"gruu\" option tag; this indicates that the registrar\
    \ has to\n   understand this extension in order to process the request.  It does\n\
    \   not require the registrar to create GRUUs, however.\n   As the registrar is\
    \ processing the contacts in the REGISTER request\n   according to the procedures\
    \ of step 7 in Section 10.3 of RFC 3261\n   [1], the registrar checks whether\
    \ each Contact header field in the\n   REGISTER message contains a \"+sip.instance\"\
    \ header field parameter.\n   If present with a non-zero expiration, the contact\
    \ is processed\n   further based on the rules in the remainder of this section.\n\
    \   Otherwise, the contact is processed based on normal RFC 3261 [1]\n   rules.\n\
    \      Note that handling of a REGISTER request containing a Contact\n      header\
    \ field with value \"*\" and an expiration of zero still\n      retains the meaning\
    \ defined in RFC 3261 [1] -- all contacts, not\n      just those with a specific\
    \ instance ID, are deleted.  As described\n      in Section 5.4, this removes\
    \ the binding of each contact to the\n      AOR and the binding of each contact\
    \ to its GRUUs.\n   If the contact URI is equivalent (based on URI equivalence\
    \ in RFC\n   3261 [1]) to the AOR, the registrar MUST reject the request with\
    \ a\n   403, since this would cause a routing loop.  If the contact URI is a\n\
    \   GRUU for the AOR in the To header field of the REGISTER request, the\n   registrar\
    \ MUST reject the request with a 403, for the same reason.\n   If the contact\
    \ is not a SIP URI, the REGISTER request MUST be\n   rejected with a 403.\n  \
    \ Next, the registrar checks if there is already a valid public GRUU\n   for the\
    \ AOR (present in the To header field of the REGISTER request)\n   and the instance\
    \ ID (present as the content of the \"+sip.instance\"\n   Contact header field\
    \ parameter).  If there is no valid public GRUU,\n   the registrar SHOULD construct\
    \ a public GRUU at this time according\n   to the procedures of Section 5.4. \
    \ The public GRUU MUST be\n   constructed by adding the \"gr\" URI parameter,\
    \ with a value, to the\n   AOR.  If the contact contained a \"pub-gruu\" Contact\
    \ header field\n   parameter, the header field parameter MUST be ignored by the\n\
    \   registrar.  A UA cannot suggest or otherwise provide a public GRUU to\n  \
    \ the registrar.\n   Next, the registrar checks for any existing contacts registered\
    \ to\n   the same AOR, instance ID, and if the contact in the REGISTER request\n\
    \   is registering a flow [14], reg-id.  If there is at least one, the\n   registrar\
    \ finds the one that was most recently registered, and\n   examines the Call-ID\
    \ value associated with that registered contact.\n   If it differs from the one\
    \ in the REGISTER request, the registrar\n   MUST invalidate all previously generated\
    \ temporary GRUUs for the AOR\n   and instance ID.  A consequence of this invalidation\
    \ is that requests\n   addressed to those GRUUs will be rejected by the domain\
    \ with a 404\n   from this point forward.\n   Next, the registrar SHOULD create\
    \ a new temporary GRUU for the AOR\n   and instance ID with the characteristics\
    \ described in Section 5.4.\n   The temporary GRUU construction algorithm MUST\
    \ have the following two\n   properties:\n   1.  The likelihood that the temporary\
    \ GRUU is equal to another GRUU\n       that the registrar has created MUST be\
    \ vanishingly small.\n   2.  Given a pair of GRUUs, it MUST be computationally\
    \ infeasible to\n       determine whether they were issued for the same AOR or\
    \ instance\n       ID or for different AORs and instance IDs.\n   If the contact\
    \ contained a \"temp-gruu\" Contact header field\n   parameter, the header field\
    \ parameter MUST be ignored by the\n   registrar.  A UA cannot suggest or otherwise\
    \ provide a temporary GRUU\n   to the registrar.\n"
- title: 5.2.  Generating a REGISTER Response
  contents:
  - "5.2.  Generating a REGISTER Response\n   When generating the 200 (OK) response\
    \ to the REGISTER request, the\n   procedures of step 8 of Section 10.3 of RFC\
    \ 3261 [1] are followed.\n   Furthermore, for each Contact header field value\
    \ placed in the\n   response, if the registrar has stored an instance ID associated\
    \ with\n   that contact, that instance ID is returned as a Contact header field\n\
    \   parameter.  If the REGISTER request contained a Supported header\n   field\
    \ that included the \"gruu\" option tag, and the registrar has at\n   least one\
    \ temporary GRUU assigned to the instance ID and AOR, the\n   registrar MUST add\
    \ a \"temp-gruu\" Contact header field parameter to\n   that Contact header field.\
    \  The value of the \"temp-gruu\" parameter is\n   a quoted string, and MUST contain\
    \ the most recently created temporary\n   GRUU for that AOR and instance ID. \
    \ In addition, if the registrar has\n   a public GRUU assigned to the instance\
    \ ID and AOR (and the client\n   supports GRUUs), the registrar MUST add a \"\
    pub-gruu\" Contact header\n   field parameter to that Contact header field.  The\
    \ value of the \"pub-\n   gruu\" Contact header field parameter is the public\
    \ GRUU.\n   The registrar SHOULD NOT include the \"gruu\" option tag in the Require\n\
    \   or Supported header field of the response.\n"
- title: 5.3.  Timing Out a Registration
  contents:
  - "5.3.  Timing Out a Registration\n   When a registered contact expires (either\
    \ due to timeout or explicit\n   de-registration), its binding to the AOR is removed\
    \ as usual.  In\n   addition, its binding to its GRUUs are removed at the same\
    \ time, as a\n   consequence of the relationships described in Section 5.4\n \
    \  If, as a consequence of the expiration of the contact, a particular\n   GRUU\
    \ no longer has any registered contacts bound to it, and the GRUU\n   is a temporary\
    \ GRUU, the GRUU MUST be invalidated.  This means that\n   all of the accumulated\
    \ temporary GRUUs get invalidated once the last\n   contact for a given instance\
    \ ID expires.\n   If, however, the GRUU was a public GRUU, the registrar SHOULD\n\
    \   continue to treat the GRUU as valid.  Consequently, subsequent\n   requests\
    \ targeted to the GRUU, prior to re-registration of a contact\n   to the GRUU,\
    \ SHOULD return a 480 (Temporarily Unavailable) response.\n   In addition, since\
    \ the GRUU remains valid, the rules in Section 5.1\n   will cause it to be retained\
    \ when a contact with that instance ID is\n   once again registered to the AOR.\n\
    \      These rules give a public GRUU a semi-permanent property.  The\n      intent\
    \ is that the registrar make every attempt to retain validity\n      of the GRUU\
    \ for as long as the AOR itself is known within the\n      domain.  The requirements\
    \ for doing so are at SHOULD strength and\n      not MUST strength because of\
    \ the difficulty in meeting a MUST\n      strength requirement; registrar failures\
    \ could cause the set of\n      valid GRUUs to be lost, and this specification\
    \ requires the UA to\n      be robust against such cases.  That said, it is possible\
    \ for a\n      public GRUU to be constructed such that a registrar does not need\n\
    \      to retain any additional state for it, yet the GRUU still meets\n     \
    \ the requirements described here.\n"
- title: 5.4.  Creation of a GRUU
  contents:
  - "5.4.  Creation of a GRUU\n   This section defines additional behaviors associated\
    \ with the\n   construction and maintenance of a GRUU that are specific to a\n\
    \   registrar.  These rules do not apply to self-made GRUUs or GRUUs not\n   obtained\
    \ through registrations.\n   When a registrar creates a GRUU, it is required to\
    \ maintain certain\n   information associated with the GRUU, regardless of whether\
    \ it is a\n   public or temporary GRUU.  Every GRUU is associated with a single\
    \ AOR\n   and a single instance ID.  A registrar MUST be able to determine the\n\
    \   instance ID and AOR when presented with a GRUU.  In addition, the\n   GRUU,\
    \ like an AOR, resolves to zero or more contacts.  While the AOR\n   resolves\
    \ to all registered contacts for an AOR, a GRUU resolves only\n   to those contacts\
    \ whose instance ID matches the one associated with\n   the GRUU.  For this reason,\
    \ a contact with an instance ID is always\n   bound to both a GRUU and its AOR,\
    \ never just an AOR or just a GRUU.\n   This is shown pictorially in Figure 1.\
    \  The figure shows three\n   contacts registered to a single AOR.  One of the\
    \ contacts has an\n   instance ID of 1, and the other two have an instance ID\
    \ of 2.  There\n   are two GRUUs for this AOR.  One is associated with instance\
    \ ID 1,\n   and the other with instance ID 2.  The first GRUU resolves only to\n\
    \   contacts whose instance ID is 1, and the second resolves only to\n   contacts\
    \ whose instance ID is 2.  There will typically be multiple\n   contacts for a\
    \ given instance ID if a UA has crashed, rebooted, and\n   re-registered with\
    \ the same instance ID, or is using the mechanisms\n   of RFC 5626 [14] to have\
    \ multiple registrations for redundancy.  If\n   the contact for instance ID 1\
    \ expires, the AOR would resolve to two\n   contacts, but the GRUU associated\
    \ with instance ID 1 would resolve to\n   zero.\n          +----------+   +----------+\
    \  +----------+\n          |  GRUU    |   |          |  |  GRUU    |\n       \
    \   |          |   |   AOR    |  |          |\n          |Instance:1|   |    \
    \      |  |Instance:2|\n          +----------+   +----------+  +----------+\n\
    \               |           /  |  \\           / |\n               |         \
    \ /   |   \\         /  |\n               |         /    |    \\       /   |\n\
    \               |        /     |     \\     /    |\n               |       / \
    \     |      \\   /     |\n               |      /       |       \\ /      |\n\
    \               |     /        |        X       |\n               |    /     \
    \    |       / \\      |\n               |   /          |      /   \\     |\n\
    \               |  /           |     /     \\    |\n               V V       \
    \     V    V       V   V\n          +----------+   +----------+  +----------+\n\
    \          | Contact  |   | Contact  |  | Contact  |\n          |          | \
    \  |          |  |          |\n          |Instance:1|   |Instance:2|  |Instance:2|\n\
    \          +----------+   +----------+  +----------+\n                       \
    \          Figure 1\n   There can be multiple GRUUs with the same instance ID\
    \ and AOR.\n   Indeed, this specification requires registrars to maintain many\
    \ --\n   one that is public, and several that are temporary.  However, if two\n\
    \   GRUUs are associated with different AORs or different instance IDs or\n  \
    \ both, the GRUUs MUST be different based on URI equality comparison.\n   A GRUU\
    \ in a domain MUST NOT be equivalent, based on URI comparison,\n   to any AOR\
    \ in a domain except for the one associated with the GRUU.\n      A public GRUU\
    \ will always be equivalent to the AOR based on URI\n      equality rules.  The\
    \ reason is that the rules in RFC 3261 [1]\n      cause URI parameters that are\
    \ in one URI, but not in the other, to\n      be ignored for equality purposes.\
    \  Since a public GRUU differs\n      from an AOR only by the presence of the\
    \ \"gr\" URI parameter, the\n      two URIs are equivalent based on those rules.\n\
    \   Once a temporary GRUU is constructed, it MUST be considered valid by\n   the\
    \ registrar until invalidated based on the rules described\n   previously.  Once\
    \ a public GRUU is constructed, it MUST be considered\n   valid for the duration\
    \ that the AOR itself is valid.  Once an AOR is\n   no longer valid within a domain,\
    \ all of its GRUUs MUST be considered\n   invalid as well.\n   This specification\
    \ does not mandate a particular mechanism for\n   construction of the GRUU.  Example\
    \ algorithms for public and\n   temporary GRUUs that work well are given in Appendix\
    \ A.  However, in\n   addition to the properties described in Section 3.1, a GRUU\n\
    \   constructed by a registrar MUST exhibit the following properties:\n   o  The\
    \ domain part of the URI is an IP address present on the public\n      Internet,\
    \ or, if it is a hostname, the resolution procedures of\n      RFC 3263 [2], once\
    \ applied, result in an IP address on the public\n      Internet.\n   o  When\
    \ a request is sent to the GRUU, it routes to a proxy that can\n      access the\
    \ registration data generated by the registrar.  Such a\n      proxy is called\
    \ an authoritative proxy, defined in RFC 5626 [14].\n"
- title: 5.5.  Registration Event Support
  contents:
  - "5.5.  Registration Event Support\n   RFC 3680 [24] defines an event package that\
    \ allows a client to learn\n   about registration events at the registrar.  This\
    \ package allows\n   registrars to alter registrations forcefully (for example,\
    \ shortening\n   them to force a re-registration).  If a registrar is supporting\
    \ RFC\n   3680 [24] and GRUU, it MUST also support RFC 5628 [28].\n"
- title: 6.  Proxy Behavior
  contents:
  - "6.  Proxy Behavior\n   Proxy behavior is fully defined in Section 16 of RFC 3261\
    \ [1].  GRUU\n   processing impacts that processing in two places -- request targeting\n\
    \   at the authoritative proxy and record-routing.\n"
- title: 6.1.  Request Targeting
  contents:
  - "6.1.  Request Targeting\n   When a proxy receives a request, owns the domain\
    \ in the Request-URI,\n   and is supposed to access a location service in order\
    \ to compute\n   request targets (as specified in Section 16.5 of RFC 3261 [1]),\
    \ the\n   proxy examines the Request-URI.  If it contains the \"gr\" URI\n   parameter\
    \ but is not equivalent, based on URI comparison, to a\n   currently valid GRUU\
    \ within the domain, it SHOULD be rejected with a\n   404 (Not Found) response;\
    \ this is the same behavior a proxy would\n   exhibit for any other URI within\
    \ the domain that is not valid.\n   If the Request-URI contains the \"gr\" URI\
    \ parameter and is equivalent,\n   based on URI comparison, to a GRUU which is\
    \ currently valid within\n   the domain, processing proceeds as it would for any\
    \ other URI present\n   in the location service, as defined in Section 16.5 of\
    \ RFC 3261 [1],\n   except that the \"gr\" URI parameter is not removed as part\
    \ of the\n   canonicalization process.  This is the case for both out-of-dialog\n\
    \   requests targeted to the GRUU, and mid-dialog requests targeted to\n   the\
    \ GRUU (in which case the incoming request would have a Route\n   header field\
    \ value containing the URI that the proxy used for record-\n   routing.).\n  \
    \ Note that the \"gr\" URI parameter is retained just for the purposes of\n  \
    \ finding the GRUU in the location service; if a match is found, the\n   Request-URI\
    \ will be rewritten with the registered contacts, replacing\n   the GRUU and its\
    \ \"gr\" URI parameter.  The \"gr\" URI parameter is not\n   carried forward into\
    \ the rewritten Request-URI.\n   If there are no registered contacts bound to\
    \ the GRUU, the server\n   MUST return a 480 (Temporarily Unavailable) response.\
    \  If there are\n   more than one, there are two cases:\n   1.  The client is\
    \ using RFC 5626 [14] and registering multiple\n       contacts for redundancy.\
    \  In that case, these contacts contain\n       \"reg-id\" Contact header field\
    \ parameters, and the rules described\n       in Section 7 of RFC 5626 [14] for\
    \ selecting a single registered\n       contact apply.\n   2.  The client was\
    \ not using RFC 5626 [14], in which case there would\n       only be multiple\
    \ contacts with the same instance ID if the client\n       had rebooted, restarted,\
    \ and re-registered.  In this case, these\n       contacts would not contain the\
    \ \"reg-id\" Contact header field\n       parameter.  The proxy MUST select the\
    \ most recently refreshed\n       contact.  As with RFC 5626, if a request to\
    \ this target fails\n       with a 408 (Request Timeout) or 430 (Flow Failed)\
    \ response, the\n       proxy SHOULD retry with the next most recently refreshed\
    \ contact.\n       Furthermore, if the request fails with any other response,\
    \ the\n       proxy MUST NOT retry on any other contacts for this instance.\n\
    \   Any caller preferences in the request (as defined in RFC 3841 [12])\n   SHOULD\
    \ be processed against the contacts bound to the GRUU.\n   In essence, to select\
    \ a registered contact, the GRUU is processed\n   just like it was the AOR, but\
    \ with only a subset of the contacts\n   bound to the AOR.\n   Special considerations\
    \ apply to the processing of any Path headers\n   stored in the registration (see\
    \ RFC 3327 [3]).  If the received\n   request has Route header field values beyond\
    \ the one pointing to the\n   authoritative proxy itself (this will happen when\
    \ the request is a\n   mid-dialog request), the Path URI MUST be discarded.  This\
    \ is\n   permitted by RFC 3327 [3] as a matter of local policy; usage of GRUUs\n\
    \   will require this policy in order to avoid call spirals and likely\n   call\
    \ failures.\n   A proxy MAY apply other processing to the request, such as execution\n\
    \   of called party features, as it might do for requests targeted to an\n   AOR.\
    \  For requests that are outside of a dialog, it is RECOMMENDED to\n   apply screening\
    \ types of functions, both automated (such as blacklist\n   and whitelist screening)\
    \ and interactive (such as interactive voice\n   response (IVR) applications that\
    \ confer with the user to determine\n   whether to accept a call).  In many cases,\
    \ the new request is related\n   to an existing dialog, and might be an attempt\
    \ to join it (using the\n   Join header field defined in RFC 3911 [21]) or replace\
    \ it (using the\n   Replaces header field defined in RFC 3891 [22]).  When the\
    \ new\n   request is related to an existing dialog, the UA will typically make\n\
    \   its own authorization decisions; bypassing screening services at the\n   authoritative\
    \ proxy might make sense, but needs to be carefully\n   considered by network\
    \ designers, as the ability to do so depends on\n   the specific type of screening\
    \ service.\n   However, forwarding services, such as call forwarding, SHOULD NOT\
    \ be\n   provided for requests sent to a GRUU.  The intent of the GRUU is to\n\
    \   target a specific UA instance, and this is incompatible with\n   forwarding\
    \ operations.\n   If the request is a mid-dialog request, a proxy SHOULD only\
    \ apply\n   services that are meaningful for mid-dialog requests, generally\n\
    \   speaking.  This excludes screening and forwarding functions.\n   In addition,\
    \ a request sent to a GRUU SHOULD NOT be redirected.  In\n   many instances, a\
    \ GRUU is used by a UA in order to assist in the\n   traversal of NATs and firewalls,\
    \ and a redirection might prevent such\n   a case from working.\n"
- title: 6.2.  Record-Routing
  contents:
  - "6.2.  Record-Routing\n   There are two distinct requirements for record-routing\
    \ -- in the\n   originating domain and in the terminating domain.  These requirements\n\
    \   avoid unnecessary, and possibly problematic, spirals of requests.\n   If:\n\
    \   o  an originating authoritative proxy receives a dialog-forming\n      request,\n\
    \   o  AND the Contact header field contains a GRUU in the domain of the\n   \
    \   proxy,\n   o  AND that GRUU is a valid one in the domain of the proxy,\n \
    \  o  AND that GRUU is associated with the AOR matching the\n      authenticated\
    \ identity of the requestor (assuming such\n      authentication has been performed),\n\
    \   o  AND the request contains Record-Route header fields,\n   then the authoritative\
    \ proxy MUST record-route.  If all of these\n   conditions are true, except that\
    \ the GRUU is associated with an AOR\n   that did not match the authenticated\
    \ identity of the requestor, it is\n   RECOMMENDED that the proxy reject the request\
    \ with a 403 (Forbidden)\n   response.\n   If:\n   o  a terminating authoritative\
    \ proxy receives a dialog-forming\n      request,\n   o  AND the Request-URI contains\
    \ a URI in the location service (either\n      a GRUU or an AOR),\n   o  AND the\
    \ contact selected for sending the request has an instance\n      ID and is bound\
    \ to a GRUU,\n   o  AND the registration contain Path URI,\n   then the authoritative\
    \ proxy MUST record-route.\n   If a proxy is in either the originating or terminating\
    \ domains but is\n   not an authoritative proxy, the proxy MAY record-route.\n\
    \   If a proxy in the terminating domain requires mid-dialog requests to\n   pass\
    \ through it for whatever reason (firewall traversal, accounting,\n   etc.), the\
    \ proxy MUST still record-route, and MUST NOT assume that a\n   UA will utilize\
    \ its GRUU in the Contact header field of its response\n   (which would cause\
    \ mid-dialog requests to pass through the proxy\n   without record-routing).\n\
    \      Implementors should note that, if a UA uses a GRUU in its contact,\n  \
    \    and a proxy inserted itself into the Path header field of a\n      registration,\
    \ that proxy will be receiving mid-dialog requests\n      regardless of whether\
    \ it record-routes or not.  The only\n      distinction is what URI the proxy\
    \ will see in the topmost Route\n      header field of mid-dialog requests.  If\
    \ the proxy record-routes,\n      it will see that URI.  If it does not, it will\
    \ see the Path URI it\n      inserted.\n"
- title: 7.  Grammar
  contents:
  - "7.  Grammar\n   This specification defines two new Contact header field parameters\n\
    \   (\"temp-gruu\" and \"pub-gruu\") by extending the grammar for \"contact-\n\
    \   params\" as defined in RFC 3261 [1].  It also defines a new SIP URI\n   parameter\
    \ (\"gr\") by extending the grammar for \"uri-parameter\" as\n   defined in RFC\
    \ 3261 [1].  The ABNF [13] is as follows:\n   contact-params  =/ temp-gruu / pub-gruu\n\
    \   temp-gruu       =  \"temp-gruu\" EQUAL quoted-string\n   pub-gruu        =\
    \  \"pub-gruu\" EQUAL quoted-string\n   uri-parameter   =/ gr-param\n   gr-param\
    \        = \"gr\" [\"=\" pvalue]   ; defined in RFC 3261\n   The quoted strings\
    \ for temp-gruu and pub-gruu MUST contain a SIP URI.\n   However, they are encoded\
    \ like all other quoted strings and can\n   therefore contain quoted-pair escapes\
    \ when represented this way.\n"
- title: 8.  Requirements
  contents:
  - "8.  Requirements\n   This specification was created in order to meet the following\n\
    \   requirements:\n   REQ 1:  When a UA invokes a GRUU, it must cause the request\
    \ to be\n      routed to the specific UA instance to which the GRUU refers.\n\
    \   REQ 2:  It must be possible for a GRUU to be invoked from anywhere on\n  \
    \    the Internet, and still cause the request to be routed\n      appropriately.\
    \  That is, a GRUU must not be restricted to use\n      within a specific addressing\
    \ realm.\n   REQ 3:  It must be possible for a GRUU to be constructed without\n\
    \      requiring the network to store additional state.\n   REQ 4:  It must be\
    \ possible for a UA to obtain a multiplicity of\n      GRUUs that each route to\
    \ that UA instance.  For example, this is\n      needed to support ad hoc conferencing\
    \ where a UA instance needs a\n      different URI for each conference it is hosting.\
    \  NOTE: This\n      requirement is not met by this specification, and is being\n\
    \      addressed in a separate specification (currently, \"Delivery of\n     \
    \ Request-URI Targets to User Agents\" [29]).\n   REQ 5:  When a UA receives a\
    \ request sent to a GRUU, it must be\n      possible for the UA to know the GRUU\
    \ that was used to invoke the\n      request.  This is necessary as a consequence\
    \ of REQ 4.  NOTE: This\n      requirement is not met by this specification, and\
    \ is being\n      addressed in a separate specification (currently, \"Delivery\
    \ of\n      Request-URI Targets to User Agents\" [29]).\n   REQ 6:  It must be\
    \ possible for a UA to add opaque content to a GRUU.\n      This content is not\
    \ interpreted or altered by the network, and is\n      used only by the UA instance\
    \ to whom the GRUU refers.  This\n      provides a basic cookie type of functionality,\
    \ allowing a UA to\n      build a GRUU with the state embedded.  NOTE: This requirement\
    \ is\n      not met by this specification, and is being addressed in a\n     \
    \ separate specification (currently, \"Delivery of Request-URI\n      Targets\
    \ to User Agents\" [29]).\n   REQ 7:  It must be possible for a proxy to execute\
    \ services and\n      features on behalf of a UA instance represented by a GRUU.\
    \  As an\n      example, if a user has call-blocking features, a proxy might want\n\
    \      to apply those call-blocking features to calls made to the GRUU,\n    \
    \  in addition to calls made to the user's AOR.\n   REQ 8:  It must be possible\
    \ for a UA in a dialog to inform its peer\n      of its GRUU, and for the peer\
    \ to know that the URI represents a\n      GRUU.  This is needed for the conferencing\
    \ and dialog reuse\n      applications of GRUUs, where the URIs are transferred\
    \ within a\n      dialog.\n   REQ 9:  When transferring a GRUU per REQ 8, it must\
    \ be possible for\n      the UA receiving the GRUU to be assured of its integrity\
    \ and\n      authenticity.\n   REQ 10:  It must be possible for a server that\
    \ is authoritative for a\n      domain to construct a GRUU that routes to a UA\
    \ instance bound to\n      an AOR in that domain.  In other words, the proxy can\
    \ construct a\n      GRUU, too.  This is needed for the presence application.\n"
- title: 9.  Example Call Flow
  contents:
  - "9.  Example Call Flow\n   The following call flow, shown in Figure 2, shows a\
    \ basic\n   registration and call setup, followed by a subscription directed to\n\
    \   the GRUU.  It then shows a failure of the callee, followed by a re-\n   registration.\
    \  The conventions of RFC 4475 [17] are used to describe\n   the representation\
    \ of long message lines.\n       Caller                 Proxy                Callee\n\
    \       |                     |(1) REGISTER         |\n       |              \
    \       |<--------------------|\n       |                     |(2) 200 OK    \
    \       |\n       |                     |-------------------->|\n       |(3) INVITE\
    \           |                     |\n       |-------------------->|          \
    \           |\n       |                     |(4) INVITE           |\n       |\
    \                     |-------------------->|\n       |                     |(5)\
    \ 200 OK           |\n       |                     |<--------------------|\n \
    \      |(6) 200 OK           |                     |\n       |<--------------------|\
    \                     |\n       |(7) ACK              |                     |\n\
    \       |-------------------->|                     |\n       |              \
    \       |(8) ACK              |\n       |                     |-------------------->|\n\
    \       |(9) SUBSCRIBE        |                     |\n       |-------------------->|\
    \                     |\n       |                     |(10) SUBSCRIBE       |\n\
    \       |                     |-------------------->|\n       |              \
    \       |(11) 200 OK          |\n       |                     |<--------------------|\n\
    \       |(12) 200 OK          |                     |\n       |<--------------------|\
    \                     |\n       |                     |(13) NOTIFY          |\n\
    \       |                     |<--------------------|\n       |(14) NOTIFY   \
    \       |                     |\n       |<--------------------|              \
    \       |\n       |(15) 200 OK          |                     |\n       |-------------------->|\
    \                     |\n       |                     |(16) 200 OK          |\n\
    \       |                     |-------------------->|\n       |              \
    \       |                     |Crashes,\n       |                     |(17) REGISTER\
    \        | Reboots\n       |                     |<--------------------|\n   \
    \    |                     |(18) 200 OK          |\n       |                 \
    \    |-------------------->|\n                                 Figure 2\n   The\
    \ callee supports the GRUU extension.  As such, its REGISTER (1)\n   looks like:\n\
    \      REGISTER sip:example.com SIP/2.0\n      Via: SIP/2.0/UDP 192.0.2.1;branch=z9hG4bKnashds7\n\
    \      Max-Forwards: 70\n      From: Callee <sip:callee@example.com>;tag=a73kszlfl\n\
    \      Supported: gruu\n      To: Callee <sip:callee@example.com>\n      Call-ID:\
    \ 1j9FpLxk3uxtm8tn@192.0.2.1\n      CSeq: 1 REGISTER\n      Contact: <sip:callee@192.0.2.1>\n\
    \       ;+sip.instance=\"<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>\"\n \
    \     Content-Length: 0\n   The registrar assigns a temporary and a public GRUU.\
    \  The REGISTER\n   response (message 2) would look like:\n      SIP/2.0 200 OK\n\
    \      Via: SIP/2.0/UDP 192.0.2.1;branch=z9hG4bKnashds7\n      From: Callee <sip:callee@example.com>;tag=a73kszlfl\n\
    \      To: Callee <sip:callee@example.com> ;tag=b88sn\n      Call-ID: 1j9FpLxk3uxtm8tn@192.0.2.1\n\
    \      CSeq: 1 REGISTER\n      <allOneLine>\n      Contact: <sip:callee@192.0.2.1>\n\
    \      ;pub-gruu=\"sip:callee@example.com\n      ;gr=urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"\
    \n      ;temp-gruu=\"sip:tgruu.7hs==\n      jd7vnzga5w7fajsc7-ajd6fabz0f8g5@example.com;gr\"\
    \n      ;+sip.instance=\"<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>\"\n \
    \     ;expires=3600\n      </allOneLine>\n      Content-Length: 0\n   The Contact\
    \ header field in the REGISTER response contains the \"pub-\n   gruu\" Contact\
    \ header field parameter with the public GRUU sip:callee@\n   example.com;gr=urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6,\
    \ and the\n   \"temp-gruu\" header field parameter with the temporary GRUU\n \
    \  sip:tgruu.7hs==jd7vnzga5w7fajsc7-ajd6fabz0f8g5@example.com;gr.  Both\n   are\
    \ valid GRUUs for the AOR and instance ID, and both translate to\n   the contact\
    \ sip:callee@192.0.2.1.\n   The INVITE from the caller (message 3) is a normal\
    \ SIP INVITE.\n   However, the 200 OK generated by the callee (message 5) now\
    \ contains\n   a GRUU as the remote target.  The UA has chosen to use its public\n\
    \   GRUU.\n      SIP/2.0 200 OK\n      Via: SIP/2.0/UDP proxy.example.com;branch=z9hG4bKnaa8\n\
    \      Via: SIP/2.0/UDP host.example.com;branch=z9hG4bK99a\n      From: Caller\
    \ <sip:caller@example.com>;tag=n88ah\n      To: Callee <sip:callee@example.com>\
    \ ;tag=a0z8\n      Call-ID: 1j9FpLxk3uxtma7@host.example.com\n      CSeq: 1 INVITE\n\
    \      Supported: gruu\n      Allow: INVITE, OPTIONS, CANCEL, BYE, ACK, SUBSCRIBE\n\
    \      <allOneLine>\n      Contact:\n      <sip:callee@example.com\n      ;gr=urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>\n\
    \      </allOneLine>\n      Content-Length: --\n      Content-Type: application/sdp\n\
    \     [SDP Not shown]\n   At some point later in the call, the caller decides\
    \ to subscribe to\n   the dialog event package (defined in [16]) at that specific\
    \ UA.  To\n   do that, it generates a SUBSCRIBE request (message 9), but directs\
    \ it\n   towards the remote target, which is a GRUU:\n      <allOneLine>\n   \
    \   SUBSCRIBE sip:callee@example.com;gr=urn:uuid:f8\n      1d4fae-7dec-11d0-a765-00a0c91e6bf6\n\
    \       SIP/2.0\n      </allOneLine>\n      Via: SIP/2.0/UDP host.example.com;branch=z9hG4bK9zz8\n\
    \      From: Caller <sip:caller@example.com>;tag=kkaz-\n      <allOneLine>\n \
    \     To: <sip:callee@example.com;gr=urn:uuid:f8\n      1d4fae-7dec-11d0-a765-00a0c91e6bf6>\n\
    \      </allOneLine>\n      Call-ID: faif9a@host.example.com\n      CSeq: 2 SUBSCRIBE\n\
    \      Supported: gruu\n      Event: dialog\n      Allow: INVITE, OPTIONS, CANCEL,\
    \ BYE, ACK, NOTIFY\n      Contact: <sip:caller@example.com;gr=hdg7777ad7aflzig8sf7>\n\
    \      Content-Length: 0\n   In this example, the caller itself supports the GRUU\
    \ extension and is\n   using its own GRUU to populate its remote target.\n   This\
    \ request is routed to the proxy, which proceeds to perform a\n   location lookup\
    \ on the Request-URI.  It is translated into the\n   contact for that instance,\
    \ and then proxied to that contact.\n       SUBSCRIBE sip:callee@192.0.2.1 SIP/2.0\n\
    \       Via: SIP/2.0/UDP proxy.example.com;branch=z9hG4bK9555\n       Via: SIP/2.0/UDP\
    \ host.example.com;branch=z9hG4bK9zz8\n       From: Caller <sip:caller@example.com>;tag=kkaz-\n\
    \       <allOneLine>\n       To: <sip:callee@example.com;gr=urn:uuid:f8\n    \
    \   1d4fae-7dec-11d0-a765-00a0c91e6bf6>\n       </allOneLine>\n       Call-ID:\
    \ faif9a@host.example.com\n       CSeq: 2 SUBSCRIBE\n       Supported: gruu\n\
    \       Event: dialog\n       Allow: INVITE, OPTIONS, CANCEL, BYE, ACK, NOTIFY\n\
    \       Contact: <sip:caller@example.com;gr=hdg7777ad7aflzig8sf7>\n       Content-Length:\
    \ 0\n   The SUBSCRIBE generates a 200 response (message 11), which is\n   followed\
    \ by a NOTIFY (message 13 and 14) and its response (message 15\n   and 16).  At\
    \ some point after message 16 is received, the callee's\n   machine crashes and\
    \ recovers.  It obtains a new IP address,\n   192.0.2.2.  Unaware that it had\
    \ previously had an active\n   registration, it creates a new one (message 17\
    \ below).  Notice how\n   the instance ID remains the same, as it persists across\
    \ reboot\n   cycles:\n      REGISTER sip:example.com SIP/2.0\n      Via: SIP/2.0/UDP\
    \ 192.0.2.2;branch=z9hG4bKnasbba\n      Max-Forwards: 70\n      From: Callee <sip:callee@example.com>;tag=ha8d777f0\n\
    \      Supported: gruu\n      To: Callee <sip:callee@example.com>\n      Call-ID:\
    \ hf8asxzff8s7f@192.0.2.2\n      CSeq: 1 REGISTER\n      <allOneLine>\n      Contact:\
    \ <sip:callee@192.0.2.2>\n      ;+sip.instance=\"<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>\"\
    \n      </allOneLine>\n      Content-Length: 0\n   The registrar notices that\
    \ a different contact, sip:callee@192.0.2.1,\n   is already associated with the\
    \ same instance ID.  It registers the\n   new one too and returns both in the\
    \ REGISTER response.  Both have the\n   same public GRUUs, but the registrar has\
    \ generated a second temporary\n   GRUU for this AOR and instance ID combination.\
    \  Both contacts are\n   included in the REGISTER response, and the temporary\
    \ GRUU for each is\n   the same -- the most recently created one for the instance\
    \ ID and\n   AOR.  The registrar then generates the following response:\n    \
    \  SIP/2.0 200 OK\n      Via: SIP/2.0/UDP 192.0.2.2;branch=z9hG4bKnasbba\n   \
    \   From: Callee <sip:callee@example.com>;tag=ha8d777f0\n      To: Callee <sip:callee@example.com>;tag=99f8f7\n\
    \      Call-ID: hf8asxzff8s7f@192.0.2.2\n      CSeq: 1 REGISTER\n      <allOneLine>\n\
    \      Contact: <sip:callee@192.0.2.2>\n      ;pub-gruu=\"sip:callee@example.com;gr=urn:\n\
    \      uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"\n      ;temp-gruu=\"sip:tgruu.7hatz6cn-098shfyq193=\n\
    \      ajfux8fyg7ajqqe7@example.com;gr\"\n      ;+sip.instance=\"<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>\"\
    \n      ;expires=3600\n      </allOneLine>\n      <allOneLine>\n      Contact:\
    \ <sip:callee@192.0.2.1>\n      ;pub-gruu=\"sip:callee@example.com;gr=urn:\n \
    \     uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"\n      ;temp-gruu=\"sip:tgruu.7hatz6cn-098shfyq193=\n\
    \      ajfux8fyg7ajqqe7@example.com;gr\"\n      ;+sip.instance=\"<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>\"\
    \n      ;expires=400\n      </allOneLine>\n      Content-Length: 0\n   There is\
    \ no need for the UA to remove the stale registered contact;\n   the request targeting\
    \ rules in Section 6.1 will cause the request to\n   be delivered to the most\
    \ recent one.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   Attacks in SIP networks using GRUUs can be divided\
    \ into outside\n   attacks (where a third party is trying to attack the system)\
    \ and\n   inside attacks (where the attacker is a valid participant in the\n \
    \  system but is malicious).  In addition, there are privacy\n   considerations\
    \ with using GRUUs.\n"
- title: 10.1.  Outside Attacks
  contents:
  - "10.1.  Outside Attacks\n   It is important for a UA to be assured of the integrity\
    \ of a GRUU\n   given in a REGISTER response.  If the GRUU is tampered with by\
    \ an\n   attacker, the result could be denial of service (DoS) to the UA.  As\n\
    \   a result, it is RECOMMENDED that a UA use the SIPS URI scheme in the\n   Request-URI\
    \ when registering.  Proxies and registrars MUST support\n   the SIPS URI and\
    \ MUST support TLS.  This does not represent a change\n   from the requirements\
    \ in RFC 3261 [1].\n   The example GRUU construction algorithm in Appendix A.1\
    \ makes no\n   attempt to create a GRUU that hides the AOR and instance ID\n \
    \  associated with the GRUU.  In general, determination of the AOR\n   associated\
    \ with a GRUU is considered a good property, since it allows\n   for easy tracking\
    \ of the target of a particular call.  Learning the\n   instance ID provides little\
    \ benefit to an attacker.  To register or\n   otherwise impact registrations for\
    \ the user, an attacker would need\n   to obtain the credentials for the user.\
    \  Knowing the instance ID is\n   insufficient.\n   The example GRUU construction\
    \ algorithm in Appendix A.1 makes no\n   attempt to create a GRUU that prevents\
    \ users from guessing a GRUU\n   based on knowledge of the AOR and instance ID.\
    \  A user that is able\n   to do that will be able to direct a new request at\
    \ a particular\n   instance.  However, this specification recommends that service\n\
    \   treatment (in particular, screening features) be given to requests\n   that\
    \ are sent to a GRUU.  That treatment will make sure that the GRUU\n   does not\
    \ provide a back door for attackers to contact a user that has\n   tried to block\
    \ the attacker.\n"
- title: 10.2.  Inside Attacks
  contents:
  - "10.2.  Inside Attacks\n   As a consequence of this specification, a UA will begin\
    \ using GRUUs\n   in the dialog forming and target refresh requests and responses\
    \ it\n   emits.  These GRUUs will be passed to another UA (called the\n   correspondent),\
    \ which then uses them in requests that they emit.\n   If a malicious correspondent\
    \ removes the \"gr\" URI parameter, the\n   request will be routed to the authoritative\
    \ proxy.  If the GRUU had\n   been temporary, removal of the \"gr\" URI parameter\
    \ produces a URI that\n   is not recognized as a GRUU and is not equal to any\
    \ AOR.  The request\n   will be rejected.  If the GRUU had been public, removing\
    \ the \"gr\" URI\n   parameter would have produced the AOR.  Therefore, the request\
    \ is\n   treated like a call to the AOR.  Since it is a desired goal to allow\n\
    \   users to extract the AOR from the GRUU, this is not an attack, and\n   the\
    \ call will be handled normally.\n   A malicious user in the system might try\
    \ to use a GRUU for launching\n   a DoS attack against another SIP UA.  To do\
    \ that, it would wait for a\n   call from that UA, and from it, observe their\
    \ GRUU.  Once the GRUU is\n   obtained, the UA would launch a SIP request to an\
    \ entity, such as a\n   presence server, which will generate many requests back\
    \ towards the\n   UA.  However, the attacker will use the target's GRUU in the\
    \ Contact\n   header field of that SUBSCRIBE request.  This will cause the traffic\n\
    \   to be directed towards the target instead.  Since the GRUU is\n   globally\
    \ routable, such traffic is more likely to be delivered to the\n   target than\
    \ traffic sent to its IP address.  This specification helps\n   mitigate this\
    \ attack by requiring proxies to validate that the GRUU\n   in the Contact of\
    \ a request matches the authenticated identity of the\n   sender of the request.\
    \  This check requires the use of an outbound\n   proxy.  SIP does not require\
    \ outbound proxies, and this does leave a\n   potential area of vulnerability.\
    \  However, in practice, nearly all\n   deployments of SIP utilize an outbound\
    \ proxy, and therefore this\n   vulnerability is not likely to be a concern.\n"
- title: 10.3.  Privacy Considerations
  contents:
  - "10.3.  Privacy Considerations\n   RFC 3323 [15] defines mechanisms for privacy.\
    \  It distinguishes\n   between network-provided privacy and user-provided privacy.\
    \  In the\n   former, the user requests privacy services from the network by\n\
    \   including a Privacy header field in the request.  In the latter, the\n   UA\
    \ follows a basic set of guidelines for construction of its request,\n   so a\
    \ certain level of privacy is afforded.\n   The guidelines in Section 4.1 of RFC\
    \ 3323 [15] for user-provided\n   privacy request that a UA construct its Contact\
    \ header field with a\n   URI that omits a user part, and utilizes the IP address\
    \ or hostname\n   of the UA.  Such recommendations are in conflict with the rules\n\
    \   defined in this specification, which require the usage of a GRUU in\n   the\
    \ Contact header field.\n   However, the temporary GRUUs provided by the registrar\
    \ can be used in\n   place of the Contact URI format described in RFC 3323 [15].\
    \  A user\n   agent would gather the temporary GRUU returned in each REGISTER\n\
    \   response, and keep a small number of them cached.  When it makes or\n   receives\
    \ a call, a temporary GRUU is used to populate the Contact\n   header field.\n\
    \   A UA can either elect to use the same temporary GRUU in each call, or\n  \
    \ it can use a different temporary GRUU in each call.  The choice\n   depends\
    \ on the level of privacy desired:\n   o  A UA utilizing the same temporary GRUU\
    \ for each call will allow a\n      correspondent, based solely on investigation\
    \ of the Contact header\n      field, to correlate calls as coming from the same\
    \ UA.  This is\n      also true for the user-provided privacy procedures in RFC\
    \ 3323\n      [15], since the IP address or hostname in the Contact URI provides\n\
    \      a similar correlator.\n   o  A UA utilizing a different temporary GRUU\
    \ for each call will not\n      allow a correspondent, based solely on investigation\
    \ of the\n      Contact header field, to correlate calls as coming from the same\n\
    \      UA.\n   o  In both cases, absent network-provided privacy, IP address and\n\
    \      port information in the Session Description Protocol (SDP)\n      (defined\
    \ in [10]) will allow a correspondent to correlate calls as\n      coming from\
    \ the same UA.\n   o  In both cases, if a user makes a call, the correspondent\
    \ will be\n      able to call back by directing requests towards the GRUU in the\n\
    \      Contact header field.  Similarly, features such as transfer and\n     \
    \ digit collection by network application servers (see RFC 4730\n      [20]),\
    \ which depend on a Contact with the GRUU property, will also\n      be possible.\
    \  These kinds of inbound requests will be possible\n      until the registration\
    \ for that UA lapses.  A UA that wishes to\n      invalidate its previous temporary\
    \ GRUU in order to limit\n      reachability MAY do so by generating a REGISTER\
    \ refresh with a\n      Call-ID that differs from ones used previously.  A UA\
    \ SHOULD NOT\n      forcefully expire its registration and then re-register in\
    \ order\n      to invalidate a temporary GRUU; this results in a brief period\
    \ of\n      unreachability and will often produce excess load on the network.\n\
    \      Refreshing with a new Call-ID is more efficient and is meant as\n     \
    \ the technique for coarse-grained control over the validity of\n      temporary\
    \ GRUUs.  A UA wishing to not be disturbed by a specific\n      call back will\
    \ need to implement manual or automated call-handling\n      procedures to reject\
    \ it.  This specification does not provide the\n      UA the ability to manually\
    \ invalidate individual temporary GRUUs.\n      If a UA insists on not receiving\
    \ any such inbound requests\n      (including ones generated by network applications,\
    \ such as those\n      used for collecting digits), the UA can place a non-GRUU\
    \ into the\n      Contact header field.  However, this is NOT RECOMMENDED.  Usage\
    \ of\n      a GRUU coupled with automated call rejection features is far\n   \
    \   superior.\n   o  As long as a temporary GRUU is used to populate the Contact\
    \ header\n      field, a correspondent will not be able to ascertain any\n   \
    \   information about the AOR or instance ID of the UA by inspection\n      of\
    \ the Contact header field.  However, absent a network-provided\n      privacy\
    \ service, the IP address in the SDP can be used to\n      determine information\
    \ about the UA, such as its geographic\n      location and ISP.\n   o  In all\
    \ cases, regardless of whether the UA uses a temporary or\n      public GRUU in\
    \ the Contact, regardless of whether it utilizes GRUU\n      at all, and regardless\
    \ of whether it invokes a network-provided\n      privacy service, a correspondent\
    \ will be able to determine the SIP\n      service provider of the UA.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   This specification defines two new Contact header\
    \ field parameters,\n   one SIP URI parameter, and a SIP option tag.\n"
- title: 11.1.  Header Field Parameter
  contents:
  - "11.1.  Header Field Parameter\n   This specification defines two new header field\
    \ parameters, as per\n   the registry created by RFC 3968 [8].  The required information\
    \ is as\n   follows:\n   Header field in which the parameter can appear:  Contact\n\
    \   Name of the Parameter:  pub-gruu\n   Predefined Values:  none\n   RFC Reference:\
    \  RFC 5627\n   Header field in which the parameter can appear:  Contact\n   Name\
    \ of the Parameter:  temp-gruu\n   Predefined Values:  none\n   RFC Reference:\
    \  RFC 5627\n"
- title: 11.2.  URI Parameter
  contents:
  - "11.2.  URI Parameter\n   This specification defines one new SIP URI parameter,\
    \ as per the\n   registry created by RFC 3969 [9].\n   Name of the Parameter:\
    \  gr\n   Predefined Values:  none\n   RFC Reference:  RFC 5627\n"
- title: 11.3.  SIP Option Tag
  contents:
  - "11.3.  SIP Option Tag\n   This specification registers a new SIP option tag,\
    \ as per the\n   guidelines in Section 27.1 of RFC 3261 [1].\n   Name:  gruu\n\
    \   Description:  This option tag is used to identify the Globally\n      Routable\
    \ User Agent URI (GRUU) extension.  When used in a\n      Supported header, it\
    \ indicates that a User Agent understands the\n      extension.  When used in\
    \ a Require header field of a REGISTER\n      request, it indicates that the registrar\
    \ is not expected to\n      process the registration unless it supports the GRUU\
    \ extension.\n"
- title: 12.  Acknowledgments
  contents:
  - "12.  Acknowledgments\n   The author would like to thank Eric Rescorla, Robert\
    \ Sparks, Rohan\n   Mahy, Paul Kyzivat, Alan Johnston, Ya-Ching Tan, Dale Worley,\
    \ Jeroen\n   van Bemmel, Vijay Gurbani, Andrew Allen, Alan Hawrylyshen, Francois\n\
    \   Audet, Fredrik Thulin, Dean Willis, David Hancock, Keith Drage, and\n   Cullen\
    \ Jennings for their comments and contributions to this work.\n   Eric Rescorla\
    \ provided the text for the introduction and the GRUU\n   construction algorithm\
    \ in the appendix.\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [1]   Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G., Johnston, A.,\n         Peterson, J., Sparks, R., Handley, M., and E. Schooler,\
    \ \"SIP:\n         Session Initiation Protocol\", RFC 3261, June 2002.\n   [2]\
    \   Rosenberg, J. and H. Schulzrinne, \"Session Initiation Protocol\n        \
    \ (SIP): Locating SIP Servers\", RFC 3263, June 2002.\n   [3]   Willis, D. and\
    \ B. Hoeneisen, \"Session Initiation Protocol (SIP)\n         Extension Header\
    \ Field for Registering Non-Adjacent Contacts\",\n         RFC 3327, December\
    \ 2002.\n   [4]   Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n\
    \         Levels\", BCP 14, RFC 2119, March 1997.\n   [5]   Roach, A., \"Session\
    \ Initiation Protocol (SIP)-Specific Event\n         Notification\", RFC 3265,\
    \ June 2002.\n   [6]   Sparks, R., \"The Session Initiation Protocol (SIP) Refer\n\
    \         Method\", RFC 3515, April 2003.\n   [7]   Rosenberg, J., Schulzrinne,\
    \ H., and P. Kyzivat, \"Indicating\n         User Agent Capabilities in the Session\
    \ Initiation Protocol\n         (SIP)\", RFC 3840, August 2004.\n   [8]   Camarillo,\
    \ G., \"The Internet Assigned Number Authority (IANA)\n         Header Field Parameter\
    \ Registry for the Session Initiation\n         Protocol (SIP)\", BCP 98, RFC\
    \ 3968, December 2004.\n   [9]   Camarillo, G., \"The Internet Assigned Number\
    \ Authority (IANA)\n         Uniform Resource Identifier (URI) Parameter Registry\
    \ for the\n         Session Initiation Protocol (SIP)\", BCP 99, RFC 3969,\n \
    \        December 2004.\n   [10]  Handley, M., Jacobson, V., and C. Perkins, \"\
    SDP: Session\n         Description Protocol\", RFC 4566, July 2006.\n   [11] \
    \ Schulzrinne, H., \"The tel URI for Telephone Numbers\", RFC 3966,\n        \
    \ December 2004.\n   [12]  Rosenberg, J., Schulzrinne, H., and P. Kyzivat, \"\
    Caller\n         Preferences for the Session Initiation Protocol (SIP)\",\n  \
    \       RFC 3841, August 2004.\n   [13]  Crocker, D. and P. Overell, \"Augmented\
    \ BNF for Syntax\n         Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n\
    \   [14]  Jennings, C., Ed. and R. Mahy, Ed., \"Managing Client-Initiated\n  \
    \       Connections in the Session Initiation Protocol (SIP)\",\n         RFC\
    \ 5626, October 2009.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [15]  Peterson, J., \"A Privacy Mechanism for\
    \ the Session Initiation\n         Protocol (SIP)\", RFC 3323, November 2002.\n\
    \   [16]  Rosenberg, J., Schulzrinne, H., and R. Mahy, \"An INVITE-\n        \
    \ Initiated Dialog Event Package for the Session Initiation\n         Protocol\
    \ (SIP)\", RFC 4235, November 2005.\n   [17]  Sparks, R., Hawrylyshen, A., Johnston,\
    \ A., Rosenberg, J., and\n         H. Schulzrinne, \"Session Initiation Protocol\
    \ (SIP) Torture Test\n         Messages\", RFC 4475, May 2006.\n   [18]  Schulzrinne,\
    \ H., \"Dynamic Host Configuration Protocol (DHCP-\n         for-IPv4) Option\
    \ for Session Initiation Protocol (SIP)\n         Servers\", RFC 3361, August\
    \ 2002.\n   [19]  Sparks, R., Johnston, A., and D. Petrie, \"Session Initiation\n\
    \         Protocol (SIP) Call Control - Transfer\", BCP 149, RFC 5589,\n     \
    \    June 2009.\n   [20]  Burger, E. and M. Dolly, \"A Session Initiation Protocol\
    \ (SIP)\n         Event Package for Key Press Stimulus (KPML)\", RFC 4730,\n \
    \        November 2006.\n   [21]  Mahy, R. and D. Petrie, \"The Session Initiation\
    \ Protocol (SIP)\n         \"Join\" Header\", RFC 3911, October 2004.\n   [22]\
    \  Mahy, R., Biggs, B., and R. Dean, \"The Session Initiation\n         Protocol\
    \ (SIP) \"Replaces\" Header\", RFC 3891, September 2004.\n   [23]  Willis, D.\
    \ and B. Hoeneisen, \"Session Initiation Protocol (SIP)\n         Extension Header\
    \ Field for Service Route Discovery During\n         Registration\", RFC 3608,\
    \ October 2003.\n   [24]  Rosenberg, J., \"A Session Initiation Protocol (SIP)\
    \ Event\n         Package for Registrations\", RFC 3680, March 2004.\n   [25]\
    \  Camarillo, G., \"Compressing the Session Initiation Protocol\n         (SIP)\"\
    , RFC 3486, February 2003.\n   [26]  Burger, E., Van Dyke, J., and A. Spitzer,\
    \ \"Basic Network Media\n         Services with SIP\", RFC 4240, December 2005.\n\
    \   [27]  Jennings, C., Audet, F., and J. Elwell, \"Session Initiation\n     \
    \    Protocol (SIP) URIs for Applications such as Voicemail and\n         Interactive\
    \ Voice Response (IVR)\", RFC 4458, April 2006.\n   [28]  Kyzivat, P., \"Registration\
    \ Event Package Extension for Session\n         Initiation Protocol (SIP) Globally\
    \ Routable User Agent URIs\n         (GRUUs)\", RFC 5628, October 2009.\n   [29]\
    \  Rosenberg, J., van Elburg, J., Holmberg, C., Audet, F., and S.\n         Schubert,\
    \ Ed., \"Delivery of Request-URI Targets to User\n         Agents\", Work in Progress,\
    \ June 2009.\n"
- title: Appendix A.  Example GRUU Construction Algorithms
  contents:
  - "Appendix A.  Example GRUU Construction Algorithms\n   The mechanism for constructing\
    \ a GRUU is not subject to\n   specification.  This appendix provides an example\
    \ that can be used by\n   a registrar to construct a public and a temporary GRUU.\
    \  Of course,\n   others are permitted, as long as they meet the constraints defined\n\
    \   for a GRUU.\n"
- title: A.1.  Public GRUU
  contents:
  - "A.1.  Public GRUU\n   The most basic approach for constructing a public GRUU\
    \ is to take the\n   AOR and place the actual value of the instance ID into the\
    \ contents\n   of the \"gr\" URI parameter.\n"
- title: A.2.  Temporary GRUU
  contents:
  - "A.2.  Temporary GRUU\n   This specification requires a registrar to create a\
    \ new temporary\n   GRUU on each registration refresh.  If a registration is very\
    \ long\n   lived, this can quickly result in hundreds or even thousands of\n \
    \  temporary GRUUs being created and allocated to a UA.  Consequently,\n   it\
    \ is important to have an algorithm for constructing temporary GRUUs\n   that\
    \ does not require additional storage that grows in size with the\n   number of\
    \ temporary GRUUs.  The following algorithm meets this goal.\n   The registrar\
    \ maintains a counter, I. This counter is 48 bits and is\n   initialized to zero.\
    \  The counter is persistently stored, using a\n   backend database or other similar\
    \ technique.  When the registrar\n   creates the first temporary GRUU for a particular\
    \ AOR and instance\n   ID, the registrar notes the current value of the counter,\
    \ I_i, and\n   increments the counter in the database.  The registrar then maps\
    \ I_i\n   to the AOR and instance ID using the database, a persistent hashmap\n\
    \   or similar technology.  If the registration expires such that there\n   are\
    \ no longer any contacts with that particular instance ID bound to\n   the GRUU,\
    \ the registrar removes the mapping.  Similarly, if the\n   temporary GRUUs are\
    \ invalidated due to a change in Call-ID, the\n   registrar removes the current\
    \ mapping from I_i to the AOR and\n   instance ID, notes the current value of\
    \ the counter I_j, and stores a\n   mapping from I_j to the AOR and instance ID.\
    \  Based on these rules,\n   the hashmap will contain a single mapping for each\
    \ AOR and instance\n   ID for which there is a currently valid registration.\n\
    \   The usage of a counter in a 48-bit space with sequential assignment\n   allows\
    \ for a compact representation of the hashmap key, which is\n   important for\
    \ generating GRUUs of reasonable size.  The counter\n   starts at zero when the\
    \ system is initialized.  Persistent and\n   reliable storage of the counter is\
    \ required to avoid misrouting of a\n   GRUU to the wrong AOR and instance ID.\
    \  Similarly, persistent storage\n   of the hashmap is required, even through\
    \ proxy and registrar\n   restarts.  If the hashmap is reset, all previous temporary\
    \ GRUUs\n   become invalidated.  This might cause dialogs in progress to fail,\
    \ or\n   future requests towards a temporary GRUU to fail when they normally\n\
    \   would not.  The same hashmap needs to be accessible by all proxies\n   and\
    \ registrars that can field requests for a particular AOR and\n   instance ID.\n\
    \   The registrar maintains a pair of local symmetric keys K_e and K_a.\n   These\
    \ are regenerated every time the counter is reset.  When the\n   counter rolls\
    \ over or is reset, the registrar remembers the old\n   values of K_e and K_a\
    \ for a time.  Like the hashmap itself, these\n   keys need to be shared across\
    \ all proxy and registrars that can\n   service requests for a particular AOR\
    \ and instance ID.\n   To generate a new temporary GRUU, the registrar generates\
    \ a random\n   80-bit distinguisher value D. It then computes:\n   M = D || I_i\n\
    \   E = AES-ECB-Encrypt(K_e, M)\n   A = HMAC-SHA256-80(K_a, E)\n   Temp-Gruu-userpart\
    \ = \"tgruu.\" || base64(E) || base64(A)\n   where || denotes concatenation, and\
    \ AES-ECB-Encrypt represents AES\n   encryption in electronic codebook mode. \
    \ M will be 128 bits long,\n   producing a value of E that is 128 bits and A that\
    \ is 80 bits.  This\n   produces a user part which has 42 characters.\n   When\
    \ a proxy receives a request whose user part begins with \"tgruu.\",\n   it extracts\
    \ the remaining portion, and splits it into 22 characters\n   (E') and the remaining\
    \ 14 characters (A').  It then computes A and E\n   by performing a base64 decode\
    \ of A' and E' respectively.  Next, it\n   computes:\n   Ac = HMAC-SHA256-80(K_a,\
    \ E)\n   If the counter has rolled over or reset, this computation is\n   performed\
    \ with the current and previous K_a.  If the Ac value(s) that\n   are computed\
    \ do not match the value of A extracted from the GRUU, the\n   GRUU is rejected\
    \ as invalid.  Next, the proxy computes:\n   M = AES-ECB-Decrypt(K_e, E)\n   If\
    \ the counter has rolled over, this computation is done using the\n   value of\
    \ K_e that goes with the value of K_a, which produced a valid\n   Ac in the previous\
    \ HMAC validation.  The leading 80 bits (the\n   distinguisher D) are discarded,\
    \ leaving an index I_i in the hashmap.\n   This index is looked up.  If it exists,\
    \ the proxy now has the AOR and\n   instance ID corresponding to this temporary\
    \ GRUU.  If there is\n   nothing in the hashmap for the key I_i, the GRUU is no\
    \ longer valid\n   and the request is rejected.\n   The usage of a 48-bit counter\
    \ allows for the registrar to have as\n   many as a billion AORs, with 10 instances\
    \ per AOR, and cycle through\n   10,000 Call-ID changes for each instance through\
    \ the duration of a\n   single registration.  These numbers reflect the average;\
    \ the system\n   works fine if a particular AOR has more than 10 instances or\
    \ a\n   particular instance cycles through more than 10,000 Call-IDs in its\n\
    \   registration, as long as the average meets these constraints.\n"
- title: Appendix B.  Network Design Considerations
  contents:
  - "Appendix B.  Network Design Considerations\n   The GRUU specification works properly\
    \ based on logic implemented at\n   the user agents and in the authoritative proxies\
    \ on both sides of a\n   call.  Consequently, it is possible to construct network\
    \ deployments\n   in which GRUUs will not work properly.\n   One important assumption\
    \ made by the GRUU mechanism is that, if a\n   request passes through any proxies\
    \ in the originating domain prior to\n   visiting the terminating domain, one\
    \ of those proxies will be the\n   authoritative proxy for the User Agent Client\
    \ (UAC).  Administrators\n   of SIP networks will need to make sure that this\
    \ property is\n   retained.  There are several ways it can be accomplished:\n\
    \   1.  If the user agents support the service-route mechanism [23], the\n   \
    \    registrar can implement it and return a service route that points\n     \
    \  to the authoritative proxy.  This will cause requests originated\n       by\
    \ the user agent to pass through the authoritative proxy.\n   2.  The user agents\
    \ can be configured to never use an outbound proxy,\n       and send requests\
    \ directly to the domain of the terminating\n       party.  This configuration\
    \ is not practical in many use cases,\n       but it is a solution to this requirement.\n\
    \   3.  The user agents can be configured with an outbound proxy in the\n    \
    \   same domain as the authoritative proxy, and this outbound proxy\n       forwards\
    \ requests to the authoritative proxy by default.  This\n       works very well\
    \ in cases where the clients are not roaming; in\n       such cases, the outbound\
    \ proxy in a visited network may be\n       discovered dynamically through DHCP\
    \ [18].\n   4.  In cases where the client discovers a local outbound proxy via\
    \ a\n       mechanism such as DHCP, and is not implementing the service route\n\
    \       mechanism, the UA can be configured to automatically add an\n       additional\
    \ Route header field after the outbound proxy, which\n       points to a proxy\
    \ in the home network.  This has the same net\n       effect of the service route\
    \ mechanism, but is accomplished\n       through static configuration.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Jonathan Rosenberg\n   Cisco Systems\n   Edison, NJ\n  \
    \ US\n   EMail: jdrosen@cisco.com\n   URI:   http://www.jdrosen.net\n"
