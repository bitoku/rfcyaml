- title: __initial_text__
  contents:
  - '          Automatic Certificate Management Environment (ACME)

    '
- title: Abstract
  contents:
  - "Abstract\n   Public Key Infrastructure using X.509 (PKIX) certificates are used\n\
    \   for a number of purposes, the most significant of which is the\n   authentication\
    \ of domain names.  Thus, certification authorities\n   (CAs) in the Web PKI are\
    \ trusted to verify that an applicant for a\n   certificate legitimately represents\
    \ the domain name(s) in the\n   certificate.  As of this writing, this verification\
    \ is done through a\n   collection of ad hoc mechanisms.  This document describes\
    \ a protocol\n   that a CA and an applicant can use to automate the process of\n\
    \   verification and certificate issuance.  The protocol also provides\n   facilities\
    \ for other certificate management functions, such as\n   certificate revocation.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8555.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Deployment Model and Operator Experience ........................5\n  \
    \ 3. Terminology .....................................................7\n   4.\
    \ Protocol Overview ...............................................7\n   5. Character\
    \ Encoding .............................................10\n   6. Message Transport\
    \ ..............................................10\n      6.1. HTTPS Requests\
    \ ............................................10\n      6.2. Request Authentication\
    \ ....................................11\n      6.3. GET and POST-as-GET Requests\
    \ ..............................13\n      6.4. Request URL Integrity .....................................13\n\
    \           6.4.1. \"url\" (URL) JWS Header Parameter ...................14\n\
    \      6.5. Replay Protection .........................................14\n  \
    \         6.5.1. Replay-Nonce .......................................15\n    \
    \       6.5.2. \"nonce\" (Nonce) JWS Header Parameter ...............16\n    \
    \  6.6. Rate Limits ...............................................16\n      6.7.\
    \ Errors ....................................................16\n           6.7.1.\
    \ Subproblems ........................................18\n   7. Certificate Management\
    \ .........................................20\n      7.1. Resources .................................................20\n\
    \           7.1.1. Directory ..........................................23\n  \
    \         7.1.2. Account Objects ....................................24\n    \
    \       7.1.3. Order Objects ......................................26\n      \
    \     7.1.4. Authorization Objects ..............................28\n        \
    \   7.1.5. Challenge Objects ..................................30\n          \
    \ 7.1.6. Status Changes .....................................30\n      7.2. Getting\
    \ a Nonce ...........................................34\n      7.3. Account Management\
    \ ........................................34\n           7.3.1. Finding an Account\
    \ URL Given a Key .................36\n           7.3.2. Account Update .....................................37\n\
    \           7.3.3. Changes of Terms of Service ........................38\n  \
    \         7.3.4. External Account Binding ...........................38\n    \
    \       7.3.5. Account Key Rollover ...............................40\n      \
    \     7.3.6. Account Deactivation ...............................43\n      7.4.\
    \ Applying for Certificate Issuance .........................44\n           7.4.1.\
    \ Pre-authorization ..................................49\n           7.4.2. Downloading\
    \ the Certificate ........................51\n      7.5. Identifier Authorization\
    \ ..................................53\n           7.5.1. Responding to Challenges\
    \ ...........................54\n           7.5.2. Deactivating an Authorization\
    \ ......................57\n      7.6. Certificate Revocation ....................................58\n\
    \   8. Identifier Validation Challenges ...............................60\n  \
    \    8.1. Key Authorizations ........................................62\n    \
    \  8.2. Retrying Challenges .......................................63\n      8.3.\
    \ HTTP Challenge ............................................63\n      8.4. DNS\
    \ Challenge .............................................66\n   9. IANA Considerations\
    \ ............................................68\n      9.1. Media Type: application/pem-certificate-chain\
    \ .............68\n      9.2. Well-Known URI for the HTTP Challenge .....................69\n\
    \      9.3. Replay-Nonce HTTP Header ..................................69\n  \
    \    9.4. \"url\" JWS Header Parameter ................................70\n  \
    \    9.5. \"nonce\" JWS Header Parameter ..............................70\n  \
    \    9.6. URN Sub-namespace for ACME (urn:ietf:params:acme) .........70\n    \
    \  9.7. New Registries ............................................71\n      \
    \     9.7.1. Fields in Account Objects ..........................71\n        \
    \   9.7.2. Fields in Order Objects ............................72\n          \
    \ 9.7.3. Fields in Authorization Objects ....................73\n           9.7.4.\
    \ Error Types ........................................74\n           9.7.5. Resource\
    \ Types .....................................74\n           9.7.6. Fields in the\
    \ \"meta\" Object within a\n                  Directory Object ...................................75\n\
    \           9.7.7. Identifier Types ...................................76\n  \
    \         9.7.8. Validation Methods .................................76\n   10.\
    \ Security Considerations .......................................78\n      10.1.\
    \ Threat Model .............................................78\n      10.2. Integrity\
    \ of Authorizations ..............................80\n      10.3. Denial-of-Service\
    \ Considerations .........................83\n      10.4. Server-Side Request\
    \ Forgery ..............................84\n      10.5. CA Policy Considerations\
    \ .................................84\n   11. Operational Considerations ....................................86\n\
    \      11.1. Key Selection ............................................86\n  \
    \    11.2. DNS Security .............................................87\n    \
    \  11.3. Token Entropy ............................................88\n      11.4.\
    \ Malformed Certificate Chains .............................88\n   12. References\
    \ ....................................................88\n      12.1. Normative\
    \ References .....................................88\n      12.2. Informative\
    \ References ...................................92\n   Acknowledgements ..................................................94\n\
    \   Authors' Addresses ................................................95\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Certificates [RFC5280] in the Web PKI are most commonly\
    \ used to\n   authenticate domain names.  Thus, certification authorities (CAs)\
    \ in\n   the Web PKI are trusted to verify that an applicant for a certificate\n\
    \   legitimately represents the domain name(s) in the certificate.\n   Different\
    \ types of certificates reflect different kinds of CA\n   verification of information\
    \ about the certificate subject.  \"Domain\n   Validation\" (DV) certificates\
    \ are by far the most common type.  The\n   only validation the CA is required\
    \ to perform in the DV issuance\n   process is to verify that the requester has\
    \ effective control of the\n   domain [CABFBR].  The CA is not required to attempt\
    \ to verify the\n   requester's real-world identity.  (This is as opposed to\n\
    \   \"Organization Validation\" (OV) and \"Extended Validation\" (EV)\n   certificates,\
    \ where the process is intended to also verify the real-\n   world identity of\
    \ the requester.)\n   Existing Web PKI certification authorities tend to use a\
    \ set of ad\n   hoc protocols for certificate issuance and identity verification.\
    \  In\n   the case of DV certificates, a typical user experience is something\n\
    \   like:\n   o  Generate a PKCS#10 [RFC2986] Certificate Signing Request (CSR).\n\
    \   o  Cut and paste the CSR into a CA's web page.\n   o  Prove ownership of the\
    \ domain(s) in the CSR by one of the\n      following methods:\n      *  Put a\
    \ CA-provided challenge at a specific place on the web\n         server.\n   \
    \   *  Put a CA-provided challenge in a DNS record corresponding to\n        \
    \ the target domain.\n      *  Receive a CA-provided challenge at (hopefully)\
    \ an\n         administrator-controlled email address corresponding to the\n \
    \        domain, and then respond to it on the CA's web page.\n   o  Download\
    \ the issued certificate and install it on the user's Web\n      Server.\n   With\
    \ the exception of the CSR itself and the certificates that are\n   issued, these\
    \ are all completely ad hoc procedures and are\n   accomplished by getting the\
    \ human user to follow interactive natural-\n   language instructions from the\
    \ CA rather than by machine-implemented\n   published protocols.  In many cases,\
    \ the instructions are difficult\n   to follow and cause significant frustration\
    \ and confusion.  Informal\n   usability tests by the authors indicate that webmasters\
    \ often need\n   1-3 hours to obtain and install a certificate for a domain. \
    \ Even in\n   the best case, the lack of published, standardized mechanisms\n\
    \   presents an obstacle to the wide deployment of HTTPS and other PKIX-\n   dependent\
    \ systems because it inhibits mechanization of tasks related\n   to certificate\
    \ issuance, deployment, and revocation.\n   This document describes an extensible\
    \ framework for automating the\n   issuance and domain validation procedure, thereby\
    \ allowing servers\n   and infrastructure software to obtain certificates without\
    \ user\n   interaction.  Use of this protocol should radically simplify the\n\
    \   deployment of HTTPS and the practicality of PKIX-based authentication\n  \
    \ for other protocols based on Transport Layer Security (TLS)\n   [RFC8446].\n\
    \   It should be noted that while the focus of this document is on\n   validating\
    \ domain names for purposes of issuing certificates in the\n   Web PKI, ACME supports\
    \ extensions for uses with other identifiers in\n   other PKI contexts.  For example,\
    \ as of this writing, there is\n   ongoing work to use ACME for issuance of Web\
    \ PKI certificates\n   attesting to IP addresses [ACME-IP] and Secure Telephone\
    \ Identity\n   Revisited (STIR) certificates attesting to telephone numbers\n\
    \   [ACME-TELEPHONE].\n   ACME can also be used to automate some aspects of certificate\n\
    \   management even where non-automated processes are still needed.  For\n   example,\
    \ the external account binding feature (see Section 7.3.4) can\n   allow an ACME\
    \ account to use authorizations that have been granted to\n   an external, non-ACME\
    \ account.  This allows ACME to address issuance\n   scenarios that cannot yet\
    \ be fully automated, such as the issuance of\n   \"Extended Validation\" certificates.\n"
- title: 2.  Deployment Model and Operator Experience
  contents:
  - "2.  Deployment Model and Operator Experience\n   The guiding use case for ACME\
    \ is obtaining certificates for websites\n   (HTTPS [RFC2818]).  In this case,\
    \ a web server is intended to speak\n   for one or more domains, and the process\
    \ of certificate issuance is\n   intended to verify that this web server actually\
    \ speaks for the\n   domain(s).\n   DV certificate validation commonly checks\
    \ claims about properties\n   related to control of a domain name -- properties\
    \ that can be\n   observed by the certificate issuer in an interactive process\
    \ that can\n   be conducted purely online.  That means that under typical\n  \
    \ circumstances, all steps in the request, verification, and issuance\n   process\
    \ can be represented and performed by Internet protocols with\n   no out-of-band\
    \ human intervention.\n   Prior to ACME, when deploying an HTTPS server, a server\
    \ operator\n   typically gets a prompt to generate a self-signed certificate.\
    \  If\n   the operator were instead deploying an HTTPS server using ACME, the\n\
    \   experience would be something like this:\n   o  The operator's ACME client\
    \ prompts the operator for the intended\n      domain name(s) that the web server\
    \ is to stand for.\n   o  The ACME client presents the operator with a list of\
    \ CAs from\n      which it could get a certificate.  (This list will change over\n\
    \      time based on the capabilities of CAs and updates to ACME\n      configuration.)\
    \  The ACME client might prompt the operator for\n      payment information at\
    \ this point.\n   o  The operator selects a CA.\n   o  In the background, the\
    \ ACME client contacts the CA and requests\n      that it issue a certificate\
    \ for the intended domain name(s).\n   o  The CA verifies that the client controls\
    \ the requested domain\n      name(s) by having the ACME client perform some action(s)\
    \ that can\n      only be done with control of the domain name(s).  For example,\
    \ the\n      CA might require a client requesting example.com to provision a\n\
    \      DNS record under example.com or an HTTP resource under\n      http://example.com.\n\
    \   o  Once the CA is satisfied, it issues the certificate and the ACME\n    \
    \  client automatically downloads and installs it, potentially\n      notifying\
    \ the operator via email, SMS, etc.\n   o  The ACME client periodically contacts\
    \ the CA to get updated\n      certificates, stapled Online Certificate Status\
    \ Protocol (OCSP)\n      responses [RFC6960], or whatever else would be required\
    \ to keep\n      the web server functional and its credentials up to date.\n \
    \  In this way, it would be nearly as easy to deploy with a CA-issued\n   certificate\
    \ as with a self-signed certificate.  Furthermore, the\n   maintenance of that\
    \ CA-issued certificate would require minimal\n   manual intervention.  Such close\
    \ integration of ACME with HTTPS\n   servers allows the immediate and automated\
    \ deployment of certificates\n   as they are issued, sparing the human administrator\
    \ from much of the\n   time-consuming work described in the previous section.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n\
    \   capitals, as shown here.\n   The two main roles in ACME are \"client\" and\
    \ \"server\".  The ACME\n   client uses the protocol to request certificate management\
    \ actions,\n   such as issuance or revocation.  An ACME client may run on a web\n\
    \   server, mail server, or some other server system that requires valid\n   X.509\
    \ certificates.  Or, it may run on a separate server that does\n   not consume\
    \ the certificate but is authorized to respond to a CA-\n   provided challenge.\
    \  The ACME server runs at a certification\n   authority and responds to client\
    \ requests, performing the requested\n   actions if the client is authorized.\n\
    \   An ACME client authenticates to the server by means of an \"account\n   key\
    \ pair\".  The client uses the private key of this key pair to sign\n   all messages\
    \ sent to the server.  The server uses the public key to\n   verify the authenticity\
    \ and integrity of messages from the client.\n"
- title: 4.  Protocol Overview
  contents:
  - "4.  Protocol Overview\n   ACME allows a client to request certificate management\
    \ actions using\n   a set of JavaScript Object Notation (JSON) messages [RFC8259]\
    \ carried\n   over HTTPS [RFC2818].  Issuance using ACME resembles a traditional\n\
    \   CA's issuance process, in which a user creates an account, requests a\n  \
    \ certificate, and proves control of the domain(s) in that certificate\n   in\
    \ order for the CA to issue the requested certificate.\n   The first phase of\
    \ ACME is for the client to request an account with\n   the ACME server.  The\
    \ client generates an asymmetric key pair and\n   requests a new account, optionally\
    \ providing contact information,\n   agreeing to terms of service (ToS), and/or\
    \ associating the account\n   with an existing account in another system.  The\
    \ creation request is\n   signed with the generated private key to prove that\
    \ the client\n   controls it.\n         Client                               \
    \                    Server\n         [Contact Information]\n         [ToS Agreement]\n\
    \         [Additional Data]\n         Signature                     ------->\n\
    \                                                             Account URL\n  \
    \                                     <-------           Account Object\n    \
    \               [] Information covered by request signatures\n               \
    \              Account Creation\n   Once an account is registered, there are four\
    \ major steps the client\n   needs to take to get a certificate:\n   1.  Submit\
    \ an order for a certificate to be issued\n   2.  Prove control of any identifiers\
    \ requested in the certificate\n   3.  Finalize the order by submitting a CSR\n\
    \   4.  Await issuance and download the issued certificate\n   The client's order\
    \ for a certificate describes the desired\n   identifiers plus a few additional\
    \ fields that capture semantics that\n   are not supported in the CSR format.\
    \  If the server is willing to\n   consider issuing such a certificate, it responds\
    \ with a list of\n   requirements that the client must satisfy before the certificate\
    \ will\n   be issued.\n   For example, in most cases, the server will require\
    \ the client to\n   demonstrate that it controls the identifiers in the requested\n\
    \   certificate.  Because there are many different ways to validate\n   possession\
    \ of different types of identifiers, the server will choose\n   from an extensible\
    \ set of challenges that are appropriate for the\n   identifier being claimed.\
    \  The client responds with a set of\n   responses that tell the server which\
    \ challenges the client has\n   completed.  The server then validates that the\
    \ client has completed\n   the challenges.\n   Once the validation process is\
    \ complete and the server is satisfied\n   that the client has met its requirements,\
    \ the client finalizes the\n   order by submitting a PKCS#10 Certificate Signing\
    \ Request (CSR).  The\n   server will issue the requested certificate and make\
    \ it available to\n   the client.\n         Client                           \
    \                        Server\n         [Order]\n         Signature        \
    \             ------->\n                                       <-------  Required\
    \ Authorizations\n         [Responses]\n         Signature                   \
    \  ------->\n                             <~~~~~~~~Validation~~~~~~~~>\n     \
    \    [CSR]\n         Signature                     ------->\n                \
    \                       <-------          Acknowledgement\n                  \
    \           <~~~~~~Await issuance~~~~~~>\n         [POST-as-GET request]\n   \
    \      Signature                     ------->\n                              \
    \         <-------              Certificate\n                   [] Information\
    \ covered by request signatures\n                           Certificate Issuance\n\
    \   To revoke a certificate, the client sends a signed revocation request\n  \
    \ indicating the certificate to be revoked:\n         Client                 \
    \                                Server\n         [Revocation request]\n     \
    \    Signature                    -------->\n                                \
    \      <--------                 Result\n                   [] Information covered\
    \ by request signatures\n                          Certificate Revocation\n  \
    \ Note that while ACME is defined with enough flexibility to handle\n   different\
    \ types of identifiers in principle, the primary use case\n   addressed by this\
    \ document is the case where domain names are used as\n   identifiers.  For example,\
    \ all of the identifier validation\n   challenges described in Section 8 address\
    \ validation of domain names.\n   The use of ACME for other identifiers will require\
    \ further\n   specification in order to describe how these identifiers are encoded\n\
    \   in the protocol and what types of validation challenges the server\n   might\
    \ require.\n"
- title: 5.  Character Encoding
  contents:
  - "5.  Character Encoding\n   All requests and responses sent via HTTP by ACME clients,\
    \ ACME\n   servers, and validation servers as well as any inputs for digest\n\
    \   computations MUST be encoded using the UTF-8 character set [RFC3629].\n  \
    \ Note that identifiers that appear in certificates may have their own\n   encoding\
    \ considerations (e.g., DNS names containing non-ASCII\n   characters are expressed\
    \ as A-labels rather than U-labels).  Any such\n   encoding considerations are\
    \ to be applied prior to the aforementioned\n   UTF-8 encoding.\n"
- title: 6.  Message Transport
  contents:
  - "6.  Message Transport\n   Communications between an ACME client and an ACME server\
    \ are done\n   over HTTPS, using JSON Web Signature (JWS) [RFC7515] to provide\
    \ some\n   additional security properties for messages sent from the client to\n\
    \   the server.  HTTPS provides server authentication and\n   confidentiality.\
    \  With some ACME-specific extensions, JWS provides\n   authentication of the\
    \ client's request payloads, anti-replay\n   protection, and integrity for the\
    \ HTTPS request URL.\n"
- title: 6.1.  HTTPS Requests
  contents:
  - "6.1.  HTTPS Requests\n   Each ACME function is accomplished by the client sending\
    \ a sequence\n   of HTTPS requests to the server [RFC2818], carrying JSON messages\n\
    \   [RFC8259].  Use of HTTPS is REQUIRED.  Each subsection of Section 7\n   below\
    \ describes the message formats used by the function and the\n   order in which\
    \ messages are sent.\n   In most HTTPS transactions used by ACME, the ACME client\
    \ is the HTTPS\n   client and the ACME server is the HTTPS server.  The ACME server\
    \ acts\n   as a client when validating challenges: an HTTP client when\n   validating\
    \ an 'http-01' challenge, a DNS client with 'dns-01', etc.\n   ACME servers SHOULD\
    \ follow the recommendations of [RFC7525] when\n   configuring their TLS implementations.\
    \  ACME servers that support TLS\n   1.3 MAY allow clients to send early data\
    \ (0-RTT).  This is safe\n   because the ACME protocol itself includes anti-replay\
    \ protections\n   (see Section 6.5) in all cases where they are required.  For\
    \ this\n   reason, there are no restrictions on what ACME data can be carried\
    \ in\n   0-RTT.\n   ACME clients MUST send a User-Agent header field, in accordance\
    \ with\n   [RFC7231].  This header field SHOULD include the name and version of\n\
    \   the ACME software in addition to the name and version of the\n   underlying\
    \ HTTP client software.\n   ACME clients SHOULD send an Accept-Language header\
    \ field in\n   accordance with [RFC7231] to enable localization of error messages.\n\
    \   ACME servers that are intended to be generally accessible need to use\n  \
    \ Cross-Origin Resource Sharing (CORS) in order to be accessible from\n   browser-based\
    \ clients [W3C.REC-cors-20140116].  Such servers SHOULD\n   set the Access-Control-Allow-Origin\
    \ header field to the value \"*\".\n   Binary fields in the JSON objects used\
    \ by ACME are encoded using\n   base64url encoding described in Section 5 of [RFC4648]\
    \ according to\n   the profile specified in JSON Web Signature in Section 2 of\n\
    \   [RFC7515].  This encoding uses a URL safe character set.  Trailing\n   '='\
    \ characters MUST be stripped.  Encoded values that include\n   trailing '=' characters\
    \ MUST be rejected as improperly encoded.\n"
- title: 6.2.  Request Authentication
  contents:
  - "6.2.  Request Authentication\n   All ACME requests with a non-empty body MUST\
    \ encapsulate their\n   payload in a JSON Web Signature (JWS) [RFC7515] object,\
    \ signed using\n   the account's private key unless otherwise specified.  The\
    \ server\n   MUST verify the JWS before processing the request.  Encapsulating\n\
    \   request bodies in JWS provides authentication of requests.\n   A JWS object\
    \ sent as the body of an ACME request MUST meet the\n   following additional criteria:\n\
    \   o  The JWS MUST be in the Flattened JSON Serialization [RFC7515]\n   o  The\
    \ JWS MUST NOT have multiple signatures\n   o  The JWS Unencoded Payload Option\
    \ [RFC7797] MUST NOT be used\n   o  The JWS Unprotected Header [RFC7515] MUST\
    \ NOT be used\n   o  The JWS Payload MUST NOT be detached\n   o  The JWS Protected\
    \ Header MUST include the following fields:\n      *  \"alg\" (Algorithm)\n  \
    \       +  This field MUST NOT contain \"none\" or a Message\n            Authentication\
    \ Code (MAC) algorithm (e.g. one in which the\n            algorithm registry\
    \ description mentions MAC/HMAC).\n      *  \"nonce\" (defined in Section 6.5)\n\
    \      *  \"url\" (defined in Section 6.4)\n      *  Either \"jwk\" (JSON Web\
    \ Key) or \"kid\" (Key ID) as specified\n         below\n   An ACME server MUST\
    \ implement the \"ES256\" signature algorithm\n   [RFC7518] and SHOULD implement\
    \ the \"EdDSA\" signature algorithm using\n   the \"Ed25519\" variant (indicated\
    \ by \"crv\") [RFC8037].\n   The \"jwk\" and \"kid\" fields are mutually exclusive.\
    \  Servers MUST\n   reject requests that contain both.\n   For newAccount requests,\
    \ and for revokeCert requests authenticated by\n   a certificate key, there MUST\
    \ be a \"jwk\" field.  This field MUST\n   contain the public key corresponding\
    \ to the private key used to sign\n   the JWS.\n   For all other requests, the\
    \ request is signed using an existing\n   account, and there MUST be a \"kid\"\
    \ field.  This field MUST contain\n   the account URL received by POSTing to the\
    \ newAccount resource.\n   If the client sends a JWS signed with an algorithm\
    \ that the server\n   does not support, then the server MUST return an error with\
    \ status\n   code 400 (Bad Request) and type\n   \"urn:ietf:params:acme:error:badSignatureAlgorithm\"\
    .  The problem\n   document returned with the error MUST include an \"algorithms\"\
    \ field\n   with an array of supported \"alg\" values.  See Section 6.7 for more\n\
    \   details on the structure of error responses.\n   If the server supports the\
    \ signature algorithm \"alg\" but either does\n   not support or chooses to reject\
    \ the public key \"jwk\", then the\n   server MUST return an error with status\
    \ code 400 (Bad Request) and\n   type \"urn:ietf:params:acme:error:badPublicKey\"\
    .  The problem document\n   detail SHOULD describe the reason for rejecting the\
    \ public key; some\n   example reasons are:\n   o  \"alg\" is \"RS256\" but the\
    \ modulus \"n\" is too small (e.g., 512-bit)\n   o  \"alg\" is \"ES256\" but \"\
    jwk\" does not contain a valid P-256 public\n      key\n   o  \"alg\" is \"EdDSA\"\
    \ and \"crv\" is \"Ed448\", but the server only\n      supports \"EdDSA\" with\
    \ \"Ed25519\"\n   o  the corresponding private key is known to have been compromised\n\
    \   Because client requests in ACME carry JWS objects in the Flattened\n   JSON\
    \ Serialization, they must have the Content-Type header field set\n   to \"application/jose+json\"\
    .  If a request does not meet this\n   requirement, then the server MUST return\
    \ a response with status code\n   415 (Unsupported Media Type).\n"
- title: 6.3.  GET and POST-as-GET Requests
  contents:
  - "6.3.  GET and POST-as-GET Requests\n   Note that authentication via signed JWS\
    \ request bodies implies that\n   requests without an entity body are not authenticated,\
    \ in particular\n   GET requests.  Except for the cases described in this section,\
    \ if the\n   server receives a GET request, it MUST return an error with status\n\
    \   code 405 (Method Not Allowed) and type \"malformed\".\n   If a client wishes\
    \ to fetch a resource from the server (which would\n   otherwise be done with\
    \ a GET), then it MUST send a POST request with\n   a JWS body as described above,\
    \ where the payload of the JWS is a\n   zero-length octet string.  In other words,\
    \ the \"payload\" field of the\n   JWS object MUST be present and set to the empty\
    \ string (\"\").\n   We will refer to these as \"POST-as-GET\" requests.  On receiving\
    \ a\n   request with a zero-length (and thus non-JSON) payload, the server\n \
    \  MUST authenticate the sender and verify any access control rules.\n   Otherwise,\
    \ the server MUST treat this request as having the same\n   semantics as a GET\
    \ request for the same resource.\n   The server MUST allow GET requests for the\
    \ directory and newNonce\n   resources (see Section 7.1), in addition to POST-as-GET\
    \ requests for\n   these resources.  This enables clients to bootstrap into the\
    \ ACME\n   authentication system.\n"
- title: 6.4.  Request URL Integrity
  contents:
  - "6.4.  Request URL Integrity\n   It is common in deployment for the entity terminating\
    \ TLS for HTTPS\n   to be different from the entity operating the logical HTTPS\
    \ server,\n   with a \"request routing\" layer in the middle.  For example, an\
    \ ACME\n   CA might have a content delivery network terminate TLS connections\n\
    \   from clients so that it can inspect client requests for denial-of-\n   service\
    \ (DoS) protection.\n   These intermediaries can also change values in the request\
    \ that are\n   not signed in the HTTPS request, e.g., the request URL and header\n\
    \   fields.  ACME uses JWS to provide an integrity mechanism, which\n   protects\
    \ against an intermediary changing the request URL to another\n   ACME URL.\n\
    \   As noted in Section 6.2, all ACME request objects carry a \"url\"\n   header\
    \ parameter in their protected header.  This header parameter\n   encodes the\
    \ URL to which the client is directing the request.  On\n   receiving such an\
    \ object in an HTTP request, the server MUST compare\n   the \"url\" header parameter\
    \ to the request URL.  If the two do not\n   match, then the server MUST reject\
    \ the request as unauthorized.\n   Except for the directory resource, all ACME\
    \ resources are addressed\n   with URLs provided to the client by the server.\
    \  In POST requests\n   sent to these resources, the client MUST set the \"url\"\
    \ header\n   parameter to the exact string provided by the server (rather than\n\
    \   performing any re-encoding on the URL).  The server SHOULD perform\n   the\
    \ corresponding string equality check, configuring each resource\n   with the\
    \ URL string provided to clients and having the resource check\n   that requests\
    \ have the same string in their \"url\" header parameter.\n   The server MUST\
    \ reject the request as unauthorized if the string\n   equality check fails.\n"
- title: 6.4.1.  "url" (URL) JWS Header Parameter
  contents:
  - "6.4.1.  \"url\" (URL) JWS Header Parameter\n   The \"url\" header parameter specifies\
    \ the URL [RFC3986] to which this\n   JWS object is directed.  The \"url\" header\
    \ parameter MUST be carried\n   in the protected header of the JWS.  The value\
    \ of the \"url\" header\n   parameter MUST be a string representing the target\
    \ URL.\n"
- title: 6.5.  Replay Protection
  contents:
  - "6.5.  Replay Protection\n   In order to protect ACME resources from any possible\
    \ replay attacks,\n   ACME POST requests have a mandatory anti-replay mechanism.\
    \  This\n   mechanism is based on the server maintaining a list of nonces that\
    \ it\n   has issued, and requiring any signed request from the client to carry\n\
    \   such a nonce.\n   An ACME server provides nonces to clients using the HTTP\
    \ Replay-Nonce\n   header field, as specified in Section 6.5.1.  The server MUST\
    \ include\n   a Replay-Nonce header field in every successful response to a POST\n\
    \   request and SHOULD provide it in error responses as well.\n   Every JWS sent\
    \ by an ACME client MUST include, in its protected\n   header, the \"nonce\" header\
    \ parameter, with contents as defined in\n   Section 6.5.2.  As part of JWS verification,\
    \ the ACME server MUST\n   verify that the value of the \"nonce\" header is a\
    \ value that the\n   server previously provided in a Replay-Nonce header field.\
    \  Once a\n   nonce value has appeared in an ACME request, the server MUST consider\n\
    \   it invalid, in the same way as a value it had never issued.\n   When a server\
    \ rejects a request because its nonce value was\n   unacceptable (or not present),\
    \ it MUST provide HTTP status code 400\n   (Bad Request), and indicate the ACME\
    \ error type\n   \"urn:ietf:params:acme:error:badNonce\".  An error response with\
    \ the\n   \"badNonce\" error type MUST include a Replay-Nonce header field with\
    \ a\n   fresh nonce that the server will accept in a retry of the original\n \
    \  query (and possibly in other requests, according to the server's\n   nonce\
    \ scoping policy).  On receiving such a response, a client SHOULD\n   retry the\
    \ request using the new nonce.\n   The precise method used to generate and track\
    \ nonces is up to the\n   server.  For example, the server could generate a random\
    \ 128-bit\n   value for each response, keep a list of issued nonces, and strike\n\
    \   nonces from this list as they are used.\n   Other than the constraint above\
    \ with regard to nonces issued in\n   \"badNonce\" responses, ACME does not constrain\
    \ how servers scope\n   nonces.  Clients MAY assume that nonces have broad scope,\
    \ e.g., by\n   having a single pool of nonces used for all requests.  However,\
    \ when\n   retrying in response to a \"badNonce\" error, the client MUST use the\n\
    \   nonce provided in the error response.  Servers should scope nonces\n   broadly\
    \ enough that retries are not needed very often.\n"
- title: 6.5.1.  Replay-Nonce
  contents:
  - "6.5.1.  Replay-Nonce\n   The Replay-Nonce HTTP header field includes a server-generated\
    \ value\n   that the server can use to detect unauthorized replay in future\n\
    \   client requests.  The server MUST generate the values provided in\n   Replay-Nonce\
    \ header fields in such a way that they are unique to each\n   message, with high\
    \ probability, and unpredictable to anyone besides\n   the server.  For instance,\
    \ it is acceptable to generate Replay-Nonces\n   randomly.\n   The value of the\
    \ Replay-Nonce header field MUST be an octet string\n   encoded according to the\
    \ base64url encoding described in Section 2 of\n   [RFC7515].  Clients MUST ignore\
    \ invalid Replay-Nonce values.  The\n   ABNF [RFC5234] for the Replay-Nonce header\
    \ field follows:\n     base64url = ALPHA / DIGIT / \"-\" / \"_\"\n     Replay-Nonce\
    \ = 1*base64url\n   The Replay-Nonce header field SHOULD NOT be included in HTTP\
    \ request\n   messages.\n"
- title: 6.5.2.  "nonce" (Nonce) JWS Header Parameter
  contents:
  - "6.5.2.  \"nonce\" (Nonce) JWS Header Parameter\n   The \"nonce\" header parameter\
    \ provides a unique value that enables the\n   verifier of a JWS to recognize\
    \ when replay has occurred.  The \"nonce\"\n   header parameter MUST be carried\
    \ in the protected header of the JWS.\n   The value of the \"nonce\" header parameter\
    \ MUST be an octet string,\n   encoded according to the base64url encoding described\
    \ in Section 2 of\n   [RFC7515].  If the value of a \"nonce\" header parameter\
    \ is not valid\n   according to this encoding, then the verifier MUST reject the\
    \ JWS as\n   malformed.\n"
- title: 6.6.  Rate Limits
  contents:
  - "6.6.  Rate Limits\n   Creation of resources can be rate limited by ACME servers\
    \ to ensure\n   fair usage and prevent abuse.  Once the rate limit is exceeded,\
    \ the\n   server MUST respond with an error with the type\n   \"urn:ietf:params:acme:error:rateLimited\"\
    .  Additionally, the server\n   SHOULD send a Retry-After header field [RFC7231]\
    \ indicating when the\n   current request may succeed again.  If multiple rate\
    \ limits are in\n   place, that is the time where all rate limits allow access\
    \ again for\n   the current request with exactly the same parameters.\n   In addition\
    \ to the human-readable \"detail\" field of the error\n   response, the server\
    \ MAY send one or multiple link relations in the\n   Link header field [RFC8288]\
    \ pointing to documentation about the\n   specific rate limit that was hit, using\
    \ the \"help\" link relation\n   type.\n"
- title: 6.7.  Errors
  contents:
  - "6.7.  Errors\n   Errors can be reported in ACME both at the HTTP layer and within\n\
    \   challenge objects as defined in Section 8.  ACME servers can return\n   responses\
    \ with an HTTP error response code (4XX or 5XX).  For\n   example, if the client\
    \ submits a request using a method not allowed\n   in this document, then the\
    \ server MAY return status code 405 (Method\n   Not Allowed).\n   When the server\
    \ responds with an error status, it SHOULD provide\n   additional information\
    \ using a problem document [RFC7807].  To\n   facilitate automatic response to\
    \ errors, this document defines the\n   following standard tokens for use in the\
    \ \"type\" field (within the\n   ACME URN namespace \"urn:ietf:params:acme:error:\"\
    ):\n   +-------------------------+-----------------------------------------+\n\
    \   | Type                    | Description                             |\n  \
    \ +-------------------------+-----------------------------------------+\n   |\
    \ accountDoesNotExist     | The request specified an account that   |\n   |  \
    \                       | does not exist                          |\n   |    \
    \                     |                                         |\n   | alreadyRevoked\
    \          | The request specified a certificate to  |\n   |                 \
    \        | be revoked that has already been        |\n   |                   \
    \      | revoked                                 |\n   |                     \
    \    |                                         |\n   | badCSR                \
    \  | The CSR is unacceptable (e.g., due to a |\n   |                         |\
    \ short key)                              |\n   |                         |  \
    \                                       |\n   | badNonce                | The\
    \ client sent an unacceptable anti-   |\n   |                         | replay\
    \ nonce                            |\n   |                         |         \
    \                                |\n   | badPublicKey            | The JWS was\
    \ signed by a public key the  |\n   |                         | server does not\
    \ support                 |\n   |                         |                  \
    \                       |\n   | badRevocationReason     | The revocation reason\
    \ provided is not   |\n   |                         | allowed by the server  \
    \                 |\n   |                         |                          \
    \               |\n   | badSignatureAlgorithm   | The JWS was signed with an algorithm\
    \    |\n   |                         | the server does not support           \
    \  |\n   |                         |                                         |\n\
    \   | caa                     | Certification Authority Authorization   |\n  \
    \ |                         | (CAA) records forbid the CA from        |\n   |\
    \                         | issuing a certificate                   |\n   |  \
    \                       |                                         |\n   | compound\
    \                | Specific error conditions are indicated |\n   |           \
    \              | in the \"subproblems\" array              |\n   |           \
    \              |                                         |\n   | connection  \
    \            | The server could not connect to         |\n   |               \
    \          | validation target                       |\n   |                 \
    \        |                                         |\n   | dns               \
    \      | There was a problem with a DNS query    |\n   |                     \
    \    | during identifier validation            |\n   |                       \
    \  |                                         |\n   | externalAccountRequired |\
    \ The request must include a value for    |\n   |                         | the\
    \ \"externalAccountBinding\" field      |\n   |                         |    \
    \                                     |\n   | incorrectResponse       | Response\
    \ received didn't match the      |\n   |                         | challenge's\
    \ requirements                |\n   |                         |              \
    \                           |\n   | invalidContact          | A contact URL for\
    \ an account was        |\n   |                         | invalid            \
    \                     |\n   |                         |                      \
    \                   |\n   | malformed               | The request message was\
    \ malformed       |\n   |                         |                          \
    \               |\n   | orderNotReady           | The request attempted to finalize\
    \ an    |\n   |                         | order that is not ready to be finalized\
    \ |\n   |                         |                                         |\n\
    \   | rateLimited             | The request exceeds a rate limit        |\n  \
    \ |                         |                                         |\n   |\
    \ rejectedIdentifier      | The server will not issue certificates  |\n   |  \
    \                       | for the identifier                      |\n   |    \
    \                     |                                         |\n   | serverInternal\
    \          | The server experienced an internal      |\n   |                 \
    \        | error                                   |\n   |                   \
    \      |                                         |\n   | tls                 \
    \    | The server received a TLS error during  |\n   |                       \
    \  | validation                              |\n   |                         |\
    \                                         |\n   | unauthorized            | The\
    \ client lacks sufficient             |\n   |                         | authorization\
    \                           |\n   |                         |                \
    \                         |\n   | unsupportedContact      | A contact URL for\
    \ an account used an    |\n   |                         | unsupported protocol\
    \ scheme             |\n   |                         |                       \
    \                  |\n   | unsupportedIdentifier   | An identifier is of an unsupported\
    \ type |\n   |                         |                                     \
    \    |\n   | userActionRequired      | Visit the \"instance\" URL and take   \
    \    |\n   |                         | actions specified there               \
    \  |\n   +-------------------------+-----------------------------------------+\n\
    \   This list is not exhaustive.  The server MAY return errors whose\n   \"type\"\
    \ field is set to a URI other than those defined above.  Servers\n   MUST NOT\
    \ use the ACME URN namespace for errors not listed in the\n   appropriate IANA\
    \ registry (see Section 9.6).  Clients SHOULD display\n   the \"detail\" field\
    \ of all errors.\n   In the remainder of this document, we use the tokens in the\
    \ table\n   above to refer to error types, rather than the full URNs.  For\n \
    \  example, an \"error of type 'badCSR'\" refers to an error document with\n \
    \  \"type\" value \"urn:ietf:params:acme:error:badCSR\".\n"
- title: 6.7.1.  Subproblems
  contents:
  - "6.7.1.  Subproblems\n   Sometimes a CA may need to return multiple errors in\
    \ response to a\n   request.  Additionally, the CA may need to attribute errors\
    \ to\n   specific identifiers.  For instance, a newOrder request may contain\n\
    \   multiple identifiers for which the CA cannot issue certificates.  In\n   this\
    \ situation, an ACME problem document MAY contain the\n   \"subproblems\" field,\
    \ containing a JSON array of problem documents,\n   each of which MAY contain\
    \ an \"identifier\" field.  If present, the\n   \"identifier\" field MUST contain\
    \ an ACME identifier (Section 9.7.7).\n   The \"identifier\" field MUST NOT be\
    \ present at the top level in ACME\n   problem documents.  It can only be present\
    \ in subproblems.\n   Subproblems need not all have the same type, and they do\
    \ not need to\n   match the top level type.\n   ACME clients may choose to use\
    \ the \"identifier\" field of a subproblem\n   as a hint that an operation would\
    \ succeed if that identifier were\n   omitted.  For instance, if an order contains\
    \ ten DNS identifiers, and\n   the newOrder request returns a problem document\
    \ with two subproblems\n   (referencing two of those identifiers), the ACME client\
    \ may choose to\n   submit another order containing only the eight identifiers\
    \ not listed\n   in the problem document.\n"
- title: HTTP/1.1 403 Forbidden
  contents:
  - 'HTTP/1.1 403 Forbidden

    '
- title: 'Content-Type: application/problem+json'
  contents:
  - 'Content-Type: application/problem+json

    '
- title: 'Link: <https://example.com/acme/directory>;rel="index"'
  contents:
  - 'Link: <https://example.com/acme/directory>;rel="index"

    '
- title: '{'
  contents:
  - "{\n    \"type\": \"urn:ietf:params:acme:error:malformed\",\n    \"detail\": \"\
    Some of the identifiers requested were rejected\",\n    \"subproblems\": [\n \
    \       {\n            \"type\": \"urn:ietf:params:acme:error:malformed\",\n \
    \           \"detail\": \"Invalid underscore in DNS name \\\"_example.org\\\"\"\
    ,\n            \"identifier\": {\n                \"type\": \"dns\",\n       \
    \         \"value\": \"_example.org\"\n            }\n        },\n        {\n\
    \            \"type\": \"urn:ietf:params:acme:error:rejectedIdentifier\",\n  \
    \          \"detail\": \"This CA will not issue for \\\"example.net\\\"\",\n \
    \           \"identifier\": {\n                \"type\": \"dns\",\n          \
    \      \"value\": \"example.net\"\n            }\n        }\n    ]\n"
- title: '}'
  contents:
  - '}

    '
- title: 7.  Certificate Management
  contents:
  - "7.  Certificate Management\n   In this section, we describe the certificate management\
    \ functions\n   that ACME enables:\n   o  Account Creation\n   o  Ordering a Certificate\n\
    \   o  Identifier Authorization\n   o  Certificate Issuance\n   o  Certificate\
    \ Revocation\n"
- title: 7.1.  Resources
  contents:
  - "7.1.  Resources\n   ACME is structured as an HTTP-based application with the\
    \ following\n   types of resources:\n   o  Account resources, representing information\
    \ about an account\n      (Section 7.1.2, Section 7.3)\n   o  Order resources,\
    \ representing an account's requests to issue\n      certificates (Section 7.1.3)\n\
    \   o  Authorization resources, representing an account's authorization\n    \
    \  to act for an identifier (Section 7.1.4)\n   o  Challenge resources, representing\
    \ a challenge to prove control of\n      an identifier (Section 7.5, Section 8)\n\
    \   o  Certificate resources, representing issued certificates\n      (Section\
    \ 7.4.2)\n   o  A \"directory\" resource (Section 7.1.1)\n   o  A \"newNonce\"\
    \ resource (Section 7.2)\n   o  A \"newAccount\" resource (Section 7.3)\n   o\
    \  A \"newOrder\" resource (Section 7.4)\n   o  A \"revokeCert\" resource (Section\
    \ 7.6)\n   o  A \"keyChange\" resource (Section 7.3.5)\n   The server MUST provide\
    \ \"directory\" and \"newNonce\" resources.\n   ACME uses different URLs for different\
    \ management functions.  Each\n   function is listed in a directory along with\
    \ its corresponding URL,\n   so clients only need to be configured with the directory\
    \ URL.  These\n   URLs are connected by a few different link relations [RFC8288].\n\
    \   The \"up\" link relation is used with challenge resources to indicate\n  \
    \ the authorization resource to which a challenge belongs.  It is also\n   used,\
    \ with some media types, from certificate resources to indicate a\n   resource\
    \ from which the client may fetch a chain of CA certificates\n   that could be\
    \ used to validate the certificate in the original\n   resource.\n   The \"index\"\
    \ link relation is present on all resources other than the\n   directory and indicates\
    \ the URL of the directory.\n   The following diagram illustrates the relations\
    \ between resources on\n   an ACME server.  For the most part, these relations\
    \ are expressed by\n   URLs provided as strings in the resources' JSON representations.\n\
    \   Lines with labels in quotes indicate HTTP link relations.\n              \
    \                    directory\n                                      |\n    \
    \                                  +--> newNonce\n                           \
    \           |\n          +----------+----------+-----+-----+------------+\n  \
    \        |          |          |           |            |\n          |       \
    \   |          |           |            |\n          V          V          V \
    \          V            V\n     newAccount   newAuthz   newOrder   revokeCert\
    \   keyChange\n          |          |          |\n          |          |     \
    \     |\n          V          |          V\n       account       |        order\
    \ --+--> finalize\n                     |          |     |\n                 \
    \    |          |     +--> cert\n                     |          V\n         \
    \            +---> authorization\n                               | ^\n       \
    \                        | | \"up\"\n                               V |\n    \
    \                         challenge\n                     ACME Resources and Relationships\n\
    \   The following table illustrates a typical sequence of requests\n   required\
    \ to establish a new account with the server, prove control of\n   an identifier,\
    \ issue a certificate, and fetch an updated certificate\n   some time after issuance.\
    \  The \"->\" is a mnemonic for a Location\n   header field pointing to a created\
    \ resource.\n   +-------------------+--------------------------------+--------------+\n\
    \   | Action            | Request                        | Response     |\n  \
    \ +-------------------+--------------------------------+--------------+\n   |\
    \ Get directory     | GET  directory                 | 200          |\n   |  \
    \                 |                                |              |\n   | Get\
    \ nonce         | HEAD newNonce                  | 200          |\n   |      \
    \             |                                |              |\n   | Create account\
    \    | POST newAccount                | 201 ->       |\n   |                 \
    \  |                                | account      |\n   |                   |\
    \                                |              |\n   | Submit order      | POST\
    \ newOrder                  | 201 -> order |\n   |                   |       \
    \                         |              |\n   | Fetch challenges  | POST-as-GET\
    \ order's            | 200          |\n   |                   | authorization\
    \ urls             |              |\n   |                   |                \
    \                |              |\n   | Respond to        | POST authorization\
    \ challenge   | 200          |\n   | challenges        | urls                \
    \           |              |\n   |                   |                       \
    \         |              |\n   | Poll for status   | POST-as-GET order       \
    \       | 200          |\n   |                   |                           \
    \     |              |\n   | Finalize order    | POST order's finalize url   \
    \   | 200          |\n   |                   |                               \
    \ |              |\n   | Poll for status   | POST-as-GET order              |\
    \ 200          |\n   |                   |                                |  \
    \            |\n   | Download          | POST-as-GET order's            | 200\
    \          |\n   | certificate       | certificate url                |      \
    \        |\n   +-------------------+--------------------------------+--------------+\n\
    \   The remainder of this section provides the details of how these\n   resources\
    \ are structured and how the ACME protocol makes use of them.\n"
- title: 7.1.1.  Directory
  contents:
  - "7.1.1.  Directory\n   In order to help clients configure themselves with the\
    \ right URLs for\n   each ACME operation, ACME servers provide a directory object.\
    \  This\n   should be the only URL needed to configure clients.  It is a JSON\n\
    \   object, whose field names are drawn from the resource registry\n   (Section\
    \ 9.7.5) and whose values are the corresponding URLs.\n                    +------------+--------------------+\n\
    \                    | Field      | URL in Value       |\n                   \
    \ +------------+--------------------+\n                    | newNonce   | New\
    \ nonce          |\n                    |            |                    |\n\
    \                    | newAccount | New account        |\n                   \
    \ |            |                    |\n                    | newOrder   | New\
    \ order          |\n                    |            |                    |\n\
    \                    | newAuthz   | New authorization  |\n                   \
    \ |            |                    |\n                    | revokeCert | Revoke\
    \ certificate |\n                    |            |                    |\n   \
    \                 | keyChange  | Key change         |\n                    +------------+--------------------+\n\
    \   There is no constraint on the URL of the directory except that it\n   should\
    \ be different from the other ACME server resources' URLs, and\n   that it should\
    \ not clash with other services.  For instance:\n   o  a host that functions as\
    \ both an ACME and a Web server may want to\n      keep the root path \"/\" for\
    \ an HTML \"front page\" and place the ACME\n      directory under the path \"\
    /acme\".\n   o  a host that only functions as an ACME server could place the\n\
    \      directory under the path \"/\".\n   If the ACME server does not implement\
    \ pre-authorization\n   (Section 7.4.1), it MUST omit the \"newAuthz\" field of\
    \ the directory.\n   The object MAY additionally contain a \"meta\" field.  If\
    \ present, it\n   MUST be a JSON object; each field in the object is an item of\n\
    \   metadata relating to the service provided by the ACME server.\n   The following\
    \ metadata items are defined (Section 9.7.6), all of\n   which are OPTIONAL:\n\
    \   termsOfService (optional, string):  A URL identifying the current\n      terms\
    \ of service.\n   website (optional, string):  An HTTP or HTTPS URL locating a\
    \ website\n      providing more information about the ACME server.\n   caaIdentities\
    \ (optional, array of string):  The hostnames that the\n      ACME server recognizes\
    \ as referring to itself for the purposes of\n      CAA record validation as defined\
    \ in [RFC6844].  Each string MUST\n      represent the same sequence of ASCII\
    \ code points that the server\n      will expect to see as the \"Issuer Domain\
    \ Name\" in a CAA issue or\n      issuewild property tag.  This allows clients\
    \ to determine the\n      correct issuer domain name to use when configuring CAA\
    \ records.\n   externalAccountRequired (optional, boolean):  If this field is\n\
    \      present and set to \"true\", then the CA requires that all\n      newAccount\
    \ requests include an \"externalAccountBinding\" field\n      associating the\
    \ new account with an external account.\n   Clients access the directory by sending\
    \ a GET request to the\n   directory URL.\n   HTTP/1.1 200 OK\n   Content-Type:\
    \ application/json\n   {\n     \"newNonce\": \"https://example.com/acme/new-nonce\"\
    ,\n     \"newAccount\": \"https://example.com/acme/new-account\",\n     \"newOrder\"\
    : \"https://example.com/acme/new-order\",\n     \"newAuthz\": \"https://example.com/acme/new-authz\"\
    ,\n     \"revokeCert\": \"https://example.com/acme/revoke-cert\",\n     \"keyChange\"\
    : \"https://example.com/acme/key-change\",\n     \"meta\": {\n       \"termsOfService\"\
    : \"https://example.com/acme/terms/2017-5-30\",\n       \"website\": \"https://www.example.com/\"\
    ,\n       \"caaIdentities\": [\"example.com\"],\n       \"externalAccountRequired\"\
    : false\n     }\n   }\n"
- title: 7.1.2.  Account Objects
  contents:
  - "7.1.2.  Account Objects\n   An ACME account resource represents a set of metadata\
    \ associated with\n   an account.  Account resources have the following structure:\n\
    \   status (required, string):  The status of this account.  Possible\n      values\
    \ are \"valid\", \"deactivated\", and \"revoked\".  The value\n      \"deactivated\"\
    \ should be used to indicate client-initiated\n      deactivation whereas \"revoked\"\
    \ should be used to indicate server-\n      initiated deactivation.  See Section\
    \ 7.1.6.\n   contact (optional, array of string):  An array of URLs that the\n\
    \      server can use to contact the client for issues related to this\n     \
    \ account.  For example, the server may wish to notify the client\n      about\
    \ server-initiated revocation or certificate expiration.  For\n      information\
    \ on supported URL schemes, see Section 7.3.\n   termsOfServiceAgreed (optional,\
    \ boolean):  Including this field in a\n      newAccount request, with a value\
    \ of true, indicates the client's\n      agreement with the terms of service.\
    \  This field cannot be updated\n      by the client.\n   externalAccountBinding\
    \ (optional, object):  Including this field in a\n      newAccount request indicates\
    \ approval by the holder of an existing\n      non-ACME account to bind that account\
    \ to this ACME account.  This\n      field is not updateable by the client (see\
    \ Section 7.3.4).\n   orders (required, string):  A URL from which a list of orders\n\
    \      submitted by this account can be fetched via a POST-as-GET\n      request,\
    \ as described in Section 7.1.2.1.\n   {\n     \"status\": \"valid\",\n     \"\
    contact\": [\n       \"mailto:cert-admin@example.org\",\n       \"mailto:admin@example.org\"\
    \n     ],\n     \"termsOfServiceAgreed\": true,\n     \"orders\": \"https://example.com/acme/orders/rzGoeA\"\
    \n   }\n"
- title: 7.1.2.1.  Orders List
  contents:
  - "7.1.2.1.  Orders List\n   Each account object includes an \"orders\" URL from\
    \ which a list of\n   orders created by the account can be fetched via POST-as-GET\
    \ request.\n   The result of the request MUST be a JSON object whose \"orders\"\
    \ field\n   is an array of URLs, each identifying an order belonging to the\n\
    \   account.  The server SHOULD include pending orders and SHOULD NOT\n   include\
    \ orders that are invalid in the array of URLs.  The server MAY\n   return an\
    \ incomplete list, along with a Link header field with a\n   \"next\" link relation\
    \ indicating where further entries can be\n   acquired.\n   HTTP/1.1 200 OK\n\
    \   Content-Type: application/json\n   Link: <https://example.com/acme/directory>;rel=\"\
    index\"\n   Link: <https://example.com/acme/orders/rzGoeA?cursor=2>;rel=\"next\"\
    \n   {\n     \"orders\": [\n       \"https://example.com/acme/order/TOlocE8rfgo\"\
    ,\n       \"https://example.com/acme/order/4E16bbL5iSw\",\n       /* more URLs\
    \ not shown for example brevity */\n       \"https://example.com/acme/order/neBHYLfw0mg\"\
    \n     ]\n   }\n"
- title: 7.1.3.  Order Objects
  contents:
  - "7.1.3.  Order Objects\n   An ACME order object represents a client's request\
    \ for a certificate\n   and is used to track the progress of that order through\
    \ to issuance.\n   Thus, the object contains information about the requested\n\
    \   certificate, the authorizations that the server requires the client\n   to\
    \ complete, and any certificates that have resulted from this order.\n   status\
    \ (required, string):  The status of this order.  Possible\n      values are \"\
    pending\", \"ready\", \"processing\", \"valid\", and\n      \"invalid\".  See\
    \ Section 7.1.6.\n   expires (optional, string):  The timestamp after which the\
    \ server\n      will consider this order invalid, encoded in the format specified\n\
    \      in [RFC3339].  This field is REQUIRED for objects with \"pending\"\n  \
    \    or \"valid\" in the status field.\n   identifiers (required, array of object):\
    \  An array of identifier\n      objects that the order pertains to.\n      type\
    \ (required, string):  The type of identifier.  This document\n         defines\
    \ the \"dns\" identifier type.  See the registry defined in\n         Section\
    \ 9.7.7 for any others.\n      value (required, string):  The identifier itself.\n\
    \   notBefore (optional, string):  The requested value of the notBefore\n    \
    \  field in the certificate, in the date format defined in [RFC3339].\n   notAfter\
    \ (optional, string):  The requested value of the notAfter\n      field in the\
    \ certificate, in the date format defined in [RFC3339].\n   error (optional, object):\
    \  The error that occurred while processing\n      the order, if any.  This field\
    \ is structured as a problem document\n      [RFC7807].\n   authorizations (required,\
    \ array of string):  For pending orders, the\n      authorizations that the client\
    \ needs to complete before the\n      requested certificate can be issued (see\
    \ Section 7.5), including\n      unexpired authorizations that the client has\
    \ completed in the past\n      for identifiers specified in the order.  The authorizations\n\
    \      required are dictated by server policy; there may not be a 1:1\n      relationship\
    \ between the order identifiers and the authorizations\n      required.  For final\
    \ orders (in the \"valid\" or \"invalid\" state),\n      the authorizations that\
    \ were completed.  Each entry is a URL from\n      which an authorization can\
    \ be fetched with a POST-as-GET request.\n   finalize (required, string):  A URL\
    \ that a CSR must be POSTed to once\n      all of the order's authorizations are\
    \ satisfied to finalize the\n      order.  The result of a successful finalization\
    \ will be the\n      population of the certificate URL for the order.\n   certificate\
    \ (optional, string):  A URL for the certificate that has\n      been issued in\
    \ response to this order.\n   {\n     \"status\": \"valid\",\n     \"expires\"\
    : \"2016-01-20T14:09:07.99Z\",\n     \"identifiers\": [\n       { \"type\": \"\
    dns\", \"value\": \"www.example.org\" },\n       { \"type\": \"dns\", \"value\"\
    : \"example.org\" }\n     ],\n     \"notBefore\": \"2016-01-01T00:00:00Z\",\n\
    \     \"notAfter\": \"2016-01-08T00:00:00Z\",\n     \"authorizations\": [\n  \
    \     \"https://example.com/acme/authz/PAniVnsZcis\",\n       \"https://example.com/acme/authz/r4HqLzrSrpI\"\
    \n     ],\n     \"finalize\": \"https://example.com/acme/order/TOlocE8rfgo/finalize\"\
    ,\n     \"certificate\": \"https://example.com/acme/cert/mAt3xBGaobw\"\n   }\n\
    \   Any identifier of type \"dns\" in a newOrder request MAY have a\n   wildcard\
    \ domain name as its value.  A wildcard domain name consists\n   of a single asterisk\
    \ character followed by a single full stop\n   character (\"*.\") followed by\
    \ a domain name as defined for use in the\n   Subject Alternate Name Extension\
    \ by [RFC5280].  An authorization\n   returned by the server for a wildcard domain\
    \ name identifier MUST NOT\n   include the asterisk and full stop (\"*.\") prefix\
    \ in the authorization\n   identifier value.  The returned authorization MUST\
    \ include the\n   optional \"wildcard\" field, with a value of true.\n   The elements\
    \ of the \"authorizations\" and \"identifiers\" arrays are\n   immutable once\
    \ set.  The server MUST NOT change the contents of\n   either array after they\
    \ are created.  If a client observes a change\n   in the contents of either array,\
    \ then it SHOULD consider the order\n   invalid.\n   The \"authorizations\" array\
    \ of the order SHOULD reflect all\n   authorizations that the CA takes into account\
    \ in deciding to issue,\n   even if some authorizations were fulfilled in earlier\
    \ orders or in\n   pre-authorization transactions.  For example, if a CA allows\
    \ multiple\n   orders to be fulfilled based on a single authorization transaction,\n\
    \   then it SHOULD reflect that authorization in all of the orders.\n   Note that\
    \ just because an authorization URL is listed in the\n   \"authorizations\" array\
    \ of an order object doesn't mean that the\n   client is required to take action.\
    \  There are several reasons that\n   the referenced authorizations may already\
    \ be valid:\n   o  The client completed the authorization as part of a previous\
    \ order\n   o  The client previously pre-authorized the identifier (see\n    \
    \  Section 7.4.1)\n   o  The server granted the client authorization based on\
    \ an external\n      account\n   Clients SHOULD check the \"status\" field of\
    \ an order to determine\n   whether they need to take any action.\n"
- title: 7.1.4.  Authorization Objects
  contents:
  - "7.1.4.  Authorization Objects\n   An ACME authorization object represents a server's\
    \ authorization for\n   an account to represent an identifier.  In addition to\
    \ the\n   identifier, an authorization includes several metadata fields, such\n\
    \   as the status of the authorization (e.g., \"pending\", \"valid\", or\n   \"\
    revoked\") and which challenges were used to validate possession of\n   the identifier.\n\
    \   The structure of an ACME authorization resource is as follows:\n   identifier\
    \ (required, object):  The identifier that the account is\n      authorized to\
    \ represent.\n      type (required, string):  The type of identifier (see below\
    \ and\n         Section 9.7.7).\n      value (required, string):  The identifier\
    \ itself.\n   status (required, string):  The status of this authorization.\n\
    \      Possible values are \"pending\", \"valid\", \"invalid\", \"deactivated\"\
    ,\n      \"expired\", and \"revoked\".  See Section 7.1.6.\n   expires (optional,\
    \ string):  The timestamp after which the server\n      will consider this authorization\
    \ invalid, encoded in the format\n      specified in [RFC3339].  This field is\
    \ REQUIRED for objects with\n      \"valid\" in the \"status\" field.\n   challenges\
    \ (required, array of objects):  For pending authorizations,\n      the challenges\
    \ that the client can fulfill in order to prove\n      possession of the identifier.\
    \  For valid authorizations, the\n      challenge that was validated.  For invalid\
    \ authorizations, the\n      challenge that was attempted and failed.  Each array\
    \ entry is an\n      object with parameters required to validate the challenge.\
    \  A\n      client should attempt to fulfill one of these challenges, and a\n\
    \      server should consider any one of the challenges sufficient to\n      make\
    \ the authorization valid.\n   wildcard (optional, boolean):  This field MUST\
    \ be present and true\n      for authorizations created as a result of a newOrder\
    \ request\n      containing a DNS identifier with a value that was a wildcard\n\
    \      domain name.  For other authorizations, it MUST be absent.\n      Wildcard\
    \ domain names are described in Section 7.1.3.\n   The only type of identifier\
    \ defined by this specification is a fully\n   qualified domain name (type: \"\
    dns\").  The domain name MUST be encoded\n   in the form in which it would appear\
    \ in a certificate.  That is, it\n   MUST be encoded according to the rules in\
    \ Section 7 of [RFC5280].\n   Servers MUST verify any identifier values that begin\
    \ with the ASCII-\n   Compatible Encoding prefix \"xn--\" as defined in [RFC5890]\
    \ are\n   properly encoded.  Wildcard domain names (with \"*\" as the first\n\
    \   label) MUST NOT be included in authorization objects.  If an\n   authorization\
    \ object conveys authorization for the base domain of a\n   newOrder DNS identifier\
    \ containing a wildcard domain name, then the\n   optional authorizations \"wildcard\"\
    \ field MUST be present with a value\n   of true.\n   Section 8 describes a set\
    \ of challenges for domain name validation.\n   {\n     \"status\": \"valid\"\
    ,\n     \"expires\": \"2015-03-01T14:09:07.99Z\",\n     \"identifier\": {\n  \
    \     \"type\": \"dns\",\n       \"value\": \"www.example.org\"\n     },\n   \
    \  \"challenges\": [\n       {\n         \"url\": \"https://example.com/acme/chall/prV_B7yEyA4\"\
    ,\n         \"type\": \"http-01\",\n         \"status\": \"valid\",\n        \
    \ \"token\": \"DGyRejmCefe7v4NfDGDKfA\",\n         \"validated\": \"2014-12-01T12:05:58.16Z\"\
    \n       }\n     ],\n     \"wildcard\": false\n   }\n"
- title: 7.1.5.  Challenge Objects
  contents:
  - "7.1.5.  Challenge Objects\n   An ACME challenge object represents a server's\
    \ offer to validate a\n   client's possession of an identifier in a specific way.\
    \  Unlike the\n   other objects listed above, there is not a single standard structure\n\
    \   for a challenge object.  The contents of a challenge object depend on\n  \
    \ the validation method being used.  The general structure of challenge\n   objects\
    \ and an initial set of validation methods are described in\n   Section 8.\n"
- title: 7.1.6.  Status Changes
  contents:
  - "7.1.6.  Status Changes\n   Each ACME object type goes through a simple state\
    \ machine over its\n   lifetime.  The \"status\" field of the object indicates\
    \ which state the\n   object is currently in.\n   Challenge objects are created\
    \ in the \"pending\" state.  They\n   transition to the \"processing\" state when\
    \ the client responds to the\n   challenge (see Section 7.5.1) and the server\
    \ begins attempting to\n   validate that the client has completed the challenge.\
    \  Note that\n   within the \"processing\" state, the server may attempt to validate\
    \ the\n   challenge multiple times (see Section 8.2).  Likewise, client\n   requests\
    \ for retries do not cause a state change.  If validation is\n   successful, the\
    \ challenge moves to the \"valid\" state; if there is an\n   error, the challenge\
    \ moves to the \"invalid\" state.\n            pending\n               |\n   \
    \            | Receive\n               | response\n               V\n        \
    \   processing <-+\n               |   |    | Server retry or\n              \
    \ |   |    | client retry request\n               |   +----+\n               |\n\
    \               |\n   Successful  |   Failed\n   validation  |   validation\n\
    \     +---------+---------+\n     |                   |\n     V              \
    \     V\n   valid              invalid\n                  State Transitions for\
    \ Challenge Objects\n   Authorization objects are created in the \"pending\" state.\
    \  If one of\n   the challenges listed in the authorization transitions to the\
    \ \"valid\"\n   state, then the authorization also changes to the \"valid\" state.\
    \  If\n   the client attempts to fulfill a challenge and fails, or if there is\n\
    \   an error while the authorization is still pending, then the\n   authorization\
    \ transitions to the \"invalid\" state.  Once the\n   authorization is in the\
    \ \"valid\" state, it can expire (\"expired\"), be\n   deactivated by the client\
    \ (\"deactivated\", see Section 7.5.2), or\n   revoked by the server (\"revoked\"\
    ).\n                      pending --------------------+\n                    \
    \     |                        |\n       Challenge failure |                 \
    \       |\n              or         |                        |\n             Error\
    \       |  Challenge valid       |\n               +---------+---------+     \
    \         |\n               |                   |              |\n           \
    \    V                   V              |\n            invalid              valid\
    \            |\n                                   |              |\n        \
    \                           |              |\n                               \
    \    |              |\n                    +--------------+--------------+\n \
    \                   |              |              |\n                    |   \
    \           |              |\n             Server |       Client |   Time after\
    \ |\n             revoke |   deactivate |    \"expires\" |\n                 \
    \   V              V              V\n                 revoked      deactivated\
    \      expired\n                State Transitions for Authorization Objects\n\
    \   Order objects are created in the \"pending\" state.  Once all of the\n   authorizations\
    \ listed in the order object are in the \"valid\" state,\n   the order transitions\
    \ to the \"ready\" state.  The order moves to the\n   \"processing\" state after\
    \ the client submits a request to the order's\n   \"finalize\" URL and the CA\
    \ begins the issuance process for the\n   certificate.  Once the certificate is\
    \ issued, the order enters the\n   \"valid\" state.  If an error occurs at any\
    \ of these stages, the order\n   moves to the \"invalid\" state.  The order also\
    \ moves to the \"invalid\"\n   state if it expires or one of its authorizations\
    \ enters a final state\n   other than \"valid\" (\"expired\", \"revoked\", or\
    \ \"deactivated\").\n    pending --------------+\n       |                  |\n\
    \       | All authz        |\n       | \"valid\"          |\n       V        \
    \          |\n     ready ---------------+\n       |                  |\n     \
    \  | Receive          |\n       | finalize         |\n       | request       \
    \   |\n       V                  |\n   processing ------------+\n       |    \
    \              |\n       | Certificate      | Error or\n       | issued      \
    \     | Authorization failure\n       V                  V\n     valid       \
    \      invalid\n                    State Transitions for Order Objects\n   Account\
    \ objects are created in the \"valid\" state, since no further\n   action is required\
    \ to create an account after a successful newAccount\n   request.  If the account\
    \ is deactivated by the client or revoked by\n   the server, it moves to the corresponding\
    \ state.\n                     valid\n                       |\n             \
    \          |\n           +-----------+-----------+\n    Client |             \
    \   Server |\n   deactiv.|                revoke |\n           V             \
    \          V\n      deactivated               revoked\n                   State\
    \ Transitions for Account Objects\n   Note that some of these states may not ever\
    \ appear in a \"status\"\n   field, depending on server behavior.  For example,\
    \ a server that\n   issues synchronously will never show an order in the \"processing\"\
    \n   state.  A server that deletes expired authorizations immediately will\n \
    \  never show an authorization in the \"expired\" state.\n"
- title: 7.2.  Getting a Nonce
  contents:
  - "7.2.  Getting a Nonce\n   Before sending a POST request to the server, an ACME\
    \ client needs to\n   have a fresh anti-replay nonce to put in the \"nonce\" header\
    \ of the\n   JWS.  In most cases, the client will have gotten a nonce from a\n\
    \   previous request.  However, the client might sometimes need to get a\n   new\
    \ nonce, e.g., on its first request to the server or if an existing\n   nonce\
    \ is no longer valid.\n   To get a fresh nonce, the client sends a HEAD request\
    \ to the newNonce\n   resource on the server.  The server's response MUST include\
    \ a Replay-\n   Nonce header field containing a fresh nonce and SHOULD have status\n\
    \   code 200 (OK).  The server MUST also respond to GET requests for this\n  \
    \ resource, returning an empty body (while still providing a Replay-\n   Nonce\
    \ header) with a status code of 204 (No Content).\n   HEAD /acme/new-nonce HTTP/1.1\n\
    \   Host: example.com\n   HTTP/1.1 200 OK\n   Replay-Nonce: oFvnlFP1wIhRlYS2jTaXbA\n\
    \   Cache-Control: no-store\n   Link: <https://example.com/acme/directory>;rel=\"\
    index\"\n   Proxy caching of responses from the newNonce resource can cause\n\
    \   clients to receive the same nonce repeatedly, leading to \"badNonce\"\n  \
    \ errors.  The server MUST include a Cache-Control header field with\n   the \"\
    no-store\" directive in responses for the newNonce resource, in\n   order to prevent\
    \ caching of this resource.\n"
- title: 7.3.  Account Management
  contents:
  - "7.3.  Account Management\n   In this section, we describe how an ACME client\
    \ can create an account\n   on an ACME server and perform some modifications to\
    \ the account after\n   it has been created.\n   A client creates a new account\
    \ with the server by sending a POST\n   request to the server's newAccount URL.\
    \  The body of the request is a\n   stub account object containing some subset\
    \ of the following fields:\n   contact (optional, array of string):  Same meaning\
    \ as the\n      corresponding server field defined in Section 7.1.2.\n   termsOfServiceAgreed\
    \ (optional, boolean):  Same meaning as the\n      corresponding server field\
    \ defined in Section 7.1.2.\n   onlyReturnExisting (optional, boolean):  If this\
    \ field is present\n      with the value \"true\", then the server MUST NOT create\
    \ a new\n      account if one does not already exist.  This allows a client to\n\
    \      look up an account URL based on an account key (see\n      Section 7.3.1).\n\
    \   externalAccountBinding (optional, object):  Same meaning as the\n      corresponding\
    \ server field defined in Section 7.1.2\n   POST /acme/new-account HTTP/1.1\n\
    \   Host: example.com\n   Content-Type: application/jose+json\n   {\n     \"protected\"\
    : base64url({\n       \"alg\": \"ES256\",\n       \"jwk\": {...},\n       \"nonce\"\
    : \"6S8IqOGY7eL2lsGoTZYifg\",\n       \"url\": \"https://example.com/acme/new-account\"\
    \n     }),\n     \"payload\": base64url({\n       \"termsOfServiceAgreed\": true,\n\
    \       \"contact\": [\n         \"mailto:cert-admin@example.org\",\n        \
    \ \"mailto:admin@example.org\"\n       ]\n     }),\n     \"signature\": \"RZPOnYoPs1PhjszF...-nh6X1qtOFPB519I\"\
    \n   }\n   The server MUST ignore any values provided in the \"orders\" fields\
    \ in\n   account objects sent by the client, as well as any other fields that\n\
    \   it does not recognize.  If new fields are specified in the future,\n   the\
    \ specification of those fields MUST describe whether they can be\n   provided\
    \ by the client.  The server MUST NOT reflect the\n   \"onlyReturnExisting\" field\
    \ or any unrecognized fields in the\n   resulting account object.  This allows\
    \ clients to detect when servers\n   do not support an extension field.\n   The\
    \ server SHOULD validate that the contact URLs in the \"contact\"\n   field are\
    \ valid and supported by the server.  If the server validates\n   contact URLs,\
    \ it MUST support the \"mailto\" scheme.  Clients MUST NOT\n   provide a \"mailto\"\
    \ URL in the \"contact\" field that contains \"hfields\"\n   [RFC6068] or more\
    \ than one \"addr-spec\" in the \"to\" component.  If a\n   server encounters\
    \ a \"mailto\" contact URL that does not meet these\n   criteria, then it SHOULD\
    \ reject it as invalid.\n   If the server rejects a contact URL for using an unsupported\
    \ scheme,\n   it MUST return an error of type \"unsupportedContact\", with a\n\
    \   description of the error and what types of contact URLs the server\n   considers\
    \ acceptable.  If the server rejects a contact URL for using\n   a supported scheme\
    \ but an invalid value, then the server MUST return\n   an error of type \"invalidContact\"\
    .\n   If the server wishes to require the client to agree to terms under\n   which\
    \ the ACME service is to be used, it MUST indicate the URL where\n   such terms\
    \ can be accessed in the \"termsOfService\" subfield of the\n   \"meta\" field\
    \ in the directory object, and the server MUST reject\n   newAccount requests\
    \ that do not have the \"termsOfServiceAgreed\" field\n   set to \"true\".  Clients\
    \ SHOULD NOT automatically agree to terms by\n   default.  Rather, they SHOULD\
    \ require some user interaction for\n   agreement to terms.\n   The server creates\
    \ an account and stores the public key used to\n   verify the JWS (i.e., the \"\
    jwk\" element of the JWS header) to\n   authenticate future requests from the\
    \ account.  The server returns\n   this account object in a 201 (Created) response,\
    \ with the account URL\n   in a Location header field.  The account URL is used\
    \ as the \"kid\"\n   value in the JWS authenticating subsequent requests by this\
    \ account\n   (see Section 6.2).  The account URL is also used for requests for\n\
    \   management actions on this account, as described below.\n   HTTP/1.1 201 Created\n\
    \   Content-Type: application/json\n   Replay-Nonce: D8s4D2mLs8Vn-goWuPQeKA\n\
    \   Link: <https://example.com/acme/directory>;rel=\"index\"\n   Location: https://example.com/acme/acct/evOfKhNU60wg\n\
    \   {\n     \"status\": \"valid\",\n     \"contact\": [\n       \"mailto:cert-admin@example.org\"\
    ,\n       \"mailto:admin@example.org\"\n     ],\n     \"orders\": \"https://example.com/acme/acct/evOfKhNU60wg/orders\"\
    \n   }\n"
- title: 7.3.1.  Finding an Account URL Given a Key
  contents:
  - "7.3.1.  Finding an Account URL Given a Key\n   If the server receives a newAccount\
    \ request signed with a key for\n   which it already has an account registered\
    \ with the provided account\n   key, then it MUST return a response with status\
    \ code 200 (OK) and\n   provide the URL of that account in the Location header\
    \ field.  The\n   body of this response represents the account object as it existed\
    \ on\n   the server before this request; any fields in the request object MUST\n\
    \   be ignored.  This allows a client that has an account key but not the\n  \
    \ corresponding account URL to recover the account URL.\n   If a client wishes\
    \ to find the URL for an existing account and does\n   not want an account to\
    \ be created if one does not already exist, then\n   it SHOULD do so by sending\
    \ a POST request to the newAccount URL with\n   a JWS whose payload has an \"\
    onlyReturnExisting\" field set to \"true\"\n   ({\"onlyReturnExisting\": true}).\
    \  If a client sends such a request and\n   an account does not exist, then the\
    \ server MUST return an error\n   response with status code 400 (Bad Request)\
    \ and type\n   \"urn:ietf:params:acme:error:accountDoesNotExist\".\n"
- title: 7.3.2.  Account Update
  contents:
  - "7.3.2.  Account Update\n   If the client wishes to update this information in\
    \ the future, it\n   sends a POST request with updated information to the account\
    \ URL.\n   The server MUST ignore any updates to the \"orders\" field,\n   \"\
    termsOfServiceAgreed\" field (see Section 7.3.3), the \"status\" field\n   (except\
    \ as allowed by Section 7.3.6), or any other fields it does not\n   recognize.\
    \  If the server accepts the update, it MUST return a\n   response with a 200\
    \ (OK) status code and the resulting account\n   object.\n   For example, to update\
    \ the contact information in the above account,\n   the client could send the\
    \ following request:\n   POST /acme/acct/evOfKhNU60wg HTTP/1.1\n   Host: example.com\n\
    \   Content-Type: application/jose+json\n   {\n     \"protected\": base64url({\n\
    \       \"alg\": \"ES256\",\n       \"kid\": \"https://example.com/acme/acct/evOfKhNU60wg\"\
    ,\n       \"nonce\": \"ax5RnthDqp_Yf4_HZnFLmA\",\n       \"url\": \"https://example.com/acme/acct/evOfKhNU60wg\"\
    \n     }),\n     \"payload\": base64url({\n       \"contact\": [\n         \"\
    mailto:certificates@example.org\",\n         \"mailto:admin@example.org\"\n  \
    \     ]\n     }),\n     \"signature\": \"hDXzvcj8T6fbFbmn...rDzXzzvzpRy64N0o\"\
    \n   }\n"
- title: 7.3.3.  Changes of Terms of Service
  contents:
  - "7.3.3.  Changes of Terms of Service\n   As described above, a client can indicate\
    \ its agreement with the CA's\n   terms of service by setting the \"termsOfServiceAgreed\"\
    \ field in its\n   account object to \"true\".\n   If the server has changed its\
    \ terms of service since a client\n   initially agreed, and the server is unwilling\
    \ to process a request\n   without explicit agreement to the new terms, then it\
    \ MUST return an\n   error response with status code 403 (Forbidden) and type\n\
    \   \"urn:ietf:params:acme:error:userActionRequired\".  This response MUST\n \
    \  include a Link header field with link relation \"terms-of-service\" and\n \
    \  the latest terms-of-service URL.\n   The problem document returned with the\
    \ error MUST also include an\n   \"instance\" field, indicating a URL that the\
    \ client should direct a\n   human user to visit in order for instructions on\
    \ how to agree to the\n   terms.\n HTTP/1.1 403 Forbidden\n Replay-Nonce: T81bdZroZ2ITWSondpTmAw\n\
    \ Link: <https://example.com/acme/directory>;rel=\"index\"\n Link: <https://example.com/acme/terms/2017-6-02>;rel=\"\
    terms-of-service\"\n Content-Type: application/problem+json\n Content-Language:\
    \ en\n {\n   \"type\": \"urn:ietf:params:acme:error:userActionRequired\",\n  \
    \ \"detail\": \"Terms of service have changed\",\n   \"instance\": \"https://example.com/acme/agreement/?token=W8Ih3PswD-8\"\
    \n }\n"
- title: 7.3.4.  External Account Binding
  contents:
  - "7.3.4.  External Account Binding\n   The server MAY require a value for the \"\
    externalAccountBinding\" field\n   to be present in \"newAccount\" requests. \
    \ This can be used to\n   associate an ACME account with an existing account in\
    \ a non-ACME\n   system, such as a CA customer database.\n   To enable ACME account\
    \ binding, the CA operating the ACME server\n   needs to provide the ACME client\
    \ with a MAC key and a key identifier,\n   using some mechanism outside of ACME.\
    \  The key identifier MUST be an\n   ASCII string.  The MAC key SHOULD be provided\
    \ in base64url-encoded\n   form, to maximize compatibility between non-ACME provisioning\
    \ systems\n   and ACME clients.\n   The ACME client then computes a binding JWS\
    \ to indicate the external\n   account holder's approval of the ACME account key.\
    \  The payload of\n   this JWS is the ACME account key being registered, in JWK\
    \ form.  The\n   protected header of the JWS MUST meet the following criteria:\n\
    \   o  The \"alg\" field MUST indicate a MAC-based algorithm\n   o  The \"kid\"\
    \ field MUST contain the key identifier provided by the CA\n   o  The \"nonce\"\
    \ field MUST NOT be present\n   o  The \"url\" field MUST be set to the same value\
    \ as the outer JWS\n   The \"signature\" field of the JWS will contain the MAC\
    \ value computed\n   with the MAC key provided by the CA.\n   POST /acme/new-account\
    \ HTTP/1.1\n   Host: example.com\n   Content-Type: application/jose+json\n   {\n\
    \     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"jwk\":\
    \ /* account key */,\n       \"nonce\": \"K60BWPrMQG9SDxBDS_xtSw\",\n       \"\
    url\": \"https://example.com/acme/new-account\"\n     }),\n     \"payload\": base64url({\n\
    \       \"contact\": [\n         \"mailto:cert-admin@example.org\",\n        \
    \ \"mailto:admin@example.org\"\n       ],\n       \"termsOfServiceAgreed\": true,\n\
    \       \"externalAccountBinding\": {\n         \"protected\": base64url({\n \
    \          \"alg\": \"HS256\",\n           \"kid\": /* key identifier from CA\
    \ */,\n           \"url\": \"https://example.com/acme/new-account\"\n        \
    \ }),\n         \"payload\": base64url(/* same as in \"jwk\" above */),\n    \
    \     \"signature\": /* MAC using MAC key from CA */\n       }\n     }),\n   \
    \  \"signature\": \"5TWiqIYQfIDfALQv...x9C2mg8JGPxl5bI4\"\n   }\n   If such a\
    \ CA requires that newAccount requests contain an\n   \"externalAccountBinding\"\
    \ field, then it MUST provide the value \"true\"\n   in the \"externalAccountRequired\"\
    \ subfield of the \"meta\" field in the\n   directory object.  If the CA receives\
    \ a newAccount request without an\n   \"externalAccountBinding\" field, then it\
    \ SHOULD reply with an error of\n   type \"externalAccountRequired\".\n   When\
    \ a CA receives a newAccount request containing an\n   \"externalAccountBinding\"\
    \ field, it decides whether or not to verify\n   the binding.  If the CA does\
    \ not verify the binding, then it MUST NOT\n   reflect the \"externalAccountBinding\"\
    \ field in the resulting account\n   object (if any).  To verify the account binding,\
    \ the CA MUST take the\n   following steps:\n   1.  Verify that the value of the\
    \ field is a well-formed JWS\n   2.  Verify that the JWS protected field meets\
    \ the above criteria\n   3.  Retrieve the MAC key corresponding to the key identifier\
    \ in the\n       \"kid\" field\n   4.  Verify that the MAC on the JWS verifies\
    \ using that MAC key\n   5.  Verify that the payload of the JWS represents the\
    \ same key as was\n       used to verify the outer JWS (i.e., the \"jwk\" field\
    \ of the outer\n       JWS)\n   If all of these checks pass and the CA creates\
    \ a new account, then\n   the CA may consider the new account associated with\
    \ the external\n   account corresponding to the MAC key.  The account object the\
    \ CA\n   returns MUST include an \"externalAccountBinding\" field with the same\n\
    \   value as the field in the request.  If any of these checks fail, then\n  \
    \ the CA MUST reject the newAccount request.\n"
- title: 7.3.5.  Account Key Rollover
  contents:
  - "7.3.5.  Account Key Rollover\n   A client may wish to change the public key that\
    \ is associated with an\n   account in order to recover from a key compromise\
    \ or proactively\n   mitigate the impact of an unnoticed key compromise.\n   To\
    \ change the key associated with an account, the client sends a\n   request to\
    \ the server containing signatures by both the old and new\n   keys.  The signature\
    \ by the new key covers the account URL and the\n   old key, signifying a request\
    \ by the new key holder to take over the\n   account from the old key holder.\
    \  The signature by the old key covers\n   this request and its signature, and\
    \ indicates the old key holder's\n   assent to the rollover request.\n   To create\
    \ this request object, the client first constructs a\n   keyChange object describing\
    \ the account to be updated and its account\n   key:\n   account (required, string):\
    \  The URL for the account being modified.\n      The content of this field MUST\
    \ be the exact string provided in the\n      Location header field in response\
    \ to the newAccount request that\n      created the account.\n   oldKey (required,\
    \ JWK):  The JWK representation of the old key.\n   The client then encapsulates\
    \ the keyChange object in an \"inner\" JWS,\n   signed with the requested new\
    \ account key.  This \"inner\" JWS becomes\n   the payload for the \"outer\" JWS\
    \ that is the body of the ACME request.\n   The outer JWS MUST meet the normal\
    \ requirements for an ACME JWS\n   request body (see Section 6.2).  The inner\
    \ JWS MUST meet the normal\n   requirements, with the following differences:\n\
    \   o  The inner JWS MUST have a \"jwk\" header parameter, containing the\n  \
    \    public key of the new key pair.\n   o  The inner JWS MUST have the same \"\
    url\" header parameter as the\n      outer JWS.\n   o  The inner JWS MUST omit\
    \ the \"nonce\" header parameter.\n   This transaction has signatures from both\
    \ the old and new keys so\n   that the server can verify that the holders of the\
    \ two keys both\n   agree to the change.  The signatures are nested to preserve\
    \ the\n   property that all signatures on POST messages are signed by exactly\n\
    \   one key.  The \"inner\" JWS effectively represents a request by the\n   holder\
    \ of the new key to take over the account form the holder of the\n   old key.\
    \  The \"outer\" JWS represents the current account holder's\n   assent to this\
    \ request.\n   POST /acme/key-change HTTP/1.1\n   Host: example.com\n   Content-Type:\
    \ application/jose+json\n   {\n     \"protected\": base64url({\n       \"alg\"\
    : \"ES256\",\n       \"kid\": \"https://example.com/acme/acct/evOfKhNU60wg\",\n\
    \       \"nonce\": \"S9XaOcxP5McpnTcWPIhYuB\",\n       \"url\": \"https://example.com/acme/key-change\"\
    \n     }),\n     \"payload\": base64url({\n       \"protected\": base64url({\n\
    \         \"alg\": \"ES256\",\n         \"jwk\": /* new key */,\n         \"url\"\
    : \"https://example.com/acme/key-change\"\n       }),\n       \"payload\": base64url({\n\
    \         \"account\": \"https://example.com/acme/acct/evOfKhNU60wg\",\n     \
    \    \"oldKey\": /* old key */\n       }),\n       \"signature\": \"Xe8B94RD30Azj2ea...8BmZIRtcSKPSd8gU\"\
    \n     }),\n     \"signature\": \"5TWiqIYQfIDfALQv...x9C2mg8JGPxl5bI4\"\n   }\n\
    \   On receiving a keyChange request, the server MUST perform the\n   following\
    \ steps in addition to the typical JWS validation:\n   1.  Validate the POST request\
    \ belongs to a currently active account,\n       as described in Section 6.\n\
    \   2.  Check that the payload of the JWS is a well-formed JWS object\n      \
    \ (the \"inner JWS\").\n   3.  Check that the JWS protected header of the inner\
    \ JWS has a \"jwk\"\n       field.\n   4.  Check that the inner JWS verifies using\
    \ the key in its \"jwk\"\n       field.\n   5.  Check that the payload of the\
    \ inner JWS is a well-formed\n       keyChange object (as described above).\n\
    \   6.  Check that the \"url\" parameters of the inner and outer JWSs are\n  \
    \     the same.\n   7.  Check that the \"account\" field of the keyChange object\
    \ contains\n       the URL for the account matching the old key (i.e., the \"\
    kid\"\n       field in the outer JWS).\n   8.  Check that the \"oldKey\" field\
    \ of the keyChange object is the same\n       as the account key for the account\
    \ in question.\n   9.  Check that no account exists whose account key is the same\
    \ as the\n       key in the \"jwk\" header parameter of the inner JWS.\n   If\
    \ all of these checks pass, then the server updates the\n   corresponding account\
    \ by replacing the old account key with the new\n   public key and returns status\
    \ code 200 (OK).  Otherwise, the server\n   responds with an error status code\
    \ and a problem document describing\n   the error.  If there is an existing account\
    \ with the new key\n   provided, then the server SHOULD use status code 409 (Conflict)\
    \ and\n   provide the URL of that account in the Location header field.\n   Note\
    \ that changing the account key for an account SHOULD NOT have any\n   other impact\
    \ on the account.  For example, the server MUST NOT\n   invalidate pending orders\
    \ or authorization transactions based on a\n   change of account key.\n"
- title: 7.3.6.  Account Deactivation
  contents:
  - "7.3.6.  Account Deactivation\n   A client can deactivate an account by posting\
    \ a signed update to the\n   account URL with a status field of \"deactivated\"\
    .  Clients may wish\n   to do this when the account key is compromised or decommissioned.\
    \  A\n   deactivated account can no longer request certificate issuance or\n \
    \  access resources related to the account, such as orders or\n   authorizations.\
    \  If a server receives a POST or POST-as-GET from a\n   deactivated account,\
    \ it MUST return an error response with status\n   code 401 (Unauthorized) and\
    \ type\n   \"urn:ietf:params:acme:error:unauthorized\".\n   POST /acme/acct/evOfKhNU60wg\
    \ HTTP/1.1\n   Host: example.com\n   Content-Type: application/jose+json\n   {\n\
    \     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"kid\":\
    \ \"https://example.com/acme/acct/evOfKhNU60wg\",\n       \"nonce\": \"ntuJWWSic4WVNSqeUmshgg\"\
    ,\n       \"url\": \"https://example.com/acme/acct/evOfKhNU60wg\"\n     }),\n\
    \     \"payload\": base64url({\n       \"status\": \"deactivated\"\n     }),\n\
    \     \"signature\": \"earzVLd3m5M4xJzR...bVTqn7R08AKOVf3Y\"\n   }\n   The server\
    \ MUST verify that the request is signed by the account key.\n   If the server\
    \ accepts the deactivation request, it replies with a 200\n   (OK) status code\
    \ and the current contents of the account object.\n   Once an account is deactivated,\
    \ the server MUST NOT accept further\n   requests authorized by that account's\
    \ key.  The server SHOULD cancel\n   any pending operations authorized by the\
    \ account's key, such as\n   certificate orders.  A server may take a variety\
    \ of actions in\n   response to an account deactivation, e.g., deleting data related\
    \ to\n   that account or sending mail to the account's contacts.  Servers\n  \
    \ SHOULD NOT revoke certificates issued by the deactivated account,\n   since\
    \ this could cause operational disruption for servers using these\n   certificates.\
    \  ACME does not provide a way to reactivate a\n   deactivated account.\n"
- title: 7.4.  Applying for Certificate Issuance
  contents:
  - "7.4.  Applying for Certificate Issuance\n   The client begins the certificate\
    \ issuance process by sending a POST\n   request to the server's newOrder resource.\
    \  The body of the POST is a\n   JWS object whose JSON payload is a subset of\
    \ the order object defined\n   in Section 7.1.3, containing the fields that describe\
    \ the certificate\n   to be issued:\n   identifiers (required, array of object):\
    \  An array of identifier\n      objects that the client wishes to submit an order\
    \ for.\n      type (required, string):  The type of identifier.\n      value (required,\
    \ string):  The identifier itself.\n   notBefore (optional, string):  The requested\
    \ value of the notBefore\n      field in the certificate, in the date format defined\
    \ in [RFC3339].\n   notAfter (optional, string):  The requested value of the notAfter\n\
    \      field in the certificate, in the date format defined in [RFC3339].\n  \
    \ POST /acme/new-order HTTP/1.1\n   Host: example.com\n   Content-Type: application/jose+json\n\
    \   {\n     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"\
    kid\": \"https://example.com/acme/acct/evOfKhNU60wg\",\n       \"nonce\": \"5XJ1L3lEkMG7tR6pA00clA\"\
    ,\n       \"url\": \"https://example.com/acme/new-order\"\n     }),\n     \"payload\"\
    : base64url({\n       \"identifiers\": [\n         { \"type\": \"dns\", \"value\"\
    : \"www.example.org\" },\n         { \"type\": \"dns\", \"value\": \"example.org\"\
    \ }\n       ],\n       \"notBefore\": \"2016-01-01T00:04:00+04:00\",\n       \"\
    notAfter\": \"2016-01-08T00:04:00+04:00\"\n     }),\n     \"signature\": \"H6ZXtGjTZyUnPeKn...wEA4TklBdh3e454g\"\
    \n   }\n   The server MUST return an error if it cannot fulfill the request as\n\
    \   specified, and it MUST NOT issue a certificate with contents other\n   than\
    \ those requested.  If the server requires the request to be\n   modified in a\
    \ certain way, it should indicate the required changes\n   using an appropriate\
    \ error type and description.\n   If the server is willing to issue the requested\
    \ certificate, it\n   responds with a 201 (Created) response.  The body of this\
    \ response is\n   an order object reflecting the client's request and any\n  \
    \ authorizations the client must complete before the certificate will\n   be issued.\n\
    \   HTTP/1.1 201 Created\n   Replay-Nonce: MYAuvOpaoIiywTezizk5vw\n   Link: <https://example.com/acme/directory>;rel=\"\
    index\"\n   Location: https://example.com/acme/order/TOlocE8rfgo\n   {\n     \"\
    status\": \"pending\",\n     \"expires\": \"2016-01-05T14:09:07.99Z\",\n     \"\
    notBefore\": \"2016-01-01T00:00:00Z\",\n     \"notAfter\": \"2016-01-08T00:00:00Z\"\
    ,\n     \"identifiers\": [\n       { \"type\": \"dns\", \"value\": \"www.example.org\"\
    \ },\n       { \"type\": \"dns\", \"value\": \"example.org\" }\n     ],\n    \
    \ \"authorizations\": [\n       \"https://example.com/acme/authz/PAniVnsZcis\"\
    ,\n       \"https://example.com/acme/authz/r4HqLzrSrpI\"\n     ],\n     \"finalize\"\
    : \"https://example.com/acme/order/TOlocE8rfgo/finalize\"\n   }\n   The order\
    \ object returned by the server represents a promise that if\n   the client fulfills\
    \ the server's requirements before the \"expires\"\n   time, then the server will\
    \ be willing to finalize the order upon\n   request and issue the requested certificate.\
    \  In the order object,\n   any authorization referenced in the \"authorizations\"\
    \ array whose\n   status is \"pending\" represents an authorization transaction\
    \ that the\n   client must complete before the server will issue the certificate\n\
    \   (see Section 7.5).  If the client fails to complete the required\n   actions\
    \ before the \"expires\" time, then the server SHOULD change the\n   status of\
    \ the order to \"invalid\" and MAY delete the order resource.\n   Clients MUST\
    \ NOT make any assumptions about the sort order of\n   \"identifiers\" or \"authorizations\"\
    \ elements in the returned order\n   object.\n   Once the client believes it has\
    \ fulfilled the server's requirements,\n   it should send a POST request to the\
    \ order resource's finalize URL.\n   The POST body MUST include a CSR:\n   csr\
    \ (required, string):  A CSR encoding the parameters for the\n      certificate\
    \ being requested [RFC2986].  The CSR is sent in the\n      base64url-encoded\
    \ version of the DER format.  (Note: Because this\n      field uses base64url,\
    \ and does not include headers, it is\n      different from PEM.)\n   POST /acme/order/TOlocE8rfgo/finalize\
    \ HTTP/1.1\n   Host: example.com\n   Content-Type: application/jose+json\n   {\n\
    \     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"kid\":\
    \ \"https://example.com/acme/acct/evOfKhNU60wg\",\n       \"nonce\": \"MSF2j2nawWHPxxkE3ZJtKQ\"\
    ,\n       \"url\": \"https://example.com/acme/order/TOlocE8rfgo/finalize\"\n \
    \    }),\n     \"payload\": base64url({\n       \"csr\": \"MIIBPTCBxAIBADBFMQ...FS6aKdZeGsysoCo4H9P\"\
    ,\n     }),\n     \"signature\": \"uOrUfIIk5RyQ...nw62Ay1cl6AB\"\n   }\n   The\
    \ CSR encodes the client's requests with regard to the content of\n   the certificate\
    \ to be issued.  The CSR MUST indicate the exact same\n   set of requested identifiers\
    \ as the initial newOrder request.\n   Identifiers of type \"dns\" MUST appear\
    \ either in the commonName\n   portion of the requested subject name or in an\
    \ extensionRequest\n   attribute [RFC2985] requesting a subjectAltName extension,\
    \ or both.\n   (These identifiers may appear in any sort order.)  Specifications\n\
    \   that define new identifier types must specify where in the\n   certificate\
    \ signing request these identifiers can appear.\n   A request to finalize an order\
    \ will result in an error if the CA is\n   unwilling to issue a certificate corresponding\
    \ to the submitted CSR.\n   For example:\n   o  If the CSR and order identifiers\
    \ differ\n   o  If the account is not authorized for the identifiers indicated\
    \ in\n      the CSR\n   o  If the CSR requests extensions that the CA is not willing\
    \ to\n      include\n   In such cases, the problem document returned by the server\
    \ SHOULD use\n   error code \"badCSR\" and describe specific reasons the CSR was\n\
    \   rejected in its \"detail\" field.  After returning such an error, the\n  \
    \ server SHOULD leave the order in the \"ready\" state, to allow the\n   client\
    \ to submit a new finalize request with an amended CSR.\n   A request to finalize\
    \ an order will result in error if the order is\n   not in the \"ready\" state.\
    \  In such cases, the server MUST return a\n   403 (Forbidden) error with a problem\
    \ document of type\n   \"orderNotReady\".  The client should then send a POST-as-GET\
    \ request\n   to the order resource to obtain its current state.  The status of\
    \ the\n   order will indicate what action the client should take (see below).\n\
    \   If a request to finalize an order is successful, the server will\n   return\
    \ a 200 (OK) with an updated order object.  The status of the\n   order will indicate\
    \ what action the client should take:\n   o  \"invalid\": The certificate will\
    \ not be issued.  Consider this\n      order process abandoned.\n   o  \"pending\"\
    : The server does not believe that the client has\n      fulfilled the requirements.\
    \  Check the \"authorizations\" array for\n      entries that are still pending.\n\
    \   o  \"ready\": The server agrees that the requirements have been\n      fulfilled,\
    \ and is awaiting finalization.  Submit a finalization\n      request.\n   o \
    \ \"processing\": The certificate is being issued.  Send a POST-as-GET\n     \
    \ request after the time given in the Retry-After header field of\n      the response,\
    \ if any.\n   o  \"valid\": The server has issued the certificate and provisioned\
    \ its\n      URL to the \"certificate\" field of the order.  Download the\n  \
    \    certificate.\n   HTTP/1.1 200 OK\n   Replay-Nonce: CGf81JWBsq8QyIgPCi9Q9X\n\
    \   Link: <https://example.com/acme/directory>;rel=\"index\"\n   Location: https://example.com/acme/order/TOlocE8rfgo\n\
    \   {\n     \"status\": \"valid\",\n     \"expires\": \"2016-01-20T14:09:07.99Z\"\
    ,\n     \"notBefore\": \"2016-01-01T00:00:00Z\",\n     \"notAfter\": \"2016-01-08T00:00:00Z\"\
    ,\n     \"identifiers\": [\n       { \"type\": \"dns\", \"value\": \"www.example.org\"\
    \ },\n       { \"type\": \"dns\", \"value\": \"example.org\" }\n     ],\n    \
    \ \"authorizations\": [\n       \"https://example.com/acme/authz/PAniVnsZcis\"\
    ,\n       \"https://example.com/acme/authz/r4HqLzrSrpI\"\n     ],\n     \"finalize\"\
    : \"https://example.com/acme/order/TOlocE8rfgo/finalize\",\n     \"certificate\"\
    : \"https://example.com/acme/cert/mAt3xBGaobw\"\n   }\n"
- title: 7.4.1.  Pre-authorization
  contents:
  - "7.4.1.  Pre-authorization\n   The order process described above presumes that\
    \ authorization objects\n   are created reactively, in response to a certificate\
    \ order.  Some\n   servers may also wish to enable clients to obtain authorization\
    \ for\n   an identifier proactively, outside of the context of a specific\n  \
    \ issuance.  For example, a client hosting virtual servers for a\n   collection\
    \ of names might wish to obtain authorization before any\n   virtual servers are\
    \ created and only create a certificate when a\n   virtual server starts up.\n\
    \   In some cases, a CA running an ACME server might have a completely\n   external,\
    \ non-ACME process for authorizing a client to issue\n   certificates for an identifier.\
    \  In these cases, the CA should\n   provision its ACME server with authorization\
    \ objects corresponding to\n   these authorizations and reflect them as already\
    \ valid in any orders\n   submitted by the client.\n   If a CA wishes to allow\
    \ pre-authorization within ACME, it can offer a\n   \"new authorization\" resource\
    \ in its directory by adding the field\n   \"newAuthz\" with a URL for the newAuthz\
    \ resource.\n   To request authorization for an identifier, the client sends a\
    \ POST\n   request to the newAuthz resource specifying the identifier for which\n\
    \   authorization is being requested.\n   identifier (required, object):  The\
    \ identifier to appear in the\n      resulting authorization object (see Section\
    \ 7.1.4).\n      type (required, string):  The type of identifier.\n      value\
    \ (required, string):  The identifier itself.\n   POST /acme/new-authz HTTP/1.1\n\
    \   Host: example.com\n   Content-Type: application/jose+json\n   {\n     \"protected\"\
    : base64url({\n       \"alg\": \"ES256\",\n       \"kid\": \"https://example.com/acme/acct/evOfKhNU60wg\"\
    ,\n       \"nonce\": \"uQpSjlRb4vQVCjVYAyyUWg\",\n       \"url\": \"https://example.com/acme/new-authz\"\
    \n     }),\n     \"payload\": base64url({\n       \"identifier\": {\n        \
    \ \"type\": \"dns\",\n         \"value\": \"example.org\"\n       }\n     }),\n\
    \     \"signature\": \"nuSDISbWG8mMgE7H...QyVUL68yzf3Zawps\"\n   }\n   Note that\
    \ because the identifier in a pre-authorization request is\n   the exact identifier\
    \ to be included in the authorization object, pre-\n   authorization cannot be\
    \ used to authorize issuance of certificates\n   containing wildcard domain names.\n\
    \   Before processing the authorization request, the server SHOULD\n   determine\
    \ whether it is willing to issue certificates for the\n   identifier.  For example,\
    \ the server should check that the identifier\n   is of a supported type.  Servers\
    \ might also check names against a\n   blacklist of known high-value identifiers.\
    \  If the server is\n   unwilling to issue for the identifier, it SHOULD return\
    \ an error with\n   status code 403 (Forbidden), with a problem document describing\
    \ the\n   reason for the rejection.\n   If the server is willing to proceed, it\
    \ builds a pending\n   authorization object from the inputs submitted by the client:\n\
    \   o  \"identifier\" the identifier submitted by the client\n   o  \"status\"\
    \ MUST be \"pending\" unless the server has out-of-band\n      information about\
    \ the client's authorization status\n   o  \"challenges\" as selected by the server's\
    \ policy for this\n      identifier\n   The server allocates a new URL for this\
    \ authorization and returns a\n   201 (Created) response with the authorization\
    \ URL in the Location\n   header field and the JSON authorization object in the\
    \ body.  The\n   client then follows the process described in Section 7.5 to complete\n\
    \   the authorization process.\n"
- title: 7.4.2.  Downloading the Certificate
  contents:
  - "7.4.2.  Downloading the Certificate\n   To download the issued certificate, the\
    \ client simply sends a POST-\n   as-GET request to the certificate URL.\n   The\
    \ default format of the certificate is application/pem-certificate-\n   chain\
    \ (see Section 9).\n   The server MAY provide one or more link relation header\
    \ fields\n   [RFC8288] with relation \"alternate\".  Each such field SHOULD express\n\
    \   an alternative certificate chain starting with the same end-entity\n   certificate.\
    \  This can be used to express paths to various trust\n   anchors.  Clients can\
    \ fetch these alternates and use their own\n   heuristics to decide which is optimal.\n\
    \   POST /acme/cert/mAt3xBGaobw HTTP/1.1\n   Host: example.com\n   Content-Type:\
    \ application/jose+json\n   Accept: application/pem-certificate-chain\n   {\n\
    \     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"kid\":\
    \ \"https://example.com/acme/acct/evOfKhNU60wg\",\n       \"nonce\": \"uQpSjlRb4vQVCjVYAyyUWg\"\
    ,\n       \"url\": \"https://example.com/acme/cert/mAt3xBGaobw\"\n     }),\n \
    \    \"payload\": \"\",\n     \"signature\": \"nuSDISbWG8mMgE7H...QyVUL68yzf3Zawps\"\
    \n   }\n   HTTP/1.1 200 OK\n   Content-Type: application/pem-certificate-chain\n\
    \   Link: <https://example.com/acme/directory>;rel=\"index\"\n   -----BEGIN CERTIFICATE-----\n\
    \   [End-entity certificate contents]\n   -----END CERTIFICATE-----\n   -----BEGIN\
    \ CERTIFICATE-----\n   [Issuer certificate contents]\n   -----END CERTIFICATE-----\n\
    \   -----BEGIN CERTIFICATE-----\n   [Other certificate contents]\n   -----END\
    \ CERTIFICATE-----\n   A certificate resource represents a single, immutable certificate.\n\
    \   If the client wishes to obtain a renewed certificate, the client\n   initiates\
    \ a new order process to request one.\n   Because certificate resources are immutable\
    \ once issuance is\n   complete, the server MAY enable the caching of the resource\
    \ by adding\n   Expires and Cache-Control header fields specifying a point in\
    \ time in\n   the distant future.  These header fields have no relation to the\n\
    \   certificate's period of validity.\n   The ACME client MAY request other formats\
    \ by including an Accept\n   header field [RFC7231] in its request.  For example,\
    \ the client could\n   use the media type \"application/pkix-cert\" [RFC2585]\
    \ or \"application/\n   pkcs7-mime\" [RFC5751] to request the end-entity certificate\
    \ in DER\n   format.  Server support for alternate formats is OPTIONAL.  For\n\
    \   formats that can only express a single certificate, the server SHOULD\n  \
    \ provide one or more \"Link: rel=\"up\"\" header fields pointing to an\n   issuer\
    \ or issuers so that ACME clients can build a certificate chain\n   as defined\
    \ in TLS (see Section 4.4.2 of [RFC8446]).\n"
- title: 7.5.  Identifier Authorization
  contents:
  - "7.5.  Identifier Authorization\n   The identifier authorization process establishes\
    \ the authorization of\n   an account to manage certificates for a given identifier.\
    \  This\n   process assures the server of two things:\n   1.  That the client\
    \ controls the private key of the account key pair,\n       and\n   2.  That the\
    \ client controls the identifier in question.\n   This process may be repeated\
    \ to associate multiple identifiers with\n   an account (e.g., to request certificates\
    \ with multiple identifiers)\n   or to associate multiple accounts with an identifier\
    \ (e.g., to allow\n   multiple entities to manage certificates).\n   Authorization\
    \ resources are created by the server in response to\n   newOrder or newAuthz\
    \ requests submitted by an account key holder;\n   their URLs are provided to\
    \ the client in the responses to these\n   requests.  The authorization object\
    \ is implicitly tied to the account\n   key used to sign the request.\n   When\
    \ a client receives an order from the server in reply to a\n   newOrder request,\
    \ it downloads the authorization resources by sending\n   POST-as-GET requests\
    \ to the indicated URLs.  If the client initiates\n   authorization using a request\
    \ to the newAuthz resource, it will have\n   already received the pending authorization\
    \ object in the response to\n   that request.\n   POST /acme/authz/PAniVnsZcis\
    \ HTTP/1.1\n   Host: example.com\n   Content-Type: application/jose+json\n   {\n\
    \     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"kid\":\
    \ \"https://example.com/acme/acct/evOfKhNU60wg\",\n       \"nonce\": \"uQpSjlRb4vQVCjVYAyyUWg\"\
    ,\n       \"url\": \"https://example.com/acme/authz/PAniVnsZcis\"\n     }),\n\
    \     \"payload\": \"\",\n     \"signature\": \"nuSDISbWG8mMgE7H...QyVUL68yzf3Zawps\"\
    \n   }\n   HTTP/1.1 200 OK\n   Content-Type: application/json\n   Link: <https://example.com/acme/directory>;rel=\"\
    index\"\n   {\n     \"status\": \"pending\",\n     \"expires\": \"2016-01-02T14:09:30Z\"\
    ,\n     \"identifier\": {\n       \"type\": \"dns\",\n       \"value\": \"www.example.org\"\
    \n     },\n     \"challenges\": [\n       {\n         \"type\": \"http-01\",\n\
    \         \"url\": \"https://example.com/acme/chall/prV_B7yEyA4\",\n         \"\
    token\": \"DGyRejmCefe7v4NfDGDKfA\"\n       },\n       {\n         \"type\": \"\
    dns-01\",\n         \"url\": \"https://example.com/acme/chall/Rg5dV14Gh1Q\",\n\
    \         \"token\": \"DGyRejmCefe7v4NfDGDKfA\"\n       }\n     ]\n   }\n"
- title: 7.5.1.  Responding to Challenges
  contents:
  - "7.5.1.  Responding to Challenges\n   To prove control of the identifier and receive\
    \ authorization, the\n   client needs to provision the required challenge response\
    \ based on\n   the challenge type and indicate to the server that it is ready\
    \ for\n   the challenge validation to be attempted.\n   The client indicates to\
    \ the server that it is ready for the challenge\n   validation by sending an empty\
    \ JSON body (\"{}\") carried in a POST\n   request to the challenge URL (not the\
    \ authorization URL).\n   For example, if the client were to respond to the \"\
    http-01\" challenge\n   in the above authorization, it would send the following\
    \ request:\n   POST /acme/chall/prV_B7yEyA4 HTTP/1.1\n   Host: example.com\n \
    \  Content-Type: application/jose+json\n   {\n     \"protected\": base64url({\n\
    \       \"alg\": \"ES256\",\n       \"kid\": \"https://example.com/acme/acct/evOfKhNU60wg\"\
    ,\n       \"nonce\": \"Q_s3MWoqT05TrdkM2MTDcw\",\n       \"url\": \"https://example.com/acme/chall/prV_B7yEyA4\"\
    \n     }),\n     \"payload\": base64url({}),\n     \"signature\": \"9cbg5JO1Gf5YLjjz...SpkUfcdPai9uVYYQ\"\
    \n   }\n   The server updates the authorization document by updating its\n   representation\
    \ of the challenge with the response object provided by\n   the client.  The server\
    \ MUST ignore any fields in the response object\n   that are not specified as\
    \ response fields for this type of challenge.\n   Note that the challenges in\
    \ this document do not define any response\n   fields, but future specifications\
    \ might define them.  The server\n   provides a 200 (OK) response with the updated\
    \ challenge object as its\n   body.\n   If the client's response is invalid for\
    \ any reason or does not\n   provide the server with appropriate information to\
    \ validate the\n   challenge, then the server MUST return an HTTP error.  On receiving\n\
    \   such an error, the client SHOULD undo any actions that have been\n   taken\
    \ to fulfill the challenge, e.g., removing files that have been\n   provisioned\
    \ to a web server.\n   The server is said to \"finalize\" the authorization when\
    \ it has\n   completed one of the validations.  This is done by assigning the\n\
    \   authorization a status of \"valid\" or \"invalid\", corresponding to\n   whether\
    \ it considers the account authorized for the identifier.  If\n   the final state\
    \ is \"valid\", then the server MUST include an \"expires\"\n   field.  When finalizing\
    \ an authorization, the server MAY remove\n   challenges other than the one that\
    \ was completed, and it may modify\n   the \"expires\" field.  The server SHOULD\
    \ NOT remove challenges with\n   status \"invalid\".\n   Usually, the validation\
    \ process will take some time, so the client\n   will need to poll the authorization\
    \ resource to see when it is\n   finalized.  For challenges where the client can\
    \ tell when the server\n   has validated the challenge (e.g., by seeing an HTTP\
    \ or DNS request\n   from the server), the client SHOULD NOT begin polling until\
    \ it has\n   seen the validation request from the server.\n   To check on the\
    \ status of an authorization, the client sends a POST-\n   as-GET request to the\
    \ authorization URL, and the server responds with\n   the current authorization\
    \ object.  In responding to poll requests\n   while the validation is still in\
    \ progress, the server MUST return a\n   200 (OK) response and MAY include a Retry-After\
    \ header field to\n   suggest a polling interval to the client.\n   POST /acme/authz/PAniVnsZcis\
    \ HTTP/1.1\n   Host: example.com\n   Content-Type: application/jose+json\n   {\n\
    \     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"kid\":\
    \ \"https://example.com/acme/acct/evOfKhNU60wg\",\n       \"nonce\": \"uQpSjlRb4vQVCjVYAyyUWg\"\
    ,\n       \"url\": \"https://example.com/acme/authz/PAniVnsZcis\"\n     }),\n\
    \     \"payload\": \"\",\n     \"signature\": \"nuSDISbWG8mMgE7H...QyVUL68yzf3Zawps\"\
    \n   }\n   HTTP/1.1 200 OK\n   Content-Type: application/json\n   Link: <https://example.com/acme/directory>;rel=\"\
    index\"\n   {\n     \"status\": \"valid\",\n     \"expires\": \"2018-09-09T14:09:01.13Z\"\
    ,\n     \"identifier\": {\n       \"type\": \"dns\",\n       \"value\": \"www.example.org\"\
    \n     },\n     \"challenges\": [\n       {\n         \"type\": \"http-01\",\n\
    \         \"url\": \"https://example.com/acme/chall/prV_B7yEyA4\",\n         \"\
    status\": \"valid\",\n         \"validated\": \"2014-12-01T12:05:13.72Z\",\n \
    \        \"token\": \"IlirfxKKXAsHtmzK29Pj8A\"\n       }\n     ]\n   }\n"
- title: 7.5.2.  Deactivating an Authorization
  contents:
  - "7.5.2.  Deactivating an Authorization\n   If a client wishes to relinquish its\
    \ authorization to issue\n   certificates for an identifier, then it may request\
    \ that the server\n   deactivate each authorization associated with it by sending\
    \ POST\n   requests with the static object {\"status\": \"deactivated\"} to each\n\
    \   authorization URL.\n   POST /acme/authz/PAniVnsZcis HTTP/1.1\n   Host: example.com\n\
    \   Content-Type: application/jose+json\n   {\n     \"protected\": base64url({\n\
    \       \"alg\": \"ES256\",\n       \"kid\": \"https://example.com/acme/acct/evOfKhNU60wg\"\
    ,\n       \"nonce\": \"xWCM9lGbIyCgue8di6ueWQ\",\n       \"url\": \"https://example.com/acme/authz/PAniVnsZcis\"\
    \n     }),\n     \"payload\": base64url({\n       \"status\": \"deactivated\"\n\
    \     }),\n     \"signature\": \"srX9Ji7Le9bjszhu...WTFdtujObzMtZcx4\"\n   }\n\
    \   The server MUST verify that the request is signed by the account key\n   corresponding\
    \ to the account that owns the authorization.  If the\n   server accepts the deactivation,\
    \ it should reply with a 200 (OK)\n   status code and the updated contents of\
    \ the authorization object.\n   The server MUST NOT treat deactivated authorization\
    \ objects as\n   sufficient for issuing certificates.\n"
- title: 7.6.  Certificate Revocation
  contents:
  - "7.6.  Certificate Revocation\n   To request that a certificate be revoked, the\
    \ client sends a POST\n   request to the ACME server's revokeCert URL.  The body\
    \ of the POST is\n   a JWS object whose JSON payload contains the certificate\
    \ to be\n   revoked:\n   certificate (required, string):  The certificate to be\
    \ revoked, in\n      the base64url-encoded version of the DER format.  (Note:\
    \ Because\n      this field uses base64url, and does not include headers, it is\n\
    \      different from PEM.)\n   reason (optional, int):  One of the revocation\
    \ reasonCodes defined in\n      Section 5.3.1 of [RFC5280] to be used when generating\
    \ OCSP\n      responses and CRLs.  If this field is not set, the server SHOULD\n\
    \      omit the reasonCode CRL entry extension when generating OCSP\n      responses\
    \ and CRLs.  The server MAY disallow a subset of\n      reasonCodes from being\
    \ used by the user.  If a request contains a\n      disallowed reasonCode, then\
    \ the server MUST reject it with the\n      error type \"urn:ietf:params:acme:error:badRevocationReason\"\
    .  The\n      problem document detail SHOULD indicate which reasonCodes are\n\
    \      allowed.\n   Revocation requests are different from other ACME requests\
    \ in that\n   they can be signed with either an account key pair or the key pair\
    \ in\n   the certificate.\n   Example using an account key pair for the signature:\n\
    \   POST /acme/revoke-cert HTTP/1.1\n   Host: example.com\n   Content-Type: application/jose+json\n\
    \   {\n     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"\
    kid\": \"https://example.com/acme/acct/evOfKhNU60wg\",\n       \"nonce\": \"JHb54aT_KTXBWQOzGYkt9A\"\
    ,\n       \"url\": \"https://example.com/acme/revoke-cert\"\n     }),\n     \"\
    payload\": base64url({\n       \"certificate\": \"MIIEDTCCAvegAwIBAgIRAP8...\"\
    ,\n       \"reason\": 4\n     }),\n     \"signature\": \"Q1bURgJoEslbD1c5...3pYdSMLio57mQNN4\"\
    \n   }\n   Example using the certificate key pair for the signature:\n   POST\
    \ /acme/revoke-cert HTTP/1.1\n   Host: example.com\n   Content-Type: application/jose+json\n\
    \   {\n     \"protected\": base64url({\n       \"alg\": \"RS256\",\n       \"\
    jwk\": /* certificate's public key */,\n       \"nonce\": \"JHb54aT_KTXBWQOzGYkt9A\"\
    ,\n       \"url\": \"https://example.com/acme/revoke-cert\"\n     }),\n     \"\
    payload\": base64url({\n       \"certificate\": \"MIIEDTCCAvegAwIBAgIRAP8...\"\
    ,\n       \"reason\": 1\n     }),\n     \"signature\": \"Q1bURgJoEslbD1c5...3pYdSMLio57mQNN4\"\
    \n   }\n   Before revoking a certificate, the server MUST verify that the key\n\
    \   used to sign the request is authorized to revoke the certificate.\n   The\
    \ server MUST consider at least the following accounts authorized\n   for a given\
    \ certificate:\n   o  the account that issued the certificate.\n   o  an account\
    \ that holds authorizations for all of the identifiers in\n      the certificate.\n\
    \   The server MUST also consider a revocation request valid if it is\n   signed\
    \ with the private key corresponding to the public key in the\n   certificate.\n\
    \   If the revocation succeeds, the server responds with status code 200\n   (OK).\
    \  If the revocation fails, the server returns an error.  For\n   example, if\
    \ the certificate has already been revoked, the server\n   returns an error response\
    \ with status code 400 (Bad Request) and type\n   \"urn:ietf:params:acme:error:alreadyRevoked\"\
    .\n   HTTP/1.1 200 OK\n   Replay-Nonce: IXVHDyxIRGcTE0VSblhPzw\n   Content-Length:\
    \ 0\n   Link: <https://example.com/acme/directory>;rel=\"index\"\n   --- or ---\n\
    \   HTTP/1.1 403 Forbidden\n   Replay-Nonce: lXfyFzi6238tfPQRwgfmPU\n   Content-Type:\
    \ application/problem+json\n   Content-Language: en\n   Link: <https://example.com/acme/directory>;rel=\"\
    index\"\n   {\n     \"type\": \"urn:ietf:params:acme:error:unauthorized\",\n \
    \    \"detail\": \"No authorization provided for name example.org\"\n   }\n"
- title: 8.  Identifier Validation Challenges
  contents:
  - "8.  Identifier Validation Challenges\n   There are few types of identifiers in\
    \ the world for which there is a\n   standardized mechanism to prove possession\
    \ of a given identifier.  In\n   all practical cases, CAs rely on a variety of\
    \ means to test whether\n   an entity applying for a certificate with a given\
    \ identifier actually\n   controls that identifier.\n   Challenges provide the\
    \ server with assurance that an account holder\n   is also the entity that controls\
    \ an identifier.  For each type of\n   challenge, it must be the case that, in\
    \ order for an entity to\n   successfully complete the challenge, the entity must\
    \ both:\n   o  Hold the private key of the account key pair used to respond to\n\
    \      the challenge, and\n   o  Control the identifier in question.\n   Section\
    \ 10 documents how the challenges defined in this document meet\n   these requirements.\
    \  New challenges will need to document how they\n   do.\n   ACME uses an extensible\
    \ challenge/response framework for identifier\n   validation.  The server presents\
    \ a set of challenges in the\n   authorization object it sends to a client (as\
    \ objects in the\n   \"challenges\" array), and the client responds by sending\
    \ a response\n   object in a POST request to a challenge URL.\n   This section\
    \ describes an initial set of challenge types.  The\n   definition of a challenge\
    \ type includes:\n   1.  Content of challenge objects\n   2.  Content of response\
    \ objects\n   3.  How the server uses the challenge and response to verify control\n\
    \       of an identifier\n   Challenge objects all contain the following basic\
    \ fields:\n   type (required, string):  The type of challenge encoded in the\n\
    \      object.\n   url (required, string):  The URL to which a response can be\
    \ posted.\n   status (required, string):  The status of this challenge.  Possible\n\
    \      values are \"pending\", \"processing\", \"valid\", and \"invalid\" (see\n\
    \      Section 7.1.6).\n   validated (optional, string):  The time at which the\
    \ server validated\n      this challenge, encoded in the format specified in [RFC3339].\n\
    \      This field is REQUIRED if the \"status\" field is \"valid\".\n   error\
    \ (optional, object):  Error that occurred while the server was\n      validating\
    \ the challenge, if any, structured as a problem document\n      [RFC7807].  Multiple\
    \ errors can be indicated by using subproblems\n      Section 6.7.1.  A challenge\
    \ object with an error MUST have status\n      equal to \"invalid\".\n   All additional\
    \ fields are specified by the challenge type.  If the\n   server sets a challenge's\
    \ \"status\" to \"invalid\", it SHOULD also\n   include the \"error\" field to\
    \ help the client diagnose why the\n   challenge failed.\n   Different challenges\
    \ allow the server to obtain proof of different\n   aspects of control over an\
    \ identifier.  In some challenges, like HTTP\n   and DNS, the client directly\
    \ proves its ability to do certain things\n   related to the identifier.  The\
    \ choice of which challenges to offer\n   to a client under which circumstances\
    \ is a matter of server policy.\n   The identifier validation challenges described\
    \ in this section all\n   relate to validation of domain names.  If ACME is extended\
    \ in the\n   future to support other types of identifiers, there will need to\
    \ be\n   new challenge types, and they will need to specify which types of\n \
    \  identifier they apply to.\n"
- title: 8.1.  Key Authorizations
  contents:
  - "8.1.  Key Authorizations\n   All challenges defined in this document make use\
    \ of a key\n   authorization string.  A key authorization is a string that\n \
    \  concatenates the token for the challenge with a key fingerprint,\n   separated\
    \ by a \".\" character:\n   keyAuthorization = token || '.' || base64url(Thumbprint(accountKey))\n\
    \   The \"Thumbprint\" step indicates the computation specified in\n   [RFC7638],\
    \ using the SHA-256 digest [FIPS180-4].  As noted in\n   [RFC7518] any prepended\
    \ zero octets in the fields of a JWK object\n   MUST be stripped before doing\
    \ the computation.\n   As specified in the individual challenges below, the token\
    \ for a\n   challenge is a string comprised entirely of characters in the URL-\n\
    \   safe base64 alphabet.  The \"||\" operator indicates concatenation of\n  \
    \ strings.\n"
- title: 8.2.  Retrying Challenges
  contents:
  - "8.2.  Retrying Challenges\n   ACME challenges typically require the client to\
    \ set up some network-\n   accessible resource that the server can query in order\
    \ to validate\n   that the client controls an identifier.  In practice, it is\
    \ not\n   uncommon for the server's queries to fail while a resource is being\n\
    \   set up, e.g., due to information propagating across a cluster or\n   firewall\
    \ rules not being in place.\n   Clients SHOULD NOT respond to challenges until\
    \ they believe that the\n   server's queries will succeed.  If a server's initial\
    \ validation\n   query fails, the server SHOULD retry the query after some time,\
    \ in\n   order to account for delay in setting up responses such as DNS\n   records\
    \ or HTTP resources.  The precise retry schedule is up to the\n   server, but\
    \ server operators should keep in mind the operational\n   scenarios that the\
    \ schedule is trying to accommodate.  Given that\n   retries are intended to address\
    \ things like propagation delays in\n   HTTP or DNS provisioning, there should\
    \ not usually be any reason to\n   retry more often than every 5 or 10 seconds.\
    \  While the server is\n   still trying, the status of the challenge remains \"\
    processing\"; it is\n   only marked \"invalid\" once the server has given up.\n\
    \   The server MUST provide information about its retry state to the\n   client\
    \ via the \"error\" field in the challenge and the Retry-After\n   HTTP header\
    \ field in response to requests to the challenge resource.\n   The server MUST\
    \ add an entry to the \"error\" field in the challenge\n   after each failed validation\
    \ query.  The server SHOULD set the Retry-\n   After header field to a time after\
    \ the server's next validation\n   query, since the status of the challenge will\
    \ not change until that\n   time.\n   Clients can explicitly request a retry by\
    \ re-sending their response\n   to a challenge in a new POST request (with a new\
    \ nonce, etc.).  This\n   allows clients to request a retry when the state has\
    \ changed (e.g.,\n   after firewall rules have been updated).  Servers SHOULD\
    \ retry a\n   request immediately on receiving such a POST request.  In order\
    \ to\n   avoid denial-of-service attacks via client-initiated retries, servers\n\
    \   SHOULD rate-limit such requests.\n"
- title: 8.3.  HTTP Challenge
  contents:
  - "8.3.  HTTP Challenge\n   With HTTP validation, the client in an ACME transaction\
    \ proves its\n   control over a domain name by proving that it can provision HTTP\n\
    \   resources on a server accessible under that domain name.  The ACME\n   server\
    \ challenges the client to provision a file at a specific path,\n   with a specific\
    \ string as its content.\n   As a domain may resolve to multiple IPv4 and IPv6\
    \ addresses, the\n   server will connect to at least one of the hosts found in\
    \ the DNS A\n   and AAAA records, at its discretion.  Because many web servers\n\
    \   allocate a default HTTPS virtual host to a particular low-privilege\n   tenant\
    \ user in a subtle and non-intuitive manner, the challenge must\n   be completed\
    \ over HTTP, not HTTPS.\n   type (required, string):  The string \"http-01\".\n\
    \   token (required, string):  A random value that uniquely identifies\n     \
    \ the challenge.  This value MUST have at least 128 bits of entropy.\n      It\
    \ MUST NOT contain any characters outside the base64url alphabet\n      and MUST\
    \ NOT include base64 padding characters (\"=\").  See\n      [RFC4086] for additional\
    \ information on randomness requirements.\n   {\n     \"type\": \"http-01\",\n\
    \     \"url\": \"https://example.com/acme/chall/prV_B7yEyA4\",\n     \"status\"\
    : \"pending\",\n     \"token\": \"LoqXcYV8q5ONbJQxbmR7SCTNo3tiAXDfowyjxAjEuX0\"\
    \n   }\n   A client fulfills this challenge by constructing a key authorization\n\
    \   from the \"token\" value provided in the challenge and the client's\n   account\
    \ key.  The client then provisions the key authorization as a\n   resource on\
    \ the HTTP server for the domain in question.\n   The path at which the resource\
    \ is provisioned is comprised of the\n   fixed prefix \"/.well-known/acme-challenge/\"\
    , followed by the \"token\"\n   value in the challenge.  The value of the resource\
    \ MUST be the ASCII\n   representation of the key authorization.\n   GET /.well-known/acme-challenge/LoqXcYV8...jxAjEuX0\n\
    \   Host: example.org\n   HTTP/1.1 200 OK\n   Content-Type: application/octet-stream\n\
    \   LoqXcYV8...jxAjEuX0.9jg46WB3...fm21mqTI\n   (In the above, \"...\" indicates\
    \ that the token and the JWK thumbprint\n   in the key authorization have been\
    \ truncated to fit on the page.)\n   A client responds with an empty object ({})\
    \ to acknowledge that the\n   challenge can be validated by the server.\n   POST\
    \ /acme/chall/prV_B7yEyA4\n   Host: example.com\n   Content-Type: application/jose+json\n\
    \   {\n     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"\
    kid\": \"https://example.com/acme/acct/evOfKhNU60wg\",\n       \"nonce\": \"UQI1PoRi5OuXzxuX7V7wL0\"\
    ,\n       \"url\": \"https://example.com/acme/chall/prV_B7yEyA4\"\n     }),\n\
    \     \"payload\": base64url({}),\n     \"signature\": \"Q1bURgJoEslbD1c5...3pYdSMLio57mQNN4\"\
    \n   }\n   On receiving a response, the server constructs and stores the key\n\
    \   authorization from the challenge \"token\" value and the current client\n\
    \   account key.\n   Given a challenge/response pair, the server verifies the\
    \ client's\n   control of the domain by verifying that the resource was provisioned\n\
    \   as expected.\n   1.  Construct a URL by populating the URL template [RFC6570]\n\
    \       \"http://{domain}/.well-known/acme-challenge/{token}\", where:\n     \
    \  *  the domain field is set to the domain name being verified; and\n       *\
    \  the token field is set to the token in the challenge.\n   2.  Verify that the\
    \ resulting URL is well-formed.\n   3.  Dereference the URL using an HTTP GET\
    \ request.  This request MUST\n       be sent to TCP port 80 on the HTTP server.\n\
    \   4.  Verify that the body of the response is a well-formed key\n       authorization.\
    \  The server SHOULD ignore whitespace characters at\n       the end of the body.\n\
    \   5.  Verify that key authorization provided by the HTTP server matches\n  \
    \     the key authorization stored by the server.\n   The server SHOULD follow\
    \ redirects when dereferencing the URL.\n   Clients might use redirects, for example,\
    \ so that the response can be\n   provided by a centralized certificate management\
    \ server.  See\n   Section 10.2 for security considerations related to redirects.\n\
    \   If all of the above verifications succeed, then the validation is\n   successful.\
    \  If the request fails, or the body does not pass these\n   checks, then it has\
    \ failed.\n   The client SHOULD de-provision the resource provisioned for this\n\
    \   challenge once the challenge is complete, i.e., once the \"status\"\n   field\
    \ of the challenge has the value \"valid\" or \"invalid\".\n   Note that because\
    \ the token appears both in the request sent by the\n   ACME server and in the\
    \ key authorization in the response, it is\n   possible to build clients that\
    \ copy the token from request to\n   response.  Clients should avoid this behavior\
    \ because it can lead to\n   cross-site scripting vulnerabilities; instead, clients\
    \ should be\n   explicitly configured on a per-challenge basis.  A client that\
    \ does\n   copy tokens from requests to responses MUST validate that the token\n\
    \   in the request matches the token syntax above (e.g., that it includes\n  \
    \ only characters from the base64url alphabet).\n"
- title: 8.4.  DNS Challenge
  contents:
  - "8.4.  DNS Challenge\n   When the identifier being validated is a domain name,\
    \ the client can\n   prove control of that domain by provisioning a TXT resource\
    \ record\n   containing a designated value for a specific validation domain name.\n\
    \   type (required, string):  The string \"dns-01\".\n   token (required, string):\
    \  A random value that uniquely identifies\n      the challenge.  This value MUST\
    \ have at least 128 bits of entropy.\n      It MUST NOT contain any characters\
    \ outside the base64url alphabet,\n      including padding characters (\"=\").\
    \  See [RFC4086] for additional\n      information on randomness requirements.\n\
    \   {\n     \"type\": \"dns-01\",\n     \"url\": \"https://example.com/acme/chall/Rg5dV14Gh1Q\"\
    ,\n     \"status\": \"pending\",\n     \"token\": \"evaGxfADs6pSRb2LAv9IZf17Dt3juxGJ-PCt92wr-oA\"\
    \n   }\n   A client fulfills this challenge by constructing a key authorization\n\
    \   from the \"token\" value provided in the challenge and the client's\n   account\
    \ key.  The client then computes the SHA-256 digest [FIPS180-4]\n   of the key\
    \ authorization.\n   The record provisioned to the DNS contains the base64url\
    \ encoding of\n   this digest.  The client constructs the validation domain name\
    \ by\n   prepending the label \"_acme-challenge\" to the domain name being\n \
    \  validated, then provisions a TXT record with the digest value under\n   that\
    \ name.  For example, if the domain name being validated is\n   \"www.example.org\"\
    , then the client would provision the following DNS\n   record:\n   _acme-challenge.www.example.org.\
    \ 300 IN TXT \"gfj9Xq...Rg85nM\"\n   A client responds with an empty object ({})\
    \ to acknowledge that the\n   challenge can be validated by the server.\n   POST\
    \ /acme/chall/Rg5dV14Gh1Q\n   Host: example.com\n   Content-Type: application/jose+json\n\
    \   {\n     \"protected\": base64url({\n       \"alg\": \"ES256\",\n       \"\
    kid\": \"https://example.com/acme/acct/evOfKhNU60wg\",\n       \"nonce\": \"SS2sSl1PtspvFZ08kNtzKd\"\
    ,\n       \"url\": \"https://example.com/acme/chall/Rg5dV14Gh1Q\"\n     }),\n\
    \     \"payload\": base64url({}),\n     \"signature\": \"Q1bURgJoEslbD1c5...3pYdSMLio57mQNN4\"\
    \n   }\n   On receiving a response, the server constructs and stores the key\n\
    \   authorization from the challenge \"token\" value and the current client\n\
    \   account key.\n   To validate a DNS challenge, the server performs the following\
    \ steps:\n   1.  Compute the SHA-256 digest [FIPS180-4] of the stored key\n  \
    \     authorization\n   2.  Query for TXT records for the validation domain name\n\
    \   3.  Verify that the contents of one of the TXT records match the\n       digest\
    \ value\n   If all of the above verifications succeed, then the validation is\n\
    \   successful.  If no DNS record is found, or DNS record and response\n   payload\
    \ do not pass these checks, then the validation fails.\n   The client SHOULD de-provision\
    \ the resource record(s) provisioned for\n   this challenge once the challenge\
    \ is complete, i.e., once the\n   \"status\" field of the challenge has the value\
    \ \"valid\" or \"invalid\".\n"
- title: 9.  IANA Considerations
  contents:
  - '9.  IANA Considerations

    '
- title: '9.1.  Media Type: application/pem-certificate-chain'
  contents:
  - "9.1.  Media Type: application/pem-certificate-chain\n   A file of this type contains\
    \ one or more certificates encoded with\n   the PEM textual encoding, according\
    \ to [RFC7468].  The textual\n   encoding of certificates in this file MUST use\
    \ the strict encoding\n   and MUST NOT include explanatory text.  The ABNF for\
    \ this format is\n   as follows, where \"stricttextualmsg\" and \"eol\" are as\
    \ defined in\n   Section 3 of RFC 7468:\n   certchain = stricttextualmsg *(eol\
    \ stricttextualmsg)\n   In order to provide easy interoperation with TLS, the\
    \ first\n   certificate MUST be an end-entity certificate.  Each following\n \
    \  certificate SHOULD directly certify the one preceding it.  Because\n   certificate\
    \ validation requires that trust anchors be distributed\n   independently, a certificate\
    \ that represents a trust anchor MAY be\n   omitted from the chain, provided that\
    \ supported peers are known to\n   possess any omitted certificates.\n   The following\
    \ has been registered in the \"Media Types\" registry:\n   Type name: application\n\
    \   Subtype name: pem-certificate-chain\n   Required parameters: None\n   Optional\
    \ parameters: None\n   Encoding considerations: 7bit\n   Security considerations:\
    \ Carries a cryptographic certificate and its\n   associated certificate chain.\
    \  This media type carries no active\n   content.\n   Interoperability considerations:\
    \ None\n   Published specification: RFC 8555\n   Applications that use this media\
    \ type: ACME clients and servers, HTTP\n   servers, other applications that need\
    \ to be configured with a\n   certificate chain\n   Additional information:\n\
    \      Deprecated alias names for this type: n/a\n      Magic number(s): n/a\n\
    \      File extension(s): .pem\n      Macintosh file type code(s): n/a\n   Person\
    \ & email address to contact for further information: See\n   Authors' Addresses\
    \ section.\n   Intended usage: COMMON\n   Restrictions on usage: n/a\n   Author:\
    \ See Authors' Addresses section.\n   Change controller: IETF <iesg@ietf.org>\n"
- title: 9.2.  Well-Known URI for the HTTP Challenge
  contents:
  - "9.2.  Well-Known URI for the HTTP Challenge\n   The following value has been\
    \ registered in the \"Well-Known URIs\"\n   registry (using the template from\
    \ [RFC5785]):\n   URI suffix: acme-challenge\n   Change controller: IETF\n   Specification\
    \ document(s): RFC 8555, Section 8.3\n   Related information: N/A\n"
- title: 9.3.  Replay-Nonce HTTP Header
  contents:
  - "9.3.  Replay-Nonce HTTP Header\n   The following value has been registered in\
    \ the \"Message Headers\"\n   registry:\n   +-------------------+----------+----------+-------------------------+\n\
    \   | Header Field Name | Protocol | Status   | Reference               |\n  \
    \ +-------------------+----------+----------+-------------------------+\n   |\
    \ Replay-Nonce      | http     | standard | RFC 8555, Section 6.5.1 |\n   +-------------------+----------+----------+-------------------------+\n"
- title: 9.4.  "url" JWS Header Parameter
  contents:
  - "9.4.  \"url\" JWS Header Parameter\n   The following value has been registered\
    \ in the \"JSON Web Signature\n   and Encryption Header Parameters\" registry:\n\
    \   o  Header Parameter Name: \"url\"\n   o  Header Parameter Description: URL\n\
    \   o  Header Parameter Usage Location(s): JWE, JWS\n   o  Change Controller:\
    \ IESG\n   o  Specification Document(s): RFC 8555, Section 6.4.1\n"
- title: 9.5.  "nonce" JWS Header Parameter
  contents:
  - "9.5.  \"nonce\" JWS Header Parameter\n   The following value has been registered\
    \ in the \"JSON Web Signature\n   and Encryption Header Parameters\" registry:\n\
    \   o  Header Parameter Name: \"nonce\"\n   o  Header Parameter Description: Nonce\n\
    \   o  Header Parameter Usage Location(s): JWE, JWS\n   o  Change Controller:\
    \ IESG\n   o  Specification Document(s): RFC 8555, Section 6.5.2\n"
- title: 9.6.  URN Sub-namespace for ACME (urn:ietf:params:acme)
  contents:
  - "9.6.  URN Sub-namespace for ACME (urn:ietf:params:acme)\n   The following value\
    \ has been registered in the \"IETF URN Sub-\n   namespace for Registered Protocol\
    \ Parameter Identifiers\" registry,\n   following the template in [RFC3553]:\n\
    \   Registry name:  acme\n   Specification:  RFC 8555\n   Repository:  http://www.iana.org/assignments/acme\n\
    \   Index value:  No transformation needed.\n"
- title: 9.7.  New Registries
  contents:
  - "9.7.  New Registries\n   IANA has created the following registries:\n   1.  ACME\
    \ Account Object Fields (Section 9.7.1)\n   2.  ACME Order Object Fields (Section\
    \ 9.7.2)\n   3.  ACME Authorization Object Fields (Section 9.7.3)\n   4.  ACME\
    \ Error Types (Section 9.7.4)\n   5.  ACME Resource Types (Section 9.7.5)\n  \
    \ 6.  ACME Directory Metadata Fields (Section 9.7.6)\n   7.  ACME Identifier Types\
    \ (Section 9.7.7)\n   8.  ACME Validation Methods (Section 9.7.8)\n   All of these\
    \ registries are under a heading of \"Automated Certificate\n   Management Environment\
    \ (ACME) Protocol\" and are administered under a\n   Specification Required policy\
    \ [RFC8126].\n"
- title: 9.7.1.  Fields in Account Objects
  contents:
  - "9.7.1.  Fields in Account Objects\n   The \"ACME Account Object Fields\" registry\
    \ lists field names that are\n   defined for use in ACME account objects.  Fields\
    \ marked as\n   \"configurable\" may be included in a newAccount request.\n  \
    \ Template:\n   o  Field name: The string to be used as a field name in the JSON\n\
    \      object\n   o  Field type: The type of value to be provided, e.g., string,\n\
    \      boolean, array of string\n   o  Requests: Either the value \"none\" or\
    \ a list of types of requests\n      where the field is allowed in a request object,\
    \ taken from the\n      following values:\n      *  \"new\" - Requests to the\
    \ \"newAccount\" URL\n      *  \"account\" - Requests to an account URL\n   o\
    \  Reference: Where this field is defined\n   Initial contents: The fields and\
    \ descriptions defined in\n   Section 7.1.2.\n   +------------------------+---------------+--------------+-----------+\n\
    \   | Field Name             | Field Type    | Requests     | Reference |\n  \
    \ +------------------------+---------------+--------------+-----------+\n   |\
    \ status                 | string        | new, account | RFC 8555  |\n   |  \
    \                      |               |              |           |\n   | contact\
    \                | array of      | new, account | RFC 8555  |\n   |          \
    \              | string        |              |           |\n   |            \
    \            |               |              |           |\n   | externalAccountBinding\
    \ | object        | new          | RFC 8555  |\n   |                        |\
    \               |              |           |\n   | termsOfServiceAgreed   | boolean\
    \       | new          | RFC 8555  |\n   |                        |          \
    \     |              |           |\n   | onlyReturnExisting     | boolean    \
    \   | new          | RFC 8555  |\n   |                        |              \
    \ |              |           |\n   | orders                 | string        |\
    \ none         | RFC 8555  |\n   +------------------------+---------------+--------------+-----------+\n"
- title: 9.7.2.  Fields in Order Objects
  contents:
  - "9.7.2.  Fields in Order Objects\n   The \"ACME Order Object Fields\" registry\
    \ lists field names that are\n   defined for use in ACME order objects.  Fields\
    \ marked as\n   \"configurable\" may be included in a newOrder request.\n   Template:\n\
    \   o  Field name: The string to be used as a field name in the JSON\n      object\n\
    \   o  Field type: The type of value to be provided, e.g., string,\n      boolean,\
    \ array of string\n   o  Configurable: Boolean indicating whether the server should\
    \ accept\n      values provided by the client\n   o  Reference: Where this field\
    \ is defined\n   Initial contents: The fields and descriptions defined in\n  \
    \ Section 7.1.3.\n      +----------------+-----------------+--------------+-----------+\n\
    \      | Field Name     | Field Type      | Configurable | Reference |\n     \
    \ +----------------+-----------------+--------------+-----------+\n      | status\
    \         | string          | false        | RFC 8555  |\n      |            \
    \    |                 |              |           |\n      | expires        |\
    \ string          | false        | RFC 8555  |\n      |                |     \
    \            |              |           |\n      | identifiers    | array of object\
    \ | true         | RFC 8555  |\n      |                |                 |   \
    \           |           |\n      | notBefore      | string          | true   \
    \      | RFC 8555  |\n      |                |                 |             \
    \ |           |\n      | notAfter       | string          | true         | RFC\
    \ 8555  |\n      |                |                 |              |         \
    \  |\n      | error          | string          | false        | RFC 8555  |\n\
    \      |                |                 |              |           |\n     \
    \ | authorizations | array of string | false        | RFC 8555  |\n      |   \
    \             |                 |              |           |\n      | finalize\
    \       | string          | false        | RFC 8555  |\n      |              \
    \  |                 |              |           |\n      | certificate    | string\
    \          | false        | RFC 8555  |\n      +----------------+-----------------+--------------+-----------+\n"
- title: 9.7.3.  Fields in Authorization Objects
  contents:
  - "9.7.3.  Fields in Authorization Objects\n   The \"ACME Authorization Object Fields\"\
    \ registry lists field names\n   that are defined for use in ACME authorization\
    \ objects.  Fields\n   marked as \"configurable\" may be included in a newAuthz\
    \ request.\n   Template:\n   o  Field name: The string to be used as a field name\
    \ in the JSON\n      object\n   o  Field type: The type of value to be provided,\
    \ e.g., string,\n      boolean, array of string\n   o  Configurable: Boolean indicating\
    \ whether the server should accept\n      values provided by the client\n   o\
    \  Reference: Where this field is defined\n   Initial contents: The fields and\
    \ descriptions defined in\n   Section 7.1.4.\n        +------------+-----------------+--------------+-----------+\n\
    \        | Field Name | Field Type      | Configurable | Reference |\n       \
    \ +------------+-----------------+--------------+-----------+\n        | identifier\
    \ | object          | true         | RFC 8555  |\n        |            |     \
    \            |              |           |\n        | status     | string     \
    \     | false        | RFC 8555  |\n        |            |                 | \
    \             |           |\n        | expires    | string          | false  \
    \      | RFC 8555  |\n        |            |                 |              |\
    \           |\n        | challenges | array of object | false        | RFC 8555\
    \  |\n        |            |                 |              |           |\n  \
    \      | wildcard   | boolean         | false        | RFC 8555  |\n        +------------+-----------------+--------------+-----------+\n"
- title: 9.7.4.  Error Types
  contents:
  - "9.7.4.  Error Types\n   The \"ACME Error Types\" registry lists values that are\
    \ used within URN\n   values that are provided in the \"type\" field of problem\
    \ documents in\n   ACME.\n   Template:\n   o  Type: The label to be included in\
    \ the URN for this error,\n      following \"urn:ietf:params:acme:error:\"\n \
    \  o  Description: A human-readable description of the error\n   o  Reference:\
    \ Where the error is defined\n   Initial contents: The types and descriptions\
    \ in the table in\n   Section 6.7 above, with the Reference field set to point\
    \ to this\n   specification.\n"
- title: 9.7.5.  Resource Types
  contents:
  - "9.7.5.  Resource Types\n   The \"ACME Resource Types\" registry lists the types\
    \ of resources that\n   ACME servers may list in their directory objects.\n  \
    \ Template:\n   o  Field name: The value to be used as a field name in the directory\n\
    \      object\n   o  Resource type: The type of resource labeled by the field\n\
    \   o  Reference: Where the resource type is defined\n   Initial contents:\n \
    \             +------------+--------------------+-----------+\n              |\
    \ Field Name | Resource Type      | Reference |\n              +------------+--------------------+-----------+\n\
    \              | newNonce   | New nonce          | RFC 8555  |\n             \
    \ |            |                    |           |\n              | newAccount\
    \ | New account        | RFC 8555  |\n              |            |           \
    \         |           |\n              | newOrder   | New order          | RFC\
    \ 8555  |\n              |            |                    |           |\n   \
    \           | newAuthz   | New authorization  | RFC 8555  |\n              | \
    \           |                    |           |\n              | revokeCert | Revoke\
    \ certificate | RFC 8555  |\n              |            |                    |\
    \           |\n              | keyChange  | Key change         | RFC 8555  |\n\
    \              |            |                    |           |\n             \
    \ | meta       | Metadata object    | RFC 8555  |\n              +------------+--------------------+-----------+\n"
- title: 9.7.6.  Fields in the "meta" Object within a Directory Object
  contents:
  - "9.7.6.  Fields in the \"meta\" Object within a Directory Object\n   The \"ACME\
    \ Directory Metadata Fields\" registry lists field names that\n   are defined\
    \ for use in the JSON object included in the \"meta\" field\n   of an ACME directory\
    \ object.\n   Template:\n   o  Field name: The string to be used as a field name\
    \ in the JSON\n      object\n   o  Field type: The type of value to be provided,\
    \ e.g., string,\n      boolean, array of string\n   o  Reference: Where this field\
    \ is defined\n   Initial contents: The fields and descriptions defined in\n  \
    \ Section 7.1.1.\n         +-------------------------+-----------------+-----------+\n\
    \         | Field Name              | Field Type      | Reference |\n        \
    \ +-------------------------+-----------------+-----------+\n         | termsOfService\
    \          | string          | RFC 8555  |\n         |                       \
    \  |                 |           |\n         | website                 | string\
    \          | RFC 8555  |\n         |                         |               \
    \  |           |\n         | caaIdentities           | array of string | RFC 8555\
    \  |\n         |                         |                 |           |\n   \
    \      | externalAccountRequired | boolean         | RFC 8555  |\n         +-------------------------+-----------------+-----------+\n"
- title: 9.7.7.  Identifier Types
  contents:
  - "9.7.7.  Identifier Types\n   The \"ACME Identifier Types\" registry lists the\
    \ types of identifiers\n   that can be present in ACME authorization objects.\n\
    \   Template:\n   o  Label: The value to be put in the \"type\" field of the identifier\n\
    \      object\n   o  Reference: Where the identifier type is defined\n   Initial\
    \ contents:\n                           +-------+-----------+\n              \
    \             | Label | Reference |\n                           +-------+-----------+\n\
    \                           | dns   | RFC 8555  |\n                          \
    \ +-------+-----------+\n"
- title: 9.7.8.  Validation Methods
  contents:
  - "9.7.8.  Validation Methods\n   The \"ACME Validation Methods\" registry lists\
    \ identifiers for the ways\n   that CAs can validate control of identifiers. \
    \ Each method's entry\n   must specify whether it corresponds to an ACME challenge\
    \ type.  The\n   \"Identifier Type\" field must be contained in the Label column\
    \ of the\n   \"ACME Identifier Types\" registry.\n   Template:\n   o  Label: The\
    \ identifier for this validation method\n   o  Identifier Type: The type of identifier\
    \ that this method applies\n      to\n   o  ACME: \"Y\" if the validation method\
    \ corresponds to an ACME\n      challenge type; \"N\" otherwise\n   o  Reference:\
    \ Where the validation method is defined\n   This registry may also contain reserved\
    \ entries (e.g., to avoid\n   collisions).  Such entries should have the \"ACME\"\
    \ field set to \"N\"\n   and the \"Identifier Type\" set to \"RESERVED\".\n  \
    \ Initial Contents\n            +------------+-----------------+------+-----------+\n\
    \            | Label      | Identifier Type | ACME | Reference |\n           \
    \ +------------+-----------------+------+-----------+\n            | http-01 \
    \   | dns             | Y    | RFC 8555  |\n            |            |       \
    \          |      |           |\n            | dns-01     | dns             |\
    \ Y    | RFC 8555  |\n            |            |                 |      |    \
    \       |\n            | tls-sni-01 | RESERVED        | N    | RFC 8555  |\n \
    \           |            |                 |      |           |\n            |\
    \ tls-sni-02 | RESERVED        | N    | RFC 8555  |\n            +------------+-----------------+------+-----------+\n\
    \   When evaluating a request for an assignment in this registry, the\n   designated\
    \ expert should ensure that the method being registered has\n   a clear, interoperable\
    \ definition and does not overlap with existing\n   validation methods.  That\
    \ is, it should not be possible for a client\n   and server to follow the same\
    \ set of actions to fulfill two different\n   validation methods.\n   The values\
    \ \"tls-sni-01\" and \"tls-sni-02\" are reserved because they\n   were used in\
    \ pre-RFC versions of this specification to denote\n   validation methods that\
    \ were removed because they were found not to\n   be secure in some cases.\n \
    \  Validation methods do not have to be compatible with ACME in order to\n   be\
    \ registered.  For example, a CA might wish to register a validation\n   method\
    \ to support its use with the ACME extensions to CAA [ACME-CAA].\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   ACME is a protocol for managing certificates\
    \ that attest to\n   identifier/key bindings.  Thus, the foremost security goal\
    \ of ACME is\n   to ensure the integrity of this process, i.e., to ensure that\
    \ the\n   bindings attested by certificates are correct and that only\n   authorized\
    \ entities can manage certificates.  ACME identifies clients\n   by their account\
    \ keys, so this overall goal breaks down into two more\n   precise goals:\n  \
    \ 1.  Only an entity that controls an identifier can get an\n       authorization\
    \ for that identifier\n   2.  Once authorized, an account key's authorizations\
    \ cannot be\n       improperly used by another account\n   In this section, we\
    \ discuss the threat model that underlies ACME and\n   the ways that ACME achieves\
    \ these security goals within that threat\n   model.  We also discuss the denial-of-service\
    \ risks that ACME servers\n   face, and a few other miscellaneous considerations.\n"
- title: 10.1.  Threat Model
  contents:
  - "10.1.  Threat Model\n   As a service on the Internet, ACME broadly exists within\
    \ the Internet\n   threat model [RFC3552].  In analyzing ACME, it is useful to\
    \ think of\n   an ACME server interacting with other Internet hosts along two\n\
    \   \"channels\":\n   o  An ACME channel, over which the ACME HTTPS requests are\
    \ exchanged\n   o  A validation channel, over which the ACME server performs\n\
    \      additional requests to validate a client's control of an\n      identifier\n\
    \   +------------+\n   |    ACME    |     ACME Channel\n   |   Client   |--------------------+\n\
    \   +------------+                    |\n                                    \
    \ V\n                               +------------+\n                         \
    \      |    ACME    |\n                               |   Server   |\n       \
    \                        +------------+\n   +------------+                   \
    \ |\n   | Validation |<-------------------+\n   |   Server   |  Validation Channel\n\
    \   +------------+\n                   Communications Channels Used by ACME\n\
    \   In practice, the risks to these channels are not entirely separate,\n   but\
    \ they are different in most cases.  Each channel, for example,\n   uses a different\
    \ communications pattern: the ACME channel will\n   comprise inbound HTTPS connections\
    \ to the ACME server and the\n   validation channel outbound HTTP or DNS requests.\n\
    \   Broadly speaking, ACME aims to be secure against active and passive\n   attackers\
    \ on any individual channel.  Some vulnerabilities arise\n   (noted below) when\
    \ an attacker can exploit both the ACME channel and\n   one of the others.\n \
    \  On the ACME channel, in addition to network-layer attackers, we also\n   need\
    \ to account for man-in-the-middle (MitM) attacks at the\n   application layer\
    \ and for abusive use of the protocol itself.\n   Protection against application-layer\
    \ MitM addresses potential\n   attackers such as Content Distribution Networks\
    \ (CDNs) and\n   middleboxes with a TLS MitM function.  Preventing abusive use\
    \ of ACME\n   means ensuring that an attacker with access to the validation channel\n\
    \   can't obtain illegitimate authorization by acting as an ACME client\n   (legitimately,\
    \ in terms of the protocol).\n   ACME does not protect against other types of\
    \ abuse by a MitM on the\n   ACME channel.  For example, such an attacker could\
    \ send a bogus\n   \"badSignatureAlgorithm\" error response to downgrade a client\
    \ to the\n   lowest-quality signature algorithm that the server supports.  A MitM\n\
    \   that is present on all connections (such as a CDN) can cause denial-\n   of-service\
    \ conditions in a variety of ways.\n"
- title: 10.2.  Integrity of Authorizations
  contents:
  - "10.2.  Integrity of Authorizations\n   ACME allows anyone to request challenges\
    \ for an identifier by\n   registering an account key and sending a newOrder request\
    \ using that\n   account key.  The integrity of the authorization process thus\
    \ depends\n   on the identifier validation challenges to ensure that the challenge\n\
    \   can only be completed by someone who both (1) holds the private key\n   of\
    \ the account key pair and (2) controls the identifier in question.\n   Validation\
    \ responses need to be bound to an account key pair in order\n   to avoid situations\
    \ where a MitM on ACME HTTPS requests can switch\n   out a legitimate domain holder's\
    \ account key for one of his choosing.\n   Such MitMs can arise, for example,\
    \ if a CA uses a CDN or third-party\n   reverse proxy in front of its ACME interface.\
    \  An attack by such an\n   MitM could have the following form:\n   1.  Legitimate\
    \ domain holder registers account key pair A\n   2.  MitM registers account key\
    \ pair B\n   3.  Legitimate domain holder sends a newOrder request signed using\n\
    \       account key A\n   4.  MitM suppresses the legitimate request but sends\
    \ the same request\n       signed using account key B\n   5.  ACME server issues\
    \ challenges and MitM forwards them to the\n       legitimate domain holder\n\
    \   6.  Legitimate domain holder provisions the validation response\n   7.  ACME\
    \ server performs validation query and sees the response\n       provisioned by\
    \ the legitimate domain holder\n   8.  Because the challenges were issued in response\
    \ to a message\n       signed with account key B, the ACME server grants authorization\n\
    \       to account key B (the MitM) instead of account key A (the\n       legitimate\
    \ domain holder)\n   Domain                                         ACME\n   Holder\
    \                  MitM                  Server\n     |                      |\
    \                      |\n     | newAccount(A)        |                      |\n\
    \     |--------------------->|--------------------->|\n     |                \
    \      |                      |\n     |                      | newAccount(B) \
    \       |\n     |                      |--------------------->|\n     | newOrder(domain,\
    \ A)  |                      |\n     |--------------------->|                \
    \      |\n     |                      | newOrder(domain, B)  |\n     |       \
    \               |--------------------->|\n     |                      |      \
    \                |\n     |   authz, challenges  |   authz, challenges  |\n   \
    \  |<---------------------|<---------------------|\n     |                   \
    \   |                      |\n     | response(chall, A)   | response(chall, B)\
    \   |\n     |--------------------->|--------------------->|\n     |          \
    \            |                      |\n     |  validation request  |         \
    \             |\n     |<--------------------------------------------|\n     |\
    \                      |                      |\n     | validation response  |\
    \                      |\n     |-------------------------------------------->|\n\
    \     |                      |                      |\n     |                \
    \      |                      | Considers challenge\n     |                  \
    \    |                      | fulfilled by B\n     |                      |  \
    \                    |\n             Man-in-the-Middle Attack Exploiting a Validation\n\
    \                    Method without Account Key Binding\n   All of the challenges\
    \ defined in this document have a binding between\n   the account private key\
    \ and the validation query made by the server,\n   via the key authorization.\
    \  The key authorization reflects the\n   account public key and is provided to\
    \ the server in the validation\n   response over the validation channel.\n   The\
    \ association of challenges to identifiers is typically done by\n   requiring\
    \ the client to perform some action that only someone who\n   effectively controls\
    \ the identifier can perform.  For the challenges\n   in this document, the actions\
    \ are as follows:\n   o  HTTP: Provision files under .well-known on a web server\
    \ for the\n      domain\n   o  DNS: Provision DNS resource records for the domain\n\
    \   There are several ways that these assumptions can be violated, both\n   by\
    \ misconfiguration and by attacks.  For example, on a web server\n   that allows\
    \ non-administrative users to write to .well-known, any\n   user can claim to\
    \ own the web server's hostname by responding to an\n   HTTP challenge.  Similarly,\
    \ if a server that can be used for ACME\n   validation is compromised by a malicious\
    \ actor, then that malicious\n   actor can use that access to obtain certificates\
    \ via ACME.\n   The use of hosting providers is a particular risk for ACME\n \
    \  validation.  If the owner of the domain has outsourced operation of\n   DNS\
    \ or web services to a hosting provider, there is nothing that can\n   be done\
    \ against tampering by the hosting provider.  As far as the\n   outside world\
    \ is concerned, the zone or website provided by the\n   hosting provider is the\
    \ real thing.\n   More limited forms of delegation can also lead to an unintended\
    \ party\n   gaining the ability to successfully complete a validation\n   transaction.\
    \  For example, suppose an ACME server follows HTTP\n   redirects in HTTP validation\
    \ and a website operator provisions a\n   catch-all redirect rule that redirects\
    \ requests for unknown resources\n   to a different domain.  Then the target of\
    \ the redirect could use\n   that to get a certificate through HTTP validation\
    \ since the\n   validation path will not be known to the primary server.\n   The\
    \ DNS is a common point of vulnerability for all of these\n   challenges.  An\
    \ entity that can provision false DNS records for a\n   domain can attack the\
    \ DNS challenge directly and can provision false\n   A/AAAA records to direct\
    \ the ACME server to send its HTTP validation\n   query to a remote server of\
    \ the attacker's choosing.  There are a few\n   different mitigations that ACME\
    \ servers can apply:\n   o  Always querying the DNS using a DNSSEC-validating\
    \ resolver\n      (enhancing security for zones that are DNSSEC-enabled)\n   o\
    \  Querying the DNS from multiple vantage points to address local\n      attackers\n\
    \   o  Applying mitigations against DNS off-path attackers, e.g., adding\n   \
    \   entropy to requests [DNS0x20] or only using TCP\n   Given these considerations,\
    \ the ACME validation process makes it\n   impossible for any attacker on the\
    \ ACME channel or a passive attacker\n   on the validation channel to hijack the\
    \ authorization process to\n   authorize a key of the attacker's choice.\n   An\
    \ attacker that can only see the ACME channel would need to convince\n   the validation\
    \ server to provide a response that would authorize the\n   attacker's account\
    \ key, but this is prevented by binding the\n   validation response to the account\
    \ key used to request challenges.  A\n   passive attacker on the validation channel\
    \ can observe the correct\n   validation response and even replay it, but that\
    \ response can only be\n   used with the account key for which it was generated.\n\
    \   An active attacker on the validation channel can subvert the ACME\n   process,\
    \ by performing normal ACME transactions and providing a\n   validation response\
    \ for his own account key.  The risks due to\n   hosting providers noted above\
    \ are a particular case.\n   Attackers can also exploit vulnerabilities in Internet\
    \ routing\n   protocols to gain access to the validation channel (see, e.g.,\n\
    \   [RFC7132]).  In order to make such attacks more difficult, it is\n   RECOMMENDED\
    \ that the server perform DNS queries and make HTTP\n   connections from multiple\
    \ points in the network.  Since routing\n   attacks are often localized or dependent\
    \ on the position of the\n   attacker, forcing the attacker to attack multiple\
    \ points (the\n   server's validation vantage points) or a specific point (the\
    \ DNS /\n   HTTP server) makes it more difficult to subvert ACME validation using\n\
    \   attacks on routing.\n"
- title: 10.3.  Denial-of-Service Considerations
  contents:
  - "10.3.  Denial-of-Service Considerations\n   As a protocol run over HTTPS, standard\
    \ considerations for TCP-based\n   and HTTP-based DoS mitigation also apply to\
    \ ACME.\n   At the application layer, ACME requires the server to perform a few\n\
    \   potentially expensive operations.  Identifier validation transactions\n  \
    \ require the ACME server to make outbound connections to potentially\n   attacker-controlled\
    \ servers, and certificate issuance can require\n   interactions with cryptographic\
    \ hardware.\n   In addition, an attacker can also cause the ACME server to send\n\
    \   validation requests to a domain of its choosing by submitting\n   authorization\
    \ requests for the victim domain.\n   All of these attacks can be mitigated by\
    \ the application of\n   appropriate rate limits.  Issues closer to the front\
    \ end, like POST\n   body validation, can be addressed using HTTP request limiting.\
    \  For\n   validation and certificate requests, there are other identifiers on\n\
    \   which rate limits can be keyed.  For example, the server might limit\n   the\
    \ rate at which any individual account key can issue certificates\n   or the rate\
    \ at which validation can be requested within a given\n   subtree of the DNS.\
    \  And in order to prevent attackers from\n   circumventing these limits simply\
    \ by minting new accounts, servers\n   would need to limit the rate at which accounts\
    \ can be registered.\n"
- title: 10.4.  Server-Side Request Forgery
  contents:
  - "10.4.  Server-Side Request Forgery\n   Server-Side Request Forgery (SSRF) attacks\
    \ can arise when an attacker\n   can cause a server to perform HTTP requests to\
    \ an attacker-chosen\n   URL.  In the ACME HTTP challenge validation process,\
    \ the ACME server\n   performs an HTTP GET request to a URL in which the attacker\
    \ can\n   choose the domain.  This request is made before the server has\n   verified\
    \ that the client controls the domain, so any client can cause\n   a query to\
    \ any domain.\n   Some ACME server implementations include information from the\n\
    \   validation server's response (in order to facilitate debugging).\n   Such\
    \ implementations enable an attacker to extract this information\n   from any\
    \ web server that is accessible to the ACME server, even if it\n   is not accessible\
    \ to the ACME client.  For example, the ACME server\n   might be able to access\
    \ servers behind a firewall that would prevent\n   access by the ACME client.\n\
    \   It might seem that the risk of SSRF through this channel is limited\n   by\
    \ the fact that the attacker can only control the domain of the URL,\n   not the\
    \ path.  However, if the attacker first sets the domain to one\n   they control,\
    \ then they can send the server an HTTP redirect (e.g., a\n   302 response) which\
    \ will cause the server to query an arbitrary URL.\n   In order to further limit\
    \ the SSRF risk, ACME server operators should\n   ensure that validation queries\
    \ can only be sent to servers on the\n   public Internet, and not, say, web services\
    \ within the server\n   operator's internal network.  Since the attacker could\
    \ make requests\n   to these public servers himself, he can't gain anything extra\
    \ through\n   an SSRF attack on ACME aside from a layer of anonymization.\n"
- title: 10.5.  CA Policy Considerations
  contents:
  - "10.5.  CA Policy Considerations\n   The controls on issuance enabled by ACME\
    \ are focused on validating\n   that a certificate applicant controls the identifier\
    \ he claims.\n   Before issuing a certificate, however, there are many other checks\n\
    \   that a CA might need to perform, for example:\n   o  Has the client agreed\
    \ to a subscriber agreement?\n   o  Is the claimed identifier syntactically valid?\n\
    \   o  For domain names:\n      *  If the leftmost label is a '*', then have the\
    \ appropriate\n         checks been applied?\n      *  Is the name on the Public\
    \ Suffix List?\n      *  Is the name a high-value name?\n      *  Is the name\
    \ a known phishing domain?\n   o  Is the key in the CSR sufficiently strong?\n\
    \   o  Is the CSR signed with an acceptable algorithm?\n   o  Has issuance been\
    \ authorized or forbidden by a Certification\n      Authority Authorization (CAA)\
    \ record ([RFC6844])?\n   CAs that use ACME to automate issuance will need to\
    \ ensure that their\n   servers perform all necessary checks before issuing.\n\
    \   CAs using ACME to allow clients to agree to terms of service should\n   keep\
    \ in mind that ACME clients can automate this agreement, possibly\n   not involving\
    \ a human user.\n   ACME does not specify how the server constructs the URLs that\
    \ it uses\n   to address resources.  If the server operator uses URLs that are\n\
    \   predictable to third parties, this can leak information about what\n   URLs\
    \ exist on the server, since an attacker can probe for whether a\n   POST-as-GET\
    \ request to the URL returns 404 (Not Found) or 401\n   (Unauthorized).\n   For\
    \ example, suppose that the CA uses highly structured URLs with\n   guessable\
    \ fields:\n   o  Accounts: https://example.com/:accountID\n   o  Orders: https://example.com/:accountID/:domainName\n\
    \   o  Authorizations: https://example.com/:accountID/:domainName\n   o  Certificates:\
    \ https://example.com/:accountID/:domainName\n   Under that scheme, an attacker\
    \ could probe for which domain names are\n   associated with which accounts, which\
    \ may allow correlation of\n   ownership between domain names, if the CA does\
    \ not otherwise permit\n   it.\n   To avoid leaking these correlations, CAs SHOULD\
    \ assign URLs with an\n   unpredictable component.  For example, a CA might assign\
    \ URLs for\n   each resource type from an independent namespace, using unpredictable\n\
    \   IDs for each resource:\n   o  Accounts: https://example.com/acct/:accountID\n\
    \   o  Orders: https://example.com/order/:orderID\n   o  Authorizations: https://example.com/authz/:authorizationID\n\
    \   o  Certificates: https://example.com/cert/:certID\n   Such a scheme would\
    \ leak only the type of resource, hiding the\n   additional correlations revealed\
    \ in the example above.\n"
- title: 11.  Operational Considerations
  contents:
  - "11.  Operational Considerations\n   There are certain factors that arise in operational\
    \ reality that\n   operators of ACME-based CAs will need to keep in mind when\n\
    \   configuring their services.  See the subsections below for examples.\n"
- title: 11.1.  Key Selection
  contents:
  - "11.1.  Key Selection\n   ACME relies on two different classes of key pair:\n\
    \   o  Account key pairs, which are used to authenticate account holders\n   o\
    \  Certificate key pairs, which are used to sign and verify CSRs (and\n      whose\
    \ public keys are included in certificates)\n   Compromise of the private key\
    \ of an account key pair has more serious\n   consequences than compromise of\
    \ a private key corresponding to a\n   certificate.  While the compromise of a\
    \ certificate key pair allows\n   the attacker to impersonate the entities named\
    \ in the certificate for\n   the lifetime of the certificate, the compromise of\
    \ an account key\n   pair allows the attacker to take full control of the victim's\
    \ ACME\n   account and take any action that the legitimate account holder could\n\
    \   take within the scope of ACME:\n   1.  Issuing certificates using existing\
    \ authorizations\n   2.  Revoking existing certificates\n   3.  Accessing and\
    \ changing account information (e.g., contacts)\n   4.  Changing the account key\
    \ pair for the account, locking out the\n       legitimate account holder\n  \
    \ For this reason, it is RECOMMENDED that each account key pair be used\n   only\
    \ for authentication of a single ACME account.  For example, the\n   public key\
    \ of an account key pair MUST NOT be included in a\n   certificate.  If an ACME\
    \ client receives a request from a user for\n   account creation or key rollover\
    \ using an account key that the client\n   knows to be used elsewhere, then the\
    \ client MUST return an error.\n   Clients MUST generate a fresh account key for\
    \ every account creation\n   or rollover operation.  Note that given the requirements\
    \ of\n   Section 7.3.1, servers will not create accounts with reused keys\n  \
    \ anyway.\n   ACME clients and servers MUST verify that a CSR submitted in a\n\
    \   finalize request does not contain a public key for any known account\n   key\
    \ pair.  In particular, when a server receives a finalize request,\n   it MUST\
    \ verify that the public key in a CSR is not the same as the\n   public key of\
    \ the account key pair used to authenticate that request.\n   This assures that\
    \ vulnerabilities in the protocols with which the\n   certificate is used (e.g.,\
    \ signing oracles in TLS [JSS15]) do not\n   result in compromise of the ACME\
    \ account.  Because ACME accounts are\n   uniquely identified by their account\
    \ key pair (see Section 7.3.1),\n   the server MUST not allow account key pair\
    \ reuse across multiple\n   accounts.\n"
- title: 11.2.  DNS Security
  contents:
  - "11.2.  DNS Security\n   As noted above, DNS forgery attacks against the ACME\
    \ server can\n   result in the server making incorrect decisions about domain\
    \ control\n   and thus mis-issuing certificates.  Servers SHOULD perform DNS\n\
    \   queries over TCP, which provides better resistance to some forgery\n   attacks\
    \ than DNS over UDP.\n   An ACME-based CA will often need to make DNS queries,\
    \ e.g., to\n   validate control of DNS names.  Because the security of such\n\
    \   validations ultimately depends on the authenticity of DNS data, every\n  \
    \ possible precaution should be taken to secure DNS queries done by the\n   CA.\
    \  Therefore, it is RECOMMENDED that ACME-based CAs make all DNS\n   queries via\
    \ DNSSEC-validating stub or recursive resolvers.  This\n   provides additional\
    \ protection to domains that choose to make use of\n   DNSSEC.\n   An ACME-based\
    \ CA must only use a resolver if it trusts the resolver\n   and every component\
    \ of the network route by which it is accessed.\n   Therefore, it is RECOMMENDED\
    \ that ACME-based CAs operate their own\n   DNSSEC-validating resolvers within\
    \ their trusted network and use\n   these resolvers both for CAA record lookups\
    \ and all record lookups in\n   furtherance of a challenge scheme (A, AAAA, TXT,\
    \ etc.).\n"
- title: 11.3.  Token Entropy
  contents:
  - "11.3.  Token Entropy\n   The http-01 and dns-01 validation methods mandate the\
    \ use of a random\n   token value to uniquely identify the challenge.  The value\
    \ of the\n   token is required to contain at least 128 bits of entropy for the\n\
    \   following security properties.  First, the ACME client should not be\n   able\
    \ to influence the ACME server's choice of token as this may allow\n   an attacker\
    \ to reuse a domain owner's previous challenge responses\n   for a new validation\
    \ request.  Second, the entropy requirement makes\n   it more difficult for ACME\
    \ clients to implement a \"naive\" validation\n   server that automatically replies\
    \ to challenges without being\n   configured per challenge.\n"
- title: 11.4.  Malformed Certificate Chains
  contents:
  - "11.4.  Malformed Certificate Chains\n   ACME provides certificate chains in the\
    \ widely used format known\n   colloquially as PEM (though it may diverge from\
    \ the actual Privacy\n   Enhanced Mail specification [RFC1421], as noted in [RFC7468]).\
    \  Some\n   current software will allow the configuration of a private key and\
    \ a\n   certificate in one PEM file by concatenating the textual encodings of\n\
    \   the two objects.  In the context of ACME, such software might be\n   vulnerable\
    \ to key replacement attacks.  A malicious ACME server could\n   cause a client\
    \ to use a private key of its choosing by including the\n   key in the PEM file\
    \ returned in response to a query for a certificate\n   URL.\n   When processing\
    \ a file of type \"application/pem-certificate-chain\", a\n   client SHOULD verify\
    \ that the file contains only encoded\n   certificates.  If anything other than\
    \ a certificate is found (i.e.,\n   if the string \"-----BEGIN\" is ever followed\
    \ by anything other than\n   \"CERTIFICATE\"), then the client MUST reject the\
    \ file as invalid.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [FIPS180-4]\n              National Institute\
    \ of Standards and Technology (NIST),\n              \"Secure Hash Standard (SHS)\"\
    , FIPS PUB 180-4,\n              DOI 10.6028/NIST.FIPS.180-4, August 2015,\n \
    \             <http://csrc.nist.gov/publications/fips/fips180-4/\n           \
    \   fips-180-4.pdf>.\n   [JSS15]    Somorovsky, J., Schwenk, J., and J. Somorovsky,\
    \ \"On the\n              Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1\n\
    \              v1.5 Encryption\", CSS '15 Proceedings of the 22nd ACM\n      \
    \        SIGSAC Conference on Computer and Communications\n              Security\
    \ Pages 1185-1196, DOI 10.1145/2810103.2813657,\n              <https://dl.acm.org/citation.cfm?id=2813657>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2585]\
    \  Housley, R. and P. Hoffman, \"Internet X.509 Public Key\n              Infrastructure\
    \ Operational Protocols: FTP and HTTP\",\n              RFC 2585, DOI 10.17487/RFC2585,\
    \ May 1999,\n              <https://www.rfc-editor.org/info/rfc2585>.\n   [RFC2818]\
    \  Rescorla, E., \"HTTP Over TLS\", RFC 2818,\n              DOI 10.17487/RFC2818,\
    \ May 2000,\n              <https://www.rfc-editor.org/info/rfc2818>.\n   [RFC2985]\
    \  Nystrom, M. and B. Kaliski, \"PKCS #9: Selected Object\n              Classes\
    \ and Attribute Types Version 2.0\", RFC 2985,\n              DOI 10.17487/RFC2985,\
    \ November 2000,\n              <https://www.rfc-editor.org/info/rfc2985>.\n \
    \  [RFC2986]  Nystrom, M. and B. Kaliski, \"PKCS #10: Certification\n        \
    \      Request Syntax Specification Version 1.7\", RFC 2986,\n              DOI\
    \ 10.17487/RFC2986, November 2000,\n              <https://www.rfc-editor.org/info/rfc2986>.\n\
    \   [RFC3339]  Klyne, G. and C. Newman, \"Date and Time on the Internet:\n   \
    \           Timestamps\", RFC 3339, DOI 10.17487/RFC3339, July 2002,\n       \
    \       <https://www.rfc-editor.org/info/rfc3339>.\n   [RFC3629]  Yergeau, F.,\
    \ \"UTF-8, a transformation format of ISO\n              10646\", STD 63, RFC\
    \ 3629, DOI 10.17487/RFC3629, November\n              2003, <https://www.rfc-editor.org/info/rfc3629>.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66,\n           \
    \   RFC 3986, DOI 10.17487/RFC3986, January 2005,\n              <https://www.rfc-editor.org/info/rfc3986>.\n\
    \   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n             \
    \ \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n             \
    \ DOI 10.17487/RFC4086, June 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n\
    \   [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n        \
    \      Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006,\n          \
    \    <https://www.rfc-editor.org/info/rfc4648>.\n   [RFC5234]  Crocker, D., Ed.\
    \ and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\"\
    , STD 68, RFC 5234,\n              DOI 10.17487/RFC5234, January 2008,\n     \
    \         <https://www.rfc-editor.org/info/rfc5234>.\n   [RFC5280]  Cooper, D.,\
    \ Santesson, S., Farrell, S., Boeyen, S.,\n              Housley, R., and W. Polk,\
    \ \"Internet X.509 Public Key\n              Infrastructure Certificate and Certificate\
    \ Revocation List\n              (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280,\
    \ May 2008,\n              <https://www.rfc-editor.org/info/rfc5280>.\n   [RFC5751]\
    \  Ramsdell, B. and S. Turner, \"Secure/Multipurpose Internet\n              Mail\
    \ Extensions (S/MIME) Version 3.2 Message\n              Specification\", RFC\
    \ 5751, DOI 10.17487/RFC5751, January\n              2010, <https://www.rfc-editor.org/info/rfc5751>.\n\
    \   [RFC5890]  Klensin, J., \"Internationalized Domain Names for\n           \
    \   Applications (IDNA): Definitions and Document Framework\",\n             \
    \ RFC 5890, DOI 10.17487/RFC5890, August 2010,\n              <https://www.rfc-editor.org/info/rfc5890>.\n\
    \   [RFC6068]  Duerst, M., Masinter, L., and J. Zawinski, \"The 'mailto'\n   \
    \           URI Scheme\", RFC 6068, DOI 10.17487/RFC6068, October 2010,\n    \
    \          <https://www.rfc-editor.org/info/rfc6068>.\n   [RFC6570]  Gregorio,\
    \ J., Fielding, R., Hadley, M., Nottingham, M.,\n              and D. Orchard,\
    \ \"URI Template\", RFC 6570,\n              DOI 10.17487/RFC6570, March 2012,\n\
    \              <https://www.rfc-editor.org/info/rfc6570>.\n   [RFC6844]  Hallam-Baker,\
    \ P. and R. Stradling, \"DNS Certification\n              Authority Authorization\
    \ (CAA) Resource Record\", RFC 6844,\n              DOI 10.17487/RFC6844, January\
    \ 2013,\n              <https://www.rfc-editor.org/info/rfc6844>.\n   [RFC7231]\
    \  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n             \
    \ Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n              DOI 10.17487/RFC7231,\
    \ June 2014,\n              <https://www.rfc-editor.org/info/rfc7231>.\n   [RFC7468]\
    \  Josefsson, S. and S. Leonard, \"Textual Encodings of PKIX,\n              PKCS,\
    \ and CMS Structures\", RFC 7468, DOI 10.17487/RFC7468,\n              April 2015,\
    \ <https://www.rfc-editor.org/info/rfc7468>.\n   [RFC7515]  Jones, M., Bradley,\
    \ J., and N. Sakimura, \"JSON Web\n              Signature (JWS)\", RFC 7515,\
    \ DOI 10.17487/RFC7515, May\n              2015, <https://www.rfc-editor.org/info/rfc7515>.\n\
    \   [RFC7518]  Jones, M., \"JSON Web Algorithms (JWA)\", RFC 7518,\n         \
    \     DOI 10.17487/RFC7518, May 2015,\n              <https://www.rfc-editor.org/info/rfc7518>.\n\
    \   [RFC7638]  Jones, M. and N. Sakimura, \"JSON Web Key (JWK)\n             \
    \ Thumbprint\", RFC 7638, DOI 10.17487/RFC7638, September\n              2015,\
    \ <https://www.rfc-editor.org/info/rfc7638>.\n   [RFC7797]  Jones, M., \"JSON\
    \ Web Signature (JWS) Unencoded Payload\n              Option\", RFC 7797, DOI\
    \ 10.17487/RFC7797, February 2016,\n              <https://www.rfc-editor.org/info/rfc7797>.\n\
    \   [RFC7807]  Nottingham, M. and E. Wilde, \"Problem Details for HTTP\n     \
    \         APIs\", RFC 7807, DOI 10.17487/RFC7807, March 2016,\n              <https://www.rfc-editor.org/info/rfc7807>.\n\
    \   [RFC8037]  Liusvaara, I., \"CFRG Elliptic Curve Diffie-Hellman (ECDH)\n  \
    \            and Signatures in JSON Object Signing and Encryption\n          \
    \    (JOSE)\", RFC 8037, DOI 10.17487/RFC8037, January 2017,\n              <https://www.rfc-editor.org/info/rfc8037>.\n\
    \   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n      \
    \        Writing an IANA Considerations Section in RFCs\", BCP 26,\n         \
    \     RFC 8126, DOI 10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8259]  Bray,\
    \ T., Ed., \"The JavaScript Object Notation (JSON) Data\n              Interchange\
    \ Format\", STD 90, RFC 8259,\n              DOI 10.17487/RFC8259, December 2017,\n\
    \              <https://www.rfc-editor.org/info/rfc8259>.\n   [RFC8288]  Nottingham,\
    \ M., \"Web Linking\", RFC 8288,\n              DOI 10.17487/RFC8288, October\
    \ 2017,\n              <https://www.rfc-editor.org/info/rfc8288>.\n   [RFC8446]\
    \  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n             \
    \ Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [ACME-CAA]\n              Landau, H., \"CAA\
    \ Record Extensions for Account URI and\n              ACME Method Binding\",\
    \ Work in Progress, draft-ietf-acme-\n              caa-06, January 2019.\n  \
    \ [ACME-IP]  Shoemaker, R., \"ACME IP Identifier Validation Extension\",\n   \
    \           Work in Progress, draft-ietf-acme-ip-05, February 2019.\n   [ACME-TELEPHONE]\n\
    \              Peterson, J. and R. Barnes, \"ACME Identifiers and\n          \
    \    Challenges for Telephone Numbers\", Work in Progress,\n              draft-ietf-acme-telephone-01,\
    \ October 2017.\n   [CABFBR]   CA/Browser Forum, \"CA/Browser Forum Baseline\n\
    \              Requirements\", September 2018,\n              <https://cabforum.org/baseline-requirements-documents/>.\n\
    \   [DNS0x20]  Vixie, P. and D. Dagon, \"Use of Bit 0x20 in DNS Labels to\n  \
    \            Improve Transaction Identity\", Work in Progress,\n             \
    \ draft-vixie-dnsext-dns0x20-00, March 2008.\n   [RFC1421]  Linn, J., \"Privacy\
    \ Enhancement for Internet Electronic\n              Mail: Part I: Message Encryption\
    \ and Authentication\n              Procedures\", RFC 1421, DOI 10.17487/RFC1421,\
    \ February\n              1993, <https://www.rfc-editor.org/info/rfc1421>.\n \
    \  [RFC3552]  Rescorla, E. and B. Korver, \"Guidelines for Writing RFC\n     \
    \         Text on Security Considerations\", BCP 72, RFC 3552,\n             \
    \ DOI 10.17487/RFC3552, July 2003,\n              <https://www.rfc-editor.org/info/rfc3552>.\n\
    \   [RFC3553]  Mealling, M., Masinter, L., Hardie, T., and G. Klyne, \"An\n  \
    \            IETF URN Sub-namespace for Registered Protocol\n              Parameters\"\
    , BCP 73, RFC 3553, DOI 10.17487/RFC3553, June\n              2003, <https://www.rfc-editor.org/info/rfc3553>.\n\
    \   [RFC5785]  Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known\n   \
    \           Uniform Resource Identifiers (URIs)\", RFC 5785,\n              DOI\
    \ 10.17487/RFC5785, April 2010,\n              <https://www.rfc-editor.org/info/rfc5785>.\n\
    \   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,\n          \
    \    Galperin, S., and C. Adams, \"X.509 Internet Public Key\n              Infrastructure\
    \ Online Certificate Status Protocol - OCSP\",\n              RFC 6960, DOI 10.17487/RFC6960,\
    \ June 2013,\n              <https://www.rfc-editor.org/info/rfc6960>.\n   [RFC7132]\
    \  Kent, S. and A. Chi, \"Threat Model for BGP Path Security\",\n            \
    \  RFC 7132, DOI 10.17487/RFC7132, February 2014,\n              <https://www.rfc-editor.org/info/rfc7132>.\n\
    \   [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations\
    \ for Secure Use of Transport Layer\n              Security (TLS) and Datagram\
    \ Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,\
    \ May\n              2015, <https://www.rfc-editor.org/info/rfc7525>.\n   [W3C.REC-cors-20140116]\n\
    \              Kesteren, A., Ed., \"Cross-Origin Resource Sharing\", W3C\n   \
    \           Recommendation REC-cors-20140116, January 2014,\n              <http://www.w3.org/TR/2014/REC-cors-20140116>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   In addition to the editors listed on the front page, this\
    \ document\n   has benefited from contributions from a broad set of contributors,\n\
    \   all the way back to its inception.\n   o  Andrew Ayer, SSLMate\n   o  Karthik\
    \ Bhargavan, INRIA\n   o  Peter Eckersley, EFF\n   o  Alex Halderman, University\
    \ of Michigan\n   o  Sophie Herold, Hemio\n   o  Tim Hollebeek, DigiCert\n   o\
    \  Eric Rescorla, Mozilla\n   o  Seth Schoen, EFF\n   o  Roland Shoemaker, Let's\
    \ Encrypt\n   o  Rob Stradling, Sectigo\n   o  Martin Thomson, Mozilla\n   o \
    \ Jakub Warmuz, University of Oxford\n   This document draws on many concepts\
    \ established by Eric Rescorla's\n   \"Automated Certificate Issuance Protocol\"\
    \ draft.  Martin Thomson\n   provided helpful guidance in the use of HTTP.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Richard Barnes\n   Cisco\n   Email: rlb@ipv.sx\n   Jacob\
    \ Hoffman-Andrews\n   EFF\n   Email: jsha@eff.org\n   Daniel McCarney\n   Let's\
    \ Encrypt\n   Email: cpu@letsencrypt.org\n   James Kasten\n   University of Michigan\n\
    \   Email: jdkasten@umich.edu\n"
