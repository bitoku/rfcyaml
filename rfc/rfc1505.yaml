- title: __initial_text__
  contents:
  - '              Encoding Header Field for Internet Messages

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard.  Discussion and\n  \
    \ suggestions for improvement are requested.  Please refer to the\n   current\
    \ edition of the \"IAB Official Protocol Standards\" for the\n   standardization\
    \ state and status of this protocol.  Distribution of\n   this memo is unlimited.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   Note that a standards-track technology already exists in this area\n\
    \   [11].\n"
- title: Abstract
  contents:
  - "Abstract\n   This document expands upon the elective experimental Encoding header\n\
    \   field which permits the mailing of multi-part, multi-structured\n   messages.\
    \  It replaces RFC 1154 [1].\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n          1.      Introduction . . . . . . . . . . . . . .\
    \ . . . . . . 3\n          2.      The Encoding Field . . . . . . . . . . . .\
    \ . . . . . 3\n          2.1       Format of the Encoding Field . . . . . . .\
    \ . . . . 3\n          2.2       <count>  . . . . . . . . . . . . . . . . . .\
    \ . . . 4\n          2.3       <keyword>  . . . . . . . . . . . . . . . . . .\
    \ . . 4\n          2.3.1       Nested Keywords  . . . . . . . . . . . . . . .\
    \ . 4\n          2.4       Comments . . . . . . . . . . . . . . . . . . . . .\
    \ 4\n          3.      Encodings  . . . . . . . . . . . . . . . . . . . . . 5\n\
    \          3.1       Text . . . . . . . . . . . . . . . . . . . . . . . 5\n  \
    \        3.2       Message  . . . . . . . . . . . . . . . . . . . . . 6\n    \
    \      3.3       Hex  . . . . . . . . . . . . . . . . . . . . . . . 6\n      \
    \    3.4       EVFU . . . . . . . . . . . . . . . . . . . . . . . 6\n        \
    \  3.5       EDI-X12 and EDIFACT  . . . . . . . . . . . . . . . 7\n          3.6\
    \       FS   . . . . . . . . . . . . . . . . . . . . . . . 7\n          3.7  \
    \     LZJU90 . . . . . . . . . . . . . . . . . . . . . . 7\n          3.8    \
    \   LZW  . . . . . . . . . . . . . . . . . . . . . . . 7\n          3.9      \
    \ UUENCODE . . . . . . . . . . . . . . . . . . . . . 7\n          3.10      PEM\
    \ and PEM-Clear  . . . . . . . . . . . . . . . . 8\n          3.11      PGP  .\
    \ . . . . . . . . . . . . . . . . . . . . . . 8\n          3.12      Signature\
    \  . . . . . . . . . . . . . . . . . . .  10\n          3.13      TAR  . . . .\
    \ . . . . . . . . . . . . . . . . . .  10\n          3.14      PostScript . .\
    \ . . . . . . . . . . . . . . . . .  10\n          3.15      SHAR . . . . . .\
    \ . . . . . . . . . . . . . . . .  10\n          3.16      Uniform Resource Locator\
    \ . . . . . . . . . . . .  10\n          3.17      Registering New Keywords .\
    \ . . . . . . . . . . .  11\n          4.      FS (File System) Object Encoding\
    \ . . . . . . . . .  11\n          4.1       Sections . . . . . . . . . . . .\
    \ . . . . . . . .  12\n          4.1.1       Directory  . . . . . . . . . . .\
    \ . . . . . . .  12\n          4.1.2       Entry  . . . . . . . . . . . . . .\
    \ . . . . . .  13\n          4.1.3       File . . . . . . . . . . . . . . . .\
    \ . . . . .  13\n          4.1.4       Segment  . . . . . . . . . . . . . . .\
    \ . . . .  13\n          4.1.5       Data . . . . . . . . . . . . . . . . . .\
    \ . . .  14\n          4.2       Attributes . . . . . . . . . . . . . . . . .\
    \ . .  14\n          4.2.1       Display  . . . . . . . . . . . . . . . . . .\
    \ .  14\n          4.2.2       Comment  . . . . . . . . . . . . . . . . . . .\
    \  15\n          4.2.3       Type . . . . . . . . . . . . . . . . . . . . .  15\n\
    \          4.2.4       Created  . . . . . . . . . . . . . . . . . . .  15\n  \
    \        4.2.5       Modified . . . . . . . . . . . . . . . . . . .  15\n    \
    \      4.2.6       Accessed . . . . . . . . . . . . . . . . . . .  15\n      \
    \    4.2.7       Owner  . . . . . . . . . . . . . . . . . . . .  15\n        \
    \  4.2.8       Group  . . . . . . . . . . . . . . . . . . . .  16\n          4.2.9\
    \       ACL  . . . . . . . . . . . . . . . . . . . . .  16\n          4.2.10 \
    \     Password . . . . . . . . . . . . . . . . . . .  16\n          4.2.11   \
    \   Block  . . . . . . . . . . . . . . . . . . . .  16\n          4.2.12     \
    \ Record . . . . . . . . . . . . . . . . . . . .  17\n          4.2.13      Application\
    \  . . . . . . . . . . . . . . . . .  17\n          4.3       Date Field . . .\
    \ . . . . . . . . . . . . . . . .  17\n          4.3.1       Syntax . . . . .\
    \ . . . . . . . . . . . . . . .  17\n          4.3.2       Semantics  . . . .\
    \ . . . . . . . . . . . . . .  17\n          5.      LZJU90: Compressed Encoding\
    \  . . . . . . . . . . .  18\n          5.1       Overview . . . . . . . . . .\
    \ . . . . . . . . . .  18\n          5.2       Specification of the LZJU90 compression\
    \  . . . .  19\n          5.3       The Decoder  . . . . . . . . . . . . . . .\
    \ . . .  21\n          5.3.1       An example of an Encoder . . . . . . . . .\
    \ . .  27\n          5.3.2       Example LZJU90 Compressed Object . . . . . .\
    \ .  33\n          6.      Alphabetical Listing of Defined Encodings  . . . .\
    \  34\n          7.      Security Considerations  . . . . . . . . . . . . .  34\n\
    \          8.      References . . . . . . . . . . . . . . . . . . . .  34\n  \
    \        9.      Acknowledgements . . . . . . . . . . . . . . . . .  35\n    \
    \      10.     Authors' Addresses . . . . . . . . . . . . . . . .  36\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   STD 11, RFC 822 [2] defines an electronic mail message to\
    \ consist of\n   two parts, the message header and the message body, separated\
    \ by a\n   blank line.\n   The Encoding header field permits the message body\
    \ itself to be\n   further broken up into parts, each part also separated from\
    \ the next\n   by a blank line.  Thus, conceptually, a message has a header part,\n\
    \   followed by one or more body parts, all separated by apparently blank\n  \
    \ lines.  Each body part has an encoding type.  The default (no\n   Encoding field\
    \ in the header) is a one part message body of type\n   \"Text\".\n   The purpose\
    \ of Encoding is to be descriptive of the content of a mail\n   message without\
    \ placing constraints on the content or requiring\n   additional structure to\
    \ appear in the body of the message that will\n   interfere with other processing.\n\
    \   A similar message format is used in the network news facility, and\n   posted\
    \ articles are often transferred by gateways between news and\n   mail.  The Encoding\
    \ field is perhaps even more useful in news, where\n   articles often are uuencoded\
    \ or shar'd, and have a number of\n   different nested encodings of graphics images\
    \ and so forth.  In news\n   in particular, the Encoding header keeps the structural\
    \ information\n   within the (usually concealed) article header, without affecting\
    \ the\n   visual presentation by simple news-reading software.\n"
- title: 2.  The Encoding Field
  contents:
  - "2.  The Encoding Field\n   The Encoding field consists of one or more subfields,\
    \ separated by\n   commas.  Each subfield corresponds to a part of the message,\
    \ in the\n   order of that part's appearance.  A subfield consists of a line count\n\
    \   and a keyword or a series of nested keywords defining the encoding.\n   The\
    \ line count is optional in the last subfield.\n"
- title: 2.1  Format of the Encoding Field
  contents:
  - "2.1  Format of the Encoding Field\n   The format of the Encoding field is:\n\
    \        [  <count> <keyword> [ <keyword> ]* ,  ]*\n                [ <count>\
    \ ] <keyword> [ <keyword> ]*\n        where:\n        <count>    := a decimal\
    \ integer\n        <keyword>  := a single alphanumeric token starting with an\
    \ alpha\n"
- title: 2.2  <count>
  contents:
  - "2.2  <count>\n   The line count is a decimal number specifying the number of\
    \ text\n   lines in the part.  Parts are separated by a blank line, which is not\n\
    \   included in the count of either the preceding or following part.\n   Blank\
    \ lines consist only of CR/LF.  Count may be zero, it must be\n   non-negative.\n\
    \   It is always possible to determine if the count is present because a\n   count\
    \ always begins with a digit and a keyword always begins with a\n   letter.\n\
    \   The count is not required on the last or only part.  A multi-part\n   message\
    \ that consists of only one part is thus identical to a\n   single-part message.\n"
- title: 2.3  <keyword>
  contents:
  - "2.3  <keyword>\n   Keyword defines the encoding type.  The keyword is a common\
    \ single-\n   word name for the encoding type and is not case-sensitive.\n   \
    \          Encoding: 107 Text\n"
- title: 2.3.1  Nested Keywords
  contents:
  - "2.3.1  Nested Keywords\n   Nested keywords are a series of keywords defining\
    \ a multi-encoded\n   message part.  The encoding keywords may either be an actual\
    \ series\n   of encoding steps the encoder used to generate the message part or\n\
    \   may merely be used to more precisely identify the type of encoding\n   (as\
    \ in the use of the keyword \"Signature\").\n   Nested keywords are parsed and\
    \ generated from left to right.  The\n   order is significant.  A decoding application\
    \ would process the list\n   from left to right, whereas, an encoder would process\
    \ the Internet\n   message and generate the nested keywords in the reverse order\
    \ of the\n   actual encoding process.\n        Encoding: 458 uuencode LZW tar\
    \ (Unix binary object)\n"
- title: 2.4  Comments
  contents:
  - "2.4  Comments\n   Comments enclosed in parentheses may be inserted anywhere in\
    \ the\n   encoding field.  Mail reading systems may pass the comments to their\n\
    \   clients.  Comments must not be used by mail reading systems for\n   content\
    \ interpretation.  Other parameters defining the type of\n   encoding must be\
    \ contained within the body portion of the Internet\n   message or be implied\
    \ by a keyword in the encoding field.\n"
- title: 3.  Encodings
  contents:
  - "3.  Encodings\n   This section describes some of the defined encodings used.\
    \  An\n   alphabetical listing is provided in Section 6.\n   As with the other\
    \ keyword-defined parts of the header format\n   standard, new keywords are expected\
    \ and welcomed.  Several basic\n   principles should be followed in adding encodings.\
    \  The keyword\n   should be the most common single word name for the encoding,\n\
    \   including acronyms if appropriate.  The intent is that different\n   implementors\
    \ will be likely to choose the same name for the same\n   encoding.  Keywords\
    \ should not be too general:  \"binary\" would have\n   been a bad choice for\
    \ the \"hex\" encoding.\n   The encoding should be as free from unnecessary idiosyncracies\
    \ as\n   possible, except when conforming to an existing standard, in which\n\
    \   case there is nothing that can be done.\n   The encoding should, if possible,\
    \ use only the 7 bit ASCII printing\n   characters if it is a complete transformation\
    \ of a source document\n   (e.g., \"hex\" or \"uuencode\").  If it is essentially\
    \ a text format, the\n   full range may be used.  If there is an external standard,\
    \ the\n   character set may already be defined.  Keywords beginning with \"X-\"\
    \n   are permanently reserved to implementation-specific use.  No standard\n \
    \  registered encoding keyword will ever begin with \"X-\".\n   New encoding keywords\
    \ which are not reserved for implementation-\n   specific use must be registered\
    \ with the Internet Assigned Numbers\n   Authority (IANA).  Refer to section 3.17\
    \ for additional information.\n"
- title: 3.1  Text
  contents:
  - "3.1  Text\n   This indicates that the message is in no particular encoded format,\n\
    \   but is to be presented to the user as-is.\n   The text is ISO-10646-UTF-1\
    \ [3].  As specified in STD 10, RFC 821\n   [10], the message is expected to consist\
    \ of lines of reasonable\n   length (less than or equal to 1000 characters).\n\
    \   On some older implementations of mail and news, only the 7 bit subset\n  \
    \ of ISO-10646-UTF-1 can be used.  This is identical to the ASCII 7 bit\n   code.\
    \  On some mail transports that are not compliant with STD 10,\n   RFC 821 [10],\
    \ line length may be restricted by the service.\n   Text may be followed by a\
    \ nested keyword to define the encoded part\n   further, e.g., \"signature\":\n\
    \        Encoding: 496 Text, 8 Text Signature\n   An automated file sending service\
    \ may find this useful, for example,\n   to differentiate between and ignore the\
    \ signature area when parsing\n   the body of a message for file requests.\n"
- title: 3.2  Message
  contents:
  - "3.2  Message\n   This encoding indicates that the body part is itself in the\
    \ format of\n   an Internet message, with its own header part and body part(s).\
    \  A\n   \"message\" body part's message header may be a full Internet message\n\
    \   header or it may consist only of an Encoding field.\n   Using the message\
    \ encoding on returned mail makes it practical for a\n   mail reading system to\
    \ implement a reliable automatic resending\n   function, if the mailer generates\
    \ it when returning contents.  It is\n   also useful in a \"copy append\" MUA\
    \ (mail user agent) operation.\n   MTAs (mail transfer agents) returning mail\
    \ should generate an\n   Encoding header.  Note that this does not require any\
    \ parsing or\n   transformation of the returned message; the message is simply\n\
    \   appended un-modified; MTAs are prohibited from modifying the content\n   of\
    \ messages.\n        Encoding: 7 Text (Return Reason), Message (Returned Mail)\n"
- title: 3.3  Hex
  contents:
  - "3.3  Hex\n   The encoding indicates that the body part contains binary data,\n\
    \   encoded as 2 hexadecimal digits per byte, highest significant nibble\n   first.\n\
    \   Lines consist of an even number of hexadecimal digits.  Blank lines\n   are\
    \ not permitted.  The decode process must accept lines with between\n   2 and\
    \ 1000 characters, inclusive.\n   The Hex encoding is provided as a simple way\
    \ of providing a method of\n   encoding small binary objects.\n"
- title: 3.4  EVFU
  contents:
  - "3.4  EVFU\n   EVFU (electronic vertical format unit) specifies that each line\n\
    \   begins with a one-character \"channel selector\".  The original purpose\n\
    \   was to select a channel on a paper tape loop controlling the printer.\n  \
    \ This encoding is sometimes called \"FORTRAN\" format.  It is the\n   default\
    \ output format of FORTRAN programs on a number of computer\n   systems.\n   The\
    \ legal characters are '0' to '9', '+', '-', and space.  These\n   correspond\
    \ to the 12 rows (and absence of a punch) on a printer\n   control tape (used\
    \ when the control unit was electromechanical).\n   The channels that have generally\
    \ agreed definitions are:\n        1          advances to the first print line\
    \ on the next page\n        0          skip a line, i.e., double-space\n     \
    \   +          over-print the preceeding line\n        -          skip 2 lines,\
    \ i.e., triple-space\n        (space)    print on the next line, single-space\n"
- title: 3.5  EDI-X12 and EDIFACT
  contents:
  - "3.5  EDI-X12 and EDIFACT\n   The EDI-X12 and EDIFACT keywords indicate that the\
    \ message or part is\n   a EDI (Electronic Document Interchange) business document,\
    \ formatted\n   according to ANSI X12 or the EDIFACT standard.\n   A message containing\
    \ a note and 2 X12 purchase orders might have an\n   encoding of:\n        Encoding:\
    \ 17 TEXT, 146 EDI-X12, 69 EDI-X12\n"
- title: 3.6  FS
  contents:
  - "3.6  FS\n   The FS (File System) keyword specifies a section consisting of\n\
    \   encoded file system objects.  This encoding method (defined in\n   section\
    \ 4) allows the moving of a structured set of files from one\n   environment to\
    \ another while preserving all common elements.\n"
- title: 3.7  LZJU90
  contents:
  - "3.7  LZJU90\n   The LZJU90 keyword specifies a section consisting of an encoded\n\
    \   binary or text object.  The encoding (defined in section 5) provides\n   both\
    \ compression and representation in a text format.\n"
- title: 3.8  LZW
  contents:
  - "3.8  LZW\n   The LZW keyword specifies a section consisting of the data produced\n\
    \   by the Unix compress program.\n"
- title: 3.9  UUENCODE
  contents:
  - "3.9  UUENCODE\n   The uuencode keyword specifies a section consisting of the\
    \ output of\n   the uuencode program supplied as part of uucp.\n"
- title: 3.10  PEM and PEM-Clear
  contents:
  - "3.10  PEM and PEM-Clear\n   The PEM and PEM-Clear keywords indicate that the\
    \ section is encrypted\n   with the methods specified in RFCs 1421-1424 [4,5,6,7]\
    \ or uses the\n   MIC-Clear encapsulation specified therein.\n   A simple text\
    \ object encrypted with PEM has the header:\n             Encoding: PEM Text\n\
    \   Note that while this indicates that the text resulting from the PEM\n   decryption\
    \ is ISO-10646-UTF-1 text, the present version of PEM\n   further restricts this\
    \ to only the 7 bit subset.  A future version of\n   PEM may lift this restriction.\n\
    \   If the object resulting from the decryption starts with Internet\n   message\
    \ header(s), the encoding is:\n             Encoding: PEM Message\n   This is\
    \ useful to conceal both the encoding within and the headers\n   not needed to\
    \ deliver the message (such as Subject:).\n   PEM does not provide detached signatures,\
    \ but rather provides the\n   MIC-Clear mode to send messages with integrity checks\
    \ that are not\n   encrypted.  In this mode, the keyword PEM-Clear is used:\n\
    \             Encoding: PEM-Clear EDIFACT\n   The example being a non-encrypted\
    \ EDIFACT transaction with a digital\n   signature.  With the proper selection\
    \ of PEM parameters and\n   environment, this can also provide non-repudiation,\
    \ but it does not\n   provide confidentiality.\n   Decoders that are capable of\
    \ decrypting PEM treat the two keywords in\n   the same way, using the contained\
    \ PEM headers to distinguish the\n   mode.  Decoders that do not understand PEM\
    \ can use the PEM-Clear\n   keyword as a hint that it may be useful to treat the\
    \ section as text,\n   or even continue the decode sequence after removing the\
    \ PEM headers.\n   When Encoding is used for PEM, the RFC934 [9] encapsulation\
    \ specified\n   in RFC1421 is not used.\n"
- title: 3.11  PGP
  contents:
  - "3.11  PGP\n   The PGP keyword indicates that the section is encrypted using the\n\
    \   Pretty Good Privacy specification, or is a public key block, keyring,\n  \
    \ or detached signature meaningful to the PGP program.  (These objects\n   are\
    \ distinguished by internal information.)\n   The keyword actually implies 3 different\
    \ transforms:  a compression\n   step, the encryption, and an ASCII encoding.\
    \  These transforms are\n   internal to the PGP encoder/decoder.  A simple text\
    \ message encrypted\n   with PGP is specified by:\n        Encoding: PGP Text\n\
    \   An EDI transaction using ANSI X12 might be:\n        Encoding: 176 PGP EDI-X12\n\
    \   Since an evesdropper can still \"see\" the nested type (Text or EDI in\n \
    \  these examples), thus making information available to traffic\n   analysis\
    \ which is undesirable in some applications, the sender may\n   prefer to use:\n\
    \        Encoding: PGP Message\n   As discussed in the description of the Message\
    \ keyword, the enclosed\n   object may have a complete header or consist only\
    \ of an Encoding:\n   header describing its content.\n   When PGP is used to transmit\
    \ an encoded key or keyring, with no\n   object significant to the mail user agent\
    \ as a result of the decoding\n   (e.g., text to display), the keyword is used\
    \ by itself.\n   Another case of the PGP keyword occurs in \"clear-signing\" a\
    \ message.\n   That is, sending an un-encrypted message with a digital signature\n\
    \   providing authentication and (in some environments) non-deniability.\n   \
    \     Encoding: 201 Text, 8 PGP Signature, 4 Text Signature\n   This example indicates\
    \ a 201 line message, followed by an 8 line (in\n   its encoded form) PGP detached\
    \ signature.  The processing of the PGP\n   section is expected (in this example)\
    \ to result in a text object that\n   is to be treated by the receiver as a signature,\
    \ possibly something\n   like:\n        [PGP signed Ariel@Process.COM Robert L\
    \ Ullmann  VALID/TRUSTED]\n   Note that the PGP signature algorithm is applied\
    \ to the encoded form\n   of the clear-text section, not the object(s) before\
    \ encoding.  (Which\n   would be quite difficult for encodings like tar or FS).\
    \  Continuing\n   the example, the PGP signature is then followed by a 4 line\n\
    \   \"ordinary\" signature section.\n"
- title: 3.12  Signature
  contents:
  - "3.12  Signature\n   The signature keyword indicates that the section contains\
    \ an Internet\n   message signature.  An Internet message signature is an area\
    \ of an\n   Internet message (usually located at the end) which contains a single\n\
    \   line or multiple lines of characters.  The signature may comprise the\n  \
    \ sender's name or a saying the sender is fond of.  It is normally\n   inserted\
    \ automatically in all outgoing message bodies.  The encoding\n   keyword \"Signature\"\
    \ must always be nested and follow another keyword.\n        Encoding: 14 Text,\
    \ 3 Text Signature\n   A usenet news posting program should generate an encoding\
    \ showing\n   which is the text and which is the signature area of the posted\n\
    \   message.\n"
- title: 3.13  TAR
  contents:
  - "3.13  TAR\n   The tar keyword specifies a section consisting of the output of\
    \ the\n   tar program supplied as part of Unix.\n"
- title: 3.14  PostScript
  contents:
  - "3.14  PostScript\n   The PostScript keyword specifies a section formatted according\
    \ to the\n   PostScript [8] computer program language definition.  PostScript\
    \ is a\n   registered trademark of Adobe Systems Inc.\n"
- title: 3.15  SHAR
  contents:
  - "3.15  SHAR\n   The SHAR keyword specifies a section encoded in shell archive\
    \ format.\n   Use of shar, although supported, is not recommended.\n   WARNING:\
    \  Because the shell archive may contain commands you may not\n   want executed,\
    \ the decoder should not automatically execute decoded\n   shell archived statements.\
    \  This warning also applies to any future\n   types that include commands to\
    \ be executed by the receiver.\n"
- title: 3.16  Uniform Resource Locator
  contents:
  - "3.16  Uniform Resource Locator\n   The URL keyword indicates that the section\
    \ consists of zero or more\n   references to resources of some type.  URL provides\
    \ a facility to\n   include by reference arbitrary external resources from various\n\
    \   sources in the Internet.  The specification of URL is a work in\n   progress\
    \ in the URI working group of the IETF.\n"
- title: 3.17  Registering New Keywords
  contents:
  - "3.17  Registering New Keywords\n   New encoding keywords which are not reserved\
    \ for implementation-\n   specific use must be registered with the Internet Assigned\
    \ Numbers\n   Authority (IANA).  IANA acts as a central registry for these values.\n\
    \   IANA may reject or modify the keyword registration request if it does\n  \
    \ not meet the criteria as specified in section 3.  Keywords beginning\n   with\
    \ \"X-\" are permanently reserved to implementation-specific use.\n   IANA will\
    \ not register an encoding keyword that begins with \"X-\".\n   Registration requests\
    \ should be sent via electronic mail to IANA as\n   follows:\n             To:\
    \  IANA@isi.edu\n             Subject:  Registration of a new EHF-MAIL Keyword\n\
    \   The mail message must specify the keyword for the encoding and\n   acronyms\
    \ if appropriate.  Documentation defining the keyword and its\n   proposed purpose\
    \ must be included.  The documentation must either\n   reference an external non-Internet\
    \ standards document or an existing\n   or soon to be RFC.  If applicable, the\
    \ documentation should contain a\n   draft version of the future RFC.  The draft\
    \ must be submitted as a\n   RFC according to the normal procedure within a reasonable\
    \ amount of\n   time after the keyword's registration has been approved.\n"
- title: 4.  FS (File System) Object Encoding
  contents:
  - "4.  FS (File System) Object Encoding\n   The file system encoding provides a\
    \ standard, transportable encoding\n   of file system objects from many different\
    \ operating systems.  The\n   intent is to allow the moving of a structured set\
    \ of files from one\n   environment to another while preserving common elements.\
    \  At the same\n   time, files can be moved within a single environment while\
    \ preserving\n   all attributes.\n   The representations consist of a series of\
    \ nested sections, with\n   attributes defined at the appropriate levels.  Each\
    \ section begins\n   with an open bracket \"[\" followed by a directive keyword\
    \ and ends\n   with a close bracket \"]\".  Attributes are lines, beginning with\
    \ a\n   keyword.  Lines which begin with a LWSP (linear white space)\n   character\
    \ are continuation lines.\n   Any string-type directive or attribute may be a\
    \ simple string not\n   starting with a quotation mark ( \" ) and not containing\
    \ special\n   characters (e.g.  newline) or LWSP (space and tab).  The string\
    \ name\n   begins with the first non-LWSP character on the line following the\n\
    \   attribute or directive keyword and ends with the last non-LWSP\n   character.\n\
    \   Otherwise, the character string name is enclosed in quotes.  The\n   string\
    \ itself contains characters in ISO-10646-UTF-1 but is quoted\n   and escaped\
    \ at octet level (as elsewhere in RFC822 [2]).  The strings\n   begin and end\
    \ with a quotation mark ( \" ).  Octets equal to quote in\n   the string are escaped,\
    \ as are octets equal to the escape characters\n   (\\\" and \\\\).  The escaped\
    \ octets may be part of a UTF multi-octet\n   character.  Octets that are not\
    \ printable are escaped with \\nnn octal\n   representation.  When an escape (\\\
    ) occurs at the end of a line, the\n   escape, the end of the line, and the first\
    \ character of the next\n   line, which must be one of the LWSP characters, are\
    \ removed\n   (ignored).\n    [ file Simple-File.Name\n    [ file \"   Long file\
    \ name starting with spaces and having a couple\\\n      [sic] of nasties in it\
    \ like this newline\\012near the end.\"\n   Note that in the above example, there\
    \ is one space (not two) between\n   \"couple\" and \"[sic]\".  The encoder may\
    \ choose to use the nnn sequence\n   for any character that might cause trouble.\
    \  Refer to section 5.1 for\n   line length recommendations.\n"
- title: 4.1  Sections
  contents:
  - "4.1  Sections\n   A section starts with an open bracket, followed by a keyword\
    \ that\n   defines the type of section.\n   The section keywords are:\n      \
    \       directory\n             entry\n             file\n             segment\n\
    \             data\n   The encoding may start with either a file, directory or\
    \ entry.  A\n   directory section may contain zero or more file, entry, and directory\n\
    \   sections.  A file section contains a data section or zero or more\n   segment\
    \ sections.  A segment section contains a data section or zero\n   or more segment\
    \ sections.\n"
- title: 4.1.1  Directory
  contents:
  - "4.1.1  Directory\n   This indicates the start of a directory.  There is one parameter,\
    \ the\n   entry name of the directory:\n             [ directory foo\n       \
    \      ...\n             ]\n"
- title: 4.1.2  Entry
  contents:
  - "4.1.2  Entry\n   The entry keyword represents an entry in a directory that is\
    \ not a\n   file or a sub-directory.  Examples of entries are soft links in Unix,\n\
    \   or access categories in Primos.  A Primos access category might look\n   like\
    \ this:\n             [ entry SYS.ACAT\n             type ACAT\n             created\
    \ 27 Jan 1987 15:31:04.00\n             acl SYADMIN:* ARIEL:DALURWX $REST:\n \
    \            ]\n"
- title: 4.1.3  File
  contents:
  - "4.1.3  File\n   The file keyword is followed by the entry name of the file. \
    \ The\n   section then continues with attributes, possibly segments, and then\n\
    \   data.\n             [ file MY.FILE\n             created 27 Feb 1987 12:10:20.07\n\
    \             modified 27 Mar 1987 16:17:03.02\n             type DAM\n      \
    \       [ data LZJU90\n             * LZJU90\n             ...\n             ]]\n"
- title: 4.1.4  Segment
  contents:
  - "4.1.4  Segment\n   This is used to define segments of a file.  It should only\
    \ be used\n   when encoding files that are actually segmented.  The optional\n\
    \   parameter is the number or name of the segment.\n   When encoding Macintosh\
    \ files, the two forks of the file are treated\n   as segments:\n            \
    \ [ file A.MAC.FILE\n             display \"A Mac File\"\n             type MAC\n\
    \             comment \"I created this myself\"\n             ...\n          \
    \   [ segment resource\n             [ data ...\n             ...\n          \
    \   ]]\n             [ segment data\n             [ data ...\n             ...\n\
    \             ]]]\n"
- title: 4.1.5  Data
  contents:
  - "4.1.5  Data\n   The data section contains the encoded data of the file.  The\
    \ encoding\n   method is defined in section 5.  The data section must be last\
    \ within\n   the containing section.\n"
- title: 4.2  Attributes
  contents:
  - "4.2  Attributes\n   Attributes may occur within file, entry, directory, and segment\n\
    \   sections.  Attributes must occur before sub-sections.\n   The attribute directives\
    \ are:\n             display\n             type\n             created\n      \
    \       modified\n             accessed\n             owner\n             group\n\
    \             acl\n             password\n             block\n             record\n\
    \             application\n"
- title: 4.2.1  Display
  contents:
  - "4.2.1  Display\n   This indicates the display name of the object.  Some systems,\
    \ such as\n   the Macintosh, use a different form of the name for matching or\n\
    \   uniqueness.\n"
- title: 4.2.2  Comment
  contents:
  - "4.2.2  Comment\n   This contains an arbitrary comment on the object.  The Macintosh\n\
    \   stores this attribute with the file.\n"
- title: 4.2.3  Type
  contents:
  - "4.2.3  Type\n   The type of an object is usually of interest only to the operating\n\
    \   system that the object was created on.\n   Types are:\n          ACAT    \
    \   access category (Primos)\n          CAM        contiguous access method (Primos)\n\
    \          DAM        direct access method (Primos)\n          FIXED      fixed\
    \ length records (VMS)\n          FLAT       `flat file', sequence of bytes (Unix,\
    \ DOS, default)\n          ISAM       indexed-sequential access method (VMS)\n\
    \          LINK       soft link (Unix)\n          MAC        Macintosh file\n\
    \          SAM        sequential access method (Primos)\n          SEGSAM    \
    \ segmented direct access method (Primos)\n          SEGDAM     segmented sequential\
    \ access method (Primos)\n          TEXT       lines of ISO-10646-UTF-1 text ending\
    \ with CR/LF\n          VAR        variable length records (VMS)\n"
- title: 4.2.4  Created
  contents:
  - "4.2.4  Created\n   Indicates the creation date of the file.  Dates are in the\
    \ format\n   defined in section 4.3.\n"
- title: 4.2.5  Modified
  contents:
  - "4.2.5  Modified\n   Indicates the date and time the file was last modified or\
    \ closed\n   after being open for write.\n"
- title: 4.2.6  Accessed
  contents:
  - "4.2.6  Accessed\n   Indicates the date and time the file was last accessed on\
    \ the\n   original file system.\n"
- title: 4.2.7  Owner
  contents:
  - "4.2.7  Owner\n   The owner directive gives the name or numerical ID of the owner\
    \ or\n   creator of the file.\n"
- title: 4.2.8  Group
  contents:
  - "4.2.8  Group\n   The group directive gives the name(s) or numerical IDs of the\
    \ group\n   or groups to which the file belongs.\n"
- title: 4.2.9  ACL
  contents:
  - "4.2.9  ACL\n   This directive specifies the access control list attribute of\
    \ an\n   object (the ACL attribute may occur more than once within an object).\n\
    \   The list consist of a series of pairs of IDs and access codes in the\n   format:\n\
    \                user-ID:access-list\n   There are four reserved IDs:\n      \
    \          $OWNER  the owner or creator\n                $GROUP  a member of the\
    \ group or groups\n                $SYSTEM a system administrator\n          \
    \      $REST   everyone else\n   The access list is zero or more single letters:\n\
    \                A    add (create file)\n                D    delete\n       \
    \         L    list (read directory)\n                P    change protection\n\
    \                R    read\n                U    use\n                W    write\n\
    \                X    execute\n                *    all possible access\n"
- title: 4.2.10  Password
  contents:
  - "4.2.10  Password\n   The password attribute gives the access password for this\
    \ object.\n   Since the content of the object follows (being the raison d'etre\
    \ of\n   the encoding), the appearance of the password in plain text is not\n\
    \   considered a security problem.  If the password is actually set by\n   the\
    \ decoder on a created object, the security (or lack) is the\n   responsibility\
    \ of the application domain controlling the decoder as\n   is true of ACL and\
    \ other protections.\n"
- title: 4.2.11  Block
  contents:
  - "4.2.11  Block\n   The block attribute gives the block size of the file as a decimal\n\
    \   number of bytes.\n"
- title: 4.2.12  Record
  contents:
  - "4.2.12  Record\n   The record attribute gives the record size of the file as\
    \ a decimal\n   number of bytes.\n"
- title: 4.2.13  Application
  contents:
  - "4.2.13  Application\n   This specifies the application that the file was created\
    \ with or\n   belongs to.  This is of particular interest for Macintosh files.\n"
- title: 4.3  Date Field
  contents:
  - "4.3  Date Field\n   Various attributes have a date and time subsequent to and\
    \ associated\n   with them.\n"
- title: 4.3.1  Syntax
  contents:
  - "4.3.1  Syntax\n   The syntax of the date field is a combination of date, time,\
    \ and\n   timezone:\n       DD Mon YYYY HH:MM:SS.FFFFFF [+-]HHMMSS\n       Date\
    \ :=  DD Mon YYYY      1 or 2 Digits \" \" 3 Alpha \" \" 4 Digits\n       DD \
    \  :=  Day              e.g. \"08\", \" 8\", \"8\"\n       Mon  :=  Month    \
    \        \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\" |\n                           \
    \      \"May\" | \"Jun\" | \"Jul\" | \"Aug\" |\n                             \
    \    \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n       YYYY :=  Year\n       Time\
    \ :=  HH:MM:SS.FFFFFF  2 Digits \":\" 2 Digits [ \":\" 2 Digits\n            \
    \                     [\".\" 1 to 6 Digits ] ]\n                             \
    \    e.g. 00:00:00, 23:59:59.999999\n       HH   :=  Hours            00 to 23\n\
    \       MM   :=  Minutes          00 to 59\n       SS   :=  Seconds          00\
    \ to 60 (60 only during a leap second)\n       FFFFF:=  Fraction\n       Zone\
    \ :=  [+-]HHMMSS       \"+\" | \"-\" 2 Digits [ 2 Digits\n                   \
    \              [ 2 Digits ] ]\n       HH   :=  Local Hour Offset\n       MM  \
    \ :=  Local Minutes Offset\n       SS   :=  Local Seconds Offset\n"
- title: 4.3.2  Semantics
  contents:
  - "4.3.2  Semantics\n   The date information is that which the file system has stored\
    \ in\n   regard to the file system object.  Date information is stored\n   differently\
    \ and with varying degrees of precision by different\n   computer file systems.\
    \  An encoder must include as much date\n   information as it has available concerning\
    \ the file system object.  A\n   decoder which receives an object encoded with\
    \ a date field containing\n   greater precision than its own must disregard the\
    \ excessive\n   information.  Zone is Co-ordinated Universal Time \"UTC\" (formerly\n\
    \   called \"Greenwich Mean Time\").  The field specifies the time zone of\n \
    \  the file system object as an offset from Universal Time.  It is\n   expressed\
    \ as a signed [+-] two, four or six digit number.\n   A file that was created\
    \ April 15, 1993 at 8:05 p.m.  in Roselle Park,\n   New Jersey, U.S.A.  might\
    \ have a date field which looks like:\n   15 Apr 1993 20:05:22.12 -0500\n"
- title: '5.  LZJU90:  Compressed Encoding'
  contents:
  - "5.  LZJU90:  Compressed Encoding\n   LZJU90 is an encoding for a binary or text\
    \ object to be sent in an\n   Internet mail message.  The encoding provides both\
    \ compression and\n   representation in a text format that will successfully survive\n\
    \   transmission through the many different mailers and gateways that\n   comprise\
    \ the Internet and connected mail networks.\n"
- title: 5.1  Overview
  contents:
  - "5.1  Overview\n   The encoding first compresses the binary object, using a modified\n\
    \   LZ77 algorithm, called LZJU90.  It then encodes each 6 bits of the\n   output\
    \ of the compression as a text character, using a character set\n   chosen to\
    \ survive any translations between codes, such as ASCII to\n   EBCDIC.  The 64\
    \ six-bit strings 000000 through 111111 are represented\n   by the characters\
    \ \"+\", \"-\", \"0\" to \"9\", \"A\" to \"Z\", and \"a\" to \"z\".\n   The output\
    \ text begins with a line identifying the encoding.  This is\n   for visual reference\
    \ only, the \"Encoding:\" field in the header\n   identifies the section to the\
    \ user program.  It also names the object\n   that was encoded, usually by a file\
    \ name.\n   The format of this line is:\n                * LZJU90 <name>\n   where\
    \ <name> is optional.  For example:\n                * LZJU90 vmunix\n   This\
    \ is followed by the compressed and encoded data, broken into\n   lines where\
    \ convenient.  It is recommended that lines be broken every\n   78 characters\
    \ to survive mailers than incorrectly restrict line\n   length.  The decoder must\
    \ accept lines with 1 to 1000 characters on\n   each line.  After this, there\
    \ is one final line that gives the number\n   of bytes in the original data and\
    \ a CRC of the original data.  This\n   should match the byte count and CRC found\
    \ during decompression.\n   This line has the format:\n                * <count>\
    \ <CRC>\n   where <count> is a decimal number, and CRC is 8 hexadecimal digits.\n\
    \   For example:\n                * 4128076 5AC2D50E\n   The count used in the\
    \ Encoding:  field in the message header is the\n   total number of lines, including\
    \ the start and end lines that begin\n   with *.  A complete example is given\
    \ in section 5.3.2.\n"
- title: 5.2  Specification of the LZJU90 compression
  contents:
  - "5.2  Specification of the LZJU90 compression\n   The Lempel-Ziv-Storer-Szymanski\
    \ model of mixing pointers and literal\n   characters is used in the compression\
    \ algorithm.  Repeat occurrences\n   of strings of octets are replaced by pointers\
    \ to the earlier\n   occurrence.\n   The data compression is defined by the decoding\
    \ algorithm.  Any\n   encoder that emits symbols which cause the decoder to produce\
    \ the\n   original input is defined to be valid.\n   There are many possible strategies\
    \ for the maximal-string matching\n   that the encoder does, section 5.3.1 gives\
    \ the code for one such\n   algorithm.  Regardless of which algorithm is used,\
    \ and what tradeoffs\n   are made between compression ratio and execution speed\
    \ or space, the\n   result can always be decoded by the simple decoder.\n   The\
    \ compressed data consists of a mixture of unencoded literal\n   characters and\
    \ copy pointers which point to an earlier occurrence of\n   the string to be encoded.\n\
    \   Compressed data contains two types of codewords:\n   LITERAL pass the literal\
    \ directly to the uncompressed output.\n   COPY    length, offset\n          \
    \ go back offset characters in the output and copy length\n           characters\
    \ forward to the current position.\n   To distinguish between codewords, the copy\
    \ length is used.  A copy\n   length of zero indicates that the following codeword\
    \ is a literal\n   codeword.  A copy length greater than zero indicates that the\n\
    \   following codeword is a copy codeword.\n   To improve copy length encoding,\
    \ a threshold value of 2 has been\n   subtracted from the original copy length\
    \ for copy codewords, because\n   the minimum copy length is 3 in this compression\
    \ scheme.\n   The maximum offset value is set at 32255.  Larger offsets offer\n\
    \   extremely low improvements in compression (less than 1 percent,\n   typically).\n\
    \   No special encoding is done on the LITERAL characters.  However,\n   unary\
    \ encoding is used for the copy length and copy offset values to\n   improve compression.\
    \  A start-step-stop unary code is used.\n   A (start, step, stop) unary code\
    \ of the integers is defined as\n   follows:  The Nth codeword has N ones followed\
    \ by a zero followed by\n   a field of size START + (N * STEP).  If the field\
    \ width is equal to\n   STOP then the preceding zero can be omitted.  The integers\
    \ are laid\n   out sequentially through these codewords.  For example, (0, 1,\
    \ 4)\n   would look like:\n             Codeword      Range\n             0  \
    \           0\n             10x           1-2\n             110xx         3-6\n\
    \             1110xxx       7-14\n             1111xxxx      15-30\n   Following\
    \ are the actual values used for copy length and copy offset:\n   The copy length\
    \ is encoded with a (0, 1, 7) code leading to a maximum\n   copy length of 256\
    \ by including the THRESHOLD value of 2.\n             Codeword       Range\n\
    \             0              0\n             10x            3-4\n            \
    \ 110xx          5-8\n             1110xxx        9-16\n             11110xxxx\
    \      17-32\n             111110xxxxx    33-64\n             1111110xxxxxx  65-128\n\
    \             1111111xxxxxxx 129-256\n   The copy offset is encoded with a (9,\
    \ 1, 14) code leading to a\n   maximum copy offset of 32255.  Offset 0 is reserved\
    \ as an end of\n   compressed data flag.\n             Codeword       Range\n\
    \             0xxxxxxxxx                0-511\n             10xxxxxxxxxx     \
    \       512-1535\n             110xxxxxxxxxxx         1536-3583\n            \
    \ 1110xxxxxxxxxxxx       3485-7679\n             11110xxxxxxxxxxxxx     7680-15871\n\
    \             11111xxxxxxxxxxxxxx   15872-32255\n   The 0 has been chosen to signal\
    \ the start of the field for ease of\n   encoding.  (The bit generator can simply\
    \ encode one more bit than is\n   significant in the binary representation of\
    \ the excess.)\n   The stop values are useful in the encoding to prevent out of\
    \ range\n   values for the lengths and offsets, as well as shortening some codes\n\
    \   by one bit.\n   The worst case compression using this scheme is a 1/8 increase\
    \ in\n   size of the encoded data.  (One zero bit followed by 8 character\n  \
    \ bits).  After the character encoding, the worst case ratio is 3/2 to\n   the\
    \ original data.\n   The minimum copy length of 3 has been chosen because the\
    \ worst case\n   copy length and offset is 3 bits (3) and 19 bits (32255) for\
    \ a total\n   of 22 bits to encode a 3 character string (24 bits).\n"
- title: 5.3  The Decoder
  contents:
  - "5.3  The Decoder\n   As mentioned previously, the compression is defined by the\
    \ decoder.\n   Any encoder that produced output that is correctly decoded is by\n\
    \   definition correct.\n   The following is an implementation of the decoder,\
    \ written more for\n   clarity and as much portability as possible, rather than\
    \ for maximum\n   speed.\n   When optimized for a specific environment, it will\
    \ run significantly\n   faster.\n    /* LZJU 90 Decoding program */\n    /* Written\
    \ By Robert Jung and Robert Ullmann, 1990 and 1991. */\n    /* This code is NOT\
    \ COPYRIGHT, not protected. It is in the true\n       Public Domain. */\n    #include\
    \ <stdio.h>\n    #include <string.h>\n    typedef unsigned char uchar;\n    typedef\
    \ unsigned int  uint;\n    #define N          32255\n    #define THRESHOLD   \
    \   3\n    #define STRTP          9\n    #define STEPP          1\n    #define\
    \ STOPP         14\n    #define STRTL          0\n    #define STEPL          1\n\
    \    #define STOPL          7\n    static FILE *in;\n    static FILE *out;\n \
    \   static int   getbuf;\n    static int   getlen;\n    static long  in_count;\n\
    \    static long  out_count;\n    static long  crc;\n    static long  crctable[256];\n\
    \    static uchar xxcodes[] =\n    \"+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n\
    \    abcdefghijklmnopqrstuvwxyz\";\n    static uchar ddcodes[256];\n    static\
    \ uchar text[N];\n    #define CRCPOLY         0xEDB88320\n    #define CRC_MASK\
    \        0xFFFFFFFF\n    #define UPDATE_CRC(crc, c)  \\\n            crc = crctable[((uchar)(crc)\
    \ ^ (uchar)(c)) & 0xFF] \\\n                  ^ (crc >> 8)\n    #define START_RECD\
    \      \"* LZJU90\"\n    void MakeCrctable()     /* Initialize CRC-32 table */\n\
    \    {\n    uint i, j;\n    long r;\n        for (i = 0; i <= 255; i++) {\n  \
    \          r = i;\n            for (j = 8; j > 0; j--) {\n                if (r\
    \ & 1)\n                    r = (r >> 1) ^ CRCPOLY;\n                else\n  \
    \                  r >>= 1;\n                }\n            crctable[i] = r;\n\
    \            }\n    }\n    int GetXX()             /* Get xxcode and translate\
    \ */\n    {\n    int c;\n        do {\n            if ((c = fgetc(in)) == EOF)\n\
    \                c = 0;\n            } while (c == '\\n');\n        in_count++;\n\
    \        return ddcodes[c];\n    }\n    int GetBit()            /* Get one bit\
    \ from input buffer */\n    {\n    int c;\n        while (getlen <= 0) {\n   \
    \         c = GetXX();\n            getbuf |= c << (10-getlen);\n            getlen\
    \ += 6;\n            }\n        c = (getbuf & 0x8000) != 0;\n        getbuf <<=\
    \ 1;\n        getbuf &= 0xFFFF;\n        getlen--;\n        return(c);\n    }\n\
    \    int GetBits(int len)        /* Get len bits */\n    {\n    int c;\n     \
    \   while (getlen <= 10) {\n            c = GetXX();\n            getbuf |= c\
    \ << (10-getlen);\n            getlen += 6;\n            }\n        if (getlen\
    \ < len) {\n            c = (uint)getbuf >> (16-len);\n            getbuf = GetXX();\n\
    \            c |= getbuf >> (6+getlen-len);\n            getbuf <<= (10+len-getlen);\n\
    \            getbuf &= 0xFFFF;\n            getlen -= len - 6;\n            }\n\
    \        else {\n            c = (uint)getbuf >> (16-len);\n            getbuf\
    \ <<= len;\n            getbuf &= 0xFFFF;\n            getlen -= len;\n      \
    \      }\n        return(c);\n    }\n    int DecodePosition()    /* Decode offset\
    \ position pointer */\n    {\n    int c;\n    int width;\n    int plus;\n    int\
    \ pwr;\n        plus = 0;\n        pwr = 1 << STRTP;\n        for (width = STRTP;\
    \ width < STOPP; width += STEPP) {\n            c = GetBit();\n            if\
    \ (c == 0)\n                break;\n            plus += pwr;\n            pwr\
    \ <<= 1;\n            }\n        if (width != 0)\n            c = GetBits(width);\n\
    \        c += plus;\n        return(c);\n    }\n    int DecodeLength()      /*\
    \ Decode code length */\n    {\n    int c;\n    int width;\n    int plus;\n  \
    \  int pwr;\n        plus = 0;\n        pwr = 1 << STRTL;\n        for (width\
    \ = STRTL; width < STOPL; width += STEPL) {\n            c = GetBit();\n     \
    \       if (c == 0)\n                break;\n            plus += pwr;\n      \
    \      pwr <<= 1;\n            }\n        if (width != 0)\n            c = GetBits(width);\n\
    \        c += plus;\n    return(c);\n    }\n    void InitCodes()        /* Initialize\
    \ decode table */\n    {\n    int i;\n        for (i = 0; i < 256; i++) ddcodes[i]\
    \ = 0;\n        for (i = 0; i < 64; i++) ddcodes[xxcodes[i]] = i;\n    return;\n\
    \    }\n    main(int ac, char **av)            /* main program */\n    {\n   \
    \ int r;\n    int j, k;\n    int c;\n    int pos;\n    char buf[80];\n    char\
    \ name[3];\n    long num, bytes;\n        if (ac < 3) {\n            fprintf(stderr,\
    \ \"usage: judecode in out\\n\");\n            return(1);\n            }\n   \
    \     in = fopen(av[1], \"r\");\n        if (!in){\n            fprintf(stderr,\
    \ \"Can't open %s\\n\", av[1]);\n            return(1);\n            }\n     \
    \   out = fopen(av[2], \"wb\");\n        if (!out) {\n            fprintf(stderr,\
    \ \"Can't open %s\\n\", av[2]);\n            fclose(in);\n        return(1);\n\
    \            }\n        while (1) {\n            if (fgets(buf, sizeof(buf), in)\
    \ == NULL) {\n                fprintf(stderr, \"Unexpected EOF\\n\");\n      \
    \      return(1);\n                }\n            if (strncmp(buf, START_RECD,\
    \ strlen(START_RECD)) == 0)\n                break;\n            }\n        in_count\
    \ = 0;\n        out_count = 0;\n        getbuf = 0;\n        getlen = 0;\n   \
    \     InitCodes();\n        MakeCrctable();\n        crc = CRC_MASK;\n       \
    \ r = 0;\n        while (feof(in) == 0) {\n            c = DecodeLength();\n \
    \           if (c == 0) {\n                c = GetBits(8);\n                UPDATE_CRC(crc,\
    \ c);\n                out_count++;\n                text[r] = c;\n          \
    \      fputc(c, out);\n                if (++r >= N)\n                    r =\
    \ 0;\n                }\n            else {\n                pos = DecodePosition();\n\
    \                if (pos == 0)\n                    break;\n                pos--;\n\
    \                j = c + THRESHOLD - 1;\n                pos = r - pos - 1;\n\
    \                if (pos < 0)\n                    pos += N;\n               \
    \ for (k = 0; k < j; k++) {\n                    c = text[pos];\n            \
    \        text[r] = c;\n                    UPDATE_CRC(crc, c);\n             \
    \       out_count++;\n                    fputc(c, out);\n                   \
    \ if (++r >= N)\n                        r = 0;\n                    if (++pos\
    \ >= N)\n                        pos = 0;\n                    }\n           \
    \     }\n            }\n        fgetc(in); /* skip newline */\n        if (fscanf(in,\
    \ \"* %ld %lX\", &bytes, &num) != 2) {\n            fprintf(stderr, \"CRC record\
    \ not found\\n\");\n            return(1);\n            }\n        else if (crc\
    \ != num) {\n            fprintf(stderr,\n                 \"CRC error, expected\
    \ %lX, found %lX\\n\",\n                 crc, num);\n            return(1);\n\
    \            }\n        else if (bytes != out_count) {\n            fprintf(stderr,\n\
    \                 \"File size error, expected %lu, found %lu\\n\",\n         \
    \        bytes, out_count);\n        return(1);\n            }\n        else\n\
    \            fprintf(stderr,\n                 \"File decoded to %lu bytes correctly\\\
    n\",\n                 out_count);\n        fclose(in);\n        fclose(out);\n\
    \    return(0);\n    }\n"
- title: 5.3.1  An example of an Encoder
  contents:
  - "5.3.1  An example of an Encoder\n   Many algorithms are possible for the encoder,\
    \ with different\n   tradeoffs between speed, size, and complexity.  The following\
    \ is a\n   simple example program which is fairly efficient; more sophisticated\n\
    \   implementations will run much faster, and in some cases produce\n   somewhat\
    \ better compression.\n   This example also shows that the encoder need not use\
    \ the entire\n   window available.  Not using the full window costs a small amount\
    \ of\n   compression, but can greatly increase the speed of some algorithms.\n\
    \    /* LZJU 90 Encoding program */\n    /* Written By Robert Jung and Robert\
    \ Ullmann, 1990 and 1991. */\n    /* This code is NOT COPYRIGHT, not protected.\
    \ It is in the true\n       Public Domain. */\n    #include <stdio.h>\n    typedef\
    \ unsigned char uchar;\n    typedef unsigned int  uint;\n    #define N       \
    \   24000    /* Size of window buffer */\n    #define F            256   /* Size\
    \ of look-ahead buffer */\n    #define THRESHOLD      3\n    #define K       \
    \   16384    /* Size of hash table */\n    #define STRTP          9\n    #define\
    \ STEPP          1\n    #define STOPP         14\n    #define STRTL          0\n\
    \    #define STEPL          1\n    #define STOPL          7\n    #define CHARSLINE\
    \     78\n    static FILE *in;\n    static FILE *out;\n    static int   putlen;\n\
    \    static int   putbuf;\n    static int   char_ct;\n    static long  in_count;\n\
    \    static long  out_count;\n    static long  crc;\n    static long  crctable[256];\n\
    \    static uchar xxcodes[] =\n    \"+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n\
    \    abcdefghijklmnopqrstuvwxyz\";\n    uchar window_text[N + F + 1];\n    /*\
    \ text contains window, plus 1st F of window again\n       (for comparisons) */\n\
    \    uint hash_table[K];\n    /* table of pointers into the text */\n    #define\
    \ CRCPOLY         0xEDB88320\n    #define CRC_MASK        0xFFFFFFFF\n    #define\
    \ UPDATE_CRC(crc, c)  \\\n      crc = crctable[((uchar)(crc) ^ (uchar)(c)) & 0xFF]\
    \ \\\n      ^ (crc >> 8)\n    void MakeCrctable()     /* Initialize CRC-32 table\
    \ */\n    {\n    uint i, j;\n    long r;\n        for (i = 0; i <= 255; i++) {\n\
    \            r = i;\n            for (j = 8; j > 0; j--) {\n                if\
    \ (r & 1)\n                    r = (r >> 1) ^ CRCPOLY;\n                else\n\
    \                    r >>= 1;\n            }\n            crctable[i] = r;\n \
    \       }\n    }\n    void PutXX(int c)           /* Translate and put xxcode\
    \ */\n    {\n        c = xxcodes[c & 0x3F];\n        if (++char_ct > CHARSLINE)\
    \ {\n            char_ct = 1;\n            fputc('\\n', out);\n        }\n   \
    \     fputc(c, out);\n        out_count++;\n    }\n    void PutBits(int c, int\
    \ len)  /* Put rightmost \"len\" bits of \"c\" */\n    {\n        c <<= 16 - len;\n\
    \        c &= 0xFFFF;\n        putbuf |= (uint) c >> putlen;\n        c <<= 16\
    \ - putlen;\n        c &= 0xFFFF;\n        putlen += len;\n        while (putlen\
    \ >= 6) {\n            PutXX(putbuf >> 10);\n            putlen -= 6;\n      \
    \      putbuf <<= 6;\n            putbuf &= 0xFFFF;\n            putbuf |= (uint)\
    \ c >> 10;\n            c = 0;\n            }\n    }\n    void EncodePosition(int\
    \ ch) /* Encode offset position pointer */\n    {\n    int width;\n    int prefix;\n\
    \    int pwr;\n        pwr = 1 << STRTP;\n        for (width = STRTP; ch >= pwr;\
    \ width += STEPP, pwr <<= 1)\n            ch -= pwr;\n        if ((prefix = width\
    \ - STRTP) != 0)\n            PutBits(0xffff, prefix);\n        if (width < STOPP)\n\
    \            width++;\n        /* else if (width > STOPP)\n        abort(); do\
    \ nothing */\n        PutBits(ch, width);\n    }\n    void EncodeLength(int ch)\
    \   /* Encode code length */\n    {\n    int width;\n    int prefix;\n    int\
    \ pwr;\n        pwr = 1 << STRTL;\n        for (width = STRTL; ch >= pwr; width\
    \ += STEPL, pwr <<= 1)\n            ch -= pwr;\n        if ((prefix = width -\
    \ STRTL) != 0)\n            PutBits(0xffff, prefix);\n        if (width < STOPL)\n\
    \            width++;\n        /* else if (width > STOPL)\n        abort(); do\
    \ nothing */\n        PutBits(ch, width);\n    }\n    main(int ac, char **av)\
    \            /* main program */\n    {\n    uint r, s, i, c;\n    uchar *p, *rp;\n\
    \    int match_position;\n    int match_length;\n    int len;\n    uint hash,\
    \ h;\n        if (ac < 3) {\n            fprintf(stderr, \"usage: juencode in\
    \ out\\n\");\n        return(1);\n            }\n        in = fopen(av[1], \"\
    rb\");\n        if (!in) {\n            fprintf(stderr, \"Can't open %s\\n\",\
    \ av[1]);\n        return(1);\n            }\n        out = fopen(av[2], \"w\"\
    );\n        if (!out) {\n            fprintf(stderr, \"Can't open %s\\n\", av[2]);\n\
    \            fclose(in);\n        return(1);\n            }\n        char_ct =\
    \ 0;\n        in_count = 0;\n        out_count = 0;\n        putbuf = 0;\n   \
    \     putlen = 0;\n        hash = 0;\n        MakeCrctable();\n        crc = CRC_MASK;\n\
    \        fprintf(out, \"* LZJU90 %s\\n\", av[1]);\n        /* The hash table inititialization\
    \ is somewhat arbitrary */\n        for (i = 0; i < K; i++) hash_table[i] = i\
    \ % N;\n        r = 0;\n        s = 0;\n        /* Fill lookahead buffer */\n\
    \        for (len = 0; len < F && (c = fgetc(in)) != EOF; len++) {\n         \
    \   UPDATE_CRC(crc, c);\n        in_count++;\n        window_text[s++] = c;\n\
    \        }\n        while (len > 0) {\n        /* look for match in window at\
    \ hash position */\n        h = ((((window_text[r] << 5) ^ window_text[r+1])\n\
    \                << 5) ^ window_text[r+2]);\n        p = window_text + hash_table[h\
    \ % K];\n        rp = window_text + r;\n        for (i = 0, match_length = 0;\
    \ i < F; i++) {\n                if (*p++ != *rp++) break;\n                match_length++;\n\
    \                }\n        match_position = r - hash_table[h % K];\n        if\
    \ (match_position <= 0) match_position += N;\n        if (match_position > N -\
    \ F - 2) match_length = 0;\n        if (match_position > in_count - len - 2)\n\
    \            match_length = 0; /* ! :-) */\n        if (match_length > len)\n\
    \            match_length = len;\n        if (match_length < THRESHOLD) {\n  \
    \          EncodeLength(0);\n            PutBits(window_text[r], 8);\n       \
    \     match_length = 1;\n            }\n        else {\n            EncodeLength(match_length\
    \ - THRESHOLD + 1);\n            EncodePosition(match_position);\n           \
    \ }\n        for (i = 0; i < match_length &&\n                        (c = fgetc(in))\
    \ != EOF; i++) {\n                UPDATE_CRC(crc, c);\n                in_count++;\n\
    \            window_text[s] = c;\n                if (s < F - 1)\n           \
    \     window_text\n                [s + N] = c;\n            if (++s > N - 1)\
    \ s = 0;\n            hash = ((hash << 5) ^ window_text[r]);\n            if (r\
    \ > 1) hash_table[hash % K] = r - 2;\n            if (++r > N - 1) r = 0;\n  \
    \          }\n        while (i++ < match_length) {\n            if (++s > N -\
    \ 1) s = 0;\n            hash = ((hash << 5) ^ window_text[r]);\n            if\
    \ (r > 1) hash_table[hash % K] = r - 2;\n            if (++r > N - 1 ) r = 0;\n\
    \            len--;\n                }\n        }\n        /* end compression\
    \ indicator */\n        EncodeLength(1);\n        EncodePosition(0);\n       \
    \ PutBits(0, 7);\n        fprintf(out, \"\\n* %lu %08lX\\n\", in_count, crc);\n\
    \        fprintf(stderr, \"Encoded %lu bytes to %lu symbols\\n\",\n          \
    \      in_count, out_count);\n        fclose(in);\n        fclose(out);\n    return(0);\n\
    \    }\n"
- title: 5.3.2  Example LZJU90 Compressed Object
  contents:
  - "5.3.2  Example LZJU90 Compressed Object\n   The following is an example of an\
    \ LZJU90 compressed object.  Using\n   this as source for the program in section\
    \ 5.3 will reveal what it is.\n      Encoding: 7 LZJU90 Text\n      * LZJU90 example\n\
    \      8-mBtWA7WBVZ3dEBtnCNdU2WkE4owW+l4kkaApW+o4Ir0k33Ao4IE4kk\n      bYtk1XY618NnCQl+OHQ61d+J8FZBVVCVdClZ2-LUI0v+I4EraItasHbG\n\
    \      VVg7c8tdk2lCBtr3U86FZANVCdnAcUCNcAcbCMUCdicx0+u4wEETHcRM\n      7tZ2-6Btr268-Eh3cUAlmBth2-IUo3As42laIE2Ao4Yq4G-cHHT-wCEU\n\
    \      6tjBtnAci-I++\n      * 190 081E2601\n"
- title: 6.  Alphabetical Listing of Defined Encodings
  contents:
  - "6.  Alphabetical Listing of Defined Encodings\n        Keyword         Description\
    \             Section  Reference(s)\n        _______         ___________     \
    \        _______  ____________\n        EDIFACT         EDIFACT format       \
    \   3.5\n        EDI-X12         EDI X12 format          3.5      ANSI X12\n \
    \       EVFU            FORTRAN format          3.4\n        FS              File\
    \ System format      3.6, 4\n        Hex             Hex binary format       3.3\n\
    \        LZJU90          LZJU90 format           3.7, 5\n        LZW         \
    \    LZW format              3.8\n        Message         Encapsulated Message\
    \    3.2      STD 11, RFC 822\n        PEM, PEM-Clear  Privacy Enhanced Mail \
    \  3.10     RFC 1421-1424\n        PGP             Pretty Good Privacy     3.11\n\
    \        Postscript      Postscript format       3.14     [8]\n        Shar  \
    \          Shell Archive format    3.15\n        Signature       Signature   \
    \            3.12\n        Tar             Tar format              3.13\n    \
    \    Text            Text                    3.1      IS 10646\n        uuencode\
    \        uuencode format         3.9\n        URL             external URL-reference\
    \  3.16\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Security of content and the receiving (decoding)\
    \ system is discussed\n   in sections 3.10, 3.11, 3.15, and 4.2.10.  The considerations\n\
    \   mentioned also apply to other encodings and attributes with similar\n   functions.\n"
- title: 8.  References
  contents:
  - "8.  References\n   [1] Robinson, D. and R. Ullmann, \"Encoding Header Field for\
    \ Internet\n       Messages\", RFC 1154, Prime Computer, Inc., April 1990.\n \
    \  [2] Crocker, D., \"Standard for the Format of ARPA Internet Text\n       Messages\"\
    , STD 11, RFC 822, University of Delaware, August 1982.\n   [3] International\
    \ Organization for Standardization, Information\n       Technology -- Universal\
    \ Coded Character Set (UCS).  ISO/IEC\n       10646-1:1993, June 1993.\n   [4]\
    \ Linn, J., \"Privacy Enhancement for Internet Electronic Mail: Part\n       I:\
    \ Message Encryption and Authentication Procedures\" RFC 1421,\n       IAB IRTF\
    \ PSRG, IETF PEM WG, February 1993.\n   [5] Kent, S., \"Privacy Enhancement for\
    \ Internet Electronic Mail: Part\n       II: Certificate-Based Key Management\"\
    , RFC 1422, IAB IRTF PSRG,\n       IETF PEM, BBN, February 1993.\n   [6] Balenson,\
    \ D., \"Privacy Enhancement for Internet Electronic Mail:\n       Part III: Algorithms,\
    \ Modes, and Identifiers\", RFC 1423, IAB IRTF\n       PSRG, IETF PEM WG, TIS,\
    \ February 1993.\n   [7] Kaliski, B., \"Privacy Enhancement for Internet Electronic\
    \ Mail:\n       Part IV: Key Certification and Related Services\", RFC 1424, RSR\n\
    \       Laboratories, February 1993.\n   [8] Adobe Systems Inc., PostScript Language\
    \ Reference Manual.  2nd\n       Edition, 2nd Printing, January 1991.\n   [9]\
    \ Rose, M. and E. Steffererud, \"Proposed Standard for Message\n       Encapsulation\"\
    , RFC 934, Delaware and NMA, January 1985.\n  [10] Postel, J., \"Simple Mail Transfer\
    \ Protocol\", STD 10, RFC 821,\n       USC/Information Sciences Institute, August\
    \ 1982.\n  [11] Borenstein, N., and N. Freed, \"MIME (Multipurpose Internet Mail\n\
    \       Extensions): Mechanisms for Specifying and Describing the Format\n   \
    \    of Internet Message Bodies\", RFC 1341, Bellcore, Innosoft, June\n      \
    \ 1992.\n  [12] Borenstein, N., and M. Linimon, \"Extension of MIME Content-Types\n\
    \       to a New Medium\", RFC 1437, 1 April 1993.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   The authors would like to thank Robert Jung for his\
    \ contributions to\n   this work, in particular the public domain sample code\
    \ for LZJU90.\n"
- title: 10.  Authors' Addresses
  contents:
  - "10.  Authors' Addresses\n   Albert K. Costanzo\n   AKC Consulting Inc.\n   P.O.\
    \ Box 4031\n   Roselle Park, NJ  07204-0531\n   Phone: +1 908 298 9000\n   Email:\
    \ AL@AKC.COM\n   David Robinson\n   Computervision Corporation\n   100 Crosby\
    \ Drive\n   Bedford, MA  01730\n   Phone: +1 617 275 1800 x2774\n   Email: DRB@Relay.CV.COM\n\
    \   Robert Ullmann\n   Phone: +1 617 247 7959\n   Email: ariel@world.std.com\n"
