- title: __initial_text__
  contents:
  - "            6LoWPAN-GHC: Generic Header Compression for IPv6\n       over Low-Power\
    \ Wireless Personal Area Networks (6LoWPANs)\n"
- title: Abstract
  contents:
  - "Abstract\n   RFC 6282 defines header compression in 6LoWPAN packets (where\n\
    \   \"6LoWPAN\" refers to \"IPv6 over Low-Power Wireless Personal Area\n   Network\"\
    ).  The present document specifies a simple addition that\n   enables the compression\
    \ of generic headers and header-like payloads,\n   without a need to define a\
    \ new header compression scheme for each\n   such new header or header-like payload.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7400.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \      1.1. The Header Compression Coupling Problem ....................2\n  \
    \    1.2. Compression Approach .......................................3\n    \
    \  1.3. Terminology ................................................3\n      1.4.\
    \ Notation ...................................................4\n   2. 6LoWPAN-GHC\
    \ .....................................................4\n   3. Integrating 6LoWPAN-GHC\
    \ into 6LoWPAN-HC .........................6\n      3.1. Compressing Payloads\
    \ (UDP and ICMPv6) ......................6\n      3.2. Compressing Extension Headers\
    \ ..............................6\n      3.3. Indicating GHC Capability ..................................7\n\
    \      3.4. Using the 6CIO .............................................8\n  \
    \ 4. IANA Considerations .............................................9\n   5.\
    \ Security Considerations ........................................10\n   6. References\
    \ .....................................................11\n      6.1. Normative\
    \ References ......................................11\n      6.2. Informative\
    \ References ....................................12\n   Appendix A. Examples ..............................................14\n\
    \   Acknowledgements ..................................................24\n  \
    \ Author's Address ..................................................24\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  The Header Compression Coupling Problem
  contents:
  - "1.1.  The Header Compression Coupling Problem\n   [RFC6282] defines a scheme\
    \ for header compression in 6LoWPAN\n   [RFC4944] packets; in this document, we\
    \ refer to that scheme as\n   6LoWPAN Header Compression, or 6LoWPAN-HC (where\
    \ \"6LoWPAN\" refers to\n   \"IPv6 over Low-Power Wireless Personal Area Network\"\
    ).  As with most\n   header compression schemes, a new specification is necessary\
    \ for\n   every new kind of header that needs to be compressed.  In addition,\n\
    \   [RFC6282] does not define an extensibility scheme like the Robust\n   Header\
    \ Compression (ROHC) profiles defined in ROHC [RFC3095]\n   [RFC5795].  This leads\
    \ to the difficult situation in which 6LoWPAN-HC\n   tended to be reopened and\
    \ reexamined each time a new header receives\n   consideration (or an old header\
    \ is changed and reconsidered) in the\n   6LoWPAN/roll/CoRE cluster of IETF working\
    \ groups.  Although [RFC6282]\n   was finally completed and published, the underlying\
    \ problem remains\n   unsolved.\n   The purpose of the present contribution is\
    \ to plug into [RFC6282] as\n   is, using its Next Header Compression (NHC) concept.\
    \  We add a\n   slightly less efficient, but vastly more general, form of compression\n\
    \   for headers of any kind and even for header-like payloads such as\n   those\
    \ exhibited by routing protocols, DHCP, etc.: Generic Header\n   Compression (GHC).\
    \  The objective is an extremely simple\n   specification that can be defined\
    \ on a single page and implemented in\n   a small number of lines of code, as\
    \ opposed to a general data\n   compression scheme such as that defined in [RFC1951].\n"
- title: 1.2.  Compression Approach
  contents:
  - "1.2.  Compression Approach\n   The basic approach of GHC's compression function\
    \ is to define a\n   bytecode for LZ77-style compression [LZ77].  The bytecode\
    \ is a series\n   of simple instructions for the decompressor to reconstitute\
    \ the\n   uncompressed payload.  These instructions include:\n   o  appending\
    \ bytes to the reconstituted payload that are literally\n      given with the\
    \ instruction in the compressed data\n   o  appending a given number of zero bytes\
    \ to the reconstituted\n      payload\n   o  appending bytes to the reconstituted\
    \ payload by copying a\n      contiguous sequence from the payload being reconstituted\n\
    \      (\"backreferencing\")\n   o  an ancillary instruction for setting up parameters\
    \ for the\n      backreferencing instruction in \"decompression variables\"\n\
    \   o  a stop code (optional; see Section 3.2)\n   The buffer for the reconstituted\
    \ payload (\"destination buffer\") is\n   prefixed by a predefined dictionary\
    \ that can be used in the\n   backreferencing as if it were a prefix of the payload.\
    \  This\n   predefined dictionary is built from the IPv6 addresses of the packet\n\
    \   being reconstituted, followed by a static component, the \"static\n   dictionary\"\
    .\n   As usual, this specification defines the decompressor operation in\n   detail\
    \ but leaves the detailed operation of the compressor open to\n   implementation.\
    \  The compressor can be implemented as with a\n   classical LZ77 compressor,\
    \ or it can be a simple protocol encoder\n   that just makes use of known compression\
    \ opportunities.\n"
- title: 1.3.  Terminology
  contents:
  - "1.3.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT\
    \ RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   RFC 2119 [RFC2119].\n   The term \"byte\" is used in its\
    \ now-customary sense as a synonym for\n   \"octet\".\n   Terms from [RFC7228]\
    \ are used in Section 5.\n"
- title: 1.4.  Notation
  contents:
  - "1.4.  Notation\n   This specification uses a trivial notation for code bytes\
    \ and the\n   bitfields in them, the meaning of which should be mostly obvious.\n\
    \   More formally, the meaning of the notation is as follows:\n   Potential values\
    \ for the code bytes themselves are expressed by\n   templates that represent\
    \ 8-bit most-significant-bit-first binary\n   numbers (without any special prefix),\
    \ where 0 stands for 0, 1 for 1,\n   and variable segments in these code byte\
    \ templates are indicated by\n   sequences of the same letter, such as kkkkkkk\
    \ or ssss, the length of\n   which indicates the length of the variable segment\
    \ in bits.\n   In the notation of values derived from the code bytes, 0b is used\
    \ as\n   a prefix for expressing binary numbers in most-significant-bit-first\n\
    \   notation (akin to the use of 0x for most-significant-digit-first\n   hexadecimal\
    \ numbers in the C programming language).  Where the above-\n   mentioned sequences\
    \ of letters are then referenced in such a binary\n   number in the text, the\
    \ intention is that the value from these\n   bitfields in the actual code byte\
    \ be inserted.\n   Example: The code byte template\n      101nssss\n   stands\
    \ for a byte that starts (most-significant-bit-first) with the\n   bits 1, 0,\
    \ and 1, and continues with five variable bits, the first of\n   which is referenced\
    \ as \"n\" and the next four of which are referenced\n   as \"ssss\".  Based on\
    \ this code byte template, a reference to\n      0b0ssss000\n   means a binary\
    \ number composed from a zero bit; the four bits that\n   are in the \"ssss\"\
    \ field (for 101nssss, the four least significant\n   bits) in the actual byte\
    \ encountered, kept in the same order; and\n   three more zero bits.\n"
- title: 2.  6LoWPAN-GHC
  contents:
  - "2.  6LoWPAN-GHC\n   The format of a GHC-compressed header or payload is a simple\n\
    \   bytecode.  A compressed header consists of a sequence of pieces, each\n  \
    \ of which begins with a code byte, which may be followed by zero or\n   more\
    \ bytes as its argument.  Some code bytes cause bytes to be laid\n   out in the\
    \ destination buffer, and some simply modify some\n   decompression variables.\n\
    \   At the start of decompressing a header or payload within an L2 packet\n  \
    \ (= fragment), the decompression variables \"sa\" and \"na\" are\n   initialized\
    \ as zero.\n   The code bytes are defined as follows (Table 1):\n   +----------+---------------------------------------------+----------+\n\
    \   | code     | Action                                      | Argument |\n  \
    \ | byte     |                                             |          |\n   +----------+---------------------------------------------+----------+\n\
    \   | 0kkkkkkk | Append k = 0b0kkkkkkk bytes of data in the  | k bytes  |\n  \
    \ |          | bytecode argument (k < 96)                  | of data  |\n   |\
    \          |                                             |          |\n   | 1000nnnn\
    \ | Append 0b0000nnnn+2 bytes of zeroes         |          |\n   |          |\
    \                                             |          |\n   | 10010000 | stop\
    \ code (end of compressed data; see      |          |\n   |          | Section\
    \ 3.2)                                |          |\n   |          |          \
    \                                   |          |\n   | 101nssss | Set up extended\
    \ arguments for a             |          |\n   |          | backreference: sa\
    \ += 0b0ssss000,            |          |\n   |          | na += 0b0000n000   \
    \                         |          |\n   |          |                      \
    \                       |          |\n   | 11nnnkkk | Backreference: n = na+0b00000nnn+2;\
    \         |          |\n   |          | s = 0b00000kkk+sa+n; append n bytes from\
    \    |          |\n   |          | previously output bytes, starting s bytes \
    \  |          |\n   |          | to the left of the current output pointer;  |\
    \          |\n   |          | set sa = 0, na = 0                          |  \
    \        |\n   +----------+---------------------------------------------+----------+\n\
    \             Table 1: Bytecodes for Generic Header Compression\n   Note that\
    \ the following bit combinations are reserved at this time:\n   o  011xxxxx\n\
    \   o  1001nnnn (where 0b0000nnnn > 0)\n   For the purposes of the backreferences,\
    \ the expansion buffer is\n   initialized with a predefined dictionary, at the\
    \ end of which the\n   reconstituted payload begins.  This dictionary is composed\
    \ of the\n   source and destination IPv6 addresses of the packet being\n   reconstituted,\
    \ followed by a 16-byte static dictionary (Figure 1).\n   These 48 dictionary\
    \ bytes are therefore available for backreferencing\n   but not copied into the\
    \ final reconstituted payload.\n             16 fe fd 17 fe fd 00 01 00 00 00\
    \ 00 00 01 00 00\n           Figure 1: The 16 Bytes of Static Dictionary (in Hex)\n"
- title: 3.  Integrating 6LoWPAN-GHC into 6LoWPAN-HC
  contents:
  - "3.  Integrating 6LoWPAN-GHC into 6LoWPAN-HC\n   6LoWPAN-GHC plugs in as an NHC\
    \ format for 6LoWPAN-HC [RFC6282].\n"
- title: 3.1.  Compressing Payloads (UDP and ICMPv6)
  contents:
  - "3.1.  Compressing Payloads (UDP and ICMPv6)\n   By definition, GHC is generic\
    \ and can be applied to different kinds\n   of packets.  Many of the examples\
    \ given in Appendix A are for ICMPv6\n   packets; a single NHC value suffices\
    \ to define an NHC format for\n   ICMPv6 based on GHC (see below).\n   In addition,\
    \ it is useful to include an NHC format for UDP, as many\n   header-like payloads\
    \ (e.g., DHCPv6, Datagram Transport Layer Security\n   (DTLS)) are carried in\
    \ UDP.  [RFC6282] already defines an NHC format\n   for UDP (11110CPP).  GHC uses\
    \ an analogous NHC byte formatted as\n   shown in Figure 2.  The difference to\
    \ the existing UDP NHC\n   specification is that for 11010CPP NHC bytes, the UDP\
    \ payload is not\n   supplied literally but compressed by 6LoWPAN-GHC.\n     \
    \                  0   1   2   3   4   5   6   7\n                     +---+---+---+---+---+---+---+---+\n\
    \                     | 1 | 1 | 0 | 1 | 0 | C |   P   |\n                    \
    \ +---+---+---+---+---+---+---+---+\n                 Figure 2: NHC Byte for UDP\
    \ GHC (11010CPP)\n   To stay in the same general numbering space, we use 11011111\
    \ as the\n   NHC byte for ICMPv6 GHC (Figure 3).\n                       0   1\
    \   2   3   4   5   6   7\n                     +---+---+---+---+---+---+---+---+\n\
    \                     | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 |\n                    \
    \ +---+---+---+---+---+---+---+---+\n               Figure 3: NHC Byte for ICMPv6\
    \ GHC (11011111)\n"
- title: 3.2.  Compressing Extension Headers
  contents:
  - "3.2.  Compressing Extension Headers\n   Compression of specific extension headers\
    \ is added in a similar way\n   (Figure 4) (however, probably only Extension Header\
    \ ID (EID) 0 to 3\n   [RFC6282] need to be assigned).  As there is no easy way\
    \ to extract\n   the Length field from the GHC-encoded header before decoding,\
    \ this\n   would make detecting the end of the extension header somewhat\n   complex.\
    \  The easiest (and most efficient) approach is to completely\n   elide the Length\
    \ field (in the same way NHC already elides the Next\n   Header field in certain\
    \ cases) and reconstruct it only on\n   decompression.  To serve as a terminator\
    \ for the extension header,\n   the bytecode 0b10010000 has been assigned as a\
    \ stop code.  Note that\n   the stop code is only needed for extension headers,\
    \ not for the final\n   payloads discussed in the previous subsection, the decompression\
    \ of\n   which is automatically stopped by the end of the packet.\n          \
    \             0   1   2   3   4   5   6   7\n                     +---+---+---+---+---+---+---+---+\n\
    \                     | 1 | 0 | 1 | 1 |    EID    |NH |\n                    \
    \ +---+---+---+---+---+---+---+---+\n                Figure 4: NHC Byte for Extension\
    \ Header GHC\n"
- title: 3.3.  Indicating GHC Capability
  contents:
  - "3.3.  Indicating GHC Capability\n   The 6LoWPAN baseline includes just [RFC4944],\
    \ [RFC6282], and\n   [RFC6775] (see [Roadmap-6LoWPAN]).  To enable the use of\
    \ GHC towards\n   a neighbor, a 6LoWPAN node needs to know that the neighbor implements\n\
    \   it.  While this can also simply be administratively required, a\n   transition\
    \ strategy as well as a way to support mixed networks is\n   required.\n   One\
    \ way to know that a neighbor does implement GHC is receiving a\n   packet from\
    \ that neighbor with GHC in it (\"implicit capability\n   detection\").  However,\
    \ there needs to be a way to bootstrap this, as\n   nobody would ever start sending\
    \ packets with GHC otherwise.\n   To minimize the impact on [RFC6775], we define\
    \ a Neighbor Discovery\n   (ND) option called the 6LoWPAN Capability Indication\
    \ Option (6CIO),\n   as illustrated in Figure 5.  (For the fields marked by an\
    \ underscore\n   in Figure 5, see Section 3.4.)\n      0                   1 \
    \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |     Type      |   Length = 1  |_____________________________|G|\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |_______________________________________________________________|\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \       Figure 5: 6LoWPAN Capability Indication Option (6CIO)\n   The G bit indicates\
    \ whether the node sending the option is GHC\n   capable.\n   Once a node receives\
    \ either an explicit or implicit indication of GHC\n   capability from another\
    \ node, it may send GHC-compressed packets to\n   that node.  Where that capability\
    \ has not been recently confirmed,\n   similar to the way Packetization Layer\
    \ Path MTU Discovery (PLPMTUD)\n   [RFC4821] finds out about changes in the network,\
    \ a node SHOULD make\n   use of Neighbor Unreachability Detection (NUD) failures\
    \ to switch\n   back to basic 6LoWPAN header compression [RFC6282].\n"
- title: 3.4.  Using the 6CIO
  contents:
  - "3.4.  Using the 6CIO\n   The 6CIO will typically only be sent in 6LoWPAN-ND Router\n\
    \   Solicitation (RS) packets (which cannot themselves be GHC compressed\n   unless\
    \ the host desires to limit itself to talking to GHC-capable\n   routers).  The\
    \ resulting 6LoWPAN-ND Router Advertisement (RA) can\n   then already make use\
    \ of GHC and thus indicate GHC capability\n   implicitly, which in turn allows\
    \ both nodes to use GHC in the\n   6LoWPAN-ND Neighbor Solicitation / Neighbor\
    \ Advertisement (NS/NA)\n   exchange.\n   The 6CIO can also be used for future\
    \ options that need to be\n   negotiated between 6LoWPAN peers; an IANA registry\
    \ is used to assign\n   the flags.  Bits marked by underscores in Figure 5 are\
    \ unassigned and\n   available for future assignment.  They MUST be sent as zero\
    \ and MUST\n   be ignored on reception until assigned by IANA.  Length values\
    \ larger\n   than 1 MUST be accepted by implementations in order to enable future\n\
    \   extensions; the additional bits in the option are then deemed\n   unassigned\
    \ in the same way.  For the purposes of the IANA registry,\n   the bits are numbered\
    \ in most-significant-bit-first order from the\n   16th bit of the option onward:\
    \ the 16th bit is flag number 0, the\n   31st bit (the G bit) is flag number 15,\
    \ up to the 63rd bit for flag\n   number 47.  (Additional bits may also be used\
    \ by a follow-on version\n   of this document if some bit combinations that have\
    \ been left\n   unassigned here are then used in an upward-compatible manner.)\n\
    \   Flag numbers 0 to 7 are reserved for experimental use.  They MUST NOT\n  \
    \ be used for actual deployments.\n   Where the use of this option by other specifications\
    \ or for\n   experimental use is envisioned, the following items have to be kept\n\
    \   in mind:\n   o  The option can be used in any ND packet.\n   o  Specific bits\
    \ are set in the option to indicate that a capability\n      is present in the\
    \ sender.  (There may be other ways to infer this\n      information, as is the\
    \ case in this specification.)  Bit\n      combinations may be used as desired.\
    \  The absence of the\n      capability _indication_ is signaled by setting these\
    \ bits to zero;\n      this does not necessarily mean that the capability is absent.\n\
    \   o  The intention is not to modify the semantics of the specific ND\n     \
    \ packet carrying the option but to provide the general capability\n      indication\
    \ described above.\n   o  Specifications have to be designed such that receivers\
    \ that do not\n      receive or do not process such a capability indication can\
    \ still\n      interoperate (presumably without exploiting the indicated\n   \
    \   capability).\n   o  The option is meant to be used sparsely, i.e., once a\
    \ sender has\n      reason to believe the capability indication has been received,\n\
    \      there is no longer a need to continue sending it.\n"
- title: 4.  IANA Considerations
  contents:
  - "4.  IANA Considerations\n   IANA has added the assignments listed in Figure 6\
    \ in the \"LOWPAN_NHC\n   Header Type\" registry (under \"IPv6 Low Power Personal\
    \ Area Network\n   Parameters\").\n           10110EEN: Extension header GHC \
    \             [RFC7400]\n           11010CPP: UDP GHC                        \
    \   [RFC7400]\n           11011111: ICMPv6 GHC                        [RFC7400]\n\
    \                Figure 6: IANA Assignments for the NHC Byte\n   IANA has allocated\
    \ ND option number 36 for the \"6LoWPAN Capability\n   Indication Option (6CIO)\"\
    \ ND option format in the \"IPv6 Neighbor\n   Discovery Option Formats\" registry\
    \ [RFC4861].\n   IANA has created a subregistry for \"6LoWPAN capability Bits\"\
    \ under\n   the \"Internet Control Message Protocol version 6 (ICMPv6) Parameters\"\
    \n   registry.  The bits are assigned by giving their numbers as small,\n   non-negative\
    \ integers as defined in Section 3.4, in the range 0-47.\n   The policy is \"\
    IETF Review\" or \"IESG Approval\" [RFC5226].  The\n   initial content of the\
    \ registry is as shown in Figure 7:\n            0-7: Reserved for Experimental\
    \ Use         [RFC7400]\n           8-14: Unassigned\n             15: GHC capable\
    \ bit (G bit)               [RFC7400]\n          16-47: Unassigned\n        Figure\
    \ 7: IANA Assignments for the 6LoWPAN Capability Bits\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   The security considerations of [RFC4944] and\
    \ [RFC6282] apply.  As\n   usual in protocols with packet parsing/construction,\
    \ care must be\n   taken in implementations to avoid buffer overflows and, in\
    \ particular\n   (with respect to the backreferencing), out-of-area references\
    \ during\n   decompression.\n   One additional consideration is that an attacker\
    \ may send a forged\n   packet that makes a second node believe a third victim\
    \ node is GHC\n   capable.  If it is not, this may prevent packets sent by the\
    \ second\n   node from reaching the third node (at least until robustness features\n\
    \   such as those discussed in Section 3.3 kick in).\n   No mitigation is proposed\
    \ (or known) for this attack, except that a\n   victim node that does implement\
    \ GHC is not vulnerable.  However, with\n   unsecured ND, a number of attacks\
    \ with similar outcomes are already\n   possible, so there is little incentive\
    \ to make use of this additional\n   attack.  With secured ND, the 6CIO is also\
    \ secured; nodes relying on\n   secured ND therefore should use the 6CIO bidirectionally\
    \ (and limit\n   the implicit capability detection to secured ND packets carrying\
    \ GHC)\n   instead of basing their neighbor capability assumptions on receiving\n\
    \   any kind of unprotected packet.\n   As with any LZ77 scheme, decompression\
    \ bombs (compressed packets\n   crafted to expand so much that the decompressor\
    \ is overloaded) are a\n   problem.  An attacker cannot send a GHC decompressor\
    \ into a tight\n   loop for too long, because the MTU will be reached quickly.\
    \  Some\n   amplification of an attack from inside the compressed link is\n  \
    \ possible, though.  Using a constrained node in a constrained network\n   as\
    \ a DoS attack source is usually not very useful, though, except\n   maybe against\
    \ other nodes in that constrained network.  The worst\n   case for an attack to\
    \ the outside is a not-so-constrained device\n   using a (typically not-so-constrained)\
    \ edge router to attack by\n   forwarding out of its Ethernet interface.  The\
    \ worst-case\n   amplification of GHC is 17, so an MTU-size packet can be generated\n\
    \   from a 6LoWPAN packet of 76 bytes.  The 6LoWPAN network is still\n   constrained,\
    \ so the amplification at the edge router turns an entire\n   250 kbit/s 802.15.4\
    \ network (assuming a theoretical upper bound of\n   225 kbit/s throughput to\
    \ a single-hop adjacent node) into a\n   3.8 Mbit/s attacker.\n   The amplification\
    \ may be more important inside the 6LoWPAN, if there\n   is a way to obtain reflection\
    \ (otherwise, the packet is likely to\n   simply stay compressed on the way and\
    \ do little damage), e.g., by\n   pinging a node using a decompression bomb, somehow\
    \ keeping that node\n   from re-compressing the ping response (which would probably\
    \ require\n   something more complex than simple runs of zeroes, so the worst-case\n\
    \   amplification is likely closer to 9).  Or, if there are nodes that do\n  \
    \ not support GHC, those can be attacked via a router that is then\n   forced\
    \ to decompress.\n   All these attacks are mitigated by some form of network access\n\
    \   control.\n   In a 6LoWPAN stack, sensitive information will normally be protected\n\
    \   by transport- or application-layer (or even IP-layer) security, which\n  \
    \ are all above the adaptation layer, leaving no sensitive information\n   to\
    \ compress at the GHC level.  However, a 6LoWPAN deployment that\n   entirely\
    \ depends on Media Access Control (MAC) layer security may be\n   vulnerable to\
    \ attacks that exploit redundancy information disclosed\n   by compression to\
    \ recover information about secret values.  The\n   attacker would need to be\
    \ in radio range to observe the compressed\n   packets.  Since compression is\
    \ stateless, the attacker would need to\n   entice the party sending the secret\
    \ value to also send some value\n   controlled (or at least usefully varying and\
    \ knowable) by the\n   attacker in (what becomes the first adaptation-layer fragment\
    \ of) the\n   same packet.  This attack is fully mitigated by not exposing secret\n\
    \   values to the adaptation layer or by not using GHC in deployments\n   where\
    \ this is done.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC4861]\
    \  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,\n              \"Neighbor\
    \ Discovery for IP version 6 (IPv6)\", RFC 4861,\n              September 2007,\
    \ <http://www.rfc-editor.org/info/rfc4861>.\n   [RFC4944]  Montenegro, G., Kushalnagar,\
    \ N., Hui, J., and D. Culler,\n              \"Transmission of IPv6 Packets over\
    \ IEEE 802.15.4\n              Networks\", RFC 4944, September 2007,\n       \
    \       <http://www.rfc-editor.org/info/rfc4944>.\n   [RFC5226]  Narten, T. and\
    \ H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC 5226,\n              May 2008, <http://www.rfc-editor.org/info/rfc5226>.\n\
    \   [RFC6282]  Hui, J. and P. Thubert, \"Compression Format for IPv6\n       \
    \       Datagrams over IEEE 802.15.4-Based Networks\", RFC 6282,\n           \
    \   September 2011, <http://www.rfc-editor.org/info/rfc6282>.\n   [RFC6775]  Shelby,\
    \ Z., Chakrabarti, S., Nordmark, E., and C. Bormann,\n              \"Neighbor\
    \ Discovery Optimization for IPv6 over Low-Power\n              Wireless Personal\
    \ Area Networks (6LoWPANs)\", RFC 6775,\n              November 2012, <http://www.rfc-editor.org/info/rfc6775>.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [ICMPv6-ND]\n              O'Flynn, C., \"ICMPv6/ND\
    \ Compression for 6LoWPAN Networks\",\n              Work in Progress, draft-oflynn-6lowpan-icmphc-00,\n\
    \              July 2010.\n   [LZ77]     Ziv, J. and A. Lempel, \"A Universal\
    \ Algorithm for\n              Sequential Data Compression\", IEEE Transactions\
    \ on\n              Information Theory, Vol. 23, No. 3, pp. 337-343, May 1977.\n\
    \   [RFC1951]  Deutsch, P., \"DEFLATE Compressed Data Format Specification\n \
    \             version 1.3\", RFC 1951, May 1996,\n              <http://www.rfc-editor.org/info/rfc1951>.\n\
    \   [RFC3095]  Bormann, C., Burmeister, C., Degermark, M., Fukushima, H.,\n  \
    \            Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le,\n       \
    \       K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K.,\n            \
    \  Wiebke, T., Yoshimura, T., and H. Zheng, \"RObust Header\n              Compression\
    \ (ROHC): Framework and four profiles: RTP, UDP,\n              ESP, and uncompressed\"\
    , RFC 3095, July 2001,\n              <http://www.rfc-editor.org/info/rfc3095>.\n\
    \   [RFC4821]  Mathis, M. and J. Heffner, \"Packetization Layer Path MTU\n   \
    \           Discovery\", RFC 4821, March 2007,\n              <http://www.rfc-editor.org/info/rfc4821>.\n\
    \   [RFC5795]  Sandlund, K., Pelletier, G., and L-E. Jonsson, \"The RObust\n \
    \             Header Compression (ROHC) Framework\", RFC 5795,\n             \
    \ March 2010, <http://www.rfc-editor.org/info/rfc5795>.\n   [RFC6550]  Winter,\
    \ T., Thubert, P., Brandt, A., Hui, J., Kelsey, R.,\n              Levis, P.,\
    \ Pister, K., Struik, R., Vasseur, JP., and R.\n              Alexander, \"RPL:\
    \ IPv6 Routing Protocol for Low-Power and\n              Lossy Networks\", RFC\
    \ 6550, March 2012,\n              <http://www.rfc-editor.org/info/rfc6550>.\n\
    \   [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, \"Terminology for\n   \
    \           Constrained-Node Networks\", RFC 7228, May 2014,\n              <http://www.rfc-editor.org/info/rfc7228>.\n\
    \   [Roadmap-6LoWPAN]\n              Bormann, C., \"6LoWPAN Roadmap and Implementation\
    \ Guide\",\n              Work in Progress, draft-bormann-6lo-6lowpan-roadmap-00,\n\
    \              October 2013.\n"
- title: Appendix A.  Examples
  contents:
  - "Appendix A.  Examples\n   This section demonstrates some relatively realistic\
    \ examples derived\n   from actual packet captures taken at previous interops.\n\
    \   For the Routing Protocol for Low-Power and Lossy Networks (RPL)\n   [RFC6550],\
    \ Figure 8 shows a Destination-Oriented Directed Acyclic\n   Graph (DODAG) Information\
    \ Solicitation (DIS), a quite short RPL\n   message that obviously cannot be improved\
    \ much.\n   IP header:\n    60 00 00 00 00 08 3a ff fe 80 00 00 00 00 00 00\n\
    \    02 1c da ff fe 00 20 24 ff 02 00 00 00 00 00 00\n    00 00 00 00 00 00 00\
    \ 1a\n   Payload:\n    9b 00 6b de 00 00 00 00\n   Dictionary:\n    fe 80 00 00\
    \ 00 00 00 00 02 1c da ff fe 00 20 24\n    ff 02 00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00 1a\n    16 fe fd 17 fe fd 00 01 00 00 00 00 00 01 00 00\n   copy: 04\
    \ 9b 00 6b de\n   4 nulls: 82\n   Compressed:\n    04 9b 00 6b de 82\n   Was 8\
    \ bytes; compressed to 6 bytes, compression factor 1.33\n                    \
    \  Figure 8: A Simple RPL Example\n   Figure 9 shows a RPL DODAG Information Object,\
    \ a longer RPL control\n   message that is improved a bit more.  Note that the\
    \ compressed output\n   exposes an inefficiency in the simple-minded compressor\
    \ used to\n   generate it; this does not devalue the example, since constrained\n\
    \   nodes are quite likely to make use of simple-minded compressors.\n   IP header:\n\
    \    60 00 00 00 00 5c 3a ff fe 80 00 00 00 00 00 00\n    02 1c da ff fe 00 30\
    \ 23 ff 02 00 00 00 00 00 00\n    00 00 00 00 00 00 00 1a\n   Payload:\n    9b\
    \ 01 7a 5f 00 f0 01 00 88 00 00 00 20 02 0d b8\n    00 00 00 00 00 00 00 ff fe\
    \ 00 fa ce 04 0e 00 14\n    09 ff 00 00 01 00 00 00 00 00 00 00 08 1e 80 20\n\
    \    ff ff ff ff ff ff ff ff 00 00 00 00 20 02 0d b8\n    00 00 00 00 00 00 00\
    \ ff fe 00 fa ce 03 0e 40 00\n    ff ff ff ff 20 02 0d b8 00 00 00 00\n   Dictionary:\n\
    \    fe 80 00 00 00 00 00 00 02 1c da ff fe 00 30 23\n    ff 02 00 00 00 00 00\
    \ 00 00 00 00 00 00 00 00 1a\n    16 fe fd 17 fe fd 00 01 00 00 00 00 00 01 00\
    \ 00\n   copy: 06 9b 01 7a 5f 00 f0\n   ref(9): 01 00 -> ref 11nnnkkk 0 7: c7\n\
    \   copy: 01 88\n   3 nulls: 81\n   copy: 04 20 02 0d b8\n   7 nulls: 85\n   ref(60):\
    \ ff fe 00 -> ref 101nssss 0 7/11nnnkkk 1 1: a7 c9\n   copy: 08 fa ce 04 0e 00\
    \ 14 09 ff\n   ref(39): 00 00 01 00 00 -> ref 101nssss 0 4/11nnnkkk 3 2: a4 da\n\
    \   5 nulls: 83\n   copy: 06 08 1e 80 20 ff ff\n   ref(2): ff ff -> ref 11nnnkkk\
    \ 0 0: c0\n   ref(4): ff ff ff ff -> ref 11nnnkkk 2 0: d0\n   4 nulls: 82\n  \
    \ ref(48): 20 02 0d b8 00 00 00 00 00 00 00 ff fe 00 fa ce\n    -> ref 101nssss\
    \ 1 4/11nnnkkk 6 0: b4 f0\n   copy: 03 03 0e 40\n   ref(9): 00 ff -> ref 11nnnkkk\
    \ 0 7: c7\n   ref(28): ff ff ff -> ref 101nssss 0 3/11nnnkkk 1 1: a3 c9\n   ref(24):\
    \ 20 02 0d b8 00 00 00 00\n    -> ref 101nssss 0 2/11nnnkkk 6 0: a2 f0\n   Compressed:\n\
    \    06 9b 01 7a 5f 00 f0 c7 01 88 81 04 20 02 0d b8\n    85 a7 c9 08 fa ce 04\
    \ 0e 00 14 09 ff a4 da 83 06\n    08 1e 80 20 ff ff c0 d0 82 b4 f0 03 03 0e 40\
    \ c7\n    a3 c9 a2 f0\n   Was 92 bytes; compressed to 52 bytes, compression factor\
    \ 1.77\n                      Figure 9: A Longer RPL Example\n   Similarly, Figure\
    \ 10 shows a RPL Destination Advertisement Object\n   (DAO) message.  One of the\
    \ embedded addresses is copied right out of\n   the pseudo-header; the other one\
    \ is effectively converted from global\n   to local by providing the prefix FE80\
    \ literally, inserting a number\n   of nulls, and copying (some of) the Interface\
    \ Identifier part again\n   out of the pseudo-header.  Note that a simple implementation\
    \ would\n   probably emit fewer nulls and copy the entire Interface Identifier;\n\
    \   there are multiple ways to encode this 50-byte payload into 27 bytes.\n  \
    \ IP header:\n    60 00 00 00 00 32 3a ff 20 02 0d b8 00 00 00 00\n    00 00 00\
    \ ff fe 00 33 44 20 02 0d b8 00 00 00 00\n    00 00 00 ff fe 00 11 22\n   Payload:\n\
    \    9b 02 58 7d 01 80 00 f1 05 12 00 80 20 02 0d b8\n    00 00 00 00 00 00 00\
    \ ff fe 00 33 44 06 14 00 80\n    f1 00 fe 80 00 00 00 00 00 00 00 00 00 ff fe\
    \ 00\n    11 22\n   Dictionary:\n    20 02 0d b8 00 00 00 00 00 00 00 ff fe 00\
    \ 33 44\n    20 02 0d b8 00 00 00 00 00 00 00 ff fe 00 11 22\n    16 fe fd 17\
    \ fe fd 00 01 00 00 00 00 00 01 00 00\n   copy: 0c 9b 02 58 7d 01 80 00 f1 05\
    \ 12 00 80\n   ref(60): 20 02 0d b8 00 00 00 00 00 00 00 ff fe 00 33 44\n    ->\
    \ ref 101nssss 1 5/11nnnkkk 6 4: b5 f4\n   copy: 08 06 14 00 80 f1 00 fe 80\n\
    \   9 nulls: 87\n   ref(66): ff fe 00 11 22 -> ref 101nssss 0 7/11nnnkkk 3 5:\
    \ a7 dd\n   Compressed:\n    0c 9b 02 58 7d 01 80 00 f1 05 12 00 80 b5 f4 08\n\
    \    06 14 00 80 f1 00 fe 80 87 a7 dd\n   Was 50 bytes; compressed to 27 bytes,\
    \ compression factor 1.85\n                       Figure 10: A RPL DAO Message\n\
    \   Figure 11 shows the effect of compressing a simple ND neighbor\n   solicitation.\n\
    \   IP header:\n    60 00 00 00 00 30 3a ff 20 02 0d b8 00 00 00 00\n    00 00\
    \ 00 ff fe 00 3b d3 fe 80 00 00 00 00 00 00\n    02 1c da ff fe 00 30 23\n   Payload:\n\
    \    87 00 a7 68 00 00 00 00 fe 80 00 00 00 00 00 00\n    02 1c da ff fe 00 30\
    \ 23 01 01 3b d3 00 00 00 00\n    1f 02 00 00 00 00 00 06 00 1c da ff fe 00 20\
    \ 24\n   Dictionary:\n    20 02 0d b8 00 00 00 00 00 00 00 ff fe 00 3b d3\n  \
    \  fe 80 00 00 00 00 00 00 02 1c da ff fe 00 30 23\n    16 fe fd 17 fe fd 00 01\
    \ 00 00 00 00 00 01 00 00\n   copy: 04 87 00 a7 68\n   4 nulls: 82\n   ref(40):\
    \ fe 80 00 00 00 00 00 00 02 1c da ff fe 00 30 23\n    -> ref 101nssss 1 3/11nnnkkk\
    \ 6 0: b3 f0\n   copy: 04 01 01 3b d3\n   4 nulls: 82\n   copy: 02 1f 02\n   5\
    \ nulls: 83\n   copy: 02 06 00\n   ref(24): 1c da ff fe 00 -> ref 101nssss 0 2/11nnnkkk\
    \ 3 3: a2 db\n   copy: 02 20 24\n   Compressed:\n    04 87 00 a7 68 82 b3 f0 04\
    \ 01 01 3b d3 82 02 1f\n    02 83 02 06 00 a2 db 02 20 24\n   Was 48 bytes; compressed\
    \ to 26 bytes, compression factor 1.85\n                  Figure 11: An ND Neighbor\
    \ Solicitation\n   Figure 12 shows the compression of an ND neighbor advertisement.\n\
    \   IP header:\n    60 00 00 00 00 30 3a fe fe 80 00 00 00 00 00 00\n    02 1c\
    \ da ff fe 00 30 23 20 02 0d b8 00 00 00 00\n    00 00 00 ff fe 00 3b d3\n   Payload:\n\
    \    88 00 26 6c c0 00 00 00 fe 80 00 00 00 00 00 00\n    02 1c da ff fe 00 30\
    \ 23 02 01 fa ce 00 00 00 00\n    1f 02 00 00 00 00 00 06 00 1c da ff fe 00 20\
    \ 24\n   Dictionary:\n    fe 80 00 00 00 00 00 00 02 1c da ff fe 00 30 23\n  \
    \  20 02 0d b8 00 00 00 00 00 00 00 ff fe 00 3b d3\n    16 fe fd 17 fe fd 00 01\
    \ 00 00 00 00 00 01 00 00\n   copy: 05 88 00 26 6c c0\n   3 nulls: 81\n   ref(56):\
    \ fe 80 00 00 00 00 00 00 02 1c da ff fe 00 30 23\n    -> ref 101nssss 1 5/11nnnkkk\
    \ 6 0: b5 f0\n   copy: 04 02 01 fa ce\n   4 nulls: 82\n   copy: 02 1f 02\n   5\
    \ nulls: 83\n   copy: 02 06 00\n   ref(24): 1c da ff fe 00 -> ref 101nssss 0 2/11nnnkkk\
    \ 3 3: a2 db\n   copy: 02 20 24\n   Compressed:\n    05 88 00 26 6c c0 81 b5 f0\
    \ 04 02 01 fa ce 82 02\n    1f 02 83 02 06 00 a2 db 02 20 24\n   Was 48 bytes;\
    \ compressed to 27 bytes, compression factor 1.78\n                  Figure 12:\
    \ An ND Neighbor Advertisement\n   Figure 13 shows the compression of an ND router\
    \ solicitation.  Note\n   that the relatively good compression is not caused by\
    \ the many zero\n   bytes in the link-layer address of this particular capture\
    \ (which are\n   unlikely to occur in practice): 7 of these 8 bytes are copied\
    \ from\n   the pseudo-header (the 8th byte cannot be copied, as the universal/\n\
    \   local bit needs to be inverted).\n   IP header:\n    60 00 00 00 00 18 3a\
    \ ff fe 80 00 00 00 00 00 00\n    ae de 48 00 00 00 00 01 ff 02 00 00 00 00 00\
    \ 00\n    00 00 00 00 00 00 00 02\n   Payload:\n    85 00 90 65 00 00 00 00 01\
    \ 02 ac de 48 00 00 00\n    00 01 00 00 00 00 00 00\n   Dictionary:\n    fe 80\
    \ 00 00 00 00 00 00 ae de 48 00 00 00 00 01\n    ff 02 00 00 00 00 00 00 00 00\
    \ 00 00 00 00 00 02\n    16 fe fd 17 fe fd 00 01 00 00 00 00 00 01 00 00\n   copy:\
    \ 04 85 00 90 65\n   ref(11): 00 00 00 00 01 -> ref 11nnnkkk 3 6: de\n   copy:\
    \ 02 02 ac\n   ref(50): de 48 00 00 00 00 01\n    -> ref 101nssss 0 5/11nnnkkk\
    \ 5 3: a5 eb\n   6 nulls: 84\n   Compressed:\n    04 85 00 90 65 de 02 02 ac a5\
    \ eb 84\n   Was 24 bytes; compressed to 12 bytes, compression factor 2.00\n  \
    \                 Figure 13: An ND Router Solicitation\n   Figure 14 shows the\
    \ compression of an ND router advertisement.  The\n   indefinite lifetime is compressed\
    \ to four bytes by backreferencing;\n   this could be improved (at the cost of\
    \ minor additional decompressor\n   complexity) by including some simple runlength\
    \ mechanism.\n   IP header:\n    60 00 00 00 00 60 3a ff fe 80 00 00 00 00 00\
    \ 00\n    10 34 00 ff fe 00 11 22 fe 80 00 00 00 00 00 00\n    ae de 48 00 00\
    \ 00 00 01\n   Payload:\n    86 00 55 c9 40 00 0f a0 1c 5a 38 17 00 00 07 d0\n\
    \    01 01 11 22 00 00 00 00 03 04 40 40 ff ff ff ff\n    ff ff ff ff 00 00 00\
    \ 00 20 02 0d b8 00 00 00 00\n    00 00 00 00 00 00 00 00 20 02 40 10 00 00 03\
    \ e8\n    20 02 0d b8 00 00 00 00 21 03 00 01 00 00 00 00\n    20 02 0d b8 00\
    \ 00 00 00 00 00 00 ff fe 00 11 22\n   Dictionary:\n    fe 80 00 00 00 00 00 00\
    \ 10 34 00 ff fe 00 11 22\n    fe 80 00 00 00 00 00 00 ae de 48 00 00 00 00 01\n\
    \    16 fe fd 17 fe fd 00 01 00 00 00 00 00 01 00 00\n   copy: 0c 86 00 55 c9\
    \ 40 00 0f a0 1c 5a 38 17\n   2 nulls: 80\n   copy: 06 07 d0 01 01 11 22\n   4\
    \ nulls: 82\n   copy: 06 03 04 40 40 ff ff\n   ref(2): ff ff -> ref 11nnnkkk 0\
    \ 0: c0\n   ref(4): ff ff ff ff -> ref 11nnnkkk 2 0: d0\n   4 nulls: 82\n   copy:\
    \ 04 20 02 0d b8\n   12 nulls: 8a\n   copy: 04 20 02 40 10\n   ref(38): 00 00\
    \ 03 -> ref 101nssss 0 4/11nnnkkk 1 3: a4 cb\n   copy: 01 e8\n   ref(24): 20 02\
    \ 0d b8 00 00 00 00\n    -> ref 101nssss 0 2/11nnnkkk 6 0: a2 f0\n   copy: 02\
    \ 21 03\n   ref(84): 00 01 00 00 00 00\n    -> ref 101nssss 0 9/11nnnkkk 4 6:\
    \ a9 e6\n   ref(40): 20 02 0d b8 00 00 00 00 00 00 00\n    -> ref 101nssss 1 3/11nnnkkk\
    \ 1 5: b3 cd\n   ref(128): ff fe 00 11 22\n    -> ref 101nssss 0 15/11nnnkkk 3\
    \ 3: af db\n   Compressed:\n    0c 86 00 55 c9 40 00 0f a0 1c 5a 38 17 80 06 07\n\
    \    d0 01 01 11 22 82 06 03 04 40 40 ff ff c0 d0 82\n    04 20 02 0d b8 8a 04\
    \ 20 02 40 10 a4 cb 01 e8 a2\n    f0 02 21 03 a9 e6 b3 cd af db\n   Was 96 bytes;\
    \ compressed to 58 bytes, compression factor 1.66\n                   Figure 14:\
    \ An ND Router Advertisement\n   Figure 15 shows the compression of a DTLS application\
    \ data packet\n   with a net payload of 13 bytes of cleartext and 8 bytes of\n\
    \   authenticator (note that the IP header is not relevant for this\n   example\
    \ and has been set to 0).  This makes good use of the static\n   dictionary and\
    \ is quite effective crunching out the redundancy in the\n   TLS_PSK_WITH_AES_128_CCM_8\
    \ header, leading to a net reduction by 15\n   bytes.\n   IP header:\n    00 00\
    \ 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n    00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00 00 00 00\n    00 00 00 00 00 00 00 00\n   Payload:\n    17 fe fd 00\
    \ 01 00 00 00 00 00 01 00 1d 00 01 00\n    00 00 00 00 01 09 b2 0e 82 c1 6e b6\
    \ 96 c5 1f 36\n    8d 17 61 e2 b5 d4 22 d4 ed 2b\n   Dictionary:\n    00 00 00\
    \ 00 00 00 00 00 00 00 00 00 00 00 00 00\n    00 00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00 00 00\n    16 fe fd 17 fe fd 00 01 00 00 00 00 00 01 00 00\n   ref(13):\
    \ 17 fe fd 00 01 00 00 00 00 00 01 00\n    -> ref 101nssss 1 0/11nnnkkk 2 1: b0\
    \ d1\n   copy: 01 1d\n   ref(10): 00 01 00 00 00 00 00 01 -> ref 11nnnkkk 6 2:\
    \ f2\n   copy: 15 09 b2 0e 82 c1 6e b6 96 c5 1f 36 8d 17 61 e2\n   copy: b5 d4\
    \ 22 d4 ed 2b\n   Compressed:\n    b0 d1 01 1d f2 15 09 b2 0e 82 c1 6e b6 96 c5\
    \ 1f\n    36 8d 17 61 e2 b5 d4 22 d4 ed 2b\n   Was 42 bytes; compressed to 27\
    \ bytes, compression factor 1.56\n                 Figure 15: A DTLS Application\
    \ Data Packet\n   Figure 16 shows that the compression is slightly worse in a\n\
    \   subsequent packet (containing 6 bytes of cleartext and 8 bytes of\n   authenticator,\
    \ yielding a net compression of 13 bytes).  The total\n   overhead does stay at\
    \ a quite acceptable 8 bytes.\n   IP header:\n    00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00 00 00 00\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n   \
    \ 00 00 00 00 00 00 00 00\n   Payload:\n    17 fe fd 00 01 00 00 00 00 00 05 00\
    \ 16 00 01 00\n    00 00 00 00 05 ae a0 15 56 67 92 4d ff 8a 24 e4\n    cb 35\
    \ b9\n   Dictionary:\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  \
    \  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n    16 fe fd 17 fe fd 00 01\
    \ 00 00 00 00 00 01 00 00\n   ref(13): 17 fe fd 00 01 00 00 00 00 00\n    -> ref\
    \ 101nssss 1 0/11nnnkkk 0 3: b0 c3\n   copy: 03 05 00 16\n   ref(10): 00 01 00\
    \ 00 00 00 00 05 -> ref 11nnnkkk 6 2: f2\n   copy: 0e ae a0 15 56 67 92 4d ff\
    \ 8a 24 e4 cb 35 b9\n   Compressed:\n    b0 c3 03 05 00 16 f2 0e ae a0 15 56 67\
    \ 92 4d ff\n    8a 24 e4 cb 35 b9\n   Was 35 bytes; compressed to 22 bytes, compression\
    \ factor 1.59\n              Figure 16: Another DTLS Application Data Packet\n\
    \   Figure 17 shows the compression of a DTLS handshake message, here a\n   client\
    \ hello.  There is little that can be compressed about the 32\n   bytes of randomness.\
    \  Still, the net reduction is by 14 bytes.\n   IP header:\n    00 00 00 00 00\
    \ 00 00 00 00 00 00 00 00 00 00 00\n    00 00 00 00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00\n    00 00 00 00 00 00 00 00\n   Payload:\n    16 fe fd 00 00 00 00\
    \ 00 00 00 00 00 36 01 00 00\n    2a 00 00 00 00 00 00 00 2a fe fd 51 52 ed 79\
    \ a4\n    20 c9 62 56 11 47 c9 39 ee 6c c0 a4 fe c6 89 2f\n    32 26 9a 16 4e\
    \ 31 7e 9f 20 92 92 00 00 00 02 c0\n    a8 01 00\n   Dictionary:\n    00 00 00\
    \ 00 00 00 00 00 00 00 00 00 00 00 00 00\n    00 00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00 00 00\n    16 fe fd 17 fe fd 00 01 00 00 00 00 00 01 00 00\n   ref(16):\
    \ 16 fe fd -> ref 101nssss 0 1/11nnnkkk 1 5: a1 cd\n   9 nulls: 87\n   copy: 01\
    \ 36\n   ref(16): 01 00 00 -> ref 101nssss 0 1/11nnnkkk 1 5: a1 cd\n   copy: 01\
    \ 2a\n   7 nulls: 85\n   copy: 23 2a fe fd 51 52 ed 79 a4 20 c9 62 56 11 47 c9\n\
    \   copy: 39 ee 6c c0 a4 fe c6 89 2f 32 26 9a 16 4e 31 7e\n   copy: 9f 20 92 92\n\
    \   3 nulls: 81\n   copy: 05 02 c0 a8 01 00\n   Compressed:\n    a1 cd 87 01 36\
    \ a1 cd 01 2a 85 23 2a fe fd 51 52\n    ed 79 a4 20 c9 62 56 11 47 c9 39 ee 6c\
    \ c0 a4 fe\n    c6 89 2f 32 26 9a 16 4e 31 7e 9f 20 92 92 81 05\n    02 c0 a8\
    \ 01 00\n   Was 67 bytes; compressed to 53 bytes, compression factor 1.26\n  \
    \           Figure 17: A DTLS Handshake Packet (Client Hello)\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Colin O'Flynn has repeatedly insisted that some form of\
    \ compression\n   for ICMPv6 and ND packets might be beneficial.  He actually\
    \ wrote his\n   own document, [ICMPv6-ND], which compresses better, but that document\n\
    \   only addresses basic ICMPv6/ND and needs a much longer specification\n   (around\
    \ 17 pages of detailed specification, as compared to the single\n   page of core\
    \ specification here).  This motivated the author to try\n   something simple,\
    \ yet general.  Special thanks go to Colin for\n   indicating that he indeed considers\
    \ his document superseded by\n   this one.\n   The examples given are based on\
    \ packet capture files that Colin\n   O'Flynn, Owen Kirby, Olaf Bergmann, and\
    \ others provided.\n   Using these files as a corpus, the static dictionary was\
    \ developed,\n   and the bit allocations validated, based on research by Sebastian\n\
    \   Dominik.\n   Erik Nordmark provided input that helped shape the 6CIO.  Thomas\n\
    \   Bjorklund proposed simplifying the predefined dictionary.\n   Yoshihiro Ohba\
    \ insisted on clarifying the notation used for the\n   definition of the bytecodes\
    \ and their bitfields.  Ulrich Herberg\n   provided some additional review and\
    \ suggested expanding the\n   introductory material, and with Hannes Tschofenig\
    \ and Brian Haberman\n   he helped come up with the IANA policy for the \"6LoWPAN\
    \ capability\n   bits\" assignments in the 6CIO.\n   The IESG reviewers Richard\
    \ Barnes and Stephen Farrell contributed\n   topics to the Security Considerations\
    \ section; they and Barry Leiba,\n   as well as GEN-ART reviewer Vijay K. Gurbani,\
    \ also provided editorial\n   improvements.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Carsten Bormann\n   Universitaet Bremen TZI\n   Postfach\
    \ 330440\n   D-28359 Bremen\n   Germany\n   Phone: +49-421-218-63921\n   EMail:\
    \ cabo@tzi.org\n"
