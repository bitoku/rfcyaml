- contents:
  - '             The COPS (Common Open Policy Service) Protocol

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Conventions used in this document\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC-2119].\n"
  title: Conventions used in this document
- contents:
  - "Abstract\n   This document describes a simple client/server model for supporting\n
    \  policy control over QoS signaling protocols. The model does not make\n   any
    assumptions about the methods of the policy server, but is based\n   on the server
    returning decisions to policy requests. The model is\n   designed to be extensible
    so that other kinds of policy clients may\n   be supported in the future. However,
    this document makes no claims\n   that it is the only or the preferred approach
    for enforcing future\n   types of policies.\n"
  title: Abstract
- contents:
  - "Table Of Contents\n   1. Introduction....................................................3\n
    \  1.1 Basic Model....................................................4\n   2.
    The Protocol....................................................6\n   2.1 Common
    Header..................................................6\n   2.2 COPS Specific
    Object Formats...................................8\n   2.2.1 Handle Object (Handle).......................................9\n
    \  2.2.2 Context Object (Context).....................................9\n   2.2.3
    In-Interface Object (IN-Int)................................10\n   2.2.4 Out-Interface
    Object (OUT-Int)..............................11\n   2.2.5 Reason Object (Reason)......................................12\n
    \  2.2.6 Decision Object (Decision)..................................12\n   2.2.7
    LPDP Decision Object (LPDPDecision).........................14\n   2.2.8 Error
    Object (Error)........................................14\n   2.2.9 Client Specific
    Information Object (ClientSI)...............15\n   2.2.10 Keep-Alive Timer Object
    (KATimer)..........................15\n   2.2.11 PEP Identification Object (PEPID)..........................16\n
    \  2.2.12 Report-Type Object (Report-Type)...........................16\n   2.2.13
    PDP Redirect Address (PDPRedirAddr)........................16\n   2.2.14 Last
    PDP Address (LastPDPAddr).............................17\n   2.2.15 Accounting
    Timer Object (AcctTimer)........................17\n   2.2.16 Message Integrity
    Object (Integrity).......................18\n   2.3 Communication.................................................19\n
    \  2.4 Client Handle Usage...........................................21\n   2.5
    Synchronization Behavior......................................21\n   3. Message
    Content................................................22\n   3.1 Request (REQ)
    \ PEP -> PDP.....................................22\n   3.2 Decision (DEC)  PDP
    -> PEP....................................24\n   3.3 Report State (RPT)  PEP ->
    PDP................................25\n   3.4 Delete Request State (DRQ)  PEP
    -> PDP........................25\n   3.5 Synchronize State Request (SSQ)  PDP
    -> PEP...................26\n   3.6 Client-Open (OPN)  PEP -> PDP.................................26\n
    \  3.7 Client-Accept (CAT)  PDP -> PEP...............................27\n   3.8
    Client-Close (CC)  PEP -> PDP, PDP -> PEP.....................28\n   3.9 Keep-Alive
    (KA)  PEP -> PDP, PDP -> PEP.......................28\n   3.10 Synchronize State
    Complete (SSC) PEP -> PDP..................29\n   4. Common Operation...............................................29\n
    \  4.1 Security and Sequence Number Negotiation......................29\n   4.2
    Key Maintenance...............................................31\n   4.3 PEP Initialization............................................31\n
    \  4.4 Outsourcing Operations........................................32\n   4.5
    Configuration Operations......................................32\n   4.6 Keep-Alive
    Operations.........................................33\n   4.7 PEP/PDP Close.................................................33\n
    \  5. Security Considerations........................................33\n   6.
    IANA Considerations............................................34\n   7. References.....................................................35\n
    \  8. Author Information and Acknowledgments.........................36\n   9.
    Full Copyright Statement.......................................38\n"
  title: Table Of Contents
- contents:
  - "1. Introduction\n   This document describes a simple query and response protocol
    that can\n   be used to exchange policy information between a policy server\n
    \  (Policy Decision Point or PDP) and its clients (Policy Enforcement\n   Points
    or PEPs).  One example of a policy client is an RSVP router\n   that must exercise
    policy-based admission control over RSVP usage\n   [RSVP].  We assume that at
    least one policy server exists in each\n   controlled administrative domain. The
    basic model of interaction\n   between a policy server and its clients is compatible
    with the\n   framework document for policy based admission control [WRK].\n   A
    chief objective of this policy control protocol is to begin with a\n   simple
    but extensible design. The main characteristics of the COPS\n   protocol include:\n
    \     1. The protocol employs a client/server model where the PEP sends\n         requests,
    updates, and deletes to the remote PDP and the PDP\n         returns decisions
    back to the PEP.\n      2. The protocol uses TCP as its transport protocol for
    reliable\n         exchange of messages between policy clients and a server.\n
    \        Therefore, no additional mechanisms are necessary for reliable\n         communication
    between a server and its clients.\n      3. The protocol is extensible in that
    it is designed to leverage\n         off self-identifying objects and can support
    diverse client\n         specific information without requiring modifications
    to the\n         COPS protocol itself. The protocol was created for the general\n
    \        administration, configuration, and enforcement of policies.\n      4.
    COPS provides message level security for authentication, replay\n         protection,
    and message integrity. COPS can also reuse existing\n         protocols for security
    such as IPSEC [IPSEC] or TLS to\n         authenticate and secure the channel
    between the PEP and the\n         PDP.\n      5. The protocol is stateful in two
    main aspects:  (1)\n         Request/Decision state is shared between client and
    server and\n         (2) State from various events (Request/Decision pairs) may
    be\n         inter-associated. By (1) we mean that requests from the client\n
    \        PEP are installed or remembered by the remote PDP until they\n         are
    explicitly deleted by the PEP. At the same time, Decisions\n         from the
    remote PDP can be generated asynchronously at any time\n         for a currently
    installed request state. By (2) we mean that\n         the server may respond
    to new queries differently because of\n         previously installed Request/Decision
    state(s) that are\n         related.\n      6. Additionally, the protocol is stateful
    in that it allows the\n         server to push configuration information to the
    client, and\n         then allows the server to remove such state from the client\n
    \        when it is no longer applicable.\n"
  - contents:
    - "1.1 Basic Model\n          +----------------+\n          |                |\n
      \         |  Network Node  |            Policy Server\n          |                |\n
      \         |   +-----+      |   COPS        +-----+\n          |   | PEP |<-----|-------------->|
      PDP |\n          |   +-----+      |               +-----+\n          |    ^
      \          |\n          |    |           |\n          |    \\-->+-----+ |\n
      \         |        | LPDP| |\n          |        +-----+ |\n          |                |\n
      \         +----------------+\n          Figure 1: A COPS illustration.\n   Figure
      1 Illustrates the layout of various policy components in a\n   typical COPS
      example (taken from [WRK]). Here, COPS is used to\n   communicate policy information
      between a Policy Enforcement Point\n   (PEP) and a remote Policy Decision Point
      (PDP) within the context of\n   a particular type of client. The optional Local
      Policy Decision Point\n   (LPDP) can be used by the device to make local policy
      decisions in\n   the absence of a PDP.\n   It is assumed that each participating
      policy client is functionally\n   consistent with a PEP [WRK]. The PEP may communicate
      with a policy\n   server (herein referred to as a remote PDP [WRK]) to obtain
      policy\n   decisions or directives.\n   The PEP is responsible for initiating
      a persistent TCP connection to\n   a PDP. The PEP uses this TCP connection to
      send requests to and\n   receive decisions from the remote PDP. Communication
      between the PEP\n   and remote PDP is mainly in the form of a stateful request/decision\n
      \  exchange, though the remote PDP may occasionally send unsolicited\n   decisions
      to the PEP to force changes in previously approved request\n   states. The PEP
      also has the capacity to report to the remote PDP\n   that it has successfully
      completed performing the PDP's decision\n   locally, useful for accounting and
      monitoring purposes. The PEP is\n   responsible for notifying the PDP when a
      request state has changed on\n   the PEP. Finally, the PEP is responsible for
      the deletion of any\n   state that is no longer applicable due to events at
      the client or\n   decisions issued by the server.\n   When the PEP sends a configuration
      request, it expects the PDP to\n   continuously send named units of configuration
      data to the PEP via\n   decision messages as applicable for the configuration
      request. When a\n   unit of named configuration data is successfully installed
      on the\n   PEP, the PEP should send a report message to the PDP confirming the\n
      \  installation. The server may then update or remove the named\n   configuration
      information via a new decision message. When the PDP\n   sends a decision to
      remove named configuration data from the PEP, the\n   PEP will delete the specified
      configuration and send a report message\n   to the PDP as confirmation.\n   The
      policy protocol is designed to communicate self-identifying\n   objects which
      contain the data necessary for identifying request\n   states, establishing
      the context for a request, identifying the type\n   of request, referencing
      previously installed requests, relaying\n   policy decisions, reporting errors,
      providing message integrity, and\n   transferring client specific/namespace
      information.\n   To distinguish between different kinds of clients, the type
      of client\n   is identified in each message. Different types of clients may
      have\n   different client specific data and may require different kinds of\n
      \  policy decisions. It is expected that each new client-type will have\n   a
      corresponding usage draft specifying the specifics of its\n   interaction with
      this policy protocol.\n   The context of each request corresponds to the type
      of event that\n   triggered it. The COPS Context object identifies the type
      of request\n   and message (if applicable) that triggered a policy event via
      its\n   message type and request type fields. COPS identifies three types of\n
      \  outsourcing events: (1) the arrival of an incoming message (2)\n   allocation
      of local resources, and (3) the forwarding of an outgoing\n   message. Each
      of these events may require different decisions to be\n   made. The content
      of a COPS request/decision message depends on the\n   context. A fourth type
      of request is useful for types of clients that\n   wish to receive configuration
      information from the PDP. This allows a\n   PEP to issue a configuration request
      for a specific named device or\n   module that requires configuration information
      to be installed.\n   The PEP may also have the capability to make a local policy
      decision\n   via its Local Policy Decision Point (LPDP) [WRK], however, the
      PDP\n   remains the authoritative decision point at all times. This means\n
      \  that the relevant local decision information must be relayed to the\n   PDP.
      That is, the PDP must be granted access to all relevant\n   information to make
      a final policy decision. To facilitate this\n   functionality, the PEP must
      send its local decision information to\n   the remote PDP via an LPDP decision
      object. The PEP must then abide\n   by the PDP's decision as it is absolute.\n
      \  Finally, fault tolerance is a required capability for this protocol,\n   particularly
      due to the fact it is associated with the security and\n   service management
      of distributed network devices. Fault tolerance\n   can be achieved by having
      both the PEP and remote PDP constantly\n   verify their connection to each other
      via keep-alive messages. When a\n   failure is detected, the PEP must try to
      reconnect to the remote PDP\n   or attempt to connect to a backup/alternative
      PDP. While\n   disconnected, the PEP should revert to making local decisions.
      Once a\n   connection is reestablished, the PEP is expected to notify the PDP
      of\n   any deleted state or new events that passed local admission control\n
      \  after the connection was lost. Additionally, the remote PDP may\n   request
      that all the PEP's internal state be resynchronized (all\n   previously installed
      requests are to be reissued). After failure and\n   before the new connection
      is fully functional, disruption of service\n   can be minimized if the PEP caches
      previously communicated decisions\n   and continues to use them for some limited
      amount of time. Sections\n   2.3 and 2.5 detail COPS mechanisms for achieving
      reliability.\n"
    title: 1.1 Basic Model
  title: 1. Introduction
- contents:
  - "2. The Protocol\n   This section describes the message formats and objects exchanged\n
    \  between the PEP and remote PDP.\n"
  - contents:
    - "2.1 Common Header\n   Each COPS message consists of the COPS header followed
      by a number of\n   typed objects.\n            0              1              2
      \             3\n     +--------------+--------------+--------------+--------------+\n
      \    |Version| Flags|    Op Code   |       Client-type           |\n     +--------------+--------------+--------------+--------------+\n
      \    |                      Message Length                       |\n     +--------------+--------------+--------------+--------------+\n
      \    Global note: //// implies field is reserved, set to 0.\n       The fields
      in the header are:\n         Version: 4 bits\n             COPS version number.
      Current version is 1.\n         Flags: 4 bits\n             Defined flag values
      (all other flags MUST be set to 0):\n               0x1 Solicited Message Flag
      Bit\n                This flag is set when the message is solicited by\n                another
      COPS message. This flag is NOT to be set\n                (value=0) unless otherwise
      specified in section 3.\n         Op Code: 8 bits\n            The COPS operations:\n
      \             1 = Request                 (REQ)\n              2 = Decision
      \               (DEC)\n              3 = Report State            (RPT)\n              4
      = Delete Request State    (DRQ)\n              5 = Synchronize State Req   (SSQ)\n
      \             6 = Client-Open             (OPN)\n              7 = Client-Accept
      \          (CAT)\n              8 = Client-Close            (CC)\n              9
      = Keep-Alive              (KA)\n              10= Synchronize Complete    (SSC)\n
      \      Client-type: 16 bits\n        The Client-type identifies the policy client.
      Interpretation of\n        all encapsulated objects is relative to the client-type.
      Client-\n        types that set the most significant bit in the client-type
      field\n        are enterprise specific (these are client-types 0x8000 -\n        0xFFFF).
      (See the specific client usage documents for particular\n        client-type
      IDs). For KA Messages, the client-type in the header\n        MUST always be
      set to 0 as the KA is used for connection\n        verification (not per client
      session verification).\n        Message Length: 32 bits\n        Size of message
      in octets, which includes the standard COPS\n        header and all encapsulated
      objects. Messages MUST be aligned on\n        4 octet intervals.\n"
    title: 2.1 Common Header
  - contents:
    - "2.2 COPS Specific Object Formats\n   All the objects follow the same object
      format; each object consists\n   of one or more 32-bit words with a four-octet
      header, using the\n   following format:\n              0             1              2
      \            3\n       +-------------+-------------+-------------+-------------+\n
      \      |       Length (octets)     |    C-Num    |   C-Type    |\n       +-------------+-------------+-------------+-------------+\n
      \      |                                                       |\n       //
      \                 (Object contents)                   //\n       |                                                       |\n
      \      +-------------+-------------+-------------+-------------+\n   The length
      is a two-octet value that describes the number of octets\n   (including the
      header) that compose the object. If the length in\n   octets does not fall on
      a 32-bit word boundary, padding MUST be added\n   to the end of the object so
      that it is aligned to the next 32-bit\n   boundary before the object can be
      sent on the wire. On the receiving\n   side, a subsequent object boundary can
      be found by simply rounding up\n   the previous stated object length to the
      next 32-bit boundary.\n   Typically, C-Num identifies the class of information
      contained in the\n   object, and the C-Type identifies the subtype or version
      of the\n   information contained in the object.\n      C-num: 8 bits\n               1
      \ = Handle\n               2  = Context\n               3  = In Interface\n
      \              4  = Out Interface\n               5  = Reason code\n               6
      \ = Decision\n               7  = LPDP Decision\n               8  = Error\n
      \              9  = Client Specific Info\n               10 = Keep-Alive Timer\n
      \              11 = PEP Identification\n               12 = Report Type\n               13
      = PDP Redirect Address\n               14 = Last PDP Address\n               15
      = Accounting Timer\n               16 = Message Integrity\n      C-type: 8 bits\n
      \              Values defined per C-num.\n"
    - contents:
      - "2.2.1 Handle Object (Handle)\n   The Handle Object encapsulates a unique
        value that identifies an\n   installed state. This identification is used
        by most COPS operations.\n   A state corresponding to a handle MUST be explicitly
        deleted when it\n   is no longer applicable. See Section 2.4 for details.\n
        \          C-Num = 1\n           C-Type = 1, Client Handle.\n   Variable-length
        field, no implied format other than it is unique from\n   other client handles
        from the same PEP (a.k.a. COPS TCP connection)\n   for a particular client-type.
        It is always initially chosen by the\n   PEP and then deleted by the PEP when
        no longer applicable. The client\n   handle is used to refer to a request
        state initiated by a particular\n   PEP and installed at the PDP for a client-type.
        A PEP will specify a\n   client handle in its Request messages, Report messages
        and Delete\n   messages sent to the PDP. In all cases, the client handle is
        used to\n   uniquely identify a particular PEP's request for a client-type.\n
        \  The client handle value is set by the PEP and is opaque to the PDP.\n   The
        PDP simply performs a byte-wise comparison on the value in this\n   object
        with respect to the handle object values of other currently\n   installed
        requests.\n"
      title: 2.2.1 Handle Object (Handle)
    - contents:
      - "2.2.2 Context Object (Context)\n   Specifies the type of event(s) that triggered
        the query. Required for\n   request messages. Admission control, resource
        allocation, and\n   forwarding requests are all amenable to client-types that
        outsource\n   their decision making facility to the PDP. For applicable client-\n
        \  types a PEP can also make a request to receive named configuration\n   information
        from the PDP. This named configuration data may be in a\n   form useful for
        setting system attributes on a PEP, or it may be in\n   the form of policy
        rules that are to be directly verified by the PEP.\n   Multiple flags can
        be set for the same request. This is only allowed,\n   however, if the set
        of client specific information in the combined\n   request is identical to
        the client specific information that would be\n   specified if individual
        requests were made for each specified flag.\n           C-num = 2, C-Type
        = 1\n              0             1               2               3\n       +--------------+--------------+--------------+--------------+\n
        \      |            R-Type           |            M-Type           |\n       +--------------+--------------+--------------+--------------+\n
        \          R-Type (Request Type Flag)\n               0x01 = Incoming-Message/Admission
        Control request\n               0x02 = Resource-Allocation request\n               0x04
        = Outgoing-Message request\n               0x08 = Configuration request\n
        \          M-Type (Message Type)\n               Client Specific 16 bit values
        of protocol message types\n"
      title: 2.2.2 Context Object (Context)
    - contents:
      - "2.2.3 In-Interface Object (IN-Int)\n   The In-Interface Object is used to
        identify the incoming interface on\n   which a particular request applies
        and the address where the received\n   message originated. For flows or messages
        generated from the PEP's\n   local host, the loop back address and ifindex
        are used.\n   This Interface object is also used to identify the incoming\n
        \  (receiving) interface via its ifindex. The ifindex may be used to\n   differentiate
        between sub-interfaces and unnumbered interfaces (see\n   RSVP's LIH for an
        example). When SNMP is supported by the PEP, this\n   ifindex integer MUST
        correspond to the same integer value for the\n   interface in the SNMP MIB-II
        interface index table.\n   Note: The ifindex specified in the In-Interface
        is typically relative\n   to the flow of the underlying protocol messages.
        The ifindex is the\n   interface on which the protocol message was received.\n
        \          C-Num = 3\n           C-Type = 1, IPv4 Address + Interface\n               0
        \            1              2             3\n       +--------------+--------------+--------------+--------------+\n
        \      |                   IPv4 Address format                     |\n       +--------------+--------------+--------------+--------------+\n
        \      |                          ifindex                          |\n       +--------------+--------------+--------------+--------------+\n
        \  For this type of the interface object, the IPv4 address specifies the\n
        \  IP address that the incoming message came from.\n           C-Type = 2,
        IPv6 Address + Interface\n               0             1              2             3\n
        \      +--------------+--------------+--------------+--------------+\n       |
        \                                                          |\n       +                                                           +\n
        \      |                                                           |\n       +
        \                   IPv6 Address format                    +\n       |                                                           |\n
        \      +                                                           +\n       |
        \                                                          |\n       +--------------+--------------+--------------+--------------+\n
        \      |                          ifindex                          |\n       +--------------+--------------+--------------+--------------+\n
        \  For this type of the interface object, the IPv6 address specifies the\n
        \  IP address that the incoming message came from. The ifindex is used\n   to
        refer to the MIB-II defined local incoming interface on the PEP as\n   described
        above.\n"
      title: 2.2.3 In-Interface Object (IN-Int)
    - contents:
      - "2.2.4 Out-Interface Object (OUT-Int)\n   The Out-Interface is used to identify
        the outgoing interface to which\n   a specific request applies and the address
        for where the forwarded\n   message is to be sent. For flows or messages destined
        to the PEP's\n   local host, the loop back address and ifindex are used.  The
        Out-\n   Interface has the same formats as the In-Interface Object.\n   This
        Interface object is also used to identify the outgoing\n   (forwarding) interface
        via its ifindex. The ifindex may be used to\n   differentiate between sub-interfaces
        and unnumbered interfaces (see\n   RSVP's LIH for an example). When SNMP is
        supported by the PEP, this\n   ifindex integer MUST correspond to the same
        integer value for the\n   interface in the SNMP MIB-II interface index table.\n
        \  Note: The ifindex specified in the Out-Interface is typically\n   relative
        to the flow of the underlying protocol messages. The ifindex\n   is the one
        on which a protocol message is about to be forwarded.\n           C-Num =
        4\n           C-Type = 1, IPv4 Address + Interface\n   Same C-Type format
        as the In-Interface object. The IPv4 address\n   specifies the IP address
        to which the outgoing message is going. The\n   ifindex is used to refer to
        the MIB-II defined local outgoing\n   interface on the PEP.\n           C-Type
        = 2, IPv6 Address + Interface\n   Same C-Type format as the In-Interface object.
        For this type of the\n   interface object, the IPv6 address specifies the
        IP address to which\n   the outgoing message is going. The ifindex is used
        to refer to the\n   MIB-II defined local outgoing interface on the PEP.\n"
      title: 2.2.4 Out-Interface Object (OUT-Int)
    - contents:
      - "2.2.5 Reason Object (Reason)\n   This object specifies the reason why the
        request state was deleted.\n   It appears in the delete request (DRQ) message.
        The Reason Sub-code\n   field is reserved for more detailed client-specific
        reason codes\n   defined in the corresponding documents.\n           C-Num
        = 5, C-Type = 1\n               0             1              2             3\n
        \      +--------------+--------------+--------------+--------------+\n       |
        \        Reason-Code         |       Reason Sub-code       |\n       +--------------+--------------+--------------+--------------+\n
        \          Reason Code:\n               1 = Unspecified\n               2
        = Management\n               3 = Preempted (Another request state takes precedence)\n
        \              4 = Tear (Used to communicate a signaled state removal)\n               5
        = Timeout (Local state has timed-out)\n               6 = Route Change (Change
        invalidates request state)\n               7 = Insufficient Resources (No
        local resource available)\n               8 = PDP's Directive (PDP decision
        caused the delete)\n               9 = Unsupported decision (PDP decision
        not supported)\n               10= Synchronize Handle Unknown\n               11=
        Transient Handle (stateless event)\n               12= Malformed Decision
        (could not recover)\n               13= Unknown COPS Object from PDP:\n                   Sub-code
        (octet 2) contains unknown object's C-Num\n                   and (octet 3)
        contains unknown object's C-Type.\n"
      title: 2.2.5 Reason Object (Reason)
    - contents:
      - "2.2.6 Decision Object (Decision)\n   Decision made by the PDP. Appears in
        replies. The specific non-\n   mandatory decision objects required in a decision
        to a particular\n   request depend on the type of client.\n               C-Num
        = 6\n               C-Type = 1, Decision Flags (Mandatory)\n               0
        \            1              2             3\n       +--------------+--------------+--------------+--------------+\n
        \      |        Command-Code         |            Flags            |\n       +--------------+--------------+--------------+--------------+\n
        \          Commands:\n               0 = NULL Decision (No configuration data
        available)\n               1 = Install (Admit request/Install configuration)\n
        \              2 = Remove (Remove request/Remove configuration)\n           Flags:\n
        \              0x01 = Trigger Error (Trigger error message if set)\n                Note:
        Trigger Error is applicable to client-types that\n                are capable
        of sending error notifications for signaled\n                messages.\n       Flag
        values not applicable to a given context's R-Type or\n       client-type MUST
        be ignored by the PEP.\n              C-Type = 2, Stateless Data\n       This
        type of decision object carries additional stateless\n       information that
        can be applied by the PEP locally. It is a\n       variable length object
        and its internal format SHOULD be\n       specified in the relevant COPS extension
        document for the given\n       client-type. This object is optional in Decision
        messages and is\n       interpreted relative to a given context.\n       It
        is expected that even outsourcing PEPs will be able to make\n       some simple
        stateless policy decisions locally in their LPDP. As\n       this set is well
        known and implemented ubiquitously, PDPs are\n       aware of it as well (either
        universally, through configuration,\n       or using the Client-Open message).
        The PDP may also include this\n       information in its decision, and the
        PEP MUST apply it to the\n       resource allocation event that generated
        the request.\n               C-Type = 3, Replacement Data\n       This type
        of decision object carries replacement data that is to\n       replace existing
        data in a signaled message. It is a variable\n       length object and its
        internal format SHOULD be specified in the\n       relevant COPS extension
        document for the given client-type. It is\n       optional in Decision messages
        and is interpreted relative to a\n       given context.\n               C-Type
        = 4, Client Specific Decision Data\n       Additional decision types can be
        introduced using the Client\n       Specific Decision Data Object. It is a
        variable length object and\n       its internal format SHOULD be specified
        in the relevant COPS\n       extension document for the given client-type.
        It is optional in\n       Decision messages and is interpreted relative to
        a given context.\n               C-Type = 5, Named Decision Data\n       Named
        configuration information is encapsulated in this version\n       of the decision
        object in response to configuration requests. It\n       is a variable length
        object and its internal format SHOULD be\n       specified in the relevant
        COPS extension document for the given\n       client-type. It is optional
        in Decision messages and is\n       interpreted relative to both a given context
        and decision flags.\n"
      title: 2.2.6 Decision Object (Decision)
    - contents:
      - "2.2.7 LPDP Decision Object (LPDPDecision)\n   Decision made by the PEP's
        local policy decision point (LPDP). May\n   appear in requests. These objects
        correspond to and are formatted the\n   same as the client specific decision
        objects defined above.\n           C-Num = 7\n           C-Type = (same C-Type
        as for Decision objects)\n"
      title: 2.2.7 LPDP Decision Object (LPDPDecision)
    - contents:
      - "2.2.8 Error Object (Error)\n   This object is used to identify a particular
        COPS protocol error.\n   The error sub-code field contains additional detailed
        client specific\n   error codes. The appropriate Error Sub-codes for a particular\n
        \  client-type SHOULD be specified in the relevant COPS extensions\n   document.\n
        \           C-Num = 8, C-Type = 1\n               0             1              2
        \            3\n       +--------------+--------------+--------------+--------------+\n
        \      |          Error-Code         |        Error Sub-code       |\n       +--------------+--------------+--------------+--------------+\n
        \          Error-Code:\n               1 = Bad handle\n               2 =
        Invalid handle reference\n               3 = Bad message format (Malformed
        Message)\n               4 = Unable to process (server gives up on query)\n
        \              5 = Mandatory client-specific info missing\n               6
        = Unsupported client-type\n               7 = Mandatory COPS object missing\n
        \              8 = Client Failure\n               9 = Communication Failure\n
        \              10= Unspecified\n               11= Shutting down\n               12=
        Redirect to Preferred Server\n               13= Unknown COPS Object:\n                   Sub-code
        (octet 2) contains unknown object's C-Num\n                   and (octet 3)
        contains unknown object's C-Type.\n               14= Authentication Failure\n
        \              15= Authentication Required\n"
      title: 2.2.8 Error Object (Error)
    - contents:
      - "2.2.9 Client Specific Information Object (ClientSI)\n   The various types
        of this object are required for requests, and used\n   in reports and opens
        when required. It contains client-type specific\n   information.\n           C-Num
        = 9,\n           C-Type = 1, Signaled ClientSI.\n   Variable-length field.
        All objects/attributes specific to a client's\n   signaling protocol or internal
        state are encapsulated within one or\n   more signaled Client Specific Information
        Objects. The format of the\n   data encapsulated in the ClientSI object is
        determined by the\n   client-type.\n           C-Type = 2, Named ClientSI.\n
        \  Variable-length field. Contains named configuration information\n   useful
        for relaying specific information about the PEP, a request, or\n   configured
        state to the PDP server.\n"
      title: 2.2.9 Client Specific Information Object (ClientSI)
    - contents:
      - "2.2.10 Keep-Alive Timer Object (KATimer)\n   Times are encoded as 2 octet
        integer values and are in units of\n   seconds.  The timer value is treated
        as a delta.\n           C-Num = 10,\n           C-Type = 1, Keep-alive timer
        value\n   Timer object used to specify the maximum time interval over which
        a\n   COPS message MUST be sent or received. The range of finite timeouts\n
        \  is 1 to 65535 seconds represented as an unsigned two-octet integer.\n   The
        value of zero implies infinity.\n               0             1              2
        \            3\n      +--------------+--------------+--------------+--------------+\n
        \     |        //////////////       |        KA Timer Value       |\n      +--------------+--------------+--------------+--------------+\n"
      title: 2.2.10 Keep-Alive Timer Object (KATimer)
    - contents:
      - "2.2.11 PEP Identification Object (PEPID)\n   The PEP Identification Object
        is used to identify the PEP client to\n   the remote PDP. It is required for
        Client-Open messages.\n           C-Num = 11, C-Type = 1\n   Variable-length
        field. It is a NULL terminated ASCII string that is\n   also zero padded to
        a 32-bit word boundary (so the object length is a\n   multiple of 4 octets).
        The PEPID MUST contain an ASCII string that\n   uniquely identifies the PEP
        within the policy domain in a manner that\n   is persistent across PEP reboots.
        For example, it may be the PEP's\n   statically assigned IP address or DNS
        name. This identifier may\n   safely be used by a PDP as a handle for identifying
        the PEP in its\n   policy rules.\n"
      title: 2.2.11 PEP Identification Object (PEPID)
    - contents:
      - "2.2.12 Report-Type Object (Report-Type)\n   The Type of Report on the request
        state associated with a handle:\n           C-Num = 12, C-Type = 1\n               0
        \            1              2             3\n       +--------------+--------------+--------------+--------------+\n
        \      |         Report-Type         |        /////////////        |\n       +--------------+--------------+--------------+--------------+\n
        \          Report-Type:\n               1 = Success   : Decision was successful
        at the PEP\n               2 = Failure   : Decision could not be completed
        by PEP\n               3 = Accounting: Accounting update for an installed
        state\n"
      title: 2.2.12 Report-Type Object (Report-Type)
    - contents:
      - "2.2.13 PDP Redirect Address (PDPRedirAddr)\n   A PDP when closing a PEP session
        for a particular client-type may\n   optionally use this object to redirect
        the PEP to the specified PDP\n   server address and TCP port number:\n       C-Num
        = 13,\n       C-Type = 1, IPv4 Address + TCP Port\n                0             1
        \             2             3\n       +--------------+--------------+--------------+--------------+\n
        \      |                   IPv4 Address format                     |\n       +--------------+--------------+--------------+--------------+\n
        \      |  /////////////////////////  |       TCP Port Number       |\n       +-----------------------------+-----------------------------+\n
        \      C-Type = 2, IPv6 Address + TCP Port\n                0             1
        \             2             3\n       +--------------+--------------+--------------+--------------+\n
        \      |                                                           |\n       +
        \                                                          +\n       |                                                           |\n
        \      +                    IPv6 Address format                    +\n       |
        \                                                          |\n       +                                                           +\n
        \      |                                                           |\n       +--------------+--------------+--------------+--------------+\n
        \      |  /////////////////////////  |       TCP Port Number       |\n       +-----------------------------+-----------------------------+\n"
      title: 2.2.13 PDP Redirect Address (PDPRedirAddr)
    - contents:
      - "2.2.14 Last PDP Address (LastPDPAddr)\n   When a PEP sends a Client-Open
        message for a particular client-type\n   the PEP SHOULD specify the last PDP
        it has successfully opened\n   (meaning it received a Client-Accept) since
        the PEP last rebooted.\n   If no PDP was used since the last reboot, the PEP
        will simply not\n   include this object in the Client-Open message.\n       C-Num
        = 14,\n       C-Type = 1, IPv4 Address (Same format as PDPRedirAddr)\n       C-Type
        = 2, IPv6 Address (Same format as PDPRedirAddr)\n"
      title: 2.2.14 Last PDP Address (LastPDPAddr)
    - contents:
      - "2.2.15 Accounting Timer Object (AcctTimer)\n   Times are encoded as 2 octet
        integer values and are in units of\n   seconds.  The timer value is treated
        as a delta.\n           C-Num = 15,\n           C-Type = 1, Accounting timer
        value\n   Optional timer value used to determine the minimum interval between\n
        \  periodic accounting type reports. It is used by the PDP to describe\n   to
        the PEP an acceptable interval between unsolicited accounting\n   updates
        via Report messages where applicable. It provides a method\n   for the PDP
        to control the amount of accounting traffic seen by the\n   network. The range
        of finite time values is 1 to 65535 seconds\n   represented as an unsigned
        two-octet integer. A value of zero means\n   there SHOULD be no unsolicited
        accounting updates.\n                0             1              2             3\n
        \      +--------------+--------------+--------------+--------------+\n       |
        \       //////////////       |        ACCT Timer Value     |\n       +--------------+--------------+--------------+--------------+\n"
      title: 2.2.15 Accounting Timer Object (AcctTimer)
    - contents:
      - "2.2.16 Message Integrity Object (Integrity)\n   The integrity object includes
        a sequence number and a message digest\n   useful for authenticating and validating
        the integrity of a COPS\n   message. When used, integrity is provided at the
        end of a COPS\n   message as the last COPS object. The digest is then computed
        over all\n   of a particular COPS message up to but not including the digest
        value\n   itself. The sender of a COPS message will compute and fill in the\n
        \  digest portion of the Integrity object. The receiver of a COPS\n   message
        will then compute a digest over the received message and\n   verify it matches
        the digest in the received Integrity object.\n           C-Num = 16,\n           C-Type
        = 1, HMAC digest\n   The HMAC integrity object employs HMAC (Keyed-Hashing
        for Message\n   Authentication) [HMAC] to calculate the message digest based
        on a key\n   shared between the PEP and its PDP.\n   This Integrity object
        specifies a 32-bit Key ID used to identify a\n   specific key shared between
        a particular PEP and its PDP and the\n   cryptographic algorithm to be used.
        The Key ID allows for multiple\n   simultaneous keys to exist on the PEP with
        corresponding keys on the\n   PDP for the given PEPID. The key identified
        by the Key ID was used to\n   compute the message digest in the Integrity
        object. All\n   implementations, at a minimum, MUST support HMAC-MD5-96, which
        is\n   HMAC employing the MD5 Message-Digest Algorithm [MD5] truncated to\n
        \  96-bits to calculate the message digest.\n   This object also includes
        a sequence number that is a 32-bit unsigned\n   integer used to avoid replay
        attacks. The sequence number is\n   initiated during an initial Client-Open
        Client-Accept message\n   exchange and is then incremented by one each time
        a new message is\n   sent over the TCP connection in the same direction. If
        the sequence\n   number reaches the value of 0xFFFFFFFF, the next increment
        will\n   simply rollover to a value of zero.\n   The variable length digest
        is calculated over a COPS message starting\n   with the COPS Header up to
        the Integrity Object (which MUST be the\n   last object in a COPS message)
        INCLUDING the Integrity object's\n   header, Key ID, and Sequence Number.
        The Keyed Message Digest field\n   is not included as part of the digest calculation.
        In the case of\n   HMAC-MD5-96, HMAC-MD5 will produce a 128-bit digest that
        is then to\n   be truncated to 96-bits before being stored in or verified
        against\n   the Keyed Message Digest field as specified in [HMAC]. The Keyed\n
        \  Message Digest MUST be 96-bits when HMAC-MD5-96 is used.\n             0
        \            1              2             3\n       +-------------+-------------+-------------+-------------+\n
        \      |                        Key ID                         |\n       +-------------+-------------+-------------+-------------+\n
        \      |                    Sequence Number                    |\n       +-------------+-------------+-------------+-------------+\n
        \      |                                                       |\n       +
        \                                                      +\n       |               ...Keyed
        Message Digest...              |\n       +                                                       +\n
        \      |                                                       |\n       +-------------+-------------+-------------+-------------+\n"
      title: 2.2.16 Message Integrity Object (Integrity)
    title: 2.2 COPS Specific Object Formats
  - contents:
    - "2.3 Communication\n   The COPS protocol uses a single persistent TCP connection
      between the\n   PEP and a remote PDP. One PDP implementation per server MUST
      listen\n   on a well-known TCP port number (COPS=3288 [IANA]). The PEP is\n
      \  responsible for initiating the TCP connection to a PDP. The location\n   of
      the remote PDP can either be configured, or obtained via a service\n   location
      mechanism [SRVLOC]. Service discovery is outside the scope\n   of this protocol,
      however.\n   If a single PEP can support multiple client-types, it may send\n
      \  multiple Client-Open messages, each specifying a particular client-\n   type
      to a PDP over one or more TCP connections. Likewise, a PDP\n   residing at a
      given address and port number may support one or more\n   client-types. Given
      the client-types it supports, a PDP has the\n   ability to either accept or
      reject each client-type independently.\n   If a client-type is rejected, the
      PDP can redirect the PEP to an\n   alternative PDP address and TCP port for
      a given client-type via\n   COPS.  Different TCP port numbers can be used to
      redirect the PEP to\n   another PDP implementation running on the same server.
      Additional\n   provisions for supporting multiple client-types (perhaps from\n
      \  independent PDP vendors) on a single remote PDP server are not\n   provided
      by the COPS protocol, but, rather, are left to the software\n   architecture
      of the given server platform.\n   It is possible a single PEP may have open
      connections to multiple\n   PDPs. This is the case when there are physically
      different PDPs\n   supporting different client-types as shown in figure 2.\n
      \      +----------------+\n       |                |\n       |  Network Node
      \ |                  Policy Servers\n       |                |\n       |   +-----+
      \     | COPS Client Type 1  +-----+\n       |   |     |<-----|-------------------->|
      PDP1|\n       |   + PEP +      | COPS Client Type 2  +-----+\n       |   |     |<-----|---------\\
      \          +-----+\n       |   +-----+      |          \\----------| PDP2|\n
      \      |    ^           |                     +-----+\n       |    |           |\n
      \      |    \\-->+-----+ |\n       |        | LPDP| |\n       |        +-----+
      |\n       |                |\n       +----------------+\n       Figure 2: Multiple
      PDPs illustration.\n   When a TCP connection is torn down or is lost, the PDP
      is expected to\n   eventually clean up any outstanding request state related
      to\n   request/decision exchanges with the PEP. When the PEP detects a lost\n
      \  connection due to a timeout condition it SHOULD explicitly send a\n   Client-Close
      message for each opened client-type containing an\n   <Error> object indicating
      the \"Communication Failure\" Error-Code.\n   Additionally, the PEP SHOULD continuously
      attempt to contact the\n   primary PDP or, if unsuccessful, any known backup
      PDPs. Specifically\n   the PEP SHOULD keep trying all relevant PDPs with which
      it has been\n   configured until it can establish a connection. If a PEP is
      in\n   communication with a backup PDP and the primary PDP becomes\n   available,
      the backup PDP is responsible for redirecting the PEP back\n   to the primary
      PDP (via a <Client-Close> message containing a\n   <PDPRedirAddr> object identifying
      the primary PDP to use for each\n   affected client-type). Section 2.5 details
      synchronization behavior\n   between PEPs and PDPs.\n"
    title: 2.3 Communication
  - contents:
    - "2.4 Client Handle Usage\n   The client handle is used to identify a unique
      request state for a\n   single PEP per client-type. Client handles are chosen
      by the PEP and\n   are opaque to the PDP. The PDP simply uses the request handle
      to\n   uniquely identify the request state for a particular Client-Type over\n
      \  a particular TCP connection and generically tie its decisions to a\n   corresponding
      request. Client handles are initiated in request\n   messages and are then used
      by subsequent request, decision, and\n   report messages to reference the same
      request state. When the PEP is\n   ready to remove a local request state, it
      will issue a delete message\n   to the PDP for the corresponding client handle.
      A handle MUST be\n   explicitly deleted by the PEP before it can be used by
      the PEP to\n   identify a new request state. Handles referring to different
      request\n   states MUST be unique within the context of a particular TCP\n   connection
      and client-type.\n"
    title: 2.4 Client Handle Usage
  - contents:
    - "2.5 Synchronization Behavior\n   When disconnected from a PDP, the PEP SHOULD
      revert to making local\n   decisions. Once a connection is reestablished, the
      PEP is expected to\n   notify the PDP of any events that have passed local admission\n
      \  control. Additionally, the remote PDP may request that all the PEP's\n   internal
      state be resynchronized (all previously installed requests\n   are to be reissued)
      by sending a Synchronize State message.\n   After a failure and before a new
      connection is fully functional,\n   disruption of service can be minimized if
      the PEP caches previously\n   communicated decisions and continues to use them
      for some appropriate\n   length of time. Specific rules for such behavior are
      to be defined in\n   the appropriate COPS client-type extension specifications.\n
      \  A PEP that caches state from a previous exchange with a disconnected\n   PDP
      MUST communicate this fact to any PDP with which it is able to\n   later reconnect.
      This is accomplished by including the address and\n   TCP port of the last PDP
      for which the PEP is still caching state in\n   the Client-Open message. The
      <LastPDPAddr> object will only be\n   included for the last PDP with which the
      PEP was completely in sync.\n   If the service interruption was temporary and
      the PDP still contains\n   the complete state for the PEP, the PDP may choose
      not to synchronize\n   all states. It is still the responsibility of the PEP
      to update the\n   PDP of all state changes that occurred during the disruption
      of\n   service including any states communicated to the previous PDP that\n
      \  had been deleted after the connection was lost.  These MUST be\n   explicitly
      deleted after a connection is reestablished. If the PDP\n   issues a synchronize
      request the PEP MUST pass all current states to\n   the PDP followed by a Synchronize
      State Complete message (thus\n   completing the synchronization process). If
      the PEP crashes and loses\n   all cached state for a client-type, it will simply
      not include a\n   <LastPDPAddr> in its Client-Open message.\n"
    title: 2.5 Synchronization Behavior
  title: 2. The Protocol
- contents:
  - "3. Message Content\n   This section describes the basic messages exchanged between
    a PEP and\n   a remote PDP as well as their contents. As a convention, object\n
    \  ordering is expected as shown in the BNF for each COPS message unless\n   otherwise
    noted. The Integrity object, if included, MUST always be\n   the last object in
    a message. If security is required and a message\n   was received without a valid
    Integrity object, the receiver MUST send\n   a Client-Close message for Client-Type=0
    specifying the appropriate\n   error code.\n"
  - contents:
    - "3.1 Request (REQ)  PEP -> PDP\n   The PEP establishes a request state client
      handle for which the\n   remote PDP may maintain state. The remote PDP then
      uses this handle\n   to refer to the exchanged information and decisions communicated
      over\n   the TCP connection to a particular PEP for a given client-type.\n   Once
      a stateful handle is established for a new request, any\n   subsequent modifications
      of the request can be made using the REQ\n   message specifying the previously
      installed handle. The PEP is\n   responsible for notifying the PDP whenever
      its local state changes so\n   the PDP's state will be able to accurately mirror
      the PEP's state.\n   The format of the Request message is as follows:\n               <Request
      Message> ::=  <Common Header>\n                                      <Client
      Handle>\n                                      <Context>\n                                      [<IN-Int>]\n
      \                                     [<OUT-Int>]\n                                      [<ClientSI(s)>]\n
      \                                     [<LPDPDecision(s)>]\n                                      [<Integrity>]\n
      \              <ClientSI(s)> ::= <ClientSI> | <ClientSI(s)> <ClientSI>\n               <LPDPDecision(s)>
      ::= <LPDPDecision> |\n                                     <LPDPDecision(s)>
      <LPDPDecision>\n               <LPDPDecision> ::= [<Context>]\n                                  <LPDPDecision:
      Flags>\n                                  [<LPDPDecision: Stateless Data>]\n
      \                                 [<LPDPDecision: Replacement Data>]\n                                  [<LPDPDecision:
      ClientSI Data>]\n                                  [<LPDPDecision: Named Data>]\n
      \  The context object is used to determine the context within which all\n   the
      other objects are to be interpreted. It also is used to determine\n   the kind
      of decision to be returned from the policy server. This\n   decision might be
      related to admission control, resource allocation,\n   object forwarding and
      substitution, or configuration.\n   The interface objects are used to determine
      the corresponding\n   interface on which a signaling protocol message was received
      or is\n   about to be sent. They are typically used if the client is\n   participating
      along the path of a signaling protocol or if the client\n   is requesting configuration
      data for a particular interface.\n   ClientSI, the client specific information
      object, holds the client-\n   type specific data for which a policy decision
      needs to be made. In\n   the case of configuration, the Named ClientSI may include
      named\n   information about the module, interface, or functionality to be\n
      \  configured. The ordering of multiple ClientSIs is not important.\n   Finally,
      LPDPDecision object holds information regarding the local\n   decision made
      by the LPDP.\n   Malformed Request messages MUST result in the PDP specifying
      a\n   Decision message with the appropriate error code.\n"
    title: 3.1 Request (REQ)  PEP -> PDP
  - contents:
    - "3.2 Decision (DEC)  PDP -> PEP\n   The PDP responds to the REQ with a DEC message
      that includes the\n   associated client handle and one or more decision objects
      grouped\n   relative to a Context object and Decision Flags object type pair.
      If\n   there was a protocol error an error object is returned instead.\n   It
      is required that the first decision message for a new/updated\n   request will
      have the solicited message flag set (value = 1) in the\n   COPS header. This
      avoids the issue of keeping track of which updated\n   request (that is, a request
      reissued for the same handle) a\n   particular decision corresponds. It is important
      that, for a given\n   handle, there be at most one outstanding solicited decision
      per\n   request. This essentially means that the PEP SHOULD NOT issue more\n
      \  than one REQ (for a given handle) before it receives a corresponding\n   DEC
      with the solicited message flag set. The PDP MUST always issue\n   decisions
      for requests on a particular handle in the order they\n   arrive and all requests
      MUST have a corresponding decision.\n   To avoid deadlock, the PEP can always
      timeout after issuing a request\n   that does not receive a decision. It MUST
      then delete the timed-out\n   handle, and may try again using a new handle.\n
      \  The format of the Decision message is as follows:\n               <Decision
      Message> ::= <Common Header>\n                                      <Client
      Handle>\n                                      <Decision(s)> | <Error>\n                                      [<Integrity>]\n
      \              <Decision(s)> ::= <Decision> | <Decision(s)> <Decision>\n               <Decision>
      ::= <Context>\n                              <Decision: Flags>\n                              [<Decision:
      Stateless Data>]\n                              [<Decision: Replacement Data>]\n
      \                             [<Decision: ClientSI Data>]\n                              [<Decision:
      Named Data>]\n   The Decision message may include either an Error object or
      one or\n   more context plus associated decision objects. COPS protocol problems\n
      \  are reported in the Error object (e.g. an error with the format of\n   the
      original request including malformed request messages, unknown\n   COPS objects
      in the Request, etc.). The applicable Decision object(s)\n   depend on the context
      and the type of client. The only ordering\n   requirement for decision objects
      is that the required Decision Flags\n   object type MUST precede the other Decision
      object types per context\n   binding.\n"
    title: 3.2 Decision (DEC)  PDP -> PEP
  - contents:
    - "3.3 Report State (RPT)  PEP -> PDP\n   The RPT message is used by the PEP to
      communicate to the PDP its\n   success or failure in carrying out the PDP's
      decision, or to report\n   an accounting related change in state. The Report-Type
      specifies the\n   kind of report and the optional ClientSI can carry additional\n
      \  information per Client-Type.\n   For every DEC message containing a configuration
      context that is\n   received by a PEP, the PEP MUST generate a corresponding
      Report State\n   message with the Solicited Message flag set describing its
      success or\n   failure in applying the configuration decision. In addition,\n
      \  outsourcing decisions from the PDP MAY result in a corresponding\n   solicited
      Report State from the PEP depending on the context and the\n   type of client.
      RPT messages solicited by decisions for a given\n   Client Handle MUST set the
      Solicited Message flag and MUST be sent in\n   the same order as their corresponding
      Decision messages were\n   received. There MUST never be more than one Report
      State message\n   generated with the Solicited Message flag set per Decision.\n
      \  The Report State may also be used to provide periodic updates of\n   client
      specific information for accounting and state monitoring\n   purposes depending
      on the type of the client. In such cases the\n   accounting report type should
      be specified utilizing the appropriate\n   client specific information object.\n
      \             <Report State> ::== <Common Header>\n                                  <Client
      Handle>\n                                  <Report-Type>\n                                  [<ClientSI>]\n
      \                                 [<Integrity>]\n"
    title: 3.3 Report State (RPT)  PEP -> PDP
  - contents:
    - "3.4 Delete Request State (DRQ)  PEP -> PDP\n   When sent from the PEP this
      message indicates to the remote PDP that\n   the state identified by the client
      handle is no longer\n   available/relevant. This information will then be used
      by the remote\n   PDP to initiate the appropriate housekeeping actions. The
      reason code\n   object is interpreted with respect to the client-type and signifies\n
      \  the reason for the removal.\n   The format of the Delete Request State message
      is as follows:\n              <Delete Request>  ::= <Common Header>\n                                    <Client
      Handle>\n                                    <Reason>\n                                    [<Integrity>]\n
      \  Given the stateful nature of COPS, it is important that when a\n   request
      state is finally removed from the PEP, a DRQ message for this\n   request state
      is sent to the PDP so the corresponding state may\n   likewise be removed on
      the PDP. Request states not explicitly deleted\n   by the PEP will be maintained
      by the PDP until either the client\n   session is closed or the connection is
      terminated.\n   Malformed Decision messages MUST trigger a DRQ specifying the\n
      \  appropriate erroneous reason code (Bad Message Format) and any\n   associated
      state on the PEP SHOULD either be removed or re-requested.\n   If a Decision
      contained an unknown COPS Decision Object, the PEP MUST\n   delete its request
      specifying the Unknown COPS Object reason code\n   because the PEP will be unable
      to comply with the information\n   contained in the unknown object. In any case,
      after issuing a DRQ,\n   the PEP may retry the corresponding Request again.\n"
    title: 3.4 Delete Request State (DRQ)  PEP -> PDP
  - contents:
    - "3.5 Synchronize State Request (SSQ)  PDP -> PEP\n   The format of the Synchronize
      State Query message is as follows:\n              <Synchronize State> ::= <Common
      Header>\n                                      [<Client Handle>]\n                                      [<Integrity>]\n
      \  This message indicates that the remote PDP wishes the client (which\n   appears
      in the common header) to re-send its state. If the optional\n   Client Handle
      is present, only the state associated with this handle\n   is synchronized.
      If the PEP does not recognize the requested handle,\n   it MUST immediately
      send a DRQ message to the PDP for the handle that\n   was specified in the SSQ
      message. If no handle is specified in the\n   SSQ message, all the active client
      state MUST be synchronized with\n   the PDP.\n   The client performs state synchronization
      by re-issuing request\n   queries of the specified client-type for the existing
      state in the\n   PEP. When synchronization is complete, the PEP MUST issue a\n
      \  synchronize state complete message to the PDP.\n"
    title: 3.5 Synchronize State Request (SSQ)  PDP -> PEP
  - contents:
    - "3.6 Client-Open (OPN)  PEP -> PDP\n   The Client-Open message can be used by
      the PEP to specify to the PDP\n   the client-types the PEP can support, the
      last PDP to which the PEP\n   connected for the given client-type, and/or client
      specific feature\n   negotiation. A Client-Open message can be sent to the PDP
      at any time\n   and multiple Client-Open messages for the same client-type are\n
      \  allowed (in case of global state changes).\n        <Client-Open>  ::= <Common
      Header>\n                           <PEPID>\n                           [<ClientSI>]\n
      \                          [<LastPDPAddr>]\n                           [<Integrity>]\n
      \  The PEPID is a symbolic, variable length name that uniquely\n   identifies
      the specific client to the PDP (see Section 2.2.11).\n   A named ClientSI object
      can be included for relaying additional\n   global information about the PEP
      to the PDP when required (as\n   specified in the appropriate extensions document
      for the client-\n   type).\n   The PEP may also provide a Last PDP Address object
      in its Client-Open\n   message specifying the last PDP (for the given client-type)
      for which\n   it is still caching decisions since its last reboot. A PDP can
      use\n   this information to determine the appropriate synchronization\n   behavior
      (See section 2.5).\n   If the PDP receives a malformed Client-Open message it
      MUST generate\n   a Client-Close message specifying the appropriate error code.\n"
    title: 3.6 Client-Open (OPN)  PEP -> PDP
  - contents:
    - "3.7 Client-Accept (CAT)  PDP -> PEP\n   The Client-Accept message is used to
      positively respond to the\n   Client-Open message. This message will return
      to the PEP a timer\n   object indicating the maximum time interval between keep-alive\n
      \  messages. Optionally, a timer specifying the minimum allowed interval\n   between
      accounting report messages may be included when applicable.\n              <Client-Accept>
      \ ::= <Common Header>\n                                   <KA Timer>\n                                   [<ACCT
      Timer>]\n                                   [<Integrity>]\n   If the PDP refuses
      the client, it will instead issue a Client-Close\n   message.\n   The KA Timer
      corresponds to maximum acceptable intermediate time\n   between the generation
      of messages by the PDP and PEP. The timer\n   value is determined by the PDP
      and is specified in seconds. A timer\n   value of 0 implies no secondary connection
      verification is necessary.\n   The optional ACCT Timer allows the PDP to indicate
      to the PEP that\n   periodic accounting reports SHOULD NOT exceed the specified
      timer\n   interval per client handle. This allows the PDP to control the rate\n
      \  at which accounting reports are sent by the PEP (when applicable).\n   In
      general, accounting type Report messages are sent to the PDP when\n   determined
      appropriate by the PEP. The accounting timer merely is\n   used by the PDP to
      keep the rate of such updates in check (i.e.\n   Preventing the PEP from blasting
      the PDP with accounting reports).\n   Not including this object implies there
      are no PDP restrictions on\n   the rate at which accounting updates are generated.\n
      \  If the PEP receives a malformed Client-Accept message it MUST\n   generate
      a Client-Close message specifying the appropriate error\n   code.\n"
    title: 3.7 Client-Accept (CAT)  PDP -> PEP
  - contents:
    - "3.8 Client-Close (CC)  PEP -> PDP, PDP -> PEP\n   The Client-Close message
      can be issued by either the PDP or PEP to\n   notify the other that a particular
      type of client is no longer being\n   supported.\n               <Client-Close>
      \ ::= <Common Header>\n                                   <Error>\n                                   [<PDPRedirAddr>]\n
      \                                  [<Integrity>]\n   The Error object is included
      to describe the reason for the close\n   (e.g. the requested client-type is
      not supported by the remote PDP or\n   client failure).\n   A PDP MAY optionally
      include a PDP Redirect Address object in order\n   to inform the PEP of the
      alternate PDP it SHOULD use for the client-\n   type specified in the common
      header.\n"
    title: 3.8 Client-Close (CC)  PEP -> PDP, PDP -> PEP
  - contents:
    - "3.9 Keep-Alive (KA)  PEP -> PDP, PDP -> PEP\n   The keep-alive message MUST
      be transmitted by the PEP within the\n   period defined by the minimum of all
      KA Timer values specified in all\n   received CAT messages for the connection.
      A KA message MUST be\n   generated randomly between 1/4 and 3/4 of this minimum
      KA timer\n   interval. When the PDP receives a keep-alive message from a PEP,
      it\n   MUST echo a keep-alive back to the PEP. This message provides\n   validation
      for each side that the connection is still functioning\n   even when there is
      no other messaging.\n   Note: The client-type in the header MUST always be set
      to 0 as the KA\n   is used for connection verification (not per client session\n
      \  verification).\n               <Keep-Alive>  ::= <Common Header>\n                                 [<Integrity>]\n
      \  Both client and server MAY assume the TCP connection is insufficient\n   for
      the client-type with the minimum time value (specified in the CAT\n   message)
      if no communication activity is detected for a period\n   exceeding the timer
      period. For the PEP, such detection implies the\n   remote PDP or connection
      is down and the PEP SHOULD now attempt to\n   use an alternative/backup PDP.\n"
    title: 3.9 Keep-Alive (KA)  PEP -> PDP, PDP -> PEP
  - contents:
    - "3.10 Synchronize State Complete (SSC) PEP -> PDP\n   The Synchronize State
      Complete is sent by the PEP to the PDP after\n   the PDP sends a synchronize
      state request to the PEP and the PEP has\n   finished synchronization. It is
      useful so that the PDP will know when\n   all the old client state has been
      successfully re-requested and,\n   thus, the PEP and PDP are completely synchronized.
      The Client Handle\n   object only needs to be included if the corresponding
      Synchronize\n   State Message originally referenced a specific handle.\n         <Synchronize
      State Complete>  ::= <Common Header>\n                                           [<Client
      Handle>]\n                                           [<Integrity>]\n"
    title: 3.10 Synchronize State Complete (SSC) PEP -> PDP
  title: 3. Message Content
- contents:
  - "4. Common Operation\n   This section describes the typical exchanges between
    remote PDP\n   servers and PEP clients.\n"
  - contents:
    - "4.1 Security and Sequence Number Negotiation\n   COPS message security is negotiated
      once per connection and covers\n   all communication over a particular connection.
      If COPS level\n   security is required, it MUST be negotiated during the initial\n
      \  Client-Open/Client-Accept message exchange specifying a Client-Type\n   of
      zero (which is reserved for connection level security negotiation\n   and connection
      verification).\n   If a PEP is not configured to use COPS security with a PDP
      it will\n   simply send the PDP Client-Open messages for the supported Client-\n
      \  Types as specified in section 4.3 and will not include the Integrity\n   object
      in any COPS messages.\n   Otherwise, security can be initiated by the PEP if
      it sends the PDP a\n   Client-Open message with Client-Type=0 before opening
      any other\n   Client-Type. If the PDP receives a Client-Open with a Client-Type=0\n
      \  after another Client-Type has already been opened successfully it\n   MUST
      return a Client-Close message (for Client-Type=0) to that PEP.\n   This first
      Client-Open message MUST specify a Client-Type of zero and\n   MUST provide
      the PEPID and a COPS Integrity object. This Integrity\n   object will contain
      the initial sequence number the PEP requires the\n   PDP to increment during
      subsequent communication after the initial\n   Client-Open/Client-Accept exchange
      and the Key ID identifying the\n   algorithm and key used to compute the digest.\n
      \  Similarly, if the PDP accepts the PEP's security key and algorithm by\n   validating
      the message digest using the identified key, the PDP MUST\n   send a Client-Accept
      message with a Client-Type of zero to the PEP\n   carrying an Integrity object.
      This Integrity object will contain the\n   initial sequence number the PDP requires
      the PEP to increment during\n   all subsequent communication with the PDP and
      the Key ID identifying\n   the key and algorithm used to compute the digest.\n
      \  If the PEP, from the perspective of a PDP that requires security,\n   fails
      or never performs the security negotiation by not sending an\n   initial Client-Open
      message with a Client-Type=0 including a valid\n   Integrity object, the PDP
      MUST send to the PEP a Client-Close message\n   with a Client-Type=0 specifying
      the appropriate error code.\n   Similarly, if the PDP, from the perspective
      of a PEP that requires\n   security, fails the security negotiation by not sending
      back a\n   Client-Accept message with a Client-Type=0 including a valid\n   Integrity
      object, the PEP MUST send to the PDP a Client-Close message\n   with a Client-Type=0
      specifying the appropriate error code.  Such a\n   Client-Close message need
      not carry an integrity object (as the\n   security negotiation did not yet complete).\n
      \  The security initialization can fail for one of several reasons: 1.\n   The
      side receiving the message requires COPS level security but an\n   Integrity
      object was not provided (Authentication Required error\n   code). 2. A COPS
      Integrity object was provided, but with an\n   unknown/unacceptable C-Type (Unknown
      COPS Object error code\n   specifying the unsupported C-Num and C-Type). 3.
      The message digest\n   or Key ID in the provided Integrity object was incorrect
      and\n   therefore the message could not be authenticated using the identified\n
      \  key (Authentication Failure error code).\n   Once the initial security negotiation
      is complete, the PEP will know\n   what sequence numbers the PDP expects and
      the PDP will know what\n   sequence numbers the PEP expects. ALL COPS messages
      must then include\n   the negotiated Integrity object specifying the correct
      sequence\n   number with the appropriate message digest (including the Client-\n
      \  Open/Client-Accept messages for specific Client-Types). ALL\n   subsequent
      messages from the PDP to the PEP MUST result in an\n   increment of the sequence
      number provided by the PEP in the Integrity\n   object of the initial Client-Open
      message. Likewise, ALL subsequent\n   messages from the PEP to the PDP MUST
      result in an increment of the\n   sequence number provided by the PDP in the
      Integrity object of the\n   initial Client-Accept message. Sequence numbers
      are incremented by\n   one starting with the corresponding initial sequence
      number. For\n   example, if the sequence number specified to the PEP by the
      PDP in\n   the initial Client-Accept was 10, the next message the PEP sends
      to\n   the PDP will provide an Integrity object with a sequence number of\n
      \  11... Then the next message the PEP sends to the PDP will have a\n   sequence
      number of 12 and so on. If any subsequent received message\n   contains the
      wrong sequence number, an unknown Key ID, an invalid\n   message digest, or
      is missing an Integrity object after integrity was\n   negotiated, then a Client-Close
      message MUST be generated for the\n   Client-Type zero containing a valid Integrity
      object and specifying\n   the appropriate error code.  The connection should
      then be dropped.\n"
    title: 4.1 Security and Sequence Number Negotiation
  - contents:
    - "4.2 Key Maintenance\n   Key maintenance is outside the scope of this document,
      but COPS\n   implementations MUST at least provide the ability to manually\n
      \  configure keys and their parameters locally. The key used to produce\n   the
      Integrity object's message digest is identified by the Key ID\n   field. Thus,
      a Key ID parameter is used to identify one of\n   potentially multiple simultaneous
      keys shared by the PEP and PDP. A\n   Key ID is relative to a particular PEPID
      on the PDP or to a\n   particular PDP on the PEP. Each key must also be configured
      with\n   lifetime parameters for the time period within which it is valid as\n
      \  well as an associated cryptographic algorithm parameter specifying\n   the
      algorithm to be used with the key. At a minimum, all COPS\n   implementations
      MUST support the HMAC-MD5-96 [HMAC][MD5]\n   cryptographic algorithm for computing
      a message digest for inclusion\n   in the Keyed Message Digest of the Integrity
      object which is appended\n   to the message.\n   It is good practice to regularly
      change keys. Keys MUST be\n   configurable such that their lifetimes overlap
      allowing smooth\n   transitions between keys. At the midpoint of the lifetime
      overlap\n   between two keys, senders should transition from using the current\n
      \  key to the next/longer-lived key. Meanwhile, receivers simply accept\n   any
      identified key received within its configured lifetime and reject\n   those
      that are not.\n"
    title: 4.2 Key Maintenance
  - contents:
    - "4.3 PEP Initialization\n   Sometime after a connection is established between
      the PEP and a\n   remote PDP and after security is negotiated (if required),
      the PEP\n   will send one or more Client-Open messages to the remote PDP, one
      for\n   each client-type supported by the PEP. The Client-Open message MUST\n
      \  contain the address of the last PDP with which the PEP is still\n   caching
      a complete set of decisions. If no decisions are being cached\n   from the previous
      PDP the LastPDPAddr object MUST NOT be included in\n   the Client-Open message
      (see Section 2.5). Each Client-Open message\n   MUST at least contain the common
      header noting one client-type\n   supported by the PEP. The remote PDP will
      then respond with separate\n   Client-Accept messages for each of the client-types
      requested by the\n   PEP that the PDP can also support.\n   If a specific client-type
      is not supported by the PDP, the PDP will\n   instead respond with a Client-Close
      specifying the client-type is not\n   supported and will possibly suggest an
      alternate PDP address and\n   port. Otherwise, the PDP will send a Client-Accept
      specifying the\n   timer interval between keep-alive messages and the PEP may
      begin\n   issuing requests to the PDP.\n"
    title: 4.3 PEP Initialization
  - contents:
    - "4.4 Outsourcing Operations\n   In the outsourcing scenario, when the PEP receives
      an event that\n   requires a new policy decision it sends a request message
      to the\n   remote PDP. What specifically qualifies as an event for a particular\n
      \  client-type SHOULD be specified in the specific document for that\n   client-type.
      The remote PDP then makes a decision and sends a\n   decision message back to
      the PEP. Since the request is stateful, the\n   request will be remembered,
      or installed, on the remote PDP. The\n   unique handle (unique per TCP connection
      and client-type), specified\n   in both the request and its corresponding decision
      identifies this\n   request state. The PEP is responsible for deleting this
      request state\n   once the request is no longer applicable.\n   The PEP can
      update a previously installed request state by reissuing\n   a request for the
      previously installed handle. The remote PDP is then\n   expected to make new
      decisions and send a decision message back to\n   the PEP. Likewise, the server
      MAY change a previously issued decision\n   on any currently installed request
      state at any time by issuing an\n   unsolicited decision message. At all times
      the PEP module is expected\n   to abide by the PDP's decisions and notify the
      PDP of any state\n   changes.\n"
    title: 4.4 Outsourcing Operations
  - contents:
    - "4.5 Configuration Operations\n   In the configuration scenario, as in the outsourcing
      scenario, the\n   PEP will make a configuration request to the PDP for a particular\n
      \  interface, module, or functionality that may be specified in the\n   named
      client specific information object. The PDP will then send\n   potentially several
      decisions containing named units of configuration\n   data to the PEP. The PEP
      is expected to install and use the\n   configuration locally. A particular named
      configuration can be\n   updated by simply sending additional decision messages
      for the same\n   named configuration. When the PDP no longer wishes the PEP
      to use a\n   piece of configuration information, it will send a decision message\n
      \  specifying the named configuration and a decision flags object with\n   the
      remove configuration command. The PEP SHOULD then proceed to\n   remove the
      corresponding configuration and send a report message to\n   the PDP that specifies
      it has been deleted.\n   In all cases, the PEP MAY notify the remote PDP of
      the local status\n   of an installed state using the report message where appropriate.\n
      \  The report message is to be used to signify when billing can begin,\n   what
      actions were taken, or to produce periodic updates for\n   monitoring and accounting
      purposes depending on the client. This\n   message can carry client specific
      information when needed.\n"
    title: 4.5 Configuration Operations
  - contents:
    - "4.6 Keep-Alive Operations\n   The Keep-Alive message is used to validate the
      connection between the\n   client and server is still functioning even when
      there is no other\n   messaging from the PEP to PDP. The PEP MUST generate a
      COPS KA\n   message randomly within one-fourth to three-fourths the minimum
      KA\n   Timer interval specified by the PDP in the Client-Accept message. On\n
      \  receiving a Keep-Alive message from the PEP, the PDP MUST then\n   respond
      to this Keep-Alive message by echoing a Keep-Alive message\n   back to the PEP.
      If either side does not receive a Keep-Alive or any\n   other COPS message within
      the minimum KA Timer interval from the\n   other, the connection SHOULD be considered
      lost.\n"
    title: 4.6 Keep-Alive Operations
  - contents:
    - "4.7 PEP/PDP Close\n   Finally, Client-Close messages are used to negate the
      effects of the\n   corresponding Client-Open messages, notifying the other side
      that the\n   specified client-type is no longer supported/active. When the PEP\n
      \  detects a lost connection due to a keep-alive timeout condition it\n   SHOULD
      explicitly send a Client-Close message for each opened\n   client-type specifying
      a communications failure error code. Then the\n   PEP MAY proceed to terminate
      the connection to the PDP and attempt to\n   reconnect again or try a backup/alternative
      PDP. When the PDP is\n   shutting down, it SHOULD also explicitly send a Client-Close
      to all\n   connected PEPs for each client-type, perhaps specifying an\n   alternative
      PDP to use instead.\n"
    title: 4.7 PEP/PDP Close
  title: 4. Common Operation
- contents:
  - "5. Security Considerations\n   The COPS protocol provides an Integrity object
    that can achieve\n   authentication, message integrity, and replay prevention.
    All COPS\n   implementations MUST support the COPS Integrity object and its\n
    \  mechanisms as described in this document. To ensure the client (PEP)\n   is
    communicating with the correct policy server (PDP) requires\n   authentication
    of the PEP and PDP using a shared secret, and\n   consistent proof that the connection
    remains valid. The shared secret\n   minimally requires manual configuration of
    keys (identified by a Key\n   ID) shared between the PEP and its PDP. The key
    is used in\n   conjunction with the contents of a COPS message to calculate a\n
    \  message digest that is part of the Integrity object. The Integrity\n   object
    is then used to validate all COPS messages sent over the TCP\n   connection between
    a PEP and PDP.\n   Key maintenance is outside the scope of this document beyond
    the\n   specific requirements discussed in section 4.2. In general, it is\n   good
    practice to regularly change keys to maintain security.\n   Furthermore, it is
    good practice to use localized keys specific to a\n   particular PEP such that
    a stolen PEP will not compromise the\n   security of an entire administrative
    domain.\n   The COPS Integrity object also provides sequence numbers to avoid\n
    \  replay attacks. The PDP chooses the initial sequence number for the\n   PEP
    and the PEP chooses the initial sequence number for the PDP.\n   These initial
    numbers are then incremented with each successive\n   message sent over the connection
    in the corresponding direction. The\n   initial sequence numbers SHOULD be chosen
    such that they are\n   monotonically increasing and never repeat for a particular
    key.\n   Security between the client (PEP) and server (PDP) MAY be provided by\n
    \  IP Security [IPSEC]. In this case, the IPSEC Authentication Header\n   (AH)
    SHOULD be used for the validation of the connection;\n   additionally IPSEC Encapsulation
    Security Payload (ESP) MAY be used\n   to provide both validation and secrecy.\n
    \  Transport Layer Security [TLS] MAY be used for both connection-level\n   validation
    and privacy.\n"
  title: 5. Security Considerations
- contents:
  - "6. IANA Considerations\n   The Client-type identifies the policy client application
    to which a\n   message refers. Client-type values within the range 0x0001-0x3FFF
    are\n   reserved Specification Required status as defined in [IANA-\n   CONSIDERATIONS].
    These values MUST be registered with IANA and their\n   behavior and applicability
    MUST be described in a COPS extension\n   document.\n   Client-type values in
    the range 0x4000 - 0x7FFF are reserved for\n   Private Use as defined in [IANA-CONSIDERATIONS].
    These Client-types\n   are not tracked by IANA and are not to be used in standards
    or\n   general-release products, as their uniqueness cannot be assured.\n   Client-type
    values in the range 0x8000 - 0xFFFF are First Come First\n   Served as defined
    in [IANA-CONSIDERATIONS]. These Client-types are\n   tracked by IANA but do not
    require published documents describing\n   their use. IANA merely assures their
    uniqueness.\n   Objects in the COPS Protocol are identified by their C-Num and
    C-Type\n   values. IETF Consensus as identified in [IANA-CONSIDERATIONS] is\n
    \  required to introduce new values for these numbers and, therefore,\n   new
    objects into the base COPS protocol.\n   Additional Context Object R-Types, Reason-Codes,
    Report-Types,\n   Decision Object Command-Codes/Flags, and Error-Codes MAY be
    defined\n   for use with future Client-types, but such additions require IETF\n
    \  Consensus as defined in [IANA-CONSIDERATIONS].\n   Context Object M-Types,
    Reason Sub-Codes, and Error Sub-codes MAY be\n   defined relative to a particular
    Client-type following the same IANA\n   considerations as their respective Client-type.\n"
  title: 6. IANA Considerations
- contents:
  - "7. References\n   [RSVP]                Braden, R., Zhang, L., Berson, S., Herzog,
    S.\n                         and S. Jamin, \"Resource ReSerVation Protocol\n                         (RSVP)
    Version 1 - Functional Specification\",\n                         RFC 2205, September
    1997.\n   [WRK]                 Yavatkar, R., Pendarakis, D. and R. Guerin, \"A\n
    \                        Framework for Policy-Based Admission Control\",\n                         RFC
    2753, January 2000.\n   [SRVLOC]              Guttman, E., Perkins, C., Veizades,
    J. and M.\n                         Day, \"Service Location Protocol , Version
    2\",\n                         RFC 2608, June 1999.\n   [INSCH]               Shenker,
    S. and  J. Wroclawski, \"General\n                         Characterization Parameters
    for Integrated\n                         Service Network Elements\", RFC 2215,
    September\n                         1997.\n   [IPSEC]               Atkinson,
    R., \"Security Architecture for the\n                         Internet Protocol\",
    RFC 2401, August 1995.\n   [HMAC]                Krawczyk, H., Bellare, M. and
    R. Canetti,\n                         \"HMAC: Keyed-Hashing for Message\n                         Authentication\",
    RFC 2104, February 1997.\n   [MD5]                 Rivest, R., \"The MD5 Message-Digest
    Algorithm\",\n                         RFC 1321, April 1992.\n   [RSVPPR]              Braden,
    R. and L. Zhang, \"Resource ReSerVation\n                         Protocol (RSVP)
    - Version 1 Message Processing\n                         Rules\", RFC 2209, September
    1997.\n   [TLS]                 Dierks T. and C. Allen, \"The TLS Protocol\n                         Version
    1.0\", RFC 2246, January 1999.\n   [IANA]                http://www.isi.edu/in-\n
    \                        notes/iana/assignments/port-numbers\n   [IANA-CONSIDERATIONS]
    Alvestrand, H. and T. Narten, \"Guidelines for\n                         Writing
    an IANA Considerations Section in\n                         RFCs\", BCP 26, RFC
    2434, October 1998.\n"
  title: 7. References
- contents:
  - "8. Author Information and Acknowledgments\n   Special thanks to Andrew Smith
    and Timothy O'Malley our WG Chairs,\n   Raj Yavatkar, Russell Fenger, Fred Baker,
    Laura Cunningham, Roch\n   Guerin, Ping Pan, and Dimitrios Pendarakis for their
    valuable\n   contributions.\n   Jim Boyle\n   Level 3 Communications\n   1025
    Eldorado Boulevard\n   Broomfield, CO 80021\n   Phone: 720.888.1192\n   EMail:
    jboyle@Level3.net\n   Ron Cohen\n   CISCO Systems\n   4 Maskit St.\n   Herzeliya
    Pituach 46766 Israel\n   Phone: +972.9.9700064\n   EMail: ronc@cisco.com\n   David
    Durham\n   Intel\n   2111 NE 25th Avenue\n   Hillsboro, OR 97124\n   Phone: 503.264.6232\n
    \  EMail: David.Durham@intel.com\n   Raju Rajan\n   AT&T Shannon Laboratory\n
    \  180 Park Avenue\n   P.O. Box 971\n   Florham Park, NJ 07932-0971\n   EMail:
    rajan@research.att.com\n   Shai Herzog\n   IPHighway, Inc.\n   55 New York Avenue\n
    \  Framingham, MA 01701\n   Phone: 508.620.1141\n   EMail: herzog@iphighway.com\n
    \  Arun Sastry\n   Cisco Systems\n   4 The Square\n   Stockley Park\n   Uxbridge,
    Middlesex UB11 1BN\n   UK\n   Phone: +44-208-756-8693\n   EMail: asastry@cisco.com\n"
  title: 8. Author Information and Acknowledgments
- contents:
  - "9.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 9.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
