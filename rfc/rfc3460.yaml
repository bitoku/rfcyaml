- title: __initial_text__
  contents:
  - '            Policy Core Information Model (PCIM) Extensions

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a number of changes to the Policy Core\n\
    \   Information Model (PCIM, RFC 3060).  Two types of changes are\n   included.\
    \  First, several completely new elements are introduced, for\n   example, classes\
    \ for header filtering, that extend PCIM into areas\n   that it did not previously\
    \ cover.  Second, there are cases where\n   elements of PCIM (for example, policy\
    \ rule priorities) are\n   deprecated, and replacement elements are defined (in\
    \ this case,\n   priorities tied to associations that refer to policy rules).\
    \  Both\n   types of changes are done in such a way that, to the extent possible,\n\
    \   interoperability with implementations of the original PCIM model is\n   preserved.\
    \  This document updates RFC 3060.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n           3.2.2. Additional Associations and Additional Reusable\n\
    \           3.2.5. CompoundPolicyConditions and\n           3.2.6. Variables and\
    \ Values................................9\n           3.2.7. Domain-Level Packet\
    \ Filtering.......................9\n           3.2.8. Device-Level Packet Filtering.......................9\n\
    \   4. The Updated Class and Association Class Hierarchies............10\n   5.\
    \ Areas of Extension to PCIM.....................................13\n      5.1.\
    \ Policy Scope..............................................13\n           5.1.1.\
    \ Levels of Abstraction: Domain- and Device-Level\n                  Policies...........................................13\n\
    \           5.1.2. Administrative and Functional Scopes...............14\n   \
    \   5.2. Reusable Policy Elements..................................15\n      5.3.\
    \ Policy Sets...............................................16\n      5.4. Nested\
    \ Policy Rules.......................................16\n           5.4.1. Usage\
    \ Rules for Nested Rules.......................17\n           5.4.2. Motivation.........................................17\n\
    \      5.5. Priorities and Decision Strategies........................18\n   \
    \        5.5.1. Structuring Decision Strategies....................19\n      \
    \     5.5.2. Side Effects.......................................21\n         \
    \  5.5.3. Multiple PolicySet Trees For a Resource............21\n           5.5.4.\
    \ Deterministic Decisions............................22\n      5.6. Policy Roles..............................................23\n\
    \           5.6.1. Comparison of Roles in PCIM with Roles in\n               \
    \   snmpconf...........................................23\n           5.6.2. Addition\
    \ of PolicyRoleCollection to PCIMe..........24\n           5.6.3. Roles for PolicyGroups.............................25\n\
    \      5.7. Compound Policy Conditions and Compound Policy Actions....27\n   \
    \        5.7.1. Compound Policy Conditions.........................27\n      \
    \     5.7.2. Compound Policy Actions............................27\n      5.8.\
    \ Variables and Values......................................28\n           5.8.1.\
    \ Simple Policy Conditions...........................29\n           5.8.2. Using\
    \ Simple Policy Conditions.....................29\n           5.8.3. The Simple\
    \ Condition Operator......................31\n           5.8.4. SimplePolicyActions................................33\n\
    \           5.8.5. Policy Variables...................................35\n   \
    \        5.8.6. Explicitly Bound Policy Variables..................36\n      \
    \     5.8.7. Implicitly Bound Policy Variables..................37\n         \
    \  5.8.8. Structure and Usage of Pre-Defined Variables.......38\n           5.8.9.\
    \ Rationale for Modeling Implicit Variables\n                  as Classes.........................................39\n\
    \           5.8.10. Policy Values.....................................40\n   \
    \   5.9. Packet Filtering..........................................41\n      \
    \     5.9.1. Domain-Level Packet Filters........................41\n         \
    \  5.9.2. Device-Level Packet Filters........................42\n      5.10. Conformance\
    \ to PCIM and PCIMe............................43\n   6. Class Definitions..............................................44\n\
    \      6.1. The Abstract Class \"PolicySet\"............................44\n \
    \     6.2. Update PCIM's Class \"PolicyGroup\".........................45\n  \
    \    6.3. Update PCIM's Class \"PolicyRule\"..........................45\n   \
    \   6.4. The Class \"SimplePolicyCondition\".........................46\n    \
    \  6.5. The Class \"CompoundPolicyCondition\".......................47\n     \
    \ 6.6. The Class \"CompoundFilterCondition\".......................47\n      6.7.\
    \ The Class \"SimplePolicyAction\"............................48\n      6.8. The\
    \ Class \"CompoundPolicyAction\"..........................48\n      6.9. The Abstract\
    \ Class \"PolicyVariable\".......................50\n      6.10. The Class \"\
    PolicyExplicitVariable\".......................50\n           6.10.1. The Single-Valued\
    \ Property \"ModelClass\"...........51\n           6.10.2. The Single-Valued Property\
    \ ModelProperty..........51\n      6.11. The Abstract Class \"PolicyImplicitVariable\"\
    ..............51\n           6.11.1. The Multi-Valued Property \"ValueTypes\"\
    ............52\n      6.12. Subclasses of \"PolicyImplicitVariable\" Specified\n\
    \            in PCIMe.................................................52\n   \
    \        6.12.1. The Class \"PolicySourceIPv4Variable\"..............52\n    \
    \       6.12.2. The Class \"PolicySourceIPv6Variable\"..............52\n     \
    \      6.12.3. The Class \"PolicyDestinationIPv4Variable\".........53\n      \
    \     6.12.4. The Class \"PolicyDestinationIPv6Variable\".........53\n       \
    \    6.12.5. The Class \"PolicySourcePortVariable\"..............54\n        \
    \   6.12.6. The Class \"PolicyDestinationPortVariable\".........54\n         \
    \  6.12.7. The Class \"PolicyIPProtocolVariable\"..............54\n          \
    \ 6.12.8. The Class \"PolicyIPVersionVariable\"...............55\n           6.12.9.\
    \ The Class \"PolicyIPToSVariable\"...................55\n           6.12.10.\
    \ The Class \"PolicyDSCPVariable\"...................55\n           6.12.11. The\
    \ Class \"PolicyFlowIdVariable\".................56\n           6.12.12. The Class\
    \ \"PolicySourceMACVariable\"..............56\n           6.12.13. The Class \"\
    PolicyDestinationMACVariable\".........56\n           6.12.14. The Class \"PolicyVLANVariable\"\
    ...................56\n           6.12.15. The Class \"PolicyCoSVariable\"....................57\n\
    \           6.12.16. The Class \"PolicyEthertypeVariable\"..............57\n \
    \          6.12.17. The Class \"PolicySourceSAPVariable\"..............57\n  \
    \         6.12.18. The Class \"PolicyDestinationSAPVariable\".........58\n   \
    \        6.12.19. The Class \"PolicySNAPOUIVariable\"................58\n    \
    \       6.12.20. The Class \"PolicySNAPTypeVariable\"...............59\n     \
    \      6.12.21. The Class \"PolicyFlowDirectionVariable\"..........59\n      6.13.\
    \ The Abstract Class \"PolicyValue\".........................59\n      6.14. Subclasses\
    \ of \"PolicyValue\" Specified in PCIMe...........60\n           6.14.1. The Class\
    \ \"PolicyIPv4AddrValue\"...................60\n           6.14.2. The Class \"\
    PolicyIPv6AddrValue....................61\n           6.14.3. The Class \"PolicyMACAddrValue\"\
    ....................62\n           6.14.4. The Class \"PolicyStringValue\".....................63\n\
    \           6.14.5. The Class \"PolicyBitStringValue\"..................63\n \
    \          6.14.6. The Class \"PolicyIntegerValue\"....................64\n  \
    \         6.14.7. The Class \"PolicyBooleanValue\"....................65\n   \
    \   6.15. The Class \"PolicyRoleCollection\".........................65\n    \
    \       6.15.1. The Single-Valued Property \"PolicyRole\"...........66\n     \
    \      6.16. The Class \"ReusablePolicyContainer\".................66\n      6.17.\
    \ Deprecate PCIM's Class \"PolicyRepository\"................66\n      6.18. The\
    \ Abstract Class \"FilterEntryBase\".....................67\n      6.19. The Class\
    \ \"IpHeadersFilter\"..............................67\n           6.19.1. The\
    \ Property HdrIpVersion.........................68\n           6.19.2. The Property\
    \ HdrSrcAddress........................68\n           6.19.3. The Property HdrSrcAddressEndOfRange..............68\n\
    \           6.19.4. The Property HdrSrcMask...........................69\n   \
    \        6.19.5. The Property HdrDestAddress.......................69\n      \
    \     6.19.6. The Property HdrDestAddressEndOfRange.............69\n         \
    \  6.19.7. The Property HdrDestMask..........................70\n           6.19.8.\
    \ The Property HdrProtocolID........................70\n           6.19.9. The\
    \ Property HdrSrcPortStart......................70\n           6.19.10. The Property\
    \ HdrSrcPortEnd.......................70\n           6.19.11. The Property HdrDestPortStart....................71\n\
    \           6.19.12. The Property HdrDestPortEnd......................71\n   \
    \        6.19.13. The Property HdrDSCP.............................72\n      \
    \     6.19.14. The Property HdrFlowLabel.................... ...72\n      6.20.\
    \ The Class \"8021Filter\"...................................72\n           6.20.1.\
    \ The Property 8021HdrSrcMACAddr....................73\n           6.20.2. The\
    \ Property 8021HdrSrcMACMask....................73\n           6.20.3. The Property\
    \ 8021HdrDestMACAddr...................73\n           6.20.4. The Property 8021HdrDestMACMask...................73\n\
    \           6.20.5. The Property 8021HdrProtocolID....................74\n   \
    \        6.20.6. The Property 8021HdrPriorityValue.................74\n      \
    \     6.20.7. The Property 8021HdrVLANID........................74\n      6.21.\
    \ The Class FilterList.....................................74\n           6.21.1.\
    \ The Property Direction............................75\n   7. Association and\
    \ Aggregation Definitions........................75\n      7.1. The Aggregation\
    \ \"PolicySetComponent\"......................75\n      7.2. Deprecate PCIM's\
    \ Aggregation \"PolicyGroupInPolicyGroup\"...76\n      7.3. Deprecate PCIM's Aggregation\
    \ \"PolicyRuleInPolicyGroup\"....76\n      7.4. The Abstract Association \"PolicySetInSystem\"\
    ..............77\n      7.5. Update PCIM's Weak Association \"PolicyGroupInSystem\"\
    ......77\n      7.6. Update PCIM's Weak Association \"PolicyRuleInSystem\".......78\n\
    \      7.7. The Abstract Aggregation \"PolicyConditionStructure\".......79\n \
    \     7.8. Update PCIM's Aggregation \"PolicyConditionInPolicyRule\"...79\n  \
    \    7.9. The Aggregation \"PolicyConditionInPolicyCondition\"........79\n   \
    \   7.10. The Abstract Aggregation \"PolicyActionStructure\".........80\n    \
    \  7.11. Update PCIM's Aggregation \"PolicyActionInPolicyRule\".....80\n     \
    \ 7.12. The Aggregation \"PolicyActionInPolicyAction\".............80\n      7.13.\
    \ The Aggregation \"PolicyVariableInSimplePolicyCondition\"..80\n      7.14. The\
    \ Aggregation \"PolicyValueInSimplePolicyCondition\".....81\n      7.15. The Aggregation\
    \ \"PolicyVariableInSimplePolicyAction\".....82\n      7.16. The Aggregation \"\
    PolicyValueInSimplePolicyAction\"........83\n      7.17. The Association \"ReusablePolicy\"\
    .........................83\n      7.18. Deprecate PCIM's \"PolicyConditionInPolicyRepository\"\
    .....84\n      7.19. Deprecate PCIM's \"PolicyActionInPolicyRepository\"........84\n\
    \      7.20. The Association ExpectedPolicyValuesForVariable..........84\n   \
    \   7.21. The Aggregation \"ContainedDomain\"........................85\n    \
    \  7.22. Deprecate PCIM's \"PolicyRepositoryInPolicyRepository\"....86\n     \
    \ 7.23. The Aggregation \"EntriesInFilterList\"....................86\n      \
    \     7.23.1. The Reference GroupComponent......................86\n         \
    \  7.23.2. The Reference PartComponent.......................87\n           7.23.3.\
    \ The Property EntrySequence........................87\n      7.24. The Aggregation\
    \ \"ElementInPolicyRoleCollection\"..........87\n      7.25. The Weak Association\
    \ \"PolicyRoleCollectionInSystem\"......87\n   8. Intellectual Property..........................................88\n\
    \   9.  Acknowledgements..............................................89\n   10.\
    \ Contributors..................................................89\n   11. Security\
    \ Considerations.......................................91\n   12. Normative References..........................................91\n\
    \   13. Informative References........................................91\n   Author's\
    \ Address..................................................92\n   Full Copyright\
    \ Statement..........................................93\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This document specifies a number of changes to the Policy\
    \ Core\n   Information Model (PCIM), RFC 3060 [1].  Two types of changes are\n\
    \   included.  First, several completely new elements are introduced, for\n  \
    \ example, classes for header filtering, that extend PCIM into areas\n   that\
    \ it did not previously cover.  Second, there are cases where\n   elements of\
    \ PCIM (for example, policy rule priorities) are\n   deprecated, and replacement\
    \ elements are defined (in this case,\n   priorities tied to associations that\
    \ refer to policy rules).  Both\n   types of changes are done in such a way that,\
    \ to the extent possible,\n   interoperability with implementations of the original\
    \ PCIM model is\n   preserved.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in BCP 14, RFC 2119 [8].\n"
- title: 2. Changes since RFC 3060
  contents:
  - "2. Changes since RFC 3060\n   Section 3.2 contains a short discussion of the\
    \ changes that this\n   document makes to the RFC 3060 information model.  Here\
    \ is a very\n   brief list of the changes:\n   1. Deprecate and replace PolicyRepository\
    \ and its associations.\n   2. Clarify and expand the ways that PolicyRules and\
    \ PolicyGroups are\n      aggregated.\n   3. Change how prioritization for PolicyRules\
    \ is represented, and\n      introduce administrator-specified decision strategies\
    \ for rule\n      evaluation.\n   4. Expand the role of PolicyRoles, and introduce\
    \ a means of\n      associating a PolicyRole with a resource.\n   5. Introduce\
    \ compound policy conditions and compound policy actions\n      into the model.\n\
    \   6. Introduce variables and values into the model.\n   7. Introduce variable\
    \ and value subclasses for packet-header\n      filtering.\n   8. Introduce classes\
    \ for device-level packet-header filtering.\n"
- title: 3. Overview of the Changes
  contents:
  - '3. Overview of the Changes

    '
- title: 3.1. How to Change an Information Model
  contents:
  - "3.1. How to Change an Information Model\n   The Policy Core Information Model\
    \ is closely aligned with the DMTF's\n   CIM Core Policy model.  Since there is\
    \ no separately documented set\n   of rules for specifying IETF information models\
    \ such as PCIM, it is\n   reasonable to look to the CIM specifications for guidance\
    \ on how to\n   modify and extend the model.  Among the CIM rules for changing\
    \ an\n   information model are the following.  Note that everything said here\n\
    \   about \"classes\" applies to association classes (including\n   aggregations)\
    \ as well as to non- association classes.\n   o  Properties may be added to existing\
    \ classes.\n   o  Classes, and individual properties, may be marked as DEPRECATED.\n\
    \      If there is a replacement feature for the deprecated class or\n      property,\
    \ it is identified explicitly.  Otherwise the notation \"No\n      value\" is\
    \ used.  In this document, the notation \"DEPRECATED FOR\n      <feature-name>\"\
    \ is used to indicate that a feature has been\n      deprecated, and to identify\
    \ its replacement feature.\n   o  Classes may be inserted into the inheritance\
    \ hierarchy above\n      existing classes, and properties from the existing classes\
    \ may\n      then be \"pulled up\" into the new classes.  The net effect is that\n\
    \      the existing classes have exactly the same properties they had\n      before,\
    \ but the properties are inherited rather than defined\n      explicitly in the\
    \ classes.\n   o  New subclasses may be defined below existing classes.\n"
- title: 3.2. List of Changes to the Model
  contents:
  - "3.2. List of Changes to the Model\n   The following subsections provide a very\
    \ brief overview of the\n   changes to PCIM defined in PCIMe.  In several cases,\
    \ the origin of\n   the change is noted, as QPIM [11], ICPM [12], or QDDIM [15].\n"
- title: 3.2.1. Changes to PolicyRepository
  contents:
  - "3.2.1. Changes to PolicyRepository\n   Because of the potential for confusion\
    \ with the Policy Framework\n   component Policy Repository (from the four-box\
    \ picture: Policy\n   Management Tool, Policy Repository, PDP, PEP), \"PolicyRepository\"\
    \ is\n   a bad name for the PCIM class representing a container of reusable\n\
    \   policy elements.  Thus the class PolicyRepository is being replaced\n   with\
    \ the class ReusablePolicyContainer.  To accomplish this change,\n   it is necessary\
    \ to deprecate the PCIM class PolicyRepository and its\n   three associations,\
    \ and replace them with a new class\n   ReusablePolicyContainer and new associations.\
    \  As a separate change,\n   the associations for ReusablePolicyContainer are\
    \ being broadened, to\n   allow a ReusablePolicyContainer to contain any reusable\
    \ policy\n   elements.  In PCIM, the only associations defined for a\n   PolicyRepository\
    \ were for it to contain reusable policy conditions\n   and policy actions.\n"
- title: 3.2.2. Additional Associations and Additional Reusable Elements
  contents:
  - "3.2.2. Additional Associations and Additional Reusable Elements\n   The PolicyRuleInPolicyRule\
    \ and PolicyGroupInPolicyRule aggregations\n   have, in effect, been imported\
    \ from QPIM.  (\"In effect\" because these\n   two aggregations, as well as PCIM's\
    \ two aggregations\n   PolicyGroupInPolicyGroup and PolicyRuleInPolicyGroup, are\
    \ all being\n   combined into a single aggregation PolicySetComponent.)  These\n\
    \   aggregations make it possible to define larger \"chunks\" of reusable\n  \
    \ policy to place in a ReusablePolicyContainer.  These aggregations\n   also introduce\
    \ new semantics representing the contextual implications\n   of having one PolicyRule\
    \ executing within the scope of another\n   PolicyRule.\n"
- title: 3.2.3. Priorities and Decision Strategies
  contents:
  - "3.2.3. Priorities and Decision Strategies\n   Drawing from both QPIM and ICPM,\
    \ the Priority property has been\n   deprecated in PolicyRule, and placed instead\
    \ on the aggregation\n   PolicySetComponent.  The QPIM rules for resolving relative\
    \ priorities\n   across nested PolicyGroups and PolicyRules have been incorporated\n\
    \   into PCIMe as well.  With the removal of the Priority property from\n   PolicyRule,\
    \ a new modeling dependency is introduced.  In order to\n   prioritize a PolicyRule/PolicyGroup\
    \ relative to other\n   PolicyRules/PolicyGroups, the elements being prioritized\
    \ must all\n   reside in one of three places: in a common PolicyGroup, in a common\n\
    \   PolicyRule, or in a common System.\n   In the absence of any clear, general\
    \ criterion for detecting policy\n   conflicts, the PCIM restriction stating that\
    \ priorities are relevant\n   only in the case of conflicts is being removed.\
    \  In its place, a\n   PolicyDecisionStrategy property has been added to the PolicyGroup\
    \ and\n   PolicyRule classes.  This property allows policy administrator to\n\
    \   select one of two behaviors with respect to rule evaluation: either\n   perform\
    \ the actions for all PolicyRules whose conditions evaluate to\n   TRUE, or perform\
    \ the actions only for the highest-priority PolicyRule\n   whose conditions evaluate\
    \ to TRUE.  (This is accomplished by placing\n   the PolicyDecisionStrategy property\
    \ in an abstract class PolicySet,\n   from which PolicyGroup and PolicyRule are\
    \ derived.)  The QPIM rules\n   for applying decision strategies to a nested set\
    \ of PolicyGroups and\n   PolicyRules have also been imported.\n"
- title: 3.2.4. Policy Roles
  contents:
  - "3.2.4. Policy Roles\n   The concept of policy roles is added to PolicyGroups\
    \ (being present\n   already in the PolicyRule class).  This is accomplished via\
    \ a new\n   superclass for both PolicyRules and PolicyGroups - PolicySet.  For\n\
    \   nested PolicyRules and PolicyGroups, any roles associated with the\n   outer\
    \ rule or group are automatically \"inherited\" by the nested one.\n   Additional\
    \ roles may be added at the level of a nested rule or group.\n   It was also observed\
    \ that there is no mechanism in PCIM for assigning\n   roles to resources.  For\
    \ example, while it is possible in PCIM to\n   associate a PolicyRule with the\
    \ role \"FrameRelay&&WAN\", there is no\n   way to indicate which interfaces match\
    \ this criterion.  A new\n   PolicyRoleCollection class has been defined in PCIMe,\
    \ representing\n   the collection of resources associated with a particular role.\
    \  The\n   linkage between a PolicyRule or PolicyGroup and a set of resources\
    \ is\n   then represented by an instance of PolicyRoleCollection.  Equivalent\n\
    \   values should be defined in the PolicyRoles property of PolicyRules\n   and\
    \ PolicyGroups, and in the PolicyRole property in\n   PolicyRoleCollection.\n"
- title: 3.2.5. CompoundPolicyConditions and CompoundPolicyActions
  contents:
  - "3.2.5. CompoundPolicyConditions and CompoundPolicyActions\n   The concept of\
    \ a CompoundPolicyCondition has also been imported into\n   PCIMe from QPIM, and\
    \ broadened to include a parallel\n   CompoundPolicyAction.  In both cases the\
    \ idea is to create reusable\n   \"chunks\" of policy that can exist as named\
    \ elements in a\n   ReusablePolicyContainer.  The \"Compound\" classes and their\n\
    \   associations incorporate the condition and action semantics that PCIM\n  \
    \ defined at the PolicyRule level: DNF/CNF for conditions, and ordering\n   for\
    \ actions.\n   Compound conditions and actions are defined to work with any\n\
    \   component conditions and actions.  In other words, while the\n   components\
    \ may be instances, respectively, of SimplePolicyCondition\n   and SimplePolicyAction\
    \ (discussed immediately below), they need not\n   be.\n"
- title: 3.2.6. Variables and Values
  contents:
  - "3.2.6. Variables and Values\n   The SimplePolicyCondition / PolicyVariable /\
    \ PolicyValue structure\n   has been imported into PCIMe from QPIM.  A list of\
    \ PCIMe-level\n   variables is defined, as well as a list of PCIMe-level values.\
    \  Other\n   variables and values may, if necessary, be defined in submodels of\n\
    \   PCIMe.  For example, QPIM defines a set of implicit variables\n   corresponding\
    \ to fields in RSVP flows.\n   A corresponding SimplePolicyAction / PolicyVariable\
    \ / PolicyValue\n   structure is also defined.  While the semantics of a\n   SimplePolicyCondition\
    \ are \"variable matches value\", a\n   SimplePolicyAction has the semantics \"\
    set variable to value\".\n"
- title: 3.2.7. Domain-Level Packet Filtering
  contents:
  - "3.2.7. Domain-Level Packet Filtering\n   For packet filtering specified at the\
    \ domain level, a set of\n   PolicyVariables and PolicyValues are defined, corresponding\
    \ to the\n   fields in an IP packet header plus the most common Layer 2 frame\n\
    \   header fields.  It is expected that domain-level policy conditions\n   that\
    \ filter on these header fields will be expressed in terms of\n   CompoundPolicyConditions\
    \ built up from SimplePolicyConditions that\n   use these variables and values.\
    \  An additional PolicyVariable,\n   PacketDirection, is also defined, to indicate\
    \ whether a packet being\n   filtered is traveling inbound or outbound on an interface.\n"
- title: 3.2.8. Device-Level Packet Filtering
  contents:
  - "3.2.8. Device-Level Packet Filtering\n   For packet filtering expressed at the\
    \ device level, including the\n   packet classifier filters modeled in QDDIM,\
    \ the variables and values\n   discussed in Section 3.2.7 need not be used.  Filter\
    \ classes derived\n   from the CIM FilterEntryBase class hierarchy are available\
    \ for use in\n   these contexts.  These latter classes have two important differences\n\
    \   from the domain-level classes:\n   o  They support specification of filters\
    \ for all of the fields in a\n      particular protocol header in a single object\
    \ instance.  With the\n      domain-level classes, separate instances are needed\
    \ for each\n      header field.\n   o  They provide native representations for\
    \ the filter values, as\n      opposed to the string representation used by the\
    \ domain-level\n      classes.\n   Device-level filter classes for the IP-related\
    \ headers (IP, UDP, and\n   TCP) and the 802 MAC headers are defined, respectively,\
    \ in Sections\n   6.19 and 6.20.\n"
- title: 4. The Updated Class and Association Class Hierarchies
  contents:
  - "4. The Updated Class and Association Class Hierarchies\n   The following figure\
    \ shows the class inheritance hierarchy for PCIMe.\n   Changes from the PCIM hierarchy\
    \ are noted parenthetically.\n   ManagedElement (abstract)\n      |\n      +--Policy\
    \ (abstract)\n      |  |\n      |  +---PolicySet (abstract -- new - 5.3)\n   \
    \   |  |   |\n      |  |   +---PolicyGroup (moved - 5.3)\n      |  |   |\n   \
    \   |  |   +---PolicyRule (moved - 5.3)\n      |  |\n      |  +---PolicyCondition\
    \ (abstract)\n      |  |   |\n      |  |   +---PolicyTimePeriodCondition\n   \
    \   |  |   |\n      |  |   +---VendorPolicyCondition\n      |  |   |\n      |\
    \  |   +---SimplePolicyCondition (new - 5.8.1)\n      |  |   |\n      |  |   +---CompoundPolicyCondition\
    \ (new - 5.7.1)\n      |  |       |\n      |  |       +---CompoundFilterCondition\
    \ (new - 5.9)\n      |  |\n      |  +---PolicyAction (abstract)\n      |  |  \
    \ |\n      |  |   +---VendorPolicyAction\n      |  |   |\n      |  |   +---SimplePolicyAction\
    \ (new - 5.8.4)\n      |  |   |\n      |  |   +---CompoundPolicyAction (new -\
    \ 5.7.2)\n      |  |\n      |  +---PolicyVariable (abstract -- new - 5.8.5)\n\
    \      |  |   |\n      |  |   +---PolicyExplicitVariable (new - 5.8.6)\n     \
    \ |  |   |\n      |  |   +---PolicyImplicitVariable (abstract -- new - 5.8.7)\n\
    \      |  |       |\n      |  |       +---(subtree of more specific classes --\
    \ new - 6.12)\n      |  |\n      |  +---PolicyValue (abstract -- new - 5.8.10)\n\
    \      |      |\n      |      +---(subtree of more specific classes -- new - 6.14)\n\
    \      |\n      +--Collection (abstract -- newly referenced)\n      |  |\n   \
    \   |  +--PolicyRoleCollection (new - 5.6.2)\n   ManagedElement(abstract)\n  \
    \    |\n      +--ManagedSystemElement (abstract)\n         |\n         +--LogicalElement\
    \ (abstract)\n            |\n            +--System (abstract)\n            | \
    \ |\n            |  +--AdminDomain (abstract)\n            |     |\n         \
    \   |     +---ReusablePolicyContainer (new - 5.2)\n            |     |\n     \
    \       |     +---PolicyRepository (deprecated - 5.2)\n            |\n       \
    \     +--FilterEntryBase (abstract -- new - 6.18)\n            |  |\n        \
    \    |  +--IpHeadersFilter (new - 6.19)\n            |  |\n            |  +--8021Filter\
    \ (new - 6.20)\n            |\n            +--FilterList (new - 6.21)\n   Figure\
    \ 1.    Class Inheritance Hierarchy for PCIMe\n   The following figure shows the\
    \ association class hierarchy for PCIMe.\n   As before, changes from PCIM are\
    \ noted parenthetically.\n   [unrooted]\n      |\n      +---PolicyComponent (abstract)\n\
    \      |   |\n      |   +---PolicySetComponent (new - 5.3)\n      |   |\n    \
    \  |   +---PolicyGroupInPolicyGroup (deprecated - 5.3)\n      |   |\n      | \
    \  +---PolicyRuleInPolicyGroup (deprecated - 5.3)\n      |   |\n      |   +---PolicyConditionStructure\
    \ (abstract -- new - 5.7.1)\n      |   |    |\n      |   |    +---PolicyConditionInPolicyRule\
    \  (moved - 5.7.1)\n      |   |    |\n      |   |    +---PolicyConditionInPolicyCondition\
    \ (new - 5.7.1)\n      |   |\n      |   +---PolicyRuleValidityPeriod\n      |\
    \   |\n      |   +---PolicyActionStructure (abstract -- new - 5.7.2)\n      |\
    \   |    |\n      |   |    +---PolicyActionInPolicyRule  (moved - 5.7.2)\n   \
    \   |   |    |\n      |   |    +---PolicyActionInPolicyAction (new - 5.7.2)\n\
    \      |   |\n      |   +---PolicyVariableInSimplePolicyCondition (new - 5.8.2)\n\
    \      |   |\n      |   +---PolicyValueInSimplePolicyCondition (new - 5.8.2)\n\
    \      |   |\n      |   +---PolicyVariableInSimplePolicyAction (new - 5.8.4)\n\
    \      |   |\n      |   +---PolicyValueInSimplePolicyAction (new - 5.8.4)\n  \
    \ [unrooted]\n      |\n      +---Dependency (abstract)\n      |   |\n      | \
    \  +---PolicyInSystem (abstract)\n      |   |   |\n      |   |   +---PolicySetInSystem\
    \ (abstract, new - 5.3)\n      |   |   |   |\n      |   |   |   +---PolicyGroupInSystem\n\
    \      |   |   |   |\n      |   |   |   +---PolicyRuleInSystem\n      |   |  \
    \ |\n      |   |   +---ReusablePolicy (new - 5.2)\n      |   |   |\n      |  \
    \ |   +---PolicyConditionInPolicyRepository (deprecated - 5.2)\n      |   |  \
    \ |\n      |   |   +---PolicyActionInPolicyRepository (deprecated - 5.2)\n   \
    \   |   |\n      |   +---ExpectedPolicyValuesForVariable (new - 5.8)\n      |\
    \   |\n      |   +---PolicyRoleCollectionInSystem (new - 5.6.2)\n      |\n   \
    \   +---Component (abstract)\n      |   |\n      |   +---SystemComponent\n   \
    \   |   |   |\n      |   |   +---ContainedDomain (new - 5.2)\n      |   |   |\n\
    \      |   |   +---PolicyRepositoryInPolicyRepository (deprecated - 5.2)\n   \
    \   |   |\n      |   +---EntriesInFilterList (new - 7.23)\n      |\n      +---MemberOfCollection\
    \ (newly referenced)\n          |\n          +--- ElementInPolicyRoleCollection\
    \ (new - 5.6.2)\n   Figure 2.    Association Class Inheritance Hierarchy for PCIMe\n\
    \   In addition to these changes that show up at the class and\n   association\
    \ class level, there are other changes from PCIM involving\n   individual class\
    \ properties.  In some cases new properties are\n   introduced into existing classes,\
    \ and in other cases existing\n   properties are deprecated (without deprecating\
    \ the classes that\n   contain them).\n"
- title: 5. Areas of Extension to PCIM
  contents:
  - "5. Areas of Extension to PCIM\n   The following subsections describe each of\
    \ the areas for which PCIM\n   extensions are being defined.\n"
- title: 5.1. Policy Scope
  contents:
  - "5.1. Policy Scope\n   Policy scopes may be thought of in two dimensions: 1) the\
    \ level of\n   abstraction of the policy specification and 2) the applicability\
    \ of\n   policies to a set of managed resources.\n"
- title: '5.1.1. Levels of Abstraction: Domain- and Device-Level Policies'
  contents:
  - "5.1.1. Levels of Abstraction: Domain- and Device-Level Policies\n   Policies\
    \ vary in level of abstraction, from the business-level\n   expression of service\
    \ level agreements (SLAs) to the specification of\n   a set of rules that apply\
    \ to devices in a network.  Those latter\n   policies can, themselves, be classified\
    \ into at least two groups:\n   those policies consumed by a Policy Decision Point\
    \ (PDP) that specify\n   the rules for an administrative and functional domain,\
    \ and those\n   policies consumed by a Policy Enforcement Point (PEP) that specify\n\
    \   the device-specific rules for a functional domain.  The higher-level\n   rules\
    \ consumed by a PDP, called domain-level policies, may have late\n   binding variables\
    \ unspecified, or specified by a classification,\n   whereas the device-level\
    \ rules are likely to have fewer unresolved\n   bindings.\n   There is a relationship\
    \ between these levels of policy specification\n   that is out of scope for this\
    \ standards effort, but that is necessary\n   in the development and deployment\
    \ of a usable policy-based\n   configuration system.  An SLA-level policy transformation\
    \ to the\n   domain-level policy may be thought of as analogous to a visual\n\
    \   builder that takes human input and develops a programmatic rule\n   specification.\
    \  The relationship between the domain-level policy and\n   the device-level policy\
    \ may be thought of as analogous to that of a\n   compiler and linkage editor\
    \ that translates the rules into specific\n   instructions that can be executed\
    \ on a specific type of platform.\n   PCIM and PCIMe may be used to specify rules\
    \ at any and all of these\n   levels of abstraction.  However, at different levels\
    \ of abstraction,\n   different mechanisms may be more or less appropriate.\n"
- title: 5.1.2. Administrative and Functional Scopes
  contents:
  - "5.1.2. Administrative and Functional Scopes\n   Administrative scopes for policy\
    \ are represented in PCIM and in these\n   extensions to PCIM as System subclass\
    \ instances.  Typically, a\n   domain-level policy would be scoped by an AdminDomain\
    \ instance (or by\n   a hierarchy of AdminDomain instances) whereas a device-level\
    \ policy\n   might be scoped by a System instance that represents the PEP (e.g.,\n\
    \   an instance of ComputerSystem, see CIM [2]).  In addition to\n   collecting\
    \ policies into an administrative domain, these System\n   classes may also aggregate\
    \ the resources to which the policies apply.\n   Functional scopes (sometimes\
    \ referred to as functional domains) are\n   generally defined by the submodels\
    \ derived from PCIM and PCIMe, and\n   correspond to the service or services to\
    \ which the policies apply.\n   So, for example, Quality of Service may be thought\
    \ of as a functional\n   scope, or Diffserv and Intserv may each be thought of\
    \ as functional\n   scopes.  These scoping decisions are represented by the structure\
    \ of\n   the submodels derived from PCIM and PCIMe, and may be reflected in\n\
    \   the number and types of PEP policy client(s), services, and the\n   interaction\
    \ between policies.  Policies in different functional\n   scopes are organized\
    \ into disjoint sets of policy rules.  Different\n   functional domains may share\
    \ some roles, some conditions, and even\n   some actions.  The rules from different\
    \ functional domains may even\n   be enforced at the same managed resource, but\
    \ for the purposes of\n   policy evaluation they are separate.  See section 5.5.3\
    \ for more\n   information.\n   The functional scopes MAY be reflected in administrative\
    \ scopes.\n   That is, deployments of policy may have different administrative\n\
    \   scopes for different functional scopes, but there is no requirement\n   to\
    \ do so.\n"
- title: 5.2. Reusable Policy Elements
  contents:
  - "5.2. Reusable Policy Elements\n   In PCIM, a distinction was drawn between reusable\
    \ PolicyConditions\n   and PolicyActions and rule-specific ones.  The PolicyRepository\
    \ class\n   was also defined, to serve as a container for these reusable\n   elements.\
    \  The name \"PolicyRepository\" has proven to be an\n   unfortunate choice for\
    \ the class that serves as a container for\n   reusable policy elements.  This\
    \ term is already used in documents\n   like the Policy Framework, to denote the\
    \ location from which the PDP\n   retrieves all policy specifications, and into\
    \ which the Policy\n   Management Tool places all policy specifications.  Consequently,\
    \ the\n   PolicyRepository class is being deprecated, in favor of a new class\n\
    \   ReusablePolicyContainer.\n   When a class is deprecated, any associations\
    \ that refer to it must\n   also be deprecated.  So replacements are needed for\
    \ the two\n   associations PolicyConditionInPolicyRepository and\n   PolicyActionInPolicyRepository,\
    \ as well as for the aggregation\n   PolicyRepositoryInPolicyRepository.  In addition\
    \ to renaming the\n   PolicyRepository class to ReusablePolicyContainer, however,\
    \ PCIMe is\n   also broadening the types of policy elements that can be reusable.\n\
    \   Consequently, rather than providing one-for-one replacements for the\n   two\
    \ associations, a single higher-level association ReusablePolicy is\n   defined.\
    \  This new association allows any policy element (that is, an\n   instance of\
    \ any subclass of the abstract class Policy) to be placed\n   in a ReusablePolicyContainer.\n\
    \   Summarizing, the following changes in Sections 6 and 7 are the result\n  \
    \ of this item:\n   o  The class ReusablePolicyContainer is defined.\n   o  PCIM's\
    \ PolicyRepository class is deprecated.\n   o  The association ReusablePolicy\
    \ is defined.\n   o  PCIM's PolicyConditionInPolicyRepository association is\n\
    \      deprecated.\n   o  PCIM's PolicyActionInPolicyRepository association is\
    \ deprecated.\n   o  The aggregation ContainedDomain is defined.\n   o  PCIM's\
    \ PolicyRepositoryInPolicyRepository aggregation is\n      deprecated.\n"
- title: 5.3. Policy Sets
  contents:
  - "5.3. Policy Sets\n   A \"policy\" can be thought of as a coherent set of rules\
    \ to\n   administer, manage, and control access to network resources (\"Policy\n\
    \   Terminology\", reference [10]).  The structuring of these coherent\n   sets\
    \ of rules into subsets is enhanced in this document.  In Section\n   5.4, we\
    \ discuss the new options for the nesting of policy rules.\n   A new abstract\
    \ class, PolicySet, is introduced to provide an\n   abstraction for a set of rules.\
    \  It is derived from Policy, and it is\n   inserted into the inheritance hierarchy\
    \ above both PolicyGroup and\n   PolicyRule.  This reflects the additional structural\
    \ flexibility and\n   semantic capability of both subclasses.\n   Two properties\
    \ are defined in PolicySet: PolicyDecisionStrategy and\n   PolicyRoles.  The PolicyDecisionStrategy\
    \ property is included in\n   PolicySet to define the evaluation relationship\
    \ among the rules in\n   the policy set.  See Section 5.5 for more information.\
    \  The\n   PolicyRoles property is included in PolicySet to characterize the\n\
    \   resources to which the PolicySet applies.  See Section 5.6 for more\n   information.\n\
    \   Along with the definition of the PolicySet class, a new concrete\n   aggregation\
    \ class is defined that will also be discussed in the\n   following sections.\
    \  PolicySetComponent is defined as a subclass of\n   PolicyComponent; it provides\
    \ the containment relationship for a\n   PolicySet in a PolicySet.  PolicySetComponent\
    \ replaces the two PCIM\n   aggregations PolicyGroupInPolicyGroup and PolicyRuleInPolicyGroup,\
    \ so\n   these two aggregations are deprecated.\n   A PolicySet's relationship\
    \ to an AdminDomain or other administrative\n   scoping system (for example, a\
    \ ComputerSystem) is represented by the\n   PolicySetInSystem abstract association.\
    \  This new association is\n   derived from PolicyInSystem, and the PolicyGroupInSystem\
    \ and\n   PolicyRuleInSystem associations are now derived from\n   PolicySetInSystem\
    \ instead of directly from PolicyInSystem.  The\n   PolicySetInSystem.Priority\
    \ property is discussed in Section 5.5.3.\n"
- title: 5.4. Nested Policy Rules
  contents:
  - "5.4. Nested Policy Rules\n   As previously discussed, policy is described by\
    \ a set of policy rules\n   that may be grouped into subsets.   In this section\
    \ we introduce the\n   notion of nested rules, or the ability to define rules\
    \ within rules.\n   Nested rules are also called sub-rules, and we use both terms\
    \ in this\n   document interchangeably.  The aggregation PolicySetComponent is\
    \ used\n   to represent the nesting of a policy rule in another policy rule.\n"
- title: 5.4.1. Usage Rules for Nested Rules
  contents:
  - "5.4.1. Usage Rules for Nested Rules\n   The relationship between rules and sub-rules\
    \ is defined as follows:\n   o  The parent rule's condition clause is a condition\
    \ for evaluation\n      of all nested rules; that is, the conditions of the parent\
    \ are\n      logically ANDed to the conditions of the sub-rules.  If the parent\n\
    \      rule's condition clause evaluates to FALSE, sub-rules MAY be\n      skipped\
    \ since they also evaluate to FALSE.\n   o  If the parent rule's condition evaluates\
    \ to TRUE, the set of sub-\n      rules SHALL BE evaluated according to the decision\
    \ strategy and\n      priorities as discussed in Section 5.5.\n   o  If the parent\
    \ rule's condition evaluates to TRUE, the parent\n      rule's set of actions\
    \ is executed BEFORE execution of the sub-\n      rules actions.  The parent rule's\
    \ actions are not to be confused\n      with default actions.  A default action\
    \ is one that is to be\n      executed only if none of the more specific sub-rules\
    \ are executed.\n      If a default action needs to be specified, it needs to\
    \ be defined\n      as an action that is part of a catchall sub-rule associated\
    \ with\n      the parent rule.  The association linking the default action(s)\
    \ in\n      this special sub-rule should have the lowest priority relative to\n\
    \      all other sub-rule associations:\n        if parent-condition then parent\
    \ rule's action\n                   if condA then actA\n                   if\
    \ condB then ActB\n                   if True then default action\n      Such\
    \ a default action functions as a default when FirstMatching\n      decision strategies\
    \ are in effect (see section 5.5).  If\n      AllMatching applies, the \"default\"\
    \ action is always performed.\n   o  Policy rules have a context in which they\
    \ are executed.  The rule\n      engine evaluates and applies the policy rules\
    \ in the context of\n      the managed resource(s) that are identified by the\
    \ policy roles\n      (or by an explicit association).  Submodels MAY add additional\n\
    \      context to policy rules based on rule structure; any such\n      additional\
    \ context is defined by the semantics of the action\n      classes of the submodel.\n"
- title: 5.4.2. Motivation
  contents:
  - "5.4.2. Motivation\n   Rule nesting enhances Policy readability, expressiveness\
    \ and\n   reusability.  The ability to nest policy rules and form sub-rules is\n\
    \   important for manageability and scalability, as it enables complex\n   policy\
    \ rules to be constructed from multiple simpler policy rules.\n   These enhancements\
    \ ease the policy management tools' task, allowing\n   policy rules to be expressed\
    \ in a way closer to how humans think.\n   Although rule nesting can be used to\
    \ suggest optimizations in the way\n   policy rules are evaluated, as discussed\
    \ in section 5.5.2 \"Side\n   Effects,\" nesting does not specify nor does it\
    \ require any particular\n   order of evaluation of conditions.  Optimization\
    \ of rule evaluation\n   can be done in the PDP or in the PEP by dedicated code.\
    \  This is\n   similar to the relation between a high level programming language\n\
    \   like C and machine code.  An optimizer can create a more efficient\n   machine\
    \ code than any optimization done by the programmer within the\n   source code.\
    \  Nevertheless, if the PEP or PDP does not do\n   optimization, the administrator\
    \ writing the policy may be able to\n   influence the evaluation of the policy\
    \ rules for execution using rule\n   nesting.\n   Nested rules are not designed\
    \ for policy repository retrieval\n   optimization.  It is assumed that all rules\
    \ and groups that are\n   assigned to a role are retrieved by the PDP or PEP from\
    \ the policy\n   repository and enforced.  Optimizing the number of rules retrieved\n\
    \   should be done by clever selection of roles.\n"
- title: 5.5. Priorities and Decision Strategies
  contents:
  - "5.5. Priorities and Decision Strategies\n   A \"decision strategy\" is used to\
    \ specify the evaluation method for\n   the policies in a PolicySet.  Two decision\
    \ strategies are defined:\n   \"FirstMatching\" and \"AllMatching.\"  The FirstMatching\
    \ strategy is\n   used to cause the evaluation of the rules in a set such that\
    \ the only\n   actions enforced on a given examination of the PolicySet are those\n\
    \   for the first rule (that is, the rule with the highest priority) that\n  \
    \ has its conditions evaluate to TRUE.  The AllMatching strategy is\n   used to\
    \ cause the evaluation of all rules in a set; for all of the\n   rules whose conditions\
    \ evaluate to TRUE, the actions are enforced.\n   Implementations MUST support\
    \ the FirstMatching decision strategy;\n   implementations MAY support the AllMatching\
    \ decision strategy.\n   As previously discussed, the PolicySet subclasses are\
    \ PolicyGroup and\n   PolicyRule: either subclass may contain PolicySets of either\n\
    \   subclass.  Loops, including the degenerate case of a PolicySet that\n   contains\
    \ itself, are not allowed when PolicySets contain other\n   PolicySets.  The containment\
    \ relationship is specified using the\n   PolicySetComponent aggregation.\n  \
    \ The relative priority within a PolicySet is established by the\n   Priority\
    \ property of the PolicySetComponent aggregation of the\n   contained PolicyGroup\
    \ and PolicyRule instances.  The use of PCIM's\n   PolicyRule.Priority property\
    \ is deprecated in favor of this new\n   property.  The separation of the priority\
    \ property from the rule has\n   two advantages.  First, it generalizes the concept\
    \ of priority, so\n   that it can be used for both groups and rules.  Second,\
    \ it places the\n   priority on the relationship between the parent policy set\
    \ and the\n   subordinate policy group or rule.  The assignment of a priority\
    \ value\n   then becomes much easier, in that the value is used only in\n   relationship\
    \ to other priorities in the same set.\n   Together, the PolicySet.PolicyDecisionStrategy\
    \ and\n   PolicySetComponent.Priority determine the processing for the rules\n\
    \   contained in a PolicySet.  As before, the larger priority value\n   represents\
    \ the higher priority.  Unlike the earlier definition,\n   PolicySetComponent.Priority\
    \ MUST have a unique value when compared\n   with others defined for the same\
    \ aggregating PolicySet.  Thus, the\n   evaluation of rules within a set is deterministically\
    \ specified.\n   For a FirstMatching decision strategy, the first rule (that is,\
    \ the\n   one with the highest priority) in the set that evaluates to True, is\n\
    \   the only rule whose actions are enforced for a particular evaluation\n   pass\
    \ through the PolicySet.\n   For an AllMatching decision strategy, all of the\
    \ matching rules are\n   enforced.  The relative priority of the rules is used\
    \ to determine\n   the order in which the actions are to be executed by the enforcement\n\
    \   point:  the actions of the higher priority rules are executed first.\n   Since\
    \ the actions of higher priority rules are executed first, lower\n   priority\
    \ rules that also match may get the \"last word,\" and thus\n   produce a counter-intuitive\
    \ result.  So, for example, if two rules\n   both evaluate to True, and the higher\
    \ priority rule sets the DSCP to\n   3 and the lower priority rule sets the DSCP\
    \ to 4, the action of the\n   lower priority rule will be executed later and,\
    \ therefore, will\n   \"win,\" in this example, setting the DSCP to 4.  Thus,\
    \ conflicts\n   between rules are resolved by this execution order.\n   An implementation\
    \ of the rule engine need not provide the action\n   sequencing but the actions\
    \ MUST be sequenced by the PEP or PDP on its\n   behalf.  So, for example, the\
    \ rule engine may provide an ordered list\n   of actions to be executed by the\
    \ PEP and any required serialization\n   is then provided by the service configured\
    \ by the rule engine.  See\n   Section 5.5.2 for a discussion of side effects.\n"
- title: 5.5.1. Structuring Decision Strategies
  contents:
  - "5.5.1. Structuring Decision Strategies\n   As discussed in Sections 5.3 and 5.4,\
    \ PolicySet instances may be\n   nested arbitrarily.  For a FirstMatching decision\
    \ strategy on a\n   PolicySet, any contained PolicySet that matches satisfies\
    \ the\n   termination criteria for the FirstMatching strategy.  A PolicySet is\n\
    \   considered to match if it is a PolicyRule and its conditions evaluate\n  \
    \ to True, or if the PolicySet is a PolicyGroup and at least one of its\n   contained\
    \ PolicyGroups or PolicyRules match.  The priority associated\n   with contained\
    \ PolicySets, then, determines when to terminate rule\n   evaluation in the structured\
    \ set of rules.\n   In the example shown in Figure 3, the relative priorities\
    \ for the\n   nested rules, high to low, are 1A, 1B1, 1X2, 1B3, 1C, 1C1, 1X2 and\n\
    \   1C3.  (Note that PolicyRule 1X2 is included in both PolicyGroup 1B\n   and\
    \ PolicyRule 1C, but with different priorities.)  Of course, which\n   rules are\
    \ enforced is also dependent on which rules, if any, match.\n   PolicyGroup 1:\
    \ FirstMatching\n     |\n     +-- Pri=6 -- PolicyRule 1A\n     |\n     +-- Pri=5\
    \ -- PolicyGroup 1B: AllMatching\n     |              |\n     |              +--\
    \ Pri=5 -- PolicyGroup 1B1: AllMatching\n     |              |              |\n\
    \     |              |              +---- etc.\n     |              |\n     |\
    \              +-- Pri=4 -- PolicyRule 1X2\n     |              |\n     |    \
    \          +-- Pri=3 -- PolicyRule 1B3: FirstMatching\n     |                \
    \             |\n     |                             +---- etc.\n     |\n     +--\
    \ Pri=4 -- PolicyRule 1C: FirstMatching\n                    |\n             \
    \       +-- Pri=4 -- PolicyRule 1C1\n                    |\n                 \
    \   +-- Pri=3 -- PolicyRule 1X2\n                    |\n                    +--\
    \ Pri=2 -- PolicyRule 1C3\n   Figure 3.    Nested PolicySets with Different Decision\
    \ Strategies\n   o  Because PolicyGroup 1 has a FirstMatching decision strategy,\
    \ if\n      the conditions of PolicyRule 1A match, its actions are enforced\n\
    \      and the evaluation stops.\n   o  If it does not match, PolicyGroup 1B is\
    \ evaluated using an\n      AllMatching strategy.  Since PolicyGroup 1B1 also\
    \ has an\n      AllMatching strategy all of the rules and groups of rules\n  \
    \    contained in PolicyGroup 1B1 are evaluated and enforced as\n      appropriate.\
    \  PolicyRule 1X2 and PolicyRule 1B3 are also evaluated\n      and enforced as\
    \ appropriate.  If any of the sub-rules in the\n      subtrees of PolicyGroup\
    \ 1B evaluate to True, then PolicyRule 1C is\n      not evaluated because the\
    \ FirstMatching strategy of PolicyGroup 1\n      has been satisfied.\n   o  If\
    \ neither PolicyRule 1A nor PolicyGroup 1B yield a match, then\n      PolicyRule\
    \ 1C is evaluated.  Since it is first matching, rules\n      1C1, 1X2, and 1C3\
    \ are evaluated until the first match, if any.\n"
- title: 5.5.2. Side Effects
  contents:
  - "5.5.2. Side Effects\n   Although evaluation of conditions is sometimes discussed\
    \ as an\n   ordered set of operations, the rule engine need not be implemented\
    \ as\n   a procedural language interpreter.  Any side effects of condition\n \
    \  evaluation or the execution of actions MUST NOT affect the result of\n   the\
    \ evaluation of other conditions evaluated by the rule engine in\n   the same\
    \ evaluation pass.  That is, an implementation of a rule\n   engine MAY evaluate\
    \ all conditions in any order before applying the\n   priority and determining\
    \ which actions are to be executed.\n   So, regardless of how a rule engine is\
    \ implemented, it MUST NOT\n   include any side effects of condition evaluation\
    \ in the evaluation of\n   conditions for either of the decision strategies. \
    \ For both the\n   AllMatching decision strategy and for the nesting of rules\
    \ within\n   rules (either directly or indirectly) where the actions of more than\n\
    \   one rule may be enforced, any side effects of the enforcement of\n   actions\
    \ MUST NOT be included in condition evaluation on the same\n   evaluation pass.\n"
- title: 5.5.3. Multiple PolicySet Trees For a Resource
  contents:
  - "5.5.3. Multiple PolicySet Trees For a Resource\n   As shown in the example in\
    \ Figure 3., PolicySet trees are defined by\n   the PolicySet subclass instances\
    \ and the PolicySetComponent\n   aggregation instances between them.  Each PolicySet\
    \ tree has a\n   defined set of decision strategies and evaluation priorities.\
    \  In\n   section 5.6 we discuss some improvements in the use of PolicyRoles\n\
    \   that cause the parent PolicySet.PolicyRoles to be applied to all\n   contained\
    \ PolicySet instances.  However, a given resource may still\n   have multiple,\
    \ disjoint PolicySet trees regardless of how they are\n   collected.  These top-level\
    \ PolicySet instances are called \"unrooted\"\n   relative to the given resource.\n\
    \   So, a PolicySet instance is defined to be rooted or unrooted in the\n   context\
    \ of a particular managed element; the relationship to the\n   managed element\
    \ is usually established by the policy roles of the\n   PolicySet instance and\
    \ of the managed element (see 5.6 \"Policy\n   Roles\").  A PolicySet instance\
    \ is unrooted in that context if and\n   only if there is no PolicySetComponent\
    \ association to a parent\n   PolicySet that is also related to the same managed\
    \ element.  These\n   PolicySetComponent aggregations are traversed up the tree\
    \ without\n   regard to how a PolicySet instance came to be related with the\n\
    \   ManagedElement.  Figure 4. shows an example where instance A has role\n  \
    \ A, instance B has role B and so on.  In this example, in the context\n   of\
    \ interface X, instances B, and C are unrooted and instances D, E,\n   and F are\
    \ all rooted.  In the context of interface Y, instance A is\n   unrooted and instances\
    \ B, C, D, E and F are all rooted.\n         +---+            +-----------+  \
    \ +-----------+\n         | A |            |   I/F X   |   |   I/F Y   |\n   \
    \      +---+            | has roles |   | has roles |\n          / \\        \
    \     |   B & C   |   |   A & B   |\n         /   \\            +-----------+\
    \   +-----------+\n      +---+ +---+\n      | B | | C |\n      +---+ +---+\n \
    \      / \\     \\\n      /   \\     \\\n   +---+ +---+ +---+\n   | D | | E |\
    \ | F |\n   +---+ +---+ +---+\n   Figure 4.    Unrooted PolicySet Instances\n\
    \   For those cases where there are multiple unrooted PolicySet instances\n  \
    \ that apply to the same managed resource (i.e., not in a common\n   PolicySetComponent\
    \ tree), the decision strategy among these disjoint\n   PolicySet instances is\
    \ the FirstMatching strategy.  The priority used\n   with this FirstMatching strategy\
    \ is defined in the PolicySetInSystem\n   association.  The PolicySetInSystem\
    \ subclass instances are present\n   for all PolicySet instances (it is a required\
    \ association) but the\n   priority is only used as a default for unrooted PolicySet\
    \ instances\n   in a given ManagedElement context.\n   The FirstMatching strategy\
    \ is used among all unrooted PolicySet\n   instances that apply to a given resource\
    \ for a given functional\n   domain.  So, for example, the PolicySet instances\
    \ that are used for\n   QoS policy and the instances that are used for IKE policy,\
    \ although\n   they are disjoint, are not joined in a FirstMatching decision\n\
    \   strategy.  Instead, they are evaluated independently of one another.\n"
- title: 5.5.4. Deterministic Decisions
  contents:
  - "5.5.4. Deterministic Decisions\n   As previously discussed, PolicySetComponent.Priority\
    \ values MUST be\n   unique within a containing PolicySet and PolicySetInSystem.Priority\n\
    \   values MUST be unique for an associated System.  Each PolicySet,\n   then,\
    \ has a deterministic behavior based upon the decision strategy\n   and uniquely\
    \ defined priority.\n   There are certainly cases where rules need not have a\
    \ unique priority\n   value (i.e., where evaluation and execution priority is\
    \ not\n   important).  However, it is believed that the flexibility gained by\n\
    \   this capability is not sufficiently beneficial to justify the\n   possible\
    \ variations in implementation behavior and the resulting\n   confusion that might\
    \ occur.\n"
- title: 5.6. Policy Roles
  contents:
  - "5.6. Policy Roles\n   A policy role is defined in [10] as \"an administratively\
    \ specified\n   characteristic of a managed element (for example, an interface).\
    \  It\n   is a selector for policy rules and PRovisioning Classes (PRCs), to\n\
    \   determine the applicability of the rule/PRC to a particular managed\n   element.\"\
    \n   In PCIMe, PolicyRoles is defined as a property of PolicySet, which is\n \
    \  inherited by both PolicyRules and PolicyGroups.  In this document, we\n   also\
    \ add PolicyRole as the identifying name of a collection of\n   resources (PolicyRoleCollection),\
    \ where each element in the\n   collection has the specified role characteristic.\n"
- title: 5.6.1. Comparison of Roles in PCIM with Roles in snmpconf
  contents:
  - "5.6.1. Comparison of Roles in PCIM with Roles in snmpconf\n   In the Configuration\
    \ Management with SNMP (snmpconf) working group's\n   Policy Based Management\
    \ MIB [14], policy rules are of the form\n      if <policyFilter> then <policyAction>\n\
    \   where <policyFilter> is a set of conditions that are used to\n   determine\
    \ whether or not the policy applies to an object instance.\n   The policy filter\
    \ can perform comparison operations on SNMP variables\n   already defined in MIBS\
    \ (e.g., \"ifType == ethernet\").\n   The policy management MIB defined in [14]\
    \ defines a Role table that\n   enables one to associate Roles with elements,\
    \ where roles have the\n   same semantics as in PCIM.  Then, since the policyFilter\
    \ in a policy\n   allows one to define conditions based on the comparison of the\
    \ values\n   of SNMP variables, one can filter elements based on their roles as\n\
    \   defined in the Role group.\n   This approach differs from that adopted in\
    \ PCIM in the following\n   ways.  First, in PCIM, a set of role(s) is associated\
    \ with a policy\n   rule as the values of the PolicyRoles property of a policy\
    \ rule.  The\n   semantics of role(s) are then expected to be implemented by the\
    \ PDP\n   (i.e., policies are applied to the elements with the appropriate\n \
    \  roles).  In [14], however, no special processing is required for\n   realizing\
    \ the semantics of roles; roles are treated just as any other\n   SNMP variables\
    \ and comparisons of role values can be included in the\n   policy filter of a\
    \ policy rule.\n   Secondly, in PCIM, there is no formally defined way of associating\
    \ a\n   role with an object instance, whereas in [14] this is done via the\n \
    \  use of the Role tables (pmRoleESTable and pmRoleSETable).  The Role\n   tables\
    \ associate Role values with elements.\n"
- title: 5.6.2. Addition of PolicyRoleCollection to PCIMe
  contents:
  - "5.6.2. Addition of PolicyRoleCollection to PCIMe\n   In order to remedy the latter\
    \ shortcoming in PCIM (the lack of a way\n   of associating a role with an object\
    \ instance), PCIMe has a new class\n   PolicyRoleCollection derived from the CIM\
    \ Collection class.\n   Resources that share a common role are aggregated by a\n\
    \   PolicyRoleCollection instance, via the ElementInPolicyRoleCollection\n   aggregation.\
    \  The role is specified in the PolicyRole property of the\n   aggregating PolicyRoleCollection\
    \ instance.\n   A PolicyRoleCollection always exists in the context of a system.\
    \  As\n   was done in PCIM for PolicyRules and PolicyGroups, an association,\n\
    \   PolicyRoleCollectionInSystem, captures this relationship.  Remember\n   that\
    \ in CIM, System is a base class for describing network devices\n   and administrative\
    \ domains.\n   The association between a PolicyRoleCollection and a system should\
    \ be\n   consistent with the associations that scope the policy rules/groups\n\
    \   that are applied to the resources in that collection.  Specifically,\n   a\
    \ PolicyRoleCollection should be associated with the same System as\n   the applicable\
    \ PolicyRules and/or PolicyGroups, or to a System higher\n   in the tree formed\
    \ by the SystemComponent association.  When a PEP\n   belongs to multiple Systems\
    \ (i.e., AdminDomains), and scoping by a\n   single domain is impractical, two\
    \ alternatives exist.  One is to\n   arbitrarily limit domain membership to one\
    \ System/AdminDomain.  The\n   other option is to define a more global AdminDomain\
    \ that simply\n   includes the others, and/or that spans the business or enterprise.\n\
    \   As an example, suppose that there are 20 traffic trunks in a network,\n  \
    \ and that an administrator would like to assign three of them to\n   provide\
    \ \"gold\" service.  Also, the administrator has defined several\n   policy rules\
    \ which specify how the \"gold\" service is delivered.  For\n   these rules, the\
    \ PolicyRoles property (inherited from PolicySet) is\n   set to \"Gold Service\"\
    .\n   In order to associate three traffic trunks with \"gold\" service, an\n \
    \  instance of the PolicyRoleCollection class is created and its\n   PolicyRole\
    \ property is also set to \"Gold Service\".  Following this,\n   the administrator\
    \ associates three traffic trunks with the new\n   instance of PolicyRoleCollection\
    \ via the\n   ElementInPolicyRoleCollection aggregation.  This enables a PDP to\n\
    \   determine that the \"Gold Service\" policy rules apply to the three\n   aggregated\
    \ traffic trunks.\n   Note that roles are used to optimize policy retrieval. \
    \ It is not\n   mandatory to implement roles or, if they have been implemented,\
    \ to\n   group elements in a PolicyRoleCollection.  However, if roles are\n  \
    \ used, then either the collection approach should be implemented, or\n   elements\
    \ should be capable of reporting their \"pre-programmed\" roles\n   (as is done\
    \ in COPS).\n"
- title: 5.6.3. Roles for PolicyGroups
  contents:
  - "5.6.3. Roles for PolicyGroups\n   In PCIM, role(s) are only associated with policy\
    \ rules.  However, it\n   may be desirable to associate role(s) with groups of\
    \ policy rules.\n   For example, a network administrator may want to define a\
    \ group of\n   rules that apply only to Ethernet interfaces.  A policy group can\
    \ be\n   defined with a role-combination=\"Ethernet\", and all the relevant\n\
    \   policy rules can be placed in this policy group.  (Note that in\n   PCIMe,\
    \ role(s) are made available to PolicyGroups as well as to\n   PolicyRules by\
    \ moving PCIM's PolicyRoles property up from PolicyRule\n   to the new abstract\
    \ class PolicySet.  The property is then inherited\n   by both PolicyGroup and\
    \ PolicyRule.)  Then every policy rule in this\n   policy group implicitly inherits\
    \ this role-combination from the\n   containing policy group.  A similar implicit\
    \ inheritance applies to\n   nested policy groups.\n   There is no explicit copying\
    \ of role(s) from container to contained\n   entity.  Obviously, this implicit\
    \ inheritance of role(s) leads to the\n   possibility of defining inconsistent\
    \ role(s) (as explained in the\n   example below); the handling of such inconsistencies\
    \ is beyond the\n   scope of PCIMe.\n   As an example, suppose that there is a\
    \ PolicyGroup PG1 that contains\n   three PolicyRules, PR1, PR2, and PR3.  Assume\
    \ that PG1 has the roles\n   \"Ethernet\" and \"Fast\".  Also, assume that the\
    \ contained policy rules\n   have the role(s) shown below:\n   +------------------------------+\n\
    \   | PolicyGroup PG1              |\n   | PolicyRoles = Ethernet, Fast |\n  \
    \ +------------------------------+\n              |\n              |        +------------------------+\n\
    \              |        | PolicyRule PR1         |\n              |--------| PolicyRoles\
    \ = Ethernet |\n              |        +------------------------+\n          \
    \    |\n              |        +--------------------------+\n              | \
    \       | PolicyRule PR2           |\n              |--------| PolicyRoles = <undefined>|\n\
    \              |        +--------------------------+\n              |\n      \
    \        |        +------------------------+\n              |        | PolicyRule\
    \ PR3         |\n              |--------| PolicyRoles = Slow     |\n         \
    \              +------------------------+\n   Figure 5.    Inheritance of Roles\n\
    \   In this example, the PolicyRoles property value for PR1 is consistent\n  \
    \ with the value in PG1, and in fact, did not need to be redefined. The\n   value\
    \ of PolicyRoles for PR2 is undefined.  Its roles are implicitly\n   inherited\
    \ from PG1.  Lastly, the value of PolicyRoles for PR3 is\n   \"Slow\".  This appears\
    \ to be in conflict with the role, \"Fast,\"\n   defined in PG1.  However, whether\
    \ these roles are actually in\n   conflict is not clear.   In one scenario, the\
    \ policy administrator\n   may have wanted only \"Fast\"- \"Ethernet\" rules in\
    \ the policy group.\n   In another scenario, the administrator may be indicating\
    \ that PR3\n   applies to all \"Ethernet\" interfaces regardless of whether they\
    \ are\n   \"Fast\" or \"Slow.\"  Only in the former scenario (only \"Fast\"-\n\
    \   \"Ethernet\" rules in the policy group) is there a role conflict.\n   Note\
    \ that it is possible to override implicitly inherited roles via\n   appropriate\
    \ conditions on a PolicyRule.  For example, suppose that\n   PR3 above had defined\
    \ the following conditions:\n      (interface is not \"Fast\") and (interface\
    \ is \"Slow\")\n   This results in unambiguous semantics for PR3.\n"
- title: 5.7. Compound Policy Conditions and Compound Policy Actions
  contents:
  - "5.7. Compound Policy Conditions and Compound Policy Actions\n   Compound policy\
    \ conditions and compound policy actions are introduced\n   to provide additional\
    \ reusable \"chunks\" of policy.\n"
- title: 5.7.1. Compound Policy Conditions
  contents:
  - "5.7.1. Compound Policy Conditions\n   A CompoundPolicyCondition is a PolicyCondition\
    \ representing a Boolean\n   combination of simpler conditions.  The conditions\
    \ being combined may\n   be SimplePolicyConditions (discussed below in Section\
    \ 6.4), but the\n   utility of reusable combinations of policy conditions is not\n\
    \   necessarily limited to the case where the component conditions are\n   simple\
    \ ones.\n   The PCIM extensions to introduce compound policy conditions are\n\
    \   relatively straightforward.  Since the purpose of the extension is to\n  \
    \ apply the DNF / CNF logic from PCIM's PolicyConditionInPolicyRule\n   aggregation\
    \ to a compound condition that aggregates simpler\n   conditions, the following\
    \ changes are required:\n   o  Create a new aggregation PolicyConditionInPolicyCondition,\
    \ with\n      the same GroupNumber and ConditionNegated properties as\n      PolicyConditionInPolicyRule.\
    \  The cleanest way to do this is to\n      move the properties up to a new abstract\
    \ aggregation superclass\n      PolicyConditionStructure, from which the existing\
    \ aggregation\n      PolicyConditionInPolicyRule and a new aggregation\n     \
    \ PolicyConditionInPolicyCondition are derived.  For now there is no\n      need\
    \ to re-document the properties themselves, since they are\n      already documented\
    \ in PCIM as part of the definition of the\n      PolicyConditionInPolicyRule\
    \ aggregation.\n   o  It is also necessary to define a concrete subclass\n   \
    \   CompoundPolicyCondition of PolicyCondition, to introduce the\n      ConditionListType\
    \ property.  This property has the same function,\n      and works in exactly\
    \ the same way, as the corresponding property\n      currently defined in PCIM\
    \ for the PolicyRule class.\n   The class and property definitions for representing\
    \ compound policy\n   conditions are below, in Section 6.\n"
- title: 5.7.2. Compound Policy Actions
  contents:
  - "5.7.2. Compound Policy Actions\n   A compound action is a convenient construct\
    \ to represent a sequence\n   of actions to be applied as a single atomic action\
    \ within a policy\n   rule.  In many cases, actions are related to each other\
    \ and should be\n   looked upon as sub-actions of one \"logical\" action.  An\
    \ example of\n   such a logical action is \"shape & mark\" (i.e., shape a certain\
    \ stream\n   to a set of predefined bandwidth characteristics and then mark these\n\
    \   packets with a certain DSCP value).  This logical action is actually\n   composed\
    \ of two different QoS actions, which should be performed in a\n   well-defined\
    \ order and as a complete set.\n   The CompoundPolicyAction construct allows one\
    \ to create a logical\n   relationship between a number of actions, and to define\
    \ the\n   activation logic associated with this logical action.\n   The CompoundPolicyAction\
    \ construct allows the reusability of these\n   complex actions, by storing them\
    \ in a ReusablePolicyContainer and\n   reusing them in different policy rules.\
    \  Note that a compound action\n   may also be aggregated by another compound\
    \ action.\n   As was the case with CompoundPolicyCondition, the PCIM extensions\
    \ to\n   introduce compound policy actions are relatively straightforward.\n \
    \  This time the goal is to apply the property ActionOrder from PCIM's\n   PolicyActionInPolicyRule\
    \ aggregation to a compound action that\n   aggregates simpler actions.  The following\
    \ changes are required:\n   o  Create a new aggregation PolicyActionInPolicyAction,\
    \ with the same\n      ActionOrder property as PolicyActionInPolicyRule.  The\
    \ cleanest\n      way to do this is to move the property up to a new abstract\n\
    \      aggregation superclass PolicyActionStructure, from which the\n      existing\
    \ aggregation PolicyActionInPolicyRule and a new\n      aggregation PolicyActionInPolicyAction\
    \ are derived.\n   o  It is also necessary to define a concrete subclass\n   \
    \   CompoundPolicyAction of PolicyAction, to introduce the\n      SequencedActions\
    \ property.  This property has the same function,\n      and works in exactly\
    \ the same way, as the corresponding property\n      currently defined in PCIM\
    \ for the PolicyRule class.\n   o  Finally, a new property ExecutionStrategy is\
    \ needed for both the\n      PCIM class PolicyRule and the new class CompoundPolicyAction.\
    \ This\n      property allows the policy administrator to specify how the PEP\n\
    \      should behave in the case where there are multiple actions\n      aggregated\
    \ by a PolicyRule or by a CompoundPolicyAction.\n   The class and property definitions\
    \ for representing compound policy\n   actions are below, in Section 6.\n"
- title: 5.8. Variables and Values
  contents:
  - "5.8. Variables and Values\n   The following subsections introduce several related\
    \ concepts,\n   including PolicyVariables and PolicyValues (and their numerous\n\
    \   subclasses), SimplePolicyConditions, and SimplePolicyActions.\n"
- title: 5.8.1. Simple Policy Conditions
  contents:
  - "5.8.1. Simple Policy Conditions\n   The SimplePolicyCondition class models elementary\
    \ Boolean expressions\n   of the form: \"(<variable> MATCH <value>)\".  The relationship\
    \ 'MATCH',\n   which is implicit in the model, is interpreted based on the variable\n\
    \   and the value.  Section 5.8.3 explains the semantics of the 'MATCH'\n   operator.\
    \  Arbitrarily complex Boolean expressions can be formed by\n   chaining together\
    \ any number of simple conditions using relational\n   operators.  Individual\
    \ simple conditions can be negated as well.\n   Arbitrarily complex Boolean expressions\
    \ are modeled by the class\n   CompoundPolicyCondition (described in Section 5.7.1).\n\
    \   For example, the expression \"SourcePort == 80\" can be modeled by a\n   simple\
    \ condition.  In this example, 'SourcePort' is a variable, '=='\n   is the relational\
    \ operator denoting the equality relationship (which\n   is generalized by PCIMe\
    \ to a \"MATCH\" relationship), and '80' is an\n   integer value.  The complete\
    \ interpretation of a simple condition\n   depends on the binding of the variable.\
    \  Section 5.8.5 describes\n   variables and their binding rules.\n   The SimplePolicyCondition\
    \ class refines the basic structure of the\n   PolicyCondition class defined in\
    \ PCIM by using the pair (<variable>,\n   <value>) to form the condition.  Note\
    \ that the operator between the\n   variable and the value is always implied in\
    \ PCIMe: it is not a part\n   of the formal notation.\n   The variable specifies\
    \ the attribute of an object that should be\n   matched when evaluating the condition.\
    \  For example, for a QoS model,\n   this object could represent the flow that\
    \ is being conditioned.  A\n   set of predefined variables that cover network\
    \ attributes commonly\n   used for filtering is introduced in PCIMe, to encourage\n\
    \   interoperability.  This list covers layer 3 IP attributes such as IP\n   network\
    \ addresses, protocols and ports, as well as a set of layer 2\n   attributes (e.g.,\
    \ MAC addresses).\n   The bound variable is matched against a value to produce\
    \ the Boolean\n   result.  For example, in the condition \"The source IP address\
    \ of the\n   flow belongs to the 10.1.x.x subnet\", a source IP address variable\
    \ is\n   matched against a 10.1.x.x subnet value.\n"
- title: 5.8.2. Using Simple Policy Conditions
  contents:
  - "5.8.2. Using Simple Policy Conditions\n   Simple conditions can be used in policy\
    \ rules directly, or as\n   building blocks for creating compound policy conditions.\n\
    \   Simple condition composition MUST enforce the following data-type\n   conformance\
    \ rule: The ValueTypes property of the variable must be\n   compatible with the\
    \ type of the value class used.  The simplest (and\n   friendliest, from a user\
    \ point-of-view) way to do this is to equate\n   the type of the value class with\
    \ the name of the class.  By ensuring\n   that the ValueTypes property of the\
    \ variable matches the name of the\n   value class used, we know that the variable\
    \ and value instance values\n   are compatible with each other.\n   Composing\
    \ a simple condition requires that an instance of the class\n   SimplePolicyCondition\
    \ be created, and that instances of the variable\n   and value classes that it\
    \ uses also exist.  Note that the variable\n   and/or value instances may already\
    \ exist as reusable objects in an\n   appropriate ReusablePolicyContainer.\n \
    \  Two aggregations are used in order to create the pair (<variable>,\n   <value>).\
    \  The aggregation PolicyVariableInSimplePolicyCondition\n   relates a SimplePolicyCondition\
    \ to a single variable instance.\n   Similarly, the aggregation PolicyValueInSimplePolicyCondition\
    \ relates\n   a SimplePolicyCondition to a single value instance.  Both\n   aggregations\
    \ are defined in this document.\n   Figure 6. depicts a SimplePolicyCondition\
    \ with its associated\n   variable and value.  Also shown are two PolicyValue\
    \ instances that\n   identify the values that the variable can assume.\n     \
    \                         +-----------------------+\n                        \
    \      | SimplePolicyCondition |\n                              +-----------------------+\n\
    \                                    *         @\n                           \
    \         *         @\n              +------------------+  *         @  +---------------+\n\
    \              | (PolicyVariable) |***         @@@| (PolicyValue) |\n        \
    \      +------------------+               +---------------+\n                \
    \ #            #\n                 #    ooo     #\n                 #        \
    \    #\n   +---------------+        +---------------+\n   | (PolicyValue) |  ooo\
    \   | (PolicyValue) |\n   +---------------+        +---------------+\n   Aggregation\
    \ Legend:\n     ****  PolicyVariableInSimplePolicyCondition\n     @@@@  PolicyValueInSimplePolicyCondition\n\
    \     ####  ExpectedPolicyValuesForVariable\n   Figure 6.    SimplePolicyCondition\n\
    \   Note:  The class names in parenthesis denote subclasses.  The classes\n  \
    \ named in the figure are abstract, and thus cannot themselves be\n   instantiated.\n"
- title: 5.8.3. The Simple Condition Operator
  contents:
  - "5.8.3. The Simple Condition Operator\n   A simple condition models an elementary\
    \ Boolean expression of the\n   form \"variable MATCHes value\".  However, the\
    \ formal notation of the\n   SimplePolicyCondition, together with its associations,\
    \ models only a\n   pair, (<variable>, <value>).  The 'MATCH' operator is not\
    \ directly\n   modeled -- it is implied.  Furthermore, this implied 'MATCH' operator\n\
    \   carries overloaded semantics.\n   For example, in the simple condition \"\
    DestinationPort MATCH '80'\",\n   the interpretation of the 'MATCH' operator is\
    \ equality (the 'equal'\n   operator).  Clearly, a different interpretation is\
    \ needed in the\n   following cases:\n   o  \"DestinationPort MATCH {'80', '8080'}\"\
    \  -- operator is 'IS SET\n      MEMBER'\n   o  \"DestinationPort MATCH {'1 to\
    \ 255'}\" -- operator is 'IN INTEGER\n      RANGE'\n   o  \"SourceIPAddress MATCH\
    \ 'MyCompany.com'\" -- operator is 'IP ADDRESS\n      AS RESOLVED BY DNS'\n  \
    \ The examples above illustrate the implicit, context-dependent nature\n   of\
    \ the 'MATCH' operator.  The interpretation depends on the actual\n   variable\
    \ and value instances in the simple condition.  The\n   interpretation is always\
    \ derived from the bound variable and the\n   value instance associated with the\
    \ simple condition.  Text\n   accompanying the value class and implicit variable\
    \ definition is used\n   for interpreting the semantics of the 'MATCH' relationship.\
    \  In the\n   following list, we define generic (type-independent) matching.\n\
    \   PolicyValues may be multi-fielded, where each field may contain a\n   range\
    \ of values.  The same equally holds for PolicyVariables.\n   Basically, we have\
    \ to deal with single values (singleton), ranges\n   ([lower bound ..  upper bound]),\
    \ and sets (a,b,c).  So independent of\n   the variable and value type, the following\
    \ set of generic matching\n   rules for the 'MATCH' operator are defined.\n  \
    \ o  singleton matches singleton -> the matching rule is defined in the\n    \
    \  type\n   o  singleton matches range [lower bound .. upper bound] -> the\n \
    \     matching evaluates to true, if the singleton matches the lower\n      bound\
    \ or the upper bound or a value in between\n   o  singleton matches set -> the\
    \ matching evaluates to true, if the\n      value of the singleton matches one\
    \ of the components in the set,\n      where a component may be a singleton or\
    \ range again\n   o  ranges [A..B] matches singleton -> is true if A matches B\
    \ matches\n      singleton\n   o  range [A..B] matches range [X..Y] -> the matching\
    \ evaluates to\n      true, if all values of the range [A..B] are also in the\
    \ range\n      [X..Y].  For instance, [3..5] match [1..6] evaluates to true,\n\
    \      whereas [3..5] match [4..6] evaluates to false.\n   o  range [A..B] matches\
    \ set (a,b,c, ...) -> the matching evaluates to\n      true, if all values in\
    \ the range [A..B] are part of the set.  For\n      instance, range [2..3] match\
    \ set ([1..2],3) evaluates to true, as\n      well as range [2..3] match set (2,3),\
    \ and range [2..3] match set\n      ([1..2],[3..5]).\n   o  set (a,b,c, ...) match\
    \ singleton -> is true if a match b match c\n      match ... match singleton\n\
    \   o  set match range -> the matching evaluates to true, if all values\n    \
    \  in the set are part of the range.  For example, set (2,3) match\n      range\
    \ [1..4] evaluates to true.\n   o  set (a,b,c,...) match set (x,y,z,...) -> the\
    \ matching evaluates to\n      true, if all values in the set (a,b,c,...) are\
    \ part of the set\n      (x,y,z,...).  For example, set (1,2,3) match set (1,2,3,4)\n\
    \      evaluates to true.  Set (1,2,3) match set (1,2) evaluates to\n      false.\n\
    \   Variables may contain various types (Section 6.11.1).  When not\n   stated\
    \ otherwise, the type of the value bound to the variable at\n   condition evaluation\
    \ time and the value type of the PolicyValue\n   instance need to be of the same\
    \ type.  If they differ, then the\n   condition evaluates to FALSE.\n   The ExpectedPolicyValuesForVariable\
    \ association specifies an expected\n   set of values that can be matched with\
    \ a variable within a simple\n   condition.  Using this association, a source\
    \ or destination port can\n   be limited to the range 0-200, a source or destination\
    \ IP address can\n   be limited to a specified list of IPv4 address values, etc.\n\
    \                          +-----------------------+\n                       \
    \   | SimplePolicyCondition |\n                          +-----------------------+\n\
    \                              *               @\n                           \
    \   *               @\n                              *               @\n   +-----------------------------------+\
    \   +--------------------------+\n   | Name=SmallSourcePorts             |   |\
    \ Name=Port300             |\n   | Class=PolicySourcePortVariable    |   | Class=PolicyIntegerValue\
    \ |\n   | ValueTypes=[PolicyIntegerValue]   |   | IntegerList = [300]      |\n\
    \   +-----------------------------------+   +--------------------------+\n   \
    \             #\n                #\n                #\n   +-------------------------+\n\
    \   |Name=SmallPortsValues    |\n   |Class=PolicyIntegerValue |\n   |IntegerList=[1..200]\
    \     |\n   +-------------------------+\n   Aggregation Legend:\n     ****  PolicyVariableInSimplePolicyCondition\n\
    \     @@@@  PolicyValueInSimplePolicyCondition\n     ####  ExpectedPolicyValuesForVariable\n\
    \   Figure 7.    An Invalid SimplePolicyCondition\n   The ability to express these\
    \ limitations appears in the model to\n   support validation of a SimplePolicyCondition\
    \ prior to its deployment\n   to an enforcement point.  A Policy Management Tool,\
    \ for example\n   SHOULD NOT accept the SimplePolicyCondition shown in Figure\
    \ 7.  If,\n   however, a policy rule containing this condition does appear at\
    \ an\n   enforcement point, the expected values play no role in the\n   determination\
    \ of whether the condition evaluates to True or False.\n   Thus in this example,\
    \ the SimplePolicyCondition evaluates to True if\n   the source port for the packet\
    \ under consideration is 300, and it\n   evaluates to False otherwise.\n"
- title: 5.8.4. SimplePolicyActions
  contents:
  - "5.8.4. SimplePolicyActions\n   The SimplePolicyAction class models the elementary\
    \ set operation.\n   \"SET <variable> TO <value>\".  The set operator MUST overwrite\
    \ an old\n   value of the variable.  In the case where the variable to be updated\n\
    \   is multi- valued, the only update operation defined is a complete\n   replacement\
    \ of all previous values with a new set.  In other words,\n   there are no Add\
    \ or Remove [to/from the set of values] operations\n   defined for SimplePolicyActions.\n\
    \   For example, the action  \"set DSCP to EF\" can be modeled by a simple\n \
    \  action.  In this example, 'DSCP' is an implicit variable referring to\n   the\
    \ IP packet header DSCP field.  'EF' is an integer or bit string\n   value (6\
    \ bits).  The complete interpretation of a simple action\n   depends on the binding\
    \ of the variable.\n   The SimplePolicyAction class refines the basic structure\
    \ of the\n   PolicyAction class defined in PCIM, by specifying the contents of\
    \ the\n   action using the (<variable>, <value>) pair to form the action.  The\n\
    \   variable specifies the attribute of an object. The value of  this\n   attribute\
    \ is set to the value specified in <value>.  Selection of the\n   object is a\
    \ function of the type of variable involved.  See Sections\n   5.8.6 and 5.8.7,\
    \ respectively, for details on object selection for\n   explicitly bound and implicitly\
    \ bound policy variables.\n   SimplePolicyActions can be used in policy rules\
    \ directly, or as\n   building blocks for creating CompoundPolicyActions.\n  \
    \ The set operation is only valid if the list of types of the variable\n   (ValueTypes\
    \ property of PolicyImplicitVariable) includes the\n   specified type of the value.\
    \  Conversion of values from one\n   representation into another is not defined.\
    \  For example, a variable\n   of IPv4Address type may not be set to a string\
    \ containing a DNS name.\n   Conversions are part of an implementation-specific\
    \ mapping of the\n   model.\n   As was the case with SimplePolicyConditions, the\
    \ role of expected\n   values for the variables that appear in SimplePolicyActions\
    \ is for\n   validation, prior to the time when an action is executed.  Expected\n\
    \   values play no role in action execution.\n   Composing a simple action requires\
    \ that an instance of the class\n   SimplePolicyAction be created, and that instances\
    \ of the variable and\n   value classes that it uses also exist.  Note that the\
    \ variable and/or\n   value instances may already exist as reusable objects in\
    \ an\n   appropriate ReusablePolicyContainer.\n   Two aggregations are used in\
    \ order to create the pair (<variable>,\n   <value>).  The aggregation PolicyVariableInSimplePolicyAction\
    \ relates\n   a SimplePolicyAction to a single variable instance.  Similarly,\
    \ the\n   aggregation PolicyValueInSimplePolicyAction relates a\n   SimplePolicyAction\
    \ to a single value instance.  Both aggregations are\n   defined in this document.\n\
    \   Figure 8. depicts a SimplePolicyAction with its associated variable\n   and\
    \ value.\n                              +-----------------------+\n          \
    \                    | SimplePolicyAction    |\n                             \
    \ |                       |\n                              +-----------------------+\n\
    \                                    *         @\n                           \
    \         *         @\n              +------------------+  *         @  +---------------+\n\
    \              | (PolicyVariable) |***         @@@| (PolicyValue) |\n        \
    \      +------------------+               +---------------+\n                \
    \ #            #\n                 #    ooo     #\n                 #        \
    \    #\n   +---------------+        +---------------+\n   | (PolicyValue) |  ooo\
    \   | (PolicyValue) |\n   +---------------+        +---------------+\n   Aggregation\
    \ Legend:\n     ****  PolicyVariableInSimplePolicyAction\n     @@@@  PolicyValueInSimplePolicyAction\n\
    \     ####  ExpectedPolicyValuesForVariable\n   Figure 8.    SimplePolicyAction\n"
- title: 5.8.5. Policy Variables
  contents:
  - "5.8.5. Policy Variables\n   A variable generically represents information that\
    \ changes (or\n   \"varies\"), and that is set or evaluated by software.  In policy,\n\
    \   conditions and actions can abstract information as \"policy variables\"\n\
    \   to be evaluated in logical expressions, or set by actions.\n   PCIMe defines\
    \ two types of PolicyVariables, PolicyImplicitVariables\n   and PolicyExplicitVariables.\
    \  The semantic difference between these\n   classes is based on modeling context.\
    \  Explicit variables are bound\n   to exact model constructs, while implicit\
    \ variables are defined and\n   evaluated outside of a model.  For example, one\
    \ can imagine a\n   PolicyCondition testing whether a CIM ManagedSystemElement's\
    \ Status\n   property has the value \"Error.\"  The Status property is an explicitly\n\
    \   defined PolicyVariable (i.e., it is defined in the context of the CIM\n  \
    \ Schema, and evaluated in the context of a specific instance).  On the\n   other\
    \ hand, network packets are not explicitly modeled or\n   instantiated, since\
    \ there is no perceived value (at this time) in\n   managing at the packet level.\
    \  Therefore, a PolicyCondition can make\n   no explicit reference to a model\
    \ construct that represents a network\n   packet's source address.  In this case,\
    \ an implicit PolicyVariable is\n   defined, to allow evaluation or modification\
    \ of a packet's source\n   address.\n"
- title: 5.8.6. Explicitly Bound Policy Variables
  contents:
  - "5.8.6. Explicitly Bound Policy Variables\n   Explicitly bound policy variables\
    \ indicate the class and property\n   names of the model construct to be evaluated\
    \ or set.  The CIM Schema\n   defines and constrains \"appropriate\" values for\
    \ the variable (i.e.,\n   model property) using data types and other information\
    \ such as\n   class/property qualifiers.\n   A PolicyExplicitVariable is \"explicit\"\
    \ because its model semantics\n   are exactly defined.  It is NOT explicit due\
    \ to an exact binding to a\n   particular object instance.  If PolicyExplicitVariables\
    \ were tied to\n   instances (either via associations or by an object identification\n\
    \   property in the class itself), then we would be forcing element-\n   specific\
    \ rules.  On the other hand, if we only specify the object's\n   model context\
    \ (class and property name), but leave the binding to the\n   policy framework\
    \ (for example, using policy roles), then greater\n   flexibility results for\
    \ either general or element-specific rules.\n   For example, an element-specific\
    \ rule is obtained by a condition\n   ((<variable>, <value>) pair) that defines\
    \ CIM LogicalDevice\n   DeviceID=\"12345\".  Alternately, if a PolicyRule's PolicyRoles\
    \ is\n   \"edge device\" and the condition ((<variable>, <value>) pair) is\n \
    \  Status=\"Error\", then a general rule results for all edge devices in\n   error.\n\
    \   Currently, the only binding for a PolicyExplicitVariable defined in\n   PCIMe\
    \ is to the instances selected by policy roles.  For each such\n   instance, a\
    \ SimplePolicyCondition that aggregates the\n   PolicyExplicitVariable evaluates\
    \ to True if and only if ALL of the\n   following are true:\n   o  The instance\
    \ selected is of the class identified by the variable's\n      ModelClass property,\
    \ or of a subclass of this class.\n   o  The instance selected has the property\
    \ identified by the\n      variable's ModelProperty property.\n   o  The value\
    \ of this property in the instance matches the value\n      specified in the PolicyValue\
    \ aggregated by the condition.\n   In all other cases, the SimplePolicyCondition\
    \ evaluates to False.\n   For the case where a SimplePolicyAction aggregates a\n\
    \   PolicyExplicitVariable, the indicated property in the selected\n   instance\
    \ is set to the value represented by the PolicyValue that the\n   SimplePolicyAction\
    \ also aggregates.  However, if the selected\n   instance is not of the class\
    \ identified by the variable's ModelClass\n   property, or of a subclass of this\
    \ class, then the action is not\n   performed.  In this case the SimplePolicyAction\
    \ is not treated either\n   as a successfully executed action (for the execution\
    \ strategy Do\n   Until Success) or as a failed action (for the execution strategy\
    \ Do\n   Until Failure).  Instead, the remaining actions for the policy rule,\n\
    \   if any, are executed as if this SimplePolicyAction were not present\n   at\
    \ all in the list of actions aggregated by the rule.\n   Explicit variables would\
    \ be more powerful if they could reach beyond\n   the instances selected by policy\
    \ roles, to related instances.\n   However, to represent a policy rule involving\
    \ such variables in any\n   kind of general way requires something that starts\
    \ to resemble very\n   much a complete policy language.  Clearly such a language\
    \ is outside\n   the scope of PCIMe, although it might be the subject of a future\n\
    \   document.\n   By restricting much of the generality, it would be possible\
    \ for\n   explicit variables in PCIMe to reach slightly beyond a selected\n  \
    \ instance.  For example, if a selected instance were related to\n   exactly one\
    \ instance of another class via a particular association\n   class, and if the\
    \ goal of the policy rule were both to test a\n   property of this related instance\
    \ and to set a property of that same\n   instance, then it would be possible to\
    \ represent the condition and\n   action of the rule using PolicyExplicitVariables.\
    \  Rather than\n   handling this one specific case with explicit variables, though,\
    \ it\n   was decided to lump them with the more general case, and deal with\n\
    \   them if and when a policy language is defined.\n   Refer to Section 6.10 for\
    \ the formal definition of the class\n   PolicyExplicitVariable.\n"
- title: 5.8.7. Implicitly Bound Policy Variables
  contents:
  - "5.8.7. Implicitly Bound Policy Variables\n   Implicitly bound policy variables\
    \ define the data type and semantics\n   of a variable.  This determines how the\
    \ variable is bound to a value\n   in a condition or an action.  Further instructions\
    \ are provided for\n   specifying data type and/or value constraints for implicitly\
    \ bound\n   variables.\n   PCIMe introduces an abstract class, PolicyImplicitVariable,\
    \ to model\n   implicitly bound variables.  This class is derived from the abstract\n\
    \   class PolicyVariable also defined in PCIMe.  Each of the implicitly\n   bound\
    \ variables introduced by PCIMe (and those that are introduced by\n   domain-\
    \ specific sub-models) MUST be derived from the\n   PolicyImplicitVariable class.\
    \  The rationale for using this mechanism\n   for modeling is explained below\
    \ in Section 5.8.9.\n   A domain-specific policy information model that extends\
    \ PCIMe may\n   define additional implicitly bound variables either by deriving\
    \ them\n   directly from the class PolicyImplicitVariable, or by further\n   refining\
    \ an existing variable class such as SourcePort.  When\n   refining a class such\
    \ as SourcePort, existing binding rules, type or\n   value constraints may be\
    \ narrowed.\n"
- title: 5.8.8. Structure and Usage of Pre-Defined Variables
  contents:
  - "5.8.8. Structure and Usage of Pre-Defined Variables\n   A class derived from\
    \ PolicyImplicitVariable to model a particular\n   implicitly bound variable SHOULD\
    \ be constructed so that its name\n   depicts the meaning of the variable.  For\
    \ example, a class defined to\n   model the source port of a TCP/UDP flow SHOULD\
    \ have 'SourcePort' in\n   its name.\n   PCIMe defines one association and one\
    \ general-purpose mechanism that\n   together characterize each of the implicitly\
    \ bound variables that it\n   introduces:\n   1. The ExpectedPolicyValuesForVariable\
    \ association defines the set of\n      value classes that could be matched to\
    \ this variable.\n   2. The list of constraints on the values that the PolicyVariable\
    \ can\n      hold (i.e., values that the variable must match) are defined by\n\
    \      the appropriate properties of an associated PolicyValue class.\n   In the\
    \ example presented above, a PolicyImplicitVariable represents\n   the SourcePort\
    \ of incoming traffic.  The ValueTypes property of an\n   instance of this class\
    \ will hold the class name PolicyIntegerValue.\n   This by itself constrains the\
    \ data type of the SourcePort instance to\n   be an integer.  However, we can\
    \ further constrain the particular\n   values that the SourcePort variable can\
    \ hold by entering valid ranges\n   in the IntegerList property of the PolicyIntegerValue\
    \ instance (0 -\n   65535 in this document).\n   The combination of the VariableName\
    \ and the\n   ExpectedPolicyValuesForVariable association provide a consistent\
    \ and\n   extensible set of metadata that define the semantics of variables\n\
    \   that are used to form policy conditions.  Since the\n   ExpectedPolicyValuesForVariable\
    \ association points to a PolicyValue\n   instance, any of the values expressible\
    \ in the PolicyValue class can\n   be used to constrain values that the PolicyImplicitVariable\
    \ can hold.\n   For example:\n   o  The ValueTypes property can be used to ensure\
    \ that only proper\n      classes are used in the expression.  For example, the\
    \ SourcePort\n      variable will not be allowed to ever be of type\n      PolicyIPv4AddrValue,\
    \ since source ports have different semantics\n      than IP addresses and may\
    \ not be matched.  However, integer value\n      types are allowed as the property\
    \ ValueTypes holds the string\n      \"PolicyIntegerValue\", which is the class\
    \ name for integer values.\n   o  The ExpectedPolicyValuesForVariable association\
    \ also ensures that\n      variable-specific semantics are enforced (e.g., the\
    \ SourcePort\n      variable may include a constraint association to a value object\n\
    \      defining a specific integer range that should be matched).\n"
- title: 5.8.9. Rationale for Modeling Implicit Variables as Classes
  contents:
  - "5.8.9. Rationale for Modeling Implicit Variables as Classes\n   An implicitly\
    \ bound variable can be modeled in one of several ways,\n   including a single\
    \ class with an enumerator for each individual\n   implicitly bound variable and\
    \ an abstract class extended for each\n   individual variable.  The reasons for\
    \ using a class inheritance\n   mechanism for specifying individual implicitly\
    \ bound variables are\n   these:\n   1. It is easy to extend.  A domain-specific\
    \ information model can\n      easily extend the PolicyImplicitVariable class\
    \ or its subclasses\n      to define domain-specific and context-specific variables.\
    \  For\n      example, a domain-specific QoS policy information model may\n  \
    \    introduce an implicitly bound variable class to model applications\n    \
    \  by deriving a qosApplicationVariable class from the\n      PolicyImplicitVariable\
    \ abstract class.\n   2. Introduction of a single structural class for implicitly\
    \ bound\n      variables would have to include an enumerator property that\n \
    \     contains all possible individual implicitly bound variables.  This\n   \
    \   means that a domain-specific information model wishing to\n      introduce\
    \ an implicitly bound variable must extend the enumerator\n      itself.  This\
    \ results in multiple definitions of the same class,\n      differing in the values\
    \ available in the enumerator class.  One\n      definition, in this document,\
    \ would include the common implicitly\n      bound variables' names, while a second\
    \ definition, in the domain-\n      specific information model document, may include\
    \ additional values\n      ('qosApplicationVariable' in the example above).  It\
    \ wouldn't even\n      be obvious to the application developer that multiple class\n\
    \      definitions existed.  It would be harder still for the application\n  \
    \    developer to actually find the correct class to use.\n   3. In addition,\
    \ an enumerator-based definition would require each\n      additional value to\
    \ be registered with IANA to ascertain adherence\n      to standards.  This would\
    \ make the process cumbersome.\n   4. A possible argument against the inheritance\
    \ mechanism would cite\n      the fact that this approach results in an explosion\
    \ of class\n      definitions compared to an enumerator class, which only introduces\n\
    \      a single class.  While, by itself, this is not a strike against\n     \
    \ the approach, it may be argued that data models derived from this\n      information\
    \ model may be more difficult to optimize for\n      applications.  This argument\
    \ is rejected on the grounds that\n      application optimization is of lesser\
    \ value for an information\n      model than clarity and ease of extension.  In\
    \ addition, it is hard\n      to claim that the inheritance model places an absolute\
    \ burden on\n      the optimization.  For example, a data model may still use\n\
    \      enumeration to denote instances of pre-defined variables and claim\n  \
    \    PCIMe compliance, as long as the data model can be mapped\n      correctly\
    \ to the definitions specified in this document.\n"
- title: 5.8.10. Policy Values
  contents:
  - "5.8.10. Policy Values\n   The abstract class PolicyValue is used for modeling\
    \ values and\n   constants used in policy conditions.  Different value types are\n\
    \   derived from this class, to represent the various attributes\n   required.\
    \  Extensions of the abstract class PolicyValue, defined in\n   this document,\
    \ provide a list of values for basic network attributes.\n   Values can be used\
    \ to represent constants as named values.  Named\n   values can be kept in a reusable\
    \ policy container to be reused by\n   multiple conditions.  Examples of constants\
    \ include well-known ports,\n   well-known protocols, server addresses, and other\
    \ similar concepts.\n   The PolicyValue subclasses define three basic types of\
    \ values:\n   scalars, ranges and sets.  For example, a well-known port number\n\
    \   could be defined using the PolicyIntegerValue class, defining a\n   single\
    \ value (80 for HTTP), a range (80-88), or a set (80, 82, 8080)\n   of ports,\
    \ respectively.  For details, please see the class definition\n   for each value\
    \ type in Section 6.14 of this document.\n   PCIMe defines the following subclasses\
    \ of the abstract class\n   PolicyValue:\n   Classes for general use:\n      -\
    \ PolicyStringValue,\n      - PolicyIntegerValue,\n      - PolicyBitStringValue\n\
    \      - PolicyBooleanValue.\n   Classes for layer 3 Network values:\n      -\
    \ PolicyIPv4AddrValue,\n      - PolicyIPv6AddrValue.\n   Classes for layer 2 Network\
    \ values:\n      - PolicyMACAddrValue.\n   For details, please see the class definition\
    \ section of each class in\n   Section 6.14 of this document.\n"
- title: 5.9. Packet Filtering
  contents:
  - "5.9. Packet Filtering\n   PCIMe contains two mechanisms for representing packet\
    \ filters.  The\n   more general of these, termed here the domain-level model,\
    \ expresses\n   packet filters in terms of policy variables and policy values.\
    \  The\n   other mechanism, termed here the device-level model, expresses packet\n\
    \   filters in a way that maps more directly to the packet fields to\n   which\
    \ the filters are being applied.  While it is possible to map\n   between these\
    \ two representations of packet filters, no mapping is\n   provided in PCIMe itself.\n"
- title: 5.9.1. Domain-Level Packet Filters
  contents:
  - "5.9.1. Domain-Level Packet Filters\n   In addition to filling in the holes in\
    \ the overall Policy\n   infrastructure, PCIMe proposes a single mechanism for\
    \ expressing\n   domain-level packet filters in policy conditions.  This is being\
    \ done\n   in response to concerns that even though the initial \"wave\" of\n\
    \   submodels derived from PCIM were all filtering on IP packets, each\n   was\
    \ doing it in a slightly different way.  PCIMe proposes a common\n   way to express\
    \ IP packet filters.  The following figure illustrates\n   how packet-filtering\
    \ conditions are expressed in PCIMe.\n                  +---------------------------------+\n\
    \                  | CompoundFilterCondition         |\n                  |  \
    \ - IsMirrored   boolean        |\n                  |   - ConditionListType (DNF|CNF)\
    \ |\n                  +---------------------------------+\n                 \
    \  +               +               +\n                   +               +   \
    \            +\n                   +               +               +\n       \
    \        SimplePC        SimplePC        SimplePC\n               *      @   \
    \     *      @        *      @\n               *      @        *      @      \
    \  *      @\n               *      @        *      @        *      @\n   FlowDirection\
    \    \"In\"     SrcIP  <addr1>  DstIP  <addr2>\n   Aggregation Legend:\n     ++++\
    \  PolicyConditionInPolicyCondition\n     ****  PolicyVariableInSimplePolicyCondition\n\
    \     @@@@  PolicyValueInSimplePolicyCondition\n   Figure 9.    Packet Filtering\
    \ in Policy Conditions\n   In Figure 9., each SimplePolicyCondition represents\
    \ a single field to\n   be filtered on: Source IP address, Destination IP address,\
    \ Source\n   port, etc.  An additional SimplePolicyCondition indicates the\n \
    \  direction that a packet is traveling on an interface: inbound or\n   outbound.\
    \  Because of the FlowDirection condition, care must be taken\n   in aggregating\
    \ a set of SimplePolicyConditions into a\n   CompoundFilterCondition.  Otherwise,\
    \ the resulting\n   CompoundPolicyCondition may match all inbound packets, or\
    \ all\n   outbound packets, when this is probably not what was intended.\n   Individual\
    \ SimplePolicyConditions may be negated when they are\n   aggregated by a CompoundFilterCondition.\n\
    \   CompoundFilterCondition is a subclass of CompoundPolicyCondition.  It\n  \
    \ introduces one additional property, the Boolean property IsMirrored.\n   The\
    \ purpose of this property is to allow a single\n   CompoundFilterCondition to\
    \ match packets traveling in both directions\n   on a higher-level connection\
    \ such as a TCP session.  When this\n   property is TRUE, additional packets match\
    \ a filter, beyond those\n   that would ordinarily match it.  An example will\
    \ illustrate how this\n   property works.\n   Suppose we have a CompoundFilterCondition\
    \ that aggregates the\n   following three filters, which are ANDed together:\n\
    \      o   FlowDirection = \"In\"\n      o   Source IP = 9.1.1.1\n      o   Source\
    \ Port = 80\n   Regardless of whether IsMirrored is TRUE or FALSE, inbound packets\n\
    \   will match this CompoundFilterCondition if their Source IP address =\n   9.1.1.1\
    \ and their Source port = 80.  If IsMirrored is TRUE, however,\n   an outbound\
    \ packet will also match the CompoundFilterCondition if its\n   Destination IP\
    \ address = 9.1.1.1 and its Destination port = 80.\n   IsMirrored \"flips\" the\
    \ following Source/Destination packet header\n   fields:\n      o   FlowDirection\
    \ \"In\" / FlowDirection \"Out\"\n      o   Source IP address / Destination IP\
    \ address\n      o   Source port / Destination port\n      o   Source MAC address\
    \ / Destination MAC address\n      o   Source [layer-2] SAP / Destination [layer-2]\
    \ SAP.\n"
- title: 5.9.2. Device-Level Packet Filters
  contents:
  - "5.9.2. Device-Level Packet Filters\n   At the device level, packet header filters\
    \ are represented by two\n   subclasses of the abstract class FilterEntryBase:\
    \ IpHeadersFilter and\n   8021Filter.  Submodels of PCIMe may define other subclasses\
    \ of\n   FilterEntryBase in addition to these two; ICPM [12], for example,\n \
    \  defines subclasses for IPsec-specific filters.\n   Instances of the subclasses\
    \ of FilterEntryBase are not used directly\n   as filters.  They are always aggregated\
    \ into a FilterList, by the\n   aggregation EntriesInFilterList.  For PCIMe and\
    \ its submodels, the\n   EntrySequence property in this aggregation always takes\
    \ its default\n   value '0', indicating that the aggregated filter entries are\
    \ ANDed\n   together.\n   The FilterList class includes an enumeration property\
    \ Direction,\n   representing the direction of the traffic flow to which the\n\
    \   FilterList is to be applied.  The value Mirrored(4) for Direction\n   represents\
    \ exactly the same thing as the IsMirrored boolean does in\n   CompoundFilterCondition.\
    \  See Section 5.9.1 for details.\n"
- title: 5.10. Conformance to PCIM and PCIMe
  contents:
  - "5.10. Conformance to PCIM and PCIMe\n   Because PCIM and PCIMe provide the core\
    \ classes for modeling\n   policies, they are not in general sufficient by themselves\
    \ for\n   representing actual policy rules.  Submodels, such as QPIM and ICPM,\n\
    \   provide the means for expressing policy rules, by defining subclasses\n  \
    \ of the classes defined in PCIM and PCIMe, and/or by indicating how\n   the PolicyVariables\
    \ and PolicyValues defined in PCIMe can be used to\n   express conditions and\
    \ actions applicable to the submodel.\n   A particular submodel will not, in general,\
    \ need to use every element\n   defined in PCIM and PCIMe.  For the elements it\
    \ does not use, a\n   submodel SHOULD remain silent on whether its implementations\
    \ must\n   support the element, must not support the element, should support the\n\
    \   element, etc.  For the elements it does use, a submodel SHOULD\n   indicate\
    \ which elements its implementations must support, which\n   elements they should\
    \ support, and which elements they may support.\n   PCIM and PCIMe themselves\
    \ simply define elements that may be of use\n   to submodels.  These documents\
    \ remain silent on whether\n   implementations are required to support an element,\
    \ should support\n   it, etc.\n   This model (and derived submodels) defines conditions\
    \ and actions\n   that are used by policy rules.  While the conditions and actions\n\
    \   defined herein are straightforward and may be presumed to be widely\n   supported,\
    \ as submodels are developed it is likely that situations\n   will arise in which\
    \ specific conditions or actions are not supported\n   by some part of the policy\
    \ execution system.  Similarly, situations\n   may also occur where rules contain\
    \ syntactic or semantic errors.\n   It should be understood that the behavior\
    \ and effect of undefined or\n   incorrectly defined conditions or actions is\
    \ not prescribed by this\n   information model.  While it would be helpful if\
    \ it were prescribed,\n   the variations in implementation restrict the ability\
    \ for this\n   information model to control the effect.  For example, if an\n\
    \   implementation only detected that a PEP could not enforce a given\n   action\
    \ on that PEP, it would be very difficult to declare that such a\n   failure should\
    \ affect other PEPs, or the PDP process.  On the other\n   hand, if the PDP determines\
    \ that it cannot properly evaluate a\n   condition, that failure may well affect\
    \ all applications of the\n   containing rules.\n"
- title: 6. Class Definitions
  contents:
  - "6. Class Definitions\n   The following definitions supplement those in PCIM itself.\
    \  PCIM\n   definitions that are not DEPRECATED here are still current parts of\n\
    \   the overall Policy Core Information Model.\n"
- title: 6.1. The Abstract Class "PolicySet"
  contents:
  - "6.1. The Abstract Class \"PolicySet\"\n   PolicySet is an abstract class that\
    \ may group policies into a\n   structured set of policies.\n   NAME         \
    \    PolicySet\n   DESCRIPTION      An abstract class that represents a set of\
    \ policies\n                    that form a coherent set.  The set of contained\n\
    \                    policies has a common decision strategy and a\n         \
    \           common set of policy roles.  Subclasses include\n                \
    \    PolicyGroup and PolicyRule.\n   DERIVED FROM     Policy\n   ABSTRACT    \
    \     TRUE\n   PROPERTIES       PolicyDecisionStrategy\n                    PolicyRoles\n\
    \   The PolicyDecisionStrategy property specifies the evaluation method\n   for\
    \ policy groups and rules contained within the policy set.\n   NAME          \
    \   PolicyDecisionStrategy\n   DESCRIPTION      The evaluation method used for\
    \ policies contained in\n                    the PolicySet.  FirstMatching enforces\
    \ the actions\n                    of the first rule that evaluates to TRUE;\n\
    \                    All Matching enforces the actions of all rules\n        \
    \            that evaluate to TRUE.\n   SYNTAX           uint16\n   VALUES   \
    \        1 [FirstMatching], 2 [AllMatching]\n   DEFAULT VALUE    1 [FirstMatching]\n\
    \   The definition of PolicyRoles is unchanged from PCIM.  It is,\n   however,\
    \ moved from the class Policy up to the superclass PolicySet.\n"
- title: 6.2. Update PCIM's Class "PolicyGroup"
  contents:
  - "6.2. Update PCIM's Class \"PolicyGroup\"\n   The PolicyGroup class is moved,\
    \ so that it is now derived from\n   PolicySet.\n   NAME             PolicyGroup\n\
    \   DESCRIPTION      A container for a set of related PolicyRules and\n      \
    \              PolicyGroups.\n   DERIVED FROM     PolicySet\n   ABSTRACT     \
    \    FALSE\n   PROPERTIES       (none)\n"
- title: 6.3. Update PCIM's Class "PolicyRule"
  contents:
  - "6.3. Update PCIM's Class \"PolicyRule\"\n   The PolicyRule class is moved, so\
    \ that it is now derived from\n   PolicySet.  The Priority property is also deprecated\
    \ in PolicyRule,\n   and PolicyRoles is now inherited from the parent class PolicySet.\n\
    \   Finally, a new property ExecutionStrategy is introduced, paralleling\n   the\
    \ property of the same name in the class CompoundPolicyAction.\n   NAME      \
    \       PolicyRule\n   DESCRIPTION      The central class for representing the\
    \ \"If Condition\n                    then Action\" semantics associated with\
    \ a policy\n                    rule.\n   DERIVED FROM     PolicySet\n   ABSTRACT\
    \         FALSE\n   PROPERTIES       Enabled\n                    ConditionListType\n\
    \                    RuleUsage\n                    Priority DEPRECATED FOR PolicySetComponent.Priority\n\
    \                                  AND FOR PolicySetInSystem.Priority\n      \
    \              Mandatory\n                    SequencedActions\n             \
    \       ExecutionStrategy\n   The property ExecutionStrategy defines the execution\
    \ strategy to be\n   used upon the sequenced actions aggregated by this PolicyRule.\
    \ (An\n   equivalent ExecutionStrategy property is also defined for the\n   CompoundPolicyAction\
    \ class, to provide the same indication for the\n   sequenced actions aggregated\
    \ by a CompoundPolicyAction.)  This\n   document defines three execution strategies:\n\
    \   Do Until Success - execute actions according to predefined order,\n      \
    \                until successful execution of a single action.\n   Do All - \
    \          execute ALL actions which are part of the modeled\n               \
    \       set, according to their predefined order.\n                      Continue\
    \ doing this, even if one or more of the\n                      actions fails.\n\
    \   Do Until Failure - execute actions according to predefined order,\n      \
    \                until the first failure in execution of a single\n          \
    \            sub-action.\n   The property definition is as follows:\n   NAME \
    \            ExecutionStrategy\n   DESCRIPTION      An enumeration indicating\
    \ how to interpret the\n                    action ordering for the actions aggregated\
    \ by this\n                    PolicyRule.\n   SYNTAX           uint16 (ENUM,\
    \ {1=Do Until Success, 2=Do All, 3=Do\n                    Until Failure} )\n\
    \   DEFAULT VALUE    Do All (2)\n"
- title: 6.4. The Class "SimplePolicyCondition"
  contents:
  - "6.4. The Class \"SimplePolicyCondition\"\n   A simple policy condition is composed\
    \ of an ordered triplet:\n      <Variable>  MATCH  <Value>\n   No formal modeling\
    \ of the MATCH operator is provided.  The 'match'\n   relationship is implied.\
    \  Such simple conditions are evaluated by\n   answering the question:\n     \
    \ Does <variable> match <value>?\n   The 'match' relationship is to be interpreted\
    \ by analyzing the\n   variable and value instances associated with the simple\
    \ condition.\n   Simple conditions are building blocks for more complex Boolean\n\
    \   Conditions, modeled by the CompoundPolicyCondition class.\n   The SimplePolicyCondition\
    \ class is derived from the PolicyCondition\n   class defined in PCIM.\n   A variable\
    \ and a value must be associated with a simple condition to\n   make it a meaningful\
    \ condition, using, respectively, the aggregations\n   PolicyVariableInSimplePolicyCondition\
    \ and\n   PolicyValueInSimplePolicyCondition.\n   The class definition is as follows:\n\
    \   NAME             SimplePolicyCondition\n   DERIVED FROM     PolicyCondition\n\
    \   ABSTRACT         False\n   PROPERTIES       (none)\n"
- title: 6.5. The Class "CompoundPolicyCondition"
  contents:
  - "6.5. The Class \"CompoundPolicyCondition\"\n   This class represents a compound\
    \ policy condition, formed by\n   aggregation of simpler policy conditions.\n\
    \   NAME             CompoundPolicyCondition\n   DESCRIPTION      A subclass of\
    \ PolicyCondition that introduces the\n                    ConditionListType property,\
    \ used for assigning DNF /\n                    CNF semantics to subordinate policy\
    \ conditions.\n   DERIVED FROM     PolicyCondition\n   ABSTRACT         FALSE\n\
    \   PROPERTIES       ConditionListType\n   The ConditionListType property is used\
    \ to specify whether the list of\n   policy conditions associated with this compound\
    \ policy condition is\n   in disjunctive normal form (DNF) or conjunctive normal\
    \ form (CNF).\n   If this property is not present, the list type defaults to DNF.\
    \  The\n   property definition is as follows:\n   NAME             ConditionListType\n\
    \   DESCRIPTION      Indicates whether the list of policy conditions\n       \
    \             associated with this policy rule is in disjunctive\n           \
    \         normal form (DNF) or conjunctive normal form (CNF).\n   SYNTAX     \
    \      uint16\n   VALUES           DNF(1), CNF(2)\n   DEFAULT VALUE    DNF(1)\n"
- title: 6.6. The Class "CompoundFilterCondition"
  contents:
  - "6.6. The Class \"CompoundFilterCondition\"\n   This subclass of CompoundPolicyCondition\
    \ introduces one additional\n   property, the boolean IsMirrored.  This property\
    \ turns on or off the\n   \"flipping\" of corresponding source and destination\
    \ fields in a filter\n   specification.\n   NAME             CompoundFilterCondition\n\
    \   DESCRIPTION      A subclass of CompoundPolicyCondition that\n            \
    \        introduces the IsMirrored property.\n   DERIVED FROM     CompoundPolicyCondition\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       IsMirrored\n   The IsMirrored\
    \ property indicates whether packets that \"mirror\" a\n   compound filter condition\
    \ should be treated as matching the filter.\n   The property definition is as\
    \ follows:\n   NAME             IsMirrored\n   DESCRIPTION      Indicates whether\
    \ packets that mirror the specified\n                    filter are to be treated\
    \ as matching the filter.\n   SYNTAX           boolean\n   DEFAULT VALUE    FALSE\n"
- title: 6.7. The Class "SimplePolicyAction"
  contents:
  - "6.7. The Class \"SimplePolicyAction\"\n   The SimplePolicyAction class models\
    \ the elementary set operation.\n   \"SET <variable> TO <value>\".  The set operator\
    \ MUST overwrite an old\n   value of the variable.\n   Two aggregations are used\
    \ in order to create the pair <variable>\n   <value>.  The aggregation PolicyVariableInSimplePolicyAction\
    \ relates\n   a SimplePolicyAction to a single variable instance.  Similarly,\
    \ the\n   aggregation PolicyValueInSimplePolicyAction relates a\n   SimplePolicyAction\
    \ to a single value instance.  Both aggregations are\n   defined in this document.\n\
    \   NAME             SimplePolicyAction\n   DESCRIPTION      A subclass of PolicyAction\
    \ that introduces the\n                    notion of \"SET variable TO value\"\
    .\n   DERIVED FROM     PolicyAction\n   ABSTRACT         FALSE\n   PROPERTIES\
    \       (none)\n"
- title: 6.8. The Class "CompoundPolicyAction"
  contents:
  - "6.8. The Class \"CompoundPolicyAction\"\n   The CompoundPolicyAction class is\
    \ used to represent an expression\n   consisting of an ordered sequence of action\
    \ terms.  Each action term\n   is represented as a subclass of the PolicyAction\
    \ class, defined in\n   [PCIM].  Compound actions are constructed by associating\
    \ dependent\n   action terms together using the PolicyActionInPolicyAction\n \
    \  aggregation.\n   The class definition is as follows:\n   NAME             CompoundPolicyAction\n\
    \   DESCRIPTION      A class for representing sequenced action terms.\n      \
    \              Each action term is defined to be a subclass of the\n         \
    \           PolicyAction class.\n   DERIVED FROM     PolicyAction\n   ABSTRACT\
    \         FALSE\n   PROPERTIES       SequencedActions\n                    ExecutionStrategy\n\
    \   This is a concrete class, and is therefore directly instantiable.\n   The\
    \ Property SequencedActions is identical to the SequencedActions\n   property\
    \ defined in PCIM for the class PolicyRule.\n   The property ExecutionStrategy\
    \ defines the execution strategy to be\n   used upon the sequenced actions associated\
    \ with this compound action.\n   (An equivalent ExecutionStrategy property is\
    \ also defined for the\n   PolicyRule class, to provide the same indication for\
    \ the sequenced\n   actions associated with a PolicyRule.)  This document defines\
    \ three\n   execution strategies:\n   Do Until Success - execute actions according\
    \ to predefined order,\n                      until successful execution of a\
    \ single sub-action.\n   Do All -           execute ALL actions which are part\
    \ of the modeled\n                      set, according to their predefined order.\n\
    \                      Continue doing this, even if one or more of the\n     \
    \                 sub-actions fails.\n   Do Until Failure - execute actions according\
    \ to predefined order,\n                      until the first failure in execution\
    \ of a single\n                      sub-action.\n   Since a CompoundPolicyAction\
    \ may itself be aggregated either by a\n   PolicyRule or by another CompoundPolicyAction,\
    \ its success or failure\n   will be an input to the aggregating entity's execution\
    \ strategy.\n   Consequently, the following rules are specified, for determining\n\
    \   whether a CompoundPolicyAction succeeds or fails:\n   If the CompoundPolicyAction's\
    \ ExecutionStrategy is Do Until Success,\n   then:\n      o  If one component\
    \ action succeeds, then the CompoundPolicyAction\n         succeeds.\n      o\
    \  If all component actions fail, then the CompoundPolicyAction\n         fails.\n\
    \   If the CompoundPolicyAction's ExecutionStrategy is Do All, then:\n      o\
    \  If all component actions succeed, then the CompoundPolicyAction\n         succeeds.\n\
    \      o  If at least one component action fails, then the\n         CompoundPolicyAction\
    \ fails.\n   If the CompoundPolicyAction's ExecutionStrategy is Do Until Failure,\n\
    \   then:\n      o  If all component actions succeed, then the CompoundPolicyAction\n\
    \         succeeds.\n      o  If at least one component action fails, then the\n\
    \         CompoundPolicyAction fails.\n   The definition of the ExecutionStrategy\
    \ property is as follows:\n   NAME             ExecutionStrategy\n   DESCRIPTION\
    \      An enumeration indicating how to interpret the\n                    action\
    \ ordering for the actions aggregated by this\n                    CompoundPolicyAction.\n\
    \   SYNTAX           uint16 (ENUM, {1=Do Until Success, 2=Do All, 3=Do\n     \
    \               Until Failure} )\n   DEFAULT VALUE    Do All (2)\n"
- title: 6.9. The Abstract Class "PolicyVariable"
  contents:
  - "6.9. The Abstract Class \"PolicyVariable\"\n   Variables are used for building\
    \ individual conditions.  The variable\n   specifies the property of a flow or\
    \ an event that should be matched\n   when evaluating the condition.  However,\
    \ not every combination of a\n   variable and a value creates a meaningful condition.\
    \  For example, a\n   source IP address variable can not be matched against a\
    \ value that\n   specifies a port number.  A given variable selects the set of\n\
    \   matchable value types.\n   A variable can have constraints that limit the\
    \ set of values within a\n   particular value type that can be matched against\
    \ it in a condition.\n   For example, a source-port variable limits the set of\
    \ values to\n   represent integers to the range of 0-65535.  Integers outside\
    \ this\n   range cannot be matched to the source-port variable, even though they\n\
    \   are of the correct data type.  Constraints for a given variable are\n   indicated\
    \ through the ExpectedPolicyValuesForVariable association.\n   The PolicyVariable\
    \ is an abstract class.  Implicit and explicit\n   context variable classes are\
    \ defined as sub classes of the\n   PolicyVariable class.  A set of implicit variables\
    \ is defined in this\n   document as well.\n   The class definition is as follows:\n\
    \   NAME             PolicyVariable\n   DERIVED FROM     Policy\n   ABSTRACT \
    \        TRUE\n   PROPERTIES       (none)\n"
- title: 6.10. The Class "PolicyExplicitVariable"
  contents:
  - "6.10. The Class \"PolicyExplicitVariable\"\n   Explicitly defined policy variables\
    \ are evaluated within the context\n   of the CIM Schema and its modeling constructs.\
    \  The\n   PolicyExplicitVariable class indicates the exact model property to\
    \ be\n   evaluated or manipulated.  See Section 5.8.6 for a complete\n   discussion\
    \ of what happens when the values of the ModelClass and\n   ModelProperty properties\
    \ in an instance of this class do not\n   correspond to the characteristics of\
    \ the model construct being\n   evaluated or updated.\n   The class definition\
    \ is as follows:\n   NAME             PolicyExplicitVariable\n   DERIVED FROM\
    \     PolicyVariable\n   ABSTRACT         False\n   PROPERTIES       ModelClass,\
    \ ModelProperty\n"
- title: 6.10.1. The Single-Valued Property "ModelClass"
  contents:
  - "6.10.1. The Single-Valued Property \"ModelClass\"\n   This property is a string\
    \ specifying the class name whose property is\n   evaluated or set as a PolicyVariable.\n\
    \   The property is defined as follows:\n   NAME             ModelClass\n   SYNTAX\
    \           String\n"
- title: 6.10.2. The Single-Valued Property ModelProperty
  contents:
  - "6.10.2. The Single-Valued Property ModelProperty\n   This property is a string\
    \ specifying the property name, within the\n   ModelClass, which is evaluated\
    \ or set as a PolicyVariable.  The\n   property is defined as follows:\n   NAME\
    \             ModelProperty\n   SYNTAX           String\n"
- title: 6.11. The Abstract Class "PolicyImplicitVariable"
  contents:
  - "6.11. The Abstract Class \"PolicyImplicitVariable\"\n   Implicitly defined policy\
    \ variables are evaluated outside of the\n   context of the CIM Schema and its\
    \ modeling constructs.  Subclasses\n   specify the data type and semantics of\
    \ the PolicyVariables.\n   Interpretation and evaluation of a PolicyImplicitVariable\
    \ can vary,\n   depending on the particular context in which it is used.  For\n\
    \   example, a \"SourceIP\" address may denote the source address field of\n \
    \  an IP packet header, or the sender address delivered by an RSVP PATH\n   message.\n\
    \   The class definition is as follows:\n   NAME             PolicyImplicitVariable\n\
    \   DERIVED FROM     PolicyVariable\n   ABSTRACT         True\n   PROPERTIES \
    \      ValueTypes[ ]\n"
- title: 6.11.1. The Multi-Valued Property "ValueTypes"
  contents:
  - "6.11.1. The Multi-Valued Property \"ValueTypes\"\n   This property is a set of\
    \ strings specifying an unordered list of\n   possible value/data types that can\
    \ be used in simple conditions and\n   actions, with this variable.  The value\
    \ types are specified by their\n   class names (subclasses of PolicyValue such\
    \ as PolicyStringValue).\n   The list of class names enables an application to\
    \ search on a\n   specific name, as well as to ensure that the data type of the\n\
    \   variable is of the correct type.\n   The list of default ValueTypes for each\
    \ subclass of\n   PolicyImplicitVariable is specified within that variable's\n\
    \   definition.\n   The property is defined as follows:\n   NAME             ValueTypes\n\
    \   SYNTAX           String\n"
- title: 6.12. Subclasses of "PolicyImplicitVariable" Specified in PCIMe
  contents:
  - "6.12. Subclasses of \"PolicyImplicitVariable\" Specified in PCIMe\n   The following\
    \ subclasses of PolicyImplicitVariable are defined in\n   PCIMe.\n"
- title: 6.12.1. The Class "PolicySourceIPv4Variable"
  contents:
  - "6.12.1. The Class \"PolicySourceIPv4Variable\"\n   NAME             PolicySourceIPv4Variable\n\
    \   DESCRIPTION      The source IPv4 address. of the outermost IP packet\n   \
    \                 header.  \"Outermost\" here refers to the IP packet as\n   \
    \                 it flows on the wire, before any headers have been\n       \
    \             stripped from it.\n                    ALLOWED VALUE TYPES:\n  \
    \                    - PolicyIPv4AddrValue\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.2. The Class "PolicySourceIPv6Variable"
  contents:
  - "6.12.2. The Class \"PolicySourceIPv6Variable\"\n   NAME             PolicySourceIPv6Variable\n\
    \   DESCRIPTION      The source IPv6 address of the outermost IP packet\n    \
    \                header.  \"Outermost\" here refers to the IP packet as\n    \
    \                it flows on the wire, before any headers have been\n        \
    \            stripped from it.\n                    ALLOWED VALUE TYPES:\n   \
    \                   - PolicyIPv6AddrValue\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.3. The Class "PolicyDestinationIPv4Variable"
  contents:
  - "6.12.3. The Class \"PolicyDestinationIPv4Variable\"\n   NAME             PolicyDestinationIPv4Variable\n\
    \   DESCRIPTION      The destination IPv4 address of the outermost IP\n      \
    \              packet header.  \"Outermost\" here refers to the IP\n         \
    \           packet as it flows on the wire, before any headers\n             \
    \       have been stripped from it.\n                    ALLOWED VALUE TYPES:\n\
    \                      - PolicyIPv4AddrValue\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.4. The Class "PolicyDestinationIPv6Variable"
  contents:
  - "6.12.4. The Class \"PolicyDestinationIPv6Variable\"\n   NAME             PolicyDestinationIPv6Variable\n\
    \   DESCRIPTION      The destination IPv6 address of the outermost IP\n      \
    \              packet header.  \"Outermost\" here refers to the IP\n         \
    \           packet as it flows on the wire, before any headers\n             \
    \       have been stripped from it.\n                    ALLOWED VALUE TYPES:\n\
    \                    - PolicyIPv6AddrValue\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.5. The Class "PolicySourcePortVariable"
  contents:
  - "6.12.5. The Class \"PolicySourcePortVariable\"\n   NAME             PolicySourcePortVariable\n\
    \   DESCRIPTION      Ports are defined as the abstraction that transport\n   \
    \                 protocols use to distinguish among multiple\n              \
    \      destinations within a given host computer.  For TCP\n                 \
    \   and UDP flows, the PolicySourcePortVariable is\n                    logically\
    \ bound to the source port field of the\n                    outermost UDP or\
    \ TCP packet header.  \"Outermost\"\n                    here refers to the IP\
    \ packet as it flows on the\n                    wire, before any headers have\
    \ been stripped from\n                    it.\n                    ALLOWED VALUE\
    \ TYPES:\n                      - PolicyIntegerValue (0..65535)\n   DERIVED FROM\
    \     PolicyImplicitVariable\n   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.6. The Class "PolicyDestinationPortVariable"
  contents:
  - "6.12.6. The Class \"PolicyDestinationPortVariable\"\n   NAME             PolicyDestinationPortVariable\n\
    \   DESCRIPTION      Ports are defined as the abstraction that transport\n   \
    \                 protocols use to distinguish among multiple\n              \
    \      destinations within a given host computer.  For TCP\n                 \
    \   and UDP flows, the PolicyDestinationPortVariable is\n                    logically\
    \ bound to the destination port field of the\n                    outermost UDP\
    \ or TCP packet header.  \"Outermost\"\n                    here refers to the\
    \ IP packet as it flows on the\n                    wire, before any headers have\
    \ been stripped from it.\n                   ALLOWED VALUE TYPES:\n          \
    \            - PolicyIntegerValue (0..65535)\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.7. The Class "PolicyIPProtocolVariable"
  contents:
  - "6.12.7. The Class \"PolicyIPProtocolVariable\"\n   NAME             PolicyIPProtocolVariable\n\
    \   DESCRIPTION      The IP protocol number.\n                    ALLOWED VALUE\
    \ TYPES:\n                      - PolicyIntegerValue (0..255)\n   DERIVED FROM\
    \     PolicyImplicitVariable\n   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.8. The Class "PolicyIPVersionVariable"
  contents:
  - "6.12.8. The Class \"PolicyIPVersionVariable\"\n   NAME             PolicyIPVersionVariable\n\
    \   DESCRIPTION      The IP version number.  The well-known values are 4\n   \
    \                 and 6.\n                    ALLOWED VALUE TYPES:\n         \
    \             - PolicyIntegerValue (0..15)\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.9. The Class "PolicyIPToSVariable"
  contents:
  - "6.12.9. The Class \"PolicyIPToSVariable\"\n   NAME             PolicyIPToSVariable\n\
    \   DESCRIPTION      The IP TOS octet.\n                    ALLOWED VALUE TYPES:\n\
    \                      - PolicyIntegerValue (0..255)\n                      -\
    \ PolicyBitStringValue (8 bits)\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.10. The Class "PolicyDSCPVariable"
  contents:
  - "6.12.10. The Class \"PolicyDSCPVariable\"\n   NAME             PolicyDSCPVariable\n\
    \   DESCRIPTION      The 6 bit Differentiated Service Code Point.\n          \
    \          ALLOWED VALUE TYPES:\n                      - PolicyIntegerValue (0..63)\n\
    \                      - PolicyBitStringValue (6 bits)\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.11. The Class "PolicyFlowIdVariable"
  contents:
  - "6.12.11. The Class \"PolicyFlowIdVariable\"\n   NAME             PolicyFlowIdVariable\n\
    \   DESCRIPTION      The flow identifier of the outermost IPv6 packet\n      \
    \              header.  \"Outermost\" here refers to the IP packet as\n      \
    \              it flows on the wire, before any headers have been\n          \
    \          stripped from it.\n                    ALLOWED VALUE TYPES:\n     \
    \                 - PolicyIntegerValue (0..1048575\n                      - PolicyBitStringValue\
    \ (20 bits)\n   DERIVED FROM     PolicyImplicitVariable\n   ABSTRACT         FALSE\n\
    \   PROPERTIES       (none)\n"
- title: 6.12.12. The Class "PolicySourceMACVariable"
  contents:
  - "6.12.12. The Class \"PolicySourceMACVariable\"\n   NAME             PolicySourceMACVariable\n\
    \   DESCRIPTION      The source MAC address.\n                    ALLOWED VALUE\
    \ TYPES:\n                      - PolicyMACAddrValue\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.13. The Class "PolicyDestinationMACVariable"
  contents:
  - "6.12.13. The Class \"PolicyDestinationMACVariable\"\n   NAME             PolicyDestinationMACVariable\n\
    \   DESCRIPTION      The destination MAC address.\n                    ALLOWED\
    \ VALUE TYPES:\n                      - PolicyMACAddrValue\n   DERIVED FROM  \
    \   PolicyImplicitVariable\n   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.14. The Class "PolicyVLANVariable"
  contents:
  - "6.12.14. The Class \"PolicyVLANVariable\"\n   NAME             PolicyVLANVariable\n\
    \   DESCRIPTION      The virtual Bridged Local Area Network Identifier, a\n  \
    \                  12-bit field as defined in the IEEE 802.1q standard.\n    \
    \                ALLOWED VALUE TYPES:\n                      - PolicyIntegerValue\
    \ (0..4095)\n                      - PolicyBitStringValue (12 bits)\n   DERIVED\
    \ FROM     PolicyImplicitVariable\n   ABSTRACT         FALSE\n   PROPERTIES  \
    \     (none)\n"
- title: 6.12.15. The Class "PolicyCoSVariable"
  contents:
  - "6.12.15. The Class \"PolicyCoSVariable\"\n   NAME             PolicyCoSVariable\n\
    \   DESCRIPTION      Class of Service, a 3-bit field, used in the layer 2\n  \
    \                  header to select the forwarding treatment.  Bound to\n    \
    \                the IEEE 802.1q user-priority field.\n                    ALLOWED\
    \ VALUE TYPES:\n                      - PolicyIntegerValue (0..7)\n          \
    \            - PolicyBitStringValue (3 bits)\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.16. The Class "PolicyEthertypeVariable"
  contents:
  - "6.12.16. The Class \"PolicyEthertypeVariable\"\n   NAME             PolicyEthertypeVariable\n\
    \   DESCRIPTION      The Ethertype protocol number of Ethernet frames.\n     \
    \               ALLOWED VALUE TYPES:\n                      - PolicyIntegerValue\
    \ (0..65535)\n                      - PolicyBitStringValue (16 bits)\n   DERIVED\
    \ FROM     PolicyImplicitVariable\n   ABSTRACT         FALSE\n   PROPERTIES  \
    \     (none)\n"
- title: 6.12.17. The Class "PolicySourceSAPVariable"
  contents:
  - "6.12.17. The Class \"PolicySourceSAPVariable\"\n   NAME             PolicySourceSAPVariable\n\
    \   DESCRIPTION      The Source Service Access Point (SAP) number of the\n   \
    \                 IEEE 802.2 LLC header.\n                    ALLOWED VALUE TYPES:\n\
    \                      - PolicyIntegerValue (0..255)\n                      -\
    \ PolicyBitStringValue (8 bits)\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.18. The Class "PolicyDestinationSAPVariable"
  contents:
  - "6.12.18. The Class \"PolicyDestinationSAPVariable\"\n   NAME             PolicyDestinationSAPVariable\n\
    \   DESCRIPTION      The Destination Service Access Point (SAP) number of\n  \
    \                  the IEEE 802.2 LLC header.\n                    ALLOWED VALUE\
    \ TYPES:\n                      - PolicyIntegerValue (0..255)\n              \
    \        - PolicyBitStringValue (8 bits)\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.19. The Class "PolicySNAPOUIVariable"
  contents:
  - "6.12.19. The Class \"PolicySNAPOUIVariable\"\n   NAME PolicySNAPOUIVariable\n\
    \   DESCRIPTION      The value of the first three octets of the Sub-\n       \
    \             Network Access Protocol (SNAP) Protocol Identifier\n           \
    \         field for 802.2 SNAP encapsulation, containing an\n                \
    \    Organizationally Unique Identifier (OUI).  The value\n                  \
    \  00-00-00 indicates the encapsulation of Ethernet\n                    frames\
    \ (RFC 1042).  OUI value 00-00-F8 indicates the\n                    special encapsulation\
    \ of Ethernet frames by certain\n                    types of bridges (IEEE 802.1H).\
    \  Other values are\n                    supported, but are not further defined\
    \ here.  These\n                    OUI values are to be interpreted according\
    \ to the\n                    endian-notation conventions of IEEE 802.  For either\n\
    \                    of the two Ethernet encapsulations, the remainder of\n  \
    \                  the Protocol Identifier field is represented by the\n     \
    \               PolicySNAPTypeVariable.\n                    ALLOWED VALUE TYPES:\n\
    \                    - PolicyIntegerValue (0..16777215)\n                    -\
    \ PolicyBitStringValue (24 bits)\n   DERIVED          FROM PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.20. The Class "PolicySNAPTypeVariable"
  contents:
  - "6.12.20. The Class \"PolicySNAPTypeVariable\"\n   NAME             PolicySNAPTypeVariable\n\
    \   DESCRIPTION      The value of the 4th and 5th octets of the Sub-\n       \
    \             Network Access Protocol (SNAP) Protocol Identifier\n           \
    \         field for IEEE 802 SNAP encapsulation when the\n                   \
    \ PolicySNAPOUIVariable indicates one of the two\n                    Encapsulated\
    \ Ethernet frame formats.  This value is\n                    undefined for other\
    \ values of PolicySNAPOUIVariable.\n                    ALLOWED VALUE TYPES:\n\
    \                      - PolicyIntegerValue (0..65535)\n                     \
    \ - PolicyBitStringValue (16 bits)\n   DERIVED FROM     PolicyImplicitVariable\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.12.21. The Class "PolicyFlowDirectionVariable"
  contents:
  - "6.12.21. The Class \"PolicyFlowDirectionVariable\"\n   NAME             PolicyFlowDirectionVariable\n\
    \   DESCRIPTION      The direction of a flow relative to a network\n         \
    \           element.  Direction may be \"IN\" and/or \"OUT\".\n              \
    \      ALLOWED VALUE TYPES:\n                      - PolicyStringValue ('IN\"\
    , \"OUT\")\n   DERIVED FROM     PolicyImplicitVariable\n   ABSTRACT         FALSE\n\
    \   PROPERTIES       (none)\n   To match on both inbound and outbound flows, the\
    \ associated\n   PolicyStringValue object has two entries in its StringList property:\n\
    \   \"IN\" and \"OUT\".\n"
- title: 6.13. The Abstract Class "PolicyValue"
  contents:
  - "6.13. The Abstract Class \"PolicyValue\"\n   This is an abstract class that serves\
    \ as the base class for all\n   subclasses that are used to define value objects\
    \ in the PCIMe.  It is\n   used for defining values and constants used in policy\
    \ conditions.\n   The class definition is as follows:\n   NAME             PolicyValue\n\
    \   DERIVED FROM     Policy\n   ABSTRACT         True\n   PROPERTIES       (none)\n"
- title: 6.14. Subclasses of "PolicyValue" Specified in PCIMe
  contents:
  - "6.14. Subclasses of \"PolicyValue\" Specified in PCIMe\n   The following subsections\
    \ contain the PolicyValue subclasses defined\n   in PCIMe.  Additional subclasses\
    \ may be defined in models derived\n   from PCIMe.\n"
- title: 6.14.1. The Class "PolicyIPv4AddrValue"
  contents:
  - "6.14.1. The Class \"PolicyIPv4AddrValue\"\n   This class is used to provide a\
    \ list of IPv4Addresses, hostnames and\n   address range values to be matched\
    \ against in a policy condition.\n   The class definition is as follows:\n   NAME\
    \             PolicyIPv4AddrValue\n   DERIVED FROM     PolicyValue\n   ABSTRACT\
    \         False\n   PROPERTIES       IPv4AddrList[ ]\n   The IPv4AddrList property\
    \ provides an unordered list of strings, each\n   specifying a single IPv4 address,\
    \ a hostname, or a range of IPv4\n   addresses, according to the ABNF definition\
    \ [6] of an IPv4 address,\n   as specified below:\n   IPv4address = 1*3DIGIT \"\
    .\" 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT\n   IPv4prefix  = IPv4address \"/\"\
    \ 1*2DIGIT\n   IPv4range = IPv4address\"-\"IPv4address\n   IPv4maskedaddress =\
    \ IPv4address\",\"IPv4address\n   Hostname (as defined in [4])\n   In the above\
    \ definition, each string entry is either:\n   1. A single IPv4address in dot\
    \ notation, as defined above.  Example:\n      121.1.1.2\n   2. An IPv4prefix\
    \ address range, as defined above, specified by an\n      address and a prefix\
    \ length, separated by \"/\".  Example:\n      2.3.128.0/15\n   3. An IPv4range\
    \ address range defined above, specified by a starting\n      address in dot notation\
    \ and an ending address in dot notation,\n      separated by \"-\".  The range\
    \ includes all addresses between the\n      range's starting and ending addresses,\
    \ including these two\n      addresses.  Example: 1.1.22.1-1.1.22.5\n   4. An\
    \ IPv4maskedaddress address range, as defined above, specified by\n      an address\
    \ and mask.  The address and mask are represented in dot\n      notation, separated\
    \ by a comma \",\".  The masked address appears\n      before the comma, and the\
    \ mask appears after the comma.  Example:\n      2.3.128.0,255.255.248.0.\n  \
    \ 5. A single Hostname.  The Hostname format follows the guidelines and\n    \
    \  restrictions specified in [4].  Example: www.bigcompany.com.\n   Conditions\
    \ matching IPv4AddrValues evaluate to true according to the\n   generic matching\
    \ rules.  Additionally, a hostname is matched against\n   another valid IPv4address\
    \ representation by resolving the hostname\n   into an IPv4 address first, and\
    \ then comparing the addresses\n   afterwards.  Matching hostnames against each\
    \ other is done using a\n   string comparison of the two names.\n   The property\
    \ definition is as follows:\n   NAME             IPv4AddrList\n   SYNTAX     \
    \      String\n   FORMAT           IPv4address | IPv4prefix | IPv4range |\n  \
    \                  IPv4maskedaddress | hostname\n"
- title: 6.14.2. The Class "PolicyIPv6AddrValue
  contents:
  - "6.14.2. The Class \"PolicyIPv6AddrValue\n   This class is used to define a list\
    \ of IPv6 addresses, hostnames, and\n   address range values.  The class definition\
    \ is as follows:\n   NAME             PolicyIPv6AddrValue\n   DERIVED FROM   \
    \  PolicyValue\n   ABSTRACT         False\n   PROPERTIES       IPv6AddrList[ ]\n\
    \   The property IPv6AddrList provides an unordered list of strings, each\n  \
    \ specifying an IPv6 address, a hostname, or a range of IPv6 addresses.\n   IPv6\
    \ address format definition uses the standard address format\n   defined in [7].\
    \  The ABNF definition [6] as specified in [7] is:\n   IPv6address = hexpart [\
    \ \":\" IPv4address ]\n   IPv4address = 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT\
    \ \".\" 1*3DIGIT\n   IPv6prefix  = hexpart \"/\" 1*2DIGIT\n   hexpart = hexseq\
    \ | hexseq \"::\" [ hexseq ] | \"::\" [ hexseq ]\n   hexseq  = hex4 *( \":\" hex4)\n\
    \   hex4    = 1*4HEXDIG\n   IPv6range = IPv6address\"-\"IPv6address\n   IPv6maskedaddress\
    \ = IPv6address\",\"IPv6address\n   Hostname (as defines in [NAMES])\n   Each\
    \ string entry is either:\n   1. A single IPv6address as defined above.\n   2.\
    \ A single Hostname.  Hostname format follows guidelines and\n      restrictions\
    \ specified in [4].\n   3. An IPv6range address range, specified by a starting\
    \ address in dot\n      notation and an ending address in dot notation, separated\
    \ by \"-\".\n      The range includes all addresses between the range's starting\
    \ and\n      ending addresses, including these two addresses.\n   4. An IPv4maskedaddress\
    \ address range defined above specified by an\n      address and mask.  The address\
    \ and mask are represented in dot\n      notation separated by a comma \",\".\n\
    \   5. A single IPv6prefix as defined above.\n   Conditions matching IPv6AddrValues\
    \ evaluate to true according to the\n   generic matching rules.  Additionally,\
    \ a hostname is matched against\n   another valid IPv6address representation by\
    \ resolving the hostname\n   into an IPv6 address first, and then comparing the\
    \ addresses\n   afterwards.  Matching hostnames against each other is done using\
    \ a\n   string comparison of the two names.\n"
- title: 6.14.3. The Class "PolicyMACAddrValue"
  contents:
  - "6.14.3. The Class \"PolicyMACAddrValue\"\n   This class is used to define a list\
    \ of MAC addresses and MAC address\n   range values.  The class definition is\
    \ as follows:\n   NAME             PolicyMACAddrValue\n   DERIVED FROM     PolicyValue\n\
    \   ABSTRACT         False\n   PROPERTIES       MACAddrList[ ]\n   The property\
    \ MACAddrList provides an unordered list of strings, each\n   specifying a MAC\
    \ address or a range of MAC addresses.  The 802 MAC\n   address canonical format\
    \ is used.  The ABNF definition [6] is:\n   MACaddress  = 1*4HEXDIG \":\" 1*4HEXDIG\
    \ \":\" 1*4HEXDIG\n   MACmaskedaddress = MACaddress\",\"MACaddress\n   Each string\
    \ entry is either:\n   1. A single MAC address.  Example: 0000:00A5:0000\n   2.\
    \ A MACmaskedaddress address range defined specified by an address\n      and\
    \ mask.  The mask specifies the relevant bits in the address.\n      Example:\
    \ 0000:00A5:0000,FFFF:FFFF:0000 defines a range of MAC\n      addresses in which\
    \ the first four octets are equal to 0000:00A5.\n   The property definition is\
    \ as follows:\n   NAME             MACAddrList\n   SYNTAX           String\n \
    \  FORMAT           MACaddress | MACmaskedaddress\n"
- title: 6.14.4. The Class "PolicyStringValue"
  contents:
  - "6.14.4. The Class \"PolicyStringValue\"\n   This class is used to represent a\
    \ single string value, or a set of\n   string values.  Each value can have wildcards.\
    \  The class definition\n   is as follows:\n   NAME             PolicyStringValue\n\
    \   DERIVED FROM     PolicyValue\n   ABSTRACT         False\n   PROPERTIES   \
    \    StringList[ ]\n   The property StringList provides an unordered list of strings,\
    \ each\n   representing a single string with wildcards.  The asterisk character\n\
    \   \"*\" is used as a wildcard, and represents an arbitrary substring\n   replacement.\
    \  For example, the value \"abc*def\" matches the string\n   \"abcxyzdef\", and\
    \ the value \"abc*def*\" matches the string\n   \"abcxxxdefyyyzzz\".  The syntax\
    \ definition is identical to the\n   substring assertion syntax defined in [5].\
    \  If the asterisk character\n   is required as part of the string value itself,\
    \ it MUST be quoted as\n   described in Section 4.3 of [5].\n   The property definition\
    \ is as follows:\n   NAME                 StringList\n   SYNTAX              \
    \ String\n"
- title: 6.14.5. The Class "PolicyBitStringValue"
  contents:
  - "6.14.5. The Class \"PolicyBitStringValue\"\n   This class is used to represent\
    \ a single bit string value, or a set\n   of bit string values.  The class definition\
    \ is as follows:\n   NAME             PolicyBitStringValue\n   DERIVED FROM  \
    \   PolicyValue\n   ABSTRACT         False\n   PROPERTIES       BitStringList[\
    \ ]\n   The property BitStringList provides an unordered list of strings,\n  \
    \ each representing a single bit string or a set of bit strings.  The\n   number\
    \ of bits specified SHOULD equal the number of bits of the\n   expected variable.\
    \  For example, for a one-octet variable, 8 bits\n   should be specified.  If\
    \ the variable does not have a fixed length,\n   the bit string should be matched\
    \ against the variable's most\n   significant bit string.  The formal definition\
    \ of a bit string is:\n   binary-digit = \"0\" / \"1\"\n   bitString = 1*binary-digit\n\
    \   maskedBitString = bitString\",\"bitString\n   Each string entry is either:\n\
    \   1. A single bit string. Example: 00111010\n   2. A range of bit strings specified\
    \ using a bit string and a bit\n      mask.  The bit string and mask fields have\
    \ the same number of bits\n      specified.  The mask bit string specifies the\
    \ significant bits in\n      the bit string value.  For example, 110110, 100110\
    \ and 110111\n      would match the maskedBitString 100110,101110 but 100100 would\n\
    \      not.\n   The property definition is as follows:\n   NAME             BitStringList\n\
    \   SYNTAX           String\n   FORMAT           bitString | maskedBitString\n"
- title: 6.14.6. The Class "PolicyIntegerValue"
  contents:
  - "6.14.6. The Class \"PolicyIntegerValue\"\n   This class provides a list of integer\
    \ and integer range values.\n   Integers of arbitrary sizes can be represented.\
    \  The class definition\n   is as follows:\n   NAME             PolicyIntegerValue\n\
    \   DERIVED FROM     PolicyValue\n   ABSTRACT         False\n   PROPERTIES   \
    \    IntegerList[ ]\n   The property IntegerList provides an unordered list of\
    \ integers and\n   integer range values, represented as strings.  The format of\
    \ this\n   property takes one of the following forms:\n   1. An integer value.\n\
    \   2. A range of integers. The range is specified by a starting integer\n   \
    \   and an ending integer, separated by '..'.  The starting integer\n      MUST\
    \ be less than or equal to the ending integer.  The range\n      includes all\
    \ integers between the starting and ending integers,\n      including these two\
    \ integers.\n   To represent a range of integers that is not bounded, the reserved\n\
    \   words -INFINITY and/or INFINITY can be used in place of the starting\n   and\
    \ ending integers.  In addition to ordinary integer matches,\n   INFINITY matches\
    \ INFINITY and -INFINITY matches -INFINITY.\n   The ABNF definition [6] is:\n\
    \   integer = [-]1*DIGIT | \"INFINITY\" | \"-INFINITY\"\n   integerrange = integer\"\
    ..\"integer\n   Using ranges, the operators greater-than, greater-than-or-equal-to,\n\
    \   less- than, and less-than-or-equal-to can be expressed.  For example,\n  \
    \ \"X is- greater-than 5\" (where X is an integer) can be translated to\n   \"\
    X matches 6-INFINITY\".  This enables the match condition semantics\n   of the\
    \ operator for the SimplePolicyCondition class to be kept simple\n   (i.e., just\
    \ the value \"match\").\n   The property definition is as follows:\n   NAME  \
    \           IntegerList\n   SYNTAX           String\n   FORMAT           integer\
    \ | integerrange\n"
- title: 6.14.7. The Class "PolicyBooleanValue"
  contents:
  - "6.14.7. The Class \"PolicyBooleanValue\"\n   This class is used to represent\
    \ a Boolean (TRUE/FALSE) value.  The\n   class definition is as follows:\n   NAME\
    \             PolicyBooleanValue\n   DERIVED FROM     PolicyValue\n   ABSTRACT\
    \         False\n   PROPERTIES       BooleanValue\n   The property definition\
    \ is as follows:\n   NAME             BooleanValue\n   SYNTAX           boolean\n"
- title: 6.15. The Class "PolicyRoleCollection"
  contents:
  - "6.15. The Class \"PolicyRoleCollection\"\n   This class represents a collection\
    \ of managed elements that share a\n   common role.  The PolicyRoleCollection\
    \ always exists in the context\n   of a system, specified using the PolicyRoleCollectionInSystem\n\
    \   association.  The value of the PolicyRole property in this class\n   specifies\
    \ the role, and can be matched with the value(s) in the\n   PolicyRoles array\
    \ in PolicyRules and PolicyGroups.  ManagedElements\n   that share the role defined\
    \ in this collection are aggregated into\n   the collection via the association\
    \ ElementInPolicyRoleCollection.\n   NAME             PolicyRoleCollection\n \
    \  DESCRIPTION      A subclass of the CIM Collection class used to group\n   \
    \                 together managed elements that share a role.\n   DERIVED FROM\
    \     Collection\n   ABSTRACT         FALSE\n   PROPERTIES       PolicyRole\n"
- title: 6.15.1. The Single-Valued Property "PolicyRole"
  contents:
  - "6.15.1. The Single-Valued Property \"PolicyRole\"\n   This property represents\
    \ the role associated with a\n   PolicyRoleCollection.  The property definition\
    \ is as follows:\n   NAME             PolicyRole\n   DESCRIPTION      A string\
    \ representing the role associated with a\n                    PolicyRoleCollection.\n\
    \   SYNTAX           string\n"
- title: 6.16. The Class "ReusablePolicyContainer"
  contents:
  - "6.16. The Class \"ReusablePolicyContainer\"\n   The new class ReusablePolicyContainer\
    \ is defined as follows:\n   NAME             ReusablePolicyContainer\n   DESCRIPTION\
    \      A class representing an administratively defined\n                    container\
    \ for reusable policy-related information.\n                    This class does\
    \ not introduce any additional\n                    properties beyond those in\
    \ its superclass\n                    AdminDomain.  It does, however, participate\
    \ in\n                    a number of unique associations.\n   DERIVED FROM  \
    \   AdminDomain\n   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.17. Deprecate PCIM's Class "PolicyRepository"
  contents:
  - "6.17. Deprecate PCIM's Class \"PolicyRepository\"\n   The class definition of\
    \ PolicyRepository (from PCIM) is updated as\n   follows, with an indication that\
    \ the class has been deprecated.  Note\n   that when an element of the model is\
    \ deprecated, its replacement\n   element is identified explicitly.\n   NAME \
    \            PolicyRepository\n   DEPRECATED FOR   ReusablePolicyContainer\n \
    \  DESCRIPTION      A class representing an administratively defined\n       \
    \             container for reusable policy-related information.\n           \
    \         This class does not introduce any additional\n                    properties\
    \ beyond those in its superclass\n                    AdminDomain.  It does, however,\
    \ participate in a\n                    number of unique associations.\n   DERIVED\
    \ FROM     AdminDomain\n   ABSTRACT         FALSE\n   PROPERTIES       (none)\n"
- title: 6.18. The Abstract Class "FilterEntryBase"
  contents:
  - "6.18. The Abstract Class \"FilterEntryBase\"\n   FilterEntryBase is the abstract\
    \ base class from which all filter\n   entry classes are derived.  It serves as\
    \ the endpoint for the\n   EntriesInFilterList aggregation, which groups filter\
    \ entries into\n   filter lists.  Its properties include CIM naming attributes\
    \ and an\n   IsNegated boolean property (to easily \"NOT\" the match information\n\
    \   specified in an instance of one of its subclasses).\n   The class definition\
    \ is as follows:\n   NAME                FilterEntryBase\n   DESCRIPTION     \
    \    An abstract class representing a single\n                       filter that\
    \ is aggregated into a\n                       FilterList via the aggregation\n\
    \                       EntriesInFilterList.\n   DERIVED FROM        LogicalElement\n\
    \   TYPE                Abstract\n   PROPERTIES          IsNegated\n"
- title: 6.19. The Class "IpHeadersFilter"
  contents:
  - "6.19. The Class \"IpHeadersFilter\"\n   This concrete class contains the most\
    \ commonly required properties\n   for performing filtering on IP, TCP or UDP\
    \ headers.  Properties not\n   present in an instance of IPHeadersFilter are treated\
    \ as 'all\n   values'.  A property HdrIpVersion identifies whether the IP addresses\n\
    \   in an instance are IPv4 or IPv6 addresses.  Since the source and\n   destination\
    \ IP addresses come from the same packet header, they will\n   always be of the\
    \ same type.\n   The class definition is as follows:\n   NAME                IpHeadersFilter\n\
    \   DESCRIPTION         A class representing an entire IP\n                  \
    \     header filter, or any subset of one.\n   DERIVED FROM        FilterEntryBase\n\
    \   TYPE                Concrete\n   PROPERTIES          HdrIpVersion, HdrSrcAddress,\n\
    \                       HdrSrcAddressEndOfRange, HdrSrcMask,\n               \
    \        HdrDestAddress, HdrDestAddressEndOfRange,\n                       HdrDestMask,\
    \ HdrProtocolID,\n                       HdrSrcPortStart, HdrSrcPortEnd,\n   \
    \                    HdrDestPortStart, HdrDestPortEnd, HdrDSCP[ ],\n         \
    \              HdrFlowLabel\n"
- title: 6.19.1. The Property HdrIpVersion
  contents:
  - "6.19.1. The Property HdrIpVersion\n   This property is an 8-bit unsigned integer,\
    \ identifying the version\n   of the IP addresses to be filtered on.  IP versions\
    \ are identified as\n   they are in the Version field of the IP packet header\
    \ - IPv4 = 4,\n   IPv6 = 6.  These two values are the only ones defined for this\n\
    \   property.\n   The value of this property determines the sizes of the OctetStrings\n\
    \   in the six properties HdrSrcAddress, HdrSrcAddressEndOfRange,\n   HdrSrcMask,\
    \ HdrDestAddress, HdrDestAddressEndOfRange, and\n   HdrDestMask, as follows:\n\
    \   o  IPv4:  OctetString(SIZE (4))\n   o  IPv6:  OctetString(SIZE (16|20)), depending\
    \ on whether a scope\n      identifier is present\n   If a value for this property\
    \ is not provided, then the filter does\n   not consider IP version in selecting\
    \ matching packets, i.e., IP\n   version matches for all values.  In this case,\
    \ the HdrSrcAddress,\n   HdrSrcAddressEndOfRange, HdrSrcMask, HdrDestAddress,\n\
    \   HdrDestAddressEndOfRange, and HdrDestMask must also not be present.\n"
- title: 6.19.2. The Property HdrSrcAddress
  contents:
  - "6.19.2. The Property HdrSrcAddress\n   This property is an OctetString, of a\
    \ size determined by the value of\n   the HdrIpVersion property, representing\
    \ a source IP address.  When\n   there is no HdrSrcAddressEndOfRange value, this\
    \ value is compared to\n   the source address in the IP header, subject to the\
    \ mask represented\n   in the HdrSrcMask property.  (Note that the mask is ANDed\
    \ with the\n   address.)  When there is a HdrSrcAddressEndOfRange value, this\
    \ value\n   is the start of the specified range (i.e., the HdrSrcAddress is lower\n\
    \   than the HdrSrcAddressEndOfRange) that is compared to the source\n   address\
    \ in the IP header and matches on any value in the range.\n   If a value for this\
    \ property is not provided, then the filter does\n   not consider HdrSrcAddress\
    \ in selecting matching packets, i.e.,\n   HdrSrcAddress matches for all values.\n"
- title: 6.19.3. The Property HdrSrcAddressEndOfRange
  contents:
  - "6.19.3. The Property HdrSrcAddressEndOfRange\n   This property is an OctetString,\
    \ of a size determined by the value of\n   the HdrIpVersion property, representing\
    \ the end of a range of source\n   IP addresses (inclusive), where the start of\
    \ the range is the\n   HdrSrcAddress property value.\n   If a value for HdrSrcAddress\
    \ is not provided, then this property also\n   MUST NOT be provided.  If a value\
    \ for this property is provided, then\n   HdrSrcMask MUST NOT be provided.\n"
- title: 6.19.4. The Property HdrSrcMask
  contents:
  - "6.19.4. The Property HdrSrcMask\n   This property is an OctetString, of a size\
    \ determined by the value of\n   the HdrIpVersion property, representing a mask\
    \ to be used in\n   comparing the source address in the IP header with the value\n\
    \   represented in the HdrSrcAddress property.\n   If a value for this property\
    \ is not provided, then the filter does\n   not consider HdrSrcMask in selecting\
    \ matching packets, i.e., the\n   value of HdrSrcAddress or the source address\
    \ range must match the\n   source address in the packet exactly.  If a value for\
    \ this property\n   is provided, then HdrSrcAddressEndOfRange MUST NOT be provided.\n"
- title: 6.19.5. The Property HdrDestAddress
  contents:
  - "6.19.5. The Property HdrDestAddress\n   This property is an OctetString, of a\
    \ size determined by the value of\n   the HdrIpVersion property, representing\
    \ a destination IP address.\n   When there is no HdrDestAddressEndOfRange value,\
    \ this value is\n   compared to the destination address in the IP header, subject\
    \ to the\n   mask represented in the HdrDestMask property.  (Note that the mask\
    \ is\n   ANDed with the address.)  When there is a HdrDestAddressEndOfRange\n\
    \   value, this value is the start of the specified range (i.e., the\n   HdrDestAddress\
    \ is lower than the HdrDestAddressEndOfRange) that is\n   compared to the destination\
    \ address in the IP header and matches on\n   any value in the range.\n   If a\
    \ value for this property is not provided, then the filter does\n   not consider\
    \ HdrDestAddress in selecting matching packets, i.e.,\n   HdrDestAddress matches\
    \ for all values.\n"
- title: 6.19.6. The Property HdrDestAddressEndOfRange
  contents:
  - "6.19.6. The Property HdrDestAddressEndOfRange\n   This property is an OctetString,\
    \ of a size determined by the value of\n   the HdrIpVersion property, representing\
    \ the end of a range of\n   destination IP addresses (inclusive), where the start\
    \ of the range is\n   the HdrDestAddress property value.\n   If a value for HdrDestAddress\
    \ is not provided, then this property\n   also MUST NOT be provided.  If a value\
    \ for this property is provided,\n   then HdrDestMask MUST NOT be provided.\n"
- title: 6.19.7. The Property HdrDestMask
  contents:
  - "6.19.7. The Property HdrDestMask\n   This property is an OctetString, of a size\
    \ determined by the value of\n   the HdrIpVersion property, representing a mask\
    \ to be used in\n   comparing the destination address in the IP header with the\
    \ value\n   represented in the HdrDestAddress property.\n   If a value for this\
    \ property is not provided, then the filter does\n   not consider HdrDestMask\
    \ in selecting matching packets, i.e., the\n   value of HdrDestAddress or the\
    \ destination address range must match\n   the destination address in the packet\
    \ exactly.  If a value for this\n   property is provided, then HdrDestAddressEndOfRange\
    \ MUST NOT be\n   provided.\n"
- title: 6.19.8. The Property HdrProtocolID
  contents:
  - "6.19.8. The Property HdrProtocolID\n   This property is an 8-bit unsigned integer,\
    \ representing an IP\n   protocol type.  This value is compared to the Protocol\
    \ field in the\n   IP header.\n   If a value for this property is not provided,\
    \ then the filter does\n   not consider HdrProtocolID in selecting matching packets,\
    \ i.e.,\n   HdrProtocolID matches for all values.\n"
- title: 6.19.9. The Property HdrSrcPortStart
  contents:
  - "6.19.9. The Property HdrSrcPortStart\n   This property is a 16-bit unsigned integer,\
    \ representing the lower\n   end of a range of UDP or TCP source ports.  The upper\
    \ end of the\n   range is represented by the HdrSrcPortEnd property.  The value\
    \ of\n   HdrSrcPortStart MUST be no greater than the value of HdrSrcPortEnd.\n\
    \   A single port is indicated by equal values for HdrSrcPortStart and\n   HdrSrcPortEnd.\n\
    \   A source port filter is evaluated by testing whether the source port\n   identified\
    \ in the IP header falls within the range of values between\n   HdrSrcPortStart\
    \ and HdrSrcPortEnd, including these two end points.\n   If a value for this property\
    \ is not provided, then the filter does\n   not consider HdrSrcPortStart in selecting\
    \ matching packets, i.e.,\n   there is no lower bound in matching source port\
    \ values.\n"
- title: 6.19.10. The Property HdrSrcPortEnd
  contents:
  - "6.19.10. The Property HdrSrcPortEnd\n   This property is a 16-bit unsigned integer,\
    \ representing the upper\n   end of a range of UDP or TCP source ports.  The lower\
    \ end of the\n   range is represented by the HdrSrcPortStart property.  The value\
    \ of\n   HdrSrcPortEnd MUST be no less than the value of HdrSrcPortStart.  A\n\
    \   single port is indicated by equal values for HdrSrcPortStart and\n   HdrSrcPortEnd.\n\
    \   A source port filter is evaluated by testing whether the source port\n   identified\
    \ in the IP header falls within the range of values between\n   HdrSrcPortStart\
    \ and HdrSrcPortEnd, including these two end points.\n   If a value for this property\
    \ is not provided, then the filter does\n   not consider HdrSrcPortEnd in selecting\
    \ matching packets, i.e., there\n   is no upper bound in matching source port\
    \ values.\n"
- title: 6.19.11. The Property HdrDestPortStart
  contents:
  - "6.19.11. The Property HdrDestPortStart\n   This property is a 16-bit unsigned\
    \ integer, representing the lower\n   end of a range of UDP or TCP destination\
    \ ports.  The upper end of the\n   range is represented by the HdrDestPortEnd\
    \ property.  The value of\n   HdrDestPortStart MUST be no greater than the value\
    \ of HdrDestPortEnd.\n   A single port is indicated by equal values for HdrDestPortStart\
    \ and\n   HdrDestPortEnd.\n   A destination port filter is evaluated by testing\
    \ whether the\n   destination port identified in the IP header falls within the\
    \ range\n   of values between HdrDestPortStart and HdrDestPortEnd, including\n\
    \   these two end points.\n   If a value for this property is not provided, then\
    \ the filter does\n   not consider HdrDestPortStart in selecting matching packets,\
    \ i.e.,\n   there is no lower bound in matching destination port values.\n"
- title: 6.19.12. The Property HdrDestPortEnd
  contents:
  - "6.19.12. The Property HdrDestPortEnd\n   This property is a 16-bit unsigned integer,\
    \ representing the upper\n   end of a range of UDP or TCP destination ports. \
    \ The lower end of the\n   range is represented by the HdrDestPortStart property.\
    \  The value of\n   HdrDestPortEnd MUST be no less than the value of HdrDestPortStart.\
    \  A\n   single port is indicated by equal values for HdrDestPortStart and\n \
    \  HdrDestPortEnd.\n   A destination port filter is evaluated by testing whether\
    \ the\n   destination port identified in the IP header falls within the range\n\
    \   of values between HdrDestPortStart and HdrDestPortEnd, including\n   these\
    \ two end points.\n   If a value for this property is not provided, then the filter\
    \ does\n   not consider HdrDestPortEnd in selecting matching packets, i.e.,\n\
    \   there is no upper bound in matching destination port values.\n"
- title: 6.19.13. The Property HdrDSCP
  contents:
  - "6.19.13. The Property HdrDSCP\n   The property HdrDSCP is defined as an array\
    \ of uint8's, restricted to\n   the range 0..63.  Since DSCPs are defined as discrete\
    \ code points,\n   with no inherent structure, there is no semantically significant\n\
    \   relationship between different DSCPs.  Consequently, there is no\n   provision\
    \ for specifying a range of DSCPs in this property.  However,\n   a list of individual\
    \ DSCPs, which are ORed together to form a filter,\n   is supported by the array\
    \ syntax.\n   If a value for this property is not provided, then the filter does\n\
    \   not consider HdrDSCP in selecting matching packets, i.e., HdrDSCP\n   matches\
    \ for all values.\n"
- title: 6.19.14. The Property HdrFlowLabel
  contents:
  - "6.19.14. The Property HdrFlowLabel\n   The 20-bit Flow Label field in the IPv6\
    \ header may be used by a\n   source to label sequences of packets for which it\
    \ requests special\n   handling by IPv6 devices, such as non-default quality of\
    \ service or\n   'real-time' service.  This property is an octet string of size\
    \ 3\n   (that is, 24 bits), in which the 20-bit Flow Label appears in the\n  \
    \ rightmost 20 bits, padded on the left with b'0000'.\n   If a value for this\
    \ property is not provided, then the filter does\n   not consider HdrFlowLabel\
    \ in selecting matching packets, i.e.,\n   HdrFlowLabel matches for all values.\n"
- title: 6.20. The Class "8021Filter"
  contents:
  - "6.20. The Class \"8021Filter\"\n   This concrete class allows 802.1.source and\
    \ destination MAC\n   addresses, as well as the 802.1 protocol ID, priority, and\
    \ VLAN\n   identifier fields, to be expressed in a single object\n   The class\
    \ definition is as follows:\n   NAME                8021Filter\n   DESCRIPTION\
    \         A class that allows 802.1 source\n                       and destination\
    \ MAC address and\n                       protocol ID, priority, and VLAN\n  \
    \                     identifier filters to be\n                       expressed\
    \ in a single object.\n   DERIVED FROM        FilterEntryBase\n   TYPE       \
    \         Concrete\n   PROPERTIES          8021HdrSrcMACAddr, 8021HdrSrcMACMask,\n\
    \                       8021HdrDestMACAddr, 8021HdrDestMACMask,\n            \
    \           8021HdrProtocolID, 8021HdrPriorityValue,\n                       8021HDRVLANID\n"
- title: 6.20.1. The Property 8021HdrSrcMACAddr
  contents:
  - "6.20.1. The Property 8021HdrSrcMACAddr\n   This property is an OctetString of\
    \ size 6, representing a 48-bit\n   source MAC address in canonical format.  This\
    \ value is compared to\n   the SourceAddress field in the MAC header, subject\
    \ to the mask\n   represented in the 8021HdrSrcMACMask property.\n   If a value\
    \ for this property is not provided, then the filter does\n   not consider 8021HdrSrcMACAddr\
    \ in selecting matching packets, i.e.,\n   8021HdrSrcMACAddr matches for all values.\n"
- title: 6.20.2. The Property 8021HdrSrcMACMask
  contents:
  - "6.20.2. The Property 8021HdrSrcMACMask\n   This property is an OctetString of\
    \ size 6, representing a 48-bit mask\n   to be used in comparing the SourceAddress\
    \ field in the MAC header\n   with the value represented in the 8021HdrSrcMACAddr\
    \ property.\n   If a value for this property is not provided, then the filter\
    \ does\n   not consider 8021HdrSrcMACMask in selecting matching packets, i.e.,\n\
    \   the value of 8021HdrSrcMACAddr must match the source MAC address in\n   the\
    \ packet exactly.\n"
- title: 6.20.3. The Property 8021HdrDestMACAddr
  contents:
  - "6.20.3. The Property 8021HdrDestMACAddr\n   This property is an OctetString of\
    \ size 6, representing a 48-bit\n   destination MAC address in canonical format.\
    \  This value is compared\n   to the DestinationAddress field in the MAC header,\
    \ subject to the\n   mask represented in the 8021HdrDestMACMask property.\n  \
    \ If a value for this property is not provided, then the filter does\n   not consider\
    \ 8021HdrDestMACAddr in selecting matching packets, i.e.,\n   8021HdrDestMACAddr\
    \ matches for all values.\n"
- title: 6.20.4. The Property 8021HdrDestMACMask
  contents:
  - "6.20.4. The Property 8021HdrDestMACMask\n   This property is an OctetString of\
    \ size 6, representing a 48-bit mask\n   to be used in comparing the DestinationAddress\
    \ field in the MAC\n   header with the value represented in the 8021HdrDestMACAddr\
    \ property.\n   If a value for this property is not provided, then the filter\
    \ does\n   not consider 8021HdrDestMACMask in selecting matching packets, i.e.,\n\
    \   the value of 8021HdrDestMACAddr must match the destination MAC\n   address\
    \ in the packet exactly.\n"
- title: 6.20.5. The Property 8021HdrProtocolID
  contents:
  - "6.20.5. The Property 8021HdrProtocolID\n   This property is a 16-bit unsigned\
    \ integer, representing an Ethernet\n   protocol type.  This value is compared\
    \ to the Ethernet Type field in\n   the 802.3 MAC header.\n   If a value for this\
    \ property is not provided, then the filter does\n   not consider 8021HdrProtocolID\
    \ in selecting matching packets, i.e.,\n   8021HdrProtocolID matches for all values.\n"
- title: 6.20.6. The Property 8021HdrPriorityValue
  contents:
  - "6.20.6. The Property 8021HdrPriorityValue\n   This property is an 8-bit unsigned\
    \ integer, representing an 802.1Q\n   priority.  This value is compared to the\
    \ Priority field in the 802.1Q\n   header.  Since the 802.1Q Priority field consists\
    \ of 3 bits, the\n   values for this property are limited to the range 0..7.\n\
    \   If a value for this property is not provided, then the filter does\n   not\
    \ consider 8021HdrPriorityValue in selecting matching packets,\n   i.e., 8021HdrPriorityValue\
    \ matches for all values.\n"
- title: 6.20.7. The Property 8021HdrVLANID
  contents:
  - "6.20.7. The Property 8021HdrVLANID\n   This property is a 32-bit unsigned integer,\
    \ representing an 802.1Q\n   VLAN Identifier.  This value is compared to the VLAN\
    \ ID field in the\n   802.1Q header.  Since the 802.1Q VLAN ID field consists\
    \ of 12 bits,\n   the values for this property are limited to the range 0..4095.\n\
    \   If a value for this property is not provided, then the filter does\n   not\
    \ consider 8021HdrVLANID in selecting matching packets, i.e.,\n   8021HdrVLANID\
    \ matches for all values.\n"
- title: 6.21. The Class FilterList
  contents:
  - "6.21. The Class FilterList\n   This is a concrete class that aggregates instances\
    \ of (subclasses of)\n   FilterEntryBase via the aggregation EntriesInFilterList.\
    \  It is\n   possible to aggregate different types of filters into a single\n\
    \   FilterList - for example, packet header filters (represented by the\n   IpHeadersFilter\
    \ class) and security filters (represented by\n   subclasses of FilterEntryBase\
    \ defined by IPsec).\n   The aggregation property EntriesInFilterList.EntrySequence\
    \ is always\n   set to 0, to indicate that the aggregated filter entries are ANDed\n\
    \   together to form a selector for a class of traffic.\n   The class definition\
    \ is as follows:\n   NAME                FilterList\n   DESCRIPTION         A\
    \ concrete class representing\n                       the aggregation of multiple\
    \ filters.\n   DERIVED FROM        LogicalElement\n   TYPE                Concrete\n\
    \   PROPERTIES          Direction\n"
- title: 6.21.1. The Property Direction
  contents:
  - "6.21.1. The Property Direction\n   This property is a 16-bit unsigned integer\
    \ enumeration, representing\n   the direction of the traffic flow to which the\
    \ FilterList is to be\n   applied.  Defined enumeration values are\n   o  NotApplicable(0)\n\
    \   o  Input(1)\n   o  Output(2)\n   o  Both(3) - This value is used to indicate\
    \ that the direction is\n      immaterial, e.g., to filter on a source subnet\
    \ regardless of\n      whether the flow is inbound or outbound\n   o  Mirrored(4)\
    \ - This value is also applicable to both inbound and\n      outbound flow processing,\
    \ but it indicates that the filter\n      criteria are applied asymmetrically\
    \ to traffic in both directions\n      and, thus, specifies the reversal of source\
    \ and destination\n      criteria (as opposed to the equality of these criteria\
    \ as\n      indicated by \"Both\").  The match conditions in the aggregated\n\
    \      FilterEntryBase subclass instances are defined from the\n      perspective\
    \ of outbound flows and applied to inbound flows as well\n      by reversing the\
    \ source and destination criteria.  So, for\n      example, consider a FilterList\
    \ with 3 filter entries indicating\n      destination port = 80, and source and\
    \ destination addresses of a\n      and b, respectively.  Then, for the outbound\
    \ direction, the filter\n      entries match as specified and the 'mirror' (for\
    \ the inbound\n      direction) matches on source port = 80 and source and destination\n\
    \      addresses of b and a, respectively.\n"
- title: 7. Association and Aggregation Definitions
  contents:
  - "7. Association and Aggregation Definitions\n   The following definitions supplement\
    \ those in PCIM itself.  PCIM\n   definitions that are not DEPRECATED here are\
    \ still current parts of\n   the overall Policy Core Information Model.\n"
- title: 7.1. The Aggregation "PolicySetComponent"
  contents:
  - "7.1. The Aggregation \"PolicySetComponent\"\n   PolicySetComponent is a new aggregation\
    \ class that collects instances\n   of PolicySet subclasses (PolicyGroups and\
    \ PolicyRules) into coherent\n   sets of policies.\n   NAME             PolicySetComponent\n\
    \   DESCRIPTION      A concrete class representing the components of a\n     \
    \               policy set that have the same decision strategy, and\n       \
    \             are prioritized within the set.\n   DERIVED FROM     PolicyComponent\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       GroupComponent[ref PolicySet[0..n]]\n\
    \                    PartComponent[ref PolicySet[0..n]]\n                    Priority\n\
    \   The definition of the Priority property is unchanged from its\n   previous\
    \ definition in [PCIM].\n   NAME             Priority\n   DESCRIPTION      A non-negative\
    \ integer for prioritizing this\n                    PolicySet component relative\
    \ to other components of\n                    the same PolicySet.  A larger value\
    \ indicates a\n                    higher priority.\n   SYNTAX           uint16\n\
    \   DEFAULT VALUE    0\n"
- title: 7.2. Deprecate PCIM's Aggregation "PolicyGroupInPolicyGroup"
  contents:
  - "7.2. Deprecate PCIM's Aggregation \"PolicyGroupInPolicyGroup\"\n   The new aggregation\
    \ PolicySetComponent is used directly to represent\n   aggregation of PolicyGroups\
    \ by a higher-level PolicyGroup.  Thus the\n   aggregation PolicyGroupInPolicyGroup\
    \ is no longer needed, and can be\n   deprecated.\n   NAME             PolicyGroupInPolicyGroup\n\
    \   DEPRECATED FOR   PolicySetComponent\n   DESCRIPTION      A class representing\
    \ the aggregation of PolicyGroups\n                    by a higher-level PolicyGroup.\n\
    \   DERIVED FROM     PolicyComponent\n   ABSTRACT         FALSE\n   PROPERTIES\
    \       GroupComponent[ref PolicyGroup[0..n]]\n                    PartComponent[ref\
    \ PolicyGroup[0..n]]\n"
- title: 7.3. Deprecate PCIM's Aggregation "PolicyRuleInPolicyGroup"
  contents:
  - "7.3. Deprecate PCIM's Aggregation \"PolicyRuleInPolicyGroup\"\n   The new aggregation\
    \ PolicySetComponent is used directly to represent\n   aggregation of PolicyRules\
    \ by a PolicyGroup.  Thus the aggregation\n   PolicyRuleInPolicyGroup is no longer\
    \ needed, and can be deprecated.\n   NAME             PolicyRuleInPolicyGroup\n\
    \   DEPRECATED FOR   PolicySetComponent\n   DESCRIPTION      A class representing\
    \ the aggregation of PolicyRules\n                    by a PolicyGroup.\n   DERIVED\
    \ FROM     PolicyComponent\n   ABSTRACT         FALSE\n   PROPERTIES       GroupComponent[ref\
    \ PolicyGroup[0..n]]\n                    PartComponent[ref PolicyRule[0..n]]\n"
- title: 7.4. The Abstract Association "PolicySetInSystem"
  contents:
  - "7.4. The Abstract Association \"PolicySetInSystem\"\n   PolicySetInSystem is\
    \ a new association that defines a relationship\n   between a System and a PolicySet\
    \ used in the administrative scope of\n   that system (e.g., AdminDomain, ComputerSystem).\
    \  The Priority\n   property is used to assign a relative priority to a PolicySet\
    \ within\n   the administrative scope in contexts where it is not a component\
    \ of\n   another PolicySet.\n   NAME             PolicySetInSystem\n   DESCRIPTION\
    \      An abstract class representing the relationship\n                    between\
    \ a System and a PolicySet that is used in the\n                    administrative\
    \ scope of the System.\n   DERIVED FROM     PolicyInSystem\n   ABSTRACT      \
    \   TRUE\n   PROPERTIES       Antecedent[ref System[0..1]]\n                 \
    \   Dependent [ref PolicySet[0..n]]\n                    Priority\n   The Priority\
    \ property is used to specify the relative priority of the\n   referenced PolicySet\
    \ when there are more than one PolicySet instances\n   applied to a managed resource\
    \ that are not PolicySetComponents and,\n   therefore, have no other relative\
    \ priority defined.\n   NAME             Priority\n   DESCRIPTION      A non-negative\
    \ integer for prioritizing the\n                    referenced PolicySet among\
    \ other PolicySet\n                    instances that are not components of a\
    \ common\n                    PolicySet.  A larger value indicates a higher\n\
    \                    priority.\n   SYNTAX           uint16\n   DEFAULT VALUE \
    \   0\n"
- title: 7.5. Update PCIM's Weak Association "PolicyGroupInSystem"
  contents:
  - "7.5. Update PCIM's Weak Association \"PolicyGroupInSystem\"\n   Regardless of\
    \ whether it a component of another PolicySet, a\n   PolicyGroup is itself defined\
    \ within the scope of a System.  This\n   association links a PolicyGroup to the\
    \ System in whose scope the\n   PolicyGroup is defined.  It is a subclass of the\
    \ abstract\n   PolicySetInSystem association.  The class definition for the\n\
    \   association is as follows:\n   NAME             PolicyGroupInSystem\n   DESCRIPTION\
    \      A class representing the fact that a PolicyGroup is\n                 \
    \   defined within the scope of a System.\n   DERIVED FROM     PolicySetInSystem\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       Antecedent[ref System[1..1]]\n\
    \                    Dependent     [ref PolicyGroup[weak]]\n   The Reference \"\
    Antecedent\" is inherited from PolicySetInSystem, and\n   overridden to restrict\
    \ its cardinality to [1..1].  It serves as an\n   object reference to a System\
    \ that provides a scope for one or more\n   PolicyGroups.  Since this is a weak\
    \ association, the cardinality for\n   this object reference is always 1, that\
    \ is, a PolicyGroup is always\n   defined within the scope of exactly one System.\n\
    \   The Reference \"Dependent\" is inherited from PolicySetInSystem, and\n   overridden\
    \ to become an object reference to a PolicyGroup defined\n   within the scope\
    \ of a System.  Note that for any single instance of\n   the association class\
    \ PolicyGroupInSystem, this property (like all\n   reference properties) is single-valued.\
    \  The [0..n] cardinality\n   indicates that a given System may have 0, 1, or\
    \ more than one\n   PolicyGroups defined within its scope.\n"
- title: 7.6. Update PCIM's Weak Association "PolicyRuleInSystem"
  contents:
  - "7.6. Update PCIM's Weak Association \"PolicyRuleInSystem\"\n   Regardless of\
    \ whether it a component of another PolicySet, a\n   PolicyRule is itself defined\
    \ within the scope of a System.  This\n   association links a PolicyRule to the\
    \ System in whose scope the\n   PolicyRule is defined.  It is a subclass of the\
    \ abstract\n   PolicySetInSystem association. The class definition for the\n \
    \  association is as follows:\n   NAME             PolicyRuleInSystem\n   DESCRIPTION\
    \      A class representing the fact that a PolicyRule is\n                  \
    \  defined within the scope of a System.\n   DERIVED FROM     PolicySetInSystem\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       Antecedent[ref System[1..1]]\n\
    \                    Dependent[ref PolicyRule[weak]]\n   The Reference \"Antecedent\"\
    \ is inherited from PolicySetInSystem, and\n   overridden to restrict its cardinality\
    \ to [1..1].  It serves as an\n   object reference to a System that provides a\
    \ scope for one or more\n   PolicyRules.  Since this is a weak association, the\
    \ cardinality for\n   this object reference is always 1, that is, a PolicyRule\
    \ is always\n   defined within the scope of exactly one System.\n   The Reference\
    \ \"Dependent\" is inherited from PolicySetInSystem, and\n   overridden to become\
    \ an object reference to a PolicyRule defined\n   within the scope of a System.\
    \  Note that for any single instance of\n   the association class PolicyRuleInSystem,\
    \ this property (like all\n   Reference properties) is single-valued.  The [0..n]\
    \ cardinality\n   indicates that a given System may have 0, 1, or more than one\n\
    \   PolicyRules defined within its scope.\n"
- title: 7.7. The Abstract Aggregation "PolicyConditionStructure"
  contents:
  - "7.7. The Abstract Aggregation \"PolicyConditionStructure\"\n   NAME         \
    \    PolicyConditionStructure\n   DESCRIPTION      A class representing the aggregation\
    \ of\n                    PolicyConditions by an aggregating instance.\n   DERIVED\
    \ FROM     PolicyComponent\n   ABSTRACT         TRUE\n   PROPERTIES       PartComponent[ref\
    \ PolicyCondition[0..n]]\n                    GroupNumber\n                  \
    \  ConditionNegated\n"
- title: 7.8. Update PCIM's Aggregation "PolicyConditionInPolicyRule"
  contents:
  - "7.8. Update PCIM's Aggregation \"PolicyConditionInPolicyRule\"\n   The PCIM aggregation\
    \ \"PolicyConditionInPolicyRule\" is updated, to\n   make it a subclass of the\
    \ new abstract aggregation\n   PolicyConditionStructure.  The properties GroupNumber\
    \ and\n   ConditionNegated are now inherited, rather than specified explicitly\n\
    \   as they were in PCIM.\n   NAME             PolicyConditionInPolicyRule\n \
    \  DESCRIPTION      A class representing the aggregation of\n                \
    \    PolicyConditions by a PolicyRule.\n   DERIVED FROM     PolicyConditionStructure\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       GroupComponent[ref PolicyRule[0..n]]\n"
- title: 7.9. The Aggregation "PolicyConditionInPolicyCondition"
  contents:
  - "7.9. The Aggregation \"PolicyConditionInPolicyCondition\"\n   A second subclass\
    \ of PolicyConditionStructure is defined,\n   representing the compounding of\
    \ policy conditions into a higher-level\n   policy condition.\n   NAME       \
    \      PolicyConditionInPolicyCondition\n   DESCRIPTION      A class representing\
    \ the aggregation of\n                    PolicyConditions by another PolicyCondition.\n\
    \   DERIVED FROM     PolicyConditionStructure\n   ABSTRACT         FALSE\n   PROPERTIES\
    \       GroupComponent[ref CompoundPolicyCondition[0..n]]\n"
- title: 7.10. The Abstract Aggregation "PolicyActionStructure"
  contents:
  - "7.10. The Abstract Aggregation \"PolicyActionStructure\"\n   NAME           \
    \  PolicyActionStructure\n   DESCRIPTION      A class representing the aggregation\
    \ of\n                    PolicyActions by an aggregating instance.\n   DERIVED\
    \ FROM     PolicyComponent\n   ABSTRACT         TRUE\n   PROPERTIES       PartComponent[ref\
    \ PolicyAction[0..n]]\n                    ActionOrder\n   The definition of the\
    \ ActionOrder property appears in Section 7.8.3\n   of PCIM [1].\n"
- title: 7.11. Update PCIM's Aggregation "PolicyActionInPolicyRule"
  contents:
  - "7.11. Update PCIM's Aggregation \"PolicyActionInPolicyRule\"\n   The PCIM aggregation\
    \ \"PolicyActionInPolicyRule\" is updated, to make\n   it a subclass of the new\
    \ abstract aggregation PolicyActionStructure.\n   The property ActionOrder is\
    \ now inherited, rather than specified\n   explicitly as it was in PCIM.\n   NAME\
    \             PolicyActionInPolicyRule\n   DESCRIPTION      A class representing\
    \ the aggregation of\n                    PolicyActions by a PolicyRule.\n   DERIVED\
    \ FROM     PolicyActionStructure\n   ABSTRACT         FALSE\n   PROPERTIES   \
    \    GroupComponent[ref PolicyRule[0..n]]\n"
- title: 7.12. The Aggregation "PolicyActionInPolicyAction"
  contents:
  - "7.12. The Aggregation \"PolicyActionInPolicyAction\"\n   A second subclass of\
    \ PolicyActionStructure is defined, representing\n   the compounding of policy\
    \ actions into a higher-level policy action.\n   NAME             PolicyActionInPolicyAction\n\
    \   DESCRIPTION      A class representing the aggregation of\n               \
    \     PolicyActions by another PolicyAction.\n   DERIVED FROM     PolicyActionStructure\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       GroupComponent[ref CompoundPolicyAction[0..n]]\n"
- title: 7.13. The Aggregation "PolicyVariableInSimplePolicyCondition"
  contents:
  - "7.13. The Aggregation \"PolicyVariableInSimplePolicyCondition\"\n   A simple\
    \ policy condition is represented as an ordered triplet\n   {variable, operator,\
    \ value}.  This aggregation provides the linkage\n   between a SimplePolicyCondition\
    \ instance and a single PolicyVariable.\n   The aggregation PolicyValueInSimplePolicyCondition\
    \ links the\n   SimplePolicyCondition to a single PolicyValue.  The Operator property\n\
    \   of SimplePolicyCondition represents the third element of the triplet,\n  \
    \ the operator.\n   The class definition for this aggregation is as follows:\n\
    \   NAME             PolicyVariableInSimplePolicyCondition\n   DERIVED FROM  \
    \   PolicyComponent\n   ABSTRACT         False\n   PROPERTIES       GroupComponent[ref\
    \ SimplePolicyCondition[0..n]]\n                    PartComponent[ref PolicyVariable[1..1]\
    \ ]\n   The reference property \"GroupComponent\" is inherited from\n   PolicyComponent,\
    \ and overridden to become an object reference to a\n   SimplePolicyCondition\
    \ that contains exactly one PolicyVariable.  Note\n   that for any single instance\
    \ of the aggregation class\n   PolicyVariableInSimplePolicyCondition, this property\
    \ is single-\n   valued.  The [0..n] cardinality indicates that there may be 0,\
    \ 1, or\n   more SimplePolicyCondition objects that contain any given policy\n\
    \   variable object.\n   The reference property \"PartComponent\" is inherited\
    \ from\n   PolicyComponent, and overridden to become an object reference to a\n\
    \   PolicyVariable that is defined within the scope of a\n   SimplePolicyCondition.\
    \  Note that for any single instance of the\n   association class PolicyVariableInSimplePolicyCondition,\
    \ this\n   property (like all reference properties) is single-valued.  The\n \
    \  [1..1] cardinality indicates that a SimplePolicyCondition must have\n   exactly\
    \ one policy variable defined within its scope in order to be\n   meaningful.\n"
- title: 7.14. The Aggregation "PolicyValueInSimplePolicyCondition"
  contents:
  - "7.14. The Aggregation \"PolicyValueInSimplePolicyCondition\"\n   A simple policy\
    \ condition is represented as an ordered triplet\n   {variable, operator, value}.\
    \  This aggregation provides the linkage\n   between a SimplePolicyCondition instance\
    \ and a single PolicyValue.\n   The aggregation PolicyVariableInSimplePolicyCondition\
    \ links the\n   SimplePolicyCondition to a single PolicyVariable.  The Operator\n\
    \   property of SimplePolicyCondition represents the third element of the\n  \
    \ triplet, the operator.\n   The class definition for this aggregation is as follows:\n\
    \   NAME             PolicyValueInSimplePolicyCondition\n   DERIVED FROM     PolicyComponent\n\
    \   ABSTRACT         False\n   PROPERTIES       GroupComponent[ref SimplePolicyCondition[0..n]]\n\
    \                    PartComponent[ref PolicyValue[1..1] ]\n   The reference property\
    \ \"GroupComponent\" is inherited from\n   PolicyComponent, and overridden to\
    \ become an object reference to a\n   SimplePolicyCondition that contains exactly\
    \ one PolicyValue.  Note\n   that for any single instance of the aggregation class\n\
    \   PolicyValueInSimplePolicyCondition, this property is single-valued.\n   The\
    \ [0..n] cardinality indicates that there may be 0, 1, or more\n   SimplePolicyCondition\
    \ objects that contain any given policy value\n   object.\n   The reference property\
    \ \"PartComponent\" is inherited from\n   PolicyComponent, and overridden to become\
    \ an object reference to a\n   PolicyValue that is defined within the scope of\
    \ a\n   SimplePolicyCondition.  Note that for any single instance of the\n   association\
    \ class PolicyValueInSimplePolicyCondition, this property\n   (like all reference\
    \ properties) is single-valued.  The [1..1]\n   cardinality indicates that a SimplePolicyCondition\
    \ must have exactly\n   one policy value defined within its scope in order to\
    \ be meaningful.\n"
- title: 7.15. The Aggregation "PolicyVariableInSimplePolicyAction"
  contents:
  - "7.15. The Aggregation \"PolicyVariableInSimplePolicyAction\"\n   A simple policy\
    \ action is represented as a pair {variable, value}.\n   This aggregation provides\
    \ the linkage between a SimplePolicyAction\n   instance and a single PolicyVariable.\
    \  The aggregation\n   PolicyValueInSimplePolicyAction links the SimplePolicyAction\
    \ to a\n   single PolicyValue.\n   The class definition for this aggregation is\
    \ as follows:\n   NAME             PolicyVariableInSimplePolicyAction\n   DERIVED\
    \ FROM     PolicyComponent\n   ABSTRACT         False\n   PROPERTIES       GroupComponent[ref\
    \ SimplePolicyAction[0..n]]\n                    PartComponent[ref PolicyVariable[1..1]\
    \ ]\n   The reference property \"GroupComponent\" is inherited from\n   PolicyComponent,\
    \ and overridden to become an object reference to a\n   SimplePolicyAction that\
    \ contains exactly one PolicyVariable.  Note\n   that for any single instance\
    \ of the aggregation class\n   PolicyVariableInSimplePolicyAction, this property\
    \ is single-valued.\n   The [0..n] cardinality indicates that there may be 0,\
    \ 1, or more\n   SimplePolicyAction objects that contain any given policy variable\n\
    \   object.\n   The reference property \"PartComponent\" is inherited from\n \
    \  PolicyComponent, and overridden to become an object reference to a\n   PolicyVariable\
    \ that is defined within the scope of a\n   SimplePolicyAction.  Note that for\
    \ any single instance of the\n   association class PolicyVariableInSimplePolicyAction,\
    \ this property\n   (like all reference properties) is single-valued.  The [1..1]\n\
    \   cardinality indicates that a SimplePolicyAction must have exactly one\n  \
    \ policy variable defined within its scope in order to be meaningful.\n"
- title: 7.16. The Aggregation "PolicyValueInSimplePolicyAction"
  contents:
  - "7.16. The Aggregation \"PolicyValueInSimplePolicyAction\"\n   A simple policy\
    \ action is represented as a pair {variable, value}.\n   This aggregation provides\
    \ the linkage between a SimplePolicyAction\n   instance and a single PolicyValue.\
    \  The aggregation\n   PolicyVariableInSimplePolicyAction links the SimplePolicyAction\
    \ to a\n   single PolicyVariable.\n   The class definition for this aggregation\
    \ is as follows:\n   NAME             PolicyValueInSimplePolicyAction\n   DERIVED\
    \ FROM     PolicyComponent\n   ABSTRACT         False\n   PROPERTIES       GroupComponent[ref\
    \ SimplePolicyAction[0..n]]\n                    PartComponent[ref PolicyValue[1..1]\
    \ ]\n   The reference property \"GroupComponent\" is inherited from\n   PolicyComponent,\
    \ and overridden to become an object reference to a\n   SimplePolicyAction that\
    \ contains exactly one PolicyValue.  Note that\n   for any single instance of\
    \ the aggregation class\n   PolicyValueInSimplePolicyAction, this property is\
    \ single-valued.  The\n   [0..n] cardinality indicates that there may be 0, 1,\
    \ or more\n   SimplePolicyAction objects that contain any given policy value\n\
    \   object.\n   The reference property \"PartComponent\" is inherited from\n \
    \  PolicyComponent, and overridden to become an object reference to a\n   PolicyValue\
    \ that is defined within the scope of a SimplePolicyAction.\n   Note that for\
    \ any single instance of the association class\n   PolicyValueInSimplePolicyAction,\
    \ this property (like all reference\n   properties) is single-valued.  The [1..1]\
    \ cardinality indicates that\n   a SimplePolicyAction must have exactly one policy\
    \ value defined\n   within its scope in order to be meaningful.\n"
- title: 7.17. The Association "ReusablePolicy"
  contents:
  - "7.17. The Association \"ReusablePolicy\"\n   The association ReusablePolicy makes\
    \ it possible to include any\n   subclass of the abstract class \"Policy\" in\
    \ a ReusablePolicyContainer.\n   NAME             ReusablePolicy\n   DESCRIPTION\
    \      A class representing the inclusion of a reusable\n                    policy\
    \ element in a ReusablePolicyContainer.\n                    Reusable elements\
    \ may be PolicyGroups, PolicyRules,\n                    PolicyConditions, PolicyActions,\
    \ PolicyVariables,\n                    PolicyValues, or instances of any other\
    \ subclasses\n                    of the abstract class Policy.\n   DERIVED FROM\
    \     PolicyInSystem\n   ABSTRACT         FALSE\n   PROPERTIES       Antecedent[ref\
    \ ReusablePolicyContainer[0..1]]\n"
- title: 7.18. Deprecate PCIM's "PolicyConditionInPolicyRepository"
  contents:
  - "7.18. Deprecate PCIM's \"PolicyConditionInPolicyRepository\"\n   NAME       \
    \      PolicyConditionInPolicyRepository\n   DEPRECATED FOR   ReusablePolicy\n\
    \   DESCRIPTION      A class representing the inclusion of a reusable\n      \
    \              PolicyCondition in a PolicyRepository.\n   DERIVED FROM     PolicyInSystem\n\
    \   ABSTRACT         FALSE\n   PROPERTIES       Antecedent[ref PolicyRepository[0..1]]\n\
    \                    Dependent[ref PolicyCondition[0..n]]\n"
- title: 7.19. Deprecate PCIM's "PolicyActionInPolicyRepository"
  contents:
  - "7.19. Deprecate PCIM's \"PolicyActionInPolicyRepository\"\n   NAME          \
    \   PolicyActionInPolicyRepository\n   DEPRECATED FOR   ReusablePolicy\n   DESCRIPTION\
    \      A class representing the inclusion of a reusable\n                    PolicyAction\
    \ in a PolicyRepository.\n   DERIVED FROM     PolicyInSystem\n   ABSTRACT    \
    \     FALSE\n   PROPERTIES       Antecedent[ref PolicyRepository[0..1]]\n    \
    \                Dependent[ref PolicyAction[0..n]]\n"
- title: 7.20. The Association ExpectedPolicyValuesForVariable
  contents:
  - "7.20. The Association ExpectedPolicyValuesForVariable\n   This association links\
    \ a PolicyValue object to a PolicyVariable\n   object, modeling the set of expected\
    \ values for that PolicyVariable.\n   Using this association, a variable (instance)\
    \ may be constrained to\n   be bound- to/assigned only a set of allowed values.\
    \  For example,\n   modeling an enumerated source port variable, one creates an\
    \ instance\n   of the PolicySourcePortVariable class and associates with it the\
    \ set\n   of values (integers) representing the allowed enumeration, using\n \
    \  appropriate number of instances of the\n   ExpectedPolicyValuesForVariable\
    \ association.\n   Note that a single variable instance may be constrained by\
    \ any number\n   of values, and a single value may be used to constrain any number\
    \ of\n   variables.  These relationships are manifested by the n-to-m\n   cardinality\
    \ of the association.\n   The purpose of this association is to support validation\
    \ of simple\n   policy conditions and simple policy actions, prior to their\n\
    \   deployment to an enforcement point.  This association, and the\n   PolicyValue\
    \ object that it refers to, plays no role when a PDP or a\n   PEP is evaluating\
    \ a simple policy condition, or executing a simple\n   policy action.  See Section\
    \ 5.8.3 for more details on this point.\n   The class definition for the association\
    \ is as follows:\n   NAME             ExpectedPolicyValuesForVariable\n   DESCRIPTION\
    \      A class representing the association of a set of\n                    expected\
    \ values to a variable object.\n   DERIVED FROM     Dependency\n   ABSTRACT  \
    \       FALSE\n   PROPERTIES       Antecedent [ref PolicyVariable[0..n]]\n   \
    \                 Dependent [ref PolicyValue [0..n]]\n   The reference property\
    \ Antecedent is inherited from Dependency.  Its\n   type and cardinality are overridden\
    \ to provide the semantics of a\n   variable optionally having value constraints.\
    \  The [0..n] cardinality\n   indicates that any number of variables may be constrained\
    \ by a given\n   value.\n   The reference property \"Dependent\" is inherited\
    \ from Dependency, and\n   overridden to become an object reference to a PolicyValue\n\
    \   representing the values that a particular PolicyVariable can have.\n   The\
    \ [0..n] cardinality indicates that a given policy variable may\n   have 0, 1\
    \ or more than one PolicyValues defined to model the set(s)\n   of values that\
    \ the policy variable can take.\n"
- title: 7.21. The Aggregation "ContainedDomain"
  contents:
  - "7.21. The Aggregation \"ContainedDomain\"\n   The aggregation ContainedDomain\
    \ provides a means of nesting of one\n   ReusablePolicyContainer inside another\
    \ one.  The aggregation is\n   defined at the level of ReusablePolicyContainer's\
    \ superclass,\n   AdminDomain, to give it applicability to areas other than Core\n\
    \   Policy.\n   NAME             ContainedDomain\n   DESCRIPTION      A class\
    \ representing the aggregation of lower level\n                    administrative\
    \ domains by a higher-level\n                    AdminDomain.\n   DERIVED FROM\
    \     SystemComponent\n   ABSTRACT         FALSE\n   PROPERTIES       GroupComponent[ref\
    \ AdminDomain [0..n]]\n                    PartComponent[ref AdminDomain [0..n]]\n"
- title: 7.22. Deprecate PCIM's "PolicyRepositoryInPolicyRepository"
  contents:
  - "7.22. Deprecate PCIM's \"PolicyRepositoryInPolicyRepository\"\n   NAME      \
    \       PolicyRepositoryInPolicyRepository\n   DEPRECATED FOR   ContainedDomain\n\
    \   DESCRIPTION      A class representing the aggregation of\n               \
    \     PolicyRepositories by a higher-level\n                    PolicyRepository.\n\
    \   DERIVED FROM     SystemComponent\n   ABSTRACT         FALSE\n   PROPERTIES\
    \       GroupComponent[ref PolicyRepository[0..n]]\n                    PartComponent[ref\
    \ PolicyRepository[0..n]]\n"
- title: 7.23. The Aggregation "EntriesInFilterList"
  contents:
  - "7.23. The Aggregation \"EntriesInFilterList\"\n   This aggregation is a specialization\
    \ of the Component aggregation; it\n   is used to define a set of filter entries\
    \ (subclasses of\n   FilterEntryBase) that are aggregated by a FilterList.\n \
    \  The cardinalities of the aggregation itself are 0..1 on the\n   FilterList\
    \ end, and 0..n on the FilterEntryBase end.  Thus in the\n   general case, a filter\
    \ entry can exist without being aggregated into\n   any FilterList.  However,\
    \ the only way a filter entry can figure in\n   the PCIMe model is by being aggregated\
    \ into a FilterList by this\n   aggregation.\n   The class definition for the\
    \ aggregation is as follows:\n   NAME              EntriesInFilterList\n   DESCRIPTION\
    \       An aggregation used to define a set of\n                     filter entries\
    \ (subclasses of\n                     FilterEntryBase) that are aggregated by\n\
    \                     a particular FilterList.\n   DERIVED FROM      Component\n\
    \   ABSTRACT          False\n   PROPERTIES        GroupComponent[ref\n       \
    \                 FilterList[0..1]],\n                     PartComponent[ref\n\
    \                        FilterEntryBase[0..n],\n                     EntrySequence\n"
- title: 7.23.1. The Reference GroupComponent
  contents:
  - "7.23.1. The Reference GroupComponent\n   This property is overridden in this\
    \ aggregation to represent an\n   object reference to a FilterList object (instead\
    \ of to the more\n   generic ManagedSystemElement object defined in its superclass).\
    \  It\n   also restricts the cardinality of the aggregate to 0..1 (instead of\n\
    \   the more generic 0-or-more), representing the fact that a filter\n   entry\
    \ always exists within the context of at most one FilterList.\n"
- title: 7.23.2. The Reference PartComponent
  contents:
  - "7.23.2. The Reference PartComponent\n   This property is overridden in this aggregation\
    \ to represent an\n   object reference to a FilterEntryBase object (instead of\
    \ to the more\n   generic ManagedSystemElement object defined in its superclass).\
    \  This\n   object represents a single filter entry, which may be aggregated with\n\
    \   other filter entries to form the FilterList.\n"
- title: 7.23.3. The Property EntrySequence
  contents:
  - "7.23.3. The Property EntrySequence\n   An unsigned 16-bit integer indicating\
    \ the order of the filter entry\n   relative to all others in the FilterList.\
    \  The default value '0'\n   indicates that order is not significant, because\
    \ the entries in this\n   FilterList are ANDed together.\n"
- title: 7.24. The Aggregation "ElementInPolicyRoleCollection"
  contents:
  - "7.24. The Aggregation \"ElementInPolicyRoleCollection\"\n   The following aggregation\
    \ is used to associate ManagedElements with a\n   PolicyRoleCollection object\
    \ that represents a role played by these\n   ManagedElements.\n   NAME       \
    \      ElementInPolicyRoleCollection\n   DESCRIPTION      A class representing\
    \ the inclusion of a\n                    ManagedElement in a collection, specified\
    \ as\n                    having a given role.  All the managed elements\n   \
    \                 in the collection share the same role.\n   DERIVED FROM    \
    \ MemberOfCollection\n   ABSTRACT         FALSE\n   PROPERTIES       Collection[ref\
    \ PolicyRoleCollection [0..n]]\n                    Member[ref ManagedElement\
    \ [0..n]]\n"
- title: 7.25. The Weak Association "PolicyRoleCollectionInSystem"
  contents:
  - "7.25. The Weak Association \"PolicyRoleCollectionInSystem\"\n   A PolicyRoleCollection\
    \ is defined within the scope of a System.  This\n   association links a PolicyRoleCollection\
    \ to the System in whose scope\n   it is defined.\n   When associating a PolicyRoleCollection\
    \ with a System, this should be\n   done consistently with the system that scopes\
    \ the policy rules/groups\n   that are applied to the resources in that collection.\
    \  A\n   PolicyRoleCollection is associated with the same system as the\n   applicable\
    \ PolicyRules and/or PolicyGroups, or to a System higher in\n   the tree formed\
    \ by the SystemComponent association.\n   The class definition for the association\
    \ is as follows:\n   NAME             PolicyRoleCollectionInSystem\n   DESCRIPTION\
    \      A class representing the fact that a\n                    PolicyRoleCollection\
    \ is defined within the scope of\n                    a System.\n   DERIVED FROM\
    \     Dependency\n   ABSTRACT         FALSE\n   PROPERTIES       Antecedent[ref\
    \ System[1..1]]\n                    Dependent[ref PolicyRoleCollection[weak]]\n\
    \   The reference property Antecedent is inherited from Dependency, and\n   overridden\
    \ to become an object reference to a System, and to restrict\n   its cardinality\
    \ to [1..1].  It serves as an object reference to a\n   System that provides a\
    \ scope for one or more PolicyRoleCollections.\n   Since this is a weak association,\
    \ the cardinality for this object\n   reference is always 1, that is, a PolicyRoleCollection\
    \ is always\n   defined within the scope of exactly one System.\n   The reference\
    \ property Dependent is inherited from Dependency, and\n   overridden to become\
    \ an object reference to a PolicyRoleCollection\n   defined within the scope of\
    \ a System.  Note that for any single\n   instance of the association class PolicyRoleCollectionInSystem,\
    \ this\n   property (like all Reference properties) is single-valued.  The\n \
    \  [0..n] cardinality indicates that a given System may have 0, 1, or\n   more\
    \ than one PolicyRoleCollections defined within its scope.\n"
- title: 8. Intellectual Property
  contents:
  - "8. Intellectual Property\n   The IETF takes no position regarding the validity\
    \ or scope of any\n   intellectual property or other rights that might be claimed\
    \ to\n   pertain to the implementation or use of the technology described in\n\
    \   this document or the extent to which any license under such rights\n   might\
    \ or might not be available; neither does it represent that it\n   has made any\
    \ effort to identify any such rights.  Information on the\n   IETF's procedures\
    \ with respect to rights in standards-track and\n   standards-related documentation\
    \ can be found in BCP-11.\n   Copies of claims of rights made available for publication\
    \ and any\n   assurances of licenses to be made available, or the result of an\n\
    \   attempt made to obtain a general license or permission for the use of\n  \
    \ such proprietary rights by implementers or users of this\n   specification can\
    \ be obtained from the IETF Secretariat.\n   The IETF invites any interested party\
    \ to bring to its attention any\n   copyrights, patents or patent applications,\
    \ or other proprietary\n   rights which may cover technology that may be required\
    \ to practice\n   this standard.  Please address the information to the IETF Executive\n\
    \   Director.\n"
- title: 9. Acknowledgements
  contents:
  - "9. Acknowledgements\n   The starting point for this document was PCIM itself\
    \ [1], and the\n   first three submodels derived from it [11], [12], [13].  The\
    \ authors\n   of these documents created the extensions to PCIM, and asked the\n\
    \   questions about PCIM, that are reflected in PCIMe.\n"
- title: 10. Contributors
  contents:
  - "10. Contributors\n   This document includes text written by a number of authors\
    \ (including\n   the editor), that was subsequently merged by the editor.  The\n\
    \   following people contributed text to this document:\n   Lee Rafalow\n   IBM\
    \ Corporation, BRQA/501\n   4205 S. Miami Blvd.\n   Research Triangle Park, NC\
    \ 27709\n   Phone: +1 919-254-4455\n   Fax: +1 919-254-6243\n   EMail: rafalow@us.ibm.com\n\
    \   Yoram Ramberg\n   Cisco Systems\n   4 Maskit Street\n   Herzliya Pituach,\
    \ Israel  46766\n   Phone: +972-9-970-0081\n   Fax:  +972-9-970-0219\n   EMail:\
    \ yramberg@cisco.com\n   Yoram Snir\n   Cisco Systems\n   4 Maskit Street\n  \
    \ Herzliya Pituach, Israel  46766\n   Phone: +972-9-970-0085\n   Fax:  +972-9-970-0366\n\
    \   EMail: ysnir@cisco.com\n   Andrea Westerinen\n   Cisco Systems\n   Building\
    \ 20\n   725 Alder Drive\n   Milpitas, CA  95035\n   Phone: +1-408-853-8294\n\
    \   Fax: +1-408-527-6351\n   EMail: andreaw@cisco.com\n   Ritu Chadha\n   Telcordia\
    \ Technologies\n   MCC 1J-218R\n   445 South Street\n   Morristown NJ 07960.\n\
    \   Phone: +1-973-829-4869\n   Fax: +1-973-829-5889\n   EMail: chadha@research.telcordia.com\n\
    \   Marcus Brunner\n   NEC Europe Ltd.\n   C&C Research Laboratories\n   Adenauerplatz\
    \ 6\n   D-69115 Heidelberg, Germany\n   Phone: +49 (0)6221 9051129\n   Fax: +49\
    \ (0)6221 9051155\n   EMail: brunner@ccrle.nec.de\n   Ron Cohen\n   Ntear LLC\n\
    \   EMail: ronc@ntear.com\n   John Strassner\n   INTELLIDEN, Inc.\n   90 South\
    \ Cascade Avenue\n   Colorado Springs, CO  80903\n   Phone: +1-719-785-0648\n\
    \   EMail: john.strassner@intelliden.com\n"
- title: 11. Security Considerations
  contents:
  - "11. Security Considerations\n   The Policy Core Information Model (PCIM) [1]\
    \ describes the general\n   security considerations related to the general core\
    \ policy model.\n   The extensions defined in this document do not introduce any\n\
    \   additional considerations related to security.\n"
- title: 12. Normative References
  contents:
  - "12. Normative References\n   [1]  Moore, B., Ellesson, E., Strassner, J. and\
    \ A. Westerinen,\n        \"Policy Core Information Model -- Version 1 Specification\"\
    , RFC\n        3060, February 2001.\n   [2]  Distributed Management Task Force,\
    \ Inc., \"DMTF Technologies: CIM\n        Standards  CIM Schema: Version 2.5\"\
    , available at\n        http://www.dmtf.org/standards/cim_schema_v25.php.\n  \
    \ [3]  Distributed Management Task Force, Inc., \"Common Information\n       \
    \ Model (CIM) Specification: Version 2.2\", June 14, 1999,\n        available\
    \ at\n        http://www.dmtf.org/standards/documents/CIM/DSP0004.pdf.\n   [4]\
    \  Mockapetris, P., \"Domain Names - implementation and\n        specification\"\
    , STD 13, RFC 1035, November 1987.\n   [5]  Wahl, M., Coulbeck, A., Howes, T.\
    \ and S. Kille, \"Lightweight\n        Directory Access Protocol (v3): Attribute\
    \ Syntax Definitions\",\n        RFC 2252, December 1997.\n   [6]  Crocker, D.\
    \ and P. Overell, \"Augmented BNF for Syntax\n        Specifications: ABNF\",\
    \ RFC 2234, November 1997.\n   [7]  Hinden, R. and S. Deering, \"IP Version 6\
    \ Addressing\n        Architecture\", RFC 2373, July 1998.\n   [8]  Bradner, S.,\
    \ \"Key words for use in RFCs to Indicate Requirement\n        Levels\", BCP 14,\
    \ RFC 2119, March 1997.\n"
- title: 13. Informative References
  contents:
  - "13. Informative References\n   [9]  Hovey, R. and S. Bradner, \"The Organizations\
    \ Involved in the\n        IETF Standards Process\", BCP 11, RFC 2028, October\
    \ 1996.\n   [10] Westerinen, A., Schnizlein, J., Strassner, J., Scherling, M.,\n\
    \        Quinn, B., Herzog, S., Huynh, A., Carlson, M., Perry, J. and\n      \
    \  Waldbusser, \"Terminology for Policy-Based Management\", RFC 3198,\n      \
    \  November 2001.\n   [11] Snir, Y., and Y. Ramberg, J. Strassner, R. Cohen, \"\
    Policy QoS\n        Information Model\", Work in Progress.\n   [12] Jason, J.,\
    \ and L. Rafalow, E. Vyncke, \"IPsec Configuration\n        Policy Model\", Work\
    \ in Progress.\n   [13] Chadha, R., and M. Brunner, M. Yoshida, J. Quittek, G.\n\
    \        Mykoniatis, A.  Poylisher, R. Vaidyanathan, A. Kind, F.\n        Reichmeyer,\
    \ \"Policy Framework MPLS Information Model for QoS and\n        TE\", Work in\
    \ Progress.\n   [14] S. Waldbusser, and J. Saperia, T. Hongal, \"Policy Based\n\
    \        Management MIB\", Work in Progress.\n   [15] B. Moore, and D. Durham,\
    \ J. Halpern, J. Strassner, A.\n        Westerinen, W.  Weiss, \"Information Model\
    \ for Describing Network\n        Device QoS Datapath Mechanisms\", Work in Progress.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Bob Moore\n   IBM Corporation, BRQA/501\n   4205 S. Miami\
    \ Blvd.\n   Research Triangle Park, NC 27709\n   Phone: +1 919-254-4436\n   Fax:\
    \ +1 919-254-6243\n   EMail: remoore@us.ibm.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2003).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
