- contents:
  - '                    IP and ARP over HIPPI-6400 (GSN)

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   The ANSI T11.1 task force has standardized HIPPI-6400 also known
    as\n   Gigabyte System Network (GSN), a physical-level, point-to-point,\n   full-duplex,
    link interface for reliable, flow-controlled,\n   transmission of user data at
    6400 Mbit/s, per direction. A parallel\n   copper cable interface for distances
    of up to 40 m is specified in\n   HIPPI-6400-PH [1].  Connections to a longer-distance
    optical\n   interface are standardized in HIPPI-6400-OPT [3].\n   HIPPI-6400-PH
    [1] defines the encapsulation of IEEE 802.2 LLC PDUs\n   [10] and by implication,
    IP on GSN. Another T11.1 standard describes\n   the operation of HIPPI-6400 physical
    switches HIPPI-6400-SC [2].\n   T11.1 chose to leave HIPPI-6400 networking issues
    largely outside the\n   scope of their standards; this document specifies the
    use of HIPPI-\n   6400 switches as IP local area networks. This document further\n
    \  specifies a method for resolving IP addresses to HIPPI-6400 hardware\n   addresses
    (HARP) and for emulating IP broadcast in a logical IP\n   subnet (LIS) as a direct
    extension of HARP. Furthermore it is the\n   goal of this memo to define a IP
    and HARP that will allow\n   interoperability for HIPPI-800 and HIPPI-6400 equipment
    both\n   broadcast and non-broadcast capable networks.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . .   3\n   2.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   3\n
    \      2.1 Global concepts used  . . . . . . . . . . . . . . . .   3\n       2.2
    Glossary  . . . . . . . . . . . . . . . . . . . . . .   4\n   3.  IP Subnetwork
    Configuration . . . . . . . . . . . . . . .   5\n       3.1 Background  . . .
    . . . . . . . . . . . . . . . . . .   5\n       3.2 HIPPI LIS Requirements  .
    . . . . . . . . . . . . . .   6\n   4.  Internet Protocol . . . . . . . . . .
    . . . . . . . . . .   7\n       4.1  Packet Format  . . . . . . . . . . . . .
    . . . . . .   7\n            4.1.1 IEEE 802.2 LLC . . . . . . . . . . . . . .
    . .   7\n            4.1.2 SNAP . . . . . . . . . . . . . . . . . . . . .   7\n
    \           4.1.3 Packet diagrams  . . . . . . . . . . . . . . .   8\n       4.2
    \ HIPPI-6400 Hardware address: Universal LAN MAC addr.   9\n       4.3  Maximum
    Transmission Unit - MTU  . . . . . . . . . .  10\n   5.  HIPPI Address Resolution
    Protocol - HARP  . . . . . . . .  11\n       5.1  HARP Algorithm . . . . . . .
    . . . . . . . . . . . .  12\n            5.1.1 Selecting the authoritative HARP
    service . . .  12\n            5.1.2 HARP registration phase  . . . . . . . .
    . . .  13\n            5.1.3 HARP operational phase . . . . . . . . . . . .  14\n
    \      5.2  HARP Client Operational Requirements . . . . . . . .  15\n       5.3
    \ Receiving Unknown HARP Messages  . . . . . . . . . .  16\n       5.4  HARP Server
    Operational Requirements . . . . . . . .  16\n       5.5  HARP and Permanent ARP
    Table Entries . . . . . . . .  18\n       5.6  HARP Table Aging . . . . . . .
    . . . . . . . . . . .  18\n   6.  HARP Message Encoding . . . . . . . . . . .
    . . . . . . .  19\n       6.1 Generic IEEE 802 ARP Message Format . . . . . .
    . . .  19\n       6.2 HIPARP Message Formats  . . . . . . . . . . . . . . .  21\n
    \          6.2.1 Example Message encodings:  . . . . . . . . . .  23\n           6.2.2
    HARP_NAK message format . . . . . . . . . . . .  24\n   7.  Broadcast and Multicast
    \  . . . . . . . . . . . . . . . .  24\n       7.1 Protocol for an IP Broadcast
    Emulation Server - PIBES  25\n       7.2 IP Broadcast Address  . . . . . . . .
    . . . . . . . .  25\n       7.3 IP Multicast Address  . . . . . . . . . . . .
    . . . .  25\n       7.4 A Note on Broadcast Emulation Performance . . . . . .
    \ 26\n   8.  HARP for Scheduled Transfer . . . . . . . . . . . . . . .  26\n   9.
    \ Security Consierations  . . . . . . . . . . . . . . . . .  26\n   10. Open Issues
    . . . . . . . . . . . . . . . . . . . . . . .  27\n   11.  HARP Examples  . .
    . . . . . . . . . . . . . . . . . . .  27\n        11.1 Registr. Phase of Client
    Y on Non-broadcast Hardware 27\n        11.2 Registr. Phase of Client Y on Broadcast-capable
    . .  28\n        11.3 Operational Phase (phase II)  . . . . . . . . . . .  29\n
    \            11.3.1 Successful HARP_Resolve example  . . . . . .  29\n             11.3.2
    Non-successful HARP_Resolve example  . . . .  30\n   12.  References . . . . .
    . . . . . . . . . . . . . . . . . .  31\n   13.  Acknowledgments  . . . . . .
    . . . . . . . . . . . . . .  32\n   14.  Author's Address . . . . . . . . . .
    . . . . . . . . . .  32\n   15.  Full Copyright Statement . . . . . . . . . .
    . . . . . .  33\n"
  title: Table of Contents
- contents:
  - "1. Introduction\n   HIPPI-6400 is a duplex data channel that can transmit and
    receive\n   data simultaneously at nearly 6400 megabits per second. HIPPI-6400\n
    \  data transfers are segmented into micropackets, each composed of 32\n   data
    bytes and 8 control bytes. HIPPI-6400 uses four multiplexed\n   virtual channels.
    These virtual channels are allocated to control\n   traffic, low latency traffic,
    and bulk traffic (see [1] for more\n   details).\n   Using small packets and four
    virtual channels, large file transfers\n   cannot lock out a host or switch port
    for interactive traffic.\n   HIPPI-6400 guarantees in order delivery of data.
    It also supports\n   link-level and end-to-end checksumming and credit-based flow
    control.\n   HIPPI-6400-PH defines a 20-bit interface for copper cables operating\n
    \  at 500 MBaud. This provides a user payload bandwidth of 6400 Mb/s\n   (800,000,000
    Bytes/sec) in each direction. [8]\n   HIPPI-6400-SC [2] defines two types of switches:
    bridging and non-\n   bridging. The bridging switches are required to support
    hardware\n   broadcast.  Non-bridging switches are not required to support\n   broadcast.
    \ This memo allows for a coherent implementation of IP and\n   HARP with both
    types of switches.\n   Gigabyte System Network(TM) (GSN) is a marketing name for
    HIPPI-6400.\n   It is a trademark of the High Performance Networking Forum (HNF;\n
    \  http://www.hnf.org) for use by its member companies that supply\n   products
    complying to ANSI HIPPI-6400 standards.\n"
  title: 1. Introduction
- contents:
  - "2  Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and
    \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC-2119
    [19].\n"
  title: 2  Definitions
- contents:
  - "2.1 Global concepts used\n   In the following discussion, the terms \"requester\"
    and \"target\" are\n   used to identify the port initiating the address resolution
    request\n   and the port whose address it wishes to discover, respectively. This\n
    \  document will use HIPPI-800 and HIPPI-6400 when referring to concepts\n   that
    apply to one or the other technology. The term HIPPI will be\n   used when referring
    to both technologies.\n   Values are decimal unless otherwise noted. Formatting
    follows IEEE\n   802.1A canonical bit order and HIPPI-6400-PH bit and byte ordering.\n"
  title: 2.1 Global concepts used
- contents:
  - "2.2 Glossary\n   Broadcast\n   A distribution mode which transmits a message
    to all ports. The\n   sending port is part of \"all\" and will therefore also
    receive a copy\n   of the sent message.\n   Classical/Conventional\n   Both terms
    are used with respect to networks, including Ethernet,\n   FDDI, and other 802
    LAN types, as distinct from HIPPI-SC LANs.\n   Destination\n   The HIPPI port
    that receives data from a HIPPI Source.\n   HARP\n   HARP (HIPPI Address Resolution
    Protocol describes the whole set of\n   HIPPI-6400 address resolution encodings
    and algorithms defined in\n   this memo. HARP is a combination and adaptation
    of the Internet\n   Address Resolution Protocol (ARP) RFC-826 [14] and Inverse
    ARP\n   (InARP) [5] (see section 5). HARP also describes the HIPPI (800 and\n
    \  6400) specific version of ARP (i.e. the protocol and the HIPPI\n   specific
    encoding).\n   HARP table\n   Each host has a HARP table which contains the IP
    to hardware address\n   mapping of IP members.\n   HRAL\n   The HARP Request Address
    List.  A list of ULAs to which HARP messages\n   are sent when resolving names
    to addresses (see section 3.2).\n   Hardware (HW) address\n   The hardware address
    of a port; it consists of an ULA (see section\n   4.2). Note: the term port as
    used in this document refers to a HIPPI\n   port and is roughly equivalent to
    the term \"interface\" as commonly\n   used in other IP documents.\n   Host\n
    \  An entity, usually a computer system, that may have one or more HIPPI\n   ports
    and which may serve as a client or a HARP server.\n   Port\n   An entity consisting
    of one HIPPI Source/Destination dual simplex\n   pair that is connected by parallel
    or serial HIPPI to a HIPPI-SC\n   switch and that transmits and receives IP datagrams.
    \ A port may be\n   an Internet host, bridge, router, or gateway.\n   PIBES\n
    \  The Protocol for Internet Broadcast Emulation Server (see section 7).\n   Source\n
    \  The HIPPI port that generates data to send to a HIPPI Destination.\n   Universal
    LAN MAC Address (ULA)\n   A 48-bit globally unique address, administered by the
    IEEE, assigned\n   to each port on an Ethernet, FDDI, 802 network, or HIPPI-SC
    LAN.\n"
  title: 2.2 Glossary
- contents:
  - '3.  IP Subnetwork Configuration

    '
  title: 3.  IP Subnetwork Configuration
- contents:
  - "3.1 Background\n   ARP (address resolution protocol) as defined in [14] was meant
    to\n   work on the 'local' cable. This definition gives the ARP protocol a\n   local
    logical IP subnet (LIS) scope. In the LIS scenario, each\n   separate administrative
    entity configures its hosts and routers\n   within the LIS. Each LIS operates
    and communicates independently of\n   other LIS's on the same HIPPI-6400 network.\n
    \  HARP has LIS scope only and serves all ports in the LIS.\n   Communication
    to ports located outside of the local LIS is usually\n   provided via an IP router.
    This router is a HIPPI-6400 port attached\n   to the HIPPI-6400 network that is
    configured as a member of one or\n   more LIS's. This configuration MAY result
    in a number of disjoint\n   LIS's operating over the same HIPPI-6400 network.
    Using this model,\n   ports of different IP subnets SHOULD communicate via an
    intermediate\n   IP router even though it may be possible to open a direct HIPPI-6400\n
    \  connection between the two IP members over the HIPPI-6400 network.\n   This
    is an consequence of using IP and choosing to have multiple\n   LIS's on the same
    HIPPI-6400 fabric.\n   By default, the HARP method detailed in section 5 and the
    classical\n   LIS routing model MUST be available to any IP member client in the\n
    \  LIS.\n"
  title: 3.1 Background
- contents:
  - "3.2 HIPPI LIS Requirements\n   The requirement for IP members (hosts, routers)
    operating in a\n   HIPPI-6400 LIS configuration is:\n   o  All members of the
    LIS SHALL have the same IP network/subnet\n      address and address mask [4].\n
    \  The following list identifies the set of HIPPI-6400-specific\n   parameters
    that MUST be implemented in each IP station connected to\n   the HIPPI-6400 network:\n
    \  o  HIPPI-6400 Hardware Address:\n      The HIPPI-6400 hardware address (a ULA)
    of an individual IP\n      endpoint (i.e. a network adapter within a host) MUST
    be unique in\n      the LIS.\n   o  HARP Request Address List (HRAL):\n   The
    HRAL is an ordered list of two or more addresses identifying the\n   address resolution
    service(s).  All HARP clients MUST be configured\n   identically, i.e. all ports
    MUST have the same addresses(es) in the\n   HRAL.\n   The HRAL MUST contain at
    least two HIPPI HW addresses identifying the\n   individual HARP service(s) that
    have authoritative responsibility for\n   resolving HARP requests of all IP members
    located within the LIS.  By\n   default the first address MUST be the reserved
    address for broadcast,\n   i.e. FF:FF:FF:FF:FF:FF.\n   The second address MUST
    be the standard HW address for the HARP\n   server 00:10:3B:FF:FF:E0.\n   Therefore,
    the HRAL entries are sorted in the following order:\n   1st     : broadcast address
    \           (FF:FF:FF:FF:FF:FF) REQUIRED\n   2nd     : official HARP server address
    (00:10:3B:FF:FF:E0) REQUIRED\n   3rd & on: any additional HARP server addresses
    will be     OPTIONAL\n             sorted in decreasing order.\n   Manual configuration
    of the addresses and address lists presented in\n   this section is implementation
    dependent and beyond the scope of this\n   memo.  However, prior to use by any
    service or operation detailed in\n   this memo, clients MUST have HRAL address(es)
    configured as\n   appropriate for their LIS.\n"
  title: 3.2 HIPPI LIS Requirements
- contents:
  - '4.  Internet Protocol

    '
  title: 4.  Internet Protocol
- contents:
  - "4.1 Packet format\n   The HIPPI-6400 packet format for Internet datagrams [15]
    shall\n   conform to the HIPPI-6400-PH standard [1].  The length of a HIPPI-\n
    \  6400-PH packet, including headers and trailing fill, shall be a\n   multiple
    of 32 bytes as required by HIPPI-6400-PH.\n   All IP Datagrams shall be carried
    on HIPPI-6400-PH Virtual Channel 1\n   (VC1). Since HIPPI-6400-PH has a 32-byte
    granularity, IP Datagrams\n   MUST be padded to a 32-byte granularity prior to
    sending. Added\n   padding is transparent to IP and is not reflected in the length
    field\n   of the IP header.\n   D_ULA   Destination ULA SHALL be the ULA of the
    destination port.\n   S_ULA   Source ULA SHALL be the ULA of the requesting port.\n
    \  M_len   Set to the IEEE 802 packet (e.g. IP or HARP message)\n           length
    + 8 Bytes to account for the LLC/SNAP header length.\n           The HIPPI-6400-PH
    [1] length parameter shall not include\n           the pad.\n"
  title: 4.1 Packet format
- contents:
  - "4.1.1 IEEE 802.2 LLC\n   The IEEE 802.2 LLC Header SHALL begin in the first byte
    after M_len.\n   The LLC values (in hexadecimal and decimal) SHALL be\n   SSAP
    \          0xAA     170  (8  bits)\n   DSAP           0xAA     170  (8  bits)\n
    \  CTL            0x03       3  (8  bits)\n   for a total length of 3 bytes. The
    0x03 CTL value indicates the\n   presence of a SNAP header.\n"
  title: 4.1.1 IEEE 802.2 LLC
- contents:
  - "4.1.2 SNAP\n   The OUI value for Organization Code SHALL be 0x00-00-00 (3 bytes)\n
    \  indicating that the following two-bytes is an Ethertype.\n   The Ethertype
    value SHALL be set as defined in Assigned Numbers [18]:\n   IP           0x0800
    \ 2048  (16 bits)\n   HARP = ARP = 0x0806  2054  (16 bits)\n   The total size
    of the LLC/SNAP header is fixed at 8 bytes.\n"
  title: 4.1.2 SNAP
- contents:
  - "4.1.3 HIPPI-6400 802 Packet diagrams\n   The following diagram shows a HIPPI-6400
    message carrying IEEE 802\n   data.\n   |31          |23          |15          |7
    \         0|\n   +------------+------------+------------+------------+ -------------\n
    0 |                                                   |\n   |         D_ULA           +-------------------------+
    \  HIPPI-6400\n 1 |                         |                         |\n   +-------------------------+
    \       S_ULA            |      MAC\n 2 |                                                   |\n
    \  +---------------------------------------------------+     header\n 3 |                      M_len
    \                       |\n   +------------+------------+------------+------------+
    -------------\n 4 |   DSAP     |   SSAP     |    Ctl     |    Org     |    IEEE
    802\n   +------------+------------+------------+------------+    LLC/SNAP\n 5
    |   Org      |    Org     |       Ethertype         |     header\n   +============+============+============+============+
    =============\n 6 | Msg byte 0 | Msg byte 1 | Msg byte 2 |    . . .   |    IEEE
    802\n   +---------------------------------------------------+      Data\n                   Generic
    802.1 data packet diagram\n   The following diagram shows an IP datagram of length
    n with the FILL\n   bytes ( value: 0x0 ). \"<><>\" indicates the micropacket separation.
    A\n   HIPPI-6400-PH [1] micropacket is 32 bytes long.\n   All IP (v4) [15] packets
    will always span two or more micropackets.\n   The first micropacket has a TYPE
    = header. The second and any further\n   micropackets have a TYPE = Data (see
    [1]).\n    |31          |23          |15          |7          0|\n    +------------+------------+------------+------------+
    -------------\n  0 |                                                   |\n    |
    \        D_ULA           +-------------------------+   HIPPI-6400\n  1 |                         |
    \                        |\n    +-------------------------+        S_ULA            |
    \     MAC\n  2 |                                                   |\n    +---------------------------------------------------+
    \    header\n  3 |                      M_len                        |\n    +------------+------------+------------+------------+
    -------------\n  4 |     AA     |     AA     |     03     |    00      |    IEEE
    802\n    +------------+------------+------------+------------+    LLC/SNAP\n  5
    |     00     |     00     | Ethertype = 0x0800=2048 |     header\n    +============+============+============+============+
    =============\n  6 | VER | HLEN |    TOS     |      Total Length       |\n    +-----+------+------------+-----+-------------------+\n
    \ 7 |           ID            | FLG |   Frag Offset     |\n    +<><><><><><>+<><><><><><>+<><><><><><>+<><><><><><>+
    \ IPv4 Header\n  8 |    TTL     |   PROTO    |    Header Checksum      |\n    +------------+------------+-------------------------+\n
    \ 9 |                 Source IP Address                 |\n    +---------------------------------------------------+\n
    10 |               Destination IP Address              |\n    +---------------------------------------------------+\n
    11 |                    .   .   .                      |\n    +---------------------------------------------------+\n
    \   |   . . .    | byte (n-2) | byte (n-1) |    FILL    |\n    +------------+------------+------------+------------+\n
    \   |    FILL    |   FILL     |   FILL     |    FILL    |\n    +------------+------------+------------+------------+\n
    M-1|    FILL    |   FILL     |   FILL     |    FILL    |\n    +<><><><><><>+<><><><><><>+<><><><><><>+<><><><><><>+\n
    \                      IP v4 data packet diagram\n   As shown in above figure
    the first eight bytes of the IP Datagram\n   occupy the last eight bytes of the
    HIPPI-6400-PH [1] Header\n   micropacket.\n"
  title: 4.1.3 HIPPI-6400 802 Packet diagrams
- contents:
  - "4.2  HIPPI-6400 Hardware address: Universal LAN MAC address (ULA)\n   HIPPI-6400
    uses Universal LAN MAC Addresses specified in IEEE\n   Standard 802.1A [10] or
    a subset as defined in HIPPI-6400-SC [2].\n   The globally unique part of the
    48 bit space is administered by the\n   IEEE. Each port on a HIPPI-6400-SC LAN
    MUST be assigned a ULA.\n   Multiple ULAs may be used if a node contains more
    than one IEEE 802.2\n   LLC protocol entity.\n   This memo assumes the use of
    \"Logical Addressing\" as described in\n   Annex A.2 of HIPPI-6400-SC[2].\n   The
    format of the address within its 48 bit HIPPI-6400-PH fields\n   follows IEEE
    802.1A canonical bit order and HIPPI-6400-PH bit and\n   byte order:\n    31              23
    \             15               7              0\n   +---------------+---------------+---------------+---------------+\n
    \  |ULA byte 0 |L|G|   ULA byte 1  |   ULA byte 2  |   ULA byte 3  |\n   +---------------+---------------+---------------+---------------+\n
    \  |   ULA byte 4  |   ULA byte 5  |      (not used for ULA)       |\n   +---------------+---------------+---------------+---------------+\n
    \                    Universal LAN MAC Address Format\n   L (U/L bit) = 1 for
    Locally administered addresses, 0 for Universal.\n   G (I/G bit) = 1 for Group
    addresses, 0 for Individual.\n"
  title: '4.2  HIPPI-6400 Hardware address: Universal LAN MAC address (ULA)'
- contents:
  - "4.3  Maximum Transmission Unit - MTU\n   Maximum Transmission Unit (MTU) is defined
    as the maximum length of\n   the IP packet, including IP header, but not including
    any overhead\n   below IP, i.e., HIPPI-6400 MAC header and IEEE 802 LLC/SNAP header.\n
    \  Conventional LANs have MTU sizes determined by physical layer\n   specification.
    \ MTUs may be required simply because the chosen medium\n   won't work with larger
    packets, or they may serve to limit the amount\n   of time a node must wait for
    an opportunity to send a packet.\n   HIPPI-6400-PH [1] limits packets to about
    4 gigabytes (on VC 3) which\n   imposes no practical limit for networking purposes.
    HIPPI-6400-PH VC\n   1, which was chosen for IP and ARP traffic, limits messages
    to about\n   128 Kbytes which is still larger than the HIPPI-800 MTU [17].\n   The
    MTU for HIPPI-6400 LANs SHALL be 65280 (decimal) bytes.\n   This value is backwards
    compatible with HIPPI-800. It allows the IP\n   packet to fit in one 64K byte
    buffer with up to 256 bytes of\n   overhead.  The IP v4 overhead is 24 bytes for
    HIPPI-6400 and 40 bytes\n   for HIPPI-800.\n   For HIPPI-6400 the byte accounting
    is:\n      HIPPI-6400-PH Header            16 bytes\n      IEEE 802.2 LLC/SNAP
    Headers      8 bytes\n      Maximum IP packet size (MTU) 65280 bytes\n      Unused
    expansion room          232 bytes\n                                   ------------\n
    \                       Total      65536 bytes (64K)\n   In contrast, the HIPPI-800
    accounting is:\n      HIPPI-800-FP Header              8 bytes\n      HIPPI-800-LE
    Header             24 bytes\n      IEEE 802.2 LLC/SNAP Headers      8 bytes\n
    \     Unused expansion room          216 bytes\n      Maximum IP packet size (MTU)
    65280 bytes\n                                   ------------\n                        Total
    \     65536 bytes (64K)\n"
  title: 4.3  Maximum Transmission Unit - MTU
- contents:
  - "5. HIPPI Address Resolution Protocol - HARP\n   Address resolution within the
    HIPPI-6400 LIS SHALL make use of the\n   HIPPI Address Resolution Protocol (HARP)
    and the Inverse HIPPI\n   Address Resolution Protocol (InHARP). HARP provides
    the same\n   functionality as the Internet Address Resolution Protocol (ARP).\n
    \  HARP is based on ARP which is defined in RFC-826 [14] except the\n   HIPPI-6400
    specific packet format. Knowing the Internet address,\n   conventional networks
    use ARP to discover another node's hardware\n   address.  HARP presented in this
    section further specifies the\n   combination of the original protocol definitions
    to form a coherent\n   address resolution service that is independent of the hardware's\n
    \  broadcast capability.  InHARP is the same protocol as the original\n   Inverse
    ARP (InARP) protocol presented in [5] except the HIPPI-6400\n   specific packet
    format.  Knowing its hardware address, InARP is used\n   to discover the other
    party's Internet address.\n   This memo further REQUIRES the PIBES (see section
    7) extension to the\n   HARP protocol, guaranteeing broadcast service to upper
    layer\n   protocols like IP.\n   Internet addresses are assigned independent of
    ULAs.  Before using\n   HARP, each node MUST know its IP and its HW addresses.
    The ULA is\n   optional but is RECOMMENDED if interoperability with conventional\n
    \  networks is desired.\n   If all switches in the LIS support broadcast, then
    the source address\n   in the reply will be the target's source address.  If all
    switches in\n   the LIS do not support broadcast, then a HARP server MUST be used
    to\n   provide the address resolution service, and the source address in the\n
    \  reply will be the HARP server's source address.\n"
  title: 5. HIPPI Address Resolution Protocol - HARP
- contents:
  - "5.1 HARP Algorithm\n   This section defines the behavior and requirements for
    HARP\n   implementations on both broadcast and non-broadcast capable HIPPI-\n
    \  6400-SC networks. HARP creates a table in each port which maps remote\n   ports'
    IP addresses to ULAs, so that when an application requests a\n   connection to
    a remote port by its IP address, the remote ULA can be\n   determined, a correct
    HIPPI-6400-PH header can be built, and a\n   connection to the port can be established
    using the ULA.\n   HARP is a two phase protocol. The first phase is the registration\n
    \  phase and the second phase is the operational phase. In the\n   registration
    phase the port detects if it is connected to broadcast\n   hardware or not. The
    InHARP protocol is used in the registration\n   phase.  In case of non-broadcast
    capable hardware, the InHARP\n   Protocol will register and establish a table
    entry with the server.\n   The operational phase works much like conventional
    ARP with the\n   exception of the message format.\n"
  title: 5.1 HARP Algorithm
- contents:
  - "5.1.1 Selecting the authoritative HARP service\n   Within the HIPPI LIS, there
    SHALL be an authoritative HARP service.\n   To select the authoritative HARP service,
    each port needs to\n   determine if it is connected to a broadcast network. At
    each point in\n   time there is only one authoritative HARP service.\n   The port
    SHALL send an InHARP_REQUEST to the first address in the\n   HRAL (FF:FF:FF:FF:FF:FF).
    If the port sees its own InHARP_REQUEST,\n   then it is connected to a broadcast
    capable network. In this case,\n   the rest of the HRAL is ignored and the authoritative
    HARP service is\n   the broadcast entry.\n   If the port is connected to a non-broadcast
    capable network, then the\n   port SHALL send the InHARP_REQUEST to all of the
    remaining entries in\n   the HRAL. Every address which sends an InHARP_REPLY is
    considered to\n   be a responsive HARP server. The authoritative HARP service
    SHALL be\n   the HARP server which appears first in the HRAL.\n   The order of
    addresses in the HRAL is only important for deciding\n   which address will be
    the authoritative one. On a non-broadcast\n   network, the port is REQUIRED to
    keep \"registered\" with all HARP\n   server addresses in the HRAL (NOTE: not
    the broadcast address since\n   it is not a HARP server address). If for instance
    the authoritative\n   HARP service is non-responsive,  then the port will consider
    the next\n   address in the HRAL as a candidate for the authoritative address
    and\n   send an InHARP_REQUEST.\n   The authoritative HARP server SHOULD be considered
    non-responsive\n   when it has failed to reply to: (1) one or more registration
    requests\n   by the client (see section 5.1.2 and 5.2), (2) any two HARP_REQUESTs\n
    \  in the last 120 seconds or (3) if an external agent has detected\n   failure
    of the authoritative HARP server. The details of such an\n   external agent and
    its interaction with the HARP client are beyond\n   the scope of this document.
    Should an authoritative HARP server\n   become non-responsive, then the registration
    process SHOULD be\n   restarted. Alternative methods for choosing an authoritative
    HARP\n   service are not prohibited.\n"
  title: 5.1.1 Selecting the authoritative HARP service
- contents:
  - "5.1.2  HARP registration phase\n   HARP clients SHALL initiate the registration
    phase by sending an\n   InHARP_REQUEST message using the HRAL addresses in order.
    The client\n   SHALL terminate the registration phase and transition into the\n
    \  operational phase, when either: (1) it receives its own\n   InHARP_REQUEST,
    or (2) when it receives an InHARP_REPLY from at least\n   one of the HARP servers
    and it has determined the authoritative HARP\n   service as described in 5.1.1.\n
    \  When ports are initiated they send an InHARP_REQUEST to the\n   authoritative
    HRAL address. The first address to be tried will be the\n   broadcast address
    \"FF:FF:FF:FF:FF:FF\". There are two outcomes:\n   1. The port sees its own InHARP_REQUEST:
    then the port is connected\n      to a broadcast capable network. The first address
    becomes, and\n      remains, the authoritative address for the HARP service.\n
    \  2. The port does not receive its InHARP_REQUEST: then the port is\n      connected
    to a non-broadcast capable network.\n      The port SHALL choose the next address
    in the HRAL as a candidate\n      for a HARP server and send an InHARP_REQUEST
    to that address:\n      (00:10:3B:FF:FF:E0).\n      The port SHALL continue to
    retry each non-broadcast HARP server\n      address in the HRAL at least once
    every 5 seconds until one of the\n      following termination criteria are met
    for each address.\n      a. If the port receives its own message, then the port
    itself is\n         the HARP server and the port is REQUIRED to provide broadcast\n
    \        services using the PIBES (see section 7).\n      b. If the port receives
    an InHARP_REPLY, then it is a HARP client\n         and not a HARP server. In
    both cases, the current candidate\n         address becomes the authoritative
    HARP service address.\n   InHARP is an application of the InARP protocol for a
    purpose not\n   originally intended.  The purpose is to accomplish registration
    of\n   port IP address mappings with a HARP server if one exists or detect\n   hardware
    broadcast capability.\n   If the HIPPI-6400-SC LAN supports broadcast, then the
    client will see\n   its own InHARP_REQUEST message and SHALL complete the registration\n
    \  phase. The client SHOULD further note that it is connected to a\n   broadcast
    capable network and use this information for aging the HARP\n   server entry and
    for IP broadcast emulation as specified in sections\n   5.4 and 5.6 respectively.\n
    \  If the client doesn't see its own InHARP_REQUEST it SHALL await an\n   InHARP_REPLY
    before completing the registration phase. This will also\n   provide the client
    with the protocol address by which the HARP server\n   is addressable.  This will
    be the case when the client happens to be\n   connected to a non-broadcast capable
    HIPPI-6400-SC network.\n"
  title: 5.1.2  HARP registration phase
- contents:
  - "5.1.3 HARP operational phase\n   Once a HARP client has completed its registration
    phase it enters the\n   operational phase. In this phase of the protocol, the
    HARP client\n   SHALL gain and refresh its own HARP table information about other
    IP\n   members by sending of HARP_REQUESTs to the authoritative address in\n   the
    HRAL and by receiving of HARP_REPLYs. The client is fully\n   operational during
    the operational phase.\n   In the operational phase, the client's behavior for
    requesting HARP\n   resolution is the same for broadcast or non-broadcast HIPPI-6400-SC\n
    \  switched networks.\n   The target of an address resolution request updates
    its address\n   mapping tables with any new information it can find in the request.\n
    \  If it is the target port it SHALL formulate and send a reply message.\n   A
    port is the target of an address resolution request if at least ONE\n   of the
    following statements is true of the request:\n   1. The port's IP address is in
    the target protocol address field\n      (ar$tpa) of the HARP message.\n   2.
    The port's ULA, is in the ULA part of the Target Hardware Address\n      field
    (ar$tha) of the message.\n   3. The port is a HARP server.\n   NOTE: It is REQUIRED
    to have a HARP server run on a port that has a\n   non-zero ULA.\n"
  title: 5.1.3 HARP operational phase
- contents:
  - "5.2 HARP Client Operational Requirements\n   The HARP client is responsible for
    contacting the HARP server(s) to\n   have its own HARP information registered
    and to gain and refresh its\n   own HARP entry/information about other IP members.
    This means, as\n   noted above, that HARP clients MUST be configured with the
    hardware\n   address  of the HARP server(s) in the HRAL.\n   HARP clients MUST:\n
    \  1. When an interface is enabled (e.g. \"ifconfig <interface> up\" with\n      an
    IP address) or assigned the first or an additional IP address\n      (i.e. an
    IP alias), the client SHALL initiate the registration\n      phase.\n   2. In
    the operational phase the client MUST respond to HARP_REQUEST\n      and InHARP_REQUEST
    messages if it is the target port.  If an\n      interface has multiple IP addresses
    (e.g., IP aliases) then the\n      client MUST cycle through all the IP addresses
    and generate an\n      InHARP_REPLY for each such address. In that case an InHARP_REQUEST\n
    \     will have multiple replies. (Refer to Section 7, \"Protocol\n      Operation\"
    in RFC-1293 [5].)\n   3. React to address resolution reply messages appropriately
    to build\n      or refresh its own client HARP table entries. All solicited and\n
    \     unsolicited HARP_REPLYs from the authoritative HARP server SHALL\n      be
    used to update and refresh its own client HARP table entries.\n      Explanation:
    This allows the HARP server to update the clients\n      when one of server's
    mappings change, similar to what is\n      accomplished on Ethernet with gratuitous
    ARP.\n   4. Generate and transmit InHARP_REQUEST messages as needed and\n      process
    InHARP_REPLY messages appropriately (see section 5.1.3 and\n      5.6). All InHARP_REPLY
    messages SHALL be used to build/refresh its\n      client HARP table entries.
    \ (Refer to Section 7, \"Protocol\n      Operation\" in [5].)\n   If the registration
    phase showed that the hardware does not support\n   broadcast, then the client
    MUST refresh its own entry for the HARP\n   server, created during the registration
    phase, at least once every 15\n   minutes. This can be accomplished either through
    the exchange of a\n   HARP request/reply with the HARP server or by repeating
    step 1. To\n   decrease the redundant network traffic, this timeout SHOULD be
    reset\n   after each HARP_REQUEST/HARP_REPLY exchange.\n   Explanation: The HARP_REQUEST
    shows the HARP server that the client\n   is still alive. Receiving a HARP_REPLY
    indicates to the client that\n   the server must have seen the HARP_REQUEST.\n
    \  If the registration phase showed that the underlying network supports\n   broadcast,
    then the refresh sequence is NOT REQUIRED.\n"
  title: 5.2 HARP Client Operational Requirements
- contents:
  - "5.3 Receiving Unknown HARP Messages\n   If a HARP client receives a HARP message
    with an operation code\n   (ar$op) that it does not support, it MUST gracefully
    discard the\n   message and continue normal operation.  A HARP client is NOT REQUIRED\n
    \  to return any message to the sender of the undefined message.\n"
  title: 5.3 Receiving Unknown HARP Messages
- contents:
  - "5.4 HARP Server Operational Requirements\n   A HARP server MUST accept HIPPI-6400
    connections from other HIPPI-\n   6400 ports. The HARP server expects an InHARP_REQUEST
    as the first\n   message from the client. A server examines the IP address, the\n
    \  hardware address of the InHARP_REQUEST and adds or updates its HARP\n   table
    entry <IP address(es), ULA> as well as the time stamp.\n   A HARP server replies
    to HARP_REQUESTs and InHARP_REQUESTs based on\n   the information which it has
    in its table. The HARP server replies\n   SHALL contain the hardware type and
    corresponding format of the\n   request (see also sec. 6).\n   The following table
    shows all possible source address combinations on\n   an incoming message and
    the actions to be taken. \"linked\" indicates\n   that an existing \"IP entry\"
    is linked to a \"hardware entry\". It is\n   possible to have an existing \"IP
    entry\" and to have an existing\n   \"hardware entry\" but neither is linked to
    the other.\n      +---+----------+----------+------------+---------------------+\n
    \     | # | IP entry | HW entry |  misc      |       Action        |\n      +---+----------+----------+------------+---------------------+\n
    \     | 1 |  exists  |  exists  |     linked | *                   |\n      |
    2 |  exists  |  exists  | not linked | *, a, b,       e, f |\n      | 3 |  exists
    \ |    new   | not linked | *, a, b, d,    e, f |\n      | 4 |   new    |  exists
    \ | not linked | *,       c,    e, f |\n      | 5 |   new    |    new   | not
    linked | *,       c, d, e, f |\n      +---+----------+----------+------------+---------------------+\n
    \     Actions:\n      *: update timeout value\n      a: break the existing IP
    -> hardware (HW) -old link\n      b: delete HW(old) -> IP link and decrement HW(old)
    refcount,\n         if refcount = 0, delete HW(old)\n      c: create new IP entry\n
    \     d: create new HW entry\n      e: add new IP -> HW link to IP entry\n      f:
    add new HW -> IP link to HW entry\n   Examples of when this could happen (Numbers
    match lines in above\n   table):\n   1: supplemental message\n      Just update
    timer.\n   2: move an IP alias to an existing interface\n      If the IP source
    address of the InHARP_REQUEST duplicates a table\n      entry IP address (e.g.
    IPa <-> HWa) and the InHARP_REQUEST\n      hardware source address matches a hardware
    address entry (e. g.\n      HWb <-> IPb), but they are not linked together, then:\n
    \     -  HWa entry needs to have its reference to the current IPa\n         address
    removed.\n      -  HWb needs to have a new reference to IPa added\n      -  IPa
    needs to be linked to HWb\n      The result will be a table with: IPb <-> HWa
    <-> IPb  If IPb was\n      the only IP address referred to by the HWb entry, then
    delete the\n      HWb entry.\n   3: move IP address to a new interface\n      If
    the InHARP_REQUEST requester's IP source address duplicates a\n      table entry
    IP address and the InHARP_REQUEST hardware source\n      address does not match
    the table entry hardware address, then a\n      new HW entry SHALL be created.
    The requestor's IP address SHALL be\n      moved from the original HW entry to
    the new one (see above).\n   4: add IP alias to table\n      If the InHARP_REQUEST
    requester's hardware source address\n      duplicates a hardware source address
    entry, but there is no IP\n      entry matching the received IP address, then
    the IP address SHALL\n      be added to the hardware entries previous IP address(es).
    (E.g.\n      adding an IP alias).\n   5: fresh entry, add it\n      Standard case,
    create both entries and link them.\n   A server MUST update the HARP table entry's
    timeout for each\n   HARP_REQUEST. Explanation: if the client is sending HARP
    requests to\n   the server, then the server should note that the client is still\n
    \  \"alive\" by updating the timeout on the client's HARP table entry.\n   A HARP
    server SHOULD use the PIBES (see sect. 7) to send out\n   HARP_REPLYs to all hardware
    addresses in its table when the HARP\n   server table changes mappings. This feature
    decreases the time of\n   stale entries in the clients.\n   If there are multiple
    addresses in the HRAL, then a server needs to\n   act as a client to the other
    servers.\n"
  title: 5.4 HARP Server Operational Requirements
- contents:
  - "5.5 HARP and Permanent ARP Table Entries\n   An IP station MUST have a mechanism
    (e.g. manual configuration) for\n   determining what permanent entries it has.
    The details of the\n   mechanism are beyond the scope of this memo.  The permanent
    entries\n   allow interoperability with legacy HIPPI adapters which do not yet\n
    \  implement dynamic HARP and use a table based static ARP. Permanent\n   entries
    are not aged.\n   The HARP server SHOULD use the static entries to resolve incoming\n
    \  HARP_REQUESTs from the clients. This feature eliminates the need for\n   maintaining
    a static HARP table on the client ports.\n"
  title: 5.5 HARP and Permanent ARP Table Entries
- contents:
  - "5.6 HARP Table Aging\n   HARP table aging MUST be supported since IP addresses,
    especially IP\n   aliases and also interfaces (with their ULA), are likely to
    move.\n   When so doing the mapping in the clients own HARP table/cache becomes\n
    \  invalid and stale.\n   o  When a client's HARP table entry ages beyond 15 minutes,
    a HARP\n      client MUST invalidate the table entry.\n   o  When a server's HARP
    table entry ages beyond 20 minutes, the HARP\n      server MUST delete the table
    entry.\n   NOTE: the client SHOULD revalidate a HARP table entry before it ages,\n
    \  thus restarting the aging time when the table entry is successfully\n   revalidated.
    \ The client MAY continue sending traffic to the port\n   referred to by this
    entry while revalidation is in progress, as long\n   as the table entry has not
    aged. The client MUST revalidate the\n   invalidated entry prior to transmitting
    any non-address resolution\n   traffic to the port referred to by this entry.\n
    \  The client revalidates the entry by querying the HARP server.  If a\n   valid
    reply is received (e.g. HARP_REPLY), the entry is updated.  If\n   the address
    resolution service cannot resolve the entry (e.g.\n   HARP_NAK, \"host not found\"),
    the associated table entry is removed.\n   If the address resolution service is
    not available (i.e. \"server\n   failure\") the client MUST attempt to revalidate
    the entry by\n   transmitting an InHARP_REQUEST to the hardware address of the
    entry\n   in question and updating the entry on receipt of an InHARP_REPLY. If\n
    \  the InHARP_REQUEST attempt fails to return an InHARP_REPLY, the\n   associated
    table entry is removed.\n"
  title: 5.6 HARP Table Aging
- contents:
  - "6. HARP Message Encoding\n   The HARP message is another type of IEEE 802 payload
    as described in\n   section 4.1.3 above. The HIPPI-6400 HARP SHALL support two
    packet\n   formats, both the generic Ethernet ARP packet and the HIPPI-800 HARP\n
    \  packet format defined in [13]. HARP messages SHALL be transmitted\n   with
    a hardware type code of 28 on non-broadcast capable hardware or\n   1 in either
    case.\n   The ar$hrd field SHALL be used to differentiate between the two\n   packet
    formats. The reply SHALL be in the format of the request.\n"
  title: 6. HARP Message Encoding
- contents:
  - "6.1 Generic IEEE 802 ARP Message Format\n   This is the ARP packet format used
    by conventional IEEE 802 networks\n   (i.e. Ethernet, etc). The packet format
    is described in RFC-826 [14]\n   and is given here only for completeness purpose.\n
    \    ar$hrd  16 bits  Hardware type\n     ar$pro  16 bits  Protocol type of the
    protocol fields below\n     ar$hln   8 bits  byte length of each hardware address\n
    \    ar$pln   8 bits  byte length of each protocol address\n     ar$op   16 bits
    \ opcode (ares_op$REQUEST | ares_op$REPLY)\n     ar$sha  48 bits  Hardware address
    of sender of this packet\n     ar$spa  32 bits  Protocol address of sender of
    this packet\n     ar$tha  48 bits  Hardware address of target of this\n     ar$tpa
    \ 32 bits  Protocol address of target.\n   Where:\n     ar$hrd  - SHALL contain
    1. (Ethernet)\n     ar$pro  - SHALL contain the IP protocol code 2048 (decimal).\n
    \    ar$hln  - SHALL contain 6.\n     ar$pln  - SHALL contain 4.\n     ar$op   -
    SHALL contain the operational value (decimal):\n               1  for   HARP_REQUESTs\n
    \              2  for   HARP_REPLYs\n               8  for InHARP_REQUESTs\n               9
    \ for InHARP_REPLYs\n               10 for   HARP_NAK\n     ar$rpa  - in requests
    and NAKs it SHALL contain the requester's IP\n               address if known,
    otherwise zero.\n               In other replies it SHALL contain the target\n
    \              port's IP address.\n     ar$sha  - in requests and NAKs it SHALL
    contain the requester's ULA\n               In replies it SHALL contain the target
    port's ULA.\n     ar$spa  - in requests and NAKs it SHALL contain the requester's
    IP\n               address if known, otherwise zero.\n               In other
    replies it SHALL contain the target\n               port's IP address.\n     ar$tha
    \ - in requests and NAKs it SHALL contain the target's ULA\n               if
    known, otherwise zero.\n               In other replies it SHALL contain the requester's
    ULA.\n     ar$tpa  - in requests and NAKs it SHALL contain the\n               target's
    IP address if known, otherwise zero.\n               In other replies it SHALL
    contain the requester's\n               IP address.\n   |31             |23             |15
    \            |7             0|\n   +---------------+---------------+---------------+---------------+-----\n
    0 |                                                               |\n   |         D_ULA
    \                +-------------------------------+HIPPI\n 1 |                               |
    \                              |6400\n   +-------------------------------+            S_ULA
    \             |MAC\n 2 |                                                               |hdr\n
    \  +---------------------------------------------------------------+\n 3 |                             M_len
    \                            |\n   +---------------+---------------+---------------+---------------+-----\n
    4 |      AA       |       AA      |       03      |      00       |IEEE\n   +---------------+---------------+---------------+---------------+802\n
    5 |       00      |       00      |  Ethertype  =  0x0800 = 2048  |LLC/\n   +------------+------------------+-------------------------------+SNAP\n
    6 |            hrd (1)            |           pro (2048)          |\n   +---------------+---------------+---------------+---------------+\n
    7 |     hln (6)   |   phl (4)     |             op (ar$op)        |\n   +<><><><><><><><+><><><><><><><>+<><><><><><><><+><><><><><><><>+\n
    8 |              Source Hardware Address  0 - 3                   |\n   +-------------------------------+-------------------------------+\n
    9 | Source ULA bytes 4 - 5        | Source IP Address bytes 0 - 1 |\n   +-------------------------------+-------------------------------+\n"
  - "10 | Source IP Address bytes 2 - 3 |    Target ULA bytes 0 - 1     |\n   +-------------------------------+-------------------------------+\n"
  - "11 |           Target Hardware Address (ULA) bytes 2 - 5           |\n   +---------------------------------------------------------------+\n"
  - "12 |                         Target IP Address                     |\n   +---------------+---------------+---------------+---------------+\n"
  - "13 |     FILL      |     FILL      |      FILL     |     FILL      |\n   +---------------+---------------+---------------+---------------+\n"
  - "14 |     FILL      |     FILL      |      FILL     |     FILL      |\n   +><><><><><><><>+<><><><><><><><+><><><><><><><>+<><><><><><><><+\n"
  - "6.2 HIPARP Message Formats\n   The HARP protocols further SHALL support the HIPARP
    hardware type\n   (ar$hrd) = 28 (dec) [18], protocol type (ar$pro), and operation
    code\n   (ar$op) data formats as the ARP, and InARP protocols [14,7]. In\n   addition,
    HARP makes use of an additional operation code for ARP_NAK\n   introduced with
    [11]. The remainder of the HIPARP message format\n   (defined in [13]) is different
    than the ARP/InARP message format\n   defined in [14,7,10] and it is also different
    from the format defined\n   in the first \"IP and ARP on HIPPI\" RFC-1374 [16].\n
    \  The HARP message has several fields that have the following format\n   and
    values:\n   Data sizes and field meaning:\n     ar$hrd  16 bits  Hardware type\n
    \    ar$pro  16 bits  Protocol type of the protocol fields below\n     ar$op   16
    bits  Operation code (request, reply, or NAK)\n     ar$pln   8 bits  byte length
    of each protocol address\n     ar$rhl   8 bits  requester's HIPPI hardware address
    length (q)\n     ar$thl   8 bits  target's HIPPI hardware address length (x)\n
    \    ar$rpa  32 bits  requester's protocol address\n     ar$tpa  32 bits  target's
    protocol address\n     ar$rha  qbytes   requester's HIPPI Hardware address\n     ar$tha
    \ xbytes   target's HIPPI Hardware address\n   Where :\n     ar$hrd  - SHALL contain
    28. (HIPARP)\n     ar$pro  - SHALL contain the IP protocol code 2048 (decimal).\n
    \    ar$op   - SHALL contain the operational value (decimal):\n               1
    \ for   HARP_REQUESTs\n               2  for   HARP_REPLYs\n               8  for
    InHARP_REQUESTs\n               9  for InHARP_REPLYs\n               10 for   HARP_NAK\n
    \    ar$pln  - SHALL contain 4.\n     ar$rln  - SHALL contain 10 IF this is a
    HIPPI-800 HW address\n               ELSE, for HIPPI-6400, it SHALL contain 6.\n
    \    ar$thl  - SHALL contain 10 IF this is a HIPPI-800 HW address\n               ELSE,
    for HIPPI-6400, it SHALL contain 6.\n     ar$rha  - in requests and NAKs it SHALL
    contain the requester's\n               HW address.\n               In replies
    it SHALL contain the target port's HW address.\n     ar$rpa  - in requests and
    NAKs it SHALL contain the requester's IP\n               address if known, otherwise
    zero.\n               In other replies it SHALL contain the target\n               port's
    IP address.\n     ar$tha  - in requests and NAKs it SHALL contain the target's\n
    \              HW address if known, otherwise zero.\n               In other replies
    it SHALL contain the requester's\n               HW address.\n     ar$tpa  - in
    requests and NAKs it SHALL contain the\n               target's IP address if
    known, otherwise zero.\n               In other replies it SHALL contain the requester's\n
    \              IP address.\n                  Payload Format for HARP/InHARP PDUs:\n
    \  |31             |23             |15             |7             0|\n   +---------------+---------------+---------------+---------------+-----\n
    0 |                                                               |\n   |         D_ULA
    \                +-------------------------------+HIPPI\n 1 |                               |
    \                              |6400\n   +-------------------------------+            S_ULA
    \             |MAC\n 2 |                                                               |hdr\n
    \  +---------------------------------------------------------------+\n 3 |                             M_len
    \                            |\n   +---------------+---------------+---------------+---------------+-----\n
    4 |      AA       |       AA      |       03      |      00       |IEEE\n   +---------------+---------------+---------------+---------------+802\n
    5 |       00      |       00      |  Ethertype  =  0x0800 = 2048  |LLC/\n   +------------+------------------+-------------------------------+SNAP\n
    6 |            hrd (28)           |           pro (2048)          |\n   +---------------+---------------+---------------+---------------+\n
    7 |             op (ar$op)        |     pln (6)   |   shl (q)     |\n   +<><><><><><><><+><><><><><><><>+<><><><><><><><+><><><><><><><>+\n
    8 |    thl (x)    |      Source IP Address upper (24 bits)        |\n   +---------------------------------------------------------------+\n
    9 | Src. IP lower |      Target IP Address upper (24 bits)        |\n   +---------------+-----------------------------------------------+\n"
  - "10 | Tgt. IP lower |       Source HW Address bytes 0 - 2           |\n   +---------------+-------------------------------+---------------+\n"
  - "11 |   Source HW Address bytes 3 - q               | Tgt HW byte 0 |\n   +-----------------------------------------------+---------------+\n"
  - "12 |              Target Hardware Address bytes 1 - 4              |\n   +---------------+-----------------------------------------------+\n"
  - "13 |Tgt HW byte 5-x|\n   +---------------+\n                          HARP -
    InHARP Message\n"
  title: 6.1 Generic IEEE 802 ARP Message Format
- contents:
  - "6.2.1 Example Message encodings:\n   Assume for the following example that the
    HARP server is in the\n   HIPPI-6400 side and the clients, X and Y are on the
    HIPPI-800 side of\n   the non-broadcast capable network.\n   HARP_REQUEST message\n
    \        HARP ar$op   = 1 (HARP_REQUEST)\n         HARP ar$rpa  = IPy                HARP
    ar$tpa  = IPx\n         HARP ar$rha  = SWy ULAy           HARP ar$tha  = **\n
    \        ** is what we would like to find out\n   HARP_REPLY message format\n
    \        HARP ar$op   = 2 (HARP_REPLY)\n         HARP ar$rpa  = IPx                HARP
    ar$tpa  = IPy\n         HARP ar$rha  = SWx ULAx *         HARP ar$tha  = SWy ULAy\n
    \        * answer we were looking for\n   InHARP_REQUEST message format\n         HARP
    ar$op    = 8 (InHARP_REQUEST)\n         HARP ar$rpa   = IPy               HARP
    ar$tpa   = 0 **\n         HARP ar$rha   = SWy ULAy          HARP ar$tha   = SWx
    ULAx\n         ** is what we would like to find out\n   InHARP_REPLY message format\n
    \        HARP ar$op    = 9 (InHARP_REPLY)\n         HARP ar$rpa   = IPx *             HARP
    ar$tpa   = IPy\n         HARP ar$rha   = SWx ULAx          HARP ar$tha   = SWy
    ULAy\n         * answer we were looking for\n"
  title: '6.2.1 Example Message encodings:'
- contents:
  - "6.2.2 HARP_NAK message format\n   The HARP_NAK message format is the same as
    the received HARP_REQUEST\n   message format with the operation code set to HARP_NAK;
    i.e. the\n   HARP_REQUEST message data is copied for transmission with the\n   HARP_REQUEST
    operation code changed to the HARP_NAK value.  HARP\n   makes use of an additional
    operation code for HARP_NAK and MUST be\n   implemented.\n"
  title: 6.2.2 HARP_NAK message format
- contents:
  - "7  Broadcast and Multicast\n   HIPPI-6400-SC requires compliant systems to support
    broadcast.\n   Initial HIPPI-6400-SC systems MAY defer broadcast capability to
    a\n   broadcast server rather than support it directly in the switching\n   mechanism.
    \ A centralized HARP server architecture meets two of the\n   three major duties
    of a broadcast server.\n   A central entity serving the whole LIS solves the coordination\n
    \  problem of a distributed approach. The registration requirement\n   solves
    the second problem of determining which addresses make up the\n   set loosely
    called \"everyone\". The last duty of a broadcast server is\n   to replicate an
    incoming packet and send it to \"everyone\".\n   During its registration phase,
    every port , including HARP server(s),\n   discover if the underlying medium is
    capable of broadcast (see\n   section 5.1.1). Should this not be the case, then
    the HARP server(s)\n   MUST emulate broadcast through an IP broadcast emulation
    server.\n   A HIPPI IP broadcast server (PIBES) is an extension to the HARP\n
    \  server and only makes sense when the LIS does not inherently support\n   broadcast.
    The PIBES allows common upper layer networking protocols\n   (RIP, TCP, UDP, etc.)to
    access IP LIS broadcast.\n"
  title: 7  Broadcast and Multicast
- contents:
  - "7.1 Protocol for an IP Broadcast Emulation Server - PIBES\n   To emulate broadcast
    within an LIS, a PIBES SHALL use the currently\n   valid HARP table of the HARP
    server as a list of addresses called the\n   target list. The broadcast server
    SHALL validate that all incoming\n   messages have a source address which corresponds
    to an address in the\n   target list. Only messages addressed to the IP LIS broadcast\n
    \  addresses, multicast address or 255.255.255.255 are considered valid\n   messages
    for broadcasting. Invalid messages MUST be dropped.  All\n   valid incoming messages
    shall be forwarded to all addresses in the\n   target list.\n   It is RECOMMENDED
    that the broadcast server run on the same port as\n   the HARP server since this
    memo does not define the protocol for\n   exchanging the valid HARP table. The
    default address to use for the\n   broadcast address is the operational HARP server
    address.\n"
  title: 7.1 Protocol for an IP Broadcast Emulation Server - PIBES
- contents:
  - "7.2 IP Broadcast Address\n   This memo only defines IP broadcast. It is independent
    of the\n   underlying hardware addressing and broadcast capabilities. Any port\n
    \  can differentiate between IP traffic directed to itself and a\n   broadcast
    message sent to it by looking at the IP address. All IP\n   broadcast messages
    SHALL use the IP LIS broadcast address.\n   It is RECOMMENDED that the PIBES run
    on the same port as the HARP\n   server. In that case, the PIBES SHALL use the
    same address as the\n   HARP server.\n"
  title: 7.2 IP Broadcast Address
- contents:
  - "7.3 IP Multicast Address\n   HIPPI-6400 does not directly support multicast address,
    therefore\n   there are no mappings available from IP multicast addresses to HIPPI\n
    \  multicast services.  Current IP multicast implementations (i.e. MBONE\n   and
    IP tunneling, see [7]) will continue to operate over HIPPI-based\n   logical IP
    subnets if all IP multicast packets are sent using the\n   same algorithm as if
    the packet were being sent to 255.255.255.255.\n"
  title: 7.3 IP Multicast Address
- contents:
  - "7.4 A Note on Broadcast Emulation Performance\n   It is obvious that a broadcast
    emulation service (as defined in\n   section 7.1) has an inherent performance
    limit. In an LIS with n\n   ports, the upper bound on the bandwidth that such
    a service can\n   broadcast is:\n                          (total bandwidth)/(n+1)\n
    \  since each message must first enter the broadcast server, accounting\n   for
    the additional 1, and then be sent to all n ports. The broadcast\n   server could
    forward the message destined to the port on which it\n   runs internally, thus
    reducing (n+1) to (n) in a first optimization.\n   This service is adequate for
    the standard networking protocols such\n   as RIP, OSPF, NIS, etc. since they
    usually use a small fraction of\n   the network bandwidth for broadcast. For these
    purposes, the\n   broadcast emulation server as defined in this memo allows the
    HIPPI-\n   6400 network to look similar to an Ethernet network to the higher\n
    \  layers.\n   It is further obvious that such an emulation cannot be used to\n
    \  broadcast high bandwidth traffic. For such a solution, hardware\n   support
    for true broadcast is required.\n"
  title: 7.4 A Note on Broadcast Emulation Performance
- contents:
  - "8 HARP for Scheduled Transfer\n   This RFC also applies for resolving addresses
    used with Scheduled\n   Transfer (ST) over HIPPI-6400 instead of IP. This RFC's
    message types\n   and algorithms can be used for ST (since ST uses Internet Addresses)\n
    \  as long as there is also an IP over HIPPI-6400 implementation on all\n   the
    ports.\n"
  title: 8 HARP for Scheduled Transfer
- contents:
  - "9 Security Consierations\n   There are known security issues relating to port
    impersonation via\n   the address resolution protocols used in the Internet [6].
    \ No\n   special security mechanisms have been added to the address resolution\n
    \  mechanism defined here for use with networks using HARP.\n   Not all of the
    security issues relating to ARP over HIPPI-6400 are\n   clearly understood at
    this time, due to the fluid state of HIPPI-6400\n   specifications, newness of
    the technology, and other factors.\n   However, given the security hole ARP allows,
    other concerns are\n   probably minor.\n"
  title: 9 Security Consierations
- contents:
  - "10 Open Issues\n   Synchronization and coordination of multiple HARP servers
    and\n   multiple broadcast servers are left for further study.\n"
  title: 10 Open Issues
- contents:
  - "11 HARP Examples\n   Assume a HIPPI-6400-SC switch is installed with three connected\n
    \  ports:  x, y, and a. Each port has a unique hardware address that\n   consists
    unique ULA (ULAx, ULAy and UlAa, respectively). There is a\n   HARP server connected
    to a switch port that is mapped to the address\n   HWa, this address is the authoritative
    HIPPI hardware address in the\n   HRAL (HARP Request Address List).\n   The HARP
    server's table is empty. Ports X and Y each know their own\n   hardware address.
    \ Eventually they want to talk to each other; each\n   knows the other's IP address
    (from the port database) but neither\n   knows the other's ULA. Both ports X and
    Y have their interfaces\n   configured DOWN.\n   NOTE: The LLC, SNAP, Ethertype,
    ar$hrd, ar$pro, ar$pln fields are\n   left out from the examples below since they
    are constant. As well as\n   ar$rhl = ar$thl = 6 since these are all HIPPI-6400
    examples.\n"
  title: 11 HARP Examples
- contents:
  - "11.1 Registration Phase of Client Y on Non-broadcast Hardware\n   Port Y starts:
    its HARP table entry state for the server: PENDING\n   1. Port Y initiates its
    interface and sends an InHARP_REQUEST to the\n      HWa after starting a table
    entry for the HWa.\n      HIPPI-6400-PH D_ULA                 = ULAa\n      HIPPI-6400-PH
    S_ULA                 = ULAy\n      HARP ar$op                          = 8 (InHARP_REQUEST)\n
    \     HARP ar$rpa                         = IPy\n      HARP ar$tpa                         =
    0 **\n      HARP ar$rha                         = ULAy\n      HARP ar$tha                         =
    ULAa\n      ** is what we would like to find out\n   2. HARP server receives Y's
    InHARP_REQUEST, it examines the source\n      addresses and scans its tables for
    a match. Since this is the\n      first time Y connects to this server there is
    no entry and one\n      will be created and time stamped with the information
    from the\n      InHARP_REQUEST. The HARP server will then send a InHARP_REPLY\n
    \     including its IP address.\n      HIPPI-6400-PH D_ULA                 = ULAy\n
    \     HIPPI-6400-PH S_ULA                 = ULAa\n      HARP ar$op                          =
    9 (InHARP_REPLY)\n      HARP ar$rpa                         = IPs *\n      HARP
    ar$tpa                         = IPy\n      HARP ar$rha                         =
    ULAa\n      HARP ar$tha                         = ULAy\n      * answer we were
    looking for\n   3. Port Y examines the incoming InHARP_REPLY and completes its
    table\n      entry for the HARP server. The client's HARP table entry for the\n
    \     server now passes into the VALID state and is usable for regular\n      HARP
    traffic. Receiving this reply ensures that the HARP server\n      has properly
    registered the client.\n"
  title: 11.1 Registration Phase of Client Y on Non-broadcast Hardware
- contents:
  - "11.2 Registration Phase of Client Y on Broadcast Capable Hardware\n   If port
    Y is connected to a broadcast-capable network then the\n   authoritative address
    is the broadcast address, HWb = SWb, ULAb\n   (FF:FF:FF:FF:FF:FF).\n   Port Y
    starts: its HARP table entry state for HWa: PENDING\n   1. Port Y initiates its
    interface and sends an InHARP_REQUEST to HWa,\n      in this example the broadcast
    address, after starting a table\n      entry.\n      HIPPI-6400-PH D_ULA                 =
    ULAb\n      HIPPI-6400-PH S_ULA                 = ULAy\n      HARP ar$op                          =
    8 (InHARP_REQUEST)\n      HARP ar$rpa                         = IPy\n      HARP
    ar$tpa                         = 0 **\n      HARP ar$rha                         =
    ULAy\n      HARP ar$tha                         = ULAb\n      ** is what we would
    like to find out\n   2. Since the network is a broadcast network, client Y will
    receive a\n      copy of its InHARP_REQUEST. Client Y examines the source\n      addresses.
    \ Since they are the same as what Y filled in the\n      InHARP_REQUEST, Y can
    deduce that it is connected to a broadcast\n      medium.  Port Y completes its
    table entry for HWa. This entry will\n      not timeout since it is considered
    unlikely for a particular\n      underlying hardware type to change between broadcast
    and non-\n      broadcast; therefore this mapping will never change.\n"
  title: 11.2 Registration Phase of Client Y on Broadcast Capable Hardware
- contents:
  - "11.3 Operational Phase (phase II)\n   The Operational Phase of the HARP protocol
    as specified in this memo\n   is the same for both broadcast and non-broadcast
    capable HIPPI-6400\n   hardware. The authoritative address in the HRAL for this
    example will\n   be HWa: <SWa, ULAa> and IPs for simplicity reasons.\n"
  title: 11.3 Operational Phase (phase II)
- contents:
  - "11.3.1 Successful HARP_Resolve example\n   Assume the same process (steps 1-3
    of section 11.1) happened for port\n   X. Then the state of X and Y's tables is:
    the HARP server table entry\n   is in the VALID state. So lets look at the message
    traffic when X\n   tries to send a message to Y. Since X doesn't have an entry
    for Y,\n   1. Port X connects to the authoritative address of the HRAL and sends\n
    \     a HARP_REQUEST for Y's hardware address:\n      HIPPI-6400-PH D_ULA                 =
    ULAa\n      HIPPI-6400-PH S_ULA                 = ULAx\n      HARP ar$op                          =
    1  (HARP_REQUEST)\n      HARP ar$rpa                         = IPx\n      HARP
    ar$tpa                         = IPy\n      HARP ar$rha                         =
    ULAx\n      HARP ar$tha                         = 0 **\n      ** is what we would
    like to find out\n   2. The HARP server receives the HARP request and updates
    its entry\n      for X if necessary. It then generates a HARP_REPLY with Y's\n
    \     hardware address information.\n      HIPPI-6400-PH D_ULA                 =
    ULAx\n      HIPPI-6400-PH S_ULA                 = ULAa\n      HARP ar$op                          =
    2  (HARP_Reply)\n      HARP ar$rpa                         = IPy\n      HARP ar$tpa
    \                        = IPx\n      HARP ar$rha                         = ULAy
    *\n      HARP ar$tha                         = ULAx\n      * answer we were looking
    for\n   3. Port X connects to port Y and transmits an IP message with the\n      following
    information in the HIPPI-LE header:\n      HIPPI-6400-PH D_ULA                 =
    ULAy\n      HIPPI-6400-PH S_ULA                 = ULAx\n      <data>\n   If the
    network had been broadcast-capable, the target ports would\n   themselves have
    received the HARP_REQUEST of step 2 above and\n   responded to them in the same
    way the HARP server did.\n"
  title: 11.3.1 Successful HARP_Resolve example
- contents:
  - "11.3.2 Non-successful HARP_Resolve example\n   As in 11.3.1, assume that X and
    Y are fully registered with the HARP\n   server. Then the state of X and Y's HARP
    server table entry is:\n   VALID. So lets look at the message traffic when X tries
    to send a\n   message to Q. Further assume that interface Q is NOT configured
    UP,\n   i.e. it is DOWN.  Since X doesn't have an entry for Q,\n   1. Port X connects
    to the HARP server switch address and sends a\n      HARP_REQUEST for Q's hardware
    address:\n      HIPPI-6400-PH D_ULA                 = ULAa\n      HIPPI-6400-PH
    S_ULA                 = ULAx\n      HARP ar$op                          = 1  (HARP_REQUEST)\n
    \     HARP ar$rpa                         = IPx\n      HARP ar$tpa                         =
    IPq\n      HARP ar$rha                         = ULAx\n      HARP ar$tha                         =
    0 **\n      ** is what we would like to find out\n   2. The HARP server receives
    the HARP request and updates its entry\n      for X if necessary. It then looks
    up IPq in its tables and doesn't\n      find it. The HARP server then generates
    a HARP_NAK reply message.\n      HIPPI-6400-PH D_ULA                 = ULAx\n
    \     HIPPI-6400-PH S_ULA                 = ULAa\n      HARP ar$op                          =
    10  (HARP_NAK)\n      HARP ar$rpa                         = IPx\n      HARP ar$tpa
    \                        = IPq\n      HARP ar$rha                         = ULAx\n
    \     HARP ar$tha                         = 0 ***\n      *** No Answer, and notice
    that the fields do not get swapped,\n          i.e. the HARP message is the same
    as the HARP_REQUEST\n          except for the operation code.\n   If the network
    had been broadcast-capable, then there would not have\n   been a reply.\n"
  title: 11.3.2 Non-successful HARP_Resolve example
- contents:
  - "12 References\n   [1]  ANSI NCITS 323-1998, Information Technology - High-Performance\n
    \       Parallel Interface - 6400 Mbit/s Physical Layer (HIPPI-6400-PH).\n   [2]
    \ ANSI NCITS 324-199x, Information Technology - High-Performance\n        Parallel
    Interface - 6400 Mbit/s Physical Switch Control\n        (HIPPI-6400-SC).\n   [3]
    \ ANSI NCITS Project Number 1249-D, Information Technology -\n        High-Performance
    Parallel Interface - 6400 Mbit/s Optical\n        Specification (HIPPI-6400-OPT).\n
    \  [4]  Braden, R., \"Requirements for Internet Hosts -- Communication\n        Layers\",
    STD 3, RFC 1122, October 1989.\n   [5]  Bradely, T. and C. Brown, \"Inverse Address
    Resolution Protocol\",\n        RFC 2390, September 1998.\n   [6]  Bellovin, Steven
    M., \"Security Problems in the TCP/IP Protocol\n        Suite\", ACM Computer
    Communications Review, Vol. 19, Issue 2,\n        pp.  32-48, 1989.\n   [7]  Deering,
    S, \"Host Extensions for IP Multicasting\", STD 5, RFC\n        1112, August 1989.\n
    \  [8]  Chesson, Greg, \"HIPPI-6400 Overview\", IEEE Hot Interconnects\n        1996,
    Stanford University.\n   [10] ANSI/IEEE Std. 802.2-1989, Information Processing
    Systems -\n        Local Area Networks - Logical Link Control IEEE, IEEE, New
    York,\n        New York, 1989.\n   [11] Laubach, M., \"Classical IP and ARP over
    ATM\", RFC 2225, April\n        1998.\n   [12] Mogul, J. and S. Deering, \"Path
    MTU Discovery\", RFC 1191,\n        November, 1990.\n   [13] Pittet, J.-M., \"ARP
    and IP Broadcast over HIPPI-800\", RFC 2834,\n        May 2000.\n   [14] Plummer,
    D., \"An Ethernet Address Resolution Protocol - or -\n        Converting Network
    Addresses to 48-bit Ethernet Address for\n        Transmission on Ethernet Hardware\",
    RFC-826, MIT, November 1982.\n   [15] Postel, J., \"Internet Protocol\", STD 5,
    RFC 791, September 1981.\n   [16] Renwick, J. and A. Nicholson, \"IP and ARP on
    HIPPI\", RFC 1374,\n        October 1992.\n   [17] Renwick, J., \"IP over HIPPI\",
    RFC 2067, January 1997.\n   [18] Reynolds, J. and J. Postel, \"Assigned Numbers\",
    STD 2, RFC 1700,\n        October 1994.\n   [19] Bradner, S., \"Key words for
    use in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March
    1997.\n"
  title: 12 References
- contents:
  - "13 Acknowledgments\n   This memo could not have come into being without the critical
    review\n   from Greg Chesson, Carlin Otto, the High performance interconnect\n
    \  group of Silicon Graphics (specifically Jim Pinkerton, Brad Strand\n   and
    Jeff Young) and the expertise of the ANSI T11.1 Task Group\n   responsible for
    the HIPPI standards work.\n   This memo is based on the second part of [17], written
    by John\n   Renwick. ARP [14] written by Dave Plummer and Inverse ARP [7] written\n
    \  by Terry Bradley and Caralyn Brown provide the fundamental algorithms\n   of
    HARP as presented in this memo. Further, the HARP server is based\n   on concepts
    and models presented in [13], written by Mark Laubach who\n   laid the structural
    groundwork for the HARP server.\n"
  title: 13 Acknowledgments
- contents:
  - "14 Author's Address\n   Jean-Michel Pittet\n   Silicon Graphics Inc\n   1600
    Amphitheatre Parkway\n   Mountain View, CA 94040\n   Phone: 650-933-6149\n   Fax:
    \  650-933-3542\n   EMail: jmp@sgi.com, jmp@acm.org\n"
  title: 14 Author's Address
- contents:
  - "15 Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 15 Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
