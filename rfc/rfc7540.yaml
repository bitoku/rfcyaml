- title: __initial_text__
  contents:
  - '             Hypertext Transfer Protocol Version 2 (HTTP/2)

    '
- title: Abstract
  contents:
  - "Abstract\n   This specification describes an optimized expression of the semantics\n\
    \   of the Hypertext Transfer Protocol (HTTP), referred to as HTTP\n   version\
    \ 2 (HTTP/2).  HTTP/2 enables a more efficient use of network\n   resources and\
    \ a reduced perception of latency by introducing header\n   field compression\
    \ and allowing multiple concurrent exchanges on the\n   same connection.  It also\
    \ introduces unsolicited push of\n   representations from servers to clients.\n\
    \   This specification is an alternative to, but does not obsolete, the\n   HTTP/1.1\
    \ message syntax.  HTTP's existing semantics remain unchanged.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7540.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. HTTP/2 Protocol Overview ........................................5\n  \
    \    2.1. Document Organization ......................................6\n    \
    \  2.2. Conventions and Terminology ................................6\n   3. Starting\
    \ HTTP/2 .................................................7\n      3.1. HTTP/2\
    \ Version Identification ..............................8\n      3.2. Starting\
    \ HTTP/2 for \"http\" URIs ............................8\n           3.2.1. HTTP2-Settings\
    \ Header Field .........................9\n      3.3. Starting HTTP/2 for \"https\"\
    \ URIs ..........................10\n      3.4. Starting HTTP/2 with Prior Knowledge\
    \ ......................10\n      3.5. HTTP/2 Connection Preface .................................11\n\
    \   4. HTTP Frames ....................................................12\n  \
    \    4.1. Frame Format ..............................................12\n    \
    \  4.2. Frame Size ................................................13\n      4.3.\
    \ Header Compression and Decompression ......................14\n   5. Streams\
    \ and Multiplexing .......................................15\n      5.1. Stream\
    \ States .............................................16\n           5.1.1. Stream\
    \ Identifiers .................................21\n           5.1.2. Stream Concurrency\
    \ .................................22\n      5.2. Flow Control ..............................................22\n\
    \           5.2.1. Flow-Control Principles ............................23\n  \
    \         5.2.2. Appropriate Use of Flow Control ....................24\n    \
    \  5.3. Stream Priority ...........................................24\n      \
    \     5.3.1. Stream Dependencies ................................25\n        \
    \   5.3.2. Dependency Weighting ...............................26\n          \
    \ 5.3.3. Reprioritization ...................................26\n           5.3.4.\
    \ Prioritization State Management ....................27\n           5.3.5. Default\
    \ Priorities .................................28\n      5.4. Error Handling ............................................28\n\
    \           5.4.1. Connection Error Handling ..........................29\n  \
    \         5.4.2. Stream Error Handling ..............................29\n    \
    \       5.4.3. Connection Termination .............................30\n      5.5.\
    \ Extending HTTP/2 ..........................................30\n   6. Frame Definitions\
    \ ..............................................31\n      6.1. DATA ......................................................31\n\
    \      6.2. HEADERS ...................................................32\n  \
    \    6.3. PRIORITY ..................................................34\n    \
    \  6.4. RST_STREAM ................................................36\n      6.5.\
    \ SETTINGS ..................................................36\n           6.5.1.\
    \ SETTINGS Format ....................................38\n           6.5.2. Defined\
    \ SETTINGS Parameters ........................38\n           6.5.3. Settings Synchronization\
    \ ...........................39\n      6.6. PUSH_PROMISE ..............................................40\n\
    \      6.7. PING ......................................................42\n  \
    \    6.8. GOAWAY ....................................................43\n    \
    \  6.9. WINDOW_UPDATE .............................................46\n      \
    \     6.9.1. The Flow-Control Window ............................47\n        \
    \   6.9.2. Initial Flow-Control Window Size ...................48\n          \
    \ 6.9.3. Reducing the Stream Window Size ....................49\n      6.10. CONTINUATION\
    \ .............................................49\n   7. Error Codes ....................................................50\n\
    \   8. HTTP Message Exchanges .........................................51\n  \
    \    8.1. HTTP Request/Response Exchange ............................52\n    \
    \       8.1.1. Upgrading from HTTP/2 ..............................53\n      \
    \     8.1.2. HTTP Header Fields .................................53\n        \
    \   8.1.3. Examples ...........................................57\n          \
    \ 8.1.4. Request Reliability Mechanisms in HTTP/2 ...........60\n      8.2. Server\
    \ Push ...............................................60\n           8.2.1. Push\
    \ Requests ......................................61\n           8.2.2. Push Responses\
    \ .....................................63\n      8.3. The CONNECT Method ........................................64\n\
    \   9. Additional HTTP Requirements/Considerations ....................65\n  \
    \    9.1. Connection Management .....................................65\n    \
    \       9.1.1. Connection Reuse ...................................66\n      \
    \     9.1.2. The 421 (Misdirected Request) Status Code ..........66\n      9.2.\
    \ Use of TLS Features .......................................67\n           9.2.1.\
    \ TLS 1.2 Features ...................................67\n           9.2.2. TLS\
    \ 1.2 Cipher Suites ..............................68\n   10. Security Considerations\
    \ .......................................69\n      10.1. Server Authority .........................................69\n\
    \      10.2. Cross-Protocol Attacks ...................................69\n  \
    \    10.3. Intermediary Encapsulation Attacks .......................70\n    \
    \  10.4. Cacheability of Pushed Responses .........................70\n      10.5.\
    \ Denial-of-Service Considerations .........................70\n           10.5.1.\
    \ Limits on Header Block Size .......................71\n           10.5.2. CONNECT\
    \ Issues ....................................72\n      10.6. Use of Compression\
    \ .......................................72\n      10.7. Use of Padding ...........................................73\n\
    \      10.8. Privacy Considerations ...................................73\n  \
    \ 11. IANA Considerations ...........................................74\n    \
    \  11.1. Registration of HTTP/2 Identification Strings ............74\n      11.2.\
    \ Frame Type Registry ......................................75\n      11.3. Settings\
    \ Registry ........................................75\n      11.4. Error Code\
    \ Registry ......................................76\n      11.5. HTTP2-Settings\
    \ Header Field Registration .................77\n      11.6. PRI Method Registration\
    \ ..................................78\n      11.7. The 421 (Misdirected Request)\
    \ HTTP Status Code ...........78\n      11.8. The h2c Upgrade Token ....................................78\n\
    \   12. References ....................................................79\n  \
    \    12.1. Normative References .....................................79\n    \
    \  12.2. Informative References ...................................81\n   Appendix\
    \ A. TLS 1.2 Cipher Suite Black List .......................83\n   Acknowledgements\
    \ ..................................................95\n   Authors' Addresses\
    \ ................................................96\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Hypertext Transfer Protocol (HTTP) is a wildly successful\n\
    \   protocol.  However, the way HTTP/1.1 uses the underlying transport\n   ([RFC7230],\
    \ Section 6) has several characteristics that have a\n   negative overall effect\
    \ on application performance today.\n   In particular, HTTP/1.0 allowed only one\
    \ request to be outstanding at\n   a time on a given TCP connection.  HTTP/1.1\
    \ added request pipelining,\n   but this only partially addressed request concurrency\
    \ and still\n   suffers from head-of-line blocking.  Therefore, HTTP/1.0 and HTTP/1.1\n\
    \   clients that need to make many requests use multiple connections to a\n  \
    \ server in order to achieve concurrency and thereby reduce latency.\n   Furthermore,\
    \ HTTP header fields are often repetitive and verbose,\n   causing unnecessary\
    \ network traffic as well as causing the initial\n   TCP [TCP] congestion window\
    \ to quickly fill.  This can result in\n   excessive latency when multiple requests\
    \ are made on a new TCP\n   connection.\n   HTTP/2 addresses these issues by defining\
    \ an optimized mapping of\n   HTTP's semantics to an underlying connection.  Specifically,\
    \ it\n   allows interleaving of request and response messages on the same\n  \
    \ connection and uses an efficient coding for HTTP header fields.  It\n   also\
    \ allows prioritization of requests, letting more important\n   requests complete\
    \ more quickly, further improving performance.\n   The resulting protocol is more\
    \ friendly to the network because fewer\n   TCP connections can be used in comparison\
    \ to HTTP/1.x.  This means\n   less competition with other flows and longer-lived\
    \ connections, which\n   in turn lead to better utilization of available network\
    \ capacity.\n   Finally, HTTP/2 also enables more efficient processing of messages\n\
    \   through use of binary message framing.\n"
- title: 2.  HTTP/2 Protocol Overview
  contents:
  - "2.  HTTP/2 Protocol Overview\n   HTTP/2 provides an optimized transport for HTTP\
    \ semantics.  HTTP/2\n   supports all of the core features of HTTP/1.1 but aims\
    \ to be more\n   efficient in several ways.\n   The basic protocol unit in HTTP/2\
    \ is a frame (Section 4.1).  Each\n   frame type serves a different purpose. \
    \ For example, HEADERS and DATA\n   frames form the basis of HTTP requests and\
    \ responses (Section 8.1);\n   other frame types like SETTINGS, WINDOW_UPDATE,\
    \ and PUSH_PROMISE are\n   used in support of other HTTP/2 features.\n   Multiplexing\
    \ of requests is achieved by having each HTTP request/\n   response exchange associated\
    \ with its own stream (Section 5).\n   Streams are largely independent of each\
    \ other, so a blocked or\n   stalled request or response does not prevent progress\
    \ on other\n   streams.\n   Flow control and prioritization ensure that it is\
    \ possible to\n   efficiently use multiplexed streams.  Flow control (Section\
    \ 5.2)\n   helps to ensure that only data that can be used by a receiver is\n\
    \   transmitted.  Prioritization (Section 5.3) ensures that limited\n   resources\
    \ can be directed to the most important streams first.\n   HTTP/2 adds a new interaction\
    \ mode whereby a server can push\n   responses to a client (Section 8.2).  Server\
    \ push allows a server to\n   speculatively send data to a client that the server\
    \ anticipates the\n   client will need, trading off some network usage against\
    \ a potential\n   latency gain.  The server does this by synthesizing a request,\
    \ which\n   it sends as a PUSH_PROMISE frame.  The server is then able to send\
    \ a\n   response to the synthetic request on a separate stream.\n   Because HTTP\
    \ header fields used in a connection can contain large\n   amounts of redundant\
    \ data, frames that contain them are compressed\n   (Section 4.3).  This has especially\
    \ advantageous impact upon request\n   sizes in the common case, allowing many\
    \ requests to be compressed\n   into one packet.\n"
- title: 2.1.  Document Organization
  contents:
  - "2.1.  Document Organization\n   The HTTP/2 specification is split into four parts:\n\
    \   o  Starting HTTP/2 (Section 3) covers how an HTTP/2 connection is\n      initiated.\n\
    \   o  The frame (Section 4) and stream (Section 5) layers describe the\n    \
    \  way HTTP/2 frames are structured and formed into multiplexed\n      streams.\n\
    \   o  Frame (Section 6) and error (Section 7) definitions include\n      details\
    \ of the frame and error types used in HTTP/2.\n   o  HTTP mappings (Section 8)\
    \ and additional requirements (Section 9)\n      describe how HTTP semantics are\
    \ expressed using frames and\n      streams.\n   While some of the frame and stream\
    \ layer concepts are isolated from\n   HTTP, this specification does not define\
    \ a completely generic frame\n   layer.  The frame and stream layers are tailored\
    \ to the needs of the\n   HTTP protocol and server push.\n"
- title: 2.2.  Conventions and Terminology
  contents:
  - "2.2.  Conventions and Terminology\n   The key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n   All numeric values are in network byte order.  Values\
    \ are unsigned\n   unless otherwise indicated.  Literal values are provided in\
    \ decimal\n   or hexadecimal as appropriate.  Hexadecimal literals are prefixed\n\
    \   with \"0x\" to distinguish them from decimal literals.\n   The following terms\
    \ are used:\n   client:  The endpoint that initiates an HTTP/2 connection.  Clients\n\
    \      send HTTP requests and receive HTTP responses.\n   connection:  A transport-layer\
    \ connection between two endpoints.\n   connection error:  An error that affects\
    \ the entire HTTP/2\n      connection.\n   endpoint:  Either the client or server\
    \ of the connection.\n   frame:  The smallest unit of communication within an\
    \ HTTP/2\n      connection, consisting of a header and a variable-length sequence\n\
    \      of octets structured according to the frame type.\n   peer:  An endpoint.\
    \  When discussing a particular endpoint, \"peer\"\n      refers to the endpoint\
    \ that is remote to the primary subject of\n      discussion.\n   receiver:  An\
    \ endpoint that is receiving frames.\n   sender:  An endpoint that is transmitting\
    \ frames.\n   server:  The endpoint that accepts an HTTP/2 connection.  Servers\n\
    \      receive HTTP requests and send HTTP responses.\n   stream:  A bidirectional\
    \ flow of frames within the HTTP/2 connection.\n   stream error:  An error on\
    \ the individual HTTP/2 stream.\n   Finally, the terms \"gateway\", \"intermediary\"\
    , \"proxy\", and \"tunnel\"\n   are defined in Section 2.3 of [RFC7230].  Intermediaries\
    \ act as both\n   client and server at different times.\n   The term \"payload\
    \ body\" is defined in Section 3.3 of [RFC7230].\n"
- title: 3.  Starting HTTP/2
  contents:
  - "3.  Starting HTTP/2\n   An HTTP/2 connection is an application-layer protocol\
    \ running on top\n   of a TCP connection ([TCP]).  The client is the TCP connection\n\
    \   initiator.\n   HTTP/2 uses the same \"http\" and \"https\" URI schemes used\
    \ by HTTP/1.1.\n   HTTP/2 shares the same default port numbers: 80 for \"http\"\
    \ URIs and\n   443 for \"https\" URIs.  As a result, implementations processing\n\
    \   requests for target resource URIs like \"http://example.org/foo\" or\n   \"\
    https://example.com/bar\" are required to first discover whether the\n   upstream\
    \ server (the immediate peer to which the client wishes to\n   establish a connection)\
    \ supports HTTP/2.\n   The means by which support for HTTP/2 is determined is\
    \ different for\n   \"http\" and \"https\" URIs.  Discovery for \"http\" URIs\
    \ is described in\n   Section 3.2.  Discovery for \"https\" URIs is described\
    \ in Section 3.3.\n"
- title: 3.1.  HTTP/2 Version Identification
  contents:
  - "3.1.  HTTP/2 Version Identification\n   The protocol defined in this document\
    \ has two identifiers.\n   o  The string \"h2\" identifies the protocol where\
    \ HTTP/2 uses\n      Transport Layer Security (TLS) [TLS12].  This identifier\
    \ is used\n      in the TLS application-layer protocol negotiation (ALPN) extension\n\
    \      [TLS-ALPN] field and in any place where HTTP/2 over TLS is\n      identified.\n\
    \      The \"h2\" string is serialized into an ALPN protocol identifier as\n \
    \     the two-octet sequence: 0x68, 0x32.\n   o  The string \"h2c\" identifies\
    \ the protocol where HTTP/2 is run over\n      cleartext TCP.  This identifier\
    \ is used in the HTTP/1.1 Upgrade\n      header field and in any place where HTTP/2\
    \ over TCP is identified.\n      The \"h2c\" string is reserved from the ALPN\
    \ identifier space but\n      describes a protocol that does not use TLS.\n  \
    \ Negotiating \"h2\" or \"h2c\" implies the use of the transport, security,\n\
    \   framing, and message semantics described in this document.\n"
- title: 3.2.  Starting HTTP/2 for "http" URIs
  contents:
  - "3.2.  Starting HTTP/2 for \"http\" URIs\n   A client that makes a request for\
    \ an \"http\" URI without prior\n   knowledge about support for HTTP/2 on the\
    \ next hop uses the HTTP\n   Upgrade mechanism (Section 6.7 of [RFC7230]).  The\
    \ client does so by\n   making an HTTP/1.1 request that includes an Upgrade header\
    \ field with\n   the \"h2c\" token.  Such an HTTP/1.1 request MUST include exactly\
    \ one\n   HTTP2-Settings (Section 3.2.1) header field.\n   For example:\n    \
    \ GET / HTTP/1.1\n     Host: server.example.com\n     Connection: Upgrade, HTTP2-Settings\n\
    \     Upgrade: h2c\n     HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS\
    \ payload>\n   Requests that contain a payload body MUST be sent in their entirety\n\
    \   before the client can send HTTP/2 frames.  This means that a large\n   request\
    \ can block the use of the connection until it is completely\n   sent.\n   If\
    \ concurrency of an initial request with subsequent requests is\n   important,\
    \ an OPTIONS request can be used to perform the upgrade to\n   HTTP/2, at the\
    \ cost of an additional round trip.\n   A server that does not support HTTP/2\
    \ can respond to the request as\n   though the Upgrade header field were absent:\n\
    \     HTTP/1.1 200 OK\n     Content-Length: 243\n     Content-Type: text/html\n\
    \     ...\n   A server MUST ignore an \"h2\" token in an Upgrade header field.\n\
    \   Presence of a token with \"h2\" implies HTTP/2 over TLS, which is\n   instead\
    \ negotiated as described in Section 3.3.\n   A server that supports HTTP/2 accepts\
    \ the upgrade with a 101\n   (Switching Protocols) response.  After the empty\
    \ line that terminates\n   the 101 response, the server can begin sending HTTP/2\
    \ frames.  These\n   frames MUST include a response to the request that initiated\
    \ the\n   upgrade.\n   For example:\n     HTTP/1.1 101 Switching Protocols\n \
    \    Connection: Upgrade\n     Upgrade: h2c\n     [ HTTP/2 connection ...\n  \
    \ The first HTTP/2 frame sent by the server MUST be a server connection\n   preface\
    \ (Section 3.5) consisting of a SETTINGS frame (Section 6.5).\n   Upon receiving\
    \ the 101 response, the client MUST send a connection\n   preface (Section 3.5),\
    \ which includes a SETTINGS frame.\n   The HTTP/1.1 request that is sent prior\
    \ to upgrade is assigned a\n   stream identifier of 1 (see Section 5.1.1) with\
    \ default priority\n   values (Section 5.3.5).  Stream 1 is implicitly \"half-closed\"\
    \ from\n   the client toward the server (see Section 5.1), since the request is\n\
    \   completed as an HTTP/1.1 request.  After commencing the HTTP/2\n   connection,\
    \ stream 1 is used for the response.\n"
- title: 3.2.1.  HTTP2-Settings Header Field
  contents:
  - "3.2.1.  HTTP2-Settings Header Field\n   A request that upgrades from HTTP/1.1\
    \ to HTTP/2 MUST include exactly\n   one \"HTTP2-Settings\" header field.  The\
    \ HTTP2-Settings header field\n   is a connection-specific header field that includes\
    \ parameters that\n   govern the HTTP/2 connection, provided in anticipation of\
    \ the server\n   accepting the request to upgrade.\n     HTTP2-Settings    = token68\n\
    \   A server MUST NOT upgrade the connection to HTTP/2 if this header\n   field\
    \ is not present or if more than one is present.  A server MUST\n   NOT send this\
    \ header field.\n   The content of the HTTP2-Settings header field is the payload\
    \ of a\n   SETTINGS frame (Section 6.5), encoded as a base64url string (that is,\n\
    \   the URL- and filename-safe Base64 encoding described in Section 5 of\n   [RFC4648],\
    \ with any trailing '=' characters omitted).  The ABNF\n   [RFC5234] production\
    \ for \"token68\" is defined in Section 2.1 of\n   [RFC7235].\n   Since the upgrade\
    \ is only intended to apply to the immediate\n   connection, a client sending\
    \ the HTTP2-Settings header field MUST\n   also send \"HTTP2-Settings\" as a connection\
    \ option in the Connection\n   header field to prevent it from being forwarded\
    \ (see Section 6.1 of\n   [RFC7230]).\n   A server decodes and interprets these\
    \ values as it would any other\n   SETTINGS frame.  Explicit acknowledgement of\
    \ these settings\n   (Section 6.5.3) is not necessary, since a 101 response serves\
    \ as\n   implicit acknowledgement.  Providing these values in the upgrade\n  \
    \ request gives a client an opportunity to provide parameters prior to\n   receiving\
    \ any frames from the server.\n"
- title: 3.3.  Starting HTTP/2 for "https" URIs
  contents:
  - "3.3.  Starting HTTP/2 for \"https\" URIs\n   A client that makes a request to\
    \ an \"https\" URI uses TLS [TLS12] with\n   the application-layer protocol negotiation\
    \ (ALPN) extension\n   [TLS-ALPN].\n   HTTP/2 over TLS uses the \"h2\" protocol\
    \ identifier.  The \"h2c\"\n   protocol identifier MUST NOT be sent by a client\
    \ or selected by a\n   server; the \"h2c\" protocol identifier describes a protocol\
    \ that does\n   not use TLS.\n   Once TLS negotiation is complete, both the client\
    \ and the server MUST\n   send a connection preface (Section 3.5).\n"
- title: 3.4.  Starting HTTP/2 with Prior Knowledge
  contents:
  - "3.4.  Starting HTTP/2 with Prior Knowledge\n   A client can learn that a particular\
    \ server supports HTTP/2 by other\n   means.  For example, [ALT-SVC] describes\
    \ a mechanism for advertising\n   this capability.\n   A client MUST send the\
    \ connection preface (Section 3.5) and then MAY\n   immediately send HTTP/2 frames\
    \ to such a server; servers can identify\n   these connections by the presence\
    \ of the connection preface.  This\n   only affects the establishment of HTTP/2\
    \ connections over cleartext\n   TCP; implementations that support HTTP/2 over\
    \ TLS MUST use protocol\n   negotiation in TLS [TLS-ALPN].\n   Likewise, the server\
    \ MUST send a connection preface (Section 3.5).\n   Without additional information,\
    \ prior support for HTTP/2 is not a\n   strong signal that a given server will\
    \ support HTTP/2 for future\n   connections.  For example, it is possible for\
    \ server configurations\n   to change, for configurations to differ between instances\
    \ in\n   clustered servers, or for network conditions to change.\n"
- title: 3.5.  HTTP/2 Connection Preface
  contents:
  - "3.5.  HTTP/2 Connection Preface\n   In HTTP/2, each endpoint is required to send\
    \ a connection preface as\n   a final confirmation of the protocol in use and\
    \ to establish the\n   initial settings for the HTTP/2 connection.  The client\
    \ and server\n   each send a different connection preface.\n   The client connection\
    \ preface starts with a sequence of 24 octets,\n   which in hex notation is:\n\
    \     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a\n   That is, the connection\
    \ preface starts with the string \"PRI *\n   HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\\
    n\").  This sequence MUST be followed by a\n   SETTINGS frame (Section 6.5), which\
    \ MAY be empty.  The client sends\n   the client connection preface immediately\
    \ upon receipt of a 101\n   (Switching Protocols) response (indicating a successful\
    \ upgrade) or\n   as the first application data octets of a TLS connection.  If\n\
    \   starting an HTTP/2 connection with prior knowledge of server support\n   for\
    \ the protocol, the client connection preface is sent upon\n   connection establishment.\n\
    \      Note: The client connection preface is selected so that a large\n     \
    \ proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do\n      not\
    \ attempt to process further frames.  Note that this does not\n      address the\
    \ concerns raised in [TALKING].\n   The server connection preface consists of\
    \ a potentially empty\n   SETTINGS frame (Section 6.5) that MUST be the first\
    \ frame the server\n   sends in the HTTP/2 connection.\n   The SETTINGS frames\
    \ received from a peer as part of the connection\n   preface MUST be acknowledged\
    \ (see Section 6.5.3) after sending the\n   connection preface.\n   To avoid unnecessary\
    \ latency, clients are permitted to send\n   additional frames to the server immediately\
    \ after sending the client\n   connection preface, without waiting to receive\
    \ the server connection\n   preface.  It is important to note, however, that the\
    \ server\n   connection preface SETTINGS frame might include parameters that\n\
    \   necessarily alter how a client is expected to communicate with the\n   server.\
    \  Upon receiving the SETTINGS frame, the client is expected to\n   honor any\
    \ parameters established.  In some configurations, it is\n   possible for the\
    \ server to transmit SETTINGS before the client sends\n   additional frames, providing\
    \ an opportunity to avoid this issue.\n   Clients and servers MUST treat an invalid\
    \ connection preface as a\n   connection error (Section 5.4.1) of type PROTOCOL_ERROR.\
    \  A GOAWAY\n   frame (Section 6.8) MAY be omitted in this case, since an invalid\n\
    \   preface indicates that the peer is not using HTTP/2.\n"
- title: 4.  HTTP Frames
  contents:
  - "4.  HTTP Frames\n   Once the HTTP/2 connection is established, endpoints can\
    \ begin\n   exchanging frames.\n"
- title: 4.1.  Frame Format
  contents:
  - "4.1.  Frame Format\n   All frames begin with a fixed 9-octet header followed\
    \ by a variable-\n   length payload.\n    +-----------------------------------------------+\n\
    \    |                 Length (24)                   |\n    +---------------+---------------+---------------+\n\
    \    |   Type (8)    |   Flags (8)   |\n    +-+-------------+---------------+-------------------------------+\n\
    \    |R|                 Stream Identifier (31)                      |\n    +=+=============================================================+\n\
    \    |                   Frame Payload (0...)                      ...\n    +---------------------------------------------------------------+\n\
    \                          Figure 1: Frame Layout\n   The fields of the frame\
    \ header are defined as:\n   Length:  The length of the frame payload expressed\
    \ as an unsigned\n      24-bit integer.  Values greater than 2^14 (16,384) MUST\
    \ NOT be\n      sent unless the receiver has set a larger value for\n      SETTINGS_MAX_FRAME_SIZE.\n\
    \      The 9 octets of the frame header are not included in this value.\n   Type:\
    \  The 8-bit type of the frame.  The frame type determines the\n      format and\
    \ semantics of the frame.  Implementations MUST ignore\n      and discard any\
    \ frame that has a type that is unknown.\n   Flags:  An 8-bit field reserved for\
    \ boolean flags specific to the\n      frame type.\n      Flags are assigned semantics\
    \ specific to the indicated frame type.\n      Flags that have no defined semantics\
    \ for a particular frame type\n      MUST be ignored and MUST be left unset (0x0)\
    \ when sending.\n   R: A reserved 1-bit field.  The semantics of this bit are\
    \ undefined,\n      and the bit MUST remain unset (0x0) when sending and MUST\
    \ be\n      ignored when receiving.\n   Stream Identifier:  A stream identifier\
    \ (see Section 5.1.1) expressed\n      as an unsigned 31-bit integer.  The value\
    \ 0x0 is reserved for\n      frames that are associated with the connection as\
    \ a whole as\n      opposed to an individual stream.\n   The structure and content\
    \ of the frame payload is dependent entirely\n   on the frame type.\n"
- title: 4.2.  Frame Size
  contents:
  - "4.2.  Frame Size\n   The size of a frame payload is limited by the maximum size\
    \ that a\n   receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.  This\n\
    \   setting can have any value between 2^14 (16,384) and 2^24-1\n   (16,777,215)\
    \ octets, inclusive.\n   All implementations MUST be capable of receiving and\
    \ minimally\n   processing frames up to 2^14 octets in length, plus the 9-octet\
    \ frame\n   header (Section 4.1).  The size of the frame header is not included\n\
    \   when describing frame sizes.\n      Note: Certain frame types, such as PING\
    \ (Section 6.7), impose\n      additional limits on the amount of payload data\
    \ allowed.\n   An endpoint MUST send an error code of FRAME_SIZE_ERROR if a frame\n\
    \   exceeds the size defined in SETTINGS_MAX_FRAME_SIZE, exceeds any\n   limit\
    \ defined for the frame type, or is too small to contain\n   mandatory frame data.\
    \  A frame size error in a frame that could alter\n   the state of the entire\
    \ connection MUST be treated as a connection\n   error (Section 5.4.1); this includes\
    \ any frame carrying a header\n   block (Section 4.3) (that is, HEADERS, PUSH_PROMISE,\
    \ and\n   CONTINUATION), SETTINGS, and any frame with a stream identifier of 0.\n\
    \   Endpoints are not obligated to use all available space in a frame.\n   Responsiveness\
    \ can be improved by using frames that are smaller than\n   the permitted maximum\
    \ size.  Sending large frames can result in\n   delays in sending time-sensitive\
    \ frames (such as RST_STREAM,\n   WINDOW_UPDATE, or PRIORITY), which, if blocked\
    \ by the transmission of\n   a large frame, could affect performance.\n"
- title: 4.3.  Header Compression and Decompression
  contents:
  - "4.3.  Header Compression and Decompression\n   Just as in HTTP/1, a header field\
    \ in HTTP/2 is a name with one or\n   more associated values.  Header fields are\
    \ used within HTTP request\n   and response messages as well as in server push\
    \ operations (see\n   Section 8.2).\n   Header lists are collections of zero or\
    \ more header fields.  When\n   transmitted over a connection, a header list is\
    \ serialized into a\n   header block using HTTP header compression [COMPRESSION].\
    \  The\n   serialized header block is then divided into one or more octet\n  \
    \ sequences, called header block fragments, and transmitted within the\n   payload\
    \ of HEADERS (Section 6.2), PUSH_PROMISE (Section 6.6), or\n   CONTINUATION (Section\
    \ 6.10) frames.\n   The Cookie header field [COOKIE] is treated specially by the\
    \ HTTP\n   mapping (see Section 8.1.2.5).\n   A receiving endpoint reassembles\
    \ the header block by concatenating\n   its fragments and then decompresses the\
    \ block to reconstruct the\n   header list.\n   A complete header block consists\
    \ of either:\n   o  a single HEADERS or PUSH_PROMISE frame, with the END_HEADERS\
    \ flag\n      set, or\n   o  a HEADERS or PUSH_PROMISE frame with the END_HEADERS\
    \ flag cleared\n      and one or more CONTINUATION frames, where the last CONTINUATION\n\
    \      frame has the END_HEADERS flag set.\n   Header compression is stateful.\
    \  One compression context and one\n   decompression context are used for the\
    \ entire connection.  A decoding\n   error in a header block MUST be treated as\
    \ a connection error\n   (Section 5.4.1) of type COMPRESSION_ERROR.\n   Each header\
    \ block is processed as a discrete unit.  Header blocks\n   MUST be transmitted\
    \ as a contiguous sequence of frames, with no\n   interleaved frames of any other\
    \ type or from any other stream.  The\n   last frame in a sequence of HEADERS\
    \ or CONTINUATION frames has the\n   END_HEADERS flag set.  The last frame in\
    \ a sequence of PUSH_PROMISE\n   or CONTINUATION frames has the END_HEADERS flag\
    \ set.  This allows a\n   header block to be logically equivalent to a single\
    \ frame.\n   Header block fragments can only be sent as the payload of HEADERS,\n\
    \   PUSH_PROMISE, or CONTINUATION frames because these frames carry data\n   that\
    \ can modify the compression context maintained by a receiver.  An\n   endpoint\
    \ receiving HEADERS, PUSH_PROMISE, or CONTINUATION frames\n   needs to reassemble\
    \ header blocks and perform decompression even if\n   the frames are to be discarded.\
    \  A receiver MUST terminate the\n   connection with a connection error (Section\
    \ 5.4.1) of type\n   COMPRESSION_ERROR if it does not decompress a header block.\n"
- title: 5.  Streams and Multiplexing
  contents:
  - "5.  Streams and Multiplexing\n   A \"stream\" is an independent, bidirectional\
    \ sequence of frames\n   exchanged between the client and server within an HTTP/2\
    \ connection.\n   Streams have several important characteristics:\n   o  A single\
    \ HTTP/2 connection can contain multiple concurrently open\n      streams, with\
    \ either endpoint interleaving frames from multiple\n      streams.\n   o  Streams\
    \ can be established and used unilaterally or shared by\n      either the client\
    \ or server.\n   o  Streams can be closed by either endpoint.\n   o  The order\
    \ in which frames are sent on a stream is significant.\n      Recipients process\
    \ frames in the order they are received.  In\n      particular, the order of HEADERS\
    \ and DATA frames is semantically\n      significant.\n   o  Streams are identified\
    \ by an integer.  Stream identifiers are\n      assigned to streams by the endpoint\
    \ initiating the stream.\n"
- title: 5.1.  Stream States
  contents:
  - "5.1.  Stream States\n   The lifecycle of a stream is shown in Figure 2.\n   \
    \                             +--------+\n                        send PP |  \
    \      | recv PP\n                       ,--------|  idle  |--------.\n      \
    \                /         |        |         \\\n                     v     \
    \     +--------+          v\n              +----------+          |           +----------+\n\
    \              |          |          | send H /  |          |\n       ,------|\
    \ reserved |          | recv H    | reserved |------.\n       |      | (local)\
    \  |          |           | (remote) |      |\n       |      +----------+    \
    \      v           +----------+      |\n       |          |             +--------+\
    \             |          |\n       |          |     recv ES |        | send ES\
    \     |          |\n       |   send H |     ,-------|  open  |-------.     | recv\
    \ H   |\n       |          |    /        |        |        \\    |          |\n\
    \       |          v   v         +--------+         v   v          |\n       |\
    \      +----------+          |           +----------+      |\n       |      |\
    \   half   |          |           |   half   |      |\n       |      |  closed\
    \  |          | send R /  |  closed  |      |\n       |      | (remote) |    \
    \      | recv R    | (local)  |      |\n       |      +----------+          |\
    \           +----------+      |\n       |           |                |       \
    \          |           |\n       |           | send ES /      |       recv ES\
    \ / |           |\n       |           | send R /       v        send R / |   \
    \        |\n       |           | recv R     +--------+   recv R   |          \
    \ |\n       | send R /  `----------->|        |<-----------'  send R / |\n   \
    \    | recv R                 | closed |               recv R   |\n       `----------------------->|\
    \        |<----------------------'\n                                +--------+\n\
    \          send:   endpoint sends this frame\n          recv:   endpoint receives\
    \ this frame\n          H:  HEADERS frame (with implied CONTINUATIONs)\n     \
    \     PP: PUSH_PROMISE frame (with implied CONTINUATIONs)\n          ES: END_STREAM\
    \ flag\n          R:  RST_STREAM frame\n                          Figure 2: Stream\
    \ States\n   Note that this diagram shows stream state transitions and the frames\n\
    \   and flags that affect those transitions only.  In this regard,\n   CONTINUATION\
    \ frames do not result in state transitions; they are\n   effectively part of\
    \ the HEADERS or PUSH_PROMISE that they follow.\n   For the purpose of state transitions,\
    \ the END_STREAM flag is\n   processed as a separate event to the frame that bears\
    \ it; a HEADERS\n   frame with the END_STREAM flag set can cause two state transitions.\n\
    \   Both endpoints have a subjective view of the state of a stream that\n   could\
    \ be different when frames are in transit.  Endpoints do not\n   coordinate the\
    \ creation of streams; they are created unilaterally by\n   either endpoint. \
    \ The negative consequences of a mismatch in states\n   are limited to the \"\
    closed\" state after sending RST_STREAM, where\n   frames might be received for\
    \ some time after closing.\n   Streams have the following states:\n   idle:\n\
    \      All streams start in the \"idle\" state.\n      The following transitions\
    \ are valid from this state:\n      *  Sending or receiving a HEADERS frame causes\
    \ the stream to\n         become \"open\".  The stream identifier is selected\
    \ as described\n         in Section 5.1.1.  The same HEADERS frame can also cause\
    \ a\n         stream to immediately become \"half-closed\".\n      *  Sending\
    \ a PUSH_PROMISE frame on another stream reserves the\n         idle stream that\
    \ is identified for later use.  The stream state\n         for the reserved stream\
    \ transitions to \"reserved (local)\".\n      *  Receiving a PUSH_PROMISE frame\
    \ on another stream reserves an\n         idle stream that is identified for later\
    \ use.  The stream state\n         for the reserved stream transitions to \"reserved\
    \ (remote)\".\n      *  Note that the PUSH_PROMISE frame is not sent on the idle\
    \ stream\n         but references the newly reserved stream in the Promised Stream\n\
    \         ID field.\n      Receiving any frame other than HEADERS or PRIORITY\
    \ on a stream in\n      this state MUST be treated as a connection error (Section\
    \ 5.4.1)\n      of type PROTOCOL_ERROR.\n   reserved (local):\n      A stream\
    \ in the \"reserved (local)\" state is one that has been\n      promised by sending\
    \ a PUSH_PROMISE frame.  A PUSH_PROMISE frame\n      reserves an idle stream by\
    \ associating the stream with an open\n      stream that was initiated by the\
    \ remote peer (see Section 8.2).\n      In this state, only the following transitions\
    \ are possible:\n      *  The endpoint can send a HEADERS frame.  This causes\
    \ the stream\n         to open in a \"half-closed (remote)\" state.\n      * \
    \ Either endpoint can send a RST_STREAM frame to cause the stream\n         to\
    \ become \"closed\".  This releases the stream reservation.\n      An endpoint\
    \ MUST NOT send any type of frame other than HEADERS,\n      RST_STREAM, or PRIORITY\
    \ in this state.\n      A PRIORITY or WINDOW_UPDATE frame MAY be received in this\
    \ state.\n      Receiving any type of frame other than RST_STREAM, PRIORITY, or\n\
    \      WINDOW_UPDATE on a stream in this state MUST be treated as a\n      connection\
    \ error (Section 5.4.1) of type PROTOCOL_ERROR.\n   reserved (remote):\n     \
    \ A stream in the \"reserved (remote)\" state has been reserved by a\n      remote\
    \ peer.\n      In this state, only the following transitions are possible:\n \
    \     *  Receiving a HEADERS frame causes the stream to transition to\n      \
    \   \"half-closed (local)\".\n      *  Either endpoint can send a RST_STREAM frame\
    \ to cause the stream\n         to become \"closed\".  This releases the stream\
    \ reservation.\n      An endpoint MAY send a PRIORITY frame in this state to\n\
    \      reprioritize the reserved stream.  An endpoint MUST NOT send any\n    \
    \  type of frame other than RST_STREAM, WINDOW_UPDATE, or PRIORITY in\n      this\
    \ state.\n      Receiving any type of frame other than HEADERS, RST_STREAM, or\n\
    \      PRIORITY on a stream in this state MUST be treated as a connection\n  \
    \    error (Section 5.4.1) of type PROTOCOL_ERROR.\n   open:\n      A stream in\
    \ the \"open\" state may be used by both peers to send\n      frames of any type.\
    \  In this state, sending peers observe\n      advertised stream-level flow-control\
    \ limits (Section 5.2).\n      From this state, either endpoint can send a frame\
    \ with an\n      END_STREAM flag set, which causes the stream to transition into\n\
    \      one of the \"half-closed\" states.  An endpoint sending an\n      END_STREAM\
    \ flag causes the stream state to become \"half-closed\n      (local)\"; an endpoint\
    \ receiving an END_STREAM flag causes the\n      stream state to become \"half-closed\
    \ (remote)\".\n      Either endpoint can send a RST_STREAM frame from this state,\n\
    \      causing it to transition immediately to \"closed\".\n   half-closed (local):\n\
    \      A stream that is in the \"half-closed (local)\" state cannot be used\n\
    \      for sending frames other than WINDOW_UPDATE, PRIORITY, and\n      RST_STREAM.\n\
    \      A stream transitions from this state to \"closed\" when a frame that\n\
    \      contains an END_STREAM flag is received or when either peer sends\n   \
    \   a RST_STREAM frame.\n      An endpoint can receive any type of frame in this\
    \ state.\n      Providing flow-control credit using WINDOW_UPDATE frames is\n\
    \      necessary to continue receiving flow-controlled frames.  In this\n    \
    \  state, a receiver can ignore WINDOW_UPDATE frames, which might\n      arrive\
    \ for a short period after a frame bearing the END_STREAM\n      flag is sent.\n\
    \      PRIORITY frames received in this state are used to reprioritize\n     \
    \ streams that depend on the identified stream.\n   half-closed (remote):\n  \
    \    A stream that is \"half-closed (remote)\" is no longer being used by\n  \
    \    the peer to send frames.  In this state, an endpoint is no longer\n     \
    \ obligated to maintain a receiver flow-control window.\n      If an endpoint\
    \ receives additional frames, other than\n      WINDOW_UPDATE, PRIORITY, or RST_STREAM,\
    \ for a stream that is in\n      this state, it MUST respond with a stream error\
    \ (Section 5.4.2) of\n      type STREAM_CLOSED.\n      A stream that is \"half-closed\
    \ (remote)\" can be used by the\n      endpoint to send frames of any type.  In\
    \ this state, the endpoint\n      continues to observe advertised stream-level\
    \ flow-control limits\n      (Section 5.2).\n      A stream can transition from\
    \ this state to \"closed\" by sending a\n      frame that contains an END_STREAM\
    \ flag or when either peer sends a\n      RST_STREAM frame.\n   closed:\n    \
    \  The \"closed\" state is the terminal state.\n      An endpoint MUST NOT send\
    \ frames other than PRIORITY on a closed\n      stream.  An endpoint that receives\
    \ any frame other than PRIORITY\n      after receiving a RST_STREAM MUST treat\
    \ that as a stream error\n      (Section 5.4.2) of type STREAM_CLOSED.  Similarly,\
    \ an endpoint\n      that receives any frames after receiving a frame with the\n\
    \      END_STREAM flag set MUST treat that as a connection error\n      (Section\
    \ 5.4.1) of type STREAM_CLOSED, unless the frame is\n      permitted as described\
    \ below.\n      WINDOW_UPDATE or RST_STREAM frames can be received in this state\n\
    \      for a short period after a DATA or HEADERS frame containing an\n      END_STREAM\
    \ flag is sent.  Until the remote peer receives and\n      processes RST_STREAM\
    \ or the frame bearing the END_STREAM flag, it\n      might send frames of these\
    \ types.  Endpoints MUST ignore\n      WINDOW_UPDATE or RST_STREAM frames received\
    \ in this state, though\n      endpoints MAY choose to treat frames that arrive\
    \ a significant\n      time after sending END_STREAM as a connection error\n \
    \     (Section 5.4.1) of type PROTOCOL_ERROR.\n      PRIORITY frames can be sent\
    \ on closed streams to prioritize\n      streams that are dependent on the closed\
    \ stream.  Endpoints SHOULD\n      process PRIORITY frames, though they can be\
    \ ignored if the stream\n      has been removed from the dependency tree (see\
    \ Section 5.3.4).\n      If this state is reached as a result of sending a RST_STREAM\n\
    \      frame, the peer that receives the RST_STREAM might have already\n     \
    \ sent -- or enqueued for sending -- frames on the stream that\n      cannot be\
    \ withdrawn.  An endpoint MUST ignore frames that it\n      receives on closed\
    \ streams after it has sent a RST_STREAM frame.\n      An endpoint MAY choose\
    \ to limit the period over which it ignores\n      frames and treat frames that\
    \ arrive after this time as being in\n      error.\n      Flow-controlled frames\
    \ (i.e., DATA) received after sending\n      RST_STREAM are counted toward the\
    \ connection flow-control window.\n      Even though these frames might be ignored,\
    \ because they are sent\n      before the sender receives the RST_STREAM, the\
    \ sender will\n      consider the frames to count against the flow-control window.\n\
    \      An endpoint might receive a PUSH_PROMISE frame after it sends\n      RST_STREAM.\
    \  PUSH_PROMISE causes a stream to become \"reserved\"\n      even if the associated\
    \ stream has been reset.  Therefore, a\n      RST_STREAM is needed to close an\
    \ unwanted promised stream.\n   In the absence of more specific guidance elsewhere\
    \ in this document,\n   implementations SHOULD treat the receipt of a frame that\
    \ is not\n   expressly permitted in the description of a state as a connection\n\
    \   error (Section 5.4.1) of type PROTOCOL_ERROR.  Note that PRIORITY can\n  \
    \ be sent and received in any stream state.  Frames of unknown types\n   are ignored.\n\
    \   An example of the state transitions for an HTTP request/response\n   exchange\
    \ can be found in Section 8.1.  An example of the state\n   transitions for server\
    \ push can be found in Sections 8.2.1 and 8.2.2.\n"
- title: 5.1.1.  Stream Identifiers
  contents:
  - "5.1.1.  Stream Identifiers\n   Streams are identified with an unsigned 31-bit\
    \ integer.  Streams\n   initiated by a client MUST use odd-numbered stream identifiers;\
    \ those\n   initiated by the server MUST use even-numbered stream identifiers.\
    \  A\n   stream identifier of zero (0x0) is used for connection control\n   messages;\
    \ the stream identifier of zero cannot be used to establish a\n   new stream.\n\
    \   HTTP/1.1 requests that are upgraded to HTTP/2 (see Section 3.2) are\n   responded\
    \ to with a stream identifier of one (0x1).  After the\n   upgrade completes,\
    \ stream 0x1 is \"half-closed (local)\" to the client.\n   Therefore, stream 0x1\
    \ cannot be selected as a new stream identifier\n   by a client that upgrades\
    \ from HTTP/1.1.\n   The identifier of a newly established stream MUST be numerically\n\
    \   greater than all streams that the initiating endpoint has opened or\n   reserved.\
    \  This governs streams that are opened using a HEADERS frame\n   and streams\
    \ that are reserved using PUSH_PROMISE.  An endpoint that\n   receives an unexpected\
    \ stream identifier MUST respond with a\n   connection error (Section 5.4.1) of\
    \ type PROTOCOL_ERROR.\n   The first use of a new stream identifier implicitly\
    \ closes all\n   streams in the \"idle\" state that might have been initiated\
    \ by that\n   peer with a lower-valued stream identifier.  For example, if a client\n\
    \   sends a HEADERS frame on stream 7 without ever sending a frame on\n   stream\
    \ 5, then stream 5 transitions to the \"closed\" state when the\n   first frame\
    \ for stream 7 is sent or received.\n   Stream identifiers cannot be reused. \
    \ Long-lived connections can\n   result in an endpoint exhausting the available\
    \ range of stream\n   identifiers.  A client that is unable to establish a new\
    \ stream\n   identifier can establish a new connection for new streams.  A server\n\
    \   that is unable to establish a new stream identifier can send a GOAWAY\n  \
    \ frame so that the client is forced to open a new connection for new\n   streams.\n"
- title: 5.1.2.  Stream Concurrency
  contents:
  - "5.1.2.  Stream Concurrency\n   A peer can limit the number of concurrently active\
    \ streams using the\n   SETTINGS_MAX_CONCURRENT_STREAMS parameter (see Section\
    \ 6.5.2) within\n   a SETTINGS frame.  The maximum concurrent streams setting\
    \ is specific\n   to each endpoint and applies only to the peer that receives\
    \ the\n   setting.  That is, clients specify the maximum number of concurrent\n\
    \   streams the server can initiate, and servers specify the maximum\n   number\
    \ of concurrent streams the client can initiate.\n   Streams that are in the \"\
    open\" state or in either of the \"half-\n   closed\" states count toward the\
    \ maximum number of streams that an\n   endpoint is permitted to open.  Streams\
    \ in any of these three states\n   count toward the limit advertised in the\n\
    \   SETTINGS_MAX_CONCURRENT_STREAMS setting.  Streams in either of the\n   \"\
    reserved\" states do not count toward the stream limit.\n   Endpoints MUST NOT\
    \ exceed the limit set by their peer.  An endpoint\n   that receives a HEADERS\
    \ frame that causes its advertised concurrent\n   stream limit to be exceeded\
    \ MUST treat this as a stream error\n   (Section 5.4.2) of type PROTOCOL_ERROR\
    \ or REFUSED_STREAM.  The choice\n   of error code determines whether the endpoint\
    \ wishes to enable\n   automatic retry (see Section 8.1.4) for details).\n   An\
    \ endpoint that wishes to reduce the value of\n   SETTINGS_MAX_CONCURRENT_STREAMS\
    \ to a value that is below the current\n   number of open streams can either close\
    \ streams that exceed the new\n   value or allow streams to complete.\n"
- title: 5.2.  Flow Control
  contents:
  - "5.2.  Flow Control\n   Using streams for multiplexing introduces contention over\
    \ use of the\n   TCP connection, resulting in blocked streams.  A flow-control\
    \ scheme\n   ensures that streams on the same connection do not destructively\n\
    \   interfere with each other.  Flow control is used for both individual\n   streams\
    \ and for the connection as a whole.\n   HTTP/2 provides for flow control through\
    \ use of the WINDOW_UPDATE\n   frame (Section 6.9).\n"
- title: 5.2.1.  Flow-Control Principles
  contents:
  - "5.2.1.  Flow-Control Principles\n   HTTP/2 stream flow control aims to allow\
    \ a variety of flow-control\n   algorithms to be used without requiring protocol\
    \ changes.  Flow\n   control in HTTP/2 has the following characteristics:\n  \
    \ 1.  Flow control is specific to a connection.  Both types of flow\n       control\
    \ are between the endpoints of a single hop and not over\n       the entire end-to-end\
    \ path.\n   2.  Flow control is based on WINDOW_UPDATE frames.  Receivers\n  \
    \     advertise how many octets they are prepared to receive on a\n       stream\
    \ and for the entire connection.  This is a credit-based\n       scheme.\n   3.\
    \  Flow control is directional with overall control provided by the\n       receiver.\
    \  A receiver MAY choose to set any window size that it\n       desires for each\
    \ stream and for the entire connection.  A sender\n       MUST respect flow-control\
    \ limits imposed by a receiver.  Clients,\n       servers, and intermediaries\
    \ all independently advertise their\n       flow-control window as a receiver\
    \ and abide by the flow-control\n       limits set by their peer when sending.\n\
    \   4.  The initial value for the flow-control window is 65,535 octets\n     \
    \  for both new streams and the overall connection.\n   5.  The frame type determines\
    \ whether flow control applies to a\n       frame.  Of the frames specified in\
    \ this document, only DATA\n       frames are subject to flow control; all other\
    \ frame types do not\n       consume space in the advertised flow-control window.\
    \  This\n       ensures that important control frames are not blocked by flow\n\
    \       control.\n   6.  Flow control cannot be disabled.\n   7.  HTTP/2 defines\
    \ only the format and semantics of the WINDOW_UPDATE\n       frame (Section 6.9).\
    \  This document does not stipulate how a\n       receiver decides when to send\
    \ this frame or the value that it\n       sends, nor does it specify how a sender\
    \ chooses to send packets.\n       Implementations are able to select any algorithm\
    \ that suits their\n       needs.\n   Implementations are also responsible for\
    \ managing how requests and\n   responses are sent based on priority, choosing\
    \ how to avoid head-of-\n   line blocking for requests, and managing the creation\
    \ of new streams.\n   Algorithm choices for these could interact with any flow-control\n\
    \   algorithm.\n"
- title: 5.2.2.  Appropriate Use of Flow Control
  contents:
  - "5.2.2.  Appropriate Use of Flow Control\n   Flow control is defined to protect\
    \ endpoints that are operating under\n   resource constraints.  For example, a\
    \ proxy needs to share memory\n   between many connections and also might have\
    \ a slow upstream\n   connection and a fast downstream one.  Flow-control addresses\
    \ cases\n   where the receiver is unable to process data on one stream yet wants\n\
    \   to continue to process other streams in the same connection.\n   Deployments\
    \ that do not require this capability can advertise a flow-\n   control window\
    \ of the maximum size (2^31-1) and can maintain this\n   window by sending a WINDOW_UPDATE\
    \ frame when any data is received.\n   This effectively disables flow control\
    \ for that receiver.\n   Conversely, a sender is always subject to the flow-control\
    \ window\n   advertised by the receiver.\n   Deployments with constrained resources\
    \ (for example, memory) can\n   employ flow control to limit the amount of memory\
    \ a peer can consume.\n   Note, however, that this can lead to suboptimal use\
    \ of available\n   network resources if flow control is enabled without knowledge\
    \ of the\n   bandwidth-delay product (see [RFC7323]).\n   Even with full awareness\
    \ of the current bandwidth-delay product,\n   implementation of flow control can\
    \ be difficult.  When using flow\n   control, the receiver MUST read from the\
    \ TCP receive buffer in a\n   timely fashion.  Failure to do so could lead to\
    \ a deadlock when\n   critical frames, such as WINDOW_UPDATE, are not read and\
    \ acted upon.\n"
- title: 5.3.  Stream Priority
  contents:
  - "5.3.  Stream Priority\n   A client can assign a priority for a new stream by\
    \ including\n   prioritization information in the HEADERS frame (Section 6.2)\
    \ that\n   opens the stream.  At any other time, the PRIORITY frame\n   (Section\
    \ 6.3) can be used to change the priority of a stream.\n   The purpose of prioritization\
    \ is to allow an endpoint to express how\n   it would prefer its peer to allocate\
    \ resources when managing\n   concurrent streams.  Most importantly, priority\
    \ can be used to select\n   streams for transmitting frames when there is limited\
    \ capacity for\n   sending.\n   Streams can be prioritized by marking them as\
    \ dependent on the\n   completion of other streams (Section 5.3.1).  Each dependency\
    \ is\n   assigned a relative weight, a number that is used to determine the\n\
    \   relative proportion of available resources that are assigned to\n   streams\
    \ dependent on the same stream.\n   Explicitly setting the priority for a stream\
    \ is input to a\n   prioritization process.  It does not guarantee any particular\n\
    \   processing or transmission order for the stream relative to any other\n  \
    \ stream.  An endpoint cannot force a peer to process concurrent\n   streams in\
    \ a particular order using priority.  Expressing priority is\n   therefore only\
    \ a suggestion.\n   Prioritization information can be omitted from messages. \
    \ Defaults\n   are used prior to any explicit values being provided (Section 5.3.5).\n"
- title: 5.3.1.  Stream Dependencies
  contents:
  - "5.3.1.  Stream Dependencies\n   Each stream can be given an explicit dependency\
    \ on another stream.\n   Including a dependency expresses a preference to allocate\
    \ resources\n   to the identified stream rather than to the dependent stream.\n\
    \   A stream that is not dependent on any other stream is given a stream\n   dependency\
    \ of 0x0.  In other words, the non-existent stream 0 forms\n   the root of the\
    \ tree.\n   A stream that depends on another stream is a dependent stream.  The\n\
    \   stream upon which a stream is dependent is a parent stream.  A\n   dependency\
    \ on a stream that is not currently in the tree -- such as a\n   stream in the\
    \ \"idle\" state -- results in that stream being given a\n   default priority\
    \ (Section 5.3.5).\n   When assigning a dependency on another stream, the stream\
    \ is added as\n   a new dependency of the parent stream.  Dependent streams that\
    \ share\n   the same parent are not ordered with respect to each other.  For\n\
    \   example, if streams B and C are dependent on stream A, and if stream\n   D\
    \ is created with a dependency on stream A, this results in a\n   dependency order\
    \ of A followed by B, C, and D in any order.\n       A                 A\n   \
    \   / \\      ==>      /|\\\n     B   C             B D C\n             Figure\
    \ 3: Example of Default Dependency Creation\n   An exclusive flag allows for the\
    \ insertion of a new level of\n   dependencies.  The exclusive flag causes the\
    \ stream to become the\n   sole dependency of its parent stream, causing other\
    \ dependencies to\n   become dependent on the exclusive stream.  In the previous\
    \ example,\n   if stream D is created with an exclusive dependency on stream A,\
    \ this\n   results in D becoming the dependency parent of B and C.\n         \
    \                A\n       A                 |\n      / \\      ==>       D\n\
    \     B   C              / \\\n                       B   C\n            Figure\
    \ 4: Example of Exclusive Dependency Creation\n   Inside the dependency tree,\
    \ a dependent stream SHOULD only be\n   allocated resources if either all of the\
    \ streams that it depends on\n   (the chain of parent streams up to 0x0) are closed\
    \ or it is not\n   possible to make progress on them.\n   A stream cannot depend\
    \ on itself.  An endpoint MUST treat this as a\n   stream error (Section 5.4.2)\
    \ of type PROTOCOL_ERROR.\n"
- title: 5.3.2.  Dependency Weighting
  contents:
  - "5.3.2.  Dependency Weighting\n   All dependent streams are allocated an integer\
    \ weight between 1 and\n   256 (inclusive).\n   Streams with the same parent SHOULD\
    \ be allocated resources\n   proportionally based on their weight.  Thus, if stream\
    \ B depends on\n   stream A with weight 4, stream C depends on stream A with weight\
    \ 12,\n   and no progress can be made on stream A, stream B ideally receives\n\
    \   one-third of the resources allocated to stream C.\n"
- title: 5.3.3.  Reprioritization
  contents:
  - "5.3.3.  Reprioritization\n   Stream priorities are changed using the PRIORITY\
    \ frame.  Setting a\n   dependency causes a stream to become dependent on the\
    \ identified\n   parent stream.\n   Dependent streams move with their parent stream\
    \ if the parent is\n   reprioritized.  Setting a dependency with the exclusive\
    \ flag for a\n   reprioritized stream causes all the dependencies of the new parent\n\
    \   stream to become dependent on the reprioritized stream.\n   If a stream is\
    \ made dependent on one of its own dependencies, the\n   formerly dependent stream\
    \ is first moved to be dependent on the\n   reprioritized stream's previous parent.\
    \  The moved dependency retains\n   its weight.\n   For example, consider an original\
    \ dependency tree where B and C\n   depend on A, D and E depend on C, and F depends\
    \ on D.  If A is made\n   dependent on D, then D takes the place of A.  All other\
    \ dependency\n   relationships stay the same, except for F, which becomes dependent\
    \ on\n   A if the reprioritization is exclusive.\n       x                x  \
    \              x                 x\n       |               / \\              \
    \ |                 |\n       A              D   A              D            \
    \     D\n      / \\            /   / \\            / \\                |\n   \
    \  B   C     ==>  F   B   C   ==>    F   A       OR      A\n        / \\     \
    \            |             / \\             /|\\\n       D   E               \
    \ E            B   C           B C F\n       |                               \
    \      |             |\n       F                                     E       \
    \      E\n                  (intermediate)   (non-exclusive)    (exclusive)\n\
    \                Figure 5: Example of Dependency Reordering\n"
- title: 5.3.4.  Prioritization State Management
  contents:
  - "5.3.4.  Prioritization State Management\n   When a stream is removed from the\
    \ dependency tree, its dependencies\n   can be moved to become dependent on the\
    \ parent of the closed stream.\n   The weights of new dependencies are recalculated\
    \ by distributing the\n   weight of the dependency of the closed stream proportionally\
    \ based on\n   the weights of its dependencies.\n   Streams that are removed from\
    \ the dependency tree cause some\n   prioritization information to be lost.  Resources\
    \ are shared between\n   streams with the same parent stream, which means that\
    \ if a stream in\n   that set closes or becomes blocked, any spare capacity allocated\
    \ to a\n   stream is distributed to the immediate neighbors of the stream.\n \
    \  However, if the common dependency is removed from the tree, those\n   streams\
    \ share resources with streams at the next highest level.\n   For example, assume\
    \ streams A and B share a parent, and streams C and\n   D both depend on stream\
    \ A.  Prior to the removal of stream A, if\n   streams A and D are unable to proceed,\
    \ then stream C receives all the\n   resources dedicated to stream A.  If stream\
    \ A is removed from the\n   tree, the weight of stream A is divided between streams\
    \ C and D.  If\n   stream D is still unable to proceed, this results in stream\
    \ C\n   receiving a reduced proportion of resources.  For equal starting\n   weights,\
    \ C receives one third, rather than one half, of available\n   resources.\n  \
    \ It is possible for a stream to become closed while prioritization\n   information\
    \ that creates a dependency on that stream is in transit.\n   If a stream identified\
    \ in a dependency has no associated priority\n   information, then the dependent\
    \ stream is instead assigned a default\n   priority (Section 5.3.5).  This potentially\
    \ creates suboptimal\n   prioritization, since the stream could be given a priority\
    \ that is\n   different from what is intended.\n   To avoid these problems, an\
    \ endpoint SHOULD retain stream\n   prioritization state for a period after streams\
    \ become closed.  The\n   longer state is retained, the lower the chance that\
    \ streams are\n   assigned incorrect or default priority values.\n   Similarly,\
    \ streams that are in the \"idle\" state can be assigned\n   priority or become\
    \ a parent of other streams.  This allows for the\n   creation of a grouping node\
    \ in the dependency tree, which enables\n   more flexible expressions of priority.\
    \  Idle streams begin with a\n   default priority (Section 5.3.5).\n   The retention\
    \ of priority information for streams that are not\n   counted toward the limit\
    \ set by SETTINGS_MAX_CONCURRENT_STREAMS could\n   create a large state burden\
    \ for an endpoint.  Therefore, the amount\n   of prioritization state that is\
    \ retained MAY be limited.\n   The amount of additional state an endpoint maintains\
    \ for\n   prioritization could be dependent on load; under high load,\n   prioritization\
    \ state can be discarded to limit resource commitments.\n   In extreme cases,\
    \ an endpoint could even discard prioritization state\n   for active or reserved\
    \ streams.  If a limit is applied, endpoints\n   SHOULD maintain state for at\
    \ least as many streams as allowed by\n   their setting for SETTINGS_MAX_CONCURRENT_STREAMS.\
    \  Implementations\n   SHOULD also attempt to retain state for streams that are\
    \ in active\n   use in the priority tree.\n   If it has retained enough state\
    \ to do so, an endpoint receiving a\n   PRIORITY frame that changes the priority\
    \ of a closed stream SHOULD\n   alter the dependencies of the streams that depend\
    \ on it.\n"
- title: 5.3.5.  Default Priorities
  contents:
  - "5.3.5.  Default Priorities\n   All streams are initially assigned a non-exclusive\
    \ dependency on\n   stream 0x0.  Pushed streams (Section 8.2) initially depend\
    \ on their\n   associated stream.  In both cases, streams are assigned a default\n\
    \   weight of 16.\n"
- title: 5.4.  Error Handling
  contents:
  - "5.4.  Error Handling\n   HTTP/2 framing permits two classes of error:\n   o \
    \ An error condition that renders the entire connection unusable is\n      a connection\
    \ error.\n   o  An error in an individual stream is a stream error.\n   A list\
    \ of error codes is included in Section 7.\n"
- title: 5.4.1.  Connection Error Handling
  contents:
  - "5.4.1.  Connection Error Handling\n   A connection error is any error that prevents\
    \ further processing of\n   the frame layer or corrupts any connection state.\n\
    \   An endpoint that encounters a connection error SHOULD first send a\n   GOAWAY\
    \ frame (Section 6.8) with the stream identifier of the last\n   stream that it\
    \ successfully received from its peer.  The GOAWAY frame\n   includes an error\
    \ code that indicates why the connection is\n   terminating.  After sending the\
    \ GOAWAY frame for an error condition,\n   the endpoint MUST close the TCP connection.\n\
    \   It is possible that the GOAWAY will not be reliably received by the\n   receiving\
    \ endpoint ([RFC7230], Section 6.6 describes how an immediate\n   connection close\
    \ can result in data loss).  In the event of a\n   connection error, GOAWAY only\
    \ provides a best-effort attempt to\n   communicate with the peer about why the\
    \ connection is being\n   terminated.\n   An endpoint can end a connection at\
    \ any time.  In particular, an\n   endpoint MAY choose to treat a stream error\
    \ as a connection error.\n   Endpoints SHOULD send a GOAWAY frame when ending\
    \ a connection,\n   providing that circumstances permit it.\n"
- title: 5.4.2.  Stream Error Handling
  contents:
  - "5.4.2.  Stream Error Handling\n   A stream error is an error related to a specific\
    \ stream that does not\n   affect processing of other streams.\n   An endpoint\
    \ that detects a stream error sends a RST_STREAM frame\n   (Section 6.4) that\
    \ contains the stream identifier of the stream where\n   the error occurred. \
    \ The RST_STREAM frame includes an error code that\n   indicates the type of error.\n\
    \   A RST_STREAM is the last frame that an endpoint can send on a stream.\n  \
    \ The peer that sends the RST_STREAM frame MUST be prepared to receive\n   any\
    \ frames that were sent or enqueued for sending by the remote peer.\n   These\
    \ frames can be ignored, except where they modify connection\n   state (such as\
    \ the state maintained for header compression\n   (Section 4.3) or flow control).\n\
    \   Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame\n   for\
    \ any stream.  However, an endpoint MAY send additional RST_STREAM\n   frames\
    \ if it receives frames on a closed stream after more than a\n   round-trip time.\
    \  This behavior is permitted to deal with misbehaving\n   implementations.\n\
    \   To avoid looping, an endpoint MUST NOT send a RST_STREAM in response\n   to\
    \ a RST_STREAM frame.\n"
- title: 5.4.3.  Connection Termination
  contents:
  - "5.4.3.  Connection Termination\n   If the TCP connection is closed or reset while\
    \ streams remain in\n   \"open\" or \"half-closed\" state, then the affected streams\
    \ cannot be\n   automatically retried (see Section 8.1.4 for details).\n"
- title: 5.5.  Extending HTTP/2
  contents:
  - "5.5.  Extending HTTP/2\n   HTTP/2 permits extension of the protocol.  Within\
    \ the limitations\n   described in this section, protocol extensions can be used\
    \ to provide\n   additional services or alter any aspect of the protocol.  Extensions\n\
    \   are effective only within the scope of a single HTTP/2 connection.\n   This\
    \ applies to the protocol elements defined in this document.  This\n   does not\
    \ affect the existing options for extending HTTP, such as\n   defining new methods,\
    \ status codes, or header fields.\n   Extensions are permitted to use new frame\
    \ types (Section 4.1), new\n   settings (Section 6.5.2), or new error codes (Section\
    \ 7).  Registries\n   are established for managing these extension points: frame\
    \ types\n   (Section 11.2), settings (Section 11.3), and error codes\n   (Section\
    \ 11.4).\n   Implementations MUST ignore unknown or unsupported values in all\n\
    \   extensible protocol elements.  Implementations MUST discard frames\n   that\
    \ have unknown or unsupported types.  This means that any of these\n   extension\
    \ points can be safely used by extensions without prior\n   arrangement or negotiation.\
    \  However, extension frames that appear in\n   the middle of a header block (Section\
    \ 4.3) are not permitted; these\n   MUST be treated as a connection error (Section\
    \ 5.4.1) of type\n   PROTOCOL_ERROR.\n   Extensions that could change the semantics\
    \ of existing protocol\n   components MUST be negotiated before being used.  For\
    \ example, an\n   extension that changes the layout of the HEADERS frame cannot\
    \ be used\n   until the peer has given a positive signal that this is acceptable.\n\
    \   In this case, it could also be necessary to coordinate when the\n   revised\
    \ layout comes into effect.  Note that treating any frames\n   other than DATA\
    \ frames as flow controlled is such a change in\n   semantics and can only be\
    \ done through negotiation.\n   This document doesn't mandate a specific method\
    \ for negotiating the\n   use of an extension but notes that a setting (Section\
    \ 6.5.2) could be\n   used for that purpose.  If both peers set a value that indicates\n\
    \   willingness to use the extension, then the extension can be used.  If\n  \
    \ a setting is used for extension negotiation, the initial value MUST\n   be defined\
    \ in such a fashion that the extension is initially\n   disabled.\n"
- title: 6.  Frame Definitions
  contents:
  - "6.  Frame Definitions\n   This specification defines a number of frame types,\
    \ each identified\n   by a unique 8-bit type code.  Each frame type serves a distinct\n\
    \   purpose in the establishment and management either of the connection\n   as\
    \ a whole or of individual streams.\n   The transmission of specific frame types\
    \ can alter the state of a\n   connection.  If endpoints fail to maintain a synchronized\
    \ view of the\n   connection state, successful communication within the connection\
    \ will\n   no longer be possible.  Therefore, it is important that endpoints\n\
    \   have a shared comprehension of how the state is affected by the use\n   any\
    \ given frame.\n"
- title: 6.1.  DATA
  contents:
  - "6.1.  DATA\n   DATA frames (type=0x0) convey arbitrary, variable-length sequences\
    \ of\n   octets associated with a stream.  One or more DATA frames are used,\n\
    \   for instance, to carry HTTP request or response payloads.\n   DATA frames\
    \ MAY also contain padding.  Padding can be added to DATA\n   frames to obscure\
    \ the size of messages.  Padding is a security\n   feature; see Section 10.7.\n\
    \    +---------------+\n    |Pad Length? (8)|\n    +---------------+-----------------------------------------------+\n\
    \    |                            Data (*)                         ...\n    +---------------------------------------------------------------+\n\
    \    |                           Padding (*)                       ...\n    +---------------------------------------------------------------+\n\
    \                       Figure 6: DATA Frame Payload\n   The DATA frame contains\
    \ the following fields:\n   Pad Length:  An 8-bit field containing the length\
    \ of the frame\n      padding in units of octets.  This field is conditional (as\n\
    \      signified by a \"?\" in the diagram) and is only present if the\n     \
    \ PADDED flag is set.\n   Data:  Application data.  The amount of data is the\
    \ remainder of the\n      frame payload after subtracting the length of the other\
    \ fields\n      that are present.\n   Padding:  Padding octets that contain no\
    \ application semantic value.\n      Padding octets MUST be set to zero when sending.\
    \  A receiver is\n      not obligated to verify padding but MAY treat non-zero\
    \ padding as\n      a connection error (Section 5.4.1) of type PROTOCOL_ERROR.\n\
    \   The DATA frame defines the following flags:\n   END_STREAM (0x1):  When set,\
    \ bit 0 indicates that this frame is the\n      last that the endpoint will send\
    \ for the identified stream.\n      Setting this flag causes the stream to enter\
    \ one of the \"half-\n      closed\" states or the \"closed\" state (Section 5.1).\n\
    \   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field\n     \
    \ and any padding that it describes are present.\n   DATA frames MUST be associated\
    \ with a stream.  If a DATA frame is\n   received whose stream identifier field\
    \ is 0x0, the recipient MUST\n   respond with a connection error (Section 5.4.1)\
    \ of type\n   PROTOCOL_ERROR.\n   DATA frames are subject to flow control and\
    \ can only be sent when a\n   stream is in the \"open\" or \"half-closed (remote)\"\
    \ state.  The entire\n   DATA frame payload is included in flow control, including\
    \ the Pad\n   Length and Padding fields if present.  If a DATA frame is received\n\
    \   whose stream is not in \"open\" or \"half-closed (local)\" state, the\n  \
    \ recipient MUST respond with a stream error (Section 5.4.2) of type\n   STREAM_CLOSED.\n\
    \   The total number of padding octets is determined by the value of the\n   Pad\
    \ Length field.  If the length of the padding is the length of the\n   frame payload\
    \ or greater, the recipient MUST treat this as a\n   connection error (Section\
    \ 5.4.1) of type PROTOCOL_ERROR.\n      Note: A frame can be increased in size\
    \ by one octet by including a\n      Pad Length field with a value of zero.\n"
- title: 6.2.  HEADERS
  contents:
  - "6.2.  HEADERS\n   The HEADERS frame (type=0x1) is used to open a stream (Section\
    \ 5.1),\n   and additionally carries a header block fragment.  HEADERS frames\
    \ can\n   be sent on a stream in the \"idle\", \"reserved (local)\", \"open\"\
    , or\n   \"half-closed (remote)\" state.\n    +---------------+\n    |Pad Length?\
    \ (8)|\n    +-+-------------+-----------------------------------------------+\n\
    \    |E|                 Stream Dependency? (31)                     |\n    +-+-------------+-----------------------------------------------+\n\
    \    |  Weight? (8)  |\n    +-+-------------+-----------------------------------------------+\n\
    \    |                   Header Block Fragment (*)                 ...\n    +---------------------------------------------------------------+\n\
    \    |                           Padding (*)                       ...\n    +---------------------------------------------------------------+\n\
    \                      Figure 7: HEADERS Frame Payload\n   The HEADERS frame payload\
    \ has the following fields:\n   Pad Length:  An 8-bit field containing the length\
    \ of the frame\n      padding in units of octets.  This field is only present\
    \ if the\n      PADDED flag is set.\n   E: A single-bit flag indicating that the\
    \ stream dependency is\n      exclusive (see Section 5.3).  This field is only\
    \ present if the\n      PRIORITY flag is set.\n   Stream Dependency:  A 31-bit\
    \ stream identifier for the stream that\n      this stream depends on (see Section\
    \ 5.3).  This field is only\n      present if the PRIORITY flag is set.\n   Weight:\
    \  An unsigned 8-bit integer representing a priority weight for\n      the stream\
    \ (see Section 5.3).  Add one to the value to obtain a\n      weight between 1\
    \ and 256.  This field is only present if the\n      PRIORITY flag is set.\n \
    \  Header Block Fragment:  A header block fragment (Section 4.3).\n   Padding:\
    \  Padding octets.\n   The HEADERS frame defines the following flags:\n   END_STREAM\
    \ (0x1):  When set, bit 0 indicates that the header block\n      (Section 4.3)\
    \ is the last that the endpoint will send for the\n      identified stream.\n\
    \      A HEADERS frame carries the END_STREAM flag that signals the end\n    \
    \  of a stream.  However, a HEADERS frame with the END_STREAM flag\n      set\
    \ can be followed by CONTINUATION frames on the same stream.\n      Logically,\
    \ the CONTINUATION frames are part of the HEADERS frame.\n   END_HEADERS (0x4):\
    \  When set, bit 2 indicates that this frame\n      contains an entire header\
    \ block (Section 4.3) and is not followed\n      by any CONTINUATION frames.\n\
    \      A HEADERS frame without the END_HEADERS flag set MUST be followed\n   \
    \   by a CONTINUATION frame for the same stream.  A receiver MUST\n      treat\
    \ the receipt of any other type of frame or a frame on a\n      different stream\
    \ as a connection error (Section 5.4.1) of type\n      PROTOCOL_ERROR.\n   PADDED\
    \ (0x8):  When set, bit 3 indicates that the Pad Length field\n      and any padding\
    \ that it describes are present.\n   PRIORITY (0x20):  When set, bit 5 indicates\
    \ that the Exclusive Flag\n      (E), Stream Dependency, and Weight fields are\
    \ present; see\n      Section 5.3.\n   The payload of a HEADERS frame contains\
    \ a header block fragment\n   (Section 4.3).  A header block that does not fit\
    \ within a HEADERS\n   frame is continued in a CONTINUATION frame (Section 6.10).\n\
    \   HEADERS frames MUST be associated with a stream.  If a HEADERS frame\n   is\
    \ received whose stream identifier field is 0x0, the recipient MUST\n   respond\
    \ with a connection error (Section 5.4.1) of type\n   PROTOCOL_ERROR.\n   The\
    \ HEADERS frame changes the connection state as described in\n   Section 4.3.\n\
    \   The HEADERS frame can include padding.  Padding fields and flags are\n   identical\
    \ to those defined for DATA frames (Section 6.1).  Padding\n   that exceeds the\
    \ size remaining for the header block fragment MUST be\n   treated as a PROTOCOL_ERROR.\n\
    \   Prioritization information in a HEADERS frame is logically equivalent\n  \
    \ to a separate PRIORITY frame, but inclusion in HEADERS avoids the\n   potential\
    \ for churn in stream prioritization when new streams are\n   created.  Prioritization\
    \ fields in HEADERS frames subsequent to the\n   first on a stream reprioritize\
    \ the stream (Section 5.3.3).\n"
- title: 6.3.  PRIORITY
  contents:
  - "6.3.  PRIORITY\n   The PRIORITY frame (type=0x2) specifies the sender-advised\
    \ priority\n   of a stream (Section 5.3).  It can be sent in any stream state,\n\
    \   including idle or closed streams.\n    +-+-------------------------------------------------------------+\n\
    \    |E|                  Stream Dependency (31)                     |\n    +-+-------------+-----------------------------------------------+\n\
    \    |   Weight (8)  |\n    +-+-------------+\n                     Figure 8:\
    \ PRIORITY Frame Payload\n   The payload of a PRIORITY frame contains the following\
    \ fields:\n   E: A single-bit flag indicating that the stream dependency is\n\
    \      exclusive (see Section 5.3).\n   Stream Dependency:  A 31-bit stream identifier\
    \ for the stream that\n      this stream depends on (see Section 5.3).\n   Weight:\
    \  An unsigned 8-bit integer representing a priority weight for\n      the stream\
    \ (see Section 5.3).  Add one to the value to obtain a\n      weight between 1\
    \ and 256.\n   The PRIORITY frame does not define any flags.\n   The PRIORITY\
    \ frame always identifies a stream.  If a PRIORITY frame\n   is received with\
    \ a stream identifier of 0x0, the recipient MUST\n   respond with a connection\
    \ error (Section 5.4.1) of type\n   PROTOCOL_ERROR.\n   The PRIORITY frame can\
    \ be sent on a stream in any state, though it\n   cannot be sent between consecutive\
    \ frames that comprise a single\n   header block (Section 4.3).  Note that this\
    \ frame could arrive after\n   processing or frame sending has completed, which\
    \ would cause it to\n   have no effect on the identified stream.  For a stream\
    \ that is in the\n   \"half-closed (remote)\" or \"closed\" state, this frame\
    \ can only affect\n   processing of the identified stream and its dependent streams;\
    \ it\n   does not affect frame transmission on that stream.\n   The PRIORITY frame\
    \ can be sent for a stream in the \"idle\" or \"closed\"\n   state.  This allows\
    \ for the reprioritization of a group of dependent\n   streams by altering the\
    \ priority of an unused or closed parent\n   stream.\n   A PRIORITY frame with\
    \ a length other than 5 octets MUST be treated as\n   a stream error (Section\
    \ 5.4.2) of type FRAME_SIZE_ERROR.\n"
- title: 6.4.  RST_STREAM
  contents:
  - "6.4.  RST_STREAM\n   The RST_STREAM frame (type=0x3) allows for immediate termination\
    \ of a\n   stream.  RST_STREAM is sent to request cancellation of a stream or\
    \ to\n   indicate that an error condition has occurred.\n    +---------------------------------------------------------------+\n\
    \    |                        Error Code (32)                        |\n    +---------------------------------------------------------------+\n\
    \                    Figure 9: RST_STREAM Frame Payload\n   The RST_STREAM frame\
    \ contains a single unsigned, 32-bit integer\n   identifying the error code (Section\
    \ 7).  The error code indicates why\n   the stream is being terminated.\n   The\
    \ RST_STREAM frame does not define any flags.\n   The RST_STREAM frame fully terminates\
    \ the referenced stream and\n   causes it to enter the \"closed\" state.  After\
    \ receiving a RST_STREAM\n   on a stream, the receiver MUST NOT send additional\
    \ frames for that\n   stream, with the exception of PRIORITY.  However, after\
    \ sending the\n   RST_STREAM, the sending endpoint MUST be prepared to receive\
    \ and\n   process additional frames sent on the stream that might have been\n\
    \   sent by the peer prior to the arrival of the RST_STREAM.\n   RST_STREAM frames\
    \ MUST be associated with a stream.  If a RST_STREAM\n   frame is received with\
    \ a stream identifier of 0x0, the recipient MUST\n   treat this as a connection\
    \ error (Section 5.4.1) of type\n   PROTOCOL_ERROR.\n   RST_STREAM frames MUST\
    \ NOT be sent for a stream in the \"idle\" state.\n   If a RST_STREAM frame identifying\
    \ an idle stream is received, the\n   recipient MUST treat this as a connection\
    \ error (Section 5.4.1) of\n   type PROTOCOL_ERROR.\n   A RST_STREAM frame with\
    \ a length other than 4 octets MUST be treated\n   as a connection error (Section\
    \ 5.4.1) of type FRAME_SIZE_ERROR.\n"
- title: 6.5.  SETTINGS
  contents:
  - "6.5.  SETTINGS\n   The SETTINGS frame (type=0x4) conveys configuration parameters\
    \ that\n   affect how endpoints communicate, such as preferences and constraints\n\
    \   on peer behavior.  The SETTINGS frame is also used to acknowledge the\n  \
    \ receipt of those parameters.  Individually, a SETTINGS parameter can\n   also\
    \ be referred to as a \"setting\".\n   SETTINGS parameters are not negotiated;\
    \ they describe characteristics\n   of the sending peer, which are used by the\
    \ receiving peer.  Different\n   values for the same parameter can be advertised\
    \ by each peer.  For\n   example, a client might set a high initial flow-control\
    \ window,\n   whereas a server might set a lower value to conserve resources.\n\
    \   A SETTINGS frame MUST be sent by both endpoints at the start of a\n   connection\
    \ and MAY be sent at any other time by either endpoint over\n   the lifetime of\
    \ the connection.  Implementations MUST support all of\n   the parameters defined\
    \ by this specification.\n   Each parameter in a SETTINGS frame replaces any existing\
    \ value for\n   that parameter.  Parameters are processed in the order in which\
    \ they\n   appear, and a receiver of a SETTINGS frame does not need to maintain\n\
    \   any state other than the current value of its parameters.  Therefore,\n  \
    \ the value of a SETTINGS parameter is the last value that is seen by a\n   receiver.\n\
    \   SETTINGS parameters are acknowledged by the receiving peer.  To\n   enable\
    \ this, the SETTINGS frame defines the following flag:\n   ACK (0x1):  When set,\
    \ bit 0 indicates that this frame acknowledges\n      receipt and application\
    \ of the peer's SETTINGS frame.  When this\n      bit is set, the payload of the\
    \ SETTINGS frame MUST be empty.\n      Receipt of a SETTINGS frame with the ACK\
    \ flag set and a length\n      field value other than 0 MUST be treated as a connection\
    \ error\n      (Section 5.4.1) of type FRAME_SIZE_ERROR.  For more information,\n\
    \      see Section 6.5.3 (\"Settings Synchronization\").\n   SETTINGS frames always\
    \ apply to a connection, never a single stream.\n   The stream identifier for\
    \ a SETTINGS frame MUST be zero (0x0).  If an\n   endpoint receives a SETTINGS\
    \ frame whose stream identifier field is\n   anything other than 0x0, the endpoint\
    \ MUST respond with a connection\n   error (Section 5.4.1) of type PROTOCOL_ERROR.\n\
    \   The SETTINGS frame affects connection state.  A badly formed or\n   incomplete\
    \ SETTINGS frame MUST be treated as a connection error\n   (Section 5.4.1) of\
    \ type PROTOCOL_ERROR.\n   A SETTINGS frame with a length other than a multiple\
    \ of 6 octets MUST\n   be treated as a connection error (Section 5.4.1) of type\n\
    \   FRAME_SIZE_ERROR.\n"
- title: 6.5.1.  SETTINGS Format
  contents:
  - "6.5.1.  SETTINGS Format\n   The payload of a SETTINGS frame consists of zero\
    \ or more parameters,\n   each consisting of an unsigned 16-bit setting identifier\
    \ and an\n   unsigned 32-bit value.\n    +-------------------------------+\n \
    \   |       Identifier (16)         |\n    +-------------------------------+-------------------------------+\n\
    \    |                        Value (32)                             |\n    +---------------------------------------------------------------+\n\
    \                         Figure 10: Setting Format\n"
- title: 6.5.2.  Defined SETTINGS Parameters
  contents:
  - "6.5.2.  Defined SETTINGS Parameters\n   The following parameters are defined:\n\
    \   SETTINGS_HEADER_TABLE_SIZE (0x1):  Allows the sender to inform the\n     \
    \ remote endpoint of the maximum size of the header compression\n      table used\
    \ to decode header blocks, in octets.  The encoder can\n      select any size\
    \ equal to or less than this value by using\n      signaling specific to the header\
    \ compression format inside a\n      header block (see [COMPRESSION]).  The initial\
    \ value is 4,096\n      octets.\n   SETTINGS_ENABLE_PUSH (0x2):  This setting\
    \ can be used to disable\n      server push (Section 8.2).  An endpoint MUST NOT\
    \ send a\n      PUSH_PROMISE frame if it receives this parameter set to a value\
    \ of\n      0.  An endpoint that has both set this parameter to 0 and had it\n\
    \      acknowledged MUST treat the receipt of a PUSH_PROMISE frame as a\n    \
    \  connection error (Section 5.4.1) of type PROTOCOL_ERROR.\n      The initial\
    \ value is 1, which indicates that server push is\n      permitted.  Any value\
    \ other than 0 or 1 MUST be treated as a\n      connection error (Section 5.4.1)\
    \ of type PROTOCOL_ERROR.\n   SETTINGS_MAX_CONCURRENT_STREAMS (0x3):  Indicates\
    \ the maximum number\n      of concurrent streams that the sender will allow.\
    \  This limit is\n      directional: it applies to the number of streams that\
    \ the sender\n      permits the receiver to create.  Initially, there is no limit\
    \ to\n      this value.  It is recommended that this value be no smaller than\n\
    \      100, so as to not unnecessarily limit parallelism.\n      A value of 0\
    \ for SETTINGS_MAX_CONCURRENT_STREAMS SHOULD NOT be\n      treated as special\
    \ by endpoints.  A zero value does prevent the\n      creation of new streams;\
    \ however, this can also happen for any\n      limit that is exhausted with active\
    \ streams.  Servers SHOULD only\n      set a zero value for short durations; if\
    \ a server does not wish to\n      accept requests, closing the connection is\
    \ more appropriate.\n   SETTINGS_INITIAL_WINDOW_SIZE (0x4):  Indicates the sender's\
    \ initial\n      window size (in octets) for stream-level flow control.  The\n\
    \      initial value is 2^16-1 (65,535) octets.\n      This setting affects the\
    \ window size of all streams (see\n      Section 6.9.2).\n      Values above the\
    \ maximum flow-control window size of 2^31-1 MUST\n      be treated as a connection\
    \ error (Section 5.4.1) of type\n      FLOW_CONTROL_ERROR.\n   SETTINGS_MAX_FRAME_SIZE\
    \ (0x5):  Indicates the size of the largest\n      frame payload that the sender\
    \ is willing to receive, in octets.\n      The initial value is 2^14 (16,384)\
    \ octets.  The value advertised\n      by an endpoint MUST be between this initial\
    \ value and the maximum\n      allowed frame size (2^24-1 or 16,777,215 octets),\
    \ inclusive.\n      Values outside this range MUST be treated as a connection\
    \ error\n      (Section 5.4.1) of type PROTOCOL_ERROR.\n   SETTINGS_MAX_HEADER_LIST_SIZE\
    \ (0x6):  This advisory setting informs a\n      peer of the maximum size of header\
    \ list that the sender is\n      prepared to accept, in octets.  The value is\
    \ based on the\n      uncompressed size of header fields, including the length\
    \ of the\n      name and value in octets plus an overhead of 32 octets for each\n\
    \      header field.\n      For any given request, a lower limit than what is\
    \ advertised MAY\n      be enforced.  The initial value of this setting is unlimited.\n\
    \   An endpoint that receives a SETTINGS frame with any unknown or\n   unsupported\
    \ identifier MUST ignore that setting.\n"
- title: 6.5.3.  Settings Synchronization
  contents:
  - "6.5.3.  Settings Synchronization\n   Most values in SETTINGS benefit from or\
    \ require an understanding of\n   when the peer has received and applied the changed\
    \ parameter values.\n   In order to provide such synchronization timepoints, the\
    \ recipient of\n   a SETTINGS frame in which the ACK flag is not set MUST apply\
    \ the\n   updated parameters as soon as possible upon receipt.\n   The values\
    \ in the SETTINGS frame MUST be processed in the order they\n   appear, with no\
    \ other frame processing between values.  Unsupported\n   parameters MUST be ignored.\
    \  Once all values have been processed, the\n   recipient MUST immediately emit\
    \ a SETTINGS frame with the ACK flag\n   set.  Upon receiving a SETTINGS frame\
    \ with the ACK flag set, the\n   sender of the altered parameters can rely on\
    \ the setting having been\n   applied.\n   If the sender of a SETTINGS frame does\
    \ not receive an acknowledgement\n   within a reasonable amount of time, it MAY\
    \ issue a connection error\n   (Section 5.4.1) of type SETTINGS_TIMEOUT.\n"
- title: 6.6.  PUSH_PROMISE
  contents:
  - "6.6.  PUSH_PROMISE\n   The PUSH_PROMISE frame (type=0x5) is used to notify the\
    \ peer endpoint\n   in advance of streams the sender intends to initiate.  The\n\
    \   PUSH_PROMISE frame includes the unsigned 31-bit identifier of the\n   stream\
    \ the endpoint plans to create along with a set of headers that\n   provide additional\
    \ context for the stream.  Section 8.2 contains a\n   thorough description of\
    \ the use of PUSH_PROMISE frames.\n    +---------------+\n    |Pad Length? (8)|\n\
    \    +-+-------------+-----------------------------------------------+\n    |R|\
    \                  Promised Stream ID (31)                    |\n    +-+-----------------------------+-------------------------------+\n\
    \    |                   Header Block Fragment (*)                 ...\n    +---------------------------------------------------------------+\n\
    \    |                           Padding (*)                       ...\n    +---------------------------------------------------------------+\n\
    \                  Figure 11: PUSH_PROMISE Payload Format\n   The PUSH_PROMISE\
    \ frame payload has the following fields:\n   Pad Length:  An 8-bit field containing\
    \ the length of the frame\n      padding in units of octets.  This field is only\
    \ present if the\n      PADDED flag is set.\n   R: A single reserved bit.\n  \
    \ Promised Stream ID:  An unsigned 31-bit integer that identifies the\n      stream\
    \ that is reserved by the PUSH_PROMISE.  The promised stream\n      identifier\
    \ MUST be a valid choice for the next stream sent by the\n      sender (see \"\
    new stream identifier\" in Section 5.1.1).\n   Header Block Fragment:  A header\
    \ block fragment (Section 4.3)\n      containing request header fields.\n   Padding:\
    \  Padding octets.\n   The PUSH_PROMISE frame defines the following flags:\n \
    \  END_HEADERS (0x4):  When set, bit 2 indicates that this frame\n      contains\
    \ an entire header block (Section 4.3) and is not followed\n      by any CONTINUATION\
    \ frames.\n      A PUSH_PROMISE frame without the END_HEADERS flag set MUST be\n\
    \      followed by a CONTINUATION frame for the same stream.  A receiver\n   \
    \   MUST treat the receipt of any other type of frame or a frame on a\n      different\
    \ stream as a connection error (Section 5.4.1) of type\n      PROTOCOL_ERROR.\n\
    \   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field\n     \
    \ and any padding that it describes are present.\n   PUSH_PROMISE frames MUST\
    \ only be sent on a peer-initiated stream that\n   is in either the \"open\" or\
    \ \"half-closed (remote)\" state.  The stream\n   identifier of a PUSH_PROMISE\
    \ frame indicates the stream it is\n   associated with.  If the stream identifier\
    \ field specifies the value\n   0x0, a recipient MUST respond with a connection\
    \ error (Section 5.4.1)\n   of type PROTOCOL_ERROR.\n   Promised streams are not\
    \ required to be used in the order they are\n   promised.  The PUSH_PROMISE only\
    \ reserves stream identifiers for\n   later use.\n   PUSH_PROMISE MUST NOT be\
    \ sent if the SETTINGS_ENABLE_PUSH setting of\n   the peer endpoint is set to\
    \ 0.  An endpoint that has set this setting\n   and has received acknowledgement\
    \ MUST treat the receipt of a\n   PUSH_PROMISE frame as a connection error (Section\
    \ 5.4.1) of type\n   PROTOCOL_ERROR.\n   Recipients of PUSH_PROMISE frames can\
    \ choose to reject promised\n   streams by returning a RST_STREAM referencing\
    \ the promised stream\n   identifier back to the sender of the PUSH_PROMISE.\n\
    \   A PUSH_PROMISE frame modifies the connection state in two ways.\n   First,\
    \ the inclusion of a header block (Section 4.3) potentially\n   modifies the state\
    \ maintained for header compression.  Second,\n   PUSH_PROMISE also reserves a\
    \ stream for later use, causing the\n   promised stream to enter the \"reserved\"\
    \ state.  A sender MUST NOT\n   send a PUSH_PROMISE on a stream unless that stream\
    \ is either \"open\"\n   or \"half-closed (remote)\"; the sender MUST ensure that\
    \ the promised\n   stream is a valid choice for a new stream identifier (Section\
    \ 5.1.1)\n   (that is, the promised stream MUST be in the \"idle\" state).\n \
    \  Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame\n   causes\
    \ the stream state to become indeterminate.  A receiver MUST\n   treat the receipt\
    \ of a PUSH_PROMISE on a stream that is neither\n   \"open\" nor \"half-closed\
    \ (local)\" as a connection error\n   (Section 5.4.1) of type PROTOCOL_ERROR.\
    \  However, an endpoint that\n   has sent RST_STREAM on the associated stream\
    \ MUST handle PUSH_PROMISE\n   frames that might have been created before the\
    \ RST_STREAM frame is\n   received and processed.\n   A receiver MUST treat the\
    \ receipt of a PUSH_PROMISE that promises an\n   illegal stream identifier (Section\
    \ 5.1.1) as a connection error\n   (Section 5.4.1) of type PROTOCOL_ERROR.  Note\
    \ that an illegal stream\n   identifier is an identifier for a stream that is\
    \ not currently in the\n   \"idle\" state.\n   The PUSH_PROMISE frame can include\
    \ padding.  Padding fields and flags\n   are identical to those defined for DATA\
    \ frames (Section 6.1).\n"
- title: 6.7.  PING
  contents:
  - "6.7.  PING\n   The PING frame (type=0x6) is a mechanism for measuring a minimal\n\
    \   round-trip time from the sender, as well as determining whether an\n   idle\
    \ connection is still functional.  PING frames can be sent from\n   any endpoint.\n\
    \    +---------------------------------------------------------------+\n    |\
    \                                                               |\n    |     \
    \                 Opaque Data (64)                         |\n    |          \
    \                                                     |\n    +---------------------------------------------------------------+\n\
    \                      Figure 12: PING Payload Format\n   In addition to the frame\
    \ header, PING frames MUST contain 8 octets of\n   opaque data in the payload.\
    \  A sender can include any value it\n   chooses and use those octets in any fashion.\n\
    \   Receivers of a PING frame that does not include an ACK flag MUST send\n  \
    \ a PING frame with the ACK flag set in response, with an identical\n   payload.\
    \  PING responses SHOULD be given higher priority than any\n   other frame.\n\
    \   The PING frame defines the following flags:\n   ACK (0x1):  When set, bit\
    \ 0 indicates that this PING frame is a PING\n      response.  An endpoint MUST\
    \ set this flag in PING responses.  An\n      endpoint MUST NOT respond to PING\
    \ frames containing this flag.\n   PING frames are not associated with any individual\
    \ stream.  If a PING\n   frame is received with a stream identifier field value\
    \ other than\n   0x0, the recipient MUST respond with a connection error\n   (Section\
    \ 5.4.1) of type PROTOCOL_ERROR.\n   Receipt of a PING frame with a length field\
    \ value other than 8 MUST\n   be treated as a connection error (Section 5.4.1)\
    \ of type\n   FRAME_SIZE_ERROR.\n"
- title: 6.8.  GOAWAY
  contents:
  - "6.8.  GOAWAY\n   The GOAWAY frame (type=0x7) is used to initiate shutdown of\
    \ a\n   connection or to signal serious error conditions.  GOAWAY allows an\n\
    \   endpoint to gracefully stop accepting new streams while still\n   finishing\
    \ processing of previously established streams.  This enables\n   administrative\
    \ actions, like server maintenance.\n   There is an inherent race condition between\
    \ an endpoint starting new\n   streams and the remote sending a GOAWAY frame.\
    \  To deal with this\n   case, the GOAWAY contains the stream identifier of the\
    \ last peer-\n   initiated stream that was or might be processed on the sending\n\
    \   endpoint in this connection.  For instance, if the server sends a\n   GOAWAY\
    \ frame, the identified stream is the highest-numbered stream\n   initiated by\
    \ the client.\n   Once sent, the sender will ignore frames sent on streams initiated\
    \ by\n   the receiver if the stream has an identifier higher than the included\n\
    \   last stream identifier.  Receivers of a GOAWAY frame MUST NOT open\n   additional\
    \ streams on the connection, although a new connection can\n   be established\
    \ for new streams.\n   If the receiver of the GOAWAY has sent data on streams\
    \ with a higher\n   stream identifier than what is indicated in the GOAWAY frame,\
    \ those\n   streams are not or will not be processed.  The receiver of the GOAWAY\n\
    \   frame can treat the streams as though they had never been created at\n   all,\
    \ thereby allowing those streams to be retried later on a new\n   connection.\n\
    \   Endpoints SHOULD always send a GOAWAY frame before closing a\n   connection\
    \ so that the remote peer can know whether a stream has been\n   partially processed\
    \ or not.  For example, if an HTTP client sends a\n   POST at the same time that\
    \ a server closes a connection, the client\n   cannot know if the server started\
    \ to process that POST request if the\n   server does not send a GOAWAY frame\
    \ to indicate what streams it might\n   have acted on.\n   An endpoint might choose\
    \ to close a connection without sending a\n   GOAWAY for misbehaving peers.\n\
    \   A GOAWAY frame might not immediately precede closing of the\n   connection;\
    \ a receiver of a GOAWAY that has no more use for the\n   connection SHOULD still\
    \ send a GOAWAY frame before terminating the\n   connection.\n    +-+-------------------------------------------------------------+\n\
    \    |R|                  Last-Stream-ID (31)                        |\n    +-+-------------------------------------------------------------+\n\
    \    |                      Error Code (32)                          |\n    +---------------------------------------------------------------+\n\
    \    |                  Additional Debug Data (*)                    |\n    +---------------------------------------------------------------+\n\
    \                     Figure 13: GOAWAY Payload Format\n   The GOAWAY frame does\
    \ not define any flags.\n   The GOAWAY frame applies to the connection, not a\
    \ specific stream.\n   An endpoint MUST treat a GOAWAY frame with a stream identifier\
    \ other\n   than 0x0 as a connection error (Section 5.4.1) of type\n   PROTOCOL_ERROR.\n\
    \   The last stream identifier in the GOAWAY frame contains the highest-\n   numbered\
    \ stream identifier for which the sender of the GOAWAY frame\n   might have taken\
    \ some action on or might yet take action on.  All\n   streams up to and including\
    \ the identified stream might have been\n   processed in some way.  The last stream\
    \ identifier can be set to 0 if\n   no streams were processed.\n      Note: In\
    \ this context, \"processed\" means that some data from the\n      stream was\
    \ passed to some higher layer of software that might have\n      taken some action\
    \ as a result.\n   If a connection terminates without a GOAWAY frame, the last\
    \ stream\n   identifier is effectively the highest possible stream identifier.\n\
    \   On streams with lower- or equal-numbered identifiers that were not\n   closed\
    \ completely prior to the connection being closed, reattempting\n   requests,\
    \ transactions, or any protocol activity is not possible,\n   with the exception\
    \ of idempotent actions like HTTP GET, PUT, or\n   DELETE.  Any protocol activity\
    \ that uses higher-numbered streams can\n   be safely retried using a new connection.\n\
    \   Activity on streams numbered lower or equal to the last stream\n   identifier\
    \ might still complete successfully.  The sender of a GOAWAY\n   frame might gracefully\
    \ shut down a connection by sending a GOAWAY\n   frame, maintaining the connection\
    \ in an \"open\" state until all in-\n   progress streams complete.\n   An endpoint\
    \ MAY send multiple GOAWAY frames if circumstances change.\n   For instance, an\
    \ endpoint that sends GOAWAY with NO_ERROR during\n   graceful shutdown could\
    \ subsequently encounter a condition that\n   requires immediate termination of\
    \ the connection.  The last stream\n   identifier from the last GOAWAY frame received\
    \ indicates which\n   streams could have been acted upon.  Endpoints MUST NOT\
    \ increase the\n   value they send in the last stream identifier, since the peers\
    \ might\n   already have retried unprocessed requests on another connection.\n\
    \   A client that is unable to retry requests loses all requests that are\n  \
    \ in flight when the server closes the connection.  This is especially\n   true\
    \ for intermediaries that might not be serving clients using\n   HTTP/2.  A server\
    \ that is attempting to gracefully shut down a\n   connection SHOULD send an initial\
    \ GOAWAY frame with the last stream\n   identifier set to 2^31-1 and a NO_ERROR\
    \ code.  This signals to the\n   client that a shutdown is imminent and that initiating\
    \ further\n   requests is prohibited.  After allowing time for any in-flight stream\n\
    \   creation (at least one round-trip time), the server can send another\n   GOAWAY\
    \ frame with an updated last stream identifier.  This ensures\n   that a connection\
    \ can be cleanly shut down without losing requests.\n   After sending a GOAWAY\
    \ frame, the sender can discard frames for\n   streams initiated by the receiver\
    \ with identifiers higher than the\n   identified last stream.  However, any frames\
    \ that alter connection\n   state cannot be completely ignored.  For instance,\
    \ HEADERS,\n   PUSH_PROMISE, and CONTINUATION frames MUST be minimally processed\
    \ to\n   ensure the state maintained for header compression is consistent (see\n\
    \   Section 4.3); similarly, DATA frames MUST be counted toward the\n   connection\
    \ flow-control window.  Failure to process these frames can\n   cause flow control\
    \ or header compression state to become\n   unsynchronized.\n   The GOAWAY frame\
    \ also contains a 32-bit error code (Section 7) that\n   contains the reason for\
    \ closing the connection.\n   Endpoints MAY append opaque data to the payload\
    \ of any GOAWAY frame.\n   Additional debug data is intended for diagnostic purposes\
    \ only and\n   carries no semantic value.  Debug information could contain security-\n\
    \   or privacy-sensitive data.  Logged or otherwise persistently stored\n   debug\
    \ data MUST have adequate safeguards to prevent unauthorized\n   access.\n"
- title: 6.9.  WINDOW_UPDATE
  contents:
  - "6.9.  WINDOW_UPDATE\n   The WINDOW_UPDATE frame (type=0x8) is used to implement\
    \ flow control;\n   see Section 5.2 for an overview.\n   Flow control operates\
    \ at two levels: on each individual stream and on\n   the entire connection.\n\
    \   Both types of flow control are hop by hop, that is, only between the\n   two\
    \ endpoints.  Intermediaries do not forward WINDOW_UPDATE frames\n   between dependent\
    \ connections.  However, throttling of data transfer\n   by any receiver can indirectly\
    \ cause the propagation of flow-control\n   information toward the original sender.\n\
    \   Flow control only applies to frames that are identified as being\n   subject\
    \ to flow control.  Of the frame types defined in this\n   document, this includes\
    \ only DATA frames.  Frames that are exempt\n   from flow control MUST be accepted\
    \ and processed, unless the receiver\n   is unable to assign resources to handling\
    \ the frame.  A receiver MAY\n   respond with a stream error (Section 5.4.2) or\
    \ connection error\n   (Section 5.4.1) of type FLOW_CONTROL_ERROR if it is unable\
    \ to accept\n   a frame.\n    +-+-------------------------------------------------------------+\n\
    \    |R|              Window Size Increment (31)                     |\n    +-+-------------------------------------------------------------+\n\
    \                  Figure 14: WINDOW_UPDATE Payload Format\n   The payload of\
    \ a WINDOW_UPDATE frame is one reserved bit plus an\n   unsigned 31-bit integer\
    \ indicating the number of octets that the\n   sender can transmit in addition\
    \ to the existing flow-control window.\n   The legal range for the increment to\
    \ the flow-control window is 1 to\n   2^31-1 (2,147,483,647) octets.\n   The WINDOW_UPDATE\
    \ frame does not define any flags.\n   The WINDOW_UPDATE frame can be specific\
    \ to a stream or to the entire\n   connection.  In the former case, the frame's\
    \ stream identifier\n   indicates the affected stream; in the latter, the value\
    \ \"0\" indicates\n   that the entire connection is the subject of the frame.\n\
    \   A receiver MUST treat the receipt of a WINDOW_UPDATE frame with an\n   flow-control\
    \ window increment of 0 as a stream error (Section 5.4.2)\n   of type PROTOCOL_ERROR;\
    \ errors on the connection flow-control window\n   MUST be treated as a connection\
    \ error (Section 5.4.1).\n   WINDOW_UPDATE can be sent by a peer that has sent\
    \ a frame bearing the\n   END_STREAM flag.  This means that a receiver could receive\
    \ a\n   WINDOW_UPDATE frame on a \"half-closed (remote)\" or \"closed\" stream.\n\
    \   A receiver MUST NOT treat this as an error (see Section 5.1).\n   A receiver\
    \ that receives a flow-controlled frame MUST always account\n   for its contribution\
    \ against the connection flow-control window,\n   unless the receiver treats this\
    \ as a connection error\n   (Section 5.4.1).  This is necessary even if the frame\
    \ is in error.\n   The sender counts the frame toward the flow-control window,\
    \ but if\n   the receiver does not, the flow-control window at the sender and\n\
    \   receiver can become different.\n   A WINDOW_UPDATE frame with a length other\
    \ than 4 octets MUST be\n   treated as a connection error (Section 5.4.1) of type\n\
    \   FRAME_SIZE_ERROR.\n"
- title: 6.9.1.  The Flow-Control Window
  contents:
  - "6.9.1.  The Flow-Control Window\n   Flow control in HTTP/2 is implemented using\
    \ a window kept by each\n   sender on every stream.  The flow-control window is\
    \ a simple integer\n   value that indicates how many octets of data the sender\
    \ is permitted\n   to transmit; as such, its size is a measure of the buffering\
    \ capacity\n   of the receiver.\n   Two flow-control windows are applicable: the\
    \ stream flow-control\n   window and the connection flow-control window.  The\
    \ sender MUST NOT\n   send a flow-controlled frame with a length that exceeds\
    \ the space\n   available in either of the flow-control windows advertised by\
    \ the\n   receiver.  Frames with zero length with the END_STREAM flag set (that\n\
    \   is, an empty DATA frame) MAY be sent if there is no available space\n   in\
    \ either flow-control window.\n   For flow-control calculations, the 9-octet frame\
    \ header is not\n   counted.\n   After sending a flow-controlled frame, the sender\
    \ reduces the space\n   available in both windows by the length of the transmitted\
    \ frame.\n   The receiver of a frame sends a WINDOW_UPDATE frame as it consumes\n\
    \   data and frees up space in flow-control windows.  Separate\n   WINDOW_UPDATE\
    \ frames are sent for the stream- and connection-level\n   flow-control windows.\n\
    \   A sender that receives a WINDOW_UPDATE frame updates the\n   corresponding\
    \ window by the amount specified in the frame.\n   A sender MUST NOT allow a flow-control\
    \ window to exceed 2^31-1\n   octets.  If a sender receives a WINDOW_UPDATE that\
    \ causes a flow-\n   control window to exceed this maximum, it MUST terminate\
    \ either the\n   stream or the connection, as appropriate.  For streams, the sender\n\
    \   sends a RST_STREAM with an error code of FLOW_CONTROL_ERROR; for the\n   connection,\
    \ a GOAWAY frame with an error code of FLOW_CONTROL_ERROR\n   is sent.\n   Flow-controlled\
    \ frames from the sender and WINDOW_UPDATE frames from\n   the receiver are completely\
    \ asynchronous with respect to each other.\n   This property allows a receiver\
    \ to aggressively update the window\n   size kept by the sender to prevent streams\
    \ from stalling.\n"
- title: 6.9.2.  Initial Flow-Control Window Size
  contents:
  - "6.9.2.  Initial Flow-Control Window Size\n   When an HTTP/2 connection is first\
    \ established, new streams are\n   created with an initial flow-control window\
    \ size of 65,535 octets.\n   The connection flow-control window is also 65,535\
    \ octets.  Both\n   endpoints can adjust the initial window size for new streams\
    \ by\n   including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS\n\
    \   frame that forms part of the connection preface.  The connection\n   flow-control\
    \ window can only be changed using WINDOW_UPDATE frames.\n   Prior to receiving\
    \ a SETTINGS frame that sets a value for\n   SETTINGS_INITIAL_WINDOW_SIZE, an\
    \ endpoint can only use the default\n   initial window size when sending flow-controlled\
    \ frames.  Similarly,\n   the connection flow-control window is set to the default\
    \ initial\n   window size until a WINDOW_UPDATE frame is received.\n   In addition\
    \ to changing the flow-control window for streams that are\n   not yet active,\
    \ a SETTINGS frame can alter the initial flow-control\n   window size for streams\
    \ with active flow-control windows (that is,\n   streams in the \"open\" or \"\
    half-closed (remote)\" state).  When the\n   value of SETTINGS_INITIAL_WINDOW_SIZE\
    \ changes, a receiver MUST adjust\n   the size of all stream flow-control windows\
    \ that it maintains by the\n   difference between the new value and the old value.\n\
    \   A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available\n   space\
    \ in a flow-control window to become negative.  A sender MUST\n   track the negative\
    \ flow-control window and MUST NOT send new flow-\n   controlled frames until\
    \ it receives WINDOW_UPDATE frames that cause\n   the flow-control window to become\
    \ positive.\n   For example, if the client sends 60 KB immediately on connection\n\
    \   establishment and the server sets the initial window size to be 16\n   KB,\
    \ the client will recalculate the available flow-control window to\n   be -44\
    \ KB on receipt of the SETTINGS frame.  The client retains a\n   negative flow-control\
    \ window until WINDOW_UPDATE frames restore the\n   window to being positive,\
    \ after which the client can resume sending.\n   A SETTINGS frame cannot alter\
    \ the connection flow-control window.\n   An endpoint MUST treat a change to SETTINGS_INITIAL_WINDOW_SIZE\
    \ that\n   causes any flow-control window to exceed the maximum size as a\n  \
    \ connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR.\n"
- title: 6.9.3.  Reducing the Stream Window Size
  contents:
  - "6.9.3.  Reducing the Stream Window Size\n   A receiver that wishes to use a smaller\
    \ flow-control window than the\n   current size can send a new SETTINGS frame.\
    \  However, the receiver\n   MUST be prepared to receive data that exceeds this\
    \ window size, since\n   the sender might send data that exceeds the lower limit\
    \ prior to\n   processing the SETTINGS frame.\n   After sending a SETTINGS frame\
    \ that reduces the initial flow-control\n   window size, a receiver MAY continue\
    \ to process streams that exceed\n   flow-control limits.  Allowing streams to\
    \ continue does not allow the\n   receiver to immediately reduce the space it\
    \ reserves for flow-control\n   windows.  Progress on these streams can also stall,\
    \ since\n   WINDOW_UPDATE frames are needed to allow the sender to resume\n  \
    \ sending.  The receiver MAY instead send a RST_STREAM with an error\n   code\
    \ of FLOW_CONTROL_ERROR for the affected streams.\n"
- title: 6.10.  CONTINUATION
  contents:
  - "6.10.  CONTINUATION\n   The CONTINUATION frame (type=0x9) is used to continue\
    \ a sequence of\n   header block fragments (Section 4.3).  Any number of CONTINUATION\n\
    \   frames can be sent, as long as the preceding frame is on the same\n   stream\
    \ and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without\n   the END_HEADERS\
    \ flag set.\n    +---------------------------------------------------------------+\n\
    \    |                   Header Block Fragment (*)                 ...\n    +---------------------------------------------------------------+\n\
    \                   Figure 15: CONTINUATION Frame Payload\n   The CONTINUATION\
    \ frame payload contains a header block fragment\n   (Section 4.3).\n   The CONTINUATION\
    \ frame defines the following flag:\n   END_HEADERS (0x4):  When set, bit 2 indicates\
    \ that this frame ends a\n      header block (Section 4.3).\n      If the END_HEADERS\
    \ bit is not set, this frame MUST be followed by\n      another CONTINUATION frame.\
    \  A receiver MUST treat the receipt of\n      any other type of frame or a frame\
    \ on a different stream as a\n      connection error (Section 5.4.1) of type PROTOCOL_ERROR.\n\
    \   The CONTINUATION frame changes the connection state as defined in\n   Section\
    \ 4.3.\n   CONTINUATION frames MUST be associated with a stream.  If a\n   CONTINUATION\
    \ frame is received whose stream identifier field is 0x0,\n   the recipient MUST\
    \ respond with a connection error (Section 5.4.1) of\n   type PROTOCOL_ERROR.\n\
    \   A CONTINUATION frame MUST be preceded by a HEADERS, PUSH_PROMISE or\n   CONTINUATION\
    \ frame without the END_HEADERS flag set.  A recipient\n   that observes violation\
    \ of this rule MUST respond with a connection\n   error (Section 5.4.1) of type\
    \ PROTOCOL_ERROR.\n"
- title: 7.  Error Codes
  contents:
  - "7.  Error Codes\n   Error codes are 32-bit fields that are used in RST_STREAM\
    \ and GOAWAY\n   frames to convey the reasons for the stream or connection error.\n\
    \   Error codes share a common code space.  Some error codes apply only\n   to\
    \ either streams or the entire connection and have no defined\n   semantics in\
    \ the other context.\n   The following error codes are defined:\n   NO_ERROR (0x0):\
    \  The associated condition is not a result of an\n      error.  For example,\
    \ a GOAWAY might include this code to indicate\n      graceful shutdown of a connection.\n\
    \   PROTOCOL_ERROR (0x1):  The endpoint detected an unspecific protocol\n    \
    \  error.  This error is for use when a more specific error code is\n      not\
    \ available.\n   INTERNAL_ERROR (0x2):  The endpoint encountered an unexpected\n\
    \      internal error.\n   FLOW_CONTROL_ERROR (0x3):  The endpoint detected that\
    \ its peer\n      violated the flow-control protocol.\n   SETTINGS_TIMEOUT (0x4):\
    \  The endpoint sent a SETTINGS frame but did\n      not receive a response in\
    \ a timely manner.  See Section 6.5.3\n      (\"Settings Synchronization\").\n\
    \   STREAM_CLOSED (0x5):  The endpoint received a frame after a stream\n     \
    \ was half-closed.\n   FRAME_SIZE_ERROR (0x6):  The endpoint received a frame\
    \ with an\n      invalid size.\n   REFUSED_STREAM (0x7):  The endpoint refused\
    \ the stream prior to\n      performing any application processing (see Section\
    \ 8.1.4 for\n      details).\n   CANCEL (0x8):  Used by the endpoint to indicate\
    \ that the stream is no\n      longer needed.\n   COMPRESSION_ERROR (0x9):  The\
    \ endpoint is unable to maintain the\n      header compression context for the\
    \ connection.\n   CONNECT_ERROR (0xa):  The connection established in response\
    \ to a\n      CONNECT request (Section 8.3) was reset or abnormally closed.\n\
    \   ENHANCE_YOUR_CALM (0xb):  The endpoint detected that its peer is\n      exhibiting\
    \ a behavior that might be generating excessive load.\n   INADEQUATE_SECURITY\
    \ (0xc):  The underlying transport has properties\n      that do not meet minimum\
    \ security requirements (see Section 9.2).\n   HTTP_1_1_REQUIRED (0xd):  The endpoint\
    \ requires that HTTP/1.1 be used\n      instead of HTTP/2.\n   Unknown or unsupported\
    \ error codes MUST NOT trigger any special\n   behavior.  These MAY be treated\
    \ by an implementation as being\n   equivalent to INTERNAL_ERROR.\n"
- title: 8.  HTTP Message Exchanges
  contents:
  - "8.  HTTP Message Exchanges\n   HTTP/2 is intended to be as compatible as possible\
    \ with current uses\n   of HTTP.  This means that, from the application perspective,\
    \ the\n   features of the protocol are largely unchanged.  To achieve this, all\n\
    \   request and response semantics are preserved, although the syntax of\n   conveying\
    \ those semantics has changed.\n   Thus, the specification and requirements of\
    \ HTTP/1.1 Semantics and\n   Content [RFC7231], Conditional Requests [RFC7232],\
    \ Range Requests\n   [RFC7233], Caching [RFC7234], and Authentication [RFC7235]\
    \ are\n   applicable to HTTP/2.  Selected portions of HTTP/1.1 Message Syntax\n\
    \   and Routing [RFC7230], such as the HTTP and HTTPS URI schemes, are\n   also\
    \ applicable in HTTP/2, but the expression of those semantics for\n   this protocol\
    \ are defined in the sections below.\n"
- title: 8.1.  HTTP Request/Response Exchange
  contents:
  - "8.1.  HTTP Request/Response Exchange\n   A client sends an HTTP request on a\
    \ new stream, using a previously\n   unused stream identifier (Section 5.1.1).\
    \  A server sends an HTTP\n   response on the same stream as the request.\n  \
    \ An HTTP message (request or response) consists of:\n   1.  for a response only,\
    \ zero or more HEADERS frames (each followed\n       by zero or more CONTINUATION\
    \ frames) containing the message\n       headers of informational (1xx) HTTP responses\
    \ (see [RFC7230],\n       Section 3.2 and [RFC7231], Section 6.2),\n   2.  one\
    \ HEADERS frame (followed by zero or more CONTINUATION frames)\n       containing\
    \ the message headers (see [RFC7230], Section 3.2),\n   3.  zero or more DATA\
    \ frames containing the payload body (see\n       [RFC7230], Section 3.3), and\n\
    \   4.  optionally, one HEADERS frame, followed by zero or more\n       CONTINUATION\
    \ frames containing the trailer-part, if present (see\n       [RFC7230], Section\
    \ 4.1.2).\n   The last frame in the sequence bears an END_STREAM flag, noting\
    \ that\n   a HEADERS frame bearing the END_STREAM flag can be followed by\n  \
    \ CONTINUATION frames that carry any remaining portions of the header\n   block.\n\
    \   Other frames (from any stream) MUST NOT occur between the HEADERS\n   frame\
    \ and any CONTINUATION frames that might follow.\n   HTTP/2 uses DATA frames to\
    \ carry message payloads.  The \"chunked\"\n   transfer encoding defined in Section\
    \ 4.1 of [RFC7230] MUST NOT be\n   used in HTTP/2.\n   Trailing header fields\
    \ are carried in a header block that also\n   terminates the stream.  Such a header\
    \ block is a sequence starting\n   with a HEADERS frame, followed by zero or more\
    \ CONTINUATION frames,\n   where the HEADERS frame bears an END_STREAM flag. \
    \ Header blocks\n   after the first that do not terminate the stream are not part\
    \ of an\n   HTTP request or response.\n   A HEADERS frame (and associated CONTINUATION\
    \ frames) can only appear\n   at the start or end of a stream.  An endpoint that\
    \ receives a HEADERS\n   frame without the END_STREAM flag set after receiving\
    \ a final (non-\n   informational) status code MUST treat the corresponding request\
    \ or\n   response as malformed (Section 8.1.2.6).\n   An HTTP request/response\
    \ exchange fully consumes a single stream.  A\n   request starts with the HEADERS\
    \ frame that puts the stream into an\n   \"open\" state.  The request ends with\
    \ a frame bearing END_STREAM,\n   which causes the stream to become \"half-closed\
    \ (local)\" for the\n   client and \"half-closed (remote)\" for the server.  A\
    \ response starts\n   with a HEADERS frame and ends with a frame bearing END_STREAM,\
    \ which\n   places the stream in the \"closed\" state.\n   An HTTP response is\
    \ complete after the server sends -- or the client\n   receives -- a frame with\
    \ the END_STREAM flag set (including any\n   CONTINUATION frames needed to complete\
    \ a header block).  A server can\n   send a complete response prior to the client\
    \ sending an entire\n   request if the response does not depend on any portion\
    \ of the request\n   that has not been sent and received.  When this is true,\
    \ a server MAY\n   request that the client abort transmission of a request without\
    \ error\n   by sending a RST_STREAM with an error code of NO_ERROR after sending\n\
    \   a complete response (i.e., a frame with the END_STREAM flag).\n   Clients\
    \ MUST NOT discard responses as a result of receiving such a\n   RST_STREAM, though\
    \ clients can always discard responses at their\n   discretion for other reasons.\n"
- title: 8.1.1.  Upgrading from HTTP/2
  contents:
  - "8.1.1.  Upgrading from HTTP/2\n   HTTP/2 removes support for the 101 (Switching\
    \ Protocols)\n   informational status code ([RFC7231], Section 6.2.2).\n   The\
    \ semantics of 101 (Switching Protocols) aren't applicable to a\n   multiplexed\
    \ protocol.  Alternative protocols are able to use the same\n   mechanisms that\
    \ HTTP/2 uses to negotiate their use (see Section 3).\n"
- title: 8.1.2.  HTTP Header Fields
  contents:
  - "8.1.2.  HTTP Header Fields\n   HTTP header fields carry information as a series\
    \ of key-value pairs.\n   For a listing of registered HTTP headers, see the \"\
    Message Header\n   Field\" registry maintained at <https://www.iana.org/assignments/\n\
    \   message-headers>.\n   Just as in HTTP/1.x, header field names are strings\
    \ of ASCII\n   characters that are compared in a case-insensitive fashion.  However,\n\
    \   header field names MUST be converted to lowercase prior to their\n   encoding\
    \ in HTTP/2.  A request or response containing uppercase\n   header field names\
    \ MUST be treated as malformed (Section 8.1.2.6).\n"
- title: 8.1.2.1.  Pseudo-Header Fields
  contents:
  - "8.1.2.1.  Pseudo-Header Fields\n   While HTTP/1.x used the message start-line\
    \ (see [RFC7230],\n   Section 3.1) to convey the target URI, the method of the\
    \ request, and\n   the status code for the response, HTTP/2 uses special pseudo-header\n\
    \   fields beginning with ':' character (ASCII 0x3a) for this purpose.\n   Pseudo-header\
    \ fields are not HTTP header fields.  Endpoints MUST NOT\n   generate pseudo-header\
    \ fields other than those defined in this\n   document.\n   Pseudo-header fields\
    \ are only valid in the context in which they are\n   defined.  Pseudo-header\
    \ fields defined for requests MUST NOT appear\n   in responses; pseudo-header\
    \ fields defined for responses MUST NOT\n   appear in requests.  Pseudo-header\
    \ fields MUST NOT appear in\n   trailers.  Endpoints MUST treat a request or response\
    \ that contains\n   undefined or invalid pseudo-header fields as malformed\n \
    \  (Section 8.1.2.6).\n   All pseudo-header fields MUST appear in the header block\
    \ before\n   regular header fields.  Any request or response that contains a\n\
    \   pseudo-header field that appears in a header block after a regular\n   header\
    \ field MUST be treated as malformed (Section 8.1.2.6).\n"
- title: 8.1.2.2.  Connection-Specific Header Fields
  contents:
  - "8.1.2.2.  Connection-Specific Header Fields\n   HTTP/2 does not use the Connection\
    \ header field to indicate\n   connection-specific header fields; in this protocol,\
    \ connection-\n   specific metadata is conveyed by other means.  An endpoint MUST\
    \ NOT\n   generate an HTTP/2 message containing connection-specific header\n \
    \  fields; any message containing connection-specific header fields MUST\n   be\
    \ treated as malformed (Section 8.1.2.6).\n   The only exception to this is the\
    \ TE header field, which MAY be\n   present in an HTTP/2 request; when it is,\
    \ it MUST NOT contain any\n   value other than \"trailers\".\n   This means that\
    \ an intermediary transforming an HTTP/1.x message to\n   HTTP/2 will need to\
    \ remove any header fields nominated by the\n   Connection header field, along\
    \ with the Connection header field\n   itself.  Such intermediaries SHOULD also\
    \ remove other connection-\n   specific header fields, such as Keep-Alive, Proxy-Connection,\n\
    \   Transfer-Encoding, and Upgrade, even if they are not nominated by the\n  \
    \ Connection header field.\n      Note: HTTP/2 purposefully does not support upgrade\
    \ to another\n      protocol.  The handshake methods described in Section 3 are\n\
    \      believed sufficient to negotiate the use of alternative protocols.\n"
- title: 8.1.2.3.  Request Pseudo-Header Fields
  contents:
  - "8.1.2.3.  Request Pseudo-Header Fields\n   The following pseudo-header fields\
    \ are defined for HTTP/2 requests:\n   o  The \":method\" pseudo-header field\
    \ includes the HTTP method\n      ([RFC7231], Section 4).\n   o  The \":scheme\"\
    \ pseudo-header field includes the scheme portion of\n      the target URI ([RFC3986],\
    \ Section 3.1).\n      \":scheme\" is not restricted to \"http\" and \"https\"\
    \ schemed URIs.  A\n      proxy or gateway can translate requests for non-HTTP\
    \ schemes,\n      enabling the use of HTTP to interact with non-HTTP services.\n\
    \   o  The \":authority\" pseudo-header field includes the authority\n      portion\
    \ of the target URI ([RFC3986], Section 3.2).  The authority\n      MUST NOT include\
    \ the deprecated \"userinfo\" subcomponent for \"http\"\n      or \"https\" schemed\
    \ URIs.\n      To ensure that the HTTP/1.1 request line can be reproduced\n  \
    \    accurately, this pseudo-header field MUST be omitted when\n      translating\
    \ from an HTTP/1.1 request that has a request target in\n      origin or asterisk\
    \ form (see [RFC7230], Section 5.3).  Clients\n      that generate HTTP/2 requests\
    \ directly SHOULD use the \":authority\"\n      pseudo-header field instead of\
    \ the Host header field.  An\n      intermediary that converts an HTTP/2 request\
    \ to HTTP/1.1 MUST\n      create a Host header field if one is not present in\
    \ a request by\n      copying the value of the \":authority\" pseudo-header field.\n\
    \   o  The \":path\" pseudo-header field includes the path and query parts\n \
    \     of the target URI (the \"path-absolute\" production and optionally a\n \
    \     '?' character followed by the \"query\" production (see Sections 3.3\n \
    \     and 3.4 of [RFC3986]).  A request in asterisk form includes the\n      value\
    \ '*' for the \":path\" pseudo-header field.\n      This pseudo-header field MUST\
    \ NOT be empty for \"http\" or \"https\"\n      URIs; \"http\" or \"https\" URIs\
    \ that do not contain a path component\n      MUST include a value of '/'.  The\
    \ exception to this rule is an\n      OPTIONS request for an \"http\" or \"https\"\
    \ URI that does not include\n      a path component; these MUST include a \":path\"\
    \ pseudo-header field\n      with a value of '*' (see [RFC7230], Section 5.3.4).\n\
    \   All HTTP/2 requests MUST include exactly one valid value for the\n   \":method\"\
    , \":scheme\", and \":path\" pseudo-header fields, unless it is\n   a CONNECT\
    \ request (Section 8.3).  An HTTP request that omits\n   mandatory pseudo-header\
    \ fields is malformed (Section 8.1.2.6).\n   HTTP/2 does not define a way to carry\
    \ the version identifier that is\n   included in the HTTP/1.1 request line.\n"
- title: 8.1.2.4.  Response Pseudo-Header Fields
  contents:
  - "8.1.2.4.  Response Pseudo-Header Fields\n   For HTTP/2 responses, a single \"\
    :status\" pseudo-header field is\n   defined that carries the HTTP status code\
    \ field (see [RFC7231],\n   Section 6).  This pseudo-header field MUST be included\
    \ in all\n   responses; otherwise, the response is malformed (Section 8.1.2.6).\n\
    \   HTTP/2 does not define a way to carry the version or reason phrase\n   that\
    \ is included in an HTTP/1.1 status line.\n"
- title: 8.1.2.5.  Compressing the Cookie Header Field
  contents:
  - "8.1.2.5.  Compressing the Cookie Header Field\n   The Cookie header field [COOKIE]\
    \ uses a semi-colon (\";\") to delimit\n   cookie-pairs (or \"crumbs\").  This\
    \ header field doesn't follow the\n   list construction rules in HTTP (see [RFC7230],\
    \ Section 3.2.2), which\n   prevents cookie-pairs from being separated into different\
    \ name-value\n   pairs.  This can significantly reduce compression efficiency\
    \ as\n   individual cookie-pairs are updated.\n   To allow for better compression\
    \ efficiency, the Cookie header field\n   MAY be split into separate header fields,\
    \ each with one or more\n   cookie-pairs.  If there are multiple Cookie header\
    \ fields after\n   decompression, these MUST be concatenated into a single octet\
    \ string\n   using the two-octet delimiter of 0x3B, 0x20 (the ASCII string \"\
    ; \")\n   before being passed into a non-HTTP/2 context, such as an HTTP/1.1\n\
    \   connection, or a generic HTTP server application.\n   Therefore, the following\
    \ two lists of Cookie header fields are\n   semantically equivalent.\n     cookie:\
    \ a=b; c=d; e=f\n     cookie: a=b\n     cookie: c=d\n     cookie: e=f\n"
- title: 8.1.2.6.  Malformed Requests and Responses
  contents:
  - "8.1.2.6.  Malformed Requests and Responses\n   A malformed request or response\
    \ is one that is an otherwise valid\n   sequence of HTTP/2 frames but is invalid\
    \ due to the presence of\n   extraneous frames, prohibited header fields, the\
    \ absence of mandatory\n   header fields, or the inclusion of uppercase header\
    \ field names.\n   A request or response that includes a payload body can include\
    \ a\n   content-length header field.  A request or response is also malformed\n\
    \   if the value of a content-length header field does not equal the sum\n   of\
    \ the DATA frame payload lengths that form the body.  A response\n   that is defined\
    \ to have no payload, as described in [RFC7230],\n   Section 3.3.2, can have a\
    \ non-zero content-length header field, even\n   though no content is included\
    \ in DATA frames.\n   Intermediaries that process HTTP requests or responses (i.e.,\
    \ any\n   intermediary not acting as a tunnel) MUST NOT forward a malformed\n\
    \   request or response.  Malformed requests or responses that are\n   detected\
    \ MUST be treated as a stream error (Section 5.4.2) of type\n   PROTOCOL_ERROR.\n\
    \   For malformed requests, a server MAY send an HTTP response prior to\n   closing\
    \ or resetting the stream.  Clients MUST NOT accept a malformed\n   response.\
    \  Note that these requirements are intended to protect\n   against several types\
    \ of common attacks against HTTP; they are\n   deliberately strict because being\
    \ permissive can expose\n   implementations to these vulnerabilities.\n"
- title: 8.1.3.  Examples
  contents:
  - "8.1.3.  Examples\n   This section shows HTTP/1.1 requests and responses, with\n\
    \   illustrations of equivalent HTTP/2 requests and responses.\n   An HTTP GET\
    \ request includes request header fields and no payload\n   body and is therefore\
    \ transmitted as a single HEADERS frame, followed\n   by zero or more CONTINUATION\
    \ frames containing the serialized block\n   of request header fields.  The HEADERS\
    \ frame in the following has\n   both the END_HEADERS and END_STREAM flags set;\
    \ no CONTINUATION frames\n   are sent.\n     GET /resource HTTP/1.1          \
    \ HEADERS\n     Host: example.org          ==>     + END_STREAM\n     Accept:\
    \ image/jpeg                 + END_HEADERS\n                                 \
    \         :method = GET\n                                          :scheme = https\n\
    \                                          :path = /resource\n               \
    \                           host = example.org\n                             \
    \             accept = image/jpeg\n   Similarly, a response that includes only\
    \ response header fields is\n   transmitted as a HEADERS frame (again, followed\
    \ by zero or more\n   CONTINUATION frames) containing the serialized block of\
    \ response\n   header fields.\n     HTTP/1.1 304 Not Modified        HEADERS\n\
    \     ETag: \"xyzzy\"              ==>     + END_STREAM\n     Expires: Thu, 23\
    \ Jan ...           + END_HEADERS\n                                          :status\
    \ = 304\n                                          etag = \"xyzzy\"\n        \
    \                                  expires = Thu, 23 Jan ...\n   An HTTP POST\
    \ request that includes request header fields and payload\n   data is transmitted\
    \ as one HEADERS frame, followed by zero or more\n   CONTINUATION frames containing\
    \ the request header fields, followed by\n   one or more DATA frames, with the\
    \ last CONTINUATION (or HEADERS)\n   frame having the END_HEADERS flag set and\
    \ the final DATA frame having\n   the END_STREAM flag set:\n     POST /resource\
    \ HTTP/1.1          HEADERS\n     Host: example.org          ==>     - END_STREAM\n\
    \     Content-Type: image/jpeg           - END_HEADERS\n     Content-Length: 123\
    \                  :method = POST\n                                          :path\
    \ = /resource\n     {binary data}                        :scheme = https\n   \
    \                                   CONTINUATION\n                           \
    \             + END_HEADERS\n                                          content-type\
    \ = image/jpeg\n                                          host = example.org\n\
    \                                          content-length = 123\n            \
    \                          DATA\n                                        + END_STREAM\n\
    \                                      {binary data}\n   Note that data contributing\
    \ to any given header field could be spread\n   between header block fragments.\
    \  The allocation of header fields to\n   frames in this example is illustrative\
    \ only.\n   A response that includes header fields and payload data is\n   transmitted\
    \ as a HEADERS frame, followed by zero or more CONTINUATION\n   frames, followed\
    \ by one or more DATA frames, with the last DATA frame\n   in the sequence having\
    \ the END_STREAM flag set:\n     HTTP/1.1 200 OK                  HEADERS\n  \
    \   Content-Type: image/jpeg   ==>     - END_STREAM\n     Content-Length: 123\
    \                + END_HEADERS\n                                          :status\
    \ = 200\n     {binary data}                        content-type = image/jpeg\n\
    \                                          content-length = 123\n            \
    \                          DATA\n                                        + END_STREAM\n\
    \                                      {binary data}\n   An informational response\
    \ using a 1xx status code other than 101 is\n   transmitted as a HEADERS frame,\
    \ followed by zero or more CONTINUATION\n   frames.\n   Trailing header fields\
    \ are sent as a header block after both the\n   request or response header block\
    \ and all the DATA frames have been\n   sent.  The HEADERS frame starting the\
    \ trailers header block has the\n   END_STREAM flag set.\n   The following example\
    \ includes both a 100 (Continue) status code,\n   which is sent in response to\
    \ a request containing a \"100-continue\"\n   token in the Expect header field,\
    \ and trailing header fields:\n     HTTP/1.1 100 Continue            HEADERS\n\
    \     Extension-Field: bar       ==>     - END_STREAM\n                      \
    \                  + END_HEADERS\n                                          :status\
    \ = 100\n                                          extension-field = bar\n   \
    \  HTTP/1.1 200 OK                  HEADERS\n     Content-Type: image/jpeg   ==>\
    \     - END_STREAM\n     Transfer-Encoding: chunked         + END_HEADERS\n  \
    \   Trailer: Foo                         :status = 200\n                     \
    \                     content-length = 123\n     123                         \
    \         content-type = image/jpeg\n     {binary data}                      \
    \  trailer = Foo\n     0\n     Foo: bar                         DATA\n       \
    \                                 - END_STREAM\n                             \
    \         {binary data}\n                                      HEADERS\n     \
    \                                   + END_STREAM\n                           \
    \             + END_HEADERS\n                                          foo = bar\n"
- title: 8.1.4.  Request Reliability Mechanisms in HTTP/2
  contents:
  - "8.1.4.  Request Reliability Mechanisms in HTTP/2\n   In HTTP/1.1, an HTTP client\
    \ is unable to retry a non-idempotent\n   request when an error occurs because\
    \ there is no means to determine\n   the nature of the error.  It is possible\
    \ that some server processing\n   occurred prior to the error, which could result\
    \ in undesirable\n   effects if the request were reattempted.\n   HTTP/2 provides\
    \ two mechanisms for providing a guarantee to a client\n   that a request has\
    \ not been processed:\n   o  The GOAWAY frame indicates the highest stream number\
    \ that might\n      have been processed.  Requests on streams with higher numbers\
    \ are\n      therefore guaranteed to be safe to retry.\n   o  The REFUSED_STREAM\
    \ error code can be included in a RST_STREAM\n      frame to indicate that the\
    \ stream is being closed prior to any\n      processing having occurred.  Any\
    \ request that was sent on the\n      reset stream can be safely retried.\n  \
    \ Requests that have not been processed have not failed; clients MAY\n   automatically\
    \ retry them, even those with non-idempotent methods.\n   A server MUST NOT indicate\
    \ that a stream has not been processed\n   unless it can guarantee that fact.\
    \  If frames that are on a stream\n   are passed to the application layer for\
    \ any stream, then\n   REFUSED_STREAM MUST NOT be used for that stream, and a\
    \ GOAWAY frame\n   MUST include a stream identifier that is greater than or equal\
    \ to the\n   given stream identifier.\n   In addition to these mechanisms, the\
    \ PING frame provides a way for a\n   client to easily test a connection.  Connections\
    \ that remain idle can\n   become broken as some middleboxes (for instance, network\
    \ address\n   translators or load balancers) silently discard connection bindings.\n\
    \   The PING frame allows a client to safely test whether a connection is\n  \
    \ still active without sending a request.\n"
- title: 8.2.  Server Push
  contents:
  - "8.2.  Server Push\n   HTTP/2 allows a server to pre-emptively send (or \"push\"\
    ) responses\n   (along with corresponding \"promised\" requests) to a client in\n\
    \   association with a previous client-initiated request.  This can be\n   useful\
    \ when the server knows the client will need to have those\n   responses available\
    \ in order to fully process the response to the\n   original request.\n   A client\
    \ can request that server push be disabled, though this is\n   negotiated for\
    \ each hop independently.  The SETTINGS_ENABLE_PUSH\n   setting can be set to\
    \ 0 to indicate that server push is disabled.\n   Promised requests MUST be cacheable\
    \ (see [RFC7231], Section 4.2.3),\n   MUST be safe (see [RFC7231], Section 4.2.1),\
    \ and MUST NOT include a\n   request body.  Clients that receive a promised request\
    \ that is not\n   cacheable, that is not known to be safe, or that indicates the\n\
    \   presence of a request body MUST reset the promised stream with a\n   stream\
    \ error (Section 5.4.2) of type PROTOCOL_ERROR.  Note this could\n   result in\
    \ the promised stream being reset if the client does not\n   recognize a newly\
    \ defined method as being safe.\n   Pushed responses that are cacheable (see [RFC7234],\
    \ Section 3) can be\n   stored by the client, if it implements an HTTP cache.\
    \  Pushed\n   responses are considered successfully validated on the origin server\n\
    \   (e.g., if the \"no-cache\" cache response directive is present\n   ([RFC7234],\
    \ Section 5.2.2)) while the stream identified by the\n   promised stream ID is\
    \ still open.\n   Pushed responses that are not cacheable MUST NOT be stored by\
    \ any\n   HTTP cache.  They MAY be made available to the application\n   separately.\n\
    \   The server MUST include a value in the \":authority\" pseudo-header\n   field\
    \ for which the server is authoritative (see Section 10.1).  A\n   client MUST\
    \ treat a PUSH_PROMISE for which the server is not\n   authoritative as a stream\
    \ error (Section 5.4.2) of type\n   PROTOCOL_ERROR.\n   An intermediary can receive\
    \ pushes from the server and choose not to\n   forward them on to the client.\
    \  In other words, how to make use of\n   the pushed information is up to that\
    \ intermediary.  Equally, the\n   intermediary might choose to make additional\
    \ pushes to the client,\n   without any action taken by the server.\n   A client\
    \ cannot push.  Thus, servers MUST treat the receipt of a\n   PUSH_PROMISE frame\
    \ as a connection error (Section 5.4.1) of type\n   PROTOCOL_ERROR.  Clients MUST\
    \ reject any attempt to change the\n   SETTINGS_ENABLE_PUSH setting to a value\
    \ other than 0 by treating the\n   message as a connection error (Section 5.4.1)\
    \ of type PROTOCOL_ERROR.\n"
- title: 8.2.1.  Push Requests
  contents:
  - "8.2.1.  Push Requests\n   Server push is semantically equivalent to a server\
    \ responding to a\n   request; however, in this case, that request is also sent\
    \ by the\n   server, as a PUSH_PROMISE frame.\n   The PUSH_PROMISE frame includes\
    \ a header block that contains a\n   complete set of request header fields that\
    \ the server attributes to\n   the request.  It is not possible to push a response\
    \ to a request that\n   includes a request body.\n   Pushed responses are always\
    \ associated with an explicit request from\n   the client.  The PUSH_PROMISE frames\
    \ sent by the server are sent on\n   that explicit request's stream.  The PUSH_PROMISE\
    \ frame also includes\n   a promised stream identifier, chosen from the stream\
    \ identifiers\n   available to the server (see Section 5.1.1).\n   The header\
    \ fields in PUSH_PROMISE and any subsequent CONTINUATION\n   frames MUST be a\
    \ valid and complete set of request header fields\n   (Section 8.1.2.3).  The\
    \ server MUST include a method in the \":method\"\n   pseudo-header field that\
    \ is safe and cacheable.  If a client receives\n   a PUSH_PROMISE that does not\
    \ include a complete and valid set of\n   header fields or the \":method\" pseudo-header\
    \ field identifies a\n   method that is not safe, it MUST respond with a stream\
    \ error\n   (Section 5.4.2) of type PROTOCOL_ERROR.\n   The server SHOULD send\
    \ PUSH_PROMISE (Section 6.6) frames prior to\n   sending any frames that reference\
    \ the promised responses.  This\n   avoids a race where clients issue requests\
    \ prior to receiving any\n   PUSH_PROMISE frames.\n   For example, if the server\
    \ receives a request for a document\n   containing embedded links to multiple\
    \ image files and the server\n   chooses to push those additional images to the\
    \ client, sending\n   PUSH_PROMISE frames before the DATA frames that contain\
    \ the image\n   links ensures that the client is able to see that a resource will\
    \ be\n   pushed before discovering embedded links.  Similarly, if the server\n\
    \   pushes responses referenced by the header block (for instance, in\n   Link\
    \ header fields), sending a PUSH_PROMISE before sending the header\n   block ensures\
    \ that clients do not request those resources.\n   PUSH_PROMISE frames MUST NOT\
    \ be sent by the client.\n   PUSH_PROMISE frames can be sent by the server in\
    \ response to any\n   client-initiated stream, but the stream MUST be in either\
    \ the \"open\"\n   or \"half-closed (remote)\" state with respect to the server.\n\
    \   PUSH_PROMISE frames are interspersed with the frames that comprise a\n   response,\
    \ though they cannot be interspersed with HEADERS and\n   CONTINUATION frames\
    \ that comprise a single header block.\n   Sending a PUSH_PROMISE frame creates\
    \ a new stream and puts the stream\n   into the \"reserved (local)\" state for\
    \ the server and the \"reserved\n   (remote)\" state for the client.\n"
- title: 8.2.2.  Push Responses
  contents:
  - "8.2.2.  Push Responses\n   After sending the PUSH_PROMISE frame, the server can\
    \ begin delivering\n   the pushed response as a response (Section 8.1.2.4) on\
    \ a server-\n   initiated stream that uses the promised stream identifier.  The\n\
    \   server uses this stream to transmit an HTTP response, using the same\n   sequence\
    \ of frames as defined in Section 8.1.  This stream becomes\n   \"half-closed\"\
    \ to the client (Section 5.1) after the initial HEADERS\n   frame is sent.\n \
    \  Once a client receives a PUSH_PROMISE frame and chooses to accept the\n   pushed\
    \ response, the client SHOULD NOT issue any requests for the\n   promised response\
    \ until after the promised stream has closed.\n   If the client determines, for\
    \ any reason, that it does not wish to\n   receive the pushed response from the\
    \ server or if the server takes\n   too long to begin sending the promised response,\
    \ the client can send\n   a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM\
    \ code\n   and referencing the pushed stream's identifier.\n   A client can use\
    \ the SETTINGS_MAX_CONCURRENT_STREAMS setting to limit\n   the number of responses\
    \ that can be concurrently pushed by a server.\n   Advertising a SETTINGS_MAX_CONCURRENT_STREAMS\
    \ value of zero disables\n   server push by preventing the server from creating\
    \ the necessary\n   streams.  This does not prohibit a server from sending PUSH_PROMISE\n\
    \   frames; clients need to reset any promised streams that are not\n   wanted.\n\
    \   Clients receiving a pushed response MUST validate that either the\n   server\
    \ is authoritative (see Section 10.1) or the proxy that provided\n   the pushed\
    \ response is configured for the corresponding request.  For\n   example, a server\
    \ that offers a certificate for only the\n   \"example.com\" DNS-ID or Common\
    \ Name is not permitted to push a\n   response for \"https://www.example.org/doc\"\
    .\n   The response for a PUSH_PROMISE stream begins with a HEADERS frame,\n  \
    \ which immediately puts the stream into the \"half-closed (remote)\"\n   state\
    \ for the server and \"half-closed (local)\" state for the client,\n   and ends\
    \ with a frame bearing END_STREAM, which places the stream in\n   the \"closed\"\
    \ state.\n      Note: The client never sends a frame with the END_STREAM flag\
    \ for\n      a server push.\n"
- title: 8.3.  The CONNECT Method
  contents:
  - "8.3.  The CONNECT Method\n   In HTTP/1.x, the pseudo-method CONNECT ([RFC7231],\
    \ Section 4.3.6) is\n   used to convert an HTTP connection into a tunnel to a\
    \ remote host.\n   CONNECT is primarily used with HTTP proxies to establish a\
    \ TLS\n   session with an origin server for the purposes of interacting with\n\
    \   \"https\" resources.\n   In HTTP/2, the CONNECT method is used to establish\
    \ a tunnel over a\n   single HTTP/2 stream to a remote host for similar purposes.\
    \  The HTTP\n   header field mapping works as defined in Section 8.1.2.3 (\"Request\n\
    \   Pseudo-Header Fields\"), with a few differences.  Specifically:\n   o  The\
    \ \":method\" pseudo-header field is set to \"CONNECT\".\n   o  The \":scheme\"\
    \ and \":path\" pseudo-header fields MUST be omitted.\n   o  The \":authority\"\
    \ pseudo-header field contains the host and port to\n      connect to (equivalent\
    \ to the authority-form of the request-target\n      of CONNECT requests (see\
    \ [RFC7230], Section 5.3)).\n   A CONNECT request that does not conform to these\
    \ restrictions is\n   malformed (Section 8.1.2.6).\n   A proxy that supports CONNECT\
    \ establishes a TCP connection [TCP] to\n   the server identified in the \":authority\"\
    \ pseudo-header field.  Once\n   this connection is successfully established,\
    \ the proxy sends a\n   HEADERS frame containing a 2xx series status code to the\
    \ client, as\n   defined in [RFC7231], Section 4.3.6.\n   After the initial HEADERS\
    \ frame sent by each peer, all subsequent\n   DATA frames correspond to data sent\
    \ on the TCP connection.  The\n   payload of any DATA frames sent by the client\
    \ is transmitted by the\n   proxy to the TCP server; data received from the TCP\
    \ server is\n   assembled into DATA frames by the proxy.  Frame types other than\
    \ DATA\n   or stream management frames (RST_STREAM, WINDOW_UPDATE, and PRIORITY)\n\
    \   MUST NOT be sent on a connected stream and MUST be treated as a\n   stream\
    \ error (Section 5.4.2) if received.\n   The TCP connection can be closed by either\
    \ peer.  The END_STREAM flag\n   on a DATA frame is treated as being equivalent\
    \ to the TCP FIN bit.  A\n   client is expected to send a DATA frame with the\
    \ END_STREAM flag set\n   after receiving a frame bearing the END_STREAM flag.\
    \  A proxy that\n   receives a DATA frame with the END_STREAM flag set sends the\
    \ attached\n   data with the FIN bit set on the last TCP segment.  A proxy that\n\
    \   receives a TCP segment with the FIN bit set sends a DATA frame with\n   the\
    \ END_STREAM flag set.  Note that the final TCP segment or DATA\n   frame could\
    \ be empty.\n   A TCP connection error is signaled with RST_STREAM.  A proxy treats\n\
    \   any error in the TCP connection, which includes receiving a TCP\n   segment\
    \ with the RST bit set, as a stream error (Section 5.4.2) of\n   type CONNECT_ERROR.\
    \  Correspondingly, a proxy MUST send a TCP segment\n   with the RST bit set if\
    \ it detects an error with the stream or the\n   HTTP/2 connection.\n"
- title: 9.  Additional HTTP Requirements/Considerations
  contents:
  - "9.  Additional HTTP Requirements/Considerations\n   This section outlines attributes\
    \ of the HTTP protocol that improve\n   interoperability, reduce exposure to known\
    \ security vulnerabilities,\n   or reduce the potential for implementation variation.\n"
- title: 9.1.  Connection Management
  contents:
  - "9.1.  Connection Management\n   HTTP/2 connections are persistent.  For best\
    \ performance, it is\n   expected that clients will not close connections until\
    \ it is\n   determined that no further communication with a server is necessary\n\
    \   (for example, when a user navigates away from a particular web page)\n   or\
    \ until the server closes the connection.\n   Clients SHOULD NOT open more than\
    \ one HTTP/2 connection to a given\n   host and port pair, where the host is derived\
    \ from a URI, a selected\n   alternative service [ALT-SVC], or a configured proxy.\n\
    \   A client can create additional connections as replacements, either to\n  \
    \ replace connections that are near to exhausting the available stream\n   identifier\
    \ space (Section 5.1.1), to refresh the keying material for\n   a TLS connection,\
    \ or to replace connections that have encountered\n   errors (Section 5.4.1).\n\
    \   A client MAY open multiple connections to the same IP address and TCP\n  \
    \ port using different Server Name Indication [TLS-EXT] values or to\n   provide\
    \ different TLS client certificates but SHOULD avoid creating\n   multiple connections\
    \ with the same configuration.\n   Servers are encouraged to maintain open connections\
    \ for as long as\n   possible but are permitted to terminate idle connections\
    \ if\n   necessary.  When either endpoint chooses to close the transport-layer\n\
    \   TCP connection, the terminating endpoint SHOULD first send a GOAWAY\n   (Section\
    \ 6.8) frame so that both endpoints can reliably determine\n   whether previously\
    \ sent frames have been processed and gracefully\n   complete or terminate any\
    \ necessary remaining tasks.\n"
- title: 9.1.1.  Connection Reuse
  contents:
  - "9.1.1.  Connection Reuse\n   Connections that are made to an origin server, either\
    \ directly or\n   through a tunnel created using the CONNECT method (Section 8.3),\
    \ MAY\n   be reused for requests with multiple different URI authority\n   components.\
    \  A connection can be reused as long as the origin server\n   is authoritative\
    \ (Section 10.1).  For TCP connections without TLS,\n   this depends on the host\
    \ having resolved to the same IP address.\n   For \"https\" resources, connection\
    \ reuse additionally depends on\n   having a certificate that is valid for the\
    \ host in the URI.  The\n   certificate presented by the server MUST satisfy any\
    \ checks that the\n   client would perform when forming a new TLS connection for\
    \ the host\n   in the URI.\n   An origin server might offer a certificate with\
    \ multiple\n   \"subjectAltName\" attributes or names with wildcards, one of which\
    \ is\n   valid for the authority in the URI.  For example, a certificate with\n\
    \   a \"subjectAltName\" of \"*.example.com\" might permit the use of the\n  \
    \ same connection for requests to URIs starting with\n   \"https://a.example.com/\"\
    \ and \"https://b.example.com/\".\n   In some deployments, reusing a connection\
    \ for multiple origins can\n   result in requests being directed to the wrong\
    \ origin server.  For\n   example, TLS termination might be performed by a middlebox\
    \ that uses\n   the TLS Server Name Indication (SNI) [TLS-EXT] extension to select\
    \ an\n   origin server.  This means that it is possible for clients to send\n\
    \   confidential information to servers that might not be the intended\n   target\
    \ for the request, even though the server is otherwise\n   authoritative.\n  \
    \ A server that does not wish clients to reuse connections can indicate\n   that\
    \ it is not authoritative for a request by sending a 421\n   (Misdirected Request)\
    \ status code in response to the request (see\n   Section 9.1.2).\n   A client\
    \ that is configured to use a proxy over HTTP/2 directs\n   requests to that proxy\
    \ through a single connection.  That is, all\n   requests sent via a proxy reuse\
    \ the connection to the proxy.\n"
- title: 9.1.2.  The 421 (Misdirected Request) Status Code
  contents:
  - "9.1.2.  The 421 (Misdirected Request) Status Code\n   The 421 (Misdirected Request)\
    \ status code indicates that the request\n   was directed at a server that is\
    \ not able to produce a response.\n   This can be sent by a server that is not\
    \ configured to produce\n   responses for the combination of scheme and authority\
    \ that are\n   included in the request URI.\n   Clients receiving a 421 (Misdirected\
    \ Request) response from a server\n   MAY retry the request -- whether the request\
    \ method is idempotent or\n   not -- over a different connection.  This is possible\
    \ if a connection\n   is reused (Section 9.1.1) or if an alternative service is\
    \ selected\n   [ALT-SVC].\n   This status code MUST NOT be generated by proxies.\n\
    \   A 421 response is cacheable by default, i.e., unless otherwise\n   indicated\
    \ by the method definition or explicit cache controls (see\n   Section 4.2.2 of\
    \ [RFC7234]).\n"
- title: 9.2.  Use of TLS Features
  contents:
  - "9.2.  Use of TLS Features\n   Implementations of HTTP/2 MUST use TLS version\
    \ 1.2 [TLS12] or higher\n   for HTTP/2 over TLS.  The general TLS usage guidance\
    \ in [TLSBCP]\n   SHOULD be followed, with some additional restrictions that are\n\
    \   specific to HTTP/2.\n   The TLS implementation MUST support the Server Name\
    \ Indication (SNI)\n   [TLS-EXT] extension to TLS.  HTTP/2 clients MUST indicate\
    \ the target\n   domain name when negotiating TLS.\n   Deployments of HTTP/2 that\
    \ negotiate TLS 1.3 or higher need only\n   support and use the SNI extension;\
    \ deployments of TLS 1.2 are subject\n   to the requirements in the following\
    \ sections.  Implementations are\n   encouraged to provide defaults that comply,\
    \ but it is recognized that\n   deployments are ultimately responsible for compliance.\n"
- title: 9.2.1.  TLS 1.2 Features
  contents:
  - "9.2.1.  TLS 1.2 Features\n   This section describes restrictions on the TLS 1.2\
    \ feature set that\n   can be used with HTTP/2.  Due to deployment limitations,\
    \ it might not\n   be possible to fail TLS negotiation when these restrictions\
    \ are not\n   met.  An endpoint MAY immediately terminate an HTTP/2 connection\
    \ that\n   does not meet these TLS requirements with a connection error\n   (Section\
    \ 5.4.1) of type INADEQUATE_SECURITY.\n   A deployment of HTTP/2 over TLS 1.2\
    \ MUST disable compression.  TLS\n   compression can lead to the exposure of information\
    \ that would not\n   otherwise be revealed [RFC3749].  Generic compression is\
    \ unnecessary\n   since HTTP/2 provides compression features that are more aware\
    \ of\n   context and therefore likely to be more appropriate for use for\n   performance,\
    \ security, or other reasons.\n   A deployment of HTTP/2 over TLS 1.2 MUST disable\
    \ renegotiation.  An\n   endpoint MUST treat a TLS renegotiation as a connection\
    \ error\n   (Section 5.4.1) of type PROTOCOL_ERROR.  Note that disabling\n   renegotiation\
    \ can result in long-lived connections becoming unusable\n   due to limits on\
    \ the number of messages the underlying cipher suite\n   can encipher.\n   An\
    \ endpoint MAY use renegotiation to provide confidentiality\n   protection for\
    \ client credentials offered in the handshake, but any\n   renegotiation MUST\
    \ occur prior to sending the connection preface.  A\n   server SHOULD request\
    \ a client certificate if it sees a renegotiation\n   request immediately after\
    \ establishing a connection.\n   This effectively prevents the use of renegotiation\
    \ in response to a\n   request for a specific protected resource.  A future specification\n\
    \   might provide a way to support this use case.  Alternatively, a\n   server\
    \ might use an error (Section 5.4) of type HTTP_1_1_REQUIRED to\n   request the\
    \ client use a protocol that supports renegotiation.\n   Implementations MUST\
    \ support ephemeral key exchange sizes of at least\n   2048 bits for cipher suites\
    \ that use ephemeral finite field Diffie-\n   Hellman (DHE) [TLS12] and 224 bits\
    \ for cipher suites that use\n   ephemeral elliptic curve Diffie-Hellman (ECDHE)\
    \ [RFC4492].  Clients\n   MUST accept DHE sizes of up to 4096 bits.  Endpoints\
    \ MAY treat\n   negotiation of key sizes smaller than the lower limits as a\n\
    \   connection error (Section 5.4.1) of type INADEQUATE_SECURITY.\n"
- title: 9.2.2.  TLS 1.2 Cipher Suites
  contents:
  - "9.2.2.  TLS 1.2 Cipher Suites\n   A deployment of HTTP/2 over TLS 1.2 SHOULD\
    \ NOT use any of the cipher\n   suites that are listed in the cipher suite black\
    \ list (Appendix A).\n   Endpoints MAY choose to generate a connection error (Section\
    \ 5.4.1)\n   of type INADEQUATE_SECURITY if one of the cipher suites from the\n\
    \   black list is negotiated.  A deployment that chooses to use a black-\n   listed\
    \ cipher suite risks triggering a connection error unless the\n   set of potential\
    \ peers is known to accept that cipher suite.\n   Implementations MUST NOT generate\
    \ this error in reaction to the\n   negotiation of a cipher suite that is not\
    \ on the black list.\n   Consequently, when clients offer a cipher suite that\
    \ is not on the\n   black list, they have to be prepared to use that cipher suite\
    \ with\n   HTTP/2.\n   The black list includes the cipher suite that TLS 1.2 makes\n\
    \   mandatory, which means that TLS 1.2 deployments could have non-\n   intersecting\
    \ sets of permitted cipher suites.  To avoid this problem\n   causing TLS handshake\
    \ failures, deployments of HTTP/2 that use TLS\n   1.2 MUST support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\
    \ [TLS-ECDHE]\n   with the P-256 elliptic curve [FIPS186].\n   Note that clients\
    \ might advertise support of cipher suites that are\n   on the black list in order\
    \ to allow for connection to servers that do\n   not support HTTP/2.  This allows\
    \ servers to select HTTP/1.1 with a\n   cipher suite that is on the HTTP/2 black\
    \ list.  However, this can\n   result in HTTP/2 being negotiated with a black-listed\
    \ cipher suite if\n   the application protocol and cipher suite are independently\
    \ selected.\n"
- title: 10.  Security Considerations
  contents:
  - '10.  Security Considerations

    '
- title: 10.1.  Server Authority
  contents:
  - "10.1.  Server Authority\n   HTTP/2 relies on the HTTP/1.1 definition of authority\
    \ for determining\n   whether a server is authoritative in providing a given response\
    \ (see\n   [RFC7230], Section 9.1).  This relies on local name resolution for\n\
    \   the \"http\" URI scheme and the authenticated server identity for the\n  \
    \ \"https\" scheme (see [RFC2818], Section 3).\n"
- title: 10.2.  Cross-Protocol Attacks
  contents:
  - "10.2.  Cross-Protocol Attacks\n   In a cross-protocol attack, an attacker causes\
    \ a client to initiate a\n   transaction in one protocol toward a server that\
    \ understands a\n   different protocol.  An attacker might be able to cause the\n\
    \   transaction to appear as a valid transaction in the second protocol.\n   In\
    \ combination with the capabilities of the web context, this can be\n   used to\
    \ interact with poorly protected servers in private networks.\n   Completing a\
    \ TLS handshake with an ALPN identifier for HTTP/2 can be\n   considered sufficient\
    \ protection against cross-protocol attacks.\n   ALPN provides a positive indication\
    \ that a server is willing to\n   proceed with HTTP/2, which prevents attacks\
    \ on other TLS-based\n   protocols.\n   The encryption in TLS makes it difficult\
    \ for attackers to control the\n   data that could be used in a cross-protocol\
    \ attack on a cleartext\n   protocol.\n   The cleartext version of HTTP/2 has\
    \ minimal protection against cross-\n   protocol attacks.  The connection preface\
    \ (Section 3.5) contains a\n   string that is designed to confuse HTTP/1.1 servers,\
    \ but no special\n   protection is offered for other protocols.  A server that\
    \ is willing\n   to ignore parts of an HTTP/1.1 request containing an Upgrade\
    \ header\n   field in addition to the client connection preface could be exposed\n\
    \   to a cross-protocol attack.\n"
- title: 10.3.  Intermediary Encapsulation Attacks
  contents:
  - "10.3.  Intermediary Encapsulation Attacks\n   The HTTP/2 header field encoding\
    \ allows the expression of names that\n   are not valid field names in the Internet\
    \ Message Syntax used by\n   HTTP/1.1.  Requests or responses containing invalid\
    \ header field\n   names MUST be treated as malformed (Section 8.1.2.6).  An\n\
    \   intermediary therefore cannot translate an HTTP/2 request or response\n  \
    \ containing an invalid field name into an HTTP/1.1 message.\n   Similarly, HTTP/2\
    \ allows header field values that are not valid.\n   While most of the values\
    \ that can be encoded will not alter header\n   field parsing, carriage return\
    \ (CR, ASCII 0xd), line feed (LF, ASCII\n   0xa), and the zero character (NUL,\
    \ ASCII 0x0) might be exploited by\n   an attacker if they are translated verbatim.\
    \  Any request or response\n   that contains a character not permitted in a header\
    \ field value MUST\n   be treated as malformed (Section 8.1.2.6).  Valid characters\
    \ are\n   defined by the \"field-content\" ABNF rule in Section 3.2 of [RFC7230].\n"
- title: 10.4.  Cacheability of Pushed Responses
  contents:
  - "10.4.  Cacheability of Pushed Responses\n   Pushed responses do not have an explicit\
    \ request from the client; the\n   request is provided by the server in the PUSH_PROMISE\
    \ frame.\n   Caching responses that are pushed is possible based on the guidance\n\
    \   provided by the origin server in the Cache-Control header field.\n   However,\
    \ this can cause issues if a single server hosts more than one\n   tenant.  For\
    \ example, a server might offer multiple users each a\n   small portion of its\
    \ URI space.\n   Where multiple tenants share space on the same server, that server\n\
    \   MUST ensure that tenants are not able to push representations of\n   resources\
    \ that they do not have authority over.  Failure to enforce\n   this would allow\
    \ a tenant to provide a representation that would be\n   served out of cache,\
    \ overriding the actual representation that the\n   authoritative tenant provides.\n\
    \   Pushed responses for which an origin server is not authoritative (see\n  \
    \ Section 10.1) MUST NOT be used or cached.\n"
- title: 10.5.  Denial-of-Service Considerations
  contents:
  - "10.5.  Denial-of-Service Considerations\n   An HTTP/2 connection can demand a\
    \ greater commitment of resources to\n   operate than an HTTP/1.1 connection.\
    \  The use of header compression\n   and flow control depend on a commitment of\
    \ resources for storing a\n   greater amount of state.  Settings for these features\
    \ ensure that\n   memory commitments for these features are strictly bounded.\n\
    \   The number of PUSH_PROMISE frames is not constrained in the same\n   fashion.\
    \  A client that accepts server push SHOULD limit the number\n   of streams it\
    \ allows to be in the \"reserved (remote)\" state.  An\n   excessive number of\
    \ server push streams can be treated as a stream\n   error (Section 5.4.2) of\
    \ type ENHANCE_YOUR_CALM.\n   Processing capacity cannot be guarded as effectively\
    \ as state\n   capacity.\n   The SETTINGS frame can be abused to cause a peer\
    \ to expend additional\n   processing time.  This might be done by pointlessly\
    \ changing SETTINGS\n   parameters, setting multiple undefined parameters, or\
    \ changing the\n   same setting multiple times in the same frame.  WINDOW_UPDATE\
    \ or\n   PRIORITY frames can be abused to cause an unnecessary waste of\n   resources.\n\
    \   Large numbers of small or empty frames can be abused to cause a peer\n   to\
    \ expend time processing frame headers.  Note, however, that some\n   uses are\
    \ entirely legitimate, such as the sending of an empty DATA or\n   CONTINUATION\
    \ frame at the end of a stream.\n   Header compression also offers some opportunities\
    \ to waste processing\n   resources; see Section 7 of [COMPRESSION] for more details\
    \ on\n   potential abuses.\n   Limits in SETTINGS parameters cannot be reduced\
    \ instantaneously,\n   which leaves an endpoint exposed to behavior from a peer\
    \ that could\n   exceed the new limits.  In particular, immediately after establishing\n\
    \   a connection, limits set by a server are not known to clients and\n   could\
    \ be exceeded without being an obvious protocol violation.\n   All these features\
    \ -- i.e., SETTINGS changes, small frames, header\n   compression -- have legitimate\
    \ uses.  These features become a burden\n   only when they are used unnecessarily\
    \ or to excess.\n   An endpoint that doesn't monitor this behavior exposes itself\
    \ to a\n   risk of denial-of-service attack.  Implementations SHOULD track the\n\
    \   use of these features and set limits on their use.  An endpoint MAY\n   treat\
    \ activity that is suspicious as a connection error\n   (Section 5.4.1) of type\
    \ ENHANCE_YOUR_CALM.\n"
- title: 10.5.1.  Limits on Header Block Size
  contents:
  - "10.5.1.  Limits on Header Block Size\n   A large header block (Section 4.3) can\
    \ cause an implementation to\n   commit a large amount of state.  Header fields\
    \ that are critical for\n   routing can appear toward the end of a header block,\
    \ which prevents\n   streaming of header fields to their ultimate destination.\
    \  This\n   ordering and other reasons, such as ensuring cache correctness, mean\n\
    \   that an endpoint might need to buffer the entire header block.  Since\n  \
    \ there is no hard limit to the size of a header block, some endpoints\n   could\
    \ be forced to commit a large amount of available memory for\n   header fields.\n\
    \   An endpoint can use the SETTINGS_MAX_HEADER_LIST_SIZE to advise peers\n  \
    \ of limits that might apply on the size of header blocks.  This\n   setting is\
    \ only advisory, so endpoints MAY choose to send header\n   blocks that exceed\
    \ this limit and risk having the request or response\n   being treated as malformed.\
    \  This setting is specific to a\n   connection, so any request or response could\
    \ encounter a hop with a\n   lower, unknown limit.  An intermediary can attempt\
    \ to avoid this\n   problem by passing on values presented by different peers,\
    \ but they\n   are not obligated to do so.\n   A server that receives a larger\
    \ header block than it is willing to\n   handle can send an HTTP 431 (Request\
    \ Header Fields Too Large) status\n   code [RFC6585].  A client can discard responses\
    \ that it cannot\n   process.  The header block MUST be processed to ensure a\
    \ consistent\n   connection state, unless the connection is closed.\n"
- title: 10.5.2.  CONNECT Issues
  contents:
  - "10.5.2.  CONNECT Issues\n   The CONNECT method can be used to create disproportionate\
    \ load on an\n   proxy, since stream creation is relatively inexpensive when compared\n\
    \   to the creation and maintenance of a TCP connection.  A proxy might\n   also\
    \ maintain some resources for a TCP connection beyond the closing\n   of the stream\
    \ that carries the CONNECT request, since the outgoing\n   TCP connection remains\
    \ in the TIME_WAIT state.  Therefore, a proxy\n   cannot rely on SETTINGS_MAX_CONCURRENT_STREAMS\
    \ alone to limit the\n   resources consumed by CONNECT requests.\n"
- title: 10.6.  Use of Compression
  contents:
  - "10.6.  Use of Compression\n   Compression can allow an attacker to recover secret\
    \ data when it is\n   compressed in the same context as data under attacker control.\n\
    \   HTTP/2 enables compression of header fields (Section 4.3); the\n   following\
    \ concerns also apply to the use of HTTP compressed content-\n   codings ([RFC7231],\
    \ Section 3.1.2.1).\n   There are demonstrable attacks on compression that exploit\
    \ the\n   characteristics of the web (e.g., [BREACH]).  The attacker induces\n\
    \   multiple requests containing varying plaintext, observing the length\n   of\
    \ the resulting ciphertext in each, which reveals a shorter length\n   when a\
    \ guess about the secret is correct.\n   Implementations communicating on a secure\
    \ channel MUST NOT compress\n   content that includes both confidential and attacker-controlled\
    \ data\n   unless separate compression dictionaries are used for each source of\n\
    \   data.  Compression MUST NOT be used if the source of data cannot be\n   reliably\
    \ determined.  Generic stream compression, such as that\n   provided by TLS, MUST\
    \ NOT be used with HTTP/2 (see Section 9.2).\n   Further considerations regarding\
    \ the compression of header fields are\n   described in [COMPRESSION].\n"
- title: 10.7.  Use of Padding
  contents:
  - "10.7.  Use of Padding\n   Padding within HTTP/2 is not intended as a replacement\
    \ for general\n   purpose padding, such as might be provided by TLS [TLS12]. \
    \ Redundant\n   padding could even be counterproductive.  Correct application\
    \ can\n   depend on having specific knowledge of the data that is being padded.\n\
    \   To mitigate attacks that rely on compression, disabling or limiting\n   compression\
    \ might be preferable to padding as a countermeasure.\n   Padding can be used\
    \ to obscure the exact size of frame content and is\n   provided to mitigate specific\
    \ attacks within HTTP, for example,\n   attacks where compressed content includes\
    \ both attacker-controlled\n   plaintext and secret data (e.g., [BREACH]).\n \
    \  Use of padding can result in less protection than might seem\n   immediately\
    \ obvious.  At best, padding only makes it more difficult\n   for an attacker\
    \ to infer length information by increasing the number\n   of frames an attacker\
    \ has to observe.  Incorrectly implemented\n   padding schemes can be easily defeated.\
    \  In particular, randomized\n   padding with a predictable distribution provides\
    \ very little\n   protection; similarly, padding payloads to a fixed size exposes\n\
    \   information as payload sizes cross the fixed-sized boundary, which\n   could\
    \ be possible if an attacker can control plaintext.\n   Intermediaries SHOULD\
    \ retain padding for DATA frames but MAY drop\n   padding for HEADERS and PUSH_PROMISE\
    \ frames.  A valid reason for an\n   intermediary to change the amount of padding\
    \ of frames is to improve\n   the protections that padding provides.\n"
- title: 10.8.  Privacy Considerations
  contents:
  - "10.8.  Privacy Considerations\n   Several characteristics of HTTP/2 provide an\
    \ observer an opportunity\n   to correlate actions of a single client or server\
    \ over time.  These\n   include the value of settings, the manner in which flow-control\n\
    \   windows are managed, the way priorities are allocated to streams, the\n  \
    \ timing of reactions to stimulus, and the handling of any features\n   that are\
    \ controlled by settings.\n   As far as these create observable differences in\
    \ behavior, they could\n   be used as a basis for fingerprinting a specific client,\
    \ as defined\n   in Section 1.8 of [HTML5].\n   HTTP/2's preference for using\
    \ a single TCP connection allows\n   correlation of a user's activity on a site.\
    \  Reusing connections for\n   different origins allows tracking across those\
    \ origins.\n   Because the PING and SETTINGS frames solicit immediate responses,\n\
    \   they can be used by an endpoint to measure latency to their peer.\n   This\
    \ might have privacy implications in certain scenarios.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   A string for identifying HTTP/2 is entered into\
    \ the \"Application-\n   Layer Protocol Negotiation (ALPN) Protocol IDs\" registry\
    \ established\n   in [TLS-ALPN].\n   This document establishes a registry for\
    \ frame types, settings, and\n   error codes.  These new registries appear in\
    \ the new \"Hypertext\n   Transfer Protocol version 2 (HTTP/2) Parameters\" section.\n\
    \   This document registers the HTTP2-Settings header field for use in\n   HTTP;\
    \ it also registers the 421 (Misdirected Request) status code.\n   This document\
    \ registers the \"PRI\" method for use in HTTP to avoid\n   collisions with the\
    \ connection preface (Section 3.5).\n"
- title: 11.1.  Registration of HTTP/2 Identification Strings
  contents:
  - "11.1.  Registration of HTTP/2 Identification Strings\n   This document creates\
    \ two registrations for the identification of\n   HTTP/2 (see Section 3.3) in\
    \ the \"Application-Layer Protocol\n   Negotiation (ALPN) Protocol IDs\" registry\
    \ established in [TLS-ALPN].\n   The \"h2\" string identifies HTTP/2 when used\
    \ over TLS:\n   Protocol:  HTTP/2 over TLS\n   Identification Sequence:  0x68\
    \ 0x32 (\"h2\")\n   Specification:  This document\n   The \"h2c\" string identifies\
    \ HTTP/2 when used over cleartext TCP:\n   Protocol:  HTTP/2 over TCP\n   Identification\
    \ Sequence:  0x68 0x32 0x63 (\"h2c\")\n   Specification:  This document\n"
- title: 11.2.  Frame Type Registry
  contents:
  - "11.2.  Frame Type Registry\n   This document establishes a registry for HTTP/2\
    \ frame type codes.\n   The \"HTTP/2 Frame Type\" registry manages an 8-bit space.\
    \  The \"HTTP/2\n   Frame Type\" registry operates under either of the \"IETF\
    \ Review\" or\n   \"IESG Approval\" policies [RFC5226] for values between 0x00\
    \ and 0xef,\n   with values between 0xf0 and 0xff being reserved for Experimental\n\
    \   Use.\n   New entries in this registry require the following information:\n\
    \   Frame Type:  A name or label for the frame type.\n   Code:  The 8-bit code\
    \ assigned to the frame type.\n   Specification:  A reference to a specification\
    \ that includes a\n      description of the frame layout, its semantics, and flags\
    \ that the\n      frame type uses, including any parts of the frame that are\n\
    \      conditionally present based on the value of flags.\n   The entries in the\
    \ following table are registered by this document.\n   +---------------+------+--------------+\n\
    \   | Frame Type    | Code | Section      |\n   +---------------+------+--------------+\n\
    \   | DATA          | 0x0  | Section 6.1  |\n   | HEADERS       | 0x1  | Section\
    \ 6.2  |\n   | PRIORITY      | 0x2  | Section 6.3  |\n   | RST_STREAM    | 0x3\
    \  | Section 6.4  |\n   | SETTINGS      | 0x4  | Section 6.5  |\n   | PUSH_PROMISE\
    \  | 0x5  | Section 6.6  |\n   | PING          | 0x6  | Section 6.7  |\n   | GOAWAY\
    \        | 0x7  | Section 6.8  |\n   | WINDOW_UPDATE | 0x8  | Section 6.9  |\n\
    \   | CONTINUATION  | 0x9  | Section 6.10 |\n   +---------------+------+--------------+\n"
- title: 11.3.  Settings Registry
  contents:
  - "11.3.  Settings Registry\n   This document establishes a registry for HTTP/2\
    \ settings.  The\n   \"HTTP/2 Settings\" registry manages a 16-bit space.  The\
    \ \"HTTP/2\n   Settings\" registry operates under the \"Expert Review\" policy\n\
    \   [RFC5226] for values in the range from 0x0000 to 0xefff, with values\n   between\
    \ and 0xf000 and 0xffff being reserved for Experimental Use.\n   New registrations\
    \ are advised to provide the following information:\n   Name:  A symbolic name\
    \ for the setting.  Specifying a setting name is\n      optional.\n   Code:  The\
    \ 16-bit code assigned to the setting.\n   Initial Value:  An initial value for\
    \ the setting.\n   Specification:  An optional reference to a specification that\n\
    \      describes the use of the setting.\n   The entries in the following table\
    \ are registered by this document.\n   +------------------------+------+---------------+---------------+\n\
    \   | Name                   | Code | Initial Value | Specification |\n   +------------------------+------+---------------+---------------+\n\
    \   | HEADER_TABLE_SIZE      | 0x1  | 4096          | Section 6.5.2 |\n   | ENABLE_PUSH\
    \            | 0x2  | 1             | Section 6.5.2 |\n   | MAX_CONCURRENT_STREAMS\
    \ | 0x3  | (infinite)    | Section 6.5.2 |\n   | INITIAL_WINDOW_SIZE    | 0x4\
    \  | 65535         | Section 6.5.2 |\n   | MAX_FRAME_SIZE         | 0x5  | 16384\
    \         | Section 6.5.2 |\n   | MAX_HEADER_LIST_SIZE   | 0x6  | (infinite) \
    \   | Section 6.5.2 |\n   +------------------------+------+---------------+---------------+\n"
- title: 11.4.  Error Code Registry
  contents:
  - "11.4.  Error Code Registry\n   This document establishes a registry for HTTP/2\
    \ error codes.  The\n   \"HTTP/2 Error Code\" registry manages a 32-bit space.\
    \  The \"HTTP/2\n   Error Code\" registry operates under the \"Expert Review\"\
    \ policy\n   [RFC5226].\n   Registrations for error codes are required to include\
    \ a description\n   of the error code.  An expert reviewer is advised to examine\
    \ new\n   registrations for possible duplication with existing error codes.\n\
    \   Use of existing registrations is to be encouraged, but not mandated.\n   New\
    \ registrations are advised to provide the following information:\n   Name:  A\
    \ name for the error code.  Specifying an error code name is\n      optional.\n\
    \   Code:  The 32-bit error code value.\n   Description:  A brief description\
    \ of the error code semantics, longer\n      if no detailed specification is provided.\n\
    \   Specification:  An optional reference for a specification that\n      defines\
    \ the error code.\n   The entries in the following table are registered by this\
    \ document.\n   +---------------------+------+----------------------+---------------+\n\
    \   | Name                | Code | Description          | Specification |\n  \
    \ +---------------------+------+----------------------+---------------+\n   |\
    \ NO_ERROR            | 0x0  | Graceful shutdown    | Section 7     |\n   | PROTOCOL_ERROR\
    \      | 0x1  | Protocol error       | Section 7     |\n   |                 \
    \    |      | detected             |               |\n   | INTERNAL_ERROR    \
    \  | 0x2  | Implementation fault | Section 7     |\n   | FLOW_CONTROL_ERROR  |\
    \ 0x3  | Flow-control limits  | Section 7     |\n   |                     |  \
    \    | exceeded             |               |\n   | SETTINGS_TIMEOUT    | 0x4\
    \  | Settings not         | Section 7     |\n   |                     |      |\
    \ acknowledged         |               |\n   | STREAM_CLOSED       | 0x5  | Frame\
    \ received for   | Section 7     |\n   |                     |      | closed stream\
    \        |               |\n   | FRAME_SIZE_ERROR    | 0x6  | Frame size incorrect\
    \ | Section 7     |\n   | REFUSED_STREAM      | 0x7  | Stream not processed |\
    \ Section 7     |\n   | CANCEL              | 0x8  | Stream cancelled     | Section\
    \ 7     |\n   | COMPRESSION_ERROR   | 0x9  | Compression state    | Section 7\
    \     |\n   |                     |      | not updated          |            \
    \   |\n   | CONNECT_ERROR       | 0xa  | TCP connection error | Section 7    \
    \ |\n   |                     |      | for CONNECT method   |               |\n\
    \   | ENHANCE_YOUR_CALM   | 0xb  | Processing capacity  | Section 7     |\n  \
    \ |                     |      | exceeded             |               |\n   |\
    \ INADEQUATE_SECURITY | 0xc  | Negotiated TLS       | Section 7     |\n   |  \
    \                   |      | parameters not       |               |\n   |    \
    \                 |      | acceptable           |               |\n   | HTTP_1_1_REQUIRED\
    \   | 0xd  | Use HTTP/1.1 for the | Section 7     |\n   |                    \
    \ |      | request              |               |\n   +---------------------+------+----------------------+---------------+\n"
- title: 11.5.  HTTP2-Settings Header Field Registration
  contents:
  - "11.5.  HTTP2-Settings Header Field Registration\n   This section registers the\
    \ HTTP2-Settings header field in the\n   \"Permanent Message Header Field Names\"\
    \ registry [BCP90].\n   Header field name:  HTTP2-Settings\n   Applicable protocol:\
    \  http\n   Status:  standard\n   Author/Change controller:  IETF\n   Specification\
    \ document(s):  Section 3.2.1 of this document\n   Related information:  This\
    \ header field is only used by an HTTP/2\n      client for Upgrade-based negotiation.\n"
- title: 11.6.  PRI Method Registration
  contents:
  - "11.6.  PRI Method Registration\n   This section registers the \"PRI\" method\
    \ in the \"HTTP Method Registry\"\n   ([RFC7231], Section 8.1).\n   Method Name:\
    \  PRI\n   Safe:  Yes\n   Idempotent:  Yes\n   Specification document(s):  Section\
    \ 3.5 of this document\n   Related information:  This method is never used by\
    \ an actual client.\n      This method will appear to be used when an HTTP/1.1\
    \ server or\n      intermediary attempts to parse an HTTP/2 connection preface.\n"
- title: 11.7.  The 421 (Misdirected Request) HTTP Status Code
  contents:
  - "11.7.  The 421 (Misdirected Request) HTTP Status Code\n   This document registers\
    \ the 421 (Misdirected Request) HTTP status\n   code in the \"HTTP Status Codes\"\
    \ registry ([RFC7231], Section 8.2).\n   Status Code:  421\n   Short Description:\
    \  Misdirected Request\n   Specification:  Section 9.1.2 of this document\n"
- title: 11.8.  The h2c Upgrade Token
  contents:
  - "11.8.  The h2c Upgrade Token\n   This document registers the \"h2c\" upgrade\
    \ token in the \"HTTP Upgrade\n   Tokens\" registry ([RFC7230], Section 8.6).\n\
    \   Value:  h2c\n   Description:  Hypertext Transfer Protocol version 2 (HTTP/2)\n\
    \   Expected Version Tokens:  None\n   Reference:  Section 3.2 of this document\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [COMPRESSION] Peon, R. and H. Ruellan, \"HPACK:\
    \ Header Compression for\n                 HTTP/2\", RFC 7541, DOI 10.17487/RFC7541,\
    \ May 2015,\n                 <http://www.rfc-editor.org/info/rfc7541>.\n   [COOKIE]\
    \      Barth, A., \"HTTP State Management Mechanism\", RFC 6265,\n           \
    \      DOI 10.17487/RFC6265, April 2011,\n                 <http://www.rfc-editor.org/info/rfc6265>.\n\
    \   [FIPS186]     NIST, \"Digital Signature Standard (DSS)\", FIPS PUB\n     \
    \            186-4, July 2013,\n                 <http://dx.doi.org/10.6028/NIST.FIPS.186-4>.\n\
    \   [RFC2119]     Bradner, S., \"Key words for use in RFCs to Indicate\n     \
    \            Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/\n         \
    \        RFC2119, March 1997,\n                 <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC2818]     Rescorla, E., \"HTTP Over TLS\", RFC 2818, DOI 10.17487/\n \
    \                RFC2818, May 2000,\n                 <http://www.rfc-editor.org/info/rfc2818>.\n\
    \   [RFC3986]     Berners-Lee, T., Fielding, R., and L. Masinter,\n          \
    \       \"Uniform Resource Identifier (URI): Generic Syntax\",\n             \
    \    STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005,\n                 <http://www.rfc-editor.org/info/rfc3986>.\n\
    \   [RFC4648]     Josefsson, S., \"The Base16, Base32, and Base64 Data\n     \
    \            Encodings\", RFC 4648, DOI 10.17487/RFC4648, October\n          \
    \       2006, <http://www.rfc-editor.org/info/rfc4648>.\n   [RFC5226]     Narten,\
    \ T. and H. Alvestrand, \"Guidelines for Writing\n                 an IANA Considerations\
    \ Section in RFCs\", BCP 26,\n                 RFC 5226, DOI 10.17487/RFC5226,\
    \ May 2008,\n                 <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC5234]\
    \     Crocker, D., Ed. and P. Overell, \"Augmented BNF for\n                 Syntax\
    \ Specifications: ABNF\", STD 68, RFC 5234,\n                 DOI 10.17487/ RFC5234,\
    \ January 2008,\n                 <http://www.rfc-editor.org/info/rfc5234>.\n\
    \   [RFC7230]     Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext\n       \
    \          Transfer Protocol (HTTP/1.1): Message Syntax and\n                \
    \ Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014,\n                 <http://www.rfc-editor.org/info/rfc7230>.\n\
    \   [RFC7231]     Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext\n       \
    \          Transfer Protocol (HTTP/1.1): Semantics and Content\",\n          \
    \       RFC 7231, DOI 10.17487/RFC7231, June 2014,\n                 <http://www.rfc-editor.org/info/rfc7231>.\n\
    \   [RFC7232]     Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext\n       \
    \          Transfer Protocol (HTTP/1.1): Conditional Requests\",\n           \
    \      RFC 7232, DOI 10.17487/RFC7232, June 2014,\n                 <http://www.rfc-editor.org/info/rfc7232>.\n\
    \   [RFC7233]     Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,\n  \
    \               \"Hypertext Transfer Protocol (HTTP/1.1): Range\n            \
    \     Requests\", RFC 7233, DOI 10.17487/RFC7233, June 2014,\n               \
    \  <http://www.rfc-editor.org/info/rfc7233>.\n   [RFC7234]     Fielding, R., Ed.,\
    \ Nottingham, M., Ed., and J. Reschke,\n                 Ed., \"Hypertext Transfer\
    \ Protocol (HTTP/1.1): Caching\",\n                 RFC 7234, DOI 10.17487/RFC7234,\
    \ June 2014,\n                 <http://www.rfc-editor.org/info/rfc7234>.\n   [RFC7235]\
    \     Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext\n                 Transfer\
    \ Protocol (HTTP/1.1): Authentication\",\n                 RFC 7235, DOI 10.17487/RFC7235,\
    \ June 2014,\n                 <http://www.rfc-editor.org/info/rfc7235>.\n   [TCP]\
    \         Postel, J., \"Transmission Control Protocol\", STD 7, RFC\n        \
    \         793, DOI 10.17487/RFC0793, September 1981,\n                 <http://www.rfc-editor.org/info/rfc793>.\n\
    \   [TLS-ALPN]    Friedl, S., Popov, A., Langley, A., and E. Stephan,\n      \
    \           \"Transport Layer Security (TLS) Application-Layer\n             \
    \    Protocol Negotiation Extension\", RFC 7301,\n                 DOI 10.17487/RFC7301,\
    \ July 2014,\n                 <http://www.rfc-editor.org/info/rfc7301>.\n   [TLS-ECDHE]\
    \   Rescorla, E., \"TLS Elliptic Curve Cipher Suites with\n                 SHA-256/384\
    \ and AES Galois Counter Mode (GCM)\",\n                 RFC 5289, DOI 10.17487/RFC5289,\
    \ August 2008,\n                 <http://www.rfc-editor.org/info/rfc5289>.\n \
    \  [TLS-EXT]     Eastlake 3rd, D., \"Transport Layer Security (TLS)\n        \
    \         Extensions: Extension Definitions\", RFC 6066,\n                 DOI\
    \ 10.17487/RFC6066, January 2011,\n                 <http://www.rfc-editor.org/info/rfc6066>.\n\
    \   [TLS12]       Dierks, T. and E. Rescorla, \"The Transport Layer\n        \
    \         Security (TLS) Protocol Version 1.2\", RFC 5246,\n                 DOI\
    \ 10.17487/ RFC5246, August 2008,\n                 <http://www.rfc-editor.org/info/rfc5246>.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [ALT-SVC]     Nottingham, M., McManus, P.,\
    \ and J. Reschke, \"HTTP\n                 Alternative Services\", Work in Progress,\
    \ draft-ietf-\n                 httpbis-alt-svc-06, February 2015.\n   [BCP90]\
    \       Klyne, G., Nottingham, M., and J. Mogul, \"Registration\n            \
    \     Procedures for Message Header Fields\", BCP 90,\n                 RFC 3864,\
    \ September 2004,\n                 <http://www.rfc-editor.org/info/bcp90>.\n\
    \   [BREACH]      Gluck, Y., Harris, N., and A. Prado, \"BREACH: Reviving\n  \
    \               the CRIME Attack\", July 2013,\n                 <http://breachattack.com/resources/\n\
    \                 BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>.\n   [HTML5]\
    \       Hickson, I., Berjon, R., Faulkner, S., Leithead, T.,\n               \
    \  Doyle Navara, E., O'Connor, E., and S. Pfeiffer,\n                 \"HTML5\"\
    , W3C Recommendation REC-html5-20141028, October\n                 2014, <http://www.w3.org/TR/2014/REC-html5-20141028/>.\n\
    \   [RFC3749]     Hollenbeck, S., \"Transport Layer Security Protocol\n      \
    \           Compression Methods\", RFC 3749, DOI 10.17487/RFC3749,\n         \
    \        May 2004, <http://www.rfc-editor.org/info/rfc3749>.\n   [RFC4492]   \
    \  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and\n                 B.\
    \  Moeller, \"Elliptic Curve Cryptography (ECC) Cipher\n                 Suites\
    \ for Transport Layer Security (TLS)\", RFC 4492,\n                 DOI 10.17487/RFC4492,\
    \ May 2006,\n                 <http://www.rfc-editor.org/info/rfc4492>.\n   [RFC6585]\
    \     Nottingham, M. and R. Fielding, \"Additional HTTP Status\n             \
    \    Codes\", RFC 6585, DOI 10.17487/RFC6585, April 2012,\n                 <http://www.rfc-editor.org/info/rfc6585>.\n\
    \   [RFC7323]     Borman, D., Braden, B., Jacobson, V., and R.\n             \
    \    Scheffenegger, Ed., \"TCP Extensions for High\n                 Performance\"\
    , RFC 7323, DOI 10.17487/RFC7323, September\n                 2014, <http://www.rfc-editor.org/info/rfc7323>.\n\
    \   [TALKING]     Huang, L., Chen, E., Barth, A., Rescorla, E., and C.\n     \
    \            Jackson, \"Talking to Yourself for Fun and Profit\",\n          \
    \       2011, <http://w2spconf.com/2011/papers/websocket.pdf>.\n   [TLSBCP]  \
    \    Sheffer, Y., Holz, R., and P. Saint-Andre,\n                 \"Recommendations\
    \ for Secure Use of Transport Layer\n                 Security (TLS) and Datagram\
    \ Transport Layer Security\n                 (DTLS)\", BCP 195, RFC 7525, DOI\
    \ 10.17487/RFC7525, May\n                 2015, <http://www.rfc-editor.org/info/rfc7525>.\n"
- title: Appendix A.  TLS 1.2 Cipher Suite Black List
  contents:
  - "Appendix A.  TLS 1.2 Cipher Suite Black List\n   An HTTP/2 implementation MAY\
    \ treat the negotiation of any of the\n   following cipher suites with TLS 1.2\
    \ as a connection error\n   (Section 5.4.1) of type INADEQUATE_SECURITY:\n   o\
    \  TLS_NULL_WITH_NULL_NULL\n   o  TLS_RSA_WITH_NULL_MD5\n   o  TLS_RSA_WITH_NULL_SHA\n\
    \   o  TLS_RSA_EXPORT_WITH_RC4_40_MD5\n   o  TLS_RSA_WITH_RC4_128_MD5\n   o  TLS_RSA_WITH_RC4_128_SHA\n\
    \   o  TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5\n   o  TLS_RSA_WITH_IDEA_CBC_SHA\n \
    \  o  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA\n   o  TLS_RSA_WITH_DES_CBC_SHA\n   o\
    \  TLS_RSA_WITH_3DES_EDE_CBC_SHA\n   o  TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA\n\
    \   o  TLS_DH_DSS_WITH_DES_CBC_SHA\n   o  TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA\n \
    \  o  TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA\n   o  TLS_DH_RSA_WITH_DES_CBC_SHA\n\
    \   o  TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA\n   o  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\n\
    \   o  TLS_DHE_DSS_WITH_DES_CBC_SHA\n   o  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\n\
    \   o  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\n   o  TLS_DHE_RSA_WITH_DES_CBC_SHA\n\
    \   o  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\n   o  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5\n\
    \   o  TLS_DH_anon_WITH_RC4_128_MD5\n   o  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA\n\
    \   o  TLS_DH_anon_WITH_DES_CBC_SHA\n   o  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA\n\
    \   o  TLS_KRB5_WITH_DES_CBC_SHA\n   o  TLS_KRB5_WITH_3DES_EDE_CBC_SHA\n   o \
    \ TLS_KRB5_WITH_RC4_128_SHA\n   o  TLS_KRB5_WITH_IDEA_CBC_SHA\n   o  TLS_KRB5_WITH_DES_CBC_MD5\n\
    \   o  TLS_KRB5_WITH_3DES_EDE_CBC_MD5\n   o  TLS_KRB5_WITH_RC4_128_MD5\n   o \
    \ TLS_KRB5_WITH_IDEA_CBC_MD5\n   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA\n   o\
    \  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA\n   o  TLS_KRB5_EXPORT_WITH_RC4_40_SHA\n\
    \   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5\n   o  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5\n\
    \   o  TLS_KRB5_EXPORT_WITH_RC4_40_MD5\n   o  TLS_PSK_WITH_NULL_SHA\n   o  TLS_DHE_PSK_WITH_NULL_SHA\n\
    \   o  TLS_RSA_PSK_WITH_NULL_SHA\n   o  TLS_RSA_WITH_AES_128_CBC_SHA\n   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA\n\
    \   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA\n   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA\n\
    \   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA\n   o  TLS_DH_anon_WITH_AES_128_CBC_SHA\n\
    \   o  TLS_RSA_WITH_AES_256_CBC_SHA\n   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA\n \
    \  o  TLS_DH_RSA_WITH_AES_256_CBC_SHA\n   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA\n\
    \   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA\n   o  TLS_DH_anon_WITH_AES_256_CBC_SHA\n\
    \   o  TLS_RSA_WITH_NULL_SHA256\n   o  TLS_RSA_WITH_AES_128_CBC_SHA256\n   o \
    \ TLS_RSA_WITH_AES_256_CBC_SHA256\n   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA256\n\
    \   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA256\n   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\n\
    \   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA\n   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA\n\
    \   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA\n   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA\n\
    \   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA\n   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA\n\
    \   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\n   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA256\n\
    \   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA256\n   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\n\
    \   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\n   o  TLS_DH_anon_WITH_AES_128_CBC_SHA256\n\
    \   o  TLS_DH_anon_WITH_AES_256_CBC_SHA256\n   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA\n\
    \   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA\n   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA\n\
    \   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA\n   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA\n\
    \   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA\n   o  TLS_PSK_WITH_RC4_128_SHA\n\
    \   o  TLS_PSK_WITH_3DES_EDE_CBC_SHA\n   o  TLS_PSK_WITH_AES_128_CBC_SHA\n   o\
    \  TLS_PSK_WITH_AES_256_CBC_SHA\n   o  TLS_DHE_PSK_WITH_RC4_128_SHA\n   o  TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA\n\
    \   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA\n   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA\n\
    \   o  TLS_RSA_PSK_WITH_RC4_128_SHA\n   o  TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA\n\
    \   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA\n   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA\n\
    \   o  TLS_RSA_WITH_SEED_CBC_SHA\n   o  TLS_DH_DSS_WITH_SEED_CBC_SHA\n   o  TLS_DH_RSA_WITH_SEED_CBC_SHA\n\
    \   o  TLS_DHE_DSS_WITH_SEED_CBC_SHA\n   o  TLS_DHE_RSA_WITH_SEED_CBC_SHA\n  \
    \ o  TLS_DH_anon_WITH_SEED_CBC_SHA\n   o  TLS_RSA_WITH_AES_128_GCM_SHA256\n  \
    \ o  TLS_RSA_WITH_AES_256_GCM_SHA384\n   o  TLS_DH_RSA_WITH_AES_128_GCM_SHA256\n\
    \   o  TLS_DH_RSA_WITH_AES_256_GCM_SHA384\n   o  TLS_DH_DSS_WITH_AES_128_GCM_SHA256\n\
    \   o  TLS_DH_DSS_WITH_AES_256_GCM_SHA384\n   o  TLS_DH_anon_WITH_AES_128_GCM_SHA256\n\
    \   o  TLS_DH_anon_WITH_AES_256_GCM_SHA384\n   o  TLS_PSK_WITH_AES_128_GCM_SHA256\n\
    \   o  TLS_PSK_WITH_AES_256_GCM_SHA384\n   o  TLS_RSA_PSK_WITH_AES_128_GCM_SHA256\n\
    \   o  TLS_RSA_PSK_WITH_AES_256_GCM_SHA384\n   o  TLS_PSK_WITH_AES_128_CBC_SHA256\n\
    \   o  TLS_PSK_WITH_AES_256_CBC_SHA384\n   o  TLS_PSK_WITH_NULL_SHA256\n   o \
    \ TLS_PSK_WITH_NULL_SHA384\n   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA256\n   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA384\n\
    \   o  TLS_DHE_PSK_WITH_NULL_SHA256\n   o  TLS_DHE_PSK_WITH_NULL_SHA384\n   o\
    \  TLS_RSA_PSK_WITH_AES_128_CBC_SHA256\n   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA384\n\
    \   o  TLS_RSA_PSK_WITH_NULL_SHA256\n   o  TLS_RSA_PSK_WITH_NULL_SHA384\n   o\
    \  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256\n\
    \   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256\n\
    \   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256\n\
    \   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256\n   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256\n\
    \   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256\n   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256\n\
    \   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256\n   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256\n\
    \   o  TLS_EMPTY_RENEGOTIATION_INFO_SCSV\n   o  TLS_ECDH_ECDSA_WITH_NULL_SHA\n\
    \   o  TLS_ECDH_ECDSA_WITH_RC4_128_SHA\n   o  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\n\
    \   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\n   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\n\
    \   o  TLS_ECDHE_ECDSA_WITH_NULL_SHA\n   o  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n\
    \   o  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\n   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n\
    \   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n   o  TLS_ECDH_RSA_WITH_NULL_SHA\n\
    \   o  TLS_ECDH_RSA_WITH_RC4_128_SHA\n   o  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\n\
    \   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\n   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA\n\
    \   o  TLS_ECDHE_RSA_WITH_NULL_SHA\n   o  TLS_ECDHE_RSA_WITH_RC4_128_SHA\n   o\
    \  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n\
    \   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n   o  TLS_ECDH_anon_WITH_NULL_SHA\n\
    \   o  TLS_ECDH_anon_WITH_RC4_128_SHA\n   o  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA\n\
    \   o  TLS_ECDH_anon_WITH_AES_128_CBC_SHA\n   o  TLS_ECDH_anon_WITH_AES_256_CBC_SHA\n\
    \   o  TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA\n   o  TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA\n\
    \   o  TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA\n   o  TLS_SRP_SHA_WITH_AES_128_CBC_SHA\n\
    \   o  TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA\n   o  TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA\n\
    \   o  TLS_SRP_SHA_WITH_AES_256_CBC_SHA\n   o  TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA\n\
    \   o  TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA\n   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n\
    \   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\n   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256\n\
    \   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384\n   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n\
    \   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\n   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256\n\
    \   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384\n   o  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256\n\
    \   o  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\n   o  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256\n\
    \   o  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384\n   o  TLS_ECDHE_PSK_WITH_RC4_128_SHA\n\
    \   o  TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA\n   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA\n\
    \   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA\n   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256\n\
    \   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384\n   o  TLS_ECDHE_PSK_WITH_NULL_SHA\n\
    \   o  TLS_ECDHE_PSK_WITH_NULL_SHA256\n   o  TLS_ECDHE_PSK_WITH_NULL_SHA384\n\
    \   o  TLS_RSA_WITH_ARIA_128_CBC_SHA256\n   o  TLS_RSA_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256\n   o  TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256\n   o  TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256\n   o  TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256\n   o  TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_DH_anon_WITH_ARIA_128_CBC_SHA256\n   o  TLS_DH_anon_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256\n   o  TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256\n   o  TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256\n   o  TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256\n   o  TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_RSA_WITH_ARIA_128_GCM_SHA256\n   o  TLS_RSA_WITH_ARIA_256_GCM_SHA384\n\
    \   o  TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256\n   o  TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384\n\
    \   o  TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256\n   o  TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384\n\
    \   o  TLS_DH_anon_WITH_ARIA_128_GCM_SHA256\n   o  TLS_DH_anon_WITH_ARIA_256_GCM_SHA384\n\
    \   o  TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256\n   o  TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384\n\
    \   o  TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256\n   o  TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384\n\
    \   o  TLS_PSK_WITH_ARIA_128_CBC_SHA256\n   o  TLS_PSK_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256\n   o  TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256\n   o  TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_PSK_WITH_ARIA_128_GCM_SHA256\n   o  TLS_PSK_WITH_ARIA_256_GCM_SHA384\n\
    \   o  TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256\n   o  TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384\n\
    \   o  TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256\n   o  TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384\n\
    \   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384\n\
    \   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384\n\
    \   o  TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384\n\
    \   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384\n\
    \   o  TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256\n   o  TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384\n\
    \   o  TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256\n   o  TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384\n\
    \   o  TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256\n   o  TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384\n\
    \   o  TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256\n   o  TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384\n\
    \   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256\n   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384\n\
    \   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256\n   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384\n\
    \   o  TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256\n   o  TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384\n\
    \   o  TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256\n   o  TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384\n\
    \   o  TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384\n\
    \   o  TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\n\
    \   o  TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384\n\
    \   o  TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\n   o  TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\n\
    \   o  TLS_RSA_WITH_AES_128_CCM\n   o  TLS_RSA_WITH_AES_256_CCM\n   o  TLS_RSA_WITH_AES_128_CCM_8\n\
    \   o  TLS_RSA_WITH_AES_256_CCM_8\n   o  TLS_PSK_WITH_AES_128_CCM\n   o  TLS_PSK_WITH_AES_256_CCM\n\
    \   o  TLS_PSK_WITH_AES_128_CCM_8\n   o  TLS_PSK_WITH_AES_256_CCM_8\n      Note:\
    \ This list was assembled from the set of registered TLS\n      cipher suites\
    \ at the time of writing.  This list includes those\n      cipher suites that\
    \ do not offer an ephemeral key exchange and\n      those that are based on the\
    \ TLS null, stream, or block cipher type\n      (as defined in Section 6.2.3 of\
    \ [TLS12]).  Additional cipher\n      suites with these properties could be defined;\
    \ these would not be\n      explicitly prohibited.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This document includes substantial input from the following\n\
    \   individuals:\n   o  Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham,\
    \ Alyssa\n      Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe Chan,\
    \ Adam\n      Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay,\n\
    \      Paul Amer, Fan Yang, and Jonathan Leighton (SPDY contributors).\n   o \
    \ Gabriel Montenegro and Willy Tarreau (Upgrade mechanism).\n   o  William Chan,\
    \ Salvatore Loreto, Osama Mazahir, Gabriel Montenegro,\n      Jitu Padhye, Roberto\
    \ Peon, and Rob Trace (Flow control).\n   o  Mike Bishop (Extensibility).\n  \
    \ o  Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike\n      Bishop,\
    \ and Herve Ruellan (Substantial editorial contributions).\n   o  Kari Hurtta,\
    \ Tatsuhiro Tsujikawa, Greg Wilkins, Poul-Henning Kamp,\n      and Jonathan Thackray.\n\
    \   o  Alexey Melnikov, who was an editor of this document in 2013.\n   A substantial\
    \ proportion of Martin's contribution was supported by\n   Microsoft during his\
    \ employment there.\n   The Japanese HTTP/2 community provided invaluable contributions,\n\
    \   including a number of implementations as well as numerous technical\n   and\
    \ editorial contributions.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Mike Belshe\n   BitGo\n   EMail: mike@belshe.com\n   Roberto\
    \ Peon\n   Google, Inc\n   EMail: fenix@google.com\n   Martin Thomson (editor)\n\
    \   Mozilla\n   331 E Evelyn Street\n   Mountain View, CA  94041\n   United States\n\
    \   EMail: martin.thomson@gmail.com\n"
