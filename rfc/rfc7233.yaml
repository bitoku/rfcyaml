- contents:
  - '         Hypertext Transfer Protocol (HTTP/1.1): Range Requests

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Hypertext Transfer Protocol (HTTP) is a stateless application-\n
    \  level protocol for distributed, collaborative, hypertext information\n   systems.
    \ This document defines range requests and the rules for\n   constructing and
    combining responses to those requests.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7233.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Conformance and Error Handling .............................4\n      1.2.
    Syntax Notation ............................................4\n   2. Range Units
    .....................................................5\n      2.1. Byte Ranges
    ................................................5\n      2.2. Other Range Units
    ..........................................7\n      2.3. Accept-Ranges ..............................................7\n
    \  3. Range Requests ..................................................8\n      3.1.
    Range ......................................................8\n      3.2. If-Range
    ...................................................9\n   4. Responses to a Range
    Request ...................................10\n      4.1. 206 Partial Content
    .......................................10\n      4.2. Content-Range .............................................12\n
    \     4.3. Combining Ranges ..........................................14\n      4.4.
    416 Range Not Satisfiable .................................15\n   5. IANA Considerations
    ............................................16\n      5.1. Range Unit Registry
    .......................................16\n           5.1.1. Procedure ..........................................16\n
    \          5.1.2. Registrations ......................................16\n      5.2.
    Status Code Registration ..................................17\n      5.3. Header
    Field Registration .................................17\n      5.4. Internet Media
    Type Registration ..........................17\n           5.4.1. Internet Media
    Type multipart/byteranges ...........18\n   6. Security Considerations ........................................19\n
    \     6.1. Denial-of-Service Attacks Using Range .....................19\n   7.
    Acknowledgments ................................................19\n   8. References
    .....................................................20\n      8.1. Normative
    References ......................................20\n      8.2. Informative References
    ....................................20\n   Appendix A. Internet Media Type multipart/byteranges
    ..............21\n   Appendix B. Changes from RFC 2616 .................................22\n
    \  Appendix C. Imported ABNF .........................................22\n   Appendix
    D. Collected ABNF ........................................23\n   Index .............................................................24\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Hypertext Transfer Protocol (HTTP) clients often encounter\n
    \  interrupted data transfers as a result of canceled requests or\n   dropped
    connections.  When a client has stored a partial\n   representation, it is desirable
    to request the remainder of that\n   representation in a subsequent request rather
    than transfer the\n   entire representation.  Likewise, devices with limited local
    storage\n   might benefit from being able to request only a subset of a larger\n
    \  representation, such as a single page of a very large document, or\n   the
    dimensions of an embedded image.\n   This document defines HTTP/1.1 range requests,
    partial responses, and\n   the multipart/byteranges media type.  Range requests
    are an OPTIONAL\n   feature of HTTP, designed so that recipients not implementing
    this\n   feature (or not supporting it for the target resource) can respond as\n
    \  if it is a normal GET request without impacting interoperability.\n   Partial
    responses are indicated by a distinct status code to not be\n   mistaken for full
    responses by caches that might not implement the\n   feature.\n   Although the
    range request mechanism is designed to allow for\n   extensible range types, this
    specification only defines requests for\n   byte ranges.\n"
  - contents:
    - "1.1.  Conformance and Error Handling\n   The key words \"MUST\", \"MUST NOT\",
      \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
      \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
      in [RFC2119].\n   Conformance criteria and considerations regarding error handling
      are\n   defined in Section 2.5 of [RFC7230].\n"
    title: 1.1.  Conformance and Error Handling
  - contents:
    - "1.2.  Syntax Notation\n   This specification uses the Augmented Backus-Naur
      Form (ABNF)\n   notation of [RFC5234] with a list extension, defined in Section
      7 of\n   [RFC7230], that allows for compact definition of comma-separated\n
      \  lists using a '#' operator (similar to how the '*' operator indicates\n   repetition).
      \ Appendix C describes rules imported from other\n   documents.  Appendix D
      shows the collected grammar with all list\n   operators expanded to standard
      ABNF notation.\n"
    title: 1.2.  Syntax Notation
  title: 1.  Introduction
- contents:
  - "2.  Range Units\n   A representation can be partitioned into subranges according
    to\n   various structural units, depending on the structure inherent in the\n
    \  representation's media type.  This \"range unit\" is used in the\n   Accept-Ranges
    (Section 2.3) response header field to advertise\n   support for range requests,
    the Range (Section 3.1) request header\n   field to delineate the parts of a representation
    that are requested,\n   and the Content-Range (Section 4.2) payload header field
    to describe\n   which part of a representation is being transferred.\n     range-unit
    \      = bytes-unit / other-range-unit\n"
  - contents:
    - "2.1.  Byte Ranges\n   Since representation data is transferred in payloads
      as a sequence of\n   octets, a byte range is a meaningful substructure for any\n
      \  representation transferable over HTTP (Section 3 of [RFC7231]).  The\n   \"bytes\"
      range unit is defined for expressing subranges of the data's\n   octet sequence.\n
      \    bytes-unit       = \"bytes\"\n   A byte-range request can specify a single
      range of bytes or a set of\n   ranges within a single representation.\n     byte-ranges-specifier
      = bytes-unit \"=\" byte-range-set\n     byte-range-set  = 1#( byte-range-spec
      / suffix-byte-range-spec )\n     byte-range-spec = first-byte-pos \"-\" [ last-byte-pos
      ]\n     first-byte-pos  = 1*DIGIT\n     last-byte-pos   = 1*DIGIT\n   The first-byte-pos
      value in a byte-range-spec gives the byte-offset\n   of the first byte in a
      range.  The last-byte-pos value gives the\n   byte-offset of the last byte in
      the range; that is, the byte\n   positions specified are inclusive.  Byte offsets
      start at zero.\n   Examples of byte-ranges-specifier values:\n   o  The first
      500 bytes (byte offsets 0-499, inclusive):\n        bytes=0-499\n   o  The second
      500 bytes (byte offsets 500-999, inclusive):\n        bytes=500-999\n   A byte-range-spec
      is invalid if the last-byte-pos value is present\n   and less than the first-byte-pos.\n
      \  A client can limit the number of bytes requested without knowing the\n   size
      of the selected representation.  If the last-byte-pos value is\n   absent, or
      if the value is greater than or equal to the current\n   length of the representation
      data, the byte range is interpreted as\n   the remainder of the representation
      (i.e., the server replaces the\n   value of last-byte-pos with a value that
      is one less than the current\n   length of the selected representation).\n   A
      client can request the last N bytes of the selected representation\n   using
      a suffix-byte-range-spec.\n     suffix-byte-range-spec = \"-\" suffix-length\n
      \    suffix-length = 1*DIGIT\n   If the selected representation is shorter than
      the specified\n   suffix-length, the entire representation is used.\n   Additional
      examples, assuming a representation of length 10000:\n   o  The final 500 bytes
      (byte offsets 9500-9999, inclusive):\n        bytes=-500\n   Or:\n        bytes=9500-\n
      \  o  The first and last bytes only (bytes 0 and 9999):\n        bytes=0-0,-1\n
      \  o  Other valid (but not canonical) specifications of the second 500\n      bytes
      (byte offsets 500-999, inclusive):\n        bytes=500-600,601-999\n        bytes=500-700,601-999\n
      \  If a valid byte-range-set includes at least one byte-range-spec with\n   a
      first-byte-pos that is less than the current length of the\n   representation,
      or at least one suffix-byte-range-spec with a\n   non-zero suffix-length, then
      the byte-range-set is satisfiable.\n   Otherwise, the byte-range-set is unsatisfiable.\n
      \  In the byte-range syntax, first-byte-pos, last-byte-pos, and\n   suffix-length
      are expressed as decimal number of octets.  Since there\n   is no predefined
      limit to the length of a payload, recipients MUST\n   anticipate potentially
      large decimal numerals and prevent parsing\n   errors due to integer conversion
      overflows.\n"
    title: 2.1.  Byte Ranges
  - contents:
    - "2.2.  Other Range Units\n   Range units are intended to be extensible.  New
      range units ought to\n   be registered with IANA, as defined in Section 5.1.\n
      \    other-range-unit = token\n"
    title: 2.2.  Other Range Units
  - contents:
    - "2.3.  Accept-Ranges\n   The \"Accept-Ranges\" header field allows a server
      to indicate that it\n   supports range requests for the target resource.\n     Accept-Ranges
      \    = acceptable-ranges\n     acceptable-ranges = 1#range-unit / \"none\"\n
      \  An origin server that supports byte-range requests for a given target\n   resource
      MAY send\n     Accept-Ranges: bytes\n   to indicate what range units are supported.
      \ A client MAY generate\n   range requests without having received this header
      field for the\n   resource involved.  Range units are defined in Section 2.\n
      \  A server that does not support any kind of range request for the\n   target
      resource MAY send\n     Accept-Ranges: none\n   to advise the client not to
      attempt a range request.\n"
    title: 2.3.  Accept-Ranges
  title: 2.  Range Units
- contents:
  - '3.  Range Requests

    '
  - contents:
    - "3.1.  Range\n   The \"Range\" header field on a GET request modifies the method\n
      \  semantics to request transfer of only one or more subranges of the\n   selected
      representation data, rather than the entire selected\n   representation data.\n
      \    Range = byte-ranges-specifier / other-ranges-specifier\n     other-ranges-specifier
      = other-range-unit \"=\" other-range-set\n     other-range-set = 1*VCHAR\n   A
      server MAY ignore the Range header field.  However, origin servers\n   and intermediate
      caches ought to support byte ranges when possible,\n   since Range supports
      efficient recovery from partially failed\n   transfers and partial retrieval
      of large representations.  A server\n   MUST ignore a Range header field received
      with a request method other\n   than GET.\n   An origin server MUST ignore a
      Range header field that contains a\n   range unit it does not understand.  A
      proxy MAY discard a Range\n   header field that contains a range unit it does
      not understand.\n   A server that supports range requests MAY ignore or reject
      a Range\n   header field that consists of more than two overlapping ranges,
      or a\n   set of many small ranges that are not listed in ascending order,\n
      \  since both are indications of either a broken client or a deliberate\n   denial-of-service
      attack (Section 6.1).  A client SHOULD NOT request\n   multiple ranges that
      are inherently less efficient to process and\n   transfer than a single range
      that encompasses the same data.\n   A client that is requesting multiple ranges
      SHOULD list those ranges\n   in ascending order (the order in which they would
      typically be\n   received in a complete representation) unless there is a specific\n
      \  need to request a later part earlier.  For example, a user agent\n   processing
      a large representation with an internal catalog of parts\n   might need to request
      later parts first, particularly if the\n   representation consists of pages
      stored in reverse order and the user\n   agent wishes to transfer one page at
      a time.\n   The Range header field is evaluated after evaluating the precondition\n
      \  header fields defined in [RFC7232], and only if the result in absence\n   of
      the Range header field would be a 200 (OK) response.  In other\n   words, Range
      is ignored when a conditional GET would result in a 304\n   (Not Modified) response.\n
      \  The If-Range header field (Section 3.2) can be used as a precondition\n   to
      applying the Range header field.\n   If all of the preconditions are true, the
      server supports the Range\n   header field for the target resource, and the
      specified range(s) are\n   valid and satisfiable (as defined in Section 2.1),
      the server SHOULD\n   send a 206 (Partial Content) response with a payload containing
      one\n   or more partial representations that correspond to the satisfiable\n
      \  ranges requested, as defined in Section 4.\n   If all of the preconditions
      are true, the server supports the Range\n   header field for the target resource,
      and the specified range(s) are\n   invalid or unsatisfiable, the server SHOULD
      send a 416 (Range Not\n   Satisfiable) response.\n"
    title: 3.1.  Range
  - contents:
    - "3.2.  If-Range\n   If a client has a partial copy of a representation and wishes
      to have\n   an up-to-date copy of the entire representation, it could use the\n
      \  Range header field with a conditional GET (using either or both of\n   If-Unmodified-Since
      and If-Match.)  However, if the precondition\n   fails because the representation
      has been modified, the client would\n   then have to make a second request to
      obtain the entire current\n   representation.\n   The \"If-Range\" header field
      allows a client to \"short-circuit\" the\n   second request.  Informally, its
      meaning is as follows: if the\n   representation is unchanged, send me the part(s)
      that I am requesting\n   in Range; otherwise, send me the entire representation.\n
      \    If-Range = entity-tag / HTTP-date\n   A client MUST NOT generate an If-Range
      header field in a request that\n   does not contain a Range header field.  A
      server MUST ignore an\n   If-Range header field received in a request that does
      not contain a\n   Range header field.  An origin server MUST ignore an If-Range
      header\n   field received in a request for a target resource that does not\n
      \  support Range requests.\n   A client MUST NOT generate an If-Range header
      field containing an\n   entity-tag that is marked as weak.  A client MUST NOT
      generate an\n   If-Range header field containing an HTTP-date unless the client
      has\n   no entity-tag for the corresponding representation and the date is a\n
      \  strong validator in the sense defined by Section 2.2.2 of [RFC7232].\n   A
      server that evaluates an If-Range precondition MUST use the strong\n   comparison
      function when comparing entity-tags (Section 2.3.2 of\n   [RFC7232]) and MUST
      evaluate the condition as false if an HTTP-date\n   validator is provided that
      is not a strong validator in the sense\n   defined by Section 2.2.2 of [RFC7232].
      \ A valid entity-tag can be\n   distinguished from a valid HTTP-date by examining
      the first two\n   characters for a DQUOTE.\n   If the validator given in the
      If-Range header field matches the\n   current validator for the selected representation
      of the target\n   resource, then the server SHOULD process the Range header
      field as\n   requested.  If the validator does not match, the server MUST ignore\n
      \  the Range header field.  Note that this comparison by exact match,\n   including
      when the validator is an HTTP-date, differs from the\n   \"earlier than or equal
      to\" comparison used when evaluating an\n   If-Unmodified-Since conditional.\n"
    title: 3.2.  If-Range
  title: 3.  Range Requests
- contents:
  - '4.  Responses to a Range Request

    '
  - contents:
    - "4.1.  206 Partial Content\n   The 206 (Partial Content) status code indicates
      that the server is\n   successfully fulfilling a range request for the target
      resource by\n   transferring one or more parts of the selected representation
      that\n   correspond to the satisfiable ranges found in the request's Range\n
      \  header field (Section 3.1).\n   If a single part is being transferred, the
      server generating the 206\n   response MUST generate a Content-Range header
      field, describing what\n   range of the selected representation is enclosed,
      and a payload\n   consisting of the range.  For example:\n     HTTP/1.1 206
      Partial Content\n     Date: Wed, 15 Nov 1995 06:25:24 GMT\n     Last-Modified:
      Wed, 15 Nov 1995 04:58:08 GMT\n     Content-Range: bytes 21010-47021/47022\n
      \    Content-Length: 26012\n     Content-Type: image/gif\n     ... 26012 bytes
      of partial image data ...\n   If multiple parts are being transferred, the server
      generating the\n   206 response MUST generate a \"multipart/byteranges\" payload,
      as\n   defined in Appendix A, and a Content-Type header field containing the\n
      \  multipart/byteranges media type and its required boundary parameter.\n   To
      avoid confusion with single-part responses, a server MUST NOT\n   generate a
      Content-Range header field in the HTTP header section of a\n   multiple part
      response (this field will be sent in each part\n   instead).\n   Within the
      header area of each body part in the multipart payload,\n   the server MUST
      generate a Content-Range header field corresponding\n   to the range being enclosed
      in that body part.  If the selected\n   representation would have had a Content-Type
      header field in a 200\n   (OK) response, the server SHOULD generate that same
      Content-Type\n   field in the header area of each body part.  For example:\n
      \    HTTP/1.1 206 Partial Content\n     Date: Wed, 15 Nov 1995 06:25:24 GMT\n
      \    Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n     Content-Length: 1741\n
      \    Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n     --THIS_STRING_SEPARATES\n
      \    Content-Type: application/pdf\n     Content-Range: bytes 500-999/8000\n
      \    ...the first range...\n     --THIS_STRING_SEPARATES\n     Content-Type:
      application/pdf\n     Content-Range: bytes 7000-7999/8000\n     ...the second
      range\n     --THIS_STRING_SEPARATES--\n   When multiple ranges are requested,
      a server MAY coalesce any of the\n   ranges that overlap, or that are separated
      by a gap that is smaller\n   than the overhead of sending multiple parts, regardless
      of the order\n   in which the corresponding byte-range-spec appeared in the
      received\n   Range header field.  Since the typical overhead between parts of
      a\n   multipart/byteranges payload is around 80 bytes, depending on the\n   selected
      representation's media type and the chosen boundary\n   parameter length, it
      can be less efficient to transfer many small\n   disjoint parts than it is to
      transfer the entire selected\n   representation.\n   A server MUST NOT generate
      a multipart response to a request for a\n   single range, since a client that
      does not request multiple parts\n   might not support multipart responses.  However,
      a server MAY\n   generate a multipart/byteranges payload with only a single
      body part\n   if multiple ranges were requested and only one range was found
      to be\n   satisfiable or only one range remained after coalescing.  A client\n
      \  that cannot process a multipart/byteranges response MUST NOT generate\n   a
      request that asks for multiple ranges.\n   When a multipart response payload
      is generated, the server SHOULD\n   send the parts in the same order that the
      corresponding\n   byte-range-spec appeared in the received Range header field,\n
      \  excluding those ranges that were deemed unsatisfiable or that were\n   coalesced
      into other ranges.  A client that receives a multipart\n   response MUST inspect
      the Content-Range header field present in each\n   body part in order to determine
      which range is contained in that body\n   part; a client cannot rely on receiving
      the same ranges that it\n   requested, nor the same order that it requested.\n
      \  When a 206 response is generated, the server MUST generate the\n   following
      header fields, in addition to those required above, if the\n   field would have
      been sent in a 200 (OK) response to the same\n   request: Date, Cache-Control,
      ETag, Expires, Content-Location, and\n   Vary.\n   If a 206 is generated in
      response to a request with an If-Range\n   header field, the sender SHOULD NOT
      generate other representation\n   header fields beyond those required above,
      because the client is\n   understood to already have a prior response containing
      those header\n   fields.  Otherwise, the sender MUST generate all of the\n   representation
      header fields that would have been sent in a 200 (OK)\n   response to the same
      request.\n   A 206 response is cacheable by default; i.e., unless otherwise\n
      \  indicated by explicit cache controls (see Section 4.2.2 of\n   [RFC7234]).\n"
    title: 4.1.  206 Partial Content
  - contents:
    - "4.2.  Content-Range\n   The \"Content-Range\" header field is sent in a single
      part 206\n   (Partial Content) response to indicate the partial range of the\n
      \  selected representation enclosed as the message payload, sent in each\n   part
      of a multipart 206 response to indicate the range enclosed\n   within each body
      part, and sent in 416 (Range Not Satisfiable)\n   responses to provide information
      about the selected representation.\n     Content-Range       = byte-content-range\n
      \                        / other-content-range\n     byte-content-range  = bytes-unit
      SP\n                           ( byte-range-resp / unsatisfied-range )\n     byte-range-resp
      \    = byte-range \"/\" ( complete-length / \"*\" )\n     byte-range          =
      first-byte-pos \"-\" last-byte-pos\n     unsatisfied-range   = \"*/\" complete-length\n
      \    complete-length     = 1*DIGIT\n     other-content-range = other-range-unit
      SP other-range-resp\n     other-range-resp    = *CHAR\n   If a 206 (Partial
      Content) response contains a Content-Range header\n   field with a range unit
      (Section 2) that the recipient does not\n   understand, the recipient MUST NOT
      attempt to recombine it with a\n   stored representation.  A proxy that receives
      such a message SHOULD\n   forward it downstream.\n   For byte ranges, a sender
      SHOULD indicate the complete length of the\n   representation from which the
      range has been extracted, unless the\n   complete length is unknown or difficult
      to determine.  An asterisk\n   character (\"*\") in place of the complete-length
      indicates that the\n   representation length was unknown when the header field
      was\n   generated.\n   The following example illustrates when the complete length
      of the\n   selected representation is known by the sender to be 1234 bytes:\n
      \    Content-Range: bytes 42-1233/1234\n   and this second example illustrates
      when the complete length is\n   unknown:\n     Content-Range: bytes 42-1233/*\n
      \  A Content-Range field value is invalid if it contains a\n   byte-range-resp
      that has a last-byte-pos value less than its\n   first-byte-pos value, or a
      complete-length value less than or equal\n   to its last-byte-pos value.  The
      recipient of an invalid\n   Content-Range MUST NOT attempt to recombine the
      received content with\n   a stored representation.\n   A server generating a
      416 (Range Not Satisfiable) response to a\n   byte-range request SHOULD send
      a Content-Range header field with an\n   unsatisfied-range value, as in the
      following example:\n     Content-Range: bytes */1234\n   The complete-length
      in a 416 response indicates the current length of\n   the selected representation.\n
      \  The Content-Range header field has no meaning for status codes that\n   do
      not explicitly describe its semantic.  For this specification,\n   only the
      206 (Partial Content) and 416 (Range Not Satisfiable) status\n   codes describe
      a meaning for Content-Range.\n   The following are examples of Content-Range
      values in which the\n   selected representation contains a total of 1234 bytes:\n
      \  o  The first 500 bytes:\n        Content-Range: bytes 0-499/1234\n   o  The
      second 500 bytes:\n        Content-Range: bytes 500-999/1234\n   o  All except
      for the first 500 bytes:\n        Content-Range: bytes 500-1233/1234\n   o  The
      last 500 bytes:\n        Content-Range: bytes 734-1233/1234\n"
    title: 4.2.  Content-Range
  - contents:
    - "4.3.  Combining Ranges\n   A response might transfer only a subrange of a representation
      if the\n   connection closed prematurely or if the request used one or more\n
      \  Range specifications.  After several such transfers, a client might\n   have
      received several ranges of the same representation.  These\n   ranges can only
      be safely combined if they all have in common the\n   same strong validator
      (Section 2.1 of [RFC7232]).\n   A client that has received multiple partial
      responses to GET requests\n   on a target resource MAY combine those responses
      into a larger\n   continuous range if they share the same strong validator.\n
      \  If the most recent response is an incomplete 200 (OK) response, then\n   the
      header fields of that response are used for any combined response\n   and replace
      those of the matching stored responses.\n   If the most recent response is a
      206 (Partial Content) response and\n   at least one of the matching stored responses
      is a 200 (OK), then the\n   combined response header fields consist of the most
      recent 200\n   response's header fields.  If all of the matching stored responses\n
      \  are 206 responses, then the stored response with the most recent\n   header
      fields is used as the source of header fields for the combined\n   response,
      except that the client MUST use other header fields\n   provided in the new
      response, aside from Content-Range, to replace\n   all instances of the corresponding
      header fields in the stored\n   response.\n   The combined response message
      body consists of the union of partial\n   content ranges in the new response
      and each of the selected\n   responses.  If the union consists of the entire
      range of the\n   representation, then the client MUST process the combined response
      as\n   if it were a complete 200 (OK) response, including a Content-Length\n
      \  header field that reflects the complete length.  Otherwise, the\n   client
      MUST process the set of continuous ranges as one of the\n   following: an incomplete
      200 (OK) response if the combined response\n   is a prefix of the representation,
      a single 206 (Partial Content)\n   response containing a multipart/byteranges
      body, or multiple 206\n   (Partial Content) responses, each with one continuous
      range that is\n   indicated by a Content-Range header field.\n"
    title: 4.3.  Combining Ranges
  - contents:
    - "4.4.  416 Range Not Satisfiable\n   The 416 (Range Not Satisfiable) status
      code indicates that none of\n   the ranges in the request's Range header field
      (Section 3.1) overlap\n   the current extent of the selected resource or that
      the set of ranges\n   requested has been rejected due to invalid ranges or an
      excessive\n   request of small or overlapping ranges.\n   For byte ranges, failing
      to overlap the current extent means that the\n   first-byte-pos of all of the
      byte-range-spec values were greater than\n   the current length of the selected
      representation.  When this status\n   code is generated in response to a byte-range
      request, the sender\n   SHOULD generate a Content-Range header field specifying
      the current\n   length of the selected representation (Section 4.2).\n   For
      example:\n     HTTP/1.1 416 Range Not Satisfiable\n     Date: Fri, 20 Jan 2012
      15:41:54 GMT\n     Content-Range: bytes */47022\n      Note: Because servers
      are free to ignore Range, many\n      implementations will simply respond with
      the entire selected\n      representation in a 200 (OK) response.  That is partly
      because\n      most clients are prepared to receive a 200 (OK) to complete the\n
      \     task (albeit less efficiently) and partly because clients might\n      not
      stop making an invalid partial request until they have\n      received a complete
      representation.  Thus, clients cannot depend\n      on receiving a 416 (Range
      Not Satisfiable) response even when it\n      is most appropriate.\n"
    title: 4.4.  416 Range Not Satisfiable
  title: 4.  Responses to a Range Request
- contents:
  - '5.  IANA Considerations

    '
  - contents:
    - "5.1.  Range Unit Registry\n   The \"HTTP Range Unit Registry\" defines the
      namespace for the range\n   unit names and refers to their corresponding specifications.
      \ The\n   registry has been created and is now maintained at\n   <http://www.iana.org/assignments/http-parameters>.\n"
    - contents:
      - "5.1.1.  Procedure\n   Registration of an HTTP Range Unit MUST include the
        following fields:\n   o  Name\n   o  Description\n   o  Pointer to specification
        text\n   Values to be added to this namespace require IETF Review (see\n   [RFC5226],
        Section 4.1).\n"
      title: 5.1.1.  Procedure
    - contents:
      - "5.1.2.  Registrations\n   The initial range unit registry contains the registrations
        below:\n   +-------------+---------------------------------------+-------------+\n
        \  | Range Unit  | Description                           | Reference   |\n
        \  | Name        |                                       |             |\n
        \  +-------------+---------------------------------------+-------------+\n
        \  | bytes       | a range of octets                     | Section 2.1 |\n
        \  | none        | reserved as keyword, indicating no    | Section 2.3 |\n
        \  |             | ranges are supported                  |             |\n
        \  +-------------+---------------------------------------+-------------+\n
        \  The change controller is: \"IETF (iesg@ietf.org) - Internet\n   Engineering
        Task Force\".\n"
      title: 5.1.2.  Registrations
    title: 5.1.  Range Unit Registry
  - contents:
    - "5.2.  Status Code Registration\n   The \"Hypertext Transfer Protocol (HTTP)
      Status Code Registry\" located\n   at <http://www.iana.org/assignments/http-status-codes>
      has been\n   updated to include the registrations below:\n   +-------+-----------------------+-------------+\n
      \  | Value | Description           | Reference   |\n   +-------+-----------------------+-------------+\n
      \  | 206   | Partial Content       | Section 4.1 |\n   | 416   | Range Not Satisfiable
      | Section 4.4 |\n   +-------+-----------------------+-------------+\n"
    title: 5.2.  Status Code Registration
  - contents:
    - "5.3.  Header Field Registration\n   HTTP header fields are registered within
      the \"Message Headers\"\n   registry maintained at\n   <http://www.iana.org/assignments/message-headers/>.\n
      \  This document defines the following HTTP header fields, so their\n   associated
      registry entries have been updated according to the\n   permanent registrations
      below (see [BCP90]):\n   +-------------------+----------+----------+-------------+\n
      \  | Header Field Name | Protocol | Status   | Reference   |\n   +-------------------+----------+----------+-------------+\n
      \  | Accept-Ranges     | http     | standard | Section 2.3 |\n   | Content-Range
      \    | http     | standard | Section 4.2 |\n   | If-Range          | http     |
      standard | Section 3.2 |\n   | Range             | http     | standard | Section
      3.1 |\n   +-------------------+----------+----------+-------------+\n   The
      change controller is: \"IETF (iesg@ietf.org) - Internet\n   Engineering Task
      Force\".\n"
    title: 5.3.  Header Field Registration
  - contents:
    - "5.4.  Internet Media Type Registration\n   IANA maintains the registry of Internet
      media types [BCP13] at\n   <http://www.iana.org/assignments/media-types>.\n
      \  This document serves as the specification for the Internet media type\n   \"multipart/byteranges\".
      \ The following has been registered with IANA.\n"
    - contents:
      - "5.4.1.  Internet Media Type multipart/byteranges\n   Type name:  multipart\n
        \  Subtype name:  byteranges\n   Required parameters:  boundary\n   Optional
        parameters:  N/A\n   Encoding considerations:  only \"7bit\", \"8bit\", or
        \"binary\" are\n      permitted\n   Security considerations:  see Section
        6\n   Interoperability considerations:  N/A\n   Published specification:  This
        specification (see Appendix A).\n   Applications that use this media type:
        \ HTTP components supporting\n      multiple ranges in a single request.\n
        \  Fragment identifier considerations:  N/A\n   Additional information:\n
        \     Deprecated alias names for this type:  N/A\n      Magic number(s):  N/A\n
        \     File extension(s):  N/A\n      Macintosh file type code(s):  N/A\n   Person
        and email address to contact for further information:  See\n      Authors'
        Addresses section.\n   Intended usage:  COMMON\n   Restrictions on usage:
        \ N/A\n   Author:  See Authors' Addresses section.\n   Change controller:
        \ IESG\n"
      title: 5.4.1.  Internet Media Type multipart/byteranges
    title: 5.4.  Internet Media Type Registration
  title: 5.  IANA Considerations
- contents:
  - "6.  Security Considerations\n   This section is meant to inform developers, information
    providers,\n   and users of known security concerns specific to the HTTP range\n
    \  request mechanisms.  More general security considerations are\n   addressed
    in HTTP messaging [RFC7230] and semantics [RFC7231].\n"
  - contents:
    - "6.1.  Denial-of-Service Attacks Using Range\n   Unconstrained multiple range
      requests are susceptible to denial-of-\n   service attacks because the effort
      required to request many\n   overlapping ranges of the same data is tiny compared
      to the time,\n   memory, and bandwidth consumed by attempting to serve the requested\n
      \  data in many parts.  Servers ought to ignore, coalesce, or reject\n   egregious
      range requests, such as requests for more than two\n   overlapping ranges or
      for many small ranges in a single set,\n   particularly when the ranges are
      requested out of order for no\n   apparent reason.  Multipart range requests
      are not designed to\n   support random access.\n"
    title: 6.1.  Denial-of-Service Attacks Using Range
  title: 6.  Security Considerations
- contents:
  - "7.  Acknowledgments\n   See Section 10 of [RFC7230].\n"
  title: 7.  Acknowledgments
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [RFC2046]  Freed, N. and N. Borenstein, \"Multipurpose
      Internet Mail\n              Extensions (MIME) Part Two: Media Types\", RFC
      2046,\n              November 1996.\n   [RFC2119]  Bradner, S., \"Key words
      for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented
      BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234, January
      2008.\n   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Message Syntax and Routing\",\n              RFC
      7230, June 2014.\n   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext
      Transfer\n              Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n
      \             June 2014.\n   [RFC7232]  Fielding, R., Ed. and J. Reschke, Ed.,
      \"Hypertext Transfer\n              Protocol (HTTP/1.1): Conditional Requests\",
      RFC 7232,\n              June 2014.\n   [RFC7234]  Fielding, R., Ed., Nottingham,
      M., Ed., and J. Reschke,\n              Ed., \"Hypertext Transfer Protocol (HTTP/1.1):
      Caching\",\n              RFC 7234, June 2014.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [BCP13]    Freed, N., Klensin, J., and T.
      Hansen, \"Media Type\n              Specifications and Registration Procedures\",
      BCP 13,\n              RFC 6838, January 2013.\n   [BCP90]    Klyne, G., Nottingham,
      M., and J. Mogul, \"Registration\n              Procedures for Message Header
      Fields\", BCP 90, RFC 3864,\n              September 2004.\n   [RFC2616]  Fielding,
      R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach,
      P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol -- HTTP/1.1\",
      RFC 2616, June 1999.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines
      for Writing an\n              IANA Considerations Section in RFCs\", BCP 26,
      RFC 5226,\n              May 2008.\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "Appendix A.  Internet Media Type multipart/byteranges\n   When a 206 (Partial
    Content) response message includes the content of\n   multiple ranges, they are
    transmitted as body parts in a multipart\n   message body ([RFC2046], Section
    5.1) with the media type of\n   \"multipart/byteranges\".\n   The multipart/byteranges
    media type includes one or more body parts,\n   each with its own Content-Type
    and Content-Range fields.  The\n   required boundary parameter specifies the boundary
    string used to\n   separate each body part.\n   Implementation Notes:\n   1.  Additional
    CRLFs might precede the first boundary string in the\n       body.\n   2.  Although
    [RFC2046] permits the boundary string to be quoted, some\n       existing implementations
    handle a quoted boundary string\n       incorrectly.\n   3.  A number of clients
    and servers were coded to an early draft of\n       the byteranges specification
    that used a media type of multipart/\n       x-byteranges, which is almost (but
    not quite) compatible with\n       this type.\n   Despite the name, the \"multipart/byteranges\"
    media type is not\n   limited to byte ranges.  The following example uses an \"exampleunit\"\n
    \  range unit:\n     HTTP/1.1 206 Partial Content\n     Date: Tue, 14 Nov 1995
    06:25:24 GMT\n     Last-Modified: Tue, 14 July 04:58:08 GMT\n     Content-Length:
    2331785\n     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n
    \    --THIS_STRING_SEPARATES\n     Content-Type: video/example\n     Content-Range:
    exampleunit 1.2-4.3/25\n     ...the first range...\n     --THIS_STRING_SEPARATES\n
    \    Content-Type: video/example\n     Content-Range: exampleunit 11.2-14.3/25\n
    \    ...the second range\n     --THIS_STRING_SEPARATES--\n"
  title: Appendix A.  Internet Media Type multipart/byteranges
- contents:
  - "Appendix B.  Changes from RFC 2616\n   Servers are given more leeway in how they
    respond to a range request,\n   in order to mitigate abuse by malicious (or just
    greedy) clients.\n   (Section 3.1)\n   A weak validator cannot be used in a 206
    response.  (Section 4.1)\n   The Content-Range header field only has meaning when
    the status code\n   explicitly defines its use.  (Section 4.2)\n   This specification
    introduces a Range Unit Registry.  (Section 5.1)\n   multipart/byteranges can
    consist of a single part.  (Appendix A)\n"
  title: Appendix B.  Changes from RFC 2616
- contents:
  - "Appendix C.  Imported ABNF\n   The following core rules are included by reference,
    as defined in\n   Appendix B.1 of [RFC5234]: ALPHA (letters), CR (carriage return),\n
    \  CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double\n   quote),
    HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any\n   8-bit sequence
    of data), SP (space), and VCHAR (any visible US-ASCII\n   character).\n   Note
    that all rules derived from token are to be compared\n   case-insensitively, like
    range-unit and acceptable-ranges.\n   The rules below are defined in [RFC7230]:\n
    \    OWS        = <OWS, see [RFC7230], Section 3.2.3>\n     token      = <token,
    see [RFC7230], Section 3.2.6>\n   The rules below are defined in other parts:\n
    \    HTTP-date  = <HTTP-date, see [RFC7231], Section 7.1.1.1>\n     entity-tag
    = <entity-tag, see [RFC7232], Section 2.3>\n"
  title: Appendix C.  Imported ABNF
- contents:
  - "Appendix D.  Collected ABNF\n   In the collected ABNF below, list rules are expanded
    as per Section\n   1.2 of [RFC7230].\n   Accept-Ranges = acceptable-ranges\n   Content-Range
    = byte-content-range / other-content-range\n   HTTP-date = <HTTP-date, see [RFC7231],
    Section 7.1.1.1>\n   If-Range = entity-tag / HTTP-date\n   OWS = <OWS, see [RFC7230],
    Section 3.2.3>\n   Range = byte-ranges-specifier / other-ranges-specifier\n   acceptable-ranges
    = ( *( \",\" OWS ) range-unit *( OWS \",\" [ OWS\n    range-unit ] ) ) / \"none\"\n
    \  byte-content-range = bytes-unit SP ( byte-range-resp /\n    unsatisfied-range
    )\n   byte-range = first-byte-pos \"-\" last-byte-pos\n   byte-range-resp = byte-range
    \"/\" ( complete-length / \"*\" )\n   byte-range-set = *( \",\" OWS ) ( byte-range-spec
    /\n    suffix-byte-range-spec ) *( OWS \",\" [ OWS ( byte-range-spec /\n    suffix-byte-range-spec
    ) ] )\n   byte-range-spec = first-byte-pos \"-\" [ last-byte-pos ]\n   byte-ranges-specifier
    = bytes-unit \"=\" byte-range-set\n   bytes-unit = \"bytes\"\n   complete-length
    = 1*DIGIT\n   entity-tag = <entity-tag, see [RFC7232], Section 2.3>\n   first-byte-pos
    = 1*DIGIT\n   last-byte-pos = 1*DIGIT\n   other-content-range = other-range-unit
    SP other-range-resp\n   other-range-resp = *CHAR\n   other-range-set = 1*VCHAR\n
    \  other-range-unit = token\n   other-ranges-specifier = other-range-unit \"=\"
    other-range-set\n   range-unit = bytes-unit / other-range-unit\n   suffix-byte-range-spec
    = \"-\" suffix-length\n   suffix-length = 1*DIGIT\n   token = <token, see [RFC7230],
    Section 3.2.6>\n   unsatisfied-range = \"*/\" complete-length\n"
  title: Appendix D.  Collected ABNF
- contents:
  - "Index\n   2\n      206 Partial Content (status code)  10\n   4\n      416 Range
    Not Satisfiable (status code)  15\n   A\n      Accept-Ranges header field  7\n
    \  C\n      Content-Range header field  12\n   G\n      Grammar\n         Accept-Ranges
    \ 7\n         acceptable-ranges  7\n         byte-content-range  12\n         byte-range
    \ 12\n         byte-range-resp  12\n         byte-range-set  5\n         byte-range-spec
    \ 5\n         byte-ranges-specifier  5\n         bytes-unit  5\n         complete-length
    \ 12\n         Content-Range  12\n         first-byte-pos  5\n         If-Range
    \ 9\n         last-byte-pos  5\n         other-content-range  12\n         other-range-resp
    \ 12\n         other-range-unit  5, 7\n         Range  8\n         range-unit
    \ 5\n         ranges-specifier  5\n         suffix-byte-range-spec  6\n         suffix-length
    \ 6\n         unsatisfied-range  12\n   I\n      If-Range header field  9\n   M\n
    \     Media Type\n         multipart/byteranges  18, 21\n         multipart/x-byteranges
    \ 19\n      multipart/byteranges Media Type  18, 21\n      multipart/x-byteranges
    Media Type  21\n   R\n      Range header field  8\n"
  title: Index
- contents:
  - "Authors' Addresses\n   Roy T. Fielding (editor)\n   Adobe Systems Incorporated\n
    \  345 Park Ave\n   San Jose, CA  95110\n   USA\n   EMail: fielding@gbiv.com\n
    \  URI:   http://roy.gbiv.com/\n   Yves Lafon (editor)\n   World Wide Web Consortium\n
    \  W3C / ERCIM\n   2004, rte des Lucioles\n   Sophia-Antipolis, AM  06902\n   France\n
    \  EMail: ylafon@w3.org\n   URI:   http://www.raubacapeu.net/people/yves/\n   Julian
    F. Reschke (editor)\n   greenbytes GmbH\n   Hafenweg 16\n   Muenster, NW  48155\n
    \  Germany\n   EMail: julian.reschke@greenbytes.de\n   URI:   http://greenbytes.de/tech/webdav/\n"
  title: Authors' Addresses
