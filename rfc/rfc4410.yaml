- title: __initial_text__
  contents:
  - '             Selectively Reliable Multicast Protocol (SRMP)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   The Selectively Reliable Multicast Protocol (SRMP) is a transport\n\
    \   protocol, intended to deliver a mix of reliable and best-effort\n   messages\
    \ in an any-to-any multicast environment, where the best-\n   effort traffic occurs\
    \ in significantly greater volume than the\n   reliable traffic and therefore\
    \ can carry sequence numbers of reliable\n   messages for loss detection.  SRMP\
    \ is intended for use in a\n   distributed simulation application environment,\
    \ where only the latest\n   value of reliable transmission for any particular\
    \ data identifier\n   requires delivery.  SRMP has two sublayers: a bundling sublayer\n\
    \   handling message aggregation and congestion control, and a\n   Selectively\
    \ Reliable Transport (SRT) sublayer.  Selection between\n   reliable and best-effort\
    \ messages is performed by the application.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Terminology ................................................3\n  \
    \ 2. Protocol Description ............................................4\n   3.\
    \ Message Formats .................................................6\n      3.1.\
    \ Bundle Message Format: .....................................6\n      3.2. Bundle\
    \ Header Format .......................................7\n      3.3. Feedback\
    \ Message Format ....................................9\n      3.4. SRT Mode 0\
    \ Header Format ..................................10\n      3.5. SRT Mode 1 Header\
    \ Format ..................................11\n      3.6. SRT Mode 2 Header Format\
    \ ..................................11\n      3.7. SRT NACK Format ...........................................12\n\
    \      3.8. User-Configurable Parameters ..............................13\n  \
    \ 4. TFMCC Operation ................................................13\n    \
    \  4.1. TCP Rate Prediction Equation for TFMCC ....................13\n      4.2.\
    \ Bundling ..................................................13\n      4.3. Congestion\
    \ Control ........................................14\n      4.4. Any-Source Multicast\
    \ ......................................14\n      4.5. Multiple Sources ..........................................14\n\
    \      4.6. Bundle Size ...............................................15\n  \
    \    4.7. Data Rate Control .........................................15\n    \
    \  4.8. Mode 1 Loss Detection .....................................16\n      \
    \     4.8.1. Sending a Negative Acknowledgement .................16\n      4.9.\
    \ Unbundling ................................................17\n      4.10. Heartbeat\
    \ Bundle .........................................17\n   5. SRT Operation ..................................................17\n\
    \      5.1. Mode 0 Operation ..........................................18\n  \
    \         5.1.1. Sending Mode 0 Messages ............................18\n    \
    \       5.1.2. Receiving Mode 0 Messages ..........................18\n      5.2.\
    \ Mode 1 Operation ..........................................18\n           5.2.1.\
    \ Sending Mode 1 Data Messages .......................19\n           5.2.2. Receiving\
    \ Mode 1 Data Messages .....................19\n           5.2.3. Sending a Negative\
    \ Acknowledgement .................20\n           5.2.4. Receiving a Negative\
    \ Acknowledgement ...............21\n      5.3. Mode 2 Operation ..........................................21\n\
    \           5.3.1. Sending Mode 2 Data Messages .......................21\n  \
    \         5.3.2. Receiving Mode 2 Data Messages .....................22\n    \
    \       5.3.3. Sending a Positive Acknowledgement .................23\n      \
    \     5.3.4. Receiving a Positive Acknowledgement ...............23\n   6. RFC\
    \ 2357 Analysis ..............................................23\n      6.1. Scalability\
    \ ...............................................23\n      6.2. Congestion ................................................24\n\
    \   7. Security Considerations ........................................25\n  \
    \ 8. List of Acronyms Used ..........................................26\n   9.\
    \ Contributions ..................................................27\n   10. References\
    \ ....................................................27\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   There is no viable generic approach to achieving reliable\
    \ transport\n   over multicast networks.  Existing successful approaches require\
    \ that\n   the transport protocol take advantage of special properties of the\n\
    \   traffic in a way originally proposed by Cohen [10].  The protocol\n   described\
    \ here is applicable to real-time traffic containing a mix of\n   two categories\
    \ of messages: a small fraction requiring reliable\n   delivery, mixed with a\
    \ predominating flow of best-effort messages.\n   This sort of traffic is associated\
    \ with distributed virtual\n   simulation (RFC 2502 [4]) and also with some forms\
    \ of distributed\n   multimedia conferencing.  These applications typically have\
    \ some data\n   that changes rarely, or not at all, so the best efficiency will\
    \ be\n   achieved by transmitting that data reliably (the external appearance\n\
    \   of a simulated vehicle is an excellent example).  They also require\n   real-time\
    \ transmission of a best-effort stream (for example, the\n   position and orientation\
    \ of the vehicle).  There is no value to\n   reliable transmission of this stream\
    \ because typically new updates\n   arrive faster than loss identification and\
    \ retransmission could take\n   place.  By piggy-backing the sequence number (SN)\
    \ of the latest\n   reliable transmission on each bundle of traffic, the reliable\
    \ and\n   best-effort traffic can co-exist synergistically.  This approach is\n\
    \   implemented in the Selectively Reliable Multicast Protocol (SRMP).\n   The\
    \ IETF has conducted a successful working group on Reliable\n   Multicast Transport\
    \ (RMT) that has produced RFCs 2357 [6], 2887 [11],\n   and 3450 through 3453\
    \ [12 - 15], which define building block\n   protocols for reliable multicast.\
    \  Selectively reliable multicast is\n   similar in spirit to these protocols\
    \ and in fact uses one of them,\n   TCP-Friendly Multicast Congestion Control\
    \ (TFMCC).  This document\n   provides the basis for specifying SRMP with TFMCC\
    \ for use on an\n   experimental basis.  Key requirements of the RMT process that\
    \ is\n   carried forward here are specified in RFC 2357 [6].  These generally\n\
    \   relate to scalability and congestion control, and are addressed in\n   section\
    \ 6 of this document.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   In this document, the key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\",\n   and \"OPTIONAL\" are to be interpreted as described in RFC 2119\
    \ [1] and\n   indicate requirement levels for compliant implementations.\n"
- title: 2.  Protocol Description
  contents:
  - "2.  Protocol Description\n   The Selectively Reliable Multicast Protocol (SRMP)\
    \ has two major\n   components: Selectively Reliable Transport (SRT) and a \"\
    bundling\n   sublayer\" that implements TCP-Friendly Multicast Congestion Control\n\
    \   (TFMCC), as proposed by Widmer and Handley [2], in order to meet the\n   requirements\
    \ of RFC 2357 [6] for congestion avoidance.\n   SRMP is capable of reliable message\
    \ delivery over multicast networks,\n   when the messages to be delivered reliably\
    \ represent a fraction of a\n   larger, associated best-effort flow and only the\
    \ latest reliable\n   message must be delivered.  The basic strategy for SRMP\
    \ is to trade\n   as little network capacity as possible for reliability by buffering\n\
    \   the most recently sent reliable message at each sender and piggy-\n   backing\
    \ its sequence number on associated best-effort messages.  For\n   this purpose,\
    \ three modes of sending are defined:\n   o  Mode 0 messages.  These will be delivered\
    \ best-effort; if lost, no\n      retransmission will be done.\n   o  Mode 1 messages.\
    \  When a Mode 1 message loss is detected, the\n      receiver will send back\
    \ a NACK to the sender, where SRMP will\n      retransmit the latest reliable\
    \ message from that sender.  Senders\n      define data identifiers (dataIDs),\
    \ allowing multiple reliable\n      message streams to be supported.  Mode 1 messages\
    \ may be up to\n      131,071 bytes long; SRMP provides for segmentation and reassembly,\n\
    \      but only for the latest Mode 1 message for any given\n      <sourceAddress,\
    \ multicastAddress, dataID>.\n   o  Mode 2 messages.  Through Mode 2 messages,\
    \ SRMP provides for a\n      lightweight, reliable, connectionless peer-to-peer\
    \ unicast\n      transaction exchange between any two members of the multicast\n\
    \      group.  This is a unicast message requiring positive\n      acknowledgement\
    \ (ACK).\n      | Application   |\n      -----------------       ----------\n\
    \      |      SRT      |\n      -----------------   ->     SRMP\n      |Bundling(TFMCC)|\n\
    \      -----------------       ----------\n      |      UDP      |\n   The bundling\
    \ sublayer is transparent to the Selectively Reliable\n   Transport (SRT) sublayer.\
    \  It implements congestion control both by\n   dropping Mode 0 messages at the\
    \ source when needed and by bundling\n   multiple short messages that are presented\
    \ by applications within a\n   short time window.  It also performs NACK suppression.\n\
    \   A bundling sublayer data unit is called a bundle.  A bundle is made\n   up\
    \ of a bundle header and one or more Mode 0 and Mode 1 SRMP\n   messages.  Retransmission\
    \ of Mode 1 messages does not imply\n   retransmission of the original bundle;\
    \ the retransmitted message\n   becomes part of a new bundle.\n   The TFMCC layer's\
    \ behavior follows the mechanism described by Widmer\n   and Handley.  This is\
    \ an equation-based multicast congestion control\n   mechanism: in a multicast\
    \ group, each receiver determines its loss\n   rate with regard to the sender,\
    \ and calculates a desired source\n   sending rate based on an equation that models\
    \ the steady-state\n   sending rate of TCP.  A distributed feedback suppression\
    \ mechanism\n   restricts feedback to those receivers likely to report the lowest\n\
    \   desired rates.  Congestion control is achieved by dropping best-\n   effort\
    \ (Mode 0) messages at random.  For example, in distributed\n   simulation, Mode\
    \ 0 messages are part of a stream of state updates for\n   dynamic data such as\
    \ geographic location; therefore, the application\n   can continue to function\
    \ (with lower fidelity) when they are dropped.\n   As described by its authors,\
    \ TFMCC's congestion control mechanism\n   works as follows:\n   o  Each receiver\
    \ measures the loss event rate and its Round-Trip Time\n      (RTT) to the sender.\n\
    \   o  Each receiver then uses this information, together with an\n      equation\
    \ for TCP throughput, to derive a TCP-friendly sending\n      rate.\n   o  Through\
    \ a distributed feedback suppression mechanism, only a\n      subset of the receivers\
    \ is allowed to give feedback to prevent a\n      feedback implosion at the sender.\
    \  The feedback mechanism ensures\n      that receivers reporting a low desired\
    \ transmission rate have a\n      high probability of sending feedback.\n   o\
    \  Receivers whose feedback is not suppressed report the calculated\n      transmission\
    \ rate back to the sender in so-called receiver\n      reports.  The receiver\
    \ reports serve two purposes: they inform the\n      sender about the appropriate\
    \ transmit rate, and they allow the\n      receivers to measure their RTT.\n \
    \  o  The sender selects the receiver that reports the lowest rate as\n      the\
    \ current limiting receiver (CLR).  Whenever feedback with an\n      even lower\
    \ rate reaches the sender, the corresponding receiver\n      becomes the CLR and\
    \ the sending rate is reduced to match that\n      receiver's calculated rate.\
    \  The sending rate increases when the\n      CLR reports a calculated rate higher\
    \ than the current sending\n      rate.\n   TFMCC was intended for fixed-size\
    \ packets with variable rate.  SRMP\n   applies it to variable-size SRMP messages\
    \ that are mostly the same\n   size because the best-effort updates typically\
    \ all represent the same\n   sort of simulation information and are grouped into\
    \ bundles of size\n   just under one MTU during periods of heavy network activity.\
    \  Future\n   developments in TFMCC for variable-size messages will be of high\n\
    \   value for inclusion in SRMP if, as expected, they prove to be\n   appropriate\
    \ for the types of traffic SRMP is intended to support.\n   SRMP is intended for\
    \ general use under applications that need its\n   services and may exist in parallel\
    \ instances on the same host.  The\n   UDP port is therefore established ad hoc\
    \ from available application\n   ports; accordingly, it would not be appropriate\
    \ to have a well-known\n   port for SRMP.\n"
- title: 3.  Message Formats
  contents:
  - '3.  Message Formats

    '
- title: '3.1.  Bundle Message Format:'
  contents:
  - "3.1.  Bundle Message Format:\n   --------------------------------------------------------------------\n\
    \   | bundle header | SRT Message 0 | SRT message 1 | SRT message 2 |...\n   --------------------------------------------------------------------\n\
    \   A bundle is an aggregation of multiple SRMP messages destined for the\n  \
    \ same multicast address.  A bundle can contain only Mode 0 and Mode 1\n   messages;\
    \ Mode 2 messages are exchanged using unicast addresses.\n   SRMP identifies the\
    \ sender and receiver using their 32-bit Sender_ID,\n   which may be an IPv4 address.\
    \  For use with IPv6, a user group will\n   need to establish a unique identifier\
    \ per host.  There is no\n   requirement for this identifier to be unique in the\
    \ Internet; it only\n   needs to be unique in the communicating group.\n"
- title: 3.2.  Bundle Header Format
  contents:
  - "3.2.  Bundle Header Format\n      0              8              16          \
    \   24             32\n      +--------------+--------------+--------------+--------------+\n\
    \      |Version| Type |fb_nr | flag  |        bundle_SN            |\n      +--------------+--------------+--------------+--------------+\n\
    \      |                       Sender_ID                           |\n      +--------------+--------------+--------------+--------------+\n\
    \      |                       Receiver_ID                         |\n      +--------------+--------------+--------------+--------------+\n\
    \      |       Sender_Timestamp      |    Receiver_Timestamp       |\n      +--------------+--------------+--------------+--------------+\n\
    \      |            x_supp           |            R_max            |\n      +--------------+--------------+--------------+--------------+\n\
    \      |  DSN_count   |   padding    |           Length            |\n      +--------------+--------------+--------------+--------------+\n\
    \      |     0 to 255 DSN: <dataID, SN, NoSegs> of this sender     |\n      +-----------------------------------------------------------+\n\
    \   Version:\n      4 bits   currently 0010\n   Type:\n      4 bits   0000 - indicates\
    \ bundle\n   fb_nr:\n      4 bits   feedback round, range 0-15\n   flag:\n   \
    \   4 bits   0001 Is_CLR\n               other bits reserved\n   bundle_SN:\n\
    \      16 bits   range 0-65535\n   Sender_Timestamp:\n      16 bits   Representing\
    \ the time that the bundle was sent out (in\n                milliseconds) based\
    \ on the sender's local clock.\n   Receiver_Timestamp:\n      16 bits   Echo of\
    \ the Receiver_Time_Stamp field (in milliseconds)\n                of the receiver\
    \ feedback message.  If the sender has\n                time delay between receiving\
    \ the feedback and echoing\n                the timestamp, it MUST adjust the\
    \ Receiver_Timestamp\n                value to compensate.\n   Receiver_ID\n \
    \     32 bits   Unique identifier for the receiver within the multicast\n    \
    \            group.  IPv4 addresses may be used.\n   Sender_ID:\n      32 bits\
    \   Unique identifier for the sender within the multicast\n                group.\
    \  IPv4 addresses may be used.\n   X_supp:\n      16 bits   The suppression rate\
    \ corresponding to the sender, in\n                bits/s.  Only those receivers\
    \ whose desired rate is less\n                than the suppression rate, or whose\
    \ RTT is larger than\n                R_max, may send feedback information to\
    \ the sender.  The\n                suppression rate is represented as a 16-bit\
    \ floating\n                point value with 8 bits for the unsigned exponent\
    \ and 8\n                bits for the unsigned mantissa.\n   R_max:\n      16\
    \ bits   The maximum of the RTTs of all receivers, in\n                milliseconds.\
    \  The Maximum RTT should be represented as\n                a 16-bit floating\
    \ point value with 8 bits for the\n                unsigned exponent and 8 bits\
    \ for the unsigned mantissa.\n   DSN_count:\n      8 bits    The count of DSN\
    \ blocks following the header.\n   Length:\n      16 bits   Range from 0~65535.\
    \  The total length of the bundle\n                in octets (including the header).\n\
    \   DSN:\n      32 bits   There can be up to 256 of these in a header.  An SRMP\n\
    \                implementation MUST support a minimum of 1.  Each DSN\n     \
    \           consists of three fields:\n      dataID:\n         16 bits   A unique\
    \ number associated with a particular data\n                   element on the\
    \ sending host, used to identify a\n                   Mode 1 message.\n     \
    \ SN:\n         9 bits    Sequence number associated with a particular Mode 1\n\
    \                   transmission of a particular dataID.\n      NoSegs:\n    \
    \     7 bits    Number of segments, if the dataID was long enough\n          \
    \         to require segmentation; otherwise 0x0.\n   Note that the number of\
    \ DSNs reflects the number of different Mode 1\n   DataIDs being supported at\
    \ this time by this instance of SRMP, and is\n   not the count of SRMP messages\
    \ bundled in this transmission.\n   Note also that 16-bit timestamps will wrap\
    \ around in 65536\n   milliseconds.  This should not be a problem unless an RTT\
    \ is greater\n   than 65 seconds. If a timestamp is less than its predecessor\n\
    \   (treating the 16 bits as an unsigned integer), its value must be\n   increased\
    \ by 65536 for comparisons against the predecessor.\n"
- title: 3.3.  Feedback Message Format
  contents:
  - "3.3.  Feedback Message Format\n      0              8              16       \
    \      24             32\n      +--------------+--------------+--------------+--------------+\n\
    \      |Version| Type | fb_nr| flag  |             X_r             |\n      +--------------+--------------+--------------+--------------+\n\
    \      |       Sender_Timestamp      |    Receiver_Timestamp       |\n      +--------------+--------------+--------------+--------------+\n\
    \      |                       Sender_ID                           |\n      +--------------+--------------+--------------+--------------+\n\
    \      |                      Receiver_ID                          |\n      +--------------+--------------+--------------+--------------+\n\
    \   Version:\n      4 bits   currently 0010\n   Type:\n      4 bits   value 0001\n\
    \   fb_nr:\n      4 bits   current feedback round of the sender\n   flag:\n  \
    \    4 bits\n         0001 - have_RTT\n         0010 - have_loss\n         0100\
    \ - receiver_leave\n         other values reserved\n   X_r:\n      16 bits   desired\
    \ sending rate X_r in bits/s, calculated by the\n                receiver to be\
    \ TCP-friendly, 16 bit floating point\n                value with 8 bits for the\
    \ unsigned exponent and 8 bits\n                for the unsigned mantissa.\n \
    \  Sender_Timestamp:\n      16 bits   Echo of the Sender_Timestamp in bundle header.\
    \  If the\n                receiver has time delay between receiving the bundle\
    \ and\n                echoing the timestamp, it MUST adjust the\n           \
    \     Sender_Timestamp value correspondently.\n   Receiver_Timestamp:\n      16\
    \ bits   The time when the feedback message was sent out from the\n          \
    \      receiver.\n   Receiver_ID:\n      32 bits   Unique identifier for the receiver\
    \ within the multicast\n                group.  IPv4 addresses may be used.  (Identifies\
    \ the\n                receiver that sends the feedback message).\n   Sender_ID:\n\
    \      32 bits   Unique identifier for the sender within the multicast\n     \
    \           group.  IPv4 addresses may be used.  (Identifies the\n           \
    \     sender that is the destination of the current feedback\n               \
    \ message.)\n"
- title: 3.4.  SRT Mode 0 Header Format
  contents:
  - "3.4.  SRT Mode 0 Header Format\n      0              8              16      \
    \       24             32\n      +--------------+--------------+--------------+--------------+\n\
    \      |Version| Type | 000 |  00000000  |        Length           |\n      +--------------+--------------+--------------+--------------+\n\
    \   Version:\n      4 bits   currently 0010\n   Type:\n      4 bits   0000\n \
    \  Mode:\n      3 bits   000\n   Padding:\n      8 bits   00000000\n   Length:\n\
    \      11 bits  Length of the payload data in octets (does not include\n     \
    \          the header).\n"
- title: 3.5.  SRT Mode 1 Header Format
  contents:
  - "3.5.  SRT Mode 1 Header Format\n      0              8              16      \
    \       24             32\n      +--------------+--------------+--------------+--------------+\n\
    \      |Version| Type | 001 |  SegNo    |            Length        |\n      +--------------+--------------+--------------+--------------+\n\
    \      |                            DSN                            |\n      +--------------+--------------+--------------+--------------+\n\
    \   Version:\n      4 bits   currently 0010\n   Type:\n      4 bits   0000\n \
    \  Mode:\n      3 bits   001\n   SegNo:\n      7 bits   The index number of this\
    \ segment.\n   Length:\n      14 bits   Length of the payload data in octets (does\
    \ not include\n                the header).\n   DSN:\n      32 bits   Same as\
    \ in the bundle header.  Note that this contains\n                NoSegs, whereas\
    \ SegNo is a separate element.\n"
- title: 3.6.  SRT Mode 2 Header Format
  contents:
  - "3.6.  SRT Mode 2 Header Format\n      0              8              16      \
    \       24             32\n      +--------------+--------------+--------------+--------------+\n\
    \      |Version| Type |010 |  00000  |            Length           |\n      +--------------+--------------+--------------+--------------+\n\
    \      |                            SN                             |\n      +--------------+--------------+--------------+--------------+\n\
    \   Version:\n      4 bits   currently 0010\n   Type:\n      4 bits   0010\n \
    \  Mode:\n      3 bits   010\n   Padding:\n      5 bits   00000\n   Length:\n\
    \      16 bits  Length of the payload data in octets (does not the\n         \
    \      include header).\n   SN:\n      32 bits   Same as in bundle header.\n"
- title: 3.7.  SRT NACK Format
  contents:
  - "3.7.  SRT NACK Format\n      0              8              16             24\
    \             32\n      +--------------+--------------+--------------+--------------+\n\
    \      |Version| Type |111 |  00000  |          reserved           |\n      +--------------+--------------+--------------+--------------+\n\
    \      |                            DSN                            |\n      +--------------+--------------+--------------+--------------+\n\
    \      |                      Sender Address                       |\n      +--------------+--------------+--------------+--------------+\n\
    \   Version:\n      4 bits   currently 0010\n   Type:\n      4 bits   0010\n \
    \  Mode:\n      3 bits   111\n   Padding:\n      5 bits   00000\n   Reserved:\n\
    \      16 bits\n   DSN:\n      32 bits  sequence number\n   Sender Address:\n\
    \      The IP address of the sender of the message being NACKed.\n"
- title: 3.8.  User-Configurable Parameters
  contents:
  - "3.8.  User-Configurable Parameters\n   Name                 Minimum Value   Recommended\
    \ Value       Units\n   DSN_Max                 1                 32         \
    \       messages\n   dataID_Timeout         none              none           \
    \      ms\n   Segment_Timeout         50                250                 ms\n\
    \   Bundle_Timeout          1                 10                  ms\n   Heartbeat_Interval\
    \      1                none                 s\n   Mode2_Max               1 \
    \               none               messages\n   ACK_Threshold          none  \
    \       worst RTT in group        ms\n"
- title: 4.  TFMCC Operation
  contents:
  - '4.  TFMCC Operation

    '
- title: 4.1.  TCP Rate Prediction Equation for TFMCC
  contents:
  - "4.1.  TCP Rate Prediction Equation for TFMCC\n   The RECOMMENDED throughput equation\
    \ for SRMP is a slightly simplified\n   version of the throughput equation for\
    \ Reno TCP from [5]:\n                                      8*s\n      X = ------------------------------------------------------\
    \   (1)\n            R * (sqrt(2*p/3) + (3*sqrt(6*p) * p * (1+32*p^2)))\n   (the\
    \ formula may be simplified for implementation), where\n      X is the transmit\
    \ rate in bits/second.\n      s is the message size in bytes.\n      R is the\
    \ round-trip time in seconds.\n      p is the loss event rate, between 0.0 and\
    \ 1.0, of the number of\n        loss events as a fraction of the number of messages\
    \ transmitted.\n   In the future, different TCP formulas may be substituted for\
    \ this\n   equation.  The requirement is that the throughput equation be a\n \
    \  reasonable approximation of the sending rate of TCP for conformant\n   TCP\
    \ congestion control.\n"
- title: 4.2.  Bundling
  contents:
  - "4.2.  Bundling\n   Multiple SRMP messages will be encapsulated into a bundle.\
    \  When a\n   new SRMP message (Mode 0 or Mode 1) arrives, the SRMP daemon will\
    \ try\n   to add the new message into the current bundle.\n   The SRMP daemon\
    \ MUST keep a timer, which will be reset when the first\n   SRMP message is added\
    \ into the bundle.  After Bundle_Timeout, the\n   timer will time out, and the\
    \ current bundle should be transmitted\n   immediately.  A new bundle will then\
    \ be initialized to hold new SRMP\n   messages.  Bundle_Timeout SHALL NOT be less\
    \ than 1 ms.  The\n   recommended value is 10 ms.\n   Also, the bundle length\
    \ MUST NOT exceed LENGTH_MAX.  If adding a new\n   SRMP message will produce a\
    \ greater length, the SRMP daemon MUST\n   initialize a new bundle for the new\
    \ SRMP messages, and the current\n   bundle should be transmitted immediately.\
    \  The recommended value for\n   LENGTH_MAX is 1454 bytes (Ethernet MTU minus\
    \ IP and UDP header\n   lengths).\n   In a bundle, there may exist multiple SRMP\
    \ messages with the same\n   dataID.  In this case, only the latest version of\
    \ that dataID is\n   useful.  SRMP may check for duplicate dataIDs in the same\
    \ bundle and\n   delete all but the latest one.  If a Mode 1 message appears in\
    \ the\n   outgoing bundle, then the corresponding DSN should not appear in the\n\
    \   bundle header.\n   The bundle header contains the DSN <dataID,SN,NoSegs> for\
    \ Mode 1\n   messages from this sender.  The absolute maximum number of DSN is\n\
    \   255; however, an implementation may apply a user-specified DSN_Max,\n   no\
    \ smaller than 1.  An implementation may support a user-defined\n   dataID_Timeout,\
    \ after which a given dataID will not be announced in\n   the bundle header unless\
    \ a new Mode 1 message has been sent.  If the\n   sender has more dataIDs sent\
    \ (and not timed out) than will fit in the\n   bundle header, the DSNs MUST be\
    \ announced on a round-robin basis,\n   with the exception that no bundle header\
    \ will announce a DSN for a\n   Mode 1 message contained within that bundle. \
    \ If a duplicate DSN is\n   received, it may be silently discarded.\n"
- title: 4.3.  Congestion Control
  contents:
  - "4.3.  Congestion Control\n   The congestion control mechanism operates as described\
    \ in [7].\n"
- title: 4.4.  Any-Source Multicast
  contents:
  - "4.4.  Any-Source Multicast\n   SRMP uses the Any-Source Multicast Mode.  Each\
    \ sender will determine\n   its maximum RTT, suppression data rate, and sending\
    \ rate with respect\n   to each sender.  Each receiver will measure its RTT and\
    \ desired rate\n   to each sender in the group, and send feedback to every sender\
    \ by\n   sending to the multicast group.\n"
- title: 4.5.  Multiple Sources
  contents:
  - "4.5.  Multiple Sources\n   Under SRMP, each group member in a multicast group\
    \ is a sender as\n   well as a receiver.  Each receiver may need to participate\
    \ in TFMCC\n   information exchange with all senders.  Thus, when a receiver sends\
    \ a\n   feedback message, it must identify to which source the message should\n\
    \   be sent using the \"Sender ID\" field in the header.\n   The feedback is multicast\
    \ to the group.  Depending on the network\n   situation, senders may select different\
    \ receivers to provide\n   feedback.  Feedback messages from receivers that are\
    \ not among those\n   selected by the local TFMCC to provide feedback should be\
    \ silently\n   discarded.\n"
- title: 4.6.  Bundle Size
  contents:
  - "4.6.  Bundle Size\n   TFMCC is designed for traffic with a fixed message size.\
    \  The maximum\n   bundle size (including header) for SRMP is set to a configurable\n\
    \   maximum, typically 1454 bytes (Ethernet MTU minus IP and UDP header\n   lengths).\
    \  The bundle size will be used in a TCP throughput equation,\n   to get a desired\
    \ source rate.  However, in SRMP, the message size is\n   variable because:\n\
    \   1. After bundle time out, the current bundle will not wait for new\n     \
    \ SRMP messages.  This happens with sources sending at a slow rate.\n   2. In\
    \ long messages, there is no further space in the current bundle\n      for new\
    \ SRMP messages.  This will happen with sources sending at a\n      high rate\
    \ or sending messages with a length over half of the\n      bundle payload size.\n\
    \   The case 1 bundle size is likely to be much smaller than that of case\n  \
    \ 2.\n   Therefore, in SRMP, the mean value of the 10 most recent bundles'\n \
    \  sizes will be used as the bundle size in the TCP throughput equation.\n   This\
    \ mean value is independent from the network condition and\n   reflects current\
    \ activity of the source.\n"
- title: 4.7.  Data Rate Control
  contents:
  - "4.7.  Data Rate Control\n   Each host will have a single instance of SRMP supporting\
    \ all of its\n   applications.  Thus, the sender's source rate is the sum of the\
    \ rates\n   of all the clients of the same multicast group.\n   If the source\
    \ rate is larger than the sender's desired transmission\n   rate, it is the sender's\
    \ responsibility to do traffic shaping.  Any\n   method that conforms to the target\
    \ sending rate may be used.  The\n   RECOMMENDED method is to randomly discard\
    \ enough Mode 0 messages to\n   meet the target rate.\n"
- title: 4.8.  Mode 1 Loss Detection
  contents:
  - "4.8.  Mode 1 Loss Detection\n   Bundle header processing includes checking each\
    \ DSN in the bundle\n   header and scheduling a NACK for each DSN bearing a dataID\
    \ for which\n   some application has indicated interest, if the SN/SegNo in that\
    \ DSN\n   indicates that a NACK is needed.  NACKs are sent in bundles and may\n\
    \   be bundled with data messages.  A NACK is required if:\n   o  the SN is one\
    \ or more greater (mod 512) than the latest received\n      Mode 1 message for\
    \ that dataID, or\n   o  the SegNo has not been received, some segment of the\
    \ <dataID,SN>\n      has been received, and a user-defined Segment_Timeout, which\
    \ SHALL\n      NOT be less than 50 ms, has expired since receipt of the first\n\
    \      SegNo for the <dataID,SN>.\n   The bundling sublayer will pass the DSN\
    \ list in any received bundle\n   header to the SRT sublayer.  It also will suppress\
    \ NACKs in outgoing\n   bundles, as described in the next section.\n"
- title: 4.8.1.  Sending a Negative Acknowledgement
  contents:
  - "4.8.1.  Sending a Negative Acknowledgement\n   Negative acknowledgements are\
    \ used by SRMP for multicast messages in\n   order to avoid the congestion of\
    \ an \"ACK implosion\" at the original\n   sender that would likely occur if positive\
    \ acknowledgements were used\n   instead.  However, with a large multicast group\
    \ spread out over a\n   congested wide-area network, there is the potential for\
    \ enough\n   members of the multicast group to fail to receive the message and\n\
    \   generate NACKs to cause considerable congestion at the original\n   sender\
    \ despite the use of negative acknowledgements instead of\n   positive acknowledgements.\
    \  For this reason, SRMP uses a NACK\n   suppression mechanism to reduce the number\
    \ of NACKs generated in\n   response to any single lost message.\n   The NACK\
    \ suppression mechanism uses the Bundle_Timeout to distribute\n   NACKs over an\
    \ appropriate time window.  This assumes that the user\n   has selected a bundle\
    \ timeout appropriate for the needs of the\n   application for real-time responsiveness.\n\
    \   When the bundling sublayer is ready to send a bundle, it removes from\n  \
    \ the bundle any NACKs for which a response has been sent by another\n   member\
    \ of the multicast group within the NACK_Repeat_Timeout window.\n   If the original\
    \ Bundle_Timeout has not expired, transmission of the\n   bundle may then be delayed\
    \ until the original Bundle_Timeout expires\n   or the bundle is full, whichever\
    \ happens first.\n"
- title: 4.9.  Unbundling
  contents:
  - "4.9.  Unbundling\n   After a receiver completes congestion control processing\
    \ on a bundle,\n   it parses the bundle into SRT messages and sends these to the\
    \ SRT\n   sublayer.\n"
- title: 4.10.  Heartbeat Bundle
  contents:
  - "4.10.  Heartbeat Bundle\n   SRMP implementations may support a user-defined Heartbeat_Interval,\n\
    \   which SHALL NOT be less than one second.  At the end of each\n   heartbeat\
    \ interval, if the sender has not sent any bundle, an empty\n   bundle will be\
    \ sent in order to trigger Mode 1 loss detection.\n"
- title: 5.  SRT Operation
  contents:
  - "5.  SRT Operation\n   SRMP operates in three distinct transmission modes in order\
    \ to\n   deliver varying levels of reliability: Mode 0 for multicast data that\n\
    \   does not require reliable transmission, Mode 1 for data that must be\n   received\
    \ reliably by all members of a multicast group, and Mode 2 for\n   data that must\
    \ be received reliably by a single dynamically\n   determined member of a multicast\
    \ group.\n   Mode 0 operates as a pure best-effort service.  Mode 1 operates with\n\
    \   negative acknowledgements only, triggered by bundle arrivals that\n   indicate\
    \ loss of a Mode 1 message.  Mode 2 uses a positive\n   acknowledgement for each\
    \ message to provide reliability and low\n   latency.  Mode 2 is used where a\
    \ transaction between two members of a\n   multicast group is needed.  Because\
    \ there can be many members in such\n   a group, use of a transaction protocol,\
    \ with reliability achieved by\n   SRMP retransmission, avoids the potentially\
    \ large amount of\n   connection setup and associated state that would be required\
    \ if each\n   pair of hosts in the group established a separate TCP connection.\n\
    \   Use of SRMP anticipates that only a small fraction of messages will\n   require\
    \ reliable multicast, and a comparably small fraction will\n   require reliable\
    \ unicast.  This is due to a property of distributed\n   virtual simulation: the\
    \ preponderance of messages consist of state\n   update streams for object attributes\
    \ such as position and\n   orientation.  SRMP is unlikely to provide effective\
    \ reliable\n   multicast if the traffic does not have this property.\n   In SRMP,\
    \ \"dataID\" is used to associate related messages with each\n   other.  Typically,\
    \ all messages with the same dataID are associated\n   with the same application\
    \ entity.  All the messages with the same\n   dataID must be transmitted in the\
    \ same mode.  Among all the messages\n   with the same dataID, the latest version\
    \  will obsolete all older\n   messages.\n"
- title: 5.1.  Mode 0 Operation
  contents:
  - "5.1.  Mode 0 Operation\n   Mode 0 is for multicast messages that do not require\
    \ reliable\n   transmission because they are part of a real-time stream of data\
    \ that\n   is periodically updated with high frequency.  Any such message is\n\
    \   very likely to have been superceded by a more recent update before\n   retransmission\
    \ could be completed.\n"
- title: 5.1.1.  Sending Mode 0 Messages
  contents:
  - "5.1.1.  Sending Mode 0 Messages\n   When an application requests transmission\
    \ of Mode 0 data, a\n   destination multicast group must be provided to SRMP along\
    \ with the\n   data to be sent.  After verifying the data length and multicast\n\
    \   group, the following steps MUST be performed by the SRT sublayer:\n   1. An\
    \ SRT message MUST be generated with the following\n      characteristics:\n \
    \     the version is set to the current version, the message type is set\n   \
    \   to 0x0, the mode is set to 0x0.  User data is included after the\n      message\
    \ header.  If the message cannot be generated as described\n      above, the user\
    \ data is discarded and the error MUST be reported\n      to the application.\n\
    \   2. If step 1 was completed without error, the newly generated message\n  \
    \    MUST be sent to the bundling sublayer.  The implementation MUST\n      report\
    \ to the application whether the message was ultimately\n      accepted by UDP.\n"
- title: 5.1.2.  Receiving Mode 0 Messages
  contents:
  - "5.1.2.  Receiving Mode 0 Messages\n   When a Mode 0 message is received by SRMP,\
    \ it MUST be processed as\n   follows: after verifying the version, message type,\
    \ and destination\n   multicast address fields, the user data MUST be delivered\
    \ to all\n   applications that are associated with the multicast group in the\n\
    \   message.  If the SRMP receiver has never received any Mode 1 messages\n  \
    \ before the Mode 0 message is received, the Mode 0 message should be\n   silently\
    \ discarded.\n   It is RECOMMENDED that the following information be provided\
    \ to the\n   receiving applications: message body, multicast address.\n"
- title: 5.2.  Mode 1 Operation
  contents:
  - "5.2.  Mode 1 Operation\n   Mode 1 is for multicast data that requires reliable\
    \ transmission.  A\n   Mode 1 message can be either a data message or a NACK.\
    \  Mode 1 data\n   messages are expected to be part of a data stream.  This data\
    \ stream\n   is likely to contain Mode 0 messages as well (see section 5.1.1),\
    \ but\n   it is possible for a data stream to be comprised solely of Mode 1\n\
    \   messages.\n"
- title: 5.2.1.  Sending Mode 1 Data Messages
  contents:
  - "5.2.1.  Sending Mode 1 Data Messages\n   After the data length, dataID, and destination\
    \ multicast group are\n   verified, SRT MUST take the following steps:\n   1.\
    \ If the message will not fit in an empty bundle with DSN_Max DSN in\n      the\
    \ header, the message MUST be segmented.  The remaining steps\n      pertain to\
    \ each segment of the message.  Each segment receives a\n      unique SegNo, starting\
    \ with 0 and ending with (NoSegs-1).\n   2. An SRT message is generated with the\
    \ following characteristics:\n      the version is set to 0x02, the message type\
    \ is set to 0x0, the\n      transmission mode is set to 0x01, the SN is set equal\
    \ to the SN of\n      the most recently sent Mode 1 complete message of the same\
    \ dataID,\n      incremented by 1 modulo 512.  If no such Mode 1 message exists,\n\
    \      the SN is set to 0x0.\n   3. The newly generated message (all segments)\
    \ must then be buffered,\n      replacing any formerly buffered Mode 1 message\
    \ of the same dataID,\n      destination multicast address.  If the message cannot\
    \ be buffered,\n      the user data is discarded and the error is reported to\
    \ the\n      application.\n   4. If step 2 was completed without error, the newly\
    \ generated message\n      is sent to the TFMCC sublayer.\n"
- title: 5.2.2.  Receiving Mode 1 Data Messages
  contents:
  - "5.2.2.  Receiving Mode 1 Data Messages\n   When a Mode 1 data message is received\
    \ by SRT, it will be processed\n   as follows (assuming that the version field\
    \ has already been verified\n   to be 0x02):\n   1. The destination address MUST\
    \ be verified to be a valid IP\n      multicast address on which this instance\
    \ of SRMP is a member.  If\n      this is not the case, the message should be\
    \ silently discarded.\n   2. The destination address MUST be verified to be one\
    \ for which some\n      application has indicated interest.  Otherwise, the message\
    \ should\n      be silently discarded.\n   3. The SN, SegNo, source_ip_address,\
    \ and the body of the received\n      message MUST be buffered, and the user data\
    \ MUST then be delivered\n      to all applications that have indicated interest\
    \ in the multicast\n      group of the received message.\n   4. When a new DSN\
    \ value is received with NoSegs greater than zero, a\n      timer should be set\
    \ for Segment_Timeout, after which a NACK should\n      be sent to the bundling\
    \ sublayer and the timer should be restarted\n      for Segment_Timeout.\n   5.\
    \ If NoSegs in the received message is not 0, a reassembly process\n      MUST\
    \ be started.  Each segment MUST be buffered.  If receipt of\n      the current\
    \ message completes the segment, the reassembled message\n      MUST be released\
    \ to the application and the Segment_Timeout timer\n      cancelled.\n   6. If\
    \ a new DSN is received before all segments of the previous DSN\n      are received,\
    \ the segments that have been received should be\n      dropped silently.\n  \
    \ 7. It is RECOMMENDED that the following information be provided to\n      the\
    \ receiving applications: message body, dataID,\n      source_ip_address, multicast_group\
    \ address.\n   8. When a client signs on to a new multicast group, all locally\n\
    \      buffered Mode 1 messages related to that multicast group should be\n  \
    \    delivered to the client immediately.\n"
- title: 5.2.3.  Sending a Negative Acknowledgement
  contents:
  - "5.2.3.  Sending a Negative Acknowledgement\n   Whenever a bundle is received,\
    \ the bundling sublayer will forward the\n   DSN list from the bundle header to\
    \ the SRT sublayer.  The SRT\n   sublayer will examine buffered values of <SenderID,dataID,SN,SegNo>\n\
    \   to determine whether a NACK is required.  If so, it will generate a\n   NACK\
    \ message and send it to the bundling sublayer.  The NACK message\n   will have\
    \ version set to 0x2, message type set to 0x2, and\n   transmission mode set to\
    \ 0x7.  dataID, SN, and destination address\n   are set to that of the Mode 1\
    \ message for which the NACK is being\n   sent.  If a NACK has been received from\
    \ any member of the destination\n   multicast group for the Mode 1 message in\
    \ question within the NACK\n   threshold, no NACK is generated.\n   For segmented\
    \ messages, there are two possible types of NACKs:\n   o  Based on the DSN list\
    \ in the bundle header, the SRT implementation\n      may determine that an entire\
    \ segmented Mode 1 message was lost.\n      In this case, the NACK MUST carry\
    \ SegNo=0x7F (all in one field).\n   o  Based on the Segment Timeout, the SRT\
    \ implementation may determine\n      that one or more segments of a message have\
    \ not been delivered.\n      In this case, a NACK will be sent for each missing\
    \ segment.\n"
- title: 5.2.4.  Receiving a Negative Acknowledgement
  contents:
  - "5.2.4.  Receiving a Negative Acknowledgement\n   When a NACK is received by SRT,\
    \ it MUST be processed as follows,\n   after verifying the multicast address,\
    \ dataID, source IP address, and\n   transmission mode:\n   1. If this instance\
    \ of SRT's most recent Mode 1 message of the dataID\n      indicated in the NACK\
    \ has an SN newer than the SN in the NACK,\n      that message (which is buffered)\
    \ should be immediately\n      retransmitted to the multicast address indicated\
    \ in the received\n      NACK.  If the most recent Mode 1 message has an SN equal\
    \ to the SN\n      indicated in the NACK, and if the SegNo field in the NACK contains\n\
    \      0x7F, all segments of the buffered Mode 1 message MUST be\n      retransmitted;\
    \ if the SegNo has some other value, only the\n      indicated segment should\
    \ be retransmitted.\n   2. Whether or not step 1 results in the retransmission\
    \ of a message,\n      the event of receiving the NACK and the (local machine)\
    \ time at\n      which the NACK was received should be buffered.  Each instance\
    \ of\n      SRT MUST buffer the number of NACKs that have been received for\n\
    \      each dataID-multicast address pair, since the most recent Mode 1\n    \
    \  message of the same pair was received and the time at which the\n      most\
    \ recent of these NACKs was received.\n"
- title: 5.3.  Mode 2 Operation
  contents:
  - "5.3.  Mode 2 Operation\n   Mode 2 is for infrequent reliable transaction-oriented\
    \ communication\n   between two dynamically determined members of a multicast\
    \ group.  TCP\n   could be used for such communication, but there would be unnecessary\n\
    \   overhead and delay in establishing a stream-oriented connection for a\n  \
    \ single exchange of data, whereas there is already an ongoing stream\n   of best-effort\
    \ data between the hosts that require Mode 2\n   transmission.  An example is\
    \ a Distributed Interactive Simulation\n   (DIS) collision PDU.\n"
- title: 5.3.1.  Sending Mode 2 Data Messages
  contents:
  - "5.3.1.  Sending Mode 2 Data Messages\n   When an application requests transmission\
    \ of Mode 2 data, a dataID\n   and a destination unicast IP address MUST be provided\
    \ to SRT along\n   with the data to be sent.  After verifying the data length,\
    \ dataID,\n   and destination address, SRT MUST perform the following steps:\n\
    \   1. An SRT message is generated with the following characteristics:\n     \
    \ the version is set to 0x02, the message type is set to 0x02, the\n      transmission\
    \ mode is set to 0x2, the dataID is set to the\n      application-provided value,\
    \ and the destination address is set to\n      the application-provided IP address.\
    \  The SN is set equal to the\n      SN of the most recently sent Mode 2 message\
    \ of the same dataID\n      incremented by 1 modulo 65536.  If no such Mode 1\
    \ message exists,\n      it is set to 0x0.\n   2. The newly generated message\
    \ is buffered.  This new message does\n      not replace any formerly buffered\
    \ Mode 2 messages.  An\n      implementation MUST provide a Mode 2 message buffer\
    \ that can hold\n      one or more Mode 2 messages. Mode 2 messages are expected\
    \ to be\n      infrequent (less than 1 percent of total traffic), but it is still\n\
    \      strongly RECOMMENDED that an implementation provide a buffer of\n     \
    \ user-configurable size Mode2_Max that can hold more than a single\n      Mode\
    \ 2 message.  If the message cannot be buffered, the user data\n      is discarded\
    \ and the error MUST be reported to the application.\n      If the message can\
    \ be buffered, it should be sent to UDP\n      immediately after being buffered.\n\
    \   3. If step 2 was completed without error, the newly generated message\n  \
    \    MUST be sent to the IP address contained in its destination\n      address\
    \ field, encapsulated within a UDP datagram.  If the UDP\n      interface on the\
    \ sending system reports an error to SRT when the\n      attempt to send the SRT\
    \ message is made, an implementation may\n      attempt to resend the message\
    \ any finite number of times.\n      However, every implementation MUST provide\
    \ a mode in which no\n      retries are attempted.  Implementations should default\
    \ to this\n      latter mode of operation.  The implementation MUST report to\
    \ the\n      application whether the message was ultimately accepted by UDP.\n\
    \   4. If some user-configurable \"ACK_Threshold\" (which should be greater\n\
    \      than the worst-case round-trip time for the multicast group)\n      elapses\
    \ without receipt of an ACK for the Mode 2 message, it is\n      retransmitted.\
    \  An implementation may define a maximum number of\n      retransmissions to\
    \ be attempted before the Mode 2 message is\n      removed from the buffer.\n"
- title: 5.3.2.  Receiving Mode 2 Data Messages
  contents:
  - "5.3.2.  Receiving Mode 2 Data Messages\n   When a Mode 2 data message is received\
    \ by SRT, it should be processed\n   as follows after verifying version, dataID,\
    \ sender address, and SN:\n   1. For Mode 2 messages, the sequence number field\
    \ is used to\n      associate the required positive acknowledgement with a specific\n\
    \      Mode 2 message.  If the message passes verification, the\n      encapsulated\
    \ user data is delivered to all applications that have\n      indicated interest\
    \ in the dataID and multicast address of the\n      received message, regardless\
    \ of the value of the SN field.\n   2. Additionally, an ACK MUST be sent to the\
    \ host from which the Mode\n      2 data message originated.  See section 5.3.3.\
    \ below for details.\n"
- title: 5.3.3.  Sending a Positive Acknowledgement
  contents:
  - "5.3.3.  Sending a Positive Acknowledgement\n   A positive acknowledgement (ACK)\
    \ is triggered by the receipt of a\n   Mode 2 data message.  To send an ACK, a\
    \ new SRT message is generated\n   with version set to 0x02, message type set\
    \ to 0x2, and transmission\n   mode set to 0x2.  The dataID and SN are those of\
    \ the Mode 2 data\n   message being acknowledged.  The destination address field\
    \ is set to\n   the source IP address from which the data message was received.\n\
    \   Since Mode 2 data messages are unicast, there is little concern about\n  \
    \ an ACK implosion causing excessive congestion at the original sender,\n   so\
    \ no suppression mechanism is necessary.\n"
- title: 5.3.4.  Receiving a Positive Acknowledgement
  contents:
  - "5.3.4.  Receiving a Positive Acknowledgement\n   When an ACK is received by SRT,\
    \ after verifying the transmission\n   mode, dataID, and source IP address against\
    \ outstanding Mode 2\n   transmission, SRT MUST remove the pending transmission\
    \ from its\n   buffer.\n"
- title: 6.  RFC 2357 Analysis
  contents:
  - "6.  RFC 2357 Analysis\n   This section provides answers to the questions posed\
    \ by RFC 2357 for\n   reliable multicast protocols, which are quoted.\n"
- title: 6.1.  Scalability
  contents:
  - "6.1.  Scalability\n   \"How scalable is the protocol to the number of senders\
    \ or receivers\n   in a group, the number of groups, and wide dispersion of group\n\
    \   members?\"\n   SRMP is intended to scale at least to hundreds of group members.\
    \  It\n   has been designed not to impose limitations on the scalability of the\n\
    \   underlying multicast network.  No problems have been identified in\n   its\
    \ mechanisms that would preclude this on uncongested networks.\n   \"Identify\
    \ the mechanisms which limit scalability and estimate those\n   limits.\"\n  \
    \ There is a practical concern with use of TFMCC, in that the receiver\n   with\
    \ the most congested path constrains delivery to the entire group.\n   Distributed\
    \ virtual simulation requires data delivery at rates\n   perceived as continuous\
    \ by humans.  Therefore, it may prove necessary\n   to assign such receivers to\
    \ different, lower-fidelity groups as a\n   practical means of sustaining performance\
    \ to the majority of\n   participating hosts.  SRMP does not have a mechanism\
    \ to support such\n   pruning at this time.\n"
- title: 6.2.  Congestion
  contents:
  - "6.2.  Congestion\n   \"How does the protocol protect the Internet from congestion?\
    \  How\n   well does it perform?  When does it fail?  Under what circumstances\n\
    \   will the protocol fail to perform the functions needed by the\n   applications\
    \ it serves?  Is there a congestion control mechanism?\n   How well does it perform?\
    \  When does it fail?\"\n   Both simulations and tests indicate that SRMP with\
    \ TFMCC displays\n   backoff comparable to that of TCP under conditions of significant\n\
    \   packet loss.  The mechanism fails in a network-friendly way, in that\n   under\
    \ severe congestion, it reduces sending of the best-effort\n   traffic to a very\
    \ small rate that typically is unsatisfactory to\n   support a virtual simulation.\
    \  This is possible because the reliable\n   traffic typically is a small percentage\
    \ of the overall traffic and\n   SRMP is NACK oriented, with NACK suppression,\
    \ so that reliable\n   traffic loss adds little traffic to the total.  If the\
    \ traffic mix\n   assumption is not met, the reliable traffic (which does not\
    \ back off\n   under increased RTT) could produce a higher level of traffic than\
    \ a\n   comparable TCP connection.  However, levels of reliable traffic this\n\
    \   large are not in the intended application domain of SRMP.\n   \"Include a\
    \ description of trials and/or simulations which support the\n   development of\
    \ the protocol and the answers to the above questions.\"\n   SRMP has been simulated\
    \ using a discrete event simulator developed\n   for academic use [8].  The design\
    \ assumptions were validated by the\n   results.  It also has been emulated in\
    \ a LAN-based cluster and\n   application-tested in a wide-area testbed under\
    \ its intended traffic\n   mix (distributed virtual simulation) and using a traffic\
    \ generator\n   with losses emulated by random dropping of packets [9].\n   \"\
    Include an analysis of whether the protocol has congestion avoidance\n   mechanisms\
    \ strong enough to cope with deployment in the Global\n   Internet, and if not,\
    \ clearly document the circumstances in which\n   congestion harm can occur. \
    \ How are these circumstances to be\n   prevented?\"\n   Because it provides sending\
    \ backoff comparable to TCP, SRMP is able\n   to function as well as TCP for congestion\
    \ avoidance, even in the\n   Global Internet.  The only way an SRMP sender can\
    \ generate congestion\n   is to use the protocol for unintended purposes, for\
    \ example, reliable\n   transmission of a large fraction of the traffic.  Doing\
    \ this would\n   produce unsatisfactory results for the application, as SRMP's\n\
    \   mechanism for providing reliability will not function well if the\n   best-effort\
    \ traffic does not constitute the majority of the total\n   traffic.\n   \"Include\
    \ a description of any mechanisms which contain the traffic\n   within limited\
    \ network environments.\"\n   SRMP has no such mechanisms, as it is intended for\
    \ use over the open\n   Internet.\n   \"Reliable multicast protocols must include\
    \ an analysis of how they\n   address a number of security and privacy concerns.\"\
    \n   See section 7 below.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   As a transport protocol, SRMP is subject to denial\
    \ of service by\n   hostile third parties sending conflicting values of its parameters\
    \ on\n   the multicast address.  SRMP could attempt to protect itself from\n \
    \  this sort of behavior.  However, it can be shielded from such attacks\n   by\
    \ traffic authentication at the network layer, as described below.\n   A comparable\
    \ level of authentication also could be obtained by a\n   message using MD5, or\
    \ a similar message hash in each bundle, and\n   using the SRMP bundle header\
    \ to detect duplicate transmissions from a\n   given host.  However, this would\
    \ duplicate the function of existing\n   network layer authentication protocols.\n\
    \   Specific threats that can be eliminated by packet-level\n   authentication\
    \ are as follows:\n   a. Amplification attack: SRMP receivers could be manipulated\
    \ into\n      sending large amounts of NACK traffic, which could cause network\n\
    \      congestion or overwhelm the processing capabilities of a sender.\n    \
    \  This could be done by sending them faked traffic indicating that a\n      reliable\
    \ transmission has been lost.  SRMP's NACK suppression\n      limits the effect\
    \ of such manipulation.  However, true protection\n      requires authentication\
    \ of each bundle.\n   b. Denial-of-service attack: If an SRMP sender accepts a\
    \ large number\n      of forged NACKs, it will flood the multicast group with\
    \ repair\n      messages.  This attack also is stopped by per-bundle\n      authentication.\n\
    \   c. Replay attack: The attacker could copy a valid, authenticated\n      bundle\
    \ containing a NACK and send it repeatedly to the original\n      sender of the\
    \ NACKed data.  Protection against this attack\n      requires a sequence number\
    \ per transmission per source host.  The\n      SRMP bundle header sequence number\
    \ would satisfy this need.\n      However, the SN also can be applied at a lower\
    \ layer.\n   d. Reverse path forwarding attack (spoofing): If checks are not\n\
    \      enabled in all network routers and switches along the path from\n     \
    \ each sender to all receivers, forged packets can be injected into\n      the\
    \ multicast tree data path to manipulate the protocol into\n      sending a large\
    \ volume of repairs.  Packet-level authentication\n      can eliminate this possibility.\n\
    \   e. Inadvertent errors: A receiver with an incorrect or corrupted\n      implementation\
    \ of TFMCC could respond with values of RTT that\n      might stimulate a TFMCC\
    \ sender to create or increase congestion in\n      the path to that sender. \
    \ It is therefore RECOMMENDED that\n      receivers be required to identify themselves\
    \ as legitimate before\n      they receive the Session Description needed to join\
    \ the session.\n      How receivers identify themselves as legitimate is outside\
    \ the\n      scope of this document.\n   The required authentication could become\
    \ part of SRMP or could be\n   accomplished by a lower layer protocol.  In any\
    \ case, it needs to be\n   (1) scalable and (2) not very computationally demanding\
    \ so it can be\n   performed with minimal delay on a real-time virtual simulation\n\
    \   stream.  Public-key encryption meets the first requirement but not\n   the\
    \ second.  Using the IPsec Authentication Header (AH) (RFC 4302\n   [3]) meets\
    \ the second requirement using symmetric-key cryptography.\n   See RFC 4302 [3]\
    \ for guidance on multicast per-packet authentication.\n   In practice, users\
    \ of distributed simulation are likely to work over\n   a (possibly virtual) private\
    \ network and thus will not need special\n   authentication for SRMP.\n"
- title: 8.  List of Acronyms Used
  contents:
  - "8.  List of Acronyms Used\n   ACK   - positive acknowledgement\n   AH    - Authentication\
    \ Header\n   CLR   - current limiting receiver\n   IPSEC - Internet Protocol Security\n\
    \   MTU   - maximum transmission unit\n   NACK  - negative acknowledgement\n \
    \  RTT   - round-trip time\n   SA    - security association\n   SRMP  - Selectively\
    \ Reliable Multicast Protocol\n   SRT   - Selectively Reliable Transport\n   TFMCC\
    \ - TCP-Friendly Multicast Congestion Control\n"
- title: 9.  Contributions
  contents:
  - "9.  Contributions\n   We gratefully acknowledge the significant contributions\
    \ of two\n   people without whom this RFC would not have been developed.\n   Vincent\
    \ Laviano created the first specification and implementation\n   of SRMP (at that\
    \ time called SRTP).  Babu Shanmugam employed SRMP\n   in a sizable distributed\
    \ virtual simulation environment, where he\n   revised the implementation and\
    \ helped revise the design to support\n   distributed virtual simulation workload\
    \ effectively.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n \
    \  [2]  J. Widmer, M. Handley, Extending Equation-Based Congestion\n        Control\
    \ to Multicast Applications, ACM SIGCOMM Conference, San\n        Diego, August\
    \ 2001.  <http://www.sigcomm.org/sigcomm2001/p22-\n        widmer.pdf>\n   [3]\
    \  Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [4]  Pullen, M., Myjak, M., and C. Bouwens,\
    \ \"Limitations of Internet\n        Protocol Suite for Distributed Simulation\
    \ the Large Multicast\n        Environment\", RFC 2502, February 1999.\n   [5]\
    \  J. Padhye, V. Firoiu, D. Towsley and J. Kurose, \"Modeling TCP\n        Throughput:\
    \ A Simple Model and its Empirical Validation\",\n        Proceedings of ACM SIGCOMM\
    \ 1998.\n   [6]  Mankin, A., Romanow, A., Bradner, S., and V. Paxson, \"IETF\n\
    \        Criteria for Evaluating Reliable Multicast Transport and\n        Application\
    \ Protocols\", RFC 2357, June 1998.\n   [7]  Floyd, S., \"Congestion Control Principles\"\
    , BCP 41, RFC 2914,\n        September 2000.\n   [8]  J. M. Pullen, \"The Network\
    \ Workbench: Network Simulation\n        Software for Academic Investigation of\
    \ Internet Concepts,\"\n        Computer Networks Vol 32 No 3 pp 365-378, March\
    \ 2000.\n   [9]  J. M. Pullen, R. Simon, F. Zhao and W. Chang, \"NGI-FOM over\n\
    \        RTI-NG and SRMP: Lessons Learned,\" Proceedings of the IEEE Fall\n  \
    \      Simulation Interoperability Workshop, paper 03F-SIW-111,\n        Orlando,\
    \ FL, September 2003.\n   [10] D. Cohen, \"NG-DIS-PDU: The Next Generation of\
    \ DIS-PDU (IEEE-\n        P1278)\", 10th Workshop on Standards for Interoperability\
    \ of\n        Distributed Simulations, March 1994.\n   [11] Handley, M., Floyd,\
    \ S., Whetten, B., Kermode, R., Vicisano, L.,\n        and M. Luby, \"The Reliable\
    \ Multicast Design Space for Bulk Data\n        Transfer\", RFC 2887, August 2000.\n\
    \   [12] Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., and J.\n        Crowcroft,\
    \ \"Asynchronous Layered Coding (ALC) Protocol\n        Instantiation\", RFC 3450,\
    \ December 2002.\n   [13] Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., Handley,\
    \ M., and\n        J. Crowcroft, \"Layered Coding Transport (LCT) Building Block\"\
    ,\n        RFC 3451, December 2002.\n   [14] Luby, M., Vicisano, L., Gemmell,\
    \ J., Rizzo, L., Handley, M., and\n        J. Crowcroft, \"Forward Error Correction\
    \ (FEC) Building Block\",\n        RFC 3452, December 2002.\n   [15] Luby, M.,\
    \ Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and\n        J. Crowcroft,\
    \ \"The Use of Forward Error Correction (FEC) in\n        Reliable Multicast\"\
    , RFC 3453, December 2002.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   J. Mark Pullen\n   C4I Center\n   George Mason University\n\
    \   Fairfax, VA 22030\n   USA\n   EMail: mpullen@gmu.edu\n   Fei Zhao\n   C4I\
    \ Center\n   George Mason University\n   Fairfax, VA 22030\n   USA\n   EMail:\
    \ fzhao@netlab.gmu.edu\n   Danny Cohen\n   Sun Microsystems\n   M/S UMPK16-160\n\
    \   16 Network Circle\n   Menlo Park, CA 94025\n   USA\n   EMail: danny.cohen@sun.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
