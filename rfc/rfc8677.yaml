- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                        D. Trossen
  contents:
  - "Independent Submission                                        D. Trossen\n  \
    \  Name-Based Service Function Forwarder (nSFF) Component within a\n         \
    \      Service Function Chaining (SFC) Framework\n"
- title: Abstract
  contents:
  - "Abstract\n   Adoption of cloud and fog technology allows operators to deploy\
    \ a\n   single \"Service Function\" (SF) to multiple \"execution locations\".\n\
    \   The decision to steer traffic to a specific location may change\n   frequently\
    \ based on load, proximity, etc.  Under the current Service\n   Function Chaining\
    \ (SFC) framework, steering traffic dynamically to\n   the different execution\
    \ endpoints requires a specific \"rechaining\",\n   i.e., a change in the service\
    \ function path reflecting the different\n   IP endpoints to be used for the new\
    \ execution points.  This procedure\n   may be complex and take time.  In order\
    \ to simplify rechaining and\n   reduce the time to complete the procedure, we\
    \ discuss separating the\n   logical Service Function Path (SFP) from the specific\
    \ execution\n   endpoints.  This can be done by identifying the SFs using a name\n\
    \   rather than a routable IP endpoint (or Layer 2 address).  This\n   document\
    \ describes the necessary extensions, additional functions,\n   and protocol details\
    \ in the Service Function Forwarder (SFF) to\n   handle name-based relationships.\n\
    \   This document presents InterDigital's approach to name-based SFC.  It\n  \
    \ does not represent IETF consensus and is presented here so that the\n   SFC\
    \ community may benefit from considering this mechanism and the\n   possibility\
    \ of its use in the edge data centers.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not candidates for any level of Internet\
    \ Standard;\n   see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8677.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n   2.  Terminology\n   3.  Example Use\
    \ Case: 5G Control-Plane Services\n   4.  Background\n     4.1.  Relevant Part\
    \ of SFC Architecture\n     4.2.  Challenges with Current Framework\n   5.  Name-Based\
    \ Operation in SFF\n     5.1.  General Idea\n     5.2.  Name-Based Service Function\
    \ Path (nSFP)\n     5.3.  Name-Based Network Locator Map (nNLM)\n     5.4.  Name-Based\
    \ Service Function Forwarder (nSFF)\n     5.5.  High-Level Architecture\n    \
    \ 5.6.  Operational Steps\n   6.  nSFF Forwarding Operations\n     6.1.  nSFF\
    \ Protocol Layers\n     6.2.  nSFF Operations\n       6.2.1.  Forwarding between\
    \ nSFFs and nSFF-NRs\n       6.2.2.  SF Registration\n       6.2.3.  Local SF\
    \ Forwarding\n       6.2.4.  Handling of HTTP Responses\n       6.2.5.  Remote\
    \ SF Forwarding\n   7.  IANA Considerations\n   8.  Security Considerations\n\
    \   9.  References\n     9.1.  Normative References\n     9.2.  Informative References\n\
    \   Acknowledgements\n   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The requirements on today's networks are very diverse, enabling\n\
    \   multiple use cases such as the Internet of Things (IoT), Content\n   Distribution,\
    \ Gaming, and Network functions such as Cloud Radio\n   Access Network (RAN) and\
    \ 5G control planes based on a Service-Based\n   Architecture (SBA).  These services\
    \ are deployed, provisioned, and\n   managed using Cloud-based techniques as seen\
    \ in the IT world.\n   Virtualization of compute and storage resources is at the\
    \ heart of\n   providing (often web) services to end users with the ability to\n\
    \   quickly provision virtualized service endpoints through, e.g.,\n   container-based\
    \ techniques.  This creates the ability to dynamically\n   compose new services\
    \ from existing services.  It also allows an\n   operator to move a service instance\
    \ in response to user mobility or\n   to change resource availability.  When moving\
    \ from a purely \"distant\n   cloud\" model to one of localized micro data centers\
    \ with regional,\n   metro, or even street level, often called \"edge\" data centers,\
    \ such\n   virtualized service instances can be instantiated in topologically\n\
    \   different locations with the overall \"distant\" data center now being\n \
    \  transformed into a network of distributed ones.  The reaction of\n   content\
    \ providers, like Facebook, Google, NetFlix, and others, is not\n   just to rely\
    \ on deploying content servers at the ingress of the\n   customer network.  Instead,\
    \ the trend is towards deploying multiple\n   Point of Presences (POPs) within\
    \ the customer network, those POPs\n   being connected through proprietary mechanisms\
    \ [Schlinker2017] to\n   push content.\n   The Service Function Chaining (SFC)\
    \ framework [RFC7665] allows\n   network operators as well as service providers\
    \ to compose new\n   services by chaining individual \"service functions\".  Such\
    \ chains are\n   expressed through explicit relationships of functional components\n\
    \   (the SFs) realized through their direct Layer 2 (e.g., Media Access\n   Control\
    \ (MAC) address) or Layer 3 (e.g., IP address) relationship as\n   defined through\
    \ next-hop information that is being defined by the\n   network operator.  See\
    \ Section 4 for more background on SFC.\n   In a dynamic service environment of\
    \ distributed data centers such as\n   the one outlined above, with the ability\
    \ to create and recreate\n   service endpoints frequently, the SFC framework requires\n\
    \   reconfiguring the existing chain through information based on the new\n  \
    \ relationships, causing overhead in a number of components,\n   specifically\
    \ the orchestrator that initiates the initial SFC and any\n   possible reconfiguration.\n\
    \   This document describes how such changes can be handled without\n   involving\
    \ the initiation of new and reconfigured SFCs.  This is\n   accomplished by lifting\
    \ the chaining relationship from Layer 2 and\n   Layer 3 information to that of\
    \ SF \"names\", which can, for instance,\n   be expressed as URIs.  In order to\
    \ transparently support such named\n   relationships, we propose to embed the\
    \ necessary functionality\n   directly into the Service Function Forwarder (SFF)\
    \ as described in\n   [RFC7665].  With that, the SFF described in this document\
    \ allows for\n   keeping an existing SFC intact, as described by its Service Function\n\
    \   Path (SFP), while enabling the selection of appropriate service\n   function\
    \ endpoint(s) during the traversal of packets through the SFC.\n   This document\
    \ is an Independent Submission to the RFC Editor.  It is\n   not an output of\
    \ the IETF SFC WG.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n\
    \   capitals, as shown here.\n"
- title: '3.  Example Use Case: 5G Control-Plane Services'
  contents:
  - "3.  Example Use Case: 5G Control-Plane Services\n   We exemplify the need for\
    \ chaining SFs at the level of a service name\n   through a use case stemming\
    \ from the current 3GPP Release 16 work on\n   Service Based Architecture (SBA)\
    \ [SDO-3GPP-SBA],\n   [SDO-3GPP-SBA-ENHANCEMENT].  In this work, mobile network\
    \ control\n   planes are proposed to be realized by replacing the traditional\n\
    \   network function interfaces with a fully service-based one.  HTTP was\n  \
    \ chosen as the application-layer protocol for exchanging suitable\n   service\
    \ requests [SDO-3GPP-SBA].  With this in mind, the exchange\n   between, for example,\
    \ the 3GPP-defined (Rel. 15) Session Management\n   Function (SMF) and the Access\
    \ and Mobility Management Function (AMF)\n   in a 5G control plane is being described\
    \ as a set of web-service-like\n   requests that are, in turn, embedded into HTTP\
    \ requests.  Hence,\n   interactions in a 5G control plane can be modeled based\
    \ on SFCs where\n   the relationship is between the specific (IP-based) SF endpoints\
    \ that\n   implement the necessary service endpoints in the SMF and AMF.  The\n\
    \   SFs are exposed through URIs with work ongoing to define the used\n   naming\
    \ conventions for such URIs.\n   This move from a network function model (in pre-Release\
    \ 15 systems of\n   3GPP) to a service-based model is motivated through the proliferation\n\
    \   of data-center operations for mobile network control-plane services.\n   In\
    \ other words, typical IT-based methods to service provisioning,\n   particularly\
    \ that of virtualization of entire compute resources, are\n   envisioned to being\
    \ used in future operations of mobile networks.\n   Hence, operators of such future\
    \ mobile networks desire to virtualize\n   SF endpoints and direct (control-plane)\
    \ traffic to the most\n   appropriate current service instance in the most appropriate\
    \ (local)\n   data center.  Such a data center is envisioned as being\n   interconnected\
    \ through a software-defined wide area network (SD-WAN).\n   \"Appropriate\" here\
    \ can be defined by topological or geographical\n   proximity of the service initiator\
    \ to the SF endpoint.\n   Alternatively, network or service instance compute load\
    \ can be used\n   to direct a request to a more appropriate (in this case less\
    \ loaded)\n   instance to reduce possible latency of the overall request.  Such\n\
    \   data-center-centric operation is extended with the trend towards\n   regionalization\
    \ of load through a \"regional office\" approach, where\n   micro data centers\
    \ provide virtualizable resources that can be used\n   in the service execution,\
    \ creating a larger degree of freedom when\n   choosing the \"most appropriate\"\
    \ service endpoint for a particular\n   incoming service request.\n   While the\
    \ move to a service-based model aligns well with the\n   framework of SFC, choosing\
    \ the most appropriate service instance at\n   runtime requires so-called \"rechaining\"\
    \ of the SFC since the\n   relationships in said SFC are defined through Layer\
    \ 2 or Layer 3\n   identifiers, which, in turn, are likely to be different if\
    \ the chosen\n   service instances reside in different parts of the network (e.g.,\
    \ in\n   a regional data center).\n   Hence, when a traffic flow is forwarded\
    \ over a service chain\n   expressed as an SFC-compliant SFP, packets in the traffic\
    \ flow are\n   processed by the various SF instances, with each SF instance applying\n\
    \   an SF prior to forwarding the packets to the next network node.  It\n   is\
    \ a service-layer concept and can possibly work over any Virtual\n   network layer\
    \ and corresponding underlay network.  The underlay\n   network can be IP or alternatively\
    \ any Layer 2 technology.  At the\n   service layer, SFs are identified using\
    \ a path identifier and an\n   index.  Eventually, this index is translated to\
    \ an IP address (or MAC\n   address) of the host where the SF is running.  Because\
    \ of this, any\n   change-of-service function instance is likely to require a\
    \ change of\n   the path information since either the IP address (in the case\
    \ of\n   changing the execution from one data center to another) or MAC\n   address\
    \ will change due to the newly selected SF instance.\n   Returning to our 5G control-plane\
    \ example, a user's connection\n   request to access an application server in\
    \ the Internet may start\n   with signaling in the control plane to set up user-plane\
    \ bearers.\n   The connection request may flow through SFs over a service chain\
    \ in\n   the control plane, as deployed by a network operator.  Typical SFs in\n\
    \   a 5G control plane may include \"RAN termination / processing\", \"Slice\n\
    \   Selection Function\", \"AMF\", and \"SMF\".  A \"Network Slice\" is a\n  \
    \ complete logical network including Radio Access Network (RAN) and\n   Core Network\
    \ (CN).  Distinct RAN and CN Slices may exist.  A device\n   may access multiple\
    \ Network Slices simultaneously through a single\n   RAN.  The device may provide\
    \ Network Slice Selection Assistance\n   Information (NSSAI) parameters to the\
    \ network to help it select a RAN\n   and a Core Network part of a slice instance.\
    \  Part of the control\n   plane, the Common Control Network Function (CCNF),\
    \ includes the\n   Network Slice Selection Function (NSSF), which is in charge\
    \ of\n   selecting core Network Slice instances.  The classifier, as described\n\
    \   in SFC architecture, may reside in the user terminal or at the\n   Evolved\
    \ Node B (eNB).  These SFs can be configured to be part of an\n   SFC.  We can\
    \ also say that some of the configurations of the SFP may\n   change at the execution\
    \ time.  For example, the SMF may be relocated\n   as the user moves and a new\
    \ SMF may be included in the SFP based on\n   user location.  Figure 1 shows the\
    \ example SFC described here.\n               | User |   | Slice   |  |     |\
    \   |     |\n               | App  |-->| Control |->| AMF |-->| SMF |-->\n   \
    \            | Fn   |   | Function|  |     |   |     |\n        Figure 1: Mapping\
    \ SFC onto Service Function Execution Points\n                       along a Service\
    \ Function Path\n"
- title: 4.  Background
  contents:
  - "4.  Background\n   [RFC7665] describes an architecture for the specification,\
    \ creation,\n   and ongoing maintenance of SFCs.  It includes architectural concepts,\n\
    \   principles, and components used in the construction of composite\n   services\
    \ through deployment of SFCs.  In the following, we outline\n   the parts of this\
    \ SFC architecture relevant for our proposed\n   extension, followed by the challenges\
    \ with this current framework in\n   the light of our example use case.\n"
- title: 4.1.  Relevant Part of SFC Architecture
  contents:
  - "4.1.  Relevant Part of SFC Architecture\n   The SFC architecture, as defined\
    \ in [RFC7665], describes\n   architectural components such as SF, classifier,\
    \ and SFF.  It\n   describes the SFP as the logical path of an SFC.  Forwarding\
    \ traffic\n   along such an SFP is the responsibility of the SFF.  For this, the\n\
    \   SFFs in a network maintain the requisite SFP forwarding information.\n   Such\
    \ SFP forwarding information is associated with a service path\n   identifier\
    \ (SPI) that is used to uniquely identify an SFP.  The\n   service forwarding\
    \ state is represented by the Service Index (SI) and\n   enables an SFF to identify\
    \ which SFs of a given SFP should be\n   applied, and in what order.  The SFF\
    \ also has information that allows\n   it to forward packets to the next SFF after\
    \ applying local SFs.\n   The operational steps to forward traffic are then as\
    \ follows: Traffic\n   arrives at an SFF from the network.  The SFF determines\
    \ the\n   appropriate SF the traffic should be forwarded to via information\n\
    \   contained in the SFC encapsulation.  After SF processing, the traffic\n  \
    \ is returned to the SFF and, if needed, is forwarded to another SF\n   associated\
    \ with that SFF.  If there is another non-local hop (i.e.,\n   to an SF with a\
    \ different SFF) in the SFP, the SFF further\n   encapsulates the traffic in the\
    \ appropriate network transport\n   protocol and delivers it to the network for\
    \ delivery to the next SFF\n   along the path.  Related to this forwarding responsibility,\
    \ an SFF\n   should be able to interact with metadata.\n"
- title: 4.2.  Challenges with Current Framework
  contents:
  - "4.2.  Challenges with Current Framework\n   As outlined in previous sections,\
    \ the SFP defines an ordered sequence\n   of specific SF instances being used\
    \ for the interaction between\n   initiator and SFs along the SFP.  These SFs\
    \ are addressed by IP (or\n   any L2/MAC) addresses and defined as next-hop information\
    \ in the\n   network locator maps of traversing SFF nodes.\n   As outlined in\
    \ our use case, however, the service provider may want\n   to provision SFC nodes\
    \ based on dynamically spun-up SF instances so\n   that these (now virtualized)\
    \ SFs can be reached in the SFC domain\n   using the SFC underlay layer.\n   Following\
    \ the original model of SFC, any change in a specific\n   execution point for\
    \ a specific SF along the SFP will require a change\n   of the SFP information\
    \ (since the new SF execution point likely\n   carries different IP or L2 address\
    \ information) and possibly even the\n   next-hop information in SFFs along the\
    \ SFP.  In case the availability\n   of new SF instances is rather dynamic (e.g.,\
    \ through the use of\n   container-based virtualization techniques), the current\
    \ model and\n   realization of SFC could lead to reducing the flexibility of service\n\
    \   providers and increasing the management complexity incurred by the\n   frequent\
    \ changes of (service) forwarding information in the\n   respective SFF nodes.\
    \  This is because any change of the SFP (and\n   possibly next-hop info) will\
    \ need to go through suitable management\n   cycles.\n   To address these challenges\
    \ through a suitable solution, we identify\n   the following requirements:\n \
    \  *  Relations between Service Execution Points MUST be abstracted so\n     \
    \ that, from an SFP point of view, the Logical Path never changes.\n   *  Deriving\
    \ the Service Execution Points from the abstract SFP SHOULD\n      be fast and\
    \ incur minimum delay.\n   *  Identification of the Service Execution Points SHOULD\
    \ NOT use a\n      combination of Layer 2 or Layer 3 mechanisms.\n   The next\
    \ section outlines a solution to address the issue, allowing\n   for keeping SFC\
    \ information (represented in its SFP) intact while\n   addressing the desired\
    \ flexibility of the service provider.\n"
- title: 5.  Name-Based Operation in SFF
  contents:
  - '5.  Name-Based Operation in SFF

    '
- title: 5.1.  General Idea
  contents:
  - "5.1.  General Idea\n   The general idea is two pronged.  Firstly, we elevate\
    \ the definition\n   of an SFP onto the level of \"name-based interactions\" rather\
    \ than\n   limiting SFPs to Layer 2 or Layer 3 information only.  Secondly, we\n\
    \   extend the operations of the SFF to allow for forwarding decisions\n   that\
    \ take into account such name-based interaction while remaining\n   backward compatible\
    \ to the current SFC architecture as defined in\n   [RFC7665].  In the following\
    \ sections, we outline these two\n   components of our solution.\n   If the next-hop\
    \ information in the Network Locator Map (NLM) is\n   described using an L2/L3\
    \ identifier, the name-based SFF (nSFF) may\n   operate as described for (traditional)\
    \ SFF, as defined in [RFC7665].\n   On the other hand, if the next-hop information\
    \ in the NLM is\n   described as a name, then the nSFF operates as described in\
    \ the\n   following sections.\n   In the following sections, we outline the two\
    \ components of our\n   solution.\n"
- title: 5.2.  Name-Based Service Function Path (nSFP)
  contents:
  - "5.2.  Name-Based Service Function Path (nSFP)\n   The existing SFC framework\
    \ is defined in [RFC7665].  Section 4\n   outlines that the SFP information is\
    \ representing path information\n   based on Layer 2 or Layer 3 information, i.e.,\
    \ MAC or IP addresses,\n   causing the aforementioned frequent adaptations in\
    \ cases of\n   execution-point changes.  Instead, we introduce the notion of a\n\
    \   \"name-based Service Function Path (nSFP)\".\n   In today's networking terms,\
    \ any identifier can be treated as a name,\n   but we will illustrate the realization\
    \ of a \"Name-based SFP\" through\n   extended SFF operations (see Section 6)\
    \ based on URIs as names and\n   HTTP as the protocol of exchanging information.\
    \  Here, URIs are being\n   used to name for an SF along the nSFP.  Note that\
    \ the nSFP approach\n   is not restricted to HTTP (as the protocol) and URIs (as\
    \ next-hop\n   identifier within the SFP).  Other identifiers such as an IP address\n\
    \   itself can also be used and are interpreted as a \"name\" in the nSFP.\n \
    \  IP addresses as well as fully qualified domain names forming complex\n   URIs\
    \ (uniform resource identifiers), such as www.example.com/\n   service_name1,\
    \ are all captured by the notion of \"name\" in this\n   document.\n   Generally,\
    \ nSFPs are defined as an ordered sequence of the \"name\" of\n   SFs, and a typical\
    \ nSFP may look like: 192.0.x.x -> www.example.com\n   -> www.example2.com/service1\
    \ -> www.example2.com/service2.\n   Our use case in Section 3 can then be represented\
    \ as an ordered named\n   sequence.  An example for a session initiation that\
    \ involves an\n   authentication procedure, this could look like 192.0.x.x ->\n\
    \   smf.example.org/session_initiate -> amf.example.org/auth ->\n   smf.example.org/session_complete\
    \ -> 192.0.x.x.  (Note that this\n   example is only a conceptual one since the\
    \ exact nature of any future\n   SBA-based exchange of 5G control-plane functions\
    \ is yet to be defined\n   by standardization bodies such as 3GPP).\n   In accordance\
    \ with our use case in Section 3, any of these named\n   services can potentially\
    \ be realized through more than one replicated\n   SF instance.  This leads to\
    \ making dynamic decisions on where to send\n   packets along the SAME SFP information,\
    \ being provided during the\n   execution of the SFC.  Through elevating the SFP\
    \ onto the notion of\n   name-based interactions, the SFP will remain the same\
    \ even if those\n   specific execution points change for a specific service interaction.\n\
    \   The following diagram in Figure 2 describes this nSFP concept and the\n  \
    \ resulting mapping of those named interactions onto (possibly)\n   replicated\
    \ instances.\n     |Service Layer                                            \
    \      |\n     | 192.0.x.x --> www.example.com --> www.example2.com -->      \
    \  |\n     |Underlay Network      \\/              \\/                       |\n\
    \     |               Compute and       Compute and                   |\n    \
    \ |               storage nodes     storage nodes                 |\n        Figure\
    \ 2: Mapping SFC onto Service Function Execution Points\n         along a Service\
    \ Function Path Based on Virtualized Service\n                             Function\
    \ Instance\n"
- title: 5.3.  Name-Based Network Locator Map (nNLM)
  contents:
  - "5.3.  Name-Based Network Locator Map (nNLM)\n   In order to forward a packet\
    \ within an nSFP, we need to extend the\n   NLM as defined in [RFC8300] with the\
    \ ability to consider name\n   relations based on URIs as well as high-level transport\
    \ protocols\n   such as HTTP for means of SFC packet forwarding.  Another example\
    \ for\n   SFC packet forwarding could be that of Constrained Application\n   Protocol\
    \ (CoAP).\n   The extended NLM or name-based Network Locator Map (nNLM) is shown\
    \ in\n   Table 1 as an example for www.example.com being part of the nSFP.\n \
    \  Such extended nNLM is stored at each SFF throughout the SFC domain\n   with\
    \ suitable information populated to the nNLM during the\n   configuration phase.\n\
    \     | SPI | SI  | Next Hop(s)        | Transport Encapsulation (TE) |\n    \
    \ | 10  | 255 | 192.0.2.1          | VXLAN-gpe                    |\n     | 10\
    \  | 254 | 198.51.100.10      | GRE                          |\n     | 10  | 253\
    \ | www.example.com    | HTTP                         |\n     | 40  | 251 | 198.51.100.15\
    \      | GRE                          |\n     | 50  | 200 | 01:23:45:67:89:ab\
    \  | Ethernet                     |\n     | 15  | 212 | Null (end of path) | None\
    \                         |\n                  Table 1: Name-Based Network Locator\
    \ Map\n   Alternatively, the extended NLM may be defined with implicit name\n\
    \   information rather than explicit URIs as in Table 1.  In the example\n   of\
    \ Table 2, the next hop is represented as a generic HTTP service\n   without a\
    \ specific URI being identified in the extended NLM.  In this\n   scenario, the\
    \ SFF forwards the packet based on parsing the HTTP\n   request in order to identify\
    \ the host name or URI.  It retrieves the\n   URI and may apply policy information\
    \ to determine the destination\n   host/service.\n     | SPI | SI  | Next Hop(s)\
    \        | Transport Encapsulation (TE) |\n     | 10  | 255 | 192.0.2.1      \
    \    | VXLAN-gpe                    |\n     | 10  | 254 | 198.51.100.10      |\
    \ GRE                          |\n     | 10  | 253 | HTTP Service       | HTTP\
    \                         |\n     | 40  | 251 | 198.51.100.15      | GRE     \
    \                     |\n     | 50  | 200 | 01:23:45:67:89:ab  | Ethernet    \
    \                 |\n     | 15  | 212 | Null (end of path) | None            \
    \             |\n         Table 2: Name-Based Network Locator Map with Implicit\
    \ Name\n"
- title: 5.4.  Name-Based Service Function Forwarder (nSFF)
  contents:
  - "5.4.  Name-Based Service Function Forwarder (nSFF)\n   It is desirable to extend\
    \ the SFF of the SFC underlay to handle nSFPs\n   transparently and without the\
    \ need to insert any SF into the nSFP.\n   Such extended nSFFs would then be responsible\
    \ for forwarding a packet\n   in the SFC domain as per the definition of the (extended)\
    \ nSFP.\n   In our example realization for an extended SFF, the solution\n   described\
    \ in this document uses HTTP as the protocol of forwarding\n   SFC packets to\
    \ the next (name-based) hop in the nSFP.  The URI in the\n   HTTP transaction\
    \ is the name in our nSFP information, which will be\n   used for name-based forwarding.\n\
    \   Following our reasoning so far, HTTP requests (and more specifically,\n  \
    \ the plaintext-encoded requests above) are the equivalent of packets\n   that\
    \ enter the SFC domain.  In the existing SFC framework, an IP\n   payload is typically\
    \ assumed to be a packet entering the SFC domain.\n   This packet is forwarded\
    \ to destination nodes using the L2\n   encapsulation.  Any layer 2 network can\
    \ be used as an underlay\n   network.  This notion is now extended to packets\
    \ being possibly part\n   of an entire higher-layer application such as HTTP requests.\
    \  The\n   handling of any intermediate layers, such as TCP and IP, is left to\n\
    \   the realization of the (extended) SFF operations towards the next\n   (named)\
    \ hop.  For this, we will first outline the general lifecycle\n   of an SFC packet\
    \ in the following subsection, followed by two\n   examples for determining next-hop\
    \ information in Section 6.2.3,\n   finished up by a layered view on the realization\
    \ of the nSFF in\n   Section 6.2.4.\n"
- title: 5.5.  High-Level Architecture
  contents:
  - "5.5.  High-Level Architecture\n   +----------+\n   | SF1      |             \
    \    +--------+                  +------+\n   | instance |\\                |\
    \   NR   |                  | SF2  |\n   | Classifier |---| nSFF1 |---|Forwarder|---|Forwarder|---|\
    \ nSFF2 |\n                     Figure 3: High-Level Architecture\n   The high-level\
    \ architecture for name-based operation shown in\n   Figure 3 is very similar\
    \ to the SFC architecture as described in\n   [RFC7665].  Two new functions are\
    \ introduced, as shown in the above\n   diagram: namely, the nSFF and the Name\
    \ Resolver (NR).\n   The nSFF is an extension of the existing SFF and is capable\
    \ of\n   processing SFC packets based on nNLM information, determining the\n \
    \  next SF where the packet should be forwarded, and the required\n   transport\
    \ encapsulation (TE).  Like standard SFF operation, it adds\n   TE to the SFC\
    \ packet and forwards it.\n   The NR is a new functional component, capable of\
    \ identifying the\n   execution endpoints, where a \"named SF\" is running, triggered\
    \ by\n   suitable resolution requests sent by the nSFF.  Though this is\n   similar\
    \ to DNS function, it is not same.  It does not use DNS\n   protocols or data\
    \ records.  A new procedure to determine the suitable\n   routing/forwarding information\
    \ towards the nSFF serving the next hop\n   of the SFP is used.  The details are\
    \ described later.\n   The other functional components, such as classifier and\
    \ SF, are the\n   same as described in SFC architecture, as defined in [RFC7665],\
    \ while\n   the Forwarders shown in the above diagram are traditional Layer 2\n\
    \   switches.\n"
- title: 5.6.  Operational Steps
  contents:
  - "5.6.  Operational Steps\n   In the proposed solution, the operations are realized\
    \ by the name-\n   based SFF, called \"nSFF\".  We utilize the high-level architecture\
    \ in\n   Figure 3 to describe the traversal between two SF instances of an\n \
    \  nSFP-based transaction in an example chain of: 192.0.x.x -> SF1\n   (www.example.com)\
    \ -> SF2 (www.example2.com) -> SF3 -> ...\n   Service Function 3 (SF3) is assumed\
    \ to be a classical SF; hence,\n   existing SFC mechanisms can be used to reach\
    \ it and will not be\n   considered in this example.\n   According to the SFC\
    \ lifecycle, as defined in [RFC7665], based on our\n   example chain above, the\
    \ traffic originates from a classifier or\n   another SFF on the left.  The traffic\
    \ is processed by the incoming\n   nSFF1 (on the left side) through the following\
    \ steps.  The traffic\n   exits at nSFF2.\n   Step 1:  At nSFF1, the following\
    \ nNLM is assumed:\n     | SPI | SI  | Next Hop(s)        | Transport Encapsulation\
    \ (TE) |\n     | 10  | 255 | 192.0.2.1          | VXLAN-gpe                  \
    \  |\n     | 10  | 254 | 198.51.100.10      | GRE                          |\n\
    \     | 10  | 253 | www.example.com    | HTTP                         |\n    \
    \ | 10  | 252 | www.example2.com   | HTTP                         |\n     | 40\
    \  | 251 | 198.51.100.15      | GRE                          |\n     | 50  | 200\
    \ | 01:23:45:67:89:ab  | Ethernet                     |\n     | 15  | 212 | Null\
    \ (end of path) | None                         |\n                           Table\
    \ 3: nNLM at nSFF1\n   Step 2:  nSFF1 removes the previous transport encapsulation\
    \ (TE) for\n            any traffic originating from another SFF or classifier\n\
    \            (traffic from an SF instance does not carry any TE and is\n     \
    \       therefore directly processed at the nSFF).\n   Step 3:  nSFF1 then processes\
    \ the Network Service Header (NSH)\n            information, as defined in [RFC8300],\
    \ to identify the next\n            SF at the nSFP level by mapping the NSH information\
    \ to the\n            appropriate entry in its nNLM (see Table 3) based on the\n\
    \            provided SPI/SI information in the NSH (see Section 4) in\n     \
    \       order to determine the name-based identifier of the next-hop\n       \
    \     SF.  With such nNLM in mind, the nSFF searches the map for\n           \
    \ SPI = 10 and SI = 253.  It identifies the next hop as =\n            www.example.com\
    \ and HTTP as the protocol to be used.  Given\n            that the next hop resides\
    \ locally, the SFC packet is\n            forwarded to the SF1 instance of www.example.com.\
    \  Note that\n            the next hop could also be identified from the provided\
    \ HTTP\n            request, if the next-hop information was identified as a\n\
    \            generic HTTP service, as defined in Section 5.3.\n   Step 4:  The\
    \ SF1 instance then processes the received SFC packet\n            according to\
    \ its service semantics and modifies the NSH by\n            setting SPI = 10\
    \ and SI = 252 for forwarding the packet\n            along the SFP.  It then\
    \ forwards the SFC packet to its local\n            nSFF, i.e., nSFF1.\n   Step\
    \ 5:  nSFF1 processes the NSH of the SFC packet again, now with\n            the\
    \ NSH modified (SPI = 10, SI = 252) by the SF1 instance.\n            It retrieves\
    \ the next-hop information from its nNLM in\n            Table 3 to be www.example2.com.\
    \  Due to this SF not being\n            locally available, the nSFF consults\
    \ any locally available\n            information regarding routing/forwarding\
    \ towards a suitable\n            nSFF that can serve this next hop.\n   Step\
    \ 6:  If such information exists, the Packet (plus the NSH\n            information)\
    \ is marked to be sent towards the nSFF serving\n            the next hop based\
    \ on such information in Step 8.\n   Step 7:  If such information does not exist,\
    \ nSFF1 consults the NR to\n            determine the suitable routing/forwarding\
    \ information\n            towards the identified nSFF serving the next hop of\
    \ the SFP.\n            For future SFC packets towards this next hop, such resolved\n\
    \            information may be locally cached, avoiding contacting the\n    \
    \        NR for every SFC packet forwarding.  The packet is now\n            marked\
    \ to be sent via the network in Step 8.\n   Step 8:  Utilizing the forwarding\
    \ information determined in Steps 6\n            or 7, nSFF1 adds the suitable\
    \ TE for the SFC packet before\n            forwarding via the forwarders in the\
    \ network towards the\n            next nSFF22.\n   Step 9:  When the Packet (+NSH+TE)\
    \ arrives at the outgoing nSFF2,\n            i.e., the nSFF serving the identified\
    \ next hop of the SFP,\n            it removes the TE and processes the NSH to\
    \ identify the\n            next-hop information.  At nSFF2 the nNLM in Table\
    \ 4 is\n            assumed.  Based on this nNLM and NSH information where SPI\
    \ =\n            10 and SI = 252, nSFF2 identifies the next SF as\n          \
    \  www.example2.com.\n     | SPI | SI  | Next Hop(s)        | Transport Encapsulation\
    \ (TE) |\n     | 10  | 252 | www.example2.com   | HTTP                       \
    \  |\n     | 40  | 251 | 198.51.100.15      | GRE                          |\n\
    \     | 50  | 200 | 01:23:45:67:89:ab  | Ethernet                     |\n    \
    \ | 15  | 212 | Null (end of path) | None                         |\n        \
    \                   Table 4: nNLM at SFF2\n   Step 10: If the next hop is locally\
    \ registered at the nSFF, it\n            forwards the packet (+NSH) to the SF\
    \ instance using suitable\n            IP/MAC methods for doing so.\n   Step 11:\
    \ If the next hop is not locally registered at the nSFF, the\n            outgoing\
    \ nSFF adds new TE information to the packet and\n            forwards the packet\
    \ (+NSH+TE) to the next SFF or boundary\n            node, as shown in Table 4.\n"
- title: 6.  nSFF Forwarding Operations
  contents:
  - "6.  nSFF Forwarding Operations\n   This section outlines the realization of various\
    \ nSFF forwarding\n   operations in Section 5.6.  Although the operations in Section\
    \ 5\n   utilize the notion of name-based transactions in general, we\n   exemplify\
    \ the operations here in Section 5 specifically for HTTP-\n   based transactions\
    \ to ground our description into a specific protocol\n   for such name-based transaction.\
    \  We will refer to the various steps\n   in each of the following subsections.\n"
- title: 6.1.  nSFF Protocol Layers
  contents:
  - "6.1.  nSFF Protocol Layers\n   Figure 4 shows the protocol layers based on the\
    \ high-level\n   architecture in Figure 3.\n   |App    |  |      |    |   +--------+\
    \                 |    |     |\n   |HTTP   |  |-------->  |   |  NR    |     \
    \            |nSFF----->|--\n   |TCP    |->| TCP  |nSFF|   +---/\\---+       \
    \          |    | TCP | |\n   |IP     |  | IP   |    |       ||              \
    \       |    | IP  | |\n   |   L2  |  |      L2   |->|Forwarder|-->|Forwarder|-->|\
    \   L2     | |\n     SF1           nSFF1                                     nSFF2\
    \    |\n                         Figure 4: Protocol Layers\n   The nSFF component\
    \ here is shown as implementing a full incoming/\n   outgoing TCP/IP protocol\
    \ stack towards the local SFs, while\n   implementing the nSFF-NR and nSFF-nSFF\
    \ protocols based on the\n   descriptions in Section 6.2.3.\n   For the exchange\
    \ of HTTP-based SF transactions, the nSFF terminates\n   incoming TCP connections\
    \ as well as outgoing TCP connections to local\n   SFs, e.g., the TCP connection\
    \ from SF1 terminates at nSFF1, and nSFF1\n   may store the connection information\
    \ such as socket information.  It\n   also maintains the mapping information for\
    \ the HTTP request such as\n   originating SF, destination SF, and socket ID.\
    \ nSFF1 may implement\n   sending keep-alive messages over the socket to maintain\
    \ the\n   connection to SF1.  Upon arrival of an HTTP request from SF1, nSFF1\n\
    \   extracts the HTTP Request and forwards it towards the next node as\n   outlined\
    \ in Section 6.2.  Any returning response is mapped onto the\n   suitable open\
    \ socket (for the original request) and sent towards SF1.\n   At the outgoing\
    \ nSFF2, the destination SF2/Host is identified from\n   the HTTP request message.\
    \  If no TCP connection exists to the SF2, a\n   new TCP connection is opened\
    \ towards the destination SF2 and the HTTP\n   request is sent over said TCP connection.\
    \  The nSFF2 may also save\n   the TCP connection information (such as socket\
    \ information) and\n   maintain the mapping of the socket information to the destination\n\
    \   SF2.  When an HTTP response is received from SF2 over the TCP\n   connection,\
    \ nSFF2 extracts the HTTP response, which is forwarded to\n   the next node. nSFF2\
    \ may maintain the TCP connection through keep-\n   alive messages.\n"
- title: 6.2.  nSFF Operations
  contents:
  - "6.2.  nSFF Operations\n   In this section, we present three key aspects of operations\
    \ for the\n   realization of the steps in Section 5.6, namely, (i) the registration\n\
    \   of local SFs (for Step 3 in Section 5.6), (ii) the forwarding of SFC\n   packets\
    \ to and from local SFs (for Steps 3, 4, and 10 in\n   Section 5.6), (iii) the\
    \ forwarding to a remote SF (for Steps 5, 6,\n   and 7 in Section 5.6) and to\
    \ the NR as well as (iv) for the lookup of\n   a suitable remote SF (for Step\
    \ 7 in Section 5.6).  We also cover\n   aspects of maintaining local lookup information\
    \ for reducing lookup\n   latency and other issues.\n"
- title: 6.2.1.  Forwarding between nSFFs and nSFF-NRs
  contents:
  - "6.2.1.  Forwarding between nSFFs and nSFF-NRs\n   Forwarding between the distributed\
    \ nSFFs as well as between nSFFs and\n   NRs is realized over the operator network\
    \ via a path-based approach.\n   A path-based approach utilizes path information\
    \ provided by the\n   source of the packet for forwarding said packet in the network.\
    \  This\n   is similar to segment routing albeit differing in the type of\n  \
    \ information provided for such source-based forwarding as described in\n   this\
    \ section.  In this approach, the forwarding information to a\n   remote nSFF\
    \ or the NR is defined as a \"path identifier\" (pathID) of a\n   defined length\
    \ where said length field indicates the full pathID\n   length.  The payload of\
    \ the packet is defined by the various\n   operations outlined in the following\
    \ subsections, resulting in an\n   overall packet being transmitted.  With this,\
    \ the generic forwarding\n   format (GFF) for transport over the operator network\
    \ is defined in\n   Figure 5 with the length field defining the length of the\
    \ pathID\n   provided.\n   | Length  | Path ID         |  Payload            \
    \ //              |\n   |(12 bits)|                 |                     // \
    \              |\n                 Figure 5: Generic Forwarding Format (GFF)\n\
    \   *  Length (12 bits): Defines the length of the pathID, i.e., up to\n     \
    \ 4096 bits\n   *  Path ID: Variable-length bit field derived from IPv6 source\
    \ and\n      destination address\n   For the pathID information, solutions such\
    \ as those in [Reed2016] can\n   be used.  Here, the IPv6 source and destination\
    \ addresses are used to\n   realize a so-called path-based forwarding from the\
    \ incoming to the\n   outgoing nSFF or the NR.  The forwarders in Figure 4 are\
    \ realized via\n   SDN (software-defined networking) switches, implementing an\
    \ AND/CMP\n   operation based on arbitrary wildcard matching over the IPv6 source\n\
    \   and destination addresses as outlined in [Reed2016].  Note that in\n   the\
    \ case of using IPv6 address information for path-based forwarding,\n   the step\
    \ of removing the TE at the outgoing nSFF in Figure 4 is\n   realized by utilizing\
    \ the provided (existing) IP header (which was\n   used for the purpose of the\
    \ path-based forwarding in [Reed2016]) for\n   the purpose of next-hop forwarding\
    \ such as that of IP-based routing.\n   As described in Step 8 of the extended\
    \ nSFF operations, this\n   forwarding information is used as traffic encapsulation.\
    \  With the\n   forwarding information utilizing existing IPv6 information, IP\n\
    \   headers are utilized as TE in this case.  The next-hop nSFF (see\n   Figure\
    \ 4) will restore the IP header of the packet with the relevant\n   IP information\
    \ used to forward the SFC packet to SF2, or it will\n   create suitable TE information\
    \ to forward the information to another\n   nSFF or boundary node.  Forwarding\
    \ operations at the intermediary\n   forwarders, i.e., SDN switches, examine the\
    \ pathID information\n   through a flow-matching rule in which a specific switch-local\
    \ output\n   port is represented through the specific assigned bit position in\
    \ the\n   pathID.  Upon a positive match in said rule, the packet is forwarded\n\
    \   on said output port.\n   Alternatively, the solution in [BIER-MULTICAST] suggests\
    \ using a so-\n   called BIER (Binary Indexed Explicit Replication) underlay.\
    \  Here,\n   the nSFF would be realized at the ingress to the BIER underlay,\n\
    \   injecting the SFC packet header (plus the Network Service Header\n   (NSH))\
    \ with BIER-based traffic encapsulation into the BIER underlay\n   with each of\
    \ the forwarders in Figure 4 being realized as a so-called\n   Bit-Forwarding\
    \ Router (BFR) [RFC8279].\n"
- title: 6.2.1.1.  Transport Protocol Considerations
  contents:
  - "6.2.1.1.  Transport Protocol Considerations\n   Given that the proposed solution\
    \ operates at the \"named-transaction\"\n   level, particularly for HTTP transactions,\
    \ forwarding between nSFFs\n   and/or NRs SHOULD be implemented via a transport\
    \ protocol between\n   nSFFs and/or NRs in order to provide reliability, segmentation\
    \ of\n   large GFF packets, and flow control, with the GFF in Figure 5 being\n\
    \   the basic forwarding format for this.\n   Note that the nSFFs act as TCP proxies\
    \ at ingress and egress, thus\n   terminating incoming and initiating outgoing\
    \ HTTP sessions to SFs.\n   Figure 6 shows the packet format being used for the\
    \ transmission of\n   data, being adapted from the TCP header.  Segmentation of\
    \ large\n   transactions into single transport protocol packets is realized\n\
    \   through maintaining a \"Sequence number\".  A \"Checksum\" is calculated\n\
    \   over a single data packet with the ones-complement TCP checksum\n   calculation\
    \ being used.  The \"Window Size\" field indicates the\n   current maximum number\
    \ of transport packets that are allowed in-\n   flight by the egress nSFF.  A\
    \ data packet is sent without a \"Data\"\n   field to indicate the end of the\
    \ (e.g., HTTP) transaction.\n   Note that, in order to support future named transactions\
    \ based on\n   other application protocols, such as Constrained Application Protocol\n\
    \   (CoAP), future versions of the transport protocol MAY introduce a\n   \"Type\"\
    \ field that indicates the type of application protocol being\n   used between\
    \ SF and nSFF with \"Type\" 0x01 proposed for HTTP.  This is\n   being left for\
    \ future study.\n               |         16 bits       |        16 bits     \
    \  |\n               |              Sequence number                 |\n      \
    \         |       Checksum        |      Window Size     |\n              Figure\
    \ 6: Transport Protocol Data Packet Format\n   Given the path-based forwarding\
    \ being used between nSFFs, the\n   transport protocol between nSFFs utilizes\
    \ negative acknowledgements\n   from the egress nSFF towards the ingress nSFF.\
    \  The transport\n   protocol negative Acknowledgment (NACK) packet carries the\
    \ number of\n   NACKs as well as the specific sequence numbers being indicated\
    \ as\n   lost in the \"NACK number\" field(s) as shown in Figure 7.\n        \
    \       |         16 bits       |        16 bits       |\n               |   \
    \ Number of NACKs    |                      +\n              Figure 7: Transport\
    \ Protocol NACK Packet Format\n   If the indicated number of NACKs in a received\
    \ NACK packet is\n   nonzero, the ingress nSFF will retransmit all sequence numbers\n\
    \   signaled in the packet while decreasing its congestion window size\n   for\
    \ future transmissions.\n   If the indicated number of NACKs in a received NACK\
    \ packet is zero,\n   it will indicate the current congestion window as being\
    \ successfully\n   (and completely) being transmitted, increasing the congestion\
    \ window\n   size if smaller than the advertised \"Window Size\" in Figure 6.\n\
    \   The maintenance of the congestion window is subject to realization at\n  \
    \ the ingress nSFF and left for further study in nSFF realizations.\n"
- title: 6.2.2.  SF Registration
  contents:
  - "6.2.2.  SF Registration\n   As outlined in Steps 3 and 10 of Section 5.6, the\
    \ nSFF needs to\n   determine if the SF derived from the Name-Based Network Locator\n\
    \   (nNLM) is locally reachable or whether the packet needs to be\n   forwarded\
    \ to a remote SFF.  For this, a registration mechanism is\n   provided for such\
    \ local SF with the local nSFF.  Two mechanisms can\n   be used for this:\n  \
    \ 1.    SF-initiated: We assume that the SF registers its Fully\n         Qualified\
    \ Domain Name (FQDN) to the local nSFF.  As local\n         mechanisms, we foresee\
    \ that either a Representational State\n         Transfer (REST-based) interface\
    \ over the link-local link or\n         configuration of the nSFF (through configuration\
    \ files or\n         management consoles) can be utilized.  Such local registration\n\
    \         events lead to the nSFF registering the given FQDN with the NR\n   \
    \      in combination with a system-unique nSFF identifier that is\n         being\
    \ used for path-computation purposes in the NR.  For the\n         registration,\
    \ the packet format in Figure 8 is used (inserted\n         as the payload in\
    \ the GFF of Figure 5 with the pathID towards\n         the NR).\n           \
    \       |   R/D   |    hash(FQDN)    |    nSFF_ID     |\n                  | (1\
    \ bit) |    (16 bits)     |    (8 bits)    |\n                        Figure 8:\
    \ Registration Packet Format\n            +  R/D: 1-bit length (0 for Register,\
    \ 1 for Deregister)\n            +  hash(FQDN): 16-bit length for a hash over\
    \ the FQDN of the\n               SF\n            +  nSFF_ID: 8-bit length for\
    \ a system-unique identifier for\n               the SFF related to the SF\n \
    \           We assume that the pathID towards the NR is known to the\n       \
    \     nSFF through configuration means.\n            The NR maintains an internal\
    \ table that associates the\n            hash(FQDN), the nSFF_id information,\
    \ as well as the pathID\n            information being used for communication\
    \ between nSFFs and\n            NRs.  The nSFF locally maintains a mapping of\
    \ registered\n            FQDNs to IP addresses for the latter using link-local\n\
    \            private IP addresses.\n   2.    Orchestration-based: In this mechanism,\
    \ we assume that SFC to\n         be orchestrated and the chain to be provided\
    \ through an\n         orchestration template with FQDN information associated\
    \ to a\n         compute/storage resource that is being deployed by the\n    \
    \     orchestrator.  We also assume knowledge at the orchestrator of\n       \
    \  the resource topology.  Based on this, the orchestrator can now\n         use\
    \ the same REST-based protocol defined in option 1 to\n         instruct the NR\
    \ to register the given FQDN, as provided in the\n         template, at the nSFF\
    \ it has identified as being the locally\n         servicing nSFF, provided as\
    \ the system-unique nSFF identifier.\n"
- title: 6.2.3.  Local SF Forwarding
  contents:
  - "6.2.3.  Local SF Forwarding\n   There are two cases of local SF forwarding, namely,\
    \ the SF sending an\n   SFC packet to the local nSFF (incoming requests) or the\
    \ nSFF sending\n   a packet to the SF (outgoing requests) as part of Steps 3 and\
    \ 10 in\n   Section 5.6.  In the following, we outline the operation for HTTP\
    \ as\n   an example-named transaction.\n   As shown in Figure 4, incoming HTTP\
    \ requests from SFs are extracted\n   by terminating the incoming TCP connection\
    \ at their local nSFFs at\n   the TCP level.  The nSFF MUST maintain a mapping\
    \ of open TCP sockets\n   to HTTP requests (utilizing the URI of the request)\
    \ for HTTP response\n   association.\n   For outgoing HTTP requests, the nSFF\
    \ utilizes the maintained mapping\n   of locally registered FQDNs to link-local\
    \ IP addresses (see\n   Section 6.2.2, option 1).  Hence, upon receiving an SFC\
    \ packet from a\n   remote nSFF (in Step 9 of Section 5.6), the nSFF determines\
    \ the local\n   existence of the SF through the registration mechanisms in\n \
    \  Section 6.2.2.  If said SF does exist locally, the HTTP (+NSH)\n   packet,\
    \ after stripping the TE, is sent to the local SF as Step 10 in\n   Section 5.6\
    \ via a TCP-level connection.  Outgoing nSFFs SHOULD keep\n   TCP connections\
    \ open to local SFs for improving SFC packet delivery\n   in subsequent transactions.\n"
- title: 6.2.4.  Handling of HTTP Responses
  contents:
  - "6.2.4.  Handling of HTTP Responses\n   When executing Steps 3 and 10 in Section\
    \ 5.6, the SFC packet will be\n   delivered to the locally registered next hop.\
    \  As part of the HTTP\n   protocol, responses to the HTTP request will need to\
    \ be delivered on\n   the return path to the originating nSFF (i.e., the previous\
    \ hop).\n   For this, the nSFF maintains a list of link-local connection\n   information,\
    \ e.g., sockets to the local SF and the pathID on which\n   the request was received.\
    \  Once receiving the response, nSFF consults\n   the table to determine the pathID\
    \ of the original request, forming a\n   suitable GFF-based packet to be returned\
    \ to the previous nSFF.\n   When receiving the HTTP response at the previous nSFF,\
    \ the nSFF\n   consults the table of (locally) open sockets to determine the\n\
    \   suitable local SF connection, mapping the received HTTP response URI\n   to\
    \ the stored request URI.  Utilizing the found socket, the HTTP\n   response is\
    \ forwarded to the locally registered SF.\n"
- title: 6.2.5.  Remote SF Forwarding
  contents:
  - "6.2.5.  Remote SF Forwarding\n   In Steps 5, 6, 7, and 8 of Section 5.6, an SFC\
    \ packet is forwarded to\n   a remote nSFF based on the nNLM information for the\
    \ next hop of the\n   nSFP.  Section 6.2.5.1 handles the case of suitable forwarding\n\
    \   information to the remote nSFF not existing, therefore consulting the\n  \
    \ NR to obtain suitable information.  Section 6.2.5.2 describes the\n   maintenance\
    \ of forwarding information at the local nSFF.\n   Section 6.2.5.3 describes the\
    \ update of stale forwarding information.\n   Note that the forwarding described\
    \ in Section 6.2.1 is used for the\n   actual forwarding to the various nSFF components.\
    \  Ultimately,\n   Section 6.2.5.4 describes the forwarding to the remote nSFF\
    \ via the\n   forwarder network.\n"
- title: 6.2.5.1.  Remote SF Discovery
  contents:
  - "6.2.5.1.  Remote SF Discovery\n   The nSFF communicates with the NR for two purposes:\
    \ namely, the\n   registration and discovery of FQDNs.  The packet format for\
    \ the\n   former was shown in Figure 8 in Section 6.2.2, while Figure 9\n   outlines\
    \ the packet format for the discovery request.\n   |   hash(FQDN) |  nSFF_ID \
    \   | | Length | pathID        //          |\n   |   (16 bits)  |  (8 bits)  \
    \ | |(4 bits)|              //           |\n           Path Request          \
    \           Path Response\n                     Figure 9: Discovery Packet Format\n\
    \   For Path Request:\n   *  hash(FQDN): 16-bit length for a hash over the FQDN\
    \ of the SF\n   *  nSFF_ID: 8-bit length for a system-unique identifier for the\
    \ SFF\n      related to the SF\n   For Path Response:\n   *  Length: 4-bit length\
    \ that defines the length of the pathID\n   *  Path ID: Variable-length bit field\
    \ derived from IPv6 source and\n      destination address\n   A path to a specific\
    \ FQDN is requested by sending a hash of the FQDN\n   to the NR together with\
    \ its nSFF_id, receiving as a response a pathID\n   with a length identifier.\
    \  The NR SHOULD maintain a table of\n   discovery requests that map discovered\
    \ (hash of) FQDN to the nSFF_id\n   that requested it and the pathID that is being\
    \ calculated as a result\n   of the discovery request.\n   The discovery request\
    \ for an FQDN that has not previously been served\n   at the nSFF (or for an FQDN\
    \ whose pathID information has been flushed\n   as a result of the update operations\
    \ in Section 6.2.5.3) results in\n   an initial latency incurred by this discovery\
    \ through the NR, while\n   any SFC packet sent over the same SFP in a subsequent\
    \ transaction\n   will utilize the nSFF-local mapping table.  Such initial latency\
    \ can\n   be avoided by prepopulating the FQDN-pathID mapping proactively as\n\
    \   part of the overall orchestration procedure, e.g., alongside the\n   distribution\
    \ of the nNLM information to the nSFF.\n"
- title: 6.2.5.2.  Maintaining Forwarding Information at Local nSFF
  contents:
  - "6.2.5.2.  Maintaining Forwarding Information at Local nSFF\n   Each nSFF MUST\
    \ maintain an internal table that maps the (hash of the)\n   FQDN information\
    \ to a suitable pathID.  As outlined in Step 7 of\n   Section 5.6, if a suitable\
    \ entry does not exist for a given FQDN, the\n   pathID information is requested\
    \ with the operations in\n   Section 6.2.5.1 and the suitable entry is locally\
    \ created upon\n   receiving a reply with the forwarding operation being executed\
    \ as\n   described in Section 6.2.1.\n   If such an entry does exist (i.e., Step\
    \ 6 of Section 5.6), the pathID\n   is locally retrieved and used for the forwarding\
    \ operation in\n   Section 6.2.1.\n"
- title: 6.2.5.3.  Updating Forwarding Information at nSFF
  contents:
  - "6.2.5.3.  Updating Forwarding Information at nSFF\n   The forwarding information\
    \ maintained at each nSFF (see\n   Section 6.2.5.2) might need to be updated for\
    \ three reasons:\n   1.    An existing SF is no longer reachable: In this case,\
    \ the nSFF\n         with which the SF is locally registered deregisters the SF\n\
    \         explicitly at the NR by sending the packet in Figure 6 with the\n  \
    \       hashed FQDN and the R/D bit set to 1 (for deregister).\n   2.    Another\
    \ SF instance has become reachable in the network (and,\n         therefore, might\
    \ provide a better alternative to the existing\n         SF): In this case, the\
    \ NR has received another packet with a\n         format defined in Figure 7 but\
    \ a different nSFF_id value.\n   3.    Links along paths might no longer be reachable:\
    \ The NR might\n         use a suitable southbound interface to transport networks\
    \ to\n         detect link failures, which it associates to the appropriate\n\
    \         pathID bit position.\n   For this purpose, the packet format in Figure\
    \ 10 is sent from the NR\n   to all affected nSFFs, using the generic format in\
    \ Figure 5.\n            |   Type  |     #IDs        |  IDs       //      |\n\
    \            | (1 bit) |    (8 bits)     |           //       |\n            \
    \           Figure 10: Path Update Format\n   *  Type: 1-bit length (0 for Nsff\
    \ ID, 1 for Link ID)\n   *  #IDs: 8-bit length for number of IDs in the list\n\
    \   *  IDs: List of IDs (Nsff ID or Link ID)\n   The pathID to the affected nSFFs\
    \ is computed as the binary OR over\n   all pathIDs to those nSFF_ids affected\
    \ where the pathID information\n   to the affected nSFF_id values is determined\
    \ from the NR-local table\n   maintained in the registration/deregistration operation\
    \ of\n   Section 6.2.2.\n   The pathID may include the type of information being\
    \ updated (e.g.,\n   node identifiers of leaf nodes or link identifiers for removed\n\
    \   links).  The node identifier itself may be a special identifier to\n   signal\
    \ \"ALL NODES\" as being affected.  The node identifier may signal\n   changes\
    \ to the network that are substantial (e.g., parallel link\n   failures).  The\
    \ node identifier may trigger (e.g., recommend) purging\n   of the entire path\
    \ table (e.g., rather than the selective removal of\n   a few nodes only).\n \
    \  It will include the information according to the type.  The included\n   information\
    \ may also be related to the type and length information\n   for the number of\
    \ identifiers being provided.\n   In cases 1 and 2, the Type bit is set to 1 (type\
    \ nSFF_id) and the\n   affected nSFFs are determined by those nSFFs that have\
    \ previously\n   sent SF discovery requests, utilizing the optional table mapping\n\
    \   previously registered FQDNs to nSFF_id values.  If no table mapping\n   the\
    \ (hash of) FQDN to nSFF_id is maintained, the update is sent to\n   all nSFFs.\
    \  Upon receiving the path update at the affected nSFF, all\n   appropriate nSFF-local\
    \ mapping entries to pathIDs for the hash(FQDN)\n   identifiers provided will\
    \ be removed, leading to a new NR discovery\n   request at the next remote nSFF\
    \ forwarding to the appropriate FQDN.\n   In case 3, the Type bit is set to 0\
    \ (type linkID) and the affected\n   nSFFs are determined by those nSFFs whose\
    \ discovery requests have\n   previously resulted in pathIDs that include the\
    \ affected link,\n   utilizing the optional table mapping previously registered\
    \ FQDNs to\n   pathID values (see Section 6.2.5.1).  Upon receiving the node\n\
    \   identifier information in the path update, the affected nSFF will\n   check\
    \ its internal table that maps FQDNs to pathIDs to determine\n   those pathIDs\
    \ affected by the link problems and remove path\n   information that includes\
    \ the received node identifier(s).  For this,\n   the pathID entries of said table\
    \ are checked against the linkID\n   values provided in the ID entry of the path\
    \ update through a binary\n   AND/CMP operation to check the inclusion of the\
    \ link in the pathIDs\n   to the FQDNs.  If any pathID is affected, the FQDN-pathID\
    \ entry is\n   removed, leading to a new NR discovery request at the next remote\n\
    \   nSFF forwarding to the appropriate FQDN.\n"
- title: 6.2.5.4.  Forwarding to Remote nSFF
  contents:
  - "6.2.5.4.  Forwarding to Remote nSFF\n   Once Steps 5, 6, and 7 in Section 5.6\
    \ are being executed, Step 8\n   finally sends the SFC packet to the remote nSFF,\
    \ utilizing the pathID\n   returned in the discovery request (Section 6.2.5.1)\
    \ or retrieved from\n   the local pathID mapping table.  The SFC packet is placed\
    \ in the\n   payload of the generic forwarding format in Figure 5 together with\n\
    \   the pathID, and the nSFF eventually executes the forwarding\n   operations\
    \ in Section 6.2.1.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Sections 5 and 6 describe the forwarding of SFC\
    \ packets between named\n   SFs based on URIs exchanged in HTTP messages.  Security\
    \ is needed to\n   protect the communications between originating node and Ssff,\
    \ between\n   one Nsff and the next Nsff, and between Nsff and destination.  TLS\
    \ is\n   sufficient for this and SHOULD be used.  The TLS handshake allows to\n\
    \   determine the FQDN, which, in turn, is enough for the service routing\n  \
    \ decision.  Supporting TLS also allows the possibility of HTTPS-based\n   transactions.\n\
    \   It should be noted (per [RFC3986]) that what a URI resolves to is not\n  \
    \ necessarily stable.  This can allow flexibility in deployment, as\n   described\
    \ in this document, but may also result in unexpected\n   behavior and could provide\
    \ an attack vector as the resolution of a\n   URI could be \"hijacked\" resulting\
    \ in packets being steered to the\n   wrong place.  This could be particularly\
    \ important if the SFC is\n   intended to send packets for processing at security\
    \ functions.  Such\n   hijacking is a new attack surface introduced by using a\
    \ separate NR.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66,\n           \
    \   RFC 3986, DOI 10.17487/RFC3986, January 2005,\n              <https://www.rfc-editor.org/info/rfc3986>.\n\
    \   [RFC7665]  Halpern, J., Ed. and C. Pignataro, Ed., \"Service Function\n  \
    \            Chaining (SFC) Architecture\", RFC 7665,\n              DOI 10.17487/RFC7665,\
    \ October 2015,\n              <https://www.rfc-editor.org/info/rfc7665>.\n  \
    \ [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n       \
    \       2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n          \
    \    May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8279]  Wijnands,\
    \ IJ., Ed., Rosen, E., Ed., Dolganow, A.,\n              Przygienda, T., and S.\
    \ Aldrin, \"Multicast Using Bit Index\n              Explicit Replication (BIER)\"\
    , RFC 8279,\n              DOI 10.17487/RFC8279, November 2017,\n            \
    \  <https://www.rfc-editor.org/info/rfc8279>.\n   [RFC8300]  Quinn, P., Ed., Elzur,\
    \ U., Ed., and C. Pignataro, Ed.,\n              \"Network Service Header (NSH)\"\
    , RFC 8300,\n              DOI 10.17487/RFC8300, January 2018,\n             \
    \ <https://www.rfc-editor.org/info/rfc8300>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [BIER-MULTICAST]\n              Trossen, D.,\
    \ Rahman, A., Wang, C., and T. Eckert,\n              \"Applicability of BIER\
    \ Multicast Overlay for Adaptive\n              Streaming Services\", Work in\
    \ Progress, Internet-Draft,\n              draft-ietf-bier-multicast-http-response-01,\
    \ 28 June 2019,\n              <https://tools.ietf.org/html/draft-ietf-bier-multicast-\n\
    \              http-response-01>.\n   [Reed2016] Reed, M.J., Al-Naday, M., Thomas,\
    \ N., Trossen, D.,\n              Petropoulos, G., and S. Spirou, \"Stateless\
    \ multicast\n              switching in software defined networks\", IEEE ICC\
    \ 2016,\n              DOI 10.1109/ICC.2016.7511036, May 2016,\n             \
    \ <https://ieeexplore.ieee.org/document/7511036>.\n   [Schlinker2017]\n      \
    \        Schlinker, B., Kim, H., Cui, T., Katz-Bassett, E.,\n              Madhyastha,\
    \ H., Cunha, I., Quinn, J., Hassan, S.,\n              Lapukhov, P., and H. Zeng,\
    \ \"Engineering Egress with Edge\n              Fabric, Steering Oceans of Content\
    \ to the World\", ACM\n              SIGCOMM 2017, August 2017, <https://research.fb.com/wp-\n\
    \              content/uploads/2017/08/sigcomm17-final177-2billion.pdf>.\n   [SDO-3GPP-SBA]\n\
    \              3GPP, \"Technical Realization of Service Based\n              Architecture\"\
    , 3GPP TS 29.500 V15.5.0, September 2019,\n              <https://www.3gpp.org/ftp/Specs/html-info/29500.htm>.\n\
    \   [SDO-3GPP-SBA-ENHANCEMENT]\n              3GPP, \"New SID for Enhancements\
    \ to the Service-Based 5G\n              System Architecture\", 3GPP S2-182904,\
    \ February 2018,\n              <https://www.3gpp.org/ftp/tsg_sa/WG2_Arch/\n \
    \             TSGS2_126_Montreal/Docs/S2-182904.zip>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to thank Dirk von Hugo and Andrew\
    \ Malis for\n   their reviews and valuable comments.  We would also like to thank\n\
    \   Joel Halpern, the chair of the SFC WG, and Adrian Farrel for guiding\n   us\
    \ through the Independent Submission Editor (ISE) path.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Dirk Trossen\n   InterDigital Europe, Ltd\n   64 Great\
    \ Eastern Street, 1st Floor\n   London\n   EC2A 3QR\n   United Kingdom\n   Email:\
    \ Dirk.Trossen@InterDigital.com\n   Debashish Purkayastha\n   InterDigital Communications,\
    \ LLC\n   1001 E Hector St\n   Conshohocken, PA\n   United States of America\n\
    \   Email: Debashish.Purkayastha@InterDigital.com\n   Akbar Rahman\n   InterDigital\
    \ Communications, LLC\n   1000 Sherbrooke Street West\n   Montreal\n"
