- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                         R. Gieben
  contents:
  - "Independent Submission                                         R. Gieben\n  \
    \            Authenticated Denial of Existence in the DNS\n"
- title: Abstract
  contents:
  - "Abstract\n   Authenticated denial of existence allows a resolver to validate\
    \ that\n   a certain domain name does not exist.  It is also used to signal that\n\
    \   a domain name exists but does not have the specific resource record\n   (RR)\
    \ type you were asking for.  When returning a negative DNS\n   Security Extensions\
    \ (DNSSEC) response, a name server usually includes\n   up to two NSEC records.\
    \  With NSEC version 3 (NSEC3), this amount is\n   three.\n   This document provides\
    \ additional background commentary and some\n   context for the NSEC and NSEC3\
    \ mechanisms used by DNSSEC to provide\n   authenticated denial-of-existence responses.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7129.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Denial of Existence .............................................4\n  \
    \    2.1. NXDOMAIN Responses .........................................4\n    \
    \  2.2. NODATA Responses ...........................................5\n   3. Secure\
    \ Denial of Existence ......................................6\n      3.1. NXT\
    \ ........................................................7\n      3.2. NSEC .......................................................7\n\
    \      3.3. NODATA Responses ...........................................9\n  \
    \    3.4. Drawbacks of NSEC .........................................10\n   4.\
    \ Experimental and Deprecated Mechanisms: NO, NSEC2, and DNSNR ...11\n   5. NSEC3\
    \ ..........................................................12\n      5.1. Opt-Out\
    \ ...................................................14\n      5.2. Loading an\
    \ NSEC3 Zone .....................................15\n      5.3. Wildcards in\
    \ the DNS ......................................15\n      5.4. CNAME Records .............................................18\n\
    \      5.5. The Closest Encloser NSEC3 Record .........................19\n  \
    \    5.6. Three to Tango ............................................24\n   6.\
    \ Security Considerations ........................................25\n   7. Acknowledgments\
    \ ................................................25\n   8. References .....................................................26\n\
    \      8.1. Normative References ......................................26\n  \
    \    8.2. Informative References ....................................26\n   Appendix\
    \ A. Online Signing: Minimally Covering NSEC Records .......28\n   Appendix B.\
    \ Online Signing: NSEC3 White Lies ......................29\n   Appendix C. List\
    \ of Hashed Owner Names ............................29\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   DNSSEC can be somewhat of a complicated matter, and there\
    \ are certain\n   areas of the specification that are more difficult to comprehend\
    \ than\n   others.  One such area is \"authenticated denial of existence\".\n\
    \   Denial of existence is a mechanism that informs a resolver that a\n   certain\
    \ domain name does not exist.  It is also used to signal that a\n   domain name\
    \ exists but does not have the specific RR type you were\n   asking for.\n   The\
    \ first is referred to as a nonexistent domain (NXDOMAIN)\n   ([RFC2308], Section\
    \ 2.1) and the latter as a NODATA ([RFC2308],\n   Section 2.2) response.  Both\
    \ are also known as negative responses.\n   Authenticated denial of existence\
    \ uses cryptography to sign the\n   negative response.  However, if there is no\
    \ answer, what is it that\n   needs to be signed?  To further complicate this\
    \ matter, there is the\n   desire to pre-generate negative responses that are\
    \ applicable for all\n   queries for nonexistent names in the signed zone.  See\
    \ Section 3 for\n   the details.\n   In this document, we will explain how authenticated\
    \ denial of\n   existence works.  We begin by explaining the current technique\
    \ in the\n   DNS and work our way up to DNSSEC.  We explain the first steps taken\n\
    \   in DNSSEC and describe how NSEC and NSEC3 work.  The NXT, NO, NSEC2,\n   and\
    \ DNSNR records also briefly make their appearance, as they have\n   paved the\
    \ way for NSEC and NSEC3.\n   To complete the picture, we also need to explain\
    \ DNS wildcards as\n   these complicate matters, especially when combined with\
    \ CNAME\n   records.\n   Note: In this document, domain names in zone file examples\
    \ will have\n   a trailing dot, but in the running text they will not.  This text\
    \ is\n   written for people who have a fair understanding of DNSSEC.  The\n  \
    \ following RFCs are not required reading, but they help in\n   understanding\
    \ the problem space.\n   o  [RFC5155] -- DNS Security (DNSSEC) Hashed Authenticated\
    \ Denial of\n      Existence;\n   o  [RFC4592] -- The Role of Wildcards in the\
    \ Domain Name System.\n   And, these provide some general DNSSEC information.\n\
    \   o  [RFC4033], [RFC4034], and [RFC4035] -- DNSSEC specifications;\n   o  [RFC4956]\
    \ -- DNS Security (DNSSEC) Opt-In.  This RFC has an\n      Experimental status\
    \ but is a good read.\n   These three documents give some background information\
    \ on the NSEC3\n   development.\n   o  The NO record [DNSEXT];\n   o  The NSEC2\
    \ record [DNSEXT-NSEC2];\n   o  The DNSNR record [DNSNR-RR].\n"
- title: 2.  Denial of Existence
  contents:
  - "2.  Denial of Existence\n   We start with the basics and take a look at NXDOMAIN\
    \ handling in the\n   DNS.  To make it more visible, we are going to use a small\
    \ DNS zone\n   with three names (\"example.org\", \"a.example.org\", and\n   \"\
    d.example.org\") and four types (SOA, NS, A, and TXT).  For brevity,\n   the class\
    \ is not shown (defaults to IN) and the SOA record is\n   shortened, resulting\
    \ in the following zone file:\n   example.org.        SOA ( ... )\n   example.org.\
    \        NS  a.example.org.\n   a.example.org.      A 192.0.2.1\n            \
    \           TXT \"a record\"\n   d.example.org.      A 192.0.2.1\n           \
    \            TXT \"d record\"\n   Figure 1: The Unsigned \"example.org\" Zone\n"
- title: 2.1.  NXDOMAIN Responses
  contents:
  - "2.1.  NXDOMAIN Responses\n   If a resolver asks the name server serving this\
    \ zone for the TXT type\n   belonging to \"a.example.org\", it sends the following\
    \ question:\n   \"a.example.org TXT\".\n   The name server looks in its zone data\
    \ and generates an answer.  In\n   this case, a positive one: \"Yes, it exists\
    \ and this is the data\",\n   resulting in this reply:\n   ;; status: NOERROR,\
    \ id: 28203\n   ;; ANSWER SECTION:\n   a.example.org.      TXT \"a record\"\n\
    \   ;; AUTHORITY SECTION:\n   example.org.        NS a.example.org.\n   The \"\
    status: NOERROR\" signals that everything is OK, and the \"id\" is\n   an integer\
    \ used to match questions and answers.  In the ANSWER\n   section, we find our\
    \ answer.  The AUTHORITY section holds the names\n   of the name servers that\
    \ have information concerning the\n   \"example.org\" zone.  Note that including\
    \ this information is\n   optional.\n   If a resolver asks for \"b.example.org\
    \ TXT\", it gets an answer that\n   this name does not exist:\n   ;; status: NXDOMAIN,\
    \ id: 7042\n   ;; AUTHORITY SECTION:\n   example.org.        SOA ( ... )\n   In\
    \ this case, we do not get an ANSWER section, and the status is set\n   to NXDOMAIN.\
    \  From this, the resolver concludes that \"b.example.org\"\n   does not exist.\
    \  The AUTHORITY section holds the SOA record of\n   \"example.org\" that the\
    \ resolver can use to cache the negative\n   response.\n"
- title: 2.2.  NODATA Responses
  contents:
  - "2.2.  NODATA Responses\n   It is important to realize that NXDOMAIN is not the\
    \ only type of\n   does-not-exist response.  A name may exist, but the type you\
    \ are\n   asking for may not.  This occurrence of nonexistence is called a\n \
    \  NODATA response.  Let us ask our name server for \"a.example.org AAAA\"\n \
    \  and look at the answer:\n   ;; status: NOERROR, id: 7944\n   ;; AUTHORITY SECTION:\n\
    \   example.org.        SOA ( ... )\n   The status NOERROR shows that the \"a.example.org\"\
    \ name exists, but\n   the reply does not contain an ANSWER section.  This differentiates\
    \ a\n   NODATA response from an NXDOMAIN response; the rest of the packet is\n\
    \   very similar.  The resolver has to put these pieces of information\n   together\
    \ and conclude that \"a.example.org\" exists, but it does not\n   have a \"AAAA\"\
    \ record.\n"
- title: 3.  Secure Denial of Existence
  contents:
  - "3.  Secure Denial of Existence\n   The above has to be translated to the security-aware\
    \ world of DNSSEC.\n   But, there are a few principles DNSSEC brings to the table:\n\
    \   1.  A name server is free to compute the answer and signature(s) on\n    \
    \   the fly, but the protocol is written with a \"first sign, then\n       load\"\
    \ attitude in mind.  It is rather asymmetrical, but a lot of\n       the design\
    \ in DNSSEC stems from fact that you need to accommodate\n       authenticated\
    \ denial of existence.  If the DNS did not have\n       NXDOMAIN, DNSSEC would\
    \ be a lot simpler, but a lot less useful!\n   2.  The DNS packet header is not\
    \ signed.  This means that a \"status:\n       NXDOMAIN\" cannot be trusted. \
    \ In fact, the entire header may be\n       forged, including the AD bit (AD stands\
    \ for Authentic Data; see\n       [RFC3655]), which may give some food for thought;\n\
    \   3.  DNS wildcards and CNAME records complicate matters significantly.\n  \
    \     See more about this later in Sections 5.3 and 5.4.\n   The first principle\
    \ implies that all denial-of-existence answers need\n   to be precomputed, but\
    \ it is impossible to precompute (all\n   conceivable) nonexistence answers.\n\
    \   A generic denial record that can be used in all denial-of-existence\n   proofs\
    \ is not an option: such a record is susceptible to replay\n   attacks.  When\
    \ you are querying a name server for any record that\n   actually exists, a man\
    \ in the middle could replay that generic denial\n   record that is unlimited\
    \ in its scope, and it would be impossible to\n   tell whether the response was\
    \ genuine or spoofed.  In other words,\n   the generic record can be replayed\
    \ to falsely deny _all_ possible\n   responses.\n   We could also use the QNAME\
    \ in the answer and sign that, essentially\n   signing an NXDOMAIN response. \
    \ While this approach could have worked\n   technically, it is incompatible with\
    \ offline signing.\n   The way this has been solved is by introducing a record\
    \ that defines\n   an interval between two existing names.  Or, to put it another\
    \ way,\n   it defines the holes (nonexisting names) in the zone.  This record\n\
    \   can be signed beforehand and given to the resolver.  Appendices A and\n  \
    \ B describe online signing techniques that are compatible with this\n   scheme.\n\
    \      Given all these troubles, why didn't the designers of DNSSEC go\n     \
    \ for the easy route and allow for online signing?  Well, at that\n      time\
    \ (pre 2000), online signing was not feasible with the then-\n      current hardware.\
    \  Keep in mind that the larger servers get\n      between 2000 and 6000 queries\
    \ per second (qps), with peaks up to\n      20,000 qps or more.  Scaling signature\
    \ generation to these kind of\n      levels is always a challenge.  Another issue\
    \ was (and is) key\n      management.  For online signing to work, _each_ authoritative\
    \ name\n      server needs access to the private key(s).  This is considered a\n\
    \      security risk.  Hence, the protocol is required not to rely on\n      on-line\
    \ signing.\n   The road to the current solution (NSEC/NSEC3) was long.  It started\n\
    \   with the NXT (next) record.  The NO (not existing) record was\n   introduced,\
    \ but it never made it into an RFC.  Later on, NXT was\n   superseded by the NSEC\
    \ (next secure) record.  From there, it went\n   through NSEC2/DNSNR to finally\
    \ reach NSEC3 (Next SECure version 3) in\n   RFC 5155.\n"
- title: 3.1.  NXT
  contents:
  - "3.1.  NXT\n   The first attempt to specify authenticated denial of existence\
    \ was\n   NXT ([RFC2535]).  Section 5.1 of RFC 2535 introduces the record:\n \
    \     The NXT resource record is used to securely indicate that RRs with\n   \
    \   an owner name in a certain name interval do not exist in a zone\n      and\
    \ to indicate what RR types are present for an existing name.\n   By specifying\
    \ what you do have, you implicitly tell what you don't\n   have.  NXT is superseded\
    \ by NSEC.  In the next section, we explain\n   how NSEC (and thus NXT) works.\n"
- title: 3.2.  NSEC
  contents:
  - "3.2.  NSEC\n   In [RFC3755], all the DNSSEC types were given new names: SIG was\n\
    \   renamed RRSIG, KEY became DNSKEY, and NXT was renamed NSEC, and a\n   minor\
    \ issue was fixed in the process, namely the type bitmap was\n   redefined to\
    \ allow more than 127 types to be listed ([RFC2535],\n   Section 5.2).\n   Just\
    \ as NXT, NSEC is used to describe an interval between names: it\n   indirectly\
    \ tells a resolver which names do not exist in a zone.\n   For this to work, we\
    \ need our \"example.org\" zone to be sorted in\n   canonical order ([RFC4034],\
    \ Section 6.1), and then create the NSECs.\n   We add three NSEC records, one\
    \ for each name, and each one covers a\n   certain interval.  The last NSEC record\
    \ points back to the first as\n   required by RFC 4034 and depicted in Figure\
    \ 2.\n   1.  The first NSEC covers the interval between \"example.org\" and\n\
    \       \"a.example.org\";\n   2.  The second NSEC covers \"a.example.org\" to\
    \ \"d.example.org\";\n   3.  The third NSEC points back to \"example.org\" and\
    \ covers\n       \"d.example.org\" to \"example.org\" (i.e., the end of the zone).\n\
    \   As we have defined the intervals and put those in resource records,\n   we\
    \ now have something that can be signed.\n                       example.org\n\
    \                          **\n                      +-- ** <--+\n           \
    \      (1) /  .    .   \\ (3)\n                    /  .      .   \\\n        \
    \           |  .        .  |\n                   v .          . |\n          \
    \         **    (2)     **\n     a.example.org ** ---------> ** d.example.org\n\
    \   Figure 2: The NSEC records of \"example.org\".  The arrows represent\n   \
    \          NSEC records, starting from the apex.\n   This signed zone is loaded\
    \ into the name server.  It looks like this:\n   example.org.        SOA ( ...\
    \ )\n                       DNSKEY ( ... )\n                       NS  a.example.org.\n\
    \                       NSEC a.example.org. NS SOA RRSIG NSEC DNSKEY\n       \
    \                RRSIG(NS) ( ... )\n                       RRSIG(SOA) ( ... )\n\
    \                       RRSIG(NSEC) ( ... )\n                       RRSIG(DNSKEY)\
    \ ( ... )\n   a.example.org.      A 192.0.2.1\n                       TXT \"a\
    \ record\"\n                       NSEC d.example.org. A TXT RRSIG NSEC\n    \
    \                   RRSIG(A) ( ... )\n                       RRSIG(TXT) ( ...\
    \ )\n                       RRSIG(NSEC) ( ... )\n   d.example.org.      A 192.0.2.1\n\
    \                       TXT \"d record\"\n                       NSEC example.org.\
    \ A TXT RRSIG NSEC\n                       RRSIG(A) ( ... )\n                \
    \       RRSIG(TXT) ( ... )\n                       RRSIG(NSEC) ( ... )\n   Figure\
    \ 3: The signed and sorted \"example.org\" zone with the added\n             NSEC\
    \ records (and signatures).  For brevity, the class is\n             not shown\
    \ (defaults to IN) and the SOA, DNSKEY, and RRSIG\n             records are shortened.\n\
    \   If a DNSSEC-aware resolver asks for \"b.example.org\", it gets back a\n  \
    \ \"status: NXDOMAIN\" packet, which by itself is meaningless (remember\n   that\
    \ the DNS packet header is not signed and thus can be forged).  To\n   be able\
    \ to securely detect that \"b\" does not exist, there must also\n   be a signed\
    \ NSEC record that covers the name space where \"b\" lives.\n   The record:\n\
    \   a.example.org.      NSEC d.example.org. A TXT RRSIG NSEC\n   does precisely\
    \ that: \"b\" should come after \"a\", but the next owner\n   name is \"d.example.org\"\
    , so \"b\" does not exist.\n   Only by making that calculation is a resolver able\
    \ to conclude that\n   the name \"b\" does not exist.  If the signature of the\
    \ NSEC record is\n   valid, \"b\" is proven not to exist.  We have authenticated\
    \ denial of\n   existence.  A similar NSEC record needs to be included to deny\n\
    \   wildcard expansion, see Section 5.3.\n   Note that a man in the middle may\
    \ still replay this NXDOMAIN response\n   when you're querying for, say, \"c.example.org\"\
    .  But, it would not do\n   any harm since it is provable that this is the proper\
    \ response to the\n   query.\n"
- title: 3.3.  NODATA Responses
  contents:
  - "3.3.  NODATA Responses\n   NSEC records are also used in NODATA responses.  In\
    \ that case, we\n   need to look more closely at the type bitmap.  The type bitmap\
    \ in an\n   NSEC record tells which types are defined for a name.  If we look\
    \ at\n   the NSEC record of \"a.example.org\", we see the following types in the\n\
    \   bitmap: A, TXT, NSEC, and RRSIG.  So, for the name \"a\", this\n   indicates\
    \ we must have an A, TXT, NSEC, and RRSIG record in the zone.\n   With the type\
    \ bitmap of the NSEC record, a resolver can establish\n   that a name is there,\
    \ but the type is not.  For example, if a\n   resolver asks for \"a.example.org\
    \ AAAA\", the reply that comes back is:\n   ;; status: NOERROR, id: 44638\n  \
    \ ;; AUTHORITY SECTION:\n   example.org.        SOA ( ... )\n   example.org. \
    \       RRSIG(SOA) ( ... )\n   a.example.org.      NSEC d.example.org. A TXT RRSIG\
    \ NSEC\n   a.example.org.      RRSIG(NSEC) ( ... )\n   The resolver should check\
    \ the AUTHORITY section and conclude that:\n   (1)  \"a.example.org\" exists (because\
    \ of the NSEC with that owner\n        name); and\n   (2)  the type (AAAA) does\
    \ not exist as it is not listed in the type\n        bitmap.\n   The techniques\
    \ used by NSEC form the basics of authenticated denial\n   of existence in DNSSEC.\n"
- title: 3.4.  Drawbacks of NSEC
  contents:
  - "3.4.  Drawbacks of NSEC\n   There were two issues with NSEC (and NXT).  The first\
    \ is that it\n   allows for zone walking.  NSEC records point from one name to\n\
    \   another; in our example: \"example.org\" points to \"a.example.org\",\n  \
    \ which points to \"d.example.org\", which points back to \"example.org\".\n \
    \  So, we can reconstruct the entire \"example.org\" zone, thus defeating\n  \
    \ attempts to administratively block zone transfers ([RFC2065],\n   Section 5.5).\n\
    \   The second issue is that when a large, delegation-centric ([RFC5155],\n  \
    \ Section 1.1) zone deploys DNSSEC, every name in the zone gets an NSEC\n   plus\
    \ RRSIG.  So, this leads to a huge increase in the zone size (when\n   signed).\
    \  This would in turn mean that operators of such zones who\n   are deploying\
    \ DNSSEC face up-front costs.  This could hinder DNSSEC\n   adoption.\n   These\
    \ two issues eventually lead to NSEC3, which:\n   o  Adds a way to garble the\
    \ owner names thus thwarting zone walking;\n   o  Makes it possible to skip names\
    \ for the next owner name.  This\n      feature is called Opt-Out (see Section\
    \ 5.1).  It means not all\n      names in your zone get an NSEC3 plus ditto signature,\
    \ making it\n      possible to \"grow into\" your DNSSEC deployment.\n   Note\
    \ that there are other ways to mitigate zone walking.  RFC 4470\n   [RFC4470]\
    \ prevents zone walking by introducing minimally covering\n   NSEC records.  This\
    \ technique is described in Appendix A.\n   Before we delve into NSEC3, let us\
    \ first take a look at its\n   predecessors: NO, NSEC2, and DNSNR.\n"
- title: '4.  Experimental and Deprecated Mechanisms: NO, NSEC2, and DNSNR'
  contents:
  - "4.  Experimental and Deprecated Mechanisms: NO, NSEC2, and DNSNR\n   Long before\
    \ NSEC was defined, the NO record was introduced.  It was\n   the first record\
    \ to use the idea of hashed owner names to fix the\n   issue of zone walking that\
    \ was present with the NXT record.  It also\n   fixed the type bitmap issue of\
    \ the NXT record, but not in a space-\n   efficient way.  At that time (around\
    \ 2000), zone walking was not\n   considered important enough to warrant the new\
    \ record.  People were\n   also worried that DNSSEC deployment would be hindered\
    \ by developing\n   an alternate means of denial of existence.  Thus, the effort\
    \ was\n   shelved and NXT remained.\n   When the new DNSSEC specification [RFC4034]\
    \ was written, people were\n   still not convinced that zone walking was a problem\
    \ that should be\n   solved.  So, NSEC saw the light and inherited the two issues\
    \ from\n   NXT.\n   Several years after, NSEC2 was introduced as a way to solve\
    \ the two\n   issues of NSEC.  The NSEC2 document [DNSEXT-NSEC2] contains the\n\
    \   following paragraph:\n      This document proposes an alternate scheme which\
    \ hides owner names\n      while permitting authenticated denial of existence\
    \ of non-existent\n      names.  The scheme uses two new RR types: NSEC2 and EXIST.\n\
    \   When an authenticated denial-of-existence scheme starts to talk about\n  \
    \ EXIST records, it is worth paying extra attention.  The EXIST record\n   was\
    \ defined as a record without RDATA that would be used to signal\n   the presence\
    \ of a domain name.  From [DNSEXT-NSEC2]:\n      In order to prove the nonexistence\
    \ of a record that might be\n      covered by a wildcard, it is necessary to prove\
    \ the existence of\n      its closest encloser.  This record does that.  Its owner\
    \ is the\n      closest encloser.  It has no RDATA.  If there is another RR that\n\
    \      proves the existence of the closest encloser, this SHOULD be used\n   \
    \   instead of an EXIST record.\n   The introduction of this record led to questions\
    \ about what wildcards\n   actually mean (especially in the context of DNSSEC).\
    \  It is probably\n   not a coincidence that \"The Role of Wildcards in the Domain\
    \ Name\n   System\" [RFC4592] was standardized before NSEC3 was.\n   NSEC2 solved\
    \ the zone-walking issue by hashing (with SHA1 and a salt)\n   the \"next owner\
    \ name\" in the record, thereby making it useless for\n   zone walking.  But,\
    \ it did not have Opt-Out.\n   The DNSNR record was another attempt that used\
    \ hashed names to foil\n   zone walking, and it also introduced the concept of\
    \ opting out\n   (called \"Authoritative Only Flag\"), which limited the use of\
    \ DNSNR in\n   delegation-centric zones.\n   All of these proposals didn't make\
    \ it, but they did provide valuable\n   insights.  To summarize:\n   o  The NO\
    \ record introduced hashing, but this idea lingered in the\n      background for\
    \ a long time;\n   o  The NSEC2 record made it clear that wildcards were not completely\n\
    \      understood;\n   o  The DNSNR record used a new flag field in the RDATA\
    \ to signal Opt-\n      Out.\n"
- title: 5.  NSEC3
  contents:
  - "5.  NSEC3\n   From the experience gained with NSEC2 and DNSNR, NSEC3 was forged.\n\
    \   It incorporates both Opt-Out and the hashing of names.  NSEC3 solves\n   any\
    \ issues people might have with NSEC, but it introduces some\n   additional complexity.\n\
    \   NSEC3 did not supersede NSEC; they are both defined for DNSSEC.  So,\n   DNSSEC\
    \ is blessed with two different means to perform authenticated\n   denial of existence:\
    \ NSEC and NSEC3.  In NSEC3, every name is hashed,\n   including the owner name.\
    \  This means that the NSEC3 chain is sorted\n   in hash order, instead of canonical\
    \ order.  Because the owner names\n   are hashed, the next owner name for \"example.org\"\
    \ is unlikely to be\n   \"a.example.org\".  Because the next owner name is hashed,\
    \ zone walking\n   becomes more difficult.\n   To make it even more difficult\
    \ to retrieve the original names, the\n   hashing can be repeated several times,\
    \ each time taking the previous\n   hash as input.  To prevent the reuse of pre-generated\
    \ hash values\n   between zones, a (per-zone) salt can also be added.  In the\
    \ NSEC3 for\n   \"example.org\", we have hashed the names thrice ([RFC5155], Section\
    \ 5)\n   and used the salt \"DEAD\".  Let's look at a typical NSEC3 record:\n\
    \   15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (\n      NSEC3 1 0 2 DEAD A6EDKB6V8VL5OL8JNQQLT74QMJ7HEB84\n\
    \           NS SOA RRSIG DNSKEY NSEC3PARAM )\n   On the first line, we see the\
    \ hashed owner name:\n   \"15bg9l6359f5ch23e34ddua6n1rihl9h.example.org\"; this\
    \ is the hashed\n   name of the fully qualified domain name (FQDN) \"example.org\"\
    \ encoded\n   as Base32 [RFC4648].  Note that even though we hashed \"example.org\"\
    ,\n   the zone's name is added to make it look like a domain name again.\n   In\
    \ our zone, the basic format is \"Base32(SHA1(FQDN)).example.org\".\n   The next\
    \ hashed owner name \"A6EDKB6V8VL5OL8JNQQLT74QMJ7HEB84\" (line\n   2) is the hashed\
    \ version of \"d.example.org\", represented as Base32.\n   Note that \"d.example.org\"\
    \ is used as the next owner name because in\n   the hash ordering, its hash comes\
    \ after the hash of the zone's apex.\n   Also, note that \".example.org\" is not\
    \ added to the next hashed owner\n   name, as this name always falls in the current\
    \ zone.\n   The \"1 0 2 DEAD\" segment of the NSEC3 states:\n   o  Hash Algorithm\
    \ = 1 (SHA1 is the default; no other hash algorithms\n      are currently defined\
    \ for use in NSEC3; see Section 3.1.1 of\n      [RFC5155]);\n   o  Opt-Out = 0\
    \ (disabled; see Section 6 of [RFC5155]);\n   o  Hash Iterations = 2 (this yields\
    \ three iterations, as a zero value\n      is already one iteration; see Section\
    \ 3.1.3 of [RFC5155]);\n   o  Salt = \"DEAD\" (see Section 3.1.5 of [RFC5155].\n\
    \   At the end, we see the type bitmap, which is identical to NSEC's\n   bitmap,\
    \ that lists the types present at the original owner name.\n   Note that the type\
    \ NSEC3 is absent from the list in the example\n   above.  This is due to the\
    \ fact that the original owner name\n   (\"example.org\") does not have the NSEC3\
    \ type.  It only exists for the\n   hashed name.\n   Names like \"1.h.example.org\"\
    \ hash to one label in NSEC3 and\n   \"1.h.example.org\" becomes:\n   \"117gercprcjgg8j04ev1ndrk8d1jt14k.example.org\"\
    \ when used as an owner\n   name.  This is an important observation.  By hashing\
    \ the names, you\n   lose the depth of a zone -- hashing introduces a flat space\
    \ of names,\n   as opposed to NSEC.\n   The name used above (\"1.h.example.org\"\
    ) creates an empty non-\n   terminal.  Empty non-terminals are domain names that\
    \ have no RRs\n   associated with them and exist only because they have one or\
    \ more\n   subdomains that do ([RFC5155], Section 1.3).  The record:\n       1.h.example.org.\
    \    TXT \"1.h record\"\n   creates two names:\n   1.  \"1.h.example.org\" that\
    \ has the type: TXT;\n   2.  \"h.example.org\", which has no types.  This is the\
    \ empty non-\n       terminal.\n   An empty non-terminal will get an NSEC3 record\
    \ but not an NSEC\n   record.  In Section 5.5, how the resolver uses these NSEC3\
    \ records to\n   validate the denial-of-existence proofs is shown.\n   Note that\
    \ NSEC3 might not always be useful.  For example, highly\n   structured zones,\
    \ like the reverse zones ip6.arpa and in-addr.arpa,\n   can be walked even with\
    \ NSEC3 due to their structure.  Also, the\n   names in small, trivial zones can\
    \ be easily guessed.  In these cases,\n   it does not help to defend against zone\
    \ walking, but it does add the\n   computational load on authoritative servers\
    \ and validators.\n"
- title: 5.1.  Opt-Out
  contents:
  - "5.1.  Opt-Out\n   Hashing mitigates the zone-walking issue of NSEC.  The other\
    \ issue,\n   the high costs of securing a delegation to an insecure zone, is\n\
    \   tackled with Opt-Out.  When using Opt-Out, names that are an insecure\n  \
    \ delegation (and empty non-terminals that are only derived from\n   insecure\
    \ delegations) don't require an NSEC3 record.  For each\n   insecure delegation,\
    \ the zone size can be decreased (compared with a\n   fully signed zone without\
    \ using Opt-Out) with at least two records:\n   one NSEC3 record and one corresponding\
    \ RRSIG record.  If the insecure\n   delegation would introduce empty non-terminals,\
    \ even more records can\n   be omitted from the zone.\n   Opt-Out NSEC3 records\
    \ are not able to prove or deny the existence of\n   the insecure delegations.\
    \  In other words, those delegations do not\n   benefit from the cryptographic\
    \ security that DNSSEC provides.\n   A recently discovered corner case (see RFC\
    \ Errata ID 3441 [Err3441])\n   shows that not only those delegations remain insecure\
    \ but also the\n   empty non-terminal space that is derived from those delegations.\n\
    \   Because the names in this empty non-terminal space do exist according\n  \
    \ to the definition in [RFC4592], the server should respond to queries\n   for\
    \ these names with a NODATA response.  However, the validator\n   requires an\
    \ NSEC3 record proving the NODATA response ([RFC5155],\n   Section 8.5):\n   \
    \   The validator MUST verify that an NSEC3 RR that matches QNAME is\n      present\
    \ and that both the QTYPE and the CNAME type are not set in\n      its Type Bit\
    \ Maps field.\n   A way to resolve this contradiction in the specification is\
    \ to always\n   provide empty non-terminals with an NSEC3 record, even if it is\
    \ only\n   derived from an insecure delegation.\n"
- title: 5.2.  Loading an NSEC3 Zone
  contents:
  - "5.2.  Loading an NSEC3 Zone\n   Whenever an authoritative server receives a query\
    \ for a non-existing\n   record, it has to hash the incoming query name to determine\
    \ into\n   which interval between two existing hashes it falls.  To do that, it\n\
    \   needs to know the zone's specific NSEC3 parameters (hash iterations\n   and\
    \ salt).\n   One way to learn them is to scan the zone during loading for NSEC3\n\
    \   records and glean the NSEC3 parameters from them.  However, it would\n   need\
    \ to make sure that there is at least one complete set of NSEC3\n   records for\
    \ the zone using the same parameters.  Therefore, it would\n   need to inspect\
    \ all NSEC3 records.\n   A more graceful solution was designed.  The solution\
    \ was to create a\n   new record, NSEC3PARAM, which must be placed at the apex\
    \ of the zone.\n   Its role is to provide a fixed place where an authoritative\
    \ name\n   server can directly see the NSEC3 parameters used, and by putting it\n\
    \   in the zone, it allows for easy transfer to the secondaries.\n"
- title: 5.3.  Wildcards in the DNS
  contents:
  - "5.3.  Wildcards in the DNS\n   So far, we have only talked about denial of existence\
    \ in negative\n   responses.  However, denial of existence may also occur in positive\n\
    \   responses, i.e., where the ANSWER section of the response is not\n   empty.\
    \  This can happen because of wildcards.\n   Wildcards have been part of the DNS\
    \ since the first DNS RFCs.  They\n   allow to define all names for a certain\
    \ type in one go.  In our\n   \"example.org\" zone, we could, for instance, add\
    \ a wildcard record:\n   *.example.org.      TXT \"wildcard record\"\n   For completeness,\
    \ our (unsigned) zone now looks like this:\n   example.org.        SOA ( ... )\n\
    \   example.org.        NS  a.example.org.\n   *.example.org.      TXT \"wildcard\
    \ record\"\n   a.example.org.      A 192.0.2.1\n                       TXT \"\
    a record\"\n   d.example.org.      A 192.0.2.1\n                       TXT \"\
    d record\"\n   Figure 4: The example.org Zone with a Wildcard Record\n   If a\
    \ resolver asks for \"z.example.org TXT\", the name server will\n   respond with\
    \ an expanded wildcard instead of an NXDOMAIN:\n   ;; status: NOERROR, id: 13658\n\
    \   ;; ANSWER SECTION:\n   z.example.org.      TXT \"wildcard record\"\n   Note,\
    \ however, that the resolver cannot detect that this answer came\n   from a wildcard.\
    \  It just sees the answer as is.  How will this\n   answer look with DNSSEC?\n\
    \   ;; status: NOERROR, id: 51790\n   ;; ANSWER SECTION:\n   z.example.org.  \
    \    TXT \"wildcard record\"\n   z.example.org.      RRSIG(TXT) ( ... )\n   ;;\
    \ AUTHORITY SECTION:\n   d.example.org.      NSEC example.org. A TXT RRSIG NSEC\n\
    \   d.example.org.      RRSIG(NSEC) ( ... )\n   Figure 5: A Response with an Expanded\
    \ Wildcard and DNSSEC\n   The RRSIG of the \"z.example.org\" TXT record indicates\
    \ there is a\n   wildcard configured.  The RDATA of the signature lists a label\
    \ count,\n   [RFC4034], Section 3.1.3., of two (not visible in the figure above),\n\
    \   but the owner name of the signature has three labels.  This mismatch\n   indicates\
    \ there is a wildcard \"*.example.org\" configured.\n      An astute reader may\
    \ notice that it appears as if a\n      \"z.example.org\" RRSIG(TXT) is created\
    \ out of thin air.  This is\n      not the case.  The signature for \"z.example.org\"\
    \ does not exist.\n      The signature you are seeing is the one for \"*.example.org\"\
    , which\n      does exist; only the owner name is switched to \"z.example.org\"\
    .\n      So, even with wildcards, no signatures have to be created on the\n  \
    \    fly.\n   The DNSSEC standard mandates that an NSEC (or NSEC3) is included\
    \ in\n   such responses.  If it wasn't, an attacker could mount a replay\n   attack\
    \ and poison the cache with false data.  Suppose that the\n   resolver has asked\
    \ for \"a.example.org TXT\".  An attacker could modify\n   the packet in such\
    \ way that it looks like the response was generated\n   through wildcard expansion,\
    \ even though a record exists for\n   \"a.example.org TXT\".\n   The tweaking\
    \ simply consists of adjusting the ANSWER section to:\n   ;; status: NOERROR,\
    \ id: 31827\n   ;; ANSWER SECTION:\n   a.example.org.      TXT \"wildcard record\"\
    \n   a.example.org.      RRSIG(TXT) ( ... )\n   Figure 6: A Forged Response without\
    \ the Expanded Wildcard\n   Note the subtle difference from Figure 5 in the owner\
    \ name.  In this\n   response, we see a \"a.example.org TXT\" record for which\
    \ a record with\n   different RDATA (see Figure 4) exists in the zone.\n   That\
    \ would be a perfectly valid answer if we would not require the\n   inclusion\
    \ of an NSEC or NSEC3 record in the wildcard answer response.\n   The resolver\
    \ believes that \"a.example.org TXT\" is a wildcard record,\n   and the real record\
    \ is obscured.  This is bad and defeats all the\n   security DNSSEC can deliver.\
    \  Because of this, the NSEC or NSEC3 must\n   be present.\n   Another way of\
    \ putting this is that DNSSEC is there to ensure the\n   name server has followed\
    \ the steps as outlined in [RFC1034],\n   Section 4.3.2 for looking up names in\
    \ the zone.  It explicitly lists\n   wildcard lookup as one of these steps (3c),\
    \ so with DNSSEC this must\n   be communicated to the resolver: hence, the NSEC\
    \ or NSEC3 record.\n"
- title: 5.4.  CNAME Records
  contents:
  - "5.4.  CNAME Records\n   So far, the maximum number of NSEC records a response\
    \ will have is\n   two: one for the denial of existence and another for the wildcard.\n\
    \   We say maximum because sometimes a single NSEC can prove both.  With\n   NSEC3,\
    \ this is three (as to why, we will explain in the next\n   section).\n   When\
    \ we take CNAME wildcard records into account, we can have more\n   NSEC or NSEC3\
    \ records.  For every wildcard expansion, we need to\n   prove that the expansion\
    \ was allowed.  Let's add some CNAME wildcard\n   records to our zone:\n   example.org.\
    \        SOA ( ... )\n   example.org.        NS  a.example.org.\n   *.example.org.\
    \      TXT \"wildcard record\"\n   a.example.org.      A 192.0.2.1\n         \
    \              TXT \"a record\"\n   *.a.example.org.    CNAME w.b\n   *.b.example.org.\
    \    CNAME w.c\n   *.c.example.org.    A 192.0.2.1\n   d.example.org.      A 192.0.2.1\n\
    \                       TXT \"d record\"\n   w.example.org.      CNAME w.a\n \
    \  Figure 7: A Wildcard CNAME Chain Added to the \"example.org\" Zone\n   A query\
    \ for \"w.example.org A\" will result in the following response:\n   ;; status:\
    \ NOERROR, id: 4307\n   ;; ANSWER SECTION:\n   w.example.org.      CNAME w.a.example.org.\n\
    \   w.example.org.      RRSIG(CNAME) ( ... )\n   w.a.example.org.    CNAME w.b.example.org.\n\
    \   w.a.example.org.    RRSIG(CNAME) ( ... )\n   w.b.example.org.    CNAME w.c.example.org.\n\
    \   w.b.example.org.    RRSIG(CNAME) ( ... )\n   w.c.example.org.    A 192.0.2.1\n\
    \   w.c.example.org.    RRSIG(A) ( ... )\n   ;; AUTHORITY SECTION:\n   *.a.example.org.\
    \    NSEC *.b.example.org. CNAME RRSIG NSEC\n   *.a.example.org.    RRSIG(NSEC)\
    \ ( ... )\n   *.b.example.org.    NSEC *.c.example.org. CNAME RRSIG NSEC\n   *.b.example.org.\
    \    RRSIG(NSEC) ( ... )\n   *.c.example.org.    NSEC d.example.org. A RRSIG NSEC\n\
    \   *.c.example.org.    RRSIG(NSEC) ( ... )\n   The NSEC record \"*.a.example.org\"\
    \ proves that wildcard expansion to\n   \"w.a.example.org\" was appropriate: \"\
    w.a.\" falls in the gap \"*.a\" to\n   \"*.b\".  Similarly, the NSEC record \"\
    *.b.example.org\" proves that\n   there was no direct match for \"w.b.example.org\"\
    \ and \"*.c.example.org\"\n   denies the direct match for \"w.c.example.org\"\
    .\n   DNAME records and wildcard names should not be used as reiterated in\n \
    \  [RFC6672], Section 3.3.\n"
- title: 5.5.  The Closest Encloser NSEC3 Record
  contents:
  - "5.5.  The Closest Encloser NSEC3 Record\n   We can have one or more NSEC3 records\
    \ that deny the existence of the\n   requested name and one NSEC3 record that\
    \ denies wildcard synthesis.\n   What do we miss?\n   The short answer is that\
    \ due to the hashing in NSEC3, you lose the\n   depth of your zone and everything\
    \ is hashed into a flat plane.  To\n   make up for this loss of information, you\
    \ need an extra record.\n   To understand NSEC3, we will need two definitions:\n\
    \   Closest encloser:  Introduced in [RFC4592] as:\n      The closest encloser\
    \ is the node in the zone's tree of existing\n      domain names that has the\
    \ most labels matching the query name\n      (consecutively, counting from the\
    \ root label downward).\n      In our example, if the query name is \"x.2.example.org\"\
    , then\n      \"example.org\" is the \"closest encloser\";\n   Next closer name:\
    \  Introduced in [RFC5155], this is the closest\n      encloser with one more\
    \ label added to the left.  So, if\n      \"example.org\" is the closest encloser\
    \ for the query name\n      \"x.2.example.org\", \"2.example.org\" is the \"next\
    \ closer name\".\n   An NSEC3 \"closest encloser proof\" consists of:\n   1. \
    \ An NSEC3 record that *matches* the \"closest encloser\".  This\n       means\
    \ the unhashed owner name of the record is the closest\n       encloser.  This\
    \ bit of information tells a resolver: \"The name\n       you are asking for does\
    \ not exist; the closest I have is this\".\n   2.  An NSEC3 record that *covers*\
    \ the \"next closer name\".  This means\n       it defines an interval in which\
    \ the \"next closer name\" falls.\n       This tells the resolver: \"The next\
    \ closer name falls in this\n       interval, and therefore the name in your question\
    \ does not exist.\n       In fact, the closest encloser is indeed the closest\
    \ I have\".\n   These two records already deny the existence of the requested\
    \ name,\n   so we do not need an NSEC3 record that covers the actual queried\n\
    \   name.  By denying the existence of the next closer name, you also\n   deny\
    \ the existence of the queried name.\n   Note that with NSEC, the existence of\
    \ all empty non-terminals between\n   the two names are denied, hence it implicitly\
    \ contains the closest\n   encloser.\n   For a given query name, there is one\
    \ (and only one) place where\n   wildcard expansion is possible.  This is the\
    \ \"source of synthesis\"\n   and is defined ([RFC4592], Sections 2.1.1 and 3.3.1)\
    \ as:\n   <asterisk label>.<closest encloser>\n   In other words, to deny wildcard\
    \ synthesis, the resolver needs to\n   know the hash of the source of synthesis.\
    \  Since it does not know\n   beforehand what the closest encloser of the query\
    \ name is, it must be\n   provided in the answer.\n   Take the following example.\
    \  We have a zone with two TXT records to\n   it.  The records added are \"1.h.example.org\"\
    \ and \"3.3.example.org\".\n   It is signed with NSEC3, resulting in the following\
    \ unsigned zone:\n    example.org.        SOA ( ... )\n    example.org.      \
    \  NS  a.example.org.\n    1.h.example.org.    TXT \"1.h record\"\n    3.3.example.org.\
    \    TXT \"3.3 record\"\n   Figure 8: The TXT records in example.org.  These records\
    \ create two\n   empty non-terminals: h.example.org and 3.example.org.\n   The\
    \ resolver asks the following: \"x.2.example.org TXT\".  This leads\n   to an\
    \ NXDOMAIN response from the server, which contains three NSEC3\n   records. \
    \ A list of hashed owner names can be found in Appendix C.\n   Also, see Figure\
    \ 9; the numbers in that figure correspond with the\n   following NSEC3 records:\n\
    \   15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (\n    NSEC3 1 0 2 DEAD 1AVVQN74SG75UKFVF25DGCETHGQ638EK\
    \ NS SOA RRSIG\n           DNSKEY NSEC3PARAM )\n   1avvqn74sg75ukfvf25dgcethgq638ek.example.org.\
    \ (\n       NSEC3 1 0 2 DEAD 75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ )\n   75b9id679qqov6ldfhd8ocshsssb6jvq.example.org.\
    \ (\n    NSEC3 1 0 2 DEAD 8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ TXT RRSIG )\n   If\
    \ we would follow the NSEC approach, the resolver is only interested\n   in one\
    \ thing.  Does the hash of \"x.2.example.org\" fall in any of the\n   intervals\
    \ of the NSEC3 records it got?\n                       example.org\n         \
    \                 **\n                      +-- ** . . . . . . . . . . .\n   \
    \              (1) /  . ^ .                     .\n                    /  .  |\
    \   .                    .\n                   |  .   |    .                 \
    \   .\n                   v .    |     .                    .\n              \
    \     **     | (2)  **                  ++\n     h.example.org ** ----+----> **\
    \ 3.example.org    ++ 2.example.org\n                   .     /        . |   \
    \             .\n                   .    / (5)     . | (3)            .\n    \
    \               .   /          . |                .\n                   .  / \
    \          . v                .\n   1.h.example.org **            **         \
    \         ++\n                   ** <--------- ** 3.3.example.org  ++ x.2.example.org\n\
    \                            (4)\n   Figure 9: \"x.2.example.org\" does not exist.\
    \  The five arrows\n             represent the NSEC3 records; the ones numbered\
    \ (1), (2),\n             and (3) are the NSEC3s returned in our answer.\n   \
    \          \"2.example.org\" is covered by (3) and \"x.2.example.org\" is\n  \
    \           covered by (4).\n   The hash of \"x.2.example.org\" is \"ndtu6dste50pr4a1f2qvr1v31g00i2i1\"\
    .\n   Checking this hash on the first NSEC3 yields that it does not fall in\n\
    \   between the interval: \"15bg9l6359f5ch23e34ddua6n1rihl9h\" to\n   \"1avvqn74sg75ukfvf25dgcethgq638ek\"\
    .  For the second NSEC3, the answer\n   is also negative: the hash sorts outside\
    \ the interval described by\n   \"1avvqn74sg75ukfvf25dgcethgq638ek\" and\n   \"\
    75b9id679qqov6ldfhd8ocshsssb6jvq\".  And, the third NSEC3, with\n   interval \"\
    75b9id679qqov6ldfhd8ocshsssb6jvq\" to\n   \"8555t7qegau7pjtksnbchg4td2m0jnpj\"\
    \ also isn't of any help.\n   What is a resolver to do?  It has been given the\
    \ maximum amount of\n   NSEC3s and they all seem useless.\n   So, this is where\
    \ the closest encloser proof comes into play.  And,\n   for the proof to work,\
    \ the resolver needs to know what the closest\n   encloser is.  There must be\
    \ an existing ancestor in the zone: a name\n   must exist that is shorter than\
    \ the query name.  The resolver keeps\n   hashing increasingly shorter names from\
    \ the query name until an owner\n   name of an NSEC3 matches.  This owner name\
    \ is the closest encloser.\n   When the resolver has found the closest encloser,\
    \ the next step is to\n   construct the next closer name.  This is the closest\
    \ encloser with\n   the last chopped label from the query name prepended to it:\
    \ \"<last\n   chopped label>.<closest encloser>\".  The hash of this name should\
    \ be\n   covered by the interval set in any of the NSEC3 records.\n   Then, the\
    \ resolver needs to check the presence of a wildcard.  It\n   creates the wildcard\
    \ name by prepending the asterisk label to the\n   closest encloser, \"*.<closest\
    \ encloser>\", and uses the hash of that.\n   Going back to our example, the resolver\
    \ must first detect the NSEC3\n   that matches the closest encloser.  It does\
    \ this by chopping up the\n   query name, hashing each instance (with the same\
    \ number of iterations\n   and hash as the zone it is querying), and comparing\
    \ that to the\n   answers given.  So, it has the following hashes to work with:\n\
    \   x.2.example.org:  \"ndtu6dste50pr4a1f2qvr1v31g00i2i1\", last chopped\n   \
    \   label: \"<empty>\";\n   2.example.org:  \"7t70drg4ekc28v93q7gnbleopa7vlp6q\"\
    , last chopped\n      label: \"x\";\n   example.org:  \"15bg9l6359f5ch23e34ddua6n1rihl9h\"\
    , last chopped label:\n      \"2\".\n   Of these hashes, only one matches the\
    \ owner name of one of the NSEC3\n   records: \"15bg9l6359f5ch23e34ddua6n1rihl9h\"\
    .  This must be the\n   closest encloser (unhashed: \"example.org\").  That's\
    \ the main purpose\n   of that NSEC3 record: tell the resolver what the closest\
    \ encloser is.\n   When using Opt-Out, it is possible that the actual closest\
    \ encloser\n   to the QNAME does not have an NSEC3 record.  If so, we will have\
    \ to\n   do with the closest provable encloser, which is the closest enclosing\n\
    \   authoritative name that does have an NSEC3 record.  In the worst\n   case,\
    \ this is the NSEC3 record corresponding to the apex; this name\n   must always\
    \ have an NSEC3 record.\n   With the closest (provable) encloser, the resolver\
    \ constructs the\n   next closer, which in this case is: \"2.example.org\"; \"\
    2\" is the last\n   label chopped when \"example.org\" is the closest encloser.\
    \  The hash\n   of this name should be covered in any of the other NSEC3s.  And,\
    \ it\n   is -- \"7t70drg4ekc28v93q7gnbleopa7vlp6q\" falls in the interval set\
    \ by\n   \"75b9id679qqov6ldfhd8ocshsssb6jvq\" and\n   \"8555t7qegau7pjtksnbchg4td2m0jnpj\"\
    \ (this is our second NSEC3).\n   So, what does the resolver learn from this?\n\
    \   o  \"example.org\" exists;\n   o  \"2.example.org\" does not exist.\n   And,\
    \ if \"2.example.org\" does not exist, there is also no direct match\n   for \"\
    x.2.example.org\".  The last step is to deny the existence of the\n   source of\
    \ synthesis to prove that no wildcard expansion was possible.\n   The resolver\
    \ hashes \"*.example.org\" to\n   \"22670trplhsr72pqqmedltg1kdqeolb7\" and checks\
    \ that it is covered.  In\n   this case, by the last NSEC3 (see Figure 9), the\
    \ hash falls in the\n   interval set by \"1avvqn74sg75ukfvf25dgcethgq638ek\" and\n\
    \   \"75b9id679qqov6ldfhd8ocshsssb6jvq\".  This means there is no wildcard\n \
    \  record directly below the closest encloser, and \"x.2.example.org\"\n   definitely\
    \ does not exist.\n   When we have validated the signatures, we have reached our\
    \ goal:\n   authenticated denial of existence.\n"
- title: 5.6.  Three to Tango
  contents:
  - "5.6.  Three to Tango\n   One extra NSEC3 record plus an additional signature\
    \ may seem like a\n   lot just to deny the existence of the wildcard record, but\
    \ we cannot\n   leave it out.  If the standard would not mandate the closest encloser\n\
    \   NSEC3 record but instead required two NSEC3 records -- one to deny\n   the\
    \ query name and one to deny the wildcard record -- an attacker\n   could fool\
    \ the resolver that the source of synthesis does not exist,\n   while it in fact\
    \ does.\n   Suppose the wildcard record does exist, so our unsigned zone looks\n\
    \   like this:\n   example.org.        SOA ( ... )\n   example.org.        NS\
    \  a.example.org.\n   *.example.org.      TXT \"wildcard record\"\n   1.h.example.org.\
    \    TXT \"1.h record\"\n   3.3.example.org.    TXT \"3.3 record\"\n   The query\
    \ \"x.2.example.org TXT\" should now be answered with:\n   x.2.example.org.  \
    \  TXT \"wildcard record\"\n   An attacker can deny this wildcard expansion by\
    \ calculating the hash\n   for the wildcard name \"*.2.example.org\" and searching\
    \ for an NSEC3\n   record that covers that hash.  The hash of \"*.2.example.org\"\
    \ is\n   \"fbq73bfkjlrkdoqs27k5qf81aqqd7hho\".  Looking through the NSEC3\n  \
    \ records in our zone, we see that the NSEC3 record of \"3.3\" covers\n   this\
    \ hash:\n   8555t7qegau7pjtksnbchg4td2m0jnpj.example.org. (\n       NSEC3 1 0\
    \ 2 DEAD 15BG9L6359F5CH23E34DDUA6N1RIHL9H TXT RRSIG )\n   This record also covers\
    \ the query name \"x.2.example.org\"\n   (\"ndtu6dste50pr4a1f2qvr1v31g00i2i1\"\
    ).\n   Now an attacker adds this NSEC3 record to the AUTHORITY section of\n  \
    \ the reply to deny both \"x.2.example.org\" and any wildcard expansion.\n   The\
    \ net result is that the resolver determines that \"x.2.example.org\"\n   does\
    \ not exist, while in fact it should have been synthesized via\n   wildcard expansion.\
    \  With the NSEC3 matching the closest encloser\n   \"example.org\", the resolver\
    \ can be sure that the wildcard expansion\n   should occur at \"*.example.org\"\
    \ and nowhere else.\n   Coming back to the original question: Why do we need up\
    \ to three\n   NSEC3 records to deny a requested name?  The resolver needs to\
    \ be\n   explicitly told what the \"closest encloser\" is, and this takes up a\n\
    \   full NSEC3 record.  Then, the next closer name needs to be covered in\n  \
    \ an NSEC3 record.  Finally, an NSEC3 must say something about whether\n   wildcard\
    \ expansion was possible.  That makes three to tango.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   DNSSEC does not protect against denial-of-service\
    \ attacks, nor does\n   it provide confidentiality.  For more general security\
    \ considerations\n   related to DNSSEC, please see [RFC4033], [RFC4034], [RFC4035],\
    \ and\n   [RFC5155].\n   These RFCs are concise about why certain design choices\
    \ have been\n   made in the area of authenticated denial of existence.\n   Implementations\
    \ that do not correctly handle this aspect of DNSSEC\n   create a severe hole\
    \ in the security DNSSEC adds.  This is\n   specifically troublesome for secure\
    \ delegations.  If an attacker is\n   able to deny the existence of a Delegation\
    \ Signer (DS) record, the\n   resolver cannot establish a chain of trust, and\
    \ the resolver has to\n   fall back to insecure DNS for the remainder of the query\
    \ resolution.\n   This document aims to fill this \"documentation gap\" and provide\n\
    \   would-be implementors and other interested parties with enough\n   background\
    \ knowledge to better understand authenticated denial of\n   existence.\n"
- title: 7.  Acknowledgments
  contents:
  - "7.  Acknowledgments\n   This document would not be possible without the help\
    \ of Ed Lewis, Roy\n   Arends, Wouter Wijngaards, Olaf Kolkman, Carsten Strotmann,\
    \ Jan-Piet\n   Mens, Peter van Dijk, Marco Davids, Esther Makaay, Antoin Verschuren,\n\
    \   Lukas Wunner, Joe Abley, Ralf Weber, Geoff Huston, Dave Lawrence,\n   Tony\
    \ Finch, and Mark Andrews.  Also valuable was the source code of\n   Unbound (\"\
    validator/val_nsec3.c\") [Unbound].\n   Extensive feedback for early versions\
    \ of this document was received\n   from Karst Koymans.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names - concepts\
    \ and facilities\",\n              STD 13, RFC 1034, November 1987.\n   [RFC2065]\
    \  Eastlake, D. and C. Kaufman, \"Domain Name System Security\n              Extensions\"\
    , RFC 2065, January 1997.\n   [RFC2308]  Andrews, M., \"Negative Caching of DNS\
    \ Queries (DNS\n              NCACHE)\", RFC 2308, March 1998.\n   [RFC4033] \
    \ Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,\
    \ \"DNS Security Introduction and Requirements\", RFC\n              4033, March\
    \ 2005.\n   [RFC4034]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n\
    \              Rose, \"Resource Records for the DNS Security Extensions\",\n \
    \             RFC 4034, March 2005.\n   [RFC4035]  Arends, R., Austein, R., Larson,\
    \ M., Massey, D., and S.\n              Rose, \"Protocol Modifications for the\
    \ DNS Security\n              Extensions\", RFC 4035, March 2005.\n   [RFC4592]\
    \  Lewis, E., \"The Role of Wildcards in the Domain Name\n              System\"\
    , RFC 4592, July 2006.\n   [RFC4648]  Josefsson, S., \"The Base16, Base32, and\
    \ Base64 Data\n              Encodings\", RFC 4648, October 2006.\n   [RFC5155]\
    \  Laurie, B., Sisson, G., Arends, R., and D. Blacka, \"DNS\n              Security\
    \ (DNSSEC) Hashed Authenticated Denial of\n              Existence\", RFC 5155,\
    \ March 2008.\n   [RFC6672]  Rose, S. and W. Wijngaards, \"DNAME Redirection in\
    \ the\n              DNS\", RFC 6672, June 2012.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [DNSEXT-NSEC2]\n              Laurie, B., \"\
    DNSSEC NSEC2 Owner and RDATA Format\", Work in\n              Progress, October\
    \ 2004.\n   [DNSEXT]   Josefsson, S., \"Authenticating denial of existence in\
    \ DNS\n              with minimum disclosure\", Work in Progress, November 2000.\n\
    \   [DNSNR-RR] Arends, R., \"DNSSEC Non-Repudiation Resource Record\", Work\n\
    \   in Progress, June 2004.\n   [Err3441]  RFC Errata, Errata ID 3441, RFC 5155,\n\
    \   <http://www.rfc-editor.org>.\n   [RFC2535]  Eastlake, D., \"Domain Name System\
    \ Security Extensions\",\n   RFC 2535, March 1999.\n   [RFC3655]  Wellington,\
    \ B. and O. Gudmundsson, \"Redefinition of DNS\n   Authenticated Data (AD) bit\"\
    , RFC 3655, November 2003.\n   [RFC3755]  Weiler, S., \"Legacy Resolver Compatibility\
    \ for Delegation\n   Signer (DS)\", RFC 3755, May 2004.\n   [RFC4470]  Weiler,\
    \ S. and J. Ihren, \"Minimally Covering NSEC Records\n   and DNSSEC On-line Signing\"\
    , RFC 4470, April 2006.\n   [RFC4956]  Arends, R., Kosters, M., and D. Blacka,\
    \ \"DNS Security\n   (DNSSEC) Opt-In\", RFC 4956, July 2007.\n   [Unbound]  NLnet\
    \ Labs, \"Unbound: a validating, recursive, and caching\n   DNS resolver\", 2006,\
    \ <http://unbound.net>.\n   [phreebird]\n              Kaminsky, D., \"Phreebird:\
    \ a DNSSEC proxy\", January 2011,\n              <http://dankaminsky.com/phreebird/>.\n"
- title: 'Appendix A.  Online Signing: Minimally Covering NSEC Records'
  contents:
  - "Appendix A.  Online Signing: Minimally Covering NSEC Records\n   An NSEC record\
    \ lists the next existing name in a zone and thus makes\n   it trivial to retrieve\
    \ all the names from the zone.  This can also be\n   done with NSEC3, but an adversary\
    \ will then retrieve all the hashed\n   names.  With DNSSEC online signing, zone\
    \ walking can be prevented by\n   faking the next owner name.\n   To prevent retrieval\
    \ of the next owner name with NSEC, a different,\n   non-existing (according to\
    \ the existence rules in [RFC4592],\n   Section 2.2) name is used.  However, not\
    \ just any name can be used\n   because a validator may make assumptions about\
    \ the size of the span\n   the NSEC record covers.  The span must be large enough\
    \ to cover the\n   QNAME but not too large that it covers existing names.\n  \
    \ [RFC4470] introduces a scheme for generating minimally covering NSEC\n   records.\
    \  These records use a next owner name that is lexically\n   closer to the NSEC\
    \ owner name than the actual next owner name,\n   ensuring that no existing names\
    \ are covered.  The next owner name can\n   be derived from the QNAME with the\
    \ use of so-called epsilon\n   functions.\n   For example, to deny the existence\
    \ of \"b.example.org\" in the zone\n   from Section 3.2, the following NSEC record\
    \ could have been\n   generated:\n   a.example.org.      NSEC c.example.org. RRSIG\
    \ NSEC\n   This record also proves that \"b.example.org\" also does not exist,\
    \ but\n   an adversary _cannot_ use the next owner name in a zone-walking\n  \
    \ attack.  Note the type bitmap only has the RRSIG and NSEC set because\n   [RFC4470]\
    \ states:\n      The generated NSEC record's type bitmap MUST have the RRSIG and\n\
    \      NSEC bits set and SHOULD NOT have any other bits set.\n   This is because\
    \ the NSEC records may appear at names that did not\n   exist before the zone\
    \ was signed.  In this case, however,\n   \"a.example.org\" exists with other\
    \ RR types, and we could have also\n   set the A and TXT types in the bitmap.\n\
    \   Because DNS ordering is very strict, the span should be shortened to\n   a\
    \ minimum.  In order to do so, the last character in the leftmost\n   label of\
    \ the NSEC owner name needs to be decremented, and the label\n   must be filled\
    \ with octets of value 255 until the label length\n   reaches the maximum of 63\
    \ octets.  The next owner name is the QNAME\n   with a leading label with a single\
    \ null octet added.  This gives the\n   following minimally covering record for\
    \ \"b.example.org\":\n   a\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\
    255\\255\\255\\255\\255\\255\\255\n    \\255\\255\\255\\255\\255\\255\\255\\255\\\
    255\\255\\255\\255\\255\\255\\255\\255\\255\n    \\255\\255\\255\\255\\255\\255\\\
    255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\n    \\255\\255\\255\\255\\\
    255\\255\\255\\255\\255\\255\\255.example.org. (\n      NSEC \\000.b.example.org.\
    \ RRSIG NSEC )\n"
- title: 'Appendix B.  Online Signing: NSEC3 White Lies'
  contents:
  - "Appendix B.  Online Signing: NSEC3 White Lies\n   The same principle of minimally\
    \ covering spans can be applied to\n   NSEC3 records.  This mechanism has been\
    \ dubbed \"NSEC3 White Lies\"\n   when it was implemented in Phreebird [phreebird].\
    \  Here, the NSEC3\n   owner name is the hash of the QNAME minus one, and the\
    \ next owner\n   name is the hash of the QNAME plus one.\n   The following NSEC3\
    \ white lie denies \"b.example.org\" (recall that\n   this hashes to \"iuu8l5lmt76jeltp0bir3tmg4u3uu8e7\"\
    ):\n   iuu8l5lmt76jeltp0bir3tmg4u3uu8e6.example.org. (\n      NSEC3 1 0 2 DEAD\
    \ IUU815LMT76JELTP0BIR3TMG4U3UU8E8 )\n   The type bitmap is empty in this case.\
    \  If the hash of\n   \"b.example.org\" - 1 is a collision with an existing name,\
    \ the bitmap\n   should have been filled with the RR types that exist at that\
    \ name.\n   This record actually denies the existence of the next closer name\n\
    \   (which is conveniently \"b.example.org\").  Of course, the NSEC3\n   records\
    \ to match the closest encloser and the one to deny the\n   wildcard are still\
    \ required.  These can be generated too:\n   # Matching `example.org`: `15bg9l6359f5ch23e34ddua6n1rihl9h`\n\
    \   15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (\n      NSEC3 1 0 2 DEAD 15BG9L6359F5CH23E34DDUA6N1RIHL9I\
    \ NS SOA RRSIG\n           DNSKEY NSEC3PARAM )\n   # Covering `*.example.org`:\
    \ `22670trplhsr72pqqmedltg1kdqeolb7`\n   22670trplhsr72pqqmedltg1kdqeolb6.example.org.(\n\
    \      NSEC3 1 0 2 DEAD 22670TRPLHSR72PQQMEDLTG1KDQEOLB8 )\n"
- title: Appendix C.  List of Hashed Owner Names
  contents:
  - "Appendix C.  List of Hashed Owner Names\n   The following owner names are used\
    \ in this document.  The origin for\n   these names is \"example.org\".\n    \
    \     +----------------+-------------------------------------+\n         | Original\
    \ Name  | Hashed Name                         |\n         +----------------+-------------------------------------+\n\
    \         | \"a\"            | \"04sknapca5al7qos3km2l9tl3p5okq4c\"  |\n     \
    \    | \"1.h\"          | \"117gercprcjgg8j04ev1ndrk8d1jt14k\"  |\n         |\
    \ \"@\"            | \"15bg9l6359f5ch23e34ddua6n1rihl9h\"  |\n         | \"h\"\
    \            | \"1avvqn74sg75ukfvf25dgcethgq638ek\"  |\n         | \"*\"     \
    \       | \"22670trplhsr72pqqmedltg1kdqeolb7\"  |\n         | \"3\"          \
    \  | \"75b9id679qqov6ldfhd8ocshsssb6jvq\"  |\n         | \"2\"            | \"\
    7t70drg4ekc28v93q7gnbleopa7vlp6q\"  |\n         | \"3.3\"          | \"8555t7qegau7pjtksnbchg4td2m0jnpj\"\
    \  |\n         | \"d\"            | \"a6edkb6v8vl5ol8jnqqlt74qmj7heb84\"  |\n\
    \         | \"*.2\"          | \"fbq73bfkjlrkdoqs27k5qf81aqqd7hho\"  |\n     \
    \    | \"b\"            | \"iuu8l5lmt76jeltp0bir3tmg4u3uu8e7\"  |\n         |\
    \ \"x.2\"          | \"ndtu6dste50pr4a1f2qvr1v31g00i2i1\"  |\n         +----------------+-------------------------------------+\n\
    \        Table 1: Hashed Owner Names for \"example.org\" in Hash Order\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   R. (Miek) Gieben\n   Google\n   EMail: miek@google.com\n\
    \   W. (Matthijs) Mekking\n   NLnet Labs\n   Science Park 400\n   Amsterdam  1098\
    \ XH\n   NL\n   EMail: matthijs@nlnetlabs.nl\n   URI:   http://www.nlnetlabs.nl/\n"
