- title: __initial_text__
  contents:
  - '                Classical versus Transparent IP Proxies

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   Many modern IP security systems (also called \"firewalls\" in the\n\
    \   trade) make use of proxy technology to achieve access control.  This\n   document\
    \ explains \"classical\" and \"transparent\" proxy techniques and\n   attempts\
    \ to provide rules to help determine when each proxy system\n   may be used without\
    \ causing problems.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Background . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . 2\n   2.  Direct communication (without a proxy) . . . . . . . . .\
    \ . . 3\n   2.1.  Direct connection example  . . . . . . . . . . . . . . . . 3\n\
    \   2.2.  Requirements of direct communication . . . . . . . . . . . 5\n   3.\
    \    Classical application proxies  . . . . . . . . . . . . . . 5\n   3.1.  Classical\
    \ proxy session example  . . . . . . . . . . . . . 6\n   3.2.  Characteristics\
    \ of classical proxy configurations  . . .  12\n   3.2.1.  IP addressing and routing\
    \ requirements . . . . . . . .  12\n   3.2.2.  IP address hiding  . . . . . .\
    \ . . . . . . . . . . . .  14\n   3.2.3.  DNS requirements . . . . . . . . . .\
    \ . . . . . . . . .  14\n   3.2.4.  Software requirements  . . . . . . . . . .\
    \ . . . . . .  15\n   3.2.5.  Impact of a classical proxy on packet filtering\
    \  . . .  15\n   3.2.6.  Interconnection of conflicting IP networks . . . . .\
    \ .  16\n   4.  Transparent application proxies  . . . . . . . . . . . . .  19\n\
    \   4.1.  Transparent proxy connection example . . . . . . . . . .  20\n   4.2.\
    \  Characteristics of transparent proxy configurations  . .  26\n   4.2.1.  IP\
    \ addressing and routing requirements . . . . . . . .  26\n   4.2.2.  IP address\
    \ hiding  . . . . . . . . . . . . . . . . . .  28\n   4.2.3.  DNS requirements\
    \ . . . . . . . . . . . . . . . . . . .  28\n   4.2.4.  Software requirements\
    \  . . . . . . . . . . . . . . . .  29\n   4.2.5.  Impact of a transparent proxy\
    \ on packet filtering  . .  30\n   4.2.6.  Interconnection of conflicting IP networks\
    \ . . . . . .  31\n   5.  Comparison chart of classical and transparent proxies\
    \  . .  31\n   6.  Improving transparent proxies  . . . . . . . . . . . . . .\
    \  32\n   7.  Security Considerations  . . . . . . . . . . . . . . . . .  34\n\
    \   8.  Acknowledgements . . . . . . . . . . . . . . . . . . . . .  34\n   9.\
    \  References . . . . . . . . . . . . . . . . . . . . . . . .  35\n"
- title: 1. Background
  contents:
  - "1. Background\n   An increasing number of organizations use IP security systems\
    \ to\n   provide specific access control when crossing network security\n   perimeters.\
    \ These systems are often deployed at the network boundary\n   between two organizations\
    \ (which may be part of the same \"official\"\n   entity), or between an organization's\
    \ network and a large public\n   internetwork such as the Internet.\n   Some people\
    \ believe that IP firewalls will become commodity products.\n   Others believe\
    \ that the introduction of IPv6 and of its improved\n   security capabilities\
    \ will gradually make firewalls look like stopgap\n   solutions, and therefore\
    \ irrelevant to the computer networking scene.\n   In any case, it is currently\
    \ important to examine the impact of\n   inserting (and removing) a firewall at\
    \ a network boundary, and to\n   verify whether specific types of firewall technologies\
    \ may have\n   different effects on typical small and large IP networks.\n   Current\
    \ firewall designs usually rely on packet filtering, proxy\n   technology, or\
    \ a combination of both. Packet filtering (although hard\n   to configure correctly\
    \ in a security sense) is now a well documented\n   technology whose strengths\
    \ and weaknesses are reasonably understood.\n   Proxy technology, on the other\
    \ hand, has been deployed a lot but\n   studied little. Furthermore, many recent\
    \ firewall products support a\n   capability called \"transparent proxying\".\
    \ This type of feature has\n   been subject to much more marketing attention than\
    \ actual technical\n   analysis by the networking community.\n   It must be remembered\
    \ that the Internet's growth and success is\n   strongly related to its \"open\"\
    \ nature. An Internet which would have\n   been segmented from the start with\
    \ firewalls, packet filters, and\n   proxies may not have become what it is today.\
    \ This type of discussion\n   is, however, outside the scope of this document,\
    \ which just attempts\n   to provide an understandable description of what are\
    \ network proxies,\n   and of what are the differences, strengths, and weaknesses\
    \ of\n   \"classical\" and \"transparent\" network proxies.  Within the context\
    \ of\n   this document, a \"classical\" proxy is the older (some would say old-\n\
    \   fashioned) type of proxy of the two.\n   Also note that in this document,\
    \ the word \"connection\" is used for an\n   application session that uses TCP,\
    \ while the word \"session\" refers to\n   an application dialog that may use\
    \ UDP or TCP.\n"
- title: 2. Direct communication (without a proxy)
  contents:
  - "2. Direct communication (without a proxy)\n   In the \"normal\" Internet world,\
    \ systems do not use proxies and simply\n   use normal TCP/IP to communicate with\
    \ each other. It is important\n   (for readers who may not be familiar with this)\
    \ to take a quick look\n   at the operations involved, in order to better understand\
    \ what is the\n   exact use of a proxy.\n   2.1 Direct connection example\n  \
    \    Let's take a familiar network session and describe some details of\n    \
    \  its operation. We will look at what happens when a user on a\n      client\
    \ system \"c.dmn1.com\" sets up an FTP connection to the server\n      system\
    \ \"s.dmn2.com\". The client system's IP address is\n      c1.c2.c3.c4, the server's\
    \ IP address is s1.s2.s3.s4.\n       +---------------+      +----------+     \
    \ +---------------+\n       |               |     /    IP      \\     |      \
    \         |\n       |  c.dmn1.com   |----+  network(s)  +----|  s.dmn2.com   |\n\
    \       | (c1.c2.c3.c4) |     \\            /     | (s1.s2.s3.s4) |\n       +---------------+\
    \      +----------+      +---------------+\n      The user starts an instance\
    \ of an FTP client program on the client\n      system \"c.dmn1.com\", and specifies\
    \ that the target system is\n      \"s.dmn2.com\". On command-line systems, the\
    \ user typically types:\n          ftp s.dmn2.com\n      The client system needs\
    \ to convert the server's name to an IP\n      address (if the user directly specified\
    \ the server by address,\n      this step is not needed).\n      Converting the\
    \ server name to an IP address requires work to be\n      performed which ranges\
    \ between two extremes:\n       a) the client system has this name in its hosts\
    \ file, or has\n          local DNS caching capability and successfully retrieves\
    \ the\n          name of the server system in its cache. No network activity\n\
    \          is performed to convert the name to an IP address.\n       b) the client\
    \ system, in combination with DNS name servers,\n          generate DNS queries\
    \ that eventually propagate close to the\n          root of the DNS tree and back\
    \ down the server's DNS branch.\n          Eventually, a DNS server which is authoritative\
    \ for the\n          server system's domain is queried and returns the IP\n  \
    \        address associated with \"s.dmn2.com\" (depending on the case,\n    \
    \      it may return this to the client system directly or to an\n          intermediate\
    \ name server). Ultimately, the client system\n          obtains a valid IP address\
    \ for s.dmn2.com. For simplicity,\n          we assume the server has only one\
    \ IP address.\n       +---------------+     +--------+     +---------------+\n\
    \       |               |    /   IP     \\    |               |\n       |  c.dmn1.com\
    \   |---+ network(s) +---|  s.dmn2.com   |\n       | (c1.c2.c3.c4) |    \\   \
    \       /    | (s1.s2.s3.s4) |\n       +---------------+     +--------+     +---------------+\n\
    \          A  |                /          \\\n          |  | address for   / \
    \           \\\n          |  | s.dmn2.com?  /              \\\n          |  |\
    \             /                \\\n          |  |            /               \
    \   \\\n          |  |     +--------+ s.dmn2.com?  +--------+\n          |  +---->|\
    \  DNS   |------------->|  DNS   |\n          |        | server |            \
    \  | server |\n          +--------|   X    |<-------------|   Y    |\n       s1.s2.s3.s4\
    \ +--------+  s1.s2.s3.s4 +--------+\n      Once the client system knows the IP\
    \ address of the server system,\n      it attempts to establish a connection to\
    \ the standard FTP\n      \"control\" TCP port on the server (port 21). For this\
    \ to work, the\n      client system must have a valid route to the server's IP\
    \ address,\n      and the server system must have a valid route to the client's\
    \ IP\n      address. All intermediate devices that behave like IP gateways\n \
    \     must have valid routes for both the client and the server. If\n      these\
    \ devices perform packet filtering, they must ALL allow the\n      specific type\
    \ of traffic required between C and S for this\n      specific application.\n\
    \       +---------------+                    +---------------+\n       |  c.dmn1.com\
    \   |                    |  s.dmn2.com   |\n       | (c1.c2.c3.c4) |         \
    \           | (s1.s2.s3.s4) |\n       +---------------+                    +---------------+\n\
    \         | |                                    |   |\n         | | route to\
    \ S              route to C |   |\n         | V                              \
    \      V   |\n         |                                          |\n        \
    \ | A                                        | A\n         | | route to C    \
    \                         | | route to S\n         | |                       \
    \                 | |\n         | |      C          S                 C    | |\n\
    \       +----+    <-- +----+ -->    +----+     <-- +----+\n       | G1 |--------|\
    \ Gx |--------| Gy |---------| Gn |\n       +----+ -->    +----+    <-- +----+\
    \ -->     +----+\n               S                C          S\n      The actual\
    \ application work for the FTP session between the client\n      and server is\
    \ done with a bidirectional flow of TCP packets\n      between the client's and\
    \ server's IP addresses.\n      The FTP protocol uses a slightly complex protocol\
    \ and TCP\n      connection model which is, luckily, not important to the present\n\
    \      discussion. This allows slightly shortening this document...\n   2.2 Requirements\
    \ of direct communication\n      Based on the preceding discussion, it is possible\
    \ to say that the\n      following is required for a direct session between a\
    \ client and\n      server to be successful:\n       a) If the client uses the\
    \ NAME of the server to reference it,\n          the client must either have a\
    \ hardcoded name-to-address\n          binding for the server, or it must be able\
    \ to resolve the\n          server name (typically using DNS). In the case of\
    \ DNS, this\n          implies that the client and server must be part of the\
    \ same\n          DNS architecture or tree.\n       b) The client and server must\
    \ be part of the same internetwork:\n          the client must have a valid IP\
    \ route towards the server,\n          the server must have a valid IP route towards\
    \ the client,\n          and all intermediate IP gateways must have valid routes\n\
    \          towards the client and server (\"IP gateway\" is the RFC\n        \
    \  standard terminology; people often use the term \"IP router\"\n          in\
    \ computer rooms).\n       c) If there are devices on the path between the client\
    \ and\n          server that perform packet filtering, all these devices must\n\
    \          permit the forwarding of packets between the IP address of\n      \
    \    the client and the IP address of the server, at least for\n          packets\
    \ that fit the protocol model of the FTP application\n          (TCP ports used,\
    \ etc.).\n"
- title: 3. Classical application proxies
  contents:
  - "3. Classical application proxies\n   A classical application proxy is a special\
    \ program that knows one (or\n   more) specific application protocols. Most application\
    \ protocols are\n   not symetric; one end is considered to be a \"client\", one\
    \ end is a\n   \"server\".\n   A classical application proxy implements both the\
    \ \"client\" and\n   \"server\" parts of an application protocol. In practice,\
    \ it only needs\n   to implement enough of the client and server protocols to\
    \ accomplish\n   the following:\n   a) accept client sessions and appear to them\
    \ as a server;\n   b) receive from a client the name or address of the final target\n\
    \      server (this needs to be passed over the \"client-proxy\" session\n   \
    \   in a way that is application-specific);\n   c) setup a session to the final\
    \ server and appear to be a client\n      from the server's point of view;\n \
    \  d) relay requests, responses, and data between the client and\n      server;\n\
    \   e) perform access controls according to the proxy's design\n      criteria\
    \ (the main goal of the proxy, after all).\n   The functional goal of the proxy\
    \ is to relay application data between\n   clients and servers that may not have\
    \ direct IP connectivity. The\n   security goal of the proxy is to do checks and\
    \ types of access\n   controls that typical client and server software do not\
    \ support or\n   implement.\n   The following information will make it clear that\
    \ classical proxies\n   can offer many hidden benefits to the security-conscious\
    \ network\n   designer, at the cost of deploying client software with proxy\n\
    \   capabilities or of educating the users on proxy use.\n   Client software issues\
    \ are now easier to handle, given the increasing\n   number of popular client\
    \ applications (for Web, FTP, etc.) that offer\n   proxy support. Designers developing\
    \ new protocols are also more\n   likely to plan proxy capability from the outset,\
    \ to ensure their\n   protocols can cross the many existing large corporate firewalls\
    \ that\n   are based at least in part on classical proxy technology.\n   3.1 Classical\
    \ proxy session example\n      We will repeat our little analysis of an FTP session.\
    \ This time,\n      the FTP session is passing through a \"classical\" application\
    \ proxy\n      system. As is often the case (although not required), we will\n\
    \      assume that the proxy system has two IP addresses, two network\n      interfaces,\
    \ and two DNS names.\n      The proxy system is running a special program which\
    \ knows how to\n      behave like an FTP client on one side, and like an FTP server\
    \ on\n      the other side. This program is what people call the \"proxy\". We\n\
    \      will assume that the proxy program is listening to incoming\n      requests\
    \ on the standard FTP control port (21/tcp), although this\n      is not always\
    \ the case in practice.\n       +---------------+      +----------+\n       |\
    \               |     /    IP      \\\n       |  c.dmn1.com   |----+  network(s)\
    \  +----------+\n       | (c1.c2.c3.c4) |     \\            /           |\n  \
    \     +---------------+      +----------+    +-----------------+\n           \
    \                                   | (p1.p2.p3.p4)   |\n                    \
    \                          | proxy1.dmn3.com |\n                             \
    \                 |                 |\n                                      \
    \        | proxy2.dmn4.com |\n                                              |\
    \ (p5.p6.p7.p8)   |\n       +---------------+      +----------+    +-----------------+\n\
    \       |               |     /    IP      \\           |\n       |  s.dmn2.com\
    \   |----+  network(s)  +----------+\n       | (s1.s2.s3.s4) |     \\        \
    \    /\n       +---------------+      +----------+\n      The user starts an instance\
    \ of an FTP client program on the client\n      system \"c.dmn1.com\", and MUST\
    \ specify that the target system is\n      \"proxy1.dmn3.com\". On command-line\
    \ systems, the user typically\n      types:\n          ftp proxy1.dmn3.com\n \
    \     The client system needs to convert the proxy's name to an IP\n      address\
    \ (if the user directly specified the proxy by address, this\n      step is not\
    \ needed).\n      Converting the proxy name to an IP address requires work to\
    \ be\n      performed which ranges between two extremes:\n       a) the client\
    \ system has this name in its hosts file, or has\n          local DNS caching\
    \ capability and successfully retrieves the\n          name of the proxy system\
    \ in its cache. No network activity\n          is performed to convert the name\
    \ to an IP address.\n       b) the client system, in combination with DNS name\
    \ servers,\n          generate DNS queries that eventually propagate close to\
    \ the\n          root of the DNS tree and back down the proxy's DNS branch.\n\
    \          Eventually, a DNS server which is authoritative for the\n         \
    \ proxy system's domain is queried and returns the IP\n          address associated\
    \ with \"proxy1.dmn3.com\" (depending on the\n          case, it may return this\
    \ to the client system directly or\n          to an intermediate name server).\
    \ Ultimately, the client\n          system obtains a valid IP address for proxy1.dmn3.com.\n\
    \       +---------------+          +--------+\n       |               |      \
    \   /   IP     \\\n       |  c.dmn1.com   |--------+ network(s) +------------+\n\
    \       | (c1.c2.c3.c4) |         \\          /             |\n       +---------------+\
    \          +--------+      +-----------------+\n        A  |                 \
    \    /          \\     | (p1.p2.p3.p4)   |\n        |  | address for        /\
    \            \\    | proxy1.dmn3.com |\n        |  | proxy1.dmn3.com?  /     \
    \         \\   |    ...          |\n        |  |                  /          \
    \      \\  +-----------------+\n        |  |                 /               \
    \   \\\n        |  |                /                    \\\n        |  |    \
    \     +--------+ proxy1.dmn3.com?  +--------+\n        |  +-------->|  DNS   |------------------>|\
    \  DNS   |\n        |            | server |                   | server |\n   \
    \     +------------|   X    |<------------------|   Y    |\n         p1.p2.p3.p4\
    \ +--------+    p1.p2.p3.p4    +--------+\n      Once the client system knows\
    \ the IP address of the proxy system,\n      it attempts to establish a connection\
    \ to the standard FTP\n      \"control\" TCP port on the proxy (port 21). For\
    \ this to work, the\n      client system must have a valid route to the proxy's\
    \ IP address,\n      and the proxy system must have a valid route to the client's\
    \ IP\n      address. All intermediate devices that behave like IP gateways\n \
    \     must have valid routes to both the client and the proxy. If these\n    \
    \  devices perform packet filtering, they must ALL allow the specific\n      type\
    \ of traffic required between C and P1 for this specific\n      application (FTP).\n\
    \      Finally, the proxy system must accept this incoming connection,\n     \
    \ based on the client's IP address (the purpose of the proxy is\n      generally\
    \ to do access control, after all).\n       +---------------+                \
    \   |      ...        |\n       |  c.dmn1.com   |                   | proxy1.dmn3.com\
    \ |\n       | (c1.c2.c3.c4) |                   |  (p1.p2.p3.p4)  |\n       +---------------+\
    \                   +-----------------+\n         | |                        \
    \            |   |\n         | | route to P1             route to C |   |\n  \
    \       | V                                    V   |\n         |             \
    \                             |\n         | A                                \
    \        | A\n         | | route to C                             | | route to\
    \ P1\n         | |                                        | |\n         | |  \
    \    C          P1                C    | |\n       +----+    <-- +----+ -->  \
    \  +----+     <-- +----+\n       | G1 |--------| Gx |--------| Gy |---------|\
    \ Gn |\n       +----+ -->    +----+    <-- +----+ -->     +----+\n           \
    \    P1               C          P1\n      The actual application work for the\
    \ FTP session between the client\n      and proxy is done with a bidirectional\
    \ flow of TCP packets between\n      the client's and proxy's IP addresses.\n\
    \      For this to work, the proxy FTP application MUST fully support the\n  \
    \    FTP protocol and look identical to an FTP server from the client's\n    \
    \  point of view.\n      Once the client<->proxy session is established, the final\
    \ target\n      server name must be passed to the proxy, since, when using a\n\
    \      \"classical\" application proxy, a way MUST be defined for the proxy\n\
    \      to determine the final target system. This can be achieved in\n      three\
    \ ways:\n       a) The client system supplies the name or address of the final\n\
    \          target system to the proxy in a method that is compatible\n       \
    \   with the specific application protocol being used (in our\n          example,\
    \ FTP). This is generally considered to be the main\n          problem with classical\
    \ proxies, since for each application\n          being proxied, a method must\
    \ be defined for passing the\n          name or address of the final target system.\
    \ This method\n          must be compatible with every variant of client application\n\
    \          that implements the protocol (i.e. the target-passing\n          method\
    \ must fit within the MINIMUM functionalities required\n          by the specific\
    \ application protocol).\n          For the FTP protocol, the generally popular\
    \ method for\n          passing the final server name to the proxy is as follows:\n\
    \          When the proxy prompts the FTP client for a username, the\n       \
    \   client specifies a string of the form:\n                target_username@target_system_name\n\
    \                or\n                target_username@target_ip_address\n     \
    \     The proxy will then know what is the final target system.\n          The\
    \ target_username (and the password supplied by the\n          client) will be\
    \ forwarded \"as is\" by the proxy to the final\n          target system.\n  \
    \        A well-known example of an FTP proxy that behaves in this way\n     \
    \     is the \"ftp-gw\" program which is part of the Trusted\n          Information\
    \ System's firewall toolkit, available by anonymous\n          FTP at ftp.tis.com.\
    \ Several commercial firewalls also support\n          this de-facto standard.\n\
    \       b) If there is only one possible final destination, the proxy\n      \
    \    may be configured to know this destination in advance.\n          Since the\
    \ IP address of the client system is known when the\n          proxy must make\
    \ this decision, the proxy can (if required)\n          select a different destination\
    \ based on the IP address of\n          the client.\n       c) The client software\
    \ may also support capabilities that allow\n          it to present to the user\
    \ the illusion of a direct session\n          (the user just specifies the final\
    \ target system, and the\n          client software automatically handles the\
    \ problem of\n          reaching to the proxy system and passing the name or address\n\
    \          of the final target system in whatever mutually-acceptable\n      \
    \    form).\n          A well-known example of a system that provides modified\n\
    \          client software, proxy software, and that provides the\n          illusion\
    \ of transparency is NEC's SOCKS system, available by\n          anonymous FTP\
    \ at ftp.nec.com.\n          Alternatively, several FTP client applications support\
    \ the\n          \"username@destination_host\" de-facto standard implemented\n\
    \          (for example) by the \"ftp-gw\" proxy application.\n      Once the\
    \ FTP proxy application knows the name or IP address of the\n      target system,\
    \ it can choose to do two things:\n       a) Setup a session to the final target\
    \ system, the more\n          frequent case.\n       b) Decide (based on some\
    \ internal configuration data) that it\n          cannot reach the final target\
    \ system directly, but must go\n          through another proxy. This is rare\
    \ today, but may become\n          temporarily common due to the current shortage\
    \ of IP\n          network numbers which encourages organizations to deploy\n\
    \          \"hidden\" network numbers which are already assigned\n          elsewhere.\
    \ Sessions between systems which have the same\n          IP network number but\
    \ which belong to different actual\n          networks may require going through\
    \ two proxy systems.\n          This is discussed in more detail in section 3.2.6,\n\
    \          \"Interconnection of conflicting IP networks\".\n      If the FTP proxy\
    \ decides to connect directly to the target system,\n      and what it has is\
    \ the target system name, it will need to convert\n      the target system name\
    \ into an IP address. If this process\n      involves DNS resolution, something\
    \ like the following will happen:\n       +-----------------+\n       | proxy1.dmn3.com\
    \ |\n       |  (p1.p2.p3.p4)  |          +--------+\n       |                \
    \ |         /   IP     \\\n       | proxy2.dmn4.com |--------+ network(s) +------------+\n\
    \       |  (p5.p6.p7.p8)  |         \\          /             |\n       +-----------------+\
    \          +--------+      +---------------+\n        A  |                   \
    \  /          \\       | (s1.s2.s3.s4) |\n        |  | address for        /  \
    \          \\      | s.dmn2.com    |\n        |  | s.dmn2.com?       /       \
    \       \\     |               |\n        |  |                  /            \
    \    \\    +---------------+\n        |  |                 /                 \
    \ \\\n        |  |                /                    \\\n        |  |      \
    \   +--------+   s.dmn2.com?     +--------+\n        |  +-------->|  DNS   |------------------>|\
    \  DNS   |\n        |            | server |                   | server |\n   \
    \     +------------|   X    |<------------------|   Y    |\n         s1.s2.s3.s4\
    \ +--------+    s1.s2.s3.s4    +--------+\n      Once the proxy system knows the\
    \ IP address of the server system,\n      it attempts to establish a connection\
    \ to the standard FTP\n      \"control\" TCP port on the server (port 21). For\
    \ this to work, the\n      proxy system must have a valid route to the server's\
    \ IP address,\n      and the server system must have a valid route to at least\
    \ one of\n      the proxy's IP address. All intermediate devices that behave like\n\
    \      IP gateways must have valid routes to both the proxy and the\n      server.\
    \ If these devices perform packet filtering, they must ALL\n      allow the specific\
    \ type of traffic required between the proxy and\n      S for this specific application.\n\
    \       +-----------------+\n       | proxy1.dmn3.com |\n       |  (p1.p2.p3.p4)\
    \  |\n       |                 |                 +----------------+\n       |\
    \ proxy2.dmn4.com |                 |  s.dmn2.com    |\n       |  (p5.p6.p7.p8)\
    \  |                 | (s1.s2.s3.s4)  |\n       +-----------------+          \
    \       +----------------+\n         | |                                    |\
    \   |\n         | | route to S             route to P2 |   |\n         | V   \
    \                                 V   |\n         |                          \
    \                |\n         | A                                        | A\n\
    \         | | route to P2                            | | route to S\n        \
    \ | |                                        | |\n         | |      P2       \
    \  S                 P2   | |\n       +----+    <-- +----+ -->    +----+     <--\
    \ +----+\n       | G1 |--------| Gx |--------| Gy |---------| Gn |\n       +----+\
    \ -->    +----+    <-- +----+ -->     +----+\n               S               \
    \ P2         S\n      The actual FTP application work between the proxy and server\
    \ is\n      done with a bidirectional flow of TCP packets between the proxy's\n\
    \      and server's IP addresses.\n      What actually happens BETWEEN THE CLIENT\
    \ AND SERVER?  They both\n      send replies and responses to the proxy, which\
    \ forwards data to\n      the \"other\" end. When one party opens a data connection\
    \ and sends\n      a PORT command to the proxy, the proxy allocates its own data\n\
    \      connection and sends its PORT command to the \"other\" end. The\n     \
    \ proxy also copies data across the connections created in this way.\n   3.2 Characteristics\
    \ of classical proxy configurations\n      Several IP internetworks may be linked\
    \ using only classical proxy\n      technology. It is currently popular to link\
    \ two specific IP\n      internetworks in this way: the Internet and some organization's\n\
    \      \"private\" IP network. Such a proxy-based link is often the key\n    \
    \  component of a firewall.\n      When this is done, several benefits and problems\
    \ are introduced\n      for network administrators and users.\n      3.2.1 IP\
    \ addressing and routing requirements.\n         The proxy system must be able\
    \ to address all client and server\n         systems to which it may provide service.\
    \ It must also know\n         valid IP routes to all these client and server systems.\n\
    \         Client and server systems must be able to address the proxy\n      \
    \   system, and must know a valid IP route to the proxy system. If\n         the\
    \ proxy system has several IP addresses (and often, several\n         physical\
    \ network interfaces), the client and server systems\n         need only to be\
    \ able to access ONE of the proxy system's IP\n         addresses.\n         Note\
    \ that client and server systems that use the proxy for\n         communication\
    \ DO NOT NEED valid IP addressing or routing\n         information for systems\
    \ that they reach through the proxy.\n         In this sense, it can be said that\
    \ systems separated by a\n         classical proxy are isolated from each other\
    \ in an IP\n         addressing sense and in an IP routing sense.\n         On\
    \ the other hand, the classical proxy system (if running a\n         standard\
    \ TCP/IP software stack) needs to have a single coherent\n         view of IP\
    \ addressing and routing. If such a proxy system\n         interconnects two IP\
    \ networks and two systems use the same IP\n         network/subnetwork number\
    \ (one system on each network), the\n         proxy will only be able to address\
    \ one of the systems.\n         This restriction can be removed by chaining classical\
    \ proxies\n         (this is described later in section 3.2.6, \"Interconnection\
    \ of\n         conflicting IP networks\").\n         Using a classical proxy for\
    \ interconnection of IP\n         internetworks, it is also possible, with care,\
    \ to achieve a\n         desirable \"fail-safe\" feature: no valid routing entries\
    \ need to\n         exist for an internetwork which should be reached only through\n\
    \         the proxy (routing updates that could add such entries shout be\n  \
    \       BLOCKED). If the proxy suddenly starts to behave like an IP\n        \
    \ router, only one-way attacks become possible.\n         In other words, assume\
    \ an attacker has control of the remote\n         internetwork and has found a\
    \ way to cause the proxy to route IP\n         packets, or has found a way to\
    \ physically bypass the proxy.\n         The attacker may inject packets, but\
    \ the attacked internal\n         systems will be unable to reply to those packets.\
    \ This\n         certainly does not make attacks infeasible (as exemplified by\n\
    \         certain holiday-period events in recent years), but it still\n     \
    \    makes attacks more difficult.\n      3.2.2 IP address hiding\n         Application\
    \ \"sessions\" that go through a classical proxy are\n         actually made of\
    \ two complete sessions:\n             a) a session between the client and the\
    \ proxy\n             b) a session between the proxy and the server\n        \
    \ A device on the path sees only the client<->proxy traffic or\n         the proxy<->server\
    \ traffic, depending where it is located. If\n         the two sessions actually\
    \ pass through the same physical\n         network, a device on that network may\
    \ see both traffics, but\n         may have difficulty establishing the relationship\
    \ between the\n         two sessions (depending on the specific application and\n\
    \         activity level of the network).\n         A by-product of a classical\
    \ proxy's behavior is commonly known\n         as \"address hiding\". Equipments\
    \ on some side of a classical\n         proxy cannot easily determine what are\
    \ the IP addresses used on\n         another side of the proxy.\n         Address\
    \ hiding is generally viewed as a Good Thing, since one\n         of the purposes\
    \ of deploying proxies is to disclose as little\n         information about an\
    \ internetwork as possible.\n         People who are in charge of gathering network\
    \ statistics, and\n         who do not have access to the proxy system's reports\
    \ (if any)\n         may consider address hiding to be a Bad Thing, since the\
    \ proxy\n         obscures the actual client/server relationships where the proxy\n\
    \         was inserted.  All IP activity originates and terminates on the\n  \
    \       proxy itself (or appears to do so).\n         In the same way, server\
    \ software that accepts connections that\n         have gone through a classical\
    \ proxy do not see the IP address\n         of the incoming client, unless this\
    \ information is included in\n         the application protocol (and even if it\
    \ is, in many cases, the\n         proxy will replace this information with its\
    \ own address for\n         the protocol to be consistent). This makes server\
    \ access\n         control unusable if it is based on client IP address checks.\n\
    \      3.2.3 DNS requirements\n         In most classical-proxy configurations,\
    \ client systems pass the\n         desired server name (or address) to the proxy\
    \ system WITHOUT\n         INTERPRETING IT. Because of this, the client system\
    \ DOES NOT\n         REQUIRE to be able to resolve the name of the server system\
    \ in\n         order to access it through a classical proxy. It only needs to\n\
    \         be able to resolve the name of the proxy (if referencing the\n     \
    \    proxy system by name).\n         Because of this, it can be said that a classical\
    \ proxy system\n         can offer DNS isolation. If two IP internetworks use\
    \ completely\n         separate DNS trees (each with their own DNS root servers),\n\
    \         client software in one IP internetwork may still reference a\n     \
    \    server name in the other IP internetwork by passing its name to\n       \
    \  the classical proxy.\n         The classical proxy itself will not be able\
    \ alone to resolve\n         DNS names in both environments (if running standard\
    \ DNS\n         resolution software), since it will need to point to one or the\n\
    \         other of the two DNS \"universes\".\n         A well-known technique\
    \ called \"split-brain DNS\" can be used to\n         relax this restriction somewhat,\
    \ but such a technique\n         ultimately involves prioritizing one DNS environment\
    \ over\n         another. If a DNS query can return a valid answer in both\n \
    \        environments, only one of the answers will be found by the\n        \
    \ proxy.\n      3.2.4 Software requirements\n         A classical proxy application\
    \ is a fairly simple piece of\n         software, often simpler than either a\
    \ real client\n         implementation or a real server implementation.  Such\
    \ a program\n         may run on any system that supports normal TCP/IP connections,\n\
    \         and often does not require \"system\" or \"superuser\" privilege.\n\
    \         Classical proxy connections have no impact on normal server\n      \
    \   software; the proxy looks like a normal client in most respects\n        \
    \ except for its IP address and its \"group\" nature. All\n         connections\
    \ from the network on the other side of the proxy\n         appear to come from\
    \ the proxy, which poses problems if access\n         control by client system\
    \ is desired.\n         Normal client software may access a classical proxy if\
    \ the user\n         is willing or able to go through the extra steps necessary\
    \ to\n         indicate the final server to the proxy (whatever they are).\n \
    \        Alternatively, modified (or newer) client software may be used\n    \
    \     that knows how to negotiate transparently with the proxy.\n      3.2.5 Impact\
    \ of a classical proxy on packet filtering\n         If packet filtering is needed\
    \ around a classical proxy, the\n         packet filtering rules tend to be simplified,\
    \ since the only\n         traffic needed and allowed will originate from or terminate\
    \ on\n         the proxy (in an IP sense).\n         If the proxy starts behaving\
    \ like an IP router, or if it is\n         physically bypassed, such filtering\
    \ rules, if deployed\n         generally within an IP internetwork, will tend\
    \ to prevent any\n         direct traffic flow between the \"internal\" internetwork\
    \ and\n         \"external\" internetworks that are supposed to be only reachable\n\
    \         through the application proxy.\n      3.2.6 Interconnection of conflicting\
    \ IP networks\n         By chaining classical proxies, it is possible to achieve\
    \ some\n         interconnection of IP networks that have a high level of\n  \
    \       conflict. In practice, this type of setup resolves IP\n         addressing\
    \ conflicts much better than DNS conflicts. But DNS\n         conflicts are currently\
    \ less of a problem because the DNS\n         \"address space\" is almost infinitely\
    \ large (has anybody\n         calculated the possible DNS address space based\
    \ on the RFC-\n         standard maximum host name length?).\n         Even though\
    \ RFC 1597 was never more than an informational RFC,\n         many organizations\
    \ have been quietly following its suggestions,\n         for lack of an easier\
    \ solution. Now assume two organizations\n         each use class A network number\
    \ 10 on their network. Suddenly,\n         they need to interconnect.  What can\
    \ they do?\n         First possibility: one side changes network number (not as\
    \ hard\n         as people think if properly planned, but this still represents\n\
    \         some work)\n         Second possibility: they merge the two numbers\
    \ by renumbering\n         partially on each side to remove conflicts (actually\
    \ harder to\n         do, but has the political advantage that both sides have\
    \ to do\n         some work)\n         Third possibility: they communicate through\
    \ chained classical\n         proxies:\n            +--------+     +--------+\
    \   +--------+     +--------+\n           /  Org. 1  \\    | Proxy  |   | Proxy\
    \  |    /  Org. 2  \\\n          +  dmn1.com  +---+ system +---+ system +---+\
    \  dmn2.com  +\n           \\  net 10  /    |    1   |   |   2    |    \\  net\
    \ 10  /\n            +--------+     +--------+   +--------+     +--------+\n \
    \        Both proxy 1 and 2 are standard systems running normal TCP/IP\n     \
    \    software stacks. Their configuration is not typical, however:\n         \
    \    a) The link between proxy 1 and proxy 2 may use any IP\n                network\
    \ number that is not used (or not needed) on\n                either side. Nothing\
    \ on Org.1 and Org.2's networks\n                need to have an IP route to this\
    \ network.\n             b) Proxy 1 has an IP route for network 10 that points\
    \ to\n                Organization 1's network, and does DNS resolution\n    \
    \            (if required) using dmn1.com's name servers.\n             c) Proxy\
    \ 2 has an IP route for network 10 that points to\n                Organization\
    \ 2's network, and does DNS resolution\n                (if required) using dmn2.com's\
    \ name servers.\n             d) Proxy 1 and proxy 2 only require a host IP route\
    \ to\n                each other for communication.\n             e) For this\
    \ to be convenient, the classical proxy\n                applications must support\
    \ the automatic selection of\n                a destination based on the client\
    \ IP address.\n             f) On proxy system 1, the proxy software treats incoming\n\
    \                sessions from proxy system 2 in the normal way: the\n       \
    \         \"client\" (proxy system 2) will be prompted in an\n               \
    \ application-specific way for the final destination.\n                However,\
    \ incoming sessions from Org.1 addresses are\n                immediately and\
    \ automatically forwarded to proxy\n                system 2.\n              \
    \  Proxy system 2 is configured similarly (that is,\n                connections\
    \ coming from proxy 1 are prompted for a\n                target server name,\
    \ connections from Org.2 addresses\n                are immediately and automatically\
    \ forwarded to\n                proxy 1.\n         From a user's point of view,\
    \ the behavior of such a chained\n         proxy system is not very different\
    \ from a single classical\n         application proxy:\n             a) A user\
    \ on a client system with address 10.1.2.3\n                on Org.1's network\
    \ wishes to do an anonymous FTP to\n                \"server.dmn2.com\".\n   \
    \          b) The user starts an FTP towards proxy 1. Proxy 1 sees\n         \
    \       an incoming connection from an address in network 10,\n              \
    \  so it immediately relays the connection to proxy 2.\n             c) Proxy\
    \ 2 sees a connection coming from proxy 1, so it\n                prompts the\
    \ client. The user sees the username prompt\n                and types (assuming\
    \ FTP proxies that behave like TIS's\n                ftp-gw):\n             \
    \        anonymous@server.dmn2.com\n                This will be resolved IN THE\
    \ CONTEXT OF Org. 2'S\n                NETWORK. The user can then complete the\
    \ dialog and\n                use the FTP connection.\n             d) Note that\
    \ this setup will work even if the client and\n                server have the\
    \ EXACT SAME IP ADDRESS (10.1.2.3 in\n                our example).\n        \
    \     If the proxy applications support selecting another\n             proxy\
    \ based on the destination supplied by the client,\n             and if DNS domains\
    \ are unique, more than two conflicting\n             IP networks can be linked\
    \ in this way! Here is an\n             example configuration:\n             a)\
    \ Four IP networks that all use network 10 are linked\n                by four\
    \ proxy systems. The four proxy systems share a\n                common, private\
    \ IP network number and physical link\n                (LAN or WAN).\n       \
    \      b) A user on organization 1's network wishes to access\n              \
    \  a server on network 3. The user connects to its local\n                proxy\
    \ (proxy 1) and supplies that target system name.\n             c) Proxy 1 determines,\
    \ based on a configuration rule,\n                that the target system name\
    \ is reachable by using\n                proxy 3. So it connects to proxy 3 and\
    \ passes the\n                target system name.\n             d) Proxy 3 determines\
    \ that the target system name is\n                local (to itself) and connects\
    \ to it directly.\n             Security Implications of chained proxies\n   \
    \          Obviously, when such \"chained\" configurations are built,\n      \
    \       access control rules and logging based on a\n             final-client/final-server\
    \ combination are difficult to\n             enforce, since the first proxy in\
    \ the chain sees a\n             final-client/proxy relationship and the last\
    \ proxy in\n             the chain sees a proxy/final-server relationship.\n \
    \            Doing better than this requires that the proxies be\n           \
    \  capable of passing the \"original-client\" and\n             \"final-destination\"\
    \ information back and forth in the\n             proxy chain for access control\
    \ and/or logging purposes.\n             This requires the proxies to trust each\
    \ other, and\n             requires the network path to be trusted (forging this\n\
    \             information becomes an excellent attack).\n             Even if\
    \ these problems were to be solved reliably, the\n             original goal of\
    \ the proxy chains was to solve an IP\n             and possibly a DNS conflict.\
    \ The \"original-client\" and\n             \"final-destination\" values may not\
    \ have the same\n             meaning everywhere in the overall setup. Tagging\
    \ the\n             information with a \"universe-name\" may help, assuming\n\
    \             it is possible to define unique universe names in the\n        \
    \     first place. Obviously this topic requires more study.\n"
- title: 4. Transparent application proxies
  contents:
  - "4. Transparent application proxies\n   The most visible problem of classical\
    \ application proxies is the need\n   for proxy-capable client programs and/or\
    \ user education so that users\n   know how to use the proxies.\n   When somebody\
    \ thought of modifying proxies in such a way that normal\n   user procedures and\
    \ normal client applications would still be able to\n   take advantage of the\
    \ proxies, the transparent proxy was born.\n   A transparent application proxy\
    \ is often described as a system that\n   appears like a packet filter to clients,\
    \ and like a classical proxy\n   to servers. Apart from this important concept,\
    \ transparent and\n   classical proxies can do similar access control checks and\
    \ can offer\n   an equivalent level of security/robustness/performance, at least\
    \ as\n   far as the proxy itself is concerned.\n   The following information will\
    \ make it clear that small organizations\n   that wish to use proxy technology\
    \ for protection, that wish to rely\n   entirely on one proxy system for network\
    \ perimeter security, that\n   want a minimal (or zero) impact on user procedures,\
    \ and that do not\n   wish to bother with proxy-capable clients will tend to prefer\n\
    \   transparent proxy technology.\n   Organizations with one or more of the following\
    \ characteristics may\n   prefer deploying classical proxy technology:\n   a)\
    \ own a substantial internal IP router network, and wish to\n      avoid adding\
    \ \"external\" routes on the network\n   b) wish to deploy \"defence in depth\"\
    , such as internal firewalls,\n      packet filtering on the internal network\n\
    \   c) wish to keep their DNS environment fully isolated from the\n      \"other\
    \ side\" of their proxy system, or that fear that their\n      internal DNS servers\
    \ may be vulnerable to data-driven attacks\n   d) use some IP networks that are\
    \ in conflict with the \"other side\"\n      of their proxy system\n   e) wish\
    \ to use proxy applications that are easily portable\n      to different operating\
    \ system types and/or versions\n   f) wish to deploy multiple proxy systems interconnecting\
    \ them\n      to the SAME remote network without introducing dynamic\n      routing\
    \ for external routes on the internal network\n   4.1 Transparent proxy connection\
    \ example\n      Let us go through an FTP sesssion again, through a \"transparent\"\
    \n      proxy this time. We assume that the proxy system has two IP\n      addresses,\
    \ two network interfaces, and two DNS names.\n      The proxy system is running\
    \ a special program which knows how to\n      behave like an FTP client on one\
    \ side, and like an FTP server on\n      the other side. This program is what\
    \ people call the \"proxy\". This\n      program, being a transparent proxy, also\
    \ has a very special\n      relationship with the TCP/IP implementation of the\
    \ proxy system.\n      This relationship may be built in several ways, we will\
    \ describe\n      only one such possible way.\n      We will assume that the proxy\
    \ program is listening to incoming\n      requests on the standard FTP control\
    \ port (21/tcp), although this\n      is not always the case in practice.\n  \
    \     +---------------+      +----------+\n       |               |     /    IP\
    \      \\\n       |  c.dmn1.com   |----+  network(s)  +----------+\n       | (c1.c2.c3.c4)\
    \ |     \\            /           |\n       +---------------+      +----------+\
    \    +-----------------+\n                                              | (p1.p2.p3.p4)\
    \   |\n                                              | proxy1.dmn3.com |\n   \
    \                                           |                 |\n            \
    \                                  | proxy2.dmn4.com |\n                     \
    \                         | (p5.p6.p7.p8)   |\n       +---------------+      +----------+\
    \    +-----------------+\n       |               |     /    IP      \\       \
    \    |\n       |  s.dmn2.com   |----+  network(s)  +----------+\n       | (s1.s2.s3.s4)\
    \ |     \\            /\n       +---------------+      +----------+\n      The\
    \ user starts an instance of an FTP client program on the client\n      system\
    \ \"c.dmn1.com\", and specifies a destination of \"s.dmn2.com\",\n      just like\
    \ if it was reachable directly.  On command-line systems,\n      the user typically\
    \ types:\n          ftp s.dmn2.com\n      The client system needs to convert the\
    \ server's name to an IP\n      address (if the user directly specified the server\
    \ by address,\n      this step is not needed).\n      Converting the server name\
    \ to an IP address requires work to be\n      performed which ranges between two\
    \ extremes:\n       a) the client system has this name in its hosts file, or has\n\
    \          local DNS caching capability and successfully retrieves the\n     \
    \     name of the proxy system in its cache. No network activity\n          is\
    \ performed to convert the name to an IP address.\n       b) the client system,\
    \ in combination with DNS name servers,\n          generate DNS queries that eventually\
    \ propagate close to the\n          root of the DNS tree and back down the server's\
    \ DNS branch.\n          Eventually, a DNS server which is authoritative for the\n\
    \          server system's domain is queried and returns the IP\n          address\
    \ associated with \"s.dmn2.com\" (depending on the\n          case, it may return\
    \ this to the client system directly or\n          to an intermediate name server).\
    \ Ultimately, the client\n          system obtains a valid IP address for s.dmn2.com.\n\
    \       +---------------+          +--------+\n       |               |      \
    \   /   IP     \\\n       |  c.dmn1.com   |--------+ network(s) +------------+\n\
    \       | (c1.c2.c3.c4) |         \\          /             |\n       +---------------+\
    \          +--------+      +-----------------+\n        A  |                 \
    \    /                | (p1.p2.p3.p4)   |\n        |  | address for        / \
    \     +-----+    | proxy system    |\n        |  | s.dmn2.com?       /      /\
    \       \\   | (p5.p6.p7.p8)   |\n        |  |                  /      /     \
    \    \\  +-----------------+\n        |  |                 /      /          \
    \ \\         |\n        |  |                /      / s.dmn2.com? |        |\n\
    \        |  |         +--------+   /              |   +--------+\n        |  +-------->|\
    \  DNS   |--+   +-------+   |  /   IP     \\\n        |            | server |\
    \     /         \\  | + network(s) +\n        +------------|   X    |<---+   \
    \        + |  \\          /\n         s1.s2.s3.s4 +--------+     s1.s2.s3.s4|\
    \ |   +--------+\n                                               | |        |\n\
    \                                               | +        |\n               \
    \                                |  \\   +--------+\n                        \
    \                       +   +->|  DNS   |\n                                  \
    \              \\     | server |\n                                           \
    \      +----|   Y    |\n                                                     \
    \ +--------+\n       NOTE: In practice, DNS servers that are authoritative for\n\
    \             s.dmn2.com are highly likely to be located on the OTHER\n      \
    \       side of the proxy system. This means that DNS queries\n             from\
    \ the inside to the outside MUST be able to cross the\n             proxy system.\
    \ If the proxy system wishes to provide\n             \"address hiding\", it must\
    \ make these DNS queries\n             (originating from the inside) appear to\
    \ come from the\n             proxy itself. This can be achieved by using a BIND-based\n\
    \             DNS server (which has some proxy capabilities) or some\n       \
    \      simpler DNS proxy program.  For full RFC compliance,\n             the\
    \ proxy system must be able to relay TCP-based queries\n             just like\
    \ UDP-based queries, since some client systems\n             are rumored to ONLY\
    \ use TCP for DNS queries.\n             The proxy system must be able to detect\
    \ and block several\n             classes of attacks based on DNS which (if nothing\
    \ else)\n             may cause denial of service:\n             a) attempts from\
    \ the outside to return corrupt cache\n                entries to an internal\
    \ DNS server\n             b) attempts to return DNS bindings which have no\n\
    \                relationship to the actual DNS query (some DNS\n            \
    \    servers are vulnerable to this). The attacker's goal\n                may\
    \ be to prime the cache of internal DNS servers with\n                interesting\
    \ entries, including entries for internal\n                DNS names that point\
    \ to external IP addresses...\n             c) data-driven stuff similar in style\
    \ to the \"syslog\n                buffer overrun\" type attacks.\n      Once\
    \ the client system knows the IP address of the server system,\n      it attempts\
    \ to establish a connection to the standard FTP\n      \"control\" TCP port on\
    \ the server (port 21). For this to work, the\n      client system must have a\
    \ valid route for the server's IP address\n      THAT LEADS TO THE PROXY SYSTEM,\
    \ and the proxy system must have a\n      valid route for the client's IP address\
    \ and the server's IP\n      address. All intermediate devices that behave like\
    \ IP gateways\n      must have valid routes for the client, the server, and usually\
    \ the\n      proxy. If these devices perform packet filtering, they must ALL\n\
    \      allow the specific type of traffic required between C and S for\n     \
    \ this specific application.\n                                               \
    \ A\n                                    route to S  |\n                     \
    \                           |\n                                           +-----------------+\n\
    \       +---------------+                   |  (p5.p6.p7.p8)  |\n       |  c.dmn1.com\
    \   |                   | proxy system    |\n       | (c1.c2.c3.c4) |        \
    \           |  (p1.p2.p3.p4)  |\n       +---------------+                   +-----------------+\n\
    \         | |                                    |   |\n         | | route to\
    \ S             route to C  |   |\n         | V                              \
    \      V   |\n         |                                          |\n        \
    \ | A                                        | A\n         | | route to C    \
    \                         | | route to S\n         | |                       \
    \                 | |\n         | |      C          S                 C    | |\n\
    \       +----+    <-- +----+ -->    +----+     <-- +----+\n       | G1 |--------|\
    \ Gx |--------| Gy |---------| Gn |\n       +----+ -->    +----+    <-- +----+\
    \ -->     +----+\n               S                C          S\n      At the start\
    \ of the FTP session, a TCP packet with a source\n      address of C and a destination\
    \ address of S travels to the proxy\n      system, expecting to cross it just\
    \ like a normal IP gateway.\n      This is when the transparent proxy shows its\
    \ magic:\n      The proxy's TCP/IP software stack sees this incoming packets (and\n\
    \      subsequent ones) for a destination address that is NOT one of its\n   \
    \   own addresses. Based on some criteria (a configuration file, for\n      example),\
    \ it decides NOT to forward or drop the packet (which are\n      the only two\
    \ choices an RFC-standard TCP/IP implementation would\n      have). The proxy\
    \ system accepts the packet as if it was directed\n      to one of its own IP\
    \ addresses.\n      In our example, the incoming packet is a TCP packet. Since\n\
    \      standard TCP/IP stacks store both a LOCAL and REMOTE IP address\n     \
    \ field for each TCP connection, the transparent proxy may set the\n      LOCAL\
    \ IP address field to the IP address that the client wants to\n      reach (s1.s2.s3.s4\
    \ in our example). The standard TCP/IP stack\n      probably needs to be modified\
    \ to do this. UDP examples, although\n      not connection-based, could be handled\
    \ in similar ways.\n      Once this is done, the actual FTP proxy application\
    \ is invoked\n      since an incoming connection to TCP port 21 has occurred.\
    \ It can\n      determine what is the final target destination instantly, since\n\
    \      the LOCAL IP address field of the connection contains the target\n    \
    \  server's IP address.  There is no need for the proxy application\n      to\
    \ ask the client what is the final target system.\n      Since the FTP proxy application\
    \ knows the IP address of the target\n      system, it can choose to do two things:\n\
    \       a) Setup a session to the final target system, the more\n          frequent\
    \ case.\n       b) Decide (based on some internal configuration data) that it\n\
    \          cannot reach the final target system directly, but must go\n      \
    \    through a \"classical\" proxy. This seems technically\n          feasible,\
    \ although no real transparent proxy system is\n          known to offer this\
    \ capability. The actual value of such\n          a feature (if available) would\
    \ need to be studied.\n      If the FTP proxy decides to connect directly to the\
    \ target system,\n      it has the target system's IP address. It may choose to\
    \ do a\n      reverse lookup on the target IP address to obtain a target system\n\
    \      name (possibly needed for access control). If this process\n      involves\
    \ DNS resolution, something like the following will happen:\n       +-----------------+\n\
    \       | proxy1.dmn3.com |\n       |  (p1.p2.p3.p4)  |          +--------+\n\
    \       |                 |         /   IP     \\\n       | proxy2.dmn4.com |--------+\
    \ network(s) +------------+\n       |  (p5.p6.p7.p8)  |         \\          /\
    \             |\n       +-----------------+          +--------+      +---------------+\n\
    \        A  |                     /          \\       | (s1.s2.s3.s4) |\n    \
    \    |  | name for           /            \\      | s.dmn2.com    |\n        |\
    \  | s1.s2.s3.s4?      /              \\     |               |\n        |  | \
    \                 /                \\    +---------------+\n        |  |     \
    \            /                  \\\n        |  |                /            \
    \        \\\n        |  |         +--------+   s1.s2.s3.s4?    +--------+\n  \
    \      |  +-------->|  DNS   |------------------>|  DNS   |\n        |       \
    \     | server |                   | server |\n        +------------|   X    |<------------------|\
    \   Y    |\n         s.dmn2.com  +--------+    s.dmn2.com     +--------+\n   \
    \   Once this is done and if the connection is allowed, the proxy\n      attempts\
    \ to establish a connection to the standard FTP \"control\"\n      TCP port on\
    \ the target server (port 21), using a technique\n      identical to a \"classical\"\
    \ proxy. For this to work, the proxy\n      system must have a valid route to\
    \ the server's IP address, and the\n      server system must have a valid route\
    \ to at least one of the\n      proxy's IP address. All intermediate devices that\
    \ behave like IP\n      gateways must have valid routes to both the proxy and\
    \ the server.\n      If these devices perform packet filtering, they must ALL\
    \ allow the\n      specific type of traffic required between the proxy and S for\
    \ this\n      specific application.\n       +-----------------+\n       | proxy1.dmn3.com\
    \ |\n       |  (p1.p2.p3.p4)  |\n       |                 |                 +----------------+\n\
    \       | proxy2.dmn4.com |                 |  s.dmn2.com    |\n       |  (p5.p6.p7.p8)\
    \  |                 | (s1.s2.s3.s4)  |\n       +-----------------+          \
    \       +----------------+\n         | |                                    |\
    \   |\n         | | route to S             route to P2 |   |\n         | V   \
    \                                 V   |\n         |                          \
    \                |\n         | A                                        | A\n\
    \         | | route to P2                            | | route to S\n        \
    \ | |                                        | |\n         | |      P2       \
    \  S                 P2   | |\n       +----+    <-- +----+ -->    +----+     <--\
    \ +----+\n       | G1 |--------| Gx |--------| Gy |---------| Gn |\n       +----+\
    \ -->    +----+    <-- +----+ -->     +----+\n               S               \
    \ P2         S\n      The rest of the transparent proxy's operation is very similar\
    \ to\n      what would happen with a classical proxy.\n   4.2 Characteristics\
    \ of transparent proxy configurations\n      Transparent proxy technology can\
    \ be used to build the key\n      component of a \"firewall\", in a way quite\
    \ similar to the way\n      classical proxy technology may be used. Several important\
    \ details\n      of the architecture must be different, however.\n      4.2.1\
    \ IP addressing and routing requirements\n         The transparent proxy system\
    \ must be able to address all client\n         and server systems to which it\
    \ may provide service. It must\n         also know valid IP routes to all these\
    \ client and server\n         systems.\n         Server systems must be able to\
    \ address the proxy system, and\n         must know a valid IP route to the proxy\
    \ system. If the proxy\n         system has several IP addresses (and often, several\
    \ physical\n         network interfaces), the server systems need only to be able\
    \ to\n         access ONE of the proxy system's IP addresses.\n         Client\
    \ systems MUST HAVE valid IP addressing and routing\n         information for\
    \ systems that they reach through the proxy. For\n         example, in the common\
    \ case where a transparent proxy is being\n         used to interconnect a private\
    \ network and the Internet, the\n         private network will effectively need\
    \ to use a default route\n         that points to the transparent proxy system.\
    \ This is a specific\n         need of transparent proxy configurations.\n   \
    \      Interconnecting two internetworks with multiple transparent\n         proxies\
    \ (for load sharing or fail-over) can be accomplished by\n         using different\
    \ techniques from what would be done for\n         classical proxies:\n      \
    \       a) with multiple classical proxies to the same remote\n              \
    \  network, clients can be configured to access different\n                proxies\
    \ manually, or DNS-based techniques, such as\n                DNS load-balancing\
    \ may be used to make clients\n                access a different proxy at different\
    \ times.\n             b) with multiple transparent proxies to the same remote\n\
    \                network, the internal network must be able to provide\n     \
    \           dynamic routing towards the proxies (routing updates\n           \
    \     may need to be supplied by the proxies themselves).\n                Client\
    \ systems (depending on topology) may not need\n                to see the route\
    \ changes, but internal backbone\n                routers probably do.\n     \
    \    It is clear that internetworks linked by a transparent proxy\n         cannot\
    \ be fully isolated from each other in an IP addressing\n         and routing\
    \ sense. The network on which client systems are\n         located must have effective\
    \ valid routing entries to the remote\n         internetwork; these routing entries\
    \ must point to the proxy.\n         The transparent proxy system (if running\
    \ a vaguely standard\n         TCP/IP software stack) needs to have a single coherent\
    \ view of\n         IP addressing and routing. If a proxy system interconnects\
    \ two\n         IP networks and two systems use the same IP network/subnetwork\n\
    \         number (one system on each internetwork), the proxy will only\n    \
    \     be able to address one of the systems. Even if the proxy is\n         able\
    \ to manage multiple conflicting IP universes (if, for\n         example, one\
    \ instance of a complete TCP/IP stack and its data\n         structures is bound\
    \ to each of the proxy network interfaces),\n         the client systems will\
    \ still have a problem: Why should it\n         send packets with this network\
    \ number to the proxy since this\n         network number exists also on the internal\
    \ internetwork?\n         Chaining transparent proxies does not seem at first\
    \ glance to\n         solve IP conflicts like it does for classical proxies.\n\
    \         From a \"security\" fail-safe point of view, the transparent\n     \
    \    proxy has an undesirable characteristic: the network being\n         protected\
    \ must have valid routing entries to the remote\n         network(s). If the proxy\
    \ fails (starts behaving like a non-\n         filtering IP router) or is physically\
    \ bypassed, it is likely\n         that the internal network will be immediately\
    \ able to reply to\n         \"attacker\" packets. The attacker does not need\
    \ to modify\n         routing tables or to spoof internal IP addresses.\n    \
    \     This is important for organizations that do not wish to place\n        \
    \ ALL their confidence and protection into a proxy system (for\n         whatever\
    \ reason).\n      4.2.2 IP address hiding\n         Application \"sessions\" that\
    \ go through a transparent proxy are\n         actually made of two complete sessions:\n\
    \             a) a session between the client and the address of the\n       \
    \         server, the session being \"intercepted\" by the proxy\n           \
    \  b) a session between the proxy and the server\n         A device on the path\
    \ sees either the client<->server traffic or\n         the proxy<->server traffic,\
    \ depending where it is located. The\n         client<-\"server\" traffic is actually\
    \ generated by the\n         transparent proxy. The two sessions SHOULD NEVER\
    \ pass through\n         the same physical network, since in that case (due to\
    \ the\n         routing requirements) a total bypass of the proxy at the IP\n\
    \         routing level may easily occur without being detectable.\n         Like\
    \ classical proxies, transparent proxies accomplish a form\n         of IP address\
    \ hiding. Client IP addresses are hidden from the\n         servers, since the\
    \ servers see a session being initiated by the\n         proxy. Server IP addresses\
    \ are NOT hidden from the clients\n         however, so that the illusion of transparency\
    \ may be\n         maintained.\n         This difference implies that internal\
    \ (client-side) network\n         statistics at the IP level will accurately reflect\
    \ what outside\n         destinations are being accessed.  This can be useful\
    \ for\n         analyzing traffic patterns.\n      4.2.3 DNS requirements\n  \
    \       In transparent proxy configurations, client systems MUST be\n        \
    \ able to resolve server names belonging to remote networks. This\n         is\
    \ critical since the proxy will determine the target server\n         from the\
    \ destination IP address of the packets arriving from\n         the client. Because\
    \ of this, the \"client\" internetwork needs to\n         have some form of DNS\
    \ interconnection to the remote network. If\n         internal client and name\
    \ server IP addresses must be hidden\n         from the outside, these DNS queries\
    \ must also be proxied.\n         Of course, remote host name/address relationships\
    \ may be stored\n         locally on the client systems, but it is well known\
    \ that such\n         an approach does not scale...\n         Because of this,\
    \ it can be said that a transparent proxy system\n         cannot offer DNS isolation.\
    \ If two IP internetworks use\n         completely separate DNS trees (each with\
    \ their own DNS root\n         servers), client software in one IP internetwork\
    \ will not have\n         a way of finding name/address relationships in the \"\
    other\" DNS\n         tree, and this information must be obtained in order to\
    \ pass\n         the desired address to the transparent proxy.\n         The classical\
    \ proxy itself (if running standard DNS resolution\n         software) will not\
    \ be able alone to resolve DNS names in both\n         environments, since it\
    \ will need to point to one or the other\n         of the two DNS \"universes\"\
    .  Running multiple instances of DNS\n         resolution software can allow the\
    \ proxy to do this, however.\n         Because of the requirement placed on some\
    \ form of DNS\n         communication through the proxy, it is critical for the\
    \ proxy\n         to be able to protect ITSELF, internal clients, and internal\n\
    \         name servers from data-driven attacks at the DNS level.\n      4.2.4\
    \ Software requirements\n         The big advantage of transparent proxies is\
    \ that normal client\n         software may access remote servers with no modifications\
    \ and no\n         changes to user procedures.\n         The transparent proxy\
    \ application itself may not need to be\n         more complicated than a classical\
    \ proxy application.\n         However, the proxy TCP/IP software stack cannot\
    \ be a fully-\n         standard (well, today's standard at least) TCP/IP stack,\
    \ and\n         requires specific extensions:\n             a) the ability to\
    \ specify ranges of IP addresses that\n                do not belong to the proxy\
    \ itself, but for which\n                \"intercept\" processing will occur:\
    \ if packets arrive\n                at the proxy with a destination IP address\
    \ in those\n                ranges, the IP stack will not forward or drop the\n\
    \                packets; it will pass them up to application layers.\n      \
    \       b) This mechanism requires that applications may obtain\n            \
    \    both the IP address from which the packets come, and\n                the\
    \ address to which the packets were going. Typical\n                IP stacks\
    \ should already have the fields available\n                to store the info;\
    \ it is a matter of updating them\n                properly for these \"intercepted\"\
    \ packets.\n             c) In the case of \"intercepted\" TCP packets, the TCP\n\
    \                stack must support establishing TCP connections\n           \
    \     where the \"local\" IP address is not one of the\n                proxy's\
    \ IP address.\n         Any TCP/IP software implementation should be modifiable\
    \ to\n         perform these tasks. If a standard API becomes widely available\n\
    \         to drive these extensions, and if this API is generally\n         implemented,\
    \ transparent proxies may become \"portable\"\n         applications.\n      \
    \   Until this occurs, it must be assumed that implementors have\n         chosen\
    \ different ways of accomplishing these functions, so that\n         today's transparent\
    \ proxy applications cannot be fully\n         portable. It also remains to be\
    \ seen how much work is needed to\n         propagate these \"extensions\" to\
    \ IPV6 software stacks.\n      4.2.5 Impact of a transparent proxy on packet filtering\n\
    \         The nature of a transparent proxy's functionality makes it\n       \
    \  difficult to deploy good packet filtering on the \"inside\" (or\n         client-side)\
    \ of the proxy. The proxy will \"masquerade\" as all\n         the external systems.\
    \ Because of this, internal packet filters\n         WILL TYPICALLY NEED TO ALLOW\
    \ IP traffic between internal and\n         external IP addresses.\n         Depending\
    \ on the actual security policy of the network, it may\n         be possible to\
    \ do filtering based on protocol type and/or on\n         TCP bits (to filter\
    \ based on connection setup direction), but\n         filtering that blocks external\
    \ IP addresses CANNOT be deployed.\n         If the proxy starts behaving like\
    \ an IP router, or if\n         physically bypassed, the practical limitations\
    \ imposed on\n         internal packet filtering imply that a lot of direct traffic\n\
    \         between the inside and outside network will be allowed to flow.\n  \
    \       Furthermore, as we have seen previously, the internal network\n      \
    \   will have valid routing entries for external network numbers\n         that\
    \ point to the proxy.  If multiple proxies have been\n         deployed, the internal\
    \ network may even HAVE TO TRUST routing\n         updates generated by the proxy.\n\
    \         In general, if an internal network wishes to communicate with\n    \
    \     an external network through a transparent proxy, it MUST BE\n         FUNDAMENTALLY\
    \ DESIGNED TO COMMUNICATE DIRECTLY with that\n         external network. This\
    \ is true at the IP addressing level, at\n         the IP routing level, and at\
    \ the DNS level.  A proxy security\n         failure in this type of environment\
    \ is likely to result in\n         immediate, total, and undetected accessibility\
    \ of the internal\n         network by the external network.\n      4.2.6 Interconnection\
    \ of conflicting IP networks\n         Unlike classical proxies, transparent proxies\
    \ do not readily\n         seem useful in solving IP addressing conflicts.\n \
    \        If two internetworks use the same network number(s), systems\n      \
    \   and routers in each internetwork will have valid routes to\n         these\
    \ network numbers. If these routes are changed to point to\n         a transparent\
    \ proxy, traffic that is meant to stay within the\n         same internetwork\
    \ would start to flow towards the proxy. The\n         proxy will not be able\
    \ to distinguish reliably between traffic\n         between systems of the same\
    \ internetwork, and traffic which is\n         meant to cross the proxy.\n   \
    \      A possible solution to this problem is described in section 6\n       \
    \  of this document, \"Improving transparent proxies\".\n"
- title: 5. Comparison chart of classical and transparent proxies
  contents:
  - "5. Comparison chart of classical and transparent proxies\n   For those who do\
    \ not like longish discussions of technical details,\n   here is a one-page summary\
    \ of the strengths/weaknesses/differences of\n   classical and transparent proxies:\n\
    \    -----------------------------------------------------------------\n   | Issue\
    \             |   Classical Proxy   |  Transparent Proxy   |\n   |-------------------+---------------------+----------------------|\n\
    \   | IP addressing     | systems/gateways on | systems/gateways on  |\n   | \
    \                  | each network need   | the \"client\" network |\n   |    \
    \               | to address the proxy| need to address the  |\n   |         \
    \          |                     | remote networks      |\n   |              \
    \     |                     |                      |\n   | IP routing        |\
    \ systems/gateways on | systems/gateways on  |\n   |                   | each\
    \ network need a | the \"client\" network |\n   |                   | valid routing\
    \ entry | also need routing    |\n   |                   | for the proxy     \
    \  | entries for remote   |\n   |                   |                     | entries\
    \              |\n   |                   |                     |             \
    \         |\n   | IP address hiding | systems on each side| systems on the   \
    \    |\n   |                   | of the proxy are    | \"client\" side are   \
    \ |\n   |                   | hidden from each    | hidden from the      |\n \
    \  |                   | other               | other sides          |\n   |  \
    \                 |                     |                      |\n   | DNS   \
    \            | full isolation      | resolution of outside|\n   |            \
    \       | possible            | names by inside      |\n   |                 \
    \  |                     | systems is required  |\n   |                   |  \
    \                   |                      |\n   | Proxy software    | runs on\
    \ standard    | requires special     |\n   |    requirements   | TCP/IP stack;\
    \       | TCP/IP stack;        |\n   |                   | can be portable   \
    \  | not 100% portable    |\n   |                   |                     |  \
    \                    |\n   | Client software   | requires proxy-     | nothing\
    \ more than for|\n   |    requirements   | capable software    | a direct connection\
    \  |\n   |                   | or user education   |                      |\n\
    \   |                   |                     |                      |\n   | User\
    \ requirements | must use proxy-     | nothing more than for|\n   |          \
    \         | capable software or | a direct connection  |\n   |               \
    \    | know how to use the |                      |\n   |                   |\
    \ proxy               |                      |\n   |                   |     \
    \                |                      |\n   | Packet filtering  | can filter\
    \ out      | cannot filter out    |\n   |                   | \"external\" addresses|\
    \ \"external\" addresses |\n   |                   |                     |   \
    \                   |\n   | IP address        | can be done with    | no obvious\
    \ way to    |\n   |    conflict       | chained proxies that| get this to work\
    \     |\n   |    resolution     | support auto-connect|                      |\n\
    \    ----------------------------------------------------------------\n"
- title: 6. Improving transparent proxies
  contents:
  - "6. Improving transparent proxies\n   The main issues with transparent proxies\
    \ seem to revolve around the\n   need to force \"client\" systems to directly\
    \ access external addresses.\n   To some people, this characteristic makes a transparent\
    \ proxy look\n   too much like a complicated packet filter. Can this problem be\n\
    \   solved?\n   The first possibility that comes to mind is to use the flexibility\
    \ of\n   the DNS protocol to build new tricks. If we restrict the \"internal\"\
    \n   clients so that they MUST ALWAYS use DNS to resolve external host\n   names\
    \ AND THAT THEY MUST NEVER store permanent copies of external\n   host addresses,\
    \ the following technique would become theoretically\n   possible (this is a very\
    \ painful restriction, by the way):\n   a) arrange for all internal queries for\
    \ external DNS names to\n      go to the transparent proxy system (this can be\
    \ done in a\n      number of ways).\n   b) arrange for a routing entry to exist\
    \ for a class A network\n      number that is not used on the internal network.\
    \ This IMPLIES\n      that the internal network may not be part of the Internet.\
    \ This\n      routing entry will point to the transparent proxy system. For\n\
    \      the purpose of our discussion, this special network number will\n     \
    \ be X.0.0.0.\n   c) when an internal system generates a query for an external\n\
    \      address, the query (if no answer is cached on the internal\n      network)\
    \ will reach the proxy system. Assuming the query is to\n      obtain the IP address\
    \ corresponding to a domain name, the proxy\n      will go through the following\
    \ algorithm:\n      - try to find a valid binding for this external domain name\
    \ in\n        its local cache\n      - if not found, it will ITSELF launch an\
    \ external DNS query\n        for the domain name. When (and if) it receives a\
    \ valid reply,\n        it creates a local cache entry containing:\n         \
    \   Time To Live of the reply\n            Expiry Time of the cache entry (based\
    \ on the current time)\n            External domain name\n            External\
    \ IP address\n            Dynamically allocated IP address of the form X.x1.x2.x3.\n\
    \        and returns to the client the dynamically allocated IP address\n    \
    \    in the range X.0.0.0, NOT THE REAL ONE.\n      - the client may (or may not)\
    \ store the IP address returned in\n        its cache, and will then attempt to\
    \ connect to the\n        dynamically allocated IP address. This traffic will\
    \ arrive at\n        the proxy because of the routing setup.\n      - The transparent\
    \ proxy intercepts the traffic and can identify\n        the actual desired target\
    \ it should connect to based on the\n        dynamically allocated IP address\
    \ supplied by the client.\n   Such an approach, if workable, could improve many\
    \ characteristics of\n   transparent proxies and may even make transparent proxies\
    \ capable of\n   handling IP network number conflicts.\n   However, the algorithm\
    \ above leaves many difficult questions\n   unsolved. Here is a list (by no means\
    \ exhaustive) of these questions:\n   a) What is the percentage of client DNS\
    \ resolver and DNS server\n      implementations that conform to the RFC specifications\
    \ in their\n      handling of the Time-To-Live field?\n   b) How should the proxy\
    \ handle other types of DNS queries for\n      external domain names (inverse\
    \ queries, queries for other\n      resource record types)?\n   c) A client program\
    \ may perform a DNS query once for an external\n      name and then use the response\
    \ for a long time (a large file\n      transfer, or a permanent management session,\
    \ for example).\n      Should the proxy update the Expiry Time of cache entries\
    \ based\n      on the passing IP traffic, and if so, using what algorithm?\n \
    \  d) What new types of attacks would such a system introduce or\n      make possible?\n\
    \   e) What data structures and resources (memory, disk) would be\n      needed\
    \ for an efficient implementation if the proxy must sustain\n      a high rate\
    \ of DNS queries for external names, and where a large\n      number of different\
    \ external names are referenced? The class A\n      network number is used basically\
    \ to reference cache entries.\n      Would a 24-bit address space be sufficient\
    \ for practical use?\n   f) What happens with the cache (and the functionality)\
    \ if the proxy\n      crashes or reboots?\n   Such a system would probably exhibit\
    \ two types of intermittent\n   failures:\n   a) a client system is still using\
    \ the result of an external name\n      query (some X.x1.x2.x3 address dynamically\
    \ allocated by the\n      proxy), but this binding no longer exists in the proxy's\
    \ cache.\n      The client attempts a connection to this address, which fails.\n\
    \   b) a client's name cache contains a binding for X.x1.x2.x3, but the\n    \
    \  proxy has already reused this address for a different external\n      host\
    \ name. The client attempts a connection to this address,\n      sees no obvious\
    \ errors, but reaches a different system from the\n      expected one.\n   If\
    \ somebody has ever implemented such a scheme, information and live\n   experience\
    \ in deploying it would be useful to the IP networking\n   community.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   Most of this document is concerned with security\
    \ implications of\n   classical and transparent proxy technology.\n"
- title: 8. Acknowledgements
  contents:
  - "8. Acknowledgements\n   I could not have written this document without the support\
    \ of Digital\n   Equipment Corporation for whom I work as a consultant.\n"
- title: 9. References
  contents:
  - "9. References\n   [1] Cheswick, W., Bellovin, S., \"Firewalls and Internet Security:\n\
    \       Repelling the Wily Hacker\", Addison-Wesley, 1994.\n   [2] Chapman, B.,\
    \ Zwicky, E., \"Building Internet Firewalls\",\n       O'Reilly and Associates,\
    \ Inc., September 1995.\n   [3] Comer, D., \"Internetworking with TCP/IP volume\
    \ 1: Principles,\n       Protocols, and Architecture\", Prentice-Hall, 1991.\n\
    \   [4] Comer, D., Stevens, D., \"Internetworking with TCP/IP volume 2:\n    \
    \   \"Design, Implementation, and Internals\", Prentice-Hall, 1991.\n   [5] Postel,\
    \ J., and J. Reynolds, \"File Transfer Protocol (FTP)\",\n       STD 9, RFC 959,\
    \ USC/Information Sciences Institute, October\n       1985.\n   [6] Huitema, C.,\
    \ \"An experiment in DNS Based IP Routing\", RFC 1383,\n       INRIA, December\
    \ 1992.\n   [7] Rekhter Y., Moskowitz B., Karrenberg D., de Groot, G.,\n     \
    \  \"Address Allocation for Private Internets\", RFC 1597,\n       IBM Corp.,\
    \ Chrysler Corp, RIPE NCC, March 1994.\n   [8] The TIS firewall toolkit's documentation,\
    \ available on\n       Trusted Information System's anonymous FTP site, ftp.tis.com.\n\
    \   [9] Many discussions in the last 18 months on the firewalls-digest\n     \
    \  mailing list maintained by Great Circle Associates. The\n       archives of\
    \ the list are maintained at ftp.greatcircle.com.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Marc Chatel\n   9, avenue Jean Monnet\n   74940 ANNECY-LE-VIEUX\n\
    \   FRANCE\n   EMail: mchatel@pax.eunet.ch\n   or at Digital Equipment:\n   Marc.Chatel@aeo.mts.dec.com\n"
