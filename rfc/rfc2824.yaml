- title: __initial_text__
  contents:
  - '          Call Processing Language Framework and Requirements

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   A large number of the services we wish to make possible for Internet\n\
    \   telephony require fairly elaborate combinations of signalling\n   operations,\
    \ often in network devices, to complete. We want a simple\n   and standardized\
    \ way to create such services to make them easier to\n   implement and deploy.\
    \  This document describes an architectural\n   framework for such a mechanism,\
    \ which we call a call processing\n   language. It also outlines requirements\
    \ for such a language.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1        Introduction ........................................\
    \    2\n   2        Terminology .........................................    3\n\
    \   3        Example services ....................................    4\n   4\
    \        Usage scenarios .....................................    6\n   5    \
    \    CPL creation ........................................    6\n   6        Network\
    \ model .......................................    7\n   6.1      Model components\
    \ ....................................    7\n   6.1.1    End systems .........................................\
    \    7\n   6.1.2    Signalling servers ..................................    8\n\
    \   6.2      Component interactions ..............................    8\n   7\
    \        Interaction of CPL with network model ...............   10\n   7.1  \
    \    What a script does ..................................   10\n   7.2      Which\
    \ script is executed ............................   11\n   7.3      Where a script\
    \ runs .................................   12\n   8        Creation and transport\
    \ of a call processing\n            language script .....................................\
    \   12\n   9        Feature interaction behavior ........................   13\n\
    \   9.1      Feature-to-feature interactions .....................   13\n   9.2\
    \      Script-to-script interactions .......................   14\n   9.3    \
    \  Server-to-server interactions .......................   15\n   9.4      Signalling\
    \ ambiguity ................................   15\n   10       Relationship with\
    \ existing languages ................   15\n   11       Related work ........................................\
    \   17\n   11.1     IN service creation environments ....................   17\n\
    \   11.2     SIP CGI .............................................   17\n   12\
    \       Necessary language features .........................   17\n   12.1  \
    \   Language characteristics ............................   17\n   12.2     Base\
    \ features -- call signalling ....................   19\n   12.3     Base features\
    \ -- non-signalling .....................   21\n   12.4     Language features\
    \ ...................................   22\n   12.5     Control .............................................\
    \   23\n   13       Security Considerations .............................   23\n\
    \   14       Acknowledgments .....................................   23\n   15\
    \       Authors' Addresses ..................................   23\n   16    \
    \   Bibliography ........................................   24\n   17       Full\
    \ Copyright Statement ............................   25\n"
- title: 1 Introduction
  contents:
  - "1 Introduction\n   Recently, several protocols have been created to allow telephone\n\
    \   calls to be made over IP networks, notably SIP [1] and H.323 [2].\n   These\
    \ emerging standards have opened up the possibility of a broad\n   and dramatic\
    \ decentralization of the provisioning of telephone\n   services so they can be\
    \ under the user's control.\n   Many Internet telephony services can, and should,\
    \ be implemented\n   entirely on end devices. Multi-party calls, for instance,\
    \ or call\n   waiting alert tones, or camp-on services, depend heavily on end-\n\
    \   system state and on the specific content of media streams,\n   information\
    \ which often is only available to the end system. A\n   variety of services,\
    \ however -- those involving user location, call\n   distribution, behavior when\
    \ end systems are busy, and the like -- are\n   independent of a particular end\
    \ device, or need to be operational\n   even when an end device is unavailable.\
    \ These services are still best\n   located in a network device, rather than in\
    \ an end system.\n   Traditionally, network-based services have been created only\
    \ by\n   service providers. Service creation typically involved using\n   proprietary\
    \ or restricted tools, and there was little range for\n   customization or enhancement\
    \ by end users.  In the Internet\n   environment, however, this changes. Global\
    \ connectivity and open\n   protocols allow end users or third parties to design\
    \ and implement\n   new or customized services, and to deploy and modify their\
    \ services\n   dynamically without requiring a service provider to act as an\n\
    \   intermediary.\n   A number of Internet applications have such customization\n\
    \   environments -- the web has CGI [3], for instance, and e-mail has\n   Sieve\
    \ [4] or procmail. To create such an open customization\n   environment for Internet\
    \ telephony, we need a standardized, safe way\n   for these new service creators\
    \ to describe the desired behavior of\n   network servers.\n   This document describes\
    \ an architecture in which network devices\n   respond to call signalling events\
    \ by triggering user-created programs\n   written in a simple, static, non-expressively-complete\
    \ language. We\n   call this language a call processing language.\n   The development\
    \ of this document has been substantially informed by\n   the development of a\
    \ particular call processing language, as\n   described in [5]. In general, when\
    \ this document refers to \"a call\n   processing language,\" it is referring\
    \ to a generic language that\n   fills this role; \"the call processing language\"\
    \ or \"the CPL\" refers\n   to this particular language.\n"
- title: 2 Terminology
  contents:
  - "2 Terminology\n   In this section we define some of the terminology used in this\n\
    \   document.\n   SIP [1] terminology used includes:\n      invitation: The initial\
    \ INVITE request of a SIP transaction, by\n           which one party initiates\
    \ a call with another.\n      redirect server: A SIP device which responds to\
    \ invitations and\n           other requests by informing the request originator\
    \ of an\n           alternate address to which the request should be sent.\n \
    \     proxy server: A SIP device which receives invitations and other\n      \
    \     requests, and forwards them to other SIP devices. It then\n           receives\
    \ the responses to the requests it forwarded, and\n           forwards them back\
    \ to the sender of the initial request.\n      user agent: A SIP device which\
    \ creates and receives requests, so\n           as to set up or otherwise affect\
    \ the state of a call. This\n           may be, for example, a telephone or a\
    \ voicemail system.\n      user agent client: The portion of a user agent which\
    \ initiates\n           requests.\n      user agent server: The portion of a user\
    \ agent which responds to\n           requests.\n   H.323 [2] terminology used\
    \ includes:\n      terminal: An H.323 device which originates and receives calls,\
    \ and\n           their associated media.\n      gatekeeper: An H.323 entity on\
    \ the network that provides address\n           translation and controls access\
    \ to the network for H.323\n           terminals and other endpoints. The gatekeeper\
    \ may also\n           provide other services to the endpoints such as bandwidth\n\
    \           management and locating gateways.\n      gateway: A device which translates\
    \ calls between an H.323 network\n           and another network, typically the\
    \ public-switched telephone\n           network.\n      RAS: The Registration,\
    \ Admission and Status messages communicated\n           between two H.323 entities,\
    \ for example between an endpoint\n           and a gatekeeper.\n   General terminology\
    \ used in this document includes:\n      user location: The process by which an\
    \ Internet telephony device\n           determines where a user named by a particular\
    \ address can be\n           found.\n      CPL: A Call Processing Language, a\
    \ simple language to describe how\n           Internet telephony call invitations\
    \ should be processed.\n      script: A particular instance of a CPL, describing\
    \ a particular\n           set of services desired.\n      end system: A device\
    \ from which and to which calls are\n           established.  It creates and receives\
    \ the call's media\n           (audio, video, or the like). This may be a SIP\
    \ user agent or\n           an H.323 terminal.\n      signalling server: A device\
    \ which handles the routing of call\n           invitations. It does not process\
    \ or interact with the media\n           of a call. It may be a SIP proxy or redirect\
    \ server, or an\n           H.323 gatekeeper.\n"
- title: 3 Example services
  contents:
  - "3 Example services\n   To motivate the subsequent discussion, this section gives\
    \ some\n   specific examples of services which we want users to be able to\n \
    \  create programmatically.  Note that some of these examples are\n   deliberately\
    \ somewhat complicated, so as to demonstrate the level of\n   decision logic that\
    \ should be possible.\n      o  Call forward on busy/no answer\n         When\
    \ a new call comes in, the call should ring at the user's\n         desk telephone.\
    \  If it is busy, the call should always be\n         redirected to the user's\
    \ voicemail box. If, instead, there's no\n         answer after four rings, it\
    \ should also be redirected to his or\n         her voicemail, unless it's from\
    \ a supervisor, in which case it\n         should be proxied to the user's cell\
    \ phone if it is currently\n         registered.\n      o  Information address\n\
    \         A company advertises a general \"information\" address for\n       \
    \  prospective customers. When a call comes in to this address, if\n         it's\
    \ currently working hours, the caller should be given a list\n         of the\
    \ people currently willing to accept general information\n         calls. If it's\
    \ outside of working hours, the caller should get\n         a webpage indicating\
    \ what times they can call.\n      o  Intelligent user location\n         When\
    \ a call comes in, the list of locations where the user has\n         registered\
    \ should be consulted. Depending on the type of call\n         (work, personal,\
    \ etc.), the call should ring at an appropriate\n         subset of the registered\
    \ locations, depending on information in\n         the registrations. If the user\
    \ picks up from more than one\n         station, the pick-ups should be reported\
    \ back separately to the\n         calling party.\n      o  Intelligent user location\
    \ with media knowledge\n         When a call comes in, the call should be proxied\
    \ to the station\n         the user has registered from whose media capabilities\
    \ best\n         match those specified in the call request. If the user does not\n\
    \         pick up from that station within four rings, the call should be\n  \
    \       proxied to the other stations from which he or she has\n         registered,\
    \ sequentially, in order of decreasing closeness of\n         match.\n      o\
    \  Client billing allocation -- lawyer's office\n         When a call comes in,\
    \ the calling address is correlated with\n         the corresponding client, and\
    \ client's name, address, and the\n         time of the call is logged. If no\
    \ corresponding client is\n         found, the call is forwarded to the lawyer's\
    \ secretary.\n"
- title: 4 Usage scenarios
  contents:
  - "4 Usage scenarios\n   A CPL would be useful for implementing services in a number\
    \ of\n   different scenarios.\n      o  Script creation by end user\n        \
    \ In the most direct approach for creating a service with a CPL,\n         an\
    \ end user simply creates a script describing their service.\n         He or she\
    \ simply decides what service he or she wants,\n         describes it using a\
    \ CPL script, and then uploads it to a\n         server.\n      o  Third party\
    \ outsourcing\n         Because a CPL is a standardized language, it can also\
    \ be used\n         to allow third parties to create or customize services for\n\
    \         clients. These scripts can then be run on servers owned by the\n   \
    \      end user or the user's service provider.\n      o  Administrator service\
    \ definition\n         A CPL can also be used by server administrators to create\n\
    \         simple services or describe policy for servers they control.\n     \
    \    If a server is implementing CPL services in any case, extending\n       \
    \  the service architecture to allow administrators as well as\n         users\
    \ to create scripts is a simple extension.\n      o  Web middleware\n        \
    \ Finally, there have been a number of proposals for service\n         creation\
    \ or customization using web interfaces. A CPL could be\n         used as the\
    \ back-end to such environments: a web application\n         could create a CPL\
    \ script on behalf of a user, and the\n         telephony server could then implement\
    \ the services without\n         either component having to be aware of the specifics\
    \ of the\n         other.\n"
- title: 5 CPL creation
  contents:
  - "5 CPL creation\n   There are also a number of means by which CPL scripts could\
    \ be\n   created.  Like HTML, which can be created in a number of different\n\
    \   manners, we envision multiple creation styles for a CPL script.\n      o \
    \ Hand authoring\n         Most directly, CPL scripts can be created by hand,\
    \ by\n         knowledgeable users.  The CPL described in [5] has a text\n   \
    \      format with an uncomplicated syntax, so hand authoring will be\n      \
    \   straightforward.\n      o  Automated scripts\n         CPL features can be\
    \ created by automated means, such as in the\n         example of the web middleware\
    \ described in the previous\n         section. With a simple, text-based syntax,\
    \ standard text-\n         processing languages will be able to create and edit\
    \ CPL\n         scripts easily.\n      o  GUI tools\n         Finally, users will\
    \ be able to use GUI tools to create and edit\n         CPL scripts.  We expect\
    \ that most average-experience users will\n         take this approach once the\
    \ CPL gains popularity.  The CPL will\n         be designed with this application\
    \ in mind, so that the full\n         expressive power of scripts can be represented\
    \ simply and\n         straightforwardly in a graphical manner.\n"
- title: 6 Network model
  contents:
  - "6 Network model\n   The Call Processing Language operates on a generalized model\
    \ of an\n   Internet telephony network. While the details of various protocols\n\
    \   differ, on an abstract level all major Internet telephony\n   architectures\
    \ are sufficiently similar that their major features can\n   be described commonly.\
    \ This document generally uses SIP terminology,\n   as its authors' experience\
    \ has mainly been with that protocol.\n"
- title: 6.1 Model components
  contents:
  - "6.1 Model components\n   In the Call Processing Language's network model, an\
    \ Internet\n   telephony network contains two types of components.\n"
- title: 6.1.1 End systems
  contents:
  - "6.1.1 End systems\n   End systems are devices which originate and/or receive\
    \ signalling\n   information and media. These include simple and complex telephone\n\
    \   devices, PC telephony clients, and automated voice systems. The CPL\n   abstracts\
    \ away the details of the capabilities of these devices. An\n   end system can\
    \ originate a call; and it can accept, reject, or\n   forward incoming calls.\
    \ The details of this process (ringing, multi-\n   line telephones, and so forth)\
    \ are not important for the CPL.\n   For the purposes of the CPL, gateways --\
    \ for example, a device which\n   connects calls between an IP telephony network\
    \ and the PSTN -- are\n   also considered to be end systems. Other devices, such\
    \ as mixers or\n   firewalls, are not directly dealt with by the CPL, and they\
    \ will not\n   be discussed here.\n"
- title: 6.1.2 Signalling servers
  contents:
  - "6.1.2 Signalling servers\n   Signalling servers are devices which relay or control\
    \ signalling\n   information. In SIP, they are proxy servers, redirect servers,\
    \ or\n   registrars; in H.323, they are gatekeepers.\n   Signalling servers can\
    \ perform three types of actions on call setup\n   information. They can:\n  \
    \    proxy it: forward it on to one or more other network or end\n           systems,\
    \ returning one of the responses received.\n      redirect it: return a response\
    \ informing the sending system of a\n           different address to which it\
    \ should send the request.\n      reject it: inform the sending system that the\
    \ setup request could\n           not be completed.\n   RFC 2543 [1] has illustrations\
    \ of proxy and redirect functionality.\n   End systems may also be able to perform\
    \ some of these actions: almost\n   certainly rejection, and possibly redirection.\n\
    \   Signalling servers also normally maintain information about user\n   location.\
    \  Whether by means of registrations (SIP REGISTER or H.323\n   RAS messages),\
    \ static configuration, or dynamic searches, signalling\n   servers must have\
    \ some means by which they can determine where a user\n   is currently located,\
    \ in order to make intelligent choices about\n   their proxying or redirection\
    \ behavior.\n   Signalling servers are also usually able to keep logs of transactions\n\
    \   that pass through them, and to send e-mail to destinations on the\n   Internet,\
    \ under programmatic control.\n"
- title: 6.2 Component interactions
  contents:
  - "6.2 Component interactions\n   When an end system places a call, the call establishment\
    \ request can\n   proceed by a variety of routes through components of the network.\
    \ To\n   begin with, the originating end system must decide where to send its\n\
    \   requests. There are two possibilities here: the originator may be\n   configured\
    \ so that all its requests go to a single local server; or\n   it may resolve\
    \ the destination address to locate a remote signalling\n   server or end system\
    \ to which it can send the request directly.\n   Once the request arrives at a\
    \ signalling server, that server uses its\n   user location database, its local\
    \ policy, DNS resolution, or other\n   methods, to determine the next signalling\
    \ server or end system to\n   which the request should be sent. A request may\
    \ pass through any\n   number of signalling servers: from zero (in the case when\
    \ end systems\n   communicate directly) to, in principle, every server on the\
    \ network.\n   What's more, any end system or signalling server can (in principle)\n\
    \   receive requests from or send them to any other.\n   For example, in figure\
    \ 1, there are two paths the call establishment\n   request information may take.\
    \ For Route 1, the originator knows only\n   a user address for the user it is\
    \ trying to contact, and it is\n   configured to send outgoing calls through a\
    \ local outgoing proxy\n   server.  Therefore, it forwards the request to its\
    \ local server,\n   which finds the server of record for that address, and forwards\
    \ it on\n   to that server.\n   In this case, the organization the destination\
    \ user belongs to uses a\n   multi-stage setup to find users. The corporate server\
    \ identifies\n   which department a user is part of, then forwards the request\
    \ to the\n   appropriate departmental server, which actually locates the user.\n\
    \   (This is similar to the way e-mail forwarding is often configured.)\n   The\
    \ response to the request will travel back along the same path.\n   For Route\
    \ 2, however, the originator knows the specific device\n   address it is trying\
    \ to contact, and it is not configured to use a\n   local outgoing proxy.  In\
    \ this case, the originator can directly\n   contact the destination without having\
    \ to communicate with any\n   network servers at all.\n   We see, then, that in\
    \ Internet telephony signalling servers cannot in\n   general know the state of\
    \ end systems they \"control,\" since\n   signalling information may have bypassed\
    \ them. This architectural\n   limitation implies a number of restrictions on\
    \ how some services can\n   be implemented. For instance, a network system cannot\
    \ reliably know\n   if an end system is currently busy or not; a call may have\
    \ been\n   placed to the end system without traversing that network system.\n\
    \   Thus, signalling messages must explicitly travel to end systems to\n   find\
    \ out their state; in the example, the end system must explicitly\n   return a\
    \ \"busy\" indication.\n      Outgoing                           Corporate   \
    \     Departmental\n        Proxy                              Server        \
    \    Server\n       _______  Outgoing proxy contacts   _______            _______\n\
    \       |     |     corporate server       |     |            |     |\n      \
    \ |     | -------------------------> |     | ---------> |     |\n       |_____|\
    \                            |_____|            |_____|\n"
- title: Route 1   ^                                                    \Searches
  contents:
  - "Route 1   ^                                                    \\Searches\n \
    \        /                                                      \\   for\n"
- title: Sends to/                                                        \ User
  contents:
  - "Sends to/                                                        \\ User\n proxy\
    \ /                                                         _|\n   _______   \
    \                                                   _______\n   |     |   Route\
    \ 2                                            |     |\n   |     | --------------------------------------------------->\
    \ |     |\n   |_____|      Originator directly contacts destination        |_____|\n\
    \  Originator                                                 Destination\n  \
    \       Figure 1: Possible paths of call setup messages\n"
- title: 7 Interaction of CPL with network model
  contents:
  - '7 Interaction of CPL with network model

    '
- title: 7.1 What a script does
  contents:
  - "7.1 What a script does\n   A CPL script runs in a signalling server, and controls\
    \ that system's\n   proxy, redirect, or rejection actions for the set-up of a\
    \ particular\n   call. It does not attempt to coordinate the behavior of multiple\n\
    \   signalling servers, or to describe features on a \"Global Functional\n   Plane\"\
    \ as in the Intelligent Network architecture [6].\n   More specifically, a script\
    \ replaces the user location functionality\n   of a signalling server. As described\
    \ in section 6.1.2, a signalling\n   server typically maintains a database of\
    \ locations where a user can\n   be reached; it makes its proxy, redirect, and\
    \ rejection decisions\n   based on the contents of that database. A CPL script\
    \ replaces this\n   basic database lookup functionality; it takes the registration\n\
    \   information, the specifics of a call request, and other external\n   information\
    \ it wants to reference, and chooses the signalling actions\n   to perform.\n\
    \   Abstractly, a script can be considered as a list of condition/action\n   pairs;\
    \ if some attribute of the registration, request, and external\n   information\
    \ matches a given condition, then the corresponding action\n   (or more properly\
    \ set of actions) is taken. In some circumstances,\n   additional actions can\
    \ be taken based on the consequences of the\n   first action and additional conditions.\
    \ If no condition matches the\n   invitation, the signalling server's standard\
    \ action -- its location\n   database lookup, for example -- is taken.\n"
- title: 7.2 Which script is executed
  contents:
  - "7.2 Which script is executed\n   CPL scripts are usually associated with a particular\
    \ Internet\n   telephony address. When a call establishment request arrives at\
    \ a\n   signalling server which is a CPL server, that server associates the\n\
    \   source and destination addresses specified in the request with its\n   database\
    \ of CPL scripts; if one matches, the corresponding script is\n   executed.\n\
    \   Once the script has executed, if it has chosen to perform a proxy\n   action,\
    \ a new Internet telephony address will result as the\n   destination of that\
    \ proxying. Once this has occurred, the server\n   again checks its database of\
    \ scripts to see if any of them are\n   associated with the new address; if one\
    \ is, that script as well is\n   executed (assuming that a script has not attempted\
    \ to proxy to an\n   address which the server has already tried). For more details\
    \ of this\n   recursion process, and a description of what happens when a server\n\
    \   has scripts that correspond both to a scripts origination address and\n  \
    \ its destination address, see section 9.2.\n   In general, in an Internet telephony\
    \ network, an address will denote\n   one of two things: either a user, or a device.\
    \ A user address refers\n   to a particular individual, for example sip:joe@example.com,\n\
    \   regardless of where that user actually is or what kind of device he\n   or\
    \ she is using. A device address, by contrast, refers to a\n   particular physical\
    \ device, such as sip:x26063@phones.example.com.\n   Other, intermediate sorts\
    \ of addresses are also possible, and have\n   some use (such as an address for\
    \ \"my cell phone, wherever it\n   currently happens to be registered\"), but\
    \ we expect them to be less\n   common. A CPL script is agnostic to the type of\
    \ address it is\n   associated with; while scripts associated with user addresses\
    \ are\n   probably the most useful for most services, there is no reason that\
    \ a\n   script could not be associated with any other type of address as\n   well.\
    \  The recursion process described above allows scripts to be\n   associated with\
    \ several of a user's addresses; thus, a user script\n   could specify an action\
    \ \"try me at my cell phone,\" whereas a device\n   script could say \"I don't\
    \ want to accept cell phone calls while I'm\n   out of my home area.\"\n   It\
    \ is also possible for a CPL script to be associated not with one\n   specific\
    \ Internet telephony address, but rather with all addresses\n   handled by a signalling\
    \ server, or a large set of them. For instance,\n   an administrator might configure\
    \ a system to prevent calls from or to\n   a list of banned incoming or outgoing\
    \ addresses; these should\n   presumably be configured for everyone, but users\
    \ should still to be\n   able to have their own custom scripts as well. Exactly\
    \ when such\n   scripts should be executed in the recursion process depends on\
    \ the\n   precise nature of the administrative script. See section 9.2 for\n \
    \  further discussion of this.\n"
- title: 7.3 Where a script runs
  contents:
  - "7.3 Where a script runs\n   Users can have CPL scripts on any network server\
    \ which their call\n   establishment requests pass through and with which they\
    \ have a trust\n   relationship. For instance, in the example in figure 1, the\n\
    \   originating user could have a script on the outgoing proxy, and the\n   destination\
    \ user could have scripts on both the corporate server and\n   the departmental\
    \ server. These scripts would typically perform\n   different functions, related\
    \ to the role of the server on which they\n   reside; a script on the corporate-wide\
    \ server could be used to\n   customize which department the user wishes to be\
    \ found at, for\n   instance, whereas a script at the departmental server could\
    \ be used\n   for more fine-grained location customization. Some services, such\
    \ as\n   filtering out unwanted calls, could be located at either server. See\n\
    \   section 9.3 for some implications of a scenario like this.\n   This model\
    \ does not specify the means by which users locate a CPL-\n   capable network\
    \ server. In general, this will be through the same\n   means by which they locate\
    \ a local Internet telephony server to\n   register themselves with; this may\
    \ be through manual configuration,\n   or through automated means such as the\
    \ Service Location Protocol [7].\n   It has been proposed that automated means\
    \ of locating such servers\n   should include a field to indicate whether the\
    \ server allows users to\n   upload CPLs.\n"
- title: 8 Creation and transport of a call processing language script
  contents:
  - "8 Creation and transport of a call processing language script\n   Users create\
    \ call processing language scripts, typically on end\n   devices, and transmit\
    \ them through the network to signalling servers.\n   Scripts persist in signalling\
    \ servers until changed or deleted,\n   unless they are specifically given an\
    \ expiration time; a network\n   system which supports CPL scripting will need\
    \ stable storage.\n   The end device on which the user creates the CPL script\
    \ need not bear\n   any relationship to the end devices to which calls are actually\n\
    \   placed. For example, a CPL script might be created on a PC, whereas\n   calls\
    \ might be intended to be received on a simple audio-only\n   telephone.  Indeed,\
    \ the device on which the script is created may not\n   be an \"end device\" in\
    \ the sense described in section 6.1.1 at all;\n   for instance, a user could\
    \ create and upload a CPL script from a\n   non-multimedia-capable web terminal.\n\
    \   The CPL also might not necessarily be created on a device near either\n  \
    \ the end device or the signalling server in network terms. For\n   example, a\
    \ user might decide to forward his or her calls to a remote\n   location only\
    \ after arriving at that location.\n   The exact means by which the end device\
    \ transmits the script to the\n   server remains to be determined; it is likely\
    \ that many solutions\n   will be able to co-exist. This method will need to be\
    \ authenticated\n   in almost all cases.  The methods that have been suggested\
    \ include\n   web file upload, SIP REGISTER message payloads, remote method\n\
    \   invocation, SNMP, ACAP, LDAP, and remote file systems such as NFS.\n   Users\
    \ can also retrieve their current script from the network to an\n   end system\
    \ so it can be edited. The signalling server should also be\n   able to report\
    \ errors related to the script to the user, both static\n   errors that could\
    \ be detected at upload time, and any run-time errors\n   that occur.\n   If a\
    \ user has trust relationships with multiple signalling servers\n   (as discussed\
    \ in section 7.3), the user may choose to upload scripts\n   to any or all of\
    \ those servers. These scripts can be entirely\n   independent.\n"
- title: 9 Feature interaction behavior
  contents:
  - "9 Feature interaction behavior\n   Feature interaction is the term used in telephony\
    \ systems when two or\n   more requested features produce ambiguous or conflicting\
    \ behavior\n   [8]. Feature interaction issues for features implemented with a\
    \ call\n   processing language can be roughly divided into three categories:\n\
    \   feature-to-feature in one server, script-to-script in one server, and\n  \
    \ server-to-server.\n"
- title: 9.1 Feature-to-feature interactions
  contents:
  - "9.1 Feature-to-feature interactions\n   Due to the explicit nature of event conditions\
    \ discussed in the\n   previous section, feature-to-feature interaction is not\
    \ likely to be\n   a problem in a call processing language environment. Whereas\
    \ a\n   subscriber to traditional telephone features might unthinkingly\n   subscribe\
    \ to both \"call waiting\" and \"call forward on busy,\" a user\n   creating a\
    \ CPL script would only be able to trigger one action in\n   response to the condition\
    \ \"a call arrives while the line is busy.\"\n   Given a good user interface for\
    \ creation, or a CPL server which can\n   check for unreachable code in an uploaded\
    \ script, contradictory\n   condition/action pairs can be avoided.\n"
- title: 9.2 Script-to-script interactions
  contents:
  - "9.2 Script-to-script interactions\n   Script-to-script interactions arise when\
    \ a server invokes multiple\n   scripts for a single call, as described in section\
    \ 7.2.  This can\n   occur in a number of cases: if both the call originator and\
    \ the\n   destination have scripts specified on a single server; if a script\n\
    \   forwards a request to another address which also has a script; or if\n   an\
    \ administrative script is specified as well as a user's individual\n   script.\n\
    \   The solution to this interaction is to determine an ordering among\n   the\
    \ scripts to be executed. In this ordering, the \"first\" script is\n   executed\
    \ first; if this script allows or permits the call to be\n   proxied, the script\
    \ corresponding to the next address is executed.\n   When the first script says\
    \ to forward the request to some other\n   address, those actions are considered\
    \ as new requests which arrive at\n   the second script. When the second script\
    \ sends back a final\n   response, that response arrives at the first script in\
    \ the same\n   manner as if a request arrived over the network. Note that in some\n\
    \   cases, forwarding can be recursive; a CPL server must be careful to\n   prevent\
    \ forwarding loops.\n   Abstractly, this can be viewed as equivalent to having\
    \ each script\n   execute on a separate signalling server. Since the CPL architecture\n\
    \   is designed to allow scripts to be executed on multiple signalling\n   servers\
    \ in the course of locating a user, we can conceptually\n   transform script-to-script\
    \ interactions into the server-to-server\n   interactions described in the next\
    \ section, reducing the number of\n   types of interactions we need to concern\
    \ ourselves with.\n   The question, then, is to determine the correct ordering\
    \ of the\n   scripts.  For the case of a script forwarding to an address which\n\
    \   also has a script, the ordering is obvious; the other two cases are\n   somewhat\
    \ more subtle. When both originator and destination scripts\n   exist, the originator's\
    \ script should be executed before the\n   destination script; this allows the\
    \ originator to perform address\n   translation, call filtering, etc., before\
    \ a destination address is\n   determined and a corresponding script is chosen.\n\
    \   Even more complicated is the case of the ordering of administrative\n   scripts.\
    \ Many administrative scripts, such as ones that restrict\n   source and destination\
    \ addresses, need to be run after originator\n   scripts, but before destination\
    \ scripts, to avoid a user's script\n   evading administrative restrictions through\
    \ clever forwarding;\n   however, others, such as a global address book translation\
    \ function,\n   would need to be run earlier or later.  Servers which allow\n\
    \   administrative scripts to be run will need to allow the administrator\n  \
    \ to configure when in the script execution process a particular\n   administrative\
    \ script should fall.\n"
- title: 9.3 Server-to-server interactions
  contents:
  - "9.3 Server-to-server interactions\n   The third case of feature interactions,\
    \ server-to-server\n   interactions, is the most complex of these three. The canonical\n\
    \   example of this type of interaction is the combination of Originating\n  \
    \ Call Screening and Call Forwarding: a user (or administrator) may\n   wish to\
    \ prevent calls from being placed to a particular address, but\n   the local script\
    \ has no way of knowing if a call placed to some\n   other, legitimate address\
    \ will be proxied, by a remote server, to the\n   banned address. This type of\
    \ problem is unsolvable in an\n   administratively heterogeneous network, even\
    \ a \"lightly\"\n   heterogeneous network such as current telephone systems. CPL\
    \ does not\n   claim to solve it, but the problem is not any worse for CPL scripts\n\
    \   than for any other means of deploying services.\n   Another class of server-to-server\
    \ interactions are best resolved by\n   the underlying signalling protocol, since\
    \ they can arise whether the\n   signalling servers are being controlled by a\
    \ call processing language\n   or by some entirely different means. One example\
    \ of this is\n   forwarding loops, where user X may have calls forwarded to Y,\
    \ who has\n   calls forwarded back to X. SIP has a mechanism to detect such loops.\n\
    \   A call processing language server thus does not need to define any\n   special\
    \ mechanisms to prevent such occurrences; it should, however,\n   be possible\
    \ to trigger a different set of call processing actions in\n   the event that\
    \ a loop is detected, and/or to report back an error to\n   the owner of the script\
    \ through some standardized run-time error\n   reporting mechanism.\n"
- title: 9.4 Signalling ambiguity
  contents:
  - "9.4 Signalling ambiguity\n   As an aside, [8] discusses a fourth type of feature\
    \ interaction for\n   traditional telephone networks, signalling ambiguity. This\
    \ can arise\n   when several features overload the same operation in the limited\n\
    \   signal path from an end station to the network: for example, flashing\n  \
    \ the switch-hook can mean both \"add a party to a three-way call\" and\n   \"\
    switch to call waiting.\" Because of the explicit nature of\n   signalling in\
    \ both the Internet telephony protocols discussed here,\n   this issue does not\
    \ arise.\n"
- title: 10 Relationship with existing languages
  contents:
  - "10 Relationship with existing languages\n   This document's description of the\
    \ CPL as a \"language\" is not\n   intended to imply that a new language necessarily\
    \ needs to be\n   implemented from scratch.  A server could potentially implement\
    \ all\n   the functionality described here as a library or set of extensions\n\
    \   for an existing language; Java, or the various freely-available\n   scripting\
    \ languages (Tcl, Perl, Python, Guile), are obvious\n   possibilities.\n   However,\
    \ there are motivations for creating a new language. All the\n   existing languages\
    \ are, naturally, expressively complete; this has\n   two inherent disadvantages.\
    \ The first is that any function\n   implemented in them can take an arbitrarily\
    \ long time, use an\n   arbitrarily large amount of memory, and may never terminate.\
    \ For call\n   processing, this sort of resource usage is probably not necessary,\n\
    \   and as described in section 12.1, may in fact be undesirable. One\n   model\
    \ for this is the electronic mail filtering language Sieve [4],\n   which deliberately\
    \ restricts itself from being Turing-complete.\n   Similar levels of safety and\
    \ protection (though not automatic\n   generation and parsing) could also be achieved\
    \ through the use of a\n   \"sandbox\" such as is used by Java applets, where\
    \ strict bounds are\n   imposed on the amount of memory, cpu time, stack space,\
    \ etc., that a\n   program can use. The difficulty with this approach is primarily\
    \ in\n   its lack of transparency and portability:  unless the levels of these\n\
    \   bounds are imposed by the standard, a bad idea so long as available\n   resources\
    \ are increasing exponentially with Moore's Law, a user can\n   never be sure\
    \ whether a particular program can successfully be\n   executed on a given server\
    \ without running into the server's resource\n   limits, and a program which executes\
    \ successfully on one server may\n   fail unexpectedly on another. Non-expressively-complete\
    \ languages, on\n   the other hand, allow an implicit contract between the script\
    \ writer\n   and the server:  so long as the script stays within the rules of\
    \ the\n   language, the server will guarantee that it will execute the script.\n\
    \   The second disadvantage with expressively complete languages is that\n   they\
    \ make automatic generation and parsing of scripts very difficult,\n   as every\
    \ parsing tool must be a full interpreter for the language. An\n   analogy can\
    \ be drawn from the document-creation world: while text\n   markup languages like\
    \ HTML or XML can be, and are, easily manipulated\n   by smart editors, powerful\
    \ document programming languages such as\n   LaTeX or Postscript usually cannot\
    \ be. While there are word\n   processors that can save their documents in LaTeX\
    \ form, they cannot\n   accept as input arbitrary LaTeX documents, let alone preserve\
    \ the\n   structure of the original document in an edited form. By contrast,\n\
    \   essentially any HTML editor can edit any HTML document from the web,\n   and\
    \ the high-quality ones preserve the structure of the original\n   documents in\
    \ the course of editing them.\n"
- title: 11 Related work
  contents:
  - '11 Related work

    '
- title: 11.1 IN service creation environments
  contents:
  - "11.1 IN service creation environments\n   The ITU's IN series describe, on an\
    \ abstract level, service creation\n   environments [6]. These describe services\
    \ in a traditional circuit-\n   switched telephone network as a series of decisions\
    \ and actions\n   arranged in a directed acyclic graph. Many vendors of IN services\
    \ use\n   modified and extended versions of this for their proprietary service\n\
    \   creation environments.\n"
- title: 11.2 SIP CGI
  contents:
  - "11.2 SIP CGI\n   SIP CGI [9] is an interface for implementing services on SIP\
    \ servers.\n   Unlike a CPL, it is a very low-level interface, and would not be\n\
    \   appropriate for services written by non-trusted users.\n   The paper \"Programming\
    \ Internet Telephony Services\" [10] discusses\n   the similarities and contrasts\
    \ between SIP CGI and CPL in more\n   detail.\n"
- title: 12 Necessary language features
  contents:
  - "12 Necessary language features\n   This section lists those properties of a call\
    \ processing language\n   which we believe to be necessary to have in order to\
    \ implement the\n   motivating examples, in line with the described architecture.\n"
- title: 12.1 Language characteristics
  contents:
  - "12.1 Language characteristics\n   These are some abstract attributes which any\
    \ proposed call processing\n   language should possess.\n      o  Light-weight,\
    \ efficient, easy to implement\n         In addition to the general reasons why\
    \ this is desirable, a\n         network server might conceivably handle very\
    \ large call\n         volumes, and we don't want CPL execution to be a major\n\
    \         bottleneck. One way to achieve this might be to compile scripts\n  \
    \       before execution.\n      o  Easily verifiable for correctness\n      \
    \   For a script which runs in a server, mis-configurations can\n         result\
    \ in a user becoming unreachable, making it difficult to\n         indicate run-time\
    \ errors to a user (though a second-channel\n         error reporting mechanism\
    \ such as e-mail could ameliorate\n         this). Thus, it should be possible\
    \ to verify, when the script\n         is committed to the server, that it is\
    \ at least syntactically\n         correct, does not have any obvious loops or\
    \ other failure\n         modes, and does not use too many server resources.\n\
    \      o  Executable in a safe manner\n         No action the CPL script takes\
    \ should be able to subvert\n         anything about the server which the user\
    \ shouldn't have access\n         to, or affect the state of other users without\
    \ permission.\n         Additionally, since CPL scripts will typically run on\
    \ a server\n         on which users cannot normally run code, either the language\
    \ or\n         its execution environment must be designed so that scripts\n  \
    \       cannot use unlimited amounts of network resources, server CPU\n      \
    \   time, storage, or memory.\n      o  Easily writeable and parsable by both\
    \ humans and machines.\n         For maximum flexibility, we want to allow humans\
    \ to write their\n         own scripts, or to use and customize script libraries\
    \ provided\n         by others. However, most users will want to have a more\n\
    \         intuitive user-interface for the same functionality, and so\n      \
    \   will have a program which creates scripts for them.  Both cases\n        \
    \ should be easy; in particular, it should be easy for script\n         editors\
    \ to read human-generated scripts, and vice-versa.\n      o  Extensible\n    \
    \     It should be possible to add additional features to a language\n       \
    \  in a way that existing scripts continue to work, and existing\n         servers\
    \ can easily recognize features they don't understand and\n         safely inform\
    \ the user of this fact.\n      o  Independent of underlying signalling details\n\
    \         The same scripts should be usable whether the underlying\n         protocol\
    \ is SIP, H.323, a traditional telephone network, or any\n         other means\
    \ of setting up calls. It should also be agnostic to\n         address formats.\
    \ (We use SIP terminology in our descriptions of\n         requirements, but this\
    \ should map fairly easily to other\n         systems.) It may also be useful\
    \ to have the language extend to\n         processing of other sorts of communication,\
    \ such as e-mail or\n         fax.\n"
- title: 12.2 Base features -- call signalling
  contents:
  - "12.2 Base features -- call signalling\n   To be useful, a call processing language\
    \ obviously should be able to\n   react to and initiate call signalling events.\n\
    \      o  Should execute actions when a call request arrives\n         See section\
    \ 7, particularly 7.1.\n      o  Should be able to make decisions based on event\
    \ properties\n         A number of properties of a call event are relevant for\
    \ a\n         script's decision process. These include, roughly in order of\n\
    \         importance:\n         -  Destination address\n            We want to\
    \ be able to do destination-based routing or\n            screening.  Note that\
    \ in SIP we want to be able to filter on\n            either or both of the addresses\
    \ in the To header and the\n            Request-URI.\n         -  Originator address\n\
    \            Similarly, we want to be able to do originator-based\n          \
    \  screening or routing.\n         -  Caller Preferences\n            In SIP,\
    \ a caller can express preferences about the type of\n            device to be\
    \ reached -- see [11]. The script should be able\n            to make decisions\
    \ based on this information.\n         -  Information about caller or call\n \
    \           SIP has textual fields such as Subject, Organization,\n          \
    \  Priority, etc., and a display name for addresses; users can\n            also\
    \ add non-standard additional headers. H.323 has a single\n            Display\
    \ field. The script should be able to make decisions\n            based on these\
    \ parameters.\n         -  Media description\n            Call invitations specify\
    \ the types of media that will flow,\n            their bandwidth usage, their\
    \ network destination addresses,\n            etc. The script should be able to\
    \ make decisions based on\n            these media characteristics.\n        \
    \ -  Authentication/encryption status\n            Call invitations can be authenticated.\
    \ Many properties of\n            the authentication are relevant: the method\
    \ of\n            authentication/encryption, who performed the authentication,\n\
    \            which specific fields were encrypted, etc.  The script\n        \
    \    should be able to make decisions based on these security\n            parameters.\n\
    \      o  Should be able to take action based on a call invitation\n         There\
    \ are a number of actions we can take in response to an\n         incoming call\
    \ setup request. We can:\n         -  reject it\n            We should be able\
    \ to indicate that the call is not\n            acceptable or not able to be completed.\
    \ We should also be\n            able to send more specific rejection codes (including,\
    \ for\n            SIP, the associated textual string, warning codes, or\n   \
    \         message payload).\n         -  redirect it\n            We should be\
    \ able to tell the call initiator sender to try a\n            different location.\n\
    \         -  proxy it\n            We should be able to send the call invitation\
    \ on to another\n            location, or to several other locations (\"forking\"\
    \ the\n            invitation), and await the responses. It should also be\n \
    \           possible to specify a timeout value after which we give up\n     \
    \       on receiving any definitive responses.\n      o  Should be able to take\
    \ action based a response to a proxied or\n         forked call invitation\n \
    \        Once we have proxied an invitation, we need to be able to make\n    \
    \     decisions based on the responses we receive to that invitation\n       \
    \  (or the lack thereof).  We should be able to:\n         -  consider its message\
    \ fields\n            We should be able to consider the same fields of a response\n\
    \            as we consider in the initial invitation.\n         -  relay it on\
    \ to the call originator\n            If the response is satisfactory, it should\
    \ be returned to\n            the sender.\n         -  for a fork, choose one\
    \ of several responses to relay back\n            If we forked an invitation,\
    \ we obviously expect to receive\n            several responses. There are several\
    \ issues here -- choosing\n            among the responses, and how long to wait\
    \ if we've received\n            responses from some but not all destinations.\n\
    \         -  initiate other actions\n            If we didn't get a response,\
    \ or any we liked, we should be\n            able to try something else instead\
    \ (e.g., call forward on\n            busy).\n"
- title: 12.3 Base features -- non-signalling
  contents:
  - "12.3 Base features -- non-signalling\n   A number of other features that a call\
    \ processing language should\n   have do not refer to call signalling per se;\
    \ however, they are still\n   extremely desirable to implement many useful features.\n\
    \   The servers which provide these features might reside in other\n   Internet\
    \ devices, or might be local to the server (or other\n   possibilities). The language\
    \ should be independent of the location of\n   these servers, at least at a high\
    \ level.\n      o  Logging\n         In addition to the CPL server's natural logging\
    \ of events, the\n         user will also want to be able to log arbitrary other\
    \ items.\n         The actual storage for this logging information might live\n\
    \         either locally or remotely.\n      o  Error reporting\n         If an\
    \ unexpected error occurs, the script should be able to\n         report the error\
    \ to the script's owner. This may use the same\n         mechanism as the script\
    \ server uses to report language errors\n         to the user (see section 12.5).\n\
    \      o  Access to user-location info\n         Proxies will often collect information\
    \ on users' current\n         location, either through SIP REGISTER messages,\
    \ the H.323 RRQ\n         family of RAS messages, or some other mechanism (see\
    \ section\n         6.2). The CPL should be able to refer to this information\
    \ so a\n         call can be forwarded to the registered locations or some\n \
    \        subset of them.\n      o  Database access\n         Much information\
    \ for CPL control might be stored in external\n         databases, for example\
    \ a wide-area address database, or\n         authorization information, for a\
    \ CPL under administrative\n         control. The language could specify some\
    \ specific database\n         access protocols (such as SQL or LDAP), or could\
    \ be more\n         generic.\n      o  Other external information\n         Other\
    \ external information a script could access includes web\n         pages, which\
    \ could be sent back in a SIP message body; or a\n         clean interface to\
    \ remote procedure calls such as Corba, RMI,\n         or DCOM, for instance to\
    \ access an external billing database.\n         However, for simplicity, these\
    \ interfaces may not be in the\n         initial version of the protocol.\n"
- title: 12.4 Language features
  contents:
  - "12.4 Language features\n   Some features do not involve any operations external\
    \ to the CPL's\n   execution environment, but are still necessary to allow some\
    \ standard\n   services to be implemented. (This list is not exhaustive.)\n  \
    \    o  Pattern-matching\n         It should be possible to give special treatment\
    \ to addresses\n         and other text strings based not only on the full string\
    \ but\n         also on more general or complex sub-patterns of them.\n      o\
    \  Address filtering\n         Once a set of addresses has been retrieved through\
    \ one of the\n         methods in section 12.3, the user needs to be able to choose\
    \ a\n         sub-set of them, based on their address components or other\n  \
    \       parameters.\n      o  Randomization\n         Some forms of call distribution\
    \ are randomized as to where they\n         actually end up.\n      o  Date/time\
    \ information\n         Users may wish to condition some services (e.g., call\n\
    \         forwarding, call distribution) on the current time of day, day\n   \
    \      of the week, etc.\n"
- title: 12.5 Control
  contents:
  - "12.5 Control\n   As described in section 8, we must have a mechanism to send\
    \ and\n   retrieve CPL scripts, and associated data, to and from a signalling\n\
    \   server. This method should support reporting upload-time errors to\n   users;\
    \ we also need some mechanism to report errors to users at\n   script execution\
    \ time. Authentication is vital, and encryption is\n   very useful. The specification\
    \ of this mechanism can be (and probably\n   ought to be) a separate specification\
    \ from that of the call\n   processing language itself.\n"
- title: 13 Security Considerations
  contents:
  - "13 Security Considerations\n   The security considerations of transferring CPL\
    \ scripts are discussed\n   in sections 8 and 12.5. Some considerations about\
    \ the execution of\n   the language are discussed in section 12.1.\n"
- title: 14 Acknowledgments
  contents:
  - "14 Acknowledgments\n   We would like to thank Tom La Porta and Jonathan Rosenberg\
    \ for their\n   comments and suggestions.\n"
- title: 15 Authors' Addresses
  contents:
  - "15 Authors' Addresses\n   Jonathan Lennox\n   Dept. of Computer Science\n   Columbia\
    \ University\n   1214 Amsterdam Avenue, MC 0401\n   New York, NY 10027\n   USA\n\
    \   EMail: lennox@cs.columbia.edu\n   Henning Schulzrinne\n   Dept. of Computer\
    \ Science\n   Columbia University\n   1214 Amsterdam Avenue, MC 0401\n   New York,\
    \ NY 10027\n   USA\n   EMail: schulzrinne@cs.columbia.edu\n"
- title: 16 Bibliography
  contents:
  - "16 Bibliography\n   [1]  Handley, M., Schulzrinne, H., Schooler, E. and J. Rosenberg,\n\
    \        \"SIP: Session Initiation Protocol\", RFC 2543, March 1999.\n   [2] \
    \ International Telecommunication Union, \"Packet based multimedia\n        communication\
    \ systems,\" Recommendation H.323, Telecommunication\n        Standardization\
    \ Sector of ITU, Geneva, Switzerland, Feb. 1998.\n   [3]  K. Coar and D. Robinson,\
    \ \"The WWW common gateway interface\n        version 1.1\", Work in Progress.\n\
    \   [4]  T. Showalter, \"Sieve: A mail filtering language\", Work in\n       \
    \ Progress.\n   [5]  J. Lennox and H. Schulzrinne, \"CPL: a language for user\
    \ control\n        of internet telephony services\", Work in Progress.\n   [6]\
    \  International Telecommunication Union, \"General recommendations\n        on\
    \ telephone switching and signaling -- intelligent network:\n        Introduction\
    \ to intelligent network capability set 1,\"\n        Recommendation Q.1211, Telecommunication\
    \ Standardization Sector\n        of ITU, Geneva, Switzerland, Mar. 1993.\n  \
    \ [7]  Guttman, E., Perkins, C., Veizades, J. and M. Day, \"Service\n        Location\
    \ Protocol, Version 2\", RFC 2608, June 1999.\n   [8]  E. J. Cameron, N. D. Griffeth,\
    \ Y.-J. Lin, M. E. Nilson, W. K.\n        Schure, and H. Velthuijsen, \"A feature\
    \ interaction benchmark for\n        IN and beyond,\" Feature Interactions in\
    \ Telecommunications\n        Systems, IOS Press, pp. 1-23, 1994.\n   [9]  J.\
    \ Lennox, J. Rosenberg, and H. Schulzrinne, \"Common gateway\n        interface\
    \ for SIP\", Work in Progress.\n   [10] J. Rosenberg, J. Lennox, and H. Schulzrinne,\
    \ \"Programming\n        internet telephony services,\" Technical Report CUCS-010-99,\n\
    \        Columbia University, New York, New York, Mar. 1999.\n   [11] H. Schulzrinne\
    \ and J. Rosenberg, \"SIP caller preferences and\n        callee capabilities\"\
    , Work in Progress.\n"
- title: 17 Full Copyright Statement
  contents:
  - "17 Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
