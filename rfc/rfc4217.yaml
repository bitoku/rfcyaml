- title: __initial_text__
  contents:
  - '                         Securing FTP with TLS

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a mechanism that can be used by FTP clients\n\
    \   and servers to implement security and authentication using the TLS\n   protocol\
    \ defined by RFC 2246, \"The TLS Protocol Version 1.0.\", and\n   the extensions\
    \ to the FTP protocol defined by RFC 2228, \"FTP Security\n   Extensions\".  It\
    \ describes the subset of the extensions that are\n   required and the parameters\
    \ to be used, discusses some of the policy\n   issues that clients and servers\
    \ will need to take, considers some of\n   the implications of those policies,\
    \ and discusses some expected\n   behaviours of implementations to allow interoperation.\
    \  This document\n   is intended to provide TLS support for FTP in a similar way\
    \ to that\n   provided for SMTP in RFC 2487, \"SMTP Service Extension for Secure\n\
    \   SMTP over Transport Layer Security\", and HTTP in RFC 2817, \"Upgrading\n\
    \   to TLS Within HTTP/1.1.\".\n   This specification is in accordance with RFC\
    \ 959, \"File Transfer\n   Protocol\".  It relies on RFC 2246, \"The TLS Protocol\
    \ Version 1.0.\",\n   and RFC 2228, \"FTP Security Extensions\".\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Audience ........................................................5\n  \
    \ 3. Overview ........................................................5\n   4.\
    \ Session Negotiation on the Control Port .........................5\n      4.1.\
    \ Client Wants a Secured Session .............................5\n      4.2. Server\
    \ Wants a Secured Session .............................6\n   5. Clearing the Control\
    \ Port .......................................6\n   6. Response to the FEAT Command\
    \ ....................................7\n   7. Data Connection Behaviour .......................................8\n\
    \   8. Mechanisms for the AUTH Command .................................9\n  \
    \ 9. Data Connection Security ........................................9\n   10.\
    \ A Discussion of Negotiation Behaviour .........................11\n      10.1.\
    \ The Server's View of the Control Connection ..............11\n      10.2. The\
    \ Server's View of the Data Connection .................12\n      10.3. The Client's\
    \ View of the Control Connection ..............14\n      10.4. The Client's View\
    \ of the Data Connection .................15\n   11. Who Negotiates What, Where,\
    \ and How ...........................15\n      11.1. Do we protect at all? ....................................15\n\
    \      11.2. What level of protection do we use on the Control\n            connection?\
    \ ..............................................15\n      11.3. Do we protect\
    \ data connections in general? ...............16\n      11.4. Is protection required\
    \ for a particular data transfer? ...16\n      11.5. What level of protection\
    \ is required for a\n            particular data ..........................................16\n\
    \   12. Timing Diagrams ...............................................16\n  \
    \    12.1. Establishing a Protected Session .........................17\n    \
    \  12.2. Establishing a Protected Session Without a\n            Password Request\
    \ .........................................18\n      12.3. Establishing a Protected\
    \ Session and then\n            Clearing with the CCC ....................................19\n\
    \      12.4. A Standard Data Transfer Without Protection ..............20\n  \
    \    12.5. A Firewall-Friendly Data Transfer Without Protection .....20\n    \
    \  12.6. A Standard Data Transfer with Protection .................21\n      12.7.\
    \ A Firewall-Friendly Data Transfer with Protection ........21\n   13. Discussion\
    \ of the REIN Command ................................22\n   14. Discussion of\
    \ the STAT and ABOR Commands ......................22\n   15. Security Considerations\
    \ .......................................23\n      15.1. Verification of Authentication\
    \ Tokens ....................23\n           15.1.1. Server Certificates ...............................23\n\
    \           15.1.2. Client Certificates ...............................23\n  \
    \    15.2. Addressing FTP Security Considerations [RFC-2577] ........24\n    \
    \       15.2.1. Bounce Attack .....................................24\n      \
    \     15.2.2. Restricting Access ................................24\n        \
    \   15.2.3. Protecting Passwords ..............................24\n          \
    \ 15.2.4. Privacy ...........................................24\n           15.2.5.\
    \ Protecting Usernames ..............................24\n           15.2.6. Port\
    \ Stealing .....................................25\n           15.2.7. Software-Based\
    \ Security Problems ..................25\n      15.3. Issues with the CCC Command\
    \ ..............................25\n   16. IANA Considerations ...........................................25\n\
    \   17. Other Parameters ..............................................25\n  \
    \ 18. Scalability and Limits ........................................26\n   19.\
    \ Applicability .................................................26\n   20. Acknowledgements\
    \ ..............................................26\n   21. References ....................................................26\n\
    \      21.1. Normative References .....................................26\n  \
    \    21.2. Informative References ...................................27\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes how three other documents should\
    \ be combined\n   to provide a useful, interoperable, and secure file transfer\n\
    \   protocol.  Those documents are:\n      RFC 959 [RFC-959]\n         The description\
    \ of the Internet File Transfer Protocol.\n      RFC 2246 [RFC-2246]\n       \
    \  The description of the Transport Layer Security protocol\n         (developed\
    \ from the Netscape Secure Sockets Layer (SSL)\n         protocol version 3.0).\n\
    \      RFC 2228 [RFC-2228]\n         Extensions to the FTP protocol to allow negotiation\
    \ of security\n         mechanisms to allow authentication, confidentiality, and\n\
    \         message integrity.\n   This document is intended to provide TLS support\
    \ for FTP in a similar\n   way to that provided for SMTP in RFC 3207 [RFC-3207]\
    \ and HTTP in RFC\n   2817 [RFC-2817].\n   The security extensions to FTP in [RFC-2228]\
    \ offer a comprehensive\n   set of commands and responses that can be used to\
    \ add authentication,\n   integrity, and confidentiality to the FTP protocol.\
    \  The TLS protocol\n   is a popular (due to its wholesale adoption in the HTTP\
    \ environment)\n   mechanism for generally securing a socket connection.\n   Although\
    \ TLS is not the only mechanism for securing file transfer, it\n   does offer\
    \ some of the following positive attributes:\n      - Flexible security levels.\
    \  TLS can support confidentiality,\n        integrity, authentication, or some\
    \ combination of all of these.\n        During a session, this allows clients\
    \ and servers to dynamically\n        decide on the level of security required\
    \ for a particular data\n        transfer.\n      - Ability to provide strong\
    \ authentication of the FTP server.\n      - It is possible to use TLS identities\
    \ to authenticate client\n        users and client hosts.\n      - Formalised\
    \ public key management.  By use of well established\n        client identity\
    \ mechanisms (supported by TLS) during the\n        authentication phase, certificate\
    \ management may be built into a\n        central function.  Whilst this may not\
    \ be desirable for all uses\n        of secured file transfer, it offers advantages\
    \ in certain\n        structured environments.\n      - Co-existence and interoperation\
    \ with authentication mechanisms\n        that are already in place for the HTTPS\
    \ protocol.  This allows\n        web browsers to incorporate secure file transfer\
    \ using the same\n        infrastructure that has been set up to allow secure\
    \ web\n        browsing.\n   The TLS protocol is a development of the Netscape\
    \ Communication\n   Corporation's SSL protocol and this document can be used to\
    \ allow the\n   FTP protocol to be used with either SSL or TLS.  The actual protocol\n\
    \   used will be decided by the negotiation of the protected session by\n   the\
    \ TLS/SSL layer.  This document will only refer to the TLS\n   protocol; however,\
    \ it is understood that the Client and Server MAY\n   actually be using SSL if\
    \ they are so configured.\n   There are many ways in which these three protocols\
    \ can be combined.\n   This document selects one method by which FTP can operate\
    \ securely,\n   while providing both flexibility and interoperation.  This\n \
    \  necessitates a brief description of the actual negotiation mechanism,\n   a\
    \ detailed description of the required policies and practices, and a\n   discussion\
    \ of the expected behaviours of clients and servers to allow\n   either party\
    \ to impose their security requirements on the FTP\n   session.\n   The key words\
    \ \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\"\
    , \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\" and \"OPTIONAL\" that\n   appear in\
    \ this document are to be interpreted as described in\n   [RFC-2119].\n"
- title: 2.  Audience
  contents:
  - "2.  Audience\n   This document is aimed at developers who wish to implement TLS\
    \ as a\n   security mechanism to secure FTP clients and/or servers.\n   Systems\
    \ administrators and architects should be fully aware of the\n   security implications\
    \ discussed in [RFC-2228], which need to be\n   considered when choosing an implementation\
    \ of this protocol and\n   configuring it to provide their required security.\n"
- title: 3.  Overview
  contents:
  - "3.  Overview\n   A full description of the FTP security protocol enhancements\
    \ is\n   contained in [RFC-2228].  This document describes how the AUTH, PROT,\n\
    \   PBSZ, and CCC commands, defined therein, should be implemented with\n   the\
    \ TLS protocol.\n   In summary, an FTP session is established on the normal control\
    \ port.\n   A client requests TLS with the AUTH command and then decides if it\n\
    \   wishes to secure the data connections by use of the PBSZ and PROT\n   commands.\
    \  Should a client wish to make the control connection revert\n   back into plaintext\
    \ (for example, once the authentication phase is\n   completed), then the CCC\
    \ command can be used.\n   Implementation of this protocol extension does not\
    \ ensure that each\n   and every session and data transfer is secure, it merely\
    \ provides the\n   tools that allow a client and/or server to negotiate an acceptable\
    \ or\n   required level of security for that given session or data transfer.\n\
    \   However, it is possible to have a server implementation that is\n   capable\
    \ of refusing to operate in an insecure fashion.\n"
- title: 4.  Session Negotiation on the Control Port
  contents:
  - "4.  Session Negotiation on the Control Port\n   The server listens on the normal\
    \ FTP control port {FTP-PORT} and the\n   session initiation is not secured at\
    \ all.  Once the client wishes to\n   secure the session, the AUTH command is\
    \ sent and the server MAY then\n   allow TLS negotiation to take place.\n"
- title: 4.1.  Client Wants a Secured Session
  contents:
  - "4.1.  Client Wants a Secured Session\n   If a client wishes to attempt to secure\
    \ a session, then it SHOULD, in\n   accordance with [RFC-2228], send the AUTH\
    \ command with the parameter\n   requesting TLS {TLS-PARM} ('TLS').\n   The client\
    \ then needs to behave according to its policies depending\n   on the response\
    \ received from the server and also the result of the\n   TLS negotiation.  A\
    \ client that receives an AUTH rejection MAY choose\n   to continue with the session\
    \ unprotected if it so desires.\n"
- title: 4.2.  Server Wants a Secured Session
  contents:
  - "4.2.  Server Wants a Secured Session\n   The FTP protocol does not allow a server\
    \ to directly dictate client\n   behaviour; however, the same effect can be achieved\
    \ by refusing to\n   accept certain FTP commands until the session is secured\
    \ to a level\n   that is acceptable to the server.\n   In either case, '234' is\
    \ the server response to an 'AUTH TLS' command\n   that it will honour.\n   The\
    \ '334' response, as defined in [RFC-2228], implies that an ADAT\n   exchange\
    \ will follow.  This document does not use the ADAT command\n   and so the '334'\
    \ reply is incorrect.\n   The FTP protocol insists that a USER command be used\
    \ to identify the\n   entity attempting to use the ftp server.  Although the TLS\n\
    \   negotiation may be providing authentication information, the USER\n   command\
    \ MUST still be issued by the client.  However, it will be a\n   server implementation\
    \ issue to decide which credentials to accept and\n   what consistency checks\
    \ to make between the client cert used and the\n   parameter on the USER command.\n\
    \   [RFC-2228] states that the user must reauthorize (that is, reissue\n   some\
    \ or all of the USER, PASS, and ACCT commands) following an AUTH\n   command.\
    \  Additionally, this document specifies that all other\n   transfer parameters\
    \ (other than the AUTH parameter) must be reset,\n   almost as if a REIN command\
    \ was issued.\n      Reset transfer parameters after the AUTH command, including\
    \ (but\n      are not limited to): user identity, default data ports, TYPE,\n\
    \      STRU, MODE, and current working directory.\n"
- title: 5.  Clearing the Control Port
  contents:
  - "5.  Clearing the Control Port\n   There are circumstances in which it may be\
    \ desirable to protect the\n   control connection only during part of the session\
    \ and then to revert\n   back to a plaintext connection.  This is often due to\
    \ the limitations\n   of boundary devices such as NAT and firewalls, which expect\
    \ to be\n   able to examine the content of the control connection in order to\n\
    \   modify their behaviour.\n   Typically the AUTH, USER, PASS, PBSZ, and PROT\
    \ commands would be\n   protected within the TLS protocol and then the CCC command\
    \ would be\n   issued to return to a plaintext socket state.  This has important\n\
    \   Security Issues (which are discussed in the Security Considerations\n   section),\
    \ but this document describes how the command should be used,\n   if the client\
    \ and server still wish to use it after having considered\n   the issues.\n  \
    \ When a server receives the CCC command, it should behave as follows:\n     \
    \ If the server does not accept CCC commands (or does not understand\n      them),\
    \ then a 500 reply should be sent.\n      Otherwise, if the control connection\
    \ is not protected with TLS,\n      then a 533 reply should be sent.\n      Otherwise,\
    \ if the server does not wish to allow the control\n      connection to be cleared\
    \ at this time, then a 534 reply should be\n      sent.\n      Otherwise, the\
    \ server is accepting the CCC command and should do\n      the following:\n  \
    \       o  Send a 200 reply.\n         o  Shutdown the TLS session on the socket\
    \ and leave it open.\n         o  Continue the control connection in plaintext,\
    \ expecting the\n            next command from the client to be in plaintext.\n\
    \         o  Not accept any more PBSZ or PROT commands.  All subsequent\n    \
    \        data transfers must be protected with the current PROT\n            settings.\n"
- title: 6.  Response to the FEAT Command
  contents:
  - "6.  Response to the FEAT Command\n   The FEAT command (introduced in [RFC-2389])\
    \ allows servers with\n   additional features to advertise these to a client by\
    \ responding to\n   the FEAT command.  If a server supports the FEAT command,\
    \ then it\n   MUST advertise supported AUTH, PBSZ, and PROT commands in the reply,\n\
    \   as described in section 3.2 of [RFC-2389].  Additionally, the AUTH\n   command\
    \ should have a reply that identifies 'TLS' as one of the\n   possible parameters\
    \ to AUTH.  It is not necessary to identify the\n   'TLS-C' synonym separately.\n\
    \   Example reply (in the same style as [RFC-2389])\n      C> FEAT\n      S> 211-Extensions\
    \ supported\n      S>  AUTH TLS\n      S>  PBSZ\n      S>  PROT\n      S> 211\
    \ END\n"
- title: 7.  Data Connection Behaviour
  contents:
  - "7.  Data Connection Behaviour\n   The Data Connection in the FTP model can be\
    \ used in one of three\n   ways.  (Note: These descriptions are not necessarily\
    \ placed in exact\n   chronological order, but do describe the steps required.\
    \  See\n   diagrams later for clarification.)\n            i) Classic FTP client/server\
    \ data exchange\n                 - The client obtains a port; sends the port\
    \ number to\n                   the server; the server connects to the client.\
    \  The\n                   client issues a send or receive request to the server\n\
    \                   on the control connection and the data transfer\n        \
    \           commences on the data connection.\n          ii) Firewall-Friendly\
    \ client/server data exchange (as\n              discussed in [RFC-1579]) using\
    \ the PASV command to reverse\n              the direction of the data connection.\n\
    \                 - The client requests that the server open a port; the\n   \
    \                server obtains a port and returns the address and\n         \
    \          port number to the client; the client connects to the\n           \
    \        server on this port.  The client issues a send or\n                 \
    \  receive request on the control connection, and the\n                   data\
    \ transfer commences on the data connection.\n         iii) Client-initiated server/server\
    \ data exchange (proxy or\n              PASV connections).\n                \
    \ - The client requests that server A opens a port;\n                   server\
    \ A obtains a port and returns it to the client;\n                   the client\
    \ sends this port number to server B.\n                   Server B connects to\
    \ server A.  The client sends a\n                   send or receive request to\
    \ server A and the\n                   complement to server B and the data transfer\n\
    \                   commences.  In this model, server A is the proxy or\n    \
    \               PASV host and is a client for the Data Connection to\n       \
    \            server B.\n   For i) and ii), the FTP client MUST be the TLS client\
    \ and the FTP\n   server MUST be the TLS server.\n   That is to say, it does not\
    \ matter which side initiates the\n   connection with a connect() call or which\
    \ side reacts to the\n   connection via the accept() call; the FTP client, as\
    \ defined in\n   [RFC-959], is always the TLS client, as defined in [RFC-2246].\n\
    \   In scenario iii), there is a problem in that neither server A nor\n   server\
    \ B is the TLS client, given the fact that an FTP server must\n   act as a TLS\
    \ server for Firewall-Friendly FTP [RFC-1579].  Thus, this\n   is explicitly excluded\
    \ in the security extensions document [RFC-2228]\n   and in this document.\n"
- title: 8.  Mechanisms for the AUTH Command
  contents:
  - "8.  Mechanisms for the AUTH Command\n   The AUTH command takes a single parameter\
    \ to define the security\n   mechanism to be negotiated.  As the SSL/TLS protocols\
    \ self-negotiate\n   their levels, there is no need to distinguish between SSL\
    \ and TLS in\n   the application layer.  The mechanism name for negotiating TLS\
    \ is the\n   character string identified in {TLS-PARM}.  This allows the client\n\
    \   and server to negotiate TLS on the control connection without\n   altering\
    \ the protection of the data channel.  To protect the data\n   channel as well,\
    \ the PBSZ command, followed by the PROT command\n   sequence, MUST be used.\n\
    \   Note: The data connection state MAY be modified by the client issuing\n  \
    \ the PROT command with the new desired level of data channel\n   protection and\
    \ the server replying in the affirmative.  This data\n   channel protection negotiation\
    \ can happen at any point in the session\n   (even straight after a PORT or PASV\
    \ command) and as often as is\n   required.\n   See also Section 16, \"IANA Considerations\"\
    .\n"
- title: 9.  Data Connection Security
  contents:
  - "9.  Data Connection Security\n   The Data Connection security level is determined\
    \ by the PROT command.\n      The PROT command, as specified in [RFC-2228], allows\
    \ client/server\n      negotiation of the security level of the data connection.\
    \  Once a\n      PROT command has been issued by the client and accepted by the\n\
    \      server returning the '200' reply, the security of subsequent data\n   \
    \   connections MUST be at that level until another PROT command is\n      issued\
    \ and accepted; the session ends and a REIN command is\n      issued, or the security\
    \ of the session (via an AUTH command) is\n      re-negotiated.\n   Data Connection\
    \ Security Negotiation (the PROT command)\n      Note: In line with [RFC-2228],\
    \ there is no facility for securing\n      the Data connection with an insecure\
    \ Control connection.\n      Specifically, the PROT command MUST be preceded by\
    \ a PBSZ command,\n      and a PBSZ command MUST be preceded by a successful security\
    \ data\n      exchange (the TLS negotiation in this case).\n      The command\
    \ defined in [RFC-2228] to negotiate data connection\n      security is the PROT\
    \ command.  As defined, there are four values\n      that the PROT command parameter\
    \ can take.\n            'C' - Clear - neither Integrity nor Privacy\n       \
    \     'S' - Safe - Integrity without Privacy\n            'E' - Confidential -\
    \ Privacy without Integrity\n            'P' - Private - Integrity and Privacy\n\
    \      As TLS negotiation encompasses (and exceeds) the Safe /\n      Confidential\
    \ / Private distinction, only Private (use TLS) and\n      Clear (don't use TLS)\
    \ are used.\n      For TLS, the data connection can have one of two security levels.\n\
    \            1) Clear (requested by 'PROT C')\n            2) Private (requested\
    \ by 'PROT P')\n      With 'Clear' protection level, the data connection is made\
    \ without\n      TLS.  Thus, the connection is unauthenticated and has no\n  \
    \    confidentiality or integrity.  This might be the desired behaviour\n    \
    \  for servers sending file lists, pre-encrypted data, or non-\n      sensitive\
    \ data (e.g., for anonymous FTP servers).\n      If the data connection security\
    \ level is 'Private', then a TLS\n      negotiation must take place on the data\
    \ connection to the\n      satisfaction of the Client and Server prior to any\
    \ data being\n      transmitted over the connection.  The TLS layers of the Client\
    \ and\n      Server will be responsible for negotiating the exact TLS Cipher\n\
    \      Suites that will be used (and thus the eventual security of the\n     \
    \ connection).\n      In addition, the PBSZ (protection buffer size) command,\
    \ as\n      detailed in [RFC-2228], is compulsory prior to any PROT command.\n\
    \      This document also defines a data channel encapsulation mechanism\n   \
    \   for protected data buffers.  For FTP-TLS, which appears to the FTP\n     \
    \ application as a streaming protection mechanism, this is not\n      required.\
    \  Thus, the PBSZ command MUST still be issued, but must\n      have a parameter\
    \ of '0' to indicate that no buffering is taking\n      place and the data connection\
    \ should not be encapsulated.\n      Note that PBSZ 0 is not in the grammar of\
    \ [RFC-2228], section 8.1,\n      where it is stated:\n         PBSZ <sp> <decimal-integer>\
    \ <CRLF> <decimal-integer> ::= any\n         decimal integer from 1 to (2^32)-1\n\
    \      However, it should be noted that using a value of '0' to mean a\n     \
    \ streaming protocol is a reasonable use of '0' for that parameter\n      and\
    \ is not ambiguous.\n   Initial Data Connection Security\n      The initial state\
    \ of the data connection MUST be 'Clear' (this is\n      the behaviour as indicated\
    \ by [RFC-2228]).\n"
- title: 10.  A Discussion of Negotiation Behaviour
  contents:
  - "10.  A Discussion of Negotiation Behaviour\n   As [RFC-2228] allows security\
    \ qualities to be negotiated, enabled,\n   and disabled dynamically, this can\
    \ make implementations seem quite\n   complex.  However, in any given instance\
    \ the behaviour should be\n   quite straightforward.  Either the server will be\
    \ enforcing the\n   policy of the server host or it will be providing security\n\
    \   capabilities requested by the client.  Either the client will be\n   conforming\
    \ to the server's policy or will be endeavouring to provide\n   the capabilities\
    \ that the user desires.\n"
- title: 10.1.  The Server's View of the Control Connection
  contents:
  - "10.1.  The Server's View of the Control Connection\n   A server MAY have a policy\
    \ statement somewhere that might:\n      - Deny any command before TLS is negotiated\
    \ (this might cause\n        problems if a SITE or some such command is required\
    \ prior to\n        login).\n      - Deny certain commands before TLS is negotiated\
    \ (e.g., USER,\n        PASS, or ACCT).\n      - Deny insecure USER commands for\
    \ certain users (e.g., not\n        ftp/anonymous).\n      - Deny secure USER\
    \ commands for certain users (e.g.,\n        ftp/anonymous).\n      - Define the\
    \ level(s) of TLS to be allowed.\n      - Define the CipherSuites allowed to be\
    \ used (perhaps on a per\n        host/domain/...  basis).\n      - Allow TLS\
    \ authentication as a substitute for local\n        authentication.\n      - Define\
    \ data connection policies (see next section).\n      It is possible that the\
    \ TLS negotiation may not be completed\n      satisfactorily for the server, in\
    \ which case it can be one of\n      these states.\n         The TLS negotiation\
    \ failed completely\n            In this case, the control connection should still\
    \ be in an\n            unprotected mode and the server SHOULD issue an unprotected\n\
    \            '421' reply to end the session.\n         The TLS negotiation completed\
    \ successfully, but the server\n         decides that the session parameters are\
    \ not acceptable (e.g.,\n         Distinguished Name in the client certificate\
    \ is not permitted\n         to use the server).\n            In this case, the\
    \ control connection should still be in a\n            protected state, so the\
    \ server MAY either continue to refuse\n            to service commands or issue\
    \ a protected '421' reply and\n            close the connection.\n         The\
    \ TLS negotiation failed during the TLS handshake\n            In this case, the\
    \ control connection is in an unknown state\n            and the server SHOULD\
    \ simply drop the control connection.\n   The server code will be responsible\
    \ for implementing the required\n   policies and ensuring that the client is prevented\
    \ from circumventing\n   the chosen security by refusing to service those commands\
    \ that are\n   against policy.\n"
- title: 10.2.  The Server's View of the Data Connection
  contents:
  - "10.2.  The Server's View of the Data Connection\n   The server can take one of\
    \ four basic views of the data connection.\n      1 - Don't allow encryption at\
    \ all (in which case the PROT command\n          should not allow any value other\
    \ than 'C' - if it is allowed\n          at all).\n      2 - Allow the client\
    \ to choose protection or not.\n      3 - Insist on data protection (in which\
    \ case the PROT command must\n          be issued prior to the first attempted\
    \ data transfer).\n      4 - Decide on one of the above three for each and every\
    \ data\n          connection.\n   The server SHOULD only check the status of the\
    \ data protection level\n   (for options 3 and 4 above) on the actual command\
    \ that will initiate\n   the data transfer (and not on the PORT or PASV).  The\
    \ following\n   commands, defined in [RFC-959], cause data connections to be opened\n\
    \   and thus may be rejected before any 1xx message due to an incorrect\n   PROT\
    \ setting.\n         STOR\n         RETR\n         NLST\n         LIST\n     \
    \    STOU\n         APPE\n   The reply to indicate that the PROT setting is incorrect\
    \ is '521 data\n   connection cannot be opened with this PROT setting'\n   If\
    \ the protection level indicates that TLS is required, then it\n   should be negotiated\
    \ once the data connection is made.  Thus, the\n   '150' reply only states that\
    \ the command can be used given the\n   current PROT level.  Should the server\
    \ not like the TLS negotiation,\n   then it will close the data port immediately\
    \ and follow the '150'\n   command with a '522' reply, which indicates that the\
    \ TLS negotiation\n   failed or was unacceptable.  (Note: This means that the\
    \ application\n   can pass a standard list of CipherSuites to the TLS layer for\n\
    \   negotiation, and review the one negotiated for applicability in each\n   instance).\n\
    \   The Security Considerations section discusses the issue of cross-\n   checking\
    \ any certificates used to authenticate the data connection\n   with the one(s)\
    \ used to authenticate the control connection.  This is\n   an important security\
    \ step.\n   It is reasonable for the server to insist that the data connection\n\
    \   uses a TLS cached session.  This might be a cache of a previous data\n   connection\
    \ or of a cleared control connection.  If this is the reason\n   for the refusal\
    \ to allow the data transfer, then the '522' reply\n   should indicate this.\n\
    \   Note: This has an important impact on client design, but allows\n   servers\
    \ to minimise the cycles used during TLS negotiation by\n   refusing to perform\
    \ a full negotiation with a previously\n   authenticated client.\n   It should\
    \ be noted that the TLS authentication of the server will be\n   authentication\
    \ of the server host itself and not a user on the server\n   host.\n"
- title: 10.3.  The Client's View of the Control Connection
  contents:
  - "10.3.  The Client's View of the Control Connection\n   In most cases, it is likely\
    \ that the client will be using TLS because\n   the server would refuse to interact\
    \ insecurely.  To allow for this,\n   clients SHOULD be flexible enough to manage\
    \ the securing of a session\n   at the appropriate time and still allow the user/server\
    \ policies to\n   dictate exactly when during the session the security is negotiated.\n\
    \   In the case where it is the client that is insisting on the securing\n   of\
    \ the session, the client will need to ensure that the negotiations\n   are all\
    \ completed satisfactorily and will need to be able to sensibly\n   inform the\
    \ user should the server not support, or not be prepared to\n   use, the required\
    \ security levels.\n   Clients SHOULD be coded in such a manner as to allow the\
    \ timing of\n   the AUTH, PBSZ, and PROT commands to be flexible and dictated\
    \ by the\n   server.  It is quite reasonable for a server to refuse certain\n\
    \   commands prior to these commands.  Similarly, it is quite possible\n   that\
    \ a SITE or quoted command might be needed by a server prior to\n   the AUTH.\
    \  A client MUST allow a user to override the timing of these\n   commands to\
    \ suit a specific server.\n   For example, a client SHOULD NOT insist on sending\
    \ the AUTH as the\n   first command in a session, nor should it insist on issuing\
    \ a\n   PBSZ/PROT pair directly after the AUTH.  This may well be the default\n\
    \   behaviour, but must be overridable by a user.\n   The TLS negotiation may\
    \ not be completed satisfactorily for the\n   client, in which case it will be\
    \ in one of these states:\n      The TLS negotiation failed completely\n     \
    \    In this case, the control connection should still be in an\n         unprotected\
    \ mode and the client should issue an unprotected\n         QUIT command to end\
    \ the session.\n      The TLS negotiation completed successfully, but the client\
    \ decides\n      that the session parameters are not acceptable (e.g.,\n     \
    \ Distinguished Name in certificate is not the actual server\n      expected).\n\
    \         In this case, the control connection should still be up in a\n     \
    \    protected state, so the client should issue a protected QUIT\n         command\
    \ to end the session.\n      The TLS negotiation failed during the TLS handshake.\n\
    \         In this case, the control connection is in an unknown state and\n  \
    \       the client should simply drop the control connection.\n"
- title: 10.4.  The Client's View of the Data Connection
  contents:
  - "10.4.  The Client's View of the Data Connection\n   Client security policies\n\
    \      Clients do not typically have 'policies' as such, instead they\n      rely\
    \ on the user to define their actions and, to a certain extent,\n      are reactive\
    \ to the server policy.  Thus, a client will need to\n      have commands that\
    \ will allow the user to switch the protection\n      level of the data connection\
    \ dynamically; however, there may be a\n      general 'policy' that attempts all\
    \ LIST and NLST commands on a\n      Clear connection first (and automatically\
    \ switches to Private if\n      it fails).  In this case, there would need to\
    \ be a user command\n      available to ensure that a given data transfer was\
    \ not attempted\n      on an insecure data connection.\n      Clients also need\
    \ to understand that the level of the PROT setting\n      is only checked for\
    \ a particular data transfer after that transfer\n      has been requested.  Thus,\
    \ a refusal by the server to accept a\n      particular data transfer should not\
    \ be read by the client as a\n      refusal to accept that data protection level\
    \ completely, as not\n      only may other data transfers be acceptable at that\
    \ protection\n      level, but it is entirely possible that the same transfer\
    \ may be\n      accepted at the same protection level at a later point in the\n\
    \      session.\n      It should be noted that the TLS authentication of the client\n\
    \      should be an authentication of a user on the client host and not\n    \
    \  the client host itself.\n"
- title: 11.  Who Negotiates What, Where, and How
  contents:
  - '11.  Who Negotiates What, Where, and How

    '
- title: 11.1.  Do we protect at all?
  contents:
  - "11.1.  Do we protect at all?\n   Client issues 'AUTH TLS', server accepts or\
    \ rejects.  If the server\n   needs AUTH, then it refuses to accept certain commands\
    \ until it gets\n   a successfully protected session.\n"
- title: 11.2.  What level of protection do we use on the Control connection?
  contents:
  - "11.2.  What level of protection do we use on the Control connection?\n   Decided\
    \ entirely by the TLS CipherSuite negotiation.\n"
- title: 11.3.  Do we protect data connections in general?
  contents:
  - "11.3.  Do we protect data connections in general?\n   Client issues PROT command,\
    \ server accepts or rejects.\n"
- title: 11.4.  Is protection required for a particular data transfer?
  contents:
  - "11.4.  Is protection required for a particular data transfer?\n   A client would\
    \ have already issued a PROT command if it required the\n   connection to be protected.\n\
    \   If a server needs to have the connection protected, then it will\n   reply\
    \ to the STOR/RETR/NLST/... command with a '522', indicating that\n   the current\
    \ state of the data connection protection level is not\n   sufficient for that\
    \ data transfer at that time.\n"
- title: 11.5.  What level of protection is required for a particular data
  contents:
  - "11.5.  What level of protection is required for a particular data\n       transfer?\n\
    \   Decided entirely by the TLS CipherSuite negotiation.\n   Thus, for flexibility,\
    \ it can be seen that it is desirable for the\n   FTP application to be able to\
    \ interact with the TLS layer upon which\n   it sits to define and discover the\
    \ exact TLS CipherSuites that are to\n   be/have been negotiated and to make decisions\
    \ accordingly.\n"
- title: 12.  Timing Diagrams
  contents:
  - "12.  Timing Diagrams\n   These timing diagrams aim to help explain exactly how\
    \ the TLS\n   handshake and session protection fits into the existing logic of\
    \ the\n   FTP protocol.  Of course, the FTP protocol itself is not well\n   described\
    \ with respect to the timing of commands and responses in\n   [RFC-959], so this\
    \ is partly based on empirical observation of\n   existing widespread client and\
    \ server implementations.\n"
- title: 12.1.  Establishing a Protected Session
  contents:
  - "12.1.  Establishing a Protected Session\n              Client               \
    \                  Server\n     control          data                   data \
    \              control\n   ====================================================================\n\
    \                                                                socket()\n  \
    \                                                              bind()\n     socket()\n\
    \     connect()  ----------------------------------------------> accept()\n  \
    \             <----------------------------------------------  220\n     AUTH\
    \ TLS   ---------------------------------------------->\n               <----------------------------------------------\
    \  234\n     TLSneg()  <----------------------------------------------> TLSneg()\n\
    \     PBSZ 0     ---------------------------------------------->\n           \
    \    <----------------------------------------------  200\n     PROT P     ---------------------------------------------->\n\
    \               <----------------------------------------------  200\n     USER\
    \ fred  ---------------------------------------------->\n               <----------------------------------------------\
    \  331\n     PASS pass  ---------------------------------------------->\n    \
    \           <----------------------------------------------  230\n   Note 1: The\
    \ order of the PBSZ/PROT pair and the USER/PASS pair (with\n   respect to each\
    \ other) is not important (i.e., the USER/PASS can\n   happen prior to the PBSZ/PROT,\
    \ or the server can refuse to allow a\n   PBSZ/PROT pair until the USER/PASS pair\
    \ has happened).\n   Note 2: The PASS command might not be required at all (if\
    \ the USER\n   parameter and any client identity presented provide sufficient\n\
    \   authentication).  The server would indicate this by issuing a '232'\n   reply\
    \ to the USER command instead of the '331', which requests a PASS\n   from the\
    \ client (see below).\n   Note 3: The AUTH command might not be the first command\
    \ after the\n   receipt of the 220 welcome message.\n"
- title: 12.2.  Establishing a Protected Session Without a Password Request
  contents:
  - "12.2.  Establishing a Protected Session Without a Password Request\n       (The\
    \ TLS Authentication is Sufficient)\n              Client                    \
    \             Server\n     control          data                   data      \
    \         control\n   ====================================================================\n\
    \                                                                socket()\n  \
    \                                                              bind()\n     socket()\n\
    \     connect()  ----------------------------------------------> accept()\n  \
    \             <----------------------------------------------  220\n     AUTH\
    \ TLS   ---------------------------------------------->\n               <----------------------------------------------\
    \  234\n     TLSneg()  <----------------------------------------------> TLSneg()\n\
    \     PBSZ 0     ---------------------------------------------->\n           \
    \    <----------------------------------------------  200\n     PROT P     ---------------------------------------------->\n\
    \               <----------------------------------------------  200\n     USER\
    \ fred  ---------------------------------------------->\n               <----------------------------------------------\
    \  232\n"
- title: 12.3.  Establishing a Protected Session and then Clearing with the CCC
  contents:
  - "12.3.  Establishing a Protected Session and then Clearing with the CCC\n    \
    \   Command\n             Client                                 Server\n    control\
    \          data                   data               control\n  ====================================================================\n\
    \                                                               socket()\n   \
    \                                                            bind()\n    socket()\n\
    \    connect()  ----------------------------------------------> accept()\n   \
    \           <----------------------------------------------  220\n    AUTH TLS\
    \   ---------------------------------------------->\n              <----------------------------------------------\
    \  234\n    TLSneg()  <----------------------------------------------> TLSneg()\n\
    \    PBSZ 0     ---------------------------------------------->\n            \
    \  <----------------------------------------------  200\n    PROT P     ---------------------------------------------->\n\
    \              <----------------------------------------------  200\n    USER\
    \ fred  ---------------------------------------------->\n              <----------------------------------------------\
    \  232\n    CCC        ---------------------------------------------->\n     \
    \         <----------------------------------------------  200\n    TLSshutdown()\
    \  <-------------------------------------> TLSshutdown()\n   - The rest of the\
    \ control session continues in plaintext with\n     protected data transfers (due\
    \ to PROT P).\n   Note: This has serious security issues (see Security Considerations\n\
    \   section) but may be useful in a firewall/NAT scenario.\n"
- title: 12.4.  A Standard Data Transfer Without Protection
  contents:
  - "12.4.  A Standard Data Transfer Without Protection\n              Client    \
    \                             Server\n     control          data             \
    \      data               control\n   ====================================================================\n\
    \                      socket()\n                      bind()\n     PORT w,x,y,z,a,b\
    \ ----------------------------------------->\n         <-----------------------------------------------------\
    \ 200\n     STOR file ------------------------------------------------>\n    \
    \                                         socket()\n                         \
    \                    bind()\n         <-----------------------------------------------------\
    \ 150\n                      accept() <-----------  connect()\n              \
    \        write()   -----------> read()\n                      close()   ----------->\
    \ close()\n         <----------------------------------------------------- 226\n"
- title: 12.5.  A Firewall-Friendly Data Transfer Without Protection
  contents:
  - "12.5.  A Firewall-Friendly Data Transfer Without Protection\n              Client\
    \                                 Server\n     control          data         \
    \          data               control\n   ====================================================================\n\
    \     PASV -------------------------------------------------------->\n       \
    \                                      socket()\n                            \
    \                 bind()\n         <------------------------------------------\
    \ 227 (w,x,y,z,a,b)\n                      socket()\n     STOR file --------------------------------------------------->\n\
    \                      connect()  ----------> accept()\n         <--------------------------------------------------------\
    \ 150\n                      write()    ----------> read()\n                 \
    \     close()    ----------> close()\n         <--------------------------------------------------------\
    \ 226\n   Note: Implementers should be aware that the connect()/accept()\n   function\
    \ is performed prior to the receipt of the reply from the STOR\n   command.  This\
    \ contrasts the with situation when a non-firewall-\n   friendly PORT is used\
    \ prior to the STOR, and the accept()/connect()\n   is performed after the reply\
    \ from the aforementioned STOR has been\n   dealt with.\n"
- title: 12.6.  A Standard Data Transfer with Protection
  contents:
  - "12.6.  A Standard Data Transfer with Protection\n              Client       \
    \                          Server\n     control          data                \
    \   data               control\n   ====================================================================\n\
    \                      socket()\n                      bind()\n     PORT w,x,y,z,a,b\
    \ -------------------------------------------->\n         <--------------------------------------------------------\
    \ 200\n     STOR file --------------------------------------------------->\n \
    \                                            socket()\n                      \
    \                       bind()\n         <--------------------------------------------------------\
    \ 150\n                      accept()  <----------  connect()\n              \
    \        TLSneg()  <----------> TLSneg()\n                      TLSwrite() ---------->\
    \ TLSread()\n                      TLSshutdown() -------> TLSshutdown()\n    \
    \                  close()    ----------> close()\n         <--------------------------------------------------------\
    \ 226\n"
- title: 12.7.  A Firewall-Friendly Data Transfer with Protection
  contents:
  - "12.7.  A Firewall-Friendly Data Transfer with Protection\n              Client\
    \                                 Server\n     control          data         \
    \          data               control\n   ====================================================================\n\
    \     PASV -------------------------------------------------------->\n       \
    \                                      socket()\n                            \
    \                 bind()\n         <------------------------------------------\
    \ 227 (w,x,y,z,a,b)\n                      socket()\n     STOR file --------------------------------------------------->\n\
    \                      connect()  ----------> accept()\n         <--------------------------------------------------------\
    \ 150\n                      TLSneg()   <---------> TLSneg()\n               \
    \       TLSwrite()  ---------> TLSread()\n                      TLSshutdown()\
    \ -------> TLSshutdown()\n                      close()     ---------> close()\n\
    \         <-------------------------------------------------------- 226\n"
- title: 13.  Discussion of the REIN Command
  contents:
  - "13.  Discussion of the REIN Command\n   The REIN command, defined in [RFC-959],\
    \ allows the user to reset the\n   state of the FTP session.  From [RFC-959]:\n\
    \      REINITIALIZE (REIN)\n         This command terminates a USER, flushing\
    \ all I/O and account\n         information, except to allow any transfer in progress\
    \ to be\n         completed.  All parameters are reset to the default settings\n\
    \         and the control connection is left open.  This is identical to\n   \
    \      the state in which a user finds himself immediately after the\n       \
    \  control connection is opened.  A USER command may be expected\n         to\
    \ follow.\n   When this command is processed by the server, the TLS session(s)\
    \ MUST\n   be cleared and the control and data connections revert to\n   unprotected,\
    \ clear communications.  It MAY be acceptable to use\n   cached TLS sessions for\
    \ subsequent connections, however, a server\n   MUST NOT mandate this.\n   If\
    \ the REIN command is being used to clear a TLS session, then the\n   reply to\
    \ the REIN command MUST be sent in a protected session prior\n   to the session(s)\
    \ being cleared.\n"
- title: 14.  Discussion of the STAT and ABOR Commands
  contents:
  - "14.  Discussion of the STAT and ABOR Commands\n   The ABOR and STAT commands\
    \ and the use of TCP Urgent Pointers\n      [RFC-959] describes the use of Telnet\
    \ commands (IP and DM) and the\n      TCP Urgent pointer to indicate the transmission\
    \ of commands on the\n      control channel during the execution of a data transfer.\
    \  FTP uses\n      the Telnet Interrupt Process and Data Mark commands in conjunction\n\
    \      with Urgent data to preface two commands: ABOR (Abort Transfer)\n     \
    \ and STAT (Status request).\n      The Urgent Pointer was used because, in a\
    \ Unix implementation, the\n      receipt of a TCP packet marked as Urgent would\
    \ result in the\n      execution of the SIGURG interrupt handler.  This reliance\
    \ on\n      interrupt handlers was necessary on systems that did not implement\n\
    \      select() or did not support multiple threads.  TLS does not\n      support\
    \ the notion of Urgent data.\n      When TLS is implemented as a security method\
    \ in FTP, the server\n      SHOULD NOT rely on the use of SIGURG to process input\
    \ on the\n      control channel during data transfers.  The client MUST send all\n\
    \      data, including Telnet commands, across the TLS session.\n"
- title: 15.  Security Considerations
  contents:
  - "15.  Security Considerations\n   This document discusses how TLS may be used\
    \ in conjunction with\n   [RFC-2228] to provide mechanisms for securing FTP sessions.\n\
    \   Discussions about security rationale and security properties are\n   contained\
    \ within the [RFC-2228] document and are not repeated here.\n"
- title: 15.1.  Verification of Authentication Tokens
  contents:
  - "15.1.  Verification of Authentication Tokens\n   In this section, we assume that\
    \ X.509 certificates will be used for\n   the TLS authentication.  If some other\
    \ identity token is used (e.g.,\n   kerberos tickets - see [RFC-2712]), then similar,\
    \ mechanism-specific\n   considerations will need to be made.\n"
- title: 15.1.1.  Server Certificates
  contents:
  - "15.1.1.  Server Certificates\n   - Although it is entirely an implementation\
    \ decision, it is\n     recommended that certificates used for server authentication\
    \ of the\n     TLS session contain the server identification information in a\n\
    \     similar manner to those used for http servers (see [RFC-2818]).\n   - It\
    \ is strongly recommended that the certificate used for server\n     authentication\
    \ of Data connections be the same certificate as that\n     used for the corresponding\
    \ Control connection.  If different\n     certificates are to be used, there should\
    \ be some other mechanism\n     that the client can use to cross-check the data\
    \ and control\n     connection server identities.\n   - If Server Certificates\
    \ are not used, then many of the security\n     benefits will not be realised.\
    \  For Example, in an anonymous\n     Diffie-Hellman environment, there is no\
    \ server identity\n     authentication, so there is little protection against\
    \ man-in-the-\n     middle attacks.\n"
- title: 15.1.2.  Client Certificates
  contents:
  - "15.1.2.  Client Certificates\n   - Deciding which client certificates to allow\
    \ and defining which\n     fields define what authentication information is entirely\
    \ a server\n     implementation issue.\n   - However, it is strongly recommended\
    \ that the certificate used for\n     client authentication of Data connections\
    \ be the same certificate\n     as that used for the corresponding Control connection.\
    \  If\n     different certificates are to be used, there should be some other\n\
    \     mechanism that the server can use to cross-check the data and\n     control\
    \ connection client identities.\n   - If Client Certificates are not used, then\
    \ many of the security\n     benefits will not be realised.  For Example, it would\
    \ still be\n     possible for a malicious client to hijack a data connection.\n"
- title: 15.2.  Addressing FTP Security Considerations [RFC-2577]
  contents:
  - '15.2.  Addressing FTP Security Considerations [RFC-2577]

    '
- title: 15.2.1.  Bounce Attack
  contents:
  - "15.2.1.  Bounce Attack\n   A bounce attack should be harder in a secured FTP\
    \ environment\n   because:\n      - The FTP server that is being used to initiate\
    \ a false connection\n        will always be a 'server' in the TLS context.  Therefore,\
    \ only\n        services that act as 'clients' in the TLS context could be\n \
    \       vulnerable.  This would be a counter-intuitive way to implement\n    \
    \    TLS on a service.\n      - The FTP server would detect that the authentication\
    \ credentials\n        for the data connection are not the same as those for the\n\
    \        control connection, thus the server policies could be set to\n      \
    \  drop the data connection.\n      - Genuine users are less likely to initiate\
    \ such attacks when the\n        authentication is strong, and malicious users\
    \ are less likely to\n        gain access to the FTP server if the authentication\
    \ is not\n        easily subverted (password guessing, network tracing, etc...)\n"
- title: 15.2.2.  Restricting Access
  contents:
  - "15.2.2.  Restricting Access\n   This document presents a strong mechanism for\
    \ solving the issue\n   raised in this section.\n"
- title: 15.2.3.  Protecting Passwords
  contents:
  - "15.2.3.  Protecting Passwords\n   The twin solutions of strong authentication\
    \ and data confidentiality\n   ensure that this is not an issue when TLS is used\
    \ to protect the\n   control session.\n"
- title: 15.2.4.  Privacy
  contents:
  - "15.2.4.  Privacy\n   The TLS protocol ensures data confidentiality by encryption.\
    \  Privacy\n   (e.g., access to download logs, user profile information, etc...)\
    \ is\n   outside the scope of this document (and [RFC-2577] presumably).\n"
- title: 15.2.5.  Protecting Usernames
  contents:
  - "15.2.5.  Protecting Usernames\n   This is not an issue when TLS is used as the\
    \ primary authentication\n   mechanism.\n"
- title: 15.2.6.  Port Stealing
  contents:
  - "15.2.6.  Port Stealing\n   This specification will do little for the Denial of\
    \ Service element\n   of this section; however, strong authentication on the data\n\
    \   connection will prevent unauthorised connections from retrieving or\n   submitting\
    \ files.  Of course, this is only the case where strong\n   client authentication\
    \ is being used.  If client certificates are not\n   used, then port stealing\
    \ by a rogue client is still a problem.  If no\n   strong authentication is in\
    \ use at all (e.g., anonymous Diffie-\n   Hellman), then the port stealing problem\
    \ will remain.\n"
- title: 15.2.7.  Software-Based Security Problems
  contents:
  - "15.2.7.  Software-Based Security Problems\n   Nothing in this specification will\
    \ affect the discussion in this\n   section.\n"
- title: 15.3.  Issues with the CCC Command
  contents:
  - "15.3.  Issues with the CCC Command\n   Using the CCC command can create security\
    \ issues.  For a full\n   description, see the \"CLEAR COMMAND CHANNEL (CCC)\"\
    \ section of\n   [RFC-2228].  Clients should not assume that a server will allow\
    \ the\n   CCC command to be processed.\n   Server implementations may wish to\
    \ refuse to process the CCC command\n   on a session that has not passed through\
    \ some form of client\n   authentication (e.g., TLS client auth or FTP USER/PASS).\
    \  This can\n   prevent anonymous clients from repeatedly requesting AUTH TLS\n\
    \   followed by CCC to tie up resources on the server.\n"
- title: 16.  IANA Considerations
  contents:
  - "16.  IANA Considerations\n   {FTP-PORT} - The port assigned to the FTP control\
    \ connection is 21.\n"
- title: 17.  Other Parameters
  contents:
  - "17.  Other Parameters\n   {TLS-PARM} - The parameter for the AUTH command to\
    \ indicate that TLS\n   is required.  To request the TLS protocol in accordance\
    \ with this\n   document, the client MUST use 'TLS'\n      To maintain backward\
    \ compatibility with older versions of this\n      document, the server SHOULD\
    \ accept 'TLS-C' as a synonym for 'TLS'.\n      Note: [RFC-2228] states that these\
    \ parameters are case-\n      insensitive.\n"
- title: 18.  Scalability and Limits
  contents:
  - "18.  Scalability and Limits\n   There are no issues other than those concerned\
    \ with the ability of\n   the server to refuse to have a complete TLS negotiation\
    \ for each and\n   every data connection, which will allow servers to retain throughput\n\
    \   whilst using cycles only when necessary.\n"
- title: 19.  Applicability
  contents:
  - "19.  Applicability\n   This mechanism is generally applicable as a mechanism\
    \ for securing\n   the FTP protocol.  It is unlikely that anonymous FTP clients\
    \ or\n   servers will require such security (although some might like the\n  \
    \ authentication features without the confidentiality).\n"
- title: 20.  Acknowledgements
  contents:
  - "20.  Acknowledgements\n   o  Netscape Communications Corporation for the original\
    \ SSL protocol.\n   o  Eric Young for the SSLeay libraries.\n   o  University\
    \ of California, Berkeley for the original\n      implementations of FTP and ftpd,\
    \ on which the initial\n      implementation of these extensions were layered.\n\
    \   o  IETF CAT working group.\n   o  IETF TLS working group.\n   o  IETF FTPEXT\
    \ working group.\n   o  Jeff Altman for the ABOR and STAT discussion.\n   o  The\
    \ various people who have help author this document throughout\n      its protracted\
    \ draft stages, namely Martin Carpenter, Eric Murray,\n      Tim Hudson, and Volker\
    \ Wiegand.\n"
- title: 21.  References
  contents:
  - '21.  References

    '
- title: 21.1.  Normative References
  contents:
  - "21.1.  Normative References\n   [RFC-959]  Postel, J. and J. Reynolds, \"File\
    \ Transfer Protocol\", STD\n              9, RFC 959, October 1985.\n   [RFC-2119]\
    \ Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement\
    \ Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC-2228] Horowitz, M. and S. Lunt,\
    \ \"FTP Security Extensions\", RFC\n              2228, October 1997.\n   [RFC-2246]\
    \ Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\",\n              RFC\
    \ 2246, January 1999.\n   [RFC-2389] Hethmon, P. and R. Elz, \"Feature negotiation\
    \ mechanism for\n              the File Transfer Protocol\", RFC 2389, August\
    \ 1998.\n"
- title: 21.2.  Informative References
  contents:
  - "21.2.  Informative References\n   [RFC-1579] Bellovin, S., \"Firewall-Friendly\
    \ FTP\", RFC 1579, February\n              1994.\n   [RFC-2222] Myers, J., \"\
    Simple Authentication and Security Layer\n              (SASL)\", RFC 2222, October\
    \ 1997.\n   [RFC-2577] Allman, M. and S. Ostermann, \"FTP Security\n         \
    \     Considerations\", RFC 2577, May 1999.\n   [RFC-2712] Medvinsky, A. and M.\
    \ Hur, \"Addition of Kerberos Cipher\n              Suites to Transport Layer\
    \ Security (TLS)\", RFC 2712,\n              October 1999.\n   [RFC-2817] Khare,\
    \ R. and S. Lawrence, \"Upgrading to TLS Within\n              HTTP/1.1\", RFC\
    \ 2817, May 2000.\n   [RFC-2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May\
    \ 2000.\n   [RFC-3207] Hoffman, P., \"SMTP Service Extension for Secure SMTP over\n\
    \              Transport Layer Security\", RFC 3207, February 2002.\n"
- title: Contributors
  contents:
  - "Contributors\n   Tim Hudson\n   RSA Data Security\n   Australia Pty Ltd\n   Phone:\
    \ +61 7 3227 4444\n   EMail: tjh@rsasecurity.com.au\n   Volker Wiegand\n   SuSE\
    \ Linux\n   EMail: wiegand@suse.de\n   Martin Carpenter\n   Verisign Ltd\n   EMail:\
    \ mcarpenter@verisign.com\n   Eric Murray\n   Wave Systems Inc.\n   EMail: ericm@lne.com\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Paul Ford-Hutchinson\n   IBM UK Ltd\n   PO Box 31\n   Birmingham\
    \ Road\n   Warwick\n   United Kingdom\n   Phone: +44 1926 462005\n   EMail: rfc4217@ford-hutchinson.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
