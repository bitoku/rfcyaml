Abstract RPSL allows a network operator to be able to specify routing policies at various levels in the Internet hierarchy; for example at the Autonomous System (AS) level.
At the same time, policies can be specified with sufficient detail in RPSL so that low level router configurations can be generated from them.
RPSL is extensible; new routing protocols and new protocol features can be introduced at any time.
This memo is the reference document for the Routing Policy Specification Language (RPSL).
RPSL allows a network operator to be able to specify routing policies at various levels in the Internet hierarchy; for example at the Autonomous System (AS) level.
At the same time, policies can be specified with sufficient detail in RPSL so that low level router configurations can be generated from them.
RPSL is extensible; new routing protocols and new protocol features can be introduced at any time.
RPSL is a replacement for the current Internet policy specification language known as RIPE 181 [6] or RFC 1786 [7].
RIPE 81 [8] was the first language deployed in the Internet for specifying routing policies.
It was later replaced by RIPE 181 [6].
Through operational use of RIPE 181
it has become apparent that certain policies cannot be specified and a need for an enhanced and more generalized language is needed.
RPSL was designed so that a view of the global routing policy can be contained in a single cooperatively maintained distributed database to improve the integrity of Internet's routing.
RPSL is not designed to be a router configuration language.
RPSL is designed so that router configurations can be generated from the description of the policy for one autonomous system (aut num class) combined with the description of a router (inet rtr class), mainly providing router ID, autonomous system number of the router, interfaces and peers of the router, and combined with a global database mappings from AS sets to ASes (as set class), and from origin ASes and route sets to route prefixes (route and route set classes).
The accurate population of the RPSL database can help contribute toward such goals as router configurations that protect against accidental (or malicious) distribution of inaccurate routing information, verification of Internet's routing, and aggregation boundaries beyond a single AS.
RPSL is object oriented; that is, objects contain pieces of policy and administrative information.
These objects are registered in the Internet Routing Registry (IRR) by the authorized organizations.
The registration process is beyond the scope of this document.
Please refer to [1, 17, 4] for more details on the IRR.
In the following sections, we present the classes that are used to define various policy and administrative objects.
The "mntner" class defines entities authorized to add, delete and modify a set of objects.
The "person" and "role" classes describes technical and administrative contact personnel.
Autonomous systems (ASes) are specified using the "aut num" class.
Routes are specified using the "route" class.
Sets of objects can be defined using the "as set", "route set", "filter set", "peering set", and "rtr set" classes.
The "dictionary" class provides the extensibility to the language.
The "inet rtr" class is used to specify routers.
Many of these classes were originally defined in earlier documents [6, 13, 16, 12, 5] and have all been enhanced.
This document is self contained.
However, the reader is encouraged to read RIPE 181 [7] and the associated documents [13, 16, 12, 5] as they provide significant background as to the motivation and underlying principles behind RIPE 181 and consequently, RPSL.
For a tutorial on RPSL, the reader should read the RPSL applications document [4].
2 RPSL Names, Reserved Words, and Representation
Each class has a set of attributes which store a piece of information about the objects of the class.
Attributes can be mandatory or optional: A mandatory attribute has to be defined for all objects of the class; optional attributes can be skipped.
Attributes can also be single or multiple valued.
Each object is uniquely identified by a set of attributes, referred to as the class "key".
The value of an attribute has a type.
The following types are most widely used.
Note that RPSL is case insensitive and
only the characters from the ASCII character set can be used.
Many objects in RPSL have a name.
The following words are reserved by RPSL, and they can not be used as names: any as any rs any peeras and or not atomic from to at action accept announce except refine networks into inbound outbound Names starting with certain prefixes are reserved for certain object types.
Names starting with "as " are reserved for as set names.
Names starting with "rs " are reserved for route set names.
Names starting with "rtrs " are reserved for router set names.
Names starting with "fltr " are reserved for filter set names.
Names starting with "prng " are reserved for peering set names.
<as number> An AS number
is represented as the string "ASx".
That is, the AS 226 is represented as AS226.
For example, 128.9.128.5 represents a valid IPv4 address.
In the rest of this document, we may refer to IPv4 addresses as IP addresses.
The following are valid address prefixes: 128.9.128.5/32, 128.9.0.0/16, 0.0.0.0/0; and the following address prefixes are invalid:  0/0, 128.9/16
since 0 or 128.9 are not strings containing four integers.
> An address prefix range is an address prefix followed by an optional range operator.
For example, 128.9.0.0/16^  contains all the more specifics of 128.9.0.0/16 excluding 128.9.0.0/16.
is the inclusive more specifics operator; it stands for the more specifics of the address prefix including the address prefix itself.
For example, 5.0.0.0/8^  contains all the more specifics of 5.0.0.0/8 including 5.0.0.0/8.
^n where n is an integer, stands for all the length n specifics of the address prefix.
16 contains all the more specifics of 30.0.0.0/8 which are of length 16 such as 30.9.0.0/16.
m where n and m are integers, stands for all the length n to length m specifics of the address prefix.
For example, 30.0.0.0/8^24 32 contains all the more specifics of 30.0.0.0/8 which are of length 24 to 32 such as 30.9.9.96/28.
Range operators can also be applied to address prefix sets.
In this case, they distribute over the members of the set.
For example, for a route set (defined later)
rs foo, rs foo^  contains all the inclusive more specifics of all the prefixes in rs foo.
It is an error to follow a range operator with another one (e.g. 30.0.0.0/8^
24 28^  is an error).
However, a range operator can be applied to an address prefix set that has address prefix ranges in it (e.g. {30.0.0.0/8^
24 28}^27 30 is not an error).
In this case, the outer operator ^n
m distributes over the inner operator ^k l and becomes the operator
if m is greater than or equal to max(n,k), or otherwise, the prefix is deleted from the set.
Note that the operator ^n is equivalent to ^n n
; prefix/l^  is equivalent to prefix/
l^  is equivalent to prefix/l^(l 1) 32; {prefix/
l^n m}^  is equivalent to {prefix/
l^n  m}^  is equivalent to {prefix/l^(n 1) 32}.
A date is represented as an eight digit integer of the form YYYYMMDD where YYYY represents the year, MM represents the month of the year (01 through 12), and DD represents the day of the month (01 through 31).
All dates are in UTC unless otherwise specified.
For example, June 24, 1996 is represented as 19960624.
>is as described in RFC 822 [10].
>is as described in RFC 1034
> is a uniquely assigned identifier word used by routing, address allocation, and other registries to unambiguously refer to contact information.
Person and role classes map NIC handles to actual person names, and contact information.
>is a sequence of ASCII characters.
> is a name of an object of type X. That is <mntner name
> is a name of a mntner object.
> is a name of an IRR registry.
The routing registries are listed in Appendix A. A value of an attribute may also be a list of one of these types.
For example, "AS1, AS2, AS3, AS4" is a list of AS numbers.
Note that being list valued and being multiple valued are orthogonal.
A multiple valued attribute has more than one value, each of which may or may not be a list.
On the other hand a single valued attribute may have a list value.
An RPSL object is textually represented as a list of attribute value pairs.
Each attribute value pair is written on a separate line.
The attribute which has the same name as the object's class should be specified first.
The object's representation ends when a blank line is encountered.
More spaces may optionally be used after the continuation character to increase readability.
The order of attribute value pairs is significant.
An object's description may contain comments.
White space characters can be used to improve readability.
An integer can be specified using (1)
the C programming language notation (e.g. 1, 12345); (2) sequence of four 1 octet integers (in the range from 0 to 255) separated by the character dot "."
3 Contact Information The mntner, person and role classes, admin c, tech c, mnt by, changed, and source attributes of all classes describe contact information.
The mntner class also specifies authenticaiton information required to create, delete and update other objects.
These classes do not specify routing policies and each registry may have different or additional requirements on them.
Here we present the common denominator for completeness which is the RIPE database implementation [16].
Please consult your routing registry for the latest specification of these classes and attributes.
The "Routing Policy System Security" document [20] describes the authenticaiton and authorization model in more detail.
The mntner class specifies authenticaiton information required to create, delete and update RPSL objects.
A provider, before he/she can create RPSL objects, first needs to create a mntner object.
The attributes of the mntner class are shown in Figure 1.
The mntner class was first described in [13].
The mntner attribute is mandatory and is the class key.
Its value is an RPSL name.
The auth attribute specifies the scheme that will be used to identify and authenticate update requests from this maintainer.
It has the following syntax:
>'s currently defined are: NONE, MAIL FROM, PGP KEY and CRYPT PW.
The <auth info> is additional information required by a particular scheme: in the case of MAIL FROM, it is a regular expression matching valid email addresses; in the case of CRYPT PW, it is a password in UNIX crypt format; and in the case of PGP KEY, it is a pointer to key certif object [22] containing the PGP public key of the user.
If multiple auth attributes are specified, an update request satisfying any one of them is authenticated to be from the maintainer.
The upd to attribute is an email address.
On an unauthorized update attempt of an object maintained by this maintainer, an email message will be sent to this address.
The mnt nfy attribute is an email address.
A notification message will be forwarded to this email address whenever an object maintained by this maintainer is added, changed or deleted.
The descr attribute is a short, free form textual description of the object.
The tech c attribute is a technical contact NIC handle.
This is someone to be contacted for technical problems such as misconfiguration.
The admin c attribute is an administrative contact NIC handle.
The remarks attribute is a free text explanation or clarification.
The notify attribute is an email address to which notifications of changes to this object should be sent.
The mnt by attribute is a list of mntner object names.
The authorization for changes to this object is governed by any of the maintainer objects referenced.
The changed attribute documents who last changed this object, and when this change was made.
Its syntax has the following form: changed: <email address>
> identifies the person who made the last change.
<YYYYMMDD> is the date of the change.
The source attribute specifies the registry where the object is registered.
Figure 2 shows an example mntner object.
In the example, UNIX crypt format password authentication is used.
RIPE Figure 2:  An example mntner object.
The descr, tech c, admin c, remarks, notify, mnt by, changed and source attributes are attributes of all RPSL classes.
Their syntax, semantics, and mandatory, optional, multi valued, or single valued status are the same for for all RPSL classes.
Only exception to this is the admin c attribute which is mandatory for the aut num class.
We do not further discuss them in other sections.
3.2 person Class A person class is used to describe information about people.
Even though it does not describe routing policy, we still describe it here briefly since many policy objects make reference to person objects.
The person class was first described in [15].
The attributes of the person class are shown in Figure 3.
The person attribute is the full name of the person.
The phone and the fax
no attributes have the following syntax: phone:  <country code> <city> <subscriber> [ext.
mandatory, single valued nic hdl
person Class Attributes phone:  44 123 987654 ext.
Figure 4 shows an example person object.
31 20 535 4444 fax
The role class is similar to the person object.
However, instead of describing a human being, it describes a role performed by one or more human beings.
Examples include help desks, network monitoring centers, system administrators, etc.
Role object is particularly useful since often a person performing a role may change, however the role itself remains.
The attributes of the role class are shown in Figure 5.
The nic hdl attributes of the person and role classes share the same name space.
The trouble attribute of role object may contain additional contact information to be used when a problem arises in any object that references this role object.
Figure 6 shows an example role object.
mandatory, single valued nic hdl
multi valued Figure 5:  role
Each interAS route (also referred to as an interdomain route) originated by an AS is specified using a route object.
The attributes of the route class are shown in Figure 7.
The route attribute is the address prefix of the route and the origin attribute is the AS number of the AS that originates the route into the interAS routing system.
The route and origin attribute pair is the class key.
Figure 8 shows examples of four route objects (we do not include contact attributes such as admin c, tech c for brevity).
Note that the last two route objects have the same address prefix, namely 128.8.0.0/16.
However, they are different route objects since they are originated by different ASes (i.e. they have different keys).
AS1 route: 128.8.0.0/16 origin: AS2 Figure 8:  Route Objects 5 Set Classes
To specify policies, it is often useful to define sets of objects.
For this purpose we define as set, route set, rtr set, filter set, and peering set classes.
These classes define a named set.
The members of these sets can be specified either directly by listing them in the sets' definition, or indirectly by having member objects refer to the sets' names, or a combination of both methods.
A set's name is an rpsl word with the following restrictions: All as set names start with prefix "as ".
All route set names start with prefix "rs ".
All rtr set names start with prefix "rtrs ".
All filter set names start with prefix "fltr ".
All peering set names start with prefix "prng ".
For example, as foo is a valid as set name.
Set names can also be hierarchical.
At least one component of such a name must be an actual set name (i.e. start with one of the prefixes above).
All the set name components of an hierarchical name has to be of the same type.
For example, the following names are valid:
The purpose of an hierarchical set name is to partition the set name space so that the maintainers of the set X1 controls the whole set name space underneath, i.e. X1:...
Thus, a set object with name X1:...
:Xn can only be created by the maintainer of the object with name X1:...
That is, only the maintainer of AS1 can create a set with name AS1:AS FOO; and only the maintainer of AS1:AS FOO can create a set with name AS1:AS FOO:AS BAR.
Please see RPS Security Document [20] for details.
The attributes of the as set class are shown in Figure 9.
The as set attribute defines the name of the set.
It is an RPSL name that starts with "as ".
The members attribute lists the members of the set.
The members attribute is a list of AS numbers, or other as set names.
, multi valued <as set names
> mbrs by ref  list of <mntner names>
valued Figure 9:  as set Class Attributes Figure
10 presents two as set objects.
The set as foo contains two ASes, namely AS1 and AS2.
The set as bar contains the members of the set as foo and AS3, that is it contains AS1, AS2, AS3.
The set as  empty contains no members.
The mbrs by ref attribute is a list of maintainer names or the keyword ANY.
If this attribute is used, the AS set also includes ASes whose aut num objects are registered by one of these maintainers and whose member of attribute refers to the name of this AS set.
If the value of a mbrs by ref attribute is ANY, any AS object referring to the AS set is a member of the set.
If the mbrs by ref attribute is missing, only the ASes listed in the members attribute are members of the set.
as set: as foo members: AS1, AS2 mbrs by ref:
Figure 11 presents an example as set object that uses the mbrs by ref attribute.
The set as foo contains AS1, AS2 and AS3.
AS4 is not a member of the set as foo even though the aut num object references as foo.
This is because MNTR OTHER is not listed in the as foo's mbrs by ref attribute.
The attributes of the route set class are shown in Figure 12.
The route set attribute defines the name of the set.
It is an RPSL name that starts with "rs ".
The members attribute lists the members of the set.
The members attribute is a list of address prefixes or other route set names.
Note that, the route set class is a set of route prefixes, not of RPSL route objects.
or  optional, multi valued <route set name
route set Class Attributes Figure 13
presents some example route set objects.
The set rs foo contains two address prefixes, namely 128.9.0.0/16 and 128.9.0.0/24.
The set rs bar contains the members of the set rs foo and the address prefix 128.7.0.0/16.
An address prefix or a route set name in a members attribute can be optionally followed by a range operator.
For example, the following set:
route set: rs foo members: 128.9.0.0/16,
128.9.0.0/24 route set: rs bar members: 128.7.0.0/16,
route set Objects route set: rs bar members:
5.0.0.0/8^ , 30.0.0.0/8^24 32, rs
foo^  contains all the more specifics of 5.0.0.0/8 including 5.0.0.0/8, all the more specifics of 30.0.0.0/8 which are of length 24 to 32 such as 30.9.9.96/28, and all the more specifics of address prefixes in route set rs foo.
The mbrs by ref attribute is a list of maintainer names or the keyword ANY.
If this attribute is used, the route set also includes address prefixes whose route objects are registered by one of these maintainers and whose member of attribute refers to the name of this route set.
If the value of a mbrs by ref attribute is ANY, any route object referring to the route set name is a member.
If the mbrs by  ref attribute is missing, only the address prefixes listed in the members attribute are members of the set.
route set: rs foo mbrs by ref:
MNTR ME, MNTR YOU route set:
128.9.0.0/16 origin: AS1 member of:
128.8.0.0/16 origin: AS2 member of:
MNTR YOU Figure 14:  route set objects.
Figure 14 presents example route set objects that use the mbrs by ref attribute.
The set rs foo contains two address prefixes, namely 128.8.0.0/16 and 128.9.0.0/16
since the route objects for 128.8.0.0/16 and 128.9.0.0/16 refer to the set name rs foo in their member of attribute.
The set rs bar contains the address prefixes 128.7.0.0/16 and 128.8.0.0/16.
The route 128.7.0.0/16 is explicitly listed in the members attribute of rs bar, and the route object for 128.8.0.0/16 refer to the set name rs bar in its member of attribute.
Note that, if an address prefix is listed in a members attribute of a route set, it is a member of that route set.
The route object corresponding to this address prefix does not need to contain a member of attribute referring to this set name.
The member of attribute of the route class is an additional mechanism for specifying the members indirectly.
In a context that expects a route set (e.g.  members attribute of the route set class), an AS number ASx defines the set of routes that are originated by ASx; and an as set AS X defines the set of routes that are originated by the ASes in AS
X. A route p is said to be originated by ASx if there is a route object for p with ASx as the value of the origin attribute.
For example, in Figure 15, the route set rs special contains 128.9.0.0/16, routes of AS1 and AS2, and routes of the ASes in AS set AS FOO.
route set: rs special members: 128.9.0.0/16, AS1, AS2, AS FOO Figure 15:
Use of AS numbers and AS sets in route sets.
The set rs any contains all routes registered in IRR.
The set as any contains all ASes registered in IRR.
5.4 Filters and filter set
The attributes of the filter set class are shown in Figure 16.
A filter set object defines a set of routes that are matched by its filter.
The filter set attribute defines the name of the filter.
It is an RPSL name that starts with "fltr ".
> Figure 17:  filter set objects.
The filter attribute defines the set's policy filter.
A policy filter is a logical expression which when applied to a set of routes returns a subset of these routes.
We say that the policy filter matches the subset returned.
The policy filter can match routes using any BGP path attribute, such as the destination address prefix (or NLRI), AS path, or community attributes.
The policy filters can be composite by using the operators AND, OR, and NOT.
The following policy filters can be used to select a subset of routes: ANY The keyword ANY matches all routes.
The policy filter matches the set of routes whose destination address prefix is in the set.
{ } An address prefix can be optionally followed by a range operator (i.e. { 5.0.0.0/8^ , 128.9.0.0/16^ , 30.0.0.0/8^16, 30.0.0.0/8^24 32 } contains all the more specifics of 5.0.0.0/8 including 5.0.0.0/8, all the more specifics of 128.9.0.0/16 excluding 128.9.0.0/16, all the more specifics of 30.0.0.0/8 which are of length 16 such as 30.9.0.0/16, and all the more specifics of 30.0.0.0/8 which are of length 24 to 32 such as 30.9.9.96/28.
A route set name matches the set of routes that are members of the set.
A route set name may be a name of a route set object, an AS number, or a name of an as set object (AS numbers and as set names implicitly define route sets; please see Section 5.3).
For example: aut num: AS1 import: from AS2 accept AS2 import: from AS2 accept AS FOO import: from AS2 accept RS FOO
The keyword PeerAS can be used instead of the AS number of the peer AS.
PeerAS is particularly useful when the peering is specified using an AS expression.
AS FOO members: AS2, AS3 aut num: AS1 import: from AS FOO accept PeerAS is same as:
AS1 import: from AS2 accept AS2 import: from
AS Path Regular Expressions An AS path
An AS path policy filter matches the set of routes which traverses a sequence of ASes matched by the AS path regular expression.
A router can check this using the AS PATH attribute in the Border Gateway Protocol [19], or the RD PATH attribute in the Inter Domain Routing Protocol [18].
AS path Regular Expressions are POSIX compliant regular expressions over the alphabet of AS numbers.
The regular expression constructs are as follows:
ASN where ASN is an AS number.
ASN matches the AS path that is of length 1 and contains the corresponding AS number (e.g.  AS path regular expression AS1
matches the AS path "1").
The keyword PeerAS can be used instead of the AS number of the peer AS.
AS set where AS set is an AS set name.
AS set matches the AS paths that is matched by one of the ASes in the AS set.
matches the AS paths matched by any AS number.
It matches the AS paths matched by the AS numbers listed between the brackets.
The AS numbers in the set are separated by white space characters.
If an as set name is listed, all AS numbers in the as set are included.
It matches any AS path which is not matched by the AS numbers in the set.
Matches the empty string at the beginning of an AS path.
$ Matches the empty string at the end of an AS path.
We next list the regular expression operators in the decreasing order of evaluation.
These operators are left associative, i.e. performed left to right.
{m} {m,n} {m,} For a regular expression A, A  matches zero or more occurrences of A; A  matches one or more occurrences of A;
matches zero or one occurrence of A
; A{m} matches m occurrence of A; A{m,n} matches m to n occurrence of A
; A{m,} matches m or more occurrence of A.
For example, [AS1 AS2]{2} matches AS1 AS1, AS1 AS2, AS2 AS1, and AS2 AS2.
} ~{m,n} ~{m,} These operators have similar functionality as the corresponding operators listed above, but all occurrences of the regular expression has to match the same pattern.
For example, [AS1 AS2]~{2} matches AS1 AS1 and AS2 AS2, but it does not match AS1 AS2 and AS2 AS1.
This is an implicit operator and exists between two regular expressions A and B when no other explicit operator is specified.
The resulting expression A B matches an AS path if A matches some prefix of the AS path and B matches the rest of the AS path.
For a regular expressions A and B, A   B matches any AS path that is matched by A or B. Parenthesis can be used to override the default order of evaluation.
White spaces can be used to increase readability.
The following are examples of AS path filters:
The first example matches any route whose AS path contains AS3, the second matches routes whose AS path starts with AS1, the third matches routes whose AS path ends with AS2, the fourth matches routes whose AS path is exactly "1 2 3", and the fifth matches routes whose AS path starts with AS1 and ends in AS2 with any number of AS numbers in between.
The following operators (in decreasing order of evaluation) can be used to form composite policy filters: NOT Given a policy filter
, NOT x matches the set of routes that are not matched by x.
That is it is the negation of policy filter x. AND
x AND y matches the intersection of the routes that are matched by
and that are matched by y. OR
y matches the union of the routes that are matched by
and that are matched by y. Note that an OR operator can be implicit, that is `x y' is equivalent to
} The first example matches any route except 128.9.0.0/16 and 128.8.0.0/16.
The second example matches the routes of AS226, AS227 and AS228.
The third example matches the routes of AS226 except 128.9.0.0/16.
The fourth example matches the routes of AS226 whose length are not longer than 18.
Routing Policy Attributes Policy filters can also use the values of other attributes for comparison.
The attributes whose values can be used in policy filters are specified in the RPSL dictionary.
Please refer to Section 7 for details.
An example using the the BGP community attribute is shown below: aut num: AS1 export: to AS2 announce AS1 AND NOT community(NO EXPORT)
Filters using the routing policy attributes defined in the dictionary are evaluated before evaluating the operators AND, OR and NOT.
A filter set name matches the set of routes that are matched by its filter attribute.
Note that the filter attribute of a filter set, can recursively refer to other filter set names.
For example in Figure 17, fltr foo matches { 5.0.0.0/8, 6.0.0.0/8 }, and fltr bar matches AS1'S routes or { 5.0.0.0/8, 6.0.0.0/8 } if their as path contained AS2.
The attributes of the rtr set class are shown in Figure 18.
The rtr set attribute defines the name of the set.
It is an RPSL name that starts with "rtrs ".
The members attribute lists the members of the set.
The members attribute is a list of inet rtr names, ipv4 addresses or other rtr set names.
or  optional, multi valued <rtr set names
rtr set Class Attributes Figure 19 presents two rtr set objects.
The set rtrs foo contains two routers, namely rtr1.isp.net and
The set rtrs bar contains the members of the set rtrs foo and rtr3.isp.net, that is it contains
rtr2.isp.net   members: rtr3.isp.net, rtrs foo Figure 19:  rtr set objects.
The mbrs by ref attribute is a list of maintainer names or the keyword ANY.
If this attribute is used, the router set also includes routers whose inet rtr objects are registered by one of these maintainers and whose member of attribute refers to the name of this router set.
If the value of a mbrs by ref attribute is ANY, any inet rtr object referring to the router set is a member of the set.
If the mbrs by ref attribute is missing, only the routers listed in the members attribute are members of the set.
rtrs foo members: rtr1.isp.net, rtr2.isp.net mbrs by ref:
rtr3.isp.net local as: as1 ifaddr: 1.1.1.1 masklen 30 member of: rtrs foo mnt by: MNTR ME Figure 20:  rtr set objects.
Figure 20 presents an example rtr set object that uses the mbrs by  ref attribute.
The set rtrs foo contains rtr1.isp.net,
5.6 Peerings and peering set Class
The attributes of the peering set class are shown in Figure 21.
A peering set object defines a set of peerings that are listed in its peering attributes.
The peering set attribute defines the name of the set.
It is an RPSL name that starts with "prng ".
Example topology consisting of three ASes, AS1, AS2, and AS3; two exchange points, EX1 and EX2; and six routers.
In describing peerings, we are going to use the topology of Figure 22.
In this topology, there are three ASes, AS1, AS2, and AS3; two exchange points, EX1 and EX2; and six routers.
Routers connected to the same exchange point peer with each other and exchange routing information.
7.7.7.2 and 7.7.7.3 peer with each other; 9.9.9.1, 9.9.9.2 and 9.9.9.3 peer with each other.
The syntax of a peering specification is: <as expression> [<router expression 1>] [at <router expression 2>]
<peering set name> where <as expression> is an expression over AS numbers and AS sets using operators AND, OR, and EXCEPT, and <router expression 1> and <router expression 2
> are expressions over router IP addresses, inet rtr names, and rtr set names using operators AND, OR, and EXCEPT.
The binary "EXCEPT" operator is the set subtraction operator and has the same precedence as the operator
AND (it is semantically equivalent to "AND NOT" combination).
That is "(AS1 OR AS2)
This form identifies all the peerings between any local router in <router expression 2> to any of their peer routers in <router  expression 1> in the ASes in <as expression
If <router  expression 2> is not specified, it defaults to all routers of the local AS that peer with ASes in <as expression>.
If <router  expression 1> is not specified, it defaults to all routers of the peer ASes in <as expression> that peer with the local AS.
If a <peering set name> is used, the peerings are listed in the corresponding peering set object.
Note that the peering set objects can be recursive.
Many special forms of this general peering specification is possible.
The following examples illustrate the most common cases, using the import attribute of the aut num class.
In the following example 7.7.7.1 imports 128.9.0.0/16 from 7.7.7.2.
AS1 import: from AS2 7.7.7.2 at 7.7.7.1 accept { 128.9.0.0/16 }
In the following example 7.7.7.1 imports 128.9.0.0/16 from 7.7.7.2 and 7.7.7.3.
AS1 import: from AS2 at 7.7.7.1 accept { 128.9.0.0/16 }
In the following example 7.7.7.1 imports 128.9.0.0/16 from 7.7.7.2 and 7.7.7.3, and 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2.
from AS2 accept { 128.9.0.0/16 }
In the following example 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2 and 9.9.9.3.
In the following example 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2 and 9.9.9.3, and 7.7.7.1 imports 128.9.0.0/16 from 7.7.7.2 and 7.7.7.3.
In the following example AS1 imports 128.9.0.0/16 from AS3 at router 9.9.9.1 (6) aut num:
AS1 import: from AS FOO and not AS2 at not 7.7.7.1 accept { 128.9.0.0/16 }
This is because "AS FOO and not AS2" equals AS3 and "not 7.7.7.1" equals 9.9.9.1.
In the following example 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2 and 9.9.9.3.
(7) peering set: prng bar peering:
AS1 at 9.9.9.1 peering set:
prng bar peering: AS2 at 9.9.9.1 aut num:
AS1 import: from prng foo accept { 128.9.0.0/16 } 6 aut
num Class Routing policies are specified using the aut num class.
The attributes of the aut num class are shown in Figure 23.
The value of the aut num attribute is the AS number of the AS described by this object.
The as name attribute is a symbolic name (in RPSL name syntax) of the AS.
The import, export and default routing policies of the AS are specified using import, export and default attributes respectively.
mandatory, single valued member of  list of <as set names
6.1 import Attribute:  Import Policy Specification
In RPSL, an import policy is divided into import policy expressions.
Each import policy expression is specified using an import attribute.
The import attribute has the following syntax (we will extend this syntax later in Sections 6.3 and 6.6):
> The action specification is optional.
The semantics of an import attribute is as follows: the set of routes that are matched by <filter> are imported from all the peers in <peerings>; while importing routes at <peering M>, <action M> is executed.
AS1 import: from AS2 action pref   1; accept { 128.9.0.0/16 }
This example states that the route 128.9.0.0/16 is accepted from AS2 with preference 1.
We already presented how peerings (see Section 5.6) and filters (see Section 5.4) are specified.
We next present how to specify actions.
6.1.1 Action Specification Policy actions in RPSL either set or modify route attributes, such as assigning a preference to a route, adding a BGP community to the BGP community path attribute, or setting the MULTI EXIT DISCRIMINATOR attribute.
Policy actions can also instruct routers to perform special operations, such as route flap damping.
The routing policy attributes whose values can be modified in policy actions are specified in the RPSL dictionary.
Please refer to Section 7 for a list of these attributes.
It is possible to form composite policy actions by listing them one after the other.
In a composite policy action, the actions are executed left to right.
For example, aut num: AS1 import: from AS2 action pref   10; med   0; community.append(10250, 3561:10); accept { 128.9.0.0/16 } sets pref to 10, med to 0, and then appends 10250 and 3561:10 to the BGP community path attribute.
The pref attribute is the inverse of the local pref attribute (i.e. local pref   65535 pref).
A route with a local pref attribute is always preferred over a route without one.
AS1 import: from AS2 action pref   1
; from AS3 action pref   2; accept AS4
The above example states that AS4's routes are accepted from AS2 with preference 1, and from AS3 with preference 2 (routes with lower integer preference values are preferred over routes with higher integer preference values).
The above example states that AS4's routes are accepted from AS2 on peering 7.7.7.1 7.7.7.2 with preference 1, and on any other peering with AS2 with preference 2.
6.2 export Attribute:  Export Policy Specification Similarly, an export policy expression is specified using an export attribute.
The export attribute has the following syntax: export: to <peering 1>
> The action specification is optional.
The semantics of an export attribute is as follows:  the set of routes that are matched by <filter> are exported to all the peers specified in <peerings>; while exporting routes at <peering M>, <action M> is executed.
AS1 export: to AS2 action med   5; community .
In this example, AS4's routes are announced to AS2 with the med attribute's value set to 5 and community 70 added to the community list.
AS1 export: to AS FOO announce ANY
In this example, AS1 announces all of its routes to the ASes in the set AS FOO.
6.3 Other Routing Protocols, Multi Protocol Routing Protocols, and Injecting Routes Between Protocols The more complete syntax of the import and export attributes are as follows:
import: [protocol <protocol 1>] [into <protocol 2>] from <peering 1
[protocol <protocol 1>] [into <protocol 2>] to <peering 1
> Where the optional protocol specifications can be used for specifying policies for other routing protocols, or for injecting routes of one protocol into another protocol, or for multi protocol routing policies.
The valid protocol names are defined in the dictionary.
> is the name of the protocol whose routes are being exchanged.
> is the name of the protocol which is receiving these routes.
> default to the Internet Exterior Gateway Protocol, currently BGP.
In the following example, all interAS routes are injected into RIP.
AS1 import: from AS2 accept AS2 export: protocol BGP4 into RIP to AS1 announce ANY
In the following example, AS1 accepts AS2's routes including any more specifics of AS2's routes, but does not inject these extra more specific routes into OSPF.
AS1 import: from AS2 accept AS2^  export: protocol BGP4 into OSPF to AS1 announce AS2
In the following example, AS1 injects its static routes (routes which are members of the set AS1:RS STATIC ROUTES) to the interAS routing protocol and appends AS1 twice to their AS paths.
AS1 import: protocol STATIC into BGP4 from AS1 action aspath.prepend(AS1, AS1)
; accept AS1:RS STATIC ROUTES
In the following example, AS1 imports different set of unicast routes for multicast reverse path forwarding from AS2: aut num: AS1 import: from AS2 accept AS2 import: protocol IDMR from AS2 accept AS2:RS RPF ROUTES 6.4 Ambiguity Resolution
It is possible that the same peering can be covered by more that one peering specification in a policy expression.
For example: aut num: AS1 import: from AS2 7.7.7.2 at 7.7.7.1 action pref   2; from AS2 7.7.7.2 at 7.7.7.1 action pref   1; accept AS4
This is not an error, though definitely not desirable.
To break the ambiguity, the action corresponding to the first peering specification is used.
That is the routes are accepted with preference 2.
We call this rule as the specification order rule.
The specification order rule still applies, and only the action "pref   2" is executed.
In fact, the second peering action pair has no use since the first peering action pair always covers it.
If the intended policy was to accept these routes with preference 1 on this particular peering and with preference 2 in all other peerings, the user should have specified:
AS1 import: from AS2 7.7.7.2 at 7.7.7.1 action pref   1
It is also possible that more than one policy expression can cover the same set of routes for the same peering.
AS1 import: from AS2 action pref   2; accept AS4 import: from AS2 action pref   1; accept AS4
In this case, the specification order rule is still used.
That is, AS4's routes are accepted from AS2 with preference 2.
If the filters were overlapping but not exactly the same: aut num:
AS1 import: from AS2 action pref   2; accept AS4 import: from AS2 action pref   1; accept AS4 OR AS5 the AS4's routes are accepted from AS2 with preference 2 and however AS5's routes are also accepted, but with preference 1.
We next give the general specification order rule for the benefit of the RPSL implementors.
aut num: AS1 import: from peerings 1 action action 1 accept filter 1 import: from peerings 2 action action 2 accept filter 2
The above policy expressions are equivalent to the following three expressions where there is no ambiguity:
AS1 import: from peerings 1 action action 1 accept filter 1 import: from peerings 3 action action 2 accept filter 2 AND NOT filter 1 import: from peerings 4 action action 2
accept filter 2 where peerings 3 are those that are covered by both peerings 1 and peerings 2, and peerings 4 are those that are covered by peerings 2 but not by peerings 1
("filter 2 AND NOT filter 1" matches the routes that are matched by filter 2 but not by filter 1).
AS1 import: from AS2 7.7.7.2 at 7.7.7.1 action pref   2; accept {128.9.0.0/16} import: from AS2 action pref   1; accept {128.9.0.0/16, 75.0.0.0/8} Lets consider two peerings with AS2, 7.7.7.1 7.7.7.2 and 9.9.9.1
Both policy expressions cover 7.7.7.1 7.7.7.2.
On this peering, the route 128.9.0.0/16 is accepted with preference 2, and the route 75.0.0.0/8 is accepted with preference 1.
The peering 9.9.9.1 9.9.9.2 is only covered by the second policy expressions.
Hence, both the route 128.9.0.0/16 and the route 75.0.0.0/8 are accepted with preference 1 on peering 9.9.9.1 9.9.9.2.
Note that the same ambiguity resolution rules also apply to export and default policy expressions.
Default Policy Specification Default routing policies are specified using the default attribute.
The default attribute has the following syntax: default: to <peering> [action <action>]
The <action> and <filter> specifications are optional.
The semantics are as follows:
The <peering> specification indicates the AS (and
the router if present) is being defaulted to; the <action> specification, if present, indicates various attributes of defaulting, for example a relative preference if multiple defaults are specified; and the <filter> specifications, if present, is a policy filter.
A router only uses the default policy if it received the routes matched by <filter> from this peer.
In the following example, AS1 defaults to AS2 for routing.
In the following example, router 7.7.7.1 in AS1 defaults to router 7.7.7.2 in AS2.
AS1 default: to AS2 7.7.7.2 at 7.7.7.1
In the following example, AS1 defaults to AS2 and AS3, but prefers AS2 over AS3.
AS1 default: to AS2 action pref   1; default: to AS3 action pref   2; In the following example, AS1 defaults to AS2 and uses 128.9.0.0/16 as the default network.
AS1 default: to AS2 networks { 128.9.0.0/16
} 6.6 Structured Policy Specification
The import and export policies can be structured.
We only reccomend structured policies to advanced RPSL users.
Please feel free to skip this section.
] <import expression> Please note the semicolon at the end of an <import factor
If the policy specification is not structured (as in all the examples in other sections), this semicolon is optional.
The syntax and semantics for an <import factor> is already defined in Section 6.1.
> is either a sequence of <import factor
or just a single <import  factor
The semantics of an <import term> is the union of <import  factor>'s using the specification order rule.
> is either a single <import term> or an <import term> followed by one of the keywords "except" and "refine", followed by another <import  expression
Note that our definition allows nested expressions.
Hence there can be exceptions to exceptions, refinements to refinements, or even refinements to exceptions, and so on.
The semantics for the except operator is as follows:
The result of an except operation is another <import term
The resulting policy set contains the policies of the right hand side but their filters are modified to only include the routes also matched by the left hand side.
The policies of the left hand side are included afterwards and their filters are modified to exclude the routes matched by the right hand side.
Please note that the filters are modified during this process but the actions are copied verbatim.
When there are multiple levels of nesting, the operations (both except and refine) are performed right to left.
In this example, the route 128.9.0.0/16 is accepted from AS3, any other route (not 128.9.0.0/16) originated by AS226 is accepted from AS2, and any other ASes' routes in as foo is accepted from AS1.
We can come to the same conclusion using the algebra defined above.
; from AS1 action pref   1; accept as foo AND NOT (
; } Since AS226 is in as foo and 128.9.0.0/16 is in AS226, it simplifies to: import: { from AS3 action pref   3; accept {128.9.0.0/16}; from AS2 action pref   2; accept AS226 AND NOT {128.9.0.0/16}; from AS1 action pref   1; accept as foo AND NOT
; } In the case of the refine operator, the resulting set is constructed by taking the cartasian product of the two sides as follows:  for each policy l in the left hand side and for each policy r in the right hand side, the peerings of the resulting policy are the peerings common to both r and l; the filter of the resulting policy is the intersection of l's filter and r's filter; and action of the resulting policy is l's action followed by r's action.
If there are no common peerings, or if the intersection of filters is empty, a resulting policy is not generated.
However, only AS1's routes are imported from AS1, and only AS2's routes are imported from AS2, and only AS3's routes are imported form AS3, and no routes are imported from any other AS.
We can reach the same conclusion using the above algebra.
That is, our example is equivalent to: import: { from AS1 action pref   1; accept community(3560:10) AND AS1; from AS1 action pref   2; accept community(3560:20) AND AS1; from AS2 action pref   1; accept community(3560:10) AND AS2; from AS2 action pref   2; accept community(3560:20) AND AS2; from AS3 action pref   1; accept community(3560:10) AND AS3; from AS3 action pref   2; accept community(3560:20) AND AS3; } Note that the common peerings between "from AS1" and "from AS ANY" are those peerings in "from AS1".
Even though we do not formally define "common peerings", it is straight forward to deduce the definition from the definitions of peerings (please see Section 5.6).
This is equivalent to: import: { from AS1 at 7.7.7.1 action med 0; pref 1; accept {0.0.0.0/0^
structured export policies with "from" replaced with "to" and "accept" is replaced with "announce".
The dictionary class provides extensibility to RPSL.
Dictionary objects define routing policy attributes, types, and routing protocols.
Routing policy attributes, henceforth called rp  attributes, may correspond to actual protocol attributes, such as the BGP path attributes (e.g. community, dpa, and AS path), or they may correspond to router features (e.g. BGP route flap damping).
As new protocols, new protocol attributes, or new router features are introduced, the dictionary object is updated to include appropriate rp attribute and protocol definitions.
An rp attribute is an abstract class; that is a data representation is not available.
Instead, they are accessed through access methods.
For example, the rp attribute for the BGP AS path attribute is called aspath; and it has an access method called prepend which stuffs extra AS numbers to the AS path attributes.
Access methods can take arguments.
For example, the method prepend above takes AS numbers as arguments.
Once an rp attribute is defined in the dictionary, it can be used to describe policy filters and actions.
Policy analysis tools are required to fetch the dictionary object and recognize newly defined rp attributes, types, and protocols.
The analysis tools may approximate policy analyses on rp attributes that they do not understand:  a filter method may always match, and an action method may always perform no operation.
Analysis tools may even download code to perform appropriate operations using mechanisms outside the scope of RPSL.
We next describe the syntax and semantics of the dictionary class.
This description is not essential for understanding dictionary objects (but it is essential for creating one).
Please feel free to skip to the RPSL Initial Dictionary subsection (Section 7.1).
The attributes of the dictionary class are shown in Figure 24.
The dictionary attribute is the name of the dictionary object, obeying the RPSL naming rules.
There can be many dictionary objects, however there is always one well known dictionary object "RPSL".
All tools use this dictionary by default.
mandatory, single valued, class key rp attribute  see description in text optional,
where <name> is the name of the rp attribute; and <method i
> is the name of an access method for the rp attribute, taking Ni arguments where the j th argument is of type <type
A method name is either an RPSL name or one of the operators defined in Figure 25.
The operator methods with the exception of operator() and operator[] can take only one argument.
An rp attribute can have many methods defined for it.
Some of the methods may even have the same name, in which case their arguments are of different types.
In this case, the actual arguments after the Nth argument are of type <type N
A <type> in RPSL is either a predefined type, a union type, a list type, or a dictionary defined type.
The predefined types are listed in Figure 26.
The integer and the real predefined types can be followed by a lower and an upper bound to specify the set of valid values of the argument.
The range specification is optional.
We use the ANSI C language conventions for representing integer, real and string values.
The enum type is followed by a list of RPSL names which are the valid values of the type.
The boolean type can take the values true or false.
as number, ipv4 address, address prefix and dns name types
are as in Section 2.
filter type is a policy filter as in Section 6.
The value of filter type is suggested to be enclosed in parenthesis.
The syntax of a union type is as follows:
where <type i> is an RPSL type.
The union type is either of the types <type 1> through <type N
> (analogous to unions in C[14]).
The syntax of a list type is as follows: list [<min elems>:<max elems>] of <type>
In this case, the list elements are of <type> and the list contains at least <min elems
> and at most <max elems> elements.
The size specification is optional.
If it is not specified, there is no restriction in the number of list elements.
The typedef attribute in the dictionary defines named types as follows: typedef: <name> <type>
where <name> is a name for type <type
typedef attribute is paticularly useful when the type defined is not a predefined type (e.g. list of unions, list of lists, etc.).
A protocol attribute of the dictionary class defines a protocol and a set of peering parameters for that protocol (which are used in inet  rtr class in Section 9).
Its syntax is as follows: protocol: <name> MANDATORY
The syntax and semantics of the arguments are as in the rp attribute.
If the keyword MANDATORY is used, the parameter is mandatory and needs to be specified for each peering of this protocol.
If the keyword OPTIONAL is used, the parameter can be skipped.
7.1 Initial RPSL Dictionary and Example Policy Actions and Filters dictionary:
# BGP multi exit discriminator attribute med # to set med to 10:
med   10; # to set med to the IGP metric: med   igp cost; operator (union integer[0, 65535], enum[igp cost])
rp attribute: # BGP destination preference attribute (dpa) dpa operator (integer[0, 65535])
# a community value in RPSL is either #  a 4 byte integer (ok to use 3561:70 notation)
#  internet, no export, no advertise (see RFC 1997)
community elm union integer[1, 4294967295], enum[internet, no export, no advertise], typedef:
# list of community values { 40, no export, 3561:70 } community list list of community elm rp attribute:
# BGP community attribute community # set to a list of communities operator (community list)
# append community values operator.
# shortcut to contains: community(no export, 3561:70)
# order independent equality comparison operator (community list)
rp attribute: # next hop router in a static route next hop
# to set to 7.7.7.7:
next hop   7.7.7.7; # to set to router's own address:
next hop   self; operator (union ipv4 address, enum[self])
# cost of a static route cost operator (integer[0, 65535]) protocol:
BGP4 # as number of the peer router MANDATORY
, # penalty value for reuse integer[0,65535
# halflife in secs when down integer[0,65535])
# maximum penalty protocol: OSPF protocol: RIP protocol:
IGRP protocol: IS IS protocol: STATIC protocol:
RIPng protocol: DVMRP protocol: PIM DM protocol:
PIM SM protocol: CBT protocol:
MOSPF Figure 27:  RPSL Dictionary Figure 27 shows the initial RPSL dictionary.
It has seven rp  attributes:  pref to assign local preference to the routes accepted;
med to assign a value to the MULTI EXIT DISCRIMINATOR BGP attribute; dpa to assign a value to the DPA BGP attribute; aspath to prepend a value to the AS PATH BGP attribute; community to assign a value to or to check the value of the community BGP attribute; next hop to assign next hop routers to static routes; and cost to assign a cost to static routes.
The dictionary defines two types:  community elm and community list.
community elm type is either a 4 byte unsigned integer, or one of the keywords internet, no export or no advertise (defined in [9]).
The initial dictionary (Figure 27) defines only options for the Border Gateway Protocol:  asno and flap damp.
The mandatory asno option is the AS number of the peer router.
The optional flap damp option instructs the router to damp route flaps [21] when importing routes from the peer router.
It can be specified with or without parameters.
If parameters are missing, they default to: flap damp(1000, 2000, 750, 900, 900, 20000)
That is, a penalty of 1000 is assigned at each route flap, the route is suppressed when penalty reaches 2000.
The penalty is reduced in half after 15 minutes (900 seconds) of stability regardless of whether the route is up or down.
A supressed route is reused when the penalty falls below 750.
The maximum penalty a route can be assigned is 20,000 (i.e. the maximum suppress time after a route becomes stable is about 75 minutes).
These parameters are consistent with the default flap damping parameters in several routers.
Policy Actions and Filters Using RP Attributes
The syntax of a policy action or a filter using an rp attribute
x "op" argument where method is a method and "op" is an operator method of the rp  attribute x.
If an operator method is used in specifying a composite policy filter, it evaluates earlier than the composite policy filter operators (i.e. AND, OR, NOT, and implicit or operator).
The pref rp attribute can be assigned a positive integer as follows: pref   10; The med rp attribute can be assigned either a positive integer or the word "igp cost" as follows: med   0; med   igp cost; The dpa rp attribute can be assigned a positive integer as follows:
dpa   100; The BGP community attribute is list valued
, that is it is a list of 4 byte integers each representing a "community".
The following examples demonstrate how to add communities to this rp attribute: community .
{ 100 }; community .
{ NO EXPORT }; community .
{ 3561:10 }; In the last case, a 4 byte integer is constructed where the more significant two bytes equal 3561 and the less significant two bytes equal 10.
The following examples demonstrate how to delete communities from the community rp attribute: community.delete(100, NO EXPORT, 3561:10); Filters that use the community rp attribute can be defined as demonstrated by the following examples:
In the latter case, the community rp attribute is cleared.
The community rp attribute can be compared against a list of communities as follows:
# the first argument should be 3561 Figure 28
shows a more advanced example using the rp attribute community.
In this example, AS3561 bases its route selection preference on the community attribute.
Other ASes may indirectly affect AS3561's route selection by including the appropriate communities in their route announcements.
AS1 export: to AS2 action community. {3561:90}; to AS3 action community.
{3561:80}; announce AS1 as set:
:AS PEERS members: AS2, AS3 aut num:
AS3561 import: from AS3561:AS PEERS action pref   10; accept community(3561:90) import: from AS3561:
AS PEERS action pref   20; accept community(3561:80) import: from AS3561:
AS PEERS action pref   20; accept community(3561:70) import: from AS3561:AS PEERS action pref   0; accept ANY Figure 28:  Policy example using the community rp attribute.
Advanced route Class 8.1 Specifying Aggregate Routes
The components, aggr bndry, aggr mtd, export comps, inject, and holes attributes are used for specifying aggregate routes [11].
A route object specifies an aggregate route if any of these attributes, with the exception of inject, is specified.
The origin attribute for an aggregate route is the AS performing the aggregation, i.e. the aggregator AS.
In this section, we used the term "aggregate" to refer to the route generated, the term "component" to refer to the routes used to generate the path attributes of the aggregate, and the term "more specifics" to refer to any route which is a more specific of the aggregate regardless of whether it was used to form the path attributes.
The components attribute defines what component routes are used to form the aggregate.
Its syntax is as follows:
where <protocol> is a routing protocol name such as BGP4, OSPF or RIP (valid names are defined in the dictionary) and <filter> is a policy expression.
The routes that match one of these filters and are learned from the corresponding protocol are used to form the aggregate.
If <protocol> is omitted, it defaults to any protocol.
<filter> implicitly contains an "AND" term with the more specifics of the aggregate so that only the component routes are selected.
If the keyword ATOMIC is used, the aggregation is done atomically [11].
If a <filter> is not specified it defaults to more specifics.
If the components attribute is missing, all more specifics without the ATOMIC keyword is used.
protocol BGP4 {128.8.0.0/16^ } protocol OSPF {128.9.0.0/16^ } Figure 29:  Two aggregate route objects.
Figure 29 shows two route objects.
In the first example, more specifics of 128.8.0.0/15 with AS paths starting with AS2 are aggregated.
In the second example, some routes learned from BGP and some routes learned form OSPF are aggregated.
The aggr bndry attribute is an AS expression over AS numbers and sets (see Section 5.6).
The result defines the set of ASes which form the aggregation boundary.
If the aggr bndry attribute is missing, the origin AS is the sole aggregation boundary.
Outside the aggregation boundary, only the aggregate is exported and more specifics are suppressed.
However, within the boundary, the more specifics are also exchanged.
The aggr mtd attribute specifies how the aggregate is generated.
Its syntax is as follows:
where <as expression> is an expression over AS numbers and sets (see Section 5.6).
If <as expression> is missing, it defaults to AS ANY.
If outbound aggregation is specified, the more specifics of the aggregate will be present within the AS and the aggregate will be formed at all inter AS boundaries with ASes in <as expression> before export, except for ASes that are within the aggregating boundary (i.e. aggr bndry is enforced regardless of <as expression>).
If inbound aggregation is specified, the aggregate is formed at all inter AS boundaries prior to importing routes into the aggregator AS.
Note that <as expression> can not be specified with inbound aggregation.
If aggr mtd attribute is missing, it defaults to "outbound AS ANY".
AS1 OR AS2 aggr mtd:
outbound AS ANY Figure 30:
Outbound multi AS aggregation example.
Figure 30 shows an example of an outbound aggregation.
In this example, AS1 and AS2 are coordinating aggregation and announcing only the less specific 128.8.0.0/15 to outside world, but exchanging more specifics between each other.
This form of aggregation is useful when some of the components are within AS1 and some are within AS2.
When a set of routes are aggregated, the intent is to export only the aggregate route and suppress exporting of the more specifics outside the aggregation boundary.
However, to satisfy certain policy and topology constraints (e.g. a multi homed component), it is often required to export some of the components.
The export comps attribute equals an RPSL filter that matches the more specifics that need to be exported outside the aggregation boundary.
If this attribute is missing, more specifics are not exported outside the aggregation boundary.
Note that, the export comps filter contains an implicit "AND" term with the more specifics of the aggregate.
Figure 31 shows an example of an outbound aggregation.
In this example, the more specific 128.8.8.0/24 is exported outside AS1 in addition to the aggregate.
This is useful, when 128.8.8.0/24 is multi homed site to AS1 with some other AS.
ANY export comps: {128.8.8.0/24} Figure 31:  Outbound aggregation with export exception.
The inject attribute specifies which routers perform the aggregation and when they perform it.
Its syntax is as follow:
[action <action>] [upon <condition>] where <action> is an action specification (see Section 6.1.1), <condition>
is a boolean expression described below, and <router  expression> is as described in Section 5.6.
All routers in <router expression
> and in the aggregator AS perform the aggregation.
If a <router expression> is not specified, all routers inside the aggregator AS perform the aggregation.
The <action> specification may set path attributes of the aggregate, such as assign a preferences to the aggregate.
The upon clause is a boolean condition.
The aggregate is generated if and only if this condition is true.
<condition> is a boolean expression using the logical operators AND and OR (i.e. operator NOT is not allowed) over: HAVE COMPONENTS { list of prefixes } EXCLUDE { list of prefixes } STATIC
The list of prefixes in HAVE COMPONENTS can only be more specifics of the aggregate.
It evaluates to true when all the prefixes listed are present in the routing table of the aggregating router.
In this case, at least one prefix from each prefix range needs to be present in the routing table for the condition to be true.
The list of prefixes in EXCLUDE can be arbitrary.
It evaluates to true when none of the prefixes listed is present in the routing table.
The list can also include prefix ranges, and no prefix in that range should be present in the routing table.
The keyword static always evaluates to true.
If no upon clause is specified the aggregate is generated if an only if there is a component in the routing table (i.e. a more specific that matches the filter in the components attribute).
Figure 32 shows two examples.
In the first case, the aggregate is injected at two routers each one setting the dpa path attribute differently.
In the second case, the aggregate is generated only if both 128.8.0.0/16 and 128.9.0.0/16 are present in the routing table, as opposed to the first case where the presence of just one of them is sufficient for injection.
The holes attribute lists the component address prefixes which are not reachable through the aggregate route (perhaps that part of the address space is unallocated).
The holes attribute is useful for diagnosis purposes.
In Figure 32, the second example has a hole, namely 128.8.8.0/24.
This may be due to a customer changing providers and taking this part of the address space with it.
8.1.1 Interaction with policies in aut num class
An aggregate formed is announced to other ASes only if the export policies of the AS allows exporting the aggregate.
When the aggregate is formed, the more specifics are suppressed from being exported except to the ASes in aggr bndry and except the components in export comps.
For such exceptions to happen, the export policies of the AS should explicitly allow exporting of these exceptions.
If an aggregate is not formed (due to the upon clause), then the more specifics of the aggregate can be exported to other ASes, but only if the export policies of the AS allows it.
In other words, before a route (aggregate or more specific) is exported it is filtered twice, once based on the route objects, and once based on the export policies of the AS.
AS1 export:  to AS2 announce AS1 export:  to AS3 announce AS1 and not {128.9.0.0/16} export:  to AS4 announce AS1 export:  to AS5 announce AS1 export:  to AS6 announce AS1 Figure 33:  Interaction with policies in aut num class.
In Figure 33 shows an interaction example.
By examining the route objects, the more specifics 128.8.0.0/16 and 128.9.0.0/16 should be exchanged between AS1, AS2 and AS3 (i.e. the aggregation boundary).
Outbound aggregation is done to AS4 and AS5 and not to AS3, since AS3 is in the aggregation boundary.
The aut num object allows exporting both components to AS2, but only the component 128.8.0.0/16 to AS3.
The aggregate can only be formed if both components are available.
In this case, only the aggregate is announced to AS4 and AS5.
However, if one of the components is not available the aggregate will not be formed, and any available component or more specific will be exported to AS4 and AS5.
Regardless of aggregation is performed or not, only the more specifics will be exported to AS6 (it is not listed in the aggr mtd attribute).
When doing an inbound aggregation, configuration generators may eliminating the aggregation statements on routers where import policy of the AS prohibits importing of any more specifics.
8.1.2 Ambiguity resolution with overlapping aggregates When several aggregate routes are specified and they overlap, i.e. one is less specific of the other, they must be evaluated more specific to less specific order.
When an outbound aggregation is performed for a peer, the aggregate and the components listed in the export comps attribute for that peer are available for generating the next less specific aggregate.
The components that are not specified in the export comps attribute are not available.
A route is exportable to an AS if it is the least specific aggregate exportable to that AS or
it is listed in the export comps attribute of an exportable route.
Note that this is a recursive definition.
AS1 aggr bndry:   AS1 or AS2 or AS3 aggr mtd:
} export comps: {128.10.0.0/15} Figure 34:  Overlapping aggregations.
In Figure 34, AS1 together with AS2 aggregates 128.8.0.0/16 and 128.9.0.0/16 into 128.8.0.0/15.
Together with AS3, AS1 aggregates 128.10.0.0/16 and 128.11.0.0/16
But altogether they aggregate these four routes into 128.8.0.0/14.
Assuming all four components are available, a router in AS1 for an outside AS, say AS4, will first generate 128.8.0.0/15 and 128.10.0.0/15.
and its exception 128.11.0.0/16 available for generating 128.8.0.0/14.
The router will then generate 128.8.0.0/14 from these three routes.
Hence for AS4, 128.8.0.0/14 and its exception 128.10.0.0/15
and its exception 128.11.0.0/16 will be exportable.
For AS2, a router in AS1 will only generate 128.10.0.0/15.
and its exception 128.11.0.0/16 will be exportable.
Note that 128.8.0.0/16 and 128.9.0.0/16 are also exportable since they did not participate in an aggregate exportable to AS2.
Similarly, for AS3, a router in AS1 will only generate 128.8.0.0/15.
In this case 128.8.0.0/15, 128.10.0.0/16, 128.11.0.0/16 are exportable.
The inject attribute can be used to specify static routes by using "upon static" as the condition:
In this case, the routers in <router expression> executes the <action> and injects the route to the interAS routing system statically.
<action> may set certain route attributes such as a next hop router or a cost.
In the following example, the router 7.7.7.1 injects the route 128.7.0.0/16.
The next hop routers (in this example, there are two next hop routers) for this route are 7.7.7.2 and 7.7.7.3 and the route has a cost of 10 over 7.7.7.2 and 20 over 7.7.7.3.
AS1 inject: at 7.7.7.1 action next hop   7.7.7.2; cost   10; upon static inject: at 7.7.7.1 action next hop   7.7.7.3; cost   20; upon static 9 inet rtr Class Routers are specified using the inet rtr class.
The attributes of the inet rtr class are shown in Figure 35.
The inet rtr attribute is a valid DNS name of the router described.
Each alias attribute, if present, is a canonical DNS name for the router.
The local as attribute specifies the AS number of the AS which owns/operates this router.
mandatory, single valued, class key alias
optional, multi valued local as
optional, multi valued Figure 35:
The value of an ifaddr attribute has the following syntax: <
The IP address and the mask length are mandatory for each interface.
Optionally an action can be specified to set other parameters of this interface.
Figure 36 presents an example inet rtr object.
The name of the router is "amsterdam.ripe.net".
"amsterdam1.ripe.net" is a canonical name for the router.
The router is connected to 4 networks.
Its IP addresses and mask lengths in those networks are specified in the ifaddr attributes.
AS3333 ifaddr:   192.87.45.190 masklen 24 ifaddr:
damp() Figure 36:  inet rtr Objects
Each peer attribute, if present, specifies a protocol peering with another router.
The value of a peer attribute has the following syntax:
> <peering set name>  <options> where <protocol> is a protocol name, <ipv4 address
> is the IP address of the peer router, and <options>
is a comma separated list of peering options for <protocol
Instead of the peer's IP address, its inet rtr name can be used.
Possible protocol names and attributes are defined in the dictionary (please see Section 7).
In the above example, the router has a BGP peering with the router 192.87.45.195 in AS3334 and turns the flap damping on when importing routes from this router.
Instead of a single peer, a group of peers can be specified by using the <rtr set name> and <peering set name> forms.
form is being used only the peerings in the corresponding peering set that are with this router are included.
Figure 37 shows an example inet rtr object with peering groups.
rtrs ibgp peers members: 1.1.1.1, 2.2.2.2, 3.3.3.3 peering set:
prng ebgp peers peering: AS3334 192.87.45.195 peering: AS3335 192.87.45.196 inet rtr:
AS3333 ifaddr:   192.87.45.190 masklen 24 ifaddr:
BGP4 rtrs ibgp peers asno(AS3333), flap damp
damp() Figure 37:  inet rtr Object with peering groups 10 Extending RPSL
Our experience with earlier routing policy languages and data formats (PRDB [2], RIPE 81 [8], and RIPE 181 [7]) taught us that RPSL had to be extensible.
As a result, extensibility was a primary design goal for RPSL.
New routing protocols or new features to existing routing protocols can be easily handled using RPSL's dictionary class.
New classes or new attributes to the existing classes can also be added.
This section provides guidelines for extending RPSL.
These guidelines are designed with an eye toward maintaining backward compatibility with existing tools and databases.
We next list the available options for extending RPSL from the most preferred to the least preferred order.
10.1 Extensions by changing the dictionary class
The dictionary class is the primary mechanism provided to extend RPSL.
Dictionary objects define routing policy attributes, types, and routing protocols.
We recommend updating the RPSL dictionary to include appropriate rp  attribute and protocol definitions as new path attributes or router features are introduced.
For example, in an earlier version of the RPSL document, it was only possible to specify that a router performs route flap damping on a peer, but it was not possible to specify the parameters of route flap damping.
Later the parameters were added by changing the dictionary.
When changing the dictionary, full compatibility should be maintained.
For example, in our flap damping case, we made the parameter specification optional in case this level of detail was not desired by some ISPs.
Any object registered without the parameters will continue to be valid.
Any tool based on RPSL is expected to do a default action on routing policy attributes that they do not understand (e.g. issue a warning and otherwise ignore).
Hence, old tools upon encountering a flap damping specification with parameters will ignore the parameters.
10.2 Extensions by adding new attributes to existing classes New attributes can be added to any class.
To ensure full compatibility, new attributes should not contradict the semantics of the objects they are attached to.
Any tool that uses the IRR should be designed so that it ignores attributes that it doesn't understand.
Most existing tools adhere to this design principle.
We recommend adding new attributes to existing classes when a new aspect of a class is discovered.
For example, RPSL route class extends its RIPE 181 predecessor by including several new attributes that enable aggregate and static route specification.
10.3 Extensions by adding new classes
New classes can be added to RPSL to store new types of policy data.
Providing full compatibility is straight forward as long as existing classes are still understood.
Since a tool should only query the IRR for the classes that it understand, full compatibility should not be a problem in this case.
Before adding a new class, one should question if the information contained in the objects of the new class could have better belonged to some other class.
For example, if the geographic location of a router needs to be stored in IRR, it may be tempting to add a new class called, say router location class.
However, the information better belongs to the inet rtr class, perhaps in a new attribute called location.
10.4 Extensions by changing the syntax of existing RPSL attributes If all of the methods described above fail to provide the desired extension, it may be necessary to change the syntax of RPSL.
Any change in RPSL syntax must provide backwards compatibility, and should be considered only as a last resort since full compatibility may not be achievable.
However, we require that the old syntax to be still valid.
11 Security Considerations This document describes RPSL, a language for expressing routing policies.
The language defines a maintainer (mntner class) object which is the entity which controls or "maintains" the objects stored in a database expressed by RPSL.
Requests from maintainers can be authenticated with various techniques as defined by the "auth" attribute of the maintainer object.
The exact protocols used by IRR's to communicate RPSL objects is beyond the scope of this document, but it is envisioned that several techniques may be used, ranging from interactive query/update protocols to store and forward protocols similar to or based on electronic mail (or even voice telephone calls).
Regardless of which protocols are used in a given situation, it is expected that appropriate security techniques such as IPSEC, TLS or PGP/MIME will be utilized.
The set of routing registries as of November 1996 are RIPE, RADB, CANet, MCI and ANS.
You may contact one of these registries to find out the current list of registries.
In this section we provide formal grammar rules for RPSL.
Basic data types are defined in Section 2.
We do not provide formal grammar rules for attributes whose values are of basic types or list of basic types.
The rules are written using the input language of GNU Bison parser.
Hence, they can be cut and pasted to that program. //
as expression as expression: as expression OP OR as expression term   as expression term as expression term: as expression term OP AND as expression factor
router expression OP OR router expression term   router expression term router expression term: router expression term OP AND router expression factor   router expression term KEYW
KEYW ACTION action action: single action   action single action single action:
operand OP MS    filter prefix operand filter prefix operand:
PEERAS   filter aspath range '.'
TKN ASNO   filter aspath range
TKN ASNAME filter rp attribute:
import term KEYW REFINE import expression   import term KEYW
TO peering filter attribute: ATTR FILTER filter peering attribute:
ATTR PEER tkn word peer
ATTR AGGR BNDRY as expression aggr mtd attribute:
UPON inject expression inject expression: inject expression OP OR inject expression term
inject expression term inject expression term:
filter   components list KEYW PROTOCOL tkn word filter components attribute:
/   rs members list rs members list:
TKN ASNO OP MS   TKN ASNAME
TKN ASNAME OP MS   TKN RSNAME
TKN PRFXV4RNG rs members attribute:
ATTR RS MEMBERS opt rs members list //
ATTR RP ATTR TKN WORD methods
ATTR RP ATTR TKN RP ATTR methods methods
: method   methods method method:
KEYW UNION typedef type list
KEYW RANGE KEYW OF typedef type
KEYW LIST KEYW OF typedef type enum list:
C Changes from RFC 2280 RFC 2280
[3] contains an earlier version of RPSL.
This section summarizes the changes since then.
It is now possible to write integers as sequence of four 1 octet integers (e.g. 1.1.1.1) or as sequence of two 2 octet integers (e.g.  3561:70).
The definition of address prefix range is extended so that an address prefix is also an address prefix range.
The semantics for a range operator applied to a set containing address prefix ranges is defined (e.g. {30.0.0.0/8^24 28}^27 30).
All dates are now in UTC.
The withdrawn attribute of route class is removed from the language.
filter set class is introduced.
rtr set class is introduced.
peering set class is introduced.
Filters can now refer to filter set names.
Peerings can now refer to peering set, rtr set names.
Both local and peer routers can be specified using router expressions.
The peer attribute of the inet rtr class can refer to peering set, rtr set names.
The syntax and semantics of union, and list types and typedef attribute have changed.
In the initial dictionary, the typedef attribute defining the community elm, rp attribute defining the community attribute has changed.
Guideliness for extending RPSL is added.
Formal grammar rules are added.
