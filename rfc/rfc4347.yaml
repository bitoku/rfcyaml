- title: __initial_text__
  contents:
  - '                   Datagram Transport Layer Security

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies Version 1.0 of the Datagram Transport Layer\n\
    \   Security (DTLS) protocol.  The DTLS protocol provides communications\n   privacy\
    \ for datagram protocols.  The protocol allows client/server\n   applications\
    \ to communicate in a way that is designed to prevent\n   eavesdropping, tampering,\
    \ or message forgery.  The DTLS protocol is\n   based on the Transport Layer Security\
    \ (TLS) protocol and provides\n   equivalent security guarantees.  Datagram semantics\
    \ of the underlying\n   transport are preserved by the DTLS protocol.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n                  4.1.1.1. PMTU Discovery .............................8\n\
    \           4.1.2. Record Payload Protection ...........................9\n  \
    \                4.1.2.1. MAC ........................................9\n    \
    \              4.1.2.2. Null or Standard Stream Cipher .............9\n      \
    \            4.1.2.3. Block Cipher ..............................10\n        \
    \          4.1.2.4. New Cipher Suites .........................10\n          \
    \        4.1.2.5. Anti-replay ...............................10\n      4.2. The\
    \ DTLS Handshake Protocol ...............................11\n           4.2.1.\
    \ Denial of Service Countermeasures ..................11\n           4.2.2. Handshake\
    \ Message Format ...........................13\n           4.2.3. Message Fragmentation\
    \ and Reassembly ...............15\n           4.2.4. Timeout and Retransmission\
    \ .........................15\n                  4.2.4.1. Timer Values ..............................18\n\
    \           4.2.5. ChangeCipherSpec ...................................19\n  \
    \         4.2.6. Finished Messages ..................................19\n    \
    \       4.2.7. Alert Messages .....................................19\n      4.3.\
    \ Summary of new syntax .....................................19\n           4.3.1.\
    \ Record Layer .......................................20\n           4.3.2. Handshake\
    \ Protocol .................................20\n   5. Security Considerations\
    \ ........................................21\n   6. Acknowledgements ...............................................22\n\
    \   7. IANA Considerations ............................................22\n  \
    \ 8. References .....................................................22\n    \
    \  8.1. Normative References ......................................22\n      8.2.\
    \ Informative References ....................................23\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   TLS [TLS] is the most widely deployed protocol for securing\
    \ network\n   traffic.  It is widely used for protecting Web traffic and for e-mail\n\
    \   protocols such as IMAP [IMAP] and POP [POP].  The primary advantage\n   of\
    \ TLS is that it provides a transparent connection-oriented channel.\n   Thus,\
    \ it is easy to secure an application protocol by inserting TLS\n   between the\
    \ application layer and the transport layer.  However, TLS\n   must run over a\
    \ reliable transport channel -- typically TCP [TCP].\n   It therefore cannot be\
    \ used to secure unreliable datagram traffic.\n   However, over the past few years\
    \ an increasing number of application\n   layer protocols have been designed that\
    \ use UDP transport.  In\n   particular protocols such as the Session Initiation\
    \ Protocol (SIP)\n   [SIP] and electronic gaming protocols are increasingly popular.\n\
    \   (Note that SIP can run over both TCP and UDP, but that there are\n   situations\
    \ in which UDP is preferable).  Currently, designers of\n   these applications\
    \ are faced with a number of unsatisfactory choices.\n   First, they can use IPsec\
    \ [RFC2401].  However, for a number of\n   reasons detailed in [WHYIPSEC], this\
    \ is only suitable for some\n   applications.  Second, they can design a custom\
    \ application layer\n   security protocol.  SIP, for instance, uses a subset of\
    \ S/MIME to\n   secure its traffic.  Unfortunately, although application layer\n\
    \   security protocols generally provide superior security properties\n   (e.g.,\
    \ end-to-end security in the case of S/MIME), they typically\n   requires a large\
    \ amount of effort to design -- in contrast to the\n   relatively small amount\
    \ of effort required to run the protocol over\n   TLS.\n   In many cases, the\
    \ most desirable way to secure client/server\n   applications would be to use\
    \ TLS; however, the requirement for\n   datagram semantics automatically prohibits\
    \ use of TLS.  Thus, a\n   datagram-compatible variant of TLS would be very desirable.\
    \  This\n   memo describes such a protocol: Datagram Transport Layer Security\n\
    \   (DTLS).  DTLS is deliberately designed to be as similar to TLS as\n   possible,\
    \ both to minimize new security invention and to maximize the\n   amount of code\
    \ and infrastructure reuse.\n"
- title: 1.1. Requirements Terminology
  contents:
  - "1.1. Requirements Terminology\n   In this document, the keywords \"MUST\", \"\
    MUST NOT\", \"REQUIRED\",\n   \"SHOULD\", \"SHOULD NOT\", and \"MAY\" are to be\
    \ interpreted as described\n   in RFC 2119 [REQ].\n"
- title: 2. Usage Model
  contents:
  - "2. Usage Model\n   The DTLS protocol is designed to secure data between communicating\n\
    \   applications.  It is designed to run in application space, without\n   requiring\
    \ any kernel modifications.\n   Datagram transport does not require or provide\
    \ reliable or in-order\n   delivery of data.  The DTLS protocol preserves this\
    \ property for\n   payload data.  Applications such as media streaming, Internet\n\
    \   telephony, and online gaming use datagram transport for communication\n  \
    \ due to the delay-sensitive nature of transported data.  The behavior\n   of\
    \ such applications is unchanged when the DTLS protocol is used to\n   secure\
    \ communication, since the DTLS protocol does not compensate for\n   lost or re-ordered\
    \ data traffic.\n"
- title: 3. Overview of DTLS
  contents:
  - "3. Overview of DTLS\n   The basic design philosophy of DTLS is to construct \"\
    TLS over\n   datagram\".  The reason that TLS cannot be used directly in datagram\n\
    \   environments is simply that packets may be lost or reordered.  TLS\n   has\
    \ no internal facilities to handle this kind of unreliability, and\n   therefore\
    \ TLS implementations break when rehosted on datagram\n   transport.  The purpose\
    \ of DTLS is to make only the minimal changes\n   to TLS required to fix this\
    \ problem.  To the greatest extent\n   possible, DTLS is identical to TLS.  Whenever\
    \ we need to invent new\n   mechanisms, we attempt to do so in such a way that\
    \ preserves the\n   style of TLS.\n   Unreliability creates problems for TLS at\
    \ two levels:\n      1. TLS's traffic encryption layer does not allow independent\n\
    \      decryption of individual records.  If record N is not received,\n     \
    \ then record N+1 cannot be decrypted.\n      2. The TLS handshake layer assumes\
    \ that handshake messages are\n      delivered reliably and breaks if those messages\
    \ are lost.\n   The rest of this section describes the approach that DTLS uses\
    \ to\n   solve these problems.\n"
- title: 3.1. Loss-Insensitive Messaging
  contents:
  - "3.1. Loss-Insensitive Messaging\n   In TLS's traffic encryption layer (called\
    \ the TLS Record Layer),\n   records are not independent.  There are two kinds\
    \ of inter-record\n   dependency:\n      1. Cryptographic context (CBC state,\
    \ stream cipher key stream) is\n      chained between records.\n      2. Anti-replay\
    \ and message reordering protection are provided by a\n      MAC that includes\
    \ a sequence number, but the sequence numbers are\n      implicit in the records.\n\
    \   The fix for both of these problems is straightforward and well known\n   from\
    \ IPsec ESP [ESP]: add explicit state to the records.  TLS 1.1\n   [TLS11] is\
    \ already adding explicit CBC state to TLS records.  DTLS\n   borrows that mechanism\
    \ and adds explicit sequence numbers.\n"
- title: 3.2. Providing Reliability for Handshake
  contents:
  - "3.2. Providing Reliability for Handshake\n   The TLS handshake is a lockstep\
    \ cryptographic handshake.  Messages\n   must be transmitted and received in a\
    \ defined order, and any other\n   order is an error.  Clearly, this is incompatible\
    \ with reordering and\n   message loss.  In addition, TLS handshake messages are\
    \ potentially\n   larger than any given datagram, thus creating the problem of\n\
    \   fragmentation.  DTLS must provide fixes for both of these problems.\n"
- title: 3.2.1. Packet Loss
  contents:
  - "3.2.1. Packet Loss\n   DTLS uses a simple retransmission timer to handle packet\
    \ loss.  The\n   following figure demonstrates the basic concept, using the first\n\
    \   phase of the DTLS handshake:\n      Client                               \
    \    Server\n      ------                                   ------\n      ClientHello\
    \           ------>\n                              X<-- HelloVerifyRequest\n \
    \                                              (lost)\n      [Timer Expires]\n\
    \      ClientHello           ------>\n      (retransmit)\n   Once the client has\
    \ transmitted the ClientHello message, it expects\n   to see a HelloVerifyRequest\
    \ from the server.  However, if the\n   server's message is lost the client knows\
    \ that either the ClientHello\n   or the HelloVerifyRequest has been lost and\
    \ retransmits.  When the\n   server receives the retransmission, it knows to retransmit.\
    \  The\n   server also maintains a retransmission timer and retransmits when\n\
    \   that timer expires.\n   Note: timeout and retransmission do not apply to the\n\
    \   HelloVerifyRequest, because this requires creating state on the\n   server.\n"
- title: 3.2.2. Reordering
  contents:
  - "3.2.2. Reordering\n   In DTLS, each handshake message is assigned a specific\
    \ sequence\n   number within that handshake.  When a peer receives a handshake\n\
    \   message, it can quickly determine whether that message is the next\n   message\
    \ it expects.  If it is, then it processes it.  If not, it\n   queues it up for\
    \ future handling once all previous messages have been\n   received.\n"
- title: 3.2.3. Message Size
  contents:
  - "3.2.3. Message Size\n   TLS and DTLS handshake messages can be quite large (in\
    \ theory up to\n   2^24-1 bytes, in practice many kilobytes).  By contrast, UDP\n\
    \   datagrams are often limited to <1500 bytes if fragmentation is not\n   desired.\
    \  In order to compensate for this limitation, each DTLS\n   handshake message\
    \ may be fragmented over several DTLS records.  Each\n   DTLS handshake message\
    \ contains both a fragment offset and a fragment\n   length.  Thus, a recipient\
    \ in possession of all bytes of a handshake\n   message can reassemble the original\
    \ unfragmented message.\n"
- title: 3.3. Replay Detection
  contents:
  - "3.3. Replay Detection\n   DTLS optionally supports record replay detection. \
    \ The technique used\n   is the same as in IPsec AH/ESP, by maintaining a bitmap\
    \ window of\n   received records.  Records that are too old to fit in the window\
    \ and\n   records that have previously been received are silently discarded.\n\
    \   The replay detection feature is optional, since packet duplication is\n  \
    \ not always malicious, but can also occur due to routing errors.\n   Applications\
    \ may conceivably detect duplicate packets and accordingly\n   modify their data\
    \ transmission strategy.\n"
- title: 4. Differences from TLS
  contents:
  - "4. Differences from TLS\n   As mentioned in Section 3, DTLS is intentionally\
    \ very similar to TLS.\n   Therefore, instead of presenting DTLS as a new protocol,\
    \ we present\n   it as a series of deltas from TLS 1.1 [TLS11].  Where we do not\n\
    \   explicitly call out differences, DTLS is the same as in [TLS11].\n"
- title: 4.1. Record Layer
  contents:
  - "4.1. Record Layer\n   The DTLS record layer is extremely similar to that of TLS\
    \ 1.1.  The\n   only change is the inclusion of an explicit sequence number in\
    \ the\n   record.  This sequence number allows the recipient to correctly\n  \
    \ verify the TLS MAC.  The DTLS record format is shown below:\n       struct {\n\
    \         ContentType type;\n         ProtocolVersion version;\n         uint16\
    \ epoch;                                    // New field\n         uint48 sequence_number;\
    \                          // New field\n         uint16 length;\n         opaque\
    \ fragment[DTLSPlaintext.length];\n       } DTLSPlaintext;\n      type\n     \
    \  Equivalent to the type field in a TLS 1.1 record.\n      version\n       The\
    \ version of the protocol being employed.  This document\n       describes DTLS\
    \ Version 1.0, which uses the version { 254, 255\n       }.  The version value\
    \ of 254.255 is the 1's complement of DTLS\n       Version 1.0. This maximal spacing\
    \ between TLS and DTLS version\n       numbers ensures that records from the two\
    \ protocols can be\n       easily distinguished.  It should be noted that future\
    \ on-the-wire\n       version numbers of DTLS are decreasing in value (while the\
    \ true\n       version number is increasing in value.)\n      epoch\n       A\
    \ counter value that is incremented on every cipher state\n       change.\n  \
    \    sequence_number\n       The sequence number for this record.\n      length\n\
    \       Identical to the length field in a TLS 1.1 record.  As in TLS\n      \
    \ 1.1, the length should not exceed 2^14.\n      fragment\n       Identical to\
    \ the fragment field of a TLS 1.1 record.\n   DTLS uses an explicit sequence number,\
    \ rather than an implicit one,\n   carried in the sequence_number field of the\
    \ record.  As with TLS, the\n   sequence number is set to zero after each ChangeCipherSpec\
    \ message is\n   sent.\n   If several handshakes are performed in close succession,\
    \ there might\n   be multiple records on the wire with the same sequence number\
    \ but\n   from different cipher states.  The epoch field allows recipients to\n\
    \   distinguish such packets.  The epoch number is initially zero and is\n   incremented\
    \ each time the ChangeCipherSpec messages is sent.  In\n   order to ensure that\
    \ any given sequence/epoch pair is unique,\n   implementations MUST NOT allow\
    \ the same epoch value to be reused\n   within two times the TCP maximum segment\
    \ lifetime.  In practice, TLS\n   implementations rarely rehandshake and we therefore\
    \ do not expect\n   this to be a problem.\n"
- title: 4.1.1. Transport Layer Mapping
  contents:
  - "4.1.1. Transport Layer Mapping\n   Each DTLS record MUST fit within a single\
    \ datagram.  In order to\n   avoid IP fragmentation [MOGUL], DTLS implementations\
    \ SHOULD determine\n   the MTU and send records smaller than the MTU.  DTLS implementations\n\
    \   SHOULD provide a way for applications to determine the value of the\n   PMTU\
    \ (or, alternately, the maximum application datagram size, which\n   is the PMTU\
    \ minus the DTLS per-record overhead).  If the application\n   attempts to send\
    \ a record larger than the MTU, the DTLS\n   implementation SHOULD generate an\
    \ error, thus avoiding sending a\n   packet which will be fragmented.\n   Note\
    \ that unlike IPsec, DTLS records do not contain any association\n   identifiers.\
    \  Applications must arrange to multiplex between\n   associations.  With UDP,\
    \ this is presumably done with host/port\n   number.\n   Multiple DTLS records\
    \ may be placed in a single datagram.  They are\n   simply encoded consecutively.\
    \  The DTLS record framing is sufficient\n   to determine the boundaries.  Note,\
    \ however, that the first byte of\n   the datagram payload must be the beginning\
    \ of a record.  Records may\n   not span datagrams.\n   Some transports, such\
    \ as DCCP [DCCP] provide their own sequence\n   numbers.  When carried over those\
    \ transports, both the DTLS and the\n   transport sequence numbers will be present.\
    \  Although this introduces\n   a small amount of inefficiency, the transport\
    \ layer and DTLS sequence\n   numbers serve different purposes, and therefore\
    \ for conceptual\n   simplicity it is superior to use both sequence numbers. \
    \ In the\n   future, extensions to DTLS may be specified that allow the use of\n\
    \   only one set of sequence numbers for deployment in constrained\n   environments.\n\
    \   Some transports, such as DCCP, provide congestion control for traffic\n  \
    \ carried over them.  If the congestion window is sufficiently narrow,\n   DTLS\
    \ handshake retransmissions may be held rather than transmitted\n   immediately,\
    \ potentially leading to timeouts and spurious\n   retransmission.  When DTLS\
    \ is used over such transports, care should\n   be taken not to overrun the likely\
    \ congestion window.  In the future,\n   a DTLS-DCCP mapping may be specified\
    \ to provide optimal behavior for\n   this interaction.\n"
- title: 4.1.1.1. PMTU Discovery
  contents:
  - "4.1.1.1. PMTU Discovery\n   In general, DTLS's philosophy is to avoid dealing\
    \ with PMTU issues.\n   The general strategy is to start with a conservative MTU\
    \ and then\n   update it if events during the handshake or actual application\
    \ data\n   transport phase require it.\n   The PMTU SHOULD be initialized from\
    \ the interface MTU that will be\n   used to send packets.  If the DTLS implementation\
    \ receives an RFC\n   1191 [RFC1191] ICMP Destination Unreachable message with\
    \ the\n   \"fragmentation needed and DF set\" Code (otherwise known as Datagram\n\
    \   Too Big), it should decrease its PMTU estimate to that given in the\n   ICMP\
    \ message.  A DTLS implementation SHOULD allow the application to\n   occasionally\
    \ reset its PMTU estimate.  The DTLS implementation SHOULD\n   also allow applications\
    \ to control the status of the DF bit.  These\n   controls allow the application\
    \ to perform PMTU discovery.  RFC 1981\n   [RFC1981] procedures SHOULD be followed\
    \ for IPv6.\n   One special case is the DTLS handshake system.  Handshake messages\n\
    \   should be set with DF set.  Because some firewalls and routers screen\n  \
    \ out ICMP messages, it is difficult for the handshake layer to\n   distinguish\
    \ packet loss from an overlarge PMTU estimate.  In order to\n   allow connections\
    \ under these circumstances, DTLS implementations\n   SHOULD back off handshake\
    \ packet size during the retransmit backoff\n   described in Section 4.2.4. For\
    \ instance, if a large packet is being\n   sent, after 3 retransmits the handshake\
    \ layer might choose to\n   fragment the handshake message on retransmission.\
    \  In general, choice\n   of a conservative initial MTU will avoid this problem.\n"
- title: 4.1.2. Record Payload Protection
  contents:
  - "4.1.2. Record Payload Protection\n   Like TLS, DTLS transmits data as a series\
    \ of protected records.  The\n   rest of this section describes the details of\
    \ that format.\n"
- title: 4.1.2.1. MAC
  contents:
  - "4.1.2.1. MAC\n   The DTLS MAC is the same as that of TLS 1.1. However, rather\
    \ than\n   using TLS's implicit sequence number, the sequence number used to\n\
    \   compute the MAC is the 64-bit value formed by concatenating the epoch\n  \
    \ and the sequence number in the order they appear on the wire.  Note\n   that\
    \ the DTLS epoch + sequence number is the same length as the TLS\n   sequence\
    \ number.\n   TLS MAC calculation is parameterized on the protocol version number,\n\
    \   which, in the case of DTLS, is the on-the-wire version, i.e., {254,\n   255\
    \ } for DTLS 1.0.\n   Note that one important difference between DTLS and TLS\
    \ MAC handling\n   is that in TLS MAC errors must result in connection termination.\
    \  In\n   DTLS, the receiving implementation MAY simply discard the offending\n\
    \   record and continue with the connection.  This change is possible\n   because\
    \ DTLS records are not dependent on each other in the way that\n   TLS records\
    \ are.\n   In general, DTLS implementations SHOULD silently discard data with\n\
    \   bad MACs.  If a DTLS implementation chooses to generate an alert when\n  \
    \ it receives a message with an invalid MAC, it MUST generate\n   bad_record_mac\
    \ alert with level fatal and terminate its connection\n   state.\n"
- title: 4.1.2.2. Null or Standard Stream Cipher
  contents:
  - "4.1.2.2. Null or Standard Stream Cipher\n   The DTLS NULL cipher is performed\
    \ exactly as the TLS 1.1 NULL cipher.\n   The only stream cipher described in\
    \ TLS 1.1 is RC4, which cannot be\n   randomly accessed.  RC4 MUST NOT be used\
    \ with DTLS.\n"
- title: 4.1.2.3. Block Cipher
  contents:
  - "4.1.2.3. Block Cipher\n   DTLS block cipher encryption and decryption are performed\
    \ exactly as\n   with TLS 1.1.\n"
- title: 4.1.2.4. New Cipher Suites
  contents:
  - "4.1.2.4. New Cipher Suites\n   Upon registration, new TLS cipher suites MUST\
    \ indicate whether they\n   are suitable for DTLS usage and what, if any, adaptations\
    \ must be\n   made.\n"
- title: 4.1.2.5. Anti-replay
  contents:
  - "4.1.2.5. Anti-replay\n   DTLS records contain a sequence number to provide replay\
    \ protection.\n   Sequence number verification SHOULD be performed using the following\n\
    \   sliding window procedure, borrowed from Section 3.4.3 of [RFC 2402].\n   The\
    \ receiver packet counter for this session MUST be initialized to\n   zero when\
    \ the session is established.  For each received record, the\n   receiver MUST\
    \ verify that the record contains a Sequence Number that\n   does not duplicate\
    \ the Sequence Number of any other record received\n   during the life of this\
    \ session.  This SHOULD be the first check\n   applied to a packet after it has\
    \ been matched to a session, to speed\n   rejection of duplicate records.\n  \
    \ Duplicates are rejected through the use of a sliding receive window.\n   (How\
    \ the window is implemented is a local matter, but the following\n   text describes\
    \ the functionality that the implementation must\n   exhibit.)  A minimum window\
    \ size of 32 MUST be supported, but a\n   window size of 64 is preferred and SHOULD\
    \ be employed as the default.\n   Another window size (larger than the minimum)\
    \ MAY be chosen by the\n   receiver.  (The receiver does not notify the sender\
    \ of the window\n   size.)\n   The \"right\" edge of the window represents the\
    \ highest validated\n   Sequence Number value received on this session.  Records\
    \ that contain\n   Sequence Numbers lower than the \"left\" edge of the window\
    \ are\n   rejected.  Packets falling within the window are checked against a\n\
    \   list of received packets within the window.  An efficient means for\n   performing\
    \ this check, based on the use of a bit mask, is described\n   in Appendix C of\
    \ [RFC 2401].\n   If the received record falls within the window and is new, or\
    \ if the\n   packet is to the right of the window, then the receiver proceeds\
    \ to\n   MAC verification.  If the MAC validation fails, the receiver MUST\n \
    \  discard the received record as invalid.  The receive window is\n   updated\
    \ only if the MAC verification succeeds.\n"
- title: 4.2. The DTLS Handshake Protocol
  contents:
  - "4.2. The DTLS Handshake Protocol\n   DTLS uses all of the same handshake messages\
    \ and flows as TLS, with\n   three principal changes:\n      1. A stateless cookie\
    \ exchange has been added to prevent denial of\n      service attacks.\n     \
    \ 2. Modifications to the handshake header to handle message loss,\n      reordering,\
    \ and fragmentation.\n      3. Retransmission timers to handle message loss.\n\
    \   With these exceptions, the DTLS message formats, flows, and logic are\n  \
    \ the same as those of TLS 1.1.\n"
- title: 4.2.1. Denial of Service Countermeasures
  contents:
  - "4.2.1. Denial of Service Countermeasures\n   Datagram security protocols are\
    \ extremely susceptible to a variety of\n   denial of service (DoS) attacks. \
    \ Two attacks are of particular\n   concern:\n      1. An attacker can consume\
    \ excessive resources on the server by\n      transmitting a series of handshake\
    \ initiation requests, causing\n      the server to allocate state and potentially\
    \ to perform expensive\n      cryptographic operations.\n      2. An attacker\
    \ can use the server as an amplifier by sending\n      connection initiation messages\
    \ with a forged source of the victim.\n      The server then sends its next message\
    \ (in DTLS, a Certificate\n      message, which can be quite large) to the victim\
    \ machine, thus\n      flooding it.\n   In order to counter both of these attacks,\
    \ DTLS borrows the stateless\n   cookie technique used by Photuris [PHOTURIS]\
    \ and IKE [IKE].  When the\n   client sends its ClientHello message to the server,\
    \ the server MAY\n   respond with a HelloVerifyRequest message.  This message\
    \ contains a\n   stateless cookie generated using the technique of [PHOTURIS].\
    \  The\n   client MUST retransmit the ClientHello with the cookie added.  The\n\
    \   server then verifies the cookie and proceeds with the handshake only\n   if\
    \ it is valid.  This mechanism forces the attacker/client to be able\n   to receive\
    \ the cookie, which makes DoS attacks with spoofed IP\n   addresses difficult.\
    \  This mechanism does not provide any defense\n   against DoS attacks mounted\
    \ from valid IP addresses.\n   The exchange is shown below:\n         Client \
    \                                  Server\n         ------                   \
    \                ------\n         ClientHello           ------>\n            \
    \                   <----- HelloVerifyRequest\n                              \
    \        (contains cookie)\n         ClientHello           ------>\n         (with\
    \ cookie)\n         [Rest of handshake]\n   DTLS therefore modifies the ClientHello\
    \ message to add the cookie\n   value.\n      struct {\n        ProtocolVersion\
    \ client_version;\n        Random random;\n        SessionID session_id;\n   \
    \     opaque cookie<0..32>;                             // New field\n       \
    \ CipherSuite cipher_suites<2..2^16-1>;\n        CompressionMethod compression_methods<1..2^8-1>;\n\
    \      } ClientHello;\n   When sending the first ClientHello, the client does\
    \ not have a cookie\n   yet; in this case, the Cookie field is left empty (zero\
    \ length).\n   The definition of HelloVerifyRequest is as follows:\n      struct\
    \ {\n        ProtocolVersion server_version;\n        opaque cookie<0..32>;\n\
    \      } HelloVerifyRequest;\n   The HelloVerifyRequest message type is hello_verify_request(3).\n\
    \   The server_version field is defined as in TLS.\n   When responding to a HelloVerifyRequest\
    \ the client MUST use the same\n   parameter values (version, random, session_id,\
    \ cipher_suites,\n   compression_method) as it did in the original ClientHello.\
    \  The\n   server SHOULD use those values to generate its cookie and verify that\n\
    \   they are correct upon cookie receipt.  The server MUST use the same\n   version\
    \ number in the HelloVerifyRequest that it would use when\n   sending a ServerHello.\
    \  Upon receipt of the ServerHello, the client\n   MUST verify that the server\
    \ version values match.\n   The DTLS server SHOULD generate cookies in such a\
    \ way that they can\n   be verified without retaining any per-client state on\
    \ the server.\n   One technique is to have a randomly generated secret and generate\n\
    \   cookies as:  Cookie = HMAC(Secret, Client-IP, Client-Parameters)\n   When\
    \ the second ClientHello is received, the server can verify that\n   the Cookie\
    \ is valid and that the client can receive packets at the\n   given IP address.\n\
    \   One potential attack on this scheme is for the attacker to collect a\n   number\
    \ of cookies from different addresses and then reuse them to\n   attack the server.\
    \  The server can defend against this attack by\n   changing the Secret value\
    \ frequently, thus invalidating those\n   cookies.  If the server wishes that\
    \ legitimate clients be able to\n   handshake through the transition (e.g., they\
    \ received a cookie with\n   Secret 1 and then sent the second ClientHello after\
    \ the server has\n   changed to Secret 2), the server can have a limited window\
    \ during\n   which it accepts both secrets. [IKEv2] suggests adding a version\n\
    \   number to cookies to detect this case.  An alternative approach is\n   simply\
    \ to try verifying with both secrets.\n   DTLS servers SHOULD perform a cookie\
    \ exchange whenever a new\n   handshake is being performed.  If the server is\
    \ being operated in an\n   environment where amplification is not a problem, the\
    \ server MAY be\n   configured not to perform a cookie exchange.  The default\
    \ SHOULD be\n   that the exchange is performed, however.  In addition, the server\
    \ MAY\n   choose not to do a cookie exchange when a session is resumed.\n   Clients\
    \ MUST be prepared to do a cookie exchange with every\n   handshake.\n   If HelloVerifyRequest\
    \ is used, the initial ClientHello and\n   HelloVerifyRequest are not included\
    \ in the calculation of the\n   verify_data for the Finished message.\n"
- title: 4.2.2. Handshake Message Format
  contents:
  - "4.2.2. Handshake Message Format\n   In order to support message loss, reordering,\
    \ and fragmentation, DTLS\n   modifies the TLS 1.1 handshake header:\n      struct\
    \ {\n        HandshakeType msg_type;\n        uint24 length;\n        uint16 message_seq;\
    \                               // New field\n        uint24 fragment_offset;\
    \                           // New field\n        uint24 fragment_length;    \
    \                       // New field\n        select (HandshakeType) {\n     \
    \     case hello_request: HelloRequest;\n          case client_hello:  ClientHello;\n\
    \          case hello_verify_request: HelloVerifyRequest;  // New type\n     \
    \     case server_hello:  ServerHello;\n          case certificate:Certificate;\n\
    \          case server_key_exchange: ServerKeyExchange;\n          case certificate_request:\
    \ CertificateRequest;\n          case server_hello_done:ServerHelloDone;\n   \
    \       case certificate_verify:  CertificateVerify;\n          case client_key_exchange:\
    \ ClientKeyExchange;\n          case finished:Finished;\n        } body;\n   \
    \   } Handshake;\n   The first message each side transmits in each handshake always\
    \ has\n   message_seq = 0.  Whenever each new message is generated, the\n   message_seq\
    \ value is incremented by one.  When a message is\n   retransmitted, the same\
    \ message_seq value is used.  For example:\n      Client                     \
    \        Server\n      ------                             ------\n      ClientHello\
    \ (seq=0)  ------>\n                              X<-- HelloVerifyRequest (seq=0)\n\
    \                                              (lost)\n      [Timer Expires]\n\
    \      ClientHello (seq=0)  ------>\n      (retransmit)\n                    \
    \       <------ HelloVerifyRequest (seq=0)\n      ClientHello (seq=1)  ------>\n\
    \      (with cookie)\n                           <------        ServerHello (seq=1)\n\
    \                           <------        Certificate (seq=2)\n             \
    \              <------    ServerHelloDone (seq=3)\n      [Rest of handshake]\n\
    \   Note, however, that from the perspective of the DTLS record layer,\n   the\
    \ retransmission is a new record.  This record will have a new\n   DTLSPlaintext.sequence_number\
    \ value.\n   DTLS implementations maintain (at least notionally) a\n   next_receive_seq\
    \ counter.  This counter is initially set to zero.\n   When a message is received,\
    \ if its sequence number matches\n   next_receive_seq, next_receive_seq is incremented\
    \ and the message is\n   processed.  If the sequence number is less than next_receive_seq,\
    \ the\n   message MUST be discarded.  If the sequence number is greater than\n\
    \   next_receive_seq, the implementation SHOULD queue the message but MAY\n  \
    \ discard it.  (This is a simple space/bandwidth tradeoff).\n"
- title: 4.2.3. Message Fragmentation and Reassembly
  contents:
  - "4.2.3. Message Fragmentation and Reassembly\n   As noted in Section 4.1.1, each\
    \ DTLS message MUST fit within a single\n   transport layer datagram.  However,\
    \ handshake messages are\n   potentially bigger than the maximum record size.\
    \  Therefore, DTLS\n   provides a mechanism for fragmenting a handshake message\
    \ over a\n   number of records.\n   When transmitting the handshake message, the\
    \ sender divides the\n   message into a series of N contiguous data ranges.  These\
    \ ranges MUST\n   NOT be larger than the maximum handshake fragment size and MUST\n\
    \   jointly contain the entire handshake message.  The ranges SHOULD NOT\n   overlap.\
    \  The sender then creates N handshake messages, all with the\n   same message_seq\
    \ value as the original handshake message.  Each new\n   message is labelled with\
    \ the fragment_offset (the number of bytes\n   contained in previous fragments)\
    \ and the fragment_length (the length\n   of this fragment).  The length field\
    \ in all messages is the same as\n   the length field of the original message.\
    \  An unfragmented message is\n   a degenerate case with fragment_offset=0 and\
    \ fragment_length=length.\n   When a DTLS implementation receives a handshake\
    \ message fragment, it\n   MUST buffer it until it has the entire handshake message.\
    \  DTLS\n   implementations MUST be able to handle overlapping fragment ranges.\n\
    \   This allows senders to retransmit handshake messages with smaller\n   fragment\
    \ sizes during path MTU discovery.\n   Note that as with TLS, multiple handshake\
    \ messages may be placed in\n   the same DTLS record, provided that there is room\
    \ and that they are\n   part of the same flight.  Thus, there are two acceptable\
    \ ways to pack\n   two DTLS messages into the same datagram: in the same record\
    \ or in\n   separate records.\n"
- title: 4.2.4. Timeout and Retransmission
  contents:
  - "4.2.4. Timeout and Retransmission\n   DTLS messages are grouped into a series\
    \ of message flights, according\n   to the diagrams below.  Although each flight\
    \ of messages may consist\n   of a number of messages, they should be viewed as\
    \ monolithic for the\n   purpose of timeout and retransmission.\n    Client  \
    \                                        Server\n    ------                  \
    \                        ------\n    ClientHello             -------->       \
    \                    Flight 1\n                            <-------    HelloVerifyRequest\
    \      Flight 2\n   ClientHello              -------->                       \
    \    Flight 3\n                                               ServerHello    \\\
    \n                                              Certificate*     \\\n        \
    \                                ServerKeyExchange*      Flight 4\n          \
    \                             CertificateRequest*     /\n                    \
    \        <--------      ServerHelloDone    /\n    Certificate*               \
    \                               \\\n    ClientKeyExchange                    \
    \                      \\\n    CertificateVerify*                            \
    \              Flight 5\n    [ChangeCipherSpec]                              \
    \           /\n    Finished                -------->                         /\n\
    \                                        [ChangeCipherSpec]    \\ Flight 6\n \
    \                           <--------             Finished    /\n          Figure\
    \ 1. Message flights for full handshake\n    Client                          \
    \                 Server\n    ------                                         \
    \  ------\n    ClientHello             -------->                          Flight\
    \ 1\n                                               ServerHello    \\\n      \
    \                                  [ChangeCipherSpec]     Flight 2\n         \
    \                    <--------             Finished    /\n    [ChangeCipherSpec]\
    \                                         \\Flight 3\n    Finished           \
    \      -------->                         /\n   Figure 2. Message flights for session-resuming\
    \ handshake\n                           (no cookie exchange)\n   DTLS uses a simple\
    \ timeout and retransmission scheme with the\n   following state machine.  Because\
    \ DTLS clients send the first message\n   (ClientHello), they start in the PREPARING\
    \ state.  DTLS servers start\n   in the WAITING state, but with empty buffers\
    \ and no retransmit timer.\n                   +-----------+\n               \
    \    | PREPARING |\n             +---> |           | <--------------------+\n\
    \             |     |           |                      |\n             |     +-----------+\
    \                      |\n             |           |                         \
    \   |\n             |           |                            |\n             |\
    \           | Buffer next flight         |\n             |           |       \
    \                     |\n             |          \\|/                        \
    \   |\n             |     +-----------+                      |\n             |\
    \     |           |                      |\n             |     |  SENDING  |<------------------+\
    \  |\n             |     |           |                   |  | Send\n         \
    \    |     +-----------+                   |  | HelloRequest\n     Receive | \
    \          |                         |  |\n        next |           | Send flight\
    \             |  | or\n      flight |  +--------+                         |  |\n\
    \             |  |        | Set retransmit timer    |  | Receive\n           \
    \  |  |       \\|/                        |  | HelloRequest\n             |  |\
    \  +-----------+                   |  | Send\n             |  |  |           |\
    \                   |  | ClientHello\n             +--)--|  WAITING  |-------------------+\
    \  |\n             |  |  |           |   Timer expires   |  |\n             |\
    \  |  +-----------+                   |  |\n             |  |         |      \
    \                  |  |\n             |  |         |                        |\
    \  |\n             |  |         +------------------------+  |\n             |\
    \  |                Read retransmit      |\n     Receive |  |                \
    \                     |\n        last |  |                                   \
    \  |\n      flight |  |                                     |\n             |\
    \  |                                     |\n            \\|/\\|/             \
    \                       |\n                                                  \
    \    |\n         +-----------+                                |\n         |  \
    \         |                                |\n         | FINISHED  | -------------------------------+\n\
    \         |           |\n         +-----------+\n        Figure 3. DTLS timeout\
    \ and retransmission state machine\n   The state machine has three basic states.\n\
    \   In the PREPARING state the implementation does whatever computations\n   are\
    \ necessary to prepare the next flight of messages.  It then\n   buffers them\
    \ up for transmission (emptying the buffer first) and\n   enters the SENDING state.\n\
    \   In the SENDING state, the implementation transmits the buffered\n   flight\
    \ of messages.  Once the messages have been sent, the\n   implementation then\
    \ enters the FINISHED state if this is the last\n   flight in the handshake. \
    \ Or, if the implementation expects to\n   receive more messages, it sets a retransmit\
    \ timer and then enters the\n   WAITING state.\n   There are three ways to exit\
    \ the WAITING state:\n      1. The retransmit timer expires: the implementation\
    \ transitions to\n      the SENDING state, where it retransmits the flight, resets\
    \ the\n      retransmit timer, and returns to the WAITING state.\n      2. The\
    \ implementation reads a retransmitted flight from the peer:\n      the implementation\
    \ transitions to the SENDING state, where it\n      retransmits the flight, resets\
    \ the retransmit timer, and returns\n      to the WAITING state.  The rationale\
    \ here is that the receipt of a\n      duplicate message is the likely result\
    \ of timer expiry on the peer\n      and therefore suggests that part of one's\
    \ previous flight was\n      lost.\n      3. The implementation receives the next\
    \ flight of messages:  if\n      this is the final flight of messages, the implementation\n\
    \      transitions to FINISHED.  If the implementation needs to send a\n     \
    \ new flight, it transitions to the PREPARING state.  Partial reads\n      (whether\
    \ partial messages or only some of the messages in the\n      flight) do not cause\
    \ state transitions or timer resets.\n   Because DTLS clients send the first message\
    \ (ClientHello), they start\n   in the PREPARING state.  DTLS servers start in\
    \ the WAITING state, but\n   with empty buffers and no retransmit timer.\n   When\
    \ the server desires a rehandshake, it transitions from the\n   FINISHED state\
    \ to the PREPARING state to transmit the HelloRequest.\n   When the client receives\
    \ a HelloRequest it transitions from FINISHED\n   to PREPARING to transmit the\
    \ ClientHello.\n"
- title: 4.2.4.1. Timer Values
  contents:
  - "4.2.4.1. Timer Values\n   Though timer values are the choice of the implementation,\
    \ mishandling\n   of the timer can lead to serious congestion problems; for example,\
    \ if\n   many instances of a DTLS time out early and retransmit too quickly on\n\
    \   a congested link.  Implementations SHOULD use an initial timer value\n   of\
    \ 1 second (the minimum defined in RFC 2988 [RFC2988]) and double\n   the value\
    \ at each retransmission, up to no less than the RFC 2988\n   maximum of 60 seconds.\
    \  Note that we recommend a 1-second timer\n   rather than the 3-second RFC 2988\
    \ default in order to improve latency\n   for time-sensitive applications.  Because\
    \ DTLS only uses\n   retransmission for handshake and not dataflow, the effect\
    \ on\n   congestion should be minimal.\n   Implementations SHOULD retain the current\
    \ timer value until a\n   transmission without loss occurs, at which time the\
    \ value may be\n   reset to the initial value.  After a long period of idleness,\
    \ no less\n   than 10 times the current timer value, implementations may reset\
    \ the\n   timer to the initial value.  One situation where this might occur is\n\
    \   when a rehandshake is used after substantial data transfer.\n"
- title: 4.2.5. ChangeCipherSpec
  contents:
  - "4.2.5. ChangeCipherSpec\n   As with TLS, the ChangeCipherSpec message is not\
    \ technically a\n   handshake message but MUST be treated as part of the same\
    \ flight as\n   the associated Finished message for the purposes of timeout and\n\
    \   retransmission.\n"
- title: 4.2.6. Finished Messages
  contents:
  - "4.2.6. Finished Messages\n   Finished messages have the same format as in TLS.\
    \  However, in order\n   to remove sensitivity to fragmentation, the Finished\
    \ MAC MUST be\n   computed as if each handshake message had been sent as a single\n\
    \   fragment.  Note that in cases where the cookie exchange is used, the\n   initial\
    \ ClientHello and HelloVerifyRequest MUST NOT be included in\n   the Finished\
    \ MAC.\n"
- title: 4.2.7. Alert Messages
  contents:
  - "4.2.7. Alert Messages\n   Note that Alert messages are not retransmitted at all,\
    \ even when they\n   occur in the context of a handshake.  However, a DTLS implementation\n\
    \   SHOULD generate a new alert message if the offending record is\n   received\
    \ again (e.g., as a retransmitted handshake message).\n   Implementations SHOULD\
    \ detect when a peer is persistently sending bad\n   messages and terminate the\
    \ local connection state after such\n   misbehavior is detected.\n"
- title: 4.3. Summary of new syntax
  contents:
  - "4.3. Summary of new syntax\n   This section includes specifications for the data\
    \ structures that\n   have changed between TLS 1.1 and DTLS.\n"
- title: 4.3.1. Record Layer
  contents:
  - "4.3.1. Record Layer\n      struct {\n        ContentType type;\n        ProtocolVersion\
    \ version;\n        uint16 epoch;                                     // New field\n\
    \        uint48 sequence_number;                           // New field\n    \
    \    uint16 length;\n        opaque fragment[DTLSPlaintext.length];\n      } DTLSPlaintext;\n\
    \      struct {\n        ContentType type;\n        ProtocolVersion version;\n\
    \        uint16 epoch;                                     // New field\n    \
    \    uint48 sequence_number;                           // New field\n        uint16\
    \ length;\n        opaque fragment[DTLSCompressed.length];\n      } DTLSCompressed;\n\
    \      struct {\n        ContentType type;\n        ProtocolVersion version;\n\
    \        uint16 epoch;                                     // New field\n    \
    \    uint48 sequence_number;                           // New field\n        uint16\
    \ length;\n        select (CipherSpec.cipher_type) {\n          case block:  GenericBlockCipher;\n\
    \        } fragment;\n      } DTLSCiphertext;\n"
- title: 4.3.2. Handshake Protocol
  contents:
  - "4.3.2. Handshake Protocol\n      enum {\n        hello_request(0), client_hello(1),\
    \ server_hello(2),\n        hello_verify_request(3),                         \
    \ // New field\n        certificate(11), server_key_exchange (12),\n        certificate_request(13),\
    \ server_hello_done(14),\n        certificate_verify(15), client_key_exchange(16),\n\
    \        finished(20), (255)\n      } HandshakeType;\n      struct {\n       \
    \ HandshakeType msg_type;\n        uint24 length;\n        uint16 message_seq;\
    \                               // New field\n        uint24 fragment_offset;\
    \                           // New field\n        uint24 fragment_length;    \
    \                       // New field\n        select (HandshakeType) {\n     \
    \     case hello_request: HelloRequest;\n          case client_hello:  ClientHello;\n\
    \          case server_hello:  ServerHello;\n          case hello_verify_request:\
    \ HelloVerifyRequest;  // New field\n          case certificate:Certificate;\n\
    \          case server_key_exchange: ServerKeyExchange;\n          case certificate_request:\
    \ CertificateRequest;\n          case server_hello_done:ServerHelloDone;\n   \
    \       case certificate_verify:  CertificateVerify;\n          case client_key_exchange:\
    \ ClientKeyExchange;\n          case finished:Finished;\n        } body;\n   \
    \   } Handshake;\n      struct {\n        ProtocolVersion client_version;\n  \
    \      Random random;\n        SessionID session_id;\n        opaque cookie<0..32>;\
    \                             // New field\n        CipherSuite cipher_suites<2..2^16-1>;\n\
    \        CompressionMethod compression_methods<1..2^8-1>;\n      } ClientHello;\n\
    \      struct {\n        ProtocolVersion server_version;\n        opaque cookie<0..32>;\n\
    \      } HelloVerifyRequest;\n"
- title: 5. Security Considerations
  contents:
  - "5. Security Considerations\n   This document describes a variant of TLS 1.1 and\
    \ therefore most of\n   the security considerations are the same as those of TLS\
    \ 1.1 [TLS11],\n   described in Appendices D, E, and F.\n   The primary additional\
    \ security consideration raised by DTLS is that\n   of denial of service.  DTLS\
    \ includes a cookie exchange designed to\n   protect against denial of service.\
    \  However, implementations which do\n   not use this cookie exchange are still\
    \ vulnerable to DoS.  In\n   particular, DTLS servers which do not use the cookie\
    \ exchange may be\n   used as attack amplifiers even if they themselves are not\n\
    \   experiencing DoS.  Therefore, DTLS servers SHOULD use the cookie\n   exchange\
    \ unless there is good reason to believe that amplification is\n   not a threat\
    \ in their environment.  Clients MUST be prepared to do a\n   cookie exchange\
    \ with every handshake.\n"
- title: 6. Acknowledgements
  contents:
  - "6. Acknowledgements\n   The authors would like to thank Dan Boneh, Eu-Jin Goh,\
    \ Russ Housley,\n   Constantine Sapuntzakis, and Hovav Shacham for discussions\
    \ and\n   comments on the design of DTLS.  Thanks to the anonymous NDSS\n   reviewers\
    \ of our original NDSS paper on DTLS [DTLS] for their\n   comments.  Also, thanks\
    \ to Steve Kent for feedback that helped\n   clarify many points.  The section\
    \ on PMTU was cribbed from the DCCP\n   specification [DCCP].  Pasi Eronen provided\
    \ a detailed review of this\n   specification.  Helpful comments on the document\
    \ were also received\n   from Mark Allman, Jari Arkko, Joel Halpern, Ted Hardie,\
    \ and Allison\n   Mankin.\n"
- title: 7. IANA Considerations
  contents:
  - "7. IANA Considerations\n   This document uses the same identifier space as TLS\
    \ [TLS11], so no\n   new IANA registries are required.  When new identifiers are\
    \ assigned\n   for TLS, authors MUST specify whether they are suitable for DTLS.\n\
    \   This document defines a new handshake message, hello_verify_request,\n   whose\
    \ value has been allocated from the TLS HandshakeType registry\n   defined in\
    \ [TLS11].  The value \"3\" has been assigned by the IANA.\n"
- title: 8. References
  contents:
  - '8. References

    '
- title: 8.1. Normative References
  contents:
  - "8.1. Normative References\n   [RFC1191]  Mogul, J. and S. Deering, \"Path MTU\
    \ discovery\", RFC 1191,\n              November 1990.\n   [RFC1981]  McCann,\
    \ J., Deering, S., and J. Mogul, \"Path MTU Discovery\n              for IP version\
    \ 6\", RFC 1981, August 1996.\n   [RFC2401]  Kent, S. and R. Atkinson, \"Security\
    \ Architecture for the\n              Internet Protocol\", RFC 2401, November\
    \ 1998.\n   [RFC2988]  Paxson, V. and M. Allman, \"Computing TCP's Retransmission\n\
    \              Timer\", RFC 2988, November 2000.\n   [TCP]      Postel, J., \"\
    Transmission Control Protocol\", STD 7, RFC\n              793, September 1981.\n\
    \   [TLS11]    Dierks, T. and E. Rescorla, \"The Transport Layer Security\n  \
    \            (TLS) Protocol Version 1.1\", RFC 4346, April 2006.\n"
- title: 8.2. Informative References
  contents:
  - "8.2. Informative References\n   [AESCACHE] Bernstein, D.J., \"Cache-timing attacks\
    \ on AES\"\n              http://cr.yp.to/antiforgery/cachetiming-20050414.pdf.\n\
    \   [AH]       Kent, S. and R. Atkinson, \"IP Authentication Header\", RFC\n \
    \             2402, November 1998.\n   [DCCP]     Kohler, E., Handley, M., Floyd,\
    \ S., Padhye, J., \"Datagram\n              Congestion Control Protocol\", Work\
    \ in Progress, 10 March\n              2005.\n   [DNS]      Mockapetris, P., \"\
    Domain names - implementation and\n              specification\", STD 13, RFC\
    \ 1035, November 1987.\n   [DTLS]     Modadugu, N., Rescorla, E., \"The Design\
    \ and Implementation\n              of Datagram TLS\", Proceedings of ISOC NDSS\
    \ 2004, February\n              2004.\n   [ESP]      Kent, S. and R. Atkinson,\
    \ \"IP Encapsulating Security\n              Payload (ESP)\", RFC 2406, November\
    \ 1998.\n   [IKE]      Harkins, D. and D. Carrel, \"The Internet Key Exchange\n\
    \              (IKE)\", RFC 2409, November 1998.\n   Kaufman, C., \"Internet Key\
    \ Exchange (IKEv2) Protocol\", RFC 4306,\n              December 2005.\n   [IMAP]\
    \     Crispin, M., \"INTERNET MESSAGE ACCESS PROTOCOL - VERSION\n            \
    \  4rev1\", RFC 3501, March 2003.\n   [PHOTURIS] Karn, P. and W. Simpson, \"ICMP\
    \ Security Failures\n              Messages\", RFC 2521, March 1999.\n   [POP]\
    \      Myers, J. and M. Rose, \"Post Office Protocol - Version 3\",\n        \
    \      STD 53, RFC 1939, May 1996.\n   [REQ]      Bradner, S., \"Key words for\
    \ use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [SCTP]     Stewart, R., Xie, Q., Morneault, K., Sharp, C.,\n\
    \              Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M.,\n        \
    \      Zhang, L., and V. Paxson, \"Stream Control Transmission\n             \
    \ Protocol\", RFC 2960, October 2000.\n   [SIP]      Rosenberg, J., Schulzrinne,\
    \ H., Camarillo, G., Johnston,\n              A., Peterson, J., Sparks, R., Handley,\
    \ M., and E.\n              Schooler, \"SIP:  Session Initiation Protocol\", RFC\
    \ 3261,\n              June 2002.\n   [TLS]      Dierks, T. and C. Allen, \"The\
    \ TLS Protocol Version 1.0\",\n              RFC 2246, January 1999.\n   [WHYIPSEC]\
    \ Bellovin, S., \"Guidelines for Mandating the Use of IPsec\",\n             \
    \ Work in Progress, October 2003.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Eric Rescorla\n   RTFM, Inc.\n   2064 Edgewood Drive\n\
    \   Palo Alto, CA 94303\n   EMail: ekr@rtfm.com\n   Nagendra Modadugu\n   Computer\
    \ Science Department\n   Stanford University\n   353 Serra Mall\n   Stanford,\
    \ CA 94305\n   EMail: nagendra@cs.stanford.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
