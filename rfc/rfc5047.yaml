- title: __initial_text__
  contents:
  - "                    DA: Datamover Architecture for\n         the Internet Small\
    \ Computer System Interface (iSCSI)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Internet Small Computer System Interface (iSCSI) is a SCSI\n\
    \   transport protocol that maps the SCSI family of application protocols\n  \
    \ onto TCP/IP.  Datamover Architecture for iSCSI (DA) defines an\n   abstract\
    \ model in which the movement of data between iSCSI end nodes\n   is logically\
    \ separated from the rest of the iSCSI protocol in order\n   to allow iSCSI to\
    \ adapt to innovations available in new IP\n   transports.  While DA defines the\
    \ architectural functions required of\n   the class of Datamover protocols, it\
    \ does not define any specific\n   Datamover protocols.  Each such Datamover protocol,\
    \ defined in a\n   separate document, provides a reliable transport for all iSCSI\
    \ PDUs,\n   but actually moves the data required for certain iSCSI PDUs without\n\
    \   involving the remote iSCSI layer itself.  This document begins with\n   an\
    \ introduction of a few new abstractions, defines a layered\n   architecture for\
    \ iSCSI and Datamover protocols, and then models the\n   interactions within an\
    \ iSCSI end node between the iSCSI layer and the\n   Datamover layer that happen\
    \ in order to transparently perform remote\n   data movement within an IP fabric.\
    \  It is intended that this\n   definition will help map iSCSI to generic Remote\
    \ Direct Memory Access\n   (RDMA)-capable IP fabrics in the future comprising\
    \ TCP, the Stream\n   Control Transmission Protocol (SCTP), and possibly other\
    \ underlying\n   network transport layers, such as InfiniBand.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Motivation ......................................................4\n\
    \      1.1. Intent .....................................................4\n  \
    \    1.2. Interpretation of Requirements .............................5\n   2.\
    \ Definitions and Acronyms ........................................5\n      2.1.\
    \ Definitions ................................................5\n      2.2. Acronyms\
    \ ...................................................6\n   3. Architectural Layering\
    \ of iSCSI and Datamover Layers ............7\n   4. Design Overview .................................................9\n\
    \   5. Architectural Concepts .........................................10\n  \
    \    5.1. iSCSI PDU Types ...........................................10\n    \
    \       5.1.1. iSCSI Data-Type PDUs ...............................10\n      \
    \     5.1.2. iSCSI Control-Type PDUs ............................11\n      5.2.\
    \ Data_Descriptor ...........................................11\n      5.3. Connection_Handle\
    \ .........................................11\n      5.4. Operational Primitive\
    \ .....................................12\n      5.5. Transport Connection ......................................13\n\
    \   6. Datamover Layer and Datamover Protocol .........................13\n  \
    \ 7. Functional Overview ............................................14\n    \
    \  7.1. Startup ...................................................14\n      7.2.\
    \ Full Feature Phase ........................................15\n      7.3. Wrap-up\
    \ ...................................................15\n   8. Operational Primitives\
    \ Provided by the Datamover Layer .........16\n      8.1. Send_Control ..............................................16\n\
    \      8.2. Put_Data ..................................................17\n  \
    \    8.3. Get_Data ..................................................17\n    \
    \  8.4. Allocate_Connection_Resources .............................18\n      8.5.\
    \ Deallocate_Connection_Resources ...........................19\n      8.6. Enable_Datamover\
    \ ..........................................19\n      8.7. Connection_Terminate\
    \ ......................................20\n      8.8. Notice_Key_Values .........................................20\n\
    \      8.9. Deallocate_Task_Resources .................................20\n  \
    \ 9. Operational Primitives Provided by the iSCSI Layer .............21\n    \
    \  9.1. Control_Notify ............................................21\n      9.2.\
    \ Connection_Terminate_Notify ...............................22\n      9.3. Data_Completion_Notify\
    \ ....................................22\n      9.4. Data_ACK_Notify ...........................................23\n\
    \   10. Datamover Interface (DI) ......................................23\n  \
    \    10.1. Overview .................................................23\n    \
    \  10.2. Interactions for Handling Asynchronous Notifications .....24\n      \
    \     10.2.1. Connection Termination ............................24\n        \
    \   10.2.2. Data Transfer Completion ..........................24\n          \
    \ 10.2.3. Data Acknowledgement ..............................25\n      10.3. Interactions\
    \ for Sending an iSCSI PDU ....................25\n           10.3.1. SCSI Command\
    \ ......................................26\n           10.3.2. SCSI Response .....................................26\n\
    \           10.3.3. Task Management Function Request ..................26\n  \
    \         10.3.4. Task Management Function Response .................27\n    \
    \       10.3.5. SCSI Data-Out and SCSI Data-In ....................27\n      \
    \     10.3.6. Ready To Transfer (R2T) ...........................28\n        \
    \   10.3.7. Asynchronous Message ..............................28\n          \
    \ 10.3.8. Text Request ......................................28\n           10.3.9.\
    \ Text Response .....................................28\n           10.3.10. Login\
    \ Request ....................................29\n           10.3.11. Login Response\
    \ ...................................29\n           10.3.12. Logout Command ...................................29\n\
    \           10.3.13. Logout Response ..................................30\n  \
    \         10.3.14. SNACK Request ....................................30\n    \
    \       10.3.15. Reject ...........................................30\n      \
    \     10.3.16. NOP-Out ..........................................30\n        \
    \   10.3.17. NOP-In ...........................................30\n      10.4.\
    \ Interactions for Receiving an iSCSI PDU ..................31\n           10.4.1.\
    \ General Control-Type PDU Notification .............31\n           10.4.2. SCSI\
    \ Data Transfer PDUs ...........................31\n           10.4.3. Login Request\
    \ .....................................32\n           10.4.4. Login Response ....................................32\n\
    \   11. Security Considerations .......................................33\n  \
    \    11.1. Architectural Considerations .............................33\n    \
    \  11.2. Wire Protocol Considerations .............................33\n   12.\
    \ References ....................................................34\n      12.1.\
    \ Normative References .....................................34\n      12.2. Informative\
    \ References ...................................34\n   Appendix A. Design Considerations\
    \ and Examples ....................35\n      A.1. Design Considerations for a\
    \ Datamover Protocol ............35\n      A.2. Examples of Datamover Interactions\
    \ ........................35\n   Acknowledgements ..................................................44\n"
- title: Table of Figures
  contents:
  - "Table of Figures\n   Figure 1. Datamover Architecture Diagram, with the RDMAP\
    \ Example ...8\n   Figure 2. A Successful iSCSI Login on Initiator ...................37\n\
    \   Figure 3. A Successful iSCSI Login on Target ......................37\n  \
    \ Figure 4. A Failed iSCSI Login on Initiator .......................38\n   Figure\
    \ 5. A Failed iSCSI Login on Target ..........................38\n   Figure 6.\
    \ iSCSI Does Not Enable the Datamover .....................39\n   Figure 7. A\
    \ Normal iSCSI Connection Termination ...................40\n   Figure 8. An Abnormal\
    \ iSCSI Connection Termination ................40\n   Figure 9. A SCSI Write Data\
    \ Transfer ..............................41\n   Figure 10. A SCSI Read Data Transfer\
    \ ..............................42\n   Figure 11. A SCSI Read Data Acknowledgement\
    \ .......................43\n   Figure 12. Task Resource Cleanup on Abort .........................44\n"
- title: 1.  Motivation
  contents:
  - '1.  Motivation

    '
- title: 1.1.  Intent
  contents:
  - "1.1.  Intent\n   There are relatively new standard protocols that enable Remote\
    \ Direct\n   Memory Access (RDMA) and Remote Direct Data Placement (RDDP)\n  \
    \ technologies to work over IP fabrics.  The principal value\n   proposition of\
    \ these technologies is that they enable one end node to\n   place data in the\
    \ final intended buffer on the remote end node, thus\n   eliminating the need\
    \ for a receive path data copy that moves the data\n   to its final location.\
    \  The data copy avoidance in turn eliminates\n   unnecessary memory bandwidth\
    \ consumption, substantially decreases the\n   reassembly buffer size requirements,\
    \ and preserves CPU cycles that\n   would otherwise be spent in copying.\n   The\
    \ iSCSI specification [RFC3720] defines a very detailed data\n   transfer model\
    \ that employs SCSI Data-In PDUs, SCSI Data-Out PDUs,\n   and R2T PDUs, in addition\
    \ to the SCSI Command and SCSI Response PDUs\n   that respectively create and\
    \ conclude the task context for the data\n   transfer.  In the traditional iSCSI\
    \ model, the iSCSI protocol layer\n   plays the central role in pacing the data\
    \ transfer and carrying out\n   the ensuing data transfer itself.  An alternative\
    \ architecture would\n   be for iSCSI to delegate a large part of this data transfer\
    \ role to a\n   separate protocol layer exclusively designed to move data, which\
    \ in\n   turn is possibly aided by a data movement and placement technology\n\
    \   such as RDMA.\n   If iSCSI were operating in such RDMA environments, iSCSI\
    \ would be\n   shielded from the low-level data transfer mechanics but would only\
    \ be\n   privy to the conclusion of the requested data transfer.  Thus, there\n\
    \   would be an effective \"off-loading\" of the work that an iSCSI\n   protocol\
    \ layer is expected to perform, compared to today's iSCSI end\n   nodes.  For\
    \ such RDMA environments, it is highly desirable that there\n   be a standard\
    \ architecture to separate the data movement part of the\n   iSCSI protocol definition\
    \ from the rest of the iSCSI functionality.\n   This architecture precisely defines\
    \ what a Datamover layer is and\n   also describes the model of interactions between\
    \ the iSCSI layer and\n   the Datamover layer (Section 6).  In order to satisfy\
    \ this need, this\n   document presents a Datamover Architecture for iSCSI (DA)\
    \ and\n   summarizes a reasonable model for interactions between the iSCSI\n \
    \  layer and the Datamover layer for each of the iSCSI PDUs that are\n   defined\
    \ in [RFC3720].  Note that while DA is motivated by the advent\n   of RDMA over\
    \ TCP/IP technology, the architecture is not dependent on\n   RDMA in its design.\
    \  DA is intended to be a generic architectural\n   framework for allowing different\
    \ types of Datamovers based on\n   different types of RDMA and transport protocols.\
    \  Adoption of this\n   model will help iSCSI proliferate into more environments.\n"
- title: 1.2.  Interpretation of Requirements
  contents:
  - "1.2.  Interpretation of Requirements\n   This document introduces certain architectural\
    \ abstractions and\n   builds an abstract functional interface model between iSCSI\
    \ and\n   Datamover protocol layers based on those abstractions.  This\n   architectural\
    \ style is motivated by the following desires:\n      a) Provide guidance to Datamover\
    \ protocol designers with respect\n         to the functional boundary between\
    \ iSCSI and the Datamover\n         protocols.  This guidance is critical since\
    \ a significant part\n         of the [RFC3720] protocol definition is left unchanged\
    \ by DA\n         architecture and the iSCSI notions from [RFC3720] (e.g., tasks,\n\
    \         ITTs) are leveraged by the Datamover protocol.\n      b) Aid existing\
    \ iSCSI implementations to rapidly adapt to DA\n         architecture, largely\
    \ by leveraging the architectural\n         abstractions into implementation constructs\
    \ -- e.g., functions,\n         APIs, modules.\n   However, note that DA architecture\
    \ does not intend to impose any\n   implementation specifics per se.  When a DA\
    \ architectural concept\n   (e.g., Operational Primitive) is described as mandatory\
    \ (\"MUST\") or\n   recommended (\"SHOULD\") of a layer (iSCSI or Datamover) in\
    \ this\n   document, the intent is that an implementation respectively MUST or\n\
    \   SHOULD produce the same protocol action as what the model describes.\n   Specifically,\
    \ no implementation compliance in terms of names, modules\n   or API arguments\
    \ etc. is implied by this Architecture by such use of\n   [RFC2119] terms, only\
    \ a functional compliance is sought.\n"
- title: 2.  Definitions and Acronyms
  contents:
  - '2.  Definitions and Acronyms

    '
- title: 2.1.  Definitions
  contents:
  - "2.1.  Definitions\n   I/O Buffer - A buffer that is used in a SCSI Read or Write\
    \ operation\n      so that SCSI data may be sent from or received by the buffer.\n\
    \   Datamover protocol  - A Datamover protocol is a data transfer wire\n     \
    \ protocol for iSCSI that meets the requirements stated in Section\n      6.\n\
    \   Datamover layer - A Datamover layer is a protocol layer within an end\n  \
    \    node that implements the Datamover protocol.\n   Datamover-assisted - An\
    \ iSCSI connection is said to be \"Datamover-\n      assisted\" when a Datamover\
    \ layer is enabled for moving control and\n      data information on that iSCSI\
    \ connection.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
- title: 2.2.  Acronyms
  contents:
  - "2.2.  Acronyms\n   Acronym        Definition\n   -------------------------------------------------------------\n\
    \   DA             Datamover Architecture for iSCSI\n   DDP            Direct\
    \ Data Placement Protocol\n   DI             Datamover Interface\n   IANA    \
    \       Internet Assigned Numbers Authority\n   IETF           Internet Engineering\
    \ Task Force\n   I/O            Input - Output\n   IP             Internet Protocol\n\
    \   iSCSI          Internet SCSI\n   iSER           iSCSI Extensions for RDMA\n\
    \   ITT            Initiator Task Tag\n   LO             Leading Only\n   MPA\
    \            Marker PDU Aligned Framing for TCP\n   PDU            Protocol Data\
    \ Unit\n   RDDP           Remote Direct Data Placement\n   RDMA           Remote\
    \ Direct Memory Access\n   R2T            Ready To Transfer\n   R2TSN        \
    \  Ready To Transfer Sequence Number\n   RDMA           Remote Direct Memory Access\n\
    \   RDMAP          Remote Direct Memory Access Protocol\n   RFC            Request\
    \ For Comments\n   SAM            SCSI Architecture Model\n   SCSI           Small\
    \ Computer Systems Interface\n   SN             Sequence Number\n   SNACK    \
    \      Selective Negative Acknowledgment - also\n                  Sequence Number\
    \ Acknowledgement for Data\n   TCP            Transmission Control Protocol\n\
    \   TTT            Target Transfer Tag\n"
- title: 3.  Architectural Layering of iSCSI and Datamover Layers
  contents:
  - "3.  Architectural Layering of iSCSI and Datamover Layers\n   Figure 1 illustrates\
    \ an example of the architectural layering of\n   iSCSI and Datamover layers,\
    \ in conjunction with a TCP/IP\n   implementation of RDMAP/DDP ([DDP]) layers\
    \ in an iSCSI end node.\n   Note that RDMAP/DDP/MPA and TCP protocol layers are\
    \ shown here only\n   as an example, and in reality, DA is completely oblivious\
    \ to protocol\n   layers below the Datamover layer.  The RDMAP/DDP/MPA protocol\
    \ stack\n   provides a generic transport service with direct data placement.\n\
    \   There is no need to tailor the implementation of this protocol stack\n   to\
    \ the specific ULP to benefit from these services.\n          Initiator stack\
    \                            Target stack\n      +----------------+     SCSI application\
    \   +----------------+\n      | SCSI Layer     |     protocols          | SCSI\
    \ Layer     |\n      +----------------+                        +----------------+\n\
    \             ^                                          ^\n             |   \
    \                                       |\n             v                    \
    \                      v\n      +----------------+     iSCSI protocol     +----------------+\n\
    \      | iSCSI Layer    |    (excluding data     | iSCSI Layer    |\n      +----------------+\
    \       movement)        +----------------+\n             ^                  \
    \                        ^\n      --  ---+--  ---- DI (Datamover Interface)---\
    \  ----+---  ----\n             v                                          v\n\
    \      +----------------+      a Datamover       +----------------+\n      | Datamover\
    \ Layer|       protocol         | Datamover Layer|\n      +----------------+ \
    \                       +----------------+\n             ^                   \
    \                       ^\n     +-------+----------+                     +---------+-----------+\n\
    \     |       v          |                     |         v           |\n     |+---------------+\
    \ |                     | +-----------------+ |\n     || RDMAP/DDP/MPA | |   \
    \ RDMAP/DDP/MPA    | | RDMAP/DDP/MPA   | |\n     || Layers        | |    protocols\
    \        | | Layers          | |\n     |+---------------+ |                  \
    \   | +-----------------+ |\n     |       ^          |                     | \
    \        ^           |\n     |       | network  |                     |      \
    \   | network   |\n     |       | transport|                     |         | transport\
    \ |\n     |       v          |                     |         v           |\n \
    \    |+---------------+ |                     | +----------------+  |\n     ||\
    \ TCP Layer     | |    TCP protocol     | | TCP Layer      |  |\n     |+---------------+\
    \ |                     | +----------------+  |\n     |       ^          |   \
    \                  |         ^           |\n     +-------+----------+        \
    \             +---------+-----------+\n             +------------------------------------------+\n\
    \              Figure 1.  Datamover Architecture Diagram,\n                  \
    \      with the RDMAP Example\n   The scope of this document is limited to:\n\
    \      1. Defining the notion of a Datamover layer and a Datamover\n         protocol\
    \ (Section 6).\n      2. Defining the functionality distribution between the iSCSI\
    \ layer\n         and the Datamover layer, along with the communication model\n\
    \         between the two (Operational Primitives).\n      3. Modeling the interactions\
    \ between the blocks labeled as \"iSCSI\n         Layer\" and \"Datamover Layer\"\
    \ in Figure 1 -- i.e., defining the\n         interface labeled \"DI\" in the\
    \ figure -- for each defined iSCSI\n         PDU, based on the Operational Primitives.\n"
- title: 4.  Design Overview
  contents:
  - "4.  Design Overview\n   This document discusses and defines a model for interactions\
    \ between\n   the iSCSI layer and a \"Datamover layer\" (see Section 6) operating\n\
    \   within an iSCSI end node, presumably communicating with one or more\n   iSCSI\
    \ end nodes with similar layering.  The model for interactions\n   for handling\
    \ different iSCSI operations is called the \"Datamover\n   Interface\" (DI, Section\
    \ 10), while the architecture itself is called\n   the \"Datamover Architecture\
    \ for iSCSI\" (DA).  It is likely that the\n   architecture will have implications\
    \ on the Datamover wire protocols\n   as DA places certain requirements and functionality\
    \ expectations on\n   the Datamover layer.  However, this document itself neither\
    \ defines\n   any new wire protocol for the Datamover layer, nor any potential\n\
    \   modifications to the iSCSI wire protocol to employ the Datamover\n   layer.\
    \  The scope of this document is strictly limited to specifying\n   the architectural\
    \ framework and the minimally required interactions\n   that happen within an\
    \ iSCSI end node to leverage the Datamover layer.\n   The design ideas behind\
    \ DA can be summarized as follows:\n      1) DA defines an abstract functional\
    \ interface model of the iSCSI\n         layer's interactions with a Datamover\
    \ layer below -- i.e., DA\n         models the interactions between the logical\
    \ \"bottom\" interface\n         of iSCSI and the logical \"top\" interface of\
    \ a Datamover.\n      2) DA guides the wire protocol for a Datamover layer by\
    \ defining\n         the iSCSI knowledge that the Datamover layer may utilize\
    \ in its\n         protocol definition (as an example, this document completely\n\
    \         limits the notion of \"iSCSI session\" to the iSCSI layer).\n      3)\
    \ DA is designed to allow implementation of the Datamover layer\n         either\
    \ in hardware or in software.\n      4) DA is not a wire protocol spec, but an\
    \ architecture that also\n         models the interactions between iSCSI and Datamover\
    \ layers\n         operating within an iSCSI end node.\n      5) DA by design\
    \ seeks to model the iSCSI-Datamover interactions in\n         a way that the\
    \ modeling is independent of the specifics of\n         either a particular iSCSI\
    \ revision or an instantiation of a\n         Datamover layer.\n      6) DA introduces\
    \ and relies on the notion of a defined set of\n         Operational Primitives\
    \ (could be seen as entry point\n         definitions in implementation terms)\
    \ provided by each layer to\n         the other to carry out the request-response\
    \ interactions.\n      7) DA is intended to allow Datamover protocol definitions\
    \ with\n         minimal changes to existing iSCSI implementations.\n      8)\
    \ DA is designed to allow the iSCSI layer to completely rely on\n         the\
    \ Datamover layer for all data transport needs.\n      9) DA models the architecturally\
    \ required minimal interactions\n         between an operational iSCSI layer and\
    \ a Datamover layer to\n         realize the iSCSI-transparent data movement.\
    \  There may be\n         several other interactions in a typical implementation\
    \ in order\n         to bootstrap a Datamover layer (or an iSCSI layer) into\n\
    \         operation, but they are outside the scope of this document.\n   Note\
    \ that in summary, DA is architected to support many different\n   Datamover protocols\
    \ operating under the iSCSI layer.  One such\n   example of a Datamover protocol\
    \ is iSER [iSER].\n"
- title: 5.  Architectural Concepts
  contents:
  - '5.  Architectural Concepts

    '
- title: 5.1.  iSCSI PDU Types
  contents:
  - "5.1.  iSCSI PDU Types\n   This section defines the iSCSI PDU classification terminology,\
    \ as\n   defined and used in this document.  Out of the set of legal iSCSI\n \
    \  PDUs defined in [RFC3720], as we will see in Section 5.1.1, the iSCSI\n   layer\
    \ does not request a SCSI Data-Out PDU carrying solicited data\n   for transmission\
    \ across the Datamover Interface per this\n   architecture.  For this reason,\
    \ the SCSI Data-Out PDU carrying\n   solicited data is excluded in the iSCSI PDU\
    \ classification we\n   introduce in this section (for SCSI Data-Out PDUs for\
    \ unsolicited\n   Data, see Section 5.1.2).  The rest of the legal iSCSI PDUs\
    \ that may\n   be exchanged across the Datamover Interface are defined to consist\
    \ of\n   two classes:\n      1) iSCSI data-type PDUs\n      2) iSCSI control-type\
    \ PDUs\n"
- title: 5.1.1.  iSCSI Data-Type PDUs
  contents:
  - "5.1.1.  iSCSI Data-Type PDUs\n   An iSCSI data-type PDU is defined as an iSCSI\
    \ PDU that causes data\n   transfer, transparent to the remote iSCSI layer, to\
    \ take place\n   between the peer iSCSI nodes on a Full Feature Phase iSCSI\n\
    \   connection.  A data-type PDU, when requested for transmission by the\n   sender\
    \ iSCSI layer, results in the associated data transfer without\n   the participation\
    \ of the remote iSCSI layer, i.e., the PDU itself is\n   not delivered as-is to\
    \ the remote iSCSI layer.  The following iSCSI\n   PDUs constitute the set of\
    \ iSCSI data-type PDUs:\n      1) SCSI Data-In PDU\n      2) R2T PDU\n   In an\
    \ iSCSI end node structured as an iSCSI layer and a Datamover\n   layer as defined\
    \ in this document, the solicitation for Data-Out\n   (i.e., R2T PDU) is not delivered\
    \ to the initiator iSCSI layer, per\n   the definition of an iSCSI data-type PDU.\
    \  The data transfer is\n   instead performed via the mechanisms known to the\
    \ Datamover layer\n   (e.g., RDMA Read).  This in turn implies that a SCSI Data-Out\
    \ PDU for\n   solicited data is never requested for transmission across the\n\
    \   Datamover Interface at the initiator.\n"
- title: 5.1.2.  iSCSI Control-Type PDUs
  contents:
  - "5.1.2.  iSCSI Control-Type PDUs\n   Any iSCSI PDU that is not an iSCSI data-type\
    \ PDU and also not a\n   solicited SCSI Data-Out PDU is defined as an iSCSI control-type\
    \ PDU.\n   Specifically, note that SCSI Data-Out PDUs for unsolicited Data are\n\
    \   defined as iSCSI control-type PDUs.\n"
- title: 5.2.  Data_Descriptor
  contents:
  - "5.2.  Data_Descriptor\n   A Data_Descriptor is an information element that describes\
    \ an\n   iSCSI/SCSI data buffer, provided by the iSCSI layer to its local\n  \
    \ Datamover layer or provided by the Datamover layer to its local iSCSI\n   layer\
    \ for identifying the data associated respectively with the\n   requested or completed\
    \ operation.\n   In implementation terms, a Data_Descriptor may be a scatter-gather\n\
    \   list describing a local buffer, the exact structure of which is\n   subject\
    \ to the constraints imposed by the operating environment on\n   the local iSCSI\
    \ node.\n"
- title: 5.3.  Connection_Handle
  contents:
  - "5.3.  Connection_Handle\n   A Connection_Handle is an information element that\
    \ identifies the\n   particular iSCSI connection for which an inbound or outbound\
    \ iSCSI\n   PDU is intended.  A connection handle is unique for a given pair of\n\
    \   an iSCSI layer instance and a Datamover layer instance.  The\n   Connection_Handle\
    \ qualifier is used in all invocations of any\n   Operational Primitive for connection\
    \ identification.\n   Note that the Connection_Handle is conceptually different\
    \ from the\n   Connection Identifier (CID) defined by the iSCSI specification.\n\
    \   While the CID is a unique identifier of an iSCSI connection within an\n  \
    \ iSCSI session, the uniqueness of the Connection_Handle extends to the\n   entire\
    \ iSCSI layer instance coupled with the Datamover layer\n   instance, across possibly\
    \ multiple iSCSI sessions.\n   In implementation terms, a Connection_Handle could\
    \ be an opaque\n   identifier exchanged between the iSCSI layer and the Datamover\
    \ layer\n   at the connection login time.  One may also consider it to be similar\n\
    \   in scope of uniqueness to a socket identifier.  The exact structure\n   and\
    \ modalities of exchange of a Connection_Handle between the two\n   layers is\
    \ implementation-specific.\n"
- title: 5.4.  Operational Primitive
  contents:
  - "5.4.  Operational Primitive\n   An Operational Primitive, in this document, is\
    \ an abstract functional\n   interface procedure that requests another layer perform\
    \ a specific\n   action on the requestor's behalf or notifies the other layer\
    \ of some\n   event.  The Datamover Interface between an iSCSI layer instance\
    \ and a\n   Datamover layer instance within an iSCSI end node uses a set of\n\
    \   Operational Primitives to define the functional interface between the\n  \
    \ two layers.  Note that not every invocation of an Operational\n   Primitive\
    \ may elicit a response from the requested layer.  This\n   document describes\
    \ the types of Operational Primitives that are\n   implicitly required and provided\
    \ by the iSCSI protocol layer as\n   defined in [RFC3720], and the semantics of\
    \ these Primitives.\n   Note that ownership of buffers and data structures is\
    \ likely to be\n   exchanged between the iSCSI layer and its local Datamover layer\
    \ in\n   invoking the Operational Primitives defined in this architecture.\n \
    \  The buffer management details, including how buffers are allocated\n   and\
    \ released, are implementation-specific and thus are outside the\n   scope of\
    \ this document.\n   Each Operational Primitive invocation needs a certain \"\
    information\n   context\" (e.g., Connection_Handle) for performing the specific\
    \ action\n   being requested.  The required information context is described in\n\
    \   this document by a listing of \"qualifiers\" on each invocation, in the\n\
    \   style of function call arguments.  There is no specific\n   implementation\
    \ implied in this notation.  The \"qualifiers\" of any\n   Operational Primitive\
    \ invocation specified in this document thus\n   represent the mandatory information\
    \ context that the Operational\n   Primitive invocation MUST consider in performing\
    \ the action.  While\n   the qualifiers are required, the method of realizing\
    \ the qualifiers\n   (passed synchronously with invocation, or retrieved from\
    \ task\n   context, or retrieved from shared memory etc.) is really up to the\n\
    \   implementations.\n   When an Operational Primitive implementation is described\
    \ as\n   mandatory (\"MUST\") or recommended (\"SHOULD\") of a layer (iSCSI or\n\
    \   Datamover) in this document, the intent is that an implementation\n   respectively\
    \ MUST or SHOULD produce the same protocol action as what\n   the model describes.\n"
- title: 5.5.  Transport Connection
  contents:
  - "5.5.  Transport Connection\n   The term \"Transport Connection\" is used in this\
    \ document as a generic\n   term to represent the end-to-end logical connection\
    \ as defined by the\n   underlying reliable transport protocol.  For this document,\
    \ all\n   instances of Transport Connection refer to a TCP connection.\n"
- title: 6.  Datamover Layer and Datamover Protocol
  contents:
  - "6.  Datamover Layer and Datamover Protocol\n   This section introduces the notion\
    \ of a \"Datamover layer\" and\n   \"Datamover protocol\" as meant in this document,\
    \ and defines the\n   requirements on a Datamover protocol.\n   A Datamover layer\
    \ is the implementation component that realizes a\n   Datamover protocol functionality\
    \ in an iSCSI-capable end node in\n   communicating with other iSCSI end nodes\
    \ with similar capabilities.\n   More specifically, a \"Datamover layer\" MUST\
    \ provide the following\n   functionality and the \"Datamover protocol\" MUST\
    \ consist of the wire\n   protocol required to realize the following functionality:\n\
    \      1) guarantee that all the necessary data transfers take place when\n  \
    \       the local iSCSI layer requests transmitting a command (in order\n    \
    \     to complete a SCSI command, for an initiator), or\n         sending/receiving\
    \ an iSCSI data sequence (in order to complete\n         part of a SCSI command\
    \ for a target).\n      2) transport an iSCSI control-type PDU as-is to the peer\
    \ Datamover\n         layer when requested to do so by the local iSCSI layer.\n\
    \      3) provide notification and delivery to the iSCSI layer upon\n        \
    \ arrival of an iSCSI control-type PDU.\n      4) provide an initiator-to-target\
    \ data acknowledgement of SCSI\n         read data back to the target iSCSI layer,\
    \ when requested.\n      5) provide an asynchronous notification upon completion\
    \ of a\n         requested data transfer operation that moved data without\n \
    \        involving the iSCSI layer.\n      6) place the SCSI data into the I/O\
    \ buffers or pick up the SCSI\n         data for transmission out of the data\
    \ buffers that the iSCSI\n         layer had requested to be used for a SCSI I/O.\n\
    \      7) provide an error-free (i.e., must have at least the same level\n   \
    \      of assurance of data integrity as the CRC32C iSCSI data\n         digest),\
    \ reliable, in-order delivery transport mechanism over\n         IP networks in\
    \ performing the data transfer, and asynchronously\n         notify the iSCSI\
    \ layer upon iSCSI connection termination.\n   Note that this architecture expects\
    \ that each compliant Datamover\n   protocol will define the precise means of\
    \ satisfying the requirements\n   specified in this section.\n   In order to meet\
    \ the functional requirements listed in this section,\n   certain Datamover protocols\
    \ may require pre-posted buffers from the\n   local iSCSI protocol layer via mechanisms\
    \ outside the scope of this\n   document.  In some implementations, the absence\
    \ of such buffers may\n   result in a connection failure.  Datamover protocols\
    \ may also realize\n   these functional requirements via methods not explicitly\
    \ listed in\n   this document.\n"
- title: 7.  Functional Overview
  contents:
  - "7.  Functional Overview\n   This section presents an overview of the functional\
    \ interactions\n   between the iSCSI layer and the Datamover layer as intended\
    \ by this\n   Architecture.\n"
- title: 7.1.  Startup
  contents:
  - "7.1.  Startup\n   The iSCSI Login Phase on an iSCSI connection occurs as defined\
    \ in\n   [RFC3720].  The Architecture assumes that at the end of the Login\n \
    \  Phase, both the initiator and target, if they had so decided,\n   transition\
    \ the connection to being Datamover-assisted.  The precise\n   means of how an\
    \ iSCSI initiator and an iSCSI target agree on having\n   the connection Datamover-assisted\
    \ is defined by the Datamover\n   protocol.  The only architectural requirement\
    \ is that all iSCSI\n   interactions in the iSCSI Full Feature Phase MUST be Datamover-\n\
    \   assisted subject to the prior agreement, meaning that the Datamover\n   protocol\
    \ is in the iSCSI-to-iSCSI communication path below the iSCSI\n   layer on either\
    \ side as shown in Figure 1.  DA defines the\n   Enable_Datamover Operational\
    \ Primitive (Section 8.6) to bring about\n   this transition to a Datamover-assisted\
    \ connection.\n   The Architecture also assumes that the Datamover layer may require\
    \ a\n   certain number of opaque local resources for making a connection\n   Datamover-assisted.\
    \  DA thus defines the\n   Allocate_Connection_Resources Operational Primitive\
    \ (Section 8.4) to\n   model this interaction.  This Primitive is intended to\
    \ be invoked on\n   each side once the two sides decide (as previously noted)\
    \ to have the\n   connection be Datamover-assisted.  The expected sequence of\
    \ Primitive\n   invocations is depicted in Figures 2 and 3 in Section 13.2.  Figures\n\
    \   4, 5, and 6 illustrate how the Primitives may be employed to deal\n   with\
    \ various legal login outcomes.\n"
- title: 7.2.  Full Feature Phase
  contents:
  - "7.2.  Full Feature Phase\n   All iSCSI peer communication in the Full Feature\
    \ Phase happens\n   through the Datamover layers if the iSCSI connection is Datamover-\n\
    \   assisted.  The Architecture assumes that a Datamover layer may\n   require\
    \ a certain number of opaque local resources for each new iSCSI\n   task.  In\
    \ the normal course of execution, these task-level resources\n   in the Datamover\
    \ layer are assumed to be transparently allocated on\n   each task initiation\
    \ and deallocated on the conclusion of each task\n   as appropriate.  In exception\
    \ scenarios however -- scenarios that do\n   not yield a SCSI Response for each\
    \ task such as ABORT TASK operation\n   -- the Architecture assumes that the Datamover\
    \ layer needs to be\n   notified of the individual task terminations to aid its\
    \ task-level\n   resource management.  DA thus defines the Deallocate_Task_Resources\n\
    \   Operational Primitive (Section 8.9) to model this task-resource\n   management.\
    \  In specifying the ITT qualifier for the\n   Deallocate_Task_Resources Primitive,\
    \ the Architecture further assumes\n   that the Datamover layer tracks its opaque\
    \ task-level local resources\n   by the iSCSI ITT.  DA also defines Send_Control\
    \ (Section 8.1),\n   Put_Data (Section 8.2), Get_Data (Section 8.3),\n   Data_Completion_Notify\
    \ (Section 9.3), Data_ACK_Notify (Section 9.4),\n   and Control_Notify (Section\
    \ 9.1) Operational Primitives to model the\n   various Full Feature Phase interactions.\n\
    \   Figures 9, 10, and 11 in Section 13.2 show some Full Feature Phase\n   interactions\
    \ -- SCSI Write task, SCSI Read task, and a SCSI Read Data\n   acknowledgement,\
    \ respectively.  Figure 12 in Section 13.2 illustrates\n   how an ABORT TASK operation\
    \ can be modeled leading to deterministic\n   resource cleanup on the Datamover\
    \ layer.\n"
- title: 7.3.  Wrap-up
  contents:
  - "7.3.  Wrap-up\n   Once an iSCSI connection becomes Datamover-assisted, the connection\n\
    \   continues in that state until the end of the Full Feature Phase,\n   i.e.,\
    \ the termination of the connection.  The Architecture assumes\n   that when a\
    \ connection is normally logged out, the Datamover layer\n   needs to be notified\
    \ so that its connection-level opaque resources\n   (see Section 7.1) may be freed\
    \ up.  DA thus defines a\n   Connection_Terminate Operational Primitive (Section\
    \ 8.7) to model\n   this interaction.  The Architecture further assumes that when\
    \ a\n   connection termination happens without iSCSI layer's involvement\n   (e.g.,\
    \ TCP RST), the Datamover layer is capable of locally cleaning\n   up its task-level\
    \ and connection-level resources before notifying the\n   iSCSI layer of the fact.\
    \  DA thus defines the\n   Connection_Terminate_Notify Operational Primitive (Section\
    \ 9.2) to\n   model this interaction.\n   Figures 7 and 8 in Section 13.2 illustrate\
    \ the interactions between\n   the iSCSI and Datamover layers in normal and unexpected\
    \ connection\n   termination scenarios.\n"
- title: 8.  Operational Primitives Provided by the Datamover Layer
  contents:
  - "8.  Operational Primitives Provided by the Datamover Layer\n   While the iSCSI\
    \ specification itself does not have a notion of\n   Operational Primitives, any\
    \ iSCSI layer implementing the iSCSI\n   specification functionally requires the\
    \ following Operational\n   Primitives from its Datamover layer.  Thus, any Datamover\
    \ protocol\n   compliant with this architecture MUST implement the Operational\n\
    \   Primitives described in this section.  These Operational Primitives\n   are\
    \ invoked by the iSCSI layer as appropriate.  Unless otherwise\n   stated, all\
    \ the following Operational Primitives may be used both on\n   the initiator side\
    \ and the target side.  In general programming\n   terminology, this set of Operational\
    \ Primitives may be construed as\n   \"down calls\".\n      1) Send_Control\n\
    \      2) Put_Data\n      3) Get_Data\n      4) Allocate_Connection_Resources\n\
    \      5) Deallocate_Connection_Resources\n      6) Enable_Datamover\n      7)\
    \ Connection_Terminate\n      8) Notice_Key_Values\n      9) Deallocate_Task_Resources\n"
- title: 8.1.  Send_Control
  contents:
  - "8.1.  Send_Control\n   Input qualifiers: Connection_Handle, iSCSI PDU-specific\
    \ qualifiers\n   Return Results: Not specified.\n   An iSCSI layer requests that\
    \ its local Datamover layer transmit an\n   iSCSI control-type PDU to the peer\
    \ iSCSI layer operating in the\n   remote iSCSI node by this Operational Primitive.\
    \  The Datamover layer\n   performs the requested operation, and may add its own\
    \ protocol\n   headers in doing so.  The iSCSI layer MUST NOT invoke the\n   Send_Control\
    \ Operational Primitive on an iSCSI connection that is not\n   yet Datamover-assisted.\n\
    \   An initiator iSCSI layer requesting the transfer of a SCSI Command\n   PDU\
    \ or a target iSCSI layer requesting the transfer of a SCSI\n   response PDU are\
    \ examples of invoking the Send_Control Operational\n   Primitive.  As Section\
    \ 10.3.1 illustrates later on, the iSCSI PDU-\n   specific qualifiers in this\
    \ example are: BHS and AHS,\n   DataDescriptorOut, DataDescriptorIn, ImmediateDataSize,\
    \ and\n   UnsolicitedDataSize.\n"
- title: 8.2.  Put_Data
  contents:
  - "8.2.  Put_Data\n   Input qualifiers: Connection_Handle, contents of a SCSI Data-In\
    \ PDU\n   header, Data_Descriptor, Notify_Enable\n   Return Results: Not specified.\n\
    \   An iSCSI layer requests that its local Datamover layer transmit the\n   data\
    \ identified by the Data_Descriptor for the SCSI Data-In PDU to\n   the peer iSCSI\
    \ layer on the remote iSCSI node by this Operational\n   Primitive.  The Datamover\
    \ layer performs the operation by using its\n   own protocol means, completely\
    \ transparent to the remote iSCSI layer.\n   The iSCSI layer MUST NOT invoke the\
    \ Put_Data Operational Primitive on\n   an iSCSI connection that is not yet Datamover-assisted.\n\
    \   The Notify_Enable qualifier is used to request the local Datamover\n   layer\
    \ to generate or not generate the eventual local completion\n   notification to\
    \ the iSCSI layer for this Put_Data invocation.  For\n   detailed semantics of\
    \ this qualifier, see Section 9.3.\n   A Put_Data Primitive may only be invoked\
    \ by an iSCSI layer on the\n   target to its local Datamover layer.\n   A target\
    \ iSCSI layer requesting the transfer of an iSCSI read data\n   sequence (also\
    \ known as a read burst) is an example of invoking the\n   Put_Data Operational\
    \ Primitive.\n"
- title: 8.3.  Get_Data
  contents:
  - "8.3.  Get_Data\n   Input qualifiers: Connection_Handle, contents of an R2T PDU,\n\
    \   Data_Descriptor, Notify_Enable\n   Return Results: Not specified.\n   An iSCSI\
    \ layer requests that its local Datamover layer retrieve\n   certain data identified\
    \ by the R2T PDU from the peer iSCSI layer on\n   the remote iSCSI node and place\
    \ it into the buffer identified by the\n   Data_Descriptor by invoking this Operational\
    \ Primitive.  The\n   Datamover layer performs the operation by using its own\
    \ protocol\n   means, completely transparent to the remote iSCSI layer.  The iSCSI\n\
    \   layer MUST NOT invoke the Get_Data Operational Primitive on an iSCSI\n   connection\
    \ that is not yet Datamover-assisted.\n   The Notify_Enable qualifier is used\
    \ to request that the local\n   Datamover layer generate or not generate the eventual\
    \ local\n   completion notification to the iSCSI layer for this Get_Data\n   invocation.\
    \  For detailed semantics of this qualifier, see Section\n   9.3.\n   A Get_Data\
    \ Primitive may only be invoked by an iSCSI layer on the\n   target to its local\
    \ Datamover layer.\n   A target iSCSI layer requesting the transfer of an iSCSI\
    \ write data\n   sequence (also known as a write burst) is an example of invoking\
    \ the\n   Get_Data Operational Primitive.\n"
- title: 8.4.  Allocate_Connection_Resources
  contents:
  - "8.4.  Allocate_Connection_Resources\n   Input qualifiers: Connection_Handle[,\
    \ Resource_Descriptor ]\n   Return Results: Status.\n   By invoking this Operational\
    \ Primitive, an iSCSI layer requests that\n   its local Datamover layer perform\
    \ all the Datamover-specific resource\n   allocations required for the Full Feature\
    \ Phase of an iSCSI\n   connection.  The Connection_Handle identifies the connection\
    \ for\n   which the iSCSI layer is requesting resources to be allocated.\n   Allocation\
    \ of these resources is a step towards eventually\n   transitioning the connection\
    \ to become a Datamover-assisted iSCSI\n   connection.  Note that the Datamover\
    \ layer however does not allocate\n   any Datamover-specific task-level resources\
    \ upon invocation of this\n   Primitive.\n   An iSCSI layer, in addition, optionally\
    \ specifies the\n   implementation-specific resource requirements for the iSCSI\n\
    \   connection to the Datamover layer by passing an input qualifier\n   called\
    \ Resource_Descriptor.  The exact structure of a\n   Resource_Descriptor is implementation-dependent,\
    \ and hence\n   structurally opaque to DA.\n   A return result of Status=success\
    \ means that the\n   Allocate_Connection_Resources invocation corresponding to\
    \ that\n   Connection_Handle succeeded.  If an Allocate_Connection_Resources\n\
    \   invocation is made for a Connection_Handle for which an earlier\n   invocation\
    \ succeeded, the return Status must be success and the\n   request will be ignored\
    \ by the Datamover layer.  A return result of\n   Status=failure means that the\
    \ Allocate_Connection_Resources\n   invocation corresponding to that Connection_Handle\
    \ failed.  There\n   MUST NOT be more than one Allocate_Connection_Resources Primitive\n\
    \   invocation outstanding for a given Connection_Handle at any time.\n   The\
    \ iSCSI layer must invoke the Allocate_Connection_Resources\n   Primitive before\
    \ the invocation of the Enable_Datamover Primitive.\n"
- title: 8.5.  Deallocate_Connection_Resources
  contents:
  - "8.5.  Deallocate_Connection_Resources\n   Input qualifiers: Connection_Handle\n\
    \   Return Results: Not specified.\n   By invoking this Operational Primitive,\
    \ an iSCSI layer requests that\n   its local Datamover layer deallocate all the\
    \ Datamover-specific\n   resources that may have been allocated earlier for the\
    \ Transport\n   Connection identified by the Connection_Handle.  The iSCSI layer\
    \ may\n   invoke this Operational Primitive when the Datamover-specific\n   resources\
    \ associated with the Connection_Handle are no longer\n   necessary (such as the\
    \ Login failure of the corresponding iSCSI\n   connection).\n"
- title: 8.6.  Enable_Datamover
  contents:
  - "8.6.  Enable_Datamover\n   Input qualifiers: Connection_Handle, Transport_Connection_Descriptor\n\
    \   [, Final_Login_Response_PDU]\n   Return Results: Not specified.\n   By invoking\
    \ this Operational Primitive, an iSCSI layer requests that\n   its local Datamover\
    \ layer assist all further iSCSI exchanges on the\n   iSCSI connection (i.e.,\
    \ to make the connection Datamover-assisted)\n   identified by the Connection_Handle,\
    \ for which the Datamover-specific\n   resource allocation was earlier made. \
    \ The iSCSI layer MUST NOT\n   invoke the Enable_Datamover Operational Primitive\
    \ for an iSCSI\n   connection unless there is a corresponding prior resource allocation.\n\
    \   The Final_Login_Response_PDU input qualifier is applicable only for a\n  \
    \ target, and contains the final Login Response that concludes the\n   iSCSI Login\
    \ Phase and which must be sent as a byte stream as expected\n   by the initiator\
    \ iSCSI layer.  When this qualifier is used, the\n   target-Datamover layer MUST\
    \ transmit this final Login Response before\n   Datamover assistance is enabled\
    \ for the Transport Connection.\n   The iSCSI layer identifies the specific Transport\
    \ Connection\n   associated with the Connection_Handle to the Datamover layer\
    \ by\n   specifying the Transport_Connection_Descriptor.  The exact structure\n\
    \   of this Descriptor is implementation-dependent.\n"
- title: 8.7.  Connection_Terminate
  contents:
  - "8.7.  Connection_Terminate\n   Input qualifiers: Connection_Handle\n   Return\
    \ Results: Not specified.\n   By invoking this Operational Primitive, an iSCSI\
    \ layer requests that\n   its local Datamover layer terminate the Transport Connection\
    \ and\n   deallocate all the connection and task resources associated with the\n\
    \   Connection_Handle.  When this Operational Primitive invocation\n   returns\
    \ to the iSCSI layer, the iSCSI layer may assume the full\n   ownership of all\
    \ the iSCSI-level resources, e.g., I/O Buffers,\n   associated with the connection.\
    \  This Operational Primitive may be\n   invoked only with a valid Connection_Handle,\
    \ and the Transport\n   Connection associated with the Connection_Handle must\
    \ already be\n   Datamover-assisted.\n"
- title: 8.8.  Notice_Key_Values
  contents:
  - "8.8.  Notice_Key_Values\n   Input qualifiers: Connection_Handle, Number of keys,\
    \ a list of Key-\n   Value pairs.\n   Return Results: Not specified.\n   By invoking\
    \ this Operational Primitive, an iSCSI layer requests that\n   its local Datamover\
    \ layer take note of the negotiated values of the\n   listed keys for the Transport\
    \ Connection.  This Operational Primitive\n   may be invoked only with a valid\
    \ Connection_Handle, and the Key-Value\n   pairs MUST be the current values that\
    \ were successfully agreed upon\n   by the iSCSI peers for the connection.  The\
    \ Datamover layer may use\n   the values of the keys to aid the Datamover operation\
    \ as it deems\n   appropriate.  The specific keys to be passed as input qualifiers\
    \ and\n   the point(s) in time this Operational Primitive is invoked are\n   implementation-dependent.\n"
- title: 8.9.  Deallocate_Task_Resources
  contents:
  - "8.9.  Deallocate_Task_Resources\n   Input qualifiers: Connection_Handle, ITT\n\
    \   Return Results: Not specified.\n   By invoking this Operational Primitive,\
    \ an iSCSI layer requests that\n   its local Datamover layer deallocate all Datamover-specific\
    \ resources\n   that earlier may have been allocated for the task identified by\
    \ the\n   ITT qualifier.  The iSCSI layer uses this Operational Primitive\n  \
    \ during exception processing when one or more active tasks are to be\n   terminated\
    \ without corresponding SCSI Response PDUs.  This Primitive\n   MUST be invoked\
    \ for each active task terminated without a SCSI\n   Response PDU.  This Primitive\
    \ MUST NOT be invoked by the iSCSI layer\n   when a SCSI Response PDU normally\
    \ concludes a task.  When a SCSI\n   Response PDU normally concludes a task (even\
    \ if the SCSI Status was\n   not a success), the Datamover layer is assumed to\
    \ have automatically\n   deallocated all Datamover-specific task resources for\
    \ that task.\n   Refer to Section 7.2 for a related discussion on the Architectural\n\
    \   assumptions on the task-level Datamover resource management,\n   especially\
    \ with respect to when the resources are assumed to be\n   allocated.\n"
- title: 9.  Operational Primitives Provided by the iSCSI Layer
  contents:
  - "9.  Operational Primitives Provided by the iSCSI Layer\n   While the iSCSI specification\
    \ itself does not have a notion of\n   Operational Primitives, any iSCSI layer\
    \ implementing the iSCSI\n   specification would have to provide the following\
    \ Operational\n   Primitives to its local Datamover layer.  Thus, any iSCSI protocol\n\
    \   implementation compliant with this architecture MUST implement the\n   Operational\
    \ Primitives described in this section.  These Operational\n   Primitives are\
    \ invoked by the Datamover layer as appropriate and when\n   the iSCSI connection\
    \ is Datamover-assisted.  Unless otherwise stated,\n   all the following Operational\
    \ Primitives may be used both on the\n   initiator side and the target side. \
    \ In general programming\n   terminology, this set of Operational Primitives may\
    \ be construed as\n   \"up calls\".\n      1) Control_Notify\n      2) Connection_Terminate_Notify\n\
    \      3) Data_Completion_Notify\n      4) Data_ACK_Notify\n"
- title: 9.1.  Control_Notify
  contents:
  - "9.1.  Control_Notify\n   Input qualifiers: Connection_Handle, an iSCSI control-type\
    \ PDU.\n   Return Results: Not specified.\n   A Datamover layer notifies its local\
    \ iSCSI layer, via this\n   Operational Primitive, of the arrival of an iSCSI\
    \ control-type PDU\n   from the peer Datamover layer on the remote iSCSI node.\
    \  The iSCSI\n   layer processes the control-type PDU as defined in [RFC3720].\n\
    \   A target iSCSI layer being notified of the arrival of a SCSI command\n   is\
    \ an example of invoking the Control_Notify Operational Primitive.\n   Note that\
    \ implementations may choose to describe the \"iSCSI control-\n   type PDU\" qualifier\
    \ in this notification using a Data_Descriptor\n   (Section 5.2) and not necessarily\
    \ one contiguous buffer.\n"
- title: 9.2.  Connection_Terminate_Notify
  contents:
  - "9.2.  Connection_Terminate_Notify\n   Input qualifiers: Connection_Handle\n \
    \  Return Results: Not specified.\n   A Datamover layer notifies its local iSCSI\
    \ layer on an unsolicited\n   termination or failure of an iSCSI connection providing\
    \ the\n   Connection_Handle associated with the iSCSI Connection.  The iSCSI\n\
    \   layer MUST consider the Connection_Handle to be invalid upon being so\n  \
    \ notified.  The iSCSI layer processes the connection termination as\n   defined\
    \ in [RFC3720].  The Datamover layer MUST deallocate the\n   connection and task\
    \ resources associated with the terminated\n   connection before notifying the\
    \ iSCSI layer of the termination via\n   this Operational Primitive.\n   A target\
    \ iSCSI layer is notified of an ungraceful connection\n   termination by the Datamover\
    \ layer when the underlying Transport\n   Connection is torn down.  Such a Connection_Terminate_Notify\n\
    \   Operational Primitive may be triggered, for example, by a TCP RESET\n   in\
    \ cases where the underlying Transport Connection uses TCP.\n"
- title: 9.3.  Data_Completion_Notify
  contents:
  - "9.3.  Data_Completion_Notify\n   Input qualifiers: Connection_Handle, ITT, SN\n\
    \   Return Results: Not specified.\n   A Datamover layer notifies its local iSCSI\
    \ layer on completing the\n   retrieval of the data or upon sending the data,\
    \ as requested in a\n   prior iSCSI data-type PDU, from/to the peer Datamover\
    \ layer on the\n   remote iSCSI node via this Operational Primitive.  The iSCSI\
    \ layer\n   processes the operation as defined in [RFC3720].\n   SN may be either\
    \ the DataSN associated with the SCSI Data-In PDU or\n   R2TSN associated with\
    \ the R2T PDU depending on the SCSI operation.\n   Note that, for targets, a TTT\
    \ (see [RFC3720]) could have been\n   specified instead of an SN.  However, the\
    \ considered choice was to\n   leave the SN to be the qualifier for two reasons\
    \ -- a) it is generic\n   and applicable to initiators and targets as well as\
    \ Data-In and\n   Data-Out, and b) having both SN and TTT qualifiers for the\n\
    \   notification is considered onerous on the Datamover layer, in terms\n   of\
    \ state maintenance for each completion notification.  The\n   implication of\
    \ this choice is that iSCSI target implementations will\n   have to adapt to using\
    \ the ITT-SN tuple in associating the solicited\n   data to the appropriate task,\
    \ rather than the ITT-TTT tuple for doing\n   the same.\n   If Notify_Enable is\
    \ set in either a Put_Data or a Get_Data\n   invocation, the Datamover layer MUST\
    \ invoke the\n   Data_Completion_Notify Operational Primitive upon completing\
    \ that\n   requested data transfer.  If the Notify_Enable was cleared in either\n\
    \   a Put_Data or a Get_Data invocation, the Datamover layer MUST NOT\n   invoke\
    \ the Data_Completion_Notify Operational Primitive upon\n   completing that requested\
    \ data transfer.\n   A Data_Completion_Notify invocation serves to notify the\
    \ iSCSI layer\n   of the Put_Data or Get_Data completion, respectively.  As earlier\n\
    \   noted in Sections 8.2 and 8.3, specific Datamover protocol\n   definitions\
    \ may restrict the usage scope of Put_Data and Get_Data,\n   and thus implicitly\
    \ the usage scope of Data_Completion_Notify.\n   A target iSCSI layer being notified\
    \ of the retrieval of a write data\n   sequence is an example of invoking the\
    \ Data_Completion_Notify\n   Operational Primitive.\n"
- title: 9.4.  Data_ACK_Notify
  contents:
  - "9.4.  Data_ACK_Notify\n   Input qualifiers: Connection_Handle, ITT, DataSN\n\
    \   Return Results: Not specified.\n   A target Datamover layer notifies its local\
    \ iSCSI layer of the\n   arrival of a previously requested data acknowledgement\
    \ from the peer\n   Datamover layer on the remote (initiator) iSCSI node via this\n\
    \   Operational Primitive.  The iSCSI layer processes the data\n   acknowledgement\
    \ notification as defined in [RFC3720].\n   A target iSCSI layer being notified\
    \ of the arrival of a data\n   acknowledgement for a certain SCSI Read data PDU\
    \ is the only example\n   of invoking the Data_ACK_Notify Operational Primitive.\n"
- title: 10.  Datamover Interface (DI)
  contents:
  - '10.  Datamover Interface (DI)

    '
- title: 10.1.  Overview
  contents:
  - "10.1.  Overview\n   This section describes the model of interactions between\
    \ iSCSI and\n   Datamover layers when the iSCSI connection is Datamover-assisted\
    \ so\n   the iSCSI layer may carry out the following:\n      -  send iSCSI data-type\
    \ PDUs and exchange iSCSI control-type PDUs,\n         and\n      -  handle asynchronous\
    \ notifications such as completion of data\n         sequence transfer and connection\
    \ failure.\n   This chapter relies on the notion of Operational Primitives (Section\n\
    \   5.4) to define DI.\n"
- title: 10.2.  Interactions for Handling Asynchronous Notifications
  contents:
  - '10.2.  Interactions for Handling Asynchronous Notifications

    '
- title: 10.2.1.  Connection Termination
  contents:
  - "10.2.1.  Connection Termination\n   As stated in Section 9.2, the Datamover layer\
    \ notifies the iSCSI\n   layer of a failed or terminated connection via the\n\
    \   Connection_Terminate_Notify Operational Primitive.  The iSCSI layer\n   MUST\
    \ consider the connection unusable upon the invocation of this\n   Primitive and\
    \ handle the connection termination as specified in\n   [RFC3720].\n"
- title: 10.2.2.  Data Transfer Completion
  contents:
  - "10.2.2.  Data Transfer Completion\n   As stated in Section 9.3, the Datamover\
    \ layer notifies the iSCSI\n   layer of a completed data transfer operation via\
    \ the\n   Data_Completion_Notify Operational Primitive.  The iSCSI layer\n   processes\
    \ the transfer completion as specified in [RFC3720].\n"
- title: 10.2.2.1.  Completion of a Requested SCSI Data Transfer
  contents:
  - "10.2.2.1.  Completion of a Requested SCSI Data Transfer\n   To notify the iSCSI\
    \ layer of the completion of a requested iSCSI\n   data-type PDU transfer, the\
    \ Datamover layer uses the\n   Data_Completion_Notify Operational Primitive with\
    \ the following input\n   qualifiers.\n      a) Connection_Handle.\n      b) ITT:\
    \ Initiator Task Tag semantics as defined in [RFC3720].\n      c) SN: DataSN for\
    \ a SCSI Data-in/Data-out PDU, and R2TSN for an\n         iSCSI R2T PDU.  The\
    \ semantics for both types of sequence\n         numbers are as defined in [RFC3720].\n\
    \   The rationale for choosing SN is explained in Section 9.3.\n   Every invocation\
    \ of the Data_Completion_Notify Operational Primitive\n   MUST be preceded by\
    \ an invocation of the Put_Data or Get_Data\n   Operational Primitive with the\
    \ Notify_Enable qualifier set by the\n   iSCSI layer at an earlier point in time.\n"
- title: 10.2.3.  Data Acknowledgement
  contents:
  - "10.2.3.  Data Acknowledgement\n   [RFC3720] allows the iSCSI targets to optionally\
    \ solicit data\n   acknowledgement from the initiator for one or more Data-In\
    \ PDUs, via\n   setting of the A-bit on a Data-In PDU.  The Data_ACK_Notify\n\
    \   Operational Primitive with the following input qualifiers is used by\n   the\
    \ target Datamover layer to notify the local iSCSI layer of the\n   arrival of\
    \ data acknowledgement of a previously solicited iSCSI read\n   data acknowledgement.\
    \  This Operational Primitive thus is applicable\n   only to iSCSI targets.\n\
    \      a) Connection_Handle.\n      b) ITT: Initiator Task Tag semantics as defined\
    \ in [RFC3720].\n      c) DataSN: of the next SCSI Data-In PDU, which immediately\
    \ follows\n         the SCSI Data-In PDU with the A-bit set to which this\n  \
    \       notification corresponds, with semantics as defined in\n         [RFC3720].\n\
    \   Every invocation of the Data_ACK_Notify Operational Primitive MUST be\n  \
    \ preceded by an invocation of the Put_Data Operational Primitive by\n   the iSCSI\
    \ target layer with the A-bit set to 1 at an earlier point in\n   time.\n"
- title: 10.3.  Interactions for Sending an iSCSI PDU
  contents:
  - "10.3.  Interactions for Sending an iSCSI PDU\n   This section discusses the model\
    \ of interactions for sending each of\n   the iSCSI PDUs defined in [RFC3720].\
    \  A Connection_Handle (see\n   Section 5.3) is assumed to qualify each of these\
    \ interactions so that\n   the Datamover layer can route it to the appropriate\
    \ Transport\n   Connection.  The qualifying Connection_Handle is not explicitly\n\
    \   listed in the subsequent sections.\n   Note that the defined list of input\
    \ qualifiers represents the\n   semantically required set for the Datamover layer\
    \ to consider in\n   implementing the Primitive in each interaction described\
    \ in this\n   section (see Section 5.4 for an elaboration).  Implementations may\n\
    \   choose to deduce the qualifiers in ways that are optimized for the\n   implementation\
    \ specifics.  Two examples of this are:\n      1. For SCSI command (Section 10.3.1),\
    \ deducing the\n         ImmediateDataSize input qualifier from the DataSegmentLength\n\
    \         field of the SCSI Command PDU.\n      2. For SCSI Data-Out (Section\
    \ 10.3.5.1), deducing the\n         DataDescriptorOut input qualifier from the\
    \ associated SCSI\n         command invocation qualifiers (assuming such state\
    \ is\n         maintained) in conjunction with BHS fields of the SCSI Data-Out\n\
    \         PDU.\n"
- title: 10.3.1.  SCSI Command
  contents:
  - "10.3.1.  SCSI Command\n   The Send_Control Operational Primitive with the following\
    \ input\n   qualifiers is used for requesting the transmission of a SCSI Command\n\
    \   PDU.\n      a) BHS and AHS, if any, of the SCSI Command PDU as defined in\n\
    \         [RFC3720].\n      b) DataDescriptorOut: that defines the I/O Buffer\
    \ meant for Data-\n         Out for the entire command, in the case of a write\
    \ or\n         bidirectional command.\n      c) DataDescriptorIn: that defines\
    \ the I/O Buffer meant for Data-In\n         for the entire command, in the case\
    \ of a read or bidirectional\n         command.\n      d) ImmediateDataSize: that\
    \ defines the number of octets of\n         immediate unsolicited data for a write/bidirectional\
    \ command.\n      e) UnsolicitedDataSize: that defines the number of octets of\n\
    \         immediate and non-immediate unsolicited data for a\n         write/bidirectional\
    \ command.\n"
- title: 10.3.2.  SCSI Response
  contents:
  - "10.3.2.  SCSI Response\n   The Send_Control Operational Primitive with the following\
    \ input\n   qualifiers is used for requesting the transmission of a SCSI Response\n\
    \   PDU.\n      a) BHS of the SCSI Response PDU as defined in [RFC3720].\n   \
    \   b) DataDescriptorStatus: that defines the iSCSI buffer that\n         contains\
    \ the sense and response information for the command.\n"
- title: 10.3.3.  Task Management Function Request
  contents:
  - "10.3.3.  Task Management Function Request\n   The Send_Control Operational Primitive\
    \ with the following input\n   qualifiers is used for requesting the transmission\
    \ of a Task\n   Management Function Request PDU.\n      a) BHS of the Task Management\
    \ Function Request PDU as defined in\n         [RFC3720].\n      b) DataDescriptorOut:\
    \ that defines the I/O Buffer meant for Data-\n         Out for the entire command,\
    \ in the case of a write or\n         bidirectional command.  (Only valid if Function=\"\
    TASK REASSIGN\"\n         - [RFC3720].)\n      c) DataDescriptorIn: that defines\
    \ the I/O Buffer meant for Data-In\n         for the entire command, in the case\
    \ of a read or bidirectional\n         command.  (Only valid if Function=\"TASK\
    \ REASSIGN\" - [RFC3720].)\n"
- title: 10.3.4.  Task Management Function Response
  contents:
  - "10.3.4.  Task Management Function Response\n   The Send_Control Operational Primitive\
    \ with the following input\n   qualifier is used for requesting the transmission\
    \ of a Task\n   Management Function Response PDU.\n      a) BHS of the Task Management\
    \ Function Response PDU as defined in\n         [RFC3720].\n"
- title: 10.3.5.  SCSI Data-Out and SCSI Data-In
  contents:
  - '10.3.5.  SCSI Data-Out and SCSI Data-In

    '
- title: 10.3.5.1.  SCSI Data-Out
  contents:
  - "10.3.5.1.  SCSI Data-Out\n   The Send_Control Operational Primitive with the\
    \ following input\n   qualifiers is used by the initiator iSCSI layer for requesting\
    \ the\n   transmission of a SCSI Data-Out PDU carrying the non-immediate\n   unsolicited\
    \ data.\n      a) BHS of the SCSI Data-Out PDU as defined in [RFC3720].\n    \
    \  b) DataDescriptorOut: that defines the I/O Buffer with the Data-\n        \
    \ Out to be carried in the iSCSI data segment of the PDU.\n"
- title: 10.3.5.2.  SCSI Data-In
  contents:
  - "10.3.5.2.  SCSI Data-In\n   The Put_Data Operational Primitive with the following\
    \ input\n   qualifiers is used by the target iSCSI layer for requesting the\n\
    \   transmission of the data carried by a SCSI Data-In PDU.\n      a) BHS of the\
    \ SCSI Data-In PDU as defined in [RFC3720].\n      b) DataDescriptorIn: that defines\
    \ the I/O Buffer with the Data-In\n         being requested for transmission.\n"
- title: 10.3.6.  Ready To Transfer (R2T)
  contents:
  - "10.3.6.  Ready To Transfer (R2T)\n   The Get_Data Operational Primitive with\
    \ the following input\n   qualifiers is used by the target iSCSI layer for requesting\
    \ the\n   retrieval of the data as specified by the semantic content of an R2T\n\
    \   PDU.\n      a) BHS of the Ready To Transfer PDU as defined in [RFC3720].\n\
    \      b) DataDescriptorOut: that defines the I/O Buffer for the Data-Out\n  \
    \       being requested for retrieval.\n"
- title: 10.3.7.  Asynchronous Message
  contents:
  - "10.3.7.  Asynchronous Message\n   The Send_Control Operational Primitive with\
    \ the following input\n   qualifiers is used for requesting the transmission of\
    \ an Asynchronous\n   Message PDU.\n      a) BHS of the Asynchronous Message PDU\
    \ as defined in [RFC3720].\n      b) DataDescriptorSense: that defines an iSCSI\
    \ buffer that contains\n         the sense and iSCSI Event information.\n"
- title: 10.3.8.  Text Request
  contents:
  - "10.3.8.  Text Request\n   The Send_Control Operational Primitive with the following\
    \ input\n   qualifiers is used for requesting the transmission of a Text Request\n\
    \   PDU.\n      a) BHS of the Text Request PDU as defined in [RFC3720].\n    \
    \  b) DataDescriptorTextOut: that defines the iSCSI Text Request\n         buffer.\n"
- title: 10.3.9.  Text Response
  contents:
  - "10.3.9.  Text Response\n   The Send_Control Operational Primitive with the following\
    \ input\n   qualifiers is used for requesting the transmission of a Text Response\n\
    \   PDU.\n      a) BHS of the Text Response PDU as defined in [RFC3720].\n   \
    \   b) DataDescriptorTextIn: that defines the iSCSI Text Response\n         buffer.\n"
- title: 10.3.10.  Login Request
  contents:
  - "10.3.10.  Login Request\n   The Send_Control Operational Primitive with the following\
    \ input\n   qualifiers is used for requesting the transmission of a Login Request\n\
    \   PDU.\n      a) BHS of the Login Request PDU as defined in [RFC3720].\n   \
    \   b) DataDescriptorLoginRequest: that defines the iSCSI Login\n         Request\
    \ buffer.\n   Note that specific Datamover protocols may choose to disallow the\n\
    \   standard DA Primitives from being used for the iSCSI Login Phase.\n   When\
    \ used in conjunction with such Datamover protocols, an attempt to\n   send a\
    \ Login Request via the Send_Control Operational Primitive\n   invocation is clearly\
    \ an error scenario, as the Login Request PDU is\n   being sent while the connection\
    \ is in the iSCSI Full Feature Phase.\n   It is outside the scope of this document\
    \ to specify the resulting\n   implementation behavior in this case -- [RFC3720]\
    \ already defines the\n   error handling for this error scenario.\n"
- title: 10.3.11.  Login Response
  contents:
  - "10.3.11.  Login Response\n   The Send_Control Operational Primitive with the\
    \ following input\n   qualifiers is used for requesting the transmission of a\
    \ Login\n   Response PDU.\n      a) BHS of the Login Response PDU as defined in\
    \ [RFC3720].\n      b) DataDescriptorLoginResponse: that defines the iSCSI Login\n\
    \         Response buffer.\n   Note that specific Datamover protocols may choose\
    \ to disallow the\n   standard DA Primitives from being used for the iSCSI Login\
    \ Phase.\n   When used in conjunction with such Datamover protocols, an attempt\
    \ to\n   send a Login Response via the Send_Control Operational Primitive\n  \
    \ invocation is clearly an error scenario, as the Login Response PDU is\n   being\
    \ sent while in the iSCSI Full Feature Phase.  It is outside the\n   scope of\
    \ this document to specify the resulting implementation\n   behavior in this case\
    \ -- [RFC3720] already defines the error handling\n   for this error scenario.\n"
- title: 10.3.12.  Logout Command
  contents:
  - "10.3.12.  Logout Command\n   The Send_Control Operational Primitive with the\
    \ following input\n   qualifier is used for requesting the transmission of a Logout\
    \ Command\n   PDU.\n      a) BHS of the Logout Command PDU as defined in [RFC3720].\n"
- title: 10.3.13.  Logout Response
  contents:
  - "10.3.13.  Logout Response\n   The Send_Control Operational Primitive with the\
    \ following input\n   qualifier is used for requesting the transmission of a Logout\n\
    \   Response PDU.\n      a) BHS of the Logout Response PDU as defined in [RFC3720].\n"
- title: 10.3.14.  SNACK Request
  contents:
  - "10.3.14.  SNACK Request\n   The Send_Control Operational Primitive with the following\
    \ input\n   qualifier is used for requesting the transmission of a SNACK Request\n\
    \   PDU.\n      a) BHS of the SNACK Request PDU as defined in [RFC3720].\n"
- title: 10.3.15.  Reject
  contents:
  - "10.3.15.  Reject\n   The Send_Control Operational Primitive with the following\
    \ input\n   qualifiers is used for requesting the transmission of a Reject PDU.\n\
    \      a) BHS of the Reject PDU as defined in [RFC3720].\n      b) DataDescriptorReject:\
    \ that defines the iSCSI Reject buffer.\n"
- title: 10.3.16.  NOP-Out
  contents:
  - "10.3.16.  NOP-Out\n   The Send_Control Operational Primitive with the following\
    \ input\n   qualifiers is used for requesting the transmission of a NOP-Out PDU.\n\
    \      a) BHS of the NOP-Out PDU as defined in [RFC3720].\n      b) DataDescriptorNOPOut:\
    \ that defines the iSCSI Ping data buffer.\n"
- title: 10.3.17.  NOP-In
  contents:
  - "10.3.17.  NOP-In\n   The Send_Control Operational Primitive with the following\
    \ input\n   qualifiers is used for requesting the transmission of a NOP-In PDU.\n\
    \      a) BHS of the NOP-In PDU as defined in [RFC3720].\n      b) DataDescriptorNOPIn:\
    \ that defines the iSCSI Return Ping data\n         buffer.\n"
- title: 10.4.  Interactions for Receiving an iSCSI PDU
  contents:
  - "10.4.  Interactions for Receiving an iSCSI PDU\n   The only PDUs that are received\
    \ by an iSCSI layer operating on a\n   Datamover layer are the iSCSI control-type\
    \ PDUs.  The Datamover layer\n   delivers the iSCSI control-type PDUs as they\
    \ arrive, qualifying each\n   with the Connection_Handle (see Section 5.3) that\
    \ identifies the\n   iSCSI connection for which the PDU is meant.  The subsequent\n\
    \   processing of the iSCSI control-type PDUs proceeds as defined in\n   [RFC3720].\n"
- title: 10.4.1.  General Control-Type PDU Notification
  contents:
  - "10.4.1.  General Control-Type PDU Notification\n   This sub-section describes\
    \ the general mechanics applicable to\n   several control-type PDUs.  The following\
    \ sub-sections note\n   additional considerations for control-type PDUs that are\
    \ not covered\n   in this sub-section.\n   The Control_Notify Operational Primitive\
    \ is used to notify the iSCSI\n   layer of the arrival of the following iSCSI\
    \ control-type PDUs: SCSI\n   Command, SCSI Response, Task Management Function\
    \ Request, Task\n   Management Function Response, Asynchronous Message, Text Request,\n\
    \   Text Response, Logout Command, Logout Response, SNACK, Reject, NOP-\n   Out,\
    \ NOP-In.\n"
- title: 10.4.2.  SCSI Data Transfer PDUs
  contents:
  - '10.4.2.  SCSI Data Transfer PDUs

    '
- title: 10.4.2.1.  SCSI Data-Out
  contents:
  - "10.4.2.1.  SCSI Data-Out\n   The Control_Notify Operational Primitive is used\
    \ to notify the iSCSI\n   layer of the arrival of a SCSI Data-Out PDU carrying\
    \ the non-\n   immediate unsolicited data.  Note however that the solicited SCSI\n\
    \   Data-Out arriving on the target does not cause a notification to the\n   iSCSI\
    \ layer using the Control_Notify Primitive because the solicited\n   SCSI Data-Out\
    \ was not sent by the initiator iSCSI layer as control-\n   type PDUs.\n"
- title: 10.4.2.2.  SCSI Data-In
  contents:
  - "10.4.2.2.  SCSI Data-In\n   The Datamover layer does not notify the iSCSI layer\
    \ of the arrival of\n   the SCSI Data-in at the initiator, because SCSI Data-in\
    \ is an iSCSI\n   data-type PDU (see section 5.1).  The iSCSI layer at the initiator\n\
    \   however may infer the arrival of the SCSI Data-In when it receives a\n   subsequent\
    \ notification of the SCSI Response PDU via a Control_Notify\n   invocation.\n\
    \   While this document does not contemplate the possibility of a Data-In\n  \
    \ PDU being received at the initiator iSCSI layer, specific Datamover\n   protocols\
    \ may define how to deal with an unexpected inbound SCSI\n   Data-In PDU that\
    \ may result in the initiator iSCSI layer receiving\n   the Data-In PDU.  This\
    \ document leaves the details of handling this\n   error scenario to the specific\
    \ Datamover protocols, so each may\n   define the appropriate error handling specific\
    \ to the Datamover\n   environment.\n"
- title: 10.4.2.3.  Ready To Transfer (R2T)
  contents:
  - "10.4.2.3.  Ready To Transfer (R2T)\n   Because an R2T PDU is an iSCSI data-type\
    \ PDU (see Section 5.1) that\n   is not delivered as-is to the initiator iSCSI\
    \ layer, the Datamover\n   layer does not notify the iSCSI layer of the arrival\
    \ of an R2T PDU.\n   When an iSCSI node sends an R2T PDU to its local Datamover\
    \ layer, the\n   local and remote Datamover layers transparently bring about the\
    \ data\n   transfer requested by the R2T PDU.\n   While this document does not\
    \ contemplate the possibility of an R2T\n   PDU being received at the initiator\
    \ iSCSI layer, specific Datamover\n   protocols may define how to deal with an\
    \ unexpected inbound R2T PDU\n   that may result in the initiator iSCSI layer\
    \ receiving the R2T PDU.\n   This document leaves the details of handling this\
    \ error scenario to\n   the specific Datamover protocols, so each may define the\
    \ appropriate\n   error handling specific to the Datamover environment.\n"
- title: 10.4.3.  Login Request
  contents:
  - "10.4.3.  Login Request\n   The Control_Notify Operational Primitive is used for\
    \ notifying the\n   target iSCSI layer of the arrival of a Login Request PDU.\
    \  Note that\n   specific Datamover protocols may choose to disallow the standard\
    \ DA\n   Primitives from being used for the iSCSI Login Phase.  When used in\n\
    \   conjunction with such Datamover protocols, the arrival of a Login\n   Request\
    \ necessitating the Control_Notify Operational Primitive\n   invocation is clearly\
    \ an error scenario, as the Login Request PDU is\n   arriving in the iSCSI Full\
    \ Feature Phase.  It is outside the scope of\n   this document to specify the\
    \ resulting implementation behavior in\n   this case -- [RFC3720] already defines\
    \ the error handling in this\n   error scenario.\n"
- title: 10.4.4.  Login Response
  contents:
  - "10.4.4.  Login Response\n   The Control_Notify Operational Primitive is used\
    \ to notify the\n   initiator iSCSI layer of the arrival of a Login Response PDU.\
    \  Note\n   that specific Datamover protocols may choose to disallow the standard\n\
    \   DA Primitives from being used for the iSCSI Login Phase.  When used\n   in\
    \ conjunction with such Datamover protocols, the arrival of a Login\n   Response\
    \ necessitating the Control_Notify Operational Primitive\n   invocation is clearly\
    \ an error scenario, as the Login Response PDU is\n   arriving in the iSCSI Full\
    \ Feature Phase.  It is outside the scope of\n   this document to specify the\
    \ resulting implementation behavior in\n   this case -- [RFC3720] already defines\
    \ the error handling in this\n   error scenario.\n"
- title: 11.  Security Considerations
  contents:
  - '11.  Security Considerations

    '
- title: 11.1.  Architectural Considerations
  contents:
  - "11.1.  Architectural Considerations\n   DA enables compliant iSCSI implementations\
    \ to realize a control and\n   data separation in the way they interact with their\
    \ Datamover\n   protocols.  Note however that this separation does not imply a\n\
    \   separation in transport mediums between control traffic and data\n   traffic\
    \ -- the basic iSCSI architecture with respect to tasks and PDU\n   relationships\
    \ to tasks remains unchanged.  [RFC3720] defines several\n   MUST requirements\
    \ on ordering relationships across control and data\n   for a given task besides\
    \ a mandatory deterministic task allegiance\n   model -- DA does not change this\
    \ basic architecture (DA has a\n   normative reference to [RFC3720]) for allow\
    \ any additional\n   flexibility in compliance in this area.  To summarize, sending\
    \ bulk\n   data transfers (prompted by Put_Data and Get_Data Primitive\n   invocations)\
    \ on a different transport medium would be as ill-advised\n   as sending just\
    \ the Data-Out/Data-In PDUs on a different TCP\n   connection in RFC 3720-based\
    \ iSCSI implementations.  Consequently,\n   all the iSCSI-related security text\
    \ in [RFC3723] is directly\n   applicable to a DA-enabled iSCSI implementation.\n\
    \   Another area with security implications is the Datamover connection\n   resource\
    \ management model, which DA defines -- particularly the\n   Allocate_Connection_Resources\
    \ Primitive.  An inadvertent realization\n   of this model could leave an iSCSI\
    \ implementation exposed to denial-\n   of-service attacks.  As Figures 2 and\
    \ 3 in Section 13.2 illustrate,\n   the most effective countermeasure to this\
    \ potential attack consists\n   of performing the Datamover resource allocation\
    \ when the iSCSI layer\n   is sufficiently far along in the iSCSI Login Phase\
    \ that it is\n   reasonably certain that the peer side is not an attacker.  In\n\
    \   particular, if the Login Phase includes a SecurityNegotiation stage,\n   an\
    \ iSCSI end node MUST defer the Datamover connection resource\n   allocation (i.e.,\
    \ invoking the Allocate_Connection_Resources\n   Primitive) to the LoginOperationalNegotiation\
    \ stage [RFC3720] so that\n   the resource allocation happens post-authentication.\
    \  This\n   considerably minimizes the potential for a denial-of service attack.\n"
- title: 11.2.  Wire Protocol Considerations
  contents:
  - "11.2.  Wire Protocol Considerations\n   In view of the fact that the DA architecture\
    \ itself does not define\n   any new wire protocol or propose modifications to\
    \ the existing\n   protocols, there are no additional wire protocol security\n\
    \   considerations in employing DA itself.  However, a DA-compliant iSCSI\n  \
    \ implementation MUST comply with all the iSCSI-related requirements\n   stipulated\
    \ in [RFC3723] and [RFC3720].  Note further that in\n   realizing DA, each Datamover\
    \ protocol must define and elaborate as\n   appropriate on any additional security\
    \ considerations resulting from\n   the use of that Datamover protocol.\n   All\
    \ Datamover protocol designers are strongly recommended to refer to\n   [RDDPSEC]\
    \ for the types of security issues to consider.  While\n   [RDDPSEC] elaborates\
    \ on the security considerations applicable to an\n   RDDP-based Datamover [iSER],\
    \ the document is representative of the\n   type of analysis of resource exhaustion\
    \ and the application of\n   countermeasures that need to be done for any Datamover\
    \ protocol.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [RFC3720] Satran, J., Meth, K., Sapuntzakis,\
    \ C., Chadalapaka, M., and\n             E. Zeidner, \"Internet Small Computer\
    \ Systems Interface\n             (iSCSI)\", RFC 3720, April 2004.\n   [RFC3723]\
    \ Aboba, B., Tseng, J., Walker, J., Rangan, V., and F.\n             Travostino,\
    \ \"Securing Block Storage Protocols over IP\", RFC\n             3723, April\
    \ 2004.\n   [RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate\n \
    \            Requirement Levels\", BCP 14, RFC 2119, March 1997.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [DDP]     Shah, H., Pinkerton, J., Recio, R.,\
    \ and P. Culley, \"Direct\n             Data Placement over Reliable Transports\"\
    , RFC 5041, October\n             2007.\n   [iSER]    Ko, M., Chadalapaka, M.,\
    \ Hufferd, J., Elzur, U., Shah, H.,\n             and P. Thaler, \"Internet Small\
    \ Computer System Interface\n             (iSCSI) Extensions for Remote Direct\
    \ Memory Access (RDMA)\",\n             RFC 5046, October 2007.\n   [RDDPSEC]\
    \ Pinkerton, J. and E. Deleganes, \"Direct Data Placement\n             Protocol\
    \ (DDP) / Remote Direct Memory Access Protocol\n             (RDMAP) Security\"\
    , RFC 5042, October 2007.\n"
- title: Appendix A.  Design Considerations and Examples
  contents:
  - 'Appendix A.  Design Considerations and Examples

    '
- title: A.1.  Design Considerations for a Datamover Protocol
  contents:
  - "A.1.  Design Considerations for a Datamover Protocol\n   This section discusses\
    \ the specific considerations for RDMA-based and\n   RDDP-based Datamover protocols.\n\
    \      a) Note that the modeling of interactions for SCSI Data-Out\n         (Section\
    \ 10.3.5.1) is only used for unsolicited data transfer.\n      b) The modeling\
    \ of interactions for SNACK (Sections 10.3.14 and\n         10.4.1) is not expected\
    \ to be used given that one of the design\n         requirements on the Datamover\
    \ is that it \"guarantees an error-\n         free, reliable, in-order transport\
    \ mechanism\" (Section 6).  The\n         interactions for sending and receiving\
    \ a SNACK are nevertheless\n         modeled in this document because the receiving\
    \ iSCSI layer can\n         deterministically deal with an inadvertent SNACK.\
    \  This also\n         shows the DA designers' intent that DI is not meant to\
    \ filter\n         certain types of PDUs.\n      c) The onus is on a reliable\
    \ Datamover (per requirements stated in\n         Section 6) to realize end-to-end\
    \ data acknowledgements via\n         Datamover-specific means.  In view of this,\
    \ even use of data-\n         ACK-type SNACKs are unnecessary.  Consequently,\
    \ an initiator\n         may never request sending a SNACK Request in this model\n\
    \         assuming that the proactive (timeout-driven) SNACK\n         functionality\
    \ is turned off in the legacy iSCSI code.\n      d) Note that the current DA model\
    \ for bootstrapping a\n         Connection_Handle into service -- i.e., associating\
    \ a new iSCSI\n         connection with a Connection_Handle -- clearly implies\
    \ that the\n         iSCSI connection must already be in Full Feature Phase when\
    \ the\n         Datamover layer comes into the stack.  This further implies\n\
    \         that the iSCSI Login Phase must be carried out in the\n         traditional\
    \ \"Byte streaming mode\" with no assistance or\n         involvement from the\
    \ Datamover layer.\n"
- title: A.2.  Examples of Datamover Interactions
  contents:
  - "A.2.  Examples of Datamover Interactions\n   The figures described in this section\
    \ provide some examples of the\n   usage of Operational Primitives in interactions\
    \ between the iSCSI\n   layer and the Datamover layer.  The following abbreviations\
    \ are used\n   in this section.\n   Avail - Available\n   Abted - Aborted\n  \
    \ Buf - I/O Buffer\n   Cmd - Command\n   Compl - Complete\n   Conn - Connection\n\
    \   Ctrl_Ntfy - Control_Notify\n   Dal_Tk_Res - Deallocate_Task_Resources\n  \
    \ Data_Cmp_Nfy - Data_Completion_Notify\n   Data_ACK_Nfy - Data_ACK_Notify\n \
    \  DM - Datamover\n   Imm - Immediate\n   Snd_Ctrl - Send_Control\n   Msg - Message\n\
    \   Resp - Response\n   Sol - Solicited\n   TMF Req - Task Management Function\
    \ Request\n   TMF Res - Task Management Function Response\n   Trans - Transfer\n\
    \   Unsol - Unsolicited\n         |   | Allocate_Connection_Resources  | D | \
    \   ^\n         |   |------------------------------->| a |    |\n         |  \
    \ |    Connection resources are    | t |    |\n         | i |     successfully\
    \ allocated     | a |    |   iSCSI\n         | S |                           \
    \     | m |    |   Login\n         | C |                                | o |\
    \    |   Phase\n         | S |                                | v |    |\n   \
    \      | I |                                | e |    |\n         |   |       \
    \                         | r |    | Login Phase\n         | L | Final Login Response\
    \ (success)          v succeeds\n         | a |<----------------------------------------^\n\
    \         | y |                                | L |    |   iSCSI\n         |\
    \ e |       Enable_Datamover         | a |    |   Full\n         | r |------------------------------->|\
    \ y |    |   Feature\n         |   |     Datamover is enabled       | e |    |\
    \   Phase\n         |   |                                | r |    |\n        \
    \ |   |   Full Feature Phase           |   |    |\n         |   |   control and\
    \ data Transfer    |   |    v\n           Figure 2.  A Successful iSCSI Login\
    \ on Initiator\n         |   | Notice_Key_Values              |   |      |\n \
    \        |   |------------------------------->|   |      |\n         |   |  Datamover\
    \ layer is notified   |   |      |\n         |   |  of the negotiated key values\
    \  |   |      |\n         |   |                                |   |      |\n\
    \         |   | Allocate_Connection_Resources  |   |      |\n         |   |------------------------------->|\
    \ D |      |\n         |   |    Connection resources are    | a |      |\n   \
    \      | i |     successfully allocated     | t |      |   iSCSI\n         | S\
    \ |                                | a |      |   Login\n         | C |      \
    \                          | m |Final |   Phase\n         | S |              \
    \                  | o |Login |\n         | I |Enable_Datamover(Login Response)|\
    \ v |Resp  |\n         |   |------------------------------->| e |---->vLogin Phase\n\
    \         | L |     Datamover is enabled       | r |      ^ succeeds\n       \
    \  | a |                                |   |      |\n         | y |         \
    \                       | L |      |   iSCSI\n         | e |                 \
    \               | a |      |   Full\n         | r |                          \
    \      | y |      |   Feature\n         |   |                                |\
    \ e |      |   Phase\n         |   |      Full Feature Phase        | r |    \
    \  |\n         |   |   control and data Transfer    |   |      |\n         | \
    \  |                                |   |      v\n           Figure 3.  A Successful\
    \ iSCSI Login on Target\n         |   | Allocate_Connection_Resources  | D | \
    \     ^\n         |   |------------------------------->| a |      |\n        \
    \ |   |    Connection resources are    | t |      |\n         | i |     successfully\
    \ allocated     | a |      |   iSCSI\n         | S |                         \
    \       | m |      |   Login\n         | C |                                |\
    \ o |      |   Phase\n         | S |                                | v |    \
    \  |\n         | I |                                | e |      |\n         | \
    \  |                                | r |      | Login\n         |   |       \
    \                         |   |      | Phase\n         | L | Final Login Response\
    \ (failure)            v fails\n         | a |<------------------------------------------\n\
    \         | y |                                | L |\n         | e | Deallocate_Connection_Resources|\
    \ a |\n         | r |------------------------------->| y |\n         |   |   \
    \  Datamover-specific         | e |\n         |   |     connection resources freed\
    \ | r |\n         |   |                                |   |\n         |   |\n\
    \         |   | Connection terminated by standard means\n         |   |--------------------------------------------->\n\
    \            Figure 4.  A Failed iSCSI Login on Initiator\n         |   | Allocate_Connection_Resources\
    \  | D |      ^\n         |   |------------------------------->| a |      |\n\
    \         |   |    Connection resources are    | t |      |\n         | i |  \
    \   successfully allocated     | a |      |   iSCSI\n         | S |          \
    \                      | m |      |   Login\n         | C |                  \
    \              | o |      |   Phase\n         | S |                          \
    \      | v |      |\n         | I |                                | e |     \
    \ |\n         |   |                                | r |      | Login\n      \
    \   |   |                                |   |      | Phase\n         | L | Final\
    \ Login Response (failure)            v fails\n         | a |---------------------------------------------->\n\
    \         | y |                                | L |\n         | e | Deallocate_Connection_Resources|\
    \ a |\n         | r |------------------------------->| y |\n         |   |   \
    \  Datamover-specific         | e |\n         |   |     connection resources freed\
    \ | r |\n         |   |                                |   |\n         |   |\n\
    \         |   | Connection terminated by standard means\n         |   |-------------------------------------------->\n\
    \             Figure 5.  A Failed iSCSI Login on Target\n         |   | Allocate_Connection_Resources\
    \  | D |     ^\n         |   |------------------------------->| a |     |\n  \
    \       |   |    Connection resources are    | t |     |\n         | i |     successfully\
    \ allocated     | a |     |   iSCSI\n         | S |                          \
    \      | m |     |   Login\n         | C |                                | o\
    \ |     |   Phase\n         | S |                                | v |     |\n\
    \         | I |                                | e |     |\n         |   |   \
    \                             | r |     |\n         | L | Login non-Final Request/Response\
    \         |\n         | a |<-----------------------------------------|\n     \
    \    | y |    iSCSI layer decides not to  | L |     |\n         | e |    enable\
    \ Datamover for this   | a |     |\n         | r |    connection             \
    \     | y |     |\n         |   |                                | e |     |\n\
    \         |   | Deallocate_Connection_Resources| r |     |\n         |   |------------------------------->|\
    \   |     |\n         |   |     All Datamover-specific     |   |     |\n     \
    \    |   |     resources deallocated      |   |     |\n         |   |        \
    \                        |   |     | Login\n         |   |                   \
    \             |   |     | Phase\n         |   |                              \
    \            | continues\n         |   | Regular Login negotiation continues \
    \     |\n         |   |<---------------------------------------->|\n         |\
    \   |                                          .\n         |   |             \
    \                             .\n         |   |                              \
    \            .\n          Figure 6.  iSCSI Does Not Enable the Datamover\n   \
    \      |   |                                |   |   ^\n         |   |  Full Feature\
    \ Phase Control &  |   |   |\n         |   |    Data Transfer Using DM      |\
    \ D |   | iSCSI\n         |   |                                | a |   | Full\
    \ Feature\n         | i |                                | t |   | Phase\n   \
    \      | S |                                | a |   | (DM Enabled)\n         |\
    \ C |                                | m |   |\n         | S |    Successful iSCSI\
    \ Logout     | o |   |\n         | I |                                | v |  \
    \ v\n         |   |     Connection_Terminate       | e |\n         | L |------------------------------->|\
    \ r |\n         | a |   Connection is terminated     |   |\n         | y |   Datamover-specific\
    \ resources | L | Transport\n         | e |   deallocated, both connection | a\
    \ | Connection\n         | r |   level & task level           | y | is terminated\n\
    \         |   |                                | e |\n         |   |         \
    \                       | r |\n         |   |                                |\
    \   |\n         |   |                                |   |\n           Figure\
    \ 7.  A Normal iSCSI Connection Termination\n         |   |                  \
    \              |   |   ^\n         |   |  Full Feature Phase Control &  | D |\
    \   | iSCSI\n         |   |    Data Transfer Using DM      | a |   | Full Feature\n\
    \         | i |                                | t |   | Phase\n         | S |\
    \                                | a |   | (DM Enabled)\n         | C |      \
    \                          | m |   v\n         | S |                         \
    \       | o |<--Transport\n         | I |   Datamover-specific resources | v |\
    \ Connection\n         |   |   deallocated, both connection | e | Terminated (e.g.\n\
    \         | L |   level & task level           | r | unexpected\n         | a\
    \ |                                |   | FIN/RESET)\n         | y |          \
    \                      | L |\n         | e |   Connection_Terminate_Notify  |\
    \ a |\n         | r |<-------------------------------| y |\n         |   |   \
    \                             | e |\n         |   |                          \
    \      | r |\n         |   |                                |   |\n          \
    \ Figure 8.  An Abnormal iSCSI Connection Termination\n        <-----Initiator----->\
    \                <-------Target------->\n        |  |          |  | DM Msg holding\
    \ |  |            |  |\n   SCSI |  |          |  | SCSI Cmd PDU & |  |       \
    \     |  |SCSI\n   Cmd  |  | Snd_Ctrl |  |Unsol Imm Data  |  |Ctrl_Notify |  |Cmd\n\
    \   ---->|  |--------->|  |--------------->|  |----------->|  |--->\n        |\
    \  |          |  |                |  |            |  |\n        |  |         \
    \ |  | DM Msg holding |  |            |  |\n        |  | Snd_Ctrl |  |SCSI Dataout\
    \ PDU|  |Ctrl_Notify |  |\n        |  |--------->|  |--------------->|  |----------->|\
    \  |\n        |  |    .     |  |        .       |  |     .      |  |Unsol\n  \
    \      |  |    .     | D|        .       | D|     .      |  |Data\n        | \
    \ |    .     | a| DM Msg holding | a|     .      |  |Trans\n        | i| Snd_Ctrl\
    \ | t|SCSI Dataout PDU| t|Ctrl_Notify | i|\n        | S|--------->| a|--------------->|\
    \ a|----------->| S|\n        | C|          | m|                | m|         \
    \   | C|Buf\n        | S|          | o|                | o|            | S|Avail\n\
    \        | I|          | v|                | v|  Get_Data  | I|(R2T)\n       \
    \ |  |          | e|----------------| e|<-----------|  |<----\n        | L|  \
    \        | r||Solicited Data | r|            | L|  .\n        | a|          |\
    \  ||  Transfer     |  |            | a|  .\n        | y|          | L|--------------->|\
    \ L|      .     | y|Buf\n        | e|          | a|        .       | a|      .\
    \     | e|Avail\n        | r|          | y|        .       | y|  Get_Data  | r|(R2T)\n\
    \        |  |          | e|----------------| e|<-----------|  |<----\n       \
    \ |  |          | r||Solicited Data | r|            |  |\n        |  |       \
    \   |  ||   Transfer    |  |            |  |\n        |  |          |  |--------------->|\
    \  |Data_Cmp_Nfy|  |Data\n        |  |          |  |                |  |----------->|\
    \  |Trans\n        |  |          |  |                |  |            |  |Compl\n\
    \        |  |          |  | DM Msg holding |  |            |  |\n   SCSI |  |\
    \          |  |SCSI Resp PDU & |  |            |  |SCSI\n   Resp |  |Ctrl_Ntfy\
    \ |  |  Sense Data    |  |  Snd_Ctrl  |  |Resp\n   <----|  |<---------|  |<---------------|\
    \  |<-----------|  |<----\n        |  |          |  |                |  |    \
    \        |  |\n                 Figure 9.  A SCSI Write Data Transfer\n      \
    \  <-----Initiator----->                <-------Target------->\n        |  | \
    \         |  |                |  |            |  |\n   SCSI |  |          |  |\
    \ DM Msg holding |  |            |  |SCSI\n   Cmd  |  | Snd_Ctrl |  |  SCSI Cmd\
    \ PDU  |  |Ctrl_Notify |  |Cmd\n   ---->|  |--------->|  |--------------->|  |----------->|\
    \  |--->\n        |  |          |  |                |  |            |  |\n   \
    \     |  |          | D|    SCSI Read   | D|            |  |Buf\n        |  |\
    \          | a|  Data Transfer | a|  Put_Data  |  |Avail\n        | i|       \
    \   | t|<---------------| t|<-----------| i|<----\n        | S|          | a|\
    \        .       | a|     .      | S|  .\n        | C|          | m|        .\
    \       | m|     .      | C|  .\n        | S|          | o|        .       | o|\
    \     .      | S|  .\n        | I|          | v|    SCSI Read   | v|     .   \
    \   | I|Buf\n        |  |          | e|  Data Transfer | e|  Put_Data  |  |Avail\n\
    \        | L|          | r|<---------------| r|<-----------| L|<----\n       \
    \ | a|          |  |                |  |            | a|\n        | y|       \
    \   | L|                | L|            | y|\n        | e|          | a|     \
    \           | a|Data_Cmp_Nfy| e|Data\n        | r|          | y|             \
    \   | y|----------->| r|Trans\n        |  |          | e|                | e|\
    \            |  |Compl\n        |  |          | r| DM Msg holding | r|       \
    \     |  |\n   SCSI |  |          |  |SCSI Resp PDU & |  |            |  |SCSI\n\
    \   Resp |  |Ctrl_Ntfy |  |  Sense Data    |  |  Snd_Ctrl  |  |Resp\n   <----|\
    \  |<---------|  |<---------------|  |<-----------|  |<----\n        |  |    \
    \      |  |                |  |            |  |\n                 Figure 10. \
    \ A SCSI Read Data Transfer\n        <-----Initiator----->                <-------Target------->\n\
    \        |  |          |  |                |  |            |  |\n   SCSI |  |\
    \          |  | DM Msg holding |  |            |  |SCSI\n   Cmd  |  | Snd_Ctrl\
    \ |  |  SCSI Cmd PDU  |  |Ctrl_Notify |  |Cmd\n   ---->|  |--------->|  |--------------->|\
    \  |----------->|  |---->\n        |  |          |  |                |  |    \
    \        |  |\n        |  |          | D|    SCSI Read   | D|  Put_Data  |  |Buf\n\
    \        |  |          | a|  Data Transfer | a|Data_in.A=1 |  |Avail\n       \
    \ | i|          | t|<---------------| t|<-----------| i|<----\n        | S|  \
    \        | a|        .       | a|     .      | S|  .\n        | C|          |\
    \ m|        .       | m|Data_ACK_Nfy| C|  .\n        | S|          | o|      \
    \          | o|----------->| S|  .\n        | I|          | v|               \
    \ | v|     .      | I|\n        |  |          | e|                | e|     . \
    \     |  |\n        | L|          | r|                | r|            | L|\n \
    \       | a|          |  |                |  |            | a|\n        | y| \
    \         | L|                | L|            | y|\n        | e|          | a|\
    \                | a|            | e|Data\n        | r|          | y|        \
    \        | y|            | r|Trans\n        |  |          | e|               \
    \ | e|            |  |Compl\n        |  |          | r| DM Msg holding | r|  \
    \          |  |\n   SCSI |  |          |  |SCSI Resp PDU & |  |            | \
    \ |SCSI\n   Resp |  |Ctrl_Ntfy |  |  Sense Data    |  |  Snd_Ctrl  |  |Resp\n\
    \   <----|  |<---------|  |<---------------|  |<-----------|  |<----\n       \
    \ |  |          |  |                |  |            |  |\n           Figure 11.\
    \  A SCSI Read Data Acknowledgement\n        <-----Initiator----->           \
    \     <-------Target------->\n        |  |          |  |                |  | \
    \           |  |\n   SCSI |  |          |  | DM Msg holding |  |            |\
    \  |SCSI\n   Cmd  |  | Snd_Ctrl |  |  SCSI Cmd PDU  |  |Ctrl_Notify |  |Cmd\n\
    \   ---->|  |--------->|  |--------------->|  |----------->|  |---->\n       \
    \ |  |          |  |                |  |            |  |\n        |  |       \
    \   | D|    SCSI Read   | D|            |  |Buf\n        |  |          | a|  Data\
    \ Transfer | a|  Put_Data  |  |Avail\n        | i|          | t|<---------------|\
    \ t|<-----------| i|<----\n        | S|          | a|        .       | a|    \
    \ .      | S|  .\n   Abort| C|          | m| DM Msg holding | m|     .      |\
    \ C|Abort\n   Task | S| Snd_Ctrl | o|  Abort TMF Req | o|Ctrl_Notify | S|Task\n\
    \   ---->| I|--------->| v|--------------->| v|----------->| I|---->\n       \
    \ |  |          | e|       .        | e|     .      |  |\n   Abort| L|       \
    \   | r|  DM Msg holding| r|            | L| .\n   Done | a|Ctrl_Ntfy |  |   Abort\
    \ TMF Res|  | Snd_Ctrl   |  |Abted\n   <----| y|<---------| L|<---------------|\
    \ L|<-----------| y|<----\n        | e|          | a|                | a|    \
    \        | e|\n        | r|          | y|                | y|            | r|\n\
    \        |  |          | e|                | e|            |  |\n        |  |\
    \          | r|                | r|            |  |\n        |  |          | \
    \ |                |  |            |  |\n        |  |Dal_Tk_Res|  |          \
    \      |  |Dal_Tk_Res  |  |\n        |  |--------->|  |                |  |<-----------|\
    \  |\n        |  |          |  |                |  |            |  |\n       \
    \     Figure 12.  Task Resource Cleanup on Abort\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The IP Storage (IPS) Working Group in the Transport Area\
    \ of\n   IETF has been responsible for defining the iSCSI protocol\n   (apart\
    \ from a host of other relevant IP Storage protocols).\n   The authors are grateful\
    \ to the entire working group, whose\n   work allowed this document to build on\
    \ the concepts and\n   details of the iSCSI protocol.\n   In addition, the following\
    \ individuals reviewed and\n   contributed to the improvement of this document.\
    \  The authors\n   are grateful for their contribution.\n   John Carrier\n   Adaptec,\
    \ Inc.\n   691 S. Milpitas Blvd., Milpitas, CA 95035, USA\n   Phone: +1 (360)\
    \ 378-8526\n   EMail: john_carrier@adaptec.com\n   Hari Ghadia\n   Adaptec, Inc.\n\
    \   691 S. Milpitas Blvd., Milpitas, CA 95035, USA\n   Phone: +1 (408) 957-5608\n\
    \   EMail: hari_ghadia@adaptec.com\n   Hari Mudaliar\n   Adaptec, Inc.\n   691\
    \ S. Milpitas Blvd., Milpitas, CA 95035, USA\n   Phone: +1 (408) 957-6012\n  \
    \ EMail: hari_mudaliar@adaptec.com\n   Patricia Thaler\n   Agilent Technologies,\
    \ Inc.\n   1101 Creekside Ridge Drive, #100, M/S-RG10,\n   Roseville, CA 95678,\
    \ USA\n   Phone: +1-916-788-5662\n   EMail: pat_thaler@agilent.com\n   Uri Elzur\n\
    \   Broadcom Corporation\n   16215 Alton Parkway, Irvine, CA 92619-7013, USA\n\
    \   Phone: +1 (949) 585-6432\n   EMail: Uri@Broadcom.com\n   Mike Penna\n   Broadcom\
    \ Corporation\n   16215 Alton Parkway,Irvine, CA 92619-7013, USA\n   Phone: +1\
    \ (949) 926-7149\n   EMail: MPenna@Broadcom.com\n   David Black\n   EMC Corporation\n\
    \   176 South St., Hopkinton, MA 01748, USA\n   Phone: +1 (508) 293-7953\n   EMail:\
    \ black_david@emc.com\n   Ted Compton\n   EMC Corporation\n   Research Triangle\
    \ Park, NC 27709, USA\n   Phone: +1-919-248-6075\n   EMail: compton_ted@emc.com\n\
    \   Dwight Barron\n   Hewlett-Packard Company\n   20555 SH 249, Houston, TX 77070-2698,\
    \ USA\n   Phone: +1 (281) 514-2769\n   EMail: Dwight.Barron@Hp.com\n   Paul R.\
    \ Culley\n   Hewlett-Packard Company\n   20555 SH 249, Houston, TX 77070-2698,\
    \ USA\n   Phone: +1 (281) 514-5543\n   EMail: paul.culley@hp.com\n   Dave Garcia\n\
    \   Hewlett-Packard Company\n   19333 Vallco Parkway, Cupertino, CA 95014, USA\n\
    \   Phone: +1 (408) 285-6116\n   EMail: dave.garcia@hp.com\n   Randy Haagens\n\
    \   Hewlett-Packard Company\n   8000 Foothills Blvd, MS 5668, Roseville CA, USA\n\
    \   Phone: +1-916-785-4578\n   EMail: randy_haagens@hp.com\n   Jeff Hilland\n\
    \   Hewlett-Packard Company\n   20555 SH 249, Houston, TX 77070-2698, USA\n  \
    \ Phone: +1 (281) 514-9489\n   EMail: jeff.hilland@hp.com\n   Mike Krause\n  \
    \ Hewlett-Packard Company, 43LN\n   19410 Homestead Road, Cupertino, CA 95014,\
    \ USA\n   Phone: +1 (408) 447-3191\n   EMail: krause@cup.hp.com\n   Jim Wendt\n\
    \   Hewlett-Packard Company\n   8000 Foothills Blvd, MS 5668, Roseville CA, USA\n\
    \   Phone: +1-916-785-5198\n   EMail: jim_wendt@hp.com\n   Mike Ko\n   IBM\n \
    \  650 Harry Rd, San Jose, CA 95120, USA\n   Phone: +1 (408) 927-2085\n   EMail:\
    \ mako@us.ibm.com\n   Renato Recio\n   IBM Corporation\n   11501 Burnett Road,\
    \ Austin, TX 78758, USA\n   Phone: +1 (512) 838-1365\n   EMail: recio@us.ibm.com\n\
    \   Howard C. Herbert\n   Intel Corporation\n   MS CH7-404,5000 West Chandler\
    \ Blvd., Chandler, AZ 85226, USA\n   Phone: +1 (480) 554-3116\n   EMail: howard.c.herbert@intel.com\n\
    \   Dave Minturn\n   Intel Corporation\n   MS JF1-210, 5200 North East Elam Young\
    \ Parkway\n   Hillsboro, OR 97124, USA\n   Phone: +1 (503) 712-4106\n   EMail:\
    \ dave.b.minturn@intel.com\n   James Pinkerton\n   Microsoft Corporation\n   One\
    \ Microsoft Way, Redmond, WA 98052, USA\n   Phone: +1 (425) 705-5442\n   EMail:\
    \ jpink@microsoft.com\n   Tom Talpey\n   Network Appliance\n   375 Totten Pond\
    \ Road, Waltham, MA 02451, USA\n   Phone: +1 (781) 768-5329\n   EMail: thomas.talpey@netapp.com\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Mallikarjun Chadalapaka\n   Hewlett-Packard Company\n\
    \   8000 Foothills Blvd.\n   Roseville, CA 95747-5668, USA\n   Phone: +1-916-785-5621\n\
    \   EMail: cbm@rose.hp.com\n   John L. Hufferd\n   Brocade, Inc.\n   1745 Technology\
    \ Drive\n   San Jose, CA 95110, USA\n   Phone: +1-408-333-5244\n   EMail: jhufferd@brocade.com\n\
    \   Julian Satran\n   IBM, Haifa Research Lab\n   Haifa University Campus - Mount\
    \ Carmel\n   Haifa 31905, Israel\n   Phone +972-4-829-6264\n   EMail: Julian_Satran@il.ibm.com\n\
    \   Hemal Shah\n   Broadcom Corporation\n   5300 California Avenue\n   Irvine,\
    \ California 92617, USA\n   Phone: +1-949-926-6941\n   EMail: hemal@broadcom.com\n\
    \   Comments may be sent to Mallikarjun Chadalapaka.\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
