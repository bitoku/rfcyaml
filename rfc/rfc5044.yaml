- title: __initial_text__
  contents:
  - '            Marker PDU Aligned Framing for TCP Specification

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   Marker PDU Aligned Framing (MPA) is designed to work as an\n   \"\
    adaptation layer\" between TCP and the Direct Data Placement protocol\n   (DDP)\
    \ as described in RFC 5041.  It preserves the reliable, in-order\n   delivery\
    \ of TCP, while adding the preservation of higher-level\n   protocol record boundaries\
    \ that DDP requires.  MPA is fully compliant\n   with applicable TCP RFCs and\
    \ can be utilized with existing TCP\n   implementations.  MPA also supports integrated\
    \ implementations that\n   combine TCP, MPA and DDP to reduce buffering requirements\
    \ in the\n   implementation and improve performance at the system level.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Motivation .................................................4\n  \
    \    1.2. Protocol Overview ..........................................5\n   2.\
    \ Glossary ........................................................8\n   3. MPA's\
    \ Interactions with DDP ....................................11\n   4. MPA Full\
    \ Operation Phase .......................................13\n      4.1. FPDU Format\
    \ ...............................................13\n      4.2. Marker Format\
    \ .............................................14\n      4.3. MPA Markers ...............................................14\n\
    \      4.4. CRC Calculation ...........................................16\n  \
    \    4.5. FPDU Size Considerations ..................................21\n   5.\
    \ MPA's interactions with TCP ....................................22\n      5.1.\
    \ MPA transmitters with a standard layered TCP ..............22\n      5.2. MPA\
    \ receivers with a standard layered TCP .................23\n   6. MPA Receiver\
    \ FPDU Identification ...............................24\n   7. Connection Semantics\
    \ ...........................................24\n      7.1. Connection Setup ..........................................24\n\
    \           7.1.1. MPA Request and Reply Frame Format .................26\n  \
    \         7.1.2. Connection Startup Rules ...........................28\n    \
    \       7.1.3. Example Delayed Startup Sequence ...................30\n      \
    \     7.1.4. Use of Private Data ................................33\n        \
    \          7.1.4.1. Motivation ................................33\n          \
    \        7.1.4.2. Example Immediate Startup Using\n                          \
    \ Private Data ..............................35\n           7.1.5. \"Dual Stack\"\
    \ Implementations .......................37\n      7.2. Normal Connection Teardown\
    \ ................................38\n   8. Error Semantics ................................................39\n\
    \   9. Security Considerations ........................................40\n  \
    \    9.1. Protocol-Specific Security Considerations .................40\n    \
    \       9.1.1. Spoofing ...........................................40\n      \
    \            9.1.1.1. Impersonation .............................41\n        \
    \          9.1.1.2. Stream Hijacking ..........................41\n          \
    \        9.1.1.3. Man-in-the-Middle Attack ..................41\n           9.1.2.\
    \ Eavesdropping ......................................42\n      9.2. Introduction\
    \ to Security Options ..........................42\n      9.3. Using IPsec with\
    \ MPA ......................................43\n      9.4. Requirements for IPsec\
    \ Encapsulation of MPA/DDP ...........43\n   10. IANA Considerations ...........................................44\n\
    \   Appendix A. Optimized MPA-Aware TCP Implementations ...............45\n  \
    \    A.1. Optimized MPA/TCP Transmitters ............................46\n    \
    \  A.2. Effects of Optimized MPA/TCP Segmentation .................46\n      A.3.\
    \ Optimized MPA/TCP Receivers ...............................48\n      A.4. Re-segmenting\
    \ Middleboxes and Non-Optimized MPA/TCP\n           Senders ...................................................49\n\
    \      A.5. Receiver Implementation ...................................50\n  \
    \         A.5.1. Network Layer Reassembly Buffers ...................51\n    \
    \       A.5.2. TCP Reassembly Buffers .............................52\n   Appendix\
    \ B. Analysis of MPA over TCP Operations ...................52\n      B.1. Assumptions\
    \ ...............................................53\n           B.1.1. MPA Is\
    \ Layered beneath DDP .........................53\n           B.1.2. MPA Preserves\
    \ DDP Message Framing ..................53\n           B.1.3. The Size of the\
    \ ULPDU Passed to MPA Is Less Than\n                  EMSS Under Normal Conditions\
    \ .......................53\n           B.1.4. Out-of-Order Placement but NO Out-of-Order\
    \ Delivery.54\n     B.2.  The Value of FPDU Alignment ...............................54\n\
    \           B.2.1. Impact of Lack of FPDU Alignment on the Receiver\n        \
    \          Computational Load and Complexity ..................56\n          \
    \ B.2.2. FPDU Alignment Effects on TCP Wire Protocol ........60\n   Appendix C.\
    \ IETF Implementation Interoperability with RDMA\n               Consortium Protocols\
    \ ..................................62\n     C.1. Negotiated Parameters ......................................63\n\
    \     C.2. RDMAC RNIC and Non-Permissive IETF RNIC ....................64\n  \
    \        C.2.1. RDMAC RNIC Initiator ................................65\n    \
    \      C.2.2. Non-Permissive IETF RNIC Initiator ..................65\n      \
    \    C.2.3. RDMAC RNIC and Permissive IETF RNIC .................65\n        \
    \  C.2.4. RDMAC RNIC Initiator ................................66\n          C.2.5.\
    \ Permissive IETF RNIC Initiator ......................67\n     C.3. Non-Permissive\
    \ IETF RNIC and Permissive IETF RNIC ..........67\n   Normative References ..............................................68\n\
    \   Informative References ............................................68\n  \
    \ Contributors ......................................................70\n"
- title: Table of Figures
  contents:
  - "Table of Figures\n   Figure 1: ULP MPA TCP Layering .....................................5\n\
    \   Figure 2: FPDU Format .............................................13\n  \
    \ Figure 3: Marker Format ...........................................14\n   Figure\
    \ 4: Example FPDU Format with Marker .........................16\n   Figure 5:\
    \ Annotated Hex Dump of an FPDU ...........................19\n   Figure 6: Annotated\
    \ Hex Dump of an FPDU with Marker ...............20\n   Figure 7: Fully Layered\
    \ Implementation ............................22\n   Figure 8: MPA Request/Reply\
    \ Frame .................................26\n   Figure 9: Example Delayed Startup\
    \ Negotiation .....................31\n   Figure 10: Example Immediate Startup\
    \ Negotiation ..................35\n   Figure 11: Optimized MPA/TCP Implementation\
    \ .......................45\n   Figure 12: Non-Aligned FPDU Freely Placed in TCP\
    \ Octet Stream .....56\n   Figure 13: Aligned FPDU Placed Immediately after TCP\
    \ Header .......58\n   Figure 14: Connection Parameters for the RNIC Types ...............63\n\
    \   Figure 15: MPA Negotiation between an RDMAC RNIC and a\n              Non-Permissive\
    \ IETF RNIC ...............................65\n   Figure 16: MPA Negotiation between\
    \ an RDMAC RNIC and a Permissive\n              IETF RNIC ..............................................66\n\
    \   Figure 17: MPA Negotiation between a Non-Permissive IETF RNIC and\n      \
    \        a Permissive IETF RNIC .................................67\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This section discusses the reason for creating MPA on TCP\
    \ and a\n   general overview of the protocol.\n"
- title: 1.1.  Motivation
  contents:
  - "1.1.  Motivation\n   The Direct Data Placement protocol [DDP], when used with\
    \ TCP\n   [RFC793], requires a mechanism to detect record boundaries.  The DDP\n\
    \   records are referred to as Upper Layer Protocol Data Units by this\n   document.\
    \  The ability to locate the Upper Layer Protocol Data Unit\n   (ULPDU) boundary\
    \ is useful to a hardware network adapter that uses\n   DDP to directly place\
    \ the data in the application buffer based on the\n   control information carried\
    \ in the ULPDU header.  This may be done\n   without requiring that the packets\
    \ arrive in order.  Potential\n   benefits of this capability are the avoidance\
    \ of the memory copy\n   overhead and a smaller memory requirement for handling\
    \ out-of-order\n   or dropped packets.\n   Many approaches have been proposed\
    \ for a generalized framing\n   mechanism.  Some are probabilistic in nature and\
    \ others are\n   deterministic.  An example probabilistic approach is characterized\
    \ by\n   a detectable value embedded in the octet stream, with no method of\n\
    \   preventing that value elsewhere within user data.  It is\n   probabilistic\
    \ because under some conditions the receiver may\n   incorrectly interpret application\
    \ data as the detectable value.\n   Under these conditions, the protocol may fail\
    \ with unacceptable\n   frequency.  One deterministic approach is characterized\
    \ by embedded\n   controls at known locations in the octet stream.  Because the\n\
    \   receiver can guarantee it will only examine the data stream at\n   locations\
    \ that are known to contain the embedded control, the\n   protocol can never misinterpret\
    \ application data as being embedded\n   control data.  For unambiguous handling\
    \ of an out-of-order packet, a\n   deterministic approach is preferred.\n   The\
    \ MPA protocol provides a framing mechanism for DDP running over\n   TCP using\
    \ the deterministic approach.  It allows the location of the\n   ULPDU to be determined\
    \ in the TCP stream even if the TCP segments\n   arrive out of order.\n"
- title: 1.2.  Protocol Overview
  contents:
  - "1.2.  Protocol Overview\n   The layering of PDUs with MPA is shown in Figure\
    \ 1, below.\n               +------------------+\n               |     ULP client\
    \   |\n               +------------------+  <- Consumer messages\n           \
    \    |        DDP       |\n               +------------------+  <- ULPDUs\n  \
    \             |        MPA*      |\n               +------------------+  <- FPDUs\
    \ (containing ULPDUs)\n               |        TCP*      |\n               +------------------+\
    \  <- TCP Segments (containing FPDUs)\n               |      IP etc.     |\n \
    \              +------------------+\n                * These may be fully layered\
    \ or optimized together.\n                       Figure 1: ULP MPA TCP Layering\n\
    \   MPA is described as an extra layer above TCP and below DDP.  The\n   operation\
    \ sequence is:\n   1.  A TCP connection is established by ULP action.  This is\
    \ done\n       using methods not described by this specification.  The ULP may\n\
    \       exchange some amount of data in streaming mode prior to starting\n   \
    \    MPA, but is not required to do so.\n   2.  The Consumer negotiates the use\
    \ of DDP and MPA at both ends of a\n       connection.  The mechanisms to do this\
    \ are not described in this\n       specification.  The negotiation may be done\
    \ in streaming mode, or\n       by some other mechanism (such as a pre-arranged\
    \ port number).\n   3.  The ULP activates MPA on each end in the Startup Phase,\
    \ either as\n       an Initiator or a Responder, as determined by the ULP.  This\
    \ mode\n       verifies the usage of MPA, specifies the use of CRC and Markers,\n\
    \       and allows the ULP to communicate some additional data via a\n       Private\
    \ Data exchange.  See Section 7.1, Connection Setup, for\n       more details\
    \ on the startup process.\n   4.  At the end of the Startup Phase, the ULP puts\
    \ MPA (and DDP) into\n       Full Operation and begins sending DDP data as further\
    \ described\n       below.  In this document, DDP data chunks are called ULPDUs.\
    \  For\n       a description of the DDP data, see [DDP].\n   Following is a description\
    \ of data transfer when MPA is in Full\n   Operation.\n   1.  DDP determines the\
    \ Maximum ULPDU (MULPDU) size by querying MPA\n       for this value.  MPA derives\
    \ this information from TCP or IP,\n       when it is available, or chooses a\
    \ reasonable value.\n   2.  DDP creates ULPDUs of MULPDU size or smaller, and\
    \ hands them to\n       MPA at the sender.\n   3.  MPA creates a Framed Protocol\
    \ Data Unit (FPDU) by prepending a\n       header, optionally inserting Markers,\
    \ and appending a CRC field\n       after the ULPDU and PAD (if any).  MPA delivers\
    \ the FPDU to TCP.\n   4.  The TCP sender puts the FPDUs into the TCP stream.\
    \  If the sender\n       is optimized MPA/TCP, it segments the TCP stream in such\
    \ a way\n       that a TCP Segment boundary is also the boundary of an FPDU. \
    \ TCP\n       then passes each segment to the IP layer for transmission.\n   5.\
    \  The receiver may or may not be optimized.  If it is optimized\n       MPA/TCP,\
    \ it may separate passing the TCP payload to MPA from\n       passing the TCP\
    \ payload ordering information to MPA.  In either\n       case, RFC-compliant\
    \ TCP wire behavior is observed at both the\n       sender and receiver.\n   6.\
    \  The MPA receiver locates and assembles complete FPDUs within the\n       stream,\
    \ verifies their integrity, and removes MPA Markers (when\n       present), ULPDU_Length,\
    \ PAD, and the CRC field.\n   7.  MPA then provides the complete ULPDUs to DDP.\
    \  MPA may also\n       separate passing MPA payload to DDP from passing the MPA\
    \ payload\n       ordering information.\n   A fully layered MPA on TCP is implemented\
    \ as a data stream ULP for\n   TCP and is therefore RFC compliant.\n   An optimized\
    \ DDP/MPA/TCP uses a TCP layer that potentially contains\n   some additional behaviors\
    \ as suggested in this document.  When\n   DDP/MPA/TCP are cross-layer optimized,\
    \ the behavior of TCP\n   (especially sender segmentation) may change from that\
    \ of the un-\n   optimized implementation, but the changes are within the bounds\n\
    \   permitted by the TCP RFC specifications, and will interoperate with\n   an\
    \ un-optimized TCP.  The additional behaviors are described in\n   Appendix A\
    \ and are not normative; they are described at a TCP\n   interface layer as a\
    \ convenience.  Implementations may achieve the\n   described functionality using\
    \ any method, including cross-layer\n   optimizations between TCP, MPA, and DDP.\n\
    \   An optimized DDP/MPA/TCP sender is able to segment the data stream\n   such\
    \ that TCP segments begin with FPDUs (FPDU Alignment).  This has\n   significant\
    \ advantages for receivers.  When segments arrive with\n   aligned FPDUs, the\
    \ receiver usually need not buffer any portion of\n   the segment, allowing DDP\
    \ to place it in its destination memory\n   immediately, thus avoiding copies\
    \ from intermediate buffers (DDP's\n   reason for existence).\n   An optimized\
    \ DDP/MPA/TCP receiver allows a DDP on MPA implementation\n   to locate the start\
    \ of ULPDUs that may be received out of order.  It\n   also allows the implementation\
    \ to determine if the entire ULPDU has\n   been received.  As a result, MPA can\
    \ pass out-of-order ULPDUs to DDP\n   for immediate use.  This enables a DDP on\
    \ MPA implementation to save\n   a significant amount of intermediate storage\
    \ by placing the ULPDUs in\n   the right locations in the application buffers\
    \ when they arrive,\n   rather than waiting until full ordering can be restored.\n\
    \   The ability of a receiver to recover out-of-order ULPDUs is optional\n   and\
    \ declared to the transmitter during startup.  When the receiver\n   declares\
    \ that it does not support out-of-order recovery, the\n   transmitter does not\
    \ add the control information to the data stream\n   needed for out-of-order recovery.\n\
    \   If the receiver is fully layered, then MPA receives a strictly\n   ordered\
    \ stream of data and does not deal with out-of-order ULPDUs.\n   In this case,\
    \ MPA passes each ULPDU to DDP when the last bytes arrive\n   from TCP, along\
    \ with the indication that they are in order.\n   MPA implementations that support\
    \ recovery of out-of-order ULPDUs MUST\n   support a mechanism to indicate the\
    \ ordering of ULPDUs as the sender\n   transmitted them and indicate when missing\
    \ intermediate segments\n   arrive.  These mechanisms allow DDP to reestablish\
    \ record ordering\n   and report Delivery of complete messages (groups of records).\n\
    \   MPA also addresses enhanced data integrity.  Some users of TCP have\n   noted\
    \ that the TCP checksum is not as strong as could be desired (see\n   [CRCTCP]).\
    \  Studies such as [CRCTCP] have shown that the TCP checksum\n   indicates segments\
    \ in error at a much higher rate than the underlying\n   link characteristics\
    \ would indicate.  With these higher error rates,\n   the chance that an error\
    \ will escape detection, when using only the\n   TCP checksum for data integrity,\
    \ becomes a concern.  A stronger\n   integrity check can reduce the chance of\
    \ data errors being missed.\n   MPA includes a CRC check to increase the ULPDU\
    \ data integrity to the\n   level provided by other modern protocols, such as\
    \ SCTP [RFC4960].  It\n   is possible to disable this CRC check; however, CRCs\
    \ MUST be enabled\n   unless it is clear that the end-to-end connection through\
    \ the network\n   has data integrity at least as good as an MPA with CRC enabled\
    \ (for\n   example, when IPsec is implemented end to end).  DDP's ULP expects\n\
    \   this level of data integrity and therefore the ULP does not have to\n   provide\
    \ its own duplicate data integrity and error recovery for lost\n   data.\n"
- title: 2.  Glossary
  contents:
  - "2.  Glossary\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n\
    \   Consumer - the ULPs or applications that lie above MPA and DDP.  The\n   \
    \    Consumer is responsible for making TCP connections, starting MPA\n      \
    \ and DDP connections, and generally controlling operations.\n   CRC - Cyclic\
    \ Redundancy Check.\n   Delivery - (Delivered, Delivers) - For MPA, Delivery is\
    \ defined as\n       the process of informing DDP that a particular PDU is ordered\
    \ for\n       use.  A PDU is Delivered in the exact order that it was sent by\n\
    \       the original sender; MPA uses TCP's byte stream ordering to\n       determine\
    \ when Delivery is possible.  This is specifically\n       different from \"passing\
    \ the PDU to DDP\", which may generally\n       occur in any order, while the\
    \ order of Delivery is strictly\n       defined.\n   EMSS - Effective Maximum\
    \ Segment Size.  EMSS is the smaller of the\n       TCP maximum segment size (MSS)\
    \ as defined in RFC 793 [RFC793],\n       and the current path Maximum Transmission\
    \ Unit (MTU) [RFC1191].\n   FPDU - Framed Protocol Data Unit.  The unit of data\
    \ created by an MPA\n       sender.\n   FPDU Alignment - The property that an\
    \ FPDU is Header Aligned with the\n       TCP segment, and the TCP segment includes\
    \ an integer number of\n       FPDUs.  A TCP segment with an FPDU Alignment allows\
    \ immediate\n       processing of the contained FPDUs without waiting on other\
    \ TCP\n       segments to arrive or combining with prior segments.\n   FPDU Pointer\
    \ (FPDUPTR) - This field of the Marker is used to indicate\n       the beginning\
    \ of an FPDU.\n   Full Operation (Full Operation Phase) - After the completion\
    \ of the\n       Startup Phase, MPA begins exchanging FPDUs.\n   Header Alignment\
    \ - The property that a TCP segment begins with an\n       FPDU.  The FPDU is\
    \ Header Aligned when the FPDU header is exactly\n       at the start of the TCP\
    \ segment (right behind the TCP headers on\n       the wire).\n   Initiator -\
    \ The endpoint of a connection that sends the MPA Request\n       Frame, i.e.,\
    \ the first to actually send data (which may not be\n       the one that sends\
    \ the TCP SYN).\n   Marker - A four-octet field that is placed in the MPA data\
    \ stream at\n       fixed octet intervals (every 512 octets).\n   MPA-aware TCP\
    \ - A TCP implementation that is aware of the receiver\n       efficiencies of\
    \ MPA FPDU Alignment and is capable of sending TCP\n       segments that begin\
    \ with an FPDU.\n   MPA-enabled - MPA is enabled if the MPA protocol is visible\
    \ on the\n       wire.  When the sender is MPA-enabled, it is inserting framing\n\
    \       and Markers.  When the receiver is MPA-enabled, it is\n       interpreting\
    \ framing and Markers.\n   MPA Request Frame - Data sent from the MPA Initiator\
    \ to the MPA\n       Responder during the Startup Phase.\n   MPA Reply Frame -\
    \ Data sent from the MPA Responder to the MPA\n       Initiator during the Startup\
    \ Phase.\n   MPA - Marker-based ULP PDU Aligned Framing for TCP protocol.  This\n\
    \       document defines the MPA protocol.\n   MULPDU - Maximum ULPDU.  The current\
    \ maximum size of the record that\n       is acceptable for DDP to pass to MPA\
    \ for transmission.\n   Node - A computing device attached to one or more links\
    \ of a network.\n       A Node in this context does not refer to a specific application\n\
    \       or protocol instantiation running on the computer.  A Node may\n     \
    \  consist of one or more MPA on TCP devices installed in a host\n       computer.\n\
    \   PAD - A 1-3 octet group of zeros used to fill an FPDU to an exact\n      \
    \ modulo 4 size.\n   PDU - Protocol data unit\n   Private Data - A block of data\
    \ exchanged between MPA endpoints during\n       initial connection setup.\n \
    \  Protection Domain - An RDMA concept (see [VERBS-RDMA] and [RDMASEC])\n    \
    \   that ties use of various endpoint resources (memory access, etc.)\n      \
    \ to the specific RDMA/DDP/MPA connection.\n   RDDP - A suite of protocols including\
    \ MPA, [DDP], [RDMAP], an overall\n       security document [RDMASEC], a problem\
    \ statement [RFC4297], an\n       architecture document [RFC4296], and an applicability\
    \ document\n       [APPL].\n   RDMA - Remote Direct Memory Access; a protocol\
    \ that uses DDP and MPA\n       to enable applications to transfer data directly\
    \ from memory\n       buffers.  See [RDMAP].\n   Remote Peer - The MPA protocol\
    \ implementation on the opposite end of\n       the connection.  Used to refer\
    \ to the remote entity when\n       describing protocol exchanges or other interactions\
    \ between two\n       Nodes.\n   Responder - The connection endpoint that responds\
    \ to an incoming MPA\n       connection request (the MAP Request Frame).  This\
    \ may not be the\n       endpoint that awaited the TCP SYN.\n   Startup Phase\
    \ - The initial exchanges of an MPA connection that\n       serves to more fully\
    \ identify MPA endpoints to each other and\n       pass connection specific setup\
    \ information to each other.\n   ULP - Upper Layer Protocol.  The protocol layer\
    \ above the protocol\n       layer currently being referenced.  The ULP for MPA\
    \ is DDP [DDP].\n   ULPDU - Upper Layer Protocol Data Unit.  The data record defined\
    \ by\n       the layer above MPA (DDP).  ULPDU corresponds to DDP's DDP\n    \
    \   segment.\n   ULPDU_Length - A field in the FPDU describing the length of the\n\
    \       included ULPDU.\n"
- title: 3.  MPA's Interactions with DDP
  contents:
  - "3.  MPA's Interactions with DDP\n   DDP requires MPA to maintain DDP record boundaries\
    \ from the sender to\n   the receiver.  When using MPA on TCP to send data, DDP\
    \ provides\n   records (ULPDUs) to MPA.  MPA will use the reliable transmission\n\
    \   abilities of TCP to transmit the data, and will insert appropriate\n   additional\
    \ information into the TCP stream to allow the MPA receiver\n   to locate the\
    \ record boundary information.\n   As such, MPA accepts complete records (ULPDUs)\
    \ from DDP at the sender\n   and returns them to DDP at the receiver.\n   MPA\
    \ MUST encapsulate the ULPDU such that there is exactly one ULPDU\n   contained\
    \ in one FPDU.\n   MPA over a standard TCP stack can usually provide FPDU Alignment\
    \ with\n   the TCP Header if the FPDU is equal to TCP's EMSS.  An optimized\n\
    \   MPA/TCP stack can also maintain alignment as long as the FPDU is less\n  \
    \ than or equal to TCP's EMSS.  Since FPDU Alignment is generally\n   desired\
    \ by the receiver, DDP cooperates with MPA to ensure FPDUs'\n   lengths do not\
    \ exceed the EMSS under normal conditions.  This is done\n   with the MULPDU mechanism.\n\
    \   MPA MUST provide information to DDP on the current maximum size of\n   the\
    \ record that is acceptable to send (MULPDU).  DDP SHOULD limit\n   each record\
    \ size to MULPDU.  The range of MULPDU values MUST be\n   between 128 octets and\
    \ 64768 octets, inclusive.\n   The sending DDP MUST NOT post a ULPDU larger than\
    \ 64768 octets to\n   MPA.  DDP MAY post a ULPDU of any size between one and 64768\
    \ octets;\n   however, MPA is not REQUIRED to support a ULPDU Length that is\n\
    \   greater than the current MULPDU.\n   While the maximum theoretical length\
    \ supported by the MPA header\n   ULPDU_Length field is 65535, TCP over IP requires\
    \ the IP datagram\n   maximum length to be 65535 octets.  To enable MPA to support\
    \ FPDU\n   Alignment, the maximum size of the FPDU must fit within an IP\n   datagram.\
    \  Thus, the ULPDU limit of 64768 octets was derived by\n   taking the maximum\
    \ IP datagram length, subtracting from it the\n   maximum total length of the\
    \ sum of the IPv4 header, TCP header, IPv4\n   options, TCP options, and the worst-case\
    \ MPA overhead, and then\n   rounding the result down to a 128-octet boundary.\n\
    \   Note that MULPDU will be significantly smaller than the theoretical\n   maximum\
    \ in most implementations for most circumstances, due to link\n   MTUs, use of\
    \ extra headers such as required for IPsec, etc.\n   On receive, MPA MUST pass\
    \ each ULPDU with its length to DDP when it\n   has been validated.\n   If an\
    \ MPA implementation supports passing out-of-order ULPDUs to DDP,\n   the MPA\
    \ implementation SHOULD:\n   *   Pass each ULPDU with its length to DDP as soon\
    \ as it has been\n       fully received and validated.\n   *   Provide a mechanism\
    \ to indicate the ordering of ULPDUs as the\n       sender transmitted them. \
    \ One possible mechanism might be\n       providing the TCP sequence number for\
    \ each ULPDU.\n   *   Provide a mechanism to indicate when a given ULPDU (and\
    \ prior\n       ULPDUs) are complete (Delivered to DDP).  One possible mechanism\n\
    \       might be to allow DDP to see the current outgoing TCP ACK\n       sequence\
    \ number.\n   *   Provide an indication to DDP that the TCP has closed or has\
    \ begun\n       to close the connection (e.g., received a FIN).\n   MPA MUST provide\
    \ the protocol version negotiated with its peer to\n   DDP.  DDP will use this\
    \ version to set the version in its header and\n   to report the version to [RDMAP].\n"
- title: 4.  MPA Full Operation Phase
  contents:
  - "4.  MPA Full Operation Phase\n   The following sections describe the main semantics\
    \ of the Full\n   Operation Phase of MPA.\n"
- title: 4.1.  FPDU Format
  contents:
  - "4.1.  FPDU Format\n   MPA senders create FPDUs out of ULPDUs.  The format of\
    \ an FPDU shown\n   below MUST be used for all MPA FPDUs.  For purposes of clarity,\n\
    \   Markers are not shown in Figure 2.\n       0                   1         \
    \          2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          ULPDU_Length         |                               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n      |\
    \                                                               |\n      ~   \
    \                                                            ~\n      ~      \
    \                      ULPDU                              ~\n      |         \
    \                                                      |\n      |            \
    \                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |               \
    \                |          PAD (0-3 octets)     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                             CRC                               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                     Figure 2: FPDU Format\n   ULPDU_Length: 16 bits (unsigned\
    \ integer).  This is the number of\n   octets of the contained ULPDU.  It does\
    \ not include the length of the\n   FPDU header itself, the pad, the CRC, or of\
    \ any Markers that fall\n   within the ULPDU.  The 16-bit ULPDU Length field is\
    \ large enough to\n   support the largest IP datagrams for IPv4 or IPv6.\n   PAD:\
    \ The PAD field trails the ULPDU and contains between 0 and 3\n   octets of data.\
    \  The pad data MUST be set to zero by the sender and\n   ignored by the receiver\
    \ (except for CRC checking).  The length of the\n   pad is set so as to make the\
    \ size of the FPDU an integral multiple of\n   four.\n   CRC: 32 bits.  When CRCs\
    \ are enabled, this field contains a CRC32c\n   check value, which is used to\
    \ verify the entire contents of the FPDU,\n   using CRC32c.  See Section 4.4,\
    \ CRC Calculation.  When CRCs are not\n   enabled, this field is still present,\
    \ may contain any value, and MUST\n   NOT be checked.\n   The FPDU adds a minimum\
    \ of 6 octets to the length of the ULPDU.  In\n   addition, the total length of\
    \ the FPDU will include the length of any\n   Markers and from 0 to 3 pad octets\
    \ added to round-up the ULPDU size.\n"
- title: 4.2.  Marker Format
  contents:
  - "4.2.  Marker Format\n   The format of a Marker MUST be as specified in Figure\
    \ 3:\n       0                   1                   2                   3\n \
    \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      | \
    \          RESERVED            |            FPDUPTR            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                          Figure 3: Marker Format\n   RESERVED: The Reserved\
    \ field MUST be set to zero on transmit and\n   ignored on receive (except for\
    \ CRC calculation).\n   FPDUPTR: The FPDU Pointer is a relative pointer, 16 bits\
    \ long,\n   interpreted as an unsigned integer that indicates the number of\n\
    \   octets in the TCP stream from the beginning of the ULPDU Length field\n  \
    \ to the first octet of the entire Marker.  The least significant two\n   bits\
    \ MUST always be set to zero at the transmitter, and the receivers\n   MUST always\
    \ treat these as zero for calculations.\n"
- title: 4.3.  MPA Markers
  contents:
  - "4.3.  MPA Markers\n   MPA Markers are used to identify the start of FPDUs when\
    \ packets are\n   received out of order.  This is done by locating the Markers\
    \ at fixed\n   intervals in the data stream (which is correlated to the TCP sequence\n\
    \   number) and using the Marker value to locate the preceding FPDU\n   start.\n\
    \   All MPA Markers are included in the containing FPDU CRC calculation\n   (when\
    \ both CRCs and Markers are in use).\n   The MPA receiver's ability to locate\
    \ out-of-order FPDUs and pass the\n   ULPDUs to DDP is implementation dependent.\
    \  MPA/DDP allows those\n   receivers that are able to deal with out-of-order\
    \ FPDUs in this way\n   to require the insertion of Markers in the data stream.\
    \  When the\n   receiver cannot deal with out-of-order FPDUs in this way, it may\n\
    \   disable the insertion of Markers at the sender.  All MPA senders MUST\n  \
    \ be able to generate Markers when their use is declared by the\n   opposing receiver\
    \ (see Section 7.1, Connection Setup).\n   When Markers are enabled, MPA senders\
    \ MUST insert a Marker into the\n   data stream at a 512-octet periodic interval\
    \ in the TCP Sequence\n   Number Space.  The Marker contains a 16-bit unsigned\
    \ integer referred\n   to as the FPDUPTR (FPDU Pointer).\n   If the FPDUPTR's\
    \ value is non-zero, the FPDU Pointer is a 16-bit\n   relative back-pointer. \
    \ FPDUPTR MUST contain the number of octets in\n   the TCP stream from the beginning\
    \ of the ULPDU Length field to the\n   first octet of the Marker, unless the Marker\
    \ falls between FPDUs.\n   Thus, the location of the first octet of the previous\
    \ FPDU header can\n   be determined by subtracting the value of the given Marker\
    \ from the\n   current octet-stream sequence number (i.e., TCP sequence number)\
    \ of\n   the first octet of the Marker.  Note that this computation MUST take\n\
    \   into account that the TCP sequence number could have wrapped between\n   the\
    \ Marker and the header.\n   An FPDUPTR value of 0x0000 is a special case -- it\
    \ is used when the\n   Marker falls exactly between FPDUs (between the preceding\
    \ FPDU CRC\n   field and the next FPDU's ULPDU Length field).  In this case, the\n\
    \   Marker is considered to be contained in the following FPDU; the\n   Marker\
    \ MUST be included in the CRC calculation of the FPDU following\n   the Marker\
    \ (if CRCs are being generated or checked).  Thus, an\n   FPDUPTR value of 0x0000\
    \ means that immediately following the Marker\n   is an FPDU header (the ULPDU\
    \ Length field).\n   Since all FPDUs are integral multiples of 4 octets, the bottom\
    \ two\n   bits of the FPDUPTR as calculated by the sender are zero.  MPA\n   reserves\
    \ these bits so they MUST be treated as zero for computation\n   at the receiver.\n\
    \   When Markers are enabled (see Section 7.1, Connection Setup), the MPA\n  \
    \ Markers MUST be inserted immediately preceding the first FPDU of Full\n   Operation\
    \ Phase, and at every 512th octet of the TCP octet stream\n   thereafter.  As\
    \ a result, the first Marker has an FPDUPTR value of\n   0x0000.  If the first\
    \ Marker begins at octet sequence number\n   SeqStart, then Markers are inserted\
    \ such that the first octet of the\n   Marker is at octet sequence number SeqNum\
    \ if the remainder of (SeqNum\n   - SeqStart) mod 512 is zero.  Note that SeqNum\
    \ can wrap.\n   For example, if the TCP sequence number were used to calculate\
    \ the\n   insertion point of the Marker, the starting TCP sequence number is\n\
    \   unlikely to be zero, and 512-octet multiples are unlikely to fall on\n   a\
    \ modulo 512 of zero.  If the MPA connection is started at TCP\n   sequence number\
    \ 11, then the 1st Marker will begin at 11, and\n   subsequent Markers will begin\
    \ at 523, 1035, etc.\n   If an FPDU is large enough to contain multiple Markers,\
    \ they MUST all\n   point to the same point in the TCP stream: the first octet\
    \ of the\n   ULPDU Length field for the FPDU.\n   If a Marker interval contains\
    \ multiple FPDUs (the FPDUs are small),\n   the Marker MUST point to the start\
    \ of the ULPDU Length field for the\n   FPDU containing the Marker unless the\
    \ Marker falls between FPDUs, in\n   which case the Marker MUST be zero.\n   The\
    \ following example shows an FPDU containing a Marker.\n   0                 \
    \  1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       ULPDU Length (0x0010)   |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   |                                      \
    \                         |\n   +                                            \
    \                   +\n   |                         ULPDU (octets 0-9)       \
    \             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            (0x0000)           |        FPDU ptr (0x000C)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        ULPDU (octets 10-15)                   |\n   |  \
    \                             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |        \
    \                       |          PAD (2 octets:0,0)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              CRC                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 4: Example FPDU Format with Marker\n   MPA Receivers MUST\
    \ preserve ULPDU boundaries when passing data to\n   DDP.  MPA Receivers MUST\
    \ pass the ULPDU data and the ULPDU Length to\n   DDP and not the Markers, headers,\
    \ and CRC.\n"
- title: 4.4.  CRC Calculation
  contents:
  - "4.4.  CRC Calculation\n   An MPA implementation MUST implement CRC support and\
    \ MUST either:\n   (1)  always use CRCs; the MPA provider is not REQUIRED to support\
    \ an\n        administrator's request that CRCs not be used.\n        or\n   (2a)\
    \ only indicate a preference not to use CRCs on the explicit\n        request\
    \ of the system administrator, via an interface not\n        defined in this spec.\
    \  The default configuration for a\n        connection MUST be to use CRCs.\n\
    \   (2b) disable CRC checking (and possibly generation) if both the local\n  \
    \      and remote endpoints indicate preference not to use CRCs.\n   An administrative\
    \ decision to have a host request CRC suppression\n   SHOULD NOT be made unless\
    \ there is assurance that the TCP connection\n   involved provides protection\
    \ from undetected errors that is at least\n   as strong as an end-to-end CRC32c.\
    \  End-to-end usage of an IPsec\n   cryptographic integrity check is among the\
    \ ways to provide such\n   protection, and the use of channel bindings [NFSv4CHANNEL]\
    \ by the ULP\n   can provide a high level of assurance that the IPsec protection\
    \ scope\n   is end-to-end with respect to the ULP.\n   The process MUST be invisible\
    \ to the ULP.\n   After receipt of an MPA startup declaration indicating that\
    \ its peer\n   requires CRCs, an MPA instance MUST continue generating and checking\n\
    \   CRCs until the connection terminates.  If an MPA instance has\n   declared\
    \ that it does not require CRCs, it MUST turn off CRC checking\n   immediately\
    \ after receipt of an MPA mode declaration indicating that\n   its peer also does\
    \ not require CRCs.  It MAY continue generating\n   CRCs.  See Section 7.1, Connection\
    \ Setup, for details on the MPA\n   startup.\n   When sending an FPDU, the sender\
    \ MUST include a CRC field.  When CRCs\n   are enabled, the CRC field in the MPA\
    \ FPDU MUST be computed using the\n   CRC32c polynomial in the manner described\
    \ in the iSCSI Protocol\n   [iSCSI] document for Header and Data Digests.\n  \
    \ The fields which MUST be included in the CRC calculation when sending\n   an\
    \ FPDU are as follows:\n   1)  If a Marker does not immediately precede the ULPDU\
    \ Length field,\n       the CRC-32c is calculated from the first octet of the\
    \ ULPDU\n       Length field, through all the ULPDU and Markers (if present),\
    \ to\n       the last octet of the PAD (if present), inclusive.  If there is a\n\
    \       Marker immediately following the PAD, the Marker is included in\n    \
    \   the CRC calculation for this FPDU.\n   2)  If a Marker immediately precedes\
    \ the first octet of the ULPDU\n       Length field of the FPDU, (i.e., the Marker\
    \ fell between FPDUs,\n       and thus is required to be included in the second\
    \ FPDU), the\n       CRC-32c is calculated from the first octet of the Marker,\
    \ through\n       the ULPDU Length header, through all the ULPDU and Markers (if\n\
    \       present), to the last octet of the PAD (if present), inclusive.\n   3)\
    \  After calculating the CRC-32c, the resultant value is placed into\n       the\
    \ CRC field at the end of the FPDU.\n   When an FPDU is received, and CRC checking\
    \ is enabled, the receiver\n   MUST first perform the following:\n   1)  Calculate\
    \ the CRC of the incoming FPDU in the same fashion as\n       defined above.\n\
    \   2)  Verify that the calculated CRC-32c value is the same as the\n       received\
    \ CRC-32c value found in the FPDU CRC field.  If not, the\n       receiver MUST\
    \ treat the FPDU as an invalid FPDU.\n   The procedure for handling invalid FPDUs\
    \ is covered in Section 8,\n   Error Semantics.\n   The following is an annotated\
    \ hex dump of an example FPDU sent as the\n   first FPDU on the stream.  As such,\
    \ it starts with a Marker.  The\n   FPDU contains a 42 octet ULPDU (an example\
    \ DDP segment) which in turn\n   contains 24 octets of the contained ULPDU, which\
    \ is a data load that\n   is all zeros.  The CRC32c has been correctly calculated\
    \ and can be\n   used as a reference.  See the [DDP] and [RDMAP] specification\
    \ for\n   definitions of the DDP Control field, Queue, MSN, MO, and Send Data.\n\
    \       Octet Contents  Annotation\n       Count\n       0000    00      Marker:\
    \ Reserved\n       0001    00\n       0002    00      Marker: FPDUPTR\n      \
    \ 0003    00\n       0004    00      ULPDU Length\n       0005    2a\n       0006\
    \    41      DDP Control Field, Send with Last flag set\n       0007    43\n \
    \      0008    00      Reserved (DDP STag position with no STag)\n       0009\
    \    00\n       000a    00\n       000b    00\n       000c    00      DDP Queue\
    \ = 0\n       000d    00\n       000e    00\n       000f    00\n       0010  \
    \  00      DDP MSN = 1\n       0011    00\n       0012    00\n       0013    01\n\
    \       0014    00      DDP MO = 0\n       0015    00\n       0016    00\n   \
    \    0017    00\n       0018    00      DDP Send Data (24 octets of zeros)\n \
    \      ...\n       002f    00\n       0030    52      CRC32c\n       0031    23\n\
    \       0032    99\n       0033    83\n                  Figure 5: Annotated Hex\
    \ Dump of an FPDU\n      The following is an example sent as the second FPDU of\
    \ the stream\n      where the first FPDU (which is not shown here) had a length\
    \ of 492\n      octets and was also a Send to Queue 0 with Last Flag set.  This\n\
    \      example contains a Marker.\n       Octet Contents  Annotation\n       Count\n\
    \       01ec    00      Length\n       01ed    2a\n       01ee    41      DDP\
    \ Control Field: Send with Last Flag set\n       01ef    43\n       01f0    00\
    \      Reserved (DDP STag position with no STag)\n       01f1    00\n       01f2\
    \    00\n       01f3    00\n       01f4    00      DDP Queue = 0\n       01f5\
    \    00\n       01f6    00\n       01f7    00\n       01f8    00      DDP MSN\
    \ = 2\n       01f9    00\n       01fa    00\n       01fb    02\n       01fc  \
    \  00      DDP MO = 0\n       01fd    00\n       01fe    00\n       01ff    00\n\
    \       0200    00      Marker: Reserved\n       0201    00\n       0202    00\
    \      Marker: FPDUPTR\n       0203    14\n       0204    00      DDP Send Data\
    \ (24 octets of zeros)\n       ...\n       021b    00\n       021c    84     \
    \ CRC32c\n       021d    92\n       021e    58\n       021f    98\n          \
    \  Figure 6: Annotated Hex Dump of an FPDU with Marker\n"
- title: 4.5.  FPDU Size Considerations
  contents:
  - "4.5.  FPDU Size Considerations\n   MPA defines the Maximum Upper Layer Protocol\
    \ Data Unit (MULPDU) as\n   the size of the largest ULPDU fitting in an FPDU.\
    \  For an empty TCP\n   Segment, MULPDU is EMSS minus the FPDU overhead (6 octets)\
    \ minus\n   space for Markers and pad octets.\n       The maximum ULPDU Length\
    \ for a single ULPDU when Markers are\n       present MUST be computed as:\n \
    \      MULPDU = EMSS - (6 + 4 * Ceiling(EMSS / 512) + EMSS mod 4)\n   The formula\
    \ above accounts for the worst-case number of Markers.\n       The maximum ULPDU\
    \ Length for a single ULPDU when Markers are NOT\n       present MUST be computed\
    \ as:\n       MULPDU = EMSS - (6 + EMSS mod 4)\n   As a further optimization of\
    \ the wire efficiency an MPA\n   implementation MAY dynamically adjust the MULPDU\
    \ (see Section 5 for\n   latency and wire efficiency trade-offs).  When one or\
    \ more FPDUs are\n   already packed into a TCP Segment, MULPDU MAY be reduced\
    \ accordingly.\n   DDP SHOULD provide ULPDUs that are as large as possible, but\
    \ less\n   than or equal to MULPDU.\n   If the TCP implementation needs to adjust\
    \ EMSS to support MTU changes\n   or changing TCP options, the MULPDU value is\
    \ changed accordingly.\n   In certain rare situations, the EMSS may shrink below\
    \ 128 octets in\n   size.  If this occurs, the MPA on TCP sender MUST NOT shrink\
    \ the\n   MULPDU below 128 octets and is not required to follow the\n   segmentation\
    \ rules in Section 5.1 and Appendix A.\n   If one or more FPDUs are already packed\
    \ into a TCP segment, such that\n   the remaining room is less than 128 octets,\
    \ MPA MUST NOT provide a\n   MULPDU smaller than 128.  In this case, MPA would\
    \ typically provide a\n   MULPDU for the next full sized segment, but may still\
    \ pack the next\n   FPDU into the small remaining room, provide that the next\
    \ FPDU is\n   small enough to fit.\n   The value 128 is chosen as to allow DDP\
    \ designers room for the DDP\n   Header and some user data.\n"
- title: 5.  MPA's interactions with TCP
  contents:
  - "5.  MPA's interactions with TCP\n   The following sections describe MPA's interactions\
    \ with TCP.  This\n   section discusses using a standard layered TCP stack with\
    \ MPA\n   attached above a TCP socket.  Discussion of using an optimized MPA-\n\
    \   aware TCP with an MPA implementation that takes advantage of the\n   extra\
    \ optimizations is done in Appendix A.\n                   +-----------------------------------+\n\
    \                   | +-----+       +-----------------+ |\n                  \
    \ | | MPA |       | Other Protocols | |\n                   | +-----+       +-----------------+\
    \ |\n                   |    ||                  ||         |\n              \
    \     |  ----- socket API --------------  |\n                   |            ||\
    \                     |\n                   |         +-----+                \
    \   |\n                   |         | TCP |                   |\n            \
    \       |         +-----+                   |\n                   |          \
    \  ||                     |\n                   |         +-----+            \
    \       |\n                   |         | IP  |                   |\n        \
    \           |         +-----+                   |\n                   +-----------------------------------+\n\
    \                   Figure 7: Fully Layered Implementation\n   The Fully layered\
    \ implementation is described for completeness;\n   however, the user is cautioned\
    \ that the reduced probability of FPDU\n   alignment when transmitting with this\
    \ implementation will tend to\n   introduce a higher overhead at optimized receivers.\
    \  In addition, the\n   lack of out-of-order receive processing will significantly\
    \ reduce the\n   value of DDP/MPA by imposing higher buffering and copying overhead\
    \ in\n   the local receiver.\n"
- title: 5.1.  MPA transmitters with a standard layered TCP
  contents:
  - "5.1.  MPA transmitters with a standard layered TCP\n   MPA transmitters SHOULD\
    \ calculate a MULPDU as described in Section\n   4.5.  If the TCP implementation\
    \ allows EMSS to be determined by MPA,\n   that value should be used.  If the\
    \ transmit side TCP implementation\n   is not able to report the EMSS, MPA SHOULD\
    \ use the current MTU value\n   to establish a likely FPDU size, taking into account\
    \ the various\n   expected header sizes.\n   MPA transmitters SHOULD also use\
    \ whatever facilities the TCP stack\n   presents to cause the TCP transmitter\
    \ to start TCP segments at FPDU\n   boundaries.  Multiple FPDUs MAY be packed\
    \ into a single TCP segment\n   as determined by the EMSS calculation as long\
    \ as they are entirely\n   contained in the TCP segment.\n   For example, passing\
    \ FPDU buffers sized to the current EMSS to the\n   TCP socket and using the TCP_NODELAY\
    \ socket option to disable the\n   Nagle [RFC896] algorithm will usually result\
    \ in many of the segments\n   starting with an FPDU.\n   It is recognized that\
    \ various effects can cause an FPDU Alignment to\n   be lost.  Following are a\
    \ few of the effects:\n   *   ULPDUs that are smaller than the MULPDU.  If these\
    \ are sent in a\n       continuous stream, FPDU Alignment will be lost.  Note\
    \ that\n       careful use of a dynamic MULPDU can help in this case; the MULPDU\n\
    \       for future FPDUs can be adjusted to re-establish alignment with\n    \
    \   the segments based on the current EMSS.\n   *   Sending enough data that the\
    \ TCP receive window limit is reached.\n       TCP may send a smaller segment\
    \ to exactly fill the receive\n       window.\n   *   Sending data when TCP is\
    \ operating up against the congestion\n       window.  If TCP is not tracking\
    \ the congestion window in\n       segments, it may transmit a smaller segment\
    \ to exactly fill the\n       receive window.\n   *   Changes in EMSS due to varying\
    \ TCP options, or changes in MTU.\n   If FPDU Alignment with TCP segments is lost\
    \ for any reason, the\n   alignment is regained after a break in transmission\
    \ where the TCP\n   send buffers are emptied.  Many usage models for DDP/MPA will\
    \ include\n   such breaks.\n   MPA receivers are REQUIRED to be able to operate\
    \ correctly even if\n   alignment is lost (see Section 6).\n"
- title: 5.2.  MPA receivers with a standard layered TCP
  contents:
  - "5.2.  MPA receivers with a standard layered TCP\n   MPA receivers will get TCP\
    \ data in the usual ordered stream.  The\n   receivers MUST identify FPDU boundaries\
    \ by using the ULPDU_LENGTH\n   field, as described in Section 6.  Receivers MAY\
    \ utilize markers to\n   check for FPDU boundary consistency, but they are NOT\
    \ required to\n   examine the markers to determine the FPDU boundaries.\n"
- title: 6.  MPA Receiver FPDU Identification
  contents:
  - "6.  MPA Receiver FPDU Identification\n   An MPA receiver MUST first verify the\
    \ FPDU before passing the ULPDU\n   to DDP.  To do this, the receiver MUST:\n\
    \   *   locate the start of the FPDU unambiguously,\n   *   verify its CRC (if\
    \ CRC checking is enabled).\n   If the above conditions are true, the MPA receiver\
    \ passes the ULPDU\n   to DDP.\n   To detect the start of the FPDU unambiguously\
    \ one of the following\n   MUST be used:\n   1:  In an ordered TCP stream, the\
    \ ULPDU Length field in the current\n       FPDU when FPDU has a valid CRC, can\
    \ be used to identify the\n       beginning of the next FPDU.\n   2:  For optimized\
    \ MPA/TCP receivers that support out-of-order\n       reception of FPDUs (see\
    \ Section 4.3, MPA Markers) a Marker can\n       always be used to locate the\
    \ beginning of an FPDU (in FPDUs with\n       valid CRCs).  Since the location\
    \ of the Marker is known in the\n       octet stream (sequence number space),\
    \ the Marker can always be\n       found.\n   3:  Having found an FPDU by means\
    \ of a Marker, an optimized MPA/TCP\n       receiver can find following contiguous\
    \ FPDUs by using the ULPDU\n       Length fields (from FPDUs with valid CRCs)\
    \ to establish the next\n       FPDU boundary.\n   The ULPDU Length field (see\
    \ Section 4) MUST be used to determine if\n   the entire FPDU is present before\
    \ forwarding the ULPDU to DDP.\n   CRC calculation is discussed in Section 4.4\
    \ above.\n"
- title: 7.  Connection Semantics
  contents:
  - '7.  Connection Semantics

    '
- title: 7.1.  Connection Setup
  contents:
  - "7.1.  Connection Setup\n   MPA requires that the Consumer MUST activate MPA,\
    \ and any TCP\n   enhancements for MPA, on a TCP half connection at the same location\n\
    \   in the octet stream at both the sender and the receiver.  This is\n   required\
    \ in order for the Marker scheme to correctly locate the\n   Markers (if enabled)\
    \ and to correctly locate the first FPDU.\n   MPA, and any TCP enhancements for\
    \ MPA are enabled by the ULP in both\n   directions at once at an endpoint.\n\
    \   This can be accomplished several ways, and is left up to DDP's ULP:\n   *\
    \   DDP's ULP MAY require DDP on MPA startup immediately after TCP\n       connection\
    \ setup.  This has the advantage that no streaming mode\n       negotiation is\
    \ needed.  An example of such a protocol is shown in\n       Figure 10: Example\
    \ Immediate Startup negotiation.\n       This may be accomplished by using a well-known\
    \ port, or a service\n       locator protocol to locate an appropriate port on\
    \ which DDP on\n       MPA is expected to operate.\n   *   DDP's ULP MAY negotiate\
    \ the start of DDP on MPA sometime after a\n       normal TCP startup, using TCP\
    \ streaming data exchanges on the\n       same connection.  The exchange establishes\
    \ that DDP on MPA (as\n       well as other ULPs) will be used, and exactly locates\
    \ the point\n       in the octet stream where MPA is to begin operation.  Note\
    \ that\n       such a negotiation protocol is outside the scope of this\n    \
    \   specification.  A simplified example of such a protocol is shown\n       in\
    \ Figure 9: Example Delayed Startup negotiation on page 33.\n   An MPA endpoint\
    \ operates in two distinct phases.\n   The Startup Phase is used to verify correct\
    \ MPA setup, exchange CRC\n   and Marker configuration, and optionally pass Private\
    \ Data between\n   endpoints prior to completing a DDP connection.  During this\
    \ phase,\n   specifically formatted frames are exchanged as TCP byte streams\n\
    \   without using CRCs or Markers.  During this phase a DDP endpoint need\n  \
    \ not be \"bound\" to the MPA connection.  In fact, the choice of DDP\n   endpoint\
    \ and its operating parameters may not be known until the\n   Consumer supplied\
    \ Private Data (if any) has been examined by the\n   Consumer.\n   The second\
    \ distinct phase is Full Operation during which FPDUs are\n   sent using all the\
    \ rules that pertain (CRCs, Markers, MULPDU\n   restrictions, etc.).  A DDP endpoint\
    \ MUST be \"bound\" to the MPA\n   connection at entry to this phase.\n   When\
    \ Private Data is passed between ULPs in the Startup Phase, the\n   ULP is responsible\
    \ for interpreting that data, and then placing MPA\n   into Full Operation.\n\
    \   Note: The following text differentiates the two endpoints by calling\n   \
    \    them Initiator and Responder.  This is quite arbitrary and is NOT\n     \
    \  related to the TCP startup (SYN, SYN/ACK sequence).  The\n       Initiator\
    \ is the side that sends first in the MPA startup\n       sequence (the MPA Request\
    \ Frame).\n   Note: The possibility that both endpoints would be allowed to make\
    \ a\n       connection at the same time, sometimes called an active/active\n \
    \      connection, was considered by the work group and rejected.  There\n   \
    \    were several motivations for this decision.  One was that\n       applications\
    \ needing this facility were few (none other than\n       theoretical at the time\
    \ of this document).  Another was that the\n       facility created some implementation\
    \ difficulties, particularly\n       with the \"dual stack\" designs described\
    \ later on.  A last issue\n       was that dealing with rejected connections at\
    \ startup would have\n       required at least an additional frame type, and more\
    \ recovery\n       actions, complicating the protocol.  While none of these issues\n\
    \       was overwhelming, the group and implementers were not motivated\n    \
    \   to do the work to resolve these issues.  The protocol includes a\n       method\
    \ of detecting these active/active startup attempts so that\n       they can be\
    \ rejected and an error reported.\n   The ULP is responsible for determining which\
    \ side is Initiator or\n   Responder.  For client/server type ULPs, this is easy.\
    \  For peer-peer\n   ULPs (which might utilize a TCP style active/active startup),\
    \ some\n   mechanism (not defined by this specification) must be established,\
    \ or\n   some streaming mode data exchanged prior to MPA startup to determine\n\
    \   which side starts in Initiator and which starts in Responder MPA\n   mode.\n"
- title: 7.1.1  MPA Request and Reply Frame Format
  contents:
  - "7.1.1  MPA Request and Reply Frame Format\n       0                   1     \
    \              2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   0  |                                                               |\n   \
    \   +         Key (16 bytes containing \"MPA ID Req Frame\")          +\n   4\
    \  |      (4D 50 41 20 49 44 20 52 65 71 20 46 72 61 6D 65)        |\n      +\
    \         Or  (16 bytes containing \"MPA ID Rep Frame\")          +\n   8  | \
    \     (4D 50 41 20 49 44 20 52 65 70 20 46 72 61 6D 65)        |\n      +    \
    \                                                           +\n   12 |       \
    \                                                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   16 |M|C|R| Res     |     Rev       |          PD_Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      ~   \
    \                                                            ~\n      ~      \
    \             Private Data                                ~\n      |         \
    \                                                      |\n      |            \
    \                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |               \
    \                |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                \
    \     Figure 8: MPA Request/Reply Frame\n   Key: This field contains the \"key\"\
    \ used to validate that the sender\n       is an MPA sender.  Initiator mode senders\
    \ MUST set this field to\n       the fixed value \"MPA ID Req Frame\" or (in byte\
    \ order) 4D 50 41 20\n       49 44 20 52 65 71 20 46 72 61 6D 65 (in hexadecimal).\
    \  Responder\n       mode receivers MUST check this field for the same value,\
    \ and\n       close the connection and report an error locally if any other\n\
    \       value is detected.  Responder mode senders MUST set this field to\n  \
    \     the fixed value \"MPA ID Rep Frame\" or (in byte order) 4D 50 41 20\n  \
    \     49 44 20 52 65 70 20 46 72 61 6D 65 (in hexadecimal).  Initiator\n     \
    \  mode receivers MUST check this field for the same value, and\n       close\
    \ the connection and report an error locally if any other\n       value is detected.\n\
    \   M: This bit declares an endpoint's REQUIRED Marker usage.  When this\n   \
    \    bit is '1' in an MPA Request Frame, the Initiator declares that\n       Markers\
    \ are REQUIRED in FPDUs sent from the Responder.  When set\n       to '1' in an\
    \ MPA Reply Frame, this bit declares that Markers are\n       REQUIRED in FPDUs\
    \ sent from the Initiator.  When in a received\n       MPA Request Frame or MPA\
    \ Reply Frame and the value is '0',\n       Markers MUST NOT be added to the data\
    \ stream by that endpoint.\n       When '1' Markers MUST be added as described\
    \ in Section 4.3, MPA\n       Markers.\n   C: This bit declares an endpoint's\
    \ preferred CRC usage.  When this\n       field is '0' in the MPA Request Frame\
    \ and the MPA Reply Frame,\n       CRCs MUST not be checked and need not be generated\
    \ by either\n       endpoint.  When this bit is '1' in either the MPA Request\
    \ Frame\n       or MPA Reply Frame, CRCs MUST be generated and checked by both\n\
    \       endpoints.  Note that even when not in use, the CRC field remains\n  \
    \     present in the FPDU.  When CRCs are not in use, the CRC field\n       MUST\
    \ be considered valid for FPDU checking regardless of its\n       contents.\n\
    \   R: This bit is set to zero, and not checked on reception in the MPA\n    \
    \   Request Frame.  In the MPA Reply Frame, this bit is the Rejected\n       Connection\
    \ bit, set by the Responders ULP to indicate acceptance\n       '0', or rejection\
    \ '1', of the connection parameters provided in\n       the Private Data.\n  \
    \ Res: This field is reserved for future use.  It MUST be set to zero\n      \
    \ when sending, and not checked on reception.\n   Rev: This field contains the\
    \ revision of MPA.  For this version of\n       the specification, senders MUST\
    \ set this field to one.  MPA\n       receivers compliant with this version of\
    \ the specification MUST\n       check this field.  If the MPA receiver cannot\
    \ interoperate with\n       the received version, then it MUST close the connection\
    \ and\n       report an error locally.  Otherwise, the MPA receiver should\n \
    \      report the received version to the ULP.\n   PD_Length: This field MUST\
    \ contain the length in octets of the\n       Private Data field.  A value of\
    \ zero indicates that there is no\n       Private Data field present at all. \
    \ If the receiver detects that\n       the PD_Length field does not match the\
    \ length of the Private Data\n       field, or if the length of the Private Data\
    \ field exceeds 512\n       octets, the receiver MUST close the connection and\
    \ report an\n       error locally.  Otherwise, the MPA receiver should pass the\n\
    \       PD_Length value and Private Data to the ULP.\n   Private Data: This field\
    \ may contain any value defined by ULPs or may\n       not be present.  The Private\
    \ Data field MUST be between 0 and 512\n       octets in length.  ULPs define\
    \ how to size, set, and validate\n       this field within these limits.  Private\
    \ Data usage is further\n       discussed in Section 7.1.4.\n"
- title: 7.1.2.  Connection Startup Rules
  contents:
  - "7.1.2.  Connection Startup Rules\n   The following rules apply to MPA connection\
    \ Startup Phase:\n   1.  When MPA is started in the Initiator mode, the MPA implementation\n\
    \       MUST send a valid MPA Request Frame.  The MPA Request Frame MAY\n    \
    \   include ULP-supplied Private Data.\n   2.  When MPA is started in the Responder\
    \ mode, the MPA implementation\n       MUST wait until an MPA Request Frame is\
    \ received and validated\n       before entering Full MPA/DDP Operation.\n   \
    \    If the MPA Request Frame is improperly formatted, the\n       implementation\
    \ MUST close the TCP connection and exit MPA.\n       If the MPA Request Frame\
    \ is properly formatted but the Private\n       Data is not acceptable, the implementation\
    \ SHOULD return an MPA\n       Reply Frame with the Rejected Connection bit set\
    \ to '1'; the MPA\n       Reply Frame MAY include ULP-supplied Private Data; the\n\
    \       implementation MUST exit MPA, leaving the TCP connection open.\n     \
    \  The ULP may close TCP or use the connection for other purposes.\n       If\
    \ the MPA Request Frame is properly formatted and the Private\n       Data is\
    \ acceptable, the implementation SHOULD return an MPA Reply\n       Frame with\
    \ the Rejected Connection bit set to '0'; the MPA Reply\n       Frame MAY include\
    \ ULP-supplied Private Data; and the Responder\n       SHOULD prepare to interpret\
    \ any data received as FPDUs and pass\n       any received ULPDUs to DDP.\n  \
    \     Note: Since the receiver's ability to deal with Markers is\n           unknown\
    \ until the Request and Reply Frames have been\n           received, sending FPDUs\
    \ before this occurs is not possible.\n       Note: The requirement to wait on\
    \ a Request Frame before sending a\n           Reply Frame is a design choice.\
    \  It makes for a well-ordered\n           sequence of events at each end, and\
    \ avoids having to specify\n           how to deal with situations where both\
    \ ends start at the same\n           time.\n   3.  MPA Initiator mode implementations\
    \ MUST receive and validate an\n       MPA Reply Frame.\n       If the MPA Reply\
    \ Frame is improperly formatted, the\n       implementation MUST close the TCP\
    \ connection and exit MPA.\n       If the MPA Reply Frame is properly formatted\
    \ but is the Private\n       Data is not acceptable, or if the Rejected Connection\
    \ bit is set\n       to '1', the implementation MUST exit MPA, leaving the TCP\n\
    \       connection open.  The ULP may close TCP or use the connection for\n  \
    \     other purposes.\n       If the MPA Reply Frame is properly formatted and\
    \ the Private Data\n       is acceptable, and the Reject Connection bit is set\
    \ to '0', the\n       implementation SHOULD enter Full MPA/DDP Operation Phase;\n\
    \       interpreting any received data as FPDUs and sending DDP ULPDUs as\n  \
    \     FPDUs.\n   4.  MPA Responder mode implementations MUST receive and validate\
    \ at\n       least one FPDU before sending any FPDUs or Markers.\n       Note:\
    \ This requirement is present to allow the Initiator time to\n           get its\
    \ receiver into Full Operation before an FPDU arrives,\n           avoiding potential\
    \ race conditions at the Initiator.  This\n           was also subject to some\
    \ debate in the work group before\n           rough consensus was reached.  Eliminating\
    \ this requirement\n           would allow faster startup in some types of applications.\n\
    \           However, that would also make certain implementations\n          \
    \ (particularly \"dual stack\") much harder.\n   5.  If a received \"Key\" does\
    \ not match the expected value (see\n       Section 7.1.1, MPA Request and Reply\
    \ Frame Format) the TCP/DDP\n       connection MUST be closed, and an error returned\
    \ to the ULP.\n   6.  The received Private Data fields may be used by Consumers\
    \ at\n       either end to further validate the connection and set up DDP or\n\
    \       other ULP parameters.  The Initiator ULP MAY close the\n       TCP/MPA/DDP\
    \ connection as a result of validating the Private Data\n       fields.  The Responder\
    \ SHOULD return an MPA Reply Frame with the\n       \"Reject Connection\" bit\
    \ set to '1' if the validation of the\n       Private Data is not acceptable to\
    \ the ULP.\n   7.  When the first FPDU is to be sent, then if Markers are enabled,\n\
    \       the first octets sent are the special Marker 0x00000000, followed\n  \
    \     by the start of the FPDU (the FPDU's ULPDU Length field).  If\n       Markers\
    \ are not enabled, the first octets sent are the start of\n       the FPDU (the\
    \ FPDU's ULPDU Length field).\n   8.  MPA implementations MUST use the difference\
    \ between the MPA\n       Request Frame and the MPA Reply Frame to check for incorrect\n\
    \       \"Initiator/Initiator\" startups.  Implementations SHOULD put a\n    \
    \   timeout on waiting for the MPA Request Frame when started in\n       Responder\
    \ mode, to detect incorrect \"Responder/Responder\"\n       startups.\n   9. \
    \ MPA implementations MUST validate the PD_Length field.  The\n       buffer that\
    \ receives the Private Data field MUST be large enough\n       to receive that\
    \ data; the amount of Private Data MUST not exceed\n       the PD_Length or the\
    \ application buffer.  If any of the above\n       fails, the startup frame MUST\
    \ be considered improperly formatted.\n   10. MPA implementations SHOULD implement\
    \ a reasonable timeout while\n       waiting for the entire set of startup frames;\
    \ this prevents\n       certain denial-of-service attacks.  ULPs SHOULD implement\
    \ a\n       reasonable timeout while waiting for FPDUs, ULPDUs, and\n       application\
    \ level messages to guard against application failures\n       and certain denial-of-service\
    \ attacks.\n"
- title: 7.1.3.  Example Delayed Startup Sequence
  contents:
  - "7.1.3.  Example Delayed Startup Sequence\n   A variety of startup sequences are\
    \ possible when using MPA on TCP.\n   Following is an example of an MPA/DDP startup\
    \ that occurs after TCP\n   has been running for a while and has exchanged some\
    \ amount of\n   streaming data.  This example does not use any Private Data (an\n\
    \   example that does is shown later in Section 7.1.4.2, Example\n   Immediate\
    \ Startup Using Private Data), although it is perfectly legal\n   to include the\
    \ Private Data.  Note that since the example does not\n   use any Private Data,\
    \ there are no ULP interactions shown between\n   receiving \"startup frames\"\
    \ and putting MPA into Full Operation.\n         Initiator                   \
    \              Responder\n  +---------------------------+\n  |ULP streaming mode\
    \         |\n  |  <Hello> request to       |\n  |  transition to DDP/MPA    |\
    \           +---------------------------+\n  |  mode (optional).         | -------->\
    \ |ULP gets request;          |\n  +---------------------------+           | \
    \ enables MPA Responder    |\n                                          |  mode\
    \ with last (optional)|\n                                          |  streaming\
    \ mode           |\n                                          |  <Hello Ack> for\
    \ MPA to   |\n                                          |  send.             \
    \       |\n  +---------------------------+           |MPA waits for incoming \
    \    |\n  |ULP receives streaming     | <-------- |  <MPA Request Frame>.    \
    \ |\n  |  <Hello Ack>;             |           +---------------------------+\n\
    \  |Enters MPA Initiator mode; |\n  |MPA sends                  |\n  |  <MPA Request\
    \ Frame>;     |\n  |MPA waits for incoming     |           +---------------------------+\n\
    \  |  <MPA Reply Frame>.       | - - - - > |MPA receives               |\n  +---------------------------+\
    \           |  <MPA Request Frame>.     |\n                                  \
    \        |Consumer binds DDP to MPA; |\n                                     \
    \     |MPA sends the              |\n                                        \
    \  |  <MPA Reply Frame>.       |\n                                          |DDP/MPA\
    \ enables FPDU       |\n  +---------------------------+           |  decoding,\
    \ but does not   |\n  |MPA receives the           | < - - - - |  send any FPDUs.\
    \          |\n  |  <MPA Reply Frame>        |           +---------------------------+\n\
    \  |Consumer binds DDP to MPA; |\n  |DDP/MPA begins Full        |\n  |  Operation.\
    \               |\n  |MPA sends first FPDU (as   |           +---------------------------+\n\
    \  |  DDP ULPDUs become        | ========> |MPA receives first FPDU.   |\n  |\
    \  available).              |           |MPA sends first FPDU (as   |\n  +---------------------------+\
    \           |  DDP ULPDUs become        |\n                                  <======\
    \ |  available).              |\n                                          +---------------------------+\n\
    \              Figure 9: Example Delayed Startup Negotiation\n   An example Delayed\
    \ Startup sequence is described below:\n       *   Active and passive sides start\
    \ up a TCP connection in the\n           usual fashion, probably using sockets\
    \ APIs.  They exchange\n           some amount of streaming mode data.  At some\
    \ point, one side\n           (the MPA Initiator) sends streaming mode data that\n\
    \           effectively says \"Hello, let's go into MPA/DDP mode\".\n   *   When\
    \ the remote side (the MPA Responder) gets this streaming mode\n       message,\
    \ the Consumer would send a last streaming mode message\n       that effectively\
    \ says \"I acknowledge your Hello, and am now in\n       MPA Responder mode\"\
    .  The exchange of these messages establishes\n       the exact point in the TCP\
    \ stream where MPA is enabled.  The\n       Responding Consumer enables MPA in\
    \ the Responder mode and waits\n       for the initial MPA startup message.\n\
    \       *   The Initiating Consumer would enable MPA startup in the\n        \
    \   Initiator mode which then sends the MPA Request Frame.  It is\n          \
    \ assumed that no Private Data messages are needed for this\n           example,\
    \ although it is possible to do so.  The Initiating\n           MPA (and Consumer)\
    \ would also wait for the MPA connection to\n           be accepted.\n   *   The\
    \ Responding MPA would receive the initial MPA Request Frame\n       and would\
    \ inform the Consumer that this message arrived.  The\n       Consumer can then\
    \ accept the MPA/DDP connection or close the TCP\n       connection.\n   *   To\
    \ accept the connection request, the Responding Consumer would\n       use an\
    \ appropriate API to bind the TCP/MPA connections to a DDP\n       endpoint, thus\
    \ enabling MPA/DDP into Full Operation.  In the\n       process of going to Full\
    \ Operation, MPA sends the MPA Reply\n       Frame.  MPA/DDP waits for the first\
    \ incoming FPDU before sending\n       any FPDUs.\n   *   If the initial TCP data\
    \ was not a properly formatted MPA Request\n       Frame, MPA will close or reset\
    \ the TCP connection immediately.\n       *   The Initiating MPA would receive\
    \ the MPA Reply Frame and\n           would report this message to the Consumer.\
    \  The Consumer can\n           then accept the MPA/DDP connection, or close or\
    \ reset the TCP\n           connection to abort the process.\n       *   On determining\
    \ that the connection is acceptable, the\n           Initiating Consumer would\
    \ use an appropriate API to bind the\n           TCP/MPA connections to a DDP\
    \ endpoint thus enabling MPA/DDP\n           into Full Operation.  MPA/DDP would\
    \ begin sending DDP\n           messages as MPA FPDUs.\n"
- title: 7.1.4.  Use of Private Data
  contents:
  - "7.1.4.  Use of Private Data\n   This section is advisory in nature, in that it\
    \ suggests a method by\n   which a ULP can deal with pre-DDP connection information\
    \ exchange.\n"
- title: 7.1.4.1.  Motivation
  contents:
  - "7.1.4.1.  Motivation\n   Prior RDMA protocols have been developed that provide\
    \ Private Data\n   via out-of-band mechanisms.  As a result, many applications\
    \ now\n   expect some form of Private Data to be available for application use\n\
    \   prior to setting up the DDP/RDMA connection.  Following are some\n   examples\
    \ of the use of Private Data.\n   An RDMA endpoint (referred to as a Queue Pair,\
    \ or QP, in InfiniBand\n   and the [VERBS-RDMA]) must be associated with a Protection\
    \ Domain.\n   No receive operations may be posted to the endpoint before it is\n\
    \   associated with a Protection Domain.  Indeed under both the\n   InfiniBand\
    \ and proposed RDMA/DDP verbs [VERBS-RDMA] an endpoint/QP is\n   created within\
    \ a Protection Domain.\n   There are some applications where the choice of Protection\
    \ Domain is\n   dependent upon the identity of the remote ULP client.  For example,\n\
    \   if a user session requires multiple connections, it is highly\n   desirable\
    \ for all of those connections to use a single Protection\n   Domain.  Note: Use\
    \ of Protection Domains is further discussed in\n   [RDMASEC].\n   InfiniBand,\
    \ the DAT APIs [DAT-API], and the IT-API [IT-API] all\n   provide for the active-side\
    \ ULP to provide Private Data when\n   requesting a connection.  This data is\
    \ passed to the ULP to allow it\n   to determine whether to accept the connection,\
    \ and if so with which\n   endpoint (and implicitly which Protection Domain).\n\
    \   The Private Data can also be used to ensure that both ends of the\n   connection\
    \ have configured their RDMA endpoints compatibly on such\n   matters as the RDMA\
    \ Read capacity (see [RDMAP]).  Further ULP-\n   specific uses are also presumed,\
    \ such as establishing the identity of\n   the client.\n   Private Data is also\
    \ allowed for when accepting the connection, to\n   allow completion of any negotiation\
    \ on RDMA resources and for other\n   ULP reasons.\n   There are several potential\
    \ ways to exchange this Private Data.  For\n   example, the InfiniBand specification\
    \ includes a connection\n   management protocol that allows a small amount of\
    \ Private Data to be\n   exchanged using datagrams before actually starting the\
    \ RDMA\n   connection.\n   This document allows for small amounts of Private Data\
    \ to be\n   exchanged as part of the MPA startup sequence.  The actual Private\n\
    \   Data fields are carried in the MPA Request Frame and the MPA Reply\n   Frame.\n\
    \   If larger amounts of Private Data or more negotiation is necessary,\n   TCP\
    \ streaming mode messages may be exchanged prior to enabling MPA.\n"
- title: 7.1.4.2.  Example Immediate Startup Using Private Data
  contents:
  - "7.1.4.2.  Example Immediate Startup Using Private Data\n          Initiator \
    \                                Responder\n   +---------------------------+\n\
    \   |TCP SYN sent.              |           +--------------------------+\n   +---------------------------+\
    \ --------> |TCP gets SYN packet;      |\n   +---------------------------+   \
    \        |  sends SYN-Ack.          |\n   |TCP gets SYN-Ack           | <--------\
    \ +--------------------------+\n   |  sends Ack.               |\n   +---------------------------+\
    \ --------> +--------------------------+\n   +---------------------------+   \
    \        |Consumer enables MPA      |\n   |Consumer enables MPA       |      \
    \     |Responder mode, waits for |\n   |Initiator mode with        |         \
    \  |  <MPA Request frame>.    |\n   |Private Data; MPA sends    |           +--------------------------+\n\
    \   |  <MPA Request Frame>;     |\n   |MPA waits for incoming     |          \
    \ +--------------------------+\n   |  <MPA Reply Frame>.       | - - - - > |MPA\
    \ receives              |\n   +---------------------------+           |  <MPA\
    \ Request Frame>.    |\n                                           |Consumer examines\
    \ Private |\n                                           |Data, provides MPA with\
    \   |\n                                           |return Private Data,      |\n\
    \                                           |binds DDP to MPA, and     |\n   \
    \                                        |enables MPA to send an    |\n      \
    \                                     |  <MPA Reply Frame>.      |\n         \
    \                                  |DDP/MPA enables FPDU      |\n   +---------------------------+\
    \           |decoding, but does not    |\n   |MPA receives the           | < -\
    \ - - - |send any FPDUs.           |\n   |  <MPA Reply Frame>.       |       \
    \    +--------------------------+\n   |Consumer examines Private  |\n   |Data,\
    \ binds DDP to MPA,    |\n   |and enables DDP/MPA to     |\n   |begin Full Operation.\
    \      |\n   |MPA sends first FPDU (as   |           +--------------------------+\n\
    \   |DDP ULPDUs become          | ========> |MPA receives first FPDU.  |\n   |available).\
    \                |           |MPA sends first FPDU (as  |\n   +---------------------------+\
    \           |DDP ULPDUs become         |\n                                   <======\
    \ |available).               |\n                                           +--------------------------+\n\
    \             Figure 10: Example Immediate Startup Negotiation\n   Note: The exact\
    \ order of when MPA is started in the TCP connection\n       sequence is implementation\
    \ dependent; the above diagram shows one\n       possible sequence.  Also, the\
    \ Initiator \"Ack\" to the Responder's\n       \"SYN-Ack\" may be combined into\
    \ the same TCP segment containing\n       the MPA Request Frame (as is allowed\
    \ by TCP RFCs).\n   The example immediate startup sequence is described below:\n\
    \   *   The passive side (Responding Consumer) would listen on the TCP\n     \
    \  destination port, to indicate its readiness to accept a\n       connection.\n\
    \       *   The active side (Initiating Consumer) would request a\n          \
    \ connection from a TCP endpoint (that expected to upgrade to\n           MPA/DDP/RDMA\
    \ and expected the Private Data) to a destination\n           address and port.\n\
    \       *   The Initiating Consumer would initiate a TCP connection to\n     \
    \      the destination port.  Acceptance/rejection of the connection\n       \
    \    would proceed as per normal TCP connection establishment.\n   *   The passive\
    \ side (Responding Consumer) would receive the TCP\n       connection request\
    \ as usual allowing normal TCP gatekeepers, such\n       as INETD and TCPserver,\
    \ to exercise their normal\n       safeguard/logging functions.  On acceptance\
    \ of the TCP\n       connection, the Responding Consumer would enable MPA in the\n\
    \       Responder mode and wait for the initial MPA startup message.\n       *\
    \   The Initiating Consumer would enable MPA startup in the\n           Initiator\
    \ mode to send an initial MPA Request Frame with its\n           included Private\
    \ Data message to send.  The Initiating MPA\n           (and Consumer) would also\
    \ wait for the MPA connection to be\n           accepted, and any returned Private\
    \ Data.\n   *   The Responding MPA would receive the initial MPA Request Frame\n\
    \       with the Private Data message and would pass the Private Data\n      \
    \ through to the Consumer.  The Consumer can then accept the\n       MPA/DDP connection,\
    \ close the TCP connection, or reject the MPA\n       connection with a return\
    \ message.\n   *   To accept the connection request, the Responding Consumer would\n\
    \       use an appropriate API to bind the TCP/MPA connections to a DDP\n    \
    \   endpoint, thus enabling MPA/DDP into Full Operation.  In the\n       process\
    \ of going to Full Operation, MPA sends the MPA Reply\n       Frame, which includes\
    \ the Consumer-supplied Private Data\n       containing any appropriate Consumer\
    \ response.  MPA/DDP waits for\n       the first incoming FPDU before sending\
    \ any FPDUs.\n   *   If the initial TCP data was not a properly formatted MPA\
    \ Request\n       Frame, MPA will close or reset the TCP connection immediately.\n\
    \   *   To reject the MPA connection request, the Responding Consumer\n      \
    \ would send an MPA Reply Frame with any ULP-supplied Private Data\n       (with\
    \ reason for rejection), with the \"Rejected Connection\" bit\n       set to '1',\
    \ and may close the TCP connection.\n       *   The Initiating MPA would receive\
    \ the MPA Reply Frame with the\n           Private Data message and would report\
    \ this message to the\n           Consumer, including the supplied Private Data.\n\
    \           If the \"Rejected Connection\" bit is set to a '1', MPA will\n   \
    \        close the TCP connection and exit.\n           If the \"Rejected Connection\"\
    \ bit is set to a '0', and on\n           determining from the MPA Reply Frame\
    \ Private Data that the\n           connection is acceptable, the Initiating Consumer\
    \ would use\n           an appropriate API to bind the TCP/MPA connections to\
    \ a DDP\n           endpoint thus enabling MPA/DDP into Full Operation.  MPA/DDP\n\
    \           would begin sending DDP messages as MPA FPDUs.\n"
- title: 7.1.5.  "Dual Stack" Implementations
  contents:
  - "7.1.5.  \"Dual Stack\" Implementations\n   MPA/DDP implementations are commonly\
    \ expected to be implemented as\n   part of a \"dual stack\" architecture.  One\
    \ stack is the traditional\n   TCP stack, usually with a sockets interface API\
    \ (Application\n   Programming Interface).  The second stack is the MPA/DDP stack\
    \ with\n   its own API, and potentially separate code or hardware to deal with\n\
    \   the MPA/DDP data.  Of course, implementations may vary, so the\n   following\
    \ comments are of an advisory nature only.\n   The use of the two stacks offers\
    \ advantages:\n       TCP connection setup is usually done with the TCP stack.\
    \  This\n       allows use of the usual naming and addressing mechanisms.  It\n\
    \       also means that any mechanisms used to \"harden\" the connection\n   \
    \    setup against security threats are also used when starting\n       MPA/DDP.\n\
    \       Some applications may have been originally designed for TCP, but\n   \
    \    are \"enhanced\" to utilize MPA/DDP after a negotiation reveals the\n   \
    \    capability to do so.  The negotiation process takes place in\n       TCP's\
    \ streaming mode, using the usual TCP APIs.\n       Some new applications, designed\
    \ for RDMA or DDP, still need to\n       exchange some data prior to starting\
    \ MPA/DDP.  This exchange can\n       be of arbitrary length or complexity, but\
    \ often consists of only\n       a small amount of Private Data, perhaps only\
    \ a single message.\n       Using the TCP streaming mode for this exchange allows\
    \ this to be\n       done using well-understood methods.\n   The main disadvantage\
    \ of using two stacks is the conversion of an\n   active TCP connection between\
    \ them.  This process must be done with\n   care to prevent loss of data.\n  \
    \ To avoid some of the problems when using a \"dual stack\" architecture,\n  \
    \ the following additional restrictions may be required by the\n   implementation:\n\
    \   1.  Enabling the DDP/MPA stack SHOULD be done only when no incoming\n    \
    \   stream data is expected.  This is typically managed by the ULP\n       protocol.\
    \  When following the recommended startup sequence, the\n       Responder side\
    \ enters DDP/MPA mode, sends the last streaming mode\n       data, and then waits\
    \ for the MPA Request Frame.  No additional\n       streaming mode data is expected.\
    \  The Initiator side ULP receives\n       the last streaming mode data, and then\
    \ enters DDP/MPA mode.\n       Again, no additional streaming mode data is expected.\n\
    \   2.  The DDP/MPA MAY provide the ability to send a \"last streaming\n     \
    \  message\" as part of its Responder DDP/MPA enable function.  This\n       allows\
    \ the DDP/MPA stack to more easily manage the conversion to\n       DDP/MPA mode\
    \ (and avoid problems with a very fast return of the\n       MPA Request Frame\
    \ from the Initiator side).\n   Note: Regardless of the \"stack\" architecture\
    \ used, TCP's rules MUST\n       be followed.  For example, if network data is\
    \ lost, re-segmented,\n       or re-ordered, TCP MUST recover appropriately even\
    \ when this\n       occurs while switching stacks.\n"
- title: 7.2.  Normal Connection Teardown
  contents:
  - "7.2.  Normal Connection Teardown\n   Each half connection of MPA terminates when\
    \ DDP closes the\n   corresponding TCP half connection.\n   A mechanism SHOULD\
    \ be provided by MPA to DDP for DDP to be made aware\n   that a graceful close\
    \ of the TCP connection has been received by the\n   TCP (e.g., FIN is received).\n"
- title: 8.  Error Semantics
  contents:
  - "8.  Error Semantics\n   The following errors MUST be detected by MPA and the\
    \ codes SHOULD be\n   provided to DDP or other Consumer:\n   Code Error\n   1\
    \   TCP connection closed, terminated, or lost.  This includes lost\n       by\
    \ timeout, too many retries, RST received, or FIN received.\n   2   Received MPA\
    \ CRC does not match the calculated value for the\n       FPDU.\n   3   In the\
    \ event that the CRC is valid, received MPA Marker (if\n       enabled) and ULPDU\
    \ Length fields do not agree on the start of an\n       FPDU.  If the FPDU start\
    \ determined from previous ULPDU Length\n       fields does not match with the\
    \ MPA Marker position, MPA SHOULD\n       deliver an error to DDP.  It may not\
    \ be possible to make this\n       check as a segment arrives, but the check SHOULD\
    \ be made when a\n       gap creating an out-of-order sequence is closed and any\
    \ time a\n       Marker points to an already identified FPDU.  It is OPTIONAL\
    \ for\n       a receiver to check each Marker, if multiple Markers are present\n\
    \       in an FPDU, or if the segment is received in order.\n   4   Invalid MPA\
    \ Request Frame or MPA Response Frame received.  In\n       this case, the TCP\
    \ connection MUST be immediately closed.  DDP\n       and other ULPs should treat\
    \ this similar to code 1, above.\n   When conditions 2 or 3 above are detected,\
    \ an optimized MPA/TCP\n   implementation MAY choose to silently drop the TCP\
    \ segment rather\n   than reporting the error to DDP.  In this case, the sending\
    \ TCP will\n   retry the segment, usually correcting the error, unless the problem\n\
    \   was at the source.  In that case, the source will usually exceed the\n   number\
    \ of retries and terminate the connection.\n   Once MPA delivers an error of any\
    \ type, it MUST NOT pass or deliver\n   any additional FPDUs on that half connection.\n\
    \   For Error codes 2 and 3, MPA MUST NOT close the TCP connection\n   following\
    \ a reported error.  Closing the connection is the\n   responsibility of DDP's\
    \ ULP.\n       Note that since MPA will not Deliver any FPDUs on a half\n    \
    \   connection following an error detected on the receive side of\n       that\
    \ connection, DDP's ULP is expected to tear down the\n       connection.  This\
    \ may not occur until after one or more last\n       messages are transmitted\
    \ on the opposite half connection.  This\n       allows a diagnostic error message\
    \ to be sent.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This section discusses the security considerations\
    \ for MPA.\n"
- title: 9.1.  Protocol-Specific Security Considerations
  contents:
  - "9.1.  Protocol-Specific Security Considerations\n   The vulnerabilities of MPA\
    \ to third-party attacks are no greater than\n   any other protocol running over\
    \ TCP.  A third party, by sending\n   packets into the network that are delivered\
    \ to an MPA receiver, could\n   launch a variety of attacks that take advantage\
    \ of how MPA operates.\n   For example, a third party could send random packets\
    \ that are valid\n   for TCP, but contain no FPDU headers.  An MPA receiver reports\
    \ an\n   error to DDP when any packet arrives that cannot be validated as an\n\
    \   FPDU when properly located on an FPDU boundary.  A third party could\n   also\
    \ send packets that are valid for TCP, MPA, and DDP, but do not\n   target valid\
    \ buffers.  These types of attacks ultimately result in\n   loss of connection\
    \ and thus become a type of DOS (Denial Of Service)\n   attack.  Communication\
    \ security mechanisms such as IPsec [RFC2401,\n   RFC4301] may be used to prevent\
    \ such attacks.\n   Independent of how MPA operates, a third party could use ICMP\n\
    \   messages to reduce the path MTU to such a small size that performance\n  \
    \ would likewise be severely impacted.  Range checking on path MTU\n   sizes in\
    \ ICMP packets may be used to prevent such attacks.\n   [RDMAP] and [DDP] are\
    \ used to control, read, and write data buffers\n   over IP networks.  Therefore,\
    \ the control and the data packets of\n   these protocols are vulnerable to the\
    \ spoofing, tampering, and\n   information disclosure attacks listed below.  In\
    \ addition, connection\n   to/from an unauthorized or unauthenticated endpoint\
    \ is a potential\n   problem with most applications using RDMA, DDP, and MPA.\n"
- title: 9.1.1.  Spoofing
  contents:
  - "9.1.1.  Spoofing\n   Spoofing attacks can be launched by the Remote Peer or by\
    \ a network\n   based attacker.  A network-based spoofing attack applies to all\n\
    \   Remote Peers.  Because the MPA Stream requires a TCP Stream in the\n   ESTABLISHED\
    \ state, certain types of traditional forms of wire attacks\n   do not apply --\
    \ an end-to-end handshake must have occurred to\n   establish the MPA Stream.\
    \  So, the only form of spoofing that applies\n   is one when a remote node can\
    \ both send and receive packets.  Yet\n   even with this limitation the Stream\
    \ is still exposed to the\n   following spoofing attacks.\n"
- title: 9.1.1.1.  Impersonation
  contents:
  - "9.1.1.1.  Impersonation\n   A network-based attacker can impersonate a legal\
    \ MPA/DDP/RDMAP peer\n   (by spoofing a legal IP address) and establish an MPA/DDP/RDMAP\n\
    \   Stream with the victim.  End-to-end authentication (i.e., IPsec or\n   ULP\
    \ authentication) provides protection against this attack.\n"
- title: 9.1.1.2.  Stream Hijacking
  contents:
  - "9.1.1.2.  Stream Hijacking\n   Stream hijacking happens when a network-based\
    \ attacker follows the\n   Stream establishment phase, and waits until the authentication\
    \ phase\n   (if such a phase exists) is completed successfully.  He can then\n\
    \   spoof the IP address and redirect the Stream from the victim to its\n   own\
    \ machine.  For example, an attacker can wait until an iSCSI\n   authentication\
    \ is completed successfully, and hijack the iSCSI\n   Stream.\n   The best protection\
    \ against this form of attack is end-to-end\n   integrity protection and authentication,\
    \ such as IPsec, to prevent\n   spoofing.  Another option is to provide physical\
    \ security.\n   Discussion of physical security is out of scope for this document.\n"
- title: 9.1.1.3.  Man-in-the-Middle Attack
  contents:
  - "9.1.1.3.  Man-in-the-Middle Attack\n   If a network-based attacker has the ability\
    \ to delete, inject,\n   replay, or modify packets that will still be accepted\
    \ by MPA (e.g.,\n   TCP sequence number is correct, FPDU is valid, etc.), then\
    \ the Stream\n   can be exposed to a man-in-the-middle attack.  The attacker could\n\
    \   potentially use the services of [DDP] and [RDMAP] to read the\n   contents\
    \ of the associated Data Buffer, to modify the contents of the\n   associated\
    \ Data Buffer, or to disable further access to the buffer.\n   Other attacks on\
    \ the connection setup sequence and even on TCP can be\n   used to cause denial\
    \ of service.  The only countermeasure for this\n   form of attack is to either\
    \ secure the MPA/DDP/RDMAP Stream (i.e.,\n   integrity protect) or attempt to\
    \ provide physical security to prevent\n   man-in-the-middle type attacks.\n \
    \  The best protection against this form of attack is end-to-end\n   integrity\
    \ protection and authentication, such as IPsec, to prevent\n   spoofing or tampering.\
    \  If Stream or session level authentication and\n   integrity protection are\
    \ not used, then a man-in-the-middle attack\n   can occur, enabling spoofing and\
    \ tampering.\n   Another approach is to restrict access to only the local subnet/link\n\
    \   and provide some mechanism to limit access, such as physical security\n  \
    \ or 802.1.x.  This model is an extremely limited deployment scenario\n   and\
    \ will not be further examined here.\n"
- title: 9.1.2.  Eavesdropping
  contents:
  - "9.1.2.  Eavesdropping\n   Generally speaking, Stream confidentiality protects\
    \ against\n   eavesdropping.  Stream and/or session authentication and integrity\n\
    \   protection are a counter measurement against various spoofing and\n   tampering\
    \ attacks.  The effectiveness of authentication and integrity\n   against a specific\
    \ attack depend on whether the authentication is\n   machine-level authentication\
    \ (as the one provided by IPsec) or ULP\n   authentication.\n"
- title: 9.2.  Introduction to Security Options
  contents:
  - "9.2.  Introduction to Security Options\n   The following security services can\
    \ be applied to an MPA/DDP/RDMAP\n   Stream:\n   1.  Session confidentiality -\
    \ protects against eavesdropping.\n   2.  Per-packet data source authentication\
    \ - protects against the\n       following spoofing attacks: network-based impersonation,\
    \ Stream\n       hijacking, and man in the middle.\n   3.  Per-packet integrity\
    \ - protects against tampering done by\n       network-based modification of FPDUs\
    \ (indirectly affecting buffer\n       content through DDP services).\n   4. \
    \ Packet sequencing - protects against replay attacks, which is a\n       special\
    \ case of the above tampering attack.\n   If an MPA/DDP/RDMAP Stream may be subject\
    \ to impersonation attacks,\n   or Stream hijacking attacks, it is recommended\
    \ that the Stream be\n   authenticated, integrity protected, and protected from\
    \ replay\n   attacks.  It may use confidentiality protection to protect from\n\
    \   eavesdropping (in case the MPA/DDP/RDMAP Stream traverses a public\n   network).\n\
    \   IPsec is capable of providing the above security services for IP and\n   TCP\
    \ traffic.\n   ULP protocols may be able to provide part of the above security\n\
    \   services.  See [NFSv4CHAN] for additional information on a promising\n   approach\
    \ called \"channel binding\".  From [NFSv4CHAN]:\n       \"The concept of channel\
    \ bindings allows applications to prove\n       that the end-points of two secure\
    \ channels at different network\n       layers are the same by binding authentication\
    \ at one channel to\n       the session protection at the other channel.  The\
    \ use of channel\n       bindings allows applications to delegate session protection\
    \ to\n       lower layers, which may significantly improve performance for\n \
    \      some applications.\"\n"
- title: 9.3.  Using IPsec with MPA
  contents:
  - "9.3.  Using IPsec with MPA\n   IPsec can be used to protect against the packet\
    \ injection attacks\n   outlined above.  Because IPsec is designed to secure individual\
    \ IP\n   packets, MPA can run above IPsec without change.  IPsec packets are\n\
    \   processed (e.g., integrity checked and decrypted) in the order they\n   are\
    \ received, and an MPA receiver will process the decrypted FPDUs\n   contained\
    \ in these packets in the same manner as FPDUs contained in\n   unsecured IP packets.\n\
    \   MPA implementations MUST implement IPsec as described in Section 9.4\n   below.\
    \  The use of IPsec is up to ULPs and administrators.\n"
- title: 9.4.  Requirements for IPsec Encapsulation of MPA/DDP
  contents:
  - "9.4.  Requirements for IPsec Encapsulation of MPA/DDP\n   The IP Storage working\
    \ group has spent significant time and effort to\n   define the normative IPsec\
    \ requirements for IP storage [RFC3723].\n   Portions of that specification are\
    \ applicable to a wide variety of\n   protocols, including the RDDP protocol suite.\
    \  In order not to\n   replicate this effort, an MPA on TCP implementation MUST\
    \ follow the\n   requirements defined in RFC 3723, Sections 2.3 and 5, including\
    \ the\n   associated normative references for those sections.\n   Additionally,\
    \ since IPsec acceleration hardware may only be able to\n   handle a limited number\
    \ of active Internet Key Exchange Protocol\n   (IKE) Phase 2 security associations\
    \ (SAs), Phase 2 delete messages\n   MAY be sent for idle SAs, as a means of keeping\
    \ the number of active\n   Phase 2 SAs to a minimum.  The receipt of an IKE Phase\
    \ 2 delete\n   message MUST NOT be interpreted as a reason for tearing down a\n\
    \   DDP/RDMA Stream.  Rather, it is preferable to leave the Stream up,\n   and\
    \ if additional traffic is sent on it, to bring up another IKE\n   Phase 2 SA\
    \ to protect it.  This avoids the potential for continually\n   bringing Streams\
    \ up and down.\n   The IPsec requirements for RDDP are based on the version of\
    \ IPsec\n   specified in RFC 2401 [RFC2401] and related RFCs, as profiled by RFC\n\
    \   3723 [RFC3723], despite the existence of a newer version of IPsec\n   specified\
    \ in RFC 4301 [RFC4301] and related RFCs.  One of the\n   important early applications\
    \ of the RDDP protocols is their use with\n   iSCSI [iSER]; RDDP's IPsec requirements\
    \ follow those of IPsec in\n   order to facilitate that usage by allowing a common\
    \ profile of IPsec\n   to be used with iSCSI and the RDDP protocols.  In the future,\
    \ RFC\n   3723 may be updated to the newer version of IPsec; the IPsec security\n\
    \   requirements of any such update should apply uniformly to iSCSI and\n   the\
    \ RDDP protocols.\n   Note that there are serious security issues if IPsec is\
    \ not\n   implemented end-to-end.  For example, if IPsec is implemented as a\n\
    \   tunnel in the middle of the network, any hosts between the peer and\n   the\
    \ IPsec tunneling device can freely attack the unprotected Stream.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   No IANA actions are required by this document.\n\
    \   If a well-known port is chosen as the mechanism to identify a DDP on\n   MPA\
    \ on TCP, the well-known port must be registered with IANA.\n   Because the use\
    \ of the port is DDP specific, registration of the port\n   with IANA is left\
    \ to DDP.\n"
- title: Appendix A.  Optimized MPA-Aware TCP Implementations
  contents:
  - "Appendix A.  Optimized MPA-Aware TCP Implementations\n   This appendix is for\
    \ information only and is NOT part of the\n   standard.\n   This appendix covers\
    \ some Optimized MPA-aware TCP implementation\n   guidance to implementers.  It\
    \ is intended for those implementations\n   that want to send/receive as much\
    \ traffic as possible in an aligned\n   and zero-copy fashion.\n             \
    \      +-----------------------------------+\n                   | +-----------+\
    \ +-----------------+ |\n                   | | Optimized | | Other Protocols\
    \ | |\n                   | |  MPA/TCP  | +-----------------+ |\n            \
    \       | +-----------+        ||           |\n                   |         \\\
    \\     --- socket API --- |\n                   |          \\\\          ||  \
    \         |\n                   |           \\\\      +-----+         |\n    \
    \               |            \\\\     | TCP |         |\n                   |\
    \             \\\\    +-----+         |\n                   |              \\\\\
    \    //             |\n                   |             +-------+            \
    \ |\n                   |             |  IP   |             |\n              \
    \     |             +-------+             |\n                   +-----------------------------------+\n\
    \                Figure 11: Optimized MPA/TCP Implementation\n   The diagram above\
    \ shows a block diagram of a potential\n   implementation.  The network sub-system\
    \ in the diagram can support\n   traditional sockets-based connections using the\
    \ normal API as shown\n   on the right side of the diagram.  Connections for DDP/MPA/TCP\
    \ are\n   run using the facilities shown on the left side of the diagram.\n  \
    \ The DDP/MPA/TCP connections can be started using the facilities shown\n   on\
    \ the left side using some suitable API, or they can be initiated\n   using the\
    \ facilities shown on the right side and transitioned to the\n   left side at\
    \ the point in the connection setup where MPA goes to\n   \"Full MPA/DDP Operation\
    \ Phase\" as described in Section 7.1.2.\n   The optimized MPA/TCP implementations\
    \ (left side of diagram and\n   described below) are only applicable to MPA. \
    \ All other TCP\n   applications continue to use the standard TCP stacks and interfaces\n\
    \   shown in the right side of the diagram.\n"
- title: A.1.  Optimized MPA/TCP Transmitters
  contents:
  - "A.1.  Optimized MPA/TCP Transmitters\n   The various TCP RFCs allow considerable\
    \ choice in segmenting a TCP\n   stream.  In order to optimize FPDU recovery at\
    \ the MPA receiver, an\n   optimized MPA/TCP implementation uses additional segmentation\
    \ rules.\n   To provide optimum performance, an optimized MPA/TCP transmit side\n\
    \   implementation should be enabled to:\n   *   With an EMSS large enough to\
    \ contain the FPDU(s), segment the\n       outgoing TCP stream such that the first\
    \ octet of every TCP\n       segment begins with an FPDU.  Multiple FPDUs may\
    \ be packed into a\n       single TCP segment as long as they are entirely contained\
    \ in the\n       TCP segment.\n   *   Report the current EMSS from the TCP to\
    \ the MPA transmit layer.\n   There are exceptions to the above rule.  Once an\
    \ ULPDU is provided to\n   MPA, the MPA/TCP sender transmits it or fails the connection;\
    \ it\n   cannot be repudiated.  As a result, during changes in MTU and EMSS,\n\
    \   or when TCP's Receive Window size (RWIN) becomes too small, it may be\n  \
    \ necessary to send FPDUs that do not conform to the segmentation rule\n   above.\n\
    \   A possible, but less desirable, alternative is to use IP\n   fragmentation\
    \ on accepted FPDUs to deal with MTU reductions or\n   extremely small EMSS.\n\
    \   Even when alignment with TCP segments is lost, the sender still\n   formats\
    \ the FPDU according to FPDU format as shown in Figure 2.\n   On a retransmission,\
    \ TCP does not necessarily preserve original TCP\n   segmentation boundaries.\
    \  This can lead to the loss of FPDU Alignment\n   and containment within a TCP\
    \ segment during TCP retransmissions.  An\n   optimized MPA/TCP sender should\
    \ try to preserve original TCP\n   segmentation boundaries on a retransmission.\n"
- title: A.2.  Effects of Optimized MPA/TCP Segmentation
  contents:
  - "A.2.  Effects of Optimized MPA/TCP Segmentation\n   Optimized MPA/TCP senders\
    \ will fill TCP segments to the EMSS with a\n   single FPDU when a DDP message\
    \ is large enough.  Since the DDP\n   message may not exactly fit into TCP segments,\
    \ a \"message tail\" often\n   occurs that results in an FPDU that is smaller\
    \ than a single TCP\n   segment.  Additionally, some DDP messages may be considerably\
    \ shorter\n   than the EMSS.  If a small FPDU is sent in a single TCP segment,\
    \ the\n   result is a \"short\" TCP segment.\n   Applications expected to see\
    \ strong advantages from Direct Data\n   Placement include transaction-based applications\
    \ and throughput\n   applications.  Request/response protocols typically send\
    \ one FPDU per\n   TCP segment and then wait for a response.  Under these conditions,\n\
    \   these \"short\" TCP segments are an appropriate and expected effect of\n \
    \  the segmentation.\n   Another possibility is that the application might be\
    \ sending multiple\n   messages (FPDUs) to the same endpoint before waiting for\
    \ a response.\n   In this case, the segmentation policy would tend to reduce the\n\
    \   available connection bandwidth by under-filling the TCP segments.\n   Standard\
    \ TCP implementations often utilize the Nagle [RFC896]\n   algorithm to ensure\
    \ that segments are filled to the EMSS whenever the\n   round-trip latency is\
    \ large enough that the source stream can fully\n   fill segments before ACKs\
    \ arrive.  The algorithm does this by\n   delaying the transmission of TCP segments\
    \ until a ULP can fill a\n   segment, or until an ACK arrives from the far side.\
    \  The algorithm\n   thus allows for smaller segments when latencies are shorter\
    \ to keep\n   the ULP's end-to-end latency to reasonable levels.\n   The Nagle\
    \ algorithm is not mandatory to use [RFC1122].\n   When used with optimized MPA/TCP\
    \ stacks, Nagle and similar algorithms\n   can result in the \"packing\" of multiple\
    \ FPDUs into TCP segments.\n   If a \"message tail\", small DDP messages, or the\
    \ start of a larger DDP\n   message are available, MPA may pack multiple FPDUs\
    \ into TCP segments.\n   When this is done, the TCP segments can be more fully\
    \ utilized, but,\n   due to the size constraints of FPDUs, segments may not be\
    \ filled to\n   the EMSS.  A dynamic MULPDU that informs DDP of the size of the\n\
    \   remaining TCP segment space makes filling the TCP segment more\n   effective.\n\
    \       Note that MPA receivers do more processing of a TCP segment that\n   \
    \    contains multiple FPDUs; this may affect the performance of some\n      \
    \ receiver implementations.\n   It is up to the ULP to decide if Nagle is useful\
    \ with DDP/MPA.  Note\n   that many of the applications expected to take advantage\
    \ of MPA/DDP\n   prefer to avoid the extra delays caused by Nagle.  In such scenarios,\n\
    \   it is anticipated there will be minimal opportunity for packing at\n   the\
    \ transmitter and receivers may choose to optimize their\n   performance for this\
    \ anticipated behavior.\n   Therefore, the application is expected to set TCP\
    \ parameters such\n   that it can trade off latency and wire efficiency.  Implementations\n\
    \   should provide a connection option that disables Nagle for MPA/TCP\n   similar\
    \ to the way the TCP_NODELAY socket option is provided for a\n   traditional sockets\
    \ interface.\n   When latency is not critical, application is expected to leave\
    \ Nagle\n   enabled.  In this case, the TCP implementation may pack any available\n\
    \   FPDUs into TCP segments so that the segments are filled to the EMSS.\n   If\
    \ the amount of data available is not enough to fill the TCP segment\n   when\
    \ it is prepared for transmission, TCP can send the segment partly\n   filled,\
    \ or use the Nagle algorithm to wait for the ULP to post more\n   data.\n"
- title: A.3.  Optimized MPA/TCP Receivers
  contents:
  - "A.3.  Optimized MPA/TCP Receivers\n   When an MPA receive implementation and\
    \ the MPA-aware receive side TCP\n   implementation support handling out-of-order\
    \ ULPDUs, the TCP receive\n   implementation performs the following functions:\n\
    \   1)  The implementation passes incoming TCP segments to MPA as soon as\n  \
    \     they have been received and validated, even if not received in\n       order.\
    \  The TCP layer commits to keeping each segment before it\n       can be passed\
    \ to the MPA.  This means that the segment must have\n       passed the TCP, IP,\
    \ and lower layer data integrity validation\n       (i.e., checksum), must be\
    \ in the receive window, must be part of\n       the same epoch (if timestamps\
    \ are used to verify this), and must\n       have passed any other checks required\
    \ by TCP RFCs.\n       This is not to imply that the data must be completely ordered\n\
    \       before use.  An implementation can accept out-of-order segments,\n   \
    \    SACK them [RFC2018], and pass them to MPA immediately, before the\n     \
    \  reception of the segments needed to fill in the gaps.  MPA\n       expects\
    \ to utilize these segments when they are complete FPDUs or\n       can be combined\
    \ into complete FPDUs to allow the passing of\n       ULPDUs to DDP when they\
    \ arrive, independent of ordering.  DDP\n       uses the passed ULPDU to \"place\"\
    \ the DDP segments (see [DDP] for\n       more details).\n       Since MPA performs\
    \ a CRC calculation and other checks on received\n       FPDUs, the MPA/TCP implementation\
    \ ensures that any TCP segments\n       that duplicate data already received and\
    \ processed (as can happen\n       during TCP retries) do not overwrite already\
    \ received and\n       processed FPDUs.  This avoids the possibility that duplicate\
    \ data\n       may corrupt already validated FPDUs.\n   2)  The implementation\
    \ provides a mechanism to indicate the ordering\n       of TCP segments as the\
    \ sender transmitted them.  One possible\n       mechanism might be attaching\
    \ the TCP sequence number to each\n       segment.\n   3)  The implementation\
    \ also provides a mechanism to indicate when a\n       given TCP segment (and\
    \ the prior TCP stream) is complete.  One\n       possible mechanism might be\
    \ to utilize the leading (left) edge of\n       the TCP Receive Window.\n    \
    \   MPA uses the ordering and completion indications to inform DDP\n       when\
    \ a ULPDU is complete; MPA Delivers the FPDU to DDP.  DDP uses\n       the indications\
    \ to \"deliver\" its messages to the DDP consumer\n       (see [DDP] for more\
    \ details).\n       DDP on MPA utilizes the above two mechanisms to establish\
    \ the\n       Delivery semantics that DDP's consumers agree to.  These\n     \
    \  semantics are described fully in [DDP].  These include\n       requirements\
    \ on DDP's consumer to respect ownership of buffers\n       prior to the time\
    \ that DDP delivers them to the Consumer.\n   The use of SACK [RFC2018] significantly\
    \ improves network utilization\n   and performance and is therefore recommended.\
    \  When combined with the\n   out-of-order passing of segments to MPA and DDP,\
    \ significant\n   buffering and copying of received data can be avoided.\n"
- title: A.4.  Re-Segmenting Middleboxes and Non-Optimized MPA/TCP Senders
  contents:
  - "A.4.  Re-Segmenting Middleboxes and Non-Optimized MPA/TCP Senders\n   Since MPA\
    \ senders often start FPDUs on TCP segment boundaries, a\n   receiving optimized\
    \ MPA/TCP implementation may be able to optimize\n   the reception of data in\
    \ various ways.\n   However, MPA receivers MUST NOT depend on FPDU Alignment on\
    \ TCP\n   segment boundaries.\n   Some MPA senders may be unable to conform to\
    \ the sender requirements\n   because their implementation of TCP is not designed\
    \ with MPA in mind.\n   Even for optimized MPA/TCP senders, the network may contain\n\
    \   \"middleboxes\" which modify the TCP stream by changing the\n   segmentation.\
    \  This is generally interoperable with TCP and its users\n   and MPA must be\
    \ no exception.\n   The presence of Markers in MPA (when enabled) allows an optimized\n\
    \   MPA/TCP receiver to recover the FPDUs despite these obstacles,\n   although\
    \ it may be necessary to utilize additional buffering at the\n   receiver to do\
    \ so.\n   Some of the cases that a receiver may have to contend with are listed\n\
    \   below as a reminder to the implementer:\n   *   A single aligned and complete\
    \ FPDU, either in order or out of\n       order:  This can be passed to DDP as\
    \ soon as validated, and\n       Delivered when ordering is established.\n   *\
    \   Multiple FPDUs in a TCP segment, aligned and fully contained,\n       either\
    \ in order or out of order:  These can be passed to DDP as\n       soon as validated,\
    \ and Delivered when ordering is established.\n   *   Incomplete FPDU: The receiver\
    \ should buffer until the remainder\n       of the FPDU arrives.  If the remainder\
    \ of the FPDU is already\n       available, this can be passed to DDP as soon\
    \ as validated, and\n       Delivered when ordering is established.\n   *   Unaligned\
    \ FPDU start: The partial FPDU must be combined with its\n       preceding portion(s).\
    \  If the preceding parts are already\n       available, and the whole FPDU is\
    \ present, this can be passed to\n       DDP as soon as validated, and Delivered\
    \ when ordering is\n       established.  If the whole FPDU is not available, the\
    \ receiver\n       should buffer until the remainder of the FPDU arrives.\n  \
    \ *   Combinations of unaligned or incomplete FPDUs (and potentially\n       other\
    \ complete FPDUs) in the same TCP segment:  If any FPDU is\n       present in\
    \ its entirety, or can be completed with portions\n       already available, it\
    \ can be passed to DDP as soon as validated,\n       and Delivered when ordering\
    \ is established.\n"
- title: A.5.  Receiver Implementation
  contents:
  - "A.5.  Receiver Implementation\n   Transport & Network Layer Reassembly Buffers:\n\
    \   The use of reassembly buffers (either TCP reassembly buffers or IP\n   fragmentation\
    \ reassembly buffers) is implementation dependent.  When\n   MPA is enabled, reassembly\
    \ buffers are needed if out-of-order packets\n   arrive and Markers are not enabled.\
    \  Buffers are also needed if FPDU\n   alignment is lost or if IP fragmentation\
    \ occurs.  This is because the\n   incoming out-of-order segment may not contain\
    \ enough information for\n   MPA to process all of the FPDU.  For cases where\
    \ a re-segmenting\n   middlebox is present, or where the TCP sender is not optimized,\
    \ the\n   presence of Markers significantly reduces the amount of buffering\n\
    \   needed.\n   Recovery from IP fragmentation is transparent to the MPA Consumers.\n"
- title: A.5.1  Network Layer Reassembly Buffers
  contents:
  - "A.5.1  Network Layer Reassembly Buffers\n   The MPA/TCP implementation should\
    \ set the IP Don't Fragment bit at\n   the IP layer.  Thus, upon a path MTU change,\
    \ intermediate devices\n   drop the IP datagram if it is too large and reply with\
    \ an ICMP\n   message that tells the source TCP that the path MTU has changed.\n\
    \   This causes TCP to emit segments conformant with the new path MTU\n   size.\
    \  Thus, IP fragments under most conditions should never occur at\n   the receiver.\
    \  But it is possible.\n   There are several options for implementation of network\
    \ layer\n   reassembly buffers:\n   1.  drop any IP fragments, and reply with\
    \ an ICMP message according\n       to [RFC792] (fragmentation needed and DF set)\
    \ to tell the Remote\n       Peer to resize its TCP segment.\n   2.  support an\
    \ IP reassembly buffer, but have it of limited size\n       (possibly the same\
    \ size as the local link's MTU).  The end node\n       would normally never Advertise\
    \ a path MTU larger than the local\n       link MTU.  It is recommended that a\
    \ dropped IP fragment cause an\n       ICMP message to be generated according\
    \ to RFC 792.\n   3.  multiple IP reassembly buffers, of effectively unlimited\
    \ size.\n   4.  support an IP reassembly buffer for the largest IP datagram (64\n\
    \       KB).\n   5.  support for a large IP reassembly buffer that could span\
    \ multiple\n       IP datagrams.\n   An implementation should support at least\
    \ 2 or 3 above, to avoid\n   dropping packets that have traversed the entire fabric.\n\
    \   There is no end-to-end ACK for IP reassembly buffers, so there is no\n   flow\
    \ control on the buffer.  The only end-to-end ACK is a TCP ACK,\n   which can\
    \ only occur when a complete IP datagram is delivered to TCP.\n   Because of this,\
    \ under worst case, pathological scenarios, the\n   largest IP reassembly buffer\
    \ is the TCP receive window (to buffer\n   multiple IP datagrams that have all\
    \ been fragmented).\n   Note that if the Remote Peer does not implement re-segmentation\
    \ of\n   the data stream upon receiving the ICMP reply updating the path MTU,\n\
    \   it is possible to halt forward progress because the opposite peer\n   would\
    \ continue to retransmit using a transport segment size that is\n   too large.\
    \  This deadlock scenario is no different than if the fabric\n   MTU (not last-hop\
    \ MTU) was reduced after connection setup, and the\n   remote node's behavior\
    \ is not compliant with [RFC1122].\n"
- title: A.5.2  TCP Reassembly Buffers
  contents:
  - "A.5.2  TCP Reassembly Buffers\n   A TCP reassembly buffer is also needed.  TCP\
    \ reassembly buffers are\n   needed if FPDU Alignment is lost when using TCP with\
    \ MPA or when the\n   MPA FPDU spans multiple TCP segments.  Buffers are also\
    \ needed if\n   Markers are disabled and out-of-order packets arrive.\n   Since\
    \ lost FPDU Alignment often means that FPDUs are incomplete, an\n   MPA on TCP\
    \ implementation must have a reassembly buffer large enough\n   to recover an\
    \ FPDU that is less than or equal to the MTU of the\n   locally attached link\
    \ (this should be the largest possible Advertised\n   TCP path MTU).  If the MTU\
    \ is smaller than 140 octets, a buffer of at\n   least 140 octets long is needed\
    \ to support the minimum FPDU size.\n   The 140 octets allow for the minimum MULPDU\
    \ of 128, 2 octets of pad,\n   2 of ULPDU_Length, 4 of CRC, and space for a possible\
    \ Marker.  As\n   usual, additional buffering is likely to provide better performance.\n\
    \   Note that if the TCP segments were not stored, it would be possible\n   to\
    \ deadlock the MPA algorithm.  If the path MTU is reduced, FPDU\n   Alignment\
    \ requires the source TCP to re-segment the data stream to\n   the new path MTU.\
    \  The source MPA will detect this condition and\n   reduce the MPA segment size,\
    \ but any FPDUs already posted to the\n   source TCP will be re-segmented and\
    \ lose FPDU Alignment.  If the\n   destination does not support a TCP reassembly\
    \ buffer, these segments\n   can never be successfully transmitted and the protocol\
    \ deadlocks.\n   When a complete FPDU is received, processing continues normally.\n"
- title: Appendix B.  Analysis of MPA over TCP Operations
  contents:
  - "Appendix B.  Analysis of MPA over TCP Operations\n   This appendix is for information\
    \ only and is NOT part of the\n   standard.\n   This appendix is an analysis of\
    \ MPA on TCP and why it is useful to\n   integrate MPA with TCP (with modifications\
    \ to typical TCP\n   implementations) to reduce overall system buffering and overhead.\n\
    \   One of MPA's high-level goals is to provide enough information, when\n   combined\
    \ with the Direct Data Placement Protocol [DDP], to enable\n   out-of-order placement\
    \ of DDP payload into the final Upper Layer\n   Protocol (ULP) Buffer.  Note that\
    \ DDP separates the act of placing\n   data into a ULP Buffer from that of notifying\
    \ the ULP that the ULP\n   Buffer is available for use.  In DDP terminology, the\
    \ former is\n   defined as \"Placement\", and the later is defined as \"Delivery\"\
    .  MPA\n   supports in-order Delivery of the data to the ULP, including support\n\
    \   for Direct Data Placement in the final ULP Buffer location when TCP\n   segments\
    \ arrive out of order.  Effectively, the goal is to use the\n   pre-posted ULP\
    \ Buffers as the TCP receive buffer, where the\n   reassembly of the ULP Protocol\
    \ Data Unit (PDU) by TCP (with MPA and\n   DDP) is done in place, in the ULP Buffer,\
    \ with no data copies.\n   This appendix walks through the advantages and disadvantages\
    \ of the\n   TCP sender modifications proposed by MPA:\n   1) that MPA prefers\
    \ that the TCP sender to do Header Alignment, where\n      a TCP segment should\
    \ begin with an MPA Framing Protocol Data Unit\n      (FPDU) (if there is payload\
    \ present).\n   2) that there be an integral number of FPDUs in a TCP segment\
    \ (under\n      conditions where the path MTU is not changing).\n   This appendix\
    \ concludes that the scaling advantages of FPDU Alignment\n   are strong, based\
    \ primarily on fairly drastic TCP receive buffer\n   reduction requirements and\
    \ simplified receive handling.  The analysis\n   also shows that there is little\
    \ effect to TCP wire behavior.\n"
- title: B.1.  Assumptions
  contents:
  - 'B.1.  Assumptions

    '
- title: B.1.1  MPA Is Layered beneath DDP
  contents:
  - "B.1.1  MPA Is Layered beneath DDP\n   MPA is an adaptation layer between DDP\
    \ and TCP.  DDP requires\n   preservation of DDP segment boundaries and a CRC32c\
    \ digest covering\n   the DDP header and data.  MPA adds these features to the\
    \ TCP stream\n   so that DDP over TCP has the same basic properties as DDP over\
    \ SCTP.\n"
- title: B.1.2.  MPA Preserves DDP Message Framing
  contents:
  - "B.1.2.  MPA Preserves DDP Message Framing\n   MPA was designed as a framing layer\
    \ specifically for DDP and was not\n   intended as a general-purpose framing layer\
    \ for any other ULP using\n   TCP.\n   A framing layer allows ULPs using it to\
    \ receive indications from the\n   transport layer only when complete ULPDUs are\
    \ present.  As a framing\n   layer, MPA is not aware of the content of the DDP\
    \ PDU, only that it\n   has received and, if necessary, reassembled a complete\
    \ PDU for\n   Delivery to the DDP.\n"
- title: B.1.3.  The Size of the ULPDU Passed to MPA Is Less Than EMSS under
  contents:
  - "B.1.3.  The Size of the ULPDU Passed to MPA Is Less Than EMSS under\n       \
    \ Normal Conditions\n   To make reception of a complete DDP PDU on every received\
    \ segment\n   possible, DDP passes to MPA a PDU that is no larger than the EMSS\
    \ of\n   the underlying fabric.  Each FPDU that MPA creates contains\n   sufficient\
    \ information for the receiver to directly place the ULP\n   payload in the correct\
    \ location in the correct receive buffer.\n   Edge cases when this condition does\
    \ not occur are dealt with, but do\n   not need to be on the fast path.\n"
- title: B.1.4.  Out-of-Order Placement but NO Out-of-Order Delivery
  contents:
  - "B.1.4.  Out-of-Order Placement but NO Out-of-Order Delivery\n   DDP receives\
    \ complete DDP PDUs from MPA.  Each DDP PDU contains the\n   information necessary\
    \ to place its ULP payload directly in the\n   correct location in host memory.\n\
    \   Because each DDP segment is self-describing, it is possible for DDP\n   segments\
    \ received out of order to have their ULP payload placed\n   immediately in the\
    \ ULP receive buffer.\n   Data delivery to the ULP is guaranteed to be in the\
    \ order the data\n   was sent.  DDP only indicates data delivery to the ULP after\
    \ TCP has\n   acknowledged the complete byte stream.\n"
- title: B.2.  The Value of FPDU Alignment
  contents:
  - "B.2.  The Value of FPDU Alignment\n   Significant receiver optimizations can\
    \ be achieved when Header\n   Alignment and complete FPDUs are the common case.\
    \  The optimizations\n   allow utilizing significantly fewer buffers on the receiver\
    \ and less\n   computation per FPDU.  The net effect is the ability to build a\n\
    \   \"flow-through\" receiver that enables TCP-based solutions to scale to\n \
    \  10G and beyond in an economical way.  The optimizations are\n   especially\
    \ relevant to hardware implementations of receivers that\n   process multiple\
    \ protocol layers -- Data Link Layer (e.g., Ethernet),\n   Network and Transport\
    \ Layer (e.g., TCP/IP), and even some ULP on top\n   of TCP (e.g., MPA/DDP). \
    \ As network speed increases, there is an\n   increasing desire to use a hardware-based\
    \ receiver in order to\n   achieve an efficient high performance solution.\n \
    \  A TCP receiver, under worst-case conditions, has to allocate buffers\n   (BufferSizeTCP)\
    \ whose capacities are a function of the bandwidth-\n   delay product.  Thus:\n\
    \       BufferSizeTCP = K * bandwidth [octets/second] * Delay [seconds].\n   Where\
    \ bandwidth is the end-to-end bandwidth of the connection, delay\n   is the round-trip\
    \ delay of the connection, and K is an\n   implementation-dependent constant.\n\
    \   Thus, BufferSizeTCP scales with the end-to-end bandwidth (10x more\n   buffers\
    \ for a 10x increase in end-to-end bandwidth).  As this\n   buffering approach\
    \ may scale poorly for hardware or software\n   implementations alike, several\
    \ approaches allow reduction in the\n   amount of buffering required for high-speed\
    \ TCP communication.\n   The MPA/DDP approach is to enable the ULP's Buffer to\
    \ be used as the\n   TCP receive buffer.  If the application pre-posts a sufficient\
    \ amount\n   of buffering, and each TCP segment has sufficient information to\n\
    \   place the payload into the right application buffer, when an out-of-\n   order\
    \ TCP segment arrives it could potentially be placed directly in\n   the ULP Buffer.\
    \  However, placement can only be done when a complete\n   FPDU with the placement\
    \ information is available to the receiver, and\n   the FPDU contents contain\
    \ enough information to place the data into\n   the correct ULP Buffer (e.g.,\
    \ there is a DDP header available).\n   For the case when the FPDU is not aligned\
    \ with the TCP segment, it\n   may take, on average, 2 TCP segments to assemble\
    \ one FPDU.\n   Therefore, the receiver has to allocate BufferSizeNAF (Buffer\
    \ Size,\n   Non-Aligned FPDU) octets:\n       BufferSizeNAF = K1* EMSS * number_of_connections\
    \ + K2 * EMSS\n   Where K1 and K2 are implementation-dependent constants and EMSS\
    \ is\n   the effective maximum segment size.\n   For example, a 1 GB/sec link\
    \ with 10,000 connections and an EMSS of\n   1500 B would require 15 MB of memory.\
    \  Often the number of\n   connections used scales with the network speed, aggravating\
    \ the\n   situation for higher speeds.\n   FPDU Alignment would allow the receiver\
    \ to allocate BufferSizeAF\n   (Buffer Size, Aligned FPDU) octets:\n       BufferSizeAF\
    \ = K2 * EMSS\n   for the same conditions.  An FPDU Aligned receiver may require\
    \ memory\n   in the range of ~100s of KB -- which is feasible for an on-chip\n\
    \   memory and enables a \"flow-through\" design, in which the data flows\n  \
    \ through the network interface card (NIC) and is placed directly in\n   the destination\
    \ buffer.  Assuming most of the connections support\n   FPDU Alignment, the receiver\
    \ buffers no longer scale with number of\n   connections.\n   Additional optimizations\
    \ can be achieved in a balanced I/O sub-system\n   -- where the system interface\
    \ of the network controller provides\n   ample bandwidth as compared with the\
    \ network bandwidth.  For almost\n   twenty years this has been the case and the\
    \ trend is expected to\n   continue.  While Ethernet speeds have scaled by 1000\
    \ (from 10\n   megabit/sec to 10 gigabit/sec), I/O bus bandwidth of volume CPU\n\
    \   architectures has scaled from ~2 MB/sec to ~2 GB/sec (PC-XT bus to\n   PCI-X\
    \ DDR).  Under these conditions, the FPDU Alignment approach\n   allows BufferSizeAF\
    \ to be indifferent to network speed.  It is\n   primarily a function of the local\
    \ processing time for a given frame.\n   Thus, when the FPDU Alignment approach\
    \ is used, receive buffering is\n   expected to scale gracefully (i.e., less than\
    \ linear scaling) as\n   network speed is increased.\n"
- title: B.2.1.  Impact of Lack of FPDU Alignment on the Receiver Computational
  contents:
  - "B.2.1.  Impact of Lack of FPDU Alignment on the Receiver Computational\n    \
    \    Load and Complexity\n   The receiver must perform IP and TCP processing,\
    \ and then perform\n   FPDU CRC checks, before it can trust the FPDU header placement\n\
    \   information.  For simplicity of the description, the assumption is\n   that\
    \ an FPDU is carried in no more than 2 TCP segments.  In reality,\n   with no\
    \ FPDU Alignment, an FPDU can be carried by more than 2 TCP\n   segments (e.g.,\
    \ if the path MTU was reduced).\n   ----++-----------------------------++-----------------------++-----\n\
    \   +---||---------------+    +--------||--------+   +----------||----+\n   |\
    \   TCP Seg X-1      |    |     TCP Seg X    |   |  TCP Seg X+1   |\n   +---||---------------+\
    \    +--------||--------+   +----------||----+\n   ----++-----------------------------++-----------------------++-----\n\
    \                   FPDU #N-1                  FPDU #N\n     Figure 12: Non-Aligned\
    \ FPDU Freely Placed in TCP Octet Stream\n   The receiver algorithm for processing\
    \ TCP segments (e.g., TCP segment\n   #X in Figure 12) carrying non-aligned FPDUs\
    \ (in order or out of\n   order) includes:\n   Data Link Layer processing (whole\
    \ frame) -- typically including a CRC\n   calculation.\n       1.  Network Layer\
    \ processing (assuming not an IP fragment, the\n           whole Data Link Layer\
    \ frame contains one IP datagram.  IP\n           fragments should be reassembled\
    \ in a local buffer.  This is\n           not a performance optimization goal.)\n\
    \       2.  Transport Layer processing -- TCP protocol processing, header\n  \
    \         and checksum checks.\n           a.  Classify incoming TCP segment using\
    \ the 5 tuple (IP SRC,\n               IP DST, TCP SRC Port, TCP DST Port, protocol).\n\
    \       3.  Find FPDU message boundaries.\n           a.  Get MPA state information\
    \ for the connection.\n               If the TCP segment is in order, use the\
    \ receiver-managed\n               MPA state information to calculate where the\
    \ previous\n               FPDU message (#N-1) ends in the current TCP segment\
    \ X.\n               (previously, when the MPA receiver processed the first\n\
    \               part of FPDU #N-1, it calculated the number of bytes\n       \
    \        remaining to complete FPDU #N-1 by using the MPA Length\n           \
    \    field).\n                   Get the stored partial CRC for FPDU #N-1.\n \
    \                  Complete CRC calculation for FPDU #N-1 data (first\n      \
    \                 portion of TCP segment #X).\n                   Check CRC calculation\
    \ for FPDU #N-1.\n                   If no FPDU CRC errors, placement is allowed.\n\
    \                   Locate the local buffer for the first portion of\n       \
    \                FPDU#N-1, CopyData(local buffer of first portion\n          \
    \             of FPDU #N-1, host buffer address, length).\n                  \
    \ Compute host buffer address for second portion of\n                       FPDU\
    \ #N-1.\n                   CopyData (local buffer of second portion of FPDU #N-\n\
    \                       1, host buffer address for second portion,\n         \
    \              length).\n                   Calculate the octet offset into the\
    \ TCP segment for\n                       the next FPDU #N.\n                \
    \   Start calculation of CRC for available data for FPDU.\n                  \
    \     #N\n                   Store partial CRC results for FPDU #N.\n        \
    \           Store local buffer address of first portion of FPDU\n            \
    \           #N.\n                   No further action is possible on FPDU #N,\
    \ before it\n                       is completely received.\n               If\
    \ the TCP segment is out of order, the receiver must\n               buffer the\
    \ data until at least one complete FPDU is\n               received.  Typically,\
    \ buffering for more than one TCP\n               segment per connection is required.\
    \  Use the MPA-based\n               Markers to calculate where FPDU boundaries\
    \ are.\n                   When a complete FPDU is available, a similar\n    \
    \               procedure to the in-order algorithm above is used.\n         \
    \          There is additional complexity, though, because when\n            \
    \       the missing segment arrives, this TCP segment must be\n              \
    \     run through the CRC engine after the CRC is\n                   calculated\
    \ for the missing segment.\n   If we assume FPDU Alignment, the following diagram\
    \ and the algorithm\n   below apply.  Note that when using MPA, the receiver is\
    \ assumed to\n   actively detect presence or loss of FPDU Alignment for every\
    \ TCP\n   segment received.\n      +--------------------------+      +--------------------------+\n\
    \   +--|--------------------------+   +--|--------------------------+\n   |  |\
    \       TCP Seg X          |   |  |         TCP Seg X+1      |\n   +--|--------------------------+\
    \   +--|--------------------------+\n      +--------------------------+      +--------------------------+\n\
    \                FPDU #N                          FPDU #N+1\n      Figure 13:\
    \ Aligned FPDU Placed Immediately after TCP Header\n   The receiver algorithm\
    \ for FPDU Aligned frames (in order or out of\n   order) includes:\n       1)\
    \  Data Link Layer processing (whole frame) -- typically\n           including\
    \ a CRC calculation.\n       2)  Network Layer processing (assuming not an IP\
    \ fragment, the\n           whole Data Link Layer frame contains one IP datagram.\
    \  IP\n           fragments should be reassembled in a local buffer.  This is\n\
    \           not a performance optimization goal.)\n       3)  Transport Layer\
    \ processing -- TCP protocol processing, header\n           and checksum checks.\n\
    \           a.  Classify incoming TCP segment using the 5 tuple (IP SRC,\n   \
    \            IP DST, TCP SRC Port, TCP DST Port, protocol).\n       4)  Check\
    \ for Header Alignment (described in detail in Section\n           6).  Assuming\
    \ Header Alignment for the rest of the algorithm\n           below.\n        \
    \   a.  If the header is not aligned, see the algorithm defined\n            \
    \   in the prior section.\n       5)  If TCP segment is in order or out of order,\
    \ the MPA header is\n           at the beginning of the current TCP payload. \
    \ Get the FPDU\n           length from the FPDU header.\n       6)  Calculate\
    \ CRC over FPDU.\n       7)  Check CRC calculation for FPDU #N.\n       8)  If\
    \ no FPDU CRC errors, placement is allowed.\n       9)  CopyData(TCP segment #X,\
    \ host buffer address, length).\n       10) Loop to #5 until all the FPDUs in\
    \ the TCP segment are\n           consumed in order to handle FPDU packing.\n\
    \   Implementation note: In both cases, the receiver has to classify the\n   incoming\
    \ TCP segment and associate it with one of the flows it\n   maintains.  In the\
    \ case of no FPDU Alignment, the receiver is forced\n   to classify incoming traffic\
    \ before it can calculate the FPDU CRC.\n   In the case of FPDU Alignment, the\
    \ operations order is left to the\n   implementer.\n   The FPDU Aligned receiver\
    \ algorithm is significantly simpler.  There\n   is no need to locally buffer\
    \ portions of FPDUs.  Accessing state\n   information is also substantially simplified\
    \ -- the normal case does\n   not require retrieving information to find out where\
    \ an FPDU starts\n   and ends or retrieval of a partial CRC before the CRC calculation\
    \ can\n   commence.  This avoids adding internal latencies, having multiple\n\
    \   data passes through the CRC machine, or scheduling multiple commands\n   for\
    \ moving the data to the host buffer.\n   The aligned FPDU approach is useful\
    \ for in-order and out-of-order\n   reception.  The receiver can use the same\
    \ mechanisms for data storage\n   in both cases, and only needs to account for\
    \ when all the TCP\n   segments have arrived to enable Delivery.  The Header Alignment,\n\
    \   along with the high probability that at least one complete FPDU is\n   found\
    \ with every TCP segment, allows the receiver to perform data\n   placement for\
    \ out-of-order TCP segments with no need for intermediate\n   buffering.  Essentially,\
    \ the TCP receive buffer has been eliminated\n   and TCP reassembly is done in\
    \ place within the ULP Buffer.\n   In case FPDU Alignment is not found, the receiver\
    \ should follow the\n   algorithm for non-aligned FPDU reception, which may be\
    \ slower and\n   less efficient.\n"
- title: B.2.2.  FPDU Alignment Effects on TCP Wire Protocol
  contents:
  - "B.2.2.  FPDU Alignment Effects on TCP Wire Protocol\n   In an optimized MPA/TCP\
    \ implementation, TCP exposes its EMSS to MPA.\n   MPA uses the EMSS to calculate\
    \ its MULPDU, which it then exposes to\n   DDP, its ULP.  DDP uses the MULPDU\
    \ to segment its payload so that\n   each FPDU sent by MPA fits completely into\
    \ one TCP segment.  This has\n   no impact on wire protocol, and exposing this\
    \ information is already\n   supported on many TCP implementations, including\
    \ all modern flavors\n   of BSD networking, through the TCP_MAXSEG socket option.\n\
    \   In the common case, the ULP (i.e., DDP over MPA) messages provided to\n  \
    \ the TCP layer are segmented to MULPDU size.  It is assumed that the\n   ULP\
    \ message size is bounded by MULPDU, such that a single ULP message\n   can be\
    \ encapsulated in a single TCP segment.  Therefore, in the\n   common case, there\
    \ is no increase in the number of TCP segments\n   emitted.  For smaller ULP messages,\
    \ the sender can also apply\n   packing, i.e., the sender packs as many complete\
    \ FPDUs as possible\n   into one TCP segment.  The requirement to always have\
    \ a complete FPDU\n   may increase the number of TCP segments emitted.  Typically,\
    \ a ULP\n   message size varies from a few bytes to multiple EMSSs (e.g., 64\n\
    \   Kbytes).  In some cases, the ULP may post more than one message at a\n   time\
    \ for transmission, giving the sender an opportunity for packing.\n   In the case\
    \ where more than one FPDU is available for transmission\n   and the FPDUs are\
    \ encapsulated into a TCP segment and there is no\n   room in the TCP segment\
    \ to include the next complete FPDU, another\n   TCP segment is sent.  In this\
    \ corner case, some of the TCP segments\n   are not full size.  In the worst-case\
    \ scenario, the ULP may choose an\n   FPDU size that is EMSS/2 +1 and has multiple\
    \ messages available for\n   transmission.  For this poor choice of FPDU size,\
    \ the average TCP\n   segment size is therefore about 1/2 of the EMSS and the\
    \ number of TCP\n   segments emitted is approaching 2x of what is possible without\
    \ the\n   requirement to encapsulate an integer number of complete FPDUs in\n\
    \   every TCP segment.  This is a dynamic situation that only lasts for\n   the\
    \ duration where the sender ULP has multiple non-optimal messages\n   for transmission\
    \ and this causes a minor impact on the wire\n   utilization.\n   However, it\
    \ is not expected that requiring FPDU Alignment will have a\n   measurable impact\
    \ on wire behavior of most applications.  Throughput\n   applications with large\
    \ I/Os are expected to take full advantage of\n   the EMSS.  Another class of\
    \ applications with many small outstanding\n   buffers (as compared to EMSS) is\
    \ expected to use packing when\n   applicable.  Transaction-oriented applications\
    \ are also optimal.\n   TCP retransmission is another area that can affect sender\
    \ behavior.\n   TCP supports retransmission of the exact, originally transmitted\n\
    \   segment (see [RFC793], Sections 2.6 and 3.7 (under \"Managing the\n   Window\"\
    ) and [RFC1122], Section 4.2.2.15).  In the unlikely event\n   that part of the\
    \ original segment has been received and acknowledged\n   by the Remote Peer (e.g.,\
    \ a re-segmenting middlebox, as documented in\n   Appendix A.4, Re-Segmenting\
    \ Middleboxes and Non-Optimized MPA/TCP\n   Senders), a better available bandwidth\
    \ utilization may be possible by\n   retransmitting only the missing octets. \
    \ If an optimized MPA/TCP\n   retransmits complete FPDUs, there may be some marginal\
    \ bandwidth\n   loss.\n   Another area where a change in the TCP segment number\
    \ may have impact\n   is that of slow start and congestion avoidance.  Slow-start\n\
    \   exponential increase is measured in segments per second, as the\n   algorithm\
    \ focuses on the overhead per segment at the source for\n   congestion that eventually\
    \ results in dropped segments.  Slow-start\n   exponential bandwidth growth for\
    \ optimized MPA/TCP is similar to any\n   TCP implementation.  Congestion avoidance\
    \ allows for a linear growth\n   in available bandwidth when recovering after\
    \ a packet drop.  Similar\n   to the analysis for slow start, optimized MPA/TCP\
    \ doesn't change the\n   behavior of the algorithm.  Therefore, the average size\
    \ of the\n   segment versus EMSS is not a major factor in the assessment of the\n\
    \   bandwidth growth for a sender.  Both slow start and congestion\n   avoidance\
    \ for an optimized MPA/TCP will behave similarly to any TCP\n   sender and allow\
    \ an optimized MPA/TCP to enjoy the theoretical\n   performance limits of the\
    \ algorithms.\n   In summary, the ULP messages generated at the sender (e.g.,\
    \ the\n   amount of messages grouped for every transmission request) and\n   message\
    \ size distribution has the most significant impact over the\n   number of TCP\
    \ segments emitted.  The worst-case effect for certain\n   ULPs (with average\
    \ message size of EMSS/2+1 to EMSS) is bounded by an\n   increase of up to 2x\
    \ in the number of TCP segments and acknowledges.\n   In reality, the effect is\
    \ expected to be marginal.\n"
- title: Appendix C.  IETF Implementation Interoperability with RDMA Consortium
  contents:
  - "Appendix C.  IETF Implementation Interoperability with RDMA Consortium\n    \
    \         Protocols\n   This appendix is for information only and is NOT part\
    \ of the\n   standard.\n   This appendix covers methods of making MPA implementations\n\
    \   interoperate with both IETF and RDMA Consortium versions of the\n   protocols.\n\
    \   The RDMA Consortium created early specifications of the MPA/DDP/RDMA\n   protocols,\
    \ and some manufacturers created implementations of those\n   protocols before\
    \ the IETF versions were finalized.  These protocols\n   are very similar to the\
    \ IETF versions making it possible for\n   implementations to be created or modified\
    \ to support either set of\n   specifications.\n   For those interested, the RDMA\
    \ Consortium protocol documents (draft-\n   culley-iwarp-mpa-v1.0.pdf [RDMA-MPA],\
    \ draft-shah-iwarp-ddp-v1.0.pdf\n   [RDMA-DDP], and draft-recio-iwarp-rdmac-v1.0.pdf\
    \ [RDMA-RDMAC]) can be\n   obtained at http://www.rdmaconsortium.org/home.\n \
    \  In this section, implementations of MPA/DDP/RDMA that conform to the\n   RDMAC\
    \ specifications are called RDMAC RNICs.  Implementations of\n   MPA/DDP/RDMA\
    \ that conform to the IETF RFCs are called IETF RNICs.\n   Without the exchange\
    \ of MPA Request/Reply Frames, there is no\n   standard mechanism for enabling\
    \ RDMAC RNICs to interoperate with IETF\n   RNICs.  Even if a ULP uses a well-known\
    \ port to start an IETF RNIC\n   immediately in RDMA mode (i.e., without exchanging\
    \ the MPA\n   Request/Reply messages), there is no reason to believe an IETF RNIC\n\
    \   will interoperate with an RDMAC RNIC because of the differences in\n   the\
    \ version number in the DDP and RDMAP headers on the wire.\n   Therefore, the\
    \ ULP or other supporting entity at the RDMAC RNIC must\n   implement MPA Request/Reply\
    \ Frames on behalf of the RNIC in order to\n   negotiate the connection parameters.\
    \  The following section describes\n   the results following the exchange of the\
    \ MPA Request/Reply Frames\n   before the conversion from streaming to RDMA mode.\n"
- title: C.1.  Negotiated Parameters
  contents:
  - "C.1.  Negotiated Parameters\n   Three types of RNICs are considered:\n   Upgraded\
    \ RDMAC RNIC - an RNIC implementing the RDMAC protocols that\n   has a ULP or\
    \ other supporting entity that exchanges the MPA\n   Request/Reply Frames in streaming\
    \ mode before the conversion to RDMA\n   mode.\n   Non-permissive IETF RNIC -\
    \ an RNIC implementing the IETF protocols\n   that is not capable of implementing\
    \ the RDMAC protocols.  Such an\n   RNIC can only interoperate with other IETF\
    \ RNICs.\n   Permissive IETF RNIC - an RNIC implementing the IETF protocols that\n\
    \   is capable of implementing the RDMAC protocols on a per-connection\n   basis.\n\
    \   The Permissive IETF RNIC is recommended for those implementers that\n   want\
    \ maximum interoperability with other RNIC implementations.\n   The values used\
    \ by these three RNIC types for the MPA, DDP, and RDMAP\n   versions as well as\
    \ MPA Markers and CRC are summarized in Figure 14.\n    +----------------++-----------+-----------+-----------+-----------+\n\
    \    | RNIC TYPE      || DDP/RDMAP |    MPA    |    MPA    |    MPA    |\n   \
    \ |                ||  Version  | Revision  |  Markers  |    CRC    |\n    +----------------++-----------+-----------+-----------+-----------+\n\
    \    +----------------++-----------+-----------+-----------+-----------+\n   \
    \ | RDMAC          ||     0     |     0     |     1     |     1     |\n    | \
    \               ||           |           |           |           |\n    +----------------++-----------+-----------+-----------+-----------+\n\
    \    | IETF           ||     1     |     1     |  0 or 1   |  0 or 1   |\n   \
    \ | Non-permissive ||           |           |           |           |\n    +----------------++-----------+-----------+-----------+-----------+\n\
    \    | IETF           ||  1 or 0   |  1 or 0   |  0 or 1   |  0 or 1   |\n   \
    \ | permissive     ||           |           |           |           |\n    +----------------++-----------+-----------+-----------+-----------+\n\
    \           Figure 14: Connection Parameters for the RNIC Types\n            for\
    \ MPA Markers and MPA CRC, enabled=1, disabled=0.\n   It is assumed there is no\
    \ mixing of versions allowed between MPA,\n   DDP, and RDMAP.  The RNIC either\
    \ generates the RDMAC protocols on the\n   wire (version is zero) or uses the\
    \ IETF protocols (version is one).\n   During the exchange of the MPA Request/Reply\
    \ Frames, each peer\n   provides its MPA Revision, Marker preference (M: 0=disabled,\n\
    \   1=enabled), and CRC preference.  The MPA Revision provided in the MPA\n  \
    \ Request Frame and the MPA Reply Frame may differ.\n   From the information in\
    \ the MPA Request/Reply Frames, each side sets\n   the Version field (V: 0=RDMAC,\
    \ 1=IETF) of the DDP/RDMAP protocols as\n   well as the state of the Markers for\
    \ each half connection.  Between\n   DDP and RDMAP, no mixing of versions is allowed.\
    \  Moreover, the DDP\n   and RDMAP version MUST be identical in the two directions.\
    \  The RNIC\n   either generates the RDMAC protocols on the wire (version is zero)\
    \ or\n   uses the IETF protocols (version is one).\n   In the following sections,\
    \ the figures do not discuss CRC negotiation\n   because there is no interoperability\
    \ issue for CRCs.  Since the RDMAC\n   RNIC will always request CRC use, then,\
    \ according to the IETF MPA\n   specification, both peers MUST generate and check\
    \ CRCs.\n"
- title: C.2.  RDMAC RNIC and Non-Permissive IETF RNIC
  contents:
  - "C.2.  RDMAC RNIC and Non-Permissive IETF RNIC\n   Figure 15 shows that a Non-permissive\
    \ IETF RNIC cannot interoperate\n   with an RDMAC RNIC, despite the fact that\
    \ both peers exchange MPA\n   Request/Reply Frames.  For a Non-permissive IETF\
    \ RNIC, the MPA\n   negotiation has no effect on the DDP/RDMAP version and it\
    \ is unable\n   to interoperate with the RDMAC RNIC.\n   The rows in the figure\
    \ show the state of the Marker field in the MPA\n   Request Frame sent by the\
    \ MPA Initiator.  The columns show the state\n   of the Marker field in the MPA\
    \ Reply Frame sent by the MPA Responder.\n   Each type of RNIC is shown as an\
    \ Initiator and a Responder.  The\n   connection results are shown in the lower\
    \ right corner, at the\n   intersection of the different RNIC types, where V=0\
    \ is the RDMAC\n   DDP/RDMAP version, V=1 is the IETF DDP/RDMAC version, M=0 means\
    \ MPA\n   Markers are disabled, and M=1 means MPA Markers are enabled.  The\n\
    \   negotiated Marker state is shown as X/Y, for the receive direction of\n  \
    \ the Initiator/Responder.\n          +---------------------------++-----------------------+\n\
    \          |   MPA                     ||          MPA          |\n          |\
    \ CONNECT                   ||       Responder       |\n          |   MODE  +-----------------++-------+---------------+\n\
    \          |         |   RNIC          || RDMAC |     IETF      |\n          |\
    \         |   TYPE          ||       | Non-permissive|\n          |         |\
    \          +------++-------+-------+-------+\n          |         |          |MARKER||\
    \ M=1   | M=0   |  M=1  |\n          +---------+----------+------++-------+-------+-------+\n\
    \          +---------+----------+------++-------+-------+-------+\n          |\
    \         |   RDMAC  | M=1  || V=0   | close | close |\n          |         |\
    \          |      || M=1/1 |       |       |\n          |         +----------+------++-------+-------+-------+\n\
    \          |   MPA   |          | M=0  || close | V=1   | V=1   |\n          |Initiator|\
    \   IETF   |      ||       | M=0/0 | M=0/1 |\n          |         |Non-perms.+------++-------+-------+-------+\n\
    \          |         |          | M=1  || close | V=1   | V=1   |\n          |\
    \         |          |      ||       | M=1/0 | M=1/1 |\n          +---------+----------+------++-------+-------+-------+\n\
    \           Figure 15: MPA Negotiation between an RDMAC RNIC and\n           \
    \           a Non-Permissive IETF RNIC\n"
- title: C.2.1.  RDMAC RNIC Initiator
  contents:
  - "C.2.1.  RDMAC RNIC Initiator\n   If the RDMAC RNIC is the MPA Initiator, its\
    \ ULP sends an MPA Request\n   Frame with Rev field set to zero and the M and\
    \ C bits set to one.\n   Because the Non-permissive IETF RNIC cannot dynamically\
    \ downgrade the\n   version number it uses for DDP and RDMAP, it would send an\
    \ MPA Reply\n   Frame with the Rev field equal to one and then gracefully close\
    \ the\n   connection.\n"
- title: C.2.2.  Non-Permissive IETF RNIC Initiator
  contents:
  - "C.2.2.  Non-Permissive IETF RNIC Initiator\n   If the Non-permissive IETF RNIC\
    \ is the MPA Initiator, it sends an MPA\n   Request Frame with Rev field equal\
    \ to one.  The ULP or supporting\n   entity for the RDMAC RNIC responds with an\
    \ MPA Reply Frame that has\n   the Rev field equal to zero and the M bit set to\
    \ one.  The Non-\n   permissive IETF RNIC will gracefully close the connection\
    \ after it\n   reads the incompatible Rev field in the MPA Reply Frame.\n"
- title: C.2.3.  RDMAC RNIC and Permissive IETF RNIC
  contents:
  - "C.2.3.  RDMAC RNIC and Permissive IETF RNIC\n   Figure 16 shows that a Permissive\
    \ IETF RNIC can interoperate with an\n   RDMAC RNIC regardless of its Marker preference.\
    \  The figure uses the\n   same format as shown with the Non-permissive IETF RNIC.\n\
    \          +---------------------------++-----------------------+\n          |\
    \   MPA                     ||          MPA          |\n          | CONNECT  \
    \                 ||       Responder       |\n          |   MODE  +-----------------++-------+---------------+\n\
    \          |         |   RNIC          || RDMAC |     IETF      |\n          |\
    \         |   TYPE          ||       |  Permissive   |\n          |         |\
    \          +------++-------+-------+-------+\n          |         |          |MARKER||\
    \ M=1   | M=0   | M=1   |\n          +---------+----------+------++-------+-------+-------+\n\
    \          +---------+----------+------++-------+-------+-------+\n          |\
    \         |   RDMAC  | M=1  || V=0   | N/A   | V=0   |\n          |         |\
    \          |      || M=1/1 |       | M=1/1 |\n          |         +----------+------++-------+-------+-------+\n\
    \          |   MPA   |          | M=0  || V=0   | V=1   | V=1   |\n          |Initiator|\
    \   IETF   |      || M=1/1 | M=0/0 | M=0/1 |\n          |         |Permissive+------++-------+-------+-------+\n\
    \          |         |          | M=1  || V=0   | V=1   | V=1   |\n          |\
    \         |          |      || M=1/1 | M=1/0 | M=1/1 |\n          +---------+----------+------++-------+-------+-------+\n\
    \           Figure 16: MPA Negotiation between an RDMAC RNIC and\n           \
    \              a Permissive IETF RNIC\n   A truly Permissive IETF RNIC will recognize\
    \ an RDMAC RNIC from the\n   Rev field of the MPA Req/Rep Frames and then adjust\
    \ its receive\n   Marker state and DDP/RDMAP version to accommodate the RDMAC\
    \ RNIC.  As\n   a result, as an MPA Responder, the Permissive IETF RNIC will never\n\
    \   return an MPA Reply Frame with the M bit set to zero.  This case is\n   shown\
    \ as a not applicable (N/A) in Figure 16.\n"
- title: C.2.4.  RDMAC RNIC Initiator
  contents:
  - "C.2.4.  RDMAC RNIC Initiator\n   When the RDMAC RNIC is the MPA Initiator, its\
    \ ULP or other supporting\n   entity prepares an MPA Request message and sets\
    \ the revision to zero\n   and the M bit and C bit to one.\n   The Permissive\
    \ IETF Responder receives the MPA Request message and\n   checks the revision\
    \ field.  Since it is capable of generating RDMAC\n   DDP/RDMAP headers, it sends\
    \ an MPA Reply message with revision set to\n   zero and the M and C bits set\
    \ to one.  The Responder must inform its\n   ULP that it is generating version\
    \ zero DDP/RDMAP messages.\n"
- title: C.2.5  Permissive IETF RNIC Initiator
  contents:
  - "C.2.5  Permissive IETF RNIC Initiator\n   If the Permissive IETF RNIC is the\
    \ MPA Initiator, it prepares the MPA\n   Request Frame setting the Rev field to\
    \ one.  Regardless of the value\n   of the M bit in the MPA Request Frame, the\
    \ ULP or other supporting\n   entity for the RDMAC RNIC will create an MPA Reply\
    \ Frame with Rev\n   equal to zero and the M bit set to one.\n   When the Initiator\
    \ reads the Rev field of the MPA Reply Frame and\n   finds that its peer is an\
    \ RDMAC RNIC, it must inform its ULP that it\n   should generate version zero\
    \ DDP/RDMAP messages and enable MPA\n   Markers and CRC.\n"
- title: C.3.  Non-Permissive IETF RNIC and Permissive IETF RNIC
  contents:
  - "C.3.  Non-Permissive IETF RNIC and Permissive IETF RNIC\n   For completeness,\
    \ Figure 17 below shows the results of MPA\n   negotiation between a Non-permissive\
    \ IETF RNIC and a Permissive IETF\n   RNIC.  The important point from this figure\
    \ is that an IETF RNIC\n   cannot detect whether its peer is a Permissive or Non-permissive\n\
    \   RNIC.\n      +---------------------------++-------------------------------+\n\
    \      |   MPA                     ||              MPA              |\n      |\
    \ CONNECT                   ||            Responder          |\n      |   MODE\
    \  +-----------------++---------------+---------------+\n      |         |   RNIC\
    \          ||     IETF      |     IETF      |\n      |         |   TYPE      \
    \    || Non-permissive|  Permissive   |\n      |         |          +------++-------+-------+-------+-------+\n\
    \      |         |          |MARKER|| M=0   | M=1   | M=0   | M=1   |\n      +---------+----------+------++-------+-------+-------+-------+\n\
    \      +---------+----------+------++-------+-------+-------+-------+\n      |\
    \         |          | M=0  || V=1   | V=1   | V=1   | V=1   |\n      |      \
    \   |   IETF   |      || M=0/0 | M=0/1 | M=0/0 | M=0/1 |\n      |         |Non-perms.+------++-------+-------+-------+-------+\n\
    \      |         |          | M=1  || V=1   | V=1   | V=1   | V=1   |\n      |\
    \         |          |      || M=1/0 | M=1/1 | M=1/0 | M=1/1 |\n      |   MPA\
    \   +----------+------++-------+-------+-------+-------+\n      |Initiator|  \
    \        | M=0  || V=1   | V=1   | V=1   | V=1   |\n      |         |   IETF \
    \  |      || M=0/0 | M=0/1 | M=0/0 | M=0/1 |\n      |         |Permissive+------++-------+-------+-------+-------+\n\
    \      |         |          | M=1  || V=1   | V=1   | V=1   | V=1   |\n      |\
    \         |          |      || M=1/0 | M=1/1 | M=1/0 | M=1/1 |\n      +---------+----------+------++-------+-------+-------+-------+\n\
    \    Figure 17: MPA negotiation between a Non-permissive IETF RNIC and a\n   \
    \                        Permissive IETF RNIC.\n"
- title: Normative References
  contents:
  - "Normative References\n   [iSCSI]      Satran, J., Meth, K., Sapuntzakis, C.,\
    \ Chadalapaka, M.,\n                and E. Zeidner, \"Internet Small Computer\
    \ Systems\n                Interface (iSCSI)\", RFC 3720, April 2004.\n   [RFC1191]\
    \    Mogul, J. and S. Deering, \"Path MTU discovery\", RFC\n                1191,\
    \ November 1990.\n   [RFC2018]    Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow,\
    \ \"TCP\n                Selective Acknowledgment Options\", RFC 2018, October\n\
    \                1996.\n   [RFC2119]    Bradner, S., \"Key words for use in RFCs\
    \ to Indicate\n                Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [RFC2401]    Kent, S. and R. Atkinson, \"Security Architecture for the\n \
    \               Internet Protocol\", RFC 2401, November 1998.\n   [RFC3723]  \
    \  Aboba, B., Tseng, J., Walker, J., Rangan, V., and F.\n                Travostino,\
    \ \"Securing Block Storage Protocols over IP\",\n                RFC 3723, April\
    \ 2004.\n   [RFC793]     Postel, J., \"Transmission Control Protocol\", STD 7,\
    \ RFC\n                793, September 1981.\n   [RDMASEC]    Pinkerton, J. and\
    \ E. Deleganes, \"Direct Data Placement\n                Protocol (DDP) / Remote\
    \ Direct Memory Access Protocol\n                (RDMAP) Security\", RFC 5042,\
    \ October 2007.\n"
- title: Informative References
  contents:
  - "Informative References\n   [APPL]       Bestler, C. and L. Coene, \"Applicability\
    \ of Remote\n                Direct Memory Access Protocol (RDMA) and Direct Data\n\
    \                Placement (DDP)\", RFC 5045, October 2007.\n   [CRCTCP]     Stone\
    \ J., Partridge, C., \"When the CRC and TCP checksum\n                disagree\"\
    , ACM Sigcomm, Sept. 2000.\n   [DAT-API]    DAT Collaborative, \"kDAPL (Kernel\
    \ Direct Access\n                Programming Library) and uDAPL (User Direct Access\n\
    \                Programming Library)\", Http://www.datcollaborative.org.\n  \
    \ [DDP]        Shah, H., Pinkerton, J., Recio, R., and P. Culley,\n          \
    \      \"Direct Data Placement over Reliable Transports\", RFC\n             \
    \   5041, October 2007.\n   [iSER]       Ko, M., Chadalapaka, M., Hufferd, J.,\
    \ Elzur, U., Shah,\n                H., and P. Thaler, \"Internet Small Computer\
    \ System\n                Interface (iSCSI) Extensions for Remote Direct Memory\n\
    \                Access (RDMA)\" RFC 5046, October 2007.\n   [IT-API]     The\
    \ Open Group, \"Interconnect Transport API (IT-API)\"\n                Version\
    \ 2.1, http://www.opengroup.org.\n   [NFSv4CHAN]  Williams, N., \"On the Use of\
    \ Channel Bindings to Secure\n                Channels\", Work in Progress, June\
    \ 2006.\n   [RDMA-DDP]   \"Direct Data Placement over Reliable Transports (Version\n\
    \                1.0)\", RDMA Consortium, October 2002,\n                <http://www.rdmaconsortium.org/home/draft-shah-iwarp-\n\
    \                ddp-v1.0.pdf>.\n   [RDMA-MPA]   \"Marker PDU Aligned Framing\
    \ for TCP Specification\n                (Version 1.0)\", RDMA Consortium, October\
    \ 2002,\n                <http://www.rdmaconsortium.org/home/draft-culley-iwarp-\n\
    \                mpa-v1.0.pdf>.\n   [RDMA-RDMAC] \"An RDMA Protocol Specification\
    \ (Version 1.0)\", RDMA\n                Consortium, October 2002,\n         \
    \       <http://www.rdmaconsortium.org/home/draft-recio-iwarp-\n             \
    \   rdmac-v1.0.pdf>.\n   [RDMAP]      Recio, R., Culley, P., Garcia, D., Hilland,\
    \ J., and B.\n                Metzler, \"A Remote Direct Memory Access Protocol\n\
    \                Specification\", RFC 5040, October 2007.\n   [RFC792]     Postel,\
    \ J., \"Internet Control Message Protocol\", STD 5,\n                RFC 792,\
    \ September 1981.\n   [RFC896]     Nagle, J., \"Congestion control in IP/TCP internetworks\"\
    ,\n                RFC 896, January 1984.\n   [RFC1122]    Braden, R., \"Requirements\
    \ for Internet Hosts -\n                Communication Layers\", STD 3, RFC 1122,\
    \ October 1989.\n   [RFC4960]    Stewart, R., Ed., \"Stream Control Transmission\n\
    \                Protocol\", RFC 4960, September 2007.\n   [RFC4296]    Bailey,\
    \ S. and T. Talpey, \"The Architecture of Direct\n                Data Placement\
    \ (DDP) and Remote Direct Memory Access\n                (RDMA) on Internet Protocols\"\
    , RFC 4296, December 2005.\n   [RFC4297]    Romanow, A., Mogul, J., Talpey, T.,\
    \ and S. Bailey,\n                \"Remote Direct Memory Access (RDMA) over IP\
    \ Problem\n                Statement\", RFC 4297, December 2005.\n   [RFC4301]\
    \    Kent, S. and K. Seo, \"Security Architecture for the\n                Internet\
    \ Protocol\", RFC 4301, December 2005.\n   [VERBS-RMDA] \"RDMA Protocol Verbs\
    \ Specification\", RDMA Consortium\n                standard, April 2003, <http://www.rdmaconsortium.org/\n\
    \                home/draft-hilland-iwarp-verbs-v1.0-RDMAC.pdf>.\n"
- title: Contributors
  contents:
  - "Contributors\n   Dwight Barron\n   Hewlett-Packard Company\n   20555 SH 249\n\
    \   Houston, TX 77070-2698 USA\n   Phone: 281-514-2769\n   EMail: dwight.barron@hp.com\n\
    \   Jeff Chase\n   Department of Computer Science\n   Duke University\n   Durham,\
    \ NC 27708-0129 USA\n   Phone: +1 919 660 6559\n   EMail: chase@cs.duke.edu\n\
    \   Ted Compton\n   EMC Corporation\n   Research Triangle Park, NC 27709 USA\n\
    \   Phone: 919-248-6075\n   EMail: compton_ted@emc.com\n   Dave Garcia\n   24100\
    \ Hutchinson Rd.\n   Los Gatos, CA  95033\n   Phone: 831 247 4464\n   EMail: Dave.Garcia@StanfordAlumni.org\n\
    \   Hari Ghadia\n   Gen10 Technology, Inc.\n   1501 W Shady Grove Road\n   Grand\
    \ Prairie, TX 75050\n   Phone: (972) 301 3630\n   EMail: hghadia@gen10technology.com\n\
    \   Howard C. Herbert\n   Intel Corporation\n   MS CH7-404\n   5000 West Chandler\
    \ Blvd.\n   Chandler, AZ 85226\n   Phone: 480-554-3116\n   EMail: howard.c.herbert@intel.com\n\
    \   Jeff Hilland\n   Hewlett-Packard Company\n   20555 SH 249\n   Houston, TX\
    \ 77070-2698 USA\n   Phone: 281-514-9489\n   EMail: jeff.hilland@hp.com\n   Mike\
    \ Ko\n   IBM\n   650 Harry Rd.\n   San Jose, CA 95120\n   Phone: (408) 927-2085\n\
    \   EMail: mako@us.ibm.com\n   Mike Krause\n   Hewlett-Packard Corporation, 43LN\n\
    \   19410 Homestead Road\n   Cupertino, CA 95014 USA\n   Phone: +1 (408) 447-3191\n\
    \   EMail: krause@cup.hp.com\n   Dave Minturn\n   Intel Corporation\n   MS JF1-210\n\
    \   5200 North East Elam Young Parkway\n   Hillsboro, Oregon  97124\n   Phone:\
    \ 503-712-4106\n   EMail: dave.b.minturn@intel.com\n   Jim Pinkerton\n   Microsoft,\
    \ Inc.\n   One Microsoft Way\n   Redmond, WA 98052 USA\n   EMail: jpink@microsoft.com\n\
    \   Hemal Shah\n   Broadcom Corporation\n   5300 California Avenue\n   Irvine,\
    \ CA 92617 USA\n   Phone: +1 (949) 926-6941\n   EMail: hemal@broadcom.com\n  \
    \ Allyn Romanow\n   Cisco Systems\n   170 W Tasman Drive\n   San Jose, CA 95134\
    \ USA\n   Phone: +1 408 525 8836\n   EMail: allyn@cisco.com\n   Tom Talpey\n \
    \  Network Appliance\n   1601 Trapelo Road #16\n   Waltham, MA  02451 USA\n  \
    \ Phone: +1 (781) 768-5329\n   EMail: thomas.talpey@netapp.com\n   Patricia Thaler\n\
    \   Broadcom\n   16215 Alton Parkway\n   Irvine, CA 92618\n   Phone: 916 570 2707\n\
    \   EMail: pthaler@broadcom.com\n   Jim Wendt\n   Hewlett Packard Corporation\n\
    \   8000 Foothills Boulevard MS 5668\n   Roseville, CA 95747-5668 USA\n   Phone:\
    \ +1 916 785 5198\n   EMail: jim_wendt@hp.com\n   Jim Williams\n   Emulex Corporation\n\
    \   580 Main Street\n   Bolton, MA 01740 USA\n   Phone: +1 978 779 7224\n   EMail:\
    \ jim.williams@emulex.com\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Paul R. Culley\n   Hewlett-Packard Company\n   20555 SH\
    \ 249\n   Houston, TX 77070-2698 USA\n   Phone: 281-514-5543\n   EMail: paul.culley@hp.com\n\
    \   Uri Elzur\n   5300 California Avenue\n   Irvine, CA 92617, USA\n   Phone:\
    \ 949.926.6432\n   EMail: uri@broadcom.com\n   Renato J Recio\n   IBM\n   Internal\
    \ Zip 9043\n   11400 Burnett Road\n   Austin, Texas 78759\n   Phone: 512-838-3685\n\
    \   EMail: recio@us.ibm.com\n   Stephen Bailey\n   Sandburst Corporation\n   600\
    \ Federal Street\n   Andover, MA 01810 USA\n   Phone: +1 978 689 1614\n   EMail:\
    \ steph@sandburst.com\n   John Carrier\n   Cray Inc.\n   411 First Avenue S, Suite\
    \ 600\n   Seattle, WA 98104-2860\n   Phone: 206-701-2090\n   EMail: carrier@cray.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
