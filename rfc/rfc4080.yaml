- title: __initial_text__
  contents:
  - '               Next Steps in Signaling (NSIS): Framework

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   The Next Steps in Signaling (NSIS) working group is considering\n\
    \   protocols for signaling information about a data flow along its path\n   in\
    \ the network.  The NSIS suite of protocols is envisioned to support\n   various\
    \ signaling applications that need to install and/or manipulate\n   such state\
    \ in the network.  Based on existing work on signaling\n   requirements, this\
    \ document proposes an architectural framework for\n   these signaling protocols.\n\
    \   This document provides a model for the network entities that take\n   part\
    \ in such signaling, and for the relationship between signaling\n   and the rest\
    \ of network operation.  We decompose the overall\n   signaling protocol suite\
    \ into a generic (lower) layer, with separate\n   upper layers for each specific\
    \ signaling application.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n           3.1.2. Path-Coupled and Path-Decoupled Signaling\
    \ ...........7\n           3.1.3. Signaling to Hosts, Networks, and Proxies ...........8\n\
    \           3.1.4. Signaling Messages and Network Control State .......10\n  \
    \         3.1.5. Data Flows and Sessions ............................10\n    \
    \  3.2. Layer Model for the Protocol Suite ........................11\n      \
    \     3.2.1. Layer Model Overview ...............................11\n        \
    \   3.2.2. Layer Split Concept ................................12\n          \
    \ 3.2.3. Bypassing Intermediate Nodes .......................13\n           3.2.4.\
    \ Core NSIS Transport Layer Functionality ............15\n           3.2.5. State\
    \ Management Functionality .....................16\n           3.2.6. Path-Decoupled\
    \ Operation ...........................17\n      3.3. Signaling Application Properties\
    \ ..........................18\n           3.3.1. Sender/Receiver Orientation\
    \ ........................18\n           3.3.2. Uni- and Bi-Directional Operation\
    \ ..................19\n           3.3.3. Heterogeneous Operation ............................19\n\
    \           3.3.4. Aggregation ........................................20\n  \
    \         3.3.5. Peer-Peer and End-End Relationships ................21\n    \
    \       3.3.6. Acknowledgements and Notifications .................21\n      \
    \     3.3.7. Security and Other AAA Issues ......................22\n   4. The\
    \ NSIS Transport Layer Protocol ..............................23\n      4.1. Internal\
    \ Protocol Components ..............................23\n      4.2. Addressing\
    \ ................................................24\n      4.3. Classical Transport\
    \ Functions .............................24\n      4.4. Lower Layer Interfaces\
    \ ....................................26\n      4.5. Upper Layer Services ......................................27\n\
    \      4.6. Identity Elements .........................................28\n  \
    \         4.6.1. Flow Identification ................................28\n    \
    \       4.6.2. Session Identification .............................28\n      \
    \     4.6.3. Signaling Application Identification ...............29\n      4.7.\
    \ Security Properties .......................................30\n   5. Interactions\
    \ with Other Protocols ..............................30\n      5.1. IP Routing\
    \ Interactions ...................................30\n           5.1.1. Load Sharing\
    \ and Policy-Based Forwarding ...........31\n           5.1.2. Route Changes ......................................31\n\
    \      5.2. Mobility and Multihoming Interactions .....................33\n  \
    \    5.3. Interactions with NATs ....................................36\n    \
    \  5.4. Interactions with IP Tunneling ............................36\n   6. Signaling\
    \ Applications .........................................37\n      6.1. Signaling\
    \ for Quality of Service ..........................37\n           6.1.1. Protocol\
    \ Message Semantics .........................38\n           6.1.2. State Management\
    \ ...................................39\n           6.1.3. Route Changes and QoS\
    \ Reservations .................39\n           6.1.4. Resource Management Interactions\
    \ ...................41\n      6.2. Other Signaling Applications ..............................42\n\
    \   7. Security Considerations ........................................42\n  \
    \ 8. References .....................................................43\n    \
    \  8.1. Normative References ......................................43\n      8.2.\
    \ Informative References ....................................44\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Definition of the Signaling Problem
  contents:
  - "1.1.  Definition of the Signaling Problem\n   The Next Steps in Signaling (NSIS)\
    \ working group is considering\n   protocols for signaling information about a\
    \ data flow along its path\n   in the network.\n   It is assumed that the path\
    \ taken by the data flow is already\n   determined by network configuration and\
    \ routing protocols,\n   independently of the signaling itself; that is, signaling\
    \ to set up\n   the routes themselves is not considered.  Instead, the signaling\n\
    \   simply interacts with nodes along the data flow path.  Additional\n   simplifications\
    \ are that the actual signaling messages pass directly\n   through these nodes\
    \ themselves (i.e., the 'path-coupled' case; see\n   Section 3.1.2) and that only\
    \ unicast data flows are considered.\n   The signaling problem in this sense is\
    \ very similar to that addressed\n   by RSVP.  However, there are two generalizations.\
    \  First, the\n   intention is that components of the NSIS protocol suite will\
    \ be\n   usable in different parts of the Internet, for different needs,\n   without\
    \ requiring a complete end-to-end deployment (in particular,\n   the signaling\
    \ protocol messages may not need to run all the way\n   between the data flow\
    \ endpoints).\n   Second, the signaling is intended for more purposes than just\
    \ QoS\n   (resource reservation).  The basic mechanism to achieve this\n   flexibility\
    \ is to divide the signaling protocol stack into two\n   layers: a generic (lower)\
    \ layer, and an upper layer specific to each\n   signaling application.  The scope\
    \ of NSIS work is to define both the\n   generic protocol and, initially, upper\
    \ layers suitable for QoS\n   signaling (similar to the corresponding functionality\
    \ in RSVP) and\n   middlebox signaling.  Further applications may be considered\
    \ later.\n"
- title: 1.2.  Scope and Structure of the NSIS Framework
  contents:
  - "1.2.  Scope and Structure of the NSIS Framework\n   The underlying requirements\
    \ for signaling in the context of NSIS are\n   defined in [1] and a separate security\
    \ threats document [2]; other\n   related requirements can be found in [3] and\
    \ [4] for QoS/Mobility and\n   middlebox communication, respectively.  This framework\
    \ does not\n   replace or update these requirements.  Discussions about lessons\
    \ to\n   be learned from existing signaling and resource management protocols\n\
    \   are contained in separate analysis documents [5], [6].\n   The role of this\
    \ framework is to explain how NSIS signaling should\n   work within the broader\
    \ networking context, and to describe the\n   overall structure of the protocol\
    \ suite itself.  Therefore, it\n   discusses important protocol considerations\
    \ such as routing,\n   mobility, security, and interactions with network 'resource'\n\
    \   management (in the broadest sense).\n   The basic context for NSIS protocols\
    \ is given in Section 3.\n   Section 3.1 describes the fundamental elements of\
    \ NSIS protocol\n   operation in comparison to RSVP [7]; in particular, Section\
    \ 3.1.3\n   describes more general signaling scenarios, and Section 3.1.4 defines\n\
    \   a broader class of signaling applications for which the NSIS\n   protocols\
    \ should be useful.  The two-layer protocol architecture that\n   supports this\
    \ generality is described in Section 3.2, and Section 3.3\n   gives examples of\
    \ the ways in which particular signaling application\n   properties can be accommodated\
    \ within signaling layer protocol\n   behavior.\n   The overall functionality\
    \ required from the lower (generic) protocol\n   layer is described in Section\
    \ 4.  This is not intended to define the\n   detailed design of the protocol or\
    \ even design options, although some\n   are described as examples.  It describes\
    \ the interfaces between this\n   lower-layer protocol and the IP layer (below)\
    \ and signaling\n   application protocols (above), including the identifier elements\
    \ that\n   appear on these interfaces (Section 4.6).  Following this, Section\
    \ 5\n   describes how signaling applications that use the NSIS protocols can\n\
    \   interact sensibly with network layer operations; specifically,\n   routing\
    \ (and re-routing), IP mobility, and network address\n   translation (NAT).\n\
    \   Section 6 describes particular signaling applications.  The example\n   of\
    \ signaling for QoS (comparable to core RSVP QoS signaling\n   functionality)\
    \ is given in detail in Section 6.1, which describes\n   both the signaling application\
    \ specific protocol and example modes of\n   interaction with network resource\
    \ management and other deployment\n   aspects.  However, note that these examples\
    \ are included only as\n   background and for explanation; we do not intend to\
    \ define an\n   over-arching architecture for carrying out resource management\
    \ in the\n   Internet.  Further possible signaling applications are outlined in\n\
    \   Section 6.2.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   Classifier: an entity that selects packets based on their\
    \ contents\n      according to defined rules.\n   [Data] flow: a stream of packets\
    \ from sender to receiver that is a\n      distinguishable subset of a packet\
    \ stream.  Each flow is\n      distinguished by some flow identifier (see Section\
    \ 4.6.1).\n   Edge node: an (NSIS-capable) node on the boundary of some\n    \
    \  administrative domain.\n   Interior nodes: the set of (NSIS-capable) nodes\
    \ that form an\n      administrative domain, excluding the edge nodes.\n   NSIS\
    \ Entity (NE): the function within a node that implements an NSIS\n      protocol.\
    \  In the case of path-coupled signaling, the NE will\n      always be on the\
    \ data path.\n   NSIS Signaling Layer Protocol (NSLP): generic term for an NSIS\n\
    \      protocol component that supports a specific signaling application.\n  \
    \    See also Section 3.2.1.\n   NSIS Transport Layer Protocol (NTLP): placeholder\
    \ name for the NSIS\n      protocol component that will support lower-layer (signaling\n\
    \      application-independent) functions.  See also Section 3.2.1.\n   Path-coupled\
    \ signaling: a mode of signaling in which the signaling\n      messages follow\
    \ a path that is tied to the data messages.\n   Path-decoupled signaling: signaling\
    \ for state manipulation related to\n      data flows, but only loosely coupled\
    \ to the data path; e.g., at\n      the AS level.\n   Peer discovery: the act\
    \ of locating and/or selecting which NSIS peer\n      to carry out signaling exchanges\
    \ with for a specific data flow.\n   Peer relationship: signaling relationship\
    \ between two adjacent NSIS\n      entities (i.e., NEs with no other NEs between\
    \ them).\n   Receiver: the node in the network that is receiving the data packets\n\
    \      in a flow.\n   Sender: the node in the network that is sending the data\
    \ packets in a\n      flow.\n   Session: application layer flow of information\
    \ for which some network\n      control state information is to be manipulated\
    \ or monitored (see\n      Section 3.1.5).\n   Signaling application: the purpose\
    \ of the NSIS signaling.  A\n      signaling application could be QoS management,\
    \ firewall control,\n      and so on.  Totally distinct from any specific user\
    \ application.\n"
- title: 3.  Overview of Signaling Scenarios and Protocol Structure
  contents:
  - '3.  Overview of Signaling Scenarios and Protocol Structure

    '
- title: 3.1.  Fundamental Signaling Concepts
  contents:
  - '3.1.  Fundamental Signaling Concepts

    '
- title: 3.1.1.  Simple Network and Signaling Topology
  contents:
  - "3.1.1.  Simple Network and Signaling Topology\n   The NSIS suite of protocols\
    \ is envisioned to support various\n   signaling applications that need to install\
    \ and/or manipulate state\n   in the network.  This state is related to a data\
    \ flow and is\n   installed and maintained on the NSIS Entities (NEs) along the\
    \ data\n   flow path through the network; not every node has to contain an NE.\n\
    \   The basic protocol concepts do not depend on the signaling\n   application,\
    \ but the details of operation and the information carried\n   do.  This section\
    \ discusses the basic entities involved with\n   signaling as well as interfaces\
    \ between them.\n   Two NSIS entities that communicate directly are said to be\
    \ in a 'peer\n   relationship'.  This concept might loosely be described as an\
    \ 'NSIS\n   hop'; however, there is no implication that it corresponds to a\n\
    \   single IP hop.  Either or both NEs might store some state information\n  \
    \ about the other, but there is no assumption that they necessarily\n   establish\
    \ a long-term signaling connection between themselves.\n   It is common to consider\
    \ a network as composed of various domains\n   (e.g., for administrative or routing\
    \ purposes), and the operation of\n   signaling protocols may be influenced by\
    \ these domain boundaries.\n   However, it seems there is no reason to expect\
    \ that an 'NSIS domain'\n   should exactly overlap with an IP domain (AS, area),\
    \ but it is likely\n   that its boundaries would consist of boundaries (segments)\
    \ of one or\n   several IP domains.\n   Figure 1 shows a diagram of nearly the\
    \ simplest possible signaling\n   configuration.  A single data flow is running\
    \ from an application in\n   the sender to the receiver via routers R1, R2, and\
    \ R3.  Each host and\n   two of the routers contain NEs that exchange signaling\
    \ messages --\n   possibly in both directions -- about the flow.  This scenario\
    \ is\n   essentially the same as that considered by RSVP for QoS signaling;\n\
    \   the main difference is that here we make no assumptions about the\n   particular\
    \ sequence of signaling messages that will be invoked.\n       Sender        \
    \                                       Receiver\n   +-----------+      +----+\
    \      +----+      +----+      +-----------+\n   |Application|----->| R1 |----->|\
    \ R2 |----->| R3 |----->|Application|\n   |   +--+    |      |+--+|      |+--+|\
    \      +----+      |   +--+    |\n   |   |NE|====|======||NE||======||NE||==================|===|NE|\
    \    |\n   |   +--+    |      |+--+|      |+--+|                  |   +--+   \
    \ |\n   +-----------+      +----+      +----+                  +-----------+\n\
    \      +--+\n      |NE| = NSIS      ==== = Signaling    ---> = Data flow messages\n\
    \      +--+   Entity           Messages            (unidirectional)\n        \
    \         Figure 1: Simple Signaling and Data Flows\n"
- title: 3.1.2.  Path-Coupled and Path-Decoupled Signaling
  contents:
  - "3.1.2.  Path-Coupled and Path-Decoupled Signaling\n   We can consider two basic\
    \ paradigms for resource reservation\n   signaling, which we refer to as \"path-coupled\"\
    \ and \"path-decoupled\".\n   In the path-coupled case, signaling messages are\
    \ routed only through\n   NEs that are on the data path.  They do not have to\
    \ reach all the\n   nodes on the data path.  (For example, there could be intermediate\n\
    \   signaling-unaware nodes, or the presence of proxies such as those\n   shown\
    \ in Figure 2 could prevent the signaling from reaching the path\n   end points.)\
    \  Between adjacent NEs, the route taken by signaling and\n   data might diverge.\
    \  The path-coupled case can be supported by\n   various addressing styles, with\
    \ messages either explicitly addressed\n   to the neighbor on-path NE, or addressed\
    \ identically to the data\n   packets, but also with the router alert option (see\
    \ [8] and [9]), and\n   intercepted.  These cases are considered in Section 4.2.\
    \  In the\n   second case, some network configurations may split the signaling\
    \ and\n   data paths (see Section 5.1.1); this is considered an error case for\n\
    \   path-coupled signaling.\n   In the path-decoupled case, signaling messages\
    \ are routed to nodes\n   (NEs) that are not assumed to be on the data path, but\
    \ that are\n   (presumably) aware of it.  Signaling messages will always be directly\n\
    \   addressed to the neighbor NE, and the signaling endpoints may have no\n  \
    \ relation at all with the ultimate data sender or receiver.  The\n   implications\
    \ of path-decoupled operation for the NSIS protocols are\n   considered briefly\
    \ in Section 3.2.6; however, the initial goal of\n   NSIS and this framework is\
    \ to concentrate mainly on the path-coupled\n   case.\n"
- title: 3.1.3.  Signaling to Hosts, Networks, and Proxies
  contents:
  - "3.1.3.  Signaling to Hosts, Networks, and Proxies\n   There are different possible\
    \ triggers for the signaling protocols.\n   Among them are user applications (that\
    \ are using NSIS signaling\n   services), other signaling applications, network\
    \ management actions,\n   some network events, and so on.  The variety of possible\
    \ triggers\n   requires that the signaling can be initiated and terminated in\
    \ the\n   different parts of the network: hosts, domain boundary nodes (edge\n\
    \   nodes), or interior domain nodes.\n   The NSIS protocol suite extends the\
    \ RSVP model to consider this wider\n   variety of possible signaling exchanges.\
    \  As well as the basic\n   end-to-end model already described, examples such\
    \ as end-to-edge and\n   edge-to-edge can be considered.  The edge-to-edge case\
    \ might involve\n   the edge nodes communicating directly, as well as via the\
    \ interior\n   nodes.\n   Although the end-to-edge (host-to-network) scenario\
    \ requires only\n   intra-domain signaling, the other cases might need inter-domain\
    \ NSIS\n   signaling as well if the signaling endpoints (hosts or network edges)\n\
    \   are connected to different domains.  Depending on the trust relation\n   between\
    \ concatenated NSIS domains, the edge-to-edge scenario might\n   cover a single\
    \ domain or multiple concatenated NSIS domains.  The\n   latter case assumes the\
    \ existence of trust relations between domains.\n   In some cases, it is desired\
    \ to be able to initiate and/or terminate\n   NSIS signaling not from the end\
    \ host that sends/receives the data\n   flow, but from some other entities in\
    \ the network that can be called\n   signaling proxies.  There could be various\
    \ reasons for this:\n   signaling on behalf of the end hosts that are not NSIS-aware,\n\
    \   consolidation of the customer accounting (authentication,\n   authorization)\
    \ in respect to consumed application and transport\n   resources, security considerations,\
    \ limitation of the physical\n   connection between host and network, and so on.\
    \  This configuration\n   can be considered a kind of \"proxy on the data path\"\
    ; see Figure 2.\n                 Proxy1                        Proxy2\n   +------+\
    \      +----+    +----+    +----+    +----+      +--------+\n   |Sender|-...->|Appl|--->|\
    \ R  |--->| R  |--->|Appl|-...->|Receiver|\n   |      |      |+--+|    |+--+|\
    \    |+--+|    |+--+|      |        |\n   +------+      ||NE||====||NE||====||NE||====||NE||\
    \      +--------+\n                 |+--+|    |+--+|    |+--+|    |+--+|\n   \
    \              +----+    +----+    +----+    +----+\n      +--+\n      |NE| =\
    \ NSIS      ==== = Signaling    ---> = Data flow messages\n      +--+   Entity\
    \           Messages            (unidirectional)\n      Appl = signaling application\n\
    \                      Figure 2: \"On path\" NSIS proxy\n   This configuration\
    \ presents two specific challenges for the\n   signaling:\n   o  A proxy that\
    \ terminates signaling on behalf of the NSIS-unaware\n      host (or part of the\
    \ network) should be able to determine that it\n      is the last NSIS-aware node\
    \ along the path.\n   o  Where a proxy initiates NSIS signaling on behalf of the\
    \ NSIS-\n      unaware host, interworking with some other \"local\" technology\n\
    \      might be required (for example, to provide QoS reservation from\n     \
    \ proxy to the end host in the case of a QoS signaling application).\n   +------+\
    \      +----+      +----+      +----+      +--------+\n   |Sender|----->| PA |----->|\
    \ R2 |----->| R3 |----->|Receiver|\n   |      |      |+--+|      |+--+|      +----+\
    \      |  +--+  |\n   +------+      ||NE||======||NE||==================|==|NE|\
    \  |\n                 |+--+|      |+--+|                  |  +--+  |\n      \
    \           +-..-+      +----+                  +--------+\n                 \
    \  ..\n                   ..\n                 +-..-+\n                 |Appl|\n\
    \                 +----+\n            Appl = signaling         PA = Proxy for\
    \ signaling\n                   application            application\n         \
    \             Figure 3: \"Off path\" NSIS proxy\n   Another possible configuration,\
    \ shown in Figure 3, is where an NE can\n   send and receive signaling information\
    \ to a remote processor.  The\n   NSIS protocols may or may not be suitable for\
    \ this remote\n   interaction, but in any case it is not currently part of the\
    \ NSIS\n   problem.  This configuration is supported by considering the NE a\n\
    \   proxy at the signaling application level.  This is a natural\n   implementation\
    \ approach for some policy control and centralized\n   control architectures;\
    \ see also Section 6.1.4.\n"
- title: 3.1.4.  Signaling Messages and Network Control State
  contents:
  - "3.1.4.  Signaling Messages and Network Control State\n   The distinguishing features\
    \ of the signaling supported by the NSIS\n   protocols are that it is related\
    \ to specific flows (rather than to\n   network operation in general), and that\
    \ it involves nodes in the\n   network (rather than running transparently between\
    \ the end hosts).\n   Therefore, each signaling application (upper-layer) protocol\
    \ must\n   carry per-flow information for the aspects of network-internal\n  \
    \ operation that are of interest to that signaling application.  An\n   example\
    \ for the case of an RSVP-like QoS signaling application would\n   be state data\
    \ representing resource reservations.  However, more\n   generally, the per-flow\
    \ information might be related to some other\n   control function in routers and\
    \ middleboxes along the path.  Indeed,\n   the signaling might simply be used\
    \ to gather per-flow information,\n   without modifying network operation at all.\n\
    \   We call this information 'network control state' generically.\n   Signaling\
    \ messages may install, modify, refresh, or simply read this\n   state from network\
    \ elements for particular data flows.  Usually a\n   network element will also\
    \ manage this information at the per-flow\n   level, although coarser-grained\
    \ ('per-class') state management is\n   also possible.\n"
- title: 3.1.5.  Data Flows and Sessions
  contents:
  - "3.1.5.  Data Flows and Sessions\n   Formally, a data flow is a (unidirectional)\
    \ sequence of packets\n   between the same endpoints that all follow a unique\
    \ path through the\n   network (determined by IP routing and other network configuration).\n\
    \   A flow is defined by a packet classifier (in the simplest cases, just\n  \
    \ the destination address and topological origin are needed).  In\n   general\
    \ we assume that when discussing only the data flow path, we\n   only need to\
    \ consider 'simple' fixed classifiers (e.g., IPv4 5-tuple\n   or equivalent).\n\
    \   A session is an application layer concept for an exchange of packets\n   between\
    \ two endpoints, for which some network state is to be\n   allocated or monitored.\
    \  In simple cases, a session may map to a\n   specific flow; however, signaling\
    \ applications are allowed to create\n   more flexible flow:session relationships.\
    \  (Note that this concept of\n   'session' is different from that of RSVP, which\
    \ defines a session as\n   a flow with a specific destination address and transport\
    \ protocol.\n   The NSIS usage is closer to the session concepts of higher-layer\n\
    \   protocols.)\n   The simplest service provided by NSIS signaling protocols\
    \ is the\n   management of network control state at the level of a specific flow,\n\
    \   as described in the previous subsection.  In particular, it should be\n  \
    \ possible to monitor routing updates as they change the path taken by\n   a flow\
    \ and, for example, update network state appropriately.  This is\n   no different\
    \ from the case for RSVP (local path repair).  Where there\n   is a 1:1 flow:session\
    \ relationship, this is all that is required.\n   However, for some more complex\
    \ scenarios (especially mobility and\n   multihoming related ones; see [1] and\
    \ the mobility discussion of\n   [5]), it is desirable to update the flow:session\
    \ mapping during the\n   session lifetime.  For example, a new flow can be added,\
    \ and the old\n   one deleted (and maybe in that order, for a 'make-before-break'\n\
    \   handover), effectively transferring the network control state between\n  \
    \ data flows to keep it associated with the same session.  Such updates\n   are\
    \ best managed by the end systems (generally, systems that\n   understand the\
    \ flow:session mapping and are aware of the packet\n   classifier change).  To\
    \ enable this, it must be possible to relate\n   signaling messages to sessions\
    \ as well as to data flows.  A session\n   identifier (Section 4.6.2) is one component\
    \ of the solution.\n"
- title: 3.2.  Layer Model for the Protocol Suite
  contents:
  - '3.2.  Layer Model for the Protocol Suite

    '
- title: 3.2.1.  Layer Model Overview
  contents:
  - "3.2.1.  Layer Model Overview\n   In order to achieve a modular solution for the\
    \ NSIS requirements, the\n   NSIS protocol suite will be structured in two layers:\n\
    \   o  a 'signaling transport' layer, responsible for moving signaling\n     \
    \ messages around, which should be independent of any particular\n      signaling\
    \ application; and\n   o  a 'signaling application' layer, which contains functionality\
    \ such\n      as message formats and sequences, specific to a particular\n   \
    \   signaling application.\n   For the purpose of this document, we use the term\
    \ 'NSIS Transport\n   Layer Protocol' (NTLP) to refer to the component that will\
    \ be used in\n   the transport layer.  We also use the term 'NSIS Signaling Layer\n\
    \   Protocol' (NSLP) to refer generically to any protocol within the\n   signaling\
    \ application layer; in the end, there will be several NSLPs,\n   largely independent\
    \ of each other.  These relationships are\n   illustrated in Figure 4.  Note that\
    \ the NTLP may or may not have an\n   interesting internal structure (e.g., including\
    \ existing transport\n   protocols), but that is not relevant at this level of\
    \ description.\n                 ^                     +-----------------+\n \
    \                |                     | NSIS Signaling  |\n                 |\
    \                     | Layer Protocol  |\n         NSIS    |    +----------------|\
    \ for middleboxes |\n       Signaling |    | NSIS Signaling |        +-----------------+\n\
    \         Layer   |    | Layer Protocol +--------| NSIS Signaling  |\n       \
    \          |    |     for QoS     |       | Layer Protocol  |\n              \
    \   |    +-----------------+       |    for ...      |\n                 V   \
    \                           +-----------------+\n                      =============================================\n\
    \         NSIS    ^         +--------------------------------+\n       Transport\
    \ |         | NSIS Transport Layer Protocol  |\n         Layer   V         +--------------------------------+\n\
    \                      =============================================\n       \
    \                    +--------------------------------+\n                    \
    \       .      IP and lower layers       .\n                           .     \
    \                           .\n                    Figure 4: NSIS Protocol Components\n\
    \   Note that not every generic function has to be located in the NTLP.\n   Another\
    \ option would be to have re-usable components within the\n   signaling application\
    \ layer.  Functionality within the NTLP should be\n   restricted to what interacts\
    \ strongly with other transport and\n   lower-layer operations.\n"
- title: 3.2.2.  Layer Split Concept
  contents:
  - "3.2.2.  Layer Split Concept\n   This section describes the basic concepts underlying\
    \ the\n   functionality of the NTLP.  First, we make a working assumption that\n\
    \   the protocol mechanisms of the NTLP operate only between adjacent NEs\n  \
    \ (informally, the NTLP is a 'hop-by-hop' protocol), whereas any\n   larger-scope\
    \ issues (including e2e aspects) are left to the upper\n   layers.\n   The way\
    \ in which the NTLP works can be described as follows: When a\n   signaling message\
    \ is ready to be sent from one NE, it is given to the\n   NTLP along with information\
    \ about what flow it is for; it is then up\n   to the NTLP to get it to the next\
    \ NE along the path (upstream or\n   downstream), where it is received and the\
    \ responsibility of the NTLP\n   ends.  Note that there is no assumption here\
    \ about how the messages\n   are actually addressed (this is a protocol design\
    \ issue, and the\n   options are outlined in Section 4.2).  The key point is that\
    \ the NTLP\n   for a given NE does not use any knowledge about addresses,\n  \
    \ capabilities, or status of any NEs other than its direct peers.\n   The NTLP\
    \ in the receiving NE either forwards the message directly or,\n   if there is\
    \ an appropriate signaling application locally, passes it\n   upwards for further\
    \ processing; the signaling application can then\n   generate another message\
    \ to be sent via the NTLP.  In this way,\n   larger-scope (including end-to-end)\
    \ message delivery is achieved.\n   This definition relates to NTLP operation.\
    \  It does not restrict the\n   ability of an NSLP to send messages by other means.\
    \  For example, an\n   NE in the middle or end of the signaling path could send\
    \ a message\n   directly to the other end as a notification or acknowledgement\
    \ of\n   some signaling application event.  However, the issues in sending\n \
    \  such messages (endpoint discovery, security, NAT traversal, and so\n   on)\
    \ are so different from the direct peer-peer case that there is no\n   benefit\
    \ in extending the NTLP to include such non-local\n   functionality.  Instead,\
    \ an NSLP that requires such messages and\n   wants to avoid traversing the path\
    \ of NEs should use some other\n   existing transport protocol.  For example,\
    \ UDP or DCCP would be a\n   good match for many of the scenarios that have been\
    \ proposed.\n   Acknowledgements and notifications of this type are considered\n\
    \   further in Section 3.3.6.\n   One motivation for restricting the NTLP to peer-relationship\
    \ scope is\n   that if there are any options or variants in design approach --\
    \ or,\n   worse, in basic functionality -- it is easier to manage the resulting\n\
    \   complexity if it only impacts direct peers rather than potentially\n   the\
    \ whole Internet.\n"
- title: 3.2.3.  Bypassing Intermediate Nodes
  contents:
  - "3.2.3.  Bypassing Intermediate Nodes\n   Because the NSIS problem includes multiple\
    \ signaling applications, it\n   is very likely that a particular NSLP will only\
    \ be implemented on a\n   subset of the NSIS-aware nodes on a path, as shown in\
    \ Figure 5.  In\n   addition, a node inside an aggregation region will still wish\
    \ to\n   ignore signaling messages that are per-flow, even if they are for a\n\
    \   signaling application that the node is generally able to process.\n      \
    \         +------+    +------+    +------+    +------+\n               |  NE \
    \ |    |  NE  |    |  NE  |    |  NE  |\n               |+----+|    |      | \
    \   |+----+|    |+----+|\n               ||NSLP||    |      |    ||NSLP||    ||NSLP||\n\
    \               || 1  ||    |      |    || 2  ||    || 1  ||\n               |+----+|\
    \    |      |    |+----+|    |+----+|\n               |  ||  |    |      |   \
    \ |      |    |  ||  |\n               |+----+|    |+----+|    |+----+|    |+----+|\n\
    \           ====||NTLP||====||NTLP||====||NTLP||====||NTLP||====\n           \
    \    |+----+|    |+----+|    |+----+|    |+----+|\n               +------+   \
    \ +------+    +------+    +------+\n               Figure 5: Signaling with Heterogeneous\
    \ NSLPs\n   Where signaling messages traverse such NSIS-aware intermediate nodes,\n\
    \   it is desirable to process them at the lowest level possible (in\n   particular,\
    \ on the fastest path).  In order to offer a non-trivial\n   message transfer\
    \ service (in terms of security, reliability and so\n   on) to the peer NSLP nodes,\
    \ it is important that the NTLP at\n   intermediate nodes is as transparent as\
    \ possible; that is, it carries\n   out minimal processing.  In addition, if intermediate\
    \ nodes have to\n   do slow-path processing of all NSIS messages, this eliminates\
    \ many of\n   the scaling benefits of aggregation, unless tunneling is used.\n\
    \   Considering first the case of messages sent with the router alert\n   option,\
    \ there are two complementary methods to achieve this bypassing\n   of intermediate\
    \ NEs:\n   o  At the IP layer, a set of protocol numbers or a range of values\
    \ in\n      the router alert option can be used.  In this way, messages can be\n\
    \      marked with an implied granularity, and routers can choose to\n      apply\
    \ further slow-path processing only to configured subsets of\n      messages.\
    \  This is the method used in [10] to distinguish per-flow\n      and per-aggregate\
    \ signaling.\n   o  The NTLP could process the message but determine that there\
    \ was no\n      local signaling application it was relevant to.  At this stage,\n\
    \      the message can be returned unchanged to the IP layer for normal\n    \
    \  forwarding; the intermediate NE has effectively chosen to be\n      transparent\
    \ to the message in question.\n   In both cases, the existence of the intermediate\
    \ NE is totally hidden\n   from the NSLP nodes.  If later stages of the signaling\
    \ use directly\n   addressed messages (e.g., for reverse routing), they will not\
    \ involve\n   the intermediate NE at all, except perhaps as a normal router.\n\
    \   There may be cases where the intermediate NE would like to do some\n   restricted\
    \ protocol processing, such as the following:\n   o  Translating addresses in\
    \ message payloads (compare Section 4.6.1);\n      note that this would have to\
    \ be done to messages passing in both\n      directions through a node.\n   o\
    \  Updating signaling application payloads with local status\n      information\
    \ (e.g., path property measurement inside a domain).\n   If this can be done without\
    \ fully terminating the NSIS protocols, it\n   would allow a more lightweight\
    \ implementation of the intermediate NE,\n   and a more direct 'end-to-end' NTLP\
    \ association between the peer\n   NSLPs where the signaling application is fully\
    \ processed.  On the\n   other hand, this is only possible with a limited class\
    \ of possible\n   NTLP designs, and makes it harder for the NTLP to offer a security\n\
    \   service (since messages have to be partially protected).  The\n   feasibility\
    \ of this approach will be evaluated during the NTLP\n   design.\n"
- title: 3.2.4.  Core NSIS Transport Layer Functionality
  contents:
  - "3.2.4.  Core NSIS Transport Layer Functionality\n   This section describes the\
    \ basic functionality to be supported by the\n   NTLP.  Note that the overall\
    \ signaling solution will always be the\n   result of joint operation of both\
    \ the NTLP and the signaling layer\n   protocols (NSLPs); for example, we can\
    \ always assume that an NSLP is\n   operating above the NTLP and taking care of\
    \ end-to-end issues (e.g.,\n   recovery of messages after restarts).\n   Therefore,\
    \ NTLP functionality is essentially just efficient upstream\n   and downstream\
    \ peer-peer message delivery, in a wide variety of\n   network scenarios.  Message\
    \ delivery includes the act of locating\n   and/or selecting which NTLP peer to\
    \ carry out signaling exchanges\n   with for a specific data flow.  This discovery\
    \ might be an active\n   process (using specific signaling packets) or a passive\
    \ process (a\n   side effect of using a particular addressing mode).  In addition,\
    \ it\n   appears that the NTLP can sensibly carry out many of the functions\n\
    \   that enable signaling messages to pass through middleboxes, since\n   this\
    \ is closely related to the problem of routing the signaling\n   messages in the\
    \ first place.  Further details about NTLP\n   functionality are contained in\
    \ Sections 3.2.5 and 4.3.\n"
- title: 3.2.5.  State Management Functionality
  contents:
  - "3.2.5.  State Management Functionality\n   Internet signaling requires the existence\
    \ and management of state\n   within the network for several reasons.  This section\
    \ describes how\n   state management functionality is split across the NSIS layers.\n\
    \   (Note that how the NTLP internal state is managed is a matter for its\n  \
    \ design and indeed implementation.)\n   1.  Conceptually, the NTLP provides a\
    \ uniform message delivery\n       service.  It is unaware of the difference in\
    \ state semantics\n       between different types of signaling application messages\
    \ (e.g.,\n       whether a message changes, just refreshes signaling application\n\
    \       state, or even has nothing to with signaling application state at\n  \
    \     all).\n   2.  An NTLP instance processes and, if necessary, forwards all\n\
    \       signaling application messages \"immediately\".  (It might offer\n   \
    \    different service classes, but these would be distinguished by,\n       for\
    \ example, reliability or priority, not by state aspects.)\n       This means\
    \ that the NTLP does not know explicit timer or message\n       sequence information\
    \ for the signaling application; and that\n       signaling application messages\
    \ pass immediately through an\n       NSLP-unaware node.  (Their timing cannot\
    \ be jittered there, nor\n       can messages be stored up to be re-sent on a\
    \ new path in case of\n       a later re-routing event.)\n   3.  Within any node,\
    \ it is an implementation decision whether to\n       generate/jitter/filter refreshes\
    \ separately within each signaling\n       application that needs this functionality,\
    \ or to integrate it\n       with the NTLP implementation as a generic \"soft-state\
    \ management\n       toolbox\".  The choice doesn't affect the NTLP specification\
    \ at\n       all.  Implementations might piggyback NTLP soft-state refresh\n \
    \      information (if the NTLP works this way) on signaling application\n   \
    \    messages, or they might even combine soft-state management\n       between\
    \ layers.  The state machines of the NTLP and NSLPs remain\n       logically independent,\
    \ but an implementation is free to allow\n       them to interact to reduce the\
    \ load on the network to the same\n       level that would be achieved by a monolithic\
    \ model.\n   4.  It may be helpful for signaling applications to receive\n   \
    \    state-management related 'triggers' from the NTLP indicating that\n     \
    \  a peer has failed or become available (\"down/up notifications\").\n      \
    \ These triggers would be about adjacent NTLP peers, rather than\n       signaling\
    \ application peers.  We can consider this another case\n       of route change\
    \ detection/notification (which the NTLP is also\n       allowed to do anyway).\
    \  However, apart from generating such\n       triggers, the NTLP takes no action\
    \ itself on such events, other\n       than to ensure that subsequent signaling\
    \ messages are routed\n       correctly.\n   5.  The existence of these triggers\
    \ doesn't replace NSLP refreshes as\n       the mechanism for maintaining liveness\
    \ at the signaling\n       application level.  In this sense, up/down notifications\
    \ are\n       advisories that allow faster reaction to events in the network,\n\
    \       but that shouldn't be built into NSLP semantics.  (This is\n       essentially\
    \ the same distinction, with the same rationale, that\n       SNMP makes between\
    \ notifications and normal message exchanges.)\n"
- title: 3.2.6.  Path-Decoupled Operation
  contents:
  - "3.2.6.  Path-Decoupled Operation\n   Path-decoupled signaling is defined as signaling\
    \ for state\n   installation along the data path, without the restriction of passing\n\
    \   only through nodes that are located on the data path.  Signaling\n   messages\
    \ can be routed to nodes that are off the data path, but that\n   are (presumably)\
    \ aware of it.  This allows a looser coupling between\n   signaling and data plane\
    \ nodes (e.g., at the autonomous system\n   level).  Although support for path-decoupled\
    \ operation is not one of\n   the initial goals of the NSIS work, this section\
    \ is included for\n   completeness and to capture some initial considerations\
    \ for future\n   reference.\n   The main advantages of path-decoupled signaling\
    \ are ease of\n   deployment and support of additional functionality.  The ease\
    \ of\n   deployment comes from a restriction of the number of impacted nodes\n\
    \   in case of deployment and/or upgrade of an NSLP.  Path-decoupled\n   signaling\
    \ would allow, for instance, deploying a solution without\n   upgrading any of\
    \ the routers in the data plane.  Additional\n   functionality that can be supported\
    \ includes the use of off-path\n   proxies to support authorization or accounting\
    \ architectures.\n   There are potentially significant differences in the way\
    \ that the two\n   signaling paradigms should be analyzed.  Using a single centralized\n\
    \   off-path NE may increase the requirements in terms of message\n   handling;\
    \ on the other hand, path-decoupled signaling is equally\n   applicable to distributed\
    \ off-path entities.  Failure recovery\n   scenarios need to be analyzed differently\
    \ because fate-sharing\n   between data and control planes can no longer be assumed.\n\
    \   Furthermore, the interpretation of sender/receiver orientation\n   becomes\
    \ less natural.  With the local operation of the NTLP, the\n   impact of path-decoupled\
    \ signaling on the routing of signaling\n   messages is presumably restricted\
    \ to the problem of peer\n   determination.  The assumption that the off-path\
    \ NSIS nodes are\n   loosely tied to the data path suggests, however, that peer\n\
    \   determination can still be based on L3 routing information.  This\n   means\
    \ that a path-decoupled signaling solution could be implemented\n   using a lower-layer\
    \ protocol presenting the same service interface to\n   NSLPs as the path-coupled\
    \ NTLP.  A new message transport protocol\n   (possibly derived from the path-coupled\
    \ NTLP) would be needed, but\n   NSLP specifications and the inter-layer interaction\
    \ would be\n   unchanged from the path-coupled case.\n"
- title: 3.3.  Signaling Application Properties
  contents:
  - "3.3.  Signaling Application Properties\n   It is clear that many signaling applications\
    \ will require specific\n   protocol behavior in their NSLP.  This section outlines\
    \ some of the\n   options for NSLP behavior; further work on selecting from these\n\
    \   options would depend on detailed analysis of the signaling\n   application\
    \ in question.\n"
- title: 3.3.1.  Sender/Receiver Orientation
  contents:
  - "3.3.1.  Sender/Receiver Orientation\n   In some signaling applications, a node\
    \ at one end of the data flow\n   takes responsibility for requesting special\
    \ treatment (such as a\n   resource reservation) from the network.  Which end\
    \ may depend on the\n   signaling application, or on characteristics of the network\n\
    \   deployment.\n   In a sender-initiated approach, the sender of the data flow\
    \ requests\n   and maintains the treatment for that flow.  In a receiver-initiated\n\
    \   approach, the receiver of the data flow requests and maintains the\n   treatment\
    \ for that flow.  The NTLP itself has no freedom in this\n   area: Next NTLP peers\
    \ have to be discovered in the sender-to-receiver\n   direction, but after that\
    \ the default assumption is that signaling is\n   possible both upstream and downstream\
    \ (unless a signaling application\n   specifically indicates that this is not\
    \ required).  This implies that\n   backward routing state must be maintained\
    \ by the NTLP or that\n   backward routing information must be available in the\
    \ signaling\n   message.\n   The sender- and receiver-initiated approaches have\
    \ several\n   differences in their operational characteristics.  The main ones\
    \ are\n   as follows:\n   o  In a receiver-initiated approach, the signaling messages\
    \ traveling\n      from the receiver to the sender must be backward routed such\
    \ that\n      they follow exactly the same path as was followed by the signaling\n\
    \      messages belonging to the same flow traveling from the sender to\n    \
    \  the receiver.  In a sender-initiated approach, provided that\n      acknowledgements\
    \ and notifications can be delivered securely to\n      the sending node, backward\
    \ routing is not necessary, and nodes do\n      not have to maintain backward\
    \ routing state.\n   o  In a sender-initiated approach, a mobile node can initiate\
    \ a\n      reservation for its outgoing flows as soon as it has moved to\n   \
    \   another roaming subnetwork.  In a receiver-initiated approach, a\n      mobile\
    \ node has to inform the receiver about its handover, thus\n      allowing the\
    \ receiver to initiate a reservation for these flows.\n      For incoming flows,\
    \ the reverse argument applies.\n   o  In general, setup and modification will\
    \ be fastest if the node\n      responsible for authorizing these actions can\
    \ initiate them\n      directly within the NSLP.  A mismatch between authorizing\
    \ and\n      initiating NEs will cause additional message exchanges, either in\n\
    \      the NSLP or in a protocol executed prior to NSIS invocation.\n      Depending\
    \ on how the authorization for a particular signaling\n      application is done,\
    \ this may favor either sender- or receiver-\n      initiated signaling.  Note\
    \ that this may complicate modification\n      of network control state for existing\
    \ flows.\n"
- title: 3.3.2.  Uni- and Bi-Directional Operation
  contents:
  - "3.3.2.  Uni- and Bi-Directional Operation\n   For some signaling applications\
    \ and scenarios, signaling may only be\n   considered for a unidirectional data\
    \ flow.  However, in other cases,\n   there may be interesting relationships in\
    \ the signaling between the\n   two flows of a bi-directional session; an example\
    \ is QoS for a voice\n   call.  Note that the path in the two directions may differ\
    \ due to\n   asymmetric routing.  In the basic case, bi-directional signaling\
    \ can\n   simply use a separate instance of the same signaling mechanism in\n\
    \   each direction.\n   In constrained topologies where parts of the route are\
    \ symmetric, it\n   may be possible to use a more unified approach to bi-directional\n\
    \   signaling; e.g., carrying the two signaling directions in common\n   messages.\
    \  This optimization might be used for example to make mobile\n   QoS signaling\
    \ more efficient.\n   In either case, the correlation of the signaling for the\
    \ two flow\n   directions is carried out in the NSLP.  The NTLP would simply be\n\
    \   enabled to bundle the messages together.\n"
- title: 3.3.3.  Heterogeneous Operation
  contents:
  - "3.3.3.  Heterogeneous Operation\n   It is likely that the appropriate way to\
    \ describe the state for which\n   NSIS is signaling will vary from one part of\
    \ the network to another\n   (depending on the signaling application).  For example,\
    \ in the QoS\n   case, resource descriptions that are valid for inter-domain links\n\
    \   will probably be different from those useful for intra-domain\n   operation\
    \ (and the latter will differ from one domain to another).\n   One way to address\
    \ this issue is to consider the state description\n   used within the NSLP as\
    \ carried in globally-understood objects and\n   locally-understood objects. \
    \ The local objects are only applicable\n   for intra-domain signaling, while\
    \ the global objects are mainly used\n   in inter-domain signaling.  Note that\
    \ the local objects are still\n   part of the protocol but are inserted, used,\
    \ and removed by one\n   single domain.\n   The purpose of this division is to\
    \ provide additional flexibility in\n   defining the objects carried by the NSLP\
    \ such that only the objects\n   applicable in a particular setting are used.\
    \  One approach for\n   reflecting the distinction is that local objects could\
    \ be put into\n   separate local messages that are initiated and terminated within\
    \ one\n   single domain; an alternative is that they could be \"stacked\" within\n\
    \   the NSLP messages that are used anyway for inter-domain signaling.\n"
- title: 3.3.4.  Aggregation
  contents:
  - "3.3.4.  Aggregation\n   It is a well-known problem that per-flow signaling in\
    \ large-scale\n   networks presents scaling challenges because of the large number\
    \ of\n   flows that may traverse individual nodes.\n   The possibilities for aggregation\
    \ at the level of the NTLP are quite\n   limited; the primary scaling approach\
    \ for path-coupled signaling is\n   for a signaling application to group flows\
    \ together and to perform\n   signaling for the aggregate, rather than for the\
    \ flows individually.\n   The aggregate may be created in a number of ways; for\
    \ example, the\n   individual flows may be sent down a tunnel, or given a common\n\
    \   Differentiated Services Code Point (DSCP) marking.  The aggregation\n   and\
    \ de-aggregation points perform per flow signaling, but nodes\n   within the aggregation\
    \ region should only be forced to process\n   signaling messages for the aggregate.\
    \  This depends on the ability of\n   the interior nodes to ignore the per-flow\
    \ signaling as discussed in\n   Section 3.2.3.\n   Individual NSLPs will need\
    \ to specify what aggregation means in their\n   context, and how it should be\
    \ performed.  For example, in the QoS\n   context it is possible to add together\
    \ the resources specified in a\n   number of separate reservations.  In the case\
    \ of other applications,\n   such as signaling to NATs and firewalls, the feasibility\
    \ (and even\n   the meaning) of aggregation is less clear.\n"
- title: 3.3.5.  Peer-Peer and End-End Relationships
  contents:
  - "3.3.5.  Peer-Peer and End-End Relationships\n   The assumption in this framework\
    \ is that the NTLP will operate\n   'locally'; that is, just over the scope of\
    \ a single peer\n   relationship.  End-to-end operation is built up by concatenating\n\
    \   these relationships.  Non-local operation (if any) will take place in\n  \
    \ NSLPs.\n   The peering relations may also have an impact on the required amount\n\
    \   of state at each NSIS entity.  When direct interaction with remote\n   peers\
    \ is not allowed, it may be required to keep track of the path\n   that a message\
    \ has followed through the network.  This could be\n   achieved by keeping per-flow\
    \ state at the NSIS entities, as is done\n   in RSVP.  Another approach would\
    \ be to maintain a record route object\n   in the messages; this object would\
    \ be carried within the NSIS\n   protocols, rather than depend on the route-recording\
    \ functionality\n   provided by the IP layer.\n"
- title: 3.3.6.  Acknowledgements and Notifications
  contents:
  - "3.3.6.  Acknowledgements and Notifications\n   We are assuming that the NTLP\
    \ provides a simple message transfer\n   service, and that any acknowledgements\
    \ or notifications it generates\n   are handled purely internally (and apply within\
    \ the scope of a single\n   NTLP peer relationship).\n   However, we expect that\
    \ some signaling applications will require\n   acknowledgements regarding the\
    \ failure/success of state installation\n   along the data path, and this will\
    \ be an NSLP function.\n   Acknowledgements can be sent along the sequence of\
    \ NTLP peer\n   relationships towards the signaling initiator, which relieves\
    \ the\n   requirements on the security associations that need to be maintained\n\
    \   by NEs and that can allow NAT traversal in both directions.  (If this\n  \
    \ direction is towards the sender, it implies maintaining reverse\n   routing\
    \ state in the NTLP.)  In certain circumstances (e.g., trusted\n   domains), an\
    \ optimization could be to send acknowledgements directly\n   to the signaling\
    \ initiator outside the NTLP (see Section 3.2.2),\n   although any such approach\
    \ would have to take into account the\n   necessity of handling denial of service\
    \ attacks launched from outside\n   the network.\n   The semantics of the acknowledgement\
    \ messages are of particular\n   importance.  An NE sending a message could assume\
    \ responsibility for\n   the entire downstream chain of NEs, indicating (for instance)\
    \ the\n   availability of reserved resources for the entire downstream path.\n\
    \   Alternatively, the message could have a more local meaning,\n   indicating\
    \ (for instance) that a certain failure or degradation\n   occurred at a particular\
    \ point in the network.\n   Notifications differ from acknowledgements because\
    \ they are not\n   (necessarily) generated in response to other signaling messages.\n\
    \   This means that it may not be obvious how to determine where the\n   notification\
    \ should be sent.  Other than that, the same\n   considerations apply as for acknowledgements.\
    \  One useful distinction\n   to make would be to differentiate between notifications\
    \ that trigger\n   a signaling action and others that don't.  The security requirements\n\
    \   for the latter are less stringent, which means they could be sent\n   directly\
    \ to the NE they are destined for (provided that this NE can\n   be determined).\n"
- title: 3.3.7.  Security and Other AAA Issues
  contents:
  - "3.3.7.  Security and Other AAA Issues\n   In some cases, it will be possible\
    \ to achieve the necessary level of\n   signaling security by using basic 'channel\
    \ security' mechanisms [11]\n   at the level of the NTLP, and the possibilities\
    \ are described in\n   Section 4.7.  In other cases, signaling applications may\
    \ have\n   specific security requirements, in which case they are free to invoke\n\
    \   their own authentication and key exchange mechanisms and to apply\n   'object\
    \ security' to specific fields within the NSLP messages.\n   In addition to authentication,\
    \ the authorization (to manipulate\n   network control state) has to be considered\
    \ as functionality above\n   the NTLP level, since it will be entirely application\
    \ specific.\n   Indeed, authorization decisions may be handed off to a third party\
    \ in\n   the protocol (e.g., for QoS, the resource management function as\n  \
    \ described in Section 6.1.4).  Many different authorization models are\n   possible,\
    \ and the variations impact:\n   o  what message flows take place -- for example,\
    \ whether\n      authorization information is carried along with a control state\n\
    \      modification request or is sent in the reverse direction in\n      response\
    \ to it;\n   o  what administrative relationships are required -- for example,\n\
    \      whether authorization takes place only between peer signaling\n      applications,\
    \ or over longer distances.\n   Because the NTLP operates only between adjacent\
    \ peers and places no\n   constraints on the direction or order in which signaling\
    \ applications\n   can send messages, these authorization aspects are left open\
    \ to be\n   defined by each NSLP.  Further background discussion of this issue\
    \ is\n   contained in [12].\n"
- title: 4.  The NSIS Transport Layer Protocol
  contents:
  - "4.  The NSIS Transport Layer Protocol\n   This section describes the overall\
    \ functionality required from the\n   NTLP.  It mentions possible protocol components\
    \ within the NTLP layer\n   and the different possible addressing modes that can\
    \ be utilized, as\n   well as the assumed transport and state management functionality.\n\
    \   The interfaces between NTLP and the layers above and below it are\n   identified,\
    \ with a description of the identity elements that appear\n   on these interfaces.\n\
    \   This discussion is not intended to design the NTLP or even to\n   enumerate\
    \ design options, although some are included as examples.\n   The goal is to provide\
    \ a general discussion of required functionality\n   and to highlight some of\
    \ the issues associated with this.\n"
- title: 4.1.  Internal Protocol Components
  contents:
  - "4.1.  Internal Protocol Components\n   The NTLP includes all functionality below\
    \ the signaling application\n   layer and above the IP layer.  The functionality\
    \ that is required\n   within the NTLP is outlined in Section 3.2.4, with some\
    \ more details\n   in Sections 3.2.5 and 4.3.\n   Some NTLP functionality could\
    \ be provided via components operating as\n   sublayers within the NTLP design.\
    \  For example, if specific transport\n   capabilities are required (such as congestion\
    \ avoidance,\n   retransmission, and security), then existing protocols (such\
    \ as\n   TCP+TLS or DCCP+IPsec) could be incorporated into the NTLP.  This\n \
    \  possibility is not required or excluded by this framework.\n   If peer-peer\
    \ addressing (Section 4.2) is used for some messages, then\n   active next-peer\
    \ discovery functionality will be required within the\n   NTLP to support the\
    \ explicit addressing of these messages.  This\n   could use message exchanges\
    \ for dynamic peer discovery as a sublayer\n   within the NTLP; there could also\
    \ be an interface to external\n   mechanisms to carry out this function.\n   \
    \             ====================      ===========================\n        \
    \     ^  +------------------+      +-------------------------+\n             |\
    \  |                  |      | NSIS Specific Functions |\n             |  |  \
    \                |      |            .............|\n      NSIS   |  |    Monolithic\
    \    |      |+----------+.   Peer    .|\n   Transport |  |     Protocol     |\
    \      || Existing |. Discovery .|\n     Layer   |  |                  |     \
    \ || Protocol |.  Aspects  .|\n             |  |                  |      |+----------+.............|\n\
    \             V  +------------------+      +-------------------------+\n     \
    \           ====================      ===========================\n          \
    \         Figure 6: Options for NTLP Structure\n"
- title: 4.2.  Addressing
  contents:
  - "4.2.  Addressing\n   There are two ways to address a signaling message being\
    \ transmitted\n   between NTLP peers:\n   o  peer-peer, where the message is addressed\
    \ to a neighboring NSIS\n      entity that is known to be closer to the destination\
    \ NE.\n   o  end-to-end, where the message is addressed to the flow destination\n\
    \      directly and intercepted by an intervening NE.\n   With peer-peer addressing,\
    \ an NE will determine the address of the\n   next NE based on the payload of\
    \ the message (and potentially on the\n   previous NE).  This requires that the\
    \ address of the destination NE\n   be derivable from the information present\
    \ in the payload, either by\n   using some local routing table or through participation\
    \ in active\n   peer discovery message exchanges.  Peer-peer addressing inherently\n\
    \   supports tunneling of messages between NEs, and is equally applicable\n  \
    \ to the path-coupled and path-decoupled cases.\n   In the case of end-to-end\
    \ addressing, the message is addressed to the\n   data flow receiver, and (some\
    \ of) the NEs along the data path\n   intercept the messages.  The routing of\
    \ the messages should follow\n   exactly the same path as the associated data\
    \ flow (but see\n   Section 5.1.1 on this point).  Note that securing messages\
    \ sent this\n   way raises some interesting security issues (these are discussed\
    \ in\n   [2]).  In addition, it is a matter of the protocol design what should\n\
    \   be used as the source address of the message (the flow source or\n   signaling\
    \ source).\n   It is not possible at this stage to mandate one addressing mode\
    \ or\n   the other.  Indeed, each is necessary for some aspects of NTLP\n   operation:\
    \ In particular, initial discovery of the next downstream\n   peer will usually\
    \ require end-to-end addressing, whereas reverse\n   routing will always require\
    \ peer-peer addressing.  For other message\n   types, the choice is a matter of\
    \ protocol design.  The mode used is\n   not visible to the NSLP, and the information\
    \ needed in each case is\n   available from the flow identifier (Section 4.6.1)\
    \ or locally stored\n   NTLP state.\n"
- title: 4.3.  Classical Transport Functions
  contents:
  - "4.3.  Classical Transport Functions\n   The NSIS signaling protocols are responsible\
    \ for transporting\n   (signaling) data around the network; in general, this requires\n\
    \   functionality such as congestion management, reliability, and so on.\n   This\
    \ section discusses how much of this functionality should be\n   provided within\
    \ the NTLP.  It appears that this doesn't affect the\n   basic way in which the\
    \ NSLP/NTLP layers relate to each other (e.g.,\n   in terms of the semantics of\
    \ the inter-layer interaction); it is much\n   more a question of the overall\
    \ performance/complexity tradeoff\n   implied by placing certain functions within\
    \ each layer.\n   Note that, per the discussion at the end of Section 3.2.3, there\
    \ may\n   be cases where intermediate nodes wish to modify messages in transit\n\
    \   even though they do not perform full signaling application\n   processing.\
    \  In this case, not all the following functionality would\n   be invoked at every\
    \ intermediate node.\n   The following functionality is assumed to lie within\
    \ the NTLP:\n   1.  Bundling together of small messages (comparable to [13]) can\
    \ be\n       provided locally by the NTLP as an option, if desired; it doesn't\n\
    \       affect the operation of the network elsewhere.  The NTLP should\n    \
    \   always support unbundling, to avoid the cost of negotiating the\n       feature\
    \ as an option.  (The related function of refresh\n       summarization -- where\
    \ objects in a refresh message are replaced\n       with a reference to a previous\
    \ message identifier -- is left to\n       NSLPs, which can then do this in a\
    \ way tuned to the state\n       management requirements of the signaling application.\
    \  Additional\n       transparent compression functionality could be added to\
    \ the NTLP\n       design later as a local option.)  Note that end-to-end addressed\n\
    \       messages for different flows cannot be bundled safely unless the\n   \
    \    next node on the outgoing interface is known to be NSIS-aware.\n   2.  When\
    \ needed, message fragmentation should be provided by the\n       NTLP.  The use\
    \ of IP fragmentation for large messages may lead to\n       reduced reliability\
    \ and may be incompatible with some addressing\n       schemes.  Therefore, this\
    \ functionality should be provided within\n       the NTLP as a service for NSLPs\
    \ that generate large messages.\n       How the NTLP determines and accommodates\
    \ Maximum Transmission\n       Unit (MTU) constraints is left as a matter of protocol\
    \ design.\n       To avoid imposing the cost of reassembly on intermediate nodes,\n\
    \       the fragmentation scheme used should allow for the independent\n     \
    \  forwarding of individual fragments towards a node hosting an\n       interested\
    \ NSLP.\n   3.  There can be significant benefits for signaling applications if\n\
    \       state-changing messages are delivered reliably (as introduced in\n   \
    \    [13] for RSVP; see also the more general analysis of [14]).  This\n     \
    \  does not change any assumption about the use of soft-state by\n       NSLPs\
    \ to manage signaling application state, and it leaves the\n       responsibility\
    \ for detecting and recovering from application\n       layer error conditions\
    \ in the NSLP.  However, it means that such\n       functionality does not need\
    \ to be tuned to handle fast recovery\n       from message loss due to congestion\
    \ or corruption in the lower\n       layers, and it also means that the NTLP can\
    \ prevent the\n       amplification of message loss rates caused by fragmentation.\n\
    \       Reliable delivery functionality is invoked by the NSLP on a\n       message-by-message\
    \ basis and is always optional to use.\n   4.  The NTLP should not allow signaling\
    \ messages to cause congestion\n       in the network (i.e., at the IP layer).\
    \  Congestion could be\n       caused by retransmission of lost signaling packets\
    \ or by upper\n       layer actions (e.g., a flood of signaling updates to recover\
    \ from\n       a route change).  In some cases, it may be possible to engineer\n\
    \       the network to ensure that signaling cannot overload it; in\n       others,\
    \ the NTLP would have to detect congestion and to adapt the\n       rate at which\
    \ it allows signaling messages to be transmitted.\n       Principles of congestion\
    \ control in Internet protocols are given\n       in [15].  The NTLP may or may\
    \ not be able to detect overload in\n       the control plane itself (e.g., an\
    \ NSLP-aware node several\n       NTLP-hops away that cannot keep up with the\
    \ incoming message\n       rate) and indicate this as a flow-control condition\
    \ to local\n       signaling applications.  However, for both the congestion and\n\
    \       overload cases, it is up to the signaling applications themselves\n  \
    \     to adapt their behavior accordingly.\n"
- title: 4.4.  Lower Layer Interfaces
  contents:
  - "4.4.  Lower Layer Interfaces\n   The NTLP interacts with 'lower layers' of the\
    \ protocol stack for the\n   purposes of sending and receiving signaling messages.\
    \  This framework\n   places the lower boundary of the NTLP at the IP layer. \
    \ The interface\n   to the lower layer is therefore very simple:\n   o  The NTLP\
    \ sends raw IP packets\n   o  The NTLP receives raw IP packets.  In the case of\
    \ peer-peer\n      addressing, they have been addressed directly to it.  In the\
    \ case\n      of end-to-end addressing, this will be achieved by intercepting\n\
    \      packets that have been marked in some special way (by special\n      protocol\
    \ number or by some option interpreted within the IP layer,\n      such as the\
    \ router alert option).\n   o  The NTLP receives indications from the IP layer\
    \ (including local\n      forwarding tables and routing protocol state) that provide\
    \ some\n      information about route changes and similar events (see\n      Section\
    \ 5.1).\n   For correct message routing, the NTLP needs to have some information\n\
    \   about link and IP layer configuration of the local networking stack.\n   In\
    \ general, it needs to know how to select the outgoing interface for\n   a signaling\
    \ message and where this must match the interface that will\n   be used by the\
    \ corresponding flow.  This might be as simple as just\n   allowing the IP layer\
    \ to handle the message using its own routing\n   table.  There is no intention\
    \ to do something different from IP\n   routing (for end-to-end addressed messages);\
    \ however, some hosts\n   allow applications to bypass routing for their data\
    \ flows, and the\n   NTLP processing must account for this.  Further network layer\n\
    \   information would be needed to handle scoped addresses (if such\n   things\
    \ ever exist).\n   Configuration of lower-layer operation to handle flows in particular\n\
    \   ways is handled by the signaling application.\n"
- title: 4.5.  Upper Layer Services
  contents:
  - "4.5.  Upper Layer Services\n   The NTLP offers transport-layer services to higher-layer\
    \ signaling\n   applications for two purposes: sending and receiving signaling\n\
    \   messages, and exchanging control and feedback information.\n   For sending\
    \ and receiving messages, two basic control primitives are\n   required:\n   o\
    \  Send Message, to allow the signaling application to pass data to\n      the\
    \ NTLP for transport.\n   o  Receive Message, to allow the NTLP to pass received\
    \ data to the\n      signaling application.\n   The NTLP and signaling application\
    \ may also want to exchange other\n   control information, such as the following:\n\
    \   o  Signaling application registration/de-registration, so that\n      particular\
    \ signaling application instances can register their\n      presence with the\
    \ transport layer.  This may also require some\n      identifier to be agreed\
    \ upon between the NTLP and signaling\n      application to support the exchange\
    \ of further control information\n      and to allow the de-multiplexing of incoming\
    \ data.\n   o  NTLP configuration, allowing signaling applications to indicate\n\
    \      what optional NTLP features they want to use, and to configure\n      NTLP\
    \ operation, such as controlling what transport layer state\n      should be maintained.\n\
    \   o  Error messages, to allow the NTLP to indicate error conditions to\n   \
    \   the signaling application, and vice versa.\n   o  Feedback information, such\
    \ as route change indications so that the\n      signaling application can decide\
    \ what action to take.\n"
- title: 4.6.  Identity Elements
  contents:
  - '4.6.  Identity Elements

    '
- title: 4.6.1.  Flow Identification
  contents:
  - "4.6.1.  Flow Identification\n   The flow identification is a method of identifying\
    \ a flow in a unique\n   way.  All packets associated with the same flow will\
    \ be identified by\n   the same flow identifier.  The key aspect of the flow identifier\
    \ is\n   to provide enough information such that the signaling flow receives\n\
    \   the same treatment along the data path as the actual data itself;\n   i.e.,\
    \ consistent behavior is applied to the signaling and data flows\n   by a NAT\
    \ or policy-based forwarding engine.\n   Information that could be used in flow\
    \ identification may include:\n   o  source IP address;\n   o  destination IP\
    \ address;\n   o  protocol identifier and higher layer (port) addressing;\n  \
    \ o  flow label (typical for IPv6);\n   o  SPI field for IPsec encapsulated data;\
    \ and\n   o  DSCP/TOS field.\n   It is assumed that at most limited wildcarding\
    \ on these identifiers\n   is needed.\n   We assume here that the flow identification\
    \ is not hidden within the\n   NSLP, but is explicitly part of the NTLP.  The\
    \ justification for this\n   is that being able to do NSIS processing, even at\
    \ a node which was\n   unaware of the specific signaling application (see Section\
    \ 3.2.3)\n   might be valuable.  An example scenario would be messages passing\n\
    \   through an addressing boundary where the flow identification had to\n   be\
    \ re-written.\n"
- title: 4.6.2.  Session Identification
  contents:
  - "4.6.2.  Session Identification\n   There are circumstances in which being able\
    \ to refer to signaling\n   application state independently of the underlying\
    \ flow is important.\n   For example, if the address of one of the flow endpoints\
    \ changes due\n   to a mobility event, it is desirable to be able to change the\
    \ flow\n   identifier without having to install a completely new reservation.\n\
    \   The session identifier provides a method to correlate the signaling\n   about\
    \ the different flows with the same network control state.\n   The session identifier\
    \ is essentially a signaling application\n   concept, since it is only used in\
    \ non-trivial state management\n   actions that are application specific.  However,\
    \ we assume here that\n   it should be visible within the NTLP.  This enables\
    \ it to be used to\n   control NTLP behavior; for example, by controlling how\
    \ the transport\n   layer should forward packets belonging to this session (as\
    \ opposed to\n   this signaling application).  In addition, the session identifier\
    \ can\n   be used by the NTLP to demultiplex received signaling messages\n   between\
    \ multiple instances of the same signaling application, if such\n   an operational\
    \ scenario is supported (see Section 4.6.3 for more\n   information on signaling\
    \ application identification).\n   To be useful for mobility support, the session\
    \ identifier should be\n   globally unique, and it should not be modified end-to-end.\
    \  It is\n   well known that it is practically impossible to generate identifiers\n\
    \   in a way that guarantees this property; however, using a large random\n  \
    \ number makes it highly likely.  In any case, the NTLP ascribes no\n   valuable\
    \ semantics to the identifier (such as 'session ownership');\n   this problem\
    \ is left to the signaling application, which may be able\n   to secure it to\
    \ be used for this purpose.\n"
- title: 4.6.3.  Signaling Application Identification
  contents:
  - "4.6.3.  Signaling Application Identification\n   Because the NTLP can be used\
    \ to support several NSLP types, there is\n   a need to identify which type a\
    \ particular signaling message exchange\n   is being used for.  This is to support:\n\
    \   o  processing of incoming messages -- the NTLP should be able to\n      demultiplex\
    \ these towards the appropriate signaling applications;\n      and\n   o  processing\
    \ of general messages at an NSIS-aware intermediate node\n      -- if the node\
    \ does not handle the specific signaling application,\n      it should be able\
    \ to make a forwarding decision without having to\n      parse upper-layer information.\n\
    \   No position is taken on the form of the signaling application\n   identifier,\
    \ or even the structure of the signaling application\n   'space': free-standing\
    \ applications, potentially overlapping groups\n   of capabilities, etc.  These\
    \ details should not influence the rest of\n   the NTLP design.\n"
- title: 4.7.  Security Properties
  contents:
  - "4.7.  Security Properties\n   It is assumed that the only security service required\
    \ within the NTLP\n   is channel security.  Channel security requires a security\n\
    \   association to be established between the signaling endpoints, which\n   is\
    \ carried out via some authentication and key management exchange.\n   This functionality\
    \ could be provided by reusing a standard protocol.\n   In order to protect a\
    \ particular signaling exchange, the NSIS entity\n   needs to select the security\
    \ association that it has in place with\n   the next NSIS entity that will be\
    \ receiving the signaling message.\n   The ease of doing this depends on the addressing\
    \ model in use by the\n   NTLP (see Section 4.2).\n   Channel security can provide\
    \ many different types of protection to\n   signaling exchanges, including integrity\
    \ and replay protection and\n   encryption.  It is not clear which of these is\
    \ required at the NTLP\n   layer, although most channel security mechanisms support\
    \ them all.\n   It is also not clear how tightly an NSLP can 'bind' to the channel\n\
    \   security service provided by the NTLP.\n   Channel security can also be applied\
    \ to the signaling messages with\n   differing granularity; i.e., all or parts\
    \ of the signaling message\n   may be protected.  For example, if the flow is\
    \ traversing a NAT, only\n   the parts of the message that do not need to be processed\
    \ by the NAT\n   should be protected.  (Alternatively, if the NAT takes part in\
    \ NTLP\n   security procedures, it only needs to be given access to the message\n\
    \   fields containing addresses, often just the flow id.)  Which parts of\n  \
    \ the NTLP messages need protecting is an open question, as is what\n   type of\
    \ protection should be applied to each.\n"
- title: 5.  Interactions with Other Protocols
  contents:
  - '5.  Interactions with Other Protocols

    '
- title: 5.1.  IP Routing Interactions
  contents:
  - "5.1.  IP Routing Interactions\n   The NTLP is responsible for determining the\
    \ next node to be visited\n   by the signaling protocol.  For path-coupled signaling,\
    \ this next\n   node should be one that will be visited by the data flow.  In\n\
    \   practice, this peer discovery will be approximate, as any node could\n   use\
    \ any feature of the peer discovery packet to route it differently\n   from the\
    \ corresponding data flow packets.  Divergence between the\n   data and signaling\
    \ paths can occur due to load sharing or load\n   balancing (Section 5.1.1). \
    \ An example specific to the case of QoS is\n   given in Section 6.1.1.  Route\
    \ changes cause a temporary divergence\n   between the data path and the path\
    \ on which signaling state has been\n   installed.  The occurrence, detection,\
    \ and impact of route changes is\n   described in Section 5.1.2.  A description\
    \ of this issue in the\n   context of QoS is given in Section 6.1.2.\n"
- title: 5.1.1.  Load Sharing and Policy-Based Forwarding
  contents:
  - "5.1.1.  Load Sharing and Policy-Based Forwarding\n   Load sharing or load balancing\
    \ is a network optimization technique\n   that exploits the existence of multiple\
    \ paths to the same destination\n   in order to obtain benefits in terms of protection,\
    \ resource\n   efficiency, or network stability.  It has been proposed for a number\n\
    \   of routing protocols, such as OSPF [16] and others.  In general, load\n  \
    \ sharing means that packet forwarding will take into account header\n   fields\
    \ in addition to the destination address; a general discussion\n   of such techniques\
    \ and the problems they cause is provided in [17].\n   The significance of load\
    \ sharing in the context of NSIS is that\n   routing of signaling messages using\
    \ end-to-end addressing does not\n   guarantee that these messages will follow\
    \ the data path.  Policy-\n   based forwarding for data packets -- where the outgoing\
    \ link is\n   selected based on policy information about fields additional to\
    \ the\n   packet destination address -- has the same impact.  Signaling and\n\
    \   data packets may diverge because of both of these techniques.\n   If signaling\
    \ packets are given source and destination addresses\n   identical to data packets,\
    \ signaling and data may still diverge\n   because of layer-4 load balancing (based\
    \ on protocol or port).  Such\n   techniques would also cause ICMP errors to be\
    \ misdirected to the\n   source of the data because of source address spoofing.\
    \  If signaling\n   packets are made identical in the complete 5-tuple, divergence\
    \ may\n   still occur because of the presence of router alert options.  The\n\
    \   same ICMP misdirection applies, and it becomes difficult for the end\n   systems\
    \ to distinguish between data and signaling packets.  Finally,\n   QoS routing\
    \ techniques may base the routing decision on any field in\n   the packet header\
    \ (e.g., DSCP).\n"
- title: 5.1.2.  Route Changes
  contents:
  - "5.1.2.  Route Changes\n   In a connectionless network, each packet is independently\
    \ routed\n   based on its header information.  Whenever a better route towards\
    \ the\n   destination becomes available, this route is installed in the\n   forwarding\
    \ table and will be used for all subsequent (data and\n   signaling) packets.\
    \  This can cause a divergence between the path\n   along which state has been\
    \ installed and the path along which\n   forwarding will actually take place.\
    \  The problem of route changes is\n   reduced if route pinning is performed.\
    \  Route pinning refers to the\n   independence of the path taken by certain data\
    \ packets from\n   reachability changes caused by routing updates from an Interior\n\
    \   Gateway Protocol (OSPF, IS-IS) or an Exterior Gateway Protocol (BGP).\n  \
    \ Nothing about NSIS signaling prevents route pinning from being used\n   as a\
    \ network engineering technique, provided that it is done in a way\n   that preserves\
    \ the common routing of signaling and data.  However,\n   even if route pinning\
    \ is used, it cannot be depended on to prevent\n   all route changes (for example,\
    \ in the case of link failures).\n   Handling route changes requires the presence\
    \ of three processes in\n   the signaling protocol:\n   1.  route change detection\n\
    \   2.  installation of state on the new path\n   3.  removal of state on the\
    \ old path\n   Many route change detection methods can be used, some needing\n\
    \   explicit protocol support, and some of which are implementation-\n   internal.\
    \  They differ in their speed of reaction and in the types of\n   change they\
    \ can detect.  In rough order of increasing applicability,\n   they can be summarized\
    \ as follows:\n   1.  monitoring changes in local forwarding table state\n   2.\
    \  monitoring topology changes in a link-state routing protocol\n   3.  inference\
    \ from changes in data packet TTL\n   4.  inference from loss of packet stream\
    \ in a flow-aware router\n   5.  inference from changes in signaling packet TTL\n\
    \   6.  changed route of an end-to-end addressed signaling packet\n   7.  changed\
    \ route of a specific end-to-end addressed probe packet\n   These methods can\
    \ be categorized as being based on network monitoring\n   (methods 1-2), on data\
    \ packet monitoring (methods 3-4) and on\n   monitoring signaling protocol messages\
    \ (methods 5-7); method 6 is the\n   baseline method of RSVP.  The network monitoring\
    \ methods can only\n   detect local changes; in particular, method 1 can only\
    \ detect an\n   event that changes the immediate next downstream hop, and method\
    \ 2\n   can only detect changes within the scope of the link-state protocol.\n\
    \   Methods 5-7, which are contingent on monitoring signaling messages,\n   become\
    \ less effective as soft-state refresh rates are reduced.\n   When a route change\
    \ has been detected, it is important that state is\n   installed as quickly as\
    \ possible along the new path.  It is not\n   guaranteed that the new path will\
    \ be able to provide the same\n   characteristics that were available on the old\
    \ path.  To avoid\n   duplicate state installation or, worse, rejection of the\
    \ signaling\n   message because of previously installed state, it is important\
    \ to be\n   able to recognize the new signaling message as belonging to an\n \
    \  existing session.  In this respect, we distinguish between route\n   changes\
    \ with associated change of the flow identification (e.g., in\n   case of a mobility\
    \ event when the IP source might change) and route\n   changes without change\
    \ of the flow identification (e.g., in case of a\n   link failure along the path).\
    \  The former case requires an identifier\n   independent from the flow identification;\
    \ i.e., the session\n   identifier (Section 4.6.2).  Mobility issues are discussed\
    \ in more\n   detail in Section 5.2.\n   When state has been installed along the\
    \ new path, the existing state\n   on the old path needs to be removed.  With\
    \ the soft-state principle,\n   this will happen automatically because of the\
    \ lack of refresh\n   messages.  Depending on the refresh timer, however, it may\
    \ be\n   required to tear down this state much faster (e.g., because it is\n \
    \  tied to an accounting record).  In that case, the teardown message\n   needs\
    \ to be able to distinguish between the new path and the old\n   path.\n   In\
    \ some environments, it is desirable to provide connectivity and\n   per-flow\
    \ or per-class state management with high-availability\n   characteristics; i.e.,\
    \ with rapid transparent recovery, even in the\n   presence of route changes.\
    \  This may require interactions with\n   protocols that are used to manage the\
    \ routing in this case, such as\n   Virtual Router Redundancy Protocol (VRRP)\
    \ [18].\n   Our basic assumption about such interactions is that the NTLP would\n\
    \   be responsible for detecting the route change and ensuring that\n   signaling\
    \ messages were re-routed consistently (in the same way as\n   the data traffic).\
    \  However, further state re-synchronization\n   (including failover between 'main'\
    \ and 'standby' nodes in the high\n   availability case) would be the responsibility\
    \ of the signaling\n   application and its NSLP, and would possibly be triggered\
    \ by the\n   NTLP.\n"
- title: 5.2.  Mobility and Multihoming Interactions
  contents:
  - "5.2.  Mobility and Multihoming Interactions\n   The issues associated with mobility\
    \ and multihoming are a\n   generalization of the basic route change case of the\
    \ previous\n   section.  As well as the fact that packets for a given session\
    \ are no\n   longer traveling over a single topological path, the following extra\n\
    \   considerations arise:\n   1.  The use of IP-layer mobility and multihoming\
    \ means that more than\n       one IP source or destination address will be associated\
    \ with a\n       single session.  The same applies if application-layer solutions\n\
    \       (e.g., SIP-based approaches) are used.\n   2.  Mobile IP and associated\
    \ protocols use some special\n       encapsulations for some segments of the data\
    \ path.\n   3.  The double route may persist for some time in the network (e.g.,\n\
    \       in the case of a 'make-before-break' handover being done by a\n      \
    \ multihomed host).\n   4.  Conversely, the re-routing may be rapid and routine\
    \ (unlike\n       network-internal route changes), increasing the importance of\n\
    \       rapid state release on old paths.\n   The interactions between mobility\
    \ and signaling have been extensively\n   analyzed in recent years, primarily\
    \ in the context of RSVP and Mobile\n   IP interaction (e.g., the mobility discussion\
    \ of [5]), but also in\n   that of other types of network (e.g., [19]).  A general\
    \ review of the\n   fundamental interactions is given in [20], which provides\
    \ further\n   details on many of the subjects considered in this section.\n  \
    \ We assume that the signaling will refer to 'outer' IP headers when\n   defining\
    \ the flows it is controlling.  There are two main reasons for\n   this.  The\
    \ first is that the data plane will usually be unable to\n   work in terms of\
    \ anything else when implementing per-flow treatment\n   (e.g., we cannot expect\
    \ that a router will analyze inner headers to\n   decide how to schedule packets).\
    \  The second reason is that we are\n   implicitly relying on the security provided\
    \ by the network\n   infrastructure to ensure that the correct packets are given\
    \ the\n   special treatment being signaled for, and this is built on the\n   relationship\
    \ between packet source and destination addresses and\n   network topology.  (This\
    \ is essentially the same approach that is\n   used as the basis of route optimization\
    \ security in Mobile IPv6\n   [21].)  The consequence of this assumption is that\
    \ we see the packet\n   streams to (or from) different addresses as different\
    \ flows.  Where a\n   flow is carried inside a tunnel, it is seen as a different\
    \ flow\n   again.  The encapsulation issues (point (2) above) are therefore to\n\
    \   be handled the same way as other tunneling cases (Section 5.4).\n   Therefore,\
    \ the most critical aspect is that multiple flows are being\n   used, and the\
    \ signaling for them needs to be correlated.  This is the\n   intended role of\
    \ the session identifier (see Section 4.6.2, which\n   also describes some of\
    \ the security requirements for such an\n   identifier).  Although the session\
    \ identifier is visible at the NTLP,\n   the signaling application is responsible\
    \ for performing the\n   correlation (and for doing so securely).  The NTLP responsibility\
    \ is\n   limited to delivering the signaling messages for each flow between\n\
    \   the correct signaling application peers.  The locations at which the\n   correlation\
    \ takes place are the end system and the signaling-\n   application-aware node\
    \ in the network where the flows meet.  (This\n   node is generally referred to\
    \ as the \"crossover router\"; it can be\n   anywhere in the network.)\n   Although\
    \ much work has been done in the past on finding the crossover\n   router directly\
    \ from information held in particular mobility\n   signaling protocols, the initial\
    \ focus of NSIS work should be a\n   solution that is not tightly bound to any\
    \ single mobility approach.\n   In other words, it should be possible to determine\
    \ the crossover\n   router based on NSIS signaling.  (This doesn't rule out the\n\
    \   possibility that some implementations may be able to do this\n   discovery\
    \ faster; e.g., by being tightly integrated with local\n   mobility management\
    \ protocols.  This is directly comparable to\n   spotting route changes in fixed\
    \ networks by being routing aware.)\n   Note that the crossover router discovery\
    \ may involve end-to-end\n   signaling exchanges (especially for flows towards\
    \ the mobile or\n   multihomed node), which raises a latency concern.  On the\
    \ other hand,\n   end-to-end signaling will have been necessary in any case, at\
    \ the\n   application level not only to communicate changed addresses, but also\n\
    \   to update packet classifiers along the path.  It is a matter for\n   further\
    \ analysis to decide how these exchanges could be combined or\n   carried out\
    \ in parallel.\n   On the shared part of the path, signaling is needed at least\
    \ to\n   update the packet classifiers to include the new flow, although if\n\
    \   correlation with the existing flow is possible it should be possible\n   to\
    \ bypass any policy or admission control processing.  State\n   installation on\
    \ the new path (and possibly release on the old one)\n   are also required.  Which\
    \ entity (one of the end hosts or the\n   crossover router) controls all these\
    \ procedures depends on which\n   entities are authorized to carry out network\
    \ state manipulations, so\n   this is therefore a matter of signaling application\
    \ and NSLP design.\n   The approach may depend on the sender/receiver orientation\
    \ of the\n   original signaling (see Section 3.3.1).  In addition, in the mobility\n\
    \   case, the old path may no longer be directly accessible to the mobile\n  \
    \ node; inter-access-router communication may be required to release\n   state\
    \ in these circumstances.\n   The frequency of handovers in some network types\
    \ makes fast handover\n   support protocols desirable, for selecting the optimal\
    \ access router\n   for handover (for example, [22]), and for transferring state\n\
    \   information to avoid having to regenerate it in the new access router\n  \
    \ after handover (for example, [23]).  Both of these procedures could\n   have\
    \ strong interactions with signaling protocols.  The access router\n   selection\
    \ might depend on the network control state that could be\n   supported on the\
    \ path through the new access router.  Transfer of\n   signaling application state\
    \ or NTLP/NSLP protocol state may be a\n   candidate for context transfer.\n"
- title: 5.3.  Interactions with NATs
  contents:
  - "5.3.  Interactions with NATs\n   Because at least some messages will almost inevitably\
    \ contain\n   addresses and possibly higher-layer information as payload, we must\n\
    \   consider the interaction with address translation devices (NATs).\n   These\
    \ considerations apply both to 'traditional' NATs of various\n   types (as defined\
    \ in [24]) as well as some IPv4/v6 transition\n   mechanisms, such as Stateless\
    \ IP/ICMP Translation (SIIT) [25].\n   In the simplest case of an NSIS-unaware\
    \ NAT in the path, payloads\n   will be uncorrected, and signaling will refer\
    \ to the flow\n   incorrectly.  Applications could attempt to use STUN [26] or\
    \ similar\n   techniques to detect and recover from the presence of the NAT. \
    \ Even\n   then, NSIS protocols would have to use a well-known encapsulation\n\
    \   (TCP/UDP/ICMP) to avoid being dropped by more cautious low-end NAT\n   devices.\n\
    \   A simple 'NSIS-aware' NAT would require flow identification\n   information\
    \ to be in the clear and not to be integrity protected.  An\n   alternative conceptual\
    \ approach is to consider the NAT functionality\n   part of message processing\
    \ itself, in which case the translating node\n   can take part natively in any\
    \ NSIS protocol security mechanisms.\n   Depending on NSIS protocol layering,\
    \ it would be possible for this\n   processing to be done in an NSIS entity that\
    \ was otherwise ignorant\n   of any particular signaling applications.  This is\
    \ the motivation for\n   including basic flow identification information in the\
    \ NTLP\n   (Section 4.6.1).\n   Note that all of this discussion is independent\
    \ of the use of a\n   specific NSLP for general control of NATs (and firewalls).\
    \  That case\n   is considered in Section 6.2.\n"
- title: 5.4.  Interactions with IP Tunneling
  contents:
  - "5.4.  Interactions with IP Tunneling\n   Tunneling is used in the Internet for\
    \ a number of reasons, such as\n   flow aggregation, IPv4/6 transition mechanisms,\
    \ mobile IP, virtual\n   private networking, and so on.  An NSIS solution must\
    \ continue to\n   work in the presence of these techniques.  The presence of the\
    \ tunnel\n   should not cause problems for end-to-end signaling, and it should\n\
    \   also be possible to use NSIS signaling to control the treatment of\n   the\
    \ packets carrying the tunneled data.\n   It is assumed that the NSIS approach\
    \ will be similar to that of [27],\n   where the signaling for the end-to-end\
    \ data flow is tunneled along\n   with that data flow and is invisible to nodes\
    \ along the path of the\n   tunnel (other than the endpoints).  This provides\
    \ backwards\n   compatibility with networks where the tunnel endpoints do not\
    \ support\n   the NSIS protocols.  We assume that NEs will not unwrap tunnel\n\
    \   encapsulations to find and process tunneled signaling messages.\n   To signal\
    \ for the packets carrying the tunneled data, the tunnel is\n   considered a new\
    \ data flow in its own right, and NSIS signaling is\n   applied to it recursively.\
    \  This requires signaling support in at\n   least one tunnel endpoint.  In some\
    \ cases (where the signaling\n   initiator is at the opposite end of the data\
    \ flow from the tunnel\n   initiator; i.e., in the case of receiver initiated\
    \ signaling), the\n   ability to provide a binding between the original flow identification\n\
    \   and that for the tunneled flow is needed.  It is left open here\n   whether\
    \ this should be an NTLP or an NSLP function.\n"
- title: 6.  Signaling Applications
  contents:
  - "6.  Signaling Applications\n   This section gives an overview of NSLPs for particular\
    \ signaling\n   applications.  The assumption is that the NSLP uses the generic\n\
    \   functionality of the NTLP given earlier; this section describes\n   specific\
    \ aspects of NSLP operation.  It includes simple examples that\n   are intended\
    \ to clarify how NSLPs fit into the framework.  It does\n   not replace or even\
    \ form part of the formal NSLP protocol\n   specifications; in particular, initial\
    \ designs are being developed\n   for NSLPs for resource reservation [28] and\
    \ middlebox communication\n   [29].\n"
- title: 6.1.  Signaling for Quality of Service
  contents:
  - "6.1.  Signaling for Quality of Service\n   In the case of signaling for QoS,\
    \ all the basic NSIS concepts of\n   Section 3.1 apply.  In addition, there is\
    \ an assumed directionality\n   of the signaling process, in that one end of the\
    \ signaling flow takes\n   responsibility for actually requesting the resource.\
    \  This leads to\n   the following definitions:\n   o  QoS NSIS Initiator (QNI):\
    \ the signaling entity that makes the\n      resource request, usually as a result\
    \ of user application request.\n   o  QoS NSIS Responder (QNR): the signaling\
    \ entity that acts as the\n      endpoint for the signaling and that can optionally\
    \ interact with\n      applications as well.\n   o  QoS NSIS Forwarder (QNF):\
    \ a signaling entity between a QNI and QNR\n      that propagates NSIS signaling\
    \ further through the network.\n   Each of these entities will interact with a\
    \ resource management\n   function (RMF) that actually allocates network resources\
    \ (router\n   buffers, interface bandwidth, and so on).\n   Note that there is\
    \ no constraint on which end of the signaling flow\n   should take the QNI role:\
    \ With respect to the data flow direction, it\n   could be at the sending or receiving\
    \ end.\n"
- title: 6.1.1.  Protocol Message Semantics
  contents:
  - "6.1.1.  Protocol Message Semantics\n   The QoS NSLP will include a set of messages\
    \ to carry out resource\n   reservations along the signaling path.  A possible\
    \ set of message\n   semantics for the QoS NSLP is shown below.  Note that the\
    \ 'direction'\n   column in the table below only indicates the 'orientation' of\
    \ the\n   message.  Messages can be originated and absorbed at QNF nodes as\n\
    \   well as the QNI or QNR; an example might be QNFs at the edge of a\n   domain\
    \ exchanging messages to set up resources for a flow across a\n   it.  Note that\
    \ it is left open if the responder can release or modify\n   a reservation, during\
    \ or after setup.  This seems mainly a matter of\n   assumptions about authorization,\
    \ and the possibilities might depend\n   on resource type specifics.\n   The table\
    \ also explicitly includes a refresh operation.  This does\n   nothing to a reservation\
    \ except extend its lifetime, and it is one\n   possible state management mechanism\
    \ (see next section).\n   +-----------+-----------+-------------------------------------------+\n\
    \   | Operation | Direction |                 Operation                 |\n  \
    \ +-----------+-----------+-------------------------------------------+\n   |\
    \  Request  |   I-->R   |    Create a new reservation for a flow    |\n   |  \
    \         |           |                                           |\n   |   Modify\
    \  |   I-->R   |       Modify an existing reservation      |\n   |           |\
    \ (&R-->I?) |                                           |\n   |           |  \
    \         |                                           |\n   |  Release  |   I-->R\
    \   |       Delete (tear down) an existing      |\n   |           | (&R-->I?)\
    \ |                reservation                |\n   |           |           |\
    \                                           |\n   |  Accept/  |   R-->I   |  Confirm\
    \ (possibly modified?) or reject a |\n   |   Reject  |           |           \
    \ reservation request            |\n   |           |           |             \
    \                              |\n   |   Notify  |  I-->R &  |    Report an event\
    \ detected within the    |\n   |           |   R-->I   |                  network\
    \                  |\n   |           |           |                           \
    \                |\n   |  Refresh  |   I-->R   |    State management (see Section\
    \ 6.1.2)   |\n   +-----------+-----------+-------------------------------------------+\n"
- title: 6.1.2.  State Management
  contents:
  - "6.1.2.  State Management\n   The primary purpose of NSIS is to manage state information\
    \ along the\n   path taken by a data flow.  The issues regarding state management\n\
    \   within the NTLP (state related to message transport) are described in\n  \
    \ Section 4.  The QoS NSLP will typically have to handle additional\n   state\
    \ related to the desired resource reservation to be made.\n   There two critical\
    \ issues to be considered in building a robust NSLP\n   to handle this problem:\n\
    \   o  The protocol must be scalable.  It should allow minimization of\n     \
    \ the resource reservation state-storage demands that it implies for\n      intermediate\
    \ nodes; in particular, storage of state per 'micro'\n      flow is likely to\
    \ be impossible except at the very edge of the\n      network.  A QoS signaling\
    \ application might require per-flow or\n      lower granularity state; examples\
    \ of each for the case of QoS\n      would be IntServ [30] or RMD [31] (per 'class'\
    \ state),\n      respectively.\n   o  The protocol must be robust against failure\
    \ and other conditions\n      that imply that the stored resource reservation\
    \ state has to be\n      moved or removed.\n   For resource reservations, soft-state\
    \ management is typically used as\n   a general robustness mechanism.  According\
    \ to the discussion of\n   Section 3.2.5, the soft-state protocol mechanisms are\
    \ built into the\n   NSLP for the specific signaling application that needs them;\
    \ the NTLP\n   sees this simply as a sequence of (presumably identical) messages.\n"
- title: 6.1.3.  Route Changes and QoS Reservations
  contents:
  - "6.1.3.  Route Changes and QoS Reservations\n   In this section, we will explore\
    \ the expected interaction between\n   resource signaling and routing updates\
    \ (the precise source of routing\n   updates does not matter).  The normal operation\
    \ of the NSIS protocol\n   will lead to the situation depicted in Figure 7, where\
    \ the reserved\n   resources match the data path.\n                   reserved\
    \ +-----+  reserved  +-----+\n                  =========>| QNF |===========>|\
    \ QNF |\n                            +-----+            +-----+\n            \
    \     --------------------------------------->\n                             \
    \    data path\n                 Figure 7: Normal NSIS Protocol Operation\n  \
    \ A route change can occur while such a reservation is in place.  The\n   route\
    \ change will be installed immediately, and any data will be\n   forwarded on\
    \ the new path.  This situation is depicted Figure 8.\n   Resource reservation\
    \ on the new path will only be started once the\n   next control message is routed\
    \ along the new path.  This means that\n   there is a certain time interval during\
    \ which resources are not\n   reserved on (part of) the data path, and certain\
    \ delay or\n   drop-sensitive applications will require that this time interval\
    \ be\n   minimized.  Several techniques to achieve this could be considered.\n\
    \   As an example, RSVP [7] has the concept of local repair, whereby the\n   router\
    \ may be triggered by a route change.  In that case, the RSVP\n   node can start\
    \ sending PATH messages directly after the route has\n   been changed.  Note that\
    \ this option may not be available if no\n   per-flow state is kept in the QNF.\
    \  Another approach would be to\n   pre-install backup state, and it would be\
    \ the responsibility of the\n   QoS-NSLP to do this.  However, mechanisms for\
    \ identifying backup\n   paths and routing the necessary signaling messages along\
    \ them are not\n   currently considered in the NSIS requirements and framework.\n\
    \                              Route update\n                                \
    \   |\n                                   v\n                       reserved +-----+\
    \  reserved  +-----+\n                      =========>| QNF |===========>| QNF\
    \ |\n                                +-----+            +-----+\n            \
    \           --------   ||\n                               \\  ||           +-----+\n\
    \                                |  ===========>| QNF |\n                    \
    \            |              +-----+\n                                +--------------------------->\n\
    \                                  data path\n                          Figure\
    \ 8: Route Change\n   The new path might not be able to provide the same guarantees\
    \ that\n   were available on the old path.  Therefore, it might be desirable for\n\
    \   the QNF to wait until resources have been reserved on the new path\n   before\
    \ allowing the route change to be installed (unless, of course,\n   the old path\
    \ no longer exists).  However, delaying the route change\n   installation while\
    \ waiting for reservation setup needs careful\n   analysis of the interaction\
    \ with the routing protocol being used, in\n   order to avoid routing loops.\n\
    \   Another example related to route changes is denoted as severe\n   congestion\
    \ and is explained in [31].  This solution adapts to a route\n   change when a\
    \ route change creates congestion on the new routed path.\n"
- title: 6.1.4.  Resource Management Interactions
  contents:
  - "6.1.4.  Resource Management Interactions\n   The QoS NSLP itself is not involved\
    \ in any specific resource\n   allocation or management techniques.  The definition\
    \ of an NSLP for\n   resource reservation with Quality of Service, however, implies\
    \ the\n   notion of admission control.  For a QoS NSLP, the measure of\n   signaling\
    \ success will be the ability to reserve resources from the\n   total resource\
    \ pool that is provisioned in the network.  We define\n   the function responsible\
    \ for allocating this resource pool as the\n   Resource Management Function (RMF).\
    \  The RMF is responsible for all\n   resource provisioning, monitoring, and assurance\
    \ functions in the\n   network.\n   A QoS NSLP will rely on the RMF to do resource\
    \ management and to\n   provide inputs for admission control.  In this model,\
    \ the RMF acts as\n   a server towards client NSLP(s).  Note, however, that the\
    \ RMF may in\n   turn use another NSLP instance to do the actual resource provisioning\n\
    \   in the network.  In this case, the RMF acts as the initiator (client)\n  \
    \ of an NSLP.\n   This essentially corresponds to a multi-level signaling paradigm,\n\
    \   with an 'upper' level handling internetworking QoS signaling\n   (possibly\
    \ running end-to-end), and a 'lower' level handling the more\n   specialized intra-domain\
    \ QoS signaling (running between just the\n   edges of the network).  (See [10],\
    \ [32], and [33] for a discussion of\n   similar architectures.)  Given that NSIS\
    \ signaling is already\n   supposed to be able to support multiple instances of\
    \ NSLPs for a\n   given flow and limited scope (e.g., edge-to-edge) operation,\
    \ it is\n   not currently clear that supporting the multi-level model leads to\n\
    \   any new protocol requirements for the QoS NSLP.\n   The RMF may or may not\
    \ be co-located with a QNF (note that\n   co-location with a QNI/QNR can be handled\
    \ logically as a combination\n   between QNF and QNI/QNR).  To cater for both\
    \ cases, we define a\n   (possibly logical) QNF-RMF interface.  Over this interface,\n\
    \   information may be provided from the RMF about monitoring, resource\n   availability,\
    \ topology, and configuration.  In the other direction,\n   the interface may\
    \ be used to trigger requests for resource\n   provisioning.  One way to formalize\
    \ the interface between the QNF and\n   the RMF is via a Service Level Agreement\
    \ (SLA).  The SLA may be\n   static or it may be dynamically updated by means\
    \ of a negotiation\n   protocol.  Such a protocol is outside the scope of NSIS.\n\
    \   There is no assumed restriction on the placement of the RMF.  It may\n   be\
    \ a centralized RMF per domain, several off-path distributed RMFs,\n   or an on-path\
    \ RMF per router.  The advantages and disadvantages of\n   both approaches are\
    \ well-known.  Centralization typically allows\n   decisions to be taken using\
    \ more global information, with more\n   efficient resource utilization as a result.\
    \  It also facilitates\n   deployment or upgrade of policies.  Distribution allows\
    \ local\n   decision processes and rapid response to data path changes.\n"
- title: 6.2.  Other Signaling Applications
  contents:
  - "6.2.  Other Signaling Applications\n   As well as the use for 'traditional' QoS\
    \ signaling, it should be\n   possible to develop NSLPs for other signaling applications\
    \ that\n   operate on different types of network control state.  One specific\n\
    \   case is setting up flow-related state in middleboxes (firewalls,\n   NATs,\
    \ and so on).  Requirements for such communication are given in\n   [4].  Other\
    \ examples include network monitoring and testing, and\n   tunnel endpoint discovery.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This document describes a framework for signaling\
    \ protocols that\n   assumes a two-layer decomposition, with a common lower layer\
    \ (NTLP)\n   supporting a family of signaling-application-specific upper-layer\n\
    \   protocols (NSLPs).  The overall security considerations for the\n   signaling\
    \ therefore depend on the joint security properties assumed\n   or demanded for\
    \ each layer.\n   Security for the NTLP is discussed in Section 4.7.  We have\
    \ assumed\n   that, apart from being resistant to denial of service attacks against\n\
    \   itself, the main role of the NTLP will be to provide message\n   protection\
    \ over the scope of a single peer relationship, between\n   adjacent signaling\
    \ application entities.  (See Section 3.2.3 for a\n   discussion of the case where\
    \ these entities are separated by more\n   than one NTLP hop.)  These functions\
    \ can ideally be provided by an\n   existing channel security mechanism, preferably\
    \ using an external key\n   management mechanism based on mutual authentication.\
    \  Examples of\n   possible mechanisms are TLS, IPsec and SSH.  However, there\
    \ are\n   interactions between the actual choice of security protocol and the\n\
    \   rest of the NTLP design.  Primarily, most existing channel security\n   mechanisms\
    \ require explicit identification of the peers involved at\n   the network and/or\
    \ transport level.  This conflicts with those\n   aspects of path-coupled signaling\
    \ operation (e.g., discovery) where\n   this information is not even implicitly\
    \ available because peer\n   identities are unknown; the impact of this 'next-hop\
    \ problem' on RSVP\n   design is discussed in the security properties document\
    \ [6] and also\n   influences many parts of the threat analysis [2].  Therefore,\
    \ this\n   framework does not mandate the use of any specific channel security\n\
    \   protocol; instead, this has to be integrated with the design of the\n   NTLP\
    \ as a whole.\n   Security for the NSLPs is entirely dependent on signaling application\n\
    \   requirements.  In some cases, no additional protection may be\n   required\
    \ compared to what is provided by the NTLP.  In other cases,\n   more sophisticated\
    \ object-level protection and the use of public-\n   key-based solutions may be\
    \ required.  In addition, the NSLP needs to\n   consider the authorization requirements\
    \ of the signaling application.\n   Authorization is a complex topic, for which\
    \ a very brief overview is\n   provided in Section 3.3.7.\n   Another factor is\
    \ that NTLP security mechanisms operate only locally,\n   whereas NSLP mechanisms\
    \ may also need to operate over larger regions\n   (not just between adjacent\
    \ peers), especially for authorization\n   aspects.  This complicates the analysis\
    \ of basing signaling\n   application security on NTLP protection.\n   An additional\
    \ concern for signaling applications is the session\n   identifier security issue\
    \ (Sections 4.6.2 and 5.2).  The purpose of\n   this identifier is to decouple\
    \ session identification (as a handle\n   for network control state) from session\
    \ \"location\" (i.e., the data\n   flow endpoints).  The identifier/locator distinction\
    \ has been\n   extensively discussed in the user plane for end-to-end data flows,\n\
    \   and is known to lead to non-trivial security issues in binding the\n   two\
    \ together again.  Our problem is the analogue in the control\n   plane, and is\
    \ at least similarly complex, because of the need to\n   involve nodes in the\
    \ interior of the network as well.\n   Further work on this and other security\
    \ design will depend on a\n   refinement of the NSIS threats work begun in [2].\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [1]   Brunner, M., \"Requirements for Signaling\
    \ Protocols\", RFC 3726,\n         April 2004.\n   [2]   Tschofenig, H. and D.\
    \ Kroeselberg, \"Security Threats for Next\n         Steps in Signaling (NSIS)\"\
    , RFC 4081, June 2005.\n   [3]   Chaskar, H., \"Requirements of a Quality of Service\
    \ (QoS)\n         Solution for Mobile IP\", RFC 3583, September 2003.\n   [4]\
    \   Swale, R., Mart, P., Sijben, P., Brim, S., and M. Shore,\n         \"Middlebox\
    \ Communications (midcom) Protocol Requirements\",\n         RFC 3304, August\
    \ 2002.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [5]   Manner, J. and X. Fu, \"Analysis of Existing\
    \ Quality of Service\n         Signaling Protocols\", Work in Progress, December\
    \ 2004.\n   [6]   Tschofenig, H., \"RSVP Security Properties\", Work in Progress,\n\
    \         February 2005.\n   [7]   Braden, R., Zhang, L., Berson, S., Herzog,\
    \ S., and S. Jamin,\n         \"Resource ReSerVation Protocol (RSVP) -- Version\
    \ 1 Functional\n         Specification\", RFC 2205, September 1997.\n   [8]  \
    \ Katz, D., \"IP Router Alert Option\", RFC 2113, February 1997.\n   [9]   Partridge,\
    \ C. and A. Jackson, \"IPv6 Router Alert Option\",\n         RFC 2711, October\
    \ 1999.\n   [10]  Baker, F., Iturralde, C., Le Faucheur, F., and B. Davie,\n \
    \        \"Aggregation of RSVP for IPv4 and IPv6 Reservations\", RFC 3175,\n \
    \        September 2001.\n   [11]  Rescorla, E. and B. Korver, \"Guidelines for\
    \ Writing RFC Text on\n         Security Considerations\", BCP 72, RFC 3552, July\
    \ 2003.\n   [12]  Tschofenig, H., \"NSIS Authentication, Authorization and\n \
    \        Accounting Issues\", Work in Progress, March 2003.\n   [13]  Berger,\
    \ L., Gan, D., Swallow, G., Pan, P., Tommasi, F., and S.\n         Molendini,\
    \ \"RSVP Refresh Overhead Reduction Extensions\",\n         RFC 2961, April 2001.\n\
    \   [14]  Ji, P., Ge, Z., Kurose, J., and D. Townsley, \"A Comparison of\n   \
    \      Hard-State and Soft-State Signaling Protocols\", Computer\n         Communication\
    \ Review, Volume 33, Number 4, October 2003.\n   [15]  Floyd, S., \"Congestion\
    \ Control Principles\", BCP 41, RFC 2914,\n         September 2000.\n   [16] \
    \ Apostolopoulos, G., Kamat, S., Williams, D., Guerin, R., Orda,\n         A.,\
    \ and T. Przygienda, \"QoS Routing Mechanisms and OSPF\n         Extensions\"\
    , RFC 2676, August 1999.\n   [17]  Thaler, D. and C. Hopps, \"Multipath Issues\
    \ in Unicast and\n         Multicast Next-Hop Selection\", RFC 2991, November\
    \ 2000.\n   [18]  Hinden, R., \"Virtual Router Redundancy Protocol (VRRP)\", RFC\n\
    \         3768, April 2004.\n   [19]  Heijenk, G., Karagiannis, G., Rexhepi, V.,\
    \ and L. Westberg,\n         \"DiffServ Resource Management in IP-based Radio\
    \ Access\n         Networks\", Proceedings of 4th International Symposium on\n\
    \         Wireless Personal Multimedia Communications WPMC'01, September\n   \
    \      9 - 12 2001.\n   [20]  Manner, J., Lopez, A., Mihailovic, A., Velayos,\
    \ H., Hepworth,\n         E., and Y. Khouaja, \"Evaluation of Mobility and QoS\n\
    \         Interaction\", Computer Networks Volume 38, Issue 2, p. 137-163,\n \
    \        5 February 2002.\n   [21]  Johnson, D., Perkins, C., and J. Arkko, \"\
    Mobility Support in\n         IPv6\", RFC 3775, June 2004.\n   [22]  Liebsch,\
    \ M., Ed., Singh, A., Ed., Chaskar, H., Funato, D., and\n         E. Shim, \"\
    Candidate Access Router Discovery (CARD)\", Work in\n         Progress, May 2005.\n\
    \   [23]  Kempf, J., \"Problem Description: Reasons For Performing Context\n \
    \        Transfers Between Nodes in an IP Access Network\", RFC 3374,\n      \
    \   September 2002.\n   [24]  Srisuresh, P. and M. Holdrege, \"IP Network Address\
    \ Translator\n         (NAT) Terminology and Considerations\", RFC 2663, August\
    \ 1999.\n   [25]  Nordmark, E., \"Stateless IP/ICMP Translation Algorithm (SIIT)\"\
    ,\n         RFC 2765, February 2000.\n   [26]  Rosenberg, J., Weinberger, J.,\
    \ Huitema, C., and R. Mahy, \"STUN\n         - Simple Traversal of User Datagram\
    \ Protocol (UDP) Through\n         Network Address Translators (NATs)\", RFC 3489,\
    \ March 2003.\n   [27]  Terzis, A., Krawczyk, J., Wroclawski, J., and L. Zhang,\
    \ \"RSVP\n         Operation Over IP Tunnels\", RFC 2746, January 2000.\n   [28]\
    \  Bosch, S., Karagiannis, G., and A. McDonald, \"NSLP for\n         Quality-of-Service\
    \ signaling\", Work in Progress, February 2005.\n   [29]  Stiemerling, M., \"\
    A NAT/Firewall NSIS Signaling Layer Protocol\n         (NSLP)\", Work in Progress,\
    \ February 2005.\n   [30]  Braden, R., Clark, D., and S. Shenker, \"Integrated\
    \ Services in\n         the Internet Architecture: an Overview\", RFC 1633, June\
    \ 1994.\n   [31]  Westberg, L., Csaszar, A., Karagiannis, G., Marquetant, A.,\n\
    \         Partain, D., Pop, O., Rexhepi, V., Szabo, R., and A. Takacs,\n     \
    \    \"Resource Management in Diffserv (RMD): A Functionality and\n         Performance\
    \ Behavior Overview\", Seventh International Workshop\n         on Protocols for\
    \ High-Speed networks PfHSN 2002, 22 - 24\n         April 2002.\n   [32]  Ferrari,\
    \ D., Banerjea, A., and H. Zhang, \"Network Support for\n         Multimedia -\
    \ A Discussion of the Tenet Approach\",\n         Berkeley TR-92-072, November\
    \ 1992.\n   [33]  Nichols, K., Jacobson, V., and L. Zhang, \"A Two-bit\n     \
    \    Differentiated Services Architecture for the Internet\",\n         RFC 2638,\
    \ July 1999.\n"
- title: Appendix A.  Contributors
  contents:
  - "Appendix A.  Contributors\n   Several parts of the introductory sections of this\
    \ document (in\n   particular, in Sections 3.1 and 3.3) are based on contributions\
    \ from\n   Ilya Freytsis, then of Cetacean Networks, Inc.\n   Bob Braden originally\
    \ proposed \"A Two-Level Architecture for Internet\n   Signalling\" as an Internet-Draft\
    \ in November 2001.  This document\n   served as an important starting point for\
    \ the framework discussed\n   herein, and the authors owe a debt of gratitude\
    \ to Bob for this\n   proposal.\n"
- title: Appendix B.  Acknowledgements
  contents:
  - "Appendix B.  Acknowledgements\n   The authors would like to thank Bob Braden,\
    \ Maarten Buchli, Eleanor\n   Hepworth, Andrew McDonald, Melinda Shore, and Hannes\
    \ Tschofenig for\n   significant contributions in particular areas of this document.\
    \  In\n   addition, the authors would like to acknowledge Cedric Aoun, Attila\n\
    \   Bader, Anders Bergsten, Roland Bless, Marcus Brunner, Louise Burness,\n  \
    \ Xiaoming Fu, Ruediger Geib, Danny Goderis, Kim Hui, Cornelia Kappler,\n   Sung\
    \ Hycuk Lee, Thanh Tra Luu, Mac McTiffin, Paulo Mendes, Hans De\n   Neve, Ping\
    \ Pan, David Partain, Vlora Rexhepi, Henning Schulzrinne,\n   Tom Taylor, Michael\
    \ Thomas, Daniel Warren, Michael Welzl, Lars\n   Westberg, and Lixia Zhang for\
    \ insights and inputs during this and\n   previous framework activities.  Dave\
    \ Oran, Michael Richardson, and\n   Alex Zinin provided valuable comments during\
    \ the final review stages.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Robert Hancock\n   Siemens/Roke Manor Research\n   Old\
    \ Salisbury Lane\n   Romsey, Hampshire  SO51 0ZN\n   UK\n   EMail: robert.hancock@roke.co.uk\n\
    \   Georgios Karagiannis\n   University of Twente\n   P.O. BOX 217\n   7500 AE\
    \ Enschede\n   The Netherlands\n   EMail: g.karagiannis@ewi.utwente.nl\n   John\
    \ Loughney\n   Nokia Research Center\n   11-13 Itamerenkatu\n   Helsinki  00180\n\
    \   Finland\n   EMail: john.loughney@nokia.com\n   Sven Van den Bosch\n   Alcatel\n\
    \   Francis Wellesplein 1\n   B-2018 Antwerpen\n   Belgium\n   EMail: sven.van_den_bosch@alcatel.be\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
