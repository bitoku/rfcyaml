- contents:
  - "     Generalized Multi-Protocol Label Switching (GMPLS) Signaling\n Resource
    ReserVation Protocol-Traffic Engineering (RSVP-TE) Extensions\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes extensions to Multi-Protocol Label Switching\n
    \  (MPLS) Resource ReserVation Protocol - Traffic Engineering (RSVP-TE)\n   signaling
    required to support Generalized MPLS.  Generalized MPLS\n   extends the MPLS control
    plane to encompass time-division (e.g.,\n   Synchronous Optical Network and Synchronous
    Digital Hierarchy,\n   SONET/SDH), wavelength (optical lambdas) and spatial switching
    (e.g.,\n   incoming port or fiber to outgoing port or fiber).  This document\n
    \  presents a RSVP-TE specific description of the extensions.  A generic\n   functional
    description can be found in separate documents.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction  ..............................................
    \  2\n   2.  Label Related Formats   ....................................   3\n
    \   2.1  Generalized Label Request Object  ........................   3\n    2.2
    \ Bandwidth Encoding  ......................................   4\n    2.3  Generalized
    Label Object  ................................   5\n    2.4  Waveband Switching
    \ ......................................   5\n    2.5  Suggested Label  .........................................
    \  6\n    2.6  Label Set  ...............................................   7\n
    \  3.  Bidirectional LSPs  ........................................   8\n    3.1
    \ Procedures  ..............................................   9\n    3.2  Contention
    Resolution  ...................................   9\n   4.  Notification  ..............................................
    \  9\n    4.1  Acceptable Label Set Object  .............................  10\n
    \   4.2  Notify Request Objects  ..................................  10\n    4.3
    \ Notify Message  ..........................................  12\n    4.4  Removing
    State with a PathErr message  ...................  14\n   5.  Explicit Label Control
    \ ....................................  15\n    5.1  Label ERO subobject  .....................................
    \ 15\n    5.2  Label RRO subobject  .....................................  16\n
    \  6.  Protection Object  .........................................  17\n    6.1
    \ Procedures  ..............................................  18\n   7.  Administrative
    Status Information  .........................  18\n    7.1  Admin Status Object
    \ .....................................  18\n    7.2  Path and Resv Message Procedures
    \ ........................  18\n    7.3  Notify Message Procedures  ...............................
    \ 20\n   8.  Control Channel Separation  ................................  21\n
    \   8.1  Interface Identification  ................................  21\n    8.2
    \ Errored Interface Identification  ........................  23\n   9.  Fault
    Handling  ............................................  25\n    9.1  Restart_Cap
    Object  ......................................  25\n    9.2  Processing of Restart_Cap
    Object  ........................  26\n    9.3  Modification to Hello Processing
    to Support\n         State Recovery  ..........................................
    \ 26\n    9.4  Control Channel Faults  ..................................  27\n
    \   9.5  Nodal Faults  ............................................  27\n   10.
    RSVP Message Formats and Handling  .........................  30\n    10.1  RSVP
    Message Formats  ...................................  30\n    10.2  Addressing
    Path and PathTear Messages   .................  32\n   11. Acknowledgments  ...........................................
    \ 32\n   12. Security Considerations  ...................................  33\n
    \  13. IANA Considerations  .......................................  34\n    13.1
    \ IANA Assignments  .......................................  35\n   14. Intellectual
    Property Considerations  ......................  36\n   15. References  ................................................
    \ 37\n    15.1  Normative References  ...................................  37\n
    \   15.2  Informative References  .................................  38\n   16.
    Contributors  ..............................................  38\n   17. Editor's
    Address  ..........................................  41\n   18. Full Copyright
    Statement  ..................................  42\n"
  title: Table of Contents
- contents:
  - "1. Introduction\n   Generalized MPLS extends MPLS from supporting packet (PSC)
    interfaces\n   and switching to include support of three new classes of interfaces\n
    \  and switching: Time-Division Multiplex (TDM), Lambda Switch (LSC) and\n   Fiber-Switch
    (FSC).  A functional description of the extensions to\n   MPLS signaling needed
    to support the new classes of interfaces and\n   switching is provided in [RFC3471].
    \ This document presents RSVP-TE\n   specific formats and mechanisms needed to
    support all four classes of\n   interfaces.\n   [RFC3471] should be viewed as
    a companion document to this document.\n   The format of this document parallels
    [RFC3471].  In addition to the\n   other features of Generalized MPLS, this document
    also defines RSVP-\n   TE specific features to support rapid failure notification,
    see\n   Sections 4.2 and 4.3.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
  title: 1. Introduction
- contents:
  - "2. Label Related Formats\n   This section defines formats for a generalized label
    request, a\n   generalized label, support for waveband switching, suggested label\n
    \  and label sets.\n"
  - contents:
    - "2.1. Generalized Label Request Object\n   A Path message SHOULD contain as
      specific an LSP (Label Switched\n   Path) Encoding Type as possible to allow
      the maximum flexibility in\n   switching by transit LSRs.  A Generalized Label
      Request object is set\n   by the ingress node, transparently passed by transit
      nodes, and used\n   by the egress node.  The Switching Type field may also be
      updated\n   hop-by-hop.\n   The format of a Generalized Label Request object
      is:\n    0                   1                   2                   3\n    0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Length             | Class-Num (19)|  C-Type (4)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | LSP Enc. Type |Switching Type |             G-PID             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  See [RFC3471] for a description of parameters.\n"
    - contents:
      - "2.1.1. Procedures\n   A node processing a Path message containing a Generalized
        Label\n   Request must verify that the requested parameters can be satisfied
        by\n   the interface on which the incoming label is to be allocated, the\n
        \  node itself, and by the interface on which the traffic will be\n   transmitted.
        \ The node may either directly support the LSP or it may\n   use a tunnel
        (FA), i.e., another class of switching.  In either case,\n   each parameter
        must be checked.\n   Note that local node policy dictates when tunnels may
        be used and\n   when they may be created.  Local policy may allow for tunnels
        to be\n   dynamically established or may be solely administratively controlled.\n
        \  For more information on tunnels and processing of ER hops when using\n
        \  tunnels see [MPLS-HIERARCHY].\n   Transit and egress nodes MUST verify
        that the node itself and, where\n   appropriate, that the interface or tunnel
        on which the traffic will\n   be transmitted can support the requested LSP
        Encoding Type.  If\n   encoding cannot be supported, the node MUST generate
        a PathErr\n   message, with a \"Routing problem/Unsupported Encoding\" indication.\n
        \  Nodes MUST verify that the type indicated in the Switching Type\n   parameter
        is supported on the corresponding incoming interface.  If\n   the type cannot
        be supported, the node MUST generate a PathErr\n   message with a \"Routing
        problem/Switching Type\" indication.\n   The G-PID parameter is normally only
        examined at the egress.  If the\n   indicated G-PID cannot be supported then
        the egress MUST generate a\n   PathErr message, with a \"Routing problem/Unsupported
        L3PID\"\n   indication.  In the case of PSC and when penultimate hop popping\n
        \  (PHP) is requested, the penultimate hop also examines the (stored)\n   G-PID
        during the processing of the Resv message.  In this case if the\n   G-PID
        is not supported, then the penultimate hop MUST generate a\n   ResvErr message
        with a \"Routing problem/Unacceptable label value\"\n   indication.  The generated
        ResvErr message MAY include an Acceptable\n   Label Set, see Section 4.1.\n
        \  When an error message is not generated, normal processing occurs.  In\n
        \  the transit case this will typically result in a Path message being\n   propagated.
        \ In the egress case and PHP special case this will\n   typically result in
        a Resv message being generated.\n"
      title: 2.1.1. Procedures
    title: 2.1. Generalized Label Request Object
  - contents:
    - "2.2. Bandwidth Encoding\n   Bandwidth encodings are carried in the SENDER_TSPEC
      and FLOWSPEC\n   objects.  See [RFC3471] for a definition of values to be used
      for\n   specific signal types.  These values are set in the Peak Data Rate\n
      \  field of Int-Serv objects, see [RFC2210].  Other bandwidth/service\n   related
      parameters in the object are ignored and carried\n   transparently.\n"
    title: 2.2. Bandwidth Encoding
  - contents:
    - "2.3. Generalized Label Object\n   The format of a Generalized Label object
      is:\n    0                   1                   2                   3\n    0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Length             | Class-Num (16)|   C-Type (2)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                             Label                             |\n   |                              ...
      \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  See [RFC3471] for a description of parameters and encoding of labels.\n"
    - contents:
      - "2.3.1. Procedures\n   The Generalized Label travels in the upstream direction
        in Resv\n   messages.\n   The presence of both a generalized and normal label
        object in a Resv\n   message is a protocol error and should treated as a malformed
        message\n   by the recipient.\n   The recipient of a Resv message containing
        a Generalized Label\n   verifies that the values passed are acceptable.  If
        the label is\n   unacceptable then the recipient MUST generate a ResvErr message
        with\n   a \"Routing problem/MPLS label allocation failure\" indication.\n"
      title: 2.3.1. Procedures
    title: 2.3. Generalized Label Object
  - contents:
    - "2.4. Waveband Switching Object\n   Waveband switching uses the same format
      as the generalized label, see\n   section 2.2.  Waveband Label uses C-Type (3),\n
      \  In the context of waveband switching, the generalized label has the\n   following
      format:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Length             | Class-Num (16)|   C-Type (3)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                          Waveband Id                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                          Start Label                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                           End Label                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  See [RFC3471] for a description of parameters.\n"
    - contents:
      - "2.4.1. Procedures\n   The procedures defined in Section 2.3.1 apply to waveband
        switching.\n   This includes generating a ResvErr message with a \"Routing\n
        \  problem/MPLS label allocation failure\" indication if any of the label\n
        \  fields are unrecognized or unacceptable.\n   Additionally, when a waveband
        is switched to another waveband, it is\n   possible that the wavelengths within
        the waveband will be mirrored\n   about a center frequency.  When this type
        of switching is employed,\n   the start and end label in the waveband label
        object MUST be flipped\n   before forwarding the label object with the new
        waveband Id.  In this\n   manner an egress/ingress LSR which receives a waveband
        label which\n   has these values inverted, knows that it must also invert
        its egress\n   association to pick up the proper wavelengths.\n   This operation
        MUST be performed in both directions when a\n   bidirectional waveband tunnel
        is being established.\n"
      title: 2.4.1. Procedures
    title: 2.4. Waveband Switching Object
  - contents:
    - "2.5. Suggested Label Object\n   The format of a Suggested_Label object is identical
      to a generalized\n   label.  It is used in Path messages.  A Suggested_Label
      object uses\n   Class-Number 129 (of form 10bbbbbb) and the C-Type of the label
      being\n   suggested.\n   Errors in received Suggested_Label objects MUST be
      ignored.  This\n   includes any received inconsistent or unacceptable values.\n
      \  Per [RFC3471], if a downstream node passes a label value that differs\n   from
      the suggested label upstream, the upstream LSR MUST either\n   reconfigure itself
      so that it uses the label specified by the\n   downstream node or generate a
      ResvErr message with a \"Routing\n   problem/Unacceptable label value\" indication.
      \ Furthermore, an\n   ingress node SHOULD NOT transmit data traffic using a
      suggested label\n   until the downstream node passes a corresponding label upstream.\n"
    title: 2.5. Suggested Label Object
  - contents:
    - "2.6. Label Set Object\n   The Label_Set object uses Class-Number 36 (of form
      0bbbbbbb) and the\n   C-Type of 1.  It is used in Path messages.\n   The format
      of a Label_Set is:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Length             | Class-Num (36)|   C-Type (1)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |    Action     |      Reserved     |        Label Type         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                          Subchannel 1                         |\n   |                              ...
      \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  :                               :                               :\n   :                               :
      \                              :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                          Subchannel N                         |\n   |                              ...
      \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Label Type: 14 bits\n      Indicates the type and format of the labels carried
      in the object.\n      Values match the C-Type of the appropriate RSVP_LABEL
      object.\n      Only the low order 8 bits are used in this field.\n   See [RFC3471]
      for a description of other parameters.\n"
    - contents:
      - "2.6.1. Procedures\n   A Label Set is defined via one or more Label_Set objects.
        \ Specific\n   labels/subchannels can be added to or excluded from a Label
        Set via\n   Action zero (0) and one (1) objects respectively.  Ranges of\n
        \  labels/subchannels can be added to or excluded from a Label Set via\n   Action
        two (2) and three (3) objects respectively.  When the\n   Label_Set objects
        only list labels/subchannels to exclude, this\n   implies that all other labels
        are acceptable.\n   The absence of any Label_Set objects implies that all
        labels are\n   acceptable.  A Label Set is included when a node wishes to
        restrict\n   the label(s) that may be used downstream.\n   On reception of
        a Path message, the receiving node will restrict its\n   choice of labels
        to one which is in the Label Set.  Nodes capable of\n   performing label conversion
        may also remove the Label Set prior to\n   forwarding the Path message.  If
        the node is unable to pick a label\n   from the Label Set or if there is a
        problem parsing the Label_Set\n   objects, then the request is terminated
        and a PathErr message with a\n   \"Routing problem/Label Set\" indication
        MUST be generated.  It is a\n   local matter if the Label Set is stored for
        later selection on the\n   Resv or if the selection is made immediately for
        propagation in the\n   Resv.\n   On reception of a Path message, the Label
        Set represented in the\n   message is compared against the set of available
        labels at the\n   downstream interface and the resulting intersecting Label
        Set is\n   forwarded in a Path message.  When the resulting Label Set is empty,\n
        \  the Path must be terminated, and a PathErr message, and a \"Routing\n   problem/Label
        Set\" indication MUST be generated.  Note that\n   intersection is based on
        the physical labels (actual wavelength/band\n   values) which may have different
        logical values on different links,\n   as a result it is the responsibility
        of the node to map these values\n   so that they have a consistent physical
        meaning, or to drop the\n   particular values from the set if no suitable
        logical label value\n   exists.\n   When processing a Resv message at an intermediate
        node, the label\n   propagated upstream MUST fall within the Label Set.\n
        \  Note, on reception of a Resv message a node that is incapable of\n   performing
        label conversion has no other choice than to use the same\n   physical label
        (wavelength/band) as received in the Resv message.  In\n   this case, the
        use and propagation of a Label Set will significantly\n   reduce the chances
        that this allocation will fail.\n"
      title: 2.6.1. Procedures
    title: 2.6. Label Set Object
  title: 2. Label Related Formats
- contents:
  - "3. Bidirectional LSPs\n   Bidirectional LSP setup is indicated by the presence
    of an Upstream\n   Label in the Path message.  An Upstream_Label object has the
    same\n   format as the generalized label, see Section 2.3.  The Upstream_Label\n
    \  object uses Class-Number 35 (of form 0bbbbbbb) and the C-Type of the\n   label
    being used.\n"
  - contents:
    - "3.1. Procedures\n   The process of establishing a bidirectional LSP follows
      the\n   establishment of a unidirectional LSP with some additions.  To\n   support
      bidirectional LSPs an Upstream_Label object is added to the\n   Path message.
      \ The Upstream_Label object MUST indicate a label that\n   is valid for forwarding
      at the time the Path message is sent.\n   When a Path message containing an
      Upstream_Label object is received,\n   the receiver first verifies that the
      upstream label is acceptable.\n   If the label is not acceptable, the receiver
      MUST issue a PathErr\n   message with a \"Routing problem/Unacceptable label
      value\" indication.\n   The generated PathErr message MAY include an Acceptable
      Label Set,\n   see Section 4.1.\n   An intermediate node must also allocate
      a label on the outgoing\n   interface and establish internal data paths before
      filling in an\n   outgoing upstream label and propagating the Path message.
      \ If an\n   intermediate node is unable to allocate a label or internal\n   resources,
      then it MUST issue a PathErr message with a \"Routing\n   problem/MPLS label
      allocation failure\" indication.\n   Terminator nodes process Path messages
      as usual, with the exception\n   that the upstream label can immediately be
      used to transport data\n   traffic associated with the LSP upstream towards
      the initiator.\n   When a bidirectional LSP is removed, both upstream and downstream\n
      \  labels are invalidated and it is no longer valid to send data using\n   the
      associated labels.\n"
    title: 3.1. Procedures
  - contents:
    - "3.2. Contention Resolution\n   There are two additional contention resolution
      related considerations\n   when controlling bidirectional LSP setup via RSVP-TE.
      \ The first is\n   that for the purposes of RSVP contention resolution, the
      node ID is\n   the IP address used in the RSVP_HOP object.  The second is that
      a\n   neighbor's node ID might not be known when sending an initial Path\n   message.
      \ When this case occurs, a node should suggest a label chosen\n   at random
      from the available label space.\n"
    title: 3.2. Contention Resolution
  title: 3. Bidirectional LSPs
- contents:
  - "4. Notification\n   This section covers several notification related extensions.
    \ The\n   first extension defines the Acceptable Label Set object to support\n
    \  Notification on Label Error, per [RFC3471].  The second and third\n   extensions
    enable expedited notification of failures and other events\n   to nodes responsible
    for restoring failed LSPs.  (The second\n   extension, the Notify Request object,
    identifies where event\n   notifications are to be sent.  The third extension,
    the Notify\n   message, provides for general event notification.)  The final\n
    \  notification related extension allows for the removal of Path state\n   on
    handling of PathErr messages.\n"
  - contents:
    - "4.1. Acceptable Label Set Object\n   Acceptable_Label_Set objects use a Class-Number
      130 (of form\n   10bbbbbb).  The remaining contents of the object, including
      C-Type,\n   have the identical format as the Label_Set object, see Section 2.6.\n
      \  Acceptable_Label_Set objects may be carried in PathErr and ResvErr\n   messages.
      \ The procedures for defining an Acceptable Label Set follow\n   the procedures
      for defining a Label Set, see Section 2.6.1.\n   Specifically, an Acceptable
      Label Set is defined via one or more\n   Acceptable_Label_Set objects.  Specific
      labels/subchannels can be\n   added to or excluded from an Acceptable Label
      Set via  Action zero\n   (0) and one (1) objects respectively.  Ranges of labels/subchannels\n
      \  can be added to or excluded from an Acceptable Label Set via Action\n   two
      (2) and three (3) objects respectively.  When the\n   Acceptable_Label_Set objects
      only list labels/subchannels to exclude,\n   this implies that all other labels
      are acceptable.\n   The inclusion of Acceptable_Label_Set objects is optional.
      \ If\n   included, the PathErr or ResvErr message SHOULD contain a \"Routing\n
      \  problem/Unacceptable label value\" indication.  The absence of\n   Acceptable_Label_Set
      objects does not have any specific meaning.\n"
    title: 4.1. Acceptable Label Set Object
  - contents:
    - "4.2. Notify Request Objects\n   Notifications may be sent via the Notify message
      defined below.  The\n   Notify Request object is used to request the generation
      of\n   notifications.  Notifications, i.e., the sending of a Notify message,\n
      \  may be requested in both the upstream and downstream directions.\n"
    - contents:
      - "4.2.1. Required Information\n   The Notify Request Object may be carried
        in Path or Resv Messages,\n   see Section 7.  The Notify_Request Class-Number
        is 195 (of form\n   11bbbbbb).  The format of a Notify Request is:\n      o
        \ IPv4 Notify Request Object\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |            Length             | Class-Num (1) |  C-Type (1)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                    IPv4 Notify Node Address                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  IPv4 Notify Node Address: 32 bits\n      The IP address of the node that
        should be notified when generating\n      an error message.\n      o  IPv6
        Notify Request Object\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |            Length             | Class-Num (2) |  C-Type (2)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                                               |\n   |
        \                   IPv6 Notify Node Address                   |\n   |                                                               |\n
        \  |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  IPv6 Notify Node Address: 16 bytes\n      The IP address of the node that
        should be notified when generating\n      an error message.\n   If a message
        contains multiple Notify_Request objects, only the first\n   object is meaningful.
        \ Subsequent Notify_Request objects MAY be\n   ignored and SHOULD NOT be propagated.\n"
      title: 4.2.1. Required Information
    - contents:
      - "4.2.2. Procedures\n   A Notify Request object may be inserted in Path or
        Resv messages to\n   indicate the address of a node that should be notified
        of an LSP\n   failure.  As previously mentioned, notifications may be requested
        in\n   both the upstream and downstream directions.  Upstream notification\n
        \  is indicated via the inclusion of a Notify Request Object in the\n   corresponding
        Path message.  Downstream notification is indicated via\n   the inclusion
        of a Notify Request Object in the corresponding Resv\n   message.\n   A node
        receiving a message containing a Notify Request object SHOULD\n   store the
        Notify Node Address in the corresponding state block.  If\n   the node is
        a transit node, it SHOULD also included a Notify Request\n   object in the
        outgoing Path or Resv message.  The outgoing Notify\n   Node Address MAY be
        updated based on local policy.\n   Note that the inclusion of a Notify Request
        object does not guarantee\n   that a Notify message will be generated.\n"
      title: 4.2.2. Procedures
    title: 4.2. Notify Request Objects
  - contents:
    - "4.3. Notify Message\n   The Notify message provides a mechanism to inform non-adjacent
      nodes\n   of LSP related events.  Notify messages are normally generated only\n
      \  after a Notify Request object has been received.  The Notify message\n   differs
      from the currently defined error messages (i.e., PathErr and\n   ResvErr messages)
      in that it can be \"targeted\" to a node other than\n   the immediate upstream
      or downstream neighbor and that it is a\n   generalized notification mechanism.
      \ The Notify message does not\n   replace existing error messages.  The Notify
      message may be sent\n   either (a) normally, where non-target nodes just forward
      the Notify\n   message to the target node, similar to ResvConf processing in\n
      \  [RFC2205]; or (b) encapsulated in a new IP header whose destination\n   is
      equal to the target IP address.  Regardless of the transmission\n   mechanism,
      nodes receiving a Notify message not destined to the node\n   forward the message,
      unmodified, towards the target.\n   To support reliable delivery of the Notify
      message, an Ack Message\n   [RFC2961] is used to acknowledge the receipt of
      a Notify Message.\n   See [RFC2961] for details on reliable RSVP message delivery.\n"
    - contents:
      - "4.3.1. Required Information\n   The Notify message is a generalized notification
        message.  The IP\n   destination address is set to the IP address of the intended\n
        \  receiver.  The Notify message is sent without the router alert\n   option.
        \ A single Notify message may contain notifications being\n   sent, with respect
        to each listed session, both upstream and\n   downstream.\n   The Notify message
        has a Message Type of 21.  The Notify message\n   format is as follows:\n
        \  <Notify message>            ::= <Common Header> [<INTEGRITY>]\n                        [
        [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                                   [
        <MESSAGE_ID> ]\n                                   <ERROR_SPEC> <notify session
        list>\n   <notify session list>       ::= [ <notify session list> ]\n                                   <upstream
        notify session> |\n                                   <downstream notify session>\n
        \  <upstream notify session>   ::= <SESSION> [ <ADMIN_STATUS> ]\n                                   [<POLICY_DATA>...]\n
        \                                  <sender descriptor>\n   <downstream notify
        session> ::= <SESSION> [<POLICY_DATA>...]\n                                   <flow
        descriptor list>\n   The ERROR_SPEC object specifies the error and includes
        the IP address\n   of either the node that detected the error or the link
        that has\n   failed.  See ERROR_SPEC definition in [RFC2205].  The MESSAGE_ID
        and\n   related objects are defined in [RFC2961] and are used when [RFC2961]\n
        \  is supported.\n"
      title: 4.3.1. Required Information
    - contents:
      - "4.3.2. Procedures\n   Notify messages are most commonly generated at nodes
        that detect an\n   error that will trigger the generation of a PathErr or
        ResvErr\n   message.  If a PathErr message is to be generated and a Notify\n
        \  Request object has been received in the corresponding Path message,\n   then
        a Notify message destined to the recorded node SHOULD be\n   generated.  If
        a ResvErr message is to be generated and a Notify\n   Request object has been
        received in the corresponding Resv message,\n   then a Notify message destined
        to the recorded node SHOULD be\n   generated.  As previously mentioned, a
        single error may generate a\n   Notify message in both the upstream and downstream
        directions.  Note\n   that a Notify message MUST NOT be generated unless an
        appropriate\n   Notify Request object has been received.\n   When generating
        Notify messages, a node SHOULD attempt to combine\n   notifications being
        sent to the same Notify Node and that share the\n   same ERROR_SPEC into a
        single Notify message.  The means by which a\n   node determines which information
        may be combined is implementation\n   dependent.  Implementations may use
        event, timer based or other\n   approaches.  If using a timer based approach,
        the implementation\n   SHOULD allow the user to configure the interval over
        which\n   notifications are combined.  When using a timer based approach,
        a\n   default \"notification interval\" of 1 ms SHOULD be used.  Notify\n
        \  messages SHOULD be delivered using the reliable message delivery\n   mechanisms
        defined in [RFC2961].\n   Upon receiving a Notify message, the Notify Node
        SHOULD send a\n   corresponding Ack message.\n"
      title: 4.3.2. Procedures
    title: 4.3. Notify Message
  - contents:
    - "4.4. Removing State with a PathErr message\n   The PathErr message as defined
      in [RFC2205] is sent hop-by-hop to the\n   source of the associated Path message.
      \ Intermediate nodes may\n   inspect this message, but take no action upon it.
      \ In an environment\n   where Path messages are routed according to an IGP and
      that route may\n   change dynamically, this behavior is a fine design choice.\n
      \  However, when RSVP is used with explicit routes, it is often the case\n   that
      errors can only be corrected at the source node or some other\n   node further
      upstream.  In order to clean up resources, the source\n   must receive the PathErr
      and then either send a PathTear (or wait for\n   the messages to timeout).  This
      causes idle resources to be held\n   longer than necessary and increases control
      message load.  In a\n   situation where the control plane is attempting to recover
      from a\n   serious outage, both the message load and the delay in freeing\n
      \  resources hamper the ability to rapidly reconverge.\n   The situation can
      be greatly improved by allowing state to be removed\n   by intermediate nodes
      on certain error conditions.  To facilitate\n   this a new flag is defined in
      the ERROR_SPEC object.  The two\n   currently defined ERROR_SPEC objects (IPv4
      and IPv6 error spec\n   objects) each contain a one byte flag field.  Within
      that field two\n   flags are defined.  This specification defines a third flag,
      0x04,\n   Path_State_Removed.\n   The semantics of the Path_State_Removed flag
      are simply that the node\n   forwarding the error message has removed the Path
      state associated\n   with the PathErr.  By default, the Path_State_Removed flag
      is always\n   set to zero when generating or forwarding a PathErr message.  A
      node\n   which encounters an error MAY set this flag if the error results in\n
      \  the associated Path state being discarded.  If the node setting the\n   flag
      is not the session endpoint, the node SHOULD generate a\n   corresponding PathTear.
      \ A node receiving a PathErr message\n   containing an ERROR_SPEC object with
      the Path_State_Removed flag set\n   MAY also remove the associated Path state.
      \ If the Path state is\n   removed the Path_State_Removed flag SHOULD be set
      in the outgoing\n   PathErr message.  A node which does not remove the associated
      Path\n   state MUST NOT set the Path_State_Removed flag.  A node that receives\n
      \  an error with the Path_State_Removed flag set to zero MUST NOT set\n   this
      flag unless it also generates a corresponding PathTear message.\n   Note that
      the use of this flag does not result in any\n   interoperability incompatibilities.\n"
    title: 4.4. Removing State with a PathErr message
  title: 4. Notification
- contents:
  - "5. Explicit Label Control\n   The Label ERO (Explicit Route Object) and RRO (Record
    Route Object)\n   subobjects are defined to support Explicit Label Control.  Note
    that\n   the Label RRO subobject was defined in [RFC3209] and is being\n   extended
    to support bidirectional LSPs.\n"
  - contents:
    - "5.1. Label ERO subobject\n   The Label ERO subobject is defined as follows:\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |L|    Type     |     Length    |U|   Reserved  |   C-Type      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                             Label                             |\n   |                              ...
      \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  See [RFC3471] for a description of L, U and Label parameters.\n   Type\n
      \     3  Label\n   Length\n      The Length contains the total length of the
      subobject in bytes,\n      including the Type and Length fields.  The Length
      is always\n      divisible by 4.\n   C-Type\n      The C-Type of the included
      Label Object.  Copied from the Label\n      Object.\n"
    - contents:
      - "5.1.1. Procedures\n   The Label subobject follows a subobject containing
        the IP address, or\n   the interface identifier [RFC3477], associated with
        the link on which\n   it is to be used.  Up to two label subobjects may be
        present, one for\n   the downstream label and one for the upstream label.
        \ The following\n   SHOULD result in \"Bad EXPLICIT_ROUTE object\" errors:\n
        \  o If the first label subobject is not preceded by a subobject\n     containing
        an IP address, or an interface identifier [RFC3477],\n     associated with
        an output link.\n   o For a label subobject to follow a subobject that has
        the L-bit set\n   o On unidirectional LSP setup, for there to be a label subobject
        with\n     the U-bit set\n   o For there to be two label subobjects with the
        same U-bit values\n   To support the label subobject, a node must check to
        see if the\n   subobject following its associate address/interface is a label\n
        \  subobject.  If it is, one subobject is examined for unidirectional\n   LSPs
        and two subobjects for bidirectional LSPs.  If the U-bit of the\n   subobject
        being examined is clear (0), then value of the label is\n   copied into a
        new Label_Set object.  This Label_Set object MUST be\n   included on the corresponding
        outgoing Path message.\n   If the U-bit of the subobject being examined is
        set (1), then value\n   of the label is label to be used for upstream traffic
        associated with\n   the bidirectional LSP.  If this label is not acceptable,
        a \"Bad\n   EXPLICIT_ROUTE object\" error SHOULD be generated.  If the label
        is\n   acceptable, the label is copied into a new Upstream_Label object.\n
        \  This Upstream_Label object MUST be included on the corresponding\n   outgoing
        Path message.\n   After processing, the label subobjects are removed from
        the ERO.\n   Note an implication of the above procedures is that the label\n
        \  subobject should never be the first subobject in a newly received\n   message.
        \ If the label subobject is the the first subobject an a\n   received ERO,
        then it SHOULD be treated as a \"Bad strict node\" error.\n   Procedures by
        which an LSR at the head-end of an LSP obtains the\n   information needed
        to construct the Label subobject are outside the\n   scope of this document.\n"
      title: 5.1.1. Procedures
    title: 5.1. Label ERO subobject
  - contents:
    - "5.2. Label RRO subobject\n   The Label RRO subobject is defined as follows:\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |      Type     |     Length    |U|   Flags     |   C-Type      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                             Label                             |\n   |                              ...
      \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  See [RFC3471] for a description of U and Label parameters.\n   Type\n      3
      \ Label\n   Length\n      See [RFC3209].\n   Flags\n      See [RFC3209].\n   C-Type\n
      \     The C-Type of the included Label Object.  Copied from the Label\n      Object.\n"
    - contents:
      - "5.2.1. Procedures\n   Label RRO subobjects are included in RROs as described
        in [RFC3209].\n   The only modification to usage and processing from [RFC3209]
        is that\n   when labels are recorded for bidirectional LSPs, label ERO subobjects\n
        \  for both downstream and upstream labels MUST be included.\n"
      title: 5.2.1. Procedures
    title: 5.2. Label RRO subobject
  title: 5. Explicit Label Control
- contents:
  - "6. Protection Object\n   The use of the Protection Object is optional.  The object
    is included\n   to indicate specific protection attributes of an LSP.  The Protection\n
    \  Object uses Class-Number 37 (of form 0bbbbbbb).\n   The format of the Protection
    Object is:\n    0                   1                   2                   3\n
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |            Length             | Class-Num (37)|   C-Type (1)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |S|                  Reserved                       | Link Flags|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  See [RFC3471] for a description of parameters.\n"
  - contents:
    - "6.1. Procedures\n   Transit nodes processing a Path message containing a Protection\n
      \  Object MUST verify that the requested protection can be satisfied by\n   the
      outgoing interface or tunnel (FA).  If it cannot, the node MUST\n   generate
      a PathErr message, with a \"Routing problem/Unsupported Link\n   Protection\"
      indication.\n"
    title: 6.1. Procedures
  title: 6. Protection Object
- contents:
  - "7. Administrative Status Information\n   Administrative Status Information is
    carried in the Admin_Status\n   object.  The object provides information related
    to the\n   administrative state of a particular LSP.  The information is used
    in\n   two ways.  In the first, the object is carried in Path and Resv\n   messages
    to indicate the administrative state of an LSP.  In the\n   second, the object
    is carried in a Notification message to request\n   that the ingress node change
    the administrative state of an LSP.\n"
  - contents:
    - "7.1. Admin Status Object\n   The use of the Admin_Status Object is optional.
      \ It uses Class-Number\n   196 (of form 11bbbbbb).\n   The format of the Admin_Status
      Object is:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Length             | Class-Num(196)|   C-Type (1)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |R|                        Reserved                       |T|A|D|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  See [RFC3471] for a description of parameters.\n"
    title: 7.1. Admin Status Object
  - contents:
    - "7.2. Path and Resv Message Procedures\n   The Admin_Status object is used to
      notify each node along the path of\n   the status of the LSP.  Status information
      is processed by each node\n   based on local policy and then propagated in the
      corresponding\n   outgoing messages.  The object may be inserted in either Path
      or Resv\n   messages at the discretion of the ingress (for Path messages) or\n
      \  egress (for Resv messages) nodes.  The absence of the object is\n   equivalent
      to receiving an object containing values all set to zero\n   (0).\n   Transit
      nodes receiving a non-refresh Path or Resv message containing\n   an Admin_Status
      object, update their local state, take any\n   appropriate local action based
      on the indicated status and then\n   propagate the received Admin_Status object
      in the corresponding\n   outgoing Path or Resv message.  If the values of an
      Admin_Status\n   object received in a Resv message differs from the values received
      in\n   a Path message then, with one exception, no local action should be\n
      \  taken but the values should still be propagated.  The one case where\n   values
      received in the Resv message should result in local action is\n   when both
      the received R and D bits are set, i.e., are one (1).\n   Edge nodes receiving
      a non-refresh Path or Resv message containing an\n   Admin_Status object, also
      update their local state and take any\n   appropriate local action based on
      the indicated status.  When an\n   Admin Status object is received with the
      R bit set, the receiving\n   edge node should reflect the received values in
      a corresponding\n   outgoing message.  Specifically, if an egress node receives
      a Path\n   message with the R bit of the Admin_Status object set and the node\n
      \  has previously issued a Resv message corresponding to the Path\n   message,
      the node SHOULD send an updated Resv message containing an\n   Admin_Status
      object with the same values set, with the exception of\n   the R bit, as received
      in the corresponding Path message.\n   Furthermore, the egress node SHOULD also
      ensure that subsequent Resv\n   messages sent by the node contain the same Admin
      Status Object.\n   Additionally, if an ingress node receives a Resv message
      with the R\n   bit of the Admin_Status object set, the node SHOULD send an updated\n
      \  Path message containing an Admin_Status object with the same values\n   set,
      with the exception of the R bit, as received in the\n   corresponding Resv message.
      \ Furthermore, the ingress node SHOULD\n   also ensure that subsequent Path
      messages sent by the node contain\n   the same Admin Status Object.\n"
    - contents:
      - "7.2.1. Deletion procedure\n   In some circumstances, particularly optical
        networks, it is useful to\n   set the administrative status of an LSP before
        tearing it down.  In\n   such circumstances the procedure SHOULD be followed
        when deleting an\n   LSP from the ingress:\n   1. The ingress node precedes
        an LSP deletion by inserting an Admin\n      Status Object in a Path message
        and setting the Reflect (R) and\n      Delete (D) bits.\n   2. Transit and
        egress nodes process the Admin Status Object as\n      described above.  (Alternatively,
        the egress MAY respond with a\n      PathErr message with the Path_State_Removed
        flag set, see section\n      4.4.)\n   3. Upon receiving the Admin Status
        Object with the Delete (D) bit set\n      in the Resv message, the ingress
        node sends a PathTear message\n      downstream to remove the LSP and normal
        RSVP processing takes\n      place.\n   In such circumstances the procedure
        SHOULD be followed when deleting\n   an LSP from the egress:\n   1. The egress
        node indicates its desire for deletion by inserting an\n      Admin Status
        Object in a Resv message and setting the Reflect (R)\n      and Delete (D)
        bits.\n   2. Transit nodes process the Admin Status Object as described above.\n
        \  3. Upon receiving the Admin Status Object with the Delete (D) bit set\n
        \     in the Resv message, the ingress node sends a PathTear message\n      downstream
        to remove the LSP and normal RSVP processing takes\n      place.\n"
      title: 7.2.1. Deletion procedure
    - contents:
      - "7.2.2. Compatibility and Error Procedures\n   It is possible that some nodes
        along an LSP will not support the\n   Admin Status Object.  In the case of
        a non-supporting transit node,\n   the object will pass through the node unmodified
        and normal\n   processing can continue.  In the case of a non-supporting egress\n
        \  node, the Admin Status Object will not be reflected back in the Resv\n
        \  Message.  To support the case of a non-supporting egress node, the\n   ingress
        SHOULD only wait a configurable period of time for the\n   updated Admin Status
        Object in a Resv message.  Once the period of\n   time has elapsed, the ingress
        node sends a PathTear message.  By\n   default this period of time SHOULD
        be 30 seconds.\n"
      title: 7.2.2. Compatibility and Error Procedures
    title: 7.2. Path and Resv Message Procedures
  - contents:
    - "7.3. Notify Message Procedures\n   Intermediate and egress nodes may trigger
      the setting of\n   administrative status via the use of Notify messages.  To
      accomplish\n   this, an intermediate or egress node generates a Notify message
      with\n   the corresponding upstream notify session information.  The Admin\n
      \  Status Object MUST be included in the session information, with the\n   appropriate
      bit or bits set.  The Reflect (R) bit MUST NOT be set.\n   The Notify message
      may be, but is not required to be, encapsulated,\n   see Section 4.3.\n   An
      ingress node receiving a Notify message containing an Admin Status\n   Object
      with the Delete (D) bit set, SHOULD initiate the deletion\n   procedure described
      in the previous section.  Other bits SHOULD be\n   propagated in an outgoing
      Path message as normal.\n"
    - contents:
      - "7.3.1. Compatibility and Error Procedures\n   Some special processing is
        required in order to cover the case of\n   nodes that do not support the Admin
        Status Object and other error\n   conditions.  Specifically, a node that sends
        a Notify message\n   containing an Admin Status Object with the Down (D) bit
        set MUST\n   verify that it receives a corresponding Path message with the
        Down\n   (D) bit set within a configurable period of time.  By default this\n
        \  period of time SHOULD be 30 seconds.  If the node does not receive\n   such
        a Path message, it SHOULD send a PathTear message downstream and\n   either
        a ResvTear message or a PathErr message with the\n   Path_State_Removed flag
        set upstream.\n"
      title: 7.3.1. Compatibility and Error Procedures
    title: 7.3. Notify Message Procedures
  title: 7. Administrative Status Information
- contents:
  - "8. Control Channel Separation\n   This section provides the protocol specific
    formats and procedures to\n   required support a control channel not being in-band
    with a data\n   channel.\n"
  - contents:
    - "8.1. Interface Identification\n   The choice of the data interface to use is
      always made by the sender\n   of the Path message. The choice of the data interface
      is indicated by\n   the sender of the Path message by including the data channel's\n
      \  interface identifier in the message using a new RSVP_HOP object sub-\n   type.
      \ For bidirectional LSPs, the sender chooses the data interface\n   in each
      direction.  In all cases but bundling, the upstream interface\n   is implied
      by the downstream interface.  For bundling, the path\n   sender explicitly identifies
      the component interface used in each\n   direction.  The new RSVP_HOP object
      is used in Resv message to\n   indicate the downstream node's usage of the indicated
      interface(s).\n"
    - contents:
      - "8.1.1. IF_ID RSVP_HOP Objects\n   The format of the IPv4 IF_ID RSVP_HOP Object
        is:\n    0                   1                   2                   3\n    0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |            Length             | Class-Num (3) | C-Type (3)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                 IPv4 Next/Previous Hop Address                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                     Logical Interface Handle                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                                               |\n   ~
        \                             TLVs                             ~\n   |                                                               |\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
        format of the IPv6 IF_ID RSVP_HOP Object is:\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |            Length             | Class-Num (3) | C-Type (4)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                                               |\n   |
        \                IPv6 Next/Previous Hop Address                |\n   |                                                               |\n
        \  |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                     Logical Interface Handle                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                                               |\n   ~
        \                             TLVs                             ~\n   |                                                               |\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   See
        [RFC2205] for a description of hop address and handle fields.\n   See [RFC3471]
        for a description of parameters and encoding of\n   TLVs.\n"
      title: 8.1.1. IF_ID RSVP_HOP Objects
    - contents:
      - "8.1.2. Procedures\n   An IF_ID RSVP_HOP object is used in place of previously
        defined\n   RSVP_HOP objects.  It is used on links where there is not a one-to-\n
        \  one association of a control channel to a data channel, see\n   [RFC3471].
        \ The Hop Address and Logical Interface Handle fields are\n   used per standard
        RSVP [RFC2205].\n   TLVs are used to identify the data channel(s) associated
        with an LSP.\n   For a unidirectional LSP, a downstream data channel MUST
        be\n   indicated.  For bidirectional LSPs, a common downstream and upstream\n
        \  data channel is normally indicated.  In the special case where a\n   bidirectional
        LSP that traverses a bundled link, it is possible to\n   specify a downstream
        data channel that differs from the upstream data\n   channel.  Data channels
        are specified from the viewpoint of the\n   sender of the Path message.  The
        IF_ID RSVP_HOP object SHOULD NOT be\n   used when no TLVs are needed.\n   A
        node receiving one or more TLVs in a Path message saves their\n   values and
        returns them in the HOP objects of subsequent Resv\n   messages sent to the
        node that originated the TLVs.\n   Note, the node originating an IF_ID object
        MUST ensure that the\n   selected outgoing interface, as specified in the
        IF_ID object, is\n   consistent with an ERO.  A node that receives an IF_ID
        object SHOULD\n   check whether the information carried in this object is
        consistent\n   with the information carried in a received ERO, and if not
        it MUST\n   send a PathErr Message with the error code \"Routing Error\" and
        error\n   value of \"Bad Explicit Route Object\" toward the sender.  This
        check\n   CANNOT be performed when the initial ERO subobject is not the\n
        \  incoming interface.\n"
      title: 8.1.2. Procedures
    title: 8.1. Interface Identification
  - contents:
    - "8.2. Errored Interface Identification\n   There are cases where it is useful
      to indicate a specific interface\n   associated with an error.  To support these
      cases the IF_ID\n   ERROR_SPEC Objects are defined.\n"
    - contents:
      - "8.2.1. IF_ID ERROR_SPEC Objects\n   The format of the IPv4 IF_ID ERROR_SPEC
        Object is:\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |            Length             | Class-Num (6) | C-Type (3)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                     IPv4 Error Node Address                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |     Flags     |   Error Code  |          Error Value          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                                               |\n   ~
        \                             TLVs                             ~\n   |                                                               |\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
        format of the IPv6 IF_ID ERROR_SPEC Object is:\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |            Length             | Class-Num (6) | C-Type (4)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                                               |\n   |
        \                    IPv6 Error Node Address                   |\n   |                                                               |\n
        \  |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |     Flags     |   Error Code  |          Error Value          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                                               |\n   ~
        \                             TLVs                             ~\n   |                                                               |\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   See
        [RFC2205] for a description of address, flags, error code and\n   error value
        fields.  See [RFC3471] for a description of parameters\n   and encoding of
        TLVs.\n"
      title: 8.2.1. IF_ID ERROR_SPEC Objects
    - contents:
      - "8.2.2. Procedures\n   Nodes wishing to indicate that an error is related
        to a specific\n   interface SHOULD use the appropriate IF_ID ERROR_SPEC Object
        in the\n   corresponding PathErr or ResvErr message.  IF_ID ERROR_SPEC Objects\n
        \  SHOULD be generated and processed as any other ERROR_SPEC Object, see\n
        \  [RFC2205].\n"
      title: 8.2.2. Procedures
    title: 8.2. Errored Interface Identification
  title: 8. Control Channel Separation
- contents:
  - "9. Fault Handling\n   The handling of two types of control communication faults
    is\n   described in this section.  The first, referred to as nodal faults,\n   relates
    to the case where a node losses its control state (e.g.,\n   after a restart)
    but does not loose its data forwarding state.  In\n   the second, referred to
    as control channel faults, relates to the\n   case where control communication
    is lost between two nodes.  The\n   handling of both faults is supported by the
    Restart_Cap object\n   defined below and require the use of Hello messages.\n
    \  Note, the Restart_Cap object MUST NOT be sent when there is no\n   mechanism
    to detect data channel failures independent of control\n   channel failures.\n
    \  Please note this section is derived from [PAN-RESTART].\n"
  - contents:
    - "9.1. Restart_Cap Object\n   The Restart_Cap Object is carried in Hello messages.\n
      \  The format of the Restart_Cap Object is:\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Length             | Class-Num(131)|  C-Type  (1)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                         Restart Time                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                        Recovery Time                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Restart Time: 32 bits\n      Restart Time is measured in milliseconds.  Restart
      Time SHOULD be\n      set to the sum of the time it takes the sender of the
      object to\n      restart its RSVP-TE component (to the point where it can exchange\n
      \     RSVP Hello with its neighbors) and the communication channel that\n      is
      used for RSVP communication.  A value of 0xffffffff indicates\n      that the
      restart of the sender's control plane may occur over an\n      indeterminate
      interval and that the operation of its data plane is\n      unaffected by control
      plane failures.  The method used to ensure\n      continued data plane operation
      is outside the scope of this\n      document.\n   Recovery Time: 32 bits\n      The
      period of time, in milliseconds, that the sender desires for\n      the recipient
      to re-synchronize RSVP and MPLS forwarding state\n      with the sender after
      the re-establishment of Hello\n      synchronization.  A value of zero (0) indicates
      that MPLS\n      forwarding state was not preserved across a particular reboot.\n"
    title: 9.1. Restart_Cap Object
  - contents:
    - "9.2. Processing of Restart_Cap Object\n   Nodes supporting state recovery advertise
      this capability by carrying\n   the Restart_Cap object in Hello messages.  Such
      nodes MUST include\n   the Restart_Cap object in all Hello messages. (Note that
      this\n   includes Hello messages containing ACK objects.)  Usage of the\n   special
      case Recovery Time values is described in greater detail\n   below.\n   When
      a node receives a Hello message with the Restart_Cap object, it\n   SHOULD record
      the values of the parameters received.\n"
    title: 9.2. Processing of Restart_Cap Object
  - contents:
    - "9.3. Modification to Hello Processing to Support State Recovery\n   When a
      node determines that RSVP communication with a neighbor has\n   been lost, and
      the node previously learned that the neighbor supports\n   state recovery, the
      node SHOULD wait at least the amount of time\n   indicated by the Restart Time
      indicated by the neighbor before\n   invoking procedures related to communication
      loss.  A node MAY wait a\n   different amount of time based on local policy
      or configuration\n   information.\n   During this waiting period, all Hello
      messages MUST be sent with a\n   Dst_Instance value set to zero (0), and Src_Instance
      should be\n   unchanged.  While waiting, the node SHOULD also preserve the RSVP
      and\n   MPLS forwarding state for (already) established LSPs that traverse\n
      \  the link(s) between the node and the neighbor.  In a sense with\n   respect
      to established LSPs the node behaves as if it continues to\n   receive periodic
      RSVP refresh messages from the neighbor.  The node\n   MAY clear RSVP and forwarding
      state for the LSPs that are in the\n   process of being established when their
      refresh timers expire.\n   Refreshing of Resv and Path state SHOULD be suppressed
      during this\n   waiting period.\n   During this waiting period, the node MAY
      inform upstream nodes of the\n   communication loss via a PathErr and/or upstream
      Notify message with\n   \"Control Channel Degraded State\" indication.  If such
      notification\n   has been sent, then upon restoration of the control channel
      the node\n   MUST inform other nodes of the restoration via a PathErr and/or\n
      \  upstream Notify message with \"Control Channel Active State\"\n   indication.
      \ (Specific error codes have been assigned by IANA.)\n   When a new Hello message
      is received from the neighbor, the node must\n   determine if the fault was
      limited to the control channel or was a\n   nodal fault.  This determination
      is based on the Src_Instance\n   received from the neighbor.  If the value is
      different than the value\n   that was received from the neighbor prior to the
      fault, then the\n   neighbor should be treated as if it has restarted.  Otherwise,
      the\n   the fault was limited control channel.  Procedures for handling each\n
      \  case are described below.\n"
    title: 9.3. Modification to Hello Processing to Support State Recovery
  - contents:
    - "9.4. Control Channel Faults\n   In the case of control channel faults, the
      node SHOULD refresh all\n   state shared with the neighbor.  Summary Refreshes
      [RFC2961] with the\n   ACK_Desired flag set SHOULD be used, if supported.  Note
      that if a\n   large number of messages are need, some pacing should be applied.\n
      \  All state SHOULD be refreshed within the Recovery time advertised by\n   the
      neighbor.\n"
    title: 9.4. Control Channel Faults
  - contents:
    - "9.5. Nodal Faults\n   Recovering from nodal faults uses one new object and
      other existing\n   protocol messages and objects.\n"
    - contents:
      - "9.5.1. Recovery Label\n   The Recovery_Label object is used during the nodal
        fault recovery\n   process.  The format of a Recovery_Label object is identical
        to a\n   generalized label.  A Recovery_Label object uses Class-Number 34
        (of\n   form 0bbbbbbb) and the C-Type of the label being suggested.\n"
      title: 9.5.1. Recovery Label
    - contents:
      - "9.5.2. Procedures for the Restarting node\n   After a node restarts its control
        plane, a node that supports state\n   recovery SHOULD check whether it was
        able to preserve its MPLS\n   forwarding state.  If no forwarding state from
        prior to the restart\n   was preserved, then the node MUST set the Recovery
        Time to 0 in the\n   Hello message the node sends to its neighbors.\n   If
        the forwarding state was preserved, then the node initiates the\n   state
        recovery process.  The period during which a node is prepared\n   to support
        the recovery process is referred to as the Recovery\n   Period.  The total
        duration of the Recovery Period is advertised by\n   the recovering node in
        the Recovery Time parameter of the Restart_Cap\n   object.  The Recovery Time
        MUST be set to the duration of the\n   Recovery Period in all Hello messages
        sent during the Recovery\n   Period.  State that is not resynchronized during
        the Recovery Period\n   SHOULD be removed at the end of the Period.\n   Note
        that if during Hello synchronization the restarting node\n   determines that
        a neighbor does not support state recovery, and the\n   restarting node maintains
        its MPLS forwarding state on a per neighbor\n   basis, the restarting node
        should immediately consider the Recovery\n   Period with that neighbor completed.
        \ Forwarding state may be\n   considered to be maintained on a per neighbor
        basis when per\n   interface labels are used on point-to-point interfaces.\n
        \  When a node receives a Path message during the Recovery Period, the\n   node
        first checks if it has an RSVP state associated with the\n   message.  If
        the state is found, then the node handles this message\n   according to previously
        defined procedures.\n   If the RSVP state is not found, and the message does
        not carry a\n   Recovery_Label object, the node treats this as a setup for
        a new LSP,\n   and handles it according to previously defined procedures.\n
        \  If the RSVP state is not found, and the message carries a\n   Recovery_Label
        object, the node searches its MPLS forwarding table\n   (the one that was
        preserved across the restart) for an entry whose\n   incoming interface matches
        the Path message and whose incoming label\n   is equal to the label carried
        in the Recovery_Label object.\n   If the MPLS forwarding table entry is not
        found, the node treats this\n   as a setup for a new LSP, and handles it according
        to previously\n   defined procedures.\n   If the MPLS forwarding table entry
        is found, the appropriate RSVP\n   state is created, the entry is bound to
        the LSP associated with the\n   message, and related forwarding state should
        be considered as valid\n   and refreshed.  Normal Path message processing
        should also be\n   conducted.  When sending the corresponding outgoing Path
        message the\n   node SHOULD include a Suggested_Label object with a label
        value\n   matching the outgoing label from the now restored forwarding entry.\n
        \  The outgoing interface SHOULD also be selected based on the\n   forwarding
        entry.  In the special case where a restarting node also\n   has a restating
        downstream neighbor, a Recovery_Label object should\n   be used instead of
        a Suggested_Label object.\n   Additionally, for bidirectional LSPs, the node
        extracts the label\n   from the UPSTREAM_LABEL object carried in the received
        Path message,\n   and searches its MPLS forwarding table for an entry whose
        outgoing\n   label is equal to the label carried in the object (in the case
        of\n   link bundling, this may also involved first identifying the\n   appropriate
        incoming component link).\n   If the MPLS forwarding table entry is not found,
        the node treats this\n   as a setup for a new LSP, and handles it according
        to previously\n   defined procedures.\n   If the MPLS forwarding table entry
        is found, the entry is bound to\n   the LSP associated with the Path message,
        and the entry should be\n   considered to be re-synchronized.  In addition,
        if the node is not\n   the tail-end of the LSP, the corresponding outgoing
        Path messages is\n   sent with the incoming label from that entry carried
        in the\n   UPSTREAM_LABEL object.\n   During the Recovery Period, Resv messages
        are processed normally with\n   two exceptions.  In the case that a forwarding
        entry is recovered, no\n   new label or resource allocation is required while
        processing the\n   Resv message.  The second exception is that ResvErr messages
        SHOULD\n   NOT be generated when a Resv message with no matching Path state
        is\n   received.  In this case the Resv message SHOULD just be silently\n
        \  discarded.\n"
      title: 9.5.2. Procedures for the Restarting node
    - contents:
      - "9.5.3. Procedures for the Neighbor of a Restarting node\n   The following
        specifies the procedures that apply when the node\n   reestablishes communication
        with the neighbor's control plane within\n   the Restart Time, the node determines
        (using the procedures defined\n   in Section 5 of [RFC3209]) that the neighbor's
        control plane has\n   restarted, and the neighbor was able to preserve its
        forwarding state\n   across the restart (as was indicated by a non-zero Recovery
        Time\n   carried in the Restart_Cap object of the RSVP Hello messages received\n
        \  from the neighbor).  Note, a Restart Time value of 0xffffffff\n   indicates
        an infinite Restart Time interval.\n   Upon detecting a restart with a neighbor
        that supports state\n   recovery, a node SHOULD refresh all Path state shared
        with that\n   neighbor.  The outgoing Path messages MUST include a Recovery_Label\n
        \  object containing a label value corresponding to the label value\n   received
        in the most recently received corresponding Resv message.\n   All Path state
        SHOULD be refreshed within approximately 1/2 of the\n   Recovery time advertised
        by the restarted neighbor.  If there are\n   many LSP's going through the
        restarting node, the neighbor node\n   should avoid sending Path messages
        in a short time interval, as to\n   avoid unnecessary stressing the restarting
        node's CPU.  Instead, it\n   should spread the messages across 1/2 the Recovery
        Time interval.\n   After detecting a restart of a neighbor that supports state
        recovery,\n   all Resv state shared with the restarting node MUST NOT be refreshed\n
        \  until a corresponding Path message is received.  This requires\n   suppression
        of normal Resv and Summary Refresh processing to the\n   neighbor during the
        Recovery Time advertised by the restarted\n   neighbor.  As soon as a corresponding
        Path message is received a Resv\n   message SHOULD be generated and normal
        state processing SHOULD be\n   re-enabled.\n"
      title: 9.5.3. Procedures for the Neighbor of a Restarting node
    title: 9.5. Nodal Faults
  title: 9. Fault Handling
- contents:
  - "10. RSVP Message Formats and Handling\n   This message summarizes RSVP message
    formats and handling as modified\n   by GMPLS.\n"
  - contents:
    - "10.1. RSVP Message Formats\n   This section presents the RSVP message related
      formats as modified by\n   this document.  Where they differ, formats for unidirectional
      LSPs\n   are presented separately from bidirectional LSPs.  Unmodified formats\n
      \  are not listed.  Again, MESSAGE_ID and related objects are defined in\n   [RFC2961].\n
      \  The format of a Path message is as follows:\n"
    - "<Path Message> ::=       <Common Header> [ <INTEGRITY> ]\n                         [
      [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                         [ <MESSAGE_ID>
      ]\n                         <SESSION> <RSVP_HOP>\n                         <TIME_VALUES>\n
      \                        [ <EXPLICIT_ROUTE> ]\n                         <LABEL_REQUEST>\n
      \                        [ <PROTECTION> ]\n                         [ <LABEL_SET>
      ... ]\n                         [ <SESSION_ATTRIBUTE> ]\n                         [
      <NOTIFY_REQUEST> ]\n                         [ <ADMIN_STATUS> ]\n                         [
      <POLICY_DATA> ... ]\n                         <sender descriptor>\n   The format
      of the sender description for unidirectional LSPs is:\n"
    - "<sender descriptor> ::=  <SENDER_TEMPLATE> <SENDER_TSPEC>\n                         [
      <ADSPEC> ]\n                         [ <RECORD_ROUTE> ]\n                         [
      <SUGGESTED_LABEL> ]\n                         [ <RECOVERY_LABEL> ]\n   The format
      of the sender description for bidirectional LSPs is:\n"
    - "<sender descriptor> ::=  <SENDER_TEMPLATE> <SENDER_TSPEC>\n                         [
      <ADSPEC> ]\n                         [ <RECORD_ROUTE> ]\n                         [
      <SUGGESTED_LABEL> ]\n                         [ <RECOVERY_LABEL> ]\n                         <UPSTREAM_LABEL>\n
      \  The format of a PathErr message is as follows:\n"
    - "<PathErr Message> ::=    <Common Header> [ <INTEGRITY> ]\n                         [
      [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                         [ <MESSAGE_ID>
      ]\n                         <SESSION> <ERROR_SPEC>\n                         [
      <ACCEPTABLE_LABEL_SET> ... ]\n                         [ <POLICY_DATA> ... ]\n
      \                        <sender descriptor>\n   The format of a Resv message
      is as follows:\n"
    - "<Resv Message> ::=       <Common Header> [ <INTEGRITY> ]\n                         [
      [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                         [ <MESSAGE_ID>
      ]\n                         <SESSION> <RSVP_HOP>\n                         <TIME_VALUES>\n
      \                        [ <RESV_CONFIRM> ]  [ <SCOPE> ]\n                         [
      <NOTIFY_REQUEST> ]\n                         [ <ADMIN_STATUS> ]\n                         [
      <POLICY_DATA> ... ]\n                         <STYLE> <flow descriptor list>\n
      \  <flow descriptor list> is not modified by this document.\n   The format of
      a ResvErr message is as follows:\n"
    - "<ResvErr Message> ::=    <Common Header> [ <INTEGRITY> ]\n                         [
      [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                         [ <MESSAGE_ID>
      ]\n                         <SESSION> <RSVP_HOP>\n                         <ERROR_SPEC>
      [ <SCOPE> ]\n                         [ <ACCEPTABLE_LABEL_SET> ... ]\n                         [
      <POLICY_DATA> ... ]\n                         <STYLE> <error flow descriptor>\n
      \  The modified Hello message format is:\n"
    - "<Hello Message> ::= <Common Header> [ <INTEGRITY> ] <HELLO>\n                    [
      <RESTART_CAP> ]\n"
    title: 10.1. RSVP Message Formats
  - contents:
    - "10.2. Addressing Path, PathTear and ResvConf Messages\n   RSVP was designed
      to handle dynamic (non-explicit) path changes and\n   non RSVP hops along the
      path.  To this end, the Path, PathTear and\n   ResvConf messages carry the destination
      address of the session in the\n   IP header.  In generalized signaling, routes
      are usually explicitly\n   signaled.  Further, hops that cannot allocate labels
      cannot exist in\n   the path of an LSP.  A further difference with traditional
      RSVP is\n   that at times, an RSVP message may travel out of band with respect
      to\n   an LSP's data channel.\n   When a node is sending a Path, PathTear or
      ResvConf message to a node\n   that it knows to be adjacent at the data plane
      (i.e., along the path\n   of the LSP), it SHOULD address the message directly
      to an address\n   associated with the adjacent node's control plane.  In this
      case the\n   router-alert option SHOULD not be included.\n"
    title: 10.2. Addressing Path, PathTear and ResvConf Messages
  title: 10. RSVP Message Formats and Handling
- contents:
  - "11. Acknowledgments\n   This document is the work of numerous authors and consists
    of a\n   composition of a number of previous documents in this area.\n   Valuable
    comments and input were received from a number of people,\n   including Igor Bryskin,
    Adrian Farrel and Dimitrios Pendarakis.\n   Portions of Section 4 are based on
    suggestions and text proposed by\n   Adrian Farrel.\n   The security considerations
    section is based on text provided by\n   Steven Bellovin.\n"
  title: 11. Acknowledgments
- contents:
  - "12. Security Considerations\n   RSVP message security is described in [RFC2747]
    and provides message\n   integrity and node authentication.  For hop-by-hop messages,
    this\n   document introduces no other new security considerations.\n   This document
    introduces the ability to send a Notify message in a\n   non-hop-by-hop fashion.
    \ This precludes RSVP's hop-by-hop integrity\n   and authentication model.  In
    the case where RSVP is generating end-\n   to-end messages and the same level
    of security provided by [RFC2747]\n   is desired, the standard IPSEC based integrity
    and authentication can\n   be used.  Alternatively, the sending of no-hop-by-hop
    Notify messages\n   can be disabled.\n   When using IPSEC to provide message authentication,
    the following\n   apply:\n      Selectors\n         The selector is identified
    by RSVP messages exchanged between a\n         pair of non-adjacent nodes.  The
    nodes are identified by the\n         source and destination IP address of the
    inner IP header used\n         on Notify messages.\n      Mode\n         In this
    application, transport mode is the proper choice.  The\n         information being
    communicated is generally not confidential,\n         so encryption need not be
    used.  Either AH [RFC2402] or ESP\n         [RFC2406] MAY be used; if ESP is used,
    the sender's IP address\n         MUST be checked against the IP address asserted
    in the key\n         management exchange.\n      Key Management\n         To permit
    replay detection, an automated key management system\n         SHOULD be used,
    most likely IKE [RFC2409].  Configured keys MAY\n         be used.\n      Security
    Policy\n         Messages MUST NOT be accepted except from nodes that are not\n
    \        known to the recipient to be authorized to make such requests.\n      Identification\n
    \        Shared keys mechanisms should be adequate for initial\n         deployments
    and smaller networks.  For larger-scale\n         deployments, certificate-based
    IKE should be supported.\n         Whatever scheme is used, it must tie back to
    a source IP\n         address in some fashion.\n      Availability\n         Many
    routers and switches already support IPSEC.  For cases\n         where IPSEC is
    unavailable and security is required, Notify\n         messages MUST be sent hop-by-hop.\n"
  title: 12. Security Considerations
- contents:
  - "13. IANA Considerations\n   IANA assigns values to RSVP protocol parameters.
    \ Within the current\n   document multiple objects are defined.  Each of these
    objects contain\n   C-Types.  This section defines the rules for the assignment
    of the\n   related C-Type values.  This section uses the terminology of BCP 26\n
    \  \"Guidelines for Writing an IANA Considerations Section in RFCs\"\n   [BCP26].\n
    \  As per [RFC2205], C-Type is an 8-bit number that identifies the\n   function
    of an object.  All possible values except zero are available\n   for assignment.\n
    \  The assignment of C-Type values of the objects defined in this\n   document
    fall into three categories.  The first category inherit C-\n   Types from the
    Label object, i.e., object class number 16 [RFC3209].\n   IANA is requested to
    institute a policy whereby all C-Type values\n   assign for the Label object are
    also assigned for the following\n   objects:\n      o Suggested_Label    (Class-Num
    129)\n      o Upstream_Label     (Class-Num 35)\n      o Recovery_Label     (Class-Num
    34)\n   The second category of objects follow independent policies.\n   Specifically,
    following the policies outlined in [BCP26], C-Type\n   values in the range 0x00
    - 0x3F are allocated through an IETF\n   Consensus action, values in the range
    00x40 - 0x5F are allocated as\n   First Come First Served, and values in the range
    0x60 - 0x7F are\n   reserved for Private Use.  This policy applies to the following\n
    \  objects.\n      o Label_Set          (Class-Num 36)\n      o Notify_Request
    \    (Class-Num 195)\n      o Protection         (Class-Num 37)\n      o Admin
    Status       (Class-Num 196)\n      o Restart_Cap        (Class-Num 131)\n   The
    assignment of C-Type values for the remaining object, the\n   Acceptable_Label_Set
    object, follows the assignment of C-Type values\n   of the Label_Set object.  IANA
    will institute a policy whereby all\n   C-Type values assigned for the Label_Set
    object are also assigned for\n   the Acceptable_Label_Set object.\n"
  - contents:
    - "13.1. IANA Assignments\n   This section summarizes values used in this document
      that have been\n   assigned by IANA.\n   ---------------------------------------------------------------------\n
      \  Message Types\n   o Notify message (Message type = 21)\n   ---------------------------------------------------------------------\n
      \  Class Types\n   o RSVP_HOP (C-Num 3)\n     - IPv4 IF_ID RSVP_HOP (C-type
      = 3)\n     - IPv6 IF_ID RSVP_HOP (C-type = 4)\n   o ERROR_SPEC (C-Num 6)\n     -
      IPv4 IF_ID ERROR_SPEC (C-type = 3)\n     - IPv6 IF_ID ERROR_SPEC (C-type = 4)\n
      \  o LABEL_REQUEST (Class-Num 19)\n     - Generalized_Label_Request (C-Type
      = 4)\n   o RSVP_LABEL (Class-Num = 16)\n     - Generalized_Label (C-Type = 2)\n
      \    - Waveband_Switching_Label C-Type (C-Type = 3)\n   ---------------------------------------------------------------------\n
      \  New Class-Nums, C-Types inherited from Label object (same as CNum16)\n   o
      RECOVERY_LABEL     Class-Num of form 0bbbbbbb (= 34)\n   o SUGGESTED_LABEL    Class-Num
      of form 10bbbbbb (= 129)\n   o UPSTREAM_LABEL     Class-Num of form 0bbbbbbb
      (= 35)\n   ---------------------------------------------------------------------\n
      \  New Class-Nums\n   o LABEL_SET                 Class-Num of form 0bbbbbbb
      (= 36)\n     - Type 1               (C-Type = 1)\n   o ACCEPTABLE_LABEL_SET
      \     Class-Num of form 10bbbbbb (= 130)\n     - Type 1 Acceptable_Label_Set
      (C-type from label_set cnum)\n   o NOTIFY_REQUEST            Class-Num of form
      11bbbbbb (= 195)\n     - IPv4 Notify Request  (C-Type = 1)\n     - IPv6 Notify
      Request  (C-Type = 2)\n   o PROTECTION                Class-Num of form 0bbbbbbb
      (= 37)\n     - Type 1               (C-Type = 1)\n   o ADMIN STATUS              Class-Num
      of form 11bbbbbb (= 196)\n     - Type 1               (C-Type = 1)\n   o RESTART_CAP
      \              Class-Num of form 10bbbbbb (= 131)\n     - Type 1               (C-Type
      = 1)\n   ---------------------------------------------------------------------\n
      \  ERO/RRO subobject types\n   o Label ERO subobject\n     Type 3 - Label\n
      \  o Label RRO subobject\n     Type 3 - Label\n   ---------------------------------------------------------------------\n
      \  Error codes\n   o \"Routing problem/Label Set\"                   (value
      = 11)\n   o \"Routing problem/Switching Type\"              (value = 12)\n                                        (duplicate
      code 13 dropped)\n   o \"Routing problem/Unsupported Encoding\"        (value
      = 14)\n   o \"Routing problem/Unsupported Link Protection\" (value = 15)\n   o
      \"Notify Error/Control Channel Active State\"   (value = 4)\n   o \"Notify Error/Control
      Channel Degraded State\" (value = 5)\n   ---------------------------------------------------------------------\n"
    title: 13.1. IANA Assignments
  title: 13. IANA Considerations
- contents:
  - "14. Intellectual Property Considerations\n   This section is taken from Section
    10.4 of [RFC2026].\n   The IETF takes no position regarding the validity or scope
    of any\n   intellectual property or other rights that might be claimed to\n   pertain
    to the implementation or use of the technology described in\n   this document
    or the extent to which any license under such rights\n   might or might not be
    available; neither does it represent that it\n   has made any effort to identify
    any such rights.  Information on the\n   IETF's procedures with respect to rights
    in standards-track and\n   standards-related documentation can be found in BCP-11.
    \ Copies of\n   claims of rights made available for publication and any assurances
    of\n   licenses to be made available, or the result of an attempt made to\n   obtain
    a general license or permission for the use of such\n   proprietary rights by
    implementors or users of this specification can\n   be obtained from the IETF
    Secretariat.\n   The IETF invites any interested party to bring to its attention
    any\n   copyrights, patents or patent applications, or other proprietary\n   rights
    which may cover technology that may be required to practice\n   this standard.
    \ Please address the information to the IETF Executive\n   Director.\n"
  title: 14. Intellectual Property Considerations
- contents:
  - '15. References

    '
  - contents:
    - "15.1. Normative References\n   [RFC2119]        Bradner, S., \"Key words for
      use in RFCs to Indicate\n                    Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC2205]        Braden, R. (Ed.), Zhang, L., Berson,
      S., Herzog, S.\n                    and S. Jamin, \"Resource ReserVation Protocol
      --\n                    Version 1 Functional Specification\", RFC 2205,\n                    September
      1997.\n   [RFC2210]        Wroclawski, J., \"The Use of RSVP with IETF\n                    Integrated
      Services\", RFC 2210, September 1997.\n   [RFC2402]        Kent, S. and R. Atkinson,
      \"IP Authentication\n                    Header\", RFC 2401, November 1998.\n
      \  [RFC2406]        Kent, S. and R. Atkinson, \"IP Encapsulating Security\n
      \                   Payload (ESP)\", RFC 2401, November 1998.\n   [RFC2409]
      \       Harkins, D. and D. Carrel, \"The Internet Key\n                    Exchange
      (IKE)\", RFC 2409, November 1998.\n   [RFC2747]        Baker, F., Lindell, B.
      and M. Talwar, \"RSVP\n                    Cryptographic Authentication\", RFC
      2747, January\n                    2000.\n   [RFC2961]        Berger, L., Gan,
      D., Swallow, G., Pan, P., Tommasi,\n                    F. and S. Molendini,
      \"RSVP Refresh Overhead\n                    Reduction Extensions\", RFC 2961,
      April 2001.\n   [RFC3209]        Awduche, D., Berger, L., Gan, D., Li, T.,\n
      \                   Srinivasan, V. and G. Swallow, \"RSVP-TE: Extensions\n                    to
      RSVP for LSP Tunnels\", RFC 3209, December 2001.\n   [RFC3471]        Berger,
      L., Editor, \"Generalized Multi-Protocol\n                    Label Switching
      (GMPLS) Signaling Functional\n                    Description\", RFC 3471, January
      2003.\n   [RFC3477]        Kompella, K. and Y. Rekhter, \"Signalling Unnumbered\n
      \                   Links in Resource Reservation Protocol - Traffic\n                    Engineering
      (RSVP-TE)\", RFC 3477, January 2003.\n"
    title: 15.1. Normative References
  - contents:
    - "15.2. Informative References\n   [BCP26]          Narten, T. and H. Alvestrand,
      \"Guidelines for\n                    Writing an IANA Considerations Section
      in RFCs\", BCP\n                    26, RFC 2434, October 1998.\n   [MPLS-HIERARCHY]
      Kompella, K. and Y. Rekhter, \"LSP Hierarchy with\n                    MPLS
      TE\", Work in Progress.\n   [PAN-RESTART]    Pan, P., et. al., \"Graceful Restart
      Mechanism for\n                    RSVP-TE\", Work in Progress.\n   [RFC2026]
      \       Bradner, S., \"The Internet Standards Process --\n                    Revision
      3\", BCP 9, RFC 2026, October 1996.\n"
    title: 15.2. Informative References
  title: 15. References
- contents:
  - "16. Contributors\n   Peter Ashwood-Smith\n   Nortel Networks Corp.\n   P.O. Box
    3511 Station C,\n   Ottawa, ON K1Y 4H7\n   Canada\n   Phone:  +1 613 763 4534\n
    \  EMail:  petera@nortelnetworks.com\n   Ayan Banerjee\n   Calient Networks\n
    \  5853 Rue Ferrari\n   San Jose, CA 95138\n   Phone:  +1 408 972-3645\n   EMail:
    \ abanerjee@calient.net\n   Lou Berger\n   Movaz Networks, Inc.\n   7926 Jones
    Branch Drive\n   Suite 615\n   McLean VA, 22102\n   Phone:  +1 703 847-1801\n
    \  EMail:  lberger@movaz.com\n   Greg Bernstein\n   EMail:  gregb@grotto-networking.com\n
    \  John Drake\n   Calient Networks\n   5853 Rue Ferrari\n   San Jose, CA 95138\n
    \  Phone:  +1 408 972 3720\n   EMail:  jdrake@calient.net\n   Yanhe Fan\n   Axiowave
    Networks, Inc.\n   200 Nickerson Road\n   Marlborough, MA 01752\n   Phone: + 1
    774 348 4627\n   EMail: yfan@axiowave.com\n   Kireeti Kompella\n   Juniper Networks,
    Inc.\n   1194 N. Mathilda Ave.\n   Sunnyvale, CA 94089\n   EMail:  kireeti@juniper.net\n
    \  Jonathan P. Lang\n   EMail:  jplang@ieee.org\n   Fong Liaw\n   Solas Research,
    LLC\n   EMail:  fongliaw@yahoo.com\n   Eric Mannie\n   Independent Consultant\n
    \  2 Avenue de la Folle Chanson\n   1050 Brussels\n   Belgium\n   EMail:  eric_mannie@hotmail.com\n
    \  Ping Pan\n   Ciena\n   10480 Ridgeview Court\n   Cupertino, CA 95014\n   Phone:
    \ 408-366-4700\n   EMail:  ppan@ciena.com\n   Bala Rajagopalan\n   Tellium, Inc.\n
    \  2 Crescent Place\n   P.O. Box 901\n   Oceanport, NJ 07757-0901\n   Phone:  +1
    732 923 4237\n   Fax:    +1 732 923 9804\n   EMail:  braja@tellium.com\n   Yakov
    Rekhter\n   Juniper Networks, Inc.\n   EMail:  yakov@juniper.net\n   Debanjan
    Saha\n   EMail:  debanjan@acm.org\n   Vishal Sharma\n   Metanoia, Inc.\n   1600
    Villa Street, Unit 352\n   Mountain View, CA 94041-1174\n   Phone:  +1 650-386-6723\n
    \  EMail:  v.sharma@ieee.org\n   George Swallow\n   Cisco Systems, Inc.\n   250
    Apollo Drive\n   Chelmsford, MA 01824\n   Phone:  +1 978 244 8143\n   EMail:  swallow@cisco.com\n
    \  Z. Bo Tang\n   EMail:  botang01@yahoo.com\n"
  title: 16. Contributors
- contents:
  - "17. Editor's Address\n   Lou Berger\n   Movaz Networks, Inc.\n   7926 Jones Branch
    Drive\n   Suite 615\n   McLean VA, 22102\n   Phone:  +1 703 847-1801\n   EMail:
    \ lberger@movaz.com\n"
  title: 17. Editor's Address
- contents:
  - "18.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 18.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
