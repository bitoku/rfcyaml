- contents:
  - '                  Diameter Load Information Conveyance

    '
  title: __initial_text__
- contents:
  - "Abstract\n   RFC 7068 describes requirements for Overload Control in Diameter.\n
    \  This includes a requirement to allow Diameter nodes to send \"load\"\n   information,
    even when the node is not overloaded.  The base solution\n   defined in RFC 7683
    (Diameter Overload Information Conveyance (DOIC))\n   describes a mechanism meeting
    most of the requirements but does not\n   currently include the ability to send
    load information.  This\n   document defines a mechanism for the conveying of
    Diameter load\n   information.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8583.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n   2.  Terminology and Abbreviations . . . . . . . . . . . . .
    . . .   4\n   3.  Conventions Used in This Document . . . . . . . . . . . . .
    .   5\n   4.  Background  . . . . . . . . . . . . . . . . . . . . . . . . .   5\n
    \    4.1.  Differences between Load and Overload Information . . . .   5\n     4.2.
    \ How Is Load Information Used? . . . . . . . . . . . . . .   6\n   5.  Solution
    Overview . . . . . . . . . . . . . . . . . . . . . .   7\n     5.1.  Theory of
    Operation . . . . . . . . . . . . . . . . . . .   9\n   6.  Load-Mechanism Procedures
    . . . . . . . . . . . . . . . . . .  11\n     6.1.  Reporting-Node Behavior .
    . . . . . . . . . . . . . . . .  11\n       6.1.1.  Endpoint Reporting-Node Behavior
    \ . . . . . . . . . .  11\n       6.1.2.  Agent Reporting-Node Behavior . . .
    . . . . . . . . .  12\n     6.2.  Reacting-Node Behavior  . . . . . . . . . .
    . . . . . . .  13\n     6.3.  Extensibility . . . . . . . . . . . . . . . . .
    . . . . .  14\n     6.4.  Addition and Removal of Nodes . . . . . . . . . . .
    . . .  14\n   7.  Attribute-Value Pairs . . . . . . . . . . . . . . . . . . .
    .  15\n     7.1.  Load AVP  . . . . . . . . . . . . . . . . . . . . . . . .  15\n
    \    7.2.  Load-Type AVP . . . . . . . . . . . . . . . . . . . . . .  15\n     7.3.
    \ Load-Value AVP  . . . . . . . . . . . . . . . . . . . . .  15\n     7.4.  SourceID
    AVP  . . . . . . . . . . . . . . . . . . . . . .  15\n     7.5.  Attribute-Value
    Pair Flag Rules . . . . . . . . . . . . .  16\n   8.  Security Considerations
    . . . . . . . . . . . . . . . . . . .  16\n   9.  IANA Considerations . . . .
    . . . . . . . . . . . . . . . . .  16\n   10. References  . . . . . . . . . .
    . . . . . . . . . . . . . . .  17\n     10.1.  Normative References . . . . .
    . . . . . . . . . . . . .  17\n     10.2.  Informative References . . . . . .
    . . . . . . . . . . .  17\n   Appendix A.  Topology Scenarios . . . . . . . .
    . . . . . . . . .  18\n     A.1.  No Agent  . . . . . . . . . . . . . . . . .
    . . . . . . .  18\n     A.2.  Single Agent  . . . . . . . . . . . . . . . . .
    . . . . .  18\n     A.3.  Multiple Agents . . . . . . . . . . . . . . . . . .
    . . .  19\n     A.4.  Linked Agents . . . . . . . . . . . . . . . . . . . . .
    .  19\n     A.5.  Shared Server Pools . . . . . . . . . . . . . . . . . . .  21\n
    \    A.6.  Agent Chains  . . . . . . . . . . . . . . . . . . . . . .  21\n     A.7.
    \ Fully-Meshed Layers . . . . . . . . . . . . . . . . . . .  22\n     A.8.  Partitions
    \ . . . . . . . . . . . . . . . . . . . . . . .  22\n     A.9.  Active-Standby
    Nodes  . . . . . . . . . . . . . . . . . .  22\n   Authors' Addresses  . . . .
    . . . . . . . . . . . . . . . . . . .  23\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   [RFC7068] describes requirements for Overload Control in
    Diameter\n   [RFC6733].  The DIME Working Group has finished the Diameter Overload\n
    \  Information Conveyance (DOIC) mechanism [RFC7683].  As currently\n   specified,
    DOIC fulfills some, but not all, of the requirements.\n   In particular, DOIC
    does not fulfill Req 23 and Req 24:\n      REQ 23: The solution MUST provide sufficient
    information to enable\n      a load-balancing node to divert messages that are
    rejected or\n      otherwise throttled by an overloaded upstream node to other\n
    \     upstream nodes that are the most likely to have sufficient\n      capacity
    to process them.\n      REQ 24: The solution MUST provide a mechanism for indicating
    load\n      levels, even when not in an overload condition, to assist nodes in\n
    \     making decisions to prevent overload conditions from occurring.\n   There
    are several other requirements in [RFC7068] that mention both\n   overload and
    load information that are only partially fulfilled by\n   DOIC.\n   The DIME Working
    Group explicitly chose not to fulfill these\n   requirements when publishing DOIC
    [RFC7683] due to several reasons.\n   A principal reason was that the working
    group did not agree on a\n   general approach for conveying load information.
    \ It chose to\n   progress the rest of DOIC and deferred load information conveyance
    to\n   a DOIC extension or a separate mechanism.\n   This document defines a mechanism
    that addresses the load-related\n   requirements from RFC 7068.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology and Abbreviations\n   AVP\n      Attribute-Value Pair\n   DOIC\n
    \     Diameter Overload Information Conveyance [RFC7683]\n   Load\n      The relative
    usage of the Diameter message processing capacity of\n      a Diameter node.  A
    low load level indicates that the Diameter\n      node is underutilized.  A high
    load level indicates that the node\n      is closer to being fully utilized.\n
    \  Offered Load\n      The actual traffic sent to the reporting node after overload\n
    \     abatement and routing decisions are made.\n   Reporting Node\n      A DOIC
    node that sends a DOIC Overload report in a Diameter answer\n      message.\n
    \  Reacting Node\n      A DOIC node that receives and acts on a DOIC Overload
    report.\n   Routing Information\n      Routing Information referred to in this
    document can include the\n      Routing and Peer tables defined in RFC 6733.  It
    can also include\n      other implementation-specific tables used to store load\n
    \     information.  This document does not define the structure of such\n      tables.\n"
  title: 2.  Terminology and Abbreviations
- contents:
  - "3.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be
    interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,
    they appear in all\n   capitals, as shown here.\n"
  title: 3.  Conventions Used in This Document
- contents:
  - '4.  Background

    '
  - contents:
    - "4.1.  Differences between Load and Overload Information\n   Previous discussions
      of how to solve the load-related requirements in\n   [RFC7068] have shown that
      people did not have an agreed-upon concept\n   of how \"load\" information differs
      from \"overload\" information.  While\n   the two concepts are highly interrelated,
      there are two primary\n   differences.  First, a Diameter node always has a
      load.  At any given\n   time, that load may be effectively zero, effectively
      fully loaded, or\n   somewhere in between.  In contrast, overload is an exceptional\n
      \  condition.  A node only has Overload information when it is in an\n   overloaded
      state.  Furthermore, the relationship between a node's\n   load level and overload
      state at any given time may be vague.  For\n   example, a node may normally
      operate at a \"fully loaded\" level, but\n   still not be considered overloaded.
      \ Another node may declare itself\n   to be \"overloaded\" even though it might
      not be fully \"loaded\".\n   Second, Overload information, in the form of a
      DOIC Overload Report\n   (OLR) [RFC7683] indicates an explicit request for action
      on the part\n   of the reacting node; the OLR requests that the reacting node
      reduce\n   the offered load, the actual traffic sent to the reporting node after\n
      \  overload abatement and routing decisions are made, by an indicated\n   amount
      (by default) or as prescribed by the selected abatement\n   algorithm.  Effectively,
      DOIC provides a contract between the\n   reporting node and the reacting node.\n
      \  In contrast, load is informational; load information can be\n   considered
      a hint to the recipient node.  That node may use the load\n   information for
      load-balancing purposes, as an input to certain\n   overload abatement techniques,
      to make inferences about the\n   likelihood that the sending node becomes overloaded
      in the immediate\n   future, or for other purposes.\n   None of this prevents
      a Diameter node from deciding to reduce the\n   offered load based on load information.
      \ The fundamental difference\n   is that an Overload report requires the reduction
      of the offered\n   load.  It is also reasonable for a Diameter node to decide
      to\n   increase the offered load based on load information.\n"
    title: 4.1.  Differences between Load and Overload Information
  - contents:
    - "4.2.  How Is Load Information Used?\n   [RFC7068] contemplates two primary
      uses for load information.  Req 23\n   discusses how load information might
      be used when performing\n   diversion as an overload abatement technique as
      described in\n   [RFC7683].  When a reacting node diverts traffic away from
      an\n   overloaded node, it needs load information for the other candidates\n
      \  for that traffic in order to effectively load-balance the diverted\n   load
      between potential candidates.  Otherwise, diversion has a\n   greater potential
      to drive other nodes into overload.\n   Req 24 discusses how Diameter load information
      might be used when no\n   overload condition currently exists.  Diameter nodes
      can use the load\n   information to make decisions to try to avoid overload
      conditions in\n   the first place.  Normal load-balancing falls into this category,
      but\n   the Diameter node can take other proactive steps as well.\n   If the
      loaded nodes are Diameter servers (or clients in the case of\n   server-to-client
      transactions), both of these uses of load\n   information should be accomplished
      by a Diameter node that performs\n   server selection (selection of the Diameter
      endpoint to which the\n   request is to be routed for processing).  Typically,
      server selection\n   is performed by a node (a client or an agent) that is an
      immediate\n   peer of the server.  However, there are scenarios (see Appendix
      A)\n   where a client or proxy that is not the immediate peer to the\n   selected
      servers performs server selection.  In this case, the client\n   or proxy enforces
      the server selection by inserting a Destination-\n   Host AVP.\n   As an example,
      a Diameter node (e.g., client) can use a redirect\n   agent to get candidate
      destination host addresses.  The redirect\n   agent might return several destination
      host addresses from which the\n   Diameter node selects one.  The Diameter node
      can use load\n   information received from these hosts to make the selection.\n
      \  Just as load information can be used as part of server selection, it\n   can
      also be used as input to the selection of the next-hop peer to\n   which a request
      is to be routed.\n   It should be noted that a Diameter node will need to process
      both\n   load reports and Overload reports from the same Diameter node.  The\n
      \  reacting node for the overload report always has the responsibility\n   to
      reduce the amount of Diameter traffic sent to the overloaded node.\n   If, or
      how, the reacting node uses load information to achieve this\n   is left as
      an implementation decision.\n"
    title: 4.2.  How Is Load Information Used?
  title: 4.  Background
- contents:
  - "5.  Solution Overview\n   The mechanism defined here for the conveyance of load
    information is\n   similar in some ways to the mechanism defined for DOIC and
    is\n   different in other ways.\n   As with DOIC, load information is conveyed
    by piggybacking the Load\n   AVPs on existing Diameter applications.\n   There
    are two primary differences.  First, there is no capability\n   negotiation process
    for load.  The sender of the load information is\n   sending it with the expectation
    that any supporting nodes will use it\n   when making routing decisions.  If there
    are no nodes that support\n   the Load mechanism, then the load information is
    ignored.\n   The second big difference between DOIC and Load is visibility of
    the\n   DOIC or load information within a Diameter network.  DOIC information\n
    \  is sent end-to-end resulting in the ability of all nodes in the path\n   of
    the answer message that carries the OC-OLR AVP to act on the\n   information,
    although only one node actually consumes and reacts to\n   the report.  The DOIC
    Overload reports remain in the message all the\n   way from the reporting node
    to the node that is the target for the\n   answer message.\n   For the Load mechanism,
    there are two types of load reports and only\n   the first one is transmitted
    end-to-end.\n   The first type of load report is a host-load report, which contains\n
    \  the load of the endpoint sending the answer message.  This load\n   report
    is carried end-to-end to enable any nodes that make server\n   selection decisions
    to use the load status of the sending endpoint as\n   part of the server selection
    decision.  Unlike with DOIC, more than\n   one node may make use of the load information
    received.\n   The second type of load report is a peer-load report.  This report
    is\n   used by Diameter nodes as part of the logic to select the next-hop\n   Diameter
    node and, as such, does not have significance beyond the\n   peer node.  load
    reports of type \"PEER\" are removed by the first\n   supporting Diameter node
    to receive the report.\n   Because load reports can traverse Diameter nodes that
    do not support\n   the Load mechanism, it is necessary to include the identity
    of the\n   node to which the load report applies as part of the load report.\n
    \  This allows for a Diameter node to verify that a load report applies\n   to
    its peer or that it should be ignored.\n   The load report includes a value indicating
    the relative load of the\n   sending node, specified in a manner consistent with
    that defined for\n   DNS SRV [RFC2782].\n   The goal is to make it possible to
    use both the Load values received\n   as a part of the Diameter Load mechanism
    and weight values received\n   as a result of a DNS SRV query.  As a result, the
    Diameter Load value\n   has a range of 0-65535.  This value and DNS SRV weight
    values are\n   then used in a distribution algorithm similar to that specified
    in\n   [RFC2782].\n   The DNS SRV distribution algorithm results in more messages
    being\n   sent to a node with a higher weight value.  As a result, a higher\n
    \  Diameter Load value indicates a LOWER load on the sending node.  A\n   node
    that is heavily loaded sends a lower Diameter Load value.\n   Stated another way,
    a node that has zero load would have a Load value\n   of 65535.  A node that is
    100% loaded would have a Load value of 0.\n   The distribution algorithm used
    by Diameter nodes supporting the\n   Diameter Load mechanism is an implementation
    decision, but it needs\n   to result in similar behavior to the algorithm described
    for the use\n   of weight values specified in [RFC2782].\n   The method for calculating
    the Load value included in the load report\n   is also left as an implementation
    decision.\n   The frequency for sending of load reports is also left as an\n   implementation
    decision.  The sending node might choose to send load\n   reports in all messages
    or it might choose to only send load reports\n   when the Load value has changed
    by some implementation-specific\n   amount.  The important consideration is that
    all nodes needing the\n   load information have a sufficiently accurate view of
    the node's\n   load.\n"
  - contents:
    - "5.1.  Theory of Operation\n   This section outlines how the Diameter Load mechanism
      is expected to\n   work.\n   For this discussion, assume the following Diameter
      network\n   configuration:\n           ---A1---A3----S[1], S[2]...S[p]\n          /
      \  | \\ /\n         C    |  x\n          \\   | / \\\n           ---A2---A4----S[p+1],
      S[p+2] ...S[n]\n                    Figure 1: Example Diameter Network\n   Note
      that in this diagram, S[1] and S[2] through S[p] are peers to\n   A3.  S[p+1]
      and S[p+2] through S[n] are peers to A4.\n   Also assume that the request for
      a Diameter transaction takes the\n   following path:\n         C     A1     A4
      \    S[n]\n         |      |      |      |\n         |----->|----->|----->|\n
      \        xxR     xxR    xxR\n                      Figure 2: Request Message
      Path\n   When sending the answer message, an endpoint node that supports the\n
      \  Diameter Load mechanism includes its own load information in the\n   answer
      message.  Because it is a Diameter endpoint, it includes a\n   host-load report.\n
      \        C     A1     A4     S[n]\n         |      |      |      |\n         |
      \     |      |<-----|\n         |      |       xxA(Load type:HOST, source:S[n])\n
      \        |      |      |      |\n                    Figure 3: Answer Message
      from S[n]\n   If Agent A4 supports the Load mechanism, then A4's actions depend
      on\n   whether A4 is responsible for doing server selection.  If A4 is not\n
      \  doing server selection, then A4 ignores the host-load report.  If A4\n   is
      responsible for doing server selection, then it stores the load\n   information
      for S[n] in its routing information for the handling of\n   subsequent request
      messages.  In both cases, A4 leaves the host-load\n   report in the message.\n
      \     Note: If A4 does not support the Load mechanism, then it will\n      relay
      the answer message without doing any processing on the load\n      information.
      \ In this case, the load information AVPs will be\n      relayed without change.\n
      \  A4 then calculates its own load information and inserts load\n   information
      AVPs of type \"PEER\" in the message before sending the\n   message to A1.\n
      \        C     A1     A4     S[n]\n         |      |      |      |\n         |
      \     |<-----|      |\n         |       xxA(Load type:PEER, source:A4)\n         |
      \      xxA(Load type:HOST, source:S[n])\n         |      |      |      |\n                     Figure
      4: Answer Message from A4\n   If A1 supports the Load mechanism, then it processes
      each of the load\n   reports it receives separately.\n   For the peer-load report,
      A1 first determines if the source of the\n   report indicated in the load report
      matches the DiameterIdentity of\n   the Diameter node from which the request
      was received.  If the\n   identities do not match, then the peer-load report
      is discarded.  If\n   the identities match, then A1 saves the load information
      in its\n   routing information for routing of subsequent request messages.  In\n
      \  both cases, A1 strips the peer-load report from the message.\n   For the
      host-load report, A1's actions depend on whether A1 is\n   responsible for doing
      server selection.  If A1 is not doing server\n   selection, then A1 ignores
      the host-load report.  If A1 is\n   responsible for doing server selection,
      then it stores the load\n   information for S[n] in its routing information
      for the handling of\n   subsequent request messages.  In both cases, A1 leaves
      the host-load\n   report in the message.\n   A1 then calculates its own load
      information and inserts load\n   information AVPs of type \"PEER\" in the message
      before sending the\n   message to C:\n         C     A1     A4     S[n]\n         |
      \     |      |      |\n         |<-----|      |      |\n          xxA(Load type:PEER,
      source:A1)\n          xxA(Load type:HOST, source:S[n])\n                     Figure
      5: Answer Message from A1\n   As with A1, C processes each load report separately.\n
      \  For the peer-load report, C follows the same procedure as A1 for\n   determining
      if the load report was received from the peer from which\n   the report was
      sent.  When finding it does, C stores the load\n   information for use when
      making future routing decisions.\n   For the host-load report, C saves the load
      information only if it is\n   responsible for doing server selection.\n   The
      load information received by all nodes is then used for routing\n   of subsequent
      request messages.\n"
    title: 5.1.  Theory of Operation
  title: 5.  Solution Overview
- contents:
  - "6.  Load-Mechanism Procedures\n   This section defines the normative behaviors
    for the Load mechanism.\n"
  - contents:
    - "6.1.  Reporting-Node Behavior\n   This section defines the procedures of Diameter
      reporting nodes that\n   generate load reports.\n"
    - contents:
      - "6.1.1.  Endpoint Reporting-Node Behavior\n   A Diameter endpoint that supports
        the Diameter Load mechanism MUST\n   include a load report of type \"HOST\"
        in sufficient answer messages to\n   ensure that all consumers of the load
        information receive timely\n   updates.\n   The Diameter endpoint MUST include
        its own DiameterIdentity in the\n   SourceID AVP included in the Load AVP.\n
        \  The Diameter endpoint MUST include a Load-Type AVP of type \"HOST\" in\n
        \  the Load AVP.\n   The Diameter endpoint MUST include its Load value in
        the Load-Value\n   AVP in the Load AVP.\n   The Load value should be calculated
        in a way that reflects the\n   available load independently of the weight
        of each server in order to\n   accurately compare Load values from different
        nodes.  Any specific\n   Load value needs to identify the same amount of available
        capacity\n   regardless of the Diameter node that calculates the value.\n
        \  The mechanism used to calculate the Load value that fulfills this\n   requirement
        is an implementation decision.\n   The frequency of sending load reports is
        an implementation decision.\n   For instance, if the only consumer of the
        load reports is the\n   endpoint's peer, then the endpoint can choose to only
        include a load\n   report when the load of the endpoint has changed by a meaningful\n
        \  percentage.  If there are consumers of the endpoint load report other\n
        \  than the endpoint's peer (this will be the case if other nodes are\n   responsible
        for server selection), then the endpoint might choose to\n   include load
        reports in all answer messages as a way of ensuring that\n   all nodes doing
        server selection get accurate load information.\n"
      title: 6.1.1.  Endpoint Reporting-Node Behavior
    - contents:
      - "6.1.2.  Agent Reporting-Node Behavior\n   A Diameter Agent that supports
        the Diameter Load mechanism MUST\n   include a peer-load report in sufficient
        answer messages to ensure\n   that all users of the load information receive
        timely updates.\n   The Diameter Agent MUST include its own DiameterIdentity
        in the\n   SourceID AVP included in the Load AVP.\n   The Diameter Agent MUST
        include a Load-Type AVP of type \"PEER\" in the\n   Load AVP.\n   The Diameter
        Agent MUST include its Load value in the Load-Value AVP\n   in the Load AVP.\n
        \  The Load value should be calculated in a way that reflects the\n   available
        load independently of the weight of each agent in order to\n   accurately
        compare Load values from different nodes.  Any specific\n   Load value needs
        to identify the same amount of available capacity\n   regardless of the Diameter
        node that calculates the value.\n   The mechanism used to calculate the Load
        value that fulfills this\n   requirement is an implementation decision.\n
        \  The frequency of sending load reports is an implementation decision.\n
        \     Note: In the case of load reports of type \"PEER\", it is only\n      necessary
        to include load reports when the Load value has changed\n      by some meaningful
        value, as long as the agent ensures that all\n      peers receive the report.
        \ It is also acceptable to include the\n      load report in every answer
        message handled by the Diameter Agent.\n"
      title: 6.1.2.  Agent Reporting-Node Behavior
    title: 6.1.  Reporting-Node Behavior
  - contents:
    - "6.2.  Reacting-Node Behavior\n   This section defines the behavior of Diameter
      nodes processing load\n   reports.\n   A Diameter node that supports the Diameter
      Load mechanism MUST be\n   prepared to process load reports of type \"HOST\"
      and of type \"PEER\",\n   as indicated in the Load-Type AVP included in the
      Load AVP received\n   in the same answer message or from multiple answer messages.\n
      \     Note: The node needs to be able to handle messages with no Load\n      reports,
      messages with just a peer-load report, messages with just\n      a host-load
      report, and messages with both types of load reports.\n   If the Diameter node
      is not responsible for doing server selection,\n   then it SHOULD ignore load
      reports of type \"HOST\".\n   If the Diameter node is responsible for doing
      server selection, then\n   it SHOULD save the Load value included in the Load-Value
      AVP included\n   in the Load AVP of type \"HOST\" in its routing information.\n
      \  If the Diameter node receives a load report of type \"PEER\", then the\n
      \  Diameter node MUST determine if the load report was inserted into the\n   answer
      message by the peer from which the message was received.  This\n   is achieved
      by comparing the DiameterIdentity associated with the\n   connection from which
      the message was received with the\n   DiameterIdentity included in the SourceID
      AVP in the load report.\n   If the Diameter node determines that the load report
      of type \"PEER\"\n   was not received from the peer that sent or relayed the
      answer\n   message, then the node MUST ignore the load report.\n   If the Diameter
      node determines that the load report of type \"PEER\"\n   was received from
      the peer that sent or relayed the answer message,\n   then the node SHOULD save
      the load information in its routing\n   information.\n   In all cases, a Diameter
      Agent MUST strip all load reports of type\n   \"PEER\" received in answer messages.\n
      \     Note: This ensures that there will be precisely one load report of\n      type
      \"PEER\", e.g., that of the Diameter node sending the message,\n      in any
      answer messages sent by the Diameter Agent.\n   How a Diameter node uses load
      information for making routing\n   decisions is an implementation decision.
      \ However, the distribution\n   algorithm MUST result in similar behavior as
      the algorithm described\n   for the use of weight values in [RFC2782].\n"
    title: 6.2.  Reacting-Node Behavior
  - contents:
    - "6.3.  Extensibility\n   The Load mechanism can be extended to include additional
      information\n   in the load reports.\n   Any extension may define new AVPs for
      use in load reports.  These new\n   AVPs SHOULD be defined to be extensions
      to the Load AVPs defined in\n   this document.\n   Grouped AVP extension mechanisms
      defined by [RFC6733] apply.  This\n   allows, for example, defining a new feature
      that is mandatory to be\n   understood even when piggybacked on an existing
      application.\n   As with any Diameter specification, [RFC6733] requires all
      new AVPs\n   to be registered with IANA.  See Section 9 for the required\n   procedures.\n"
    title: 6.3.  Extensibility
  - contents:
    - "6.4.  Addition and Removal of Nodes\n   When a Diameter node is added, the
      new node will start by advertising\n   its load.  Downstream nodes will need
      to factor the new load\n   information into load-balancing decisions.  The downstream
      nodes can\n   attempt to ensure a smooth increase of the traffic to the new
      node,\n   avoiding an immediate spike of traffic to that new node.  The method\n
      \  for the handling of such a smooth increase is implementation-\n   specific,
      but it can rely on the evolution of load information\n   received from the new
      node and from the other nodes.\n   When removing a node in a controlled way
      (e.g., for maintenance\n   purposes, so outside a failure case), it might be
      appropriate to\n   progressively reduce the traffic to this node by routing
      traffic to\n   other nodes.  Simple load information (load percentage) would
      not be\n   sufficient.  The method for the handling of the node removal is\n
      \  implementation-specific, but it can rely on the evolution of the load\n   information
      received from the node to be removed.\n"
    title: 6.4.  Addition and Removal of Nodes
  title: 6.  Load-Mechanism Procedures
- contents:
  - "7.  Attribute-Value Pairs\n   The section defines the AVPs required for the Load
    mechanism.\n"
  - contents:
    - "7.1.  Load AVP\n   The Load AVP (AVP code 650) is of type Grouped and is used
      to convey\n   load information between Diameter nodes.\n    Load ::= < AVP Header:
      650 >\n             [ Load-Type ]\n             [ Load-Value ]\n             [
      SourceID ]\n           * [ AVP ]\n"
    title: 7.1.  Load AVP
  - contents:
    - "7.2.  Load-Type AVP\n   The Load-Type AVP (AVP code 651) is of type Enumerated.
      \ It is used\n   to convey the type of Diameter node that sent the load information.\n
      \  The following values are defined:\n   HOST 0  The load report is for a host.\n
      \  PEER 1  The load report is for a peer.\n"
    title: 7.2.  Load-Type AVP
  - contents:
    - "7.3.  Load-Value AVP\n   The Load-Value AVP (AVP code 652) is of type Unsigned64.
      \ It is used\n   to convey relative load information about the sender of the
      load\n   report.\n   The Load-Value AVP is specified in a manner similar to
      the weight\n   value in DNS SRV ([RFC2782]).\n   The Load value has a range
      of 0-65535.\n   A higher value indicates a lower load on the sending node.  A
      lower\n   value indicates that the sending node is heavily loaded.\n      Stated
      another way, a node that has zero load would have a Load\n      value of 65535.
      \ A node that is 100% loaded would have a Load\n      value of 0.\n"
    title: 7.3.  Load-Value AVP
  - contents:
    - "7.4.  SourceID AVP\n   The SourceID AVP is defined in [RFC8581].  It is used
      to identify the\n   Diameter node that sent the load report.\n"
    title: 7.4.  SourceID AVP
  - contents:
    - "7.5.  Attribute-Value Pair Flag Rules\n                                                             +---------+\n
      \                                                            |AVP flag |\n                                                             |rules
      \   |\n                                                             +----+----+\n
      \                           AVP   Section                    |    |MUST|\n     Attribute
      Name         Code  Defined  Value Type        |MUST| NOT|\n    +--------------------------------------------------------+----+----+\n
      \   |Load                   650   7.1      Grouped           |    | V  |\n    +--------------------------------------------------------+----+----+\n
      \   |Load-Type              651   7.2      Enumerated        |    | V  |\n    +--------------------------------------------------------+----+----+\n
      \   |Load-Value             652   7.3      Unsigned64        |    | V  |\n    +------------------------------------------------------
      -+----+----+\n    |SourceID               649   7.4      DiameterIdentity  |
      \   | V  |\n    +--------------------------------------------------------+----+----+\n
      \  As described in the Diameter base protocol [RFC6733], the M-bit usage\n   for
      a given AVP in a given command may be defined by the application.\n"
    title: 7.5.  Attribute-Value Pair Flag Rules
  title: 7.  Attribute-Value Pairs
- contents:
  - "8.  Security Considerations\n   Load information may be sensitive information
    in some cases.\n   Depending on the mechanism, an unauthorized recipient might
    be able\n   to infer the topology of a Diameter network from load information.\n
    \  Load information might be useful in identifying targets for denial-\n   of-service
    (DoS) attacks, where a node known to be already heavily\n   loaded might be a
    tempting target.  Load information might also be\n   useful as feedback about
    the success of an ongoing DoS attack.\n   Given that routing decisions are impacted
    by load information, there\n   is potential for negative impacts on a Diameter
    network caused by\n   erroneous or malicious load reports.  This includes the
    malicious\n   changing of Load values by Diameter Agents.\n   Any load information
    conveyance mechanism will need to allow\n   operators to avoid sending load information
    to nodes that are not\n   authorized to receive it.  Since Diameter currently
    only offers\n   authentication of nodes at the transport level and does not support\n
    \  end-to-end security mechanisms, any solution that sends load\n   information
    to non-peer nodes requires a transitive-trust model.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  IANA Considerations\n   IANA has registered three new AVP codes in the \"Authentication,\n
    \  Authorization, and Accounting (AAA) Parameters\" registry; see\n   Sections
    7.1, 7.2, and 7.3.\n"
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC2782]  Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for\n              specifying
      the location of services (DNS SRV)\", RFC 2782,\n              DOI 10.17487/RFC2782,
      February 2000,\n              <https://www.rfc-editor.org/info/rfc2782>.\n   [RFC6733]
      \ Fajardo, V., Ed., Arkko, J., Loughney, J., and G. Zorn,\n              Ed.,
      \"Diameter Base Protocol\", RFC 6733,\n              DOI 10.17487/RFC6733, October
      2012,\n              <https://www.rfc-editor.org/info/rfc6733>.\n   [RFC7683]
      \ Korhonen, J., Ed., Donovan, S., Ed., Campbell, B., and L.\n              Morand,
      \"Diameter Overload Indication Conveyance\",\n              RFC 7683, DOI 10.17487/RFC7683,
      October 2015,\n              <https://www.rfc-editor.org/info/rfc7683>.\n   [RFC8174]
      \ Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8581]  Donovan, S., \"Diameter
      Agent Overload and the Peer\n              Overload Report\", RFC 8581, DOI
      10.17487/RFC8581, August\n              2019, <https://www.rfc-editor.org/info/rfc8581>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [RFC7068]  McMurry, E. and B. Campbell, \"Diameter
      Overload Control\n              Requirements\", RFC 7068, DOI 10.17487/RFC7068,
      November\n              2013, <https://www.rfc-editor.org/info/rfc7068>.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Topology Scenarios\n   This section presents a number of Diameter
    topology scenarios and\n   discusses how load information might be used in each
    scenario.\n"
  - contents:
    - "A.1.  No Agent\n   Figure 6 shows a simple client-server scenario where a client
      picks\n   from a set of candidate servers available for a particular realm and\n
      \  application.  The client selects the server for a given transaction\n   using
      the load information received from each server.\n       ------S1\n      /\n
      \    C\n      \\\n       ------S2\n                  Figure 6: Basic Client
      Server Scenario\n      If a node supports dynamic discovery, it will not obtain
      load\n      information from the nodes with which it has no Diameter\n      connection
      established.  Nevertheless, it might take into account\n      the load information
      from the other nodes to decide to add\n      connections to new nodes with the
      dynamic discovery mechanism.\n      Note: The use of dynamic connections needs
      to be considered.\n"
    title: A.1.  No Agent
  - contents:
    - "A.2.  Single Agent\n   Figure 7 shows a client that sends requests to an agent.
      \ The agent\n   selects the request destination from a set of candidate servers,\n
      \  using load information received from each server.  The client does\n   not
      need to receive load information since it does not select between\n   multiple
      agents.\n            ------S1\n           /\n     C----A\n           \\\n            ------S2\n
      \                     Figure 7: Simple Agent Scenario\n"
    title: A.2.  Single Agent
  - contents:
    - "A.3.  Multiple Agents\n   Figure 8 shows a client selecting between multiple
      agents and each\n   agent selecting from multiple servers.  The client selects
      an agent\n   based on the load information received from each agent.  Each agent\n
      \  selects a server based on the load information received from its\n   servers.\n
      \  This scenario adds a complication that one set of servers may be more\n   loaded
      than the other set.  If, for example, S4 was the least loaded\n   server, C
      would need to know to select agent A2 to reach S4.  This\n   might require C
      to receive load information from the servers as well\n   as the agents.  Alternatively,
      each agent might use the load of its\n   servers as an input into calculating
      its own load, in effect\n   aggregating upstream load.\n   Similarly, if C sends
      a host-routed request [RFC7683], it needs to\n   know which agent can deliver
      requests to the selected server.\n   Without some special, potentially proprietary,
      knowledge of the\n   topology upstream of A1 and A2, C would select the agent
      based on the\n   normal peer selection procedures for the realm and application,
      and\n   perhaps consider the load information from A1 and A2.  If C sends a\n
      \  request to A1 that contains a Destination-Host AVP with a value of\n   S4,
      A1 will not be able to deliver the request.\n             -----S3\n            /\n
      \      ---A1------S1\n      /\n     C\n      \\\n       ---A2------S2\n            \\\n
      \            ---- S4\n                   Figure 8: Multiple Agents and Servers\n"
    title: A.3.  Multiple Agents
  - contents:
    - "A.4.  Linked Agents\n   Figure 9 shows a scenario similar to that of Figure
      8, except that\n   the agents are linked so that A1 can forward a request to
      A2, and\n   vice-versa.  Each agent could receive load information from the\n
      \  linked agent as well as its connected servers.\n   This somewhat simplifies
      the complication from Figure 8 due to the\n   fact that C does not necessarily
      need to choose a particular agent to\n   reach a particular server.  But, it
      creates a similar question of\n   how, for example, A1 might know that S4 was
      less loaded than S1 or\n   S3.  Additionally, it creates the opportunity for
      sub-optimal request\n   paths.  For example, [C,A1,A2,S4] vs. [C,A2,S4].\n   A
      likely application for linked agents is when each agent prefers to\n   route
      only to directly connected servers and only forwards requests\n   to another
      agent under exceptional circumstances.  For example, A1\n   might not forward
      requests to A2 unless both S1 and S3 are\n   overloaded.  In this case, A1 might
      use the load information from S1\n   and S3 to select between those, and only
      consider the load\n   information from A2 (and other connected agents) if it
      needs to\n   divert requests to different agents.\n              -----S3\n             /\n
      \       ---A1------S1\n      /    |\n     C     |\n      \\    |\n        ---A2------S2\n
      \            \\\n              ---- S4\n                          Figure 9:
      Linked Agents\n   Figure 10 is a variant of Figure 9.  In this case, C1 sends
      all\n   traffic through A1, and C2 sends all traffic through A2.  By default,\n
      \  A1 will load-balance traffic between S1 and S3, and A2 will load-\n   balance
      traffic between S2 and S4.\n   Now, if S1 and S3 are significantly more loaded
      than S2 and S4, A1\n   may route some C1 traffic to A2.  This is a non-optimal
      path, but it\n   allows better load balancing between the servers.  To achieve
      this,\n   A1 needs to receive some load info from A2 about the S2/S4 load.\n
      \             -----S3\n             /\n     C1----A1------S1\n           |\n
      \          |\n           |\n     C2----A2------S2\n             \\\n              ----
      S4\n                         Figure 10: Linked Agents\n"
    title: A.4.  Linked Agents
  - contents:
    - "A.5.  Shared Server Pools\n   Figure 11 is similar to Figure 9, except that
      instead of a link\n   between agents, each agent is linked to all servers (The
      links to\n   each set of servers should be interpreted as a link to each server.\n
      \  The links are not shown separately due to the limitations of ASCII\n   art.).\n
      \  In this scenario, each agent can select among all of the servers\n   based
      on the load information from the servers.  The client need only\n   be concerned
      with the load information of the agents.\n       ---A1---S[1], S[2]...S[p]\n
      \     /     \\ /\n     C       x\n      \\     / \\\n       ---A2---S[p+1],
      S[p+2] ...S[n]\n                      Figure 11: Shared Server Pools\n"
    title: A.5.  Shared Server Pools
  - contents:
    - "A.6.  Agent Chains\n   The scenario in Figure 12 is similar to that of Figure
      8, except that\n   instead of the client possibly needing to select an agent
      that can\n   route requests to the least loaded server, in this case A1 and
      A2\n   need to make similar decisions when selecting between A3 or A4.  As\n
      \  the former scenario, this could be mitigated if A3 and A4 aggregate\n   upstream
      loads into the load information they report downstream.\n       ---A1---A3----S[1],
      S[2]...S[p]\n      /   | \\ /\n     C    |  x\n      \\   | / \\\n       ---A2---A4----S[p+1],
      S[p+2] ...S[n]\n                          Figure 12: Agent Chains\n"
    title: A.6.  Agent Chains
  - contents:
    - "A.7.  Fully-Meshed Layers\n   Figure 13 extends the scenario in Figure 11 by
      adding an extra layer\n   of agents.  But since each layer of nodes can reach
      any node in the\n   next layer, each node only needs to consider the load of
      its next-hop\n   peer.\n       ---A1---A3---S[1], S[2]...S[p]\n      /   | \\
      / |\\ /\n     C    |  x  | x\n      \\   | / \\ |/ \\\n       ---A2---A4---S[p+1],
      S[p+2] ...S[n]\n                           Figure 13: Full Mesh\n"
    title: A.7.  Fully-Meshed Layers
  - contents:
    - "A.8.  Partitions\n   A Diameter network with multiple servers is said to be
      \"partitioned\"\n   when only a subset of available servers can serve a particular
      realm-\n   routed request.  For example, one group of servers may handle users\n
      \  whose names start with \"A\" through \"M\", and another group may handle\n
      \  \"N\" through \"Z\".\n   In such a partitioned network, nodes cannot load
      balance requests\n   across partitions since not all servers can handle the
      request.  A\n   client, or an intermediate agent, may still be able to load
      balance\n   between servers inside a partition.\n"
    title: A.8.  Partitions
  - contents:
    - "A.9.  Active-Standby Nodes\n   The previous scenarios assume that traffic can
      be load balanced among\n   all peers that are eligible to handle a request.
      \ That is, the peers\n   operate in an \"active-active\" configuration.  In
      an \"active-standby\"\n   configuration, traffic would be load balanced among
      active peers.\n   Requests would only be sent to peers in a \"standby\" state
      if the\n   active peers became unavailable.  For example, requests might be\n
      \  diverted to a stand-by peer if one or more active peers becomes\n   overloaded.\n"
    title: A.9.  Active-Standby Nodes
  title: Appendix A.  Topology Scenarios
- contents:
  - "Authors' Addresses\n   Ben Campbell\n   Oracle\n   7460 Warren Parkway, Suite
    300\n   Frisco, Texas  75034\n   United States of America\n   Email: ben@nostrum.com\n
    \  Steve Donovan (editor)\n   Oracle\n   7460 Warren Parkway # 300\n   Frisco,
    Texas  75034\n   United States of America\n   Email: srdonovan@usdonovans.com\n
    \  Jean-Jacques Trottin\n   Nokia\n   Route de Villejust\n   91620 Nozay\n   France\n
    \  Email: jean-jacques.trottin@nokia.com\n"
  title: Authors' Addresses
