- title: __initial_text__
  contents:
  - '                          UDP Usage Guidelines

    '
- title: Abstract
  contents:
  - "Abstract\n   The User Datagram Protocol (UDP) provides a minimal message-passing\n\
    \   transport that has no inherent congestion control mechanisms.  This\n   document\
    \ provides guidelines on the use of UDP for the designers of\n   applications,\
    \ tunnels, and other protocols that use UDP.  Congestion\n   control guidelines\
    \ are a primary focus, but the document also\n   provides guidance on other topics,\
    \ including message sizes,\n   reliability, checksums, middlebox traversal, the\
    \ use of Explicit\n   Congestion Notification (ECN), Differentiated Services Code\
    \ Points\n   (DSCPs), and ports.\n   Because congestion control is critical to\
    \ the stable operation of the\n   Internet, applications and other protocols that\
    \ choose to use UDP as\n   an Internet transport must employ mechanisms to prevent\
    \ congestion\n   collapse and to establish some degree of fairness with concurrent\n\
    \   traffic.  They may also need to implement additional mechanisms,\n   depending\
    \ on how they use UDP.\n   Some guidance is also applicable to the design of other\
    \ protocols\n   (e.g., protocols layered directly on IP or via IP-based tunnels),\n\
    \   especially when these protocols do not themselves provide congestion\n   control.\n\
    \   This document obsoletes RFC 5405 and adds guidelines for multicast\n   UDP\
    \ usage.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo documents an Internet Best Current Practice.\n\
    \   This document is a product of the Internet Engineering Task Force\n   (IETF).\
    \  It represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   BCPs is available in Section\
    \ 2 of RFC 7841.\n   Information about the current status of this document, any\
    \ errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8085.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................5\n  \
    \ 3. UDP Usage Guidelines ............................................5\n    \
    \  3.1. Congestion Control Guidelines ..............................6\n      3.2.\
    \ Message Size Guidelines ...................................19\n      3.3. Reliability\
    \ Guidelines ....................................21\n      3.4. Checksum Guidelines\
    \ .......................................22\n      3.5. Middlebox Traversal Guidelines\
    \ ............................25\n      3.6. Limited Applicability and Controlled\
    \ Environments .........27\n   4. Multicast UDP Usage Guidelines .................................28\n\
    \      4.1. Multicast Congestion Control Guidelines ...................30\n  \
    \    4.2. Message Size Guidelines for Multicast .....................32\n   5.\
    \ Programming Guidelines .........................................32\n      5.1.\
    \ Using UDP Ports ...........................................34\n      5.2. ICMP\
    \ Guidelines ...........................................37\n   6. Security Considerations\
    \ ........................................38\n   7. Summary ........................................................40\n\
    \   8. References .....................................................42\n  \
    \    8.1. Normative References ......................................42\n    \
    \  8.2. Informative References ....................................43\n   Appendix\
    \ A. .......................................................53\n   Acknowledgments\
    \ ...................................................55\n   Authors' Addresses\
    \ ................................................55\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The User Datagram Protocol (UDP) [RFC768] provides a minimal,\n\
    \   unreliable, best-effort, message-passing transport to applications\n   and\
    \ other protocols (such as tunnels) that wish to operate over IP.\n   Both are\
    \ simply called \"applications\" in the remainder of this\n   document.\n   Compared\
    \ to other transport protocols, UDP and its UDP-Lite variant\n   [RFC3828] are\
    \ unique in that they do not establish end-to-end\n   connections between communicating\
    \ end systems.  UDP communication\n   consequently does not incur connection establishment\
    \ and teardown\n   overheads, and there is minimal associated end-system state.\
    \  Because\n   of these characteristics, UDP can offer a very efficient\n   communication\
    \ transport to some applications.\n   A second unique characteristic of UDP is\
    \ that it provides no inherent\n   congestion control mechanisms.  On many platforms,\
    \ applications can\n   send UDP datagrams at the line rate of the platform's link\
    \ interface,\n   which is often much greater than the available end-to-end path\n\
    \   capacity, and doing so contributes to congestion along the path.\n   [RFC2914]\
    \ describes the best current practice for congestion control\n   in the Internet.\
    \  It identifies two major reasons why congestion\n   control mechanisms are critical\
    \ for the stable operation of the\n   Internet:\n   1.  The prevention of congestion\
    \ collapse, i.e., a state where an\n       increase in network load results in\
    \ a decrease in useful work\n       done by the network.\n   2.  The establishment\
    \ of a degree of fairness, i.e., allowing\n       multiple flows to share the\
    \ capacity of a path reasonably\n       equitably.\n   Because UDP itself provides\
    \ no congestion control mechanisms, it is\n   up to the applications that use\
    \ UDP for Internet communication to\n   employ suitable mechanisms to prevent\
    \ congestion collapse and\n   establish a degree of fairness.  [RFC2309] discusses\
    \ the dangers of\n   congestion-unresponsive flows and states that \"all UDP-based\n\
    \   streaming applications should incorporate effective congestion\n   avoidance\
    \ mechanisms.\"  [RFC7567] reaffirms this statement.  This is\n   an important\
    \ requirement, even for applications that do not use UDP\n   for streaming.  In\
    \ addition, congestion-controlled transmission is of\n   benefit to an application\
    \ itself, because it can reduce self-induced\n   packet loss, minimize retransmissions,\
    \ and hence reduce delays.\n   Congestion control is essential even at relatively\
    \ slow transmission\n   rates.  For example, an application that generates five\
    \ 1500-byte UDP\n   datagrams in one second can already exceed the capacity of\
    \ a 56 Kb/s\n   path.  For applications that can operate at higher, potentially\n\
    \   unbounded data rates, congestion control becomes vital to prevent\n   congestion\
    \ collapse and establish some degree of fairness.  Section 3\n   describes a number\
    \ of simple guidelines for the designers of such\n   applications.\n   A UDP datagram\
    \ is carried in a single IP packet and is hence limited\n   to a maximum payload\
    \ of 65,507 bytes for IPv4 and 65,527 bytes for\n   IPv6.  The transmission of\
    \ large IP packets usually requires IP\n   fragmentation.  Fragmentation decreases\
    \ communication reliability and\n   efficiency and should be avoided.  IPv6 allows\
    \ the option of\n   transmitting large packets (\"jumbograms\") without fragmentation\
    \ when\n   all link layers along the path support this [RFC2675].  Some of the\n\
    \   guidelines in Section 3 describe how applications should determine\n   appropriate\
    \ message sizes.  Other sections of this document provide\n   guidance on reliability,\
    \ checksums, middlebox traversal and use of\n   multicast.\n   This document provides\
    \ guidelines and recommendations.  Although most\n   UDP applications are expected\
    \ to follow these guidelines, there do\n   exist valid reasons why a specific\
    \ application may decide not to\n   follow a given guideline.  In such cases,\
    \ it is RECOMMENDED that\n   application designers cite the respective section(s)\
    \ of this document\n   in the technical specification of their application or\
    \ protocol and\n   explain their rationale for their design choice.\n   [RFC5405]\
    \ was scoped to provide guidelines for unicast applications\n   only, whereas\
    \ this document also provides guidelines for UDP flows\n   that use IP anycast,\
    \ multicast, broadcast, and applications that use\n   UDP tunnels to support IP\
    \ flows.\n   Finally, although this document specifically refers to usage of UDP,\n\
    \   the spirit of some of its guidelines also applies to other message-\n   passing\
    \ applications and protocols (specifically on the topics of\n   congestion control,\
    \ message sizes, and reliability).  Examples\n   include signaling, tunnel or\
    \ control applications that choose to run\n   directly over IP by registering\
    \ their own IP protocol number with\n   IANA.  This document is expected to provide\
    \ useful background reading\n   to the designers of such applications and protocols.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   [RFC2119].\n"
- title: 3.  UDP Usage Guidelines
  contents:
  - "3.  UDP Usage Guidelines\n   Internet paths can have widely varying characteristics,\
    \ including\n   transmission delays, available bandwidths, congestion levels,\n\
    \   reordering probabilities, supported message sizes, or loss rates.\n   Furthermore,\
    \ the same Internet path can have very different\n   conditions over time.  Consequently,\
    \ applications that may be used on\n   the Internet MUST NOT make assumptions\
    \ about specific path\n   characteristics.  They MUST instead use mechanisms that\
    \ let them\n   operate safely under very different path conditions.  Typically,\
    \ this\n   requires conservatively probing the current conditions of the\n   Internet\
    \ path they communicate over to establish a transmission\n   behavior that it\
    \ can sustain and that is reasonably fair to other\n   traffic sharing the path.\n\
    \   These mechanisms are difficult to implement correctly.  For most\n   applications,\
    \ the use of one of the existing IETF transport protocols\n   is the simplest\
    \ method of acquiring the required mechanisms.  Doing\n   so also avoids issues\
    \ that protocols using a new IP protocol number\n   face when being deployed over\
    \ the Internet, where middleboxes that\n   only support TCP and UDP are sometimes\
    \ present.  Consequently, the\n   RECOMMENDED alternative to the UDP usage described\
    \ in the remainder\n   of this section is the use of an IETF transport protocol\
    \ such as TCP\n   [RFC793], Stream Control Transmission Protocol (SCTP) [RFC4960],\
    \ and\n   SCTP Partial Reliability Extension (SCTP-PR) [RFC3758], or Datagram\n\
    \   Congestion Control Protocol (DCCP) [RFC4340] with its different\n   congestion\
    \ control types [RFC4341][RFC4342][RFC5622], or transport\n   protocols specified\
    \ by the IETF in the future.  (UDP-encapsulated\n   SCTP [RFC6951] and DCCP [RFC6773]\
    \ can offer support for traversing\n   firewalls and other middleboxes where the\
    \ native protocols are not\n   supported.)\n   If used correctly, these more fully\
    \ featured transport protocols are\n   not as \"heavyweight\" as often claimed.\
    \  For example, the TCP\n   algorithms have been continuously improved over decades,\
    \ and they\n   have reached a level of efficiency and correctness that custom\n\
    \   application-layer mechanisms will struggle to easily duplicate.  In\n   addition,\
    \ many TCP implementations allow connections to be tuned by\n   an application\
    \ to its purposes.  For example, TCP's \"Nagle\" algorithm\n   [RFC1122] can be\
    \ disabled, improving communication latency at the\n   expense of more frequent\
    \ -- but still congestion controlled -- packet\n   transmissions.  Another example\
    \ is the TCP SYN cookie mechanism\n   [RFC4987], which is available on many platforms.\
    \  TCP with SYN\n   cookies does not require a server to maintain per-connection\
    \ state\n   until the connection is established.  TCP also requires the end that\n\
    \   closes a connection to maintain the TIME-WAIT state that prevents\n   delayed\
    \ segments from one connection instance from interfering with a\n   later one.\
    \  Applications that are aware of and designed for this\n   behavior can shift\
    \ maintenance of the TIME-WAIT state to conserve\n   resources by controlling\
    \ which end closes a TCP connection [FABER].\n   Finally, TCP's built-in capacity-probing\
    \ and awareness of the maximum\n   transmission unit supported by the path (PMTU)\
    \ results in efficient\n   data transmission that quickly compensates for the\
    \ initial connection\n   setup delay, in the case of transfers that exchange more\
    \ than a few\n   segments.\n"
- title: 3.1.  Congestion Control Guidelines
  contents:
  - "3.1.  Congestion Control Guidelines\n   If an application or protocol chooses\
    \ not to use a congestion-\n   controlled transport protocol, it SHOULD control\
    \ the rate at which it\n   sends UDP datagrams to a destination host, in order\
    \ to fulfill the\n   requirements of [RFC2914].  It is important to stress that\
    \ an\n   application SHOULD perform congestion control over all UDP traffic it\n\
    \   sends to a destination, independently from how it generates this\n   traffic.\
    \  For example, an application that forks multiple worker\n   processes or otherwise\
    \ uses multiple sockets to generate UDP\n   datagrams SHOULD perform congestion\
    \ control over the aggregate\n   traffic.\n   Several approaches to perform congestion\
    \ control are discussed in the\n   remainder of this section.  This section describes\
    \ generic topics\n   with an intended emphasis on unicast and anycast [RFC1546]\
    \ usage.\n   Not all approaches discussed below are appropriate for all UDP-\n\
    \   transmitting applications.  Section 3.1.2 discusses congestion\n   control\
    \ options for applications that perform bulk transfers over\n   UDP.  Such applications\
    \ can employ schemes that sample the path over\n   several subsequent round-trips\
    \ during which data is exchanged to\n   determine a sending rate that the path\
    \ at its current load can\n   support.  Other applications only exchange a few\
    \ UDP datagrams with a\n   destination.  Section 3.1.3 discusses congestion control\
    \ options for\n   such \"low data-volume\" applications.  Because they typically\
    \ do not\n   transmit enough data to iteratively sample the path to determine\
    \ a\n   safe sending rate, they need to employ different kinds of congestion\n\
    \   control mechanisms.  Section 3.1.11 discusses congestion control\n   considerations\
    \ when UDP is used as a tunneling protocol.  Section 4\n   provides additional\
    \ recommendations for broadcast and multicast\n   usage.\n   It is important to\
    \ note that congestion control should not be viewed\n   as an add-on to a finished\
    \ application.  Many of the mechanisms\n   discussed in the guidelines below require\
    \ application support to\n   operate correctly.  Application designers need to\
    \ consider congestion\n   control throughout the design of their application,\
    \ similar to how\n   they consider security aspects throughout the design process.\n\
    \   In the past, the IETF has also investigated integrated congestion\n   control\
    \ mechanisms that act on the traffic aggregate between two\n   hosts, i.e., a\
    \ framework such as the Congestion Manager [RFC3124],\n   where active sessions\
    \ may share current congestion information in a\n   way that is independent of\
    \ the transport protocol.  Such mechanisms\n   have currently failed to see deployment,\
    \ but would otherwise simplify\n   the design of congestion control mechanisms\
    \ for UDP sessions, so that\n   they fulfill the requirements in [RFC2914].\n"
- title: 3.1.1.  Protocol Timer Guidelines
  contents:
  - "3.1.1.  Protocol Timer Guidelines\n   Understanding the latency between communicating\
    \ endpoints is usually\n   a crucial part of effective congestion control implementations\
    \ for\n   protocols and applications.  Latency estimation can be used in a\n \
    \  number of protocol functions, such as calculating a congestion-\n   controlled\
    \ transmission rate, triggering retransmission, and\n   detecting packet loss.\
    \  Additional protocol functions, for example,\n   determining an interval for\
    \ probing a path, determining an interval\n   between keep-alive messages, determining\
    \ an interval for measuring\n   the quality of experience, or determining if a\
    \ remote endpoint has\n   responded to a request to perform an action, typically\
    \ operate over\n   longer timescales than congestion control and therefore are\
    \ not\n   covered in this section.\n   The general recommendation in this document\
    \ is that applications\n   SHOULD leverage existing congestion control techniques\
    \ and the\n   latency estimators specified therein (see next subsection).  The\n\
    \   following guidelines are provided for applications that need to\n   design\
    \ their own latency estimation mechanisms.\n   The guidelines are framed in terms\
    \ of \"latency\" and not \"round-trip\n   time\" because some situations require\
    \ characterizing only the\n   network-based latency (e.g., TCP-Friendly Rate Control\
    \ (TFRC)\n   [RFC5348]), while other cases necessitate inclusion of the time\n\
    \   required by the remote endpoint to provide feedback (e.g., developing\n  \
    \ an understanding of when to retransmit a message).\n   The latency between endpoints\
    \ is generally a dynamic property.\n   Therefore, estimates SHOULD represent some\
    \ sort of averaging of\n   multiple recent measurement samples to account for\
    \ variance.\n   Leveraging an Exponentially Weighted Moving Average (EWMA) has\
    \ proven\n   useful for this purpose (e.g., in TCP [RFC6298] and TFRC [RFC5348]).\n\
    \   Independent latency estimates SHOULD be maintained for each\n   destination\
    \ with which an endpoint communicates.\n   Latency samples MUST NOT be derived\
    \ from ambiguous transactions.  The\n   canonical example is in a protocol that\
    \ retransmits data, but\n   subsequently cannot determine which copy is being\
    \ acknowledged.  This\n   ambiguity makes correct computation of the latency problematic.\
    \  See\n   the discussion of Karn's algorithm in [RFC6298].  This requirement\n\
    \   ensures a sender establishes a sound estimate of the latency without\n   relying\
    \ on misleading measurements.\n   When a latency estimate is used to arm a timer\
    \ that provides loss\n   detection -- with or without retransmission -- expiry\
    \ of the timer\n   MUST be interpreted as an indication of congestion in the network,\n\
    \   causing the sending rate to be adapted to a safe conservative rate\n   (e.g.,\
    \ TCP collapses the congestion window to one segment [RFC5681]).\n   Some applications\
    \ require an initial latency estimate before the\n   latency between endpoints\
    \ can be empirically sampled.  For instance,\n   when arming a retransmission\
    \ timer, an initial value is needed to\n   protect the messages sent before the\
    \ endpoints sample the latency.\n   This initial latency estimate SHOULD generally\
    \ be as conservative\n   (large) as possible for the given application.  For instance,\
    \ in the\n   absence of any knowledge about the latency of a path, TCP requires\n\
    \   the initial Retransmission Timeout (RTO) to be set to no less than 1\n   second\
    \ [RFC6298].  UDP applications SHOULD similarly use an initial\n   latency estimate\
    \ of 1 second.  Values shorter than 1 second can be\n   problematic (see the data\
    \ analysis in the appendix of [RFC6298]).\n"
- title: 3.1.2.  Bulk-Transfer Applications
  contents:
  - "3.1.2.  Bulk-Transfer Applications\n   Applications that perform bulk transmission\
    \ of data to a peer over\n   UDP, i.e., applications that exchange more than a\
    \ few UDP datagrams\n   per RTT, SHOULD implement TFRC [RFC5348], window-based\
    \ TCP-like\n   congestion control, or otherwise ensure that the application complies\n\
    \   with the congestion control principles.\n   TFRC has been designed to provide\
    \ both congestion control and\n   fairness in a way that is compatible with the\
    \ IETF's other transport\n   protocols.  If an application implements TFRC, it\
    \ need not follow the\n   remaining guidelines in Section 3.1.2, because TFRC\
    \ already addresses\n   them, but it SHOULD still follow the remaining guidelines\
    \ in the\n   subsequent subsections of Section 3.\n   Bulk-transfer applications\
    \ that choose not to implement TFRC or TCP-\n   like windowing SHOULD implement\
    \ a congestion control scheme that\n   results in bandwidth (capacity) use that\
    \ competes fairly with TCP\n   within an order of magnitude.\n   Section 2 of\
    \ [RFC3551] suggests that applications SHOULD monitor the\n   packet-loss rate\
    \ to ensure that it is within acceptable parameters.\n   Packet loss is considered\
    \ acceptable if a TCP flow across the same\n   network path under the same network\
    \ conditions would achieve an\n   average throughput, measured on a reasonable\
    \ timescale, that is not\n   less than that of the UDP flow.  The comparison to\
    \ TCP cannot be\n   specified exactly, but is intended as an \"order-of-magnitude\"\
    \n   comparison in timescale and throughput.  The recommendations for\n   managing\
    \ timers specified in Section 3.1.1 also apply.\n   Finally, some bulk-transfer\
    \ applications may choose not to implement\n   any congestion control mechanism\
    \ and instead rely on transmitting\n   across reserved path capacity (see Section\
    \ 3.1.9).  This might be an\n   acceptable choice for a subset of restricted networking\
    \ environments,\n   but is by no means a safe practice for operation over the\
    \ wider\n   Internet.  When the UDP traffic of such applications leaks out into\n\
    \   unprovisioned Internet paths, it can significantly degrade the\n   performance\
    \ of other traffic sharing the path and even result in\n   congestion collapse.\
    \  Applications that support an uncontrolled or\n   unadaptive transmission behavior\
    \ SHOULD NOT do so by default and\n   SHOULD instead require users to explicitly\
    \ enable this mode of\n   operation, and they SHOULD verify that sufficient path\
    \ capacity has\n   been reserved for them.\n"
- title: 3.1.3.  Low Data-Volume Applications
  contents:
  - "3.1.3.  Low Data-Volume Applications\n   When applications that at any time exchange\
    \ only a few UDP datagrams\n   with a destination implement TFRC or one of the\
    \ other congestion\n   control schemes in Section 3.1.2, the network sees little\
    \ benefit,\n   because those mechanisms perform congestion control in a way that\
    \ is\n   only effective for longer transmissions.\n   Applications that at any\
    \ time exchange only a few UDP datagrams with\n   a destination SHOULD still control\
    \ their transmission behavior by not\n   sending on average more than one UDP\
    \ datagram per RTT to a\n   destination.  Similar to the recommendation in [RFC1536],\
    \ an\n   application SHOULD maintain an estimate of the RTT for any\n   destination\
    \ with which it communicates using the methods specified in\n   Section 3.1.1.\n\
    \   Some applications cannot maintain a reliable RTT estimate for a\n   destination.\
    \  These applications do not need to or are unable to use\n   protocol timers\
    \ to measure the RTT (Section 3.1.1).  Two cases can be\n   identified:\n   1.\
    \  The first case is that of applications that exchange too few UDP\n       datagrams\
    \ with a peer to establish a statistically accurate RTT\n       estimate but that\
    \ can monitor the reliability of transmission\n       (Section 3.3).  Such applications\
    \ MAY use a predetermined\n       transmission interval that is exponentially\
    \ backed off when\n       packets are deemed lost.  TCP specifies an initial value\
    \ of 1\n       second [RFC6298], which is also RECOMMENDED as an initial value\n\
    \       for UDP applications.  Some low data-volume applications, e.g.,\n    \
    \   SIP [RFC3261] and General Internet Signaling Transport (GIST)\n       [RFC5971]\
    \ use an interval of 500 ms, and shorter values are\n       likely problematic\
    \ in many cases.  As in the previous case, note\n       that the initial timeout\
    \ is not the maximum possible timeout, see\n       Section 3.1.1.\n   2.  A second\
    \ case of applications cannot maintain an RTT estimate for\n       a destination,\
    \ because the destination does not send return\n       traffic.  Such applications\
    \ SHOULD NOT send more than one UDP\n       datagram every 3 seconds and SHOULD\
    \ use an even less aggressive\n       rate when possible.  Shorter values are\
    \ likely problematic in\n       many cases.  Note that the sending rate in this\
    \ case must be more\n       conservative than in the previous cases, because the\
    \ lack of\n       return traffic prevents the detection of packet loss, i.e.,\n\
    \       congestion, and the application therefore cannot perform\n       exponential\
    \ back off to reduce load.\n"
- title: 3.1.4.  Applications Supporting Bidirectional Communications
  contents:
  - "3.1.4.  Applications Supporting Bidirectional Communications\n   Applications\
    \ that communicate bidirectionally SHOULD employ\n   congestion control for both\
    \ directions of the communication.  For\n   example, for a client-server, request-response-style\
    \ application,\n   clients SHOULD congestion-control their request transmission\
    \ to a\n   server, and the server SHOULD congestion-control its responses to the\n\
    \   clients.  Congestion in the forward and reverse directions is\n   uncorrelated,\
    \ and an application SHOULD either independently detect\n   and respond to congestion\
    \ along both directions or limit new and\n   retransmitted requests based on acknowledged\
    \ responses across the\n   entire round-trip path.\n"
- title: 3.1.5.  Implications of RTT and Loss Measurements on Congestion Control
  contents:
  - "3.1.5.  Implications of RTT and Loss Measurements on Congestion Control\n   Transports\
    \ such as TCP, SCTP, and DCCP provide timely detection of\n   congestion that\
    \ results in an immediate reduction of their maximum\n   sending rate when congestion\
    \ is experienced.  This reaction is\n   typically completed 1-2 RTTs after loss/congestion\
    \ is encountered.\n   Applications using UDP SHOULD implement a congestion control\
    \ scheme\n   that provides a prompt reaction to signals indicating congestion\n\
    \   (e.g., by reducing the rate within the next RTT following a\n   congestion\
    \ signal).\n   The operation of a UDP congestion control algorithm can be very\n\
    \   different from the way TCP operates.  This includes congestion\n   controls\
    \ that respond on timescales that fit applications that cannot\n   usefully work\
    \ within the \"change rate every RTT\" model of TCP.\n   Applications that experience\
    \ a low or varying RTT are particularly\n   vulnerable to sampling errors (e.g.,\
    \ due to measurement noise or\n   timer accuracy).  This suggests the need to\
    \ average loss/congestion\n   and RTT measurements over a longer interval; however,\
    \ this also can\n   contribute additional delay in detecting congestion.  Some\n\
    \   applications may not react by reducing their sending rate immediately\n  \
    \ for various reasons, including the following: RTT and loss\n   measurements\
    \ are only made periodically (e.g., using RTCP),\n   additional time is required\
    \ to filter information, or the application\n   is only able to change its sending\
    \ rate at predetermined interval\n   (e.g., some video codecs).\n   When designing\
    \ a congestion control algorithm, the designer therefore\n   needs to consider\
    \ the total time taken to reduce the load following a\n   lack of feedback or\
    \ a congestion event.  An application where the\n   most recent RTT measurement\
    \ is smaller than the actual RTT or the\n   measured loss rate is smaller than\
    \ the current rate, can result in\n   over estimating the available capacity.\
    \  Such over-estimation can\n   result in a sending rate that creates congestion\
    \ to the application\n   or other flows sharing the path capacity, and can contribute\
    \ to\n   congestion collapse -- both of these need to be avoided.\n   A congestion\
    \ control designed for UDP SHOULD respond as quickly as\n   possible when it experiences\
    \ congestion, and it SHOULD take into\n   account both the loss rate and the response\
    \ time when choosing a new\n   rate.  The implemented congestion control scheme\
    \ SHOULD result in\n   bandwidth (capacity) use that is comparable to that of\
    \ TCP within an\n   order of magnitude, so that it does not starve other flows\
    \ sharing a\n   common bottleneck.\n"
- title: 3.1.6.  Burst Mitigation and Pacing
  contents:
  - "3.1.6.  Burst Mitigation and Pacing\n   UDP applications SHOULD provide mechanisms\
    \ to regulate the bursts of\n   transmission that the application may send to\
    \ the network.  Many TCP\n   and SCTP implementations provide mechanisms that\
    \ prevent a sender\n   from generating long bursts at line-rate, since these are\
    \ known to\n   induce early loss to applications sharing a common network\n  \
    \ bottleneck.  The use of pacing with TCP [ALLMAN] has also been shown\n   to\
    \ improve the coexistence of TCP flows with other flows.  The need\n   to avoid\
    \ excessive transmission bursts is also noted in\n   specifications for applications\
    \ (e.g., [RFC7143]).\n   Even low data-volume UDP flows may benefit from packet\
    \ pacing, e.g.,\n   an application that sends three copies of a packet to improve\n\
    \   robustness to loss is RECOMMENDED to pace out those three packets\n   over\
    \ several RTTs, to reduce the probability that all three packets\n   will be lost\
    \ due to the same congestion event (or other event, such\n   as burst corruption).\n"
- title: 3.1.7.  Explicit Congestion Notification
  contents:
  - "3.1.7.  Explicit Congestion Notification\n   Internet applications can use Explicit\
    \ Congestion Notification (ECN)\n   [RFC3168] to gain benefits for the services\
    \ they support [RFC8087].\n   Internet transports, such as TCP, provide a set\
    \ of mechanisms that\n   are needed to utilize ECN.  ECN operates by setting an\
    \ ECN-capable\n   codepoint (ECT(0) or ECT(1)) in the IP header of packets that\
    \ are\n   sent.  This indicates to ECN-capable network devices (routers and\n\
    \   other devices) that they may mark (set the congestion experienced,\n   Congestion\
    \ Experience (CE) codepoint) rather than drop the IP packet\n   as a signal of\
    \ incipient congestion.\n   UDP applications can also benefit from enabling ECN,\
    \ providing that\n   the API supports ECN and that they implement the required\
    \ protocol\n   mechanisms to support ECN.\n   The set of mechanisms required for\
    \ an application to use ECN over UDP\n   are:\n   o  A sender MUST provide a method\
    \ to determine (e.g., negotiate) that\n      the corresponding application is\
    \ able to provide ECN feedback\n      using a compatible ECN method.\n   o  A\
    \ receiver that enables the use of ECN for a UDP port MUST check\n      the ECN\
    \ field at the receiver for each UDP datagram that it\n      receives on this\
    \ port.\n   o  The receiving application needs to provide feedback of congestion\n\
    \      information to the sending application.  This MUST report the\n      presence\
    \ of datagrams received with a CE-mark by providing a\n      mechanism to feed\
    \ this congestion information back to the sending\n      application.  The feedback\
    \ MAY also report the presence of ECT(1)\n      and ECT(0)/Not-ECT packets [RFC7560].\
    \  ([RFC3168] and [RFC7560]\n      specify methods for TCP.)\n   o  An application\
    \ sending ECN-capable datagrams MUST provide an\n      appropriate congestion\
    \ reaction when it receives feedback\n      indicating that congestion has been\
    \ experienced.  This ought to\n      result in reduction of the sending rate by\
    \ the UDP congestion\n      control method (see Section 3.1) that is not less\
    \ than the\n      reaction of TCP under equivalent conditions.\n   o  A sender\
    \ SHOULD detect network paths that do not support the ECN\n      field correctly.\
    \  When detected, they need to either\n      conservatively react to congestion\
    \ or even fall back to not using\n      ECN [RFC8087].  This method needs to be\
    \ robust to changes within\n      the network path that may occur over the lifetime\
    \ of a session.\n   o  A sender is encouraged to provide a mechanism to detect\
    \ and react\n      appropriately to misbehaving receivers that fail to report\n\
    \      CE-marked packets [RFC8087].\n   [RFC6679] provides guidance and an example\
    \ of this support, by\n   describing a method to allow ECN to be used for UDP-based\n\
    \   applications using the Real-Time Protocol (RTP).  Applications that\n   cannot\
    \ provide this set of mechanisms, but wish to gain the benefits\n   of using ECN,\
    \ are encouraged to use a transport protocol that already\n   supports ECN (such\
    \ as TCP).\n"
- title: 3.1.8.  Differentiated Services Model
  contents:
  - "3.1.8.  Differentiated Services Model\n   An application using UDP can use the\
    \ differentiated services\n   (DiffServ) Quality of Service (QoS) framework. \
    \ To enable\n   differentiated services processing, a UDP sender sets the\n  \
    \ Differentiated Services Code Point (DSCP) field [RFC2475] in packets\n   sent\
    \ to the network.  Normally, a UDP source/destination port pair\n   will set a\
    \ single DSCP value for all packets belonging to a flow, but\n   multiple DSCPs\
    \ can be used as described later in this section.  A\n   DSCP may be chosen from\
    \ a small set of fixed values (the class\n   selector code points), or from a\
    \ set of recommended values defined in\n   the Per Hop Behavior (PHB) specifications,\
    \ or from values that have\n   purely local meanings to a specific network that\
    \ supports DiffServ.\n   In general, packets may be forwarded across multiple\
    \ networks between\n   source and destination.\n   In setting a non-default DSCP\
    \ value, an application must be aware\n   that DSCP markings may be changed or\
    \ removed between the traffic\n   source and destination.  This has implications\
    \ on the design of\n   applications that use DSCPs.  Specifically, applications\
    \ SHOULD be\n   designed not to rely on implementation of a specific network\n\
    \   treatment; they need instead to implement congestion control methods\n   to\
    \ determine if their current sending rate is inducing congestion in\n   the network.\n\
    \   [RFC7657] describes the implications of using DSCPs and provides\n   recommendations\
    \ on using multiple DSCPs within a single network five-\n   tuple (source and\
    \ destination addresses, source and destination\n   ports, and the transport protocol\
    \ used, in this case, UDP or\n   UDP-Lite), and particularly the expected impact\
    \ on transport protocol\n   interactions, with congestion control or reliability\
    \ functionality\n   (e.g., retransmission, reordering).  Use of multiple DSCPs\
    \ can result\n   in reordering by increasing the set of network forwarding resources\n\
    \   used by a sender.  It can also increase exposure to resource\n   depletion\
    \ or failure.\n"
- title: 3.1.9.  QoS, Pre-Provisioned, or Reserved Capacity
  contents:
  - "3.1.9.  QoS, Pre-Provisioned, or Reserved Capacity\n   The IETF usually specifies\
    \ protocols for use within the Best Effort\n   General Internet.  Sometimes it\
    \ is relevant to specify protocols with\n   a different applicability.  An application\
    \ using UDP can use the\n   integrated services QoS framework.  This framework\
    \ is usually made\n   available within controlled environments (e.g., within a\
    \ single\n   administrative domain or bilaterally agreed connection between\n\
    \   domains).  Applications intended for the Internet SHOULD NOT assume\n   that\
    \ QoS mechanisms are supported by the networks they use, and\n   therefore need\
    \ to provide congestion control, error recovery, etc.,\n   in case the actual\
    \ network path does not provide provisioned service.\n   Some UDP applications\
    \ are only expected to be deployed over network\n   paths that use pre-provisioned\
    \ capacity or capacity reserved using\n   dynamic provisioning, e.g., through\
    \ the Resource Reservation Protocol\n   (RSVP).  Multicast applications are also\
    \ used with pre-provisioned\n   capacity (e.g., IPTV deployments within access\
    \ networks).  These\n   applications MAY choose not to implement any congestion\
    \ control\n   mechanism and instead rely on transmitting only on paths where the\n\
    \   capacity is provisioned and reserved for this use.  This might be an\n   acceptable\
    \ choice for a subset of restricted networking environments,\n   but is by no\
    \ means a safe practice for operation over the wider\n   Internet.  Applications\
    \ that choose this option SHOULD carefully and\n   in detail describe the provisioning\
    \ and management procedures that\n   result in the desired containment.\n   Applications\
    \ that support an uncontrolled or unadaptive transmission\n   behavior SHOULD\
    \ NOT do so by default and SHOULD instead require users\n   to explicitly enable\
    \ this mode of operation.\n   Applications designed for use within a controlled\
    \ environment (see\n   Section 3.6) may be able to exploit network management\
    \ functions to\n   detect whether they are causing congestion, and react accordingly.\n\
    \   If the traffic of such applications leaks out into unprovisioned\n   Internet\
    \ paths, it can significantly degrade the performance of other\n   traffic sharing\
    \ the path and even result in congestion collapse.\n   Protocols designed for\
    \ such networks SHOULD provide mechanisms at the\n   network edge to prevent leakage\
    \ of traffic into unprovisioned\n   Internet paths (e.g., [RFC7510]).  To protect\
    \ other applications\n   sharing the same path, applications SHOULD also deploy\
    \ an appropriate\n   circuit breaker, as described in Section 3.1.10.\n   An IETF\
    \ specification targeting a controlled environment is expected\n   to provide\
    \ an applicability statement that restricts the application\n   to the controlled\
    \ environment (see Section 3.6).\n"
- title: 3.1.10.  Circuit Breaker Mechanisms
  contents:
  - "3.1.10.  Circuit Breaker Mechanisms\n   A transport circuit breaker is an automatic\
    \ mechanism that is used to\n   estimate the congestion caused by a flow, and\
    \ to terminate (or\n   significantly reduce the rate of) the flow when excessive\
    \ congestion\n   is detected [RFC8084].  This is a safety measure to prevent\n\
    \   congestion collapse (starvation of resources available to other\n   flows),\
    \ essential for an Internet that is heterogeneous and for\n   traffic that is\
    \ hard to predict in advance.\n   A circuit breaker is intended as a protection\
    \ mechanism of last\n   resort.  Under normal circumstances, a circuit breaker\
    \ should not be\n   triggered; it is designed to protect things when there is\
    \ severe\n   overload.  The goal is usually to limit the maximum transmission\
    \ rate\n   that reflects the available capacity of a network path.  Circuit\n\
    \   breakers can operate on individual UDP flows or traffic aggregates,\n   e.g.,\
    \ traffic sent using a network tunnel.\n   [RFC8084] provides guidance and examples\
    \ on the use of circuit\n   breakers.  The use of a circuit breaker in RTP is\
    \ specified in\n   [RFC8083].\n   Applications used in the general Internet SHOULD\
    \ implement a\n   transport circuit breaker if they do not implement congestion\
    \ control\n   or operate a low data-volume service (see Section 3.6).  All\n \
    \  applications MAY implement a transport circuit breaker [RFC8084] and\n   are\
    \ encouraged to consider implementing at least a slow-acting\n   transport circuit\
    \ breaker to provide a protection of last resort for\n   their network traffic.\n"
- title: 3.1.11.  UDP Tunnels
  contents:
  - "3.1.11.  UDP Tunnels\n   One increasingly popular use of UDP is as a tunneling\
    \ protocol\n   [INT-TUNNELS], where a tunnel endpoint encapsulates the packets\
    \ of\n   another protocol inside UDP datagrams and transmits them to another\n\
    \   tunnel endpoint, which decapsulates the UDP datagrams and forwards\n   the\
    \ original packets contained in the payload.  One example of such a\n   protocol\
    \ is Teredo [RFC4380].  Tunnels establish virtual links that\n   appear to directly\
    \ connect locations that are distant in the physical\n   Internet topology and\
    \ can be used to create virtual (private)\n   networks.  Using UDP as a tunneling\
    \ protocol is attractive when the\n   payload protocol is not supported by middleboxes\
    \ that may exist along\n   the path, because many middleboxes support transmission\
    \ using UDP.\n   Well-implemented tunnels are generally invisible to the endpoints\n\
    \   that happen to transmit over a path that includes tunneled links.  On\n  \
    \ the other hand, to the routers along the path of a UDP tunnel, i.e.,\n   the\
    \ routers between the two tunnel endpoints, the traffic that a UDP\n   tunnel\
    \ generates is a regular UDP flow, and the encapsulator and\n   decapsulator appear\
    \ as regular UDP-sending and UDP-receiving\n   applications.  Because other flows\
    \ can share the path with one or\n   more UDP tunnels, congestion control needs\
    \ to be considered.\n   Two factors determine whether a UDP tunnel needs to employ\
    \ specific\n   congestion control mechanisms: first, whether the payload traffic\
    \ is\n   IP-based; and second, whether the tunneling scheme generates UDP\n  \
    \ traffic at a volume that corresponds to the volume of payload traffic\n   carried\
    \ within the tunnel.\n   IP-based unicast traffic is generally assumed to be congestion\n\
    \   controlled, i.e., it is assumed that the transport protocols\n   generating\
    \ IP-based unicast traffic at the sender already employ\n   mechanisms that are\
    \ sufficient to address congestion on the path.\n   Consequently, a tunnel carrying\
    \ IP-based unicast traffic should\n   already interact appropriately with other\
    \ traffic sharing the path,\n   and specific congestion control mechanisms for\
    \ the tunnel are not\n   necessary.\n   However, if the IP traffic in the tunnel\
    \ is known not to be\n   congestion controlled, additional measures are RECOMMENDED\
    \ to limit\n   the impact of the tunneled traffic on other traffic sharing the\
    \ path.\n   For the specific case of a tunnel that carries IP multicast traffic,\n\
    \   see Section 4.1.\n   The following guidelines define these possible cases\
    \ in more detail:\n   1.  A tunnel generates UDP traffic at a volume that corresponds\
    \ to\n       the volume of payload traffic, and the payload traffic is IP\n  \
    \     based and congestion controlled.\n       This is arguably the most common\
    \ case for Internet tunnels.  In\n       this case, the UDP tunnel SHOULD NOT\
    \ employ its own congestion\n       control mechanism, because congestion losses\
    \ of tunneled traffic\n       will already trigger an appropriate congestion response\
    \ at the\n       original senders of the tunneled traffic.  A circuit breaker\n\
    \       mechanism may provide benefit by controlling the envelope of the\n   \
    \    aggregated traffic.\n       Note that this guideline is built on the assumption\
    \ that most\n       IP-based communication is congestion controlled.  If a UDP\
    \ tunnel\n       is used for IP-based traffic that is known to not be congestion\n\
    \       controlled, the next set of guidelines applies.\n   2.  A tunnel generates\
    \ UDP traffic at a volume that corresponds to\n       the volume of payload traffic,\
    \ and the payload traffic is not\n       known to be IP based, or is known to\
    \ be IP based but not\n       congestion controlled.\n       This can be the case,\
    \ for example, when some link-layer protocols\n       are encapsulated within\
    \ UDP (but not all link-layer protocols;\n       some are congestion controlled).\
    \  Because it is not known that\n       congestion losses of tunneled non-IP traffic\
    \ will trigger an\n       appropriate congestion response at the senders, the\
    \ UDP tunnel\n       SHOULD employ an appropriate congestion control mechanism\
    \ or\n       circuit breaker mechanism designed for the traffic it carries.\n\
    \       Because tunnels are usually bulk-transfer applications as far as\n   \
    \    the intermediate routers are concerned, the guidelines in\n       Section\
    \ 3.1.2 apply.\n   3.  A tunnel generates UDP traffic at a volume that does not\n\
    \       correspond to the volume of payload traffic, independent of\n       whether\
    \ the payload traffic is IP based or congestion controlled.\n       Examples of\
    \ this class include UDP tunnels that send at a\n       constant rate, increase\
    \ their transmission rates under loss, for\n       example, due to increasing\
    \ redundancy when Forward Error\n       Correction is used, or are otherwise unconstrained\
    \ in their\n       transmission behavior.  These specialized uses of UDP for\n\
    \       tunneling go beyond the scope of the general guidelines given in\n   \
    \    this document.  The implementer of such specialized tunnels\n       SHOULD\
    \ carefully consider congestion control in the design of\n       their tunneling\
    \ mechanism and SHOULD consider use of a circuit\n       breaker mechanism.\n\
    \   The type of encapsulated payload might be identified by a UDP port;\n   identified\
    \ by an Ethernet Type or IP protocol number.  A tunnel\n   SHOULD provide mechanisms\
    \ to restrict the types of flows that may be\n   carried by the tunnel.  For instance,\
    \ a UDP tunnel designed to carry\n   IP needs to filter out non-IP traffic at\
    \ the ingress.  This is\n   particularly important when a generic tunnel encapsulation\
    \ is used\n   (e.g., one that encapsulates using an EtherType value).  Such tunnels\n\
    \   SHOULD provide a mechanism to restrict the types of traffic that are\n   allowed\
    \ to be encapsulated for a given deployment (see\n   [INT-TUNNELS]).\n   Designing\
    \ a tunneling mechanism requires significantly more expertise\n   than needed\
    \ for many other UDP applications, because tunnels are\n   usually intended to\
    \ be transparent to the endpoints transmitting over\n   them, so they need to\
    \ correctly emulate the behavior of an IP link\n   [INT-TUNNELS], for example:\n\
    \   o  Requirements for tunnels that carry or encapsulate using ECN code\n   \
    \   points [RFC6040].\n   o  Usage of the IP DSCP field by tunnel endpoints [RFC2983].\n\
    \   o  Encapsulation considerations in the design of tunnels [ENCAP].\n   o  Usage\
    \ of ICMP messages [INT-TUNNELS].\n   o  Handling of fragmentation and packet\
    \ size for tunnels\n      [INT-TUNNELS].\n   o  Source port usage for tunnels\
    \ designed to support equal cost\n      multipath (ECMP) routing (see Section\
    \ 5.1.1).\n   o  Guidance on the need to protect headers [INT-TUNNELS] and the\
    \ use\n      of checksums for IPv6 tunnels (see Section 3.4.1).\n   o  Support\
    \ for operations and maintenance [INT-TUNNELS].\n   At the same time, the tunneled\
    \ traffic is application traffic like\n   any other from the perspective of the\
    \ networks the tunnel transmits\n   over.  This document only touches upon the\
    \ congestion control\n   considerations for implementing UDP tunnels; a discussion\
    \ of other\n   required tunneling behavior is out of scope.\n"
- title: 3.2.  Message Size Guidelines
  contents:
  - "3.2.  Message Size Guidelines\n   IP fragmentation lowers the efficiency and\
    \ reliability of Internet\n   communication.  The loss of a single fragment results\
    \ in the loss of\n   an entire fragmented packet, because even if all other fragments\
    \ are\n   received correctly, the original packet cannot be reassembled and\n\
    \   delivered.  This fundamental issue with fragmentation exists for both\n  \
    \ IPv4 and IPv6.\n   In addition, some network address translators (NATs) and\
    \ firewalls\n   drop IP fragments.  The network address translation performed\
    \ by a\n   NAT only operates on complete IP packets, and some firewall policies\n\
    \   also require inspection of complete IP packets.  Even with these\n   being\
    \ the case, some NATs and firewalls simply do not implement the\n   necessary\
    \ reassembly functionality; instead, they choose to drop all\n   fragments.  Finally,\
    \ [RFC4963] documents other issues specific to\n   IPv4 fragmentation.\n   Due\
    \ to these issues, an application SHOULD NOT send UDP datagrams\n   that result\
    \ in IP packets that exceed the Maximum Transmission Unit\n   (MTU) along the\
    \ path to the destination.  Consequently, an\n   application SHOULD either use\
    \ the path MTU information provided by\n   the IP layer or implement Path MTU\
    \ Discovery (PMTUD) itself [RFC1191]\n   [RFC1981] [RFC4821] to determine whether\
    \ the path to a destination\n   will support its desired message size without\
    \ fragmentation.\n   However, the ICMP messages that enable path MTU discovery\
    \ are being\n   increasingly filtered by middleboxes (including Firewalls) [RFC4890].\n\
    \   When the path includes a tunnel, some devices acting as a tunnel\n   ingress\
    \ discard ICMP messages that originate from network devices\n   over which the\
    \ tunnel passes, preventing these from reaching the UDP\n   endpoint.\n   Packetization\
    \ Layer Path MTU Discovery (PLPMTUD) [RFC4821] does not\n   rely upon network\
    \ support for ICMP messages and is therefore\n   considered more robust than standard\
    \ PMTUD.  It is not susceptible to\n   \"black holing\" of ICMP messages.  To\
    \ operate, PLPMTUD requires\n   changes to the way the transport is used: both\
    \ to transmit probe\n   packets and to account for the loss or success of these\
    \ probes.  This\n   not only updates the PMTU algorithm, it also impacts loss\
    \ recovery,\n   congestion control, etc.  These updated mechanisms can be implemented\n\
    \   within a connection-oriented transport (e.g., TCP, SCTP, DCCP), but\n   they\
    \ are not a part of UDP; this type of feedback is not typically\n   present for\
    \ unidirectional applications.\n   Therefore, PLPMTUD places additional design\
    \ requirements on a UDP\n   application that wishes to use this method.  This\
    \ is especially true\n   for UDP tunnels, because the overhead of sending probe\
    \ packets needs\n   to be accounted for and may require adding a congestion control\n\
    \   mechanism to the tunnel (see Section 3.1.11) as well as complicating\n   the\
    \ data path at a tunnel decapsulator.\n   Applications that do not follow the\
    \ recommendation to do PMTU/PLPMTUD\n   discovery SHOULD still avoid sending UDP\
    \ datagrams that would result\n   in IP packets that exceed the path MTU.  Because\
    \ the actual path MTU\n   is unknown, such applications SHOULD fall back to sending\
    \ messages\n   that are shorter than the default effective MTU for sending (EMTU_S\n\
    \   in [RFC1122]).  For IPv4, EMTU_S is the smaller of 576 bytes and the\n   first-hop\
    \ MTU [RFC1122].  For IPv6, EMTU_S is 1280 bytes [RFC2460].\n   The effective\
    \ PMTU for a directly connected destination (with no\n   routers on the path)\
    \ is the configured interface MTU, which could be\n   less than the maximum link\
    \ payload size.  Transmission of minimum-\n   sized UDP datagrams is inefficient\
    \ over paths that support a larger\n   PMTU, which is a second reason to implement\
    \ PMTU discovery.\n   To determine an appropriate UDP payload size, applications\
    \ MUST\n   subtract the size of the IP header (which includes any IPv4 optional\n\
    \   headers or IPv6 extension headers) as well as the length of the UDP\n   header\
    \ (8 bytes) from the PMTU size.  This size, known as the Maximum\n   Segment Size\
    \ (MSS), can be obtained from the TCP/IP stack [RFC1122].\n   Applications that\
    \ do not send messages that exceed the effective PMTU\n   of IPv4 or IPv6 need\
    \ not implement any of the above mechanisms.  Note\n   that the presence of tunnels\
    \ can cause an additional reduction of the\n   effective PMTU [INT-TUNNELS], so\
    \ implementing PMTU discovery may be\n   beneficial.\n   Applications that fragment\
    \ an application-layer message into multiple\n   UDP datagrams SHOULD perform\
    \ this fragmentation so that each datagram\n   can be received independently,\
    \ and be independently retransmitted in\n   the case where an application implements\
    \ its own reliability\n   mechanisms.\n"
- title: 3.3.  Reliability Guidelines
  contents:
  - "3.3.  Reliability Guidelines\n   Application designers are generally aware that\
    \ UDP does not provide\n   any reliability, e.g., it does not retransmit any lost\
    \ packets.\n   Often, this is a main reason to consider UDP as a transport protocol.\n\
    \   Applications that do require reliable message delivery MUST implement\n  \
    \ an appropriate mechanism themselves.\n   UDP also does not protect against datagram\
    \ duplication, i.e., an\n   application may receive multiple copies of the same\
    \ UDP datagram,\n   with some duplicates arriving potentially much later than\
    \ the first.\n   Application designers SHOULD handle such datagram duplication\n\
    \   gracefully, and they may consequently need to implement mechanisms to\n  \
    \ detect duplicates.  Even if UDP datagram reception triggers only\n   idempotent\
    \ operations, applications may want to suppress duplicate\n   datagrams to reduce\
    \ load.\n   Applications that require ordered delivery MUST reestablish datagram\n\
    \   ordering themselves.  The Internet can significantly delay some\n   packets\
    \ with respect to others, e.g., due to routing transients,\n   intermittent connectivity,\
    \ or mobility.  This can cause reordering,\n   where UDP datagrams arrive at the\
    \ receiver in an order different from\n   the transmission order.\n   Applications\
    \ that use multiple transport ports need to be robust to\n   reordering between\
    \ sessions.  Load-balancing techniques within the\n   network, such as Equal Cost\
    \ Multipath (ECMP) forwarding can also\n   result in a lack of ordering between\
    \ different transport sessions,\n   even between the same two network endpoints.\n\
    \   It is important to note that the time by which packets are reordered\n   or\
    \ after which duplicates can still arrive can be very large.  Even\n   more importantly,\
    \ there is no well-defined upper boundary here.\n   [RFC793] defines the maximum\
    \ delay a TCP segment should experience --\n   the Maximum Segment Lifetime (MSL)\
    \ -- as 2 minutes.  No other RFC\n   defines an MSL for other transport protocols\
    \ or IP itself.  The MSL\n   value defined for TCP is conservative enough that\
    \ it SHOULD be used\n   by other protocols, including UDP.  Therefore, applications\
    \ SHOULD be\n   robust to the reception of delayed or duplicate packets that are\n\
    \   received within this 2-minute interval.\n   Retransmission of lost packets\
    \ or messages is a common reliability\n   mechanism.  Such retransmissions can\
    \ increase network load in\n   response to congestion, worsening that congestion.\
    \  Any application\n   that uses retransmission is responsible for congestion\
    \ control of its\n   retransmissions (as well as the application's original traffic);\n\
    \   hence, it is subject to the Congestion Control guidelines in\n   Section 3.1.\
    \  Guidance on the appropriate measurement of RTT in\n   Section 3.1.1 also applies\
    \ for timers used for retransmission packet-\n   loss detection.\n   Instead of\
    \ implementing these relatively complex reliability\n   mechanisms by itself,\
    \ an application that requires reliable and\n   ordered message delivery SHOULD\
    \ whenever possible choose an IETF\n   standard transport protocol that provides\
    \ these features.\n"
- title: 3.4.  Checksum Guidelines
  contents:
  - "3.4.  Checksum Guidelines\n   The UDP header includes an optional, 16-bit one's\
    \ complement checksum\n   that provides an integrity check.  These checks are\
    \ not strong from a\n   coding or cryptographic perspective and are not designed\
    \ to detect\n   physical-layer errors or malicious modification of the datagram\n\
    \   [RFC3819].  Application developers SHOULD implement additional checks\n  \
    \ where data integrity is important, e.g., through a Cyclic Redundancy\n   Check\
    \ (CRC) or keyed or non-keyed cryptographic hash included with\n   the data to\
    \ verify the integrity of an entire object/file sent over\n   the UDP service.\n\
    \   The UDP checksum provides a statistical guarantee that the payload\n   was\
    \ not corrupted in transit.  It also allows the receiver to verify\n   that it\
    \ was the intended destination of the packet, because it covers\n   the IP addresses,\
    \ port numbers, and protocol number, and it verifies\n   that the packet is not\
    \ truncated or padded, because it covers the\n   size field.  Therefore, it protects\
    \ an application against receiving\n   corrupted payload data in place of, or\
    \ in addition to, the data that\n   was sent.  More description of the set of\
    \ checks performed using the\n   checksum field is provided in Section 3.1 of\
    \ [RFC6396].\n   Applications SHOULD enable UDP checksums [RFC1122].  For IPv4,\n\
    \   [RFC768] permits an option to disable their use, by setting a zero\n   checksum\
    \ value.  An application is permitted to optionally discard\n   UDP datagrams\
    \ with a zero checksum [RFC1122].\n   When UDP is used over IPv6, the UDP checksum\
    \ is relied upon to\n   protect both the IPv6 and UDP headers from corruption\
    \ (because IPv6\n   lacks a checksum) and MUST be used as specified in [RFC2460].\
    \  Under\n   specific conditions, a UDP application is allowed to use a zero UDP\n\
    \   zero-checksum mode with a tunnel protocol (see Section 3.4.1).\n   Applications\
    \ that choose to disable UDP checksums MUST NOT make\n   assumptions regarding\
    \ the correctness of received data and MUST\n   behave correctly when a UDP datagram\
    \ is received that was originally\n   sent to a different destination or is otherwise\
    \ corrupted.\n"
- title: 3.4.1.  IPv6 Zero UDP Checksum
  contents:
  - "3.4.1.  IPv6 Zero UDP Checksum\n   [RFC6935] defines a method that enables use\
    \ of a zero UDP zero-\n   checksum mode with a tunnel protocol, providing that\
    \ the method\n   satisfies the requirements in [RFC6936].  The application MUST\n\
    \   implement mechanisms and/or usage restrictions when enabling this\n   mode.\
    \  This includes defining the scope for usage and measures to\n   prevent leakage\
    \ of traffic to other UDP applications (see Appendix A\n   and Section 3.6). \
    \ These additional design requirements for using a\n   zero IPv6 UDP checksum\
    \ are not present for IPv4, since the IPv4\n   header validates information that\
    \ is not protected in an IPv6 packet.\n   Key requirements are:\n   o  Use of\
    \ the UDP checksum with IPv6 MUST be the default\n      configuration for all\
    \ implementations [RFC6935].  The receiving\n      endpoint MUST only allow the\
    \ use of UDP zero-checksum mode for\n      IPv6 on a UDP destination port that\
    \ is specifically enabled.\n   o  An application that supports a checksum different\
    \ than that in\n      [RFC2460] MUST comply with all implementation requirements\n\
    \      specified in Section 4 of [RFC6936] and with the usage\n      requirements\
    \ specified in Section 5 of [RFC6936].\n   o  A UDP application MUST check that\
    \ the source and destination IPv6\n      addresses are valid for any packets with\
    \ a UDP zero-checksum and\n      MUST discard any packet for which this check\
    \ fails.  To protect\n      from misdelivery, new encapsulation designs SHOULD\
    \ include an\n      integrity check at the transport layer that includes at least\
    \ the\n      IPv6 header, the UDP header and the shim header for the\n      encapsulation,\
    \ if any [RFC6936].\n   o  One way to help satisfy the requirements of [RFC6936]\
    \ may be to\n      limit the usage of such tunnels, e.g., to constrain traffic\
    \ to an\n      operator network, as discussed in Section 3.6.  The encapsulation\n\
    \      defined for MPLS in UDP [RFC7510] chooses this approach.\n   As in IPv4,\
    \ IPv6 applications that choose to disable UDP checksums\n   MUST NOT make assumptions\
    \ regarding the correctness of received data\n   and MUST behave correctly when\
    \ a UDP datagram is received that was\n   originally sent to a different destination\
    \ or is otherwise corrupted.\n   IPv6 datagrams with a zero UDP checksum will\
    \ not be passed by any\n   middlebox that validates the checksum based on [RFC2460]\
    \ or that\n   updates the UDP checksum field, such as NATs or firewalls.  Changing\n\
    \   this behavior would require such middleboxes to be updated to\n   correctly\
    \ handle datagrams with zero UDP checksums.  To ensure end-\n   to-end robustness,\
    \ applications that may be deployed in the general\n   Internet MUST provide a\
    \ mechanism to safely fall back to using a\n   checksum when a path change occurs\
    \ that redirects a zero UDP checksum\n   flow over a path that includes a middlebox\
    \ that discards IPv6\n   datagrams with a zero UDP checksum.\n"
- title: 3.4.2.  UDP-Lite
  contents:
  - "3.4.2.  UDP-Lite\n   A special class of applications can derive benefit from\
    \ having\n   partially damaged payloads delivered, rather than discarded, when\n\
    \   using paths that include error-prone links.  Such applications can\n   tolerate\
    \ payload corruption and MAY choose to use the Lightweight\n   User Datagram Protocol\
    \ (UDP-Lite) [RFC3828] variant of UDP instead of\n   basic UDP.  Applications\
    \ that choose to use UDP-Lite instead of UDP\n   should still follow the congestion\
    \ control and other guidelines\n   described for use with UDP in Section 3.\n\
    \   UDP-Lite changes the semantics of the UDP \"payload length\" field to\n  \
    \ that of a \"checksum coverage length\" field.  Otherwise, UDP-Lite is\n   semantically\
    \ identical to UDP.  The interface of UDP-Lite differs\n   from that of UDP by\
    \ the addition of a single (socket) option that\n   communicates the checksum\
    \ coverage length: at the sender, this\n   specifies the intended checksum coverage,\
    \ with the remaining\n   unprotected part of the payload called the \"error-insensitive\
    \ part\".\n   By default, the UDP-Lite checksum coverage extends across the entire\n\
    \   datagram.  If required, an application may dynamically modify this\n   length\
    \ value, e.g., to offer greater protection to some messages.\n   UDP-Lite always\
    \ verifies that a packet was delivered to the intended\n   destination, i.e.,\
    \ always verifies the header fields.  Errors in the\n   insensitive part will\
    \ not cause a UDP datagram to be discarded by the\n   destination.  Therefore,\
    \ applications using UDP-Lite MUST NOT make\n   assumptions regarding the correctness\
    \ of the data received in the\n   insensitive part of the UDP-Lite payload.\n\
    \   A UDP-Lite sender SHOULD select the minimum checksum coverage to\n   include\
    \ all sensitive payload information.  For example, applications\n   that use the\
    \ Real-Time Protocol (RTP) [RFC3550] will likely want to\n   protect the RTP header\
    \ against corruption.  Applications, where\n   appropriate, MUST also introduce\
    \ their own appropriate validity\n   checks for protocol information carried in\
    \ the insensitive part of\n   the UDP-Lite payload (e.g., internal CRCs).\n  \
    \ A UDP-Lite receiver MUST set a minimum coverage threshold for\n   incoming packets\
    \ that is not smaller than the smallest coverage used\n   by the sender [RFC3828].\
    \  The receiver SHOULD select a threshold that\n   is sufficiently large to block\
    \ packets with an inappropriately short\n   coverage field.  This may be a fixed\
    \ value, or it may be negotiated\n   by an application.  UDP-Lite does not provide\
    \ mechanisms to negotiate\n   the checksum coverage between the sender and receiver.\
    \  Therefore,\n   this needs to be performed by the application.\n   Applications\
    \ can still experience packet loss when using UDP-Lite.\n   The enhancements offered\
    \ by UDP-Lite rely upon a link being able to\n   intercept the UDP-Lite header\
    \ to correctly identify the partial\n   coverage required.  When tunnels and/or\
    \ encryption are used, this can\n   result in UDP-Lite datagrams being treated\
    \ the same as UDP datagrams,\n   i.e., result in packet loss.  Use of IP fragmentation\
    \ can also\n   prevent special treatment for UDP-Lite datagrams, and this is another\n\
    \   reason why applications SHOULD avoid IP fragmentation (Section 3.2).\n   UDP-Lite\
    \ is supported in some endpoint protocol stacks.  Current\n   support for middlebox\
    \ traversal using UDP-Lite is poor, because UDP-\n   Lite uses a different IPv4\
    \ protocol number or IPv6 \"next header\"\n   value than that used for UDP; therefore,\
    \ few middleboxes are\n   currently able to interpret UDP-Lite and take appropriate\
    \ actions\n   when forwarding the packet.  This makes UDP-Lite less suited for\n\
    \   applications needing general Internet support, until such time as\n   UDP-Lite\
    \ has achieved better support in middleboxes.\n"
- title: 3.5.  Middlebox Traversal Guidelines
  contents:
  - "3.5.  Middlebox Traversal Guidelines\n   NATs and firewalls are examples of intermediary\
    \ devices\n   (\"middleboxes\") that can exist along an end-to-end path.  A middlebox\n\
    \   typically performs a function that requires it to maintain per-flow\n   state.\
    \  For connection-oriented protocols, such as TCP, middleboxes\n   snoop and parse\
    \ the connection-management information, and create and\n   destroy per-flow state\
    \ accordingly.  For a connectionless protocol\n   such as UDP, this approach is\
    \ not possible.  Consequently,\n   middleboxes can create per-flow state when\
    \ they see a packet that --\n   according to some local criteria -- indicates\
    \ a new flow, and destroy\n   the state after some time during which no packets\
    \ belonging to the\n   same flow have arrived.\n   Depending on the specific function\
    \ that the middlebox performs, this\n   behavior can introduce a time-dependency\
    \ that restricts the kinds of\n   UDP traffic exchanges that will be successful\
    \ across the middlebox.\n   For example, NATs and firewalls typically define the\
    \ partial path on\n   one side of them to be interior to the domain they serve,\
    \ whereas the\n   partial path on their other side is defined to be exterior to\
    \ that\n   domain.  Per-flow state is typically created when the first packet\n\
    \   crosses from the interior to the exterior, and while the state is\n   present,\
    \ NATs and firewalls will forward return traffic.  Return\n   traffic that arrives\
    \ after the per-flow state has timed out is\n   dropped, as is other traffic that\
    \ arrives from the exterior.\n   Many applications that use UDP for communication\
    \ operate across\n   middleboxes without needing to employ additional mechanisms.\
    \  One\n   example is the Domain Name System (DNS), which has a strict request-\n\
    \   response communication pattern that typically completes within\n   seconds.\n\
    \   Other applications may experience communication failures when\n   middleboxes\
    \ destroy the per-flow state associated with an application\n   session during\
    \ periods when the application does not exchange any UDP\n   traffic.  Applications\
    \ SHOULD be able to gracefully handle such\n   communication failures and implement\
    \ mechanisms to re-establish\n   application-layer sessions and state.\n   For\
    \ some applications, such as media transmissions, this\n   re-synchronization\
    \ is highly undesirable, because it can cause user-\n   perceivable playback artifacts.\
    \  Such specialized applications MAY\n   send periodic keep-alive messages to\
    \ attempt to refresh middlebox\n   state (e.g., [RFC7675]).  It is important to\
    \ note that keep-alive\n   messages are not recommended for general use -- they\
    \ are unnecessary\n   for many applications and can consume significant amounts\
    \ of system\n   and network resources.\n   An application that needs to employ\
    \ keep-alive messages to deliver\n   useful service over UDP in the presence of\
    \ middleboxes SHOULD NOT\n   transmit them more frequently than once every 15\
    \ seconds and SHOULD\n   use longer intervals when possible.  No common timeout\
    \ has been\n   specified for per-flow UDP state for arbitrary middleboxes.  NATs\n\
    \   require a state timeout of 2 minutes or longer [RFC4787].  However,\n   empirical\
    \ evidence suggests that a significant fraction of currently\n   deployed middleboxes\
    \ unfortunately use shorter timeouts.  The timeout\n   of 15 seconds originates\
    \ with the Interactive Connectivity\n   Establishment (ICE) protocol [RFC5245].\
    \  When an application is\n   deployed in a controlled environment, the deployer\
    \ SHOULD investigate\n   whether the target environment allows applications to\
    \ use longer\n   intervals, or whether it offers mechanisms to explicitly control\n\
    \   middlebox state timeout durations, for example, using the Port\n   Control\
    \ Protocol (PCP) [RFC6887], Middlebox Communications (MIDCOM)\n   [RFC3303], Next\
    \ Steps in Signaling (NSIS) [RFC5973], or Universal\n   Plug and Play (UPnP) [UPnP].\
    \  It is RECOMMENDED that applications\n   apply slight random variations (\"\
    jitter\") to the timing of keep-alive\n   transmissions, to reduce the potential\
    \ for persistent synchronization\n   between keep-alive transmissions from different\
    \ hosts [RFC7675].\n   Sending keep-alive messages is not a substitute for implementing\
    \ a\n   mechanism to recover from broken sessions.  Like all UDP datagrams,\n\
    \   keep-alive messages can be delayed or dropped, causing middlebox\n   state\
    \ to time out.  In addition, the congestion control guidelines in\n   Section\
    \ 3.1 cover all UDP transmissions by an application, including\n   the transmission\
    \ of middlebox keep-alive messages.  Congestion\n   control may thus lead to delays\
    \ or temporary suspension of keep-alive\n   transmission.\n   Keep-alive messages\
    \ are NOT RECOMMENDED for general use.  They are\n   unnecessary for many applications\
    \ and may consume significant\n   resources.  For example, on battery-powered\
    \ devices, if an\n   application needs to maintain connectivity for long periods\
    \ with\n   little traffic, the frequency at which keep-alive messages are sent\n\
    \   can become the determining factor that governs power consumption,\n   depending\
    \ on the underlying network technology.\n   Because many middleboxes are designed\
    \ to require keep-alive messages\n   for TCP connections at a frequency that is\
    \ much lower than that\n   needed for UDP, this difference alone can often be\
    \ sufficient to\n   prefer TCP over UDP for these deployments.  On the other hand,\
    \ there\n   is anecdotal evidence that suggests that direct communication through\n\
    \   middleboxes, e.g., by using ICE [RFC5245], does succeed less often\n   with\
    \ TCP than with UDP.  The trade-offs between different transport\n   protocols\
    \ -- especially when it comes to middlebox traversal --\n   deserve careful analysis.\n\
    \   UDP applications that could be deployed in the Internet need to be\n   designed\
    \ understanding that there are many variants of middlebox\n   behavior, and although\
    \ UDP is connectionless, middleboxes often\n   maintain state for each UDP flow.\
    \  Using multiple UDP flows can\n   consume available state space and also can\
    \ lead to changes in the way\n   the middlebox handles subsequent packets (either\
    \ to protect its\n   internal resources, or to prevent perceived misuse).  The\
    \ probability\n   of path failure can increase when applications use multiple\
    \ UDP flows\n   in parallel (see Section 5.1.2 for recommendations on usage of\n\
    \   multiple ports).\n"
- title: 3.6.  Limited Applicability and Controlled Environments
  contents:
  - "3.6.  Limited Applicability and Controlled Environments\n   Two different types\
    \ of applicability have been identified for the\n   specification of IETF applications\
    \ that utilize UDP:\n   General Internet.  By default, IETF specifications target\
    \ deployment\n      on the general Internet.  Experience has shown that successful\n\
    \      protocols developed in one specific context or for a particular\n     \
    \ application tend to become used in a wider range of contexts.  For\n      example,\
    \ a protocol with an initial deployment within a local area\n      network may\
    \ subsequently be used over a virtual network that\n      traverses the Internet,\
    \ or in the Internet in general.\n      Applications designed for general Internet\
    \ use may experience a\n      range of network device behaviors and, in particular,\
    \ should\n      consider whether applications need to operate over paths that\
    \ may\n      include middleboxes.\n   Controlled Environment.  A protocol/encapsulation/tunnel\
    \ could be\n      designed to be used only within a controlled environment.  For\n\
    \      example, an application designed for use by a network operator\n      might\
    \ only be deployed within the network of that single network\n      operator or\
    \ on networks of an adjacent set of cooperating network\n      operators.  The\
    \ application traffic may then be managed to avoid\n      congestion, rather than\
    \ relying on built-in mechanisms, which are\n      required when operating over\
    \ the general Internet.  Applications\n      that target a limited applicability\
    \ use case may be able to take\n      advantage of specific hardware (e.g., carrier-grade\
    \ equipment) or\n      underlying protocol features of the subnetwork over which\
    \ they are\n      used.\n   Specifications addressing a limited applicability\
    \ use case or a\n   controlled environment SHOULD identify how, in their restricted\n\
    \   deployment, a level of safety is provided that is equivalent to that\n   of\
    \ a protocol designed for operation over the general Internet (e.g.,\n   a design\
    \ based on extensive experience with deployments of particular\n   methods that\
    \ provide features that cannot be expected in general\n   Internet equipment and\
    \ the robustness of the design of MPLS to\n   corruption of headers both helped\
    \ justify use of an alternate UDP\n   integrity check [RFC7510]).\n   An IETF\
    \ specification targeting a controlled environment is expected\n   to provide\
    \ an applicability statement that restricts the application\n   traffic to the\
    \ controlled environment, and it would be expected to\n   describe how methods\
    \ can be provided to discourage or prevent escape\n   of corrupted packets from\
    \ the environment (for example, Section 5 of\n   [RFC7510]).\n"
- title: 4.  Multicast UDP Usage Guidelines
  contents:
  - "4.  Multicast UDP Usage Guidelines\n   This section complements Section 3 by\
    \ providing additional guidelines\n   that are applicable to multicast and broadcast\
    \ usage of UDP.\n   Multicast and broadcast transmission [RFC1112] usually employ\
    \ the UDP\n   transport protocol, although they may be used with other transport\n\
    \   protocols (e.g., UDP-Lite).\n   There are currently two models of multicast\
    \ delivery: the Any-Source\n   Multicast (ASM) model as defined in [RFC1112] and\
    \ the Source-Specific\n   Multicast (SSM) model as defined in [RFC4607].  ASM\
    \ group members\n   will receive all data sent to the group by any source, while\
    \ SSM\n   constrains the distribution tree to only one single source.\n   Specialized\
    \ classes of applications also use UDP for IP multicast or\n   broadcast [RFC919].\
    \  The design of such specialized applications\n   requires expertise that goes\
    \ beyond simple, unicast-specific\n   guidelines, since these senders may transmit\
    \ to potentially very many\n   receivers across potentially very heterogeneous\
    \ paths at the same\n   time, which significantly complicates congestion control,\
    \ flow\n   control, and reliability mechanisms.\n   This section provides guidance\
    \ on multicast and broadcast UDP usage.\n   Use of broadcast by an application\
    \ is normally constrained by routers\n   to the local subnetwork.  However, use\
    \ of tunneling techniques and\n   proxies can and does result in some broadcast\
    \ traffic traversing\n   Internet paths.  These guidelines therefore also apply\
    \ to broadcast\n   traffic.\n   The IETF has defined a reliable multicast framework\
    \ [RFC3048] and\n   several building blocks to aid the designers of multicast\n\
    \   applications, such as [RFC3738] or [RFC4654].\n   Senders to anycast destinations\
    \ must be aware that successive\n   messages sent to the same anycast IP address\
    \ may be delivered to\n   different anycast nodes, i.e., arrive at different locations\
    \ in the\n   topology.\n   Most UDP tunnels that carry IP multicast traffic use\
    \ a tunnel\n   encapsulation with a unicast destination address, such as Automatic\n\
    \   Multicast Tunneling [RFC7450].  These MUST follow the same\n   requirements\
    \ as a tunnel carrying unicast data (see Section 3.1.11).\n   There are deployment\
    \ cases and solutions where the outer header of a\n   UDP tunnel contains a multicast\
    \ destination address, such as\n   [RFC6513].  These cases are primarily deployed\
    \ in controlled\n   environments over reserved capacity, often operating within\
    \ a single\n   administrative domain, or between two domains over a bilaterally\n\
    \   agreed upon path with reserved capacity, and so congestion control is\n  \
    \ OPTIONAL, but circuit breaker techniques are still RECOMMENDED in\n   order\
    \ to restore some degree of service should the offered load\n   exceed the reserved\
    \ capacity (e.g., due to misconfiguration).\n"
- title: 4.1.  Multicast Congestion Control Guidelines
  contents:
  - "4.1.  Multicast Congestion Control Guidelines\n   Unicast congestion-controlled\
    \ transport mechanisms are often not\n   applicable to multicast distribution\
    \ services, or simply do not scale\n   to large multicast trees, since they require\
    \ bidirectional\n   communication and adapt the sending rate to accommodate the\
    \ network\n   conditions to a single receiver.  In contrast, multicast distribution\n\
    \   trees may fan out to massive numbers of receivers, which limits the\n   scalability\
    \ of an in-band return channel to control the sending rate,\n   and the one-to-many\
    \ nature of multicast distribution trees prevents\n   adapting the rate to the\
    \ requirements of an individual receiver.  For\n   this reason, generating TCP-compatible\
    \ aggregate flow rates for\n   Internet multicast data, either native or tunneled,\
    \ is the\n   responsibility of the application implementing the congestion\n \
    \  control.\n   Applications using multicast SHOULD provide appropriate congestion\n\
    \   control.  Multicast congestion control needs to be designed using\n   mechanisms\
    \ that are robust to the potential heterogeneity of both the\n   multicast distribution\
    \ tree and the receivers belonging to a group.\n   Heterogeneity may manifest\
    \ itself in some receivers experiencing more\n   loss that others, higher delay,\
    \ and/or less ability to respond to\n   network conditions.  Congestion control\
    \ is particularly important for\n   any multicast session where all or part of\
    \ the multicast distribution\n   tree spans an access network (e.g., a home gateway).\
    \  Two styles of\n   congestion control have been defined in the RFC Series:\n\
    \   o  Feedback-based congestion control, in which the sender receives\n     \
    \ multicast or unicast UDP messages from the receivers allowing it\n      to assess\
    \ the level of congestion and then adjust the sender\n      rate(s) (e.g., [RFC5740],[RFC4654]).\
    \  Multicast methods may\n      operate on longer timescales than for unicast\
    \ (e.g., due to the\n      higher group RTT of a heterogeneous group).  A control\
    \ method\n      could decide not to reduce the rate of the entire multicast group\n\
    \      in response to a control message received from a single receiver\n    \
    \  (e.g., a sender could set a minimum rate and decide to request a\n      congested\
    \ receiver to leave the multicast group and could also\n      decide to distribute\
    \ content to these congested receivers at a\n      lower rate using unicast congestion\
    \ control).\n   o  Receiver-driven congestion control, which does not require\
    \ a\n      receiver to send explicit UDP control messages for congestion\n   \
    \   control (e.g., [RFC3738], [RFC5775]).  Instead, the sender\n      distributes\
    \ the data across multiple IP multicast groups (e.g.,\n      using a set of {S,G}\
    \ channels).  Each receiver determines its own\n      level of congestion and\
    \ controls its reception rate using only\n      multicast join/leave messages\
    \ sent in the network control plane.\n      This method scales to arbitrary large\
    \ groups of receivers.\n   Any multicast-enabled receiver may attempt to join\
    \ and receive\n   traffic from any group.  This may imply the need for rate limits\
    \ on\n   individual receivers or the aggregate multicast service.  Note, at\n\
    \   the transport layer, there is no way to prevent a join message\n   propagating\
    \ to the next-hop router.\n   Some classes of multicast applications support applications\
    \ that can\n   monitor the user-level quality of the transfer at the receiver.\n\
    \   Applications that can detect a significant reduction in user quality\n   SHOULD\
    \ regard this as a congestion signal (e.g., to leave a group\n   using layered\
    \ multicast encoding); if not, they SHOULD use this\n   signal to provide a circuit\
    \ breaker to terminate the flow by leaving\n   the multicast group.\n"
- title: 4.1.1.  Bulk-Transfer Multicast Applications
  contents:
  - "4.1.1.  Bulk-Transfer Multicast Applications\n   Applications that perform bulk\
    \ transmission of data over a multicast\n   distribution tree, i.e., applications\
    \ that exchange more than a few\n   UDP datagrams per RTT, SHOULD implement a\
    \ method for congestion\n   control.  The currently RECOMMENDED IETF methods are\
    \ as follows:\n   Asynchronous Layered Coding (ALC) [RFC5775], TCP-Friendly Multicast\n\
    \   Congestion Control (TFMCC) [RFC4654], Wave and Equation Based Rate\n   Control\
    \ (WEBRC) [RFC3738], NACK-Oriented Reliable Multicast (NORM)\n   transport protocol\
    \ [RFC5740], File Delivery over Unidirectional\n   Transport (FLUTE) [RFC6726],\
    \ Real Time Protocol/Control Protocol\n   (RTP/RTCP) [RFC3550].\n   An application\
    \ can alternatively implement another congestion control\n   scheme following\
    \ the guidelines of [RFC2887] and utilizing the\n   framework of [RFC3048].  Bulk-transfer\
    \ applications that choose not\n   to implement [RFC4654], [RFC5775], [RFC3738],\
    \ [RFC5740], [RFC6726],\n   or [RFC3550] SHOULD implement a congestion control\
    \ scheme that\n   results in bandwidth use that competes fairly with TCP within\
    \ an\n   order of magnitude.\n   Section 2 of [RFC3551] states that multimedia\
    \ applications SHOULD\n   monitor the packet-loss rate to ensure that it is within\
    \ acceptable\n   parameters.  Packet loss is considered acceptable if a TCP flow\n\
    \   across the same network path under the same network conditions would\n   achieve\
    \ an average throughput, measured on a reasonable timescale,\n   that is not less\
    \ than that of the UDP flow.  The comparison to TCP\n   cannot be specified exactly,\
    \ but is intended as an \"order-of-\n   magnitude\" comparison in timescale and\
    \ throughput.\n"
- title: 4.1.2.  Low Data-Volume Multicast Applications
  contents:
  - "4.1.2.  Low Data-Volume Multicast Applications\n   All the recommendations in\
    \ Section 3.1.3 are also applicable to low\n   data-volume multicast applications.\n"
- title: 4.2.  Message Size Guidelines for Multicast
  contents:
  - "4.2.  Message Size Guidelines for Multicast\n   A multicast application SHOULD\
    \ NOT send UDP datagrams that result in\n   IP packets that exceed the effective\
    \ MTU as described in Section 3 of\n   [RFC6807].  Consequently, an application\
    \ SHOULD either use the\n   effective MTU information provided by the \"Population\
    \ Count\n   Extensions to Protocol Independent Multicast (PIM)\" [RFC6807] or\n\
    \   implement path MTU discovery itself (see Section 3.2) to determine\n   whether\
    \ the path to each destination will support its desired message\n   size without\
    \ fragmentation.\n"
- title: 5.  Programming Guidelines
  contents:
  - "5.  Programming Guidelines\n   The de facto standard application programming\
    \ interface (API) for\n   TCP/IP applications is the \"sockets\" interface [POSIX].\
    \  Some\n   platforms also offer applications the ability to directly assemble\n\
    \   and transmit IP packets through \"raw sockets\" or similar facilities.\n \
    \  This is a second, more cumbersome method of using UDP.  The\n   guidelines\
    \ in this document cover all such methods through which an\n   application may\
    \ use UDP.  Because the sockets API is by far the most\n   common method, the\
    \ remainder of this section discusses it in more\n   detail.\n   Although the\
    \ sockets API was developed for UNIX in the early 1980s, a\n   wide variety of\
    \ non-UNIX operating systems also implement it.  The\n   sockets API supports\
    \ both IPv4 and IPv6 [RFC3493].  The UDP sockets\n   API differs from that for\
    \ TCP in several key ways.  Because\n   application programmers are typically\
    \ more familiar with the TCP\n   sockets API, this section discusses these differences.\
    \  [STEVENS]\n   provides usage examples of the UDP sockets API.\n   UDP datagrams\
    \ may be directly sent and received, without any\n   connection setup.  Using\
    \ the sockets API, applications can receive\n   packets from more than one IP\
    \ source address on a single UDP socket.\n   Some servers use this to exchange\
    \ data with more than one remote host\n   through a single UDP socket at the same\
    \ time.  Many applications need\n   to ensure that they receive packets from a\
    \ particular source address;\n   these applications MUST implement corresponding\
    \ checks at the\n   application layer or explicitly request that the operating\
    \ system\n   filter the received packets.\n   Many operating systems also allow\
    \ a UDP socket to be connected, i.e.,\n   to bind a UDP socket to a specific pair\
    \ of addresses and ports.  This\n   is similar to the corresponding TCP sockets\
    \ API functionality.\n   However, for UDP, this is only a local operation that\
    \ serves to\n   simplify the local send/receive functions and to filter the traffic\n\
    \   for the specified addresses and ports.  Binding a UDP socket does not\n  \
    \ establish a connection -- UDP does not notify the remote end when a\n   local\
    \ UDP socket is bound.  Binding a socket also allows configuring\n   options that\
    \ affect the UDP or IP layers, for example, use of the UDP\n   checksum or the\
    \ IP Timestamp option.  On some stacks, a bound socket\n   also allows an application\
    \ to be notified when ICMP error messages\n   are received for its transmissions\
    \ [RFC1122].\n   If a client/server application executes on a host with more than\
    \ one\n   IP interface, the application SHOULD send any UDP responses with an\n\
    \   IP source address that matches the IP destination address of the UDP\n   datagram\
    \ that carried the request (see [RFC1122], Section 4.1.3.5).\n   Many middleboxes\
    \ expect this transmission behavior and drop replies\n   that are sent from a\
    \ different IP address, as explained in\n   Section 3.5.\n   A UDP receiver can\
    \ receive a valid UDP datagram with a zero-length\n   payload.  Note that this\
    \ is different from a return value of zero\n   from a read() socket call, which\
    \ for TCP indicates the end of the\n   connection.\n   UDP provides no flow-control,\
    \ i.e., the sender at any given time does\n   not know whether the receiver is\
    \ able to handle incoming\n   transmissions.  This is another reason why UDP-based\
    \ applications\n   need to be robust in the presence of packet loss.  This loss\
    \ can also\n   occur within the sending host, when an application sends data faster\n\
    \   than the line rate of the outbound network interface.  It can also\n   occur\
    \ at the destination, where receive calls fail to return all the\n   data that\
    \ was sent when the application issues them too infrequently\n   (i.e., such that\
    \ the receive buffer overflows).  Robust flow control\n   mechanisms are difficult\
    \ to implement, which is why applications that\n   need this functionality SHOULD\
    \ consider using a full-featured\n   transport protocol such as TCP.\n   When\
    \ an application closes a TCP, SCTP, or DCCP socket, the transport\n   protocol\
    \ on the receiving host is required to maintain TIME-WAIT\n   state.  This prevents\
    \ delayed packets from the closed connection\n   instance from being mistakenly\
    \ associated with a later connection\n   instance that happens to reuse the same\
    \ IP address and port pairs.\n   The UDP protocol does not implement such a mechanism.\
    \  Therefore,\n   UDP-based applications need to be robust to reordering and delay.\n\
    \   One application may close a socket or terminate, followed in time by\n   another\
    \ application receiving on the same port.  This later\n   application may then\
    \ receive packets intended for the first\n   application that were delayed in\
    \ the network.\n"
- title: 5.1.  Using UDP Ports
  contents:
  - "5.1.  Using UDP Ports\n   The rules and procedures for the management of the\
    \ \"Service Name and\n   Transport Protocol Port Number Registry\" are specified\
    \ in [RFC6335].\n   Recommendations for use of UDP ports are provided in [RFC7605].\n\
    \   A UDP sender SHOULD NOT use a source port value of zero.  A source\n   port\
    \ number that cannot be easily determined from the address or\n   payload type\
    \ provides protection at the receiver from data injection\n   attacks by off-path\
    \ devices.  A UDP receiver SHOULD NOT bind to port\n   zero.\n   Applications\
    \ SHOULD implement receiver port and address checks at the\n   application layer\
    \ or explicitly request that the operating system\n   filter the received packets\
    \ to prevent receiving packets with an\n   arbitrary port.  This measure is designed\
    \ to provide additional\n   protection from data injection attacks from an off-path\
    \ source (where\n   the port values may not be known).\n   Applications SHOULD\
    \ provide a check that protects from off-path data\n   injection, avoiding an\
    \ application receiving packets that were\n   created by an unauthorized third\
    \ party.  TCP stacks commonly use a\n   randomized source port to provide this\
    \ protection [RFC6056]; UDP\n   applications should follow the same technique.\
    \  Middleboxes and end\n   systems often make assumptions about the system ports\
    \ or user ports;\n   hence, it is recommended to use randomized ports in the Dynamic\
    \ and/\n   or Private Port range.  Setting a \"randomized\" source port also\n\
    \   provides greater assurance that reported ICMP errors originate from\n   network\
    \ systems on the path used by a particular flow.  Some UDP\n   applications choose\
    \ to use a predetermined value for the source port\n   (including some multicast\
    \ applications), these applications need to\n   therefore employ a different technique.\
    \  Protection from off-path\n   data attacks can also be provided by randomizing\
    \ the initial value of\n   another protocol field within the datagram payload,\
    \ and checking the\n   validity of this field at the receiver (e.g., RTP has random\
    \ initial\n   sequence number and random media timestamp offsets [RFC3550]).\n\
    \   When using multicast, IP routers perform a reverse-path forwarding\n   (RPF)\
    \ check for each multicast packet.  This provides protection from\n   off-path\
    \ data injection, restricting opportunities to forge a\n   packet's source address.\
    \  When a receiver joins a multicast group and\n   filters based on the source\
    \ address the filter verifies the sender's\n   IP address.  This is always the\
    \ case when using an SSM {S,G} channel.\n"
- title: 5.1.1.  Usage of UDP for Source Port Entropy and the IPv6 Flow Label
  contents:
  - "5.1.1.  Usage of UDP for Source Port Entropy and the IPv6 Flow Label\n   Some\
    \ applications use the UDP datagram header as a source of entropy\n   for network\
    \ devices that implement ECMP [RFC6438].  A UDP tunnel\n   application targeting\
    \ this usage encapsulates an inner packet using\n   UDP, where the UDP source\
    \ port value forms a part of the entropy that\n   can be used to balance forwarding\
    \ of network traffic by the devices\n   that use ECMP.  A sending tunnel endpoint\
    \ selects a source port value\n   in the UDP datagram header that is computed\
    \ from the inner flow\n   information (e.g., the encapsulated packet headers).\
    \  To provide\n   sufficient entropy, the sending tunnel endpoint maps the encapsulated\n\
    \   traffic to one of a range of UDP source values.  The value SHOULD be\n   within\
    \ the ephemeral port range, i.e., 49152 to 65535, where the high\n   order two\
    \ bits of the port are set to one.  The available source port\n   entropy of 14\
    \ bits (using the ephemeral port range) plus the outer IP\n   addresses seems\
    \ sufficient for entropy for most ECMP applications\n   [ENCAP].\n   To avoid\
    \ reordering within an IP flow, the same UDP source port value\n   SHOULD be used\
    \ for all packets assigned to an encapsulated flow\n   (e.g., using a hash of\
    \ the relevant headers).  The entropy mapping\n   for a flow MAY change over the\
    \ lifetime of the encapsulated flow\n   [ENCAP].  For instance, this could be\
    \ changed as a Denial of Service\n   (DOS) mitigation, or as a means to effect\
    \ routing through the ECMP\n   network.  However, the source port selected for\
    \ a flow SHOULD NOT\n   change more than once in every thirty seconds (e.g., as\
    \ in\n   [RFC8086]).\n   The use of the source port field for entropy has several\
    \ side effects\n   that need to be considered, including:\n   o  It can increase\
    \ the probability of misdelivery of corrupted\n      packets, which increases\
    \ the need for checksum computation or an\n      equivalent mechanism to protect\
    \ other UDP applications from\n      misdelivery errors Section 3.4.\n   o  It\
    \ is expected to reduce the probability of successful middlebox\n      traversal\
    \ Section 3.5.  This use of the source port field will\n      often not be suitable\
    \ for applications targeting deployment in the\n      general Internet.\n   o\
    \  It can prevent the field being usable to protect from off-path\n      attacks\
    \ (described in Section 5.1).  Designers therefore need to\n      consider other\
    \ mechanisms to provide equivalent protection (e.g.,\n      to restrict use to\
    \ a controlled environment [RFC7510]\n      Section 3.6).\n   The UDP source port\
    \ number field has also been leveraged to produce\n   entropy with IPv6.  However,\
    \ in the case of IPv6, the \"flow label\"\n   [RFC6437] may also alternatively\
    \ be used to provide entropy for load\n   balancing [RFC6438].  This use of the\
    \ flow label for load balancing\n   is consistent with the definition of the field,\
    \ although further\n   clarity was needed to ensure the field can be consistently\
    \ used for\n   this purpose.  Therefore, an updated IPv6 flow label [RFC6437]\
    \ and\n   ECMP routing [RFC6438] usage was specified.\n   To ensure future opportunities\
    \ to use the flow label, UDP\n   applications SHOULD set the flow label field,\
    \ even when an entropy\n   value is also set in the source port field (e.g., An\
    \ IPv6 tunnel\n   endpoint could copy the source port flow entropy value to the\
    \ IPv6\n   flow label field [RFC8086]).  Router vendors are encouraged to start\n\
    \   using the IPv6 flow label as a part of the flow hash, providing\n   support\
    \ for IP-level ECMP without requiring use of UDP.  The end-to-\n   end use of\
    \ flow labels for load balancing is a long-term solution.\n   Even if the usage\
    \ of the flow label has been clarified, there will be\n   a transition time before\
    \ a significant proportion of endpoints start\n   to assign a good quality flow\
    \ label to the flows that they originate.\n   The use of load balancing using\
    \ the transport header fields will\n   likely continue until widespread deployment\
    \ is finally achieved.\n"
- title: 5.1.2.  Applications Using Multiple UDP Ports
  contents:
  - "5.1.2.  Applications Using Multiple UDP Ports\n   A single application may exchange\
    \ several types of data.  In some\n   cases, this may require multiple UDP flows\
    \ (e.g., multiple sets of\n   flows, identified by different five-tuples).  [RFC6335]\
    \ recommends\n   application developers not to apply to IANA to be assigned multiple\n\
    \   well-known ports (user or system).  It does not discuss the\n   implications\
    \ of using multiple flows with the same well-known port or\n   pairs of dynamic\
    \ ports (e.g., identified by a service name or\n   signaling protocol).\n   Use\
    \ of multiple flows can affect the network in several ways:\n   o  Starting a\
    \ series of successive connections can increase the\n      number of state bindings\
    \ in middleboxes (e.g., NAPT or Firewall)\n      along the network path.  UDP-based\
    \ middlebox traversal usually\n      relies on timeouts to remove old state, since\
    \ middleboxes are\n      unaware when a particular flow ceases to be used by an\n\
    \      application.\n   o  Using several flows at the same time may result in\
    \ seeing\n      different network characteristics for each flow.  It cannot be\n\
    \      assumed both follow the same path (e.g., when ECMP is used,\n      traffic\
    \ is intentionally hashed onto different parallel paths\n      based on the port\
    \ numbers).\n   o  Using several flows can also increase the occupancy of a binding\n\
    \      or lookup table in a middlebox (e.g., NAPT or Firewall), which may\n  \
    \    cause the device to change the way it manages the flow state.\n   o  Further,\
    \ using excessive numbers of flows can degrade the ability\n      of a unicast\
    \ congestion control to react to congestion events,\n      unless the congestion\
    \ state is shared between all flows in a\n      session.  A receiver-driven multicast\
    \ congestion control requires\n      the sending application to distribute its\
    \ data over a set of IP\n      multicast groups, each receiver is therefore expected\
    \ to receive\n      data from a modest number of simultaneously active UDP ports.\n\
    \   Therefore, applications MUST NOT assume consistent behavior of\n   middleboxes\
    \ when multiple UDP flows are used; many devices respond\n   differently as the\
    \ number of used ports increases.  Using multiple\n   flows with different QoS\
    \ requirements requires applications to verify\n   that the expected performance\
    \ is achieved using each individual flow\n   (five-tuple), see Section 3.1.9.\n"
- title: 5.2.  ICMP Guidelines
  contents:
  - "5.2.  ICMP Guidelines\n   Applications can utilize information about ICMP error\
    \ messages that\n   the UDP layer passes up for a variety of purposes [RFC1122].\n\
    \   Applications SHOULD appropriately validate the payload of ICMP\n   messages\
    \ to ensure these are received in response to transmitted\n   traffic (i.e., a\
    \ reported error condition that corresponds to a UDP\n   datagram actually sent\
    \ by the application).  This requires context,\n   such as local state about communication\
    \ instances to each\n   destination, that although readily available in connection-oriented\n\
    \   transport protocols is not always maintained by UDP-based\n   applications.\
    \  Note that not all platforms have the necessary APIs to\n   support this validation,\
    \ and some platforms already perform this\n   validation internally before passing\
    \ ICMP information to the\n   application.\n   Any application response to ICMP\
    \ error messages SHOULD be robust to\n   temporary routing failures (sometimes\
    \ called \"soft errors\"), e.g.,\n   transient ICMP \"unreachable\" messages ought\
    \ to not normally cause a\n   communication abort.\n   ICMP messages are being\
    \ increasingly filtered by middleboxes.  A UDP\n   application therefore SHOULD\
    \ NOT rely on their delivery for correct\n   and safe operation.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   UDP does not provide communications security.\
    \  Applications that need\n   to protect their communications against eavesdropping,\
    \ tampering, or\n   message forgery SHOULD employ end-to-end security services\
    \ provided\n   by other IETF protocols.\n   UDP applications SHOULD provide protection\
    \ from off-path data\n   injection attacks using a randomized source port or equivalent\n\
    \   technique (see Section 5.1).\n   Applications that respond to short requests\
    \ with potentially large\n   responses are a potential vector for amplification\
    \ attacks, and\n   SHOULD take steps to minimize their potential for being abused\
    \ as\n   part of a DoS attack.  That could mean authenticating the sender\n  \
    \ before responding; noting that the source IP address of a request is\n   not\
    \ a useful authenticator, because it can easily be spoofed.  Or it\n   may mean\
    \ otherwise limiting the cases where short unauthenticated\n   requests produce\
    \ large responses.  Applications MAY also want to\n   offer ways to limit the\
    \ number of requests they respond to in a time\n   interval, in order to cap the\
    \ bandwidth they consume.\n   One option for securing UDP communications is with\
    \ IPsec [RFC4301],\n   which can provide authentication for flows of IP packets\
    \ through the\n   Authentication Header (AH) [RFC4302] and encryption and/or\n\
    \   authentication through the Encapsulating Security Payload (ESP)\n   [RFC4303].\
    \  Applications use the Internet Key Exchange (IKE)\n   [RFC7296] to configure\
    \ IPsec for their sessions.  Depending on how\n   IPsec is configured for a flow,\
    \ it can authenticate or encrypt the\n   UDP headers as well as UDP payloads.\
    \  If an application only requires\n   authentication, ESP with no encryption\
    \ but with authentication is\n   often a better option than AH, because ESP can\
    \ operate across\n   middleboxes.  An application that uses IPsec requires the\
    \ support of\n   an operating system that implements the IPsec protocol suite,\
    \ and the\n   network path must permit IKE and IPsec traffic.  This may become\
    \ more\n   common with IPv6 deployments [RFC6092].\n   Although it is possible\
    \ to use IPsec to secure UDP communications,\n   not all operating systems support\
    \ IPsec or allow applications to\n   easily configure it for their flows.  A second\
    \ option for securing\n   UDP communications is through Datagram Transport Layer\
    \ Security\n   (DTLS) [RFC6347][RFC7525].  DTLS provides communication privacy\
    \ by\n   encrypting UDP payloads.  It does not protect the UDP headers.\n   Applications\
    \ can implement DTLS without relying on support from the\n   operating system.\n\
    \   Many other options for authenticating or encrypting UDP payloads\n   exist.\
    \  For example, the GSS-API security framework [RFC2743] or\n   Cryptographic\
    \ Message Syntax (CMS) [RFC5652] could be used to protect\n   UDP payloads.  There\
    \ exist a number of security options for RTP\n   [RFC3550] over UDP, especially\
    \ to accomplish key-management, see\n   [RFC7201].  These options covers many\
    \ usages, including point-to-\n   point, centralized group communication as well\
    \ as multicast.  In some\n   applications, a better solution is to protect larger\
    \ stand-alone\n   objects, such as files or messages, instead of individual UDP\n\
    \   payloads.  In these situations, CMS [RFC5652], S/MIME [RFC5751] or\n   OpenPGP\
    \ [RFC4880] could be used.  In addition, there are many\n   non-IETF protocols\
    \ in this area.\n   Like congestion control mechanisms, security mechanisms are\
    \ difficult\n   to design and implement correctly.  It is hence RECOMMENDED that\n\
    \   applications employ well-known standard security mechanisms such as\n   DTLS\
    \ or IPsec, rather than inventing their own.\n   The Generalized TTL Security\
    \ Mechanism (GTSM) [RFC5082] may be used\n   with UDP applications when the intended\
    \ endpoint is on the same link\n   as the sender.  This lightweight mechanism\
    \ allows a receiver to\n   filter unwanted packets.\n   In terms of congestion\
    \ control, [RFC2309] and [RFC2914] discuss the\n   dangers of congestion-unresponsive\
    \ flows to the Internet.  [RFC8084]\n   describes methods that can be used to\
    \ set a performance envelope that\n   can assist in preventing congestion collapse\
    \ in the absence of\n   congestion control or when the congestion control fails\
    \ to react to\n   congestion events.  This document provides guidelines to designers\
    \ of\n   UDP-based applications to congestion-control their transmissions, and\n\
    \   does not raise any additional security concerns.\n   Some network operators\
    \ have experienced surges of UDP attack traffic\n   that are multiple orders of\
    \ magnitude above the baseline traffic rate\n   for UDP.  This can motivate operators\
    \ to limit the data rate or\n   packet rate of UDP traffic.  This may in turn\
    \ limit the throughput\n   that an application can achieve using UDP and could\
    \ also result in\n   higher packet loss for UDP traffic that would not be experienced\
    \ if\n   other transport protocols had been used.\n   A UDP application with a\
    \ long-lived association between the sender\n   and receiver, ought to be designed\
    \ so that the sender periodically\n   checks that the receiver still wants (\"\
    consents\") to receive traffic\n   and need to be designed to stop if there is\
    \ no explicit confirmation\n   of this [RFC7675].  Applications that require communications\
    \ in two\n   directions to implement protocol functions (such as reliability or\n\
    \   congestion control) will need to independently check both directions\n   of\
    \ communication, and may have to exchange keep-alive messages to\n   traverse\
    \ middleboxes (see Section 3.5).\n"
- title: 7.  Summary
  contents:
  - "7.  Summary\n   This section summarizes the key guidelines made in Sections 3\
    \ - 6 in\n   a tabular format (Table 1) for easy referencing.\n   +---------------------------------------------------------+---------+\n\
    \   | Recommendation                                          | Section |\n  \
    \ +---------------------------------------------------------+---------+\n   |\
    \ MUST tolerate a wide range of Internet path conditions  | 3       |\n   | SHOULD\
    \ use a full-featured transport (e.g., TCP)        |         |\n   |         \
    \                                                |         |\n   | SHOULD control\
    \ rate of transmission                     | 3.1     |\n   | SHOULD perform congestion\
    \ control over all traffic      |         |\n   |                            \
    \                             |         |\n   | for bulk transfers,          \
    \                           | 3.1.2   |\n   | SHOULD consider implementing TFRC\
    \                       |         |\n   | else, SHOULD in other ways use bandwidth\
    \ similar to TCP |         |\n   |                                           \
    \              |         |\n   | for non-bulk transfers,                     \
    \            | 3.1.3   |\n   | SHOULD measure RTT and transmit max. 1 datagram/RTT\
    \     | 3.1.1   |\n   | else, SHOULD send at most 1 datagram every 3 seconds \
    \   |         |\n   | SHOULD back-off retransmission timers following loss   \
    \ |         |\n   |                                                         |\
    \         |\n   | SHOULD provide mechanisms to regulate the bursts of     | 3.1.6\
    \   |\n   | transmission                                            |        \
    \ |\n   |                                                         |         |\n\
    \   | MAY implement ECN; a specific set of application        | 3.1.7   |\n  \
    \ | mechanisms are REQUIRED if ECN is used.                 |         |\n   |\
    \                                                         |         |\n   | for\
    \ DiffServ, SHOULD NOT rely on implementation of PHBs | 3.1.8   |\n   |      \
    \                                                   |         |\n   | for QoS-enabled\
    \ paths, MAY choose not to use CC         | 3.1.9   |\n   |                  \
    \                                       |         |\n   | SHOULD NOT rely solely\
    \ on QoS for their capacity        | 3.1.10  |\n   | non-CC controlled flows SHOULD\
    \ implement a transport    |         |\n   | circuit breaker                 \
    \                        |         |\n   | MAY implement a circuit breaker for\
    \ other applications  |         |\n   |                                      \
    \                   |         |\n   | for tunnels carrying IP traffic,       \
    \                 | 3.1.11  |\n   | SHOULD NOT perform congestion control    \
    \               |         |\n   | MUST correctly process the IP ECN field    \
    \             |         |\n   |                                              \
    \           |         |\n   | for non-IP tunnels or rate not determined by traffic,\
    \   |         |\n   | SHOULD perform CC or use circuit breaker               \
    \ | 3.1.11  |\n   | SHOULD restrict types of traffic transported by the     |\
    \         |\n   | tunnel                                                  |  \
    \       |\n   |                                                         |    \
    \     |\n   | SHOULD NOT send datagrams that exceed the PMTU, i.e.,   | 3.2  \
    \   |\n   | SHOULD discover PMTU or send datagrams < minimum PMTU;  |        \
    \ |\n   | Specific application mechanisms are REQUIRED if PLPMTUD |         |\n\
    \   | is used.                                                |         |\n  \
    \ |                                                         |         |\n   |\
    \ SHOULD handle datagram loss, duplication, reordering    | 3.3     |\n   | SHOULD\
    \ be robust to delivery delays up to 2 minutes     |         |\n   |         \
    \                                                |         |\n   | SHOULD enable\
    \ IPv4 UDP checksum                         | 3.4     |\n   | SHOULD enable IPv6\
    \ UDP checksum; Specific application   | 3.4.1   |\n   | mechanisms are REQUIRED\
    \ if a zero IPv6 UDP checksum is  |         |\n   | used.                    \
    \                               |         |\n   |                            \
    \                             |         |\n   | SHOULD provide protection from\
    \ off-path attacks         | 5.1     |\n   | else, MAY use UDP-Lite with suitable\
    \ checksum coverage  | 3.4.2   |\n   |                                       \
    \                  |         |\n   | SHOULD NOT always send middlebox keep-alive\
    \ messages    | 3.5     |\n   | MAY use keep-alives when needed (min. interval\
    \ 15 sec)  |         |\n   |                                                 \
    \        |         |\n   | Applications specified for use in limited use (or \
    \      | 3.6     |\n   | controlled environments) SHOULD identify equivalent \
    \    |         |\n   | mechanisms and describe their use case.               \
    \  |         |\n   |                                                         |\
    \         |\n   | Bulk-multicast apps SHOULD implement congestion control | 4.1.1\
    \   |\n   |                                                         |        \
    \ |\n   | Low volume multicast apps SHOULD implement congestion   | 4.1.2   |\n\
    \   | control                                                 |         |\n  \
    \ |                                                         |         |\n   |\
    \ Multicast apps SHOULD use a safe PMTU                   | 4.2     |\n   |  \
    \                                                       |         |\n   | SHOULD\
    \ avoid using multiple ports                       | 5.1.2   |\n   | MUST check\
    \ received IP source address                   |         |\n   |             \
    \                                            |         |\n   | SHOULD validate\
    \ payload in ICMP messages                | 5.2     |\n   |                  \
    \                                       |         |\n   | SHOULD use a randomized\
    \ source port or equivalent       | 6       |\n   | technique, and, for client/server\
    \ applications, SHOULD  |         |\n   | send responses from source address matching\
    \ request     |         |\n   | 5.1                                          \
    \           |         |\n   | SHOULD use standard IETF security protocols when\
    \ needed | 6       |\n   +---------------------------------------------------------+---------+\n\
    \                    Table 1: Summary of Recommendations\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC768]   Postel, J., \"User Datagram Protocol\"\
    , STD 6, RFC 768,\n              DOI 10.17487/RFC0768, August 1980,\n        \
    \      <http://www.rfc-editor.org/info/rfc768>.\n   [RFC793]   Postel, J., \"\
    Transmission Control Protocol\", STD 7,\n              RFC 793, DOI 10.17487/RFC0793,\
    \ September 1981,\n              <http://www.rfc-editor.org/info/rfc793>.\n  \
    \ [RFC1122]  Braden, R., Ed., \"Requirements for Internet Hosts -\n          \
    \    Communication Layers\", STD 3, RFC 1122,\n              DOI 10.17487/RFC1122,\
    \ October 1989,\n              <http://www.rfc-editor.org/info/rfc1122>.\n   [RFC1191]\
    \  Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191,\n             \
    \ DOI 10.17487/RFC1191, November 1990,\n              <http://www.rfc-editor.org/info/rfc1191>.\n\
    \   [RFC1981]  McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery\n \
    \             for IP version 6\", RFC 1981, DOI 10.17487/RFC1981, August\n   \
    \           1996, <http://www.rfc-editor.org/info/rfc1981>.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n       \
    \       <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC2460]  Deering, S. and\
    \ R. Hinden, \"Internet Protocol, Version 6\n              (IPv6) Specification\"\
    , RFC 2460, DOI 10.17487/RFC2460,\n              December 1998, <http://www.rfc-editor.org/info/rfc2460>.\n\
    \   [RFC2914]  Floyd, S., \"Congestion Control Principles\", BCP 41,\n       \
    \       RFC 2914, DOI 10.17487/RFC2914, September 2000,\n              <http://www.rfc-editor.org/info/rfc2914>.\n\
    \   [RFC3828]  Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., Ed.,\n  \
    \            and G. Fairhurst, Ed., \"The Lightweight User Datagram\n        \
    \      Protocol (UDP-Lite)\", RFC 3828, DOI 10.17487/RFC3828, July\n         \
    \     2004, <http://www.rfc-editor.org/info/rfc3828>.\n   [RFC4787]  Audet, F.,\
    \ Ed. and C. Jennings, \"Network Address\n              Translation (NAT) Behavioral\
    \ Requirements for Unicast\n              UDP\", BCP 127, RFC 4787, DOI 10.17487/RFC4787,\
    \ January\n              2007, <http://www.rfc-editor.org/info/rfc4787>.\n   [RFC4821]\
    \  Mathis, M. and J. Heffner, \"Packetization Layer Path MTU\n              Discovery\"\
    , RFC 4821, DOI 10.17487/RFC4821, March 2007,\n              <http://www.rfc-editor.org/info/rfc4821>.\n\
    \   [RFC5348]  Floyd, S., Handley, M., Padhye, J., and J. Widmer, \"TCP\n    \
    \          Friendly Rate Control (TFRC): Protocol Specification\",\n         \
    \     RFC 5348, DOI 10.17487/RFC5348, September 2008,\n              <http://www.rfc-editor.org/info/rfc5348>.\n\
    \   [RFC5405]  Eggert, L. and G. Fairhurst, \"Unicast UDP Usage Guidelines\n \
    \             for Application Designers\", BCP 145, RFC 5405,\n              DOI\
    \ 10.17487/RFC5405, November 2008,\n              <http://www.rfc-editor.org/info/rfc5405>.\n\
    \   [RFC6040]  Briscoe, B., \"Tunnelling of Explicit Congestion\n            \
    \  Notification\", RFC 6040, DOI 10.17487/RFC6040, November\n              2010,\
    \ <http://www.rfc-editor.org/info/rfc6040>.\n   [RFC6298]  Paxson, V., Allman,\
    \ M., Chu, J., and M. Sargent,\n              \"Computing TCP's Retransmission\
    \ Timer\", RFC 6298,\n              DOI 10.17487/RFC6298, June 2011,\n       \
    \       <http://www.rfc-editor.org/info/rfc6298>.\n   [RFC8084]  Fairhurst, G.,\
    \ \"Network Transport Circuit Breakers\",\n              BCP 208, RFC 8084, DOI\
    \ 10.17487/RFC8084, March 2017,\n              <http://www.rfc-editor.org/info/rfc8084>.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [ALLMAN]   Allman, M. and E. Blanton, \"Notes\
    \ on burst mitigation for\n              transport protocols\", March 2005.\n\
    \   [BEHAVE-APP]\n              Ford, B., \"Application Design Guidelines for\
    \ Traversal\n              through Network Address Translators\", Work in Progress,\n\
    \              draft-ford-behave-app-05, March 2007.\n   [ENCAP]    Nordmark,\
    \ E., Ed., Tian, A., Gross, J., Hudson, J.,\n              Kreeger, L., Garg,\
    \ P., Thaler, P., and T. Herbert,\n              \"Encapsulation Considerations\"\
    , Work in Progress,\n              draft-ietf-rtgwg-dt-encap-02, October 2016.\n\
    \   [FABER]    Faber, T., Touch, J., and W. Yue, \"The TIME-WAIT State in\n  \
    \            TCP and Its Effect on Busy Servers\", Proc. IEEE Infocom,\n     \
    \         March 1999.\n   [INT-TUNNELS]\n              Touch, J. and W. Townsley,\
    \ \"IP Tunnels in the Internet\n              Architecture\", Work in Progress,\n\
    \              draft-ietf-intarea-tunnels-03, July 2016.\n   [POSIX]    IEEE Std.\
    \ 1003.1-2001, , \"Standard for Information\n              Technology - Portable\
    \ Operating System Interface (POSIX)\",\n              Open Group Technical Standard:\
    \ Base Specifications Issue\n              6, ISO/IEC 9945:2002, December 2001.\n\
    \   [RFC919]   Mogul, J., \"Broadcasting Internet Datagrams\", STD 5,\n      \
    \        RFC 919, DOI 10.17487/RFC0919, October 1984,\n              <http://www.rfc-editor.org/info/rfc919>.\n\
    \   [RFC1112]  Deering, S., \"Host extensions for IP multicasting\", STD 5,\n\
    \              RFC 1112, DOI 10.17487/RFC1112, August 1989,\n              <http://www.rfc-editor.org/info/rfc1112>.\n\
    \   [RFC1536]  Kumar, A., Postel, J., Neuman, C., Danzig, P., and S.\n       \
    \       Miller, \"Common DNS Implementation Errors and Suggested\n           \
    \   Fixes\", RFC 1536, DOI 10.17487/RFC1536, October 1993,\n              <http://www.rfc-editor.org/info/rfc1536>.\n\
    \   [RFC1546]  Partridge, C., Mendez, T., and W. Milliken, \"Host\n          \
    \    Anycasting Service\", RFC 1546, DOI 10.17487/RFC1546,\n              November\
    \ 1993, <http://www.rfc-editor.org/info/rfc1546>.\n   [RFC2309]  Braden, B., Clark,\
    \ D., Crowcroft, J., Davie, B., Deering,\n              S., Estrin, D., Floyd,\
    \ S., Jacobson, V., Minshall, G.,\n              Partridge, C., Peterson, L.,\
    \ Ramakrishnan, K., Shenker,\n              S., Wroclawski, J., and L. Zhang,\
    \ \"Recommendations on\n              Queue Management and Congestion Avoidance\
    \ in the\n              Internet\", RFC 2309, DOI 10.17487/RFC2309, April 1998,\n\
    \              <http://www.rfc-editor.org/info/rfc2309>.\n   [RFC2475]  Blake,\
    \ S., Black, D., Carlson, M., Davies, E., Wang, Z.,\n              and W. Weiss,\
    \ \"An Architecture for Differentiated\n              Services\", RFC 2475, DOI\
    \ 10.17487/RFC2475, December 1998,\n              <http://www.rfc-editor.org/info/rfc2475>.\n\
    \   [RFC2675]  Borman, D., Deering, S., and R. Hinden, \"IPv6 Jumbograms\",\n\
    \              RFC 2675, DOI 10.17487/RFC2675, August 1999,\n              <http://www.rfc-editor.org/info/rfc2675>.\n\
    \   [RFC2743]  Linn, J., \"Generic Security Service Application Program\n    \
    \          Interface Version 2, Update 1\", RFC 2743,\n              DOI 10.17487/RFC2743,\
    \ January 2000,\n              <http://www.rfc-editor.org/info/rfc2743>.\n   [RFC2887]\
    \  Handley, M., Floyd, S., Whetten, B., Kermode, R.,\n              Vicisano,\
    \ L., and M. Luby, \"The Reliable Multicast Design\n              Space for Bulk\
    \ Data Transfer\", RFC 2887,\n              DOI 10.17487/RFC2887, August 2000,\n\
    \              <http://www.rfc-editor.org/info/rfc2887>.\n   [RFC2983]  Black,\
    \ D., \"Differentiated Services and Tunnels\",\n              RFC 2983, DOI 10.17487/RFC2983,\
    \ October 2000,\n              <http://www.rfc-editor.org/info/rfc2983>.\n   [RFC3048]\
    \  Whetten, B., Vicisano, L., Kermode, R., Handley, M.,\n              Floyd,\
    \ S., and M. Luby, \"Reliable Multicast Transport\n              Building Blocks\
    \ for One-to-Many Bulk-Data Transfer\",\n              RFC 3048, DOI 10.17487/RFC3048,\
    \ January 2001,\n              <http://www.rfc-editor.org/info/rfc3048>.\n   [RFC3124]\
    \  Balakrishnan, H. and S. Seshan, \"The Congestion Manager\",\n             \
    \ RFC 3124, DOI 10.17487/RFC3124, June 2001,\n              <http://www.rfc-editor.org/info/rfc3124>.\n\
    \   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition\n   \
    \           of Explicit Congestion Notification (ECN) to IP\",\n             \
    \ RFC 3168, DOI 10.17487/RFC3168, September 2001,\n              <http://www.rfc-editor.org/info/rfc3168>.\n\
    \   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n    \
    \          A., Peterson, J., Sparks, R., Handley, M., and E.\n              Schooler,\
    \ \"SIP: Session Initiation Protocol\", RFC 3261,\n              DOI 10.17487/RFC3261,\
    \ June 2002,\n              <http://www.rfc-editor.org/info/rfc3261>.\n   [RFC3303]\
    \  Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and\n              A.\
    \ Rayhan, \"Middlebox communication architecture and\n              framework\"\
    , RFC 3303, DOI 10.17487/RFC3303, August 2002,\n              <http://www.rfc-editor.org/info/rfc3303>.\n\
    \   [RFC3493]  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.\n    \
    \          Stevens, \"Basic Socket Interface Extensions for IPv6\",\n        \
    \      RFC 3493, DOI 10.17487/RFC3493, February 2003,\n              <http://www.rfc-editor.org/info/rfc3493>.\n\
    \   [RFC3550]  Schulzrinne, H., Casner, S., Frederick, R., and V.\n          \
    \    Jacobson, \"RTP: A Transport Protocol for Real-Time\n              Applications\"\
    , STD 64, RFC 3550, DOI 10.17487/RFC3550,\n              July 2003, <http://www.rfc-editor.org/info/rfc3550>.\n\
    \   [RFC3551]  Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and\n  \
    \            Video Conferences with Minimal Control\", STD 65, RFC 3551,\n   \
    \           DOI 10.17487/RFC3551, July 2003,\n              <http://www.rfc-editor.org/info/rfc3551>.\n\
    \   [RFC3738]  Luby, M. and V. Goyal, \"Wave and Equation Based Rate\n       \
    \       Control (WEBRC) Building Block\", RFC 3738,\n              DOI 10.17487/RFC3738,\
    \ April 2004,\n              <http://www.rfc-editor.org/info/rfc3738>.\n   [RFC3758]\
    \  Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P.\n              Conrad,\
    \ \"Stream Control Transmission Protocol (SCTP)\n              Partial Reliability\
    \ Extension\", RFC 3758,\n              DOI 10.17487/RFC3758, May 2004,\n    \
    \          <http://www.rfc-editor.org/info/rfc3758>.\n   [RFC3819]  Karn, P.,\
    \ Ed., Bormann, C., Fairhurst, G., Grossman, D.,\n              Ludwig, R., Mahdavi,\
    \ J., Montenegro, G., Touch, J., and L.\n              Wood, \"Advice for Internet\
    \ Subnetwork Designers\", BCP 89,\n              RFC 3819, DOI 10.17487/RFC3819,\
    \ July 2004,\n              <http://www.rfc-editor.org/info/rfc3819>.\n   [RFC4301]\
    \  Kent, S. and K. Seo, \"Security Architecture for the\n              Internet\
    \ Protocol\", RFC 4301, DOI 10.17487/RFC4301,\n              December 2005, <http://www.rfc-editor.org/info/rfc4301>.\n\
    \   [RFC4302]  Kent, S., \"IP Authentication Header\", RFC 4302,\n           \
    \   DOI 10.17487/RFC4302, December 2005,\n              <http://www.rfc-editor.org/info/rfc4302>.\n\
    \   [RFC4303]  Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n      \
    \        RFC 4303, DOI 10.17487/RFC4303, December 2005,\n              <http://www.rfc-editor.org/info/rfc4303>.\n\
    \   [RFC4340]  Kohler, E., Handley, M., and S. Floyd, \"Datagram\n           \
    \   Congestion Control Protocol (DCCP)\", RFC 4340,\n              DOI 10.17487/RFC4340,\
    \ March 2006,\n              <http://www.rfc-editor.org/info/rfc4340>.\n   [RFC4341]\
    \  Floyd, S. and E. Kohler, \"Profile for Datagram Congestion\n              Control\
    \ Protocol (DCCP) Congestion Control ID 2: TCP-like\n              Congestion\
    \ Control\", RFC 4341, DOI 10.17487/RFC4341, March\n              2006, <http://www.rfc-editor.org/info/rfc4341>.\n\
    \   [RFC4342]  Floyd, S., Kohler, E., and J. Padhye, \"Profile for\n         \
    \     Datagram Congestion Control Protocol (DCCP) Congestion\n              Control\
    \ ID 3: TCP-Friendly Rate Control (TFRC)\", RFC 4342,\n              DOI 10.17487/RFC4342,\
    \ March 2006,\n              <http://www.rfc-editor.org/info/rfc4342>.\n   [RFC4380]\
    \  Huitema, C., \"Teredo: Tunneling IPv6 over UDP through\n              Network\
    \ Address Translations (NATs)\", RFC 4380,\n              DOI 10.17487/RFC4380,\
    \ February 2006,\n              <http://www.rfc-editor.org/info/rfc4380>.\n  \
    \ [RFC4607]  Holbrook, H. and B. Cain, \"Source-Specific Multicast for\n     \
    \         IP\", RFC 4607, DOI 10.17487/RFC4607, August 2006,\n              <http://www.rfc-editor.org/info/rfc4607>.\n\
    \   [RFC4654]  Widmer, J. and M. Handley, \"TCP-Friendly Multicast\n         \
    \     Congestion Control (TFMCC): Protocol Specification\",\n              RFC\
    \ 4654, DOI 10.17487/RFC4654, August 2006,\n              <http://www.rfc-editor.org/info/rfc4654>.\n\
    \   [RFC4880]  Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R.\n   \
    \           Thayer, \"OpenPGP Message Format\", RFC 4880,\n              DOI 10.17487/RFC4880,\
    \ November 2007,\n              <http://www.rfc-editor.org/info/rfc4880>.\n  \
    \ [RFC4890]  Davies, E. and J. Mohacsi, \"Recommendations for Filtering\n    \
    \          ICMPv6 Messages in Firewalls\", RFC 4890,\n              DOI 10.17487/RFC4890,\
    \ May 2007,\n              <http://www.rfc-editor.org/info/rfc4890>.\n   [RFC4960]\
    \  Stewart, R., Ed., \"Stream Control Transmission Protocol\",\n             \
    \ RFC 4960, DOI 10.17487/RFC4960, September 2007,\n              <http://www.rfc-editor.org/info/rfc4960>.\n\
    \   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler, \"IPv4 Reassembly\n \
    \             Errors at High Data Rates\", RFC 4963,\n              DOI 10.17487/RFC4963,\
    \ July 2007,\n              <http://www.rfc-editor.org/info/rfc4963>.\n   [RFC4987]\
    \  Eddy, W., \"TCP SYN Flooding Attacks and Common\n              Mitigations\"\
    , RFC 4987, DOI 10.17487/RFC4987, August 2007,\n              <http://www.rfc-editor.org/info/rfc4987>.\n\
    \   [RFC5082]  Gill, V., Heasley, J., Meyer, D., Savola, P., Ed., and C.\n   \
    \           Pignataro, \"The Generalized TTL Security Mechanism\n            \
    \  (GTSM)\", RFC 5082, DOI 10.17487/RFC5082, October 2007,\n              <http://www.rfc-editor.org/info/rfc5082>.\n\
    \   [RFC5245]  Rosenberg, J., \"Interactive Connectivity Establishment\n     \
    \         (ICE): A Protocol for Network Address Translator (NAT)\n           \
    \   Traversal for Offer/Answer Protocols\", RFC 5245,\n              DOI 10.17487/RFC5245,\
    \ April 2010,\n              <http://www.rfc-editor.org/info/rfc5245>.\n   [RFC5622]\
    \  Floyd, S. and E. Kohler, \"Profile for Datagram Congestion\n              Control\
    \ Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate\n              Control for\
    \ Small Packets (TFRC-SP)\", RFC 5622,\n              DOI 10.17487/RFC5622, August\
    \ 2009,\n              <http://www.rfc-editor.org/info/rfc5622>.\n   [RFC5652]\
    \  Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70,\n            \
    \  RFC 5652, DOI 10.17487/RFC5652, September 2009,\n              <http://www.rfc-editor.org/info/rfc5652>.\n\
    \   [RFC5681]  Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion\n    \
    \          Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009,\n      \
    \        <http://www.rfc-editor.org/info/rfc5681>.\n   [RFC5740]  Adamson, B.,\
    \ Bormann, C., Handley, M., and J. Macker,\n              \"NACK-Oriented Reliable\
    \ Multicast (NORM) Transport\n              Protocol\", RFC 5740, DOI 10.17487/RFC5740,\
    \ November 2009,\n              <http://www.rfc-editor.org/info/rfc5740>.\n  \
    \ [RFC5751]  Ramsdell, B. and S. Turner, \"Secure/Multipurpose Internet\n    \
    \          Mail Extensions (S/MIME) Version 3.2 Message\n              Specification\"\
    , RFC 5751, DOI 10.17487/RFC5751, January\n              2010, <http://www.rfc-editor.org/info/rfc5751>.\n\
    \   [RFC5775]  Luby, M., Watson, M., and L. Vicisano, \"Asynchronous\n       \
    \       Layered Coding (ALC) Protocol Instantiation\", RFC 5775,\n           \
    \   DOI 10.17487/RFC5775, April 2010,\n              <http://www.rfc-editor.org/info/rfc5775>.\n\
    \   [RFC5971]  Schulzrinne, H. and R. Hancock, \"GIST: General Internet\n    \
    \          Signalling Transport\", RFC 5971, DOI 10.17487/RFC5971,\n         \
    \     October 2010, <http://www.rfc-editor.org/info/rfc5971>.\n   [RFC5973]  Stiemerling,\
    \ M., Tschofenig, H., Aoun, C., and E. Davies,\n              \"NAT/Firewall NSIS\
    \ Signaling Layer Protocol (NSLP)\",\n              RFC 5973, DOI 10.17487/RFC5973,\
    \ October 2010,\n              <http://www.rfc-editor.org/info/rfc5973>.\n   [RFC6056]\
    \  Larsen, M. and F. Gont, \"Recommendations for Transport-\n              Protocol\
    \ Port Randomization\", BCP 156, RFC 6056,\n              DOI 10.17487/RFC6056,\
    \ January 2011,\n              <http://www.rfc-editor.org/info/rfc6056>.\n   [RFC6092]\
    \  Woodyatt, J., Ed., \"Recommended Simple Security\n              Capabilities\
    \ in Customer Premises Equipment (CPE) for\n              Providing Residential\
    \ IPv6 Internet Service\", RFC 6092,\n              DOI 10.17487/RFC6092, January\
    \ 2011,\n              <http://www.rfc-editor.org/info/rfc6092>.\n   [RFC6335]\
    \  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.\n              Cheshire,\
    \ \"Internet Assigned Numbers Authority (IANA)\n              Procedures for the\
    \ Management of the Service Name and\n              Transport Protocol Port Number\
    \ Registry\", BCP 165,\n              RFC 6335, DOI 10.17487/RFC6335, August 2011,\n\
    \              <http://www.rfc-editor.org/info/rfc6335>.\n   [RFC6347]  Rescorla,\
    \ E. and N. Modadugu, \"Datagram Transport Layer\n              Security Version\
    \ 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n              January 2012, <http://www.rfc-editor.org/info/rfc6347>.\n\
    \   [RFC6396]  Blunk, L., Karir, M., and C. Labovitz, \"Multi-Threaded\n     \
    \         Routing Toolkit (MRT) Routing Information Export Format\",\n       \
    \       RFC 6396, DOI 10.17487/RFC6396, October 2011,\n              <http://www.rfc-editor.org/info/rfc6396>.\n\
    \   [RFC6437]  Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme,\n     \
    \         \"IPv6 Flow Label Specification\", RFC 6437,\n              DOI 10.17487/RFC6437,\
    \ November 2011,\n              <http://www.rfc-editor.org/info/rfc6437>.\n  \
    \ [RFC6438]  Carpenter, B. and S. Amante, \"Using the IPv6 Flow Label\n      \
    \        for Equal Cost Multipath Routing and Link Aggregation in\n          \
    \    Tunnels\", RFC 6438, DOI 10.17487/RFC6438, November 2011,\n             \
    \ <http://www.rfc-editor.org/info/rfc6438>.\n   [RFC6513]  Rosen, E., Ed. and\
    \ R. Aggarwal, Ed., \"Multicast in MPLS/\n              BGP IP VPNs\", RFC 6513,\
    \ DOI 10.17487/RFC6513, February\n              2012, <http://www.rfc-editor.org/info/rfc6513>.\n\
    \   [RFC6679]  Westerlund, M., Johansson, I., Perkins, C., O'Hanlon, P.,\n   \
    \           and K. Carlberg, \"Explicit Congestion Notification (ECN)\n      \
    \        for RTP over UDP\", RFC 6679, DOI 10.17487/RFC6679, August\n        \
    \      2012, <http://www.rfc-editor.org/info/rfc6679>.\n   [RFC6726]  Paila, T.,\
    \ Walsh, R., Luby, M., Roca, V., and R. Lehtonen,\n              \"FLUTE - File\
    \ Delivery over Unidirectional Transport\",\n              RFC 6726, DOI 10.17487/RFC6726,\
    \ November 2012,\n              <http://www.rfc-editor.org/info/rfc6726>.\n  \
    \ [RFC6773]  Phelan, T., Fairhurst, G., and C. Perkins, \"DCCP-UDP: A\n      \
    \        Datagram Congestion Control Protocol UDP Encapsulation for\n        \
    \      NAT Traversal\", RFC 6773, DOI 10.17487/RFC6773, November\n           \
    \   2012, <http://www.rfc-editor.org/info/rfc6773>.\n   [RFC6807]  Farinacci,\
    \ D., Shepherd, G., Venaas, S., and Y. Cai,\n              \"Population Count\
    \ Extensions to Protocol Independent\n              Multicast (PIM)\", RFC 6807,\
    \ DOI 10.17487/RFC6807, December\n              2012, <http://www.rfc-editor.org/info/rfc6807>.\n\
    \   [RFC6887]  Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and\n  \
    \            P. Selkirk, \"Port Control Protocol (PCP)\", RFC 6887,\n        \
    \      DOI 10.17487/RFC6887, April 2013,\n              <http://www.rfc-editor.org/info/rfc6887>.\n\
    \   [RFC6935]  Eubanks, M., Chimento, P., and M. Westerlund, \"IPv6 and\n    \
    \          UDP Checksums for Tunneled Packets\", RFC 6935,\n              DOI\
    \ 10.17487/RFC6935, April 2013,\n              <http://www.rfc-editor.org/info/rfc6935>.\n\
    \   [RFC6936]  Fairhurst, G. and M. Westerlund, \"Applicability Statement\n  \
    \            for the Use of IPv6 UDP Datagrams with Zero Checksums\",\n      \
    \        RFC 6936, DOI 10.17487/RFC6936, April 2013,\n              <http://www.rfc-editor.org/info/rfc6936>.\n\
    \   [RFC6951]  Tuexen, M. and R. Stewart, \"UDP Encapsulation of Stream\n    \
    \          Control Transmission Protocol (SCTP) Packets for End-Host\n       \
    \       to End-Host Communication\", RFC 6951,\n              DOI 10.17487/RFC6951,\
    \ May 2013,\n              <http://www.rfc-editor.org/info/rfc6951>.\n   [RFC7143]\
    \  Chadalapaka, M., Satran, J., Meth, K., and D. Black,\n              \"Internet\
    \ Small Computer System Interface (iSCSI) Protocol\n              (Consolidated)\"\
    , RFC 7143, DOI 10.17487/RFC7143, April\n              2014, <http://www.rfc-editor.org/info/rfc7143>.\n\
    \   [RFC7201]  Westerlund, M. and C. Perkins, \"Options for Securing RTP\n   \
    \           Sessions\", RFC 7201, DOI 10.17487/RFC7201, April 2014,\n        \
    \      <http://www.rfc-editor.org/info/rfc7201>.\n   [RFC7296]  Kaufman, C., Hoffman,\
    \ P., Nir, Y., Eronen, P., and T.\n              Kivinen, \"Internet Key Exchange\
    \ Protocol Version 2\n              (IKEv2)\", STD 79, RFC 7296, DOI 10.17487/RFC7296,\
    \ October\n              2014, <http://www.rfc-editor.org/info/rfc7296>.\n   [RFC7450]\
    \  Bumgardner, G., \"Automatic Multicast Tunneling\", RFC 7450,\n            \
    \  DOI 10.17487/RFC7450, February 2015,\n              <http://www.rfc-editor.org/info/rfc7450>.\n\
    \   [RFC7510]  Xu, X., Sheth, N., Yong, L., Callon, R., and D. Black,\n      \
    \        \"Encapsulating MPLS in UDP\", RFC 7510,\n              DOI 10.17487/RFC7510,\
    \ April 2015,\n              <http://www.rfc-editor.org/info/rfc7510>.\n   [RFC7525]\
    \  Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations\
    \ for Secure Use of Transport Layer\n              Security (TLS) and Datagram\
    \ Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,\
    \ May\n              2015, <http://www.rfc-editor.org/info/rfc7525>.\n   [RFC7560]\
    \  Kuehlewind, M., Ed., Scheffenegger, R., and B. Briscoe,\n              \"Problem\
    \ Statement and Requirements for Increased Accuracy\n              in Explicit\
    \ Congestion Notification (ECN) Feedback\",\n              RFC 7560, DOI 10.17487/RFC7560,\
    \ August 2015,\n              <http://www.rfc-editor.org/info/rfc7560>.\n   [RFC7567]\
    \  Baker, F., Ed. and G. Fairhurst, Ed., \"IETF\n              Recommendations\
    \ Regarding Active Queue Management\",\n              BCP 197, RFC 7567, DOI 10.17487/RFC7567,\
    \ July 2015,\n              <http://www.rfc-editor.org/info/rfc7567>.\n   [RFC7605]\
    \  Touch, J., \"Recommendations on Using Assigned Transport\n              Port\
    \ Numbers\", BCP 165, RFC 7605, DOI 10.17487/RFC7605,\n              August 2015,\
    \ <http://www.rfc-editor.org/info/rfc7605>.\n   [RFC7657]  Black, D., Ed. and\
    \ P. Jones, \"Differentiated Services\n              (Diffserv) and Real-Time\
    \ Communication\", RFC 7657,\n              DOI 10.17487/RFC7657, November 2015,\n\
    \              <http://www.rfc-editor.org/info/rfc7657>.\n   [RFC7675]  Perumal,\
    \ M., Wing, D., Ravindranath, R., Reddy, T., and M.\n              Thomson, \"\
    Session Traversal Utilities for NAT (STUN) Usage\n              for Consent Freshness\"\
    , RFC 7675, DOI 10.17487/RFC7675,\n              October 2015, <http://www.rfc-editor.org/info/rfc7675>.\n\
    \   [RFC8083]  Perkins, C. and V. Singh, \"Multimedia Congestion Control:\n  \
    \            Circuit Breakers for Unicast RTP Sessions\", RFC 8083,\n        \
    \      DOI 10.17487/RFC8083, March 2017,\n              <http://www.rfc-editor.org/info/rfc8083>.\n\
    \   [RFC8086]  Yong, L., Ed., Crabbe, E., Xu, X., and T. Herbert, \"GRE-\n   \
    \           in-UDP Encapsulation\", RFC 8086, DOI 10.17487/RFC8086,\n        \
    \      March 2017, <http://www.rfc-editor.org/info/rfc8086>.\n   [RFC8087]  Fairhurst,\
    \ G. and M. Welzl, \"The Benefits of Using\n              Explicit Congestion\
    \ Notification (ECN)\", RFC 8087,\n              DOI 10.17487/RFC8087, March 2017,\n\
    \              <http://www.rfc-editor.org/info/rfc8087>.\n   [STEVENS]  Stevens,\
    \ W., Fenner, B., and A. Rudoff, \"UNIX Network\n              Programming, The\
    \ sockets Networking API\", Addison-Wesley,\n              2004.\n   [UPnP]  \
    \   UPnP Forum, , \"Internet Gateway Device (IGD) Standardized\n             \
    \ Device Control Protocol V 1.0\", November 2001.\n"
- title: Appendix A.  Case Study of the Use of IPv6 UDP Zero-Checksum Mode
  contents:
  - "Appendix A.  Case Study of the Use of IPv6 UDP Zero-Checksum Mode\n   This appendix\
    \ provides a brief review of MPLS-in-UDP as an example of\n   a UDP Tunnel Encapsulation\
    \ that defines a UDP encapsulation.  The\n   purpose of the appendix is to provide\
    \ a concrete example of which\n   mechanisms were required in order to safely\
    \ use UDP zero-checksum\n   mode for MPLS-in-UDP tunnels over IPv6.  By default,\
    \ UDP requires a\n   checksum for use with IPv6.  An option has been specified\
    \ that\n   permits a zero IPv6 UDP checksum when used in specific environments,\n\
    \   specified in [RFC7510], and defines a set of operational constraints\n   for\
    \ use of this mode.  These are summarized below:\n   A UDP tunnel or encapsulation\
    \ using a zero-checksum mode with IPv6\n   must only be deployed within a single\
    \ network (with a single network\n   operator) or networks of an adjacent set\
    \ of cooperating network\n   operators where traffic is managed to avoid congestion,\
    \ rather than\n   over the Internet where congestion control is required.  MPLS-in-UDP\n\
    \   has been specified for networks under single administrative control\n   (such\
    \ as within a single operator's network) where it is known\n   (perhaps through\
    \ knowledge of equipment types and lower-layer checks)\n   that packet corruption\
    \ is exceptionally unlikely and where the\n   operator is willing to take the\
    \ risk of undetected packet corruption.\n   The tunnel encapsulator SHOULD use\
    \ different IPv6 addresses for each\n   UDP tunnel that uses the UDP zero-checksum\
    \ mode, regardless of the\n   decapsulator, to strengthen the decapsulator's check\
    \ of the IPv6\n   source address (i.e., the same IPv6 source address SHOULD NOT\
    \ be used\n   with more than one IPv6 destination address, independent of whether\n\
    \   that destination address is a unicast or multicast address).  Use of\n   MPLS-in-UDP\
    \ may be extended to networks within a set of closely\n   cooperating network\
    \ administrations (such as network operators who\n   have agreed to work together\
    \ to jointly provide specific services)\n   [RFC7510].\n   The requirement for\
    \ MPLS-in-UDP endpoints to check the source IPv6\n   address in addition to the\
    \ destination IPv6 address, plus the strong\n   recommendation against reuse of\
    \ source IPv6 addresses among MPLS-in-\n   UDP tunnels collectively provide some\
    \ mitigation for the absence of\n   UDP checksum coverage of the IPv6 header.\
    \  In addition, the MPLS data\n   plane only forwards packets with valid labels\
    \ (i.e., labels that have\n   been distributed by the tunnel egress Label Switched\
    \ Router, LSR),\n   providing some additional opportunity to detect MPLS-in-UDP\
    \ packet\n   misdelivery when the misdelivered packet contains a label that is\
    \ not\n   valid for forwarding at the receiving LSR.  The expected result for\n\
    \   IPv6 UDP zero-checksum mode for MPLS-in-UDP is that corruption of the\n  \
    \ destination IPv6 address will usually cause packet discard, as\n   offsetting\
    \ corruptions to the source IPv6 and/or MPLS top label are\n   unlikely.\n   Additional\
    \ assurance is provided by the restrictions in the above\n   exceptions that limit\
    \ usage of IPv6 UDP zero-checksum mode to well-\n   managed networks for which\
    \ MPLS packet corruption has not been a\n   problem in practice.  Hence, MPLS-in-UDP\
    \ is suitable for transmission\n   over lower layers in well-managed networks\
    \ that are allowed by the\n   exceptions stated above and the rate of corruption\
    \ of the inner IP\n   packet on such networks is not expected to increase by comparison\
    \ to\n   MPLS traffic that is not encapsulated in UDP.  For these reasons,\n \
    \  MPLS-in-UDP does not provide an additional integrity check when UDP\n   zero-checksum\
    \ mode is used with IPv6, and this design is in\n   accordance with requirements\
    \ 2, 3, and 5 specified in Section 5 of\n   [RFC6936].\n   The MPLS-in-UDP encapsulation\
    \ does not provide a mechanism to safely\n   fall back to using a checksum when\
    \ a path change occurs that\n   redirects a tunnel over a path that includes a\
    \ middlebox that\n   discards IPv6 datagrams with a zero UDP checksum.  In this\
    \ case, the\n   MPLS-in-UDP tunnel will be black-holed by that middlebox.\n  \
    \ Recommended changes to allow firewalls, NATs and other middleboxes to\n   support\
    \ use of an IPv6 zero UDP checksum are described in Section 5\n   of [RFC6936].\
    \  MPLS does not accumulate incorrect state as a\n   consequence of label-stack\
    \ corruption.  A corrupt MPLS label results\n   in either packet discard or forwarding\
    \ (and forgetting) of the packet\n   without accumulation of MPLS protocol state.\
    \  Active monitoring of\n   MPLS-in-UDP traffic for errors is REQUIRED because\
    \ the occurrence of\n   errors will result in some accumulation of error information\
    \ outside\n   the MPLS protocol for operational and management purposes.  This\n\
    \   design is in accordance with requirement 4 specified in Section 5 of\n   [RFC6936].\
    \  In addition, IPv6 traffic with a zero UDP checksum MUST\n   be actively monitored\
    \ for errors by the network operator.\n   Operators SHOULD also deploy packet\
    \ filters to prevent IPv6 packets\n   with a zero UDP checksum from escaping from\
    \ the network due to\n   misconfiguration or packet errors.  In addition, IPv6\
    \ traffic with a\n   zero UDP checksum MUST be actively monitored for errors by\
    \ the\n   network operator.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The middlebox traversal guidelines in Section 3.5 incorporate\
    \ ideas\n   from Section 5 of [BEHAVE-APP] by Bryan Ford, Pyda Srisuresh, and\
    \ Dan\n   Kegel.  The protocol timer guidelines in Section 3.1.1 were largely\n\
    \   contributed by Mark Allman.\n   G.  Fairhurst received funding from the European\
    \ Union's Horizon 2020\n   research and innovation program 2014-2018 under grant\
    \ agreement No.\n   644334 (NEAT).  Lars Eggert has received funding from the\
    \ European\n   Union's Horizon 2020 research and innovation program 2014-2018\
    \ under\n   grant agreement No. 644866 (SSICLOPS).  This document reflects only\n\
    \   the authors' views and the European Commission is not responsible for\n  \
    \ any use that may be made of the information it contains.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Lars Eggert\n   NetApp\n   Sonnenallee 1\n   Kirchheim\
    \  85551\n   Germany\n   Phone: +49 151 120 55791\n   Email: lars@netapp.com\n\
    \   URI:   https://eggert.org/\n   Godred Fairhurst\n   University of Aberdeen\n\
    \   Department of Engineering\n   Fraser Noble Building\n   Aberdeen  AB24 3UE\n\
    \   Scotland\n   Email: gorry@erg.abdn.ac.uk\n   URI:   http://www.erg.abdn.ac.uk/\n\
    \   Greg Shepherd\n   Cisco Systems\n   Tasman Drive\n   San Jose\n   United States\
    \ of America\n   Email: gjshep@gmail.com\n"
