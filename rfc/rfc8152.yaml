- title: __initial_text__
  contents:
  - '               CBOR Object Signing and Encryption (COSE)

    '
- title: Abstract
  contents:
  - "Abstract\n   Concise Binary Object Representation (CBOR) is a data format designed\n\
    \   for small code size and small message size.  There is a need for the\n   ability\
    \ to have basic security services defined for this data format.\n   This document\
    \ defines the CBOR Object Signing and Encryption (COSE)\n   protocol.  This specification\
    \ describes how to create and process\n   signatures, message authentication codes,\
    \ and encryption using CBOR\n   for serialization.  This specification additionally\
    \ describes how to\n   represent cryptographic keys using CBOR.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8152.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Design Changes from JOSE ...................................5\n  \
    \    1.2. Requirements Terminology ...................................6\n    \
    \  1.3. CBOR Grammar ...............................................6\n      1.4.\
    \ CBOR-Related Terminology ...................................7\n      1.5. Document\
    \ Terminology .......................................8\n   2. Basic COSE Structure\
    \ ............................................8\n   3. Header Parameters ..............................................10\n\
    \      3.1. Common COSE Headers Parameters ............................12\n  \
    \ 4. Signing Objects ................................................16\n    \
    \  4.1. Signing with One or More Signers ..........................16\n      4.2.\
    \ Signing with One Signer ...................................18\n      4.3. Externally\
    \ Supplied Data ..................................19\n      4.4. Signing and Verification\
    \ Process ..........................20\n      4.5. Computing Counter Signatures\
    \ ..............................22\n   5. Encryption Objects .............................................22\n\
    \      5.1. Enveloped COSE Structure ..................................23\n  \
    \         5.1.1. Content Key Distribution Methods ...................24\n    \
    \  5.2. Single Recipient Encrypted ................................25\n      5.3.\
    \ How to Encrypt and Decrypt for AEAD Algorithms ............26\n      5.4. How\
    \ to Encrypt and Decrypt for AE Algorithms ..............28\n   6. MAC Objects\
    \ ....................................................29\n      6.1. MACed Message\
    \ with Recipients .............................30\n      6.2. MACed Messages with\
    \ Implicit Key ..........................31\n      6.3. How to Compute and Verify\
    \ a MAC ...........................32\n   7. Key Objects ....................................................33\n\
    \      7.1. COSE Key Common Parameters ................................34\n  \
    \ 8. Signature Algorithms ...........................................37\n    \
    \  8.1. ECDSA .....................................................38\n      \
    \     8.1.1. Security Considerations ............................40\n      8.2.\
    \ Edwards-Curve Digital Signature Algorithms (EdDSAs) .......40\n           8.2.1.\
    \ Security Considerations ............................41\n   9. Message Authentication\
    \ Code (MAC) Algorithms ...................42\n      9.1. Hash-Based Message Authentication\
    \ Codes (HMACs) ...........42\n           9.1.1. Security Considerations ............................44\n\
    \      9.2. AES Message Authentication Code (AES-CBC-MAC) .............44\n  \
    \         9.2.1. Security Considerations ............................45\n   10.\
    \ Content Encryption Algorithms .................................45\n      10.1.\
    \ AES GCM ..................................................46\n           10.1.1.\
    \ Security Considerations ...........................47\n      10.2. AES CCM ..................................................47\n\
    \           10.2.1. Security Considerations ...........................50\n  \
    \    10.3. ChaCha20 and Poly1305 ....................................50\n    \
    \       10.3.1. Security Considerations ...........................51\n   11.\
    \ Key Derivation Functions (KDFs) ...............................51\n      11.1.\
    \ HMAC-Based Extract-and-Expand Key Derivation\n            Function (HKDF) ..........................................52\n\
    \      11.2. Context Information Structure ............................54\n  \
    \ 12. Content Key Distribution Methods ..............................60\n    \
    \  12.1. Direct Encryption ........................................60\n      \
    \     12.1.1. Direct Key ........................................61\n        \
    \   12.1.2. Direct Key with KDF ...............................61\n       12.2.\
    \ Key Wrap ................................................63\n           12.2.1.\
    \ AES Key Wrap ......................................64\n       12.3. Key Transport\
    \ ...........................................65\n       12.4. Direct Key Agreement\
    \ ....................................65\n           12.4.1. ECDH ..............................................66\n\
    \           12.4.2. Security Considerations ...........................69\n  \
    \    12.5. Key Agreement with Key Wrap ..............................69\n    \
    \       12.5.1. ECDH ..............................................70\n   13.\
    \ Key Object Parameters .........................................72\n      13.1.\
    \ Elliptic Curve Keys ......................................73\n           13.1.1.\
    \ Double Coordinate Curves ..........................73\n      13.2. Octet Key\
    \ Pair ...........................................74\n      13.3. Symmetric Keys\
    \ ...........................................75\n   14. CBOR Encoder Restrictions\
    \ .....................................76\n   15. Application Profiling Considerations\
    \ ..........................76\n   16. IANA Considerations ...........................................78\n\
    \      16.1. CBOR Tag Assignment ......................................78\n  \
    \    16.2. COSE Header Parameters Registry ..........................78\n    \
    \  16.3. COSE Header Algorithm Parameters Registry ................79\n      16.4.\
    \ COSE Algorithms Registry .................................79\n      16.5. COSE\
    \ Key Common Parameters Registry ......................81\n      16.6. COSE Key\
    \ Type Parameters Registry ........................81\n      16.7. COSE Key Types\
    \ Registry ..................................82\n      16.8. COSE Elliptic Curves\
    \ Registry ............................83\n      16.9. Media Type Registrations\
    \ .................................84\n           16.9.1. COSE Security Message\
    \ .............................84\n           16.9.2. COSE Key Media Type ...............................85\n\
    \      16.10. CoAP Content-Formats Registry ...........................87\n  \
    \    16.11. Expert Review Instructions ..............................87\n   17.\
    \ Security Considerations .......................................88\n   18. References\
    \ ....................................................90\n      18.1. Normative\
    \ References .....................................90\n      18.2. Informative\
    \ References ...................................92\n   Appendix A. Guidelines\
    \ for External Data Authentication of\n               Algorithms ............................................96\n\
    \      A.1. Algorithm Identification ..................................96\n  \
    \    A.2. Counter Signature without Headers .........................99\n   Appendix\
    \ B. Two Layers of Recipient Information ..................100\n   Appendix C.\
    \ Examples .............................................102\n      C.1. Examples\
    \ of Signed Messages ..............................103\n           C.1.1. Single\
    \ Signature ..................................103\n           C.1.2. Multiple\
    \ Signers ..................................103\n           C.1.3. Counter Signature\
    \ .................................104\n           C.1.4. Signature with Criticality\
    \ ........................105\n      C.2. Single Signer Examples ...................................106\n\
    \           C.2.1. Single ECDSA Signature  ...........................106\n  \
    \    C.3. Examples of Enveloped Messages ...........................107\n    \
    \       C.3.1. Direct ECDH .......................................107\n      \
    \     C.3.2. Direct Plus Key Derivation ........................108\n        \
    \   C.3.3. Counter Signature on Encrypted Content ............109\n          \
    \ C.3.4. Encrypted Content with External Data ..............111\n      C.4. Examples\
    \ of Encrypted Messages ...........................111\n           C.4.1. Simple\
    \ Encrypted Message ..........................111\n           C.4.2. Encrypted\
    \ Message with a Partial IV ...............112\n      C.5. Examples of MACed Messages\
    \ ...............................112\n           C.5.1. Shared Secret Direct MAC\
    \ ..........................112\n           C.5.2. ECDH Direct MAC ...................................113\n\
    \           C.5.3. Wrapped MAC .......................................114\n  \
    \         C.5.4. Multi-Recipient MACed Message .....................115\n    \
    \  C.6. Examples of MAC0 Messages ................................117\n      \
    \     C.6.1. Shared Secret Direct MAC ..........................117\n      C.7.\
    \ COSE Keys ................................................117\n           C.7.1.\
    \ Public Keys .......................................117\n           C.7.2. Private\
    \ Keys ......................................119\n   Acknowledgments ..................................................121\n\
    \   Author's Address .................................................121\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   There has been an increased focus on small, constrained\
    \ devices that\n   make up the Internet of Things (IoT).  One of the standards\
    \ that has\n   come out of this process is \"Concise Binary Object Representation\n\
    \   (CBOR)\" [RFC7049].  CBOR extended the data model of the JavaScript\n   Object\
    \ Notation (JSON) [RFC7159] by allowing for binary data, among\n   other changes.\
    \  CBOR is being adopted by several of the IETF working\n   groups dealing with\
    \ the IoT world as their encoding of data\n   structures.  CBOR was designed specifically\
    \ to be both small in terms\n   of messages transport and implementation size\
    \ and be a schema-free\n   decoder.  A need exists to provide message security\
    \ services for IoT,\n   and using CBOR as the message-encoding format makes sense.\n\
    \   The JOSE working group produced a set of documents [RFC7515]\n   [RFC7516]\
    \ [RFC7517] [RFC7518] using JSON that specified how to\n   process encryption,\
    \ signatures, and Message Authentication Code (MAC)\n   operations and how to\
    \ encode keys using JSON.  This document defines\n   the CBOR Object Signing and\
    \ Encryption (COSE) standard, which does\n   the same thing for the CBOR encoding\
    \ format.  While there is a strong\n   attempt to keep the flavor of the original\
    \ JSON Object Signing and\n   Encryption (JOSE) documents, two considerations\
    \ are taken into\n   account:\n   o  CBOR has capabilities that are not present\
    \ in JSON and are\n      appropriate to use.  One example of this is the fact\
    \ that CBOR has\n      a method of encoding binary directly without first converting\
    \ it\n      into a base64-encoded string.\n   o  COSE is not a direct copy of\
    \ the JOSE specification.  In the\n      process of creating COSE, decisions that\
    \ were made for JOSE were\n      re-examined.  In many cases, different results\
    \ were decided on as\n      the criteria were not always the same.\n"
- title: 1.1.  Design Changes from JOSE
  contents:
  - "1.1.  Design Changes from JOSE\n   o  Define a single top message structure so\
    \ that encrypted, signed,\n      and MACed messages can easily be identified and\
    \ still have a\n      consistent view.\n   o  Signed messages distinguish between\
    \ the protected and unprotected\n      parameters that relate to the content from\
    \ those that relate to\n      the signature.\n   o  MACed messages are separated\
    \ from signed messages.\n   o  MACed messages have the ability to use the same\
    \ set of recipient\n      algorithms as enveloped messages for obtaining the MAC\n\
    \      authentication key.\n   o  Use binary encodings for binary data rather\
    \ than base64url\n      encodings.\n   o  Combine the authentication tag for encryption\
    \ algorithms with the\n      ciphertext.\n   o  The set of cryptographic algorithms\
    \ has been expanded in some\n      directions and trimmed in others.\n"
- title: 1.2.  Requirements Terminology
  contents:
  - "1.2.  Requirements Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in BCP\n   14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n   When the words appear in lowercase,\
    \ this interpretation does not\n   apply.\n"
- title: 1.3.  CBOR Grammar
  contents:
  - "1.3.  CBOR Grammar\n   There is currently no standard CBOR grammar available\
    \ for use by\n   specifications.  The CBOR structures are therefore described\
    \ in\n   prose.\n   The document was developed by first working on the grammar\
    \ and then\n   developing the prose to go with it.  An artifact of this is that\
    \ the\n   prose was written using the primitive type strings defined by CBOR\n\
    \   Data Definition Language (CDDL) [CDDL].  In this specification, the\n   following\
    \ primitive types are used:\n      any -- non-specific value that permits all\
    \ CBOR values to be\n      placed here.\n      bool -- a boolean value (true:\
    \ major type 7, value 21; false:\n      major type 7, value 20).\n      bstr --\
    \ byte string (major type 2).\n      int -- an unsigned integer or a negative\
    \ integer.\n      nil -- a null value (major type 7, value 22).\n      nint --\
    \ a negative integer (major type 1).\n      tstr -- a UTF-8 text string (major\
    \ type 3).\n      uint -- an unsigned integer (major type 0).\n   Two syntaxes\
    \ from CDDL appear in this document as shorthand.  These\n   are:\n      FOO /\
    \ BAR -- indicates that either FOO or BAR can appear here.\n      [+ FOO] -- indicates\
    \ that the type FOO appears one or more times\n      in an array.\n   As well\
    \ as the prose description, a version of a CBOR grammar is\n   presented in CDDL.\
    \  Since CDDL has not been published in an RFC, this\n   grammar may not work\
    \ with the final version of CDDL.  The CDDL\n   grammar is informational; the\
    \ prose description is normative.\n   The collected CDDL can be extracted from\
    \ the XML version of this\n   document via the following XPath expression below.\
    \  (Depending on the\n   XPath evaluator one is using, it may be necessary to\
    \ deal with &gt;\n   as an entity.)\n   //artwork[@type='CDDL']/text()\n   CDDL\
    \ expects the initial non-terminal symbol to be the first symbol\n   in the file.\
    \  For this reason, the first fragment of CDDL is\n   presented here.\n   start\
    \ = COSE_Messages / COSE_Key / COSE_KeySet / Internal_Types\n   ; This is defined\
    \ to make the tool quieter:\n   Internal_Types = Sig_structure / Enc_structure\
    \ / MAC_structure /\n           COSE_KDF_Context\n   The non-terminal Internal_Types\
    \ is defined for dealing with the\n   automated validation tools used during the\
    \ writing of this document.\n   It references those non-terminals that are used\
    \ for security\n   computations but are not emitted for transport.\n"
- title: 1.4.  CBOR-Related Terminology
  contents:
  - "1.4.  CBOR-Related Terminology\n   In JSON, maps are called objects and only\
    \ have one kind of map key: a\n   string.  In COSE, we use strings, negative integers,\
    \ and unsigned\n   integers as map keys.  The integers are used for compactness\
    \ of\n   encoding and easy comparison.  The inclusion of strings allows for an\n\
    \   additional range of short encoded values to be used as well.  Since\n   the\
    \ word \"key\" is mainly used in its other meaning, as a\n   cryptographic key,\
    \ we use the term \"label\" for this usage as a map\n   key.\n   The presence\
    \ of a label in a COSE map that is not a string or an\n   integer is an error.\
    \  Applications can either fail processing or\n   process messages with incorrect\
    \ labels; however, they MUST NOT create\n   messages with incorrect labels.\n\
    \   A CDDL grammar fragment defines the non-terminal 'label', as in the\n   previous\
    \ paragraph, and 'values', which permits any value to be used.\n   label = int\
    \ / tstr\n   values = any\n"
- title: 1.5.  Document Terminology
  contents:
  - "1.5.  Document Terminology\n   In this document, we use the following terminology:\n\
    \   Byte is a synonym for octet.\n   Constrained Application Protocol (CoAP) is\
    \ a specialized web transfer\n   protocol for use in constrained systems.  It\
    \ is defined in [RFC7252].\n   Authenticated Encryption (AE) [RFC5116] algorithms\
    \ are those\n   encryption algorithms that provide an authentication check of\
    \ the\n   contents algorithm with the encryption service.\n   Authenticated Encryption\
    \ with Authenticated Data (AEAD) [RFC5116]\n   algorithms provide the same content\
    \ authentication service as AE\n   algorithms, but they additionally provide for\
    \ authentication of non-\n   encrypted data as well.\n"
- title: 2.  Basic COSE Structure
  contents:
  - "2.  Basic COSE Structure\n   The COSE object structure is designed so that there\
    \ can be a large\n   amount of common code when parsing and processing the different\
    \ types\n   of security messages.  All of the message structures are built on\
    \ the\n   CBOR array type.  The first three elements of the array always\n   contain\
    \ the same information:\n   1.  The set of protected header parameters wrapped\
    \ in a bstr.\n   2.  The set of unprotected header parameters as a map.\n   3.\
    \  The content of the message.  The content is either the plaintext\n       or\
    \ the ciphertext as appropriate.  The content may be detached,\n       but the\
    \ location is still used.  The content is wrapped in a bstr\n       when present\
    \ and is a nil value when detached.\n   Elements after this point are dependent\
    \ on the specific message type.\n   COSE messages are also built using the concept\
    \ of layers to separate\n   different types of cryptographic concepts.  As an\
    \ example of how this\n   works, consider the COSE_Encrypt message (Section 5.1).\
    \  This message\n   type is broken into two layers: the content layer and the\
    \ recipient\n   layer.  In the content layer, the plaintext is encrypted and\n\
    \   information about the encrypted message is placed.  In the recipient\n   layer,\
    \ the content encryption key (CEK) is encrypted and information\n   about how\
    \ it is encrypted for each recipient is placed.  A single\n   layer version of\
    \ the encryption message COSE_Encrypt0 (Section 5.2)\n   is provided for cases\
    \ where the CEK is pre-shared.\n   Identification of which type of message has\
    \ been presented is done by\n   the following methods:\n   1.  The specific message\
    \ type is known from the context.  This may be\n       defined by a marker in\
    \ the containing structure or by\n       restrictions specified by the application\
    \ protocol.\n   2.  The message type is identified by a CBOR tag.  Messages with\
    \ a\n       CBOR tag are known in this specification as tagged messages,\n   \
    \    while those without the CBOR tag are known as untagged messages.\n      \
    \ This document defines a CBOR tag for each of the message\n       structures.\
    \  These tags can be found in Table 1.\n   3.  When a COSE object is carried in\
    \ a media type of 'application/\n       cose', the optional parameter 'cose-type'\
    \ can be used to identify\n       the embedded object.  The parameter is OPTIONAL\
    \ if the tagged\n       version of the structure is used.  The parameter is REQUIRED\
    \ if\n       the untagged version of the structure is used.  The value to use\n\
    \       with the parameter for each of the structures can be found in\n      \
    \ Table 1.\n   4.  When a COSE object is carried as a CoAP payload, the CoAP\n\
    \       Content-Format Option can be used to identify the message\n       content.\
    \  The CoAP Content-Format values can be found in\n       Table 26.  The CBOR\
    \ tag for the message structure is not required\n       as each security message\
    \ is uniquely identified.\n   +-------+---------------+---------------+---------------------------+\n\
    \   | CBOR  | cose-type     | Data Item     | Semantics                 |\n  \
    \ | Tag   |               |               |                           |\n   +-------+---------------+---------------+---------------------------+\n\
    \   | 98    | cose-sign     | COSE_Sign     | COSE Signed Data Object   |\n  \
    \ | 18    | cose-sign1    | COSE_Sign1    | COSE Single Signer Data   |\n   |\
    \       |               |               | Object                    |\n   | 96\
    \    | cose-encrypt  | COSE_Encrypt  | COSE Encrypted Data       |\n   |     \
    \  |               |               | Object                    |\n   | 16    |\
    \ cose-encrypt0 | COSE_Encrypt0 | COSE Single Recipient     |\n   |       |  \
    \             |               | Encrypted Data Object     |\n   | 97    | cose-mac\
    \      | COSE_Mac      | COSE MACed Data Object    |\n   | 17    | cose-mac0 \
    \    | COSE_Mac0     | COSE Mac w/o Recipients   |\n   |       |             \
    \  |               | Object                    |\n   +-------+---------------+---------------+---------------------------+\n\
    \                   Table 1: COSE Message Identification\n   The following CDDL\
    \ fragment identifies all of the top messages\n   defined in this document.  Separate\
    \ non-terminals are defined for the\n   tagged and the untagged versions of the\
    \ messages.\n   COSE_Messages = COSE_Untagged_Message / COSE_Tagged_Message\n\
    \   COSE_Untagged_Message = COSE_Sign / COSE_Sign1 /\n       COSE_Encrypt / COSE_Encrypt0\
    \ /\n       COSE_Mac / COSE_Mac0\n   COSE_Tagged_Message = COSE_Sign_Tagged /\
    \ COSE_Sign1_Tagged /\n       COSE_Encrypt_Tagged / COSE_Encrypt0_Tagged /\n \
    \      COSE_Mac_Tagged / COSE_Mac0_Tagged\n"
- title: 3.  Header Parameters
  contents:
  - "3.  Header Parameters\n   The structure of COSE has been designed to have two\
    \ buckets of\n   information that are not considered to be part of the payload\
    \ itself,\n   but are used for holding information about content, algorithms,\
    \ keys,\n   or evaluation hints for the processing of the layer.  These two\n\
    \   buckets are available for use in all of the structures except for\n   keys.\
    \  While these buckets are present, they may not all be usable in\n   all instances.\
    \  For example, while the protected bucket is defined as\n   part of the recipient\
    \ structure, some of the algorithms used for\n   recipient structures do not provide\
    \ for authenticated data.  If this\n   is the case, the protected bucket is left\
    \ empty.\n   Both buckets are implemented as CBOR maps.  The map key is a 'label'\n\
    \   (Section 1.4).  The value portion is dependent on the definition for\n   the\
    \ label.  Both maps use the same set of label/value pairs.  The\n   integer and\
    \ string values for labels have been divided into several\n   sections including\
    \ a standard range, a private range, and a range\n   that is dependent on the\
    \ algorithm selected.  The defined labels can\n   be found in the \"COSE Header\
    \ Parameters\" IANA registry\n   (Section 16.2).\n   Two buckets are provided\
    \ for each layer:\n   protected:  Contains parameters about the current layer\
    \ that are to\n      be cryptographically protected.  This bucket MUST be empty\
    \ if it\n      is not going to be included in a cryptographic computation.  This\n\
    \      bucket is encoded in the message as a binary object.  This value\n    \
    \  is obtained by CBOR encoding the protected map and wrapping it in\n      a\
    \ bstr object.  Senders SHOULD encode a zero-length map as a zero-\n      length\
    \ string rather than as a zero-length map (encoded as h'a0').\n      The zero-length\
    \ binary encoding is preferred because it is both\n      shorter and the version\
    \ used in the serialization structures for\n      cryptographic computation. \
    \ After encoding the map, the value is\n      wrapped in the binary object.  Recipients\
    \ MUST accept both a zero-\n      length binary value and a zero-length map encoded\
    \ in the binary\n      value.  The wrapping allows for the encoding of the protected\
    \ map\n      to be transported with a greater chance that it will not be\n   \
    \   altered in transit.  (Badly behaved intermediates could decode and\n     \
    \ re-encode, but this will result in a failure to verify unless the\n      re-encoded\
    \ byte string is identical to the decoded byte string.)\n      This avoids the\
    \ problem of all parties needing to be able to do a\n      common canonical encoding.\n\
    \   unprotected:  Contains parameters about the current layer that are\n     \
    \ not cryptographically protected.\n   Only parameters that deal with the current\
    \ layer are to be placed at\n   that layer.  As an example of this, the parameter\
    \ 'content type'\n   describes the content of the message being carried in the\
    \ message.\n   As such, this parameter is placed only in the content layer and\
    \ is\n   not placed in the recipient or signature layers.  In principle, one\n\
    \   should be able to process any given layer without reference to any\n   other\
    \ layer.  With the exception of the COSE_Sign structure, the only\n   data that\
    \ needs to cross layers is the cryptographic key.\n   The buckets are present\
    \ in all of the security objects defined in\n   this document.  The fields in\
    \ order are the 'protected' bucket (as a\n   CBOR 'bstr' type) and then the 'unprotected'\
    \ bucket (as a CBOR 'map'\n   type).  The presence of both buckets is required.\
    \  The parameters\n   that go into the buckets come from the IANA \"COSE Header\
    \ Parameters\"\n   registry (Section 16.2).  Some common parameters are defined\
    \ in the\n   next section, but a number of parameters are defined throughout this\n\
    \   document.\n   Labels in each of the maps MUST be unique.  When processing\
    \ messages,\n   if a label appears multiple times, the message MUST be rejected\
    \ as\n   malformed.  Applications SHOULD verify that the same label does not\n\
    \   occur in both the protected and unprotected headers.  If the message\n   is\
    \ not rejected as malformed, attributes MUST be obtained from the\n   protected\
    \ bucket before they are obtained from the unprotected\n   bucket.\n   The following\
    \ CDDL fragment represents the two header buckets.  A\n   group \"Headers\" is\
    \ defined in CDDL that represents the two buckets in\n   which attributes are\
    \ placed.  This group is used to provide these two\n   fields consistently in\
    \ all locations.  A type is also defined that\n   represents the map of common\
    \ headers.\n   Headers = (\n       protected : empty_or_serialized_map,\n    \
    \   unprotected : header_map\n   )\n   header_map = {\n       Generic_Headers,\n\
    \       * label => values\n   }\n   empty_or_serialized_map = bstr .cbor header_map\
    \ / bstr .size 0\n"
- title: 3.1.  Common COSE Headers Parameters
  contents:
  - "3.1.  Common COSE Headers Parameters\n   This section defines a set of common\
    \ header parameters.  A summary of\n   these parameters can be found in Table\
    \ 2.  This table should be\n   consulted to determine the value of label and the\
    \ type of the value.\n   The set of header parameters defined in this section\
    \ are:\n   alg:  This parameter is used to indicate the algorithm used for the\n\
    \      security processing.  This parameter MUST be authenticated where\n    \
    \  the ability to do so exists.  This support is provided by AEAD\n      algorithms\
    \ or construction (COSE_Sign, COSE_Sign0, COSE_Mac, and\n      COSE_Mac0).  This\
    \ authentication can be done either by placing the\n      header in the protected\
    \ header bucket or as part of the externally\n      supplied data.  The value\
    \ is taken from the \"COSE Algorithms\"\n      registry (see Section 16.4).\n\
    \   crit:  The parameter is used to indicate which protected header\n      labels\
    \ an application that is processing a message is required to\n      understand.\
    \  Parameters defined in this document do not need to be\n      included as they\
    \ should be understood by all implementations.\n      When present, this parameter\
    \ MUST be placed in the protected\n      header bucket.  The array MUST have at\
    \ least one value in it.\n      Not all labels need to be included in the 'crit'\
    \ parameter.  The\n      rules for deciding which header labels are placed in\
    \ the array\n      are:\n      *  Integer labels in the range of 0 to 8 SHOULD\
    \ be omitted.\n      *  Integer labels in the range -1 to -128 can be omitted\
    \ as they\n         are algorithm dependent.  If an application can correctly\n\
    \         process an algorithm, it can be assumed that it will correctly\n   \
    \      process all of the common parameters associated with that\n         algorithm.\
    \  Integer labels in the range -129 to -65536 SHOULD\n         be included as\
    \ these would be less common parameters that might\n         not be generally\
    \ supported.\n      *  Labels for parameters required for an application MAY be\n\
    \         omitted.  Applications should have a statement if the label can\n  \
    \       be omitted.\n      The header parameter values indicated by 'crit' can\
    \ be processed\n      by either the security library code or an application using\
    \ a\n      security library; the only requirement is that the parameter is\n \
    \     processed.  If the 'crit' value list includes a value for which\n      the\
    \ parameter is not in the protected bucket, this is a fatal\n      error in processing\
    \ the message.\n   content type:  This parameter is used to indicate the content\
    \ type of\n      the data in the payload or ciphertext fields.  Integers are from\n\
    \      the \"CoAP Content-Formats\" IANA registry table [COAP.Formats].\n    \
    \  Text values following the syntax of \"<type-name>/<subtype-name>\"\n      where\
    \ <type-name> and <subtype-name> are defined in Section 4.2 of\n      [RFC6838].\
    \  Leading and trailing whitespace is also omitted.\n      Textual content values\
    \ along with parameters and subparameters can\n      be located using the IANA\
    \ \"Media Types\" registry.  Applications\n      SHOULD provide this parameter\
    \ if the content structure is\n      potentially ambiguous.\n   kid:  This parameter\
    \ identifies one piece of data that can be used as\n      input to find the needed\
    \ cryptographic key.  The value of this\n      parameter can be matched against\
    \ the 'kid' member in a COSE_Key\n      structure.  Other methods of key distribution\
    \ can define an\n      equivalent field to be matched.  Applications MUST NOT\
    \ assume that\n      'kid' values are unique.  There may be more than one key\
    \ with the\n      same 'kid' value, so all of the keys associated with this 'kid'\n\
    \      may need to be checked.  The internal structure of 'kid' values is\n  \
    \    not defined and cannot be relied on by applications.  Key\n      identifier\
    \ values are hints about which key to use.  This is not a\n      security-critical\
    \ field.  For this reason, it can be placed in the\n      unprotected headers\
    \ bucket.\n   IV:  This parameter holds the Initialization Vector (IV) value.\
    \  For\n      some symmetric encryption algorithms, this may be referred to as\
    \ a\n      nonce.  The IV can be placed in the unprotected header as\n      modifying\
    \ the IV will cause the decryption to yield plaintext that\n      is readily detectable\
    \ as garbled.\n   Partial IV:  This parameter holds a part of the IV value.  When\
    \ using\n      the COSE_Encrypt0 structure, a portion of the IV can be part of\n\
    \      the context associated with the key.  This field is used to carry\n   \
    \   a value that causes the IV to be changed for each message.  The IV\n     \
    \ can be placed in the unprotected header as modifying the IV will\n      cause\
    \ the decryption to yield plaintext that is readily detectable\n      as garbled.\
    \  The 'Initialization Vector' and 'Partial\n      Initialization Vector' parameters\
    \ MUST NOT both be present in the\n      same security layer.\n      The message\
    \ IV is generated by the following steps:\n      1.  Left-pad the Partial IV with\
    \ zeros to the length of IV.\n      2.  XOR the padded Partial IV with the context\
    \ IV.\n   counter signature:  This parameter holds one or more counter\n     \
    \ signature values.  Counter signatures provide a method of having a\n      second\
    \ party sign some data.  The counter signature parameter can\n      occur as an\
    \ unprotected attribute in any of the following\n      structures: COSE_Sign1,\
    \ COSE_Signature, COSE_Encrypt,\n      COSE_recipient, COSE_Encrypt0, COSE_Mac,\
    \ and COSE_Mac0.  These\n      structures all have the same beginning elements,\
    \ so that a\n      consistent calculation of the counter signature can be computed.\n\
    \      Details on computing counter signatures are found in Section 4.5.\n   +-----------+-------+----------------+-------------+----------------+\n\
    \   | Name      | Label | Value Type     | Value       | Description    |\n  \
    \ |           |       |                | Registry    |                |\n   +-----------+-------+----------------+-------------+----------------+\n\
    \   | alg       | 1     | int / tstr     | COSE        | Cryptographic  |\n  \
    \ |           |       |                | Algorithms  | algorithm to   |\n   |\
    \           |       |                | registry    | use            |\n   | crit\
    \      | 2     | [+ label]      | COSE Header | Critical       |\n   |       \
    \    |       |                | Parameters  | headers to be  |\n   |         \
    \  |       |                | registry    | understood     |\n   | content   |\
    \ 3     | tstr / uint    | CoAP        | Content type   |\n   | type      |  \
    \     |                | Content-    | of the payload |\n   |           |    \
    \   |                | Formats or  |                |\n   |           |      \
    \ |                | Media Types |                |\n   |           |       |\
    \                | registries  |                |\n   | kid       | 4     | bstr\
    \           |             | Key identifier |\n   | IV        | 5     | bstr  \
    \         |             | Full           |\n   |           |       |         \
    \       |             | Initialization |\n   |           |       |           \
    \     |             | Vector         |\n   | Partial   | 6     | bstr        \
    \   |             | Partial        |\n   | IV        |       |               \
    \ |             | Initialization |\n   |           |       |                |\
    \             | Vector         |\n   | counter   | 7     | COSE_Signature |  \
    \           | CBOR-encoded   |\n   | signature |       | / [+           |    \
    \         | signature      |\n   |           |       | COSE_Signature |      \
    \       | structure      |\n   |           |       | ]              |        \
    \     |                |\n   +-----------+-------+----------------+-------------+----------------+\n\
    \                     Table 2: Common Header Parameters\n   The CDDL fragment\
    \ that represents the set of headers defined in this\n   section is given below.\
    \  Each of the headers is tagged as optional\n   because they do not need to be\
    \ in every map; headers required in\n   specific maps are discussed above.\n \
    \  Generic_Headers = (\n       ? 1 => int / tstr,  ; algorithm identifier\n  \
    \     ? 2 => [+label],    ; criticality\n       ? 3 => tstr / int,  ; content\
    \ type\n       ? 4 => bstr,        ; key identifier\n       ? 5 => bstr,     \
    \   ; IV\n       ? 6 => bstr,        ; Partial IV\n       ? 7 => COSE_Signature\
    \ / [+COSE_Signature] ; Counter signature\n   )\n"
- title: 4.  Signing Objects
  contents:
  - "4.  Signing Objects\n   COSE supports two different signature structures.  COSE_Sign\
    \ allows\n   for one or more signatures to be applied to the same content.\n \
    \  COSE_Sign1 is restricted to a single signer.  The structures cannot\n   be\
    \ converted between each other; as the signature computation\n   includes a parameter\
    \ identifying which structure is being used, the\n   converted structure will\
    \ fail signature validation.\n"
- title: 4.1.  Signing with One or More Signers
  contents:
  - "4.1.  Signing with One or More Signers\n   The COSE_Sign structure allows for\
    \ one or more signatures to be\n   applied to a message payload.  Parameters relating\
    \ to the content and\n   parameters relating to the signature are carried along\
    \ with the\n   signature itself.  These parameters may be authenticated by the\n\
    \   signature, or just present.  An example of a parameter about the\n   content\
    \ is the content type.  Examples of parameters about the\n   signature would be\
    \ the algorithm and key used to create the signature\n   and counter signatures.\n\
    \   RFC 5652 indicates that:\n      When more than one signature is present, the\
    \ successful validation\n      of one signature associated with a given signer\
    \ is usually treated\n      as a successful signature by that signer.  However,\
    \ there are some\n      application environments where other rules are needed.\
    \  An\n      application that employs a rule other than one valid signature for\n\
    \      each signer must specify those rules.  Also, where simple matching\n  \
    \    of the signer identifier is not sufficient to determine whether\n      the\
    \ signatures were generated by the same signer, the application\n      specification\
    \ must describe how to determine which signatures were\n      generated by the\
    \ same signer.  Support for different communities\n      of recipients is the\
    \ primary reason that signers choose to include\n      more than one signature.\n\
    \   For example, the COSE_Sign structure might include signatures\n   generated\
    \ with the Edwards-curve Digital Signature Algorithm (EdDSA)\n   [RFC8032] and\
    \ with the Elliptic Curve Digital Signature Algorithm\n   (ECDSA) [DSS].  This\
    \ allows recipients to verify the signature\n   associated with one algorithm\
    \ or the other.  More-detailed\n   information on multiple signature evaluations\
    \ can be found in\n   [RFC5752].\n   The signature structure can be encoded as\
    \ either tagged or untagged\n   depending on the context it will be used in. \
    \ A tagged COSE_Sign\n   structure is identified by the CBOR tag 98.  The CDDL\
    \ fragment that\n   represents this is:\n   COSE_Sign_Tagged = #6.98(COSE_Sign)\n\
    \   A COSE Signed Message is defined in two parts.  The CBOR object that\n   carries\
    \ the body and information about the body is called the\n   COSE_Sign structure.\
    \  The CBOR object that carries the signature and\n   information about the signature\
    \ is called the COSE_Signature\n   structure.  Examples of COSE Signed Messages\
    \ can be found in\n   Appendix C.1.\n   The COSE_Sign structure is a CBOR array.\
    \  The fields of the array in\n   order are:\n   protected:  This is as described\
    \ in Section 3.\n   unprotected:  This is as described in Section 3.\n   payload:\
    \  This field contains the serialized content to be signed.\n      If the payload\
    \ is not present in the message, the application is\n      required to supply\
    \ the payload separately.  The payload is wrapped\n      in a bstr to ensure that\
    \ it is transported without changes.  If\n      the payload is transported separately\
    \ (\"detached content\"), then a\n      nil CBOR object is placed in this location,\
    \ and it is the\n      responsibility of the application to ensure that it will\
    \ be\n      transported without changes.\n      Note: When a signature with a\
    \ message recovery algorithm is used\n      (Section 8), the maximum number of\
    \ bytes that can be recovered is\n      the length of the payload.  The size of\
    \ the payload is reduced by\n      the number of bytes that will be recovered.\
    \  If all of the bytes\n      of the payload are consumed, then the payload is\
    \ encoded as a\n      zero-length binary string rather than as being absent.\n\
    \   signatures:  This field is an array of signatures.  Each signature is\n  \
    \    represented as a COSE_Signature structure.\n   The CDDL fragment that represents\
    \ the above text for COSE_Sign\n   follows.\n   COSE_Sign = [\n       Headers,\n\
    \       payload : bstr / nil,\n       signatures : [+ COSE_Signature]\n   ]\n\
    \   The COSE_Signature structure is a CBOR array.  The fields of the\n   array\
    \ in order are:\n   protected:  This is as described in Section 3.\n   unprotected:\
    \  This is as described in Section 3.\n   signature:  This field contains the\
    \ computed signature value.  The\n      type of the field is a bstr.  Algorithms\
    \ MUST specify padding if\n      the signature value is not a multiple of 8 bits.\n\
    \   The CDDL fragment that represents the above text for COSE_Signature\n   follows.\n\
    \   COSE_Signature =  [\n       Headers,\n       signature : bstr\n   ]\n"
- title: 4.2.  Signing with One Signer
  contents:
  - "4.2.  Signing with One Signer\n   The COSE_Sign1 signature structure is used\
    \ when only one signature is\n   going to be placed on a message.  The parameters\
    \ dealing with the\n   content and the signature are placed in the same pair of\
    \ buckets\n   rather than having the separation of COSE_Sign.\n   The structure\
    \ can be encoded as either tagged or untagged depending\n   on the context it\
    \ will be used in.  A tagged COSE_Sign1 structure is\n   identified by the CBOR\
    \ tag 18.  The CDDL fragment that represents\n   this is:\n   COSE_Sign1_Tagged\
    \ = #6.18(COSE_Sign1)\n   The CBOR object that carries the body, the signature,\
    \ and the\n   information about the body and signature is called the COSE_Sign1\n\
    \   structure.  Examples of COSE_Sign1 messages can be found in\n   Appendix C.2.\n\
    \   The COSE_Sign1 structure is a CBOR array.  The fields of the array in\n  \
    \ order are:\n   protected:  This is as described in Section 3.\n   unprotected:\
    \  This is as described in Section 3.\n   payload:  This is as described in Section\
    \ 4.1.\n   signature:  This field contains the computed signature value.  The\n\
    \      type of the field is a bstr.\n   The CDDL fragment that represents the\
    \ above text for COSE_Sign1\n   follows.\n   COSE_Sign1 = [\n       Headers,\n\
    \       payload : bstr / nil,\n       signature : bstr\n   ]\n"
- title: 4.3.  Externally Supplied Data
  contents:
  - "4.3.  Externally Supplied Data\n   One of the features offered in the COSE document\
    \ is the ability for\n   applications to provide additional data to be authenticated,\
    \ but that\n   is not carried as part of the COSE object.  The primary reason\
    \ for\n   supporting this can be seen by looking at the CoAP message structure\n\
    \   [RFC7252], where the facility exists for options to be carried before\n  \
    \ the payload.  Examples of data that can be placed in this location\n   would\
    \ be the CoAP code or CoAP options.  If the data is in the header\n   section,\
    \ then it is available for proxies to help in performing its\n   operations. \
    \ For example, the Accept Option can be used by a proxy to\n   determine if an\
    \ appropriate value is in the proxy's cache.  But the\n   sender can prevent a\
    \ proxy from changing the set of values that it\n   will accept by including that\
    \ value in the resulting authentication\n   tag.  However, it may also be desired\
    \ to protect these values so that\n   if they are modified in transit, it can\
    \ be detected.\n   This document describes the process for using a byte array\
    \ of\n   externally supplied authenticated data; however, the method of\n   constructing\
    \ the byte array is a function of the application.\n   Applications that use this\
    \ feature need to define how the externally\n   supplied authenticated data is\
    \ to be constructed.  Such a\n   construction needs to take into account the following\
    \ issues:\n   o  If multiple items are included, applications need to ensure that\n\
    \      the same byte string is not produced if there are different\n      inputs.\
    \  This could occur by appending the strings 'AB' and 'CDE'\n      or by appending\
    \ the strings 'ABC' and 'DE'.  This is usually\n      addressed by making fields\
    \ a fixed width and/or encoding the\n      length of the field as part of the\
    \ output.  Using options from\n      CoAP [RFC7252] as an example, these fields\
    \ use a TLV structure so\n      they can be concatenated without any problems.\n\
    \   o  If multiple items are included, an order for the items needs to be\n  \
    \    defined.  Using options from CoAP as an example, an application\n      could\
    \ state that the fields are to be ordered by the option\n      number.\n   o \
    \ Applications need to ensure that the byte stream is going to be\n      the same\
    \ on both sides.  Using options from CoAP might give a\n      problem if the same\
    \ relative numbering is kept.  An intermediate\n      node could insert or remove\
    \ an option, changing how the relative\n      number is done.  An application\
    \ would need to specify that the\n      relative number must be re-encoded to\
    \ be relative only to the\n      options that are in the external data.\n"
- title: 4.4.  Signing and Verification Process
  contents:
  - "4.4.  Signing and Verification Process\n   In order to create a signature, a\
    \ well-defined byte stream is needed.\n   The Sig_structure is used to create\
    \ the canonical form.  This signing\n   and verification process takes in the\
    \ body information (COSE_Sign or\n   COSE_Sign1), the signer information (COSE_Signature),\
    \ and the\n   application data (external source).  A Sig_structure is a CBOR array.\n\
    \   The fields of the Sig_structure in order are:\n   1.  A text string identifying\
    \ the context of the signature.  The\n       context string is:\n          \"\
    Signature\" for signatures using the COSE_Signature structure.\n          \"Signature1\"\
    \ for signatures using the COSE_Sign1 structure.\n          \"CounterSignature\"\
    \ for signatures used as counter signature\n          attributes.\n   2.  The\
    \ protected attributes from the body structure encoded in a\n       bstr type.\
    \  If there are no protected attributes, a bstr of\n       length zero is used.\n\
    \   3.  The protected attributes from the signer structure encoded in a\n    \
    \   bstr type.  If there are no protected attributes, a bstr of\n       length\
    \ zero is used.  This field is omitted for the COSE_Sign1\n       signature structure.\n\
    \   4.  The protected attributes from the application encoded in a bstr\n    \
    \   type.  If this field is not supplied, it defaults to a zero-\n       length\
    \ binary string.  (See Section 4.3 for application guidance\n       on constructing\
    \ this field.)\n   5.  The payload to be signed encoded in a bstr type.  The payload\
    \ is\n       placed here independent of how it is transported.\n   The CDDL fragment\
    \ that describes the above text is:\n   Sig_structure = [\n       context : \"\
    Signature\" / \"Signature1\" / \"CounterSignature\",\n       body_protected :\
    \ empty_or_serialized_map,\n       ? sign_protected : empty_or_serialized_map,\n\
    \       external_aad : bstr,\n       payload : bstr\n   ]\n   How to compute a\
    \ signature:\n   1.  Create a Sig_structure and populate it with the appropriate\n\
    \       fields.\n   2.  Create the value ToBeSigned by encoding the Sig_structure\
    \ to a\n       byte string, using the encoding described in Section 14.\n   3.\
    \  Call the signature creation algorithm passing in K (the key to\n       sign\
    \ with), alg (the algorithm to sign with), and ToBeSigned (the\n       value to\
    \ sign).\n   4.  Place the resulting signature value in the 'signature' field\
    \ of\n       the array.\n   The steps for verifying a signature are:\n   1.  Create\
    \ a Sig_structure object and populate it with the\n       appropriate fields.\n\
    \   2.  Create the value ToBeSigned by encoding the Sig_structure to a\n     \
    \  byte string, using the encoding described in Section 14.\n   3.  Call the signature\
    \ verification algorithm passing in K (the key\n       to verify with), alg (the\
    \ algorithm used sign with), ToBeSigned\n       (the value to sign), and sig (the\
    \ signature to be verified).\n   In addition to performing the signature verification,\
    \ the application\n   may also perform the appropriate checks to ensure that the\
    \ key is\n   correctly paired with the signing identity and that the signing\n\
    \   identity is authorized before performing actions.\n"
- title: 4.5.  Computing Counter Signatures
  contents:
  - "4.5.  Computing Counter Signatures\n   Counter signatures provide a method of\
    \ associating a different\n   signature generated by different signers with some\
    \ piece of content.\n   This is normally used to provide a signature on a signature\
    \ allowing\n   for a proof that a signature existed at a given time (i.e., a\n\
    \   Timestamp).  In this document, we allow for counter signatures to\n   exist\
    \ in a greater number of environments.  As an example, it is\n   possible to place\
    \ a counter signature in the unprotected attributes\n   of a COSE_Encrypt object.\
    \  This would allow for an intermediary to\n   either verify that the encrypted\
    \ byte stream has not been modified,\n   without being able to decrypt it, or\
    \ assert that an encrypted byte\n   stream either existed at a given time or passed\
    \ through it in terms\n   of routing (i.e., a proxy signature).\n   An example\
    \ of a counter signature on a signature can be found in\n   Appendix C.1.3.  An\
    \ example of a counter signature in an encryption\n   object can be found in Appendix\
    \ C.3.3.\n   The creation and validation of counter signatures over the different\n\
    \   items relies on the fact that the objects have the same structure.\n   The\
    \ elements are a set of protected attributes, a set of unprotected\n   attributes,\
    \ and a body, in that order.  This means that the\n   Sig_structure can be used\
    \ in a uniform manner to get the byte stream\n   for processing a signature. \
    \ If the counter signature is going to be\n   computed over a COSE_Encrypt structure,\
    \ the body_protected and\n   payload items can be mapped into the Sig_structure\
    \ in the same manner\n   as from the COSE_Sign structure.\n   It should be noted\
    \ that only a signature algorithm with appendix (see\n   Section 8) can be used\
    \ for counter signatures.  This is because the\n   body should be able to be processed\
    \ without having to evaluate the\n   counter signature, and this is not possible\
    \ for signature schemes\n   with message recovery.\n"
- title: 5.  Encryption Objects
  contents:
  - "5.  Encryption Objects\n   COSE supports two different encryption structures.\
    \  COSE_Encrypt0 is\n   used when a recipient structure is not needed because\
    \ the key to be\n   used is known implicitly.  COSE_Encrypt is used the rest of\
    \ the time.\n   This includes cases where there are multiple recipients or a\n\
    \   recipient algorithm other than direct is used.\n"
- title: 5.1.  Enveloped COSE Structure
  contents:
  - "5.1.  Enveloped COSE Structure\n   The enveloped structure allows for one or\
    \ more recipients of a\n   message.  There are provisions for parameters about\
    \ the content and\n   parameters about the recipient information to be carried\
    \ in the\n   message.  The protected parameters associated with the content are\n\
    \   authenticated by the content encryption algorithm.  The protected\n   parameters\
    \ associated with the recipient are authenticated by the\n   recipient algorithm\
    \ (when the algorithm supports it).  Examples of\n   parameters about the content\
    \ are the type of the content and the\n   content encryption algorithm.  Examples\
    \ of parameters about the\n   recipient are the recipient's key identifier and\
    \ the recipient's\n   encryption algorithm.\n   The same techniques and structures\
    \ are used for encrypting both the\n   plaintext and the keys.  This is different\
    \ from the approach used by\n   both \"Cryptographic Message Syntax (CMS)\" [RFC5652]\
    \ and \"JSON Web\n   Encryption (JWE)\" [RFC7516] where different structures are\
    \ used for\n   the content layer and for the recipient layer.  Two structures\
    \ are\n   defined: COSE_Encrypt to hold the encrypted content and\n   COSE_recipient\
    \ to hold the encrypted keys for recipients.  Examples\n   of encrypted messages\
    \ can be found in Appendix C.3.\n   The COSE_Encrypt structure can be encoded\
    \ as either tagged or\n   untagged depending on the context it will be used in.\
    \  A tagged\n   COSE_Encrypt structure is identified by the CBOR tag 96.  The\
    \ CDDL\n   fragment that represents this is:\n   COSE_Encrypt_Tagged = #6.96(COSE_Encrypt)\n\
    \   The COSE_Encrypt structure is a CBOR array.  The fields of the array\n   in\
    \ order are:\n   protected:  This is as described in Section 3.\n   unprotected:\
    \  This is as described in Section 3.\n   ciphertext:  This field contains the\
    \ ciphertext encoded as a bstr.\n      If the ciphertext is to be transported\
    \ independently of the\n      control information about the encryption process\
    \ (i.e., detached\n      content), then the field is encoded as a nil value.\n\
    \   recipients:  This field contains an array of recipient information\n     \
    \ structures.  The type for the recipient information structure is a\n      COSE_recipient.\n\
    \   The CDDL fragment that corresponds to the above text is:\n   COSE_Encrypt\
    \ = [\n       Headers,\n       ciphertext : bstr / nil,\n       recipients : [+COSE_recipient]\n\
    \   ]\n   The COSE_recipient structure is a CBOR array.  The fields of the\n \
    \  array in order are:\n   protected:  This is as described in Section 3.\n  \
    \ unprotected:  This is as described in Section 3.\n   ciphertext:  This field\
    \ contains the encrypted key encoded as a bstr.\n      All encoded keys are symmetric\
    \ keys; the binary value of the key\n      is the content.  If there is not an\
    \ encrypted key, then this field\n      is encoded as a nil value.\n   recipients:\
    \  This field contains an array of recipient information\n      structures.  The\
    \ type for the recipient information structure is a\n      COSE_recipient (an\
    \ example of this can be found in Appendix B).\n      If there are no recipient\
    \ information structures, this element is\n      absent.\n   The CDDL fragment\
    \ that corresponds to the above text for\n   COSE_recipient is:\n   COSE_recipient\
    \ = [\n       Headers,\n       ciphertext : bstr / nil,\n       ? recipients :\
    \ [+COSE_recipient]\n   ]\n"
- title: 5.1.1.  Content Key Distribution Methods
  contents:
  - "5.1.1.  Content Key Distribution Methods\n   An encrypted message consists of\
    \ an encrypted content and an\n   encrypted CEK for one or more recipients.  The\
    \ CEK is encrypted for\n   each recipient, using a key specific to that recipient.\
    \  The details\n   of this encryption depend on which class the recipient algorithm\n\
    \   falls into.  Specific details on each of the classes can be found in\n   Section\
    \ 12.  A short summary of the five content key distribution\n   methods is:\n\
    \   direct:  The CEK is the same as the identified previously distributed\n  \
    \    symmetric key or is derived from a previously distributed secret.\n     \
    \ No CEK is transported in the message.\n   symmetric key-encryption keys (KEK):\
    \  The CEK is encrypted using a\n      previously distributed symmetric KEK. \
    \ Also known as key wrap.\n   key agreement:  The recipient's public key and a\
    \ sender's private key\n      are used to generate a pairwise secret, a Key Derivation\
    \ Function\n      (KDF) is applied to derive a key, and then the CEK is either\
    \ the\n      derived key or encrypted by the derived key.\n   key transport: \
    \ The CEK is encrypted with the recipient's public key.\n      No key transport\
    \ algorithms are defined in this document.\n   passwords:  The CEK is encrypted\
    \ in a KEK that is derived from a\n      password.  No password algorithms are\
    \ defined in this document.\n"
- title: 5.2.  Single Recipient Encrypted
  contents:
  - "5.2.  Single Recipient Encrypted\n   The COSE_Encrypt0 encrypted structure does\
    \ not have the ability to\n   specify recipients of the message.  The structure\
    \ assumes that the\n   recipient of the object will already know the identity\
    \ of the key to\n   be used in order to decrypt the message.  If a key needs to\
    \ be\n   identified to the recipient, the enveloped structure ought to be\n  \
    \ used.\n   Examples of encrypted messages can be found in Appendix C.3.\n   The\
    \ COSE_Encrypt0 structure can be encoded as either tagged or\n   untagged depending\
    \ on the context it will be used in.  A tagged\n   COSE_Encrypt0 structure is\
    \ identified by the CBOR tag 16.  The CDDL\n   fragment that represents this is:\n\
    \   COSE_Encrypt0_Tagged = #6.16(COSE_Encrypt0)\n   The COSE_Encrypt0 structure\
    \ is a CBOR array.  The fields of the array\n   in order are:\n   protected: \
    \ This is as described in Section 3.\n   unprotected:  This is as described in\
    \ Section 3.\n   ciphertext:  This is as described in Section 5.1.\n   The CDDL\
    \ fragment for COSE_Encrypt0 that corresponds to the above\n   text is:\n   COSE_Encrypt0\
    \ = [\n       Headers,\n       ciphertext : bstr / nil,\n   ]\n"
- title: 5.3.  How to Encrypt and Decrypt for AEAD Algorithms
  contents:
  - "5.3.  How to Encrypt and Decrypt for AEAD Algorithms\n   The encryption algorithm\
    \ for AEAD algorithms is fairly simple.  The\n   first step is to create a consistent\
    \ byte stream for the\n   authenticated data structure.  For this purpose, we\
    \ use an\n   Enc_structure.  The Enc_structure is a CBOR array.  The fields of\
    \ the\n   Enc_structure in order are:\n   1.  A text string identifying the context\
    \ of the authenticated data\n       structure.  The context string is:\n     \
    \     \"Encrypt0\" for the content encryption of a COSE_Encrypt0 data\n      \
    \    structure.\n          \"Encrypt\" for the first layer of a COSE_Encrypt data\
    \ structure\n          (i.e., for content encryption).\n          \"Enc_Recipient\"\
    \ for a recipient encoding to be placed in an\n          COSE_Encrypt data structure.\n\
    \          \"Mac_Recipient\" for a recipient encoding to be placed in a\n    \
    \      MACed message structure.\n          \"Rec_Recipient\" for a recipient encoding\
    \ to be placed in a\n          recipient structure.\n   2.  The protected attributes\
    \ from the body structure encoded in a\n       bstr type.  If there are no protected\
    \ attributes, a bstr of\n       length zero is used.\n   3.  The protected attributes\
    \ from the application encoded in a bstr\n       type.  If this field is not supplied,\
    \ it defaults to a zero-\n       length bstr.  (See Section 4.3 for application\
    \ guidance on\n       constructing this field.)\n   The CDDL fragment that describes\
    \ the above text is:\n   Enc_structure = [\n       context : \"Encrypt\" / \"\
    Encrypt0\" / \"Enc_Recipient\" /\n           \"Mac_Recipient\" / \"Rec_Recipient\"\
    ,\n       protected : empty_or_serialized_map,\n       external_aad : bstr\n \
    \  ]\n   How to encrypt a message:\n   1.  Create an Enc_structure and populate\
    \ it with the appropriate\n       fields.\n   2.  Encode the Enc_structure to\
    \ a byte stream (Additional\n       Authenticated Data (AAD)), using the encoding\
    \ described in\n       Section 14.\n   3.  Determine the encryption key (K). \
    \ This step is dependent on the\n       class of recipient algorithm being used.\
    \  For:\n       No Recipients:  The key to be used is determined by the algorithm\n\
    \          and key at the current layer.  Examples are key transport keys\n  \
    \        (Section 12.3), key wrap keys (Section 12.2.1), or pre-shared\n     \
    \     secrets.\n       Direct Encryption and Direct Key Agreement:  The key is\n\
    \          determined by the key and algorithm in the recipient\n          structure.\
    \  The encryption algorithm and size of the key to be\n          used are inputs\
    \ into the KDF used for the recipient.  (For\n          direct, the KDF can be\
    \ thought of as the identity operation.)\n          Examples of these algorithms\
    \ are found in Sections 12.1.2 and\n          12.4.1.\n       Other:  The key\
    \ is randomly or pseudorandomly generated.\n   4.  Call the encryption algorithm\
    \ with K (the encryption key), P (the\n       plaintext), and AAD.  Place the\
    \ returned ciphertext into the\n       'ciphertext' field of the structure.\n\
    \   5.  For recipients of the message, recursively perform the encryption\n  \
    \     algorithm for that recipient, using K (the encryption key) as the\n    \
    \   plaintext.\n   How to decrypt a message:\n   1.  Create an Enc_structure and\
    \ populate it with the appropriate\n       fields.\n   2.  Encode the Enc_structure\
    \ to a byte stream (AAD), using the\n       encoding described in Section 14.\n\
    \   3.  Determine the decryption key.  This step is dependent on the\n       class\
    \ of recipient algorithm being used.  For:\n       No Recipients:  The key to\
    \ be used is determined by the algorithm\n          and key at the current layer.\
    \  Examples are key transport keys\n          (Section 12.3), key wrap keys (Section\
    \ 12.2.1), or pre-shared\n          secrets.\n       Direct Encryption and Direct\
    \ Key Agreement:  The key is\n          determined by the key and algorithm in\
    \ the recipient\n          structure.  The encryption algorithm and size of the\
    \ key to be\n          used are inputs into the KDF used for the recipient.  (For\n\
    \          direct, the KDF can be thought of as the identity operation.)\n   \
    \       Examples of these algorithms are found in Sections 12.1.2 and\n      \
    \    12.4.1.\n       Other:  The key is determined by decoding and decrypting\
    \ one of\n          the recipient structures.\n   4.  Call the decryption algorithm\
    \ with K (the decryption key to use),\n       C (the ciphertext), and AAD.\n"
- title: 5.4.  How to Encrypt and Decrypt for AE Algorithms
  contents:
  - "5.4.  How to Encrypt and Decrypt for AE Algorithms\n   How to encrypt a message:\n\
    \   1.  Verify that the 'protected' field is empty.\n   2.  Verify that there\
    \ was no external additional authenticated data\n       supplied for this operation.\n\
    \   3.  Determine the encryption key.  This step is dependent on the\n       class\
    \ of recipient algorithm being used.  For:\n       No Recipients:  The key to\
    \ be used is determined by the algorithm\n          and key at the current layer.\
    \  Examples are key transport keys\n          (Section 12.3), key wrap keys (Section\
    \ 12.2.1), or pre-shared\n          secrets.\n       Direct Encryption and Direct\
    \ Key Agreement:  The key is\n          determined by the key and algorithm in\
    \ the recipient\n          structure.  The encryption algorithm and size of the\
    \ key to be\n          used are inputs into the KDF used for the recipient.  (For\n\
    \          direct, the KDF can be thought of as the identity operation.)\n   \
    \       Examples of these algorithms are found in Sections 12.1.2 and\n      \
    \    12.4.1.\n       Other:  The key is randomly generated.\n   4.  Call the encryption\
    \ algorithm with K (the encryption key to use)\n       and P (the plaintext).\
    \  Place the returned ciphertext into the\n       'ciphertext' field of the structure.\n\
    \   5.  For recipients of the message, recursively perform the encryption\n  \
    \     algorithm for that recipient, using K (the encryption key) as the\n    \
    \   plaintext.\n   How to decrypt a message:\n   1.  Verify that the 'protected'\
    \ field is empty.\n   2.  Verify that there was no external additional authenticated\
    \ data\n       supplied for this operation.\n   3.  Determine the decryption key.\
    \  This step is dependent on the\n       class of recipient algorithm being used.\
    \  For:\n       No Recipients:  The key to be used is determined by the algorithm\n\
    \          and key at the current layer.  Examples are key transport keys\n  \
    \        (Section 12.3), key wrap keys (Section 12.2.1), or pre-shared\n     \
    \     secrets.\n       Direct Encryption and Direct Key Agreement:  The key is\n\
    \          determined by the key and algorithm in the recipient\n          structure.\
    \  The encryption algorithm and size of the key to be\n          used are inputs\
    \ into the KDF used for the recipient.  (For\n          direct, the KDF can be\
    \ thought of as the identity operation.)\n          Examples of these algorithms\
    \ are found in Sections 12.1.2 and\n          12.4.1.\n       Other:  The key\
    \ is determined by decoding and decrypting one of\n          the recipient structures.\n\
    \   4.  Call the decryption algorithm with K (the decryption key to use)\n   \
    \    and C (the ciphertext).\n"
- title: 6.  MAC Objects
  contents:
  - "6.  MAC Objects\n   COSE supports two different MAC structures.  COSE_MAC0 is\
    \ used when a\n   recipient structure is not needed because the key to be used\
    \ is\n   implicitly known.  COSE_MAC is used for all other cases.  These\n   include\
    \ a requirement for multiple recipients, the key being unknown,\n   and a recipient\
    \ algorithm of other than direct.\n   In this section, we describe the structure\
    \ and methods to be used\n   when doing MAC authentication in COSE.  This document\
    \ allows for the\n   use of all of the same classes of recipient algorithms as\
    \ are allowed\n   for encryption.\n   When using MAC operations, there are two\
    \ modes in which they can be\n   used.  The first is just a check that the content\
    \ has not been\n   changed since the MAC was computed.  Any class of recipient\
    \ algorithm\n   can be used for this purpose.  The second mode is to both check\
    \ that\n   the content has not been changed since the MAC was computed and to\n\
    \   use the recipient algorithm to verify who sent it.  The classes of\n   recipient\
    \ algorithms that support this are those that use a pre-\n   shared secret or\
    \ do static-static (SS) key agreement (without the key\n   wrap step).  In both\
    \ of these cases, the entity that created and sent\n   the message MAC can be\
    \ validated.  (This knowledge of the sender\n   assumes that there are only two\
    \ parties involved and that you did not\n   send the message to yourself.)  The\
    \ origination property can be\n   obtained with both of the MAC message structures.\n"
- title: 6.1.  MACed Message with Recipients
  contents:
  - "6.1.  MACed Message with Recipients\n   The multiple recipient MACed message\
    \ uses two structures: the\n   COSE_Mac structure defined in this section for\
    \ carrying the body and\n   the COSE_recipient structure (Section 5.1) to hold\
    \ the key used for\n   the MAC computation.  Examples of MACed messages can be\
    \ found in\n   Appendix C.5.\n   The MAC structure can be encoded as either tagged\
    \ or untagged\n   depending on the context it will be used in.  A tagged COSE_Mac\n\
    \   structure is identified by the CBOR tag 97.  The CDDL fragment that\n   represents\
    \ this is:\n   COSE_Mac_Tagged = #6.97(COSE_Mac)\n   The COSE_Mac structure is\
    \ a CBOR array.  The fields of the array in\n   order are:\n   protected:  This\
    \ is as described in Section 3.\n   unprotected:  This is as described in Section\
    \ 3.\n   payload:  This field contains the serialized content to be MACed.  If\n\
    \      the payload is not present in the message, the application is\n      required\
    \ to supply the payload separately.  The payload is wrapped\n      in a bstr to\
    \ ensure that it is transported without changes.  If\n      the payload is transported\
    \ separately (i.e., detached content),\n      then a nil CBOR value is placed\
    \ in this location, and it is the\n      responsibility of the application to\
    \ ensure that it will be\n      transported without changes.\n   tag:  This field\
    \ contains the MAC value.\n   recipients:  This is as described in Section 5.1.\n\
    \   The CDDL fragment that represents the above text for COSE_Mac\n   follows.\n\
    \   COSE_Mac = [\n      Headers,\n      payload : bstr / nil,\n      tag : bstr,\n\
    \      recipients :[+COSE_recipient]\n   ]\n"
- title: 6.2.  MACed Messages with Implicit Key
  contents:
  - "6.2.  MACed Messages with Implicit Key\n   In this section, we describe the structure\
    \ and methods to be used\n   when doing MAC authentication for those cases where\
    \ the recipient is\n   implicitly known.\n   The MACed message uses the COSE_Mac0\
    \ structure defined in this\n   section for carrying the body.  Examples of MACed\
    \ messages with an\n   implicit key can be found in Appendix C.6.\n   The MAC\
    \ structure can be encoded as either tagged or untagged\n   depending on the context\
    \ it will be used in.  A tagged COSE_Mac0\n   structure is identified by the CBOR\
    \ tag 17.  The CDDL fragment that\n   represents this is:\n   COSE_Mac0_Tagged\
    \ = #6.17(COSE_Mac0)\n   The COSE_Mac0 structure is a CBOR array.  The fields\
    \ of the array in\n   order are:\n   protected:  This is as described in Section\
    \ 3.\n   unprotected:  This is as described in Section 3.\n   payload:  This is\
    \ as described in Section 6.1.\n   tag:  This field contains the MAC value.\n\
    \   The CDDL fragment that corresponds to the above text is:\n   COSE_Mac0 = [\n\
    \      Headers,\n      payload : bstr / nil,\n      tag : bstr,\n   ]\n"
- title: 6.3.  How to Compute and Verify a MAC
  contents:
  - "6.3.  How to Compute and Verify a MAC\n   In order to get a consistent encoding\
    \ of the data to be\n   authenticated, the MAC_structure is used to have a canonical\
    \ form.\n   The MAC_structure is a CBOR array.  The fields of the MAC_structure\n\
    \   in order are:\n   1.  A text string that identifies the structure that is\
    \ being\n       encoded.  This string is \"MAC\" for the COSE_Mac structure. \
    \ This\n       string is \"MAC0\" for the COSE_Mac0 structure.\n   2.  The protected\
    \ attributes from the COSE_MAC structure.  If there\n       are no protected attributes,\
    \ a zero-length bstr is used.\n   3.  The protected attributes from the application\
    \ encoded as a bstr\n       type.  If this field is not supplied, it defaults\
    \ to a zero-\n       length binary string.  (See Section 4.3 for application guidance\n\
    \       on constructing this field.)\n   4.  The payload to be MACed encoded in\
    \ a bstr type.  The payload is\n       placed here independent of how it is transported.\n\
    \   The CDDL fragment that corresponds to the above text is:\n   MAC_structure\
    \ = [\n        context : \"MAC\" / \"MAC0\",\n        protected : empty_or_serialized_map,\n\
    \        external_aad : bstr,\n        payload : bstr\n   ]\n   The steps to compute\
    \ a MAC are:\n   1.  Create a MAC_structure and populate it with the appropriate\n\
    \       fields.\n   2.  Create the value ToBeMaced by encoding the MAC_structure\
    \ to a\n       byte stream, using the encoding described in Section 14.\n   3.\
    \  Call the MAC creation algorithm passing in K (the key to use),\n       alg\
    \ (the algorithm to MAC with), and ToBeMaced (the value to\n       compute the\
    \ MAC on).\n   4.  Place the resulting MAC in the 'tag' field of the COSE_Mac\
    \ or\n       COSE_Mac0 structure.\n   5.  Encrypt and encode the MAC key for each\
    \ recipient of the message.\n   The steps to verify a MAC are:\n   1.  Create\
    \ a MAC_structure object and populate it with the\n       appropriate fields.\n\
    \   2.  Create the value ToBeMaced by encoding the MAC_structure to a\n      \
    \ byte stream, using the encoding described in Section 14.\n   3.  Obtain the\
    \ cryptographic key from one of the recipients of the\n       message.\n   4.\
    \  Call the MAC creation algorithm passing in K (the key to use),\n       alg\
    \ (the algorithm to MAC with), and ToBeMaced (the value to\n       compute the\
    \ MAC on).\n   5.  Compare the MAC value to the 'tag' field of the COSE_Mac or\n\
    \       COSE_Mac0 structure.\n"
- title: 7.  Key Objects
  contents:
  - "7.  Key Objects\n   A COSE Key structure is built on a CBOR map object.  The\
    \ set of\n   common parameters that can appear in a COSE Key can be found in the\n\
    \   IANA \"COSE Key Common Parameters\" registry (Section 16.5).\n   Additional\
    \ parameters defined for specific key types can be found in\n   the IANA \"COSE\
    \ Key Type Parameters\" registry (Section 16.6).\n   A COSE Key Set uses a CBOR\
    \ array object as its underlying type.  The\n   values of the array elements are\
    \ COSE Keys.  A COSE Key Set MUST have\n   at least one element in the array.\
    \  Examples of COSE Key Sets can be\n   found in Appendix C.7.\n   Each element\
    \ in a COSE Key Set MUST be processed independently.  If\n   one element in a\
    \ COSE Key Set is either malformed or uses a key that\n   is not understood by\
    \ an application, that key is ignored and the\n   other keys are processed normally.\n\
    \   The element \"kty\" is a required element in a COSE_Key map.\n   The CDDL\
    \ grammar describing COSE_Key and COSE_KeySet is:\n   COSE_Key = {\n       1 =>\
    \ tstr / int,          ; kty\n       ? 2 => bstr,              ; kid\n       ?\
    \ 3 => tstr / int,        ; alg\n       ? 4 => [+ (tstr / int) ], ; key_ops\n\
    \       ? 5 => bstr,              ; Base IV\n       * label => values\n   }\n\
    \   COSE_KeySet = [+COSE_Key]\n"
- title: 7.1.  COSE Key Common Parameters
  contents:
  - "7.1.  COSE Key Common Parameters\n   This document defines a set of common parameters\
    \ for a COSE Key\n   object.  Table 3 provides a summary of the parameters defined\
    \ in this\n   section.  There are also parameters that are defined for specific\
    \ key\n   types.  Key-type-specific parameters can be found in Section 13.\n \
    \  +---------+-------+----------------+------------+-------------------+\n   |\
    \ Name    | Label | CBOR Type      | Value      | Description       |\n   |  \
    \       |       |                | Registry   |                   |\n   +---------+-------+----------------+------------+-------------------+\n\
    \   | kty     | 1     | tstr / int     | COSE Key   | Identification of |\n  \
    \ |         |       |                | Common     | the key type      |\n   |\
    \         |       |                | Parameters |                   |\n   |  \
    \       |       |                |            |                   |\n   | kid\
    \     | 2     | bstr           |            | Key               |\n   |      \
    \   |       |                |            | identification    |\n   |        \
    \ |       |                |            | value -- match to |\n   |         |\
    \       |                |            | kid in message    |\n   |         |  \
    \     |                |            |                   |\n   | alg     | 3  \
    \   | tstr / int     | COSE       | Key usage         |\n   |         |      \
    \ |                | Algorithms | restriction to    |\n   |         |       |\
    \                |            | this algorithm    |\n   |         |       |  \
    \              |            |                   |\n   | key_ops | 4     | [+ (tstr/int)]\
    \ |            | Restrict set of   |\n   |         |       |                |\
    \            | permissible       |\n   |         |       |                |  \
    \          | operations        |\n   |         |       |                |    \
    \        |                   |\n   | Base IV | 5     | bstr           |      \
    \      | Base IV to be     |\n   |         |       |                |        \
    \    | xor-ed with       |\n   |         |       |                |          \
    \  | Partial IVs       |\n   +---------+-------+----------------+------------+-------------------+\n\
    \                          Table 3: Key Map Labels\n   kty:  This parameter is\
    \ used to identify the family of keys for this\n      structure and, thus, the\
    \ set of key-type-specific parameters to be\n      found.  The set of values defined\
    \ in this document can be found in\n      Table 21.  This parameter MUST be present\
    \ in a key object.\n      Implementations MUST verify that the key type is appropriate\
    \ for\n      the algorithm being processed.  The key type MUST be included as\n\
    \      part of the trust decision process.\n   alg:  This parameter is used to\
    \ restrict the algorithm that is used\n      with the key.  If this parameter\
    \ is present in the key structure,\n      the application MUST verify that this\
    \ algorithm matches the\n      algorithm for which the key is being used.  If\
    \ the algorithms do\n      not match, then this key object MUST NOT be used to\
    \ perform the\n      cryptographic operation.  Note that the same key can be in\
    \ a\n      different key structure with a different or no algorithm\n      specified;\
    \ however, this is considered to be a poor security\n      practice.\n   kid:\
    \  This parameter is used to give an identifier for a key.  The\n      identifier\
    \ is not structured and can be anything from a user-\n      provided string to\
    \ a value computed on the public portion of the\n      key.  This field is intended\
    \ for matching against a 'kid'\n      parameter in a message in order to filter\
    \ down the set of keys\n      that need to be checked.\n   key_ops:  This parameter\
    \ is defined to restrict the set of operations\n      that a key is to be used\
    \ for.  The value of the field is an array\n      of values from Table 4.  Algorithms\
    \ define the values of key ops\n      that are permitted to appear and are required\
    \ for specific\n      operations.  The set of values matches that in [RFC7517]\
    \ and\n      [W3C.WebCrypto].\n   Base IV:  This parameter is defined to carry\
    \ the base portion of an\n      IV.  It is designed to be used with the Partial\
    \ IV header\n      parameter defined in Section 3.1.  This field provides the\
    \ ability\n      to associate a Partial IV with a key that is then modified on\
    \ a\n      per message basis with the Partial IV.\n      Extreme care needs to\
    \ be taken when using a Base IV in an\n      application.  Many encryption algorithms\
    \ lose security if the same\n      IV is used twice.\n      If different keys\
    \ are derived for each sender, using the same Base\n      IV with Partial IVs\
    \ starting at zero is likely to ensure that the\n      IV would not be used twice\
    \ for a single key.  If different keys\n      are derived for each sender, starting\
    \ at the same Base IV is\n      likely to satisfy this condition.  If the same\
    \ key is used for\n      multiple senders, then the application needs to provide\
    \ for a\n      method of dividing the IV space up between the senders.  This\n\
    \      could be done by providing a different base point to start from or\n  \
    \    a different Partial IV to start with and restricting the number of\n    \
    \  messages to be sent before rekeying.\n   +---------+-------+-------------------------------------------------+\n\
    \   | Name    | Value | Description                                     |\n  \
    \ +---------+-------+-------------------------------------------------+\n   |\
    \ sign    | 1     | The key is used to create signatures.  Requires |\n   |  \
    \       |       | private key fields.                             |\n   | verify\
    \  | 2     | The key is used for verification of signatures. |\n   | encrypt |\
    \ 3     | The key is used for key transport encryption.   |\n   | decrypt | 4\
    \     | The key is used for key transport decryption.   |\n   |         |    \
    \   | Requires private key fields.                    |\n   | wrap    | 5    \
    \ | The key is used for key wrap encryption.        |\n   | key     |       |\
    \                                                 |\n   | unwrap  | 6     | The\
    \ key is used for key wrap decryption.        |\n   | key     |       | Requires\
    \ private key fields.                    |\n   | derive  | 7     | The key is\
    \ used for deriving keys.  Requires    |\n   | key     |       | private key fields.\
    \                             |\n   | derive  | 8     | The key is used for deriving\
    \ bits not to be     |\n   | bits    |       | used as a key.  Requires private\
    \ key fields.    |\n   | MAC     | 9     | The key is used for creating MACs.\
    \              |\n   | create  |       |                                     \
    \            |\n   | MAC     | 10    | The key is used for validating MACs.  \
    \          |\n   | verify  |       |                                         \
    \        |\n   +---------+-------+-------------------------------------------------+\n\
    \                       Table 4: Key Operation Values\n"
- title: 8.  Signature Algorithms
  contents:
  - "8.  Signature Algorithms\n   There are two signature algorithm schemes.  The\
    \ first is signature\n   with appendix.  In this scheme, the message content is\
    \ processed and\n   a signature is produced; the signature is called the appendix.\
    \  This\n   is the scheme used by algorithms such as ECDSA and the RSA\n   Probabilistic\
    \ Signature Scheme (RSASSA-PSS).  (In fact, the SSA in\n   RSASSA-PSS stands for\
    \ Signature Scheme with Appendix.)\n   The signature functions for this scheme\
    \ are:\n      signature = Sign(message content, key)\n      valid = Verification(message\
    \ content, key, signature)\n   The second scheme is signature with message recovery\
    \ (an example of\n   such an algorithm is [PVSig]).  In this scheme, the message\
    \ content\n   is processed, but part of it is included in the signature.  Moving\n\
    \   bytes of the message content into the signature allows for smaller\n   signatures;\
    \ the signature size is still potentially large, but the\n   message content has\
    \ shrunk.  This has implications for systems\n   implementing these algorithms\
    \ and for applications that use them.\n   The first is that the message content\
    \ is not fully available until\n   after a signature has been validated.  Until\
    \ that point, the part of\n   the message contained inside of the signature is\
    \ unrecoverable.  The\n   second is that the security analysis of the strength\
    \ of the signature\n   is very much based on the structure of the message content.\
    \  Messages\n   that are highly predictable require additional randomness to be\n\
    \   supplied as part of the signature process.  In the worst case, it\n   becomes\
    \ the same as doing a signature with appendix.  Finally, in the\n   event that\
    \ multiple signatures are applied to a message, all of the\n   signature algorithms\
    \ are going to be required to consume the same\n   number of bytes of message\
    \ content.  This means that the mixing of\n   the different schemes in a single\
    \ message is not supported, and if a\n   recovery signature scheme is used, then\
    \ the same amount of content\n   needs to be consumed by all of the signatures.\n\
    \   The signature functions for this scheme are:\n    signature, message sent\
    \ = Sign(message content, key)\n    valid, message content = Verification(message\
    \ sent, key, signature)\n   Signature algorithms are used with the COSE_Signature\
    \ and COSE_Sign1\n   structures.  At this time, only signatures with appendixes\
    \ are\n   defined for use with COSE; however, considerable interest has been\n\
    \   expressed in using a signature with message recovery algorithm due to\n  \
    \ the effective size reduction that is possible.  Implementations will\n   need\
    \ to keep this in mind for later possible integration.\n"
- title: 8.1.  ECDSA
  contents:
  - "8.1.  ECDSA\n   ECDSA [DSS] defines a signature algorithm using ECC.  Implementations\n\
    \   SHOULD use a deterministic version of ECDSA such as the one defined\n   in\
    \ [RFC6979].  The use of a deterministic signature algorithm allows\n   for systems\
    \ to avoid relying on random number generators in order to\n   avoid generating\
    \ the same value of 'k' (the per-message random\n   value).  Biased generation\
    \ of the value 'k' can be attacked, and\n   collisions of this value leads to\
    \ leaked keys.  It additionally\n   allows for doing deterministic tests for the\
    \ signature algorithm.\n   The use of deterministic ECDSA does not lessen the\
    \ need to have good\n   random number generation when creating the private key.\n\
    \   The ECDSA signature algorithm is parameterized with a hash function\n   (h).\
    \  In the event that the length of the hash function output is\n   greater than\
    \ the group of the key, the leftmost bytes of the hash\n   output are used.\n\
    \   The algorithms defined in this document can be found in Table 5.\n       \
    \       +-------+-------+---------+------------------+\n              | Name \
    \ | Value | Hash    | Description      |\n              +-------+-------+---------+------------------+\n\
    \              | ES256 | -7    | SHA-256 | ECDSA w/ SHA-256 |\n              |\
    \ ES384 | -35   | SHA-384 | ECDSA w/ SHA-384 |\n              | ES512 | -36  \
    \ | SHA-512 | ECDSA w/ SHA-512 |\n              +-------+-------+---------+------------------+\n\
    \                      Table 5: ECDSA Algorithm Values\n   This document defines\
    \ ECDSA to work only with the curves P-256,\n   P-384, and P-521.  This document\
    \ requires that the curves be encoded\n   using the 'EC2' (2 coordinate elliptic\
    \ curve) key type.\n   Implementations need to check that the key type and curve\
    \ are correct\n   when creating and verifying a signature.  Other documents can\
    \ define\n   it to work with other curves and points in the future.\n   In order\
    \ to promote interoperability, it is suggested that SHA-256 be\n   used only with\
    \ curve P-256, SHA-384 be used only with curve P-384,\n   and SHA-512 be used\
    \ with curve P-521.  This is aligned with the\n   recommendation in Section 4\
    \ of [RFC5480].\n   The signature algorithm results in a pair of integers (R,\
    \ S).  These\n   integers will be the same length as the length of the key used\
    \ for\n   the signature process.  The signature is encoded by converting the\n\
    \   integers into byte strings of the same length as the key size.  The\n   length\
    \ is rounded up to the nearest byte and is left padded with zero\n   bits to get\
    \ to the correct length.  The two integers are then\n   concatenated together\
    \ to form a byte string that is the resulting\n   signature.\n   Using the function\
    \ defined in [RFC8017], the signature is:\n   Signature = I2OSP(R, n) | I2OSP(S,\
    \ n)\n   where n = ceiling(key_length / 8)\n   When using a COSE key for this\
    \ algorithm, the following checks are\n   made:\n   o  The 'kty' field MUST be\
    \ present, and it MUST be 'EC2'.\n   o  If the 'alg' field is present, it MUST\
    \ match the ECDSA signature\n      algorithm being used.\n   o  If the 'key_ops'\
    \ field is present, it MUST include 'sign' when\n      creating an ECDSA signature.\n\
    \   o  If the 'key_ops' field is present, it MUST include 'verify' when\n    \
    \  verifying an ECDSA signature.\n"
- title: 8.1.1.  Security Considerations
  contents:
  - "8.1.1.  Security Considerations\n   The security strength of the signature is\
    \ no greater than the minimum\n   of the security strength associated with the\
    \ bit length of the key\n   and the security strength of the hash function.\n\
    \   Note: Use of this technique is a good idea even when good random\n   number\
    \ generation exists.  Doing so both reduces the possibility of\n   having the\
    \ same value of 'k' in two signature operations and allows\n   for reproducible\
    \ signature values, which helps testing.\n   There are two substitution attacks\
    \ that can theoretically be mounted\n   against the ECDSA signature algorithm.\n\
    \   o  Changing the curve used to validate the signature: If one changes\n   \
    \   the curve used to validate the signature, then potentially one\n      could\
    \ have two messages with the same signature, each computed\n      under a different\
    \ curve.  The only requirement on the new curve is\n      that its order be the\
    \ same as the old one and it be acceptable to\n      the client.  An example would\
    \ be to change from using the curve\n      secp256r1 (aka P-256) to using secp256k1.\
    \  (Both are 256-bit\n      curves.)  We currently do not have any way to deal\
    \ with this\n      version of the attack except to restrict the overall set of\
    \ curves\n      that can be used.\n   o  Change the hash function used to validate\
    \ the signature: If one\n      either has two different hash functions of the\
    \ same length or can\n      truncate a hash function down, then one could potentially\
    \ find\n      collisions between the hash functions rather than within a single\n\
    \      hash function (for example, truncating SHA-512 to 256 bits might\n    \
    \  collide with a SHA-256 bit hash value).  As the hash algorithm is\n      part\
    \ of the signature algorithm identifier, this attack is\n      mitigated by including\
    \ a signature algorithm identifier in the\n      protected header.\n"
- title: 8.2.  Edwards-Curve Digital Signature Algorithms (EdDSAs)
  contents:
  - "8.2.  Edwards-Curve Digital Signature Algorithms (EdDSAs)\n   [RFC8032] describes\
    \ the elliptic curve signature scheme Edwards-curve\n   Digital Signature Algorithm\
    \ (EdDSA).  In that document, the signature\n   algorithm is instantiated using\
    \ parameters for edwards25519 and\n   edwards448 curves.  The document additionally\
    \ describes two variants\n   of the EdDSA algorithm: Pure EdDSA, where no hash\
    \ function is applied\n   to the content before signing, and HashEdDSA, where\
    \ a hash function\n   is applied to the content before signing and the result\
    \ of that hash\n   function is signed.  For EdDSA, the content to be signed (either\
    \ the\n   message or the pre-hash value) is processed twice inside of the\n  \
    \ signature algorithm.  For use with COSE, only the pure EdDSA version\n   is\
    \ used.  This is because it is not expected that extremely large\n   contents\
    \ are going to be needed and, based on the arrangement of the\n   message structure,\
    \ the entire message is going to need to be held in\n   memory in order to create\
    \ or verify a signature.  This means that\n   there does not appear to be a need\
    \ to be able to do block updates of\n   the hash, followed by eliminating the\
    \ message from memory.\n   Applications can provide the same features by defining\
    \ the content of\n   the message as a hash value and transporting the COSE object\
    \ (with\n   the hash value) and the content as separate items.\n   The algorithms\
    \ defined in this document can be found in Table 6.  A\n   single signature algorithm\
    \ is defined, which can be used for multiple\n   curves.\n                   \
    \   +-------+-------+-------------+\n                      | Name  | Value | Description\
    \ |\n                      +-------+-------+-------------+\n                 \
    \     | EdDSA | -8    | EdDSA       |\n                      +-------+-------+-------------+\n\
    \                      Table 6: EdDSA Algorithm Values\n   [RFC8032] describes\
    \ the method of encoding the signature value.\n   When using a COSE key for this\
    \ algorithm, the following checks are\n   made:\n   o  The 'kty' field MUST be\
    \ present, and it MUST be 'OKP' (Octet Key\n      Pair).\n   o  The 'crv' field\
    \ MUST be present, and it MUST be a curve defined\n      for this signature algorithm.\n\
    \   o  If the 'alg' field is present, it MUST match 'EdDSA'.\n   o  If the 'key_ops'\
    \ field is present, it MUST include 'sign' when\n      creating an EdDSA signature.\n\
    \   o  If the 'key_ops' field is present, it MUST include 'verify' when\n    \
    \  verifying an EdDSA signature.\n"
- title: 8.2.1.  Security Considerations
  contents:
  - "8.2.1.  Security Considerations\n   How public values are computed is not the\
    \ same when looking at EdDSA\n   and Elliptic Curve Diffie-Hellman (ECDH); for\
    \ this reason, they\n   should not be used with the other algorithm.\n   If batch\
    \ signature verification is performed, a well-seeded\n   cryptographic random\
    \ number generator is REQUIRED.  Signing and non-\n   batch signature verification\
    \ are deterministic operations and do not\n   need random numbers of any kind.\n"
- title: 9.  Message Authentication Code (MAC) Algorithms
  contents:
  - "9.  Message Authentication Code (MAC) Algorithms\n   Message Authentication Codes\
    \ (MACs) provide data authentication and\n   integrity protection.  They provide\
    \ either no or very limited data\n   origination.  A MAC, for example, can be\
    \ used to prove the identity\n   of the sender to a third party.\n   MACs use\
    \ the same scheme as signature with appendix algorithms.  The\n   message content\
    \ is processed and an authentication code is produced.\n   The authentication\
    \ code is frequently called a tag.\n   The MAC functions are:\n   tag = MAC_Create(message\
    \ content, key)\n   valid = MAC_Verify(message content, key, tag)\n   MAC algorithms\
    \ can be based on either a block cipher algorithm (i.e.,\n   AES-MAC) or a hash\
    \ algorithm (i.e., a Hash-based Message\n   Authentication Code (HMAC)).  This\
    \ document defines a MAC algorithm\n   using each of these constructions.\n  \
    \ MAC algorithms are used in the COSE_Mac and COSE_Mac0 structures.\n"
- title: 9.1.  Hash-Based Message Authentication Codes (HMACs)
  contents:
  - "9.1.  Hash-Based Message Authentication Codes (HMACs)\n   HMAC [RFC2104] [RFC4231]\
    \ was designed to deal with length extension\n   attacks.  The algorithm was also\
    \ designed to allow for new hash\n   algorithms to be directly plugged in without\
    \ changes to the hash\n   function.  The HMAC design process has been shown as\
    \ solid since,\n   while the security of hash algorithms such as MD5 has decreased\
    \ over\n   time; the security of HMAC combined with MD5 has not yet been shown\n\
    \   to be compromised [RFC6151].\n   The HMAC algorithm is parameterized by an\
    \ inner and outer padding, a\n   hash function (h), and an authentication tag\
    \ value length.  For this\n   specification, the inner and outer padding are fixed\
    \ to the values\n   set in [RFC2104].  The length of the authentication tag corresponds\n\
    \   to the difficulty of producing a forgery.  For use in constrained\n   environments,\
    \ we define a set of HMAC algorithms that are truncated.\n   There are currently\
    \ no known issues with truncation; however, the\n   security strength of the message\
    \ tag is correspondingly reduced in\n   strength.  When truncating, the leftmost\
    \ tag length bits are kept and\n   transmitted.\n   The algorithms defined in\
    \ this document can be found in Table 7.\n   +-----------+-------+---------+----------+--------------------------+\n\
    \   | Name      | Value | Hash    | Tag      | Description              |\n  \
    \ |           |       |         | Length   |                          |\n   +-----------+-------+---------+----------+--------------------------+\n\
    \   | HMAC      | 4     | SHA-256 | 64       | HMAC w/ SHA-256          |\n  \
    \ | 256/64    |       |         |          | truncated to 64 bits     |\n   |\
    \ HMAC      | 5     | SHA-256 | 256      | HMAC w/ SHA-256          |\n   | 256/256\
    \   |       |         |          |                          |\n   | HMAC     \
    \ | 6     | SHA-384 | 384      | HMAC w/ SHA-384          |\n   | 384/384   |\
    \       |         |          |                          |\n   | HMAC      | 7\
    \     | SHA-512 | 512      | HMAC w/ SHA-512          |\n   | 512/512   |    \
    \   |         |          |                          |\n   +-----------+-------+---------+----------+--------------------------+\n\
    \                      Table 7: HMAC Algorithm Values\n   Some recipient algorithms\
    \ carry the key while others derive a key\n   from secret data.  For those algorithms\
    \ that carry the key (such as\n   AES Key Wrap), the size of the HMAC key SHOULD\
    \ be the same size as\n   the underlying hash function.  For those algorithms\
    \ that derive the\n   key (such as ECDH), the derived key MUST be the same size\
    \ as the\n   underlying hash function.\n   When using a COSE key for this algorithm,\
    \ the following checks are\n   made:\n   o  The 'kty' field MUST be present, and\
    \ it MUST be 'Symmetric'.\n   o  If the 'alg' field is present, it MUST match\
    \ the HMAC algorithm\n      being used.\n   o  If the 'key_ops' field is present,\
    \ it MUST include 'MAC create'\n      when creating an HMAC authentication tag.\n\
    \   o  If the 'key_ops' field is present, it MUST include 'MAC verify'\n     \
    \ when verifying an HMAC authentication tag.\n   Implementations creating and\
    \ validating MAC values MUST validate that\n   the key type, key length, and algorithm\
    \ are correct and appropriate\n   for the entities involved.\n"
- title: 9.1.1.  Security Considerations
  contents:
  - "9.1.1.  Security Considerations\n   HMAC has proved to be resistant to attack\
    \ even when used with\n   weakened hash algorithms.  The current best known attack\
    \ is to brute\n   force the key.  This means that key size is going to be directly\n\
    \   related to the security of an HMAC operation.\n"
- title: 9.2.  AES Message Authentication Code (AES-CBC-MAC)
  contents:
  - "9.2.  AES Message Authentication Code (AES-CBC-MAC)\n   AES-CBC-MAC is defined\
    \ in [MAC].  (Note that this is not the same\n   algorithm as AES Cipher-Based\
    \ Message Authentication Code (AES-CMAC)\n   [RFC4493].)\n   AES-CBC-MAC is parameterized\
    \ by the key length, the authentication\n   tag length, and the IV used.  For\
    \ all of these algorithms, the IV is\n   fixed to all zeros.  We provide an array\
    \ of algorithms for various\n   key lengths and tag lengths.  The algorithms defined\
    \ in this document\n   are found in Table 8.\n   +-------------+-------+----------+----------+-----------------------+\n\
    \   | Name        | Value | Key      | Tag      | Description           |\n  \
    \ |             |       | Length   | Length   |                       |\n   +-------------+-------+----------+----------+-----------------------+\n\
    \   | AES-MAC     | 14    | 128      | 64       | AES-MAC 128-bit key,  |\n  \
    \ | 128/64      |       |          |          | 64-bit tag            |\n   |\
    \ AES-MAC     | 15    | 256      | 64       | AES-MAC 256-bit key,  |\n   | 256/64\
    \      |       |          |          | 64-bit tag            |\n   | AES-MAC \
    \    | 25    | 128      | 128      | AES-MAC 128-bit key,  |\n   | 128/128   \
    \  |       |          |          | 128-bit tag           |\n   | AES-MAC     |\
    \ 26    | 256      | 128      | AES-MAC 256-bit key,  |\n   | 256/128     |  \
    \     |          |          | 128-bit tag           |\n   +-------------+-------+----------+----------+-----------------------+\n\
    \                     Table 8: AES-MAC Algorithm Values\n   Keys may be obtained\
    \ either from a key structure or from a recipient\n   structure.  Implementations\
    \ creating and validating MAC values MUST\n   validate that the key type, key\
    \ length, and algorithm are correct and\n   appropriate for the entities involved.\n\
    \   When using a COSE key for this algorithm, the following checks are\n   made:\n\
    \   o  The 'kty' field MUST be present, and it MUST be 'Symmetric'.\n   o  If\
    \ the 'alg' field is present, it MUST match the AES-MAC algorithm\n      being\
    \ used.\n   o  If the 'key_ops' field is present, it MUST include 'MAC create'\n\
    \      when creating an AES-MAC authentication tag.\n   o  If the 'key_ops' field\
    \ is present, it MUST include 'MAC verify'\n      when verifying an AES-MAC authentication\
    \ tag.\n"
- title: 9.2.1.  Security Considerations
  contents:
  - "9.2.1.  Security Considerations\n   A number of attacks exist against Cipher\
    \ Block Chaining Message\n   Authentication Code (CBC-MAC) that need to be considered.\n\
    \   o  A single key must only be used for messages of a fixed and known\n    \
    \  length.  If this is not the case, an attacker will be able to\n      generate\
    \ a message with a valid tag given two message and tag\n      pairs.  This can\
    \ be addressed by using different keys for messages\n      of different lengths.\
    \  The current structure mitigates this\n      problem, as a specific encoding\
    \ structure that includes lengths is\n      built and signed.  (CMAC also addresses\
    \ this issue.)\n   o  Cipher Block Chaining (CBC) mode, if the same key is used\
    \ for both\n      encryption and authentication operations, an attacker can produce\n\
    \      messages with a valid authentication code.\n   o  If the IV can be modified,\
    \ then messages can be forged.  This is\n      addressed by fixing the IV to all\
    \ zeros.\n"
- title: 10.  Content Encryption Algorithms
  contents:
  - "10.  Content Encryption Algorithms\n   Content encryption algorithms provide\
    \ data confidentiality for\n   potentially large blocks of data using a symmetric\
    \ key.  They provide\n   integrity on the data that was encrypted; however, they\
    \ provide\n   either no or very limited data origination.  (One cannot, for\n\
    \   example, be used to prove the identity of the sender to a third\n   party.)\
    \  The ability to provide data origination is linked to how the\n   CEK is obtained.\n\
    \   COSE restricts the set of legal content encryption algorithms to\n   those\
    \ that support authentication both of the content and additional\n   data.  The\
    \ encryption process will generate some type of\n   authentication value, but\
    \ that value may be either explicit or\n   implicit in terms of the algorithm\
    \ definition.  For simplicity's\n   sake, the authentication code will normally\
    \ be defined as being\n   appended to the ciphertext stream.  The encryption functions\
    \ are:\n   ciphertext = Encrypt(message content, key, additional data)\n   valid,\
    \ message content = Decrypt(cipher text, key, additional data)\n   Most AEAD algorithms\
    \ are logically defined as returning the message\n   content only if the decryption\
    \ is valid.  Many but not all\n   implementations will follow this convention.\
    \  The message content\n   MUST NOT be used if the decryption does not validate.\n\
    \   These algorithms are used in COSE_Encrypt and COSE_Encrypt0.\n"
- title: 10.1.  AES GCM
  contents:
  - "10.1.  AES GCM\n   The Galois/Counter Mode (GCM) mode is a generic authenticated\n\
    \   encryption block cipher mode defined in [AES-GCM].  The GCM mode is\n   combined\
    \ with the AES block encryption algorithm to define an AEAD\n   cipher.\n   The\
    \ GCM mode is parameterized by the size of the authentication tag\n   and the\
    \ size of the nonce.  This document fixes the size of the nonce\n   at 96 bits.\
    \  The size of the authentication tag is limited to a small\n   set of values.\
    \  For this document however, the size of the\n   authentication tag is fixed\
    \ at 128 bits.\n   The set of algorithms defined in this document are in Table\
    \ 9.\n      +---------+-------+------------------------------------------+\n \
    \     | Name    | Value | Description                              |\n      +---------+-------+------------------------------------------+\n\
    \      | A128GCM | 1     | AES-GCM mode w/ 128-bit key, 128-bit tag |\n      |\
    \ A192GCM | 2     | AES-GCM mode w/ 192-bit key, 128-bit tag |\n      | A256GCM\
    \ | 3     | AES-GCM mode w/ 256-bit key, 128-bit tag |\n      +---------+-------+------------------------------------------+\n\
    \                   Table 9: Algorithm Value for AES-GCM\n   Keys may be obtained\
    \ either from a key structure or from a recipient\n   structure.  Implementations\
    \ encrypting and decrypting MUST validate\n   that the key type, key length, and\
    \ algorithm are correct and\n   appropriate for the entities involved.\n   When\
    \ using a COSE key for this algorithm, the following checks are\n   made:\n  \
    \ o  The 'kty' field MUST be present, and it MUST be 'Symmetric'.\n   o  If the\
    \ 'alg' field is present, it MUST match the AES-GCM algorithm\n      being used.\n\
    \   o  If the 'key_ops' field is present, it MUST include 'encrypt' or\n     \
    \ 'wrap key' when encrypting.\n   o  If the 'key_ops' field is present, it MUST\
    \ include 'decrypt' or\n      'unwrap key' when decrypting.\n"
- title: 10.1.1.  Security Considerations
  contents:
  - "10.1.1.  Security Considerations\n   When using AES-GCM, the following restrictions\
    \ MUST be enforced:\n   o  The key and nonce pair MUST be unique for every message\
    \ encrypted.\n   o  The total amount of data encrypted for a single key MUST NOT\n\
    \      exceed 2^39 - 256 bits.  An explicit check is required only in\n      environments\
    \ where it is expected that it might be exceeded.\n   Consideration was given\
    \ to supporting smaller tag values; the\n   constrained community would desire\
    \ tag sizes in the 64-bit range.\n   Doing so drastically changes both the maximum\
    \ messages size\n   (generally not an issue) and the number of times that a key\
    \ can be\n   used.  Given that Counter with CBC-MAC (CCM) is the usual mode for\n\
    \   constrained environments, restricted modes are not supported.\n"
- title: 10.2.  AES CCM
  contents:
  - "10.2.  AES CCM\n   CCM is a generic authentication encryption block cipher mode\
    \ defined\n   in [RFC3610].  The CCM mode is combined with the AES block encryption\n\
    \   algorithm to define a commonly used content encryption algorithm used\n  \
    \ in constrained devices.\n   The CCM mode has two parameter choices.  The first\
    \ choice is M, the\n   size of the authentication field.  The choice of the value\
    \ for M\n   involves a trade-off between message growth (from the tag) and the\n\
    \   probability that an attacker can undetectably modify a message.  The\n   second\
    \ choice is L, the size of the length field.  This value\n   requires a trade-off\
    \ between the maximum message size and the size of\n   the Nonce.\n   It is unfortunate\
    \ that the specification for CCM specified L and M as\n   a count of bytes rather\
    \ than a count of bits.  This leads to possible\n   misunderstandings where AES-CCM-8\
    \ is frequently used to refer to a\n   version of CCM mode where the size of the\
    \ authentication is 64 bits\n   and not 8 bits.  These values have traditionally\
    \ been specified as\n   bit counts rather than byte counts.  This document will\
    \ follow the\n   convention of using bit counts so that it is easier to compare\
    \ the\n   different algorithms presented in this document.\n   We define a matrix\
    \ of algorithms in this document over the values of\n   L and M.  Constrained\
    \ devices are usually operating in situations\n   where they use short messages\
    \ and want to avoid doing recipient-\n   specific cryptographic operations.  This\
    \ favors smaller values of\n   both L and M.  Less-constrained devices will want\
    \ to be able to use\n   larger messages and are more willing to generate new keys\
    \ for every\n   operation.  This favors larger values of L and M.\n   The following\
    \ values are used for L:\n   16 bits (2):  This limits messages to 2^16 bytes\
    \ (64 KiB) in length.\n      This is sufficiently long for messages in the constrained\
    \ world.\n      The nonce length is 13 bytes allowing for 2^(13*8) possible values\n\
    \      of the nonce without repeating.\n   64 bits (8):  This limits messages\
    \ to 2^64 bytes in length.  The\n      nonce length is 7 bytes allowing for 2^56\
    \ possible values of the\n      nonce without repeating.\n   The following values\
    \ are used for M:\n   64 bits (8):  This produces a 64-bit authentication tag.\
    \  This\n      implies that there is a 1 in 2^64 chance that a modified message\n\
    \      will authenticate.\n   128 bits (16):  This produces a 128-bit authentication\
    \ tag.  This\n      implies that there is a 1 in 2^128 chance that a modified\
    \ message\n      will authenticate.\n   +--------------------+-------+----+-----+-----+---------------------+\n\
    \   | Name               | Value | L  | M   | k   | Description         |\n  \
    \ +--------------------+-------+----+-----+-----+---------------------+\n   |\
    \ AES-CCM-16-64-128  | 10    | 16 | 64  | 128 | AES-CCM mode        |\n   |  \
    \                  |       |    |     |     | 128-bit key, 64-bit |\n   |    \
    \                |       |    |     |     | tag, 13-byte nonce  |\n   | AES-CCM-16-64-256\
    \  | 11    | 16 | 64  | 256 | AES-CCM mode        |\n   |                    |\
    \       |    |     |     | 256-bit key, 64-bit |\n   |                    |  \
    \     |    |     |     | tag, 13-byte nonce  |\n   | AES-CCM-64-64-128  | 12 \
    \   | 64 | 64  | 128 | AES-CCM mode        |\n   |                    |      \
    \ |    |     |     | 128-bit key, 64-bit |\n   |                    |       |\
    \    |     |     | tag, 7-byte nonce   |\n   | AES-CCM-64-64-256  | 13    | 64\
    \ | 64  | 256 | AES-CCM mode        |\n   |                    |       |    |\
    \     |     | 256-bit key, 64-bit |\n   |                    |       |    |  \
    \   |     | tag, 7-byte nonce   |\n   | AES-CCM-16-128-128 | 30    | 16 | 128\
    \ | 128 | AES-CCM mode        |\n   |                    |       |    |     |\
    \     | 128-bit key,        |\n   |                    |       |    |     |  \
    \   | 128-bit tag,        |\n   |                    |       |    |     |    \
    \ | 13-byte nonce       |\n   | AES-CCM-16-128-256 | 31    | 16 | 128 | 256 |\
    \ AES-CCM mode        |\n   |                    |       |    |     |     | 256-bit\
    \ key,        |\n   |                    |       |    |     |     | 128-bit tag,\
    \        |\n   |                    |       |    |     |     | 13-byte nonce \
    \      |\n   | AES-CCM-64-128-128 | 32    | 64 | 128 | 128 | AES-CCM mode    \
    \    |\n   |                    |       |    |     |     | 128-bit key,      \
    \  |\n   |                    |       |    |     |     | 128-bit tag, 7-byte |\n\
    \   |                    |       |    |     |     | nonce               |\n  \
    \ | AES-CCM-64-128-256 | 33    | 64 | 128 | 256 | AES-CCM mode        |\n   |\
    \                    |       |    |     |     | 256-bit key,        |\n   |  \
    \                  |       |    |     |     | 128-bit tag, 7-byte |\n   |    \
    \                |       |    |     |     | nonce               |\n   +--------------------+-------+----+-----+-----+---------------------+\n\
    \                  Table 10: Algorithm Values for AES-CCM\n   Keys may be obtained\
    \ either from a key structure or from a recipient\n   structure.  Implementations\
    \ encrypting and decrypting MUST validate\n   that the key type, key length, and\
    \ algorithm are correct and\n   appropriate for the entities involved.\n   When\
    \ using a COSE key for this algorithm, the following checks are\n   made:\n  \
    \ o  The 'kty' field MUST be present, and it MUST be 'Symmetric'.\n   o  If the\
    \ 'alg' field is present, it MUST match the AES-CCM algorithm\n      being used.\n\
    \   o  If the 'key_ops' field is present, it MUST include 'encrypt' or\n     \
    \ 'wrap key' when encrypting.\n   o  If the 'key_ops' field is present, it MUST\
    \ include 'decrypt' or\n      'unwrap key' when decrypting.\n"
- title: 10.2.1.  Security Considerations
  contents:
  - "10.2.1.  Security Considerations\n   When using AES-CCM, the following restrictions\
    \ MUST be enforced:\n   o  The key and nonce pair MUST be unique for every message\
    \ encrypted.\n      Note that the value of L influences the number of unique nonces.\n\
    \   o  The total number of times the AES block cipher is used MUST NOT\n     \
    \ exceed 2^61 operations.  This limitation is the sum of times the\n      block\
    \ cipher is used in computing the MAC value and in performing\n      stream encryption\
    \ operations.  An explicit check is required only\n      in environments where\
    \ it is expected that it might be exceeded.\n   [RFC3610] additionally calls out\
    \ one other consideration of note.  It\n   is possible to do a pre-computation\
    \ attack against the algorithm in\n   cases where portions of the plaintext are\
    \ highly predictable.  This\n   reduces the security of the key size by half.\
    \  Ways to deal with this\n   attack include adding a random portion to the nonce\
    \ value and/or\n   increasing the key size used.  Using a portion of the nonce\
    \ for a\n   random value will decrease the number of messages that a single key\n\
    \   can be used for.  Increasing the key size may require more resources\n   in\
    \ the constrained device.  See Sections 5 and 10 of [RFC3610] for\n   more information.\n"
- title: 10.3.  ChaCha20 and Poly1305
  contents:
  - "10.3.  ChaCha20 and Poly1305\n   ChaCha20 and Poly1305 combined together is an\
    \ AEAD mode that is\n   defined in [RFC7539].  This is an algorithm defined to\
    \ be a cipher\n   that is not AES and thus would not suffer from any future weaknesses\n\
    \   found in AES.  These cryptographic functions are designed to be fast\n   in\
    \ software-only implementations.\n   The ChaCha20/Poly1305 AEAD construction defined\
    \ in [RFC7539] has no\n   parameterization.  It takes a 256-bit key and a 96-bit\
    \ nonce, as well\n   as the plaintext and additional data as inputs and produces\
    \ the\n   ciphertext as an option.  We define one algorithm identifier for this\n\
    \   algorithm in Table 11.\n   +-------------------+-------+---------------------------------------+\n\
    \   | Name              | Value | Description                           |\n  \
    \ +-------------------+-------+---------------------------------------+\n   |\
    \ ChaCha20/Poly1305 | 24    | ChaCha20/Poly1305 w/ 256-bit key,     |\n   |  \
    \                 |       | 128-bit tag                           |\n   +-------------------+-------+---------------------------------------+\n\
    \                   Table 11: Algorithm Value for AES-GCM\n   Keys may be obtained\
    \ either from a key structure or from a recipient\n   structure.  Implementations\
    \ encrypting and decrypting MUST validate\n   that the key type, key length, and\
    \ algorithm are correct and\n   appropriate for the entities involved.\n   When\
    \ using a COSE key for this algorithm, the following checks are\n   made:\n  \
    \ o  The 'kty' field MUST be present, and it MUST be 'Symmetric'.\n   o  If the\
    \ 'alg' field is present, it MUST match the ChaCha20/Poly1305\n      algorithm\
    \ being used.\n   o  If the 'key_ops' field is present, it MUST include 'encrypt'\
    \ or\n      'wrap key' when encrypting.\n   o  If the 'key_ops' field is present,\
    \ it MUST include 'decrypt' or\n      'unwrap key' when decrypting.\n"
- title: 10.3.1.  Security Considerations
  contents:
  - "10.3.1.  Security Considerations\n   The key and nonce values MUST be a unique\
    \ pair for every invocation\n   of the algorithm.  Nonce counters are considered\
    \ to be an acceptable\n   way of ensuring that they are unique.\n"
- title: 11.  Key Derivation Functions (KDFs)
  contents:
  - "11.  Key Derivation Functions (KDFs)\n   KDFs are used to take some secret value\
    \ and generate a different one.\n   The secret value comes in three flavors:\n\
    \   o  Secrets that are uniformly random: This is the type of secret that\n  \
    \    is created by a good random number generator.\n   o  Secrets that are not\
    \ uniformly random: This is type of secret that\n      is created by operations\
    \ like key agreement.\n   o  Secrets that are not random: This is the type of\
    \ secret that\n      people generate for things like passwords.\n   General KDFs\
    \ work well with the first type of secret, can do\n   reasonably well with the\
    \ second type of secret, and generally do\n   poorly with the last type of secret.\
    \  None of the KDFs in this\n   section are designed to deal with the type of\
    \ secrets that are used\n   for passwords.  Functions like PBES2 [RFC8018] need\
    \ to be used for\n   that type of secret.\n   The same KDF can be set up to deal\
    \ with the first two types of\n   secrets in a different way.  The KDF defined\
    \ in Section 11.1 is such\n   a function.  This is reflected in the set of algorithms\
    \ defined for\n   the HMAC-based Extract-and-Expand Key Derivation Function (HKDF).\n\
    \   When using KDFs, one component that is included is context\n   information.\
    \  Context information is used to allow for different\n   keying information to\
    \ be derived from the same secret.  The use of\n   context-based keying material\
    \ is considered to be a good security\n   practice.\n   This document defines\
    \ a single context structure and a single KDF.\n   These elements are used for\
    \ all of the recipient algorithms defined\n   in this document that require a\
    \ KDF process.  These algorithms are\n   defined in Sections 12.1.2, 12.4.1, and\
    \ 12.5.1.\n"
- title: 11.1.  HMAC-Based Extract-and-Expand Key Derivation Function (HKDF)
  contents:
  - "11.1.  HMAC-Based Extract-and-Expand Key Derivation Function (HKDF)\n   The HKDF\
    \ key derivation algorithm is defined in [RFC5869].\n   The HKDF algorithm takes\
    \ these inputs:\n      secret -- a shared value that is secret.  Secrets may be\
    \ either\n      previously shared or derived from operations like a Diffie-Hellman\n\
    \      (DH) key agreement.\n      salt -- an optional value that is used to change\
    \ the generation\n      process.  The salt value can be either public or private.\
    \  If the\n      salt is public and carried in the message, then the 'salt'\n\
    \      algorithm header parameter defined in Table 13 is used.  While\n      [RFC5869]\
    \ suggests that the length of the salt be the same as the\n      length of the\
    \ underlying hash value, any amount of salt will\n      improve the security as\
    \ different key values will be generated.\n      This parameter is protected by\
    \ being included in the key\n      computation and does not need to be separately\
    \ authenticated.  The\n      salt value does not need to be unique for every message\
    \ sent.\n      length -- the number of bytes of output that need to be generated.\n\
    \      context information -- Information that describes the context in\n    \
    \  which the resulting value will be used.  Making this information\n      specific\
    \ to the context in which the material is going to be used\n      ensures that\
    \ the resulting material will always be tied to that\n      usage.  The context\
    \ structure defined in Section 11.2 is used by\n      the KDFs in this document.\n\
    \      PRF -- The underlying pseudorandom function to be used in the HKDF\n  \
    \    algorithm.  The PRF is encoded into the HKDF algorithm selection.\n   HKDF\
    \ is defined to use HMAC as the underlying PRF.  However, it is\n   possible to\
    \ use other functions in the same construct to provide a\n   different KDF that\
    \ is more appropriate in the constrained world.\n   Specifically, one can use\
    \ AES-CBC-MAC as the PRF for the expand step,\n   but not for the extract step.\
    \  When using a good random shared secret\n   of the correct length, the extract\
    \ step can be skipped.  For the AES\n   algorithm versions, the extract step is\
    \ always skipped.\n   The extract step cannot be skipped if the secret is not\
    \ uniformly\n   random, for example, if it is the result of an ECDH key agreement\n\
    \   step.  This implies that the AES HKDF version cannot be used with\n   ECDH.\
    \  If the extract step is skipped, the 'salt' value is not used\n   as part of\
    \ the HKDF functionality.\n   The algorithms defined in this document are found\
    \ in Table 12.\n   +---------------+-----------------+---------------------------------+\n\
    \   | Name          | PRF             | Description                     |\n  \
    \ +---------------+-----------------+---------------------------------+\n   |\
    \ HKDF SHA-256  | HMAC with       | HKDF using HMAC SHA-256 as the  |\n   |  \
    \             | SHA-256         | PRF                             |\n   | HKDF\
    \ SHA-512  | HMAC with       | HKDF using HMAC SHA-512 as the  |\n   |       \
    \        | SHA-512         | PRF                             |\n   | HKDF AES-\
    \     | AES-CBC-MAC-128 | HKDF using AES-MAC as the PRF   |\n   | MAC-128    \
    \   |                 | w/ 128-bit key                  |\n   | HKDF AES-    \
    \ | AES-CBC-MAC-256 | HKDF using AES-MAC as the PRF   |\n   | MAC-256       |\
    \                 | w/ 256-bit key                  |\n   +---------------+-----------------+---------------------------------+\n\
    \                         Table 12: HKDF Algorithms\n   +------+-------+------+-------------------------------+-------------+\n\
    \   | Name | Label | Type | Algorithm                     | Description |\n  \
    \ +------+-------+------+-------------------------------+-------------+\n   |\
    \ salt | -20   | bstr | direct+HKDF-SHA-256, direct   | Random salt |\n   |  \
    \    |       |      | +HKDF-SHA-512, direct+HKDF-   |             |\n   |    \
    \  |       |      | AES-128, direct+HKDF-AES-256, |             |\n   |      |\
    \       |      | ECDH-ES+HKDF-256, ECDH-       |             |\n   |      |  \
    \     |      | ES+HKDF-512, ECDH-            |             |\n   |      |    \
    \   |      | SS+HKDF-256, ECDH-            |             |\n   |      |      \
    \ |      | SS+HKDF-512, ECDH-ES+A128KW,  |             |\n   |      |       |\
    \      | ECDH-ES+A192KW, ECDH-         |             |\n   |      |       |  \
    \    | ES+A256KW, ECDH-SS+A128KW,    |             |\n   |      |       |    \
    \  | ECDH-SS+A192KW, ECDH-         |             |\n   |      |       |      |\
    \ SS+A256KW                     |             |\n   +------+-------+------+-------------------------------+-------------+\n\
    \                    Table 13: HKDF Algorithm Parameters\n"
- title: 11.2.  Context Information Structure
  contents:
  - "11.2.  Context Information Structure\n   The context information structure is\
    \ used to ensure that the derived\n   keying material is \"bound\" to the context\
    \ of the transaction.  The\n   context information structure used here is based\
    \ on that defined in\n   [SP800-56A].  By using CBOR for the encoding of the context\n\
    \   information structure, we automatically get the same type and length\n   separation\
    \ of fields that is obtained by the use of ASN.1.  This\n   means that there is\
    \ no need to encode the lengths for the base\n   elements, as it is done by the\
    \ encoding used in JOSE (Section 4.6.2\n   of [RFC7518]).\n   The context information\
    \ structure refers to PartyU and PartyV as the\n   two parties that are doing\
    \ the key derivation.  Unless the\n   application protocol defines differently,\
    \ we assign PartyU to the\n   entity that is creating the message and PartyV to\
    \ the entity that is\n   receiving the message.  By doing this association, different\
    \ keys\n   will be derived for each direction as the context information is\n\
    \   different in each direction.\n   The context structure is built from information\
    \ that is known to both\n   entities.  This information can be obtained from a\
    \ variety of\n   sources:\n   o  Fields can be defined by the application.  This\
    \ is commonly used\n      to assign fixed names to parties, but it can be used\
    \ for other\n      items such as nonces.\n   o  Fields can be defined by usage\
    \ of the output.  Examples of this\n      are the algorithm and key size that\
    \ are being generated.\n   o  Fields can be defined by parameters from the message.\
    \  We define a\n      set of parameters in Table 14 that can be used to carry\
    \ the values\n      associated with the context structure.  Examples of this are\n\
    \      identities and nonce values.  These parameters are designed to be\n   \
    \   placed in the unprotected bucket of the recipient structure; they\n      do\
    \ not need to be in the protected bucket since they already are\n      included\
    \ in the cryptographic computation by virtue of being\n      included in the context\
    \ structure.\n   +----------+-------+------+---------------------------+-------------+\n\
    \   | Name     | Label | Type | Algorithm                 | Description |\n  \
    \ +----------+-------+------+---------------------------+-------------+\n   |\
    \ PartyU   | -21   | bstr | direct+HKDF-SHA-256,      | Party U     |\n   | identity\
    \ |       |      | direct+HKDF-SHA-512,      | identity    |\n   |          |\
    \       |      | direct+HKDF-AES-128,      | information |\n   |          |  \
    \     |      | direct+HKDF-AES-256,      |             |\n   |          |    \
    \   |      | ECDH-ES+HKDF-256, ECDH-   |             |\n   |          |      \
    \ |      | ES+HKDF-512, ECDH-        |             |\n   |          |       |\
    \      | SS+HKDF-256, ECDH-        |             |\n   |          |       |  \
    \    | SS+HKDF-512, ECDH-        |             |\n   |          |       |    \
    \  | ES+A128KW, ECDH-          |             |\n   |          |       |      |\
    \ ES+A192KW, ECDH-          |             |\n   |          |       |      | ES+A256KW,\
    \ ECDH-          |             |\n   |          |       |      | SS+A128KW, ECDH-\
    \          |             |\n   |          |       |      | SS+A192KW, ECDH-SS+A256KW\
    \ |             |\n   |          |       |      |                           |\
    \             |\n   | PartyU   | -22   | bstr | direct+HKDF-SHA-256,      | Party\
    \ U     |\n   | nonce    |       | /    | direct+HKDF-SHA-512,      | provided\
    \    |\n   |          |       | int  | direct+HKDF-AES-128,      | nonce     \
    \  |\n   |          |       |      | direct+HKDF-AES-256,      |             |\n\
    \   |          |       |      | ECDH-ES+HKDF-256, ECDH-   |             |\n  \
    \ |          |       |      | ES+HKDF-512, ECDH-        |             |\n   |\
    \          |       |      | SS+HKDF-256, ECDH-        |             |\n   |  \
    \        |       |      | SS+HKDF-512, ECDH-        |             |\n   |    \
    \      |       |      | ES+A128KW, ECDH-          |             |\n   |      \
    \    |       |      | ES+A192KW, ECDH-          |             |\n   |        \
    \  |       |      | ES+A256KW, ECDH-          |             |\n   |          |\
    \       |      | SS+A128KW, ECDH-          |             |\n   |          |  \
    \     |      | SS+A192KW, ECDH-SS+A256KW |             |\n   |          |    \
    \   |      |                           |             |\n   | PartyU   | -23  \
    \ | bstr | direct+HKDF-SHA-256,      | Party U     |\n   | other    |       |\
    \      | direct+HKDF-SHA-512,      | other       |\n   |          |       |  \
    \    | direct+HKDF-AES-128,      | provided    |\n   |          |       |    \
    \  | direct+HKDF-AES-256,      | information |\n   |          |       |      |\
    \ ECDH-ES+HKDF-256, ECDH-   |             |\n   |          |       |      | ES+HKDF-512,\
    \ ECDH-        |             |\n   |          |       |      | SS+HKDF-256, ECDH-\
    \        |             |\n   |          |       |      | SS+HKDF-512, ECDH-  \
    \      |             |\n   |          |       |      | ES+A128KW, ECDH-      \
    \    |             |\n   |          |       |      | ES+A192KW, ECDH-        \
    \  |             |\n   |          |       |      | ES+A256KW, ECDH-          |\
    \             |\n   |          |       |      | SS+A128KW, ECDH-          |  \
    \           |\n   |          |       |      | SS+A192KW, ECDH-SS+A256KW |    \
    \         |\n   | PartyV   | -24   | bstr | direct+HKDF-SHA-256,      | Party\
    \ V     |\n   | identity |       |      | direct+HKDF-SHA-512,      | identity\
    \    |\n   |          |       |      | direct+HKDF-AES-128,      | information\
    \ |\n   |          |       |      | direct+HKDF-AES-256,      |             |\n\
    \   |          |       |      | ECDH-ES+HKDF-256, ECDH-   |             |\n  \
    \ |          |       |      | ES+HKDF-512, ECDH-        |             |\n   |\
    \          |       |      | SS+HKDF-256, ECDH-        |             |\n   |  \
    \        |       |      | SS+HKDF-512, ECDH-        |             |\n   |    \
    \      |       |      | ES+A128KW, ECDH-          |             |\n   |      \
    \    |       |      | ES+A192KW, ECDH-          |             |\n   |        \
    \  |       |      | ES+A256KW, ECDH-          |             |\n   |          |\
    \       |      | SS+A128KW, ECDH-          |             |\n   |          |  \
    \     |      | SS+A192KW, ECDH-SS+A256KW |             |\n   |          |    \
    \   |      |                           |             |\n   | PartyV   | -25  \
    \ | bstr | direct+HKDF-SHA-256,      | Party V     |\n   | nonce    |       |\
    \ /    | direct+HKDF-SHA-512,      | provided    |\n   |          |       | int\
    \  | direct+HKDF-AES-128,      | nonce       |\n   |          |       |      |\
    \ direct+HKDF-AES-256,      |             |\n   |          |       |      | ECDH-ES+HKDF-256,\
    \ ECDH-   |             |\n   |          |       |      | ES+HKDF-512, ECDH- \
    \       |             |\n   |          |       |      | SS+HKDF-256, ECDH-   \
    \     |             |\n   |          |       |      | SS+HKDF-512, ECDH-     \
    \   |             |\n   |          |       |      | ES+A128KW, ECDH-         \
    \ |             |\n   |          |       |      | ES+A192KW, ECDH-          |\
    \             |\n   |          |       |      | ES+A256KW, ECDH-          |  \
    \           |\n   |          |       |      | SS+A128KW, ECDH-          |    \
    \         |\n   |          |       |      | SS+A192KW, ECDH-SS+A256KW |      \
    \       |\n   |          |       |      |                           |        \
    \     |\n   | PartyV   | -26   | bstr | direct+HKDF-SHA-256,      | Party V  \
    \   |\n   | other    |       |      | direct+HKDF-SHA-512,      | other      \
    \ |\n   |          |       |      | direct+HKDF-AES-128,      | provided    |\n\
    \   |          |       |      | direct+HKDF-AES-256,      | information |\n  \
    \ |          |       |      | ECDH-ES+HKDF-256, ECDH-   |             |\n   |\
    \          |       |      | ES+HKDF-512, ECDH-        |             |\n   |  \
    \        |       |      | SS+HKDF-256, ECDH-        |             |\n   |    \
    \      |       |      | SS+HKDF-512, ECDH-        |             |\n   |      \
    \    |       |      | ES+A128KW, ECDH-          |             |\n   |        \
    \  |       |      | ES+A192KW, ECDH-          |             |\n   |          |\
    \       |      | ES+A256KW, ECDH-          |             |\n   |          |  \
    \     |      | SS+A128KW, ECDH-          |             |\n   |          |    \
    \   |      | SS+A192KW, ECDH-SS+A256KW |             |\n   +----------+-------+------+---------------------------+-------------+\n\
    \                  Table 14: Context Algorithm Parameters\n   We define a CBOR\
    \ object to hold the context information.  This object\n   is referred to as COSE_KDF_Context.\
    \  The object is based on a CBOR\n   array type.  The fields in the array are:\n\
    \   AlgorithmID:  This field indicates the algorithm for which the key\n     \
    \ material will be used.  This normally is either a key wrap\n      algorithm\
    \ identifier or a content encryption algorithm identifier.\n      The values are\
    \ from the \"COSE Algorithms\" registry.  This field is\n      required to be\
    \ present.  The field exists in the context\n      information so that if the\
    \ same environment is used for different\n      algorithms, then completely different\
    \ keys will be generated for\n      each of those algorithms.  This practice means\
    \ if algorithm A is\n      broken and thus is easier to find, the key derived\
    \ for algorithm B\n      will not be the same as the key derived for algorithm\
    \ A.\n   PartyUInfo:  This field holds information about party U.  The\n     \
    \ PartyUInfo is encoded as a CBOR array.  The elements of PartyUInfo\n      are\
    \ encoded in the order presented.  The elements of the\n      PartyUInfo array\
    \ are:\n      identity:  This contains the identity information for party U.\n\
    \         The identities can be assigned in one of two manners.  First, a\n  \
    \       protocol can assign identities based on roles.  For example,\n       \
    \  the roles of \"client\" and \"server\" may be assigned to different\n     \
    \    entities in the protocol.  Each entity would then use the\n         correct\
    \ label for the data they send or receive.  The second\n         way for a protocol\
    \ to assign identities is to use a name based\n         on a naming system (i.e.,\
    \ DNS, X.509 names).\n         We define an algorithm parameter 'PartyU identity'\
    \ that can be\n         used to carry identity information in the message.  However,\n\
    \         identity information is often known as part of the protocol and\n  \
    \       can thus be inferred rather than made explicit.  If identity\n       \
    \  information is carried in the message, applications SHOULD have\n         a\
    \ way of validating the supplied identity information.  The\n         identity\
    \ information does not need to be specified and is set\n         to nil in that\
    \ case.\n      nonce:  This contains a nonce value.  The nonce can either be\n\
    \         implicit from the protocol or be carried as a value in the\n       \
    \  unprotected headers.\n         We define an algorithm parameter 'PartyU nonce'\
    \ that can be\n         used to carry this value in the message; however, the\
    \ nonce\n         value could be determined by the application and the value\n\
    \         determined from elsewhere.\n         This option does not need to be\
    \ specified and is set to nil in\n         that case.\n      other:  This contains\
    \ other information that is defined by the\n         protocol.  This option does\
    \ not need to be specified and is set\n         to nil in that case.\n   PartyVInfo:\
    \  This field holds information about party V.  The content\n      of the structure\
    \ is the same as for the PartyUInfo but for party\n      V.\n   SuppPubInfo: \
    \ This field contains public information that is mutually\n      known to both\
    \ parties.\n      keyDataLength:  This is set to the number of bits of the desired\n\
    \         output value.  This practice means if algorithm A can use two\n    \
    \     different key lengths, the key derived for longer key size will\n      \
    \   not contain the key for shorter key size as a prefix.\n      protected:  This\
    \ field contains the protected parameter field.  If\n         there are no elements\
    \ in the protected field, then use a zero-\n         length bstr.\n      other:\
    \  This field is for free form data defined by the\n         application.  An\
    \ example is that an application could define\n         two different strings\
    \ to be placed here to generate different\n         keys for a data stream versus\
    \ a control stream.  This field is\n         optional and will only be present\
    \ if the application defines a\n         structure for this information.  Applications\
    \ that define this\n         SHOULD use CBOR to encode the data so that types\
    \ and lengths\n         are correctly included.\n   SuppPrivInfo:  This field\
    \ contains private information that is\n      mutually known private information.\
    \  An example of this\n      information would be a preexisting shared secret.\
    \  (This could,\n      for example, be used in combination with an ECDH key agreement\
    \ to\n      provide a secondary proof of identity.)  The field is optional and\n\
    \      will only be present if the application defines a structure for\n     \
    \ this information.  Applications that define this SHOULD use CBOR\n      to encode\
    \ the data so that types and lengths are correctly\n      included.\n   The following\
    \ CDDL fragment corresponds to the text above.\n   PartyInfo = (\n       identity\
    \ : bstr / nil,\n       nonce : bstr / int / nil,\n       other : bstr / nil\n\
    \   )\n   COSE_KDF_Context = [\n       AlgorithmID : int / tstr,\n       PartyUInfo\
    \ : [ PartyInfo ],\n       PartyVInfo : [ PartyInfo ],\n       SuppPubInfo : [\n\
    \           keyDataLength : uint,\n           protected : empty_or_serialized_map,\n\
    \           ? other : bstr\n       ],\n       ? SuppPrivInfo : bstr\n   ]\n"
- title: 12.  Content Key Distribution Methods
  contents:
  - "12.  Content Key Distribution Methods\n   Content key distribution methods (recipient\
    \ algorithms) can be\n   defined into a number of different classes.  COSE has\
    \ the ability to\n   support many classes of recipient algorithms.  In this section,\
    \ a\n   number of classes are listed, and then a set of algorithms are\n   specified\
    \ for each of the classes.  The names of the recipient\n   algorithm classes used\
    \ here are the same as those defined in\n   [RFC7516].  Other specifications use\
    \ different terms for the\n   recipient algorithm classes or do not support some\
    \ of the recipient\n   algorithm classes.\n"
- title: 12.1.  Direct Encryption
  contents:
  - "12.1.  Direct Encryption\n   The direct encryption class algorithms share a secret\
    \ between the\n   sender and the recipient that is used either directly or after\n\
    \   manipulation as the CEK.  When direct encryption mode is used, it\n   MUST\
    \ be the only mode used on the message.\n   The COSE_Recipient structure for the\
    \ recipient is organized as\n   follows:\n   o  The 'protected' field MUST be\
    \ a zero-length item unless it is used\n      in the computation of the content\
    \ key.\n   o  The 'alg' parameter MUST be present.\n   o  A parameter identifying\
    \ the shared secret SHOULD be present.\n   o  The 'ciphertext' field MUST be a\
    \ zero-length item.\n   o  The 'recipients' field MUST be absent.\n"
- title: 12.1.1.  Direct Key
  contents:
  - "12.1.1.  Direct Key\n   This recipient algorithm is the simplest; the identified\
    \ key is\n   directly used as the key for the next layer down in the message.\n\
    \   There are no algorithm parameters defined for this algorithm.  The\n   algorithm\
    \ identifier value is assigned in Table 15.\n   When this algorithm is used, the\
    \ protected field MUST be zero length.\n   The key type MUST be 'Symmetric'.\n\
    \                  +--------+-------+-------------------+\n                  |\
    \ Name   | Value | Description       |\n                  +--------+-------+-------------------+\n\
    \                  | direct | -6    | Direct use of CEK |\n                  +--------+-------+-------------------+\n\
    \                           Table 15: Direct Key\n"
- title: 12.1.1.1.  Security Considerations
  contents:
  - "12.1.1.1.  Security Considerations\n   This recipient algorithm has several potential\
    \ problems that need to\n   be considered:\n   o  These keys need to have some\
    \ method to be regularly updated over\n      time.  All of the content encryption\
    \ algorithms specified in this\n      document have limits on how many times a\
    \ key can be used without\n      significant loss of security.\n   o  These keys\
    \ need to be dedicated to a single algorithm.  There have\n      been a number\
    \ of attacks developed over time when a single key is\n      used for multiple\
    \ different algorithms.  One example of this is\n      the use of a single key\
    \ for both the CBC encryption mode and the\n      CBC-MAC authentication mode.\n\
    \   o  Breaking one message means all messages are broken.  If an\n      adversary\
    \ succeeds in determining the key for a single message,\n      then the key for\
    \ all messages is also determined.\n"
- title: 12.1.2.  Direct Key with KDF
  contents:
  - "12.1.2.  Direct Key with KDF\n   These recipient algorithms take a common shared\
    \ secret between the\n   two parties and applies the HKDF function (Section 11.1),\
    \ using the\n   context structure defined in Section 11.2 to transform the shared\n\
    \   secret into the CEK.  The 'protected' field can be of non-zero\n   length.\
    \  Either the 'salt' parameter of HKDF or the 'PartyU nonce'\n   parameter of\
    \ the context structure MUST be present.  The salt/nonce\n   parameter can be\
    \ generated either randomly or deterministically.  The\n   requirement is that\
    \ it be a unique value for the shared secret in\n   question.\n   If the salt/nonce\
    \ value is generated randomly, then it is suggested\n   that the length of the\
    \ random value be the same length as the hash\n   function underlying HKDF.  While\
    \ there is no way to guarantee that it\n   will be unique, there is a high probability\
    \ that it will be unique.\n   If the salt/nonce value is generated deterministically,\
    \ it can be\n   guaranteed to be unique, and thus there is no length requirement.\n\
    \   A new IV must be used for each message if the same key is used.  The\n   IV\
    \ can be modified in a predictable manner, a random manner, or an\n   unpredictable\
    \ manner (i.e., encrypting a counter).\n   The IV used for a key can also be generated\
    \ from the same HKDF\n   functionality as the key is generated.  If HKDF is used\
    \ for\n   generating the IV, the algorithm identifier is set to \"IV-\n   GENERATION\"\
    .\n   When these algorithms are used, the key type MUST be 'symmetric'.\n   The\
    \ set of algorithms defined in this document can be found in\n   Table 16.\n \
    \  +---------------------+-------+-------------+-----------------------+\n   |\
    \ Name                | Value | KDF         | Description           |\n   +---------------------+-------+-------------+-----------------------+\n\
    \   | direct+HKDF-SHA-256 | -10   | HKDF        | Shared secret w/ HKDF |\n  \
    \ |                     |       | SHA-256     | and SHA-256           |\n   |\
    \ direct+HKDF-SHA-512 | -11   | HKDF        | Shared secret w/ HKDF |\n   |  \
    \                   |       | SHA-512     | and SHA-512           |\n   | direct+HKDF-AES-128\
    \ | -12   | HKDF AES-   | Shared secret w/ AES- |\n   |                     |\
    \       | MAC-128     | MAC 128-bit key       |\n   | direct+HKDF-AES-256 | -13\
    \   | HKDF AES-   | Shared secret w/ AES- |\n   |                     |      \
    \ | MAC-256     | MAC 256-bit key       |\n   +---------------------+-------+-------------+-----------------------+\n\
    \                       Table 16: Direct Key with KDF\n   When using a COSE key\
    \ for this algorithm, the following checks are\n   made:\n   o  The 'kty' field\
    \ MUST be present, and it MUST be 'Symmetric'.\n   o  If the 'alg' field is present,\
    \ it MUST match the algorithm being\n      used.\n   o  If the 'key_ops' field\
    \ is present, it MUST include 'deriveKey' or\n      'deriveBits'.\n"
- title: 12.1.2.1.  Security Considerations
  contents:
  - "12.1.2.1.  Security Considerations\n   The shared secret needs to have some method\
    \ to be regularly updated\n   over time.  The shared secret forms the basis of\
    \ trust.  Although not\n   used directly, it should still be subject to scheduled\
    \ rotation.\n   While these methods do not provide for perfect forward secrecy,\
    \ as\n   the same shared secret is used for all of the keys generated, if the\n\
    \   key for any single message is discovered, only the message (or series\n  \
    \ of messages) using that derived key are compromised.  A new key\n   derivation\
    \ step will generate a new key that requires the same amount\n   of work to get\
    \ the key.\n"
- title: 12.2.  Key Wrap
  contents:
  - "12.2.  Key Wrap\n   In key wrap mode, the CEK is randomly generated and that\
    \ key is then\n   encrypted by a shared secret between the sender and the recipient.\n\
    \   All of the currently defined key wrap algorithms for COSE are AE\n   algorithms.\
    \  Key wrap mode is considered to be superior to direct\n   encryption if the\
    \ system has any capability for doing random key\n   generation.  This is because\
    \ the shared key is used to wrap random\n   data rather than data that has some\
    \ degree of organization and may in\n   fact be repeating the same content.  The\
    \ use of key wrap loses the\n   weak data origination that is provided by the\
    \ direct encryption\n   algorithms.\n   The COSE_Encrypt structure for the recipient\
    \ is organized as follows:\n   o  The 'protected' field MUST be absent if the\
    \ key wrap algorithm is\n      an AE algorithm.\n   o  The 'recipients' field\
    \ is normally absent, but can be used.\n      Applications MUST deal with a recipient\
    \ field being present, not\n      being able to decrypt that recipient is an acceptable\
    \ way of\n      dealing with it.  Failing to process the message is not an\n \
    \     acceptable way of dealing with it.\n   o  The plaintext to be encrypted\
    \ is the key from next layer down\n      (usually the content layer).\n   o  At\
    \ a minimum, the 'unprotected' field MUST contain the 'alg'\n      parameter and\
    \ SHOULD contain a parameter identifying the shared\n      secret.\n"
- title: 12.2.1.  AES Key Wrap
  contents:
  - "12.2.1.  AES Key Wrap\n   The AES Key Wrap algorithm is defined in [RFC3394].\
    \  This algorithm\n   uses an AES key to wrap a value that is a multiple of 64\
    \ bits.  As\n   such, it can be used to wrap a key for any of the content encryption\n\
    \   algorithms defined in this document.  The algorithm requires a single\n  \
    \ fixed parameter, the initial value.  This is fixed to the value\n   specified\
    \ in Section 2.2.3.1 of [RFC3394].  There are no public\n   parameters that vary\
    \ on a per-invocation basis.  The protected header\n   field MUST be empty.\n\
    \   Keys may be obtained either from a key structure or from a recipient\n   structure.\
    \  Implementations encrypting and decrypting MUST validate\n   that the key type,\
    \ key length, and algorithm are correct and\n   appropriate for the entities involved.\n\
    \   When using a COSE key for this algorithm, the following checks are\n   made:\n\
    \   o  The 'kty' field MUST be present, and it MUST be 'Symmetric'.\n   o  If\
    \ the 'alg' field is present, it MUST match the AES Key Wrap\n      algorithm\
    \ being used.\n   o  If the 'key_ops' field is present, it MUST include 'encrypt'\
    \ or\n      'wrap key' when encrypting.\n   o  If the 'key_ops' field is present,\
    \ it MUST include 'decrypt' or\n      'unwrap key' when decrypting.\n        +--------+-------+----------+-----------------------------+\n\
    \        | Name   | Value | Key Size | Description                 |\n       \
    \ +--------+-------+----------+-----------------------------+\n        | A128KW\
    \ | -3    | 128      | AES Key Wrap w/ 128-bit key |\n        | A192KW | -4  \
    \  | 192      | AES Key Wrap w/ 192-bit key |\n        | A256KW | -5    | 256\
    \      | AES Key Wrap w/ 256-bit key |\n        +--------+-------+----------+-----------------------------+\n\
    \                  Table 17: AES Key Wrap Algorithm Values\n"
- title: 12.2.1.1.  Security Considerations for AES-KW
  contents:
  - "12.2.1.1.  Security Considerations for AES-KW\n   The shared secret needs to\
    \ have some method to be regularly updated\n   over time.  The shared secret is\
    \ the basis of trust.\n"
- title: 12.3.  Key Transport
  contents:
  - "12.3.  Key Transport\n   Key transport mode is also called key encryption mode\
    \ in some\n   standards.  Key transport mode differs from key wrap mode in that\
    \ it\n   uses an asymmetric encryption algorithm rather than a symmetric\n   encryption\
    \ algorithm to protect the key.  This document does not\n   define any key transport\
    \ mode algorithms.\n   When using a key transport algorithm, the COSE_Encrypt\
    \ structure for\n   the recipient is organized as follows:\n   o  The 'protected'\
    \ field MUST be absent.\n   o  The plaintext to be encrypted is the key from the\
    \ next layer down\n      (usually the content layer).\n   o  At a minimum, the\
    \ 'unprotected' field MUST contain the 'alg'\n      parameter and SHOULD contain\
    \ a parameter identifying the\n      asymmetric key.\n"
- title: 12.4.  Direct Key Agreement
  contents:
  - "12.4.  Direct Key Agreement\n   The 'direct key agreement' class of recipient\
    \ algorithms uses a key\n   agreement method to create a shared secret.  A KDF\
    \ is then applied to\n   the shared secret to derive a key to be used in protecting\
    \ the data.\n   This key is normally used as a CEK or MAC key, but could be used\
    \ for\n   other purposes if more than two layers are in use (see Appendix B).\n\
    \   The most commonly used key agreement algorithm is Diffie-Hellman, but\n  \
    \ other variants exist.  Since COSE is designed for a store and forward\n   environment\
    \ rather than an online environment, many of the DH\n   variants cannot be used\
    \ as the receiver of the message cannot provide\n   any dynamic key material.\
    \  One side effect of this is that perfect\n   forward secrecy (see [RFC4949])\
    \ is not achievable.  A static key will\n   always be used for the receiver of\
    \ the COSE object.\n   Two variants of DH that are supported are:\n      Ephemeral-Static\
    \ (ES) DH: where the sender of the message creates\n      a one-time DH key and\
    \ uses a static key for the recipient.  The\n      use of the ephemeral sender\
    \ key means that no additional random\n      input is needed as this is randomly\
    \ generated for each message.\n      Static-Static DH: where a static key is used\
    \ for both the sender\n      and the recipient.  The use of static keys allows\
    \ for the\n      recipient to get a weak version of data origination for the\n\
    \      message.  When static-static key agreement is used, then some\n      piece\
    \ of unique data for the KDF is required to ensure that a\n      different key\
    \ is created for each message.\n   When direct key agreement mode is used, there\
    \ MUST be only one\n   recipient in the message.  This method creates the key\
    \ directly, and\n   that makes it difficult to mix with additional recipients.\
    \  If\n   multiple recipients are needed, then the version with key wrap needs\n\
    \   to be used.\n   The COSE_Encrypt structure for the recipient is organized\
    \ as follows:\n   o  At a minimum, headers MUST contain the 'alg' parameter and\
    \ SHOULD\n      contain a parameter identifying the recipient's asymmetric key.\n\
    \   o  The headers SHOULD identify the sender's key for the static-static\n  \
    \    versions and MUST contain the sender's ephemeral key for the\n      ephemeral-static\
    \ versions.\n"
- title: 12.4.1.  ECDH
  contents:
  - "12.4.1.  ECDH\n   The mathematics for ECDH can be found in [RFC6090].  In this\n\
    \   document, the algorithm is extended to be used with the two curves\n   defined\
    \ in [RFC7748].\n   ECDH is parameterized by the following:\n   o  Curve Type/Curve:\
    \ The curve selected controls not only the size of\n      the shared secret, but\
    \ the mathematics for computing the shared\n      secret.  The curve selected\
    \ also controls how a point in the curve\n      is represented and what happens\
    \ for the identity points on the\n      curve.  In this specification, we allow\
    \ for a number of different\n      curves to be used.  A set of curves are defined\
    \ in Table 22.\n      The math used to obtain the computed secret is based on\
    \ the curve\n      selected and not on the ECDH algorithm.  For this reason, a\
    \ new\n      algorithm does not need to be defined for each of the curves.\n \
    \  o  Computed Secret to Shared Secret: Once the computed secret is\n      known,\
    \ the resulting value needs to be converted to a byte string\n      to run the\
    \ KDF.  The x-coordinate is used for all of the curves\n      defined in this\
    \ document.  For curves X25519 and X448, the\n      resulting value is used directly\
    \ as it is a byte string of a known\n      length.  For the P-256, P-384, and\
    \ P-521 curves, the x-coordinate\n      is run through the I2OSP function defined\
    \ in [RFC8017], using the\n      same computation for n as is defined in Section\
    \ 8.1.\n   o  Ephemeral-Static or Static-Static: The key agreement process may\n\
    \      be done using either a static or an ephemeral key for the sender's\n  \
    \    side.  When using ephemeral keys, the sender MUST generate a new\n      ephemeral\
    \ key for every key agreement operation.  The ephemeral\n      key is placed in\
    \ the 'ephemeral key' parameter and MUST be present\n      for all algorithm identifiers\
    \ that use ephemeral keys.  When using\n      static keys, the sender MUST either\
    \ generate a new random value or\n      create a unique value.  For the KDFs used,\
    \ this means either the\n      'salt' parameter for HKDF (Table 13) or the 'PartyU\
    \ nonce'\n      parameter for the context structure (Table 14) MUST be present\n\
    \      (both can be present if desired).  The value in the parameter MUST\n  \
    \    be unique for the pair of keys being used.  It is acceptable to\n      use\
    \ a global counter that is incremented for every static-static\n      operation\
    \ and use the resulting value.  When using static keys,\n      the static key\
    \ should be identified to the recipient.  The static\n      key can be identified\
    \ either by providing the key ('static key')\n      or by providing a key identifier\
    \ for the static key ('static key\n      id').  Both of these parameters are defined\
    \ in Table 19.\n   o  Key Derivation Algorithm: The result of an ECDH key agreement\n\
    \      process does not provide a uniformly random secret.  As such, it\n    \
    \  needs to be run through a KDF in order to produce a usable key.\n      Processing\
    \ the secret through a KDF also allows for the\n      introduction of context\
    \ material: how the key is going to be used\n      and one-time material for static-static\
    \ key agreement.  All of the\n      algorithms defined in this document use one\
    \ of the HKDF algorithms\n      defined in Section 11.1 with the context structure\
    \ defined in\n      Section 11.2.\n   o  Key Wrap Algorithm: No key wrap algorithm\
    \ is used.  This is\n      represented in Table 18 as 'none'.  The key size for\
    \ the context\n      structure is the content layer encryption algorithm size.\n\
    \   The set of direct ECDH algorithms defined in this document are found\n   in\
    \ Table 18.\n   +-----------+-------+---------+------------+--------+---------------+\n\
    \   | Name      | Value | KDF     | Ephemeral- | Key    | Description   |\n  \
    \ |           |       |         | Static     | Wrap   |               |\n   +-----------+-------+---------+------------+--------+---------------+\n\
    \   | ECDH-ES + | -25   | HKDF -  | yes        | none   | ECDH ES w/    |\n  \
    \ | HKDF-256  |       | SHA-256 |            |        | HKDF -        |\n   |\
    \           |       |         |            |        | generate key  |\n   |  \
    \         |       |         |            |        | directly      |\n   | ECDH-ES\
    \ + | -26   | HKDF -  | yes        | none   | ECDH ES w/    |\n   | HKDF-512 \
    \ |       | SHA-512 |            |        | HKDF -        |\n   |           |\
    \       |         |            |        | generate key  |\n   |           |  \
    \     |         |            |        | directly      |\n   | ECDH-SS + | -27\
    \   | HKDF -  | no         | none   | ECDH SS w/    |\n   | HKDF-256  |      \
    \ | SHA-256 |            |        | HKDF -        |\n   |           |       |\
    \         |            |        | generate key  |\n   |           |       |  \
    \       |            |        | directly      |\n   | ECDH-SS + | -28   | HKDF\
    \ -  | no         | none   | ECDH SS w/    |\n   | HKDF-512  |       | SHA-512\
    \ |            |        | HKDF -        |\n   |           |       |         |\
    \            |        | generate key  |\n   |           |       |         |  \
    \          |        | directly      |\n   +-----------+-------+---------+------------+--------+---------------+\n\
    \                      Table 18: ECDH Algorithm Values\n   +-----------+-------+----------+---------------------+--------------+\n\
    \   | Name      | Label | Type     | Algorithm           | Description  |\n  \
    \ +-----------+-------+----------+---------------------+--------------+\n   |\
    \ ephemeral | -1    | COSE_Key | ECDH-ES+HKDF-256,   | Ephemeral    |\n   | key\
    \       |       |          | ECDH-ES+HKDF-512,   | public key   |\n   |      \
    \     |       |          | ECDH-ES+A128KW,     | for the      |\n   |        \
    \   |       |          | ECDH-ES+A192KW,     | sender       |\n   |          \
    \ |       |          | ECDH-ES+A256KW      |              |\n   | static    |\
    \ -2    | COSE_Key | ECDH-SS+HKDF-256,   | Static       |\n   | key       |  \
    \     |          | ECDH-SS+HKDF-512,   | public key   |\n   |           |    \
    \   |          | ECDH-SS+A128KW,     | for the      |\n   |           |      \
    \ |          | ECDH-SS+A192KW,     | sender       |\n   |           |       |\
    \          | ECDH-SS+A256KW      |              |\n   | static    | -3    | bstr\
    \     | ECDH-SS+HKDF-256,   | Static       |\n   | key id    |       |       \
    \   | ECDH-SS+HKDF-512,   | public key   |\n   |           |       |         \
    \ | ECDH-SS+A128KW,     | identifier   |\n   |           |       |          |\
    \ ECDH-SS+A192KW,     | for the      |\n   |           |       |          | ECDH-SS+A256KW\
    \      | sender       |\n   +-----------+-------+----------+---------------------+--------------+\n\
    \                    Table 19: ECDH Algorithm Parameters\n   This document defines\
    \ these algorithms to be used with the curves\n   P-256, P-384, P-521, X25519,\
    \ and X448.  Implementations MUST verify\n   that the key type and curve are correct.\
    \  Different curves are\n   restricted to different key types.  Implementations\
    \ MUST verify that\n   the curve and algorithm are appropriate for the entities\
    \ involved.\n   When using a COSE key for this algorithm, the following checks\
    \ are\n   made:\n   o  The 'kty' field MUST be present, and it MUST be 'EC2' or\
    \ 'OKP'.\n   o  If the 'alg' field is present, it MUST match the key agreement\n\
    \      algorithm being used.\n   o  If the 'key_ops' field is present, it MUST\
    \ include 'derive key' or\n      'derive bits' for the private key.\n   o  If\
    \ the 'key_ops' field is present, it MUST be empty for the public\n      key.\n"
- title: 12.4.2.  Security Considerations
  contents:
  - "12.4.2.  Security Considerations\n   There is a method of checking that points\
    \ provided from external\n   entities are valid.  For the 'EC2' key format, this\
    \ can be done by\n   checking that the x and y values form a point on the curve.\
    \  For the\n   'OKP' format, there is no simple way to do point validation.\n\
    \   Consideration was given to requiring that the public keys of both\n   entities\
    \ be provided as part of the key derivation process (as\n   recommended in Section\
    \ 6.1 of [RFC7748]).  This was not done as COSE\n   is used in a store and forward\
    \ format rather than in online key\n   exchange.  In order for this to be a problem,\
    \ either the receiver\n   public key has to be chosen maliciously or the sender\
    \ has to be\n   malicious.  In either case, all security evaporates anyway.\n\
    \   A proof of possession of the private key associated with the public\n   key\
    \ is recommended when a key is moved from untrusted to trusted\n   (either by\
    \ the end user or by the entity that is responsible for\n   making trust statements\
    \ on keys).\n"
- title: 12.5.  Key Agreement with Key Wrap
  contents:
  - "12.5.  Key Agreement with Key Wrap\n   Key Agreement with Key Wrap uses a randomly\
    \ generated CEK.  The CEK\n   is then encrypted using a key wrap algorithm and\
    \ a key derived from\n   the shared secret computed by the key agreement algorithm.\
    \  The\n   function for this would be:\n   encryptedKey = KeyWrap(KDF(DH-Shared,\
    \ context), CEK)\n   The COSE_Encrypt structure for the recipient is organized\
    \ as follows:\n   o  The 'protected' field is fed into the KDF context structure.\n\
    \   o  The plaintext to be encrypted is the key from the next layer down\n   \
    \   (usually the content layer).\n   o  The 'alg' parameter MUST be present in\
    \ the layer.\n   o  A parameter identifying the recipient's key SHOULD be present.\
    \  A\n      parameter identifying the sender's key SHOULD be present.\n"
- title: 12.5.1.  ECDH
  contents:
  - "12.5.1.  ECDH\n   These algorithms are defined in Table 20.\n   ECDH with Key\
    \ Agreement is parameterized by the same parameters as\n   for ECDH; see Section\
    \ 12.4.1, with the following modifications:\n   o  Key Wrap Algorithm: Any of\
    \ the key wrap algorithms defined in\n      Section 12.2.1 are supported.  The\
    \ size of the key used for the\n      key wrap algorithm is fed into the KDF.\
    \  The set of identifiers\n      are found in Table 20.\n   +-----------+-------+---------+------------+--------+---------------+\n\
    \   | Name      | Value | KDF     | Ephemeral- | Key    | Description   |\n  \
    \ |           |       |         | Static     | Wrap   |               |\n   +-----------+-------+---------+------------+--------+---------------+\n\
    \   | ECDH-ES + | -29   | HKDF -  | yes        | A128KW | ECDH ES w/    |\n  \
    \ | A128KW    |       | SHA-256 |            |        | Concat KDF    |\n   |\
    \           |       |         |            |        | and AES Key   |\n   |  \
    \         |       |         |            |        | Wrap w/       |\n   |    \
    \       |       |         |            |        | 128-bit key   |\n   |      \
    \     |       |         |            |        |               |\n   | ECDH-ES\
    \ + | -30   | HKDF -  | yes        | A192KW | ECDH ES w/    |\n   | A192KW   \
    \ |       | SHA-256 |            |        | Concat KDF    |\n   |           |\
    \       |         |            |        | and AES Key   |\n   |           |  \
    \     |         |            |        | Wrap w/       |\n   |           |    \
    \   |         |            |        | 192-bit key   |\n   |           |      \
    \ |         |            |        |               |\n   | ECDH-ES + | -31   |\
    \ HKDF -  | yes        | A256KW | ECDH ES w/    |\n   | A256KW    |       | SHA-256\
    \ |            |        | Concat KDF    |\n   |           |       |         |\
    \            |        | and AES Key   |\n   |           |       |         |  \
    \          |        | Wrap w/       |\n   |           |       |         |    \
    \        |        | 256-bit key   |\n   |           |       |         |      \
    \      |        |               |\n   | ECDH-SS + | -32   | HKDF -  | no     \
    \    | A128KW | ECDH SS w/    |\n   | A128KW    |       | SHA-256 |          \
    \  |        | Concat KDF    |\n   |           |       |         |            |\
    \        | and AES Key   |\n   |           |       |         |            |  \
    \      | Wrap w/       |\n   |           |       |         |            |    \
    \    | 128-bit key   |\n   |           |       |         |            |      \
    \  |               |\n   | ECDH-SS + | -33   | HKDF -  | no         | A192KW |\
    \ ECDH SS w/    |\n   | A192KW    |       | SHA-256 |            |        | Concat\
    \ KDF    |\n   |           |       |         |            |        | and AES Key\
    \   |\n   |           |       |         |            |        | Wrap w/      \
    \ |\n   |           |       |         |            |        | 192-bit key   |\n\
    \   |           |       |         |            |        |               |\n  \
    \ | ECDH-SS + | -34   | HKDF -  | no         | A256KW | ECDH SS w/    |\n   |\
    \ A256KW    |       | SHA-256 |            |        | Concat KDF    |\n   |  \
    \         |       |         |            |        | and AES Key   |\n   |    \
    \       |       |         |            |        | Wrap w/       |\n   |      \
    \     |       |         |            |        | 256-bit key   |\n   +-----------+-------+---------+------------+--------+---------------+\n\
    \               Table 20: ECDH Algorithm Values with Key Wrap\n   When using a\
    \ COSE key for this algorithm, the following checks are\n   made:\n   o  The 'kty'\
    \ field MUST be present, and it MUST be 'EC2' or 'OKP'.\n   o  If the 'alg' field\
    \ is present, it MUST match the key agreement\n      algorithm being used.\n \
    \  o  If the 'key_ops' field is present, it MUST include 'derive key' or\n   \
    \   'derive bits' for the private key.\n   o  If the 'key_ops' field is present,\
    \ it MUST be empty for the public\n      key.\n"
- title: 13.  Key Object Parameters
  contents:
  - "13.  Key Object Parameters\n   The COSE_Key object defines a way to hold a single\
    \ key object.  It is\n   still required that the members of individual key types\
    \ be defined.\n   This section of the document is where we define an initial set\
    \ of\n   members for specific key types.\n   For each of the key types, we define\
    \ both public and private members.\n   The public members are what is transmitted\
    \ to others for their usage.\n   Private members allow for the archival of keys\
    \ by individuals.\n   However, there are some circumstances in which private keys\
    \ may be\n   distributed to entities in a protocol.  Examples include: entities\n\
    \   that have poor random number generation, centralized key creation for\n  \
    \ multi-cast type operations, and protocols in which a shared secret is\n   used\
    \ as a bearer token for authorization purposes.\n   Key types are identified by\
    \ the 'kty' member of the COSE_Key object.\n   In this document, we define four\
    \ values for the member:\n   +-----------+-------+-----------------------------------------------+\n\
    \   | Name      | Value | Description                                   |\n  \
    \ +-----------+-------+-----------------------------------------------+\n   |\
    \ OKP       | 1     | Octet Key Pair                                |\n   | EC2\
    \       | 2     | Elliptic Curve Keys w/ x- and y-coordinate    |\n   |      \
    \     |       | pair                                          |\n   | Symmetric\
    \ | 4     | Symmetric Keys                                |\n   | Reserved  |\
    \ 0     | This value is reserved                        |\n   +-----------+-------+-----------------------------------------------+\n\
    \                         Table 21: Key Type Values\n"
- title: 13.1.  Elliptic Curve Keys
  contents:
  - "13.1.  Elliptic Curve Keys\n   Two different key structures are defined for elliptic\
    \ curve keys.\n   One version uses both an x-coordinate and a y-coordinate, potentially\n\
    \   with point compression ('EC2').  This is the traditional EC point\n   representation\
    \ that is used in [RFC5480].  The other version uses\n   only the x-coordinate\
    \ as the y-coordinate is either to be recomputed\n   or not needed for the key\
    \ agreement operation ('OKP').\n   Applications MUST check that the curve and\
    \ the key type are\n   consistent and reject a key if they are not.\n    +---------+-------+----------+------------------------------------+\n\
    \    | Name    | Value | Key Type | Description                        |\n   \
    \ +---------+-------+----------+------------------------------------+\n    | P-256\
    \   | 1     | EC2      | NIST P-256 also known as secp256r1 |\n    | P-384   |\
    \ 2     | EC2      | NIST P-384 also known as secp384r1 |\n    | P-521   | 3 \
    \    | EC2      | NIST P-521 also known as secp521r1 |\n    | X25519  | 4    \
    \ | OKP      | X25519 for use w/ ECDH only        |\n    | X448    | 5     | OKP\
    \      | X448 for use w/ ECDH only          |\n    | Ed25519 | 6     | OKP   \
    \   | Ed25519 for use w/ EdDSA only      |\n    | Ed448   | 7     | OKP      |\
    \ Ed448 for use w/ EdDSA only        |\n    +---------+-------+----------+------------------------------------+\n\
    \                         Table 22: Elliptic Curves\n"
- title: 13.1.1.  Double Coordinate Curves
  contents:
  - "13.1.1.  Double Coordinate Curves\n   The traditional way of sending ECs has\
    \ been to send either both the\n   x-coordinate and y-coordinate or the x-coordinate\
    \ and a sign bit for\n   the y-coordinate.  The latter encoding has not been recommended\
    \ in\n   the IETF due to potential IPR issues.  However, for operations in\n \
    \  constrained environments, the ability to shrink a message by not\n   sending\
    \ the y-coordinate is potentially useful.\n   For EC keys with both coordinates,\
    \ the 'kty' member is set to 2\n   (EC2).  The key parameters defined in this\
    \ section are summarized in\n   Table 23.  The members that are defined for this\
    \ key type are:\n   crv: This contains an identifier of the curve to be used with\
    \ the\n        key.  The curves defined in this document for this key type can\n\
    \        be found in Table 22.  Other curves may be registered in the\n      \
    \  future, and private curves can be used as well.\n   x:   This contains the\
    \ x-coordinate for the EC point.  The integer is\n        converted to an octet\
    \ string as defined in [SEC1].  Leading zero\n        octets MUST be preserved.\n\
    \   y:   This contains either the sign bit or the value of the\n        y-coordinate\
    \ for the EC point.  When encoding the value y, the\n        integer is converted\
    \ to an octet string (as defined in [SEC1])\n        and encoded as a CBOR bstr.\
    \  Leading zero octets MUST be\n        preserved.  The compressed point encoding\
    \ is also supported.\n        Compute the sign bit as laid out in the Elliptic-Curve-Point-to-\n\
    \        Octet-String Conversion function of [SEC1].  If the sign bit is\n   \
    \     zero, then encode y as a CBOR false value; otherwise, encode y\n       \
    \ as a CBOR true value.  The encoding of the infinity point is not\n        supported.\n\
    \   d:   This contains the private key.\n   For public keys, it is REQUIRED that\
    \ 'crv', 'x', and 'y' be present\n   in the structure.  For private keys, it is\
    \ REQUIRED that 'crv' and\n   'd' be present in the structure.  For private keys,\
    \ it is RECOMMENDED\n   that 'x' and 'y' also be present, but they can be recomputed\
    \ from the\n   required elements and omitting them saves on space.\n   +-------+------+-------+--------+-----------------------------------+\n\
    \   | Key   | Name | Label | CBOR   | Description                       |\n  \
    \ | Type  |      |       | Type   |                                   |\n   +-------+------+-------+--------+-----------------------------------+\n\
    \   | 2     | crv  | -1    | int /  | EC identifier - Taken from the    |\n  \
    \ |       |      |       | tstr   | \"COSE Elliptic Curves\" registry   |\n  \
    \ | 2     | x    | -2    | bstr   | x-coordinate                      |\n   |\
    \ 2     | y    | -3    | bstr / | y-coordinate                      |\n   |  \
    \     |      |       | bool   |                                   |\n   | 2  \
    \   | d    | -4    | bstr   | Private key                       |\n   +-------+------+-------+--------+-----------------------------------+\n\
    \                        Table 23: EC Key Parameters\n"
- title: 13.2.  Octet Key Pair
  contents:
  - "13.2.  Octet Key Pair\n   A new key type is defined for Octet Key Pairs (OKP).\
    \  Do not assume\n   that keys using this type are elliptic curves.  This key\
    \ type could\n   be used for other curve types (for example, mathematics based\
    \ on\n   hyper-elliptic surfaces).\n   The key parameters defined in this section\
    \ are summarized in\n   Table 24.  The members that are defined for this key type\
    \ are:\n   crv: This contains an identifier of the curve to be used with the\n\
    \        key.  The curves defined in this document for this key type can\n   \
    \     be found in Table 22.  Other curves may be registered in the\n        future\
    \ and private curves can be used as well.\n   x:   This contains the x-coordinate\
    \ for the EC point.  The octet\n        string represents a little-endian encoding\
    \ of x.\n   d:   This contains the private key.\n   For public keys, it is REQUIRED\
    \ that 'crv' and 'x' be present in the\n   structure.  For private keys, it is\
    \ REQUIRED that 'crv' and 'd' be\n   present in the structure.  For private keys,\
    \ it is RECOMMENDED that\n   'x' also be present, but it can be recomputed from\
    \ the required\n   elements and omitting it saves on space.\n   +------+-------+-------+--------+-----------------------------------+\n\
    \   | Name | Key   | Label | Type   | Description                       |\n  \
    \ |      | Type  |       |        |                                   |\n   +------+-------+-------+--------+-----------------------------------+\n\
    \   | crv  | 1     | -1    | int /  | EC identifier - Taken from the    |\n  \
    \ |      |       |       | tstr   | \"COSE Key Common Parameters\"      |\n  \
    \ |      |       |       |        | registry                          |\n   |\
    \ x    | 1     | -2    | bstr   | x-coordinate                      |\n   | d\
    \    | 1     | -4    | bstr   | Private key                       |\n   +------+-------+-------+--------+-----------------------------------+\n\
    \                    Table 24: Octet Key Pair Parameters\n"
- title: 13.3.  Symmetric Keys
  contents:
  - "13.3.  Symmetric Keys\n   Occasionally it is required that a symmetric key be\
    \ transported\n   between entities.  This key structure allows for that to happen.\n\
    \   For symmetric keys, the 'kty' member is set to 4 ('Symmetric').  The\n   member\
    \ that is defined for this key type is:\n   k: This contains the value of the\
    \ key.\n   This key structure does not have a form that contains only public\n\
    \   members.  As it is expected that this key structure is going to be\n   transmitted,\
    \ care must be taken that it is never transmitted\n   accidentally or insecurely.\
    \  For symmetric keys, it is REQUIRED that\n   'k' be present in the structure.\n\
    \             +------+----------+-------+------+-------------+\n             |\
    \ Name | Key Type | Label | Type | Description |\n             +------+----------+-------+------+-------------+\n\
    \             | k    | 4        | -1    | bstr | Key Value   |\n             +------+----------+-------+------+-------------+\n\
    \                    Table 25: Symmetric Key Parameters\n"
- title: 14.  CBOR Encoder Restrictions
  contents:
  - "14.  CBOR Encoder Restrictions\n   There has been an attempt to limit the number\
    \ of places where the\n   document needs to impose restrictions on how the CBOR\
    \ Encoder needs\n   to work.  We have managed to narrow it down to the following\n\
    \   restrictions:\n   o  The restriction applies to the encoding of the Sig_structure,\
    \ the\n      Enc_structure, and the MAC_structure.\n   o  The rules for \"Canonical\
    \ CBOR\" (Section 3.9 of RFC 7049) MUST be\n      used in these locations.  The\
    \ main rule that needs to be enforced\n      is that all lengths in these structures\
    \ MUST be encoded such that\n      they are using definite lengths, and the minimum\
    \ length encoding\n      is used.\n   o  Applications MUST NOT generate messages\
    \ with the same label used\n      twice as a key in a single map.  Applications\
    \ MUST NOT parse and\n      process messages with the same label used twice as\
    \ a key in a\n      single map.  Applications can enforce the parse and process\n\
    \      requirement by using parsers that will fail the parse step or by\n    \
    \  using parsers that will pass all keys to the application, and the\n      application\
    \ can perform the check for duplicate keys.\n"
- title: 15.  Application Profiling Considerations
  contents:
  - "15.  Application Profiling Considerations\n   This document is designed to provide\
    \ a set of security services, but\n   not implementation requirements for specific\
    \ usage.  The\n   interoperability requirements are provided for how each of the\n\
    \   individual services are used and how the algorithms are to be used\n   for\
    \ interoperability.  The requirements about which algorithms and\n   which services\
    \ are needed are deferred to each application.\n   An example of a profile can\
    \ be found in [OSCOAP] where two profiles\n   are being developed.  One is for\
    \ carrying content by itself, and the\n   other is for carrying content in combination\
    \ with CoAP headers.\n   It is intended that a profile of this document be created\
    \ that\n   defines the interoperability requirements for that specific\n   application.\
    \  This section provides a set of guidelines and topics\n   that need to be considered\
    \ when profiling this document.\n   o  Applications need to determine the set\
    \ of messages defined in this\n      document that they will be using.  The set\
    \ of messages corresponds\n      fairly directly to the set of security services\
    \ that are needed\n      and to the security levels needed.\n   o  Applications\
    \ may define new header parameters for a specific\n      purpose.  Applications\
    \ will often times select specific header\n      parameters to use or not to use.\
    \  For example, an application\n      would normally state a preference for using\
    \ either the IV or the\n      Partial IV parameter.  If the Partial IV parameter\
    \ is specified,\n      then the application would also need to define how the\
    \ fixed\n      portion of the IV would be determined.\n   o  When applications\
    \ use externally defined authenticated data, they\n      need to define how that\
    \ data is encoded.  This document assumes\n      that the data will be provided\
    \ as a byte stream.  More information\n      can be found in Section 4.3.\n  \
    \ o  Applications need to determine the set of security algorithms that\n    \
    \  are to be used.  When selecting the algorithms to be used as the\n      mandatory-to-implement\
    \ set, consideration should be given to\n      choosing different types of algorithms\
    \ when two are chosen for a\n      specific purpose.  An example of this would\
    \ be choosing HMAC-\n      SHA512 and AES-CMAC as different MAC algorithms; the\
    \ construction\n      is vastly different between these two algorithms.  This\
    \ means that\n      a weakening of one algorithm would be unlikely to lead to\
    \ a\n      weakening of the other algorithms.  Of course, these algorithms do\n\
    \      not provide the same level of security and thus may not be\n      comparable\
    \ for the desired security functionality.\n   o  Applications may need to provide\
    \ some type of negotiation or\n      discovery method if multiple algorithms or\
    \ message structures are\n      permitted.  The method can be as simple as requiring\n\
    \      preconfiguration of the set of algorithms to providing a discovery\n  \
    \    method built into the protocol.  S/MIME provided a number of\n      different\
    \ ways to approach the problem that applications could\n      follow:\n      *\
    \  Advertising in the message (S/MIME capabilities) [RFC5751].\n      *  Advertising\
    \ in the certificate (capabilities extension)\n         [RFC4262].\n      *  Minimum\
    \ requirements for the S/MIME, which have been updated\n         over time [RFC2633]\
    \ [RFC5751] (note that [RFC2633] has been\n         obsoleted by [RFC5751]).\n"
- title: 16.  IANA Considerations
  contents:
  - '16.  IANA Considerations

    '
- title: 16.1.  CBOR Tag Assignment
  contents:
  - "16.1.  CBOR Tag Assignment\n   IANA has assigned the following tags from the\
    \ \"CBOR Tags\" registry.\n   The tags for COSE_Sign1, COSE_Encrypt0, and COSE_Mac0\
    \ were assigned\n   in the 1 to 23 value range (one byte long when encoded). \
    \ The tags\n   for COSE_Sign, COSE_Encrypt, and COSE_Mac were assigned in the\
    \ 24 to\n   255 value range (two bytes long when encoded).\n   The tags assigned\
    \ are in Table 1.\n"
- title: 16.2.  COSE Header Parameters Registry
  contents:
  - "16.2.  COSE Header Parameters Registry\n   IANA has created a new registry titled\
    \ \"COSE Header Parameters\".  The\n   registry has been created to use the \"\
    Expert Review Required\"\n   registration procedure [RFC8126].  Guidelines for\
    \ the experts are\n   provided in Section 16.11.  It should be noted that, in\
    \ addition to\n   the expert review, some portions of the registry require a\n\
    \   specification, potentially a Standards Track RFC, be supplied as\n   well.\n\
    \   The columns of the registry are:\n   Name:  The name is present to make it\
    \ easier to refer to and discuss\n      the registration entry.  The value is\
    \ not used in the protocol.\n      Names are to be unique in the table.\n   Label:\
    \  This is the value used for the label.  The label can be\n      either an integer\
    \ or a string.  Registration in the table is based\n      on the value of the\
    \ label requested.  Integer values between 1 and\n      255 and strings of length\
    \ 1 are designated as \"Standards Action\".\n      Integer values from 256 to\
    \ 65535 and strings of length 2 are\n      designated as \"Specification Required\"\
    .  Integer values of greater\n      than 65535 and strings of length greater than\
    \ 2 are designated as\n      \"Expert Review\".  Integer values in the range -1\
    \ to -65536 are\n      \"delegated to the COSE Header Algorithm Parameters registry\"\
    .\n      Integer values less than -65536 are marked as private use.\n   Value\
    \ Type:  This contains the CBOR type for the value portion of the\n      label.\n\
    \   Value Registry:  This contains a pointer to the registry used to\n      contain\
    \ values where the set is limited.\n   Description:  This contains a brief description\
    \ of the header field.\n   Reference:  This contains a pointer to the specification\
    \ defining the\n      header field (where public).\n   The initial contents of\
    \ the registry can be found in Tables 2 and 27.\n   All of the entries in the\
    \ \"References\" column of this registry point\n   to this document.\n   Additionally,\
    \ the label of 0 is to be marked as 'Reserved'.\n"
- title: 16.3.  COSE Header Algorithm Parameters Registry
  contents:
  - "16.3.  COSE Header Algorithm Parameters Registry\n   IANA has created a new registry\
    \ titled \"COSE Header Algorithm\n   Parameters\".  The registry uses the \"Expert\
    \ Review Required\"\n   registration procedure.  Expert review guidelines are\
    \ provided in\n   Section 16.11.\n   The columns of the registry are:\n   Name:\
    \  The name is present to make it easier to refer to and discuss\n      the registration\
    \ entry.  The value is not used in the protocol.\n   Algorithm:  The algorithm(s)\
    \ that this registry entry is used for.\n      This value is taken from the \"\
    COSE Algorithms\" registry.  Multiple\n      algorithms can be specified in this\
    \ entry.  For the table, the\n      algorithm/label pair MUST be unique.\n   Label:\
    \  This is the value used for the label.  The label is an\n      integer in the\
    \ range of -1 to -65536.\n   Type:  This contains the CBOR type for the value\
    \ portion of the\n      label.\n   Description:  This contains a brief description\
    \ of the header field.\n   Reference:  This contains a pointer to the specification\
    \ defining the\n      header field (where public).\n   The initial contents of\
    \ the registry can be found in Tables 13, 14,\n   and 19.  All of the entries\
    \ in the \"References\" column of this\n   registry point to this document.\n"
- title: 16.4.  COSE Algorithms Registry
  contents:
  - "16.4.  COSE Algorithms Registry\n   IANA has created a new registry titled \"\
    COSE Algorithms\".  The\n   registry has been created to use the \"Expert Review\
    \ Required\"\n   registration procedure.  Guidelines for the experts are provided\
    \ in\n   Section 16.11.  It should be noted that, in addition to the expert\n\
    \   review, some portions of the registry require a specification,\n   potentially\
    \ a Standards Track RFC, be supplied as well.\n   The columns of the registry\
    \ are:\n   Name:  A value that can be used to identify an algorithm in documents\n\
    \      for easier comprehension.  The name SHOULD be unique.  However,\n     \
    \ the 'Value' field is what is used to identify the algorithm, not\n      the\
    \ 'name' field.\n   Value:  The value to be used to identify this algorithm. \
    \ Algorithm\n      values MUST be unique.  The value can be a positive integer,\
    \ a\n      negative integer, or a string.  Integer values between -256 and\n \
    \     255 and strings of length 1 are designated as \"Standards Action\".\n  \
    \    Integer values from -65536 to 65535 and strings of length 2 are\n      designated\
    \ as \"Specification Required\".  Integer values greater\n      than 65535 and\
    \ strings of length greater than 2 are designated as\n      \"Expert Review\"\
    .  Integer values less than -65536 are marked as\n      private use.\n   Description:\
    \  A short description of the algorithm.\n   Reference:  A document where the\
    \ algorithm is defined (if publicly\n      available).\n   Recommended:  Does\
    \ the IETF have a consensus recommendation to use\n      the algorithm?  The legal\
    \ values are 'Yes', 'No', and\n      'Deprecated'.\n   The initial contents of\
    \ the registry can be found in Tables 5, 6, 7,\n   8, 9, 10, 11, 15, 16, 17, 18,\
    \ and 20.  All of the entries in the\n   \"References\" column of this registry\
    \ point to this document.  All of\n   the entries in the \"Recommended\" column\
    \ are set to \"Yes\".\n   Additionally, the label of 0 is to be marked as 'Reserved'.\n\
    \   NOTE: The assignment of algorithm identifiers in this document was\n   done\
    \ so that positive numbers were used for the first layer objects\n   (COSE_Sign,\
    \ COSE_Sign1, COSE_Encrypt, COSE_Encrypt0, COSE_Mac, and\n   COSE_Mac0).  Negative\
    \ numbers were used for second layer objects\n   (COSE_Signature and COSE_recipient).\
    \  Expert reviewers should\n   consider this practice, but are not expected to\
    \ be restricted by this\n   precedent.\n"
- title: 16.5.  COSE Key Common Parameters Registry
  contents:
  - "16.5.  COSE Key Common Parameters Registry\n   IANA has created a new registry\
    \ titled \"COSE Key Common Parameters\".\n   The registry has been created to\
    \ use the \"Expert Review Required\"\n   registration procedure.  Guidelines for\
    \ the experts are provided in\n   Section 16.11.  It should be noted that, in\
    \ addition to the expert\n   review, some portions of the registry require a specification,\n\
    \   potentially a Standards Track RFC, be supplied as well.\n   The columns of\
    \ the registry are:\n   Name:  This is a descriptive name that enables easier\
    \ reference to\n      the item.  It is not used in the encoding.\n   Label:  The\
    \ value to be used to identify this algorithm.  Key map\n      labels MUST be\
    \ unique.  The label can be a positive integer, a\n      negative integer, or\
    \ a string.  Integer values between 0 and 255\n      and strings of length 1 are\
    \ designated as \"Standards Action\".\n      Integer values from 256 to 65535\
    \ and strings of length 2 are\n      designated as \"Specification Required\"\
    .  Integer values of greater\n      than 65535 and strings of length greater than\
    \ 2 are designated as\n      \"Expert Review\".  Integer values in the range -65536\
    \ to -1 are\n      \"used for key parameters specific to a single algorithm delegated\n\
    \      to the COSE Key Type Parameters registry\".  Integer values less\n    \
    \  than -65536 are marked as private use.\n   CBOR Type:  This field contains\
    \ the CBOR type for the field.\n   Value Registry:  This field denotes the registry\
    \ that values come\n      from, if one exists.\n   Description:  This field contains\
    \ a brief description for the field.\n   Reference:  This contains a pointer to\
    \ the public specification for\n      the field if one exists.\n   This registry\
    \ has been initially populated by the values in Table 3.\n   All of the entries\
    \ in the \"References\" column of this registry point\n   to this document.\n"
- title: 16.6.  COSE Key Type Parameters Registry
  contents:
  - "16.6.  COSE Key Type Parameters Registry\n   IANA has created a new registry\
    \ titled \"COSE Key Type Parameters\".\n   The registry has been created to use\
    \ the \"Expert Review Required\"\n   registration procedure.  Expert review guidelines\
    \ are provided in\n   Section 16.11.\n   The columns of the table are:\n   Key\
    \ Type:  This field contains a descriptive string of a key type.\n      This should\
    \ be a value that is in the \"COSE Key Common Parameters\"\n      registry and\
    \ is placed in the 'kty' field of a COSE Key structure.\n   Name:  This is a descriptive\
    \ name that enables easier reference to\n      the item.  It is not used in the\
    \ encoding.\n   Label:  The label is to be unique for every value of key type.\
    \  The\n      range of values is from -65536 to -1.  Labels are expected to be\n\
    \      reused for different keys.\n   CBOR Type:  This field contains the CBOR\
    \ type for the field.\n   Description:  This field contains a brief description\
    \ for the field.\n   Reference:  This contains a pointer to the public specification\
    \ for\n      the field if one exists.\n   This registry has been initially populated\
    \ by the values in Tables\n   23, 24, and 25.  All of the entries in the \"References\"\
    \ column of\n   this registry point to this document.\n"
- title: 16.7.  COSE Key Types Registry
  contents:
  - "16.7.  COSE Key Types Registry\n   IANA has created a new registry titled \"\
    COSE Key Types\".  The\n   registry has been created to use the \"Expert Review\
    \ Required\"\n   registration procedure.  Expert review guidelines are provided\
    \ in\n   Section 16.11.\n   The columns of this table are:\n   Name:  This is\
    \ a descriptive name that enables easier reference to\n      the item.  The name\
    \ MUST be unique.  It is not used in the\n      encoding.\n   Value:  This is\
    \ the value used to identify the curve.  These values\n      MUST be unique. \
    \ The value can be a positive integer, a negative\n      integer, or a string.\n\
    \   Description:  This field contains a brief description of the curve.\n   References:\
    \  This contains a pointer to the public specification for\n      the curve if\
    \ one exists.\n   This registry has been initially populated by the values in\
    \ Table 21.\n   The specification column for all of these entries will be this\n\
    \   document.\n"
- title: 16.8.  COSE Elliptic Curves Registry
  contents:
  - "16.8.  COSE Elliptic Curves Registry\n   IANA has created a new registry titled\
    \ \"COSE Elliptic Curves\".  The\n   registry has been created to use the \"Expert\
    \ Review Required\"\n   registration procedure.  Guidelines for the experts are\
    \ provided in\n   Section 16.11.  It should be noted that, in addition to the\
    \ expert\n   review, some portions of the registry require a specification,\n\
    \   potentially a Standards Track RFC, be supplied as well.\n   The columns of\
    \ the table are:\n   Name:  This is a descriptive name that enables easier reference\
    \ to\n      the item.  It is not used in the encoding.\n   Value:  This is the\
    \ value used to identify the curve.  These values\n      MUST be unique.  The\
    \ integer values from -256 to 255 are\n      designated as \"Standards Action\"\
    .  The integer values from 256 to\n      65535 and -65536 to -257 are designated\
    \ as \"Specification\n      Required\".  Integer values over 65535 are designated\
    \ as \"Expert\n      Review\".  Integer values less than -65536 are marked as\
    \ private\n      use.\n   Key Type:  This designates the key type(s) that can\
    \ be used with this\n      curve.\n   Description:  This field contains a brief\
    \ description of the curve.\n   Reference:  This contains a pointer to the public\
    \ specification for\n      the curve if one exists.\n   Recommended:  Does the\
    \ IETF have a consensus recommendation to use\n      the algorithm?  The legal\
    \ values are 'Yes', 'No', and\n      'Deprecated'.\n   This registry has been\
    \ initially populated by the values in Table 22.\n   All of the entries in the\
    \ \"References\" column of this registry point\n   to this document.  All of the\
    \ entries in the \"Recommended\" column are\n   set to \"Yes\".\n"
- title: 16.9.  Media Type Registrations
  contents:
  - '16.9.  Media Type Registrations

    '
- title: 16.9.1.  COSE Security Message
  contents:
  - "16.9.1.  COSE Security Message\n   This section registers the 'application/cose'\
    \ media type in the\n   \"Media Types\" registry.  These media types are used\
    \ to indicate that\n   the content is a COSE message.\n      Type name: application\n\
    \      Subtype name: cose\n      Required parameters: N/A\n      Optional parameters:\
    \ cose-type\n      Encoding considerations: binary\n      Security considerations:\
    \ See the Security Considerations section\n      of RFC 8152.\n      Interoperability\
    \ considerations: N/A\n      Published specification: RFC 8152\n      Applications\
    \ that use this media type: IoT applications sending\n      security content over\
    \ HTTP(S) transports.\n      Fragment identifier considerations: N/A\n      Additional\
    \ information:\n      *  Deprecated alias names for this type: N/A\n      *  Magic\
    \ number(s): N/A\n      *  File extension(s): cbor\n      *  Macintosh file type\
    \ code(s): N/A\n      Person & email address to contact for further information:\n\
    \      iesg@ietf.org\n      Intended usage: COMMON\n      Restrictions on usage:\
    \ N/A\n      Author: Jim Schaad, ietf@augustcellars.com\n      Change Controller:\
    \ IESG\n      Provisional registration?  No\n"
- title: 16.9.2.  COSE Key Media Type
  contents:
  - "16.9.2.  COSE Key Media Type\n   This section registers the 'application/cose-key'\
    \ and 'application/\n   cose-key-set' media types in the \"Media Types\" registry.\
    \  These media\n   types are used to indicate, respectively, that content is a\
    \ COSE_Key\n   or COSE_KeySet object.\n   The template for registering 'application/cose-key'\
    \ is:\n      Type name: application\n      Subtype name: cose-key\n      Required\
    \ parameters: N/A\n      Optional parameters: N/A\n      Encoding considerations:\
    \ binary\n      Security considerations: See the Security Considerations section\n\
    \      of RFC 8152.\n      Interoperability considerations: N/A\n      Published\
    \ specification: RFC 8152\n      Applications that use this media type: Distribution\
    \ of COSE based\n      keys for IoT applications.\n      Fragment identifier considerations:\
    \ N/A\n      Additional information:\n      *  Deprecated alias names for this\
    \ type: N/A\n      *  Magic number(s): N/A\n      *  File extension(s): cbor\n\
    \      *  Macintosh file type code(s): N/A\n      Person & email address to contact\
    \ for further information:\n      iesg@ietf.org\n      Intended usage: COMMON\n\
    \      Restrictions on usage: N/A\n      Author: Jim Schaad, ietf@augustcellars.com\n\
    \      Change Controller: IESG\n      Provisional registration?  No\n   The template\
    \ for registering 'application/cose-key-set' is:\n      Type name: application\n\
    \      Subtype name: cose-key-set\n      Required parameters: N/A\n      Optional\
    \ parameters: N/A\n      Encoding considerations: binary\n      Security considerations:\
    \ See the Security Considerations section\n      of RFC 8152.\n      Interoperability\
    \ considerations: N/A\n      Published specification: RFC 8152\n      Applications\
    \ that use this media type: Distribution of COSE based\n      keys for IoT applications.\n\
    \      Fragment identifier considerations: N/A\n      Additional information:\n\
    \      *  Deprecated alias names for this type: N/A\n      *  Magic number(s):\
    \ N/A\n      *  File extension(s): cbor\n      *  Macintosh file type code(s):\
    \ N/A\n      Person & email address to contact for further information:\n    \
    \  iesg@ietf.org\n      Intended usage: COMMON\n      Restrictions on usage: N/A\n\
    \      Author: Jim Schaad, ietf@augustcellars.com\n      Change Controller: IESG\n\
    \      Provisional registration?  No\n"
- title: 16.10.  CoAP Content-Formats Registry
  contents:
  - "16.10.  CoAP Content-Formats Registry\n   IANA has added the following entries\
    \ to the \"CoAP Content-Formats\"\n   registry.\n   +--------------------------------------+----------+-----+-----------+\n\
    \   | Media Type                           | Encoding | ID  | Reference |\n  \
    \ +--------------------------------------+----------+-----+-----------+\n   |\
    \ application/cose; cose-type=\"cose-   |          | 98  | [RFC8152] |\n   | sign\"\
    \                                |          |     |           |\n   | application/cose;\
    \ cose-type=\"cose-   |          | 18  | [RFC8152] |\n   | sign1\"           \
    \                    |          |     |           |\n   | application/cose; cose-type=\"\
    cose-   |          | 96  | [RFC8152] |\n   | encrypt\"                       \
    \      |          |     |           |\n   | application/cose; cose-type=\"cose-\
    \   |          | 16  | [RFC8152] |\n   | encrypt0\"                          \
    \  |          |     |           |\n   | application/cose; cose-type=\"cose-  \
    \ |          | 97  | [RFC8152] |\n   | mac\"                                 |\
    \          |     |           |\n   | application/cose; cose-type=\"cose-   | \
    \         | 17  | [RFC8152] |\n   | mac0\"                                |  \
    \        |     |           |\n   | application/cose-key                 |    \
    \      | 101 | [RFC8152] |\n   | application/cose-key-set             |      \
    \    | 102 | [RFC8152] |\n   +--------------------------------------+----------+-----+-----------+\n\
    \                  Table 26: CoAP Content-Formats for COSE\n"
- title: 16.11.  Expert Review Instructions
  contents:
  - "16.11.  Expert Review Instructions\n   All of the IANA registries established\
    \ in this document are defined\n   as expert review.  This section gives some\
    \ general guidelines for\n   what the experts should be looking for, but they\
    \ are being designated\n   as experts for a reason, so they should be given substantial\n\
    \   latitude.\n   Expert reviewers should take into consideration the following\
    \ points:\n   o  Point squatting should be discouraged.  Reviewers are encouraged\n\
    \      to get sufficient information for registration requests to ensure\n   \
    \   that the usage is not going to duplicate one that is already\n      registered,\
    \ and that the point is likely to be used in\n      deployments.  The zones tagged\
    \ as private use are intended for\n      testing purposes and closed environments;\
    \ code points in other\n      ranges should not be assigned for testing.\n   o\
    \  Specifications are required for the standards track range of point\n      assignment.\
    \  Specifications should exist for specification\n      required ranges, but early\
    \ assignment before a specification is\n      available is considered to be permissible.\
    \  Specifications are\n      needed for the first-come, first-serve range if they\
    \ are expected\n      to be used outside of closed environments in an interoperable\
    \ way.\n      When specifications are not provided, the description provided\n\
    \      needs to have sufficient information to identify what the point is\n  \
    \    being used for.\n   o  Experts should take into account the expected usage\
    \ of fields when\n      approving point assignment.  The fact that there is a\
    \ range for\n      standards track documents does not mean that a standards track\n\
    \      document cannot have points assigned outside of that range.  The\n    \
    \  length of the encoded value should be weighed against how many\n      code\
    \ points of that length are left, the size of device it will be\n      used on,\
    \ and the number of code points left that encode to that\n      size.\n   o  When\
    \ algorithms are registered, vanity registrations should be\n      discouraged.\
    \  One way to do this is to require registrations to\n      provide additional\
    \ documentation on security analysis of the\n      algorithm.  Another thing that\
    \ should be considered is requesting\n      an opinion on the algorithm from the\
    \ Crypto Forum Research Group\n      (CFRG).  Algorithms that do not meet the\
    \ security requirements of\n      the community and the messages structures should\
    \ not be\n      registered.\n"
- title: 17.  Security Considerations
  contents:
  - "17.  Security Considerations\n   There are a number of security considerations\
    \ that need to be taken\n   into account by implementers of this specification.\
    \  The security\n   considerations that are specific to an individual algorithm\
    \ are\n   placed next to the description of the algorithm.  While some\n   considerations\
    \ have been highlighted here, additional considerations\n   may be found in the\
    \ documents listed in the references.\n   Implementations need to protect the\
    \ private key material for any\n   individuals.  There are some cases in this\
    \ document that need to be\n   highlighted on this issue.\n   o  Using the same\
    \ key for two different algorithms can leak\n      information about the key.\
    \  It is therefore recommended that keys\n      be restricted to a single algorithm.\n\
    \   o  Use of 'direct' as a recipient algorithm combined with a second\n     \
    \ recipient algorithm exposes the direct key to the second\n      recipient.\n\
    \   o  Several of the algorithms in this document have limits on the\n      number\
    \ of times that a key can be used without leaking information\n      about the\
    \ key.\n   The use of ECDH and direct plus KDF (with no key wrap) will not\n \
    \  directly lead to the private key being leaked; the one way function\n   of\
    \ the KDF will prevent that.  There is, however, a different issue\n   that needs\
    \ to be addressed.  Having two recipients requires that the\n   CEK be shared\
    \ between two recipients.  The second recipient therefore\n   has a CEK that was\
    \ derived from material that can be used for the\n   weak proof of origin.  The\
    \ second recipient could create a message\n   using the same CEK and send it to\
    \ the first recipient; the first\n   recipient would, for either static-static\
    \ ECDH or direct plus KDF,\n   make an assumption that the CEK could be used for\
    \ proof of origin\n   even though it is from the wrong entity.  If the key wrap\
    \ step is\n   added, then no proof of origin is implied and this is not an issue.\n\
    \   Although it has been mentioned before, the use of a single key for\n   multiple\
    \ algorithms has been demonstrated in some cases to leak\n   information about\
    \ a key, provide the opportunity for attackers to\n   forge integrity tags, or\
    \ gain information about encrypted content.\n   Binding a key to a single algorithm\
    \ prevents these problems.  Key\n   creators and key consumers are strongly encouraged\
    \ not only to create\n   new keys for each different algorithm, but to include\
    \ that selection\n   of algorithm in any distribution of key material and strictly\
    \ enforce\n   the matching of algorithms in the key structure to algorithms in\
    \ the\n   message structure.  In addition to checking that algorithms are\n  \
    \ correct, the key form needs to be checked as well.  Do not use an\n   'EC2'\
    \ key where an 'OKP' key is expected.\n   Before using a key for transmission,\
    \ or before acting on information\n   received, a trust decision on a key needs\
    \ to be made.  Is the data or\n   action something that the entity associated\
    \ with the key has a right\n   to see or a right to request?  A number of factors\
    \ are associated\n   with this trust decision.  Some of the ones that are highlighted\
    \ here\n   are:\n   o  What are the permissions associated with the key owner?\n\
    \   o  Is the cryptographic algorithm acceptable in the current context?\n   o\
    \  Have the restrictions associated with the key, such as algorithm\n      or\
    \ freshness, been checked and are they correct?\n   o  Is the request something\
    \ that is reasonable, given the current\n      state of the application?\n   o\
    \  Have any security considerations that are part of the message been\n      enforced\
    \ (as specified by the application or 'crit' parameter)?\n   There are a large\
    \ number of algorithms presented in this document\n   that use nonce values. \
    \ For all of the nonces defined in this\n   document, there is some type of restriction\
    \ on the nonce being a\n   unique value either for a key or for some other conditions.\
    \  In all\n   of these cases, there is no known requirement on the nonce being\
    \ both\n   unique and unpredictable; under these circumstances, it's reasonable\n\
    \   to use a counter for creation of the nonce.  In cases where one wants\n  \
    \ the pattern of the nonce to be unpredictable as well as unique, one\n   can\
    \ use a key created for that purpose and encrypt the counter to\n   produce the\
    \ nonce value.\n   One area that has been starting to get exposure is doing traffic\n\
    \   analysis of encrypted messages based on the length of the message.\n   This\
    \ specification does not provide for a uniform method of providing\n   padding\
    \ as part of the message structure.  An observer can\n   distinguish between two\
    \ different strings (for example, 'YES' and\n   'NO') based on the length for\
    \ all of the content encryption\n   algorithms that are defined in this document.\
    \  This means that it is\n   up to the applications to document how content padding\
    \ is to be done\n   in order to prevent or discourage such analysis.  (For example,\
    \ the\n   strings could be defined as 'YES' and 'NO '.)\n"
- title: 18.  References
  contents:
  - '18.  References

    '
- title: 18.1.  Normative References
  contents:
  - "18.1.  Normative References\n   [AES-GCM]  National Institute of Standards and\
    \ Technology,\n              \"Recommendation for Block Cipher Modes of Operation:\n\
    \              Galois/Counter Mode (GCM) and GMAC\", NIST Special\n          \
    \    Publication 800-38D, DOI 10.6028/NIST.SP.800-38D, November\n            \
    \  2007, <https://csrc.nist.gov/publications/nistpubs/800-\n              38D/SP-800-38D.pdf>.\n\
    \   [COAP.Formats]\n              IANA, \"Constrained RESTful Environments (CoRE)\n\
    \              Parameters\",\n              <http://www.iana.org/assignments/core-parameters/>.\n\
    \   [DSS]      National Institute of Standards and Technology, \"Digital\n   \
    \           Signature Standard (DSS)\", FIPS PUB 186-4,\n              DOI 10.6028/NIST.FIPS.186-4,\
    \ July 2013,\n              <http://nvlpubs.nist.gov/nistpubs/FIPS/\n        \
    \      NIST.FIPS.186-4.pdf>.\n   [MAC]      National Institute of Standards and\
    \ Technology, \"Computer\n              Data Authentication\", FIPS PUB 113, May\
    \ 1985,\n              <http://csrc.nist.gov/publications/fips/fips113/\n    \
    \          fips113.html>.\n   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti,\
    \ \"HMAC: Keyed-\n              Hashing for Message Authentication\", RFC 2104,\n\
    \              DOI 10.17487/RFC2104, February 1997,\n              <http://www.rfc-editor.org/info/rfc2104>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3394]\
    \  Schaad, J. and R. Housley, \"Advanced Encryption Standard\n              (AES)\
    \ Key Wrap Algorithm\", RFC 3394, DOI 10.17487/RFC3394,\n              September\
    \ 2002, <http://www.rfc-editor.org/info/rfc3394>.\n   [RFC3610]  Whiting, D.,\
    \ Housley, R., and N. Ferguson, \"Counter with\n              CBC-MAC (CCM)\"\
    , RFC 3610, DOI 10.17487/RFC3610, September\n              2003, <http://www.rfc-editor.org/info/rfc3610>.\n\
    \   [RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n \
    \             Key Derivation Function (HKDF)\", RFC 5869,\n              DOI 10.17487/RFC5869,\
    \ May 2010,\n              <http://www.rfc-editor.org/info/rfc5869>.\n   [RFC6090]\
    \  McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic\n             \
    \ Curve Cryptography Algorithms\", RFC 6090,\n              DOI 10.17487/RFC6090,\
    \ February 2011,\n              <http://www.rfc-editor.org/info/rfc6090>.\n  \
    \ [RFC6979]  Pornin, T., \"Deterministic Usage of the Digital Signature\n    \
    \          Algorithm (DSA) and Elliptic Curve Digital Signature\n            \
    \  Algorithm (ECDSA)\", RFC 6979, DOI 10.17487/RFC6979, August\n             \
    \ 2013, <http://www.rfc-editor.org/info/rfc6979>.\n   [RFC7049]  Bormann, C. and\
    \ P. Hoffman, \"Concise Binary Object\n              Representation (CBOR)\",\
    \ RFC 7049, DOI 10.17487/RFC7049,\n              October 2013, <http://www.rfc-editor.org/info/rfc7049>.\n\
    \   [RFC7539]  Nir, Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF\n    \
    \          Protocols\", RFC 7539, DOI 10.17487/RFC7539, May 2015,\n          \
    \    <http://www.rfc-editor.org/info/rfc7539>.\n   [RFC7748]  Langley, A., Hamburg,\
    \ M., and S. Turner, \"Elliptic Curves\n              for Security\", RFC 7748,\
    \ DOI 10.17487/RFC7748, January\n              2016, <http://www.rfc-editor.org/info/rfc7748>.\n\
    \   [RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n     \
    \         Signature Algorithm (EdDSA)\", RFC 8032,\n              DOI 10.17487/RFC8032,\
    \ January 2017,\n              <http://www.rfc-editor.org/info/rfc8032>.\n   [RFC8174]\
    \  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119\
    \ Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,\
    \ <http://www.rfc-editor.org/info/rfc8174>.\n   [SEC1]     Certicom Research,\
    \ \"SEC 1: Elliptic Curve Cryptography\",\n              Standards for Efficient\
    \ Cryptography, Version 2.0, May\n              2009, <http://www.secg.org/sec1-v2.pdf>.\n"
- title: 18.2.  Informative References
  contents:
  - "18.2.  Informative References\n   [CDDL]     Vigano, C. and H. Birkholz, \"CBOR\
    \ data definition language\n              (CDDL): a notational convention to express\
    \ CBOR data\n              structures\", Work in Progress, draft-greevenbosch-appsawg-\n\
    \              cbor-cddl-09, March 2017.\n   [OSCOAP]   Selander, G., Mattsson,\
    \ J., Palombini, F., and L. Seitz,\n              \"Object Security of CoAP (OSCOAP)\"\
    , Work in Progress,\n              draft-ietf-core-object-security-03, May 2017.\n\
    \   [PVSig]    Brown, D. and D. Johnson, \"Formal Security Proofs for a\n    \
    \          Signature Scheme with Partial Message Recovery\",\n              DOI\
    \ 10.1007/3-540-45353-9_11, LNCS Volume 2020, June 2000.\n   [RFC2633]  Ramsdell,\
    \ B., Ed., \"S/MIME Version 3 Message\n              Specification\", RFC 2633,\
    \ DOI 10.17487/RFC2633, June 1999,\n              <http://www.rfc-editor.org/info/rfc2633>.\n\
    \   [RFC4231]  Nystrom, M., \"Identifiers and Test Vectors for HMAC-SHA-\n   \
    \           224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\",\n           \
    \   RFC 4231, DOI 10.17487/RFC4231, December 2005,\n              <http://www.rfc-editor.org/info/rfc4231>.\n\
    \   [RFC4262]  Santesson, S., \"X.509 Certificate Extension for Secure/\n    \
    \          Multipurpose Internet Mail Extensions (S/MIME)\n              Capabilities\"\
    , RFC 4262, DOI 10.17487/RFC4262, December\n              2005, <http://www.rfc-editor.org/info/rfc4262>.\n\
    \   [RFC4493]  Song, JH., Poovendran, R., Lee, J., and T. Iwata, \"The\n     \
    \         AES-CMAC Algorithm\", RFC 4493, DOI 10.17487/RFC4493, June\n       \
    \       2006, <http://www.rfc-editor.org/info/rfc4493>.\n   [RFC4949]  Shirey,\
    \ R., \"Internet Security Glossary, Version 2\",\n              FYI 36, RFC 4949,\
    \ DOI 10.17487/RFC4949, August 2007,\n              <http://www.rfc-editor.org/info/rfc4949>.\n\
    \   [RFC5116]  McGrew, D., \"An Interface and Algorithms for Authenticated\n \
    \             Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008,\n  \
    \            <http://www.rfc-editor.org/info/rfc5116>.\n   [RFC5480]  Turner,\
    \ S., Brown, D., Yiu, K., Housley, R., and T. Polk,\n              \"Elliptic\
    \ Curve Cryptography Subject Public Key\n              Information\", RFC 5480,\
    \ DOI 10.17487/RFC5480, March 2009,\n              <http://www.rfc-editor.org/info/rfc5480>.\n\
    \   [RFC5652]  Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70,\n\
    \              RFC 5652, DOI 10.17487/RFC5652, September 2009,\n             \
    \ <http://www.rfc-editor.org/info/rfc5652>.\n   [RFC5751]  Ramsdell, B. and S.\
    \ Turner, \"Secure/Multipurpose Internet\n              Mail Extensions (S/MIME)\
    \ Version 3.2 Message\n              Specification\", RFC 5751, DOI 10.17487/RFC5751,\
    \ January\n              2010, <http://www.rfc-editor.org/info/rfc5751>.\n   [RFC5752]\
    \  Turner, S. and J. Schaad, \"Multiple Signatures in\n              Cryptographic\
    \ Message Syntax (CMS)\", RFC 5752,\n              DOI 10.17487/RFC5752, January\
    \ 2010,\n              <http://www.rfc-editor.org/info/rfc5752>.\n   [RFC5990]\
    \  Randall, J., Kaliski, B., Brainard, J., and S. Turner,\n              \"Use\
    \ of the RSA-KEM Key Transport Algorithm in the\n              Cryptographic Message\
    \ Syntax (CMS)\", RFC 5990,\n              DOI 10.17487/RFC5990, September 2010,\n\
    \              <http://www.rfc-editor.org/info/rfc5990>.\n   [RFC6151]  Turner,\
    \ S. and L. Chen, \"Updated Security Considerations\n              for the MD5\
    \ Message-Digest and the HMAC-MD5 Algorithms\",\n              RFC 6151, DOI 10.17487/RFC6151,\
    \ March 2011,\n              <http://www.rfc-editor.org/info/rfc6151>.\n   [RFC6838]\
    \  Freed, N., Klensin, J., and T. Hansen, \"Media Type\n              Specifications\
    \ and Registration Procedures\", BCP 13,\n              RFC 6838, DOI 10.17487/RFC6838,\
    \ January 2013,\n              <http://www.rfc-editor.org/info/rfc6838>.\n   [RFC7159]\
    \  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n             \
    \ Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March\n              2014,\
    \ <http://www.rfc-editor.org/info/rfc7159>.\n   [RFC7252]  Shelby, Z., Hartke,\
    \ K., and C. Bormann, \"The Constrained\n              Application Protocol (CoAP)\"\
    , RFC 7252,\n              DOI 10.17487/RFC7252, June 2014,\n              <http://www.rfc-editor.org/info/rfc7252>.\n\
    \   [RFC7515]  Jones, M., Bradley, J., and N. Sakimura, \"JSON Web\n         \
    \     Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May\n              2015,\
    \ <http://www.rfc-editor.org/info/rfc7515>.\n   [RFC7516]  Jones, M. and J. Hildebrand,\
    \ \"JSON Web Encryption (JWE)\",\n              RFC 7516, DOI 10.17487/RFC7516,\
    \ May 2015,\n              <http://www.rfc-editor.org/info/rfc7516>.\n   [RFC7517]\
    \  Jones, M., \"JSON Web Key (JWK)\", RFC 7517,\n              DOI 10.17487/RFC7517,\
    \ May 2015,\n              <http://www.rfc-editor.org/info/rfc7517>.\n   [RFC7518]\
    \  Jones, M., \"JSON Web Algorithms (JWA)\", RFC 7518,\n              DOI 10.17487/RFC7518,\
    \ May 2015,\n              <http://www.rfc-editor.org/info/rfc7518>.\n   [RFC8017]\
    \  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n              \"\
    PKCS #1: RSA Cryptography Specifications Version 2.2\",\n              RFC 8017,\
    \ DOI 10.17487/RFC8017, November 2016,\n              <http://www.rfc-editor.org/info/rfc8017>.\n\
    \   [RFC8018]  Moriarty, K., Ed., Kaliski, B., and A. Rusch, \"PKCS #5:\n    \
    \          Password-Based Cryptography Specification Version 2.1\",\n        \
    \      RFC 8018, DOI 10.17487/RFC8018, January 2017,\n              <http://www.rfc-editor.org/info/rfc8018>.\n\
    \   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n      \
    \        Writing an IANA Considerations Section in RFCs\", BCP 26,\n         \
    \     RFC 8126, DOI 10.17487/RFC8126, June 2017,\n              <http://www.rfc-editor.org/info/rfc8126>.\n\
    \   [SP800-56A]\n              Barker, E., Chen, L., Roginsky, A., and M. Smid,\n\
    \              \"Recommendation for Pair-Wise Key Establishment Schemes\n    \
    \          Using Discrete Logarithm Cryptography\", NIST Special\n           \
    \   Publication 800-56A, Revision 2,\n              DOI 10.6028/NIST.SP.800-56Ar2,\
    \ May 2013,\n              <http://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n\
    \              NIST.SP.800-56Ar2.pdf>.\n   [W3C.WebCrypto]\n              Watson,\
    \ M., \"Web Cryptography API\", W3C Recommendation,\n              January 2017,\
    \ <https://www.w3.org/TR/WebCryptoAPI/>.\n"
- title: Appendix A.  Guidelines for External Data Authentication of Algorithms
  contents:
  - "Appendix A.  Guidelines for External Data Authentication of Algorithms\n   A\
    \ portion of the working group has expressed a strong desire to relax\n   the\
    \ rule that the algorithm identifier be required to appear in each\n   level of\
    \ a COSE object.  There are two basic reasons that have been\n   advanced to support\
    \ this position.  First, the resulting message will\n   be smaller if the algorithm\
    \ identifier is omitted from the most\n   common messages in a CoAP environment.\
    \  Second, there is a potential\n   bug that will arise if full checking is not\
    \ done correctly between\n   the different places that an algorithm identifier\
    \ could be placed\n   (the message itself, an application statement, the key structure\
    \ that\n   the sender possesses, and the key structure the recipient possesses).\n\
    \   This appendix lays out how such a change can be made and the details\n   that\
    \ an application needs to specify in order to use this option.\n   Two different\
    \ sets of details are specified: those needed to omit an\n   algorithm identifier\
    \ and those needed to use a variant on the counter\n   signature attribute that\
    \ contains no attributes about itself.\n"
- title: A.1.  Algorithm Identification
  contents:
  - "A.1.  Algorithm Identification\n   In this section, three sets of recommendations\
    \ are laid out.  The\n   first set of recommendations apply to having an implicit\
    \ algorithm\n   identified for a single layer of a COSE object.  The second set\
    \ of\n   recommendations apply to having multiple implicit algorithms\n   identified\
    \ for multiple layers of a COSE object.  The third set of\n   recommendations\
    \ apply to having implicit algorithms for multiple COSE\n   object constructs.\n\
    \   The key words from RFC 2119 are deliberately not used here.  This\n   specification\
    \ can provide recommendations, but it cannot enforce\n   them.\n   This set of\
    \ recommendations applies to the case where an application\n   is distributing\
    \ a fixed algorithm along with the key information for\n   use in a single COSE\
    \ object.  This normally applies to the smallest\n   of the COSE objects, specifically\
    \ COSE_Sign1, COSE_Mac0, and\n   COSE_Encrypt0, but could apply to the other structures\
    \ as well.\n   The following items should be taken into account:\n   o  Applications\
    \ need to list the set of COSE structures that implicit\n      algorithms are\
    \ to be used in.  Applications need to require that\n      the receipt of an explicit\
    \ algorithm identifier in one of these\n      structures will lead to the message\
    \ being rejected.  This\n      requirement is stated so that there will never\
    \ be a case where\n      there is any ambiguity about the question of which algorithm\n\
    \      should be used, the implicit or the explicit one.  This applies\n     \
    \ even if the transported algorithm identifier is a protected\n      attribute.\
    \  This applies even if the transported algorithm is the\n      same as the implicit\
    \ algorithm.\n   o  Applications need to define the set of information that is\
    \ to be\n      considered to be part of a context when omitting algorithm\n  \
    \    identifiers.  At a minimum, this would be the key identifier (if\n      needed),\
    \ the key, the algorithm, and the COSE structure it is used\n      with.  Applications\
    \ should restrict the use of a single key to a\n      single algorithm.  As noted\
    \ for some of the algorithms in this\n      document, the use of the same key\
    \ in different related algorithms\n      can lead to leakage of information about\
    \ the key, leakage about\n      the data or the ability to perform forgeries.\n\
    \   o  In many cases, applications that make the algorithm identifier\n      implicit\
    \ will also want to make the context identifier implicit\n      for the same reason.\
    \  That is, omitting the context identifier\n      will decrease the message size\
    \ (potentially significantly\n      depending on the length of the identifier).\
    \  Applications that do\n      this will need to describe the circumstances where\
    \ the context\n      identifier is to be omitted and how the context identifier\
    \ is to\n      be inferred in these cases.  (An exhaustive search over all of\
    \ the\n      keys would normally not be considered to be acceptable.)  An\n  \
    \    example of how this can be done is to tie the context to a\n      transaction\
    \ identifier.  Both would be sent on the original\n      message, but only the\
    \ transaction identifier would need to be sent\n      after that point as the\
    \ context is tied into the transaction\n      identifier.  Another way would be\
    \ to associate a context with a\n      network address.  All messages coming from\
    \ a single network\n      address can be assumed to be associated with a specific\
    \ context.\n      (In this case, the address would normally be distributed as\
    \ part\n      of the context.)\n   o  Applications cannot rely on key identifiers\
    \ being unique unless\n      they take significant efforts to ensure that they\
    \ are computed in\n      such a way as to create this guarantee.  Even when an\
    \ application\n      does this, the uniqueness might be violated if the application\
    \ is\n      run in different contexts (i.e., with a different context\n      provider)\
    \ or if the system combines the security contexts from\n      different applications\
    \ together into a single store.\n   o  Applications should continue the practice\
    \ of protecting the\n      algorithm identifier.  Since this is not done by placing\
    \ it in the\n      protected attributes field, applications should define an\n\
    \      application-specific external data structure that includes this\n     \
    \ value.  This external data field can be used as such for content\n      encryption,\
    \ MAC, and signature algorithms.  It can be used in the\n      SuppPrivInfo field\
    \ for those algorithms that use a KDF to derive a\n      key value.  Applications\
    \ may also want to protect other\n      information that is part of the context\
    \ structure as well.  It\n      should be noted that those fields, such as the\
    \ key or a Base IV,\n      are protected by virtue of being used in the cryptographic\n\
    \      computation and do not need to be included in the external data\n     \
    \ field.\n   The second case is having multiple implicit algorithm identifiers\n\
    \   specified for a multiple layer COSE object.  An example of how this\n   would\
    \ work is the encryption context that an application specifies,\n   which contains\
    \ a content encryption algorithm, a key wrap algorithm,\n   a key identifier,\
    \ and a shared secret.  The sender omits sending the\n   algorithm identifier\
    \ for both the content layer and the recipient\n   layer leaving only the key\
    \ identifier.  The receiver then uses the\n   key identifier to get the implicit\
    \ algorithm identifiers.\n   The following additional items need to be taken into\
    \ consideration:\n   o  Applications that want to support this will need to define\
    \ a\n      structure that allows for, and clearly identifies, both the COSE\n\
    \      structure to be used with a given key and the structure and\n      algorithm\
    \ to be used for the secondary layer.  The key for the\n      secondary layer\
    \ is computed as normal from the recipient layer.\n   The third case is having\
    \ multiple implicit algorithm identifiers, but\n   targeted at potentially unrelated\
    \ layers or different COSE objects.\n   There are a number of different scenarios\
    \ where this might be\n   applicable.  Some of these scenarios are:\n   o  Two\
    \ contexts are distributed as a pair.  Each of the contexts is\n      for use\
    \ with a COSE_Encrypt message.  Each context will consist of\n      distinct secret\
    \ keys and IVs and potentially even different\n      algorithms.  One context\
    \ is for sending messages from party A to\n      party B, and the second context\
    \ is for sending messages from party\n      B to party A.  This means that there\
    \ is no chance for a reflection\n      attack to occur as each party uses different\
    \ secret keys to send\n      its messages; a message that is reflected back to\
    \ it would fail to\n      decrypt.\n   o  Two contexts are distributed as a pair.\
    \  The first context is used\n      for encryption of the message, and the second\
    \ context is used to\n      place a counter signature on the message.  The intention\
    \ is that\n      the second context can be distributed to other entities\n   \
    \   independently of the first context.  This allows these entities to\n     \
    \ validate that the message came from an individual without being\n      able\
    \ to decrypt the message and see the content.\n   o  Two contexts are distributed\
    \ as a pair.  The first context\n      contains a key for dealing with MACed messages,\
    \ and the second\n      context contains a key for dealing with encrypted messages.\
    \  This\n      allows for a unified distribution of keys to participants for\n\
    \      different types of messages that have different keys, but where\n     \
    \ the keys may be used in a coordinated manner.\n   For these cases, the following\
    \ additional items need to be\n   considered:\n   o  Applications need to ensure\
    \ that the multiple contexts stay\n      associated.  If one of the contexts is\
    \ invalidated for any reason,\n      all of the contexts associated with it should\
    \ also be invalidated.\n"
- title: A.2.  Counter Signature without Headers
  contents:
  - "A.2.  Counter Signature without Headers\n   There is a group of people who want\
    \ to have a counter signature\n   parameter that is directly tied to the value\
    \ being signed, and thus\n   the authenticated and unauthenticated buckets can\
    \ be removed from the\n   message being sent.  The focus on this is an even smaller\
    \ size, as\n   all of the information on the process of creating the counter\n\
    \   signature is implicit rather than being explicitly carried in the\n   message.\
    \  This includes not only the algorithm identifier as\n   presented above, but\
    \ also items such as the key identification, which\n   is always external to the\
    \ signature structure.  This means that the\n   entities that are doing the validation\
    \ of the counter signature are\n   required to infer which key is to be used from\
    \ context rather than\n   being explicit.  One way of doing this would be to presume\
    \ that all\n   data coming from a specific port (or to a specific URL) is to be\n\
    \   validated by a specific key.  (Note that this does not require that\n   the\
    \ key identifier be part of the value signed as it does not serve a\n   cryptographic\
    \ purpose.  If the key validates the counter signature,\n   then it should be\
    \ presumed that the entity associated with that key\n   produced the signature.)\n\
    \   When computing the signature for the bare counter signature header,\n   the\
    \ same Sig_structure defined in Section 4.4 is used.  The\n   sign_protected field\
    \ is omitted, as there is no protected header\n   field in this counter signature\
    \ header.  The value of\n   \"CounterSignature0\" is placed in the context field\
    \ of the\n   Sig_stucture.\n   +-------------------+-------+-------+-------+-----------------------+\n\
    \   | Name              | Label | Value | Value | Description           |\n  \
    \ |                   |       | Type  |       |                       |\n   +-------------------+-------+-------+-------+-----------------------+\n\
    \   | CounterSignature0 | 9     | bstr  |       | Counter signature     |\n  \
    \ |                   |       |       |       | with implied signer   |\n   |\
    \                   |       |       |       | and headers           |\n   +-------------------+-------+-------+-------+-----------------------+\n\
    \             Table 27: Header Parameter for CounterSignature0\n"
- title: Appendix B.  Two Layers of Recipient Information
  contents:
  - "Appendix B.  Two Layers of Recipient Information\n   All of the currently defined\
    \ recipient algorithm classes only use two\n   layers of the COSE_Encrypt structure.\
    \  The first layer is the message\n   content, and the second layer is the content\
    \ key encryption.\n   However, if one uses a recipient algorithm such as the RSA\
    \ Key\n   Encapsulation Mechanism (RSA-KEM) (see Appendix A of RSA-KEM\n   [RFC5990]),\
    \ then it makes sense to have three layers of the\n   COSE_Encrypt structure.\n\
    \   These layers would be:\n   o  Layer 0: The content encryption layer.  This\
    \ layer contains the\n      payload of the message.\n   o  Layer 1: The encryption\
    \ of the CEK by a KEK.\n   o  Layer 2: The encryption of a long random secret\
    \ using an RSA key\n      and a key derivation function to convert that secret\
    \ into the KEK.\n   This is an example of what a triple layer message would look\
    \ like.\n   The message has the following layers:\n   o  Layer 0: Has a content\
    \ encrypted with AES-GCM using a 128-bit key.\n   o  Layer 1: Uses the AES Key\
    \ Wrap algorithm with a 128-bit key.\n   o  Layer 2: Uses ECDH Ephemeral-Static\
    \ direct to generate the layer 1\n      key.\n   In effect, this example is a\
    \ decomposed version of using the\n   ECDH-ES+A128KW algorithm.\n   Size of binary\
    \ file is 183 bytes\n   96(\n     [\n       / protected / h'a10101' / {\n    \
    \       \\ alg \\ 1:1 \\ AES-GCM 128 \\\n         } / ,\n       / unprotected\
    \ / {\n         / iv / 5:h'02d1f7e6f26c43d4868d87ce'\n       },\n       / ciphertext\
    \ / h'64f84d913ba60a76070a9a48f26e97e863e2852948658f0\n   811139868826e89218a75715b',\n\
    \       / recipients / [\n         [\n           / protected / h'',\n        \
    \   / unprotected / {\n             / alg / 1:-3 / A128KW /\n           },\n \
    \          / ciphertext / h'dbd43c4e9d719c27c6275c67d628d493f090593db82\n   18f11',\n\
    \           / recipients / [\n             [\n               / protected / h'a1013818'\
    \ / {\n                   \\ alg \\ 1:-25 \\ ECDH-ES + HKDF-256 \\\n         \
    \        } / ,\n               / unprotected / {\n                 / ephemeral\
    \ / -1:{\n                   / kty / 1:2,\n                   / crv / -1:1,\n\
    \                   / x / -2:h'b2add44368ea6d641f9ca9af308b4079aeb519f11\n   e9b8a55a600b21233e86e68',\n\
    \                   / y / -3:false\n                 },\n                 / kid\
    \ / 4:'meriadoc.brandybuck@buckland.example'\n               },\n            \
    \   / ciphertext / h''\n             ]\n           ]\n         ]\n       ]\n \
    \    ]\n   )\n"
- title: Appendix C.  Examples
  contents:
  - "Appendix C.  Examples\n   This appendix includes a set of examples that show\
    \ the different\n   features and message types that have been defined in this\
    \ document.\n   To make the examples easier to read, they are presented using\
    \ the\n   extended CBOR diagnostic notation (defined in [CDDL]) rather than as\n\
    \   a binary dump.\n   A GitHub project has been created at <https://github.com/cose-wg/\n\
    \   Examples> that contains not only the examples presented in this\n   document,\
    \ but a more complete set of testing examples as well.  Each\n   example is found\
    \ in a JSON file that contains the inputs used to\n   create the example, some\
    \ of the intermediate values that can be used\n   in debugging the example and\
    \ the output of the example presented in\n   both a hex and a CBOR diagnostic\
    \ notation format.  Some of the\n   examples at the site are designed failure\
    \ testing cases; these are\n   clearly marked as such in the JSON file.  If errors\
    \ in the examples\n   in this document are found, the examples on GitHub will\
    \ be updated,\n   and a note to that effect will be placed in the JSON file.\n\
    \   As noted, the examples are presented using the CBOR's diagnostic\n   notation.\
    \  A Ruby-based tool exists that can convert between the\n   diagnostic notation\
    \ and binary.  This tool can be installed with the\n   command line:\n   gem install\
    \ cbor-diag\n   The diagnostic notation can be converted into binary files using\
    \ the\n   following command line:\n   diag2cbor.rb < inputfile > outputfile\n\
    \   The examples can be extracted from the XML version of this document\n   via\
    \ an XPath expression as all of the artwork is tagged with the\n   attribute type='CBORdiag'.\
    \  (Depending on the XPath evaluator one is\n   using, it may be necessary to\
    \ deal with &gt; as an entity.)\n   //artwork[@type='CDDL']/text()\n"
- title: C.1.  Examples of Signed Messages
  contents:
  - 'C.1.  Examples of Signed Messages

    '
- title: C.1.1.  Single Signature
  contents:
  - "C.1.1.  Single Signature\n   This example uses the following:\n   o  Signature\
    \ Algorithm: ECDSA w/ SHA-256, Curve P-256\n   Size of binary file is 103 bytes\n\
    \   98(\n     [\n       / protected / h'',\n       / unprotected / {},\n     \
    \  / payload / 'This is the content.',\n       / signatures / [\n         [\n\
    \           / protected / h'a10126' / {\n               \\ alg \\ 1:-7 \\ ECDSA\
    \ 256 \\\n             } / ,\n           / unprotected / {\n             / kid\
    \ / 4:'11'\n           },\n           / signature / h'e2aeafd40d69d19dfe6e52077c5d7ff4e408282cbefb\n\
    \   5d06cbf414af2e19d982ac45ac98b8544c908b4507de1e90b717c3d34816fe926a2b\n   98f53afd2fa0f30a'\n\
    \         ]\n       ]\n     ]\n   )\n"
- title: C.1.2.  Multiple Signers
  contents:
  - "C.1.2.  Multiple Signers\n   This example uses the following:\n   o  Signature\
    \ Algorithm: ECDSA w/ SHA-256, Curve P-256\n   o  Signature Algorithm: ECDSA w/\
    \ SHA-512, Curve P-521\n   Size of binary file is 277 bytes\n   98(\n     [\n\
    \       / protected / h'',\n       / unprotected / {},\n       / payload / 'This\
    \ is the content.',\n       / signatures / [\n         [\n           / protected\
    \ / h'a10126' / {\n               \\ alg \\ 1:-7 \\ ECDSA 256 \\\n           \
    \  } / ,\n           / unprotected / {\n             / kid / 4:'11'\n        \
    \   },\n           / signature / h'e2aeafd40d69d19dfe6e52077c5d7ff4e408282cbefb\n\
    \   5d06cbf414af2e19d982ac45ac98b8544c908b4507de1e90b717c3d34816fe926a2b\n   98f53afd2fa0f30a'\n\
    \         ],\n         [\n           / protected / h'a1013823' / {\n         \
    \      \\ alg \\ 1:-36\n             } / ,\n           / unprotected / {\n   \
    \          / kid / 4:'bilbo.baggins@hobbiton.example'\n           },\n       \
    \    / signature / h'00a2d28a7c2bdb1587877420f65adf7d0b9a06635dd1\n   de64bb62974c863f0b160dd2163734034e6ac003b01e8705524c5c4ca479a952f024\n\
    \   7ee8cb0b4fb7397ba08d009e0c8bf482270cc5771aa143966e5a469a09f613488030\n   c5b07ec6d722e3835adb5b2d8c44e95ffb13877dd2582866883535de3bb03d01753f\n\
    \   83ab87bb4f7a0297'\n         ]\n       ]\n     ]\n   )\n"
- title: C.1.3.  Counter Signature
  contents:
  - "C.1.3.  Counter Signature\n   This example uses the following:\n   o  Signature\
    \ Algorithm: ECDSA w/ SHA-256, Curve P-256\n   o  The same parameters are used\
    \ for both the signature and the\n      counter signature.\n   Size of binary\
    \ file is 180 bytes\n   98(\n     [\n       / protected / h'',\n       / unprotected\
    \ / {\n         / countersign / 7:[\n           / protected / h'a10126' / {\n\
    \               \\ alg \\ 1:-7 \\ ECDSA 256 \\\n             } / ,\n         \
    \  / unprotected / {\n             / kid / 4:'11'\n           },\n           /\
    \ signature / h'5ac05e289d5d0e1b0a7f048a5d2b643813ded50bc9e4\n   9220f4f7278f85f19d4a77d655c9d3b51e805a74b099e1e085aacd97fc29d72f887e\n\
    \   8802bb6650cceb2c'\n         ]\n       },\n       / payload / 'This is the\
    \ content.',\n       / signatures / [\n         [\n           / protected / h'a10126'\
    \ / {\n               \\ alg \\ 1:-7 \\ ECDSA 256 \\\n             } / ,\n   \
    \        / unprotected / {\n             / kid / 4:'11'\n           },\n     \
    \      / signature / h'e2aeafd40d69d19dfe6e52077c5d7ff4e408282cbefb\n   5d06cbf414af2e19d982ac45ac98b8544c908b4507de1e90b717c3d34816fe926a2b\n\
    \   98f53afd2fa0f30a'\n         ]\n       ]\n     ]\n   )\n"
- title: C.1.4.  Signature with Criticality
  contents:
  - "C.1.4.  Signature with Criticality\n   This example uses the following:\n   o\
    \  Signature Algorithm: ECDSA w/ SHA-256, Curve P-256\n   o  There is a criticality\
    \ marker on the \"reserved\" header parameter\n   Size of binary file is 125 bytes\n\
    \   98(\n     [\n       / protected / h'a2687265736572766564f40281687265736572766564'\
    \ /\n   {\n           \"reserved\":false,\n           \\ crit \\ 2:[\n       \
    \      \"reserved\"\n           ]\n         } / ,\n       / unprotected / {},\n\
    \       / payload / 'This is the content.',\n       / signatures / [\n       \
    \  [\n           / protected / h'a10126' / {\n               \\ alg \\ 1:-7 \\\
    \ ECDSA 256 \\\n             } / ,\n           / unprotected / {\n           \
    \  / kid / 4:'11'\n           },\n           / signature / h'3fc54702aa56e1b2cb20284294c9106a63f91bac658d\n\
    \   69351210a031d8fc7c5ff3e4be39445b1a3e83e1510d1aca2f2e8a7c081c7645042b\n   18aba9d1fad1bd9c'\n\
    \         ]\n       ]\n     ]\n   )\n"
- title: C.2.  Single Signer Examples
  contents:
  - 'C.2.  Single Signer Examples

    '
- title: C.2.1.  Single ECDSA Signature
  contents:
  - "C.2.1.  Single ECDSA Signature\n   This example uses the following:\n   o  Signature\
    \ Algorithm: ECDSA w/ SHA-256, Curve P-256\n   Size of binary file is 98 bytes\n\
    \   18(\n     [\n       / protected / h'a10126' / {\n           \\ alg \\ 1:-7\
    \ \\ ECDSA 256 \\\n         } / ,\n       / unprotected / {\n         / kid /\
    \ 4:'11'\n       },\n       / payload / 'This is the content.',\n       / signature\
    \ / h'8eb33e4ca31d1c465ab05aac34cc6b23d58fef5c083106c4\n   d25a91aef0b0117e2af9a291aa32e14ab834dc56ed2a223444547e01f11d3b0916e5\n\
    \   a4c345cacb36'\n     ]\n   )\n"
- title: C.3.  Examples of Enveloped Messages
  contents:
  - 'C.3.  Examples of Enveloped Messages

    '
- title: C.3.1.  Direct ECDH
  contents:
  - "C.3.1.  Direct ECDH\n   This example uses the following:\n   o  CEK: AES-GCM\
    \ w/ 128-bit key\n   o  Recipient class: ECDH Ephemeral-Static, Curve P-256\n\
    \   Size of binary file is 151 bytes\n   96(\n     [\n       / protected / h'a10101'\
    \ / {\n           \\ alg \\ 1:1 \\ AES-GCM 128 \\\n         } / ,\n       / unprotected\
    \ / {\n         / iv / 5:h'c9cf4df2fe6c632bf7886413'\n       },\n       / ciphertext\
    \ / h'7adbe2709ca818fb415f1e5df66f4e1a51053ba6d65a1a0\n   c52a357da7a644b8070a151b0',\n\
    \       / recipients / [\n         [\n           / protected / h'a1013818' / {\n\
    \               \\ alg \\ 1:-25 \\ ECDH-ES + HKDF-256 \\\n             } / ,\n\
    \           / unprotected / {\n             / ephemeral / -1:{\n             \
    \  / kty / 1:2,\n               / crv / -1:1,\n               / x / -2:h'98f50a4ff6c05861c8860d13a638ea56c3f5ad7590bbf\n\
    \   bf054e1c7b4d91d6280',\n               / y / -3:true\n             },\n   \
    \          / kid / 4:'meriadoc.brandybuck@buckland.example'\n           },\n \
    \          / ciphertext / h''\n         ]\n       ]\n     ]\n   )\n"
- title: C.3.2.  Direct Plus Key Derivation
  contents:
  - "C.3.2.  Direct Plus Key Derivation\n   This example uses the following:\n   o\
    \  CEK: AES-CCM w/ 128-bit key, truncate the tag to 64 bits\n   o  Recipient class:\
    \ Use HKDF on a shared secret with the following\n      implicit fields as part\
    \ of the context.\n      *  salt: \"aabbccddeeffgghh\"\n      *  PartyU identity:\
    \ \"lighting-client\"\n      *  PartyV identity: \"lighting-server\"\n      *\
    \  Supplementary Public Other: \"Encryption Example 02\"\n   Size of binary file\
    \ is 91 bytes\n   96(\n     [\n       / protected / h'a1010a' / {\n          \
    \ \\ alg \\ 1:10 \\ AES-CCM-16-64-128 \\\n         } / ,\n       / unprotected\
    \ / {\n         / iv / 5:h'89f52f65a1c580933b5261a76c'\n       },\n       / ciphertext\
    \ / h'753548a19b1307084ca7b2056924ed95f2e3b17006dfe93\n   1b687b847',\n      \
    \ / recipients / [\n         [\n           / protected / h'a10129' / {\n     \
    \          \\ alg \\ 1:-10\n             } / ,\n           / unprotected / {\n\
    \             / salt / -20:'aabbccddeeffgghh',\n             / kid / 4:'our-secret'\n\
    \           },\n           / ciphertext / h''\n         ]\n       ]\n     ]\n\
    \   )\n"
- title: C.3.3.  Counter Signature on Encrypted Content
  contents:
  - "C.3.3.  Counter Signature on Encrypted Content\n   This example uses the following:\n\
    \   o  CEK: AES-GCM w/ 128-bit key\n   o  Recipient class: ECDH Ephemeral-Static,\
    \ Curve P-256\n   Size of binary file is 326 bytes\n   96(\n     [\n       / protected\
    \ / h'a10101' / {\n           \\ alg \\ 1:1 \\ AES-GCM 128 \\\n         } / ,\n\
    \       / unprotected / {\n         / iv / 5:h'c9cf4df2fe6c632bf7886413',\n  \
    \       / countersign / 7:[\n           / protected / h'a1013823' / {\n      \
    \         \\ alg \\ 1:-36\n             } / ,\n           / unprotected / {\n\
    \             / kid / 4:'bilbo.baggins@hobbiton.example'\n           },\n    \
    \       / signature / h'00929663c8789bb28177ae28467e66377da12302d7f9\n   594d2999afa5dfa531294f8896f2b6cdf1740014f4c7f1a358e3a6cf57f4ed6fb02f\n\
    \   cf8f7aa989f5dfd07f0700a3a7d8f3c604ba70fa9411bd10c2591b483e1d2c31de00\n   3183e434d8fba18f17a4c7e3dfa003ac1cf3d30d44d2533c4989d3ac38c38b71481c\n\
    \   c3430c9d65e7ddff'\n         ]\n       },\n       / ciphertext / h'7adbe2709ca818fb415f1e5df66f4e1a51053ba6d65a1a0\n\
    \   c52a357da7a644b8070a151b0',\n       / recipients / [\n         [\n       \
    \    / protected / h'a1013818' / {\n               \\ alg \\ 1:-25 \\ ECDH-ES\
    \ + HKDF-256 \\\n             } / ,\n           / unprotected / {\n          \
    \   / ephemeral / -1:{\n               / kty / 1:2,\n               / crv / -1:1,\n\
    \               / x / -2:h'98f50a4ff6c05861c8860d13a638ea56c3f5ad7590bbf\n   bf054e1c7b4d91d6280',\n\
    \               / y / -3:true\n             },\n             / kid / 4:'meriadoc.brandybuck@buckland.example'\n\
    \           },\n           / ciphertext / h''\n         ]\n       ]\n     ]\n\
    \   )\n"
- title: C.3.4.  Encrypted Content with External Data
  contents:
  - "C.3.4.  Encrypted Content with External Data\n   This example uses the following:\n\
    \   o  CEK: AES-GCM w/ 128-bit key\n   o  Recipient class: ECDH static-Static,\
    \ Curve P-256 with AES Key Wrap\n   o  Externally Supplied AAD: h'0011bbcc22dd44ee55ff660077'\n\
    \   Size of binary file is 173 bytes\n   96(\n     [\n       / protected / h'a10101'\
    \ / {\n           \\ alg \\ 1:1 \\ AES-GCM 128 \\\n         } / ,\n       / unprotected\
    \ / {\n         / iv / 5:h'02d1f7e6f26c43d4868d87ce'\n       },\n       / ciphertext\
    \ / h'64f84d913ba60a76070a9a48f26e97e863e28529d8f5335\n   e5f0165eee976b4a5f6c6f09d',\n\
    \       / recipients / [\n         [\n           / protected / h'a101381f' / {\n\
    \               \\ alg \\ 1:-32 \\ ECHD-SS+A128KW \\\n             } / ,\n   \
    \        / unprotected / {\n             / static kid / -3:'peregrin.took@tuckborough.example',\n\
    \             / kid / 4:'meriadoc.brandybuck@buckland.example',\n            \
    \ / U nonce / -22:h'0101'\n           },\n           / ciphertext / h'41e0d76f579dbd0d936a662d54d8582037de2e366fd\n\
    \   e1c62'\n         ]\n       ]\n     ]\n   )\n"
- title: C.4.  Examples of Encrypted Messages
  contents:
  - 'C.4.  Examples of Encrypted Messages

    '
- title: C.4.1.  Simple Encrypted Message
  contents:
  - "C.4.1.  Simple Encrypted Message\n   This example uses the following:\n   o \
    \ CEK: AES-CCM w/ 128-bit key and a 64-bit tag\n   Size of binary file is 52 bytes\n\
    \   16(\n     [\n       / protected / h'a1010a' / {\n           \\ alg \\ 1:10\
    \ \\ AES-CCM-16-64-128 \\\n         } / ,\n       / unprotected / {\n        \
    \ / iv / 5:h'89f52f65a1c580933b5261a78c'\n       },\n       / ciphertext / h'5974e1b99a3a4cc09a659aa2e9e7fff161d38ce71cb45ce\n\
    \   460ffb569'\n     ]\n   )\n"
- title: C.4.2.  Encrypted Message with a Partial IV
  contents:
  - "C.4.2.  Encrypted Message with a Partial IV\n   This example uses the following:\n\
    \   o  CEK: AES-CCM w/ 128-bit key and a 64-bit tag\n   o  Prefix for IV is 89F52F65A1C580933B52\n\
    \   Size of binary file is 41 bytes\n   16(\n     [\n       / protected / h'a1010a'\
    \ / {\n           \\ alg \\ 1:10 \\ AES-CCM-16-64-128 \\\n         } / ,\n   \
    \    / unprotected / {\n         / partial iv / 6:h'61a7'\n       },\n       /\
    \ ciphertext / h'252a8911d465c125b6764739700f0141ed09192de139e05\n   3bd09abca'\n\
    \     ]\n   )\n"
- title: C.5.  Examples of MACed Messages
  contents:
  - 'C.5.  Examples of MACed Messages

    '
- title: C.5.1.  Shared Secret Direct MAC
  contents:
  - "C.5.1.  Shared Secret Direct MAC\n   This example uses the following:\n   o \
    \ MAC: AES-CMAC, 256-bit key, truncated to 64 bits\n   o  Recipient class: direct\
    \ shared secret\n   Size of binary file is 57 bytes\n   97(\n     [\n       /\
    \ protected / h'a1010f' / {\n           \\ alg \\ 1:15 \\ AES-CBC-MAC-256//64\
    \ \\\n         } / ,\n       / unprotected / {},\n       / payload / 'This is\
    \ the content.',\n       / tag / h'9e1226ba1f81b848',\n       / recipients / [\n\
    \         [\n           / protected / h'',\n           / unprotected / {\n   \
    \          / alg / 1:-6 / direct /,\n             / kid / 4:'our-secret'\n   \
    \        },\n           / ciphertext / h''\n         ]\n       ]\n     ]\n   )\n"
- title: C.5.2.  ECDH Direct MAC
  contents:
  - "C.5.2.  ECDH Direct MAC\n   This example uses the following:\n   o  MAC: HMAC\
    \ w/SHA-256, 256-bit key\n   o  Recipient class: ECDH key agreement, two static\
    \ keys, HKDF w/\n      context structure\n   Size of binary file is 214 bytes\n\
    \   97(\n     [\n       / protected / h'a10105' / {\n           \\ alg \\ 1:5\
    \ \\ HMAC 256//256 \\\n         } / ,\n       / unprotected / {},\n       / payload\
    \ / 'This is the content.',\n       / tag / h'81a03448acd3d305376eaa11fb3fe416a955be2cbe7ec96f012c99\n\
    \   4bc3f16a41',\n       / recipients / [\n         [\n           / protected\
    \ / h'a101381a' / {\n               \\ alg \\ 1:-27 \\ ECDH-SS + HKDF-256 \\\n\
    \             } / ,\n           / unprotected / {\n             / static kid /\
    \ -3:'peregrin.took@tuckborough.example',\n             / kid / 4:'meriadoc.brandybuck@buckland.example',\n\
    \             / U nonce / -22:h'4d8553e7e74f3c6a3a9dd3ef286a8195cbf8a23d\n   19558ccfec7d34b824f42d92bd06bd2c7f0271f0214e141fb779ae2856abf585a583\n\
    \   68b017e7f2a9e5ce4db5'\n           },\n           / ciphertext / h''\n    \
    \     ]\n       ]\n     ]\n   )\n"
- title: C.5.3.  Wrapped MAC
  contents:
  - "C.5.3.  Wrapped MAC\n   This example uses the following:\n   o  MAC: AES-MAC,\
    \ 128-bit key, truncated to 64 bits\n   o  Recipient class: AES Key Wrap w/ a\
    \ pre-shared 256-bit key\n   Size of binary file is 109 bytes\n   97(\n     [\n\
    \       / protected / h'a1010e' / {\n           \\ alg \\ 1:14 \\ AES-CBC-MAC-128//64\
    \ \\\n         } / ,\n       / unprotected / {},\n       / payload / 'This is\
    \ the content.',\n       / tag / h'36f5afaf0bab5d43',\n       / recipients / [\n\
    \         [\n           / protected / h'',\n           / unprotected / {\n   \
    \          / alg / 1:-5 / A256KW /,\n             / kid / 4:'018c0ae5-4d9b-471b-bfd6-eef314bc7037'\n\
    \           },\n           / ciphertext / h'711ab0dc2fc4585dce27effa6781c8093eba906f227\n\
    \   b6eb0'\n         ]\n       ]\n     ]\n   )\n"
- title: C.5.4.  Multi-Recipient MACed Message
  contents:
  - "C.5.4.  Multi-Recipient MACed Message\n   This example uses the following:\n\
    \   o  MAC: HMAC w/ SHA-256, 128-bit key\n   o  Recipient class: Uses three different\
    \ methods\n      1.  ECDH Ephemeral-Static, Curve P-521, AES Key Wrap w/ 128-bit\n\
    \          key\n      2.  AES Key Wrap w/ 256-bit key\n   Size of binary file\
    \ is 309 bytes\n   97(\n     [\n       / protected / h'a10105' / {\n         \
    \  \\ alg \\ 1:5 \\ HMAC 256//256 \\\n         } / ,\n       / unprotected / {},\n\
    \       / payload / 'This is the content.',\n       / tag / h'bf48235e809b5c42e995f2b7d5fa13620e7ed834e337f6aa43df16\n\
    \   1e49e9323e',\n       / recipients / [\n         [\n           / protected\
    \ / h'a101381c' / {\n               \\ alg \\ 1:-29 \\ ECHD-ES+A128KW \\\n   \
    \          } / ,\n           / unprotected / {\n             / ephemeral / -1:{\n\
    \               / kty / 1:2,\n               / crv / -1:3,\n               / x\
    \ / -2:h'0043b12669acac3fd27898ffba0bcd2e6c366d53bc4db\n   71f909a759304acfb5e18cdc7ba0b13ff8c7636271a6924b1ac63c02688075b55ef2\n\
    \   d613574e7dc242f79c3',\n               / y / -3:true\n             },\n   \
    \          / kid / 4:'bilbo.baggins@hobbiton.example'\n           },\n       \
    \    / ciphertext / h'339bc4f79984cdc6b3e6ce5f315a4c7d2b0ac466fce\n   a69e8c07dfbca5bb1f661bc5f8e0df9e3eff5'\n\
    \         ],\n         [\n           / protected / h'',\n           / unprotected\
    \ / {\n             / alg / 1:-5 / A256KW /,\n             / kid / 4:'018c0ae5-4d9b-471b-bfd6-eef314bc7037'\n\
    \           },\n           / ciphertext / h'0b2c7cfce04e98276342d6476a7723c090dfdd15f9a\n\
    \   518e7736549e998370695e6d6a83b4ae507bb'\n         ]\n       ]\n     ]\n   )\n"
- title: C.6.  Examples of MAC0 Messages
  contents:
  - 'C.6.  Examples of MAC0 Messages

    '
- title: C.6.1.  Shared Secret Direct MAC
  contents:
  - "C.6.1.  Shared Secret Direct MAC\n   This example uses the following:\n   o \
    \ MAC: AES-CMAC, 256-bit key, truncated to 64 bits\n   o  Recipient class: direct\
    \ shared secret\n   Size of binary file is 37 bytes\n   17(\n     [\n       /\
    \ protected / h'a1010f' / {\n           \\ alg \\ 1:15 \\ AES-CBC-MAC-256//64\
    \ \\\n         } / ,\n       / unprotected / {},\n       / payload / 'This is\
    \ the content.',\n       / tag / h'726043745027214f'\n     ]\n   )\n   Note that\
    \ this example uses the same inputs as Appendix C.5.1.\n"
- title: C.7.  COSE Keys
  contents:
  - 'C.7.  COSE Keys

    '
- title: C.7.1.  Public Keys
  contents:
  - "C.7.1.  Public Keys\n   This is an example of a COSE Key Set.  This example includes\
    \ the\n   public keys for all of the previous examples.\n   In order the keys\
    \ are:\n   o  An EC key with a kid of \"meriadoc.brandybuck@buckland.example\"\
    \n   o  An EC key with a kid of \"peregrin.took@tuckborough.example\"\n   o  An\
    \ EC key with a kid of \"bilbo.baggins@hobbiton.example\"\n   o  An EC key with\
    \ a kid of \"11\"\n   Size of binary file is 481 bytes\n   [\n     {\n       -1:1,\n\
    \       -2:h'65eda5a12577c2bae829437fe338701a10aaa375e1bb5b5de108de439c0\n   8551d',\n\
    \       -3:h'1e52ed75701163f7f9e40ddf9f341b3dc9ba860af7e0ca7ca7e9eecd008\n   4d19c',\n\
    \       1:2,\n       2:'meriadoc.brandybuck@buckland.example'\n     },\n     {\n\
    \       -1:1,\n       -2:h'bac5b11cad8f99f9c72b05cf4b9e26d244dc189f745228255a219a86d6a\n\
    \   09eff',\n       -3:h'20138bf82dc1b6d562be0fa54ab7804a3a64b6d72ccfed6b6fb6ed28bbf\n\
    \   c117e',\n       1:2,\n       2:'11'\n     },\n     {\n       -1:3,\n     \
    \  -2:h'0072992cb3ac08ecf3e5c63dedec0d51a8c1f79ef2f82f94f3c737bf5de\n   7986671eac625fe8257bbd0394644caaa3aaf8f27a4585fbbcad0f2457620085e5c8\n\
    \   f42ad',\n       -3:h'01dca6947bce88bc5790485ac97427342bc35f887d86d65a089377e247e\n\
    \   60baa55e4e8501e2ada5724ac51d6909008033ebc10ac999b9d7f5cc2519f3fe1ea1\n   d9475',\n\
    \       1:2,\n       2:'bilbo.baggins@hobbiton.example'\n     },\n     {\n   \
    \    -1:1,\n       -2:h'98f50a4ff6c05861c8860d13a638ea56c3f5ad7590bbfbf054e1c7b4d91\n\
    \   d6280',\n       -3:h'f01400b089867804b8e9fc96c3932161f1934f4223069170d924b7e03bf\n\
    \   822bb',\n       1:2,\n       2:'peregrin.took@tuckborough.example'\n     }\n\
    \   ]\n"
- title: C.7.2.  Private Keys
  contents:
  - "C.7.2.  Private Keys\n   This is an example of a COSE Key Set.  This example\
    \ includes the\n   private keys for all of the previous examples.\n   In order\
    \ the keys are:\n   o  An EC key with a kid of \"meriadoc.brandybuck@buckland.example\"\
    \n   o  A shared-secret key with a kid of \"our-secret\"\n   o  An EC key with\
    \ a kid of \"peregrin.took@tuckborough.example\"\n   o  A shared-secret key with\
    \ a kid of \"018c0ae5-4d9b-471b-\n      bfd6-eef314bc7037\"\n   o  An EC key with\
    \ a kid of \"bilbo.baggins@hobbiton.example\"\n   o  An EC key with a kid of \"\
    11\"\n   Size of binary file is 816 bytes\n   [\n     {\n       1:2,\n       2:'meriadoc.brandybuck@buckland.example',\n\
    \       -1:1,\n       -2:h'65eda5a12577c2bae829437fe338701a10aaa375e1bb5b5de108de439c0\n\
    \   8551d',\n       -3:h'1e52ed75701163f7f9e40ddf9f341b3dc9ba860af7e0ca7ca7e9eecd008\n\
    \   4d19c',\n       -4:h'aff907c99f9ad3aae6c4cdf21122bce2bd68b5283e6907154ad911840fa\n\
    \   208cf'\n     },\n     {\n       1:2,\n       2:'11',\n       -1:1,\n     \
    \  -2:h'bac5b11cad8f99f9c72b05cf4b9e26d244dc189f745228255a219a86d6a\n   09eff',\n\
    \       -3:h'20138bf82dc1b6d562be0fa54ab7804a3a64b6d72ccfed6b6fb6ed28bbf\n   c117e',\n\
    \       -4:h'57c92077664146e876760c9520d054aa93c3afb04e306705db609030850\n   7b4d3'\n\
    \     },\n     {\n       1:2,\n       2:'bilbo.baggins@hobbiton.example',\n  \
    \     -1:3,\n       -2:h'0072992cb3ac08ecf3e5c63dedec0d51a8c1f79ef2f82f94f3c737bf5de\n\
    \   7986671eac625fe8257bbd0394644caaa3aaf8f27a4585fbbcad0f2457620085e5c8\n   f42ad',\n\
    \       -3:h'01dca6947bce88bc5790485ac97427342bc35f887d86d65a089377e247e\n   60baa55e4e8501e2ada5724ac51d6909008033ebc10ac999b9d7f5cc2519f3fe1ea1\n\
    \   d9475',\n       -4:h'00085138ddabf5ca975f5860f91a08e91d6d5f9a76ad4018766a476680b\n\
    \   55cd339e8ab6c72b5facdb2a2a50ac25bd086647dd3e2e6e99e84ca2c3609fdf177f\n   eb26d'\n\
    \     },\n     {\n       1:4,\n       2:'our-secret',\n       -1:h'849b57219dae48de646d07dbb533566e976686457c1491be3a76dcea6c4\n\
    \   27188'\n     },\n     {\n       1:2,\n       -1:1,\n       2:'peregrin.took@tuckborough.example',\n\
    \       -2:h'98f50a4ff6c05861c8860d13a638ea56c3f5ad7590bbfbf054e1c7b4d91\n   d6280',\n\
    \       -3:h'f01400b089867804b8e9fc96c3932161f1934f4223069170d924b7e03bf\n   822bb',\n\
    \       -4:h'02d1f7e6f26c43d4868d87ceb2353161740aacf1f7163647984b522a848\n   df1c3'\n\
    \     },\n     {\n       1:4,\n       2:'our-secret2',\n       -1:h'849b5786457c1491be3a76dcea6c4271'\n\
    \     },\n     {\n       1:4,\n       2:'018c0ae5-4d9b-471b-bfd6-eef314bc7037',\n\
    \       -1:h'849b57219dae48de646d07dbb533566e976686457c1491be3a76dcea6c4\n   27188'\n\
    \     }\n   ]\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   This document is a product of the COSE working group of the\
    \ IETF.\n   The following individuals are to blame for getting me started on this\n\
    \   project in the first place: Richard Barnes, Matt Miller, and Martin\n   Thomson.\n\
    \   The initial version of the specification was based to some degree on\n   the\
    \ outputs of the JOSE and S/MIME working groups.\n   The following individuals\
    \ provided input into the final form of the\n   document: Carsten Bormann, John\
    \ Bradley, Brain Campbell, Michael B.\n   Jones, Ilari Liusvaara, Francesca Palombini,\
    \ Ludwig Seitz, and Goran\n   Selander.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Jim Schaad\n   August Cellars\n   Email: ietf@augustcellars.com\n"
