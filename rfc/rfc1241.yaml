- title: __initial_text__
  contents:
  - "            A Scheme for an Internet Encapsulation Protocol:\n              \
    \                 Version 1\n"
- title: 1. Status of this Memo
  contents:
  - "1. Status of this Memo\n   This memo defines an Experimental Protocol for the\
    \ Internet\n   community.  Discussion and suggestions for improvement are requested.\n\
    \   Please refer to the current edition of the \"IAB Official Protocol\n   Standards\"\
    \ for the standardization state and status of this protocol.\n   Distribution\
    \ of this memo is unlimited.\n"
- title: 2. Glossary
  contents:
  - "2. Glossary\n   Clear Datagram -\n     The unmodified IP datagram in the User\
    \ Space before\n     Encapsulation.\n   Clear Header -\n     The header portion\
    \ of the Clear Datagram before\n     Encapsulation.  This header includes the\
    \ IP header and\n     possibly part or all of the next layer protocol header,\n\
    \     i.e., the TCP header.\n   Decapsulation -\n     The stripping of the Encapsulation\
    \ Header and forwarding\n     of the Clear Datagram by the Decapsulator.\n   Decapsulator\
    \ -\n     The entity responsible for receiving an Encapsulated\n     Datagram,\
    \ decapsulating it, and delivering it to the\n     destination User Space.  Delivery\
    \ may be direct, or via\n     Encapsulation.  A Decapsulator may be a host or\
    \ a gateway.\n   Encapsulated Datagram -\n     The datagram consisting of a Clear\
    \ Datagram prepended with\n     an Encapsulation Header.\n   Encapsulation -\n\
    \     The process of mapping a Clear Datagram to the\n     Encapsulation Space,\
    \ prepending an Encapsulation Header to\n     the Clear Datagram and routing the\
    \ Encapsulated Datagram\n     to a Decapsulator.\n   Encapsulation Header -\n\
    \     The header for the Encapsulation Protocol prepended to the\n     Clear Datagram\
    \ during Encapsulation.  This header consists\n     of an IP header followed by\
    \ an Encapsulation Protocol\n     Header.\n   Encapsulation Protocol Header -\n\
    \     The Encapsulation Protocol specific portion of the\n     Encapsulation Header.\n\
    \   Encapsulation Space -\n     The address and routing space within which the\n\
    \     Encapsulators and Decapsulators reside.  Routing within\n     this space\
    \ is accomplished via Flows.  Encapsulation\n     Spaces do not overlap, that\
    \ is, the address of any\n     Encapsulator or Decapsulator is unique for all\n\
    \     Encapsulation Spaces.\n   Encapsulator -\n     The entity responsible for\
    \ mapping a given User Space\n     datagram to the Encapsulation Space, encapsulating\
    \ the\n     datagram, and forwarding the Encapsulated Datagram to a\n     Decapsulator.\
    \  An Encapsulator may be a host or a gateway.\n   Flow -\n     Also called a\
    \ \"tunnel.\"  A flow is the end-to-end path in\n     the Encapsulation Space\
    \ over which Encapsulated Datagrams\n     travel.  There may be several Encapsulator/Decapsulator\n\
    \     pairs along a given flow.  Note that a Flow does not\n     denote what User\
    \ Space gateways are traversed along the\n     path.\n   Flow ID -\n     A 32-bit\
    \ identifier which uniquely distinguishes a flow in\n     a given Encapsulator\
    \ or Decapsulator.  Flow IDs are\n     specific to a single Encapsulator/Decapsulator\
    \ Entity and\n     are not global quantities.\n   Mapping Function -\n     This\
    \ is the function of mapping a Clear Header to a\n     particular Flow.  All encapsulators\
    \ along a given Flow are\n     required to map a given Clear Header to the same\
    \ Flow.\n   User Address -\n     The address or identifier uniquely identifying\
    \ an entity\n     within a User Space.\n   Source Route -\n     A complete end-to-end\
    \ route which is computed at the\n     source and enumerates transit gateways.\n\
    \   User Space -\n     The address and routing space within which the users\n\
    \     reside.  Routing within this space provides reachability\n     between all\
    \ address pairs within the space.  User Spaces\n     do not overlap, that is,\
    \ a given User Address is unique in\n     all User Spaces.\n"
- title: 3. Background
  contents:
  - "3. Background\n   For several years researchers in the Internet community have\
    \ needed a\n   means of \"tunneling\" between networks.  A tunnel is essentially\
    \ a\n   Source Route that circumvents conventional routing mechanisms.\n   Tunnels\
    \ provide the means to bypass routing failures, avoid broken\n   gateways and\
    \ routing domains, or establish deterministic paths for\n   experimentation.\n\
    \   There are several means of accomplishing tunneling.  In the past,\n   tunneling\
    \ has been accomplished through source routing options in the\n   IP header which\
    \ allow gateways along a given path to be enumerated.\n   The disadvantage of\
    \ source routing in the IP header is that it\n   requires the source to know something\
    \ about the networks traversed to\n   reach the destination.  The source must\
    \ then modify outgoing packets\n   to reflect the source route.  Current routing\
    \ implementations\n   generally don't support source routes in their routing tables\
    \ as a\n   means of reaching an IP address, nor do current routing protocols.\n\
    \   Another means of tunneling would be to develop a new IP option.  This\n  \
    \ option field would be part of a separate IP header that could be\n   prepended\
    \ to an IP datagram.  The IP option would indicate\n   information about the original\
    \ datagram.  This tunneling option has\n   the disadvantage of significantly modifying\
    \ existing IP\n   implementations to handle a new IP option.  It also would be\
    \ less\n   flexible in permitting the tunneling of other protocols, such as ISO\n\
    \   protocols, through an IP environment.  An even less palatable\n   alternative\
    \ would be to replace IP with a new networking protocol or\n   a new version of\
    \ IP with tunneling built in as part of its\n   functionality.\n   A final alternative\
    \ is to create a new IP encapsulation protocol\n   which uses the current IP header\
    \ format.  By using encapsulation, a\n   destination can be reached transparently\
    \ without the source having to\n   know topology specifics.  Virtual networks\
    \ can be created by tying\n   otherwise unconnected machines together with flows\
    \ through an\n   encapsulation space.\n                                      \
    \         ++++++  Clear Datagram\n                                           \
    \    ******  Encapsulated\n       Datagram\n                                 \
    \                   #\n       Encapsulator/Decapsulator\n                    \
    \                                &  User Space Host\n           User Space A \
    \                       User Space C\n          --------------               \
    \     -----------\n         /              \\                  /           \\\n\
    \        /                \\                /             \\\n       |       \
    \           |              |               |\n       |     &            |    \
    \          |               |\n       |     +   +++++    |              |     \
    \ *****    |\n       |     +++++   +    |              |      *   *    |\n   \
    \    |             +    |              |  *****   *    |\n        \\         \
    \   +   /  -----------  \\ *       *    /  ----------\n         \\           ++>\
    \ # *         **> # *        ***> # ++++      \\\n          --------------  /\
    \ *        *  \\  ------------  /   +        \\\n                         |  *\
    \        *   |              |    +         |\n                         |  *  \
    \      *   |              |    +         |\n                         |  *****\
    \    *   |              |    +++++++   |\n                         |      *****\
    \    |              |          V   |\n                         |             \
    \  |              |          &   |\n                          \\             /\
    \                \\             /\n                           \\           / \
    \                 \\           /\n                            -----------    \
    \                ----------\n                           Encapsulation        \
    \              User\n                              Space B                   \
    \     Space D\n                  Fig. 1.  Encapsulation Architectural Model\n\
    \   Up until now, there has been no standard for an encapsulation\n   protocol.\
    \  This RFC provides a means of performing encapsulation in\n   the Internet environment.\n"
- title: 4. Architecture and Approach
  contents:
  - "4. Architecture and Approach\n   The architecture for encapsulation is based\
    \ on two entities -- an\n   Encapsulator and a Decapsulator.  These entities and\
    \ the associated\n   spaces are shown in Fig. 1.\n   Encapsulators and Decapsulators\
    \ have addresses in the User Spaces to\n   which they belong, as well as addresses\
    \ in the Encapsulation Spaces\n   to which they belong. An encapsulator will receive\
    \ a Clear Datagram\n   from its User Space, and after determining that encapsulation\
    \ should\n   be used, perform a mapping function which translates the User Space\n\
    \   information in the Clear Header to an Encapsulation Header.  This\n   Encapsulation\
    \ Header is then prepended to the Clear Datagram to form\n   the Encapsulated\
    \ Datagram, as in Fig 2.  It is desirable that the\n   encapsulation process be\
    \ transparent to entities in the User Space.\n   Only the Encapsulator need know\
    \ that encapsulation is occurring.\n         +---------------+-----------------+--------+----------------+\n\
    \         | Encapsulating |  Encapsulation  | Clear  |  Remainder of  |\n    \
    \     |   IP Header   | Protocol Header | Header | Clear Datagram |\n        \
    \ +---------------+-----------------+--------+----------------+\n         |  \
    \                               |                         |\n         |      \
    \  Encapsulation Header     |      Clear Datagram     |\n         |          \
    \                       |                         |\n                 Fig. 2.\
    \  Example of an Encapsulated Datagram\n   The Encapsulator forwards the datagram\
    \ to a Decapsulator whose\n   identity is determined at the time of encapsulation.\
    \  The\n   Decapsulator receives the Encapsulated Datagram and removes the\n \
    \  Encapsulation Header and treats the Clear Datagram as if it were\n   received\
    \ locally.  The requirement for the address of the\n   Decapsulator is that it\
    \ be reachable from the Encapsulator's\n   Encapsulation Space address.\n"
- title: 5. Generation of the Encapsulation Header
  contents:
  - "5. Generation of the Encapsulation Header\n   The contents of the Encapsulation\
    \ Header are generated by performing\n   a mapping function from the Clear Header\
    \ to the contents of the\n   Encapsulation Header.  This mapping function could\
    \ take many forms,\n   but the end result should be the same.  The following paragraphs\n\
    \   describe one method of performing the mapping.  The process is\n   illustrated\
    \ in Fig. 3.\n   In the first part of the mapping function, the Clear Header is\n\
    \   matched with stored headers and masks to determine a Flow ID.  This\n   is\
    \ essentially a \"mask-and-match\" table look up, where the lookup\n   table holds\
    \ three entries, a Clear Header, a header mask, and a\n   corresponding Flow ID.\
    \  The mask can be used for allowing a range of\n   source and destination addresses\
    \ to map to a given flow.  Other\n   fields, such as the IP TOS bits or even the\
    \ TCP source or destination\n   port addresses could also be used to discriminate\
    \ between Flows.\n   This flexibility allows many possibilities for using the\
    \ mapping\n   function.  Not only can a given network be associated with a\n \
    \  particular flow, but even a particular TCP protocol or connection\n   could\
    \ be distinguished from another.\n   How the lookup table is built and maintained\
    \ is not part of this\n   protocol.  It is assumed that it is managed by some\
    \ higher layer\n   entity.  It would be sufficient to configure the tables from\
    \ ascii\n   text files if necessary.\n                                       \
    \         +--------+\n                                                |      \
    \  |\n                                             +->| Encap. |--+\n        \
    \                                     |  | Info.  |  |\n                   +-------+\
    \                 |  | Table  |  |\n                   | Mask  |   +---------+\
    \   |  |        |  |\n       Clear --+-->|  &    |-->| Flow ID |---+  |      \
    \  |  |\n       Header  |   | Match |   +---------+      +--------+  |\n     \
    \          |   +-------+                                |\n               |  \
    \                                          +-->  Encap\n               +----------------------------------------------->\
    \  Header\n                Fig. 3.  Generation of the Encapsulation Header\n \
    \  The Flow IDs are managed at a higher layer as well.  An example of\n   how\
    \ Flow IDs can be managed is found in the Setup protocol of the\n   Inter-Domain\
    \ Policy Sensitive Routing Protocol (IDPR). [4] The upper\n   layer protocol would\
    \ be responsible for maintaining information not\n   carried in the encapsulation\
    \ protocol related to the flow.  This\n   could include the information necessary\
    \ to construct the\n   Encapsulation Header (described below) as well as information\
    \ such as\n   the type of data being encapsulated (currently only IP is defined),\n\
    \   and the type of authentication used if any.  Note that IDPR Setup\n   requires\
    \ the use of a longer Flow ID which is unique for the entire\n   universe of Encapsulators\
    \ and is the same at every Encapsulator.\n   The Flow ID that results from the\
    \ mapping of a Clear Header is a 32\n   bit quantity and identifies the Flow as\
    \ it is seen by the\n   Encapsulator.  If a Clear Datagram must be encapsulated\
    \ and\n   decapsulated several times in order reach the destination, the Flow\n\
    \   ID may be different at each Encapsulator, but need not be.  The Flow\n   ID\
    \ acts as an index into a table of Encapsulation Header information\n   that is\
    \ used to build the Encapsulation Header.  Note that the\n   decision to make\
    \ the Flow ID local to the Encapsulator is due to the\n   difficulty in choosing\
    \ and maintaining globally unique identifiers.\n   The intermediate step of using\
    \ a Flow ID entirely optional.  The\n   important requirement is that all Encapsulators\
    \ along a Flow map the\n   same Clear Header to the same Flow (which could be\
    \ identified by\n   different identifiers along the way).  However, by allowing\
    \ for a\n   Flow ID in the protocol, a more efficient implementation of the\n\
    \   mapping function becomes possible.  This is discussed in more detail\n   when\
    \ we consider the Decapsulator.\n   The following information is required to construct\
    \ the Encapsulation\n   Header:\n   Flow ID -\n     This is the key for this table\
    \ of information and\n     represents the Flow ID relative to the current\n  \
    \   Encapsulator.\n   Decapsulator Address -\n     The IP address of the Decapsulator\
    \ in the Encapsulation\n     Space must be known to build the IP portion of the\n\
    \     Encapsulation Header.\n   Decapsulator's Flow ID -\n     The Flow ID, if\
    \ any, for the Flow as seen by the\n     Decapsulator must be known.\n   Previous\
    \ Encapsulator's Address -\n     If this is not the first Encapsulator along the\
    \ Flow, the\n     previous Encapsulator's address must be known for error\n  \
    \   reporting.\n   Previous Encapsulator's Flow ID -\n     In addition to the\
    \ previous Encapsulator's address, the\n     Flow ID of the Flow relative to the\
    \ previous Encapsulator\n     must be known.\n   The Encapsulation Header consists\
    \ of an IP Header as well as an\n   Encapsulation Protocol Header.  The two pieces\
    \ of information\n   required for the Encapsulation Protocol Header which must\
    \ be\n   determined at the time of encapsulation are the protocol which is\n \
    \  being encapsulated and the Flow ID to send to the Decapsulator.  The\n   generation\
    \ of the IP header is more complicated.\n   There are  two possible ways each\
    \ field in the Clear Header could\n   related to the new IP header.\n   Copy -\n\
    \     Copy the existing field from the Clear Header to the IP\n     header in\
    \ the Encapsulation Header.\n   Ignore -\n     The field may or may not have existed\
    \ in the Clear Header,\n     but does not apply to the new IP header.\n   The\
    \ IP header has a fixed portion and a variable portion, the options\n   list.\
    \  A summary of all possible IP fields and the relation to the\n   Clear Header\
    \ follows in Table 1. [2]\n   Note that most of the fields in the Clear Header\
    \ are simply ignored.\n   Fields such as the Header Length in the Clear Header\
    \ have no effect\n   on the Header Length of the new IP header.  The fields which\
    \ are more\n   interesting and require some thought are now discussed.\n   The\
    \ Quality of Service bits should be copied from the Clear Header to\n   the new\
    \ IP header.  This is in keeping with the transparency\n   principle that if the\
    \ User Space was providing a given service, then\n   the Encapsulation Space must\
    \ provide the same service.\n   The More Fragments bit and Fragment Offset should\
    \ not be copied,\n   since the datagram being built is a complete datagram, regardless\
    \ of\n   the status of the encapsulated datagram.  If the completed datagram\n\
    \   is too large for the interface, it will be fragmented for\n   transmission\
    \ to the decapsulator by the normal IP fragmentation\n   mechanism.\n   The Don't\
    \ Fragment bit should not be copied into the Encapsulation\n   Header.  The transparency\
    \ principle would again be violated.  It\n   should be up to the Encapsulator\
    \ to decide whether fragmentation\n   should be allowed across the Encapsulation\
    \ Space.  If it is decided\n   that the DF bit should be used, then ICMP message\
    \ would be returned\n   if the Encapsulated Datagram required fragmentation across\
    \ the\n   Encapsulation Space The mechanism for returning an ICMP message to\n\
    \   the source in the User space will have to be modified, however, and\n   this\
    \ is discussed in the Appendix B.\n   Regarding the Time To Live (TTL) field,\
    \ the easiest thing to do is to\n   ignore the TTL from the Clear Header.  If\
    \ this field were copied from\n   the Clear Header to the new IP header, the packet\
    \ life might be\n   prematurely exceeded during transit in the Encapsulation Space.\
    \  This\n   breaks the transparency rule of encapsulation as seen from the User\n\
    \   Space.  The TTL of the Clear Header is decremented before\n   encapsulation\
    \ by the IP forwarding function, so there is no chance of\n   a packet looping\
    \ forever if the links of a Flow form a loop.\n                          +---------------------+---------+\n\
    \                          |        Field        | Mapping |\n               \
    \           +---------------------+---------+\n                          | Version\
    \             | Ignore  |\n                          | Header Length       | Ignore\
    \  |\n                          | Precedence          | Copy    |\n          \
    \                | QoS bits            | Copy    |\n                         \
    \ | Total Length        | Ignore  |\n                          | Identification\
    \      | Ignore  |\n                          | Don't Fragment Bit  | Ignore \
    \ |\n                          | More Fragments Bit  | Ignore  |\n           \
    \               | Fragment Offset     | Ignore  |\n                          |\
    \ Time to Live        | Ignore  |\n                          | Protocol      \
    \      | Ignore  |\n                          | Header Checksum     | Ignore \
    \ |\n                          | Source Address      | Ignore  |\n           \
    \               | Destination Address | Ignore  |\n                          |\
    \ End of Option List  | Ignore  |\n                          | NOP Option    \
    \      | Ignore  |\n                          | Security Option     | Copy   \
    \ |\n                          | LSR Option          | Ignore  |\n           \
    \               | SSR Option          | Ignore  |\n                          |\
    \ RR Option           | Ignore  |\n                          | Stream ID Option\
    \    | Ignore  |\n                          | Timestamp Option    | Ignore  |\n\
    \                          +---------------------+---------+\n               \
    \        Table 1.  Summary of IP Header Mappings\n   The protocol field for the\
    \ new IP header should be filled with the\n   protocol number of the encapsulation\
    \ protocol.\n   The source address in the new IP header becomes the IP address\
    \ of the\n   Encapsulator in the Encapsulation Domain.  The destination address\n\
    \   becomes the IP address of the Decapsulator as found in the\n   encapsulation\
    \ table.\n   IP Options are generally not copied because most don't make sense\
    \ in\n   the context of the Encapsulation Space, as the transparency principle\n\
    \   would indicate.  The security option is probably the one option that\n   should\
    \ get copied for the same reason QOS and precedence fields are\n   copied, the\
    \ Encapsulation Space must provide the expected service.\n   Timestamp, Loose\
    \ Source Route, Strict Source Route, and Record Route\n   are not copied during\
    \ encapsulation.\n"
- title: 6. Decapsulation
  contents:
  - "6. Decapsulation\n   In the ideal situation, a Decapsulator receives an Encapsulated\n\
    \   Datagram, strips off the Encapsulation Header and sends the Clear\n   Datagram\
    \ back into IP so that it is forwarded from that point.\n   However, if the Clear\
    \ Datagram has not reached the destination User\n   Space, it must again be encapsulated\
    \ to move it close to the\n   destination User Space.  In this latter case the\
    \ Decapsulator would\n   become an Encapsulator and would perform the same calculation\
    \ to\n   generate the Encapsulation Header as did the previous Encapsulator.\n\
    \   In order to make this process more efficient, the use of Flow IDs\n   have\
    \ been incorporated into the protocol.\n   When Flow IDs are used, the Flow ID\
    \ received in the Encapsulation\n   Header corresponds to a stored Flow ID in\
    \ the Decapsulator.  At this\n   point the Decapsulator has the option of bypassing\
    \ the mask and match\n   operation on the Clear Header.  The received Flow ID\
    \ can be used to\n   point directly into the local Encapsulator tables for the\n\
    \   construction of the next Encapsulation Header.  If the Flow ID is\n   unknown,\
    \ an error message is sent back to the previous Encapsulator\n   to that effect\
    \ and a signal is sent to upper layer entity managing\n   the encapsulation tables.\n\
    \   Because the normal IP forwarding mechanism is being bypassed when\n   Flow\
    \ IDs are used, certain mechanisms normally handled by IP must be\n   taken care\
    \ of by the Decapsulator before encapsulation.  The\n   Decapsulator must decrement\
    \ the TTL before the next encapsulation\n   occurs.  If a Time Exceeded error\
    \ occurs, then an ICMP message is\n   sent to the source indicated in the Clear\
    \ Header.\n"
- title: 7. Error Messages
  contents:
  - "7. Error Messages\n   There are two kinds of error message built into the encapsulation\n\
    \   protocol.  The first is used to report unknown flow identifiers seen\n   by\
    \ a Decapsulator and the second is for the forwarding of ICMP\n   messages.\n\
    \   When a Decapsulator is using the received Flow ID in an Encapsulation\n  \
    \ Header to forward a datagram to the next Decapsulator in a Flow, it\n   is possible\
    \ that the Flow ID may not be known.  For this case the\n   Decapsulator will\
    \ notify the previous Encapsulator that the Flow was\n   not known so that the\
    \ problem may be reported to the layer\n   responsible for the programming of\
    \ the Flow tables.  This is\n   accomplished through an encapsulation error message.\n\
    \   If an Encapsulator receives an ICMP messages regarding a given flow,\n   this\
    \ message should be forwarded backwards along the flow to the\n   source Encapsulator.\
    \  This is accomplished by the second kind of\n   error message.  The ICMP message\
    \ will contain the Flow ID of the\n   message which caused the error.  This Flow\
    \ ID must be translated to\n   the Flow ID relative to the Encapsulator to which\
    \ the error message\n   is sent.\n   If an error occurs while sending any error\
    \ message, no further error\n   message are generated.\n"
- title: 8. References
  contents:
  - "8. References\n   [1]  J. Postel,  Internet  Control  Message  Protocol,  RFC\
    \  792,\n        September 1981.\n   [2]  J. Postel, Internet Protocol, RFC 791,\
    \ September 1981.\n   [3]  J. Postel, Transmission Control Protocol, RFC 793,\
    \ September\n        1981.\n   [4]  ORWG, Inter-Domain Policy Routing Protocol\
    \ Specification and\n        Usage, Draft, August 1990\n"
- title: A. Packet Formats
  contents:
  - "A. Packet Formats\n   This section describes the packet formats for the encapsulation\n\
    \   protocol.\n        0               8              16              24     \
    \       31\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       | Vers  |  HL   |  MT   |  RC   |            Checksum           |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                            Flow ID                            |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \          Fig. A.1.  Encapsulation Protocol Header Example\n       Vers     \
    \ 4 bits    The  version   number  of  the  encapsulation\n                  \
    \         protocol.     The  version  of  the  protocol\n                    \
    \       described by this document is 1.\n       HL        4 bits    The  header\
    \   length  of   the  Encapsulation\n                           Protocol Header\
    \ in octets.\n       MT        4 bits    The  message   type  of   the   Encapsulation\n\
    \                           Protocol message.    A  data  message  has  a\n  \
    \                         message type  of 1.   An  error message has a\n    \
    \                       message type of 2.\n       RC        4 bits    The reason\
    \ code.  This field is unused in the\n                           Data Message\
    \  and must have a value of 0.  In\n                           the Error Message\
    \ it contains the reason code\n                           for the  Error Message.\
    \   Defined reason code\n                           values are:\n            \
    \                    1 Unknown Flow ID\n                                2 ICMP\
    \ returned\n       Checksum  16 bits   A   one's   complement   checksum   for\
    \   the\n                           Encapsulation Protocol Header.  This field\
    \ is\n                           set to 0 upon calculation of the checksum and\n\
    \                           is  filled   with  the  checksum  calculation\n  \
    \                         result before the data message is sent.\n       Flow\
    \ ID   32 bits   The Flow  ID as  seen by  the Decapsulator or\n             \
    \              Encapsulator to  which this  message is being\n               \
    \            sent.   In the  case of  an Unknown  Flow  ID\n                 \
    \          error, the Flow ID causing the error is used.\n"
- title: For Data Messages, the Encapsulation Protocol Header is followed by the
  contents:
  - 'For Data Messages, the Encapsulation Protocol Header is followed by the

    '
- title: Clear Datagram.  For Error Messages, the header is followed by the ICMP
  contents:
  - 'Clear Datagram.  For Error Messages, the header is followed by the ICMP

    '
- title: message being forwarded along a flow.
  contents:
  - 'message being forwarded along a flow.

    '
- title: B. Encapsulation and Existing IP Mechanisms
  contents:
  - "B. Encapsulation and Existing IP Mechanisms\n   This section discusses in detail\
    \ the effect of this encapsulation\n   protocol upon the existing mechanisms available\
    \ with IP and some the\n   possible effects of IP mechanisms upon this protocol.\
    \  Specifically\n   these are Fragmentation and ICMP messages.\n"
- title: B.1 Fragmentation and Maximum Transmission Unit
  contents:
  - "B.1 Fragmentation and Maximum Transmission Unit\n   An immediate concern of using\
    \ an encapsulation mechanism is that of\n   restrictions based upon MTU size.\
    \  The source of a Clear Datagram is\n   going to generate packets consistent\
    \ with MTU of the interface over\n   which datagram is transmitted.  If these\
    \ packets reach an\n   Encapsulator and are encapsulated, they may be fragmented\
    \ if they are\n   larger than the MTU of the Encapsulator, even though the physical\n\
    \   interfaces of the source and Encapsulator may have the same MTU.\n   Because\
    \ the Encapsulated Datagram is sent to the Decapsulator using\n   IP, there is\
    \ no problem in allowing IP to perform fragmentation and\n   reassembly.  However,\
    \ fragmentation is known to be inefficient and is\n   generally avoided.  Because\
    \ a new header is being prepended to the\n   Clear Datagram by the encapsulation\
    \ process, the likelihood of\n   fragmentation occurring is increased.  If the\
    \ Encapsulator decides to\n   disallow fragmentation through the Encapsulation\
    \ Space, it must send\n   an ICMP message back to the source.  This means that\
    \ the MTU of the\n   interface in the encapsulation space is effectively smaller\
    \ than that\n   of the physical MTU of the interface.\n   Fragmentation by intermediate\
    \ User Space Gateways introduces another\n   problem.  Fragmentation occurs at\
    \ the IP level.  If a TCP protocol is\n   in use and fragmentation occurs, the\
    \ TCP header is contained in the\n   first fragment, but not the following fragments.\
    \  [3] If these\n   fragments are forwarded by an Encapsulator, discrimination\
    \ of the\n   Clear Header for a given flow will only be able to occur on the IP\n\
    \   header portion of the Clear Header.  If discrimination is attempted\n   on\
    \ the TCP portion of the header, then only the first fragment will\n   be matched,\
    \ while remaining fragments will not.\n"
- title: B.2 ICMP Messages
  contents:
  - "B.2 ICMP Messages\n   The most controversial aspect of encapsulation is the handling\
    \ of\n   ICMP messages. [1] Because the Encapsulation Header contains the\n  \
    \ source address of the Encapsulator in the Encapsulation Space, ICMP\n   messages\
    \ which occur within the Encapsulation Space will be sent back\n   to the Encapsulator.\
    \  Once the Encapsulator receives the ICMP\n   message, the question is what should\
    \ the next action be.  Since the\n   original source of the Clear Datagram knows\
    \ nothing about the\n   Encapsulation Space, it does not make sense to forward\
    \ an ICMP\n   message on to it and ICMP message are not supposed to beget ICMP\n\
    \   messages.  Yet not sending the original source something may break\n   some\
    \ important mechanisms.\n   In addition to deciding what to forward to the source\
    \ of the Clear\n   Datagram, there is the problem of possibly not having enough\n\
    \   information to send anything at all back to the source.  An ICMP\n   message\
    \ returns the header of the offending message and the first\n   eight octets of\
    \ the data after the header.  For the case of the\n   encapsulation protocol,\
    \ this translates to the IP portion of the\n   Encapsulation Header, the first\
    \ eight octets of the Encapsulation\n   Protocol Header, and nothing else.  The\
    \ contents of the Clear\n   Datagram are completely lost.  Therefore, for the\
    \ Encapsulator to\n   send an ICMP message back to the source it has to reconstruct\
    \ the\n   Clear Header.  However, it is essentially impossible to reproduce the\n\
    \   exact header.\n   For the purpose of this specification, the Flow ID has been\
    \ assumed\n   to be a unique one way mapping from a Clear Header.  There is no\n\
    \   guarantee that the Flow ID could be used to map back to the Clear\n   Header,\
    \ since several headers potentially map to the same flow.  With\n   there being\
    \ no effective way to regenerate the original datagram,\n   some compromises must\
    \ be examined.\n   For each of the possible ICMP messages, the alternatives and\
    \ impact\n   will be assessed.  There are three categories of ICMP message\n \
    \  involved.  The first is those ICMP messages which are not applicable\n   in\
    \ the context of Encapsulation.  These are: Echo/Echo Reply and\n   Timestamp/Timestamp\
    \ Reply.\n   The second category are those ICMP messages which concern mechanisms\n\
    \   local to the encapsulation domain.  These are messages which would\n   not\
    \ make sense to the original source if it did receive them.  In\n   these cases\
    \ the encapsulator will have to decide what to do, but no\n   ICMP message need\
    \ be sent back to the original source.  The datagram\n   will simply be lost,\
    \ IP is not meant to be a reliable protocol.\n   Subsequent messages received\
    \ for encapsulation may cause the\n   encapsulator to generate ICMP Destination\
    \ Unreachable messages back\n   to the original source if the encapsulator can\
    \ no longer send\n   messages to the destination decapsulator.  This requires\
    \ that ICMP\n   messages inside the encapsulation domain affect the mapping from\
    \ the\n   Flow ID.  ICMP messages in the second category are: Parameter\n   Problem,\
    \ Redirect, Destination Unreachable, Time Exceeded.\n   Finally there is one ICMP\
    \ message which has direct bearing on the\n   operation of the original source\
    \ of datagrams destined for\n   encapsulation, the ICMP Source Quench message.\
    \  The only possible\n   mechanism available to the Encapsulator to handle this\
    \ message is for\n   the source quench message set a flag for the offending Flow\
    \ ID such\n   that subsequent messages that map the Flow cause the generation\
    \ of a\n   source quench back to the original source before the datagram is\n\
    \   encapsulated.\n   This last mechanism may be a solution for the more general\
    \ problem.\n   The rule of thumb could be that when an ICMP message is received\
    \ for\n   a given flow, then flag the Flow so that then next message\n   encapsulated\
    \ will cause the next message encapsulated on that flow to\n   force an ICMP message\
    \ to the source.  After the ICMP message is sent\n   to the source, the mechanism\
    \ could be reset.  This would effectively\n   cause every other packet to receive\
    \ an ICMP message if there were a\n   persistent problem.  This mechanism is probably\
    \ only safe for\n   Unreachable messages and Source Quench.\n"
- title: C. Reception of Clear Datagrams
  contents:
  - "C. Reception of Clear Datagrams\n   In order to use the encapsulation protocol\
    \ a modification is required\n   to IP forwarding.  There must be some way for\
    \ the IP module in a\n   system to pass Clear Datagrams to the encapsulation protocol.\
    \  A\n   suggested means of doing this is to make an addition to a system's\n\
    \   routing table structures.  A flag could be added to a route that\n   tells\
    \ the forwarding function to use encapsulation.  Note that the\n   default route\
    \ could also be set to use encapsulation.\n   With this mechanism in place, a\
    \ system's IP forwarding mechanism\n   would examine its routing tables to try\
    \ and match the IP destination\n   to a specific route.  If a route was found,\
    \ it would be then checked\n   to see if encapsulation should be used.  If not\
    \ the packet would be\n   handled normally.  If encapsulation was turned on for\
    \ the route, then\n   the datagram would be sent to encapsulation for forwarding.\n\
    \   In addition  to snagging packets as they are forwarded, something\n   must\
    \ be  done at  the last  Decapsulator on  a given flow so that\n   packets that\
    \  are decapsulated  are properly  dumped into  the IP\n   module for  delivery.\
    \   Because the packets are encapsulated just\n   before forwarding,  it should\
    \ be a simple matter for decapsulated\n   datagrams to be injected into the output\
    \ portion of IP.  However, the\n   source  address in  the Clear  Header must\
    \  not change.   The address\n   must  remain the address of the source in the\
    \ source User Space and\n   not be overwritten with that of the Decapsulator.\n"
- title: D. Construction of Virtual Networks with Encapsulation
  contents:
  - "D. Construction of Virtual Networks with Encapsulation\n   Because of the modification\
    \ to the routing table to permit\n   encapsulation, it becomes possible to specify\
    \ a virtual interface\n   whose sole purpose is encapsulation.  Using this mechanism,\
    \ it would\n   become possible to link topologically distant entities with Flows.\n\
    \   This would allow the construction of a Virtual Network which would\n   overlay\
    \ the actual routing topology.  An example of such a virtual\n   network is shown\
    \ in Fig. 4.\n                                      ++++++  Virtual Network A\n\
    \                                      ******  Virtual Network B\n           \
    \                                #  Encapsulator/Decapsulator\n              \
    \                        ------  Common Routing Space\n           ------------\
    \                     ------------\n          /            \\                \
    \   /            \\\n         /      +++ #   \\                 /            \
    \  \\\n        |  # +++    +    |               |    # ***** #   |\n        |\
    \  +        +    |               |    *       *   |\n        |  +       +    \
    \ |               |     *     *    |\n        |   +      +     |             \
    \  |      *   *     |\n        |   # ++++ # +   |               |       * *  \
    \    |\n         \\            + /  -------------  \\       # **   /  ---------\n\
    \          \\           + # ++            \\ # ******   *** # **        \\\n \
    \          ------------  /  +++          *  ------------  /  ***      \\\n   \
    \                     |      #        * |              |      # *** #|\n     \
    \                   |      +      **  |              |      *     *|\n       \
    \                 |      +     #    |              |     *    ** |\n         \
    \               |      + ++++ *   |              |    *    *   |\n           \
    \             |       #+     *  |              |   *    *    |\n           ------------\
    \  \\  ++++        */  ------------  \\ *    #     /\n          /            \\\
    \ # +             # **           * # *****     /\n         /              +  -------------\
    \  /  # ****** # *\\   --------\n        |   # +++++++   +|               |  \
    \ *        *   |\n        |   +        + + |               |   *         *  |\n\
    \        |    +         # |               |   *          * |\n        |    + \
    \      ++  |               |   *          # |\n        |    # ++++++    |    \
    \           |   * *********  |\n         \\              /                 \\\
    \   #          /\n          \\            /                   \\            /\n\
    \           ------------                     ------------\n                  \
    \     Fig. 4.  Virtual Networks Example\n   Each Encapsulator shown has an virtual\
    \ interface on one of the\n   virtual networks.  The lines represent individual\
    \ links in the flows\n   that connect each member of the virtual network.  Note\
    \ that new links\n   could be added between any points as long as the two entities\
    \ are\n   visible to each other in a common Encapsulation Space.  The routing\n\
    \   within the virtual network would be handled by the encapsulation\n   mechanism.\
    \  The programming of the routing tables could be a variant\n   of any of the\
    \ currently existing routing protocols, an encapsulated\n   OSPF for example.\n\
    \   With this in mind, it would be possible to have special encapsulation\n  \
    \ gateways with virtual interfaces on two virtual networks to form an\n   entire\
    \ virtual internet.  This is the role of the Encapsulators\n   joining Virtual\
    \ Network A and Virtual Network B.\n"
- title: E. Encapsulation and OSI
  contents:
  - "E. Encapsulation and OSI\n   It is intended that the encapsulation mechanism\
    \ described in the memo\n   be extensible to other environments outside of the\
    \ Internet.  It\n   should be possible to encapsulate many different protocols\
    \ within IP\n   and IP within many other protocols.\n   The key concepts defined\
    \ in this memo are the mapping of a header to\n   a Flow ID and the mapping of\
    \ fields in the original header to the\n   encapsulating header.  Special mappings\
    \ between protocols would have\n   to be defined, i.e. for the QoS bits, and some\
    \ sort of translation of\n   meanings carefully crafted, but it would be possible,\
    \ none the less.\n"
- title: F. Security Considerations
  contents:
  - "F. Security Considerations\n   No means of authentication or integrity checking\
    \ is specifically\n   defined for this protocol apart from the checksum for the\
    \ header\n   information.  However for authentication or integrity checking to\
    \ be\n   used with this protocol, it is suggested that the authentication\n  \
    \ information be appended to the Encapsulated Datagram.  Information\n   regarding\
    \ the type of authentication or integrity check in use would\n   have to be included\
    \ in the flow management protocol which is used to\n   distribute the flow information.\n"
- title: G. Authors' Addresses
  contents:
  - "G. Authors' Addresses\n   Robert A. Woodburn\n   SAIC\n   8619 Westwood Center\
    \ Drive\n   Vienna, VA  22182\n   Phone:  (703) 734-9000 or (703) 448-0210\n \
    \  EMail:  woody@cseic.saic.com\n   David L. Mills\n   Electrical Engineering\
    \ Department\n   University of Delaware\n   Newark, DE  19716\n   Phone:  (302)\
    \ 451-8247\n   EMail:  mills@udel.edu\n"
