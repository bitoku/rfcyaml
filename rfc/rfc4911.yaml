- title: __initial_text__
  contents:
  - "                     Encoding Instructions for the\n                    Robust\
    \ XML Encoding Rules (RXER)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines encoding instructions that may be used in\
    \ an\n   Abstract Syntax Notation One (ASN.1) specification to alter how ASN.1\n\
    \   values are encoded by the Robust XML Encoding Rules (RXER) and\n   Canonical\
    \ Robust XML Encoding Rules (CRXER), for example, to encode a\n   component of\
    \ an ASN.1 value as an Extensible Markup Language (XML)\n   attribute rather than\
    \ as a child element.  Some of these encoding\n   instructions also affect how\
    \ an ASN.1 specification is translated\n   into an Abstract Syntax Notation X\
    \ (ASN.X) specification.  Encoding\n   instructions that allow an ASN.1 specification\
    \ to reference\n   definitions in other XML schema languages are also defined.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Conventions .....................................................3\n  \
    \ 3. Definitions .....................................................4\n   4.\
    \ Notation for RXER Encoding Instructions .........................4\n   5. Component\
    \ Encoding Instructions .................................6\n   6. Reference Encoding\
    \ Instructions .................................8\n   7. Expanded Names of Components\
    \ ...................................10\n   8. The ATTRIBUTE Encoding Instruction\
    \ .............................11\n   9. The ATTRIBUTE-REF Encoding Instruction\
    \ .........................12\n   10. The COMPONENT-REF Encoding Instruction ........................13\n\
    \   11. The ELEMENT-REF Encoding Instruction ..........................16\n  \
    \ 12. The LIST Encoding Instruction .................................17\n   13.\
    \ The NAME Encoding Instruction .................................19\n   14. The\
    \ REF-AS-ELEMENT Encoding Instruction .......................19\n   15. The REF-AS-TYPE\
    \ Encoding Instruction ..........................20\n   16. The SCHEMA-IDENTITY\
    \ Encoding Instruction ......................22\n   17. The SIMPLE-CONTENT Encoding\
    \ Instruction .......................22\n   18. The TARGET-NAMESPACE Encoding\
    \ Instruction .....................23\n   19. The TYPE-AS-VERSION Encoding Instruction\
    \ ......................24\n   20. The TYPE-REF Encoding Instruction .............................25\n\
    \   21. The UNION Encoding Instruction ................................26\n  \
    \ 22. The VALUES Encoding Instruction ...............................27\n   23.\
    \ Insertion Encoding Instructions ...............................29\n   24. The\
    \ VERSION-INDICATOR Encoding Instruction ....................32\n   25. The GROUP\
    \ Encoding Instruction ................................34\n      25.1. Unambiguous\
    \ Encodings ....................................36\n           25.1.1. Grammar\
    \ Construction ..............................37\n           25.1.2. Unique Component\
    \ Attribution ......................47\n           25.1.3. Deterministic Grammars\
    \ ............................52\n           25.1.4. Attributes in Unknown Extensions\
    \ ..................54\n   26. Security Considerations .......................................56\n\
    \   27. References ....................................................56\n  \
    \    27.1. Normative References .....................................56\n    \
    \  27.2. Informative References ...................................57\n   Appendix\
    \ A. GROUP Encoding Instruction Examples ...................58\n   Appendix B.\
    \ Insertion Encoding Instruction Examples ...............74\n   Appendix C. Extension\
    \ and Versioning Examples .....................87\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines encoding instructions [X.680-1] that\
    \ may be\n   used in an Abstract Syntax Notation One (ASN.1) [X.680] specification\n\
    \   to alter how ASN.1 values are encoded by the Robust XML Encoding\n   Rules\
    \ (RXER) [RXER] and Canonical Robust XML Encoding Rules (CRXER)\n   [RXER], for\
    \ example, to encode a component of an ASN.1 value as an\n   Extensible Markup\
    \ Language (XML) [XML10] attribute rather than as a\n   child element.  Some of\
    \ these encoding instructions also affect how\n   an ASN.1 specification is translated\
    \ into an Abstract Syntax Notation\n   X (ASN.X) specification [ASN.X].\n   This\
    \ document also defines encoding instructions that allow an ASN.1\n   specification\
    \ to incorporate the definitions of types, elements, and\n   attributes in specifications\
    \ written in other XML schema languages.\n   References to XML Schema [XSD1] types,\
    \ elements, and attributes,\n   RELAX NG [RNG] named patterns and elements, and\
    \ XML document type\n   definition (DTD) [XML10] element types are supported.\n\
    \   In most cases, the effect of an encoding instruction is only briefly\n   mentioned\
    \ in this document.  The precise effects of these encoding\n   instructions are\
    \ described fully in the specifications for RXER\n   [RXER] and ASN.X [ASN.X],\
    \ at the points where they apply.\n"
- title: 2.  Conventions
  contents:
  - "2.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\" and \"MAY\" in\
    \ this document are\n   to be interpreted as described in BCP 14, RFC 2119 [BCP14].\
    \  The key\n   word \"OPTIONAL\" is exclusively used with its ASN.1 meaning.\n\
    \   Throughout this document \"type\" shall be taken to mean an ASN.1 type,\n\
    \   and \"value\" shall be taken to mean an ASN.1 abstract value, unless\n   qualified\
    \ otherwise.\n   A reference to an ASN.1 production [X.680] (e.g., Type, NamedType)\
    \ is\n   a reference to text in an ASN.1 specification corresponding to that\n\
    \   production.  Throughout this document, \"component\" is synonymous with\n\
    \   NamedType.\n   This document uses the namespace prefix \"xsi:\" to stand for\
    \ the\n   namespace name [XMLNS10] \"http://www.w3.org/2001/XMLSchema-instance\"\
    .\n   Example ASN.1 definitions in this document are assumed to be defined\n \
    \  in an ASN.1 module with a TagDefault of \"AUTOMATIC TAGS\" and an\n   EncodingReferenceDefault\
    \ [X.680-1] of \"RXER INSTRUCTIONS\".\n"
- title: 3.  Definitions
  contents:
  - "3.  Definitions\n   The following definition of base type is used in specifying\
    \ a number\n   of encoding instructions.\n   Definition (base type): If a type,\
    \ T, is a constrained type, then the\n   base type of T is the base type of the\
    \ type that is constrained; else\n   if T is a prefixed type, then the base type\
    \ of T is the base type of\n   the type that is prefixed; else if T is a type\
    \ notation that\n   references or denotes another type (i.e., DefinedType,\n \
    \  ObjectClassFieldType, SelectionType, TypeFromObject, or\n   ValueSetFromObjects),\
    \ then the base type of T is the base type of the\n   type that is referenced\
    \ or denoted; otherwise, the base type of T is\n   T itself.\n      Aside: A tagged\
    \ type is a special case of a prefixed type.\n"
- title: 4.  Notation for RXER Encoding Instructions
  contents:
  - "4.  Notation for RXER Encoding Instructions\n   The grammar of ASN.1 permits\
    \ the application of encoding instructions\n   [X.680-1], through type prefixes\
    \ and encoding control sections, that\n   modify how abstract values are encoded\
    \ by nominated encoding rules.\n   The generic notation for type prefixes and\
    \ encoding control sections\n   is defined by the ASN.1 basic notation [X.680]\
    \ [X.680-1], and\n   includes an encoding reference to identify the specific encoding\n\
    \   rules that are affected by the encoding instruction.\n   The encoding reference\
    \ that identifies the Robust XML Encoding rules\n   is literally RXER.  An RXER\
    \ encoding instruction applies equally to\n   both RXER and CRXER encodings.\n\
    \   The specific notation for an encoding instruction for a specific set\n   of\
    \ encoding rules is left to the specification of those encoding\n   rules.  Consequently,\
    \ this companion document to the RXER\n   specification [RXER] defines the notation\
    \ for RXER encoding\n   instructions.  Specifically, it elaborates the EncodingInstruction\n\
    \   and EncodingInstructionAssignmentList placeholder productions of the\n   ASN.1\
    \ basic notation.\n   In the context of the RXER encoding reference, the\n   EncodingInstruction\
    \ production is defined as follows, using the\n   conventions of the ASN.1 basic\
    \ notation:\n      EncodingInstruction ::=\n          AttributeInstruction |\n\
    \          AttributeRefInstruction |\n          ComponentRefInstruction |\n  \
    \        ElementRefInstruction |\n          GroupInstruction |\n          InsertionsInstruction\
    \ |\n          ListInstruction |\n          NameInstruction |\n          RefAsElementInstruction\
    \ |\n          RefAsTypeInstruction |\n          SimpleContentInstruction |\n\
    \          TypeAsVersionInstruction |\n          TypeRefInstruction |\n      \
    \    UnionInstruction |\n          ValuesInstruction |\n          VersionIndicatorInstruction\n\
    \   In the context of the RXER encoding reference, the\n   EncodingInstructionAssignmentList\
    \ production (which only appears in\n   an encoding control section) is defined\
    \ as follows:\n      EncodingInstructionAssignmentList ::=\n          SchemaIdentityInstruction\
    \ ?\n          TargetNamespaceInstruction ?\n          TopLevelComponents ?\n\
    \      TopLevelComponents ::= TopLevelComponent TopLevelComponents ?\n      TopLevelComponent\
    \ ::= \"COMPONENT\" NamedType\n   Definition (top-level NamedType): A NamedType\
    \ is a top-level\n   NamedType (equivalently, a top-level component) if and only\
    \ if it is\n   the NamedType in a TopLevelComponent.  A NamedType nested within\
    \ the\n   Type of the NamedType of a TopLevelComponent is not itself a\n   top-level\
    \ NamedType.\n      Aside: Specification writers should note that non-trivial\
    \ types\n      defined within a top-level NamedType will not be visible to ASN.1\n\
    \      tools that do not understand RXER.\n   Although a top-level NamedType only\
    \ appears in an RXER encoding\n   control section, the default encoding reference\
    \ for the module\n   [X.680-1] still applies when parsing a top-level NamedType.\n\
    \   Each top-level NamedType within a module SHALL have a distinct\n   identifier.\n\
    \   The NamedType production is defined by the ASN.1 basic notation.  The\n  \
    \ other productions are described in subsequent sections and make use\n   of the\
    \ following productions:\n      NCNameValue ::= Value\n      AnyURIValue ::= Value\n\
    \      QNameValue ::= Value\n      NameValue ::= Value\n   The Value production\
    \ is defined by the ASN.1 basic notation.\n   The governing type for the Value\
    \ in an NCNameValue is the NCName type\n   from the AdditionalBasicDefinitions\
    \ module [RXER].\n   The governing type for the Value in an AnyURIValue is the\
    \ AnyURI type\n   from the AdditionalBasicDefinitions module.\n   The governing\
    \ type for the Value in a QNameValue is the QName type\n   from the AdditionalBasicDefinitions\
    \ module.\n   The governing type for the Value in a NameValue is the Name type\
    \ from\n   the AdditionalBasicDefinitions module.\n   The Value in an NCNameValue,\
    \ AnyURIValue, QNameValue, or NameValue\n   SHALL NOT be a DummyReference [X.683]\
    \ and SHALL NOT textually contain\n   a nested DummyReference.\n      Aside: Thus,\
    \ encoding instructions are not permitted to be\n      parameterized in any way.\
    \  This restriction will become important\n      if a future specification for\
    \ ASN.X explicitly represents\n      parameterized definitions and parameterized\
    \ references instead of\n      expanding out parameterized references as in the\
    \ current\n      specification.  A parameterized definition could not be directly\n\
    \      translated into ASN.X if it contained encoding instructions that\n    \
    \  were not fully specified.\n"
- title: 5.  Component Encoding Instructions
  contents:
  - "5.  Component Encoding Instructions\n   Certain of the RXER encoding instructions\
    \ are categorized as\n   component encoding instructions.  The component encoding\
    \ instructions\n   are the ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF,\n\
    \   NAME, REF-AS-ELEMENT, SIMPLE-CONTENT, TYPE-AS-VERSION, and\n   VERSION-INDICATOR\
    \ encoding instructions (whose notations are\n   described respectively by AttributeInstruction,\n\
    \   AttributeRefInstruction, ComponentRefInstruction, GroupInstruction,\n   ElementRefInstruction,\
    \ NameInstruction, RefAsElementInstruction,\n   SimpleContentInstruction, TypeAsVersionInstruction,\
    \ and\n   VersionIndicatorInstruction).\n   The Type in the EncodingPrefixedType\
    \ for a component encoding\n   instruction SHALL be either:\n   (1) the Type in\
    \ a NamedType, or\n   (2) the Type in an EncodingPrefixedType in a PrefixedType\
    \ in a\n       BuiltinType in a Type that is one of (1) to (4), or\n   (3) the\
    \ Type in an TaggedType in a PrefixedType in a BuiltinType in a\n       Type that\
    \ is one of (1) to (4), or\n   (4) the Type in a ConstrainedType (excluding a\
    \ TypeWithConstraint) in\n       a Type that is one of (1) to (4).\n      Aside:\
    \ The effect of this condition is to force the component\n      encoding instructions\
    \ to be textually within the NamedType to\n      which they apply.  Only case\
    \ (2) can be true on the first\n      iteration as the Type belongs to an EncodingPrefixedType;\
    \ however,\n      any of (1) to (4) can be true on subsequent iterations.\n  \
    \ Case (4) is not permitted when the encoding instruction is the\n   ATTRIBUTE-REF,\
    \ COMPONENT-REF, ELEMENT-REF, or REF-AS-ELEMENT encoding\n   instruction.\n  \
    \ The NamedType in case (1) is said to be \"subject to\" the component\n   encoding\
    \ instruction.\n   A top-level NamedType SHALL NOT be subject to an ATTRIBUTE-REF,\n\
    \   COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, or SIMPLE-CONTENT\n   encoding\
    \ instruction.\n      Aside: This condition does not preclude these encoding\n\
    \      instructions being used on a nested NamedType.\n   A NamedType SHALL NOT\
    \ be subject to two or more component encoding\n   instructions of the same kind,\
    \ e.g., a NamedType is not permitted to\n   be subject to two NAME encoding instructions.\n\
    \   The ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF,\n   REF-AS-ELEMENT,\
    \ SIMPLE-CONTENT, and TYPE-AS-VERSION encoding\n   instructions are mutually exclusive.\
    \  The NAME, ATTRIBUTE-REF,\n   COMPONENT-REF, ELEMENT-REF, and REF-AS-ELEMENT\
    \ encoding instructions\n   are mutually exclusive.  A NamedType SHALL NOT be\
    \ subject to two or\n   more encoding instructions that are mutually exclusive.\n\
    \   A SelectionType [X.680] SHALL NOT be used to select the Type from a\n   NamedType\
    \ that is subject to an ATTRIBUTE-REF, COMPONENT-REF,\n   ELEMENT-REF or REF-AS-ELEMENT\
    \ encoding instruction.  The other\n   component encoding instructions are not\
    \ inherited by the type denoted\n   by a SelectionType.\n   Definition (attribute\
    \ component):  An attribute component is a\n   NamedType that is subject to an\
    \ ATTRIBUTE or ATTRIBUTE-REF encoding\n   instruction, or subject to a COMPONENT-REF\
    \ encoding instruction that\n   references a top-level NamedType that is subject\
    \ to an ATTRIBUTE\n   encoding instruction.\n   Definition (element component):\
    \  An element component is a NamedType\n   that is not subject to an ATTRIBUTE,\
    \ ATTRIBUTE-REF, GROUP, or\n   SIMPLE-CONTENT encoding instruction, and not subject\
    \ to a\n   COMPONENT-REF encoding instruction that references a top-level\n  \
    \ NamedType that is subject to an ATTRIBUTE encoding instruction.\n      Aside:\
    \ A NamedType subject to a GROUP or SIMPLE-CONTENT encoding\n      instruction\
    \ is neither an attribute component nor an element\n      component.\n"
- title: 6.  Reference Encoding Instructions
  contents:
  - "6.  Reference Encoding Instructions\n   Certain of the RXER encoding instructions\
    \ are categorized as\n   reference encoding instructions.  The reference encoding\
    \ instructions\n   are the ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, REF-AS-ELEMENT,\n\
    \   REF-AS-TYPE, and TYPE-REF encoding instructions (whose notations are\n   described\
    \ respectively by AttributeRefInstruction,\n   ComponentRefInstruction, ElementRefInstruction,\n\
    \   RefAsElementInstruction, RefAsTypeInstruction, and\n   TypeRefInstruction).\
    \  These encoding instructions (except\n   COMPONENT-REF) allow an ASN.1 specification\
    \ to incorporate the\n   definitions of types, elements, and attributes in specifications\n\
    \   written in other XML schema languages, through implied constraints on\n  \
    \ the markup that may appear in values of the Markup ASN.1 type from\n   the AdditionalBasicDefinitions\
    \ module [RXER] (for ELEMENT-REF,\n   REF-AS-ELEMENT, REF-AS-TYPE, and TYPE-REF)\
    \ or the UTF8String type\n   (for ATTRIBUTE-REF).  References to XML Schema [XSD1]\
    \ types,\n   elements, and attributes, RELAX NG [RNG] named patterns and elements,\n\
    \   and XML document type definition (DTD) [XML10] element types are\n   supported.\
    \  References to ASN.1 types and top-level components are\n   also permitted.\
    \  The COMPONENT-REF encoding instruction provides a\n   more direct method of\
    \ referencing a top-level component.\n   The Type in the EncodingPrefixedType\
    \ for an ELEMENT-REF,\n   REF-AS-ELEMENT, REF-AS-TYPE, or TYPE-REF encoding instruction\
    \ SHALL\n   be either:\n   (1) a ReferencedType that is a DefinedType that is\
    \ a typereference\n       (not a DummyReference) or ExternalTypeReference that\
    \ references\n       the Markup ASN.1 type from the AdditionalBasicDefinitions\
    \ module\n       [RXER], or\n   (2) a BuiltinType that is a PrefixedType that\
    \ is a TaggedType where\n       the Type in the TaggedType is one of (1) to (3),\
    \ or\n   (3) a BuiltinType that is a PrefixedType that is an\n       EncodingPrefixedType\
    \ where the Type in the EncodingPrefixedType\n       is one of (1) to (3) and\
    \ the EncodingPrefix in the\n       EncodingPrefixedType does not contain a reference\
    \ encoding\n       instruction.\n      Aside: Case (3) and similar cases for the\
    \ ATTRIBUTE-REF and\n      COMPONENT-REF encoding instructions have the effect\
    \ of making the\n      reference encoding instructions mutually exclusive as well\
    \ as\n      singly occurring.\n   With respect to the REF-AS-TYPE and TYPE-REF\
    \ encoding instructions,\n   the DefinedType in case (1) is said to be \"subject\
    \ to\" the encoding\n   instruction.\n   The restrictions on the Type in the EncodingPrefixedType\
    \ for an\n   ATTRIBUTE-REF encoding instruction are specified in Section 9.  The\n\
    \   restrictions on the Type in the EncodingPrefixedType for a\n   COMPONENT-REF\
    \ encoding instruction are specified in Section 10.\n   The reference encoding\
    \ instructions make use of a common production\n   defined as follows:\n     \
    \ RefParameters ::= ContextParameter ?\n      ContextParameter ::= \"CONTEXT\"\
    \ AnyURIValue\n   A RefParameters instance provides extra information about a\
    \ reference\n   to a definition.  A ContextParameter is used when a reference\
    \ is\n   ambiguous, i.e., refers to definitions in more than one schema\n   document\
    \ or external DTD subset.  This situation would occur, for\n   example, when importing\
    \ types with the same name from independently\n   developed XML Schemas defined\
    \ without a target namespace [XSD1].\n   When used in conjunction with a reference\
    \ to an element type in an\n   external DTD subset, the AnyURIValue in the ContextParameter\
    \ is the\n   system identifier (a Uniform Resource Identifier or URI [URI]) of\
    \ the\n   external DTD subset; otherwise, the AnyURIValue is a URI that\n   indicates\
    \ the intended schema document, either an XML Schema\n   specification, a RELAX\
    \ NG specification, or an ASN.1 or ASN.X\n   specification.\n"
- title: 7.  Expanded Names of Components
  contents:
  - "7.  Expanded Names of Components\n   Each NamedType has an associated expanded\
    \ name [XMLNS10], determined\n   as follows:\n   (1) if the NamedType is subject\
    \ to a NAME encoding instruction, then\n       the local name of the expanded\
    \ name is the character string\n       specified by the NCNameValue of the NAME\
    \ encoding instruction,\n   (2) else if the NamedType is subject to a COMPONENT-REF\
    \ encoding\n       instruction, then the expanded name is the same as the expanded\n\
    \       name of the referenced top-level NamedType,\n   (3) else if the NamedType\
    \ is subject to an ATTRIBUTE-REF or\n       ELEMENT-REF encoding instruction,\
    \ then the namespace name of the\n       expanded name is equal to the namespace-name\
    \ component of the\n       QNameValue of the encoding instruction, and the local\
    \ name is\n       equal to the local-name component of the QNameValue,\n   (4)\
    \ else if the NamedType is subject to a REF-AS-ELEMENT encoding\n       instruction,\
    \ then the local name of the expanded name is the\n       LocalPart [XMLNS10]\
    \ of the qualified name specified by the\n       NameValue of the encoding instruction,\n\
    \   (5) otherwise, the local name of the expanded name is the identifier\n   \
    \    of the NamedType.\n   In cases (1) and (5), if the NamedType is a top-level\
    \ NamedType and\n   the module containing the NamedType has a TARGET-NAMESPACE\
    \ encoding\n   instruction, then the namespace name of the expanded name is the\n\
    \   character string specified by the AnyURIValue of the TARGET-NAMESPACE\n  \
    \ encoding instruction; otherwise, the namespace name has no value.\n      Aside:\
    \ Thus, the TARGET-NAMESPACE encoding instruction applies to\n      a top-level\
    \ NamedType but not to any other NamedType.\n   In case (4), if the encoding instruction\
    \ contains a Namespace, then\n   the namespace name of the expanded name is the\
    \ character string\n   specified by the AnyURIValue of the Namespace; otherwise,\
    \ the\n   namespace name has no value.\n   The expanded names for the attribute\
    \ components of a CHOICE,\n   SEQUENCE, or SET type MUST be distinct.  The expanded\
    \ names for the\n   components of a CHOICE, SEQUENCE, or SET type that are not\
    \ attribute\n   components MUST be distinct.  These tests are applied after the\n\
    \   COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].\n  \
    \    Aside: Two components of the same CHOICE, SEQUENCE, or SET type\n      may\
    \ have the same expanded name if one of them is an attribute\n      component\
    \ and the other is not.  Note that the \"not\" case includes\n      components\
    \ that are subject to a GROUP or SIMPLE-CONTENT encoding\n      instruction.\n\
    \   The expanded name of a top-level NamedType subject to an ATTRIBUTE\n   encoding\
    \ instruction MUST be distinct from the expanded name of every\n   other top-level\
    \ NamedType subject to an ATTRIBUTE encoding\n   instruction in the same module.\n\
    \   The expanded name of a top-level NamedType not subject to an\n   ATTRIBUTE\
    \ encoding instruction MUST be distinct from the expanded\n   name of every other\
    \ top-level NamedType not subject to an ATTRIBUTE\n   encoding instruction in\
    \ the same module.\n      Aside: Two top-level components may have the same expanded\
    \ name if\n      one of them is an attribute component and the other is not.\n"
- title: 8.  The ATTRIBUTE Encoding Instruction
  contents:
  - "8.  The ATTRIBUTE Encoding Instruction\n   The ATTRIBUTE encoding instruction\
    \ causes an RXER encoder to encode a\n   value of the component to which it is\
    \ applied as an XML attribute\n   instead of as a child element.\n   The notation\
    \ for an ATTRIBUTE encoding instruction is defined as\n   follows:\n      AttributeInstruction\
    \ ::= \"ATTRIBUTE\"\n   The base type of the type of a NamedType that is subject\
    \ to an\n   ATTRIBUTE encoding instruction SHALL NOT be:\n   (1) a CHOICE, SET,\
    \ or SET OF type, or\n   (2) a SEQUENCE type other than the one defining the QName\
    \ type from\n       the AdditionalBasicDefinitions module [RXER] (i.e., QName\
    \ is\n       allowed), or\n   (3) a SEQUENCE OF type where the SequenceOfType\
    \ is not subject to a\n       LIST encoding instruction, or\n   (4) an open type.\n\
    \   Example\n      PersonalDetails ::= SEQUENCE {\n          firstName   [ATTRIBUTE]\
    \ UTF8String,\n          middleName  [ATTRIBUTE] UTF8String,\n          surname\
    \     [ATTRIBUTE] UTF8String\n      }\n"
- title: 9.  The ATTRIBUTE-REF Encoding Instruction
  contents:
  - "9.  The ATTRIBUTE-REF Encoding Instruction\n   The ATTRIBUTE-REF encoding instruction\
    \ causes an RXER encoder to\n   encode a value of the component to which it is\
    \ applied as an XML\n   attribute instead of as a child element, where the attribute's\
    \ name\n   is a qualified name of the attribute declaration referenced by the\n\
    \   encoding instruction.  In addition, the ATTRIBUTE-REF encoding\n   instruction\
    \ causes values of the UTF8String type to be restricted to\n   conform to the\
    \ type of the attribute declaration.\n   The notation for an ATTRIBUTE-REF encoding\
    \ instruction is defined as\n   follows:\n      AttributeRefInstruction ::=\n\
    \          \"ATTRIBUTE-REF\" QNameValue RefParameters\n   Taken together, the\
    \ QNameValue and the ContextParameter in the\n   RefParameters (if present) MUST\
    \ reference an XML Schema attribute\n   declaration or a top-level NamedType that\
    \ is subject to an ATTRIBUTE\n   encoding instruction.\n   The type of a referenced\
    \ XML Schema attribute declaration SHALL NOT\n   be, either directly or by derivation,\
    \ the XML Schema type QName,\n   NOTATION, ENTITY, ENTITIES, or anySimpleType.\n\
    \      Aside: Values of these types require information from the context\n   \
    \   of the attribute for interpretation.  Because an ATTRIBUTE-REF\n      encoding\
    \ instruction is restricted to prefixing the ASN.1\n      UTF8String type, there\
    \ is no mechanism to capture such context.\n   The type of a referenced top-level\
    \ NamedType SHALL NOT be, either\n   directly or by subtyping, the QName type\
    \ from the\n   AdditionalBasicDefinitions module [RXER].\n   The Type in the EncodingPrefixedType\
    \ for an ATTRIBUTE-REF encoding\n   instruction SHALL be either:\n   (1) the UTF8String\
    \ type, or\n   (2) a BuiltinType that is a PrefixedType that is a TaggedType where\n\
    \       the Type in the TaggedType is one of (1) to (3), or\n   (3) a BuiltinType\
    \ that is a PrefixedType that is an\n       EncodingPrefixedType where the Type\
    \ in the EncodingPrefixedType\n       is one of (1) to (3) and the EncodingPrefix\
    \ in the\n       EncodingPrefixedType does not contain a reference encoding\n\
    \       instruction.\n   The identifier of a NamedType subject to an ATTRIBUTE-REF\
    \ encoding\n   instruction does not contribute to the name of attributes in an\
    \ RXER\n   encoding.  For the sake of consistency, the identifier SHOULD, where\n\
    \   possible, be the same as the local name of the referenced attribute\n   declaration.\n"
- title: 10.  The COMPONENT-REF Encoding Instruction
  contents:
  - "10.  The COMPONENT-REF Encoding Instruction\n   The ASN.1 basic notation does\
    \ not have a concept of a top-level\n   NamedType and therefore does not have\
    \ a mechanism to reference a\n   top-level NamedType.  The COMPONENT-REF encoding\
    \ instruction provides\n   a way to specify that a NamedType within a combining\
    \ type definition\n   is equivalent to a referenced top-level NamedType.\n   The\
    \ notation for a COMPONENT-REF encoding instruction is defined as\n   follows:\n\
    \      ComponentRefInstruction ::= \"COMPONENT-REF\" ComponentReference\n    \
    \  ComponentReference ::=\n          InternalComponentReference |\n          ExternalComponentReference\n\
    \      InternalComponentReference ::= identifier FromModule ?\n      FromModule\
    \ ::= \"FROM\" GlobalModuleReference\n      ExternalComponentReference ::= modulereference\
    \ \".\" identifier\n   The GlobalModuleReference production is defined by the\
    \ ASN.1 basic\n   notation [X.680].  If the GlobalModuleReference is absent from\
    \ an\n   InternalComponentReference, then the identifier MUST be the\n   identifier\
    \ of a top-level NamedType in the same module.  If the\n   GlobalModuleReference\
    \ is present in an InternalComponentReference,\n   then the identifier MUST be\
    \ the identifier of a top-level NamedType\n   in the referenced module.\n   The\
    \ modulereference in an ExternalComponentReference is used in the\n   same way\
    \ as a modulereference in an ExternalTypeReference.  The\n   identifier in an\
    \ ExternalComponentReference MUST be the identifier of\n   a top-level NamedType\
    \ in the referenced module.\n   The Type in the EncodingPrefixedType for a COMPONENT-REF\
    \ encoding\n   instruction SHALL be either:\n   (1) a ReferencedType that is a\
    \ DefinedType that is a typereference\n       (not a DummyReference) or an ExternalTypeReference,\
    \ or\n   (2) a BuiltinType or ReferencedType that is one of the productions in\n\
    \       Table 1 in Section 5 of the specification for RXER [RXER], or\n   (3)\
    \ a BuiltinType that is a PrefixedType that is a TaggedType where\n       the\
    \ Type in the TaggedType is one of (1) to (4), or\n   (4) a BuiltinType that is\
    \ a PrefixedType that is an\n       EncodingPrefixedType where the Type in the\
    \ EncodingPrefixedType\n       is one of (1) to (4) and the EncodingPrefix in\
    \ the\n       EncodingPrefixedType does not contain a reference encoding\n   \
    \    instruction.\n   The restrictions on the use of RXER encoding instructions\
    \ are such\n   that no other RXER encoding instruction is permitted within a\n\
    \   NamedType if the NamedType is subject to a COMPONENT-REF encoding\n   instruction.\n\
    \   The Type in the top-level NamedType referenced by the COMPONENT-REF\n   encoding\
    \ instruction MUST be either:\n   (a) if the preceding case (1) is used, a ReferencedType\
    \ that is a\n       DefinedType that is a typereference or ExternalTypeReference\
    \ that\n       references the same type as the DefinedType in case (1), or\n \
    \  (b) if the preceding case (2) is used, a BuiltinType or\n       ReferencedType\
    \ that is the same as the BuiltinType or\n       ReferencedType in case (2), or\n\
    \   (c) a BuiltinType that is a PrefixedType that is an\n       EncodingPrefixedType\
    \ where the Type in the EncodingPrefixedType\n       is one of (a) to (c), and\
    \ the EncodingPrefix in the\n       EncodingPrefixedType contains an RXER encoding\
    \ instruction.\n   In principle, the COMPONENT-REF encoding instruction creates\
    \ a\n   notional NamedType where the expanded name is that of the referenced\n\
    \   top-level NamedType and the Type in case (1) or (2) is substituted by\n  \
    \ the Type of the referenced top-level NamedType.\n   In practice, it is sufficient\
    \ for non-RXER encoders and decoders to\n   use the original NamedType rather\
    \ than the notional NamedType because\n   the Type in case (1) or (2) can only\
    \ differ from the Type of the\n   referenced top-level NamedType by having fewer\
    \ RXER encoding\n   instructions, and RXER encoding instructions are ignored by\
    \ non-RXER\n   encoders and decoders.\n   Although any prefixes for the Type in\
    \ case (1) or (2) would be\n   bypassed, it is sufficient for RXER encoders and\
    \ decoders to use the\n   referenced top-level NamedType instead of the notional\
    \ NamedType\n   because these prefixes cannot be RXER encoding instructions (except,\n\
    \   of course, for the COMPONENT-REF encoding instruction) and can have\n   no\
    \ effect on an RXER encoding.\n   Example\n      Modules ::= SEQUENCE OF\n   \
    \       module [COMPONENT-REF module\n                     FROM AbstractSyntaxNotation-X\n\
    \                         { 1 3 6 1 4 1 21472 1 0 1 }]\n                     ModuleDefinition\n\
    \      Note that the \"module\" top-level NamedType in the\n      AbstractSyntaxNotation-X\
    \ module is defined like so:\n         COMPONENT module ModuleDefinition\n   \
    \   The ASN.X translation of the SEQUENCE OF type definition provides\n      a\
    \ more natural representation:\n         <namedType xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\
    \n                    name=\"Modules\">\n          <sequenceOf>\n           <element\
    \ ref=\"asnx:module\"/>\n          </sequenceOf>\n         </namedType>\n    \
    \     Aside: The <namedType> element in ASN.X corresponds to a\n         TypeAssignment,\
    \ not a NamedType.\n   The identifier of a NamedType subject to a COMPONENT-REF\
    \ encoding\n   instruction does not contribute to an RXER encoding.  For the sake\
    \ of\n   consistency with other encoding rules, the identifier SHOULD be the\n\
    \   same as the identifier in the ComponentRefInstruction.\n"
- title: 11.  The ELEMENT-REF Encoding Instruction
  contents:
  - "11.  The ELEMENT-REF Encoding Instruction\n   The ELEMENT-REF encoding instruction\
    \ causes an RXER encoder to encode\n   a value of the component to which it is\
    \ applied as an element where\n   the element's name is a qualified name of the\
    \ element declaration\n   referenced by the encoding instruction.  In addition,\
    \ the ELEMENT-REF\n   encoding instruction causes values of the Markup ASN.1 type\
    \ to be\n   restricted to conform to the type of the element declaration.\n  \
    \ The notation for an ELEMENT-REF encoding instruction is defined as\n   follows:\n\
    \      ElementRefInstruction ::= \"ELEMENT-REF\" QNameValue RefParameters\n  \
    \ Taken together, the QNameValue and the ContextParameter in the\n   RefParameters\
    \ (if present) MUST reference an XML Schema element\n   declaration, a RELAX NG\
    \ element definition, or a top-level NamedType\n   that is not subject to an ATTRIBUTE\
    \ encoding instruction.\n   A referenced XML Schema element declaration MUST NOT\
    \ have a type that\n   requires the presence of values for the XML Schema ENTITY\
    \ or ENTITIES\n   types.\n      Aside: Entity declarations are not supported by\
    \ CRXER.\n   Example\n      AnySchema ::= CHOICE {\n          module   [ELEMENT-REF\
    \ {\n                       namespace-name\n                           \"urn:ietf:params:xml:ns:asnx\"\
    ,\n                       local-name \"module\" }]\n                   Markup,\n\
    \          schema   [ELEMENT-REF {\n                       namespace-name\n  \
    \                         \"http://www.w3.org/2001/XMLSchema\",\n            \
    \           local-name \"schema\" }]\n                   Markup,\n          grammar\
    \  [ELEMENT-REF {\n                       namespace-name\n                   \
    \        \"http://relaxng.org/ns/structure/1.0\",\n                       local-name\
    \ \"grammar\" }]\n                   Markup\n      }\n      The ASN.X translation\
    \ of the choice type definition provides a\n      more natural representation:\n\
    \         <namedType xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\n            \
    \        xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n                    xmlns:rng=\"\
    http://relaxng.org/ns/structure/1.0\"\n                    name=\"AnySchema\"\
    >\n          <choice>\n           <element ref=\"asnx:module\" embedded=\"true\"\
    />\n           <element ref=\"xs:schema\" embedded=\"true\"/>\n           <element\
    \ ref=\"rng:grammar\" embedded=\"true\"/>\n          </choice>\n         </namedType>\n\
    \   The identifier of a NamedType subject to an ELEMENT-REF encoding\n   instruction\
    \ does not contribute to the name of an element in an RXER\n   encoding.  For\
    \ the sake of consistency, the identifier SHOULD, where\n   possible, be the same\
    \ as the local name of the referenced element\n   declaration.\n"
- title: 12.  The LIST Encoding Instruction
  contents:
  - "12.  The LIST Encoding Instruction\n   The LIST encoding instruction causes an\
    \ RXER encoder to encode a\n   value of a SEQUENCE OF type as a white-space-separated\
    \ list of the\n   component values.\n   The notation for a LIST encoding instruction\
    \ is defined as follows:\n      ListInstruction ::= \"LIST\"\n   The Type in an\
    \ EncodingPrefixedType for a LIST encoding instruction\n   SHALL be either:\n\
    \   (1) a BuiltinType that is a SequenceOfType of the\n       \"SEQUENCE OF NamedType\"\
    \ form, or\n   (2) a ConstrainedType that is a TypeWithConstraint of the\n   \
    \    \"SEQUENCE Constraint OF NamedType\" form or\n       \"SEQUENCE SizeConstraint\
    \ OF NamedType\" form, or\n   (3) a ConstrainedType that is not a TypeWithConstraint\
    \ where the Type\n       in the ConstrainedType is one of (1) to (5), or\n   (4)\
    \ a BuiltinType that is a PrefixedType that is a TaggedType where\n       the\
    \ Type in the TaggedType is one of (1) to (5), or\n   (5) a BuiltinType that is\
    \ a PrefixedType that is an\n       EncodingPrefixedType where the Type in the\
    \ EncodingPrefixedType\n       is one of (1) to (5).\n   The effect of this condition\
    \ is to force the LIST encoding\n   instruction to be textually co-located with\
    \ the SequenceOfType or\n   TypeWithConstraint to which it applies.\n      Aside:\
    \ This makes it clear to a reader that the encoding\n      instruction applies\
    \ to every use of the type no matter how it\n      might be referenced.\n   The\
    \ SequenceOfType in case (1) and the TypeWithConstraint in case (2)\n   are said\
    \ to be \"subject to\" the LIST encoding instruction.\n   A SequenceOfType or\
    \ TypeWithConstraint SHALL NOT be subject to more\n   than one LIST encoding instruction.\n\
    \   The base type of the component type of a SequenceOfType or\n   TypeWithConstraint\
    \ that is subject to a LIST encoding instruction\n   MUST be one of the following:\n\
    \   (1) the BOOLEAN, INTEGER, ENUMERATED, REAL, OBJECT IDENTIFIER,\n       RELATIVE-OID,\
    \ GeneralizedTime, or UTCTime type, or\n   (2) the NCName, AnyURI, Name, or QName\
    \ type from the\n       AdditionalBasicDefinitions module [RXER].\n      Aside:\
    \ While it would be feasible to allow the component type to\n      also be any\
    \ character string type that is constrained such that\n      all its abstract\
    \ values have a length greater than zero and none\n      of its abstract values\
    \ contain any white space characters, testing\n      whether this condition is\
    \ satisfied can be quite involved.  For\n      the sake of simplicity, only certain\
    \ immediately useful\n      constrained UTF8String types, which are known to be\
    \ suitable, are\n      permitted (i.e., NCName, AnyURI, and Name).\n   The NamedType\
    \ in a SequenceOfType or TypeWithConstraint that is\n   subject to a LIST encoding\
    \ instruction MUST NOT be subject to an\n   ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF,\
    \ GROUP, ELEMENT-REF,\n   REF-AS-ELEMENT, SIMPLE-CONTENT, or TYPE-AS-VERSION encoding\n\
    \   instruction.\n   Example\n      UpdateTimes ::= [LIST] SEQUENCE OF updateTime\
    \ GeneralizedTime\n"
- title: 13.  The NAME Encoding Instruction
  contents:
  - "13.  The NAME Encoding Instruction\n   The NAME encoding instruction causes an\
    \ RXER encoder to use a\n   nominated character string instead of a component's\
    \ identifier\n   wherever that identifier would otherwise appear in the encoding\n\
    \   (e.g., as an element or attribute name).\n   The notation for a NAME encoding\
    \ instruction is defined as follows:\n      NameInstruction ::= \"NAME\" \"AS\"\
    ? NCNameValue\n   Example\n      CHOICE {\n          foo-att   [ATTRIBUTE] [NAME\
    \ AS \"Foo\"] INTEGER,\n          foo-elem  [NAME \"Foo\"] INTEGER\n      }\n"
- title: 14.  The REF-AS-ELEMENT Encoding Instruction
  contents:
  - "14.  The REF-AS-ELEMENT Encoding Instruction\n   The REF-AS-ELEMENT encoding\
    \ instruction causes an RXER encoder to\n   encode a value of the component to\
    \ which it is applied as an element\n   where the element's name is the name of\
    \ the external DTD subset\n   element type declaration referenced by the encoding\
    \ instruction.  In\n   addition, the REF-AS-ELEMENT encoding instruction causes\
    \ values of\n   the Markup ASN.1 type to be restricted to conform to the content\
    \ and\n   attributes permitted by that element type declaration and its\n   associated\
    \ attribute-list declarations.\n   The notation for a REF-AS-ELEMENT encoding\
    \ instruction is defined as\n   follows:\n      RefAsElementInstruction ::=\n\
    \          \"REF-AS-ELEMENT\" NameValue Namespace ? RefParameters\n      Namespace\
    \ ::= \"NAMESPACE\" AnyURIValue\n   Taken together, the NameValue and the ContextParameter\
    \ in the\n   RefParameters (if present) MUST reference an element type declaration\n\
    \   in an external DTD subset that is conformant with Namespaces in XML\n   1.0\
    \ [XMLNS10].\n   The Namespace is present if and only if the Name of the referenced\n\
    \   element type declaration conforms to a PrefixedName (a QName)\n   [XMLNS10],\
    \ in which case the Namespace specifies the namespace name\n   to be associated\
    \ with the Prefix of the PrefixedName.\n   The referenced element type declaration\
    \ MUST NOT require the presence\n   of attributes of type ENTITY or ENTITIES.\n\
    \      Aside: Entity declarations are not supported by CRXER.\n   Example\n  \
    \    Suppose that the following external DTD subset has been defined\n      with\
    \ a system identifier of \"http://www.example.com/inventory\":\n         <?xml\
    \ version='1.0'?>\n         <!ELEMENT product EMPTY>\n         <!ATTLIST product\n\
    \             name       CDATA #IMPLIED\n             partNumber CDATA #REQUIRED\n\
    \             quantity   CDATA #REQUIRED >\n      The product element type declaration\
    \ can be referenced as an\n      element in an ASN.1 type definition:\n      \
    \   CHOICE {\n             product  [REF-AS-ELEMENT \"product\"\n            \
    \              CONTEXT \"http://www.example.com/inventory\"]\n               \
    \       Markup\n         }\n      Here is the ASN.X translation of this ASN.1\
    \ type definition:\n         <type>\n          <choice>\n           <element elementType=\"\
    product\"\n                    context=\"http://www.example.com/inventory\"/>\n\
    \          </choice>\n         </type>\n   The identifier of a NamedType subject\
    \ to a REF-AS-ELEMENT encoding\n   instruction does not contribute to the name\
    \ of an element in an RXER\n   encoding.  For the sake of consistency, the identifier\
    \ SHOULD, where\n   possible, be the same as the Name of the referenced element\
    \ type\n   declaration (or the LocalPart if the Name conforms to a\n   PrefixedName).\n"
- title: 15.  The REF-AS-TYPE Encoding Instruction
  contents:
  - "15.  The REF-AS-TYPE Encoding Instruction\n   The REF-AS-TYPE encoding instruction\
    \ causes values of the Markup\n   ASN.1 type to be restricted to conform to the\
    \ content and attributes\n   permitted by a nominated element type declaration\
    \ and its associated\n   attribute-list declarations in an external DTD subset.\n\
    \   The notation for a REF-AS-TYPE encoding instruction is defined as\n   follows:\n\
    \      RefAsTypeInstruction ::= \"REF-AS-TYPE\" NameValue RefParameters\n   Taken\
    \ together, the NameValue and the ContextParameter of the\n   RefParameters (if\
    \ present) MUST reference an element type declaration\n   in an external DTD subset\
    \ that is conformant with Namespaces in XML\n   1.0 [XMLNS10].\n   The referenced\
    \ element type declaration MUST NOT require the presence\n   of attributes of\
    \ type ENTITY or ENTITIES.\n      Aside: Entity declarations are not supported\
    \ by CRXER.\n   Example\n      The product element type declaration can be referenced\
    \ as a type\n      in an ASN.1 definition:\n         SEQUENCE OF\n           \
    \  inventoryItem\n                 [REF-AS-TYPE \"product\"\n                \
    \     CONTEXT \"http://www.example.com/inventory\"]\n                 Markup\n\
    \      Here is the ASN.X translation of this definition:\n         <sequenceOf>\n\
    \          <element name=\"inventoryItem\">\n           <type elementType=\"product\"\
    \n                 context=\"http://www.example.com/inventory\"/>\n          </element>\n\
    \         </sequenceOf>\n      Note that when an element type declaration is referenced\
    \ as a\n      type, the Name of the element type declaration does not contribute\n\
    \      to RXER encodings.  For example, child elements in the RXER\n      encoding\
    \ of values of the above SEQUENCE OF type would resemble\n      the following:\n\
    \         <inventoryItem name=\"hammer\" partNumber=\"1543\" quantity=\"29\"/>\n"
- title: 16.  The SCHEMA-IDENTITY Encoding Instruction
  contents:
  - "16.  The SCHEMA-IDENTITY Encoding Instruction\n   The SCHEMA-IDENTITY encoding\
    \ instruction associates a unique\n   identifier, a URI [URI], with the ASN.1\
    \ module containing the\n   encoding instruction.  This encoding instruction has\
    \ no effect on an\n   RXER encoder but does have an effect on the translation\
    \ of an ASN.1\n   specification into an ASN.X representation.\n   The notation\
    \ for a SCHEMA-IDENTITY encoding instruction is defined as\n   follows:\n    \
    \  SchemaIdentityInstruction ::= \"SCHEMA-IDENTITY\" AnyURIValue\n   The character\
    \ string specified by the AnyURIValue of each\n   SCHEMA-IDENTITY encoding instruction\
    \ MUST be distinct.  In\n   particular, successive versions of an ASN.1 module\
    \ must each have a\n   different schema identity URI value.\n"
- title: 17.  The SIMPLE-CONTENT Encoding Instruction
  contents:
  - "17.  The SIMPLE-CONTENT Encoding Instruction\n   The SIMPLE-CONTENT encoding\
    \ instruction causes an RXER encoder to\n   encode a value of a component of a\
    \ SEQUENCE or SET type without\n   encapsulation in a child element.\n   The notation\
    \ for a SIMPLE-CONTENT encoding instruction is defined as\n   follows:\n     \
    \ SimpleContentInstruction ::= \"SIMPLE-CONTENT\"\n   A NamedType subject to a\
    \ SIMPLE-CONTENT encoding instruction SHALL be\n   in a ComponentType in a ComponentTypeList\
    \ in a RootComponentTypeList.\n   At most one such NamedType of a SEQUENCE or\
    \ SET type is permitted to\n   be subject to a SIMPLE-CONTENT encoding instruction.\
    \  If any\n   component is subject to a SIMPLE-CONTENT encoding instruction, then\n\
    \   all other components in the same SEQUENCE or SET type definition MUST\n  \
    \ be attribute components.  These tests are applied after the\n   COMPONENTS OF\
    \ transformation specified in X.680, Clause 24.4 [X.680].\n      Aside: Child\
    \ elements and simple content are mutually exclusive.\n      Specification writers\
    \ should note that use of the SIMPLE-CONTENT\n      encoding instruction on a\
    \ component of an extensible SEQUENCE or\n      SET type means that all future\
    \ extensions to the SEQUENCE or SET\n      type are restricted to being attribute\
    \ components with the limited\n      set of types that are permitted for attribute\
    \ components.  Using\n      an ATTRIBUTE encoding instruction instead of a SIMPLE-CONTENT\n\
    \      encoding instruction avoids this limitation.\n   The base type of the type\
    \ of a NamedType that is subject to a\n   SIMPLE-CONTENT encoding instruction\
    \ SHALL NOT be:\n   (1) a SET or SET OF type, or\n   (2) a CHOICE type where the\
    \ ChoiceType is not subject to a UNION\n       encoding instruction, or\n   (3)\
    \ a SEQUENCE type other than the one defining the QName type from\n       the\
    \ AdditionalBasicDefinitions module [RXER] (i.e., QName is\n       allowed), or\n\
    \   (4) a SEQUENCE OF type where the SequenceOfType is not subject to a\n    \
    \   LIST encoding instruction, or\n   (5) an open type.\n   If the type of a NamedType\
    \ subject to a SIMPLE-CONTENT encoding\n   instruction has abstract values with\
    \ an empty character data\n   translation [RXER] (i.e., an empty encoding), then\
    \ the NamedType\n   SHALL NOT be marked OPTIONAL or DEFAULT.\n   Example\n   \
    \   SEQUENCE {\n          units   [ATTRIBUTE] UTF8String,\n          amount  [SIMPLE-CONTENT]\
    \ INTEGER\n      }\n"
- title: 18.  The TARGET-NAMESPACE Encoding Instruction
  contents:
  - "18.  The TARGET-NAMESPACE Encoding Instruction\n   The TARGET-NAMESPACE encoding\
    \ instruction associates an XML namespace\n   name [XMLNS10], a URI [URI], with\
    \ the type, object class, value,\n   object, and object set references defined\
    \ in the ASN.1 module\n   containing the encoding instruction.  In addition, it\
    \ associates the\n   namespace name with each top-level NamedType in the RXER\
    \ encoding\n   control section.\n   The notation for a TARGET-NAMESPACE encoding\
    \ instruction is defined\n   as follows:\n      TargetNamespaceInstruction ::=\n\
    \          \"TARGET-NAMESPACE\" AnyURIValue Prefix ?\n      Prefix ::= \"PREFIX\"\
    \ NCNameValue\n   The AnyURIValue SHALL NOT specify an empty string.\n   Definition\
    \ (target namespace):  If an ASN.1 module contains a\n   TARGET-NAMESPACE encoding\
    \ instruction, then the target namespace of\n   the module is the character string\
    \ specified by the AnyURIValue of\n   the TARGET-NAMESPACE encoding instruction;\
    \ otherwise, the target\n   namespace of the module is said to be absent.\n  \
    \ Two or more ASN.1 modules MAY have the same non-absent target\n   namespace\
    \ if and only if the expanded names of the top-level\n   attribute components\
    \ are distinct across all those modules, the\n   expanded names of the top-level\
    \ element components are distinct\n   across all those modules, and the defined\
    \ type, object class, value,\n   object, and object set references are distinct\
    \ in their category\n   across all those modules.\n   The Prefix, if present,\
    \ suggests an NCName to use as the namespace\n   prefix in namespace declarations\
    \ involving the target namespace.  An\n   RXER encoder is not obligated to use\
    \ the nominated namespace prefix.\n   If there are no top-level components, then\
    \ the RXER encodings\n   produced using a module with a TARGET-NAMESPACE encoding\
    \ instruction\n   are backward compatible with the RXER encodings produced by\
    \ the same\n   module without the TARGET-NAMESPACE encoding instruction.\n"
- title: 19.  The TYPE-AS-VERSION Encoding Instruction
  contents:
  - "19.  The TYPE-AS-VERSION Encoding Instruction\n   The TYPE-AS-VERSION encoding\
    \ instruction causes an RXER encoder to\n   include an xsi:type attribute in the\
    \ encoding of a value of the\n   component to which the encoding instruction is\
    \ applied.  This\n   attribute allows an XML Schema [XSD1] validator to select,\
    \ if\n   available, the appropriate XML Schema translation for the version of\n\
    \   the ASN.1 specification used to create the encoding.\n      Aside: Translations\
    \ of an ASN.1 specification into a compatible\n      XML Schema are expected to\
    \ be slightly different across versions\n      because of progressive extensions\
    \ to the ASN.1 specification.  Any\n      incompatibilities between these translations\
    \ can be accommodated\n      if each version uses a different target namespace.\
    \  The target\n      namespace will be evident in the value of the xsi:type attribute\n\
    \      and will cause an XML Schema validator to use the appropriate\n      version.\
    \  This mechanism also accommodates an ASN.1 type that is\n      renamed in a\
    \ later version of the ASN.1 specification.\n   The notation for a TYPE-AS-VERSION\
    \ encoding instruction is defined as\n   follows:\n      TypeAsVersionInstruction\
    \ ::= \"TYPE-AS-VERSION\"\n   The Type in a NamedType that is subject to a TYPE-AS-VERSION\
    \ encoding\n   instruction MUST be a namespace-qualified reference [RXER].\n \
    \  The addition of a TYPE-AS-VERSION encoding instruction does not\n   affect\
    \ the backward compatibility of RXER encodings.\n      Aside: In a translation\
    \ of an ASN.1 specification into XML Schema,\n      any Type in a NamedType that\
    \ is subject to a TYPE-AS-VERSION\n      encoding instruction is expected to be\
    \ translated into the\n      XML Schema anyType so that the xsi:type attribute\
    \ acts as a switch\n      to select the appropriate version.\n"
- title: 20.  The TYPE-REF Encoding Instruction
  contents:
  - "20.  The TYPE-REF Encoding Instruction\n   The TYPE-REF encoding instruction\
    \ causes values of the Markup ASN.1\n   type to be restricted to conform to a\
    \ specific XML Schema named type,\n   RELAX NG named pattern or an ASN.1 defined\
    \ type.\n      Aside: Referencing an ASN.1 type in a TYPE-REF encoding\n     \
    \ instruction does not have the effect of imposing a requirement to\n      preserve\
    \ the Infoset [INFOSET] representation of the RXER encoding\n      of an abstract\
    \ value of the type.  It is still sufficient to\n      preserve just the abstract\
    \ value.\n   The notation for a TYPE-REF encoding instruction is defined as\n\
    \   follows:\n      TypeRefInstruction ::= \"TYPE-REF\" QNameValue RefParameters\n\
    \   Taken together, the QNameValue and the ContextParameter of the\n   RefParameters\
    \ (if present) MUST reference an XML Schema named type, a\n   RELAX NG named pattern,\
    \ or an ASN.1 defined type.\n   A referenced XML Schema type MUST NOT require\
    \ the presence of values\n   for the XML Schema ENTITY or ENTITIES types.\n  \
    \    Aside: Entity declarations are not supported by CRXER.\n   The QNameValue\
    \ SHALL NOT be a direct reference to the XML Schema\n   NOTATION type [XSD2] (i.e.,\
    \ the namespace name\n   \"http://www.w3.org/2001/XMLSchema\" and local name \"\
    NOTATION\");\n   however, a reference to an XML Schema type derived from the NOTATION\n\
    \   type is permitted.\n      Aside: This restriction is to ensure that the lexical\
    \ space [XSD2]\n      of the referenced type is actually populated with the names\
    \ of\n      notations [XSD1].\n   Example\n      MyDecimal ::=\n          [TYPE-REF\
    \ {\n              namespace-name \"http://www.w3.org/2001/XMLSchema\",\n    \
    \          local-name     \"decimal\" }]\n          Markup\n      Note that the\
    \ ASN.X translation of this ASN.1 type definition\n      provides a more natural\
    \ way to reference the XML Schema decimal\n      type:\n         <namedType xmlns:xs=\"\
    http://www.w3.org/2001/XMLSchema\"\n                    name=\"MyDecimal\">\n\
    \          <type ref=\"xs:decimal\" embedded=\"true\"/>\n         </namedType>\n"
- title: 21.  The UNION Encoding Instruction
  contents:
  - "21.  The UNION Encoding Instruction\n   The UNION encoding instruction causes\
    \ an RXER encoder to encode the\n   value of an alternative of a CHOICE type without\
    \ encapsulation in a\n   child element.  The chosen alternative is optionally\
    \ indicated with a\n   member attribute.  The optional PrecedenceList also allows\
    \ a\n   specification writer to alter the order in which an RXER decoder will\n\
    \   consider the alternatives of the CHOICE as it determines which\n   alternative\
    \ has been used (if the actual alternative has not been\n   specified through\
    \ the member attribute).\n   The notation for a UNION encoding instruction is\
    \ defined as follows:\n      UnionInstruction ::= \"UNION\" AlternativesPrecedence\
    \ ?\n      AlternativesPrecedence ::= \"PRECEDENCE\" PrecedenceList\n      PrecedenceList\
    \ ::= identifier PrecedenceList ?\n   The Type in the EncodingPrefixedType for\
    \ a UNION encoding instruction\n   SHALL be either:\n   (1) a BuiltinType that\
    \ is a ChoiceType, or\n   (2) a ConstrainedType that is not a TypeWithConstraint\
    \ where the Type\n       in the ConstrainedType is one of (1) to (4), or\n   (3)\
    \ a BuiltinType that is a PrefixedType that is a TaggedType where\n       the\
    \ Type in the TaggedType is one of (1) to (4), or\n   (4) a BuiltinType that is\
    \ a PrefixedType that is an\n       EncodingPrefixedType where the Type in the\
    \ EncodingPrefixedType\n       is one of (1) to (4).\n   The ChoiceType in case\
    \ (1) is said to be \"subject to\" the UNION\n   encoding instruction.\n   The\
    \ base type of the type of each alternative of a ChoiceType that is\n   subject\
    \ to a UNION encoding instruction SHALL NOT be:\n   (1) a CHOICE, SET, or SET\
    \ OF type, or\n   (2) a SEQUENCE type other than the one defining the QName type\
    \ from\n       the AdditionalBasicDefinitions module [RXER] (i.e., QName is\n\
    \       allowed), or\n   (3) a SEQUENCE OF type where the SequenceOfType is not\
    \ subject to a\n       LIST encoding instruction, or\n   (4) an open type.\n \
    \  Each identifier in the PrecedenceList MUST be the identifier of a\n   NamedType\
    \ in the ChoiceType.\n   A particular identifier SHALL NOT appear more than once\
    \ in the same\n   PrecedenceList.\n   Every NamedType in a ChoiceType that is\
    \ subject to a UNION encoding\n   instruction MUST NOT be subject to an ATTRIBUTE,\
    \ ATTRIBUTE-REF,\n   COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT,\
    \ or\n   TYPE-AS-VERSION encoding instruction.\n   Example\n      [UNION PRECEDENCE\
    \ basicName] CHOICE {\n          extendedName  UTF8String,\n          basicName\
    \     PrintableString\n      }\n"
- title: 22.  The VALUES Encoding Instruction
  contents:
  - "22.  The VALUES Encoding Instruction\n   The VALUES encoding instruction causes\
    \ an RXER encoder to use\n   nominated names instead of the identifiers that would\
    \ otherwise\n   appear in the encoding of a value of a BIT STRING, ENUMERATED,\
    \ or\n   INTEGER type.\n   The notation for a VALUES encoding instruction is defined\
    \ as follows:\n      ValuesInstruction ::=\n          \"VALUES\" AllValuesMapped\
    \ ? ValueMappingList ?\n      AllValuesMapped ::= AllCapitalized | AllUppercased\n\
    \      AllCapitalized ::= \"ALL\" \"CAPITALIZED\"\n      AllUppercased ::= \"\
    ALL\" \"UPPERCASED\"\n      ValueMappingList ::= ValueMapping ValueMappingList\
    \ ?\n      ValueMapping ::= \",\" identifier \"AS\" NCNameValue\n   The Type in\
    \ the EncodingPrefixedType for a VALUES encoding\n   instruction SHALL be either:\n\
    \   (1) a BuiltinType that is a BitStringType with a NamedBitList, or\n   (2)\
    \ a BuiltinType that is an EnumeratedType, or\n   (3) a BuiltinType that is an\
    \ IntegerType with a NamedNumberList, or\n   (4) a ConstrainedType that is not\
    \ a TypeWithConstraint where the Type\n       in the ConstrainedType is one of\
    \ (1) to (6), or\n   (5) a BuiltinType that is a PrefixedType that is a TaggedType\
    \ where\n       the Type in the TaggedType is one of (1) to (6), or\n   (6) a\
    \ BuiltinType that is a PrefixedType that is an\n       EncodingPrefixedType where\
    \ the Type in the EncodingPrefixedType\n       is one of (1) to (6).\n   The effect\
    \ of this condition is to force the VALUES encoding\n   instruction to be textually\
    \ co-located with the type definition to\n   which it applies.\n   The BitStringType,\
    \ EnumeratedType, or IntegerType in case (1), (2),\n   or (3), respectively, is\
    \ said to be \"subject to\" the VALUES encoding\n   instruction.\n   A BitStringType,\
    \ EnumeratedType, or IntegerType SHALL NOT be subject\n   to more than one VALUES\
    \ encoding instruction.\n   Each identifier in a ValueMapping MUST be an identifier\
    \ appearing in\n   the NamedBitList, Enumerations, or NamedNumberList, as the\
    \ case may\n   be.\n   The identifier in a ValueMapping SHALL NOT be the same\
    \ as the\n   identifier in any other ValueMapping for the same ValueMappingList.\n\
    \   Definition (replacement name):  Each identifier in a BitStringType,\n   EnumeratedType,\
    \ or IntegerType subject to a VALUES encoding\n   instruction has a replacement\
    \ name.  If there is a ValueMapping for\n   the identifier, then the replacement\
    \ name is the character string\n   specified by the NCNameValue in the ValueMapping;\
    \ else if\n   AllCapitalized is used, then the replacement name is the identifier\n\
    \   with the first character uppercased; else if AllUppercased is used,\n   then\
    \ the replacement name is the identifier with all its characters\n   uppercased;\
    \ otherwise, the replacement name is the identifier.\n   The replacement names\
    \ for the identifiers in a BitStringType subject\n   to a VALUES encoding instruction\
    \ MUST be distinct.\n   The replacement names for the identifiers in an EnumeratedType\n\
    \   subject to a VALUES encoding instruction MUST be distinct.\n   The replacement\
    \ names for the identifiers in an IntegerType subject\n   to a VALUES encoding\
    \ instruction MUST be distinct.\n   Example\n      Traffic-Light ::= [VALUES ALL\
    \ CAPITALIZED, red AS \"RED\"]\n          ENUMERATED {\n              red,   \
    \ -- Replacement name is RED.\n              amber,  -- Replacement name is Amber.\n\
    \              green   -- Replacement name is Green.\n          }\n"
- title: 23.  Insertion Encoding Instructions
  contents:
  - "23.  Insertion Encoding Instructions\n   Certain of the RXER encoding instructions\
    \ are categorized as\n   insertion encoding instructions.  The insertion encoding\
    \ instructions\n   are the NO-INSERTIONS, HOLLOW-INSERTIONS, SINGULAR-INSERTIONS,\n\
    \   UNIFORM-INSERTIONS, and MULTIFORM-INSERTIONS encoding instructions\n   (whose\
    \ notations are described respectively by\n   NoInsertionsInstruction, HollowInsertionsInstruction,\n\
    \   SingularInsertionsInstruction, UniformInsertionsInstruction, and\n   MultiformInsertionsInstruction).\n\
    \   The notation for the insertion encoding instructions is defined as\n   follows:\n\
    \      InsertionsInstruction ::=\n          NoInsertionsInstruction |\n      \
    \    HollowInsertionsInstruction |\n          SingularInsertionsInstruction |\n\
    \          UniformInsertionsInstruction |\n          MultiformInsertionsInstruction\n\
    \      NoInsertionsInstruction ::= \"NO-INSERTIONS\"\n      HollowInsertionsInstruction\
    \ ::= \"HOLLOW-INSERTIONS\"\n      SingularInsertionsInstruction ::= \"SINGULAR-INSERTIONS\"\
    \n      UniformInsertionsInstruction ::= \"UNIFORM-INSERTIONS\"\n      MultiformInsertionsInstruction\
    \ ::= \"MULTIFORM-INSERTIONS\"\n   Using the GROUP encoding instruction on components\
    \ with extensible\n   types can lead to situations where an unknown extension\
    \ could be\n   associated with more than one extension insertion point.  The\n\
    \   insertion encoding instructions remove this ambiguity by limiting the\n  \
    \ form that extensions can take.  That is, the insertion encoding\n   instructions\
    \ indicate what extensions can be made to an ASN.1\n   specification without breaking\
    \ forward compatibility for RXER\n   encodings.\n      Aside: Forward compatibility\
    \ means the ability for a decoder to\n      successfully decode an encoding containing\
    \ extensions introduced\n      into a version of the specification that is more\
    \ recent than the\n      one used by the decoder.\n   In the most general case,\
    \ an extension to a CHOICE, SET, or SEQUENCE\n   type will generate zero or more\
    \ attributes and zero or more elements,\n   due to the potential use of the GROUP\
    \ and ATTRIBUTE encoding\n   instructions by the extension.\n   The MULTIFORM-INSERTIONS\
    \ encoding instruction indicates that the RXER\n   encodings produced by forward-compatible\
    \ extensions to a type will\n   always consist of one or more elements and zero\
    \ or more attributes.\n   No restriction is placed on the names of the elements.\n\
    \      Aside: Of necessity, the names of the attributes will all be\n      different\
    \ in any given encoding.\n   The UNIFORM-INSERTIONS encoding instruction indicates\
    \ that the RXER\n   encodings produced by forward-compatible extensions to a type\
    \ will\n   always consist of one or more elements having the same expanded name,\n\
    \   and zero or more attributes.  The expanded name shared by the\n   elements\
    \ in one particular encoding is not required to be the same as\n   the expanded\
    \ name shared by the elements in any other encoding of the\n   extension.  For\
    \ example, in one encoding of the extension the\n   elements might all be called\
    \ \"foo\", while in another encoding of the\n   extension they might all be called\
    \ \"bar\".\n   The SINGULAR-INSERTIONS encoding instruction indicates that the\
    \ RXER\n   encodings produced by forward-compatible extensions to a type will\n\
    \   always consist of a single element and zero or more attributes.  The\n   name\
    \ of the single element is not required to be the same in every\n   possible encoding\
    \ of the extension.\n   The HOLLOW-INSERTIONS encoding instruction indicates that\
    \ the RXER\n   encodings produced by forward-compatible extensions to a type will\n\
    \   always consist of zero elements and zero or more attributes.\n   The NO-INSERTIONS\
    \ encoding instruction indicates that no forward-\n   compatible extensions can\
    \ be made to a type.\n   Examples of forward-compatible extensions are provided\
    \ in Appendix C.\n   The Type in the EncodingPrefixedType for an insertion encoding\n\
    \   instruction SHALL be either:\n   (1) a BuiltinType that is a ChoiceType where\
    \ the ChoiceType is not\n       subject to a UNION encoding instruction, or\n\
    \   (2) a BuiltinType that is a SequenceType or SetType, or\n   (3) a ConstrainedType\
    \ that is not a TypeWithConstraint where the Type\n       in the ConstrainedType\
    \ is one of (1) to (5), or\n   (4) a BuiltinType that is a PrefixedType that is\
    \ a TaggedType where\n       the Type in the TaggedType is one of (1) to (5),\
    \ or\n   (5) a BuiltinType that is a PrefixedType that is an\n       EncodingPrefixedType\
    \ where the Type in the EncodingPrefixedType\n       is one of (1) to (5).\n \
    \  Case (2) is not permitted when the insertion encoding instruction is\n   the\
    \ SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, or MULTIFORM-INSERTIONS\n   encoding\
    \ instruction.\n      Aside: Because extensions to a SET or SEQUENCE type are\
    \ serial and\n      effectively optional, the SINGULAR-INSERTIONS, UNIFORM-INSERTIONS,\n\
    \      and MULTIFORM-INSERTIONS encoding instructions offer no advantage\n   \
    \   over unrestricted extensions (for a SET or SEQUENCE).  For\n      example,\
    \ an optional series of singular insertions generates zero\n      or more elements\
    \ and zero or more attributes, just like an\n      unrestricted extension.\n \
    \  The Type in case (1) or case (2) is said to be \"subject to\" the\n   insertion\
    \ encoding instruction.\n   The Type in case (1) or case (2) MUST be extensible,\
    \ either\n   explicitly or by default.\n   A Type SHALL NOT be subject to more\
    \ than one insertion encoding\n   instruction.\n   The insertion encoding instructions\
    \ indicate what kinds of extensions\n   can be made to a type without breaking\
    \ forward compatibility, but\n   they do not prohibit extensions that do break\
    \ forward compatibility.\n   That is, it is not an error for a type's base type\
    \ to contain\n   extensions that do not satisfy an insertion encoding instruction\n\
    \   affecting the type.  However, if any such extensions are made, then a\n  \
    \ new value SHOULD be introduced into the extensible set of permitted\n   values\
    \ for a version indicator attribute, or attributes (see\n   Section 24), whose\
    \ scope encompasses the extensions.  An example is\n   provided in Appendix C.\n"
- title: 24.  The VERSION-INDICATOR Encoding Instruction
  contents:
  - "24.  The VERSION-INDICATOR Encoding Instruction\n   The VERSION-INDICATOR encoding\
    \ instruction provides a mechanism for\n   RXER decoders to be alerted that an\
    \ encoding contains extensions that\n   break forward compatibility (see the preceding\
    \ section).\n   The notation for a VERSION-INDICATOR encoding instruction is defined\n\
    \   as follows:\n      VersionIndicatorInstruction ::= \"VERSION-INDICATOR\"\n\
    \   A NamedType that is subject to a VERSION-INDICATOR encoding\n   instruction\
    \ MUST also be subject to an ATTRIBUTE encoding\n   instruction.\n   The type\
    \ of the NamedType that is subject to the VERSION-INDICATOR\n   encoding instruction\
    \ MUST be directly or indirectly a constrained\n   type where the set of permitted\
    \ values is defined to be extensible.\n   Each value represents a different version\
    \ of the ASN.1 specification.\n   Ordinarily, an application will set the value\
    \ of a version indicator\n   attribute to be the last of these permitted values.\
    \  An application\n   MAY set the value of the version indicator attribute to\
    \ the value\n   corresponding to an earlier version of the specification if it\
    \ has\n   not used any of the extensions added in a subsequent version.\n   If\
    \ an RXER decoder encounters a value of the type that is not one of\n   the root\
    \ values or extension additions (but that is still allowed\n   since the set of\
    \ permitted values is extensible), then this indicates\n   that the decoder is\
    \ using a version of the ASN.1 specification that\n   is not compatible with the\
    \ version used to produce the encoding.  In\n   such cases, the decoder SHOULD\
    \ treat the element containing the\n   attribute as having an unknown ASN.1 type.\n\
    \      Aside: A version indicator attribute only indicates an\n      incompatibility\
    \ with respect to RXER encodings.  Other encodings\n      are not affected because\
    \ the GROUP encoding instruction does not\n      apply to them.\n   Examples\n\
    \      In this first example, the decoder is using an incompatible older\n   \
    \   version if the value of the version attribute in a received RXER\n      encoding\
    \ is not 1, 2, or 3.\n         SEQUENCE {\n             version  [ATTRIBUTE] [VERSION-INDICATOR]\n\
    \                          INTEGER (1, ..., 2..3),\n             message  MessageType\n\
    \         }\n      In this second example, the decoder is using an incompatible\
    \ older\n      version if the value of the format attribute in a received RXER\n\
    \      encoding is not \"1.0\", \"1.1\", or \"2.0\".\n         SEQUENCE {\n  \
    \           format   [ATTRIBUTE] [VERSION-INDICATOR]\n                       \
    \   UTF8String (\"1.0\", ..., \"1.1\" | \"2.0\"),\n             message  MessageType\n\
    \         }\n      An extensive example is provided in Appendix C.\n   It is not\
    \ necessary for every extensible type to have its own version\n   indicator attribute.\
    \  It would be typical for only the types of\n   top-level element components\
    \ to include a version indicator\n   attribute, which would serve as the version\
    \ indicator for all of the\n   nested components.\n"
- title: 25.  The GROUP Encoding Instruction
  contents:
  - "25.  The GROUP Encoding Instruction\n   The GROUP encoding instruction causes\
    \ an RXER encoder to encode a\n   value of the component to which it is applied\
    \ without encapsulation\n   as an element.  It allows the construction of non-trivial\
    \ content\n   models for element content.\n   The notation for a GROUP encoding\
    \ instruction is defined as follows:\n      GroupInstruction ::= \"GROUP\"\n \
    \  The base type of the type of a NamedType that is subject to a GROUP\n   encoding\
    \ instruction SHALL be either:\n   (1) a SEQUENCE, SET, or SET OF type, or\n \
    \  (2) a CHOICE type where the ChoiceType is not subject to a UNION\n       encoding\
    \ instruction, or\n   (3) a SEQUENCE OF type where the SequenceOfType is not subject\
    \ to a\n       LIST encoding instruction.\n   The SEQUENCE type in case (1) SHALL\
    \ NOT be the associated type for a\n   built-in type, SHALL NOT be a type from\
    \ the\n   AdditionalBasicDefinitions module [RXER], and SHALL NOT contain a\n\
    \   component that is subject to a SIMPLE-CONTENT encoding instruction.\n    \
    \  Aside: Thus, the CHARACTER STRING, EMBEDDED PDV, EXTERNAL, REAL,\n      and\
    \ QName types are excluded.\n   The CHOICE type in case (2) SHALL NOT be a type\
    \ from the\n   AdditionalBasicDefinitions module.\n      Aside: Thus, the Markup\
    \ type is excluded.\n   Definition (visible component): Ignoring all type constraints,\
    \ the\n   visible components for a type that is directly or indirectly a\n   combining\
    \ ASN.1 type (i.e., SEQUENCE, SET, CHOICE, SEQUENCE OF, or\n   SET OF) is the\
    \ set of components of the combining type definition\n   plus, for each NamedType\
    \ (of the combining type definition) that is\n   subject to a GROUP encoding instruction,\
    \ the visible components for\n   the type of the NamedType.  The visible components\
    \ are determined\n   after the COMPONENTS OF transformation specified in X.680,\
    \ Clause\n   24.4 [X.680].\n      Aside: The set of visible attribute and element\
    \ components for a\n      type is the set of all the components of the type, and\
    \ any nested\n      types, that describe attributes and child elements appearing\
    \ in\n      the RXER encodings of values of the outer type.\n   A GROUP encoding\
    \ instruction MUST NOT be used where it would cause a\n   NamedType to be a visible\
    \ component of the type of that same\n   NamedType (which is only possible if\
    \ the type definition is\n   recursive).\n      Aside: Components subject to a\
    \ GROUP encoding instruction might be\n      translated into a compatible XML\
    \ Schema [XSD1] as group\n      definitions.  A NamedType that is visible to its\
    \ own type is\n      analogous to a circular group, which XML Schema disallows.\n\
    \   Section 25.1 imposes additional conditions on the use of the GROUP\n   encoding\
    \ instruction.\n   In any use of the GROUP encoding instruction, there is a type,\
    \ the\n   including type, that contains the component subject to the GROUP\n \
    \  encoding instruction, and a type, the included type, that is the base\n   type\
    \ of that component.  Either type can have an extensible content\n   model, either\
    \ by directly using ASN.1 extensibility or by including\n   through another GROUP\
    \ encoding instruction some other type that is\n   extensible.\n   The including\
    \ and included types may be defined in different ASN.1\n   modules, in which case\
    \ the owner of the including type, i.e., the\n   person or organization having\
    \ the authority to add extensions to the\n   including type's definition, may\
    \ be different from the owner of the\n   included type.\n   If the owner of the\
    \ including type is not using the most recent\n   version of the included type's\
    \ definition, then the owner of the\n   including type might add an extension\
    \ to the including type that is\n   valid with respect to the older version of\
    \ the included type, but is\n   later found to be invalid when the latest versions\
    \ of the including\n   and included type definitions are brought together (perhaps\
    \ by a\n   third party).  Although the owner of the including type must\n   necessarily\
    \ be aware of the existence of the included type, the\n   reverse is not necessarily\
    \ true.  The owner of the included type\n   could add an extension to the included\
    \ type without realizing that it\n   invalidates someone else's including type.\n\
    \   To avoid these problems, a GROUP encoding instruction MUST NOT be\n   used\
    \ if:\n   (1) the included type is defined in a different module from the\n  \
    \     including type, and\n   (2) the included type has an extensible content\
    \ model, and\n   (3) changes to the included type are not coordinated with the\
    \ owner\n       of the including type.\n   Changes in the included type are coordinated\
    \ with the owner of the\n   including type if:\n   (1) the owner of the included\
    \ type is also the owner of the including\n       type, or\n   (2) the owner of\
    \ the including type is collaborating with the owner\n       of the included type,\
    \ or\n   (3) all changes will be vetted by a common third party before being\n\
    \       approved and published.\n"
- title: 25.1.  Unambiguous Encodings
  contents:
  - "25.1.  Unambiguous Encodings\n   Unregulated use of the GROUP encoding instruction\
    \ can easily lead to\n   specifications in which distinct abstract values have\n\
    \   indistinguishable RXER encodings, i.e., ambiguous encodings.  This\n   section\
    \ imposes restrictions on the use of the GROUP encoding\n   instruction to ensure\
    \ that distinct abstract values have distinct\n   RXER encodings.  In addition,\
    \ these restrictions ensure that an\n   abstract value can be easily decoded in\
    \ a single pass without\n   back-tracking.\n   An RXER decoder for an ASN.1 type\
    \ can be abstracted as a recognizer\n   for a notional language, consisting of\
    \ element and attribute expanded\n   names, where the type definition describes\
    \ the grammar for that\n   language (in fact it is a context-free grammar).  The\
    \ restrictions on\n   a type definition to ensure easy, unambiguous decoding are\
    \ more\n   conveniently, completely, and simply expressed as conditions on this\n\
    \   associated grammar.  Implementations are not expected to verify type\n   definitions\
    \ exactly in the manner to be described; however, the\n   procedure used MUST\
    \ produce the same result.\n   Section 25.1.1 describes the procedure for recasting\
    \ as a grammar a\n   type definition containing components subject to the GROUP\
    \ encoding\n   instruction.  Sections 25.1.2 and 25.1.3 specify conditions that\
    \ the\n   grammar must satisfy for the type definition to be valid.  Section\n\
    \   25.1.4 describes how unrecognized attributes are accepted by the\n   grammar\
    \ for an extensible type.\n   Appendices A and B have extensive examples.\n"
- title: 25.1.1.  Grammar Construction
  contents:
  - "25.1.1.  Grammar Construction\n   A grammar consists of a collection of productions.\
    \  A production has\n   a left-hand side and a right-hand side (in this document,\
    \ separated\n   by the \"::=\" symbol).  The left-hand side (in a context-free\
    \ grammar)\n   is a single non-terminal symbol.  The right-hand side is a sequence\n\
    \   of non-terminal and terminal symbols.  The terminal symbols are the\n   lexical\
    \ items of the language that the grammar describes.  One of the\n   non-terminals\
    \ is nominated to be the start symbol.  A valid sequence\n   of terminals for\
    \ the language can be generated from the grammar by\n   beginning with the start\
    \ symbol and repeatedly replacing any\n   non-terminal with the right-hand side\
    \ of one of the productions where\n   that non-terminal is on the production's\
    \ left-hand side.  The final\n   sequence of terminals is achieved when there\
    \ are no remaining\n   non-terminals to replace.\n      Aside: X.680 describes\
    \ the ASN.1 basic notation using a\n      context-free grammar.\n   Each NamedType\
    \ has an associated primary and secondary non-terminal.\n      Aside: The secondary\
    \ non-terminal for a NamedType is used when the\n      base type of the type in\
    \ the NamedType is a SEQUENCE OF type or\n      SET OF type.\n   Each ExtensionAddition\
    \ and ExtensionAdditionAlternative has an\n   associated non-terminal.  There\
    \ is a non-terminal associated with the\n   extension insertion point of each\
    \ extensible type.  There is also a\n   primary start non-terminal (this is the\
    \ start symbol) and a secondary\n   start non-terminal.  The exact nature of the\
    \ non-terminals is not\n   important, however all the non-terminals MUST be mutually\
    \ distinct.\n   It is adequate for most of the examples in this document (though\
    \ not\n   in the most general case) for the primary non-terminal for a\n   NamedType\
    \ to be the identifier of the NamedType, for the primary\n   start non-terminal\
    \ to be S, for the non-terminals for the instances\n   of ExtensionAddition and\
    \ ExtensionAdditionAlternative to be E1, E2,\n   E3, and so on, and for the non-terminals\
    \ for the extension insertion\n   points to be I1, I2, I3, and so on.  The secondary\
    \ non-terminals are\n   labelled by appending a \"'\" character to the primary\
    \ non-terminal\n   label, e.g., the primary and secondary start non-terminals\
    \ are S and\n   S', respectively.\n   Each NamedType and extension insertion point\
    \ has an associated\n   terminal.  There exists a terminal called the general\
    \ extension\n   terminal that is not associated with any specific notation.  The\n\
    \   general extension terminal and the terminals for the extension\n   insertion\
    \ points are used to represent elements in unknown\n   extensions.  The exact\
    \ nature of the terminals is not important;\n   however, the aforementioned terminals\
    \ MUST be mutually distinct.  The\n   terminals are further categorized as either\
    \ element terminals or\n   attribute terminals.  A terminal for a NamedType is\
    \ an attribute\n   terminal if its associated NamedType is an attribute component;\n\
    \   otherwise, it is an element terminal.  The general extension terminal\n  \
    \ and the terminals for the extension insertion points are categorized\n   as\
    \ element terminals.\n   Terminals for attributes in unknown extensions are not\
    \ explicitly\n   provided in the grammar.  Certain productions in the grammar\
    \ are\n   categorized as insertion point productions, and their role in\n   accepting\
    \ unknown attributes is described in Section 25.1.4.\n   In the examples in this\
    \ document, the terminal for a component other\n   than an attribute component\
    \ will be represented as the local name of\n   the expanded name of the component\
    \ enclosed in double quotes, and the\n   terminal for an attribute component will\
    \ be represented as the local\n   name of the expanded name of the component prefixed\
    \ by the '@'\n   character and enclosed in double quotes.  The general extension\n\
    \   terminal will be represented as \"*\" and the terminals for the\n   extension\
    \ insertion points will be represented as \"*1\", \"*2\", \"*3\",\n   and so on.\n\
    \   The productions generated from a NamedType depend on the base type of\n  \
    \ the type of the NamedType.  The productions for the start\n   non-terminals\
    \ depend on the combining type definition being tested.\n   In either case, the\
    \ procedure for generating productions takes a\n   primary non-terminal, a secondary\
    \ non-terminal (sometimes), and a\n   type definition.\n   The grammar is constructed\
    \ beginning with the start non-terminals and\n   the combining type definition\
    \ being tested.\n   A grammar is constructed after the COMPONENTS OF transformation\n\
    \   specified in X.680, Clause 24.4 [X.680].\n   Given a primary non-terminal,\
    \ N, and a type where the base type is a\n   SEQUENCE or SET type, a production\
    \ is added to the grammar with N as\n   the left-hand side.  The right-hand side\
    \ is constructed from an\n   initial empty state according to the following cases\
    \ considered in\n   order:\n   (1) If an initial RootComponentTypeList is present\
    \ in the base type,\n       then the sequence of primary non-terminals for the\
    \ components\n       nested in that RootComponentTypeList are appended to the\
    \ right-\n       hand side in the order of their definition.\n   (2) If an ExtensionAdditions\
    \ instance is present in the base type and\n       not empty, then the non-terminal\
    \ for the first ExtensionAddition\n       nested in the ExtensionAdditions instance\
    \ is appended to the\n       right-hand side.\n   (3) If an ExtensionAdditions\
    \ instance is empty or not present in the\n       base type, and the base type\
    \ is extensible (explicitly or by\n       default), and the base type is not subject\
    \ to a NO-INSERTIONS or\n       HOLLOW-INSERTIONS encoding instruction, then the\
    \ non-terminal for\n       the extension insertion point of the base type is appended\
    \ to the\n       right-hand side.\n   (4) If a final RootComponentTypeList is\
    \ present in the base type,\n       then the primary non-terminals for the components\
    \ nested in that\n       RootComponentTypeList are appended to the right-hand\
    \ side in the\n       order of their definition.\n   The production is an insertion\
    \ point production if an\n   ExtensionAdditions instance is empty or not present\
    \ in the base type,\n   and the base type is extensible (explicitly or by default),\
    \ and the\n   base type is not subject to a NO-INSERTIONS encoding instruction.\n\
    \   If a component in a ComponentTypeList (in either a\n   RootComponentTypeList\
    \ or an ExtensionAdditionGroup) is marked\n   OPTIONAL or DEFAULT, then a production\
    \ with the primary non-terminal\n   of the component as the left-hand side and\
    \ an empty right-hand side\n   is added to the grammar.\n   If a component (regardless\
    \ of the ASN.1 combining type containing it)\n   is subject to a GROUP encoding\
    \ instruction, then one or more\n   productions constructed according to the component's\
    \ type are added\n   to the grammar.  Each of these productions has the primary\n\
    \   non-terminal of the component as the left-hand side.\n   If a component (regardless\
    \ of the ASN.1 combining type containing it)\n   is not subject to a GROUP encoding\
    \ instruction, then a production is\n   added to the grammar with the primary\
    \ non-terminal of the component\n   as the left-hand side and the terminal of\
    \ the component as the\n   right-hand side.\n   Example\n      Consider the following\
    \ ASN.1 type definition:\n         SEQUENCE {\n             -- Start of initial\
    \ RootComponentTypeList.\n             one    [ATTRIBUTE] UTF8String,\n      \
    \       two    BOOLEAN OPTIONAL,\n             three  INTEGER\n             --\
    \ End of initial RootComponentTypeList.\n         }\n      Here is the grammar\
    \ derived from this type:\n         S ::= one two three\n         one ::= \"@one\"\
    \n         two ::= \"two\"\n         two ::=\n         three ::= \"three\"\n \
    \  For each ExtensionAddition (of a SEQUENCE or SET base type), a\n   production\
    \ is added to the grammar where the left-hand side is the\n   non-terminal for\
    \ the ExtensionAddition and the right-hand side is\n   initially empty.  If the\
    \ ExtensionAddition is a ComponentType, then\n   the primary non-terminal for\
    \ the NamedType in the ComponentType is\n   appended to the right-hand side; otherwise\
    \ (an\n   ExtensionAdditionGroup), the sequence of primary non-terminals for\n\
    \   the components nested in the ComponentTypeList in the\n   ExtensionAdditionGroup\
    \ are appended to the right-hand side in the\n   order of their definition.  If\
    \ the ExtensionAddition is followed by\n   another ExtensionAddition, then the\
    \ non-terminal for the next\n   ExtensionAddition is appended to the right-hand\
    \ side; otherwise, if\n   the base type is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS\n\
    \   encoding instruction, then the non-terminal for the extension\n   insertion\
    \ point of the base type is appended to the right-hand side.\n   If the ExtensionAddition\
    \ is not followed by another ExtensionAddition\n   and the base type is not subject\
    \ to a NO-INSERTIONS encoding\n   instruction, then the production is an insertion\
    \ point production.\n   If the empty sequence of terminals cannot be generated\
    \ from the\n   production (it may be necessary to wait until the grammar is\n\
    \   otherwise complete before making this determination), then another\n   production\
    \ is added to the grammar where the left-hand side is the\n   non-terminal for\
    \ the ExtensionAddition and the right-hand side is\n   empty.\n      Aside: An\
    \ extension is always effectively optional since a sender\n      may be using\
    \ an earlier version of the ASN.1 specification where\n      none, or only some,\
    \ of the extensions have been defined.\n      Aside: The grammar generated for\
    \ ExtensionAdditions is structured\n      to take account of the condition that\
    \ an extension can only be\n      used if all the earlier extensions are also\
    \ used [X.680].\n   If a SEQUENCE or SET base type is extensible (explicitly or\
    \ by\n   default) and is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS\n\
    \   encoding instruction, then:\n   (1) a production is added to the grammar where\
    \ the left-hand side is\n       the non-terminal for the extension insertion point\
    \ of the base\n       type and the right-hand side is the general extension terminal\n\
    \       followed by the non-terminal for the extension insertion point,\n    \
    \   and\n   (2) a production is added to the grammar where the left-hand side\
    \ is\n       the non-terminal for the extension insertion point and the\n    \
    \   right-hand side is empty.\n   Example\n      Consider the following ASN.1\
    \ type definition:\n         SEQUENCE {\n             -- Start of initial RootComponentTypeList.\n\
    \             one    BOOLEAN,\n             two    INTEGER OPTIONAL,\n       \
    \      -- End of initial RootComponentTypeList.\n             ...,\n         \
    \    -- Start of ExtensionAdditions.\n             four  INTEGER,  -- First ExtensionAddition\
    \ (E1).\n             five  BOOLEAN OPTIONAL,  -- Second ExtensionAddition (E2).\n\
    \             [[ -- An ExtensionAdditionGroup.\n                 six    UTF8String,\n\
    \                 seven  INTEGER OPTIONAL\n             ]], -- Third ExtensionAddition\
    \ (E3).\n             -- End of ExtensionAdditions.\n             -- The extension\
    \ insertion point is here (I1).\n             ...,\n             -- Start of final\
    \ RootComponentTypeList.\n             three  INTEGER\n         }\n      Here\
    \ is the grammar derived from this type:\n         S ::= one two E1 three\n  \
    \       E1 ::= four E2\n         E1 ::=\n         E2 ::= five E3\n         E3\
    \ ::= six seven I1\n         E3 ::=\n         I1 ::= \"*\" I1\n         I1 ::=\n\
    \         one ::= \"one\"\n         two ::= \"two\"\n         two ::=\n      \
    \   three ::= \"three\"\n         four ::= \"four\"\n         five ::= \"five\"\
    \n         five ::=\n         six ::= \"six\"\n         seven ::= \"seven\"\n\
    \         seven ::=\n      If the SEQUENCE type were subject to a NO-INSERTIONS\
    \ or\n      HOLLOW-INSERTIONS encoding instruction, then the productions for\n\
    \      I1 would not appear, and the first production for E3 would be:\n      \
    \   E3 ::= six seven\n   Given a primary non-terminal, N, and a type where the\
    \ base type is a\n   CHOICE type:\n   (1) A production is added to the grammar\
    \ for each NamedType nested in\n       the RootAlternativeTypeList of the base\
    \ type, where the left-hand\n       side is N and the right-hand side is the primary\
    \ non-terminal for\n       the NamedType.\n   (2) A production is added to the\
    \ grammar for each\n       ExtensionAdditionAlternative of the base type, where\
    \ the left-\n       hand side is N and the right-hand side is the non-terminal\
    \ for\n       the ExtensionAdditionAlternative.\n   (3) If the base type is extensible\
    \ (explicitly or by default) and the\n       base type is not subject to an insertion\
    \ encoding instruction,\n       then:\n       (a) A production is added to the\
    \ grammar where the left-hand side\n           is N and the right-hand side is\
    \ the non-terminal for the\n           extension insertion point of the base type.\
    \  This production\n           is an insertion point production.\n       (b) A\
    \ production is added to the grammar where the left-hand side\n           is the\
    \ non-terminal for the extension insertion point of the\n           base type\
    \ and the right-hand side is the general extension\n           terminal followed\
    \ by the non-terminal for the extension\n           insertion point.\n       (c)\
    \ A production is added to the grammar where the left-hand side\n           is\
    \ the non-terminal for the extension insertion point of the\n           base type\
    \ and the right-hand side is empty.\n   (4) If the base type is subject to a HOLLOW-INSERTIONS\
    \ encoding\n       instruction, then a production is added to the grammar where\
    \ the\n       left-hand side is N and the right-hand side is empty.  This\n  \
    \     production is an insertion point production.\n   (5) If the base type is\
    \ subject to a SINGULAR-INSERTIONS encoding\n       instruction, then a production\
    \ is added to the grammar where the\n       left-hand side is N and the right-hand\
    \ side is the general\n       extension terminal.  This production is an insertion\
    \ point\n       production.\n   (6) If the base type is subject to a UNIFORM-INSERTIONS\
    \ encoding\n       instruction, then:\n       (a) A production is added to the\
    \ grammar where the left-hand side\n           is N and the right-hand side is\
    \ the general extension\n           terminal.\n              Aside: This production\
    \ is used to verify the correctness\n              of an ASN.1 type definition,\
    \ but would not be used in the\n              implementation of an RXER decoder.\
    \  The next production\n              takes precedence over it for accepting an\
    \ unknown element.\n       (b) A production is added to the grammar where the\
    \ left-hand side\n           is N and the right-hand side is the terminal for\
    \ the\n           extension insertion point of the base type followed by the\n\
    \           non-terminal for the extension insertion point.  This\n          \
    \ production is an insertion point production.\n       (c) A production is added\
    \ to the grammar where the left-hand side\n           is the non-terminal for\
    \ the extension insertion point of the\n           base type and the right-hand\
    \ side is the terminal for the\n           extension insertion point followed\
    \ by the non-terminal for\n           the extension insertion point.\n       (d)\
    \ A production is added to the grammar where the left-hand side\n           is\
    \ the non-terminal for the extension insertion point of the\n           base type\
    \ and the right-hand side is empty.\n   (7) If the base type is subject to a MULTIFORM-INSERTIONS\
    \ encoding\n       instruction, then:\n       (a) A production is added to the\
    \ grammar where the left-hand side\n           is N and the right-hand side is\
    \ the general extension\n           terminal followed by the non-terminal for\
    \ the extension\n           insertion point of the base type.  This production\
    \ is an\n           insertion point production.\n       (b) A production is added\
    \ to the grammar where the left-hand side\n           is the non-terminal for\
    \ the extension insertion point of the\n           base type and the right-hand\
    \ side is the general extension\n           terminal followed by the non-terminal\
    \ for the extension\n           insertion point.\n       (c) A production is added\
    \ to the grammar where the left-hand side\n           is the non-terminal for\
    \ the extension insertion point of the\n           base type and the right-hand\
    \ side is empty.\n   If an ExtensionAdditionAlternative is a NamedType, then a\
    \ production\n   is added to the grammar where the left-hand side is the non-terminal\n\
    \   for the ExtensionAdditionAlternative and the right-hand side is the\n   primary\
    \ non-terminal for the NamedType.\n   If an ExtensionAdditionAlternative is an\n\
    \   ExtensionAdditionAlternativesGroup, then a production is added to the\n  \
    \ grammar for each NamedType nested in the\n   ExtensionAdditionAlternativesGroup,\
    \ where the left-hand side is the\n   non-terminal for the ExtensionAdditionAlternative\
    \ and the right-hand\n   side is the primary non-terminal for the NamedType.\n\
    \   Example\n      Consider the following ASN.1 type definition:\n         CHOICE\
    \ {\n             -- Start of RootAlternativeTypeList.\n             one    BOOLEAN,\n\
    \             two    INTEGER,\n             -- End of RootAlternativeTypeList.\n\
    \             ...,\n             -- Start of ExtensionAdditionAlternatives.\n\
    \             three  INTEGER, -- First ExtensionAdditionAlternative (E1).\n  \
    \           [[ -- An ExtensionAdditionAlternativesGroup.\n                 four\
    \  UTF8String,\n                 five  INTEGER\n             ]] -- Second ExtensionAdditionAlternative\
    \ (E2).\n             -- The extension insertion point is here (I1).\n       \
    \  }\n      Here is the grammar derived from this type:\n         S ::= one\n\
    \         S ::= two\n         S ::= E1\n         S ::= E2\n         S ::= I1\n\
    \         I1 ::= \"*\" I1\n         I1 ::=\n         E1 ::= three\n         E2\
    \ ::= four\n         E2 ::= five\n         one ::= \"one\"\n         two ::= \"\
    two\"\n         three ::= \"three\"\n         four ::= \"four\"\n         five\
    \ ::= \"five\"\n      If the CHOICE type were subject to a NO-INSERTIONS encoding\n\
    \      instruction, then the fifth, sixth, and seventh productions would\n   \
    \   be removed.\n      If the CHOICE type were subject to a HOLLOW-INSERTIONS\
    \ encoding\n      instruction, then the fifth, sixth, and seventh productions\
    \ would\n      be replaced by:\n         S ::=\n      If the CHOICE type were\
    \ subject to a SINGULAR-INSERTIONS encoding\n      instruction, then the fifth,\
    \ sixth, and seventh productions would\n      be replaced by:\n         S ::=\
    \ \"*\"\n      If the CHOICE type were subject to a UNIFORM-INSERTIONS encoding\n\
    \      instruction, then the fifth and sixth productions would be\n      replaced\
    \ by:\n         S ::= \"*\"\n         S ::= \"*1\" I1\n         I1 ::= \"*1\"\
    \ I1\n      If the CHOICE type were subject to a MULTIFORM-INSERTIONS encoding\n\
    \      instruction, then the fifth production would be replaced by:\n        \
    \ S ::= \"*\" I1\n   Constraints on a SEQUENCE, SET, or CHOICE type are ignored.\
    \  They do\n   not affect the grammar being generated.\n      Aside: This avoids\
    \ an awkward situation where values of a subtype\n      have to be decoded differently\
    \ from values of the parent type.  It\n      also simplifies the verification\
    \ procedure.\n   Given a primary non-terminal, N, and a type that has a SEQUENCE\
    \ OF or\n   SET OF base type and that permits a value of size zero (i.e., an\n\
    \   empty sequence or set):\n   (1) a production is added to the grammar where\
    \ the left-hand side of\n       the production is N and the right-hand side is\
    \ the primary\n       non-terminal for the NamedType of the component of the\n\
    \       SEQUENCE OF or SET OF base type, followed by N, and\n   (2) a production\
    \ is added to the grammar where the left-hand side of\n       the production is\
    \ N and the right-hand side is empty.\n   Given a primary non-terminal, N, a secondary\
    \ non-terminal, N', and a\n   type that has a SEQUENCE OF or SET OF base type\
    \ and that does not\n   permit a value of size zero:\n   (1) a production is added\
    \ to the grammar where the left-hand side of\n       the production is N and the\
    \ right-hand side is the primary\n       non-terminal for the NamedType of the\
    \ component of the\n       SEQUENCE OF or SET OF base type, followed by N', and\n\
    \   (2) a production is added to the grammar where the left-hand side of\n   \
    \    the production is N' and the right-hand side is the primary\n       non-terminal\
    \ for the NamedType of the component of the\n       SEQUENCE OF or SET OF base\
    \ type, followed by N', and\n   (3) a production is added to the grammar where\
    \ the left-hand side of\n       the production is N' and the right-hand side is\
    \ empty.\n   Example\n      Consider the following ASN.1 type definition:\n  \
    \       SEQUENCE SIZE(1..MAX) OF number INTEGER\n      Here is the grammar derived\
    \ from this type:\n         S ::= number S'\n         S' ::= number S'\n     \
    \    S' ::=\n         number ::= \"number\"\n   All inner subtyping (InnerTypeContraints)\
    \ is ignored for the purposes\n   of deciding whether a value of size zero is\
    \ permitted by a\n   SEQUENCE OF or SET OF type.\n   This completes the description\
    \ of the transformation of ASN.1\n   combining type definitions into a grammar.\n"
- title: 25.1.2.  Unique Component Attribution
  contents:
  - "25.1.2.  Unique Component Attribution\n   This section describes conditions that\
    \ the grammar must satisfy so\n   that each element and attribute in a received\
    \ RXER encoding can be\n   uniquely associated with an ASN.1 component definition.\n\
    \   Definition (used by the grammar):  A non-terminal, N, is used by the\n   grammar\
    \ if:\n   (1) N is the start symbol or\n   (2) N appears on the right-hand side\
    \ of a production where the\n       non-terminal on the left-hand side is used\
    \ by the grammar.\n   Definition (multiple derivation paths):  A non-terminal,\
    \ N, has\n   multiple derivation paths if:\n   (1) N appears on the right-hand\
    \ side of a production where the\n       non-terminal on the left-hand side has\
    \ multiple derivation paths,\n       or\n   (2) N appears on the right-hand side\
    \ of more than one production\n       where the non-terminal on the left-hand\
    \ side is used by the\n       grammar, or\n   (3) N is the start symbol and it\
    \ appears on the right-hand side of a\n       production where the non-terminal\
    \ on the left-hand side is used\n       by the grammar.\n   For every ASN.1 type\
    \ with a base type containing components that are\n   subject to a GROUP encoding\
    \ instruction, the grammar derived by the\n   method described in this document\
    \ MUST NOT have:\n   (1) two or more primary non-terminals that are used by the\
    \ grammar\n       and are associated with element components having the same\n\
    \       expanded name, or\n   (2) two or more primary non-terminals that are used\
    \ by the grammar\n       and are associated with attribute components having the\
    \ same\n       expanded name, or\n   (3) a primary non-terminal that has multiple\
    \ derivation paths and is\n       associated with an attribute component.\n  \
    \    Aside: Case (1) is in response to component referencing notations\n     \
    \ that are evaluated with respect to the XML encoding of an abstract\n      value.\
    \  Case (1) guarantees, without having to do extensive\n      testing (which would\
    \ necessarily have to take account of encoding\n      instructions for all other\
    \ encoding rules), that all sibling\n      elements with the same expanded name\
    \ will be associated with\n      equivalent type definitions.  Such equivalence\
    \ allows a component\n      referenced by element name to be re-encoded using\
    \ a different set\n      of ASN.1 encoding rules without ambiguity as to which\
    \ type\n      definition and encoding instructions apply.\n      Cases (2) and\
    \ (3) ensure that an attribute name is always uniquely\n      associated with\
    \ one component that can occur at most once and is\n      always nested in the\
    \ same part of an abstract value.\n   Example\n      The following example types\
    \ illustrate various uses and misuses of\n      the GROUP encoding instruction\
    \ with respect to unique component\n      attribution:\n         TA ::= SEQUENCE\
    \ {\n             a  [GROUP] TB,\n             b  [GROUP] CHOICE {\n         \
    \        a  [GROUP] TB,\n                 b  [NAME AS \"c\"] [ATTRIBUTE] INTEGER,\n\
    \                 c  INTEGER,\n                 d  TB,\n                 e  [GROUP]\
    \ TD,\n                 f  [ATTRIBUTE] UTF8String\n             },\n         \
    \    c  [ATTRIBUTE] INTEGER,\n             d  [GROUP] SEQUENCE OF\n          \
    \       a [GROUP] SEQUENCE {\n                     a  [ATTRIBUTE] OBJECT IDENTIFIER,\n\
    \                     b  INTEGER\n                 },\n             e  [NAME AS\
    \ \"c\"] INTEGER,\n             COMPONENTS OF TD\n         }\n         TB ::=\
    \ SEQUENCE {\n             a  INTEGER,\n             b  [ATTRIBUTE] BOOLEAN,\n\
    \             COMPONENTS OF TC\n         }\n         TC ::= SEQUENCE {\n     \
    \        f  OBJECT IDENTIFIER\n         }\n         TD ::= SEQUENCE {\n      \
    \       g  OBJECT IDENTIFIER\n         }\n      The grammar for TA is constructed\
    \ after performing the\n      COMPONENTS OF transformation.  The result of this\
    \ transformation\n      is shown next.  This example will depart from the usual\
    \ convention\n      of using just the identifier of a NamedType to represent the\n\
    \      primary non-terminal for that NamedType.  A label relative to the\n   \
    \   outermost type will be used instead to better illustrate unique\n      component\
    \ attribution.  The labels used for the non-terminals are\n      shown down the\
    \ right-hand side.\n         TA ::= SEQUENCE {\n             a  [GROUP] TB,  \
    \                           -- TA.a\n             b  [GROUP] CHOICE {        \
    \                -- TA.b\n                 a  [GROUP] TB,                    \
    \     -- TA.b.a\n                 b  [NAME AS \"c\"] [ATTRIBUTE] INTEGER,  --\
    \ TA.b.b\n                 c  INTEGER,                            -- TA.b.c\n\
    \                 d  TB,                                 -- TA.b.d\n         \
    \        e  [GROUP] TD,                         -- TA.b.e\n                 f\
    \  [ATTRIBUTE] UTF8String              -- TA.b.f\n             },\n          \
    \   c  [ATTRIBUTE] INTEGER,                    -- TA.c\n             d  [GROUP]\
    \ SEQUENCE OF                     -- TA.d\n                 a [GROUP] SEQUENCE\
    \ {                   -- TA.d.a\n                     a  [ATTRIBUTE] OBJECT IDENTIFIER,\
    \  -- TA.d.a.a\n                     b  INTEGER                         -- TA.d.a.b\n\
    \                 },\n             e  [NAME AS \"c\"] INTEGER,               \
    \   -- TA.e\n             g  OBJECT IDENTIFIER                       -- TA.g\n\
    \         }\n         TB ::= SEQUENCE {\n             a  INTEGER,            \
    \                    -- TB.a\n             b  [ATTRIBUTE] BOOLEAN,           \
    \         -- TB.b\n             f  OBJECT IDENTIFIER                       --\
    \ TB.f\n         }\n         -- Type TC is no longer of interest. --\n       \
    \  TD ::= SEQUENCE {\n             g  OBJECT IDENTIFIER                      \
    \ -- TD.g\n         }\n      The associated grammar is:\n         S ::= TA.a TA.b\
    \ TA.c TA.d TA.e TA.g\n         TA.a ::= TB.a TB.b TB.f\n         TB.a ::= \"\
    a\"\n         TB.b ::= \"@b\"\n         TB.f ::= \"f\"\n         TA.b ::= TA.b.a\n\
    \         TA.b ::= TA.b.b\n         TA.b ::= TA.b.c\n         TA.b ::= TA.b.d\n\
    \         TA.b ::= TA.b.e\n         TA.b ::= TA.b.f\n         TA.b.a ::= TB.a\
    \ TB.b TB.f\n         TA.b.b ::= \"@c\"\n         TA.b.c ::= \"c\"\n         TA.b.d\
    \ ::= \"d\"\n         TA.b.e ::= TD.g\n         TA.b.f ::= \"@f\"\n         TD.g\
    \ ::= \"g\"\n         TA.c ::= \"@c\"\n         TA.d ::= TA.d.a TA.d\n       \
    \  TA.d ::=\n         TA.d.a ::= TA.d.a.a TA.d.a.b\n         TA.d.a.a := \"@a\"\
    \n         TA.d.a.b ::= \"b\"\n         TA.e ::= \"c\"\n         TA.g ::= \"g\"\
    \n      All the non-terminals are used by the grammar.\n      The type definition\
    \ for TA is invalid because there are two\n      instances where two or more primary\
    \ non-terminals are associated\n      with element components having the same\
    \ expanded name:\n      (1) TA.b.c and TA.e (both generate the terminal \"c\"\
    ), and\n      (2) TD.g and TA.g (both generate the terminal \"g\").\n      In\
    \ case (2), TD.g and TA.g are derived from the same instance of\n      NamedType\
    \ notation, but become distinct components following the\n      COMPONENTS OF\
    \ transformation.  AUTOMATIC tagging is applied after\n      the COMPONENTS OF\
    \ transformation, which means that the types of\n      the components corresponding\
    \ to TD.g and TA.g will end up with\n      different tags, and therefore the types\
    \ will not be equivalent.\n      The type definition for TA is also invalid because\
    \ there is one\n      instance where two or more primary non-terminals are associated\n\
    \      with attribute components having the same expanded name:  TA.b.b\n    \
    \  and TA.c (both generate the terminal \"@c\").\n      The non-terminals with\
    \ multiple derivation paths are:  TA.d,\n      TA.d.a, TA.d.a.a, TA.d.a.b, TB.a,\
    \ TB.b, and TB.f.  The type\n      definition for TA is also invalid because TA.d.a.a\
    \ and TB.b are\n      primary non-terminals that are associated with an attribute\n\
    \      component.\n"
- title: 25.1.3.  Deterministic Grammars
  contents:
  - "25.1.3.  Deterministic Grammars\n   Let the First Set of a production P, denoted\
    \ First(P), be the set of\n   all element terminals T where T is the first element\
    \ terminal in a\n   sequence of terminals that can be generated from the right-hand\
    \ side\n   of P.  There can be any number of leading attribute terminals before\n\
    \   T.\n   Let the Follow Set of a non-terminal N, denoted Follow(N), be the set\n\
    \   of all element terminals T where T is the first element terminal\n   following\
    \ N in a sequence of non-terminals and terminals that can be\n   generated from\
    \ the grammar.  There can be any number of attribute\n   terminals between N and\
    \ T.  If a sequence of non-terminals and\n   terminals can be generated from the\
    \ grammar where N is not followed\n   by any element terminals, then Follow(N)\
    \ also contains a special end\n   terminal, denoted by \"$\".\n      Aside: If\
    \ N does not appear on the right-hand side of any\n      production, then Follow(N)\
    \ will be empty.\n   For a production P, let the predicate Empty(P) be true if\
    \ and only if\n   the empty sequence of terminals can be generated from P.  Otherwise,\n\
    \   Empty(P) is false.\n   Definition (base grammar):  The base grammar is a rewriting\
    \ of the\n   grammar in which the non-terminals for every ExtensionAddition and\n\
    \   ExtensionAdditionAlternative are removed from the right-hand side of\n   all\
    \ productions.\n   For a production P, let the predicate Preselected(P) be true\
    \ if and\n   only if every sequence of terminals that can be generated from the\n\
    \   right-hand side of P using only the base grammar contains at least\n   one\
    \ attribute terminal.  Otherwise, Preselected(P) is false.\n   The Select Set\
    \ of a production P, denoted Select(P), is empty if\n   Preselected(P) is true;\
    \ otherwise, it contains First(P).  Let N be\n   the non-terminal on the left-hand\
    \ side of P.  If Empty(P) is true,\n   then Select(P) also contains Follow(N).\n\
    \      Aside: It may appear somewhat dubious to include the attribute\n      components\
    \ in the grammar because, in reality, attributes appear\n      unordered within\
    \ the start tag of an element, and not interspersed\n      with the child elements\
    \ as the grammar would suggest.  This is why\n      attribute terminals are ignored\
    \ in composing the First Sets and\n      Follow Sets.  However, the attribute\
    \ terminals are important in\n      composing the Select Sets because they can\
    \ preselect a production\n      and can prevent a production from being able to\
    \ generate an empty\n      sequence of terminals.  In real terms, this corresponds\
    \ to an RXER\n      decoder using the attributes to determine the presence or\
    \ absence\n      of optional components and to select between the alternatives\
    \ of a\n      CHOICE, even before considering the child elements.\n      An attribute\
    \ appearing in an extension isn't used to preselect a\n      production since,\
    \ in general, a decoder using an earlier version\n      of the specification would\
    \ not be able to associate the attribute\n      with any particular extension\
    \ insertion point.\n   Let the Reach Set of a non-terminal N, denoted Reach(N),\
    \ be the set\n   of all element terminals T where T appears in a sequence of terminals\n\
    \   that can be generated from N.\n      Aside: It can be readily shown that all\
    \ the optional attribute\n      components and all but one of the mandatory attribute\
    \ components\n      of a SEQUENCE or SET type can be ignored in constructing the\n\
    \      grammar because their omission does not alter the First, Follow,\n    \
    \  Select, or Reach Sets, or the evaluation of the Preselected and\n      Empty\
    \ predicates.\n   A grammar is deterministic (for the purposes of an RXER decoder)\
    \ if\n   and only if:\n   (1) there do not exist two productions P and Q, with\
    \ the same\n       non-terminal on the left-hand side, where the intersection\
    \ of\n       Select(P) and Select(Q) is not empty, and\n   (2) there does not\
    \ exist a non-terminal E for an ExtensionAddition or\n       ExtensionAdditionAlternative\
    \ where the intersection of Reach(E)\n       and Follow(E) is not empty.\n   \
    \   Aside: In case (1), if the intersection is not empty, then a\n      decoder\
    \ would have two or more possible ways to attempt to decode\n      the input into\
    \ an abstract value.  In case (2), if the\n      intersection is not empty, then\
    \ a decoder using an earlier version\n      of the ASN.1 specification would confuse\
    \ an element in an unknown\n      (to that decoder) extension with a known component\
    \ following the\n      extension.\n      Aside: In the absence of any attribute\
    \ components, case (1) is the\n      test for an LL(1) grammar.\n   For every\
    \ ASN.1 type with a base type containing components that are\n   subject to a\
    \ GROUP encoding instruction, the grammar derived by the\n   method described\
    \ in this document MUST be deterministic.\n"
- title: 25.1.4.  Attributes in Unknown Extensions
  contents:
  - "25.1.4.  Attributes in Unknown Extensions\n   An insertion point production is\
    \ able to accept unknown attributes if\n   the non-terminal on the left-hand side\
    \ of the production does not\n   have multiple derivation paths.\n      Aside:\
    \ If the non-terminal has multiple derivation paths, then any\n      future extension\
    \ cannot possibly contain an attribute component\n      because that would violate\
    \ the requirements of Section 25.1.2.\n   For a deterministic grammar, there is\
    \ only one possible way to\n   construct a sequence of element terminals matching\
    \ the element\n   content of an element in a correctly formed RXER encoding. \
    \ Any\n   unknown attributes of the element are accepted if at least one\n   insertion\
    \ point production that is able to accept unknown attributes\n   is used in that\
    \ construction.\n   Example\n      Consider this type definition:\n         CHOICE\
    \ {\n             one  UTF8String,\n             two  [GROUP] SEQUENCE {\n   \
    \               three  INTEGER,\n                  ...\n             }\n     \
    \    }\n      The associated grammar is:\n         S ::= one\n         S ::= two\n\
    \         two ::= three I1\n         I1 ::= \"*\" I1\n         I1 ::=\n      \
    \   one ::= \"one\"\n         three ::= \"three\"\n      The third production\
    \ is an insertion point production, and it is\n      able to accept unknown attributes.\n\
    \      When decoding a value of this type, if the element content\n      contains\
    \ a <one> child element, then any unrecognized attribute\n      would be illegal\
    \ as the insertion point production would not be\n      used to recognize the\
    \ input (the \"one\" alternative does not admit\n      an extension insertion\
    \ point).  If the element content contains a\n      <three> element, then an unrecognized\
    \ attribute would be accepted\n      because the insertion point production would\
    \ be used to recognize\n      the input (the \"two\" alternative that generates\
    \ the <three>\n      element has an extensible type).\n      If the SEQUENCE type\
    \ were prefixed by a NO-INSERTIONS encoding\n      instruction, then the third,\
    \ fourth, and fifth productions would\n      be replaced by:\n         two ::=\
    \ three\n      With this change, any unrecognized attribute would be illegal for\n\
    \      the \"two\" alternative also, since the replacement production is\n   \
    \   not an insertion point production.\n   If more than one insertion point production\
    \ that is able to accept\n   unknown attributes is used in constructing a matching\
    \ sequence of\n   element terminals, then a decoder is free to associate an\n\
    \   unrecognized attribute with any one of the extension insertion points\n  \
    \ corresponding to those insertion point productions.  The\n   justification for\
    \ doing so comes from the following two observations:\n   (1) If the encoding\
    \ of an abstract value contains an extension where\n       the type of the extension\
    \ is unknown to the receiver, then it is\n       generally impossible to re-encode\
    \ the value using a different set\n       of encoding rules, including the canonical\
    \ variant of the\n       received encoding.  This is true no matter which encoding\
    \ rules\n       are being used.  It is desirable for a decoder to be able to\n\
    \       accept and store the raw encoding of an extension without raising\n  \
    \     an error, and to re-insert the raw encoding of the extension when\n    \
    \   re-encoding the abstract value using the same non-canonical\n       encoding\
    \ rules.  However, there is little more that an\n       application can do with\
    \ an unknown extension.\n       An application using RXER can successfully accept,\
    \ store, and\n       re-encode an unrecognized attribute regardless of which extension\n\
    \       insertion point it might be ascribed to.\n   (2) Even if there is a single\
    \ extension insertion point, an unknown\n       extension could still be the encoding\
    \ of a value of any one of an\n       infinite number of valid type definitions.\
    \  For example, an\n       attribute or element component could be nested to any\
    \ arbitrary\n       depth within CHOICEs whose components are subject to GROUP\n\
    \       encoding instructions.\n          Aside: A similar series of nested CHOICEs\
    \ could describe an\n          unknown extension in a Basic Encoding Rules (BER)\
    \ encoding\n          [X.690].\n"
- title: 26.  Security Considerations
  contents:
  - "26.  Security Considerations\n   ASN.1 compiler implementors should take special\
    \ care to be thorough\n   in checking that the GROUP encoding instruction has\
    \ been correctly\n   used; otherwise, ASN.1 specifications with ambiguous RXER\
    \ encodings\n   could be deployed.\n   Ambiguous encodings mean that the abstract\
    \ value recovered by a\n   decoder may differ from the original abstract value\
    \ that was encoded.\n   If that is the case, then a digital signature generated\
    \ with respect\n   to the original abstract value (using a canonical encoding\
    \ other than\n   CRXER) will not be successfully verified by a receiver using\
    \ the\n   decoded abstract value.  Also, an abstract value may have\n   security-sensitive\
    \ fields, and in particular, fields used to grant or\n   deny access.  If the\
    \ decoded abstract value differs from the encoded\n   abstract value, then a receiver\
    \ using the decoded abstract value will\n   be applying different security policy\
    \ than that embodied in the\n   original abstract value.\n"
- title: 27.  References
  contents:
  - '27.  References

    '
- title: 27.1.  Normative References
  contents:
  - "27.1.  Normative References\n   [BCP14]    Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [URI]      Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform\n\
    \              Resource Identifiers (URI): Generic Syntax\", STD 66, RFC\n   \
    \           3986, January 2005.\n   [RXER]     Legg, S. and D. Prager, \"Robust\
    \ XML Encoding Rules (RXER)\n              for Abstract Syntax Notation One (ASN.1)\"\
    , RFC 4910, July\n              2007.\n   [ASN.X]    Legg, S., \"Abstract Syntax\
    \ Notation X (ASN.X)\", RFC 4912,\n              July 2007.\n   [X.680]    ITU-T\
    \ Recommendation X.680 (07/02) | ISO/IEC 8824-1,\n              Information technology\
    \ - Abstract Syntax Notation One\n              (ASN.1):  Specification of basic\
    \ notation.\n   [X.680-1]  ITU-T Recommendation X.680 (2002) Amendment 1 (10/03)\
    \ |\n              ISO/IEC 8824-1:2002/Amd 1:2004, Support for EXTENDED-XER.\n\
    \   [X.683]    ITU-T Recommendation X.683 (07/02) | ISO/IEC 8824-4,\n        \
    \      Information technology - Abstract Syntax Notation One\n              (ASN.1):\
    \  Parameterization of ASN.1 specifications.\n   [XML10]    Bray, T., Paoli, J.,\
    \ Sperberg-McQueen, C., Maler, E. and\n              F. Yergeau, \"Extensible\
    \ Markup Language (XML) 1.0 (Fourth\n              Edition)\", W3C Recommendation,\n\
    \              http://www.w3.org/TR/2006/REC-xml-20060816, August 2006.\n   [XMLNS10]\
    \  Bray, T., Hollander, D., Layman, A., and R. Tobin,\n              \"Namespaces\
    \ in XML 1.0 (Second Edition)\", W3C\n              Recommendation,\n        \
    \      http://www.w3.org/TR/2006/REC-xml-names-20060816, August\n            \
    \  2006.\n   [XSD1]     Thompson, H., Beech, D., Maloney, M. and N. Mendelsohn,\n\
    \              \"XML Schema Part 1: Structures Second Edition\", W3C\n       \
    \       Recommendation,\n              http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/,\n\
    \              October 2004.\n   [XSD2]     Biron, P. and A. Malhotra, \"XML Schema\
    \ Part 2: Datatypes\n              Second Edition\", W3C Recommendation,\n   \
    \           http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/,\n           \
    \   October 2004.\n   [RNG]      Clark, J. and M. Makoto, \"RELAX NG Tutorial\"\
    , OASIS\n              Committee Specification, http://www.oasis-open.org/\n \
    \             committees/relax-ng/tutorial-20011203.html, December 2001.\n"
- title: 27.2.  Informative References
  contents:
  - "27.2.  Informative References\n   [INFOSET]  Cowan, J. and R. Tobin, \"XML Information\
    \ Set (Second\n              Edition)\", W3C Recommendation, http://www.w3.org/\n\
    \              TR/2004/REC-xml-infoset-20040204, February 2004.\n   [X.690]  \
    \  ITU-T Recommendation X.690 (07/02) | ISO/IEC 8825-1,\n              Information\
    \ technology - ASN.1 encoding rules:\n              Specification of Basic Encoding\
    \ Rules (BER), Canonical\n              Encoding Rules (CER) and Distinguished\
    \ Encoding Rules\n              (DER).\n"
- title: Appendix A.  GROUP Encoding Instruction Examples
  contents:
  - "Appendix A.  GROUP Encoding Instruction Examples\n   This appendix is non-normative.\n\
    \   This appendix contains examples of both correct and incorrect use of\n   the\
    \ GROUP encoding instruction, determined with respect to the\n   grammars derived\
    \ from the example type definitions.  The productions\n   of the grammars are\
    \ labeled for convenience.  Sets and predicates for\n   non-terminals with only\
    \ one production will be omitted from the\n   examples since they never indicate\
    \ non-determinism.\n   The requirements of Section 25.1.2 (\"Unique Component\
    \ Attribution\")\n   are satisfied by all the examples in this appendix and the\
    \ appendices\n   that follow it.\n"
- title: A.1.  Example 1
  contents:
  - "A.1.  Example 1\n   Consider this type definition:\n      SEQUENCE {\n      \
    \    one    [GROUP] SEQUENCE {\n              two    UTF8String OPTIONAL\n   \
    \       } OPTIONAL,\n          three  INTEGER\n      }\n   The associated grammar\
    \ is:\n      P1:  S ::= one three\n      P2:  one ::= two\n      P3:  one ::=\n\
    \      P4:  two ::= \"two\"\n      P5:  two ::=\n      P6:  three ::= \"three\"\
    \n   Select Sets have to be evaluated to test the validity of the type\n   definition.\
    \  The grammar leads to the following sets and predicates:\n      First(P2) =\
    \ { \"two\" }\n      First(P3) = { }\n      Preselected(P2) = Preselected(P3)\
    \ = false\n      Empty(P2) = Empty(P3) = true\n      Follow(one) = { \"three\"\
    \ }\n      Select(P2) = First(P2) + Follow(one) = { \"two\", \"three\" }\n   \
    \   Select(P3) = First(P3) + Follow(one) = { \"three\" }\n      First(P4) = {\
    \ \"two\" }\n      First(P5) = { }\n      Preselected(P4) = Preselected(P5) =\
    \ Empty(P4) = false\n      Empty(P5) = true\n      Follow(two) = { \"three\" }\n\
    \      Select(P4) = First(P4) = { \"two\" }\n      Select(P5) = First(P5) + Follow(two)\
    \ = { \"three\" }\n   The intersection of Select(P2) and Select(P3) is not empty;\
    \ hence,\n   the grammar is not deterministic, and the type definition is not\n\
    \   valid.  If the RXER encoding of a value of the type does not have a\n   child\
    \ element <two>, then it is not possible to determine whether the\n   \"one\"\
    \ component is present or absent in the value.\n   Now consider this type definition\
    \ with attributes in the \"one\"\n   component:\n      SEQUENCE {\n          one\
    \    [GROUP] SEQUENCE {\n              two    UTF8String OPTIONAL,\n         \
    \     four   [ATTRIBUTE] BOOLEAN,\n              five   [ATTRIBUTE] BOOLEAN OPTIONAL\n\
    \          } OPTIONAL,\n          three  INTEGER\n      }\n   The associated grammar\
    \ is:\n      P1:  S ::= one three\n      P2:  one ::= two four five\n      P3:\
    \  one ::=\n      P4:  two ::= \"two\"\n      P5:  two ::=\n      P6:  four ::=\
    \ \"@four\"\n      P7:  five ::= \"@five\"\n      P8:  five ::=\n      P9:  three\
    \ ::= \"three\"\n   This grammar leads to the following sets and predicates:\n\
    \      First(P2) = { \"two\" }\n      First(P3) = { }\n      Preselected(P3) =\
    \ Empty(P2) = false\n      Preselected(P2) = Empty(P3) = true\n      Follow(one)\
    \ = { \"three\" }\n      Select(P2) = { }\n      Select(P3) = First(P3) + Follow(one)\
    \ = { \"three\" }\n      First(P4) = { \"two\" }\n      First(P5) = { }\n    \
    \  Preselected(P4) = Preselected(P5) = Empty(P4) = false\n      Empty(P5) = true\n\
    \      Follow(two) = { \"three\" }\n      Select(P4) = First(P4) = { \"two\" }\n\
    \      Select(P5) = First(P5) + Follow(two) = { \"three\" }\n      First(P7) =\
    \ { }\n      First(P8) = { }\n      Preselected(P8) = Empty(P7) = false\n    \
    \  Preselected(P7) = Empty(P8) = true\n      Follow(five) = { \"three\" }\n  \
    \    Select(P7) = { }\n      Select(P8) = First(P8) + Follow(five) = { \"three\"\
    \ }\n   The intersection of Select(P2) and Select(P3) is empty, as is the\n  \
    \ intersection of Select(P4) and Select(P5) and the intersection of\n   Select(P7)\
    \ and Select(P8); hence, the grammar is deterministic, and\n   the type definition\
    \ is valid.  In a correct RXER encoding, the \"one\"\n   component will be present\
    \ if and only if the \"four\" attribute is\n   present.\n"
- title: A.2.  Example 2
  contents:
  - "A.2.  Example 2\n   Consider this type definition:\n      CHOICE {\n        \
    \  one    [GROUP] SEQUENCE {\n              two    [ATTRIBUTE] BOOLEAN OPTIONAL\n\
    \          },\n          three  INTEGER,\n          four   [GROUP] SEQUENCE {\n\
    \              five   BOOLEAN OPTIONAL\n          }\n      }\n   The associated\
    \ grammar is:\n      P1:  S ::= one\n      P2:  S ::= three\n      P3:  S ::=\
    \ four\n      P4:  one ::= two\n      P5:  two ::= \"@two\"\n      P6:  two ::=\n\
    \      P7:  three ::= \"three\"\n      P8:  four ::= five\n      P9:  five ::=\
    \ \"five\"\n      P10: five ::=\n   This grammar leads to the following sets and\
    \ predicates:\n      First(P1) = { }\n      First(P2) = { \"three\" }\n      First(P3)\
    \ = { \"five\" }\n      Preselected(P1) = Preselected(P2) = Preselected(P3) =\
    \ false\n      Empty(P2) = false\n      Empty(P1) = Empty(P3) = true\n      Follow(S)\
    \ = { \"$\" }\n      Select(P1) = First(P1) + Follow(S) = { \"$\" }\n      Select(P2)\
    \ = First(P2) = { \"three\" }\n      Select(P3) = First(P3) + Follow(S) = { \"\
    five\", \"$\" }\n      First(P5) = { }\n      First(P6) = { }\n      Preselected(P6)\
    \ = Empty(P5) = false\n      Preselected(P5) = Empty(P6) = true\n      Follow(two)\
    \ = { \"$\" }\n      Select(P5) = { }\n      Select(P6) = First(P6) + Follow(two)\
    \ = { \"$\" }\n      First(P9) = { \"five\" }\n      First(P10) = { }\n      Preselected(P9)\
    \ = Preselected(P10) = Empty(P9) = false\n      Empty(P10) = true\n      Follow(five)\
    \ = { \"$\" }\n      Select(P9) = First(P9) = { \"five\" }\n      Select(P10)\
    \ = First(P10) + Follow(five) = { \"$\" }\n   The intersection of Select(P1) and\
    \ Select(P3) is not empty; hence,\n   the grammar is not deterministic, and the\
    \ type definition is not\n   valid.  If the RXER encoding of a value of the type\
    \ is empty, then it\n   is not possible to determine whether the \"one\" alternative\
    \ or the\n   \"four\" alternative has been chosen.\n   Now consider this slightly\
    \ different type definition:\n      CHOICE {\n          one    [GROUP] SEQUENCE\
    \ {\n              two    [ATTRIBUTE] BOOLEAN\n          },\n          three \
    \ INTEGER,\n          four   [GROUP] SEQUENCE {\n              five   BOOLEAN\
    \ OPTIONAL\n          }\n      }\n   The associated grammar is:\n      P1:  S\
    \ ::= one\n      P2:  S ::= three\n      P3:  S ::= four\n      P4:  one ::= two\n\
    \      P5:  two ::= \"@two\"\n      P6:  three ::= \"three\"\n      P7:  four\
    \ ::= five\n      P8:  five ::= \"five\"\n      P9:  five ::=\n   This grammar\
    \ leads to the following sets and predicates:\n      First(P1) = { }\n      First(P2)\
    \ = { \"three\" }\n      First(P3) = { \"five\" }\n      Preselected(P2) = Preselected(P3)\
    \ = false\n      Empty(P1) = Empty(P2) = false\n      Preselected(P1) = Empty(P3)\
    \ = true\n      Follow(S) = { \"$\" }\n      Select(P1) = { }\n      Select(P2)\
    \ = First(P2) = { \"three\" }\n      Select(P3) = First(P3) + Follow(S) = { \"\
    five\", \"$\" }\n      First(P8) = { \"five\" }\n      First(P9) = { }\n     \
    \ Preselected(P8) = Preselected(P9) = Empty(P8) = false\n      Empty(P9) = true\n\
    \      Follow(five) = { \"$\" }\n      Select(P8) = First(P8) = { \"five\" }\n\
    \      Select(P9) = First(P9) + Follow(five) = { \"$\" }\n   The intersection\
    \ of Select(P1) and Select(P2) is empty, the\n   intersection of Select(P1) and\
    \ Select(P3) is empty, the intersection\n   of Select(P2) and Select(P3) is empty,\
    \ and the intersection of\n   Select(P8) and Select(P9) is empty; hence, the grammar\
    \ is\n   deterministic, and the type definition is valid.  The \"one\" and\n \
    \  \"four\" alternatives can be distinguished because the \"one\"\n   alternative\
    \ has a mandatory attribute.\n"
- title: A.3.  Example 3
  contents:
  - "A.3.  Example 3\n   Consider this type definition:\n      SEQUENCE {\n      \
    \    one  [GROUP] CHOICE {\n              two    [ATTRIBUTE] BOOLEAN,\n      \
    \        three  [GROUP] SEQUENCE OF number INTEGER\n          } OPTIONAL\n   \
    \   }\n   The associated grammar is:\n      P1:  S ::= one\n      P2:  one ::=\
    \ two\n      P3:  one ::= three\n      P4:  one ::=\n      P5:  two ::= \"@two\"\
    \n      P6:  three ::= number three\n      P7:  three ::=\n      P8:  number ::=\
    \ \"number\"\n   This grammar leads to the following sets and predicates:\n  \
    \    First(P2) = { }\n      First(P3) = { \"number\" }\n      First(P4) = { }\n\
    \      Preselected(P3) = Preselected(P4) = Empty(P2) = false\n      Preselected(P2)\
    \ = Empty(P3) = Empty(P4) = true\n      Follow(one) = { \"$\" }\n      Select(P2)\
    \ = { }\n      Select(P3) = First(P3) + Follow(one) = { \"number\", \"$\" }\n\
    \      Select(P4) = First(P4) + Follow(one) = { \"$\" }\n      First(P6) = { \"\
    number\" }\n      First(P7) = { }\n      Preselected(P6) = Preselected(P7) = Empty(P6)\
    \ = false\n      Empty(P7) = true\n      Follow(three) = { \"$\" }\n      Select(P6)\
    \ = First(P6) = { \"number\" }\n      Select(P7) = First(P7) + Follow(three) =\
    \ { \"$\" }\n   The intersection of Select(P3) and Select(P4) is not empty; hence,\n\
    \   the grammar is not deterministic, and the type definition is not\n   valid.\
    \  If the RXER encoding of a value of the type is empty, then it\n   is not possible\
    \ to determine whether the \"one\" component is absent or\n   the empty \"three\"\
    \ alternative has been chosen.\n"
- title: A.4.  Example 4
  contents:
  - "A.4.  Example 4\n   Consider this type definition:\n      SEQUENCE {\n      \
    \    one  [GROUP] CHOICE {\n              two    [ATTRIBUTE] BOOLEAN,\n      \
    \        three  [ATTRIBUTE] BOOLEAN\n          } OPTIONAL\n      }\n   The associated\
    \ grammar is:\n      P1:  S ::= one\n      P2:  one ::= two\n      P3:  one ::=\
    \ three\n      P4:  one ::=\n      P5:  two ::= \"@two\"\n      P6:  three ::=\
    \ \"@three\"\n   This grammar leads to the following sets and predicates:\n  \
    \    First(P2) = { }\n      First(P3) = { }\n      First(P4) = { }\n      Preselected(P4)\
    \ = Empty(P2) = Empty(P3) = false\n      Preselected(P2) = Preselected(P3) = Empty(P4)\
    \ = true\n      Follow(one) = { \"$\" }\n      Select(P2) = { }\n      Select(P3)\
    \ = { }\n      Select(P4) = First(P4) + Follow(one) = { \"$\" }\n   The intersection\
    \ of Select(P2) and Select(P3) is empty, the\n   intersection of Select(P2) and\
    \ Select(P4) is empty, and the\n   intersection of Select(P3) and Select(P4) is\
    \ empty; hence, the\n   grammar is deterministic, and the type definition is valid.\n"
- title: A.5.  Example 5
  contents:
  - "A.5.  Example 5\n   Consider this type definition:\n      SEQUENCE {\n      \
    \    one  [GROUP] SEQUENCE OF number INTEGER OPTIONAL\n      }\n   The associated\
    \ grammar is:\n      P1:  S ::= one\n      P2:  one ::= number one\n      P3:\
    \  one ::=\n      P4:  one ::=\n      P5:  number ::= \"number\"\n   P3 is generated\
    \ during the processing of the SEQUENCE OF type.  P4 is\n   generated because\
    \ the \"one\" component is optional.\n   This grammar leads to the following sets\
    \ and predicates:\n      First(P2) = { \"number\" }\n      First(P3) = { }\n \
    \     First(P4) = { }\n      Preselected(P2) = Preselected(P3) = Preselected(P4)\
    \ = false\n      Empty(P2) = false\n      Empty(P3) = Empty(P4) = true\n     \
    \ Follow(one) = { \"$\" }\n      Select(P2) = First(P2) = { \"number\" }\n   \
    \   Select(P3) = First(P3) + Follow(one) = { \"$\" }\n      Select(P4) = First(P4)\
    \ + Follow(one) = { \"$\" }\n   The intersection of Select(P3) and Select(P4)\
    \ is not empty; hence,\n   the grammar is not deterministic, and the type definition\
    \ is not\n   valid.  If the RXER encoding of a value of the type does not have\
    \ any\n   <number> child elements, then it is not possible to determine whether\n\
    \   the \"one\" component is present or absent in the value.\n   Consider this\
    \ similar type definition with a SIZE constraint:\n      SEQUENCE {\n        \
    \  one  [GROUP] SEQUENCE SIZE(1..MAX) OF number INTEGER OPTIONAL\n      }\n  \
    \ The associated grammar is:\n      P1:  S ::= one\n      P2:  one ::= number\
    \ one'\n      P3:  one' ::= number one'\n      P4:  one' ::=\n      P5:  one ::=\n\
    \      P6:  number ::= \"number\"\n   This grammar leads to the following sets\
    \ and predicates:\n      First(P2) = { \"number\" }\n      First(P5) = { }\n \
    \     Preselected(P2) = Preselected(P5) = Empty(P2) = false\n      Empty(P5) =\
    \ true\n      Follow(one) = { \"$\" }\n      Select(P2) = First(P2) = { \"number\"\
    \ }\n      Select(P5) = First(P5) + Follow(one) = { \"$\" }\n      First(P3) =\
    \ { \"number\" }\n      First(P4) = { }\n      Preselected(P3) = Preselected(P4)\
    \ = Empty(P3) = false\n      Empty(P4) = true\n      Follow(one') = { \"$\" }\n\
    \      Select(P3) = First(P3) = { \"number\" }\n      Select(P4) = First(P4) +\
    \ Follow(one') = { \"$\" }\n   The intersection of Select(P2) and Select(P5) is\
    \ empty, as is the\n   intersection of Select(P3) and Select(P4); hence, the grammar\
    \ is\n   deterministic, and the type definition is valid.  If there are no\n \
    \  <number> child elements, then the \"one\" component is necessarily\n   absent\
    \ and there is no ambiguity.\n"
- title: A.6.  Example 6
  contents:
  - "A.6.  Example 6\n   Consider this type definition:\n      SEQUENCE {\n      \
    \    beginning  [GROUP] List,\n          middle     UTF8String OPTIONAL,\n   \
    \       end        [GROUP] List\n      }\n      List ::= SEQUENCE OF string UTF8String\n\
    \   The associated grammar is:\n      P1:  S ::= beginning middle end\n      P2:\
    \  beginning ::= string beginning\n      P3:  beginning ::=\n      P4:  middle\
    \ ::= \"middle\"\n      P5:  middle ::=\n      P6:  end ::= string end\n     \
    \ P7:  end ::=\n      P8:  string ::= \"string\"\n   This grammar leads to the\
    \ following sets and predicates:\n      First(P2) = { \"string\" }\n      First(P3)\
    \ = { }\n      Preselected(P2) = Preselected(P3) = Empty(P2) = false\n      Empty(P3)\
    \ = true\n      Follow(beginning) = { \"middle\", \"string\", \"$\" }\n      Select(P2)\
    \ = First(P2) = { \"string\" }\n      Select(P3) = First(P3) + Follow(beginning)\n\
    \                 = { \"middle\", \"string\", \"$\" }\n      First(P4) = { \"\
    middle\" }\n      First(P5) = { }\n      Preselected(P4) = Preselected(P5) = Empty(P4)\
    \ = false\n      Empty(P5) = true\n      Follow(middle) = { \"string\", \"$\"\
    \ }\n      Select(P4) = First(P4) = { \"middle\" }\n      Select(P5) = First(P5)\
    \ + Follow(middle) = { \"string\", \"$\" }\n      First(P6) = { \"string\" }\n\
    \      First(P7) = { }\n      Preselected(P6) = Preselected(P7) = Empty(P6) =\
    \ false\n      Empty(P7) = true\n      Follow(end) = { \"$\" }\n      Select(P6)\
    \ = First(P6) = { \"string\" }\n      Select(P7) = First(P7) + Follow(end) = {\
    \ \"$\" }\n   The intersection of Select(P2) and Select(P3) is not empty; hence,\n\
    \   the grammar is not deterministic, and the type definition is not\n   valid.\n\
    \   Now consider the following type definition:\n      SEQUENCE {\n          beginning\
    \     [GROUP] List,\n          middleAndEnd  [GROUP] SEQUENCE {\n            \
    \  middle        UTF8String,\n              end           [GROUP] List\n     \
    \     } OPTIONAL\n      }\n   The associated grammar is:\n      P1:  S ::= beginning\
    \ middleAndEnd\n      P2:  beginning ::= string beginning\n      P3:  beginning\
    \ ::=\n      P4:  middleAndEnd ::= middle end\n      P5:  middleAndEnd ::=\n \
    \     P6:  middle ::= \"middle\"\n      P7:  end ::= string end\n      P8:  end\
    \ ::=\n      P9:  string ::= \"string\"\n   This grammar leads to the following\
    \ sets and predicates:\n      First(P2) = { \"string\" }\n      First(P3) = {\
    \ }\n      Preselected(P2) = Preselected(P3) = Empty(P2) = false\n      Empty(P3)\
    \ = true\n      Follow(beginning) = { \"middle\", \"$\" }\n      Select(P2) =\
    \ First(P2) = { \"string\" }\n      Select(P3) = First(P3) + Follow(beginning)\
    \ = { \"middle\", \"$\" }\n      First(P4) = { \"middle\" }\n      First(P5) =\
    \ { }\n      Preselected(P4) = Preselected(P5) = Empty(P4) = false\n      Empty(P5)\
    \ = true\n      Follow(middleAndEnd) = { \"$\" }\n      Select(P4) = First(P4)\
    \ = { \"middle\" }\n      Select(P5) = First(P5) + Follow(middleAndEnd) = { \"\
    $\" }\n      First(P7) = { \"string\" }\n      First(P8) = { }\n      Preselected(P7)\
    \ = Preselected(P8) = Empty(P7) = false\n      Empty(P8) = true\n      Follow(end)\
    \ = { \"$\" }\n      Select(P7) = First(P7) = { \"string\" }\n      Select(P8)\
    \ = First(P8) + Follow(end) = { \"$\" }\n   The intersection of Select(P2) and\
    \ Select(P3) is empty, as is the\n   intersection of Select(P4) and Select(P5)\
    \ and the intersection of\n   Select(P7) and Select(P8); hence, the grammar is\
    \ deterministic, and\n   the type definition is valid.\n"
- title: A.7.  Example 7
  contents:
  - "A.7.  Example 7\n   Consider the following type definition:\n      SEQUENCE SIZE(1..MAX)\
    \ OF\n          one  [GROUP] SEQUENCE {\n              two    INTEGER OPTIONAL\n\
    \          }\n   The associated grammar is:\n      P1:  S ::= one S'\n      P2:\
    \  S' ::= one S'\n      P3:  S' ::=\n      P4:  one ::= two\n      P5:  two ::=\
    \ \"two\"\n      P6:  two ::=\n   This grammar leads to the following sets and\
    \ predicates:\n      First(P2) = { \"two\" }\n      First(P3) = { }\n      Preselected(P2)\
    \ = Preselected(P3) = false\n      Empty(P2) = Empty(P3) = true\n      Follow(S')\
    \ = { \"$\" }\n      Select(P2) = First(P2) + Follow(S') = { \"two\", \"$\" }\n\
    \      Select(P3) = First(P3) + Follow(S') = { \"$\" }\n      First(P5) = { \"\
    two\" }\n      First(P6) = { }\n      Preselected(P5) = Preselected(P6) = Empty(P5)\
    \ = false\n      Empty(P6) = true\n      Follow(two) = { \"two\", \"$\" }\n  \
    \    Select(P5) = First(P5) = { \"two\" }\n      Select(P6) = First(P6) + Follow(two)\
    \ = { \"two\", \"$\" }\n   The intersection of Select(P2) and Select(P3) is not\
    \ empty and the\n   intersection of Select(P5) and Select(P6) is not empty; hence,\
    \ the\n   grammar is not deterministic, and the type definition is not valid.\n\
    \   The encoding of a value of the type contains an indeterminate number\n   of\
    \ empty instances of the component type.\n"
- title: A.8.  Example 8
  contents:
  - "A.8.  Example 8\n   Consider the following type definition:\n      SEQUENCE OF\n\
    \          list [GROUP] SEQUENCE SIZE(1..MAX) OF number INTEGER\n   The associated\
    \ grammar is:\n      P1:  S ::= list S\n      P2:  S ::=\n      P3:  list ::=\
    \ number list'\n      P4:  list' ::= number list'\n      P5:  list' ::=\n    \
    \  P6:  number ::= \"number\"\n   This grammar leads to the following sets and\
    \ predicates:\n      First(P1) = { \"number\" }\n      First(P2) = { }\n     \
    \ Preselected(P1) = Preselected(P2) = Empty(P1) = false\n      Empty(P2) = true\n\
    \      Follow(S) = { \"$\" }\n      Select(P1) = First(P1) = { \"number\" }\n\
    \      Select(P2) = First(P2) + Follow(S) = { \"$\" }\n      First(P4) = { \"\
    number\" }\n      First(P5) = { }\n      Preselected(P4) = Preselected(P5) = Empty(P4)\
    \ = false\n      Empty(P5) = true\n      Follow(list') = { \"number\", \"$\" }\n\
    \      Select(P4) = First(P4) = { \"number\" }\n      Select(P5) = First(P5) +\
    \ Follow(list') = { \"number\", \"$\" }\n   The intersection of Select(P4) and\
    \ Select(P5) is not empty; hence,\n   the grammar is not deterministic, and the\
    \ type definition is not\n   valid.  The type describes a list of lists, but it\
    \ is not possible\n   for a decoder to determine where the outer lists begin and\
    \ end.\n"
- title: A.9.  Example 9
  contents:
  - "A.9.  Example 9\n   Consider the following type definition:\n      SEQUENCE OF\
    \ item [GROUP] SEQUENCE {\n          before  [GROUP] OneAndTwo,\n          core\
    \    UTF8String,\n          after   [GROUP] OneAndTwo OPTIONAL\n      }\n    \
    \  OneAndTwo ::= SEQUENCE {\n          non-core  UTF8String\n      }\n   The associated\
    \ grammar is:\n      P1:  S ::= item S\n      P2:  S ::=\n      P3:  item ::=\
    \ before core after\n      P4:  before ::= non-core\n      P5:  non-core ::= \"\
    non-core\"\n      P6:  core ::= \"core\"\n      P7:  after ::= non-core\n    \
    \  P8:  after ::=\n   This grammar leads to the following sets and predicates:\n\
    \      First(P1) = { \"non-core\" }\n      First(P2) = { }\n      Preselected(P1)\
    \ = Preselected(P2) = Empty(P1) = false\n      Empty(P2) = true\n      Follow(S)\
    \ = { \"$\" }\n      Select(P1) = First(P1) = { \"non-core\" }\n      Select(P2)\
    \ = First(P2) + Follow(S) = { \"$\" }\n      First(P7) = { \"non-core\" }\n  \
    \    First(P8) = { }\n      Preselected(P7) = Preselected(P8) = Empty(P7) = false\n\
    \      Empty(P8) = true\n      Follow(after) = { \"non-core\", \"$\" }\n     \
    \ Select(P7) = First(P7) = { \"non-core\" }\n      Select(P8) = First(P8) + Follow(after)\
    \ = { \"non-core\", \"$\" }\n   The intersection of Select(P7) and Select(P8)\
    \ is not empty; hence,\n   the grammar is not deterministic, and the type definition\
    \ is not\n   valid.  There is ambiguity between the end of one item and the start\n\
    \   of the next.  Without looking ahead in an encoding, it is not\n   possible\
    \ to determine whether a <non-core> element belongs with the\n   preceding or\
    \ following <core> element.\n"
- title: A.10.  Example 10
  contents:
  - "A.10.  Example 10\n   Consider the following type definition:\n      CHOICE {\n\
    \          one   [GROUP] List,\n          two   [GROUP] SEQUENCE {\n         \
    \     three  [ATTRIBUTE] UTF8String,\n              four   [GROUP] List\n    \
    \      }\n      }\n      List ::= SEQUENCE OF string UTF8String\n   The associated\
    \ grammar is:\n      P1:  S ::= one\n      P2:  S ::= two\n      P3:  one ::=\
    \ string one\n      P4:  one ::=\n      P5:  two ::= three four\n      P6:  three\
    \ ::= \"@three\"\n      P7:  four ::= string four\n      P8:  four ::=\n     \
    \ P9:  string ::= \"string\"\n   This grammar leads to the following sets and\
    \ predicates:\n      First(P1) = { \"string\" }\n      First(P2) = { \"string\"\
    \ }\n      Preselected(P1) = Empty(P2) = false\n      Preselected(P2) = Empty(P1)\
    \ = true\n      Follow(S) = { \"$\" }\n      Select(P1) = First(P1) + Follow(S)\
    \ = { \"string\", \"$\" }\n      Select(P2) = { }\n      First(P3) = { \"string\"\
    \ }\n      First(P4) = { }\n      Preselected(P3) = Preselected(P4) = Empty(P3)\
    \ = false\n      Empty(P4) = true\n      Follow(one) = { \"$\" }\n      Select(P3)\
    \ = First(P3) = { \"string\" }\n      Select(P4) = First(P4) + Follow(one) = {\
    \ \"$\" }\n      First(P7) = { \"string\" }\n      First(P8) = { }\n      Preselected(P7)\
    \ = Preselected(P8) = Empty(P7) = false\n      Empty(P8) = true\n      Follow(four)\
    \ = { \"$\" }\n      Select(P7) = First(P7) = { \"string\" }\n      Select(P8)\
    \ = First(P8) + Follow(four) = { \"$\" }\n   The intersection of Select(P1) and\
    \ Select(P2) is empty, as is the\n   intersection of Select(P3) and Select(P4)\
    \ and the intersection of\n   Select(P7) and Select(P8); hence, the grammar is\
    \ deterministic, and\n   the type definition is valid.  Although both alternatives\
    \ of the\n   CHOICE can begin with a <string> element, an RXER decoder would use\n\
    \   the presence of a \"three\" attribute to decide whether to select or\n   disregard\
    \ the \"two\" alternative.\n   However, an attribute in an extension cannot be\
    \ used to select\n   between alternatives.  Consider the following type definition:\n\
    \      [SINGULAR-INSERTIONS] CHOICE {\n          one   [GROUP] List,\n       \
    \   ...,\n          two   [GROUP] SEQUENCE {\n              three  [ATTRIBUTE]\
    \ UTF8String,\n              four   [GROUP] List\n          } -- ExtensionAdditionAlternative\
    \ (E1).\n          -- The extension insertion point is here (I1).\n      }\n \
    \     List ::= SEQUENCE OF string UTF8String\n   The associated grammar is:\n\
    \      P1:  S ::= one\n      P10: S ::= E1\n      P11: S ::= \"*\"\n      P12:\
    \ E1 ::= two\n      P3:  one ::= string one\n      P4:  one ::=\n      P5:  two\
    \ ::= three four\n      P6:  three ::= \"@three\"\n      P7:  four ::= string\
    \ four\n      P8:  four ::=\n      P9:  string ::= \"string\"\n   This grammar\
    \ leads to the following sets and predicates for P1, P10\n   and P11:\n      First(P1)\
    \ = { \"string\" }\n      First(P10) = { \"string\" }\n      First(P11) = { \"\
    *\" }\n      Preselected(P1) = Preselected(P10) = Preselected(P11) = false\n \
    \     Empty(P10) = Empty(P11) = false\n      Empty(P1) = true\n      Follow(S)\
    \ = { \"$\" }\n      Select(P1) = First(P1) + Follow(S) = { \"string\", \"$\"\
    \ }\n      Select(P10) = First(P10) = { \"string\" }\n      Select(P11) = First(P11)\
    \ = { \"*\" }\n   Preselected(P10) evaluates to false because Preselected(P10)\
    \ is\n   evaluated on the base grammar, wherein P10 is rewritten as:\n      P10:\
    \ S ::=\n   The intersection of Select(P1) and Select(P10) is not empty; hence,\n\
    \   the grammar is not deterministic, and the type definition is not\n   valid.\
    \  An RXER decoder using the original, unextended version of the\n   definition\
    \ would not know that the \"three\" attribute selects between\n   the \"one\"\
    \ alternative and the extension.\n"
- title: Appendix B.  Insertion Encoding Instruction Examples
  contents:
  - "Appendix B.  Insertion Encoding Instruction Examples\n   This appendix is non-normative.\n\
    \   This appendix contains examples showing the use of insertion encoding\n  \
    \ instructions to remove extension ambiguity arising from use of the\n   GROUP\
    \ encoding instruction.\n"
- title: B.1.  Example 1
  contents:
  - "B.1.  Example 1\n   Consider the following type definition:\n      SEQUENCE {\n\
    \          one    [GROUP] SEQUENCE {\n              two    UTF8String,\n     \
    \         ... -- Extension insertion point (I1).\n          },\n          three\
    \  INTEGER OPTIONAL,\n          ... -- Extension insertion point (I2).\n     \
    \ }\n   The associated grammar is:\n      P1:  S ::= one three I2\n      P2: \
    \ one ::= two I1\n      P3:  two ::= \"two\"\n      P4:  I1 ::= \"*\" I1\n   \
    \   P5:  I1 ::=\n      P6:  three ::= \"three\"\n      P7:  three ::=\n      P8:\
    \  I2 ::= \"*\" I2\n      P9:  I2 ::=\n   This grammar leads to the following\
    \ sets and predicates:\n      First(P4) = { \"*\" }\n      First(P5) = { }\n \
    \     Preselected(P4) = Preselected(P5) = Empty(P4) = false\n      Empty(P5) =\
    \ true\n      Follow(I1) = { \"three\", \"*\", \"$\" }\n      Select(P4) = First(P4)\
    \ = { \"*\" }\n      Select(P5) = First(P5) + Follow(I1) = { \"three\", \"*\"\
    , \"$\" }\n      First(P6) = { \"three\" }\n      First(P7) = { }\n      Preselected(P6)\
    \ = Preselected(P7) = Empty(P6) = false\n      Empty(P7) = true\n      Follow(three)\
    \ = { \"*\", \"$\" }\n      Select(P6) = First(P6) = { \"three\" }\n      Select(P7)\
    \ = First(P7) + Follow(three) = { \"*\", \"$\" }\n      First(P8) = { \"*\" }\n\
    \      First(P9) = { }\n      Preselected(P8) = Preselected(P9) = Empty(P8) =\
    \ false\n      Empty(P9) = true\n      Follow(I2) = { \"$\" }\n      Select(P8)\
    \ = First(P8) = { \"*\" }\n      Select(P9) = First(P9) + Follow(I2) = { \"$\"\
    \ }\n   The intersection of Select(P4) and Select(P5) is not empty; hence,\n \
    \  the grammar is not deterministic, and the type definition is not\n   valid.\
    \  If an RXER decoder encounters an unrecognized element\n   immediately after\
    \ a <two> element, then it will not know whether to\n   associate it with extension\
    \ insertion point I1 or I2.\n   The non-determinism can be resolved with either\
    \ a NO-INSERTIONS or\n   HOLLOW-INSERTIONS encoding instruction.  Consider this\
    \ revised type\n   definition:\n      SEQUENCE {\n          one    [GROUP] [HOLLOW-INSERTIONS]\
    \ SEQUENCE {\n              two    UTF8String,\n              ... -- Extension\
    \ insertion point (I1).\n          },\n          three  INTEGER OPTIONAL,\n  \
    \        ... -- Extension insertion point (I2).\n      }\n   The associated grammar\
    \ is:\n      P1:  S ::= one three I2\n      P10: one ::= two\n      P3:  two ::=\
    \ \"two\"\n      P6:  three ::= \"three\"\n      P7:  three ::=\n      P8:  I2\
    \ ::= \"*\" I2\n      P9:  I2 ::=\n   With the addition of the HOLLOW-INSERTIONS\
    \ encoding instruction, the\n   P4 and P5 productions are no longer generated,\
    \ and the conflict\n   between Select(P4) and Select(P5) no longer exists.  The\
    \ Select Sets\n   for P6, P7, P8, and P9 are unchanged.  A decoder will now assume\
    \ that\n   an unrecognized element is to be associated with extension insertion\n\
    \   point I2.  It is still free to associate an unrecognized attribute\n   with\
    \ either extension insertion point.  If a NO-INSERTIONS encoding\n   instruction\
    \ had been used, then an unrecognized attribute could only\n   be associated with\
    \ extension insertion point I2.\n   The non-determinism could also be resolved\
    \ by adding a NO-INSERTIONS\n   or HOLLOW-INSERTIONS encoding instruction to the\
    \ outer SEQUENCE:\n      [HOLLOW-INSERTIONS] SEQUENCE {\n          one    [GROUP]\
    \ SEQUENCE {\n              two    UTF8String,\n              ... -- Extension\
    \ insertion point (I1).\n          },\n          three  INTEGER OPTIONAL,\n  \
    \        ... -- Extension insertion point (I2).\n      }\n   The associated grammar\
    \ is:\n      P11: S ::= one three\n      P2:  one ::= two I1\n      P3:  two ::=\
    \ \"two\"\n      P4:  I1 ::= \"*\" I1\n      P5:  I1 ::=\n      P6:  three ::=\
    \ \"three\"\n      P7:  three ::=\n   This grammar leads to the following sets\
    \ and predicates:\n      First(P4) = { \"*\" }\n      First(P5) = { }\n      Preselected(P4)\
    \ = Preselected(P5) = Empty(P4) = false\n      Empty(P5) = true\n      Follow(I1)\
    \ = { \"three\", \"$\" }\n      Select(P4) = First(P4) = { \"*\" }\n      Select(P5)\
    \ = First(P5) + Follow(I1) = { \"three\", \"$\" }\n      First(P6) = { \"three\"\
    \ }\n      First(P7) = { }\n      Preselected(P6) = Preselected(P7) = Empty(P6)\
    \ = false\n      Empty(P7) = true\n      Follow(three) = { \"$\" }\n      Select(P6)\
    \ = First(P6) = { \"three\" }\n      Select(P7) = First(P7) + Follow(three) =\
    \ { \"$\" }\n   The intersection of Select(P4) and Select(P5) is empty, as is\
    \ the\n   intersection of Select(P6) and Select(P7); hence, the grammar is\n \
    \  deterministic, and the type definition is valid.  A decoder will now\n   assume\
    \ that an unrecognized element is to be associated with\n   extension insertion\
    \ point I1.  It is still free to associate an\n   unrecognized attribute with\
    \ either extension insertion point.  If a\n   NO-INSERTIONS encoding instruction\
    \ had been used, then an\n   unrecognized attribute could only be associated with\
    \ extension\n   insertion point I1.\n"
- title: B.2.  Example 2
  contents:
  - "B.2.  Example 2\n   Consider the following type definition:\n      SEQUENCE {\n\
    \          one  [GROUP] CHOICE {\n              two  UTF8String,\n           \
    \   ... -- Extension insertion point (I1).\n          } OPTIONAL\n      }\n  \
    \ The associated grammar is:\n      P1:  S ::= one\n      P2:  one ::= two\n \
    \     P3:  one ::= I1\n      P4:  one ::=\n      P5:  two ::= \"two\"\n      P6:\
    \  I1 ::= \"*\" I1\n      P7:  I1 ::=\n   This grammar leads to the following\
    \ sets and predicates:\n      First(P2) = { \"two\" }\n      First(P3) = { \"\
    *\" }\n      First(P4) = { }\n      Preselected(P2) = Preselected(P3) = Preselected(P4)\
    \ = false\n      Empty(P2) = false\n      Empty(P3) = Empty(P4) = true\n     \
    \ Follow(one) = { \"$\" }\n      Select(P2) = First(P2) = { \"two\" }\n      Select(P3)\
    \ = First(P3) + Follow(one) = { \"*\", \"$\" }\n      Select(P4) = First(P4) +\
    \ Follow(one) = { \"$\" }\n      First(P6) = { \"*\" }\n      First(P7) = { }\n\
    \      Preselected(P6) = Preselected(P7) = Empty(P6) = false\n      Empty(P7)\
    \ = true\n      Follow(I1) = { \"$\" }\n      Select(P6) = First(P6) = { \"*\"\
    \ }\n      Select(P7) = First(P7) + Follow(I1) = { \"$\" }\n   The intersection\
    \ of Select(P3) and Select(P4) is not empty; hence,\n   the grammar is not deterministic,\
    \ and the type definition is not\n   valid.  If the <two> element is not present,\
    \ then a decoder cannot\n   determine whether the \"one\" alternative is absent,\
    \ or present with an\n   unknown extension that generates no elements.\n   The\
    \ non-determinism can be resolved with either a\n   SINGULAR-INSERTIONS, UNIFORM-INSERTIONS,\
    \ or MULTIFORM-INSERTIONS\n   encoding instruction.  The MULTIFORM-INSERTIONS\
    \ encoding instruction\n   is the least restrictive.  Consider this revised type\
    \ definition:\n      SEQUENCE {\n          one  [GROUP] [MULTIFORM-INSERTIONS]\
    \ CHOICE {\n              two  UTF8String,\n              ... -- Extension insertion\
    \ point (I1).\n          } OPTIONAL\n      }\n   The associated grammar is:\n\
    \      P1:  S ::= one\n      P2:  one ::= two\n      P8:  one ::= \"*\" I1\n \
    \     P4:  one ::=\n      P5:  two ::= \"two\"\n      P6:  I1 ::= \"*\" I1\n \
    \     P7:  I1 ::=\n   This grammar leads to the following sets and predicates:\n\
    \      First(P2) = { \"two\" }\n      First(P8) = { \"*\" }\n      First(P4) =\
    \ { }\n      Preselected(P2) = Preselected(P8) = Preselected(P4) = false\n   \
    \   Empty(P2) = Empty(P8) = false\n      Empty(P4) = true\n      Follow(one) =\
    \ { \"$\" }\n      Select(P2) = First(P2) = { \"two\" }\n      Select(P8) = First(P8)\
    \ = { \"*\" }\n      Select(P4) = First(P4) + Follow(one) = { \"$\" }\n      First(P6)\
    \ = { \"*\" }\n      First(P7) = { }\n      Preselected(P6) = Preselected(P7)\
    \ = Empty(P6) = false\n      Empty(P7) = true\n      Follow(I1) = { \"$\" }\n\
    \      Select(P6) = First(P6) = { \"*\" }\n      Select(P7) = First(P7) + Follow(I1)\
    \ = { \"$\" }\n   The intersection of Select(P2) and Select(P8) is empty, as is\
    \ the\n   intersection of Select(P2) and Select(P4), the intersection of\n   Select(P8)\
    \ and Select(P4), and the intersection of Select(P6) and\n   Select(P7); hence,\
    \ the grammar is deterministic, and the type\n   definition is valid.  A decoder\
    \ will now assume the \"one\" alternative\n   is present if it sees at least one\
    \ unrecognized element, and absent\n   otherwise.\n"
- title: B.3.  Example 3
  contents:
  - "B.3.  Example 3\n   Consider the following type definition:\n      SEQUENCE {\n\
    \          one    [GROUP] CHOICE {\n              two    UTF8String,\n       \
    \       ... -- Extension insertion point (I1).\n          },\n          three\
    \  [GROUP] CHOICE {\n              four   UTF8String,\n              ... -- Extension\
    \ insertion point (I2).\n          }\n      }\n   The associated grammar is:\n\
    \      P1:  S ::= one three\n      P2:  one ::= two\n      P3:  one ::= I1\n \
    \     P4:  two ::= \"two\"\n      P5:  I1 ::= \"*\" I1\n      P6:  I1 ::=\n  \
    \    P7:  three ::= four\n      P8:  three ::= I2\n      P9:  four ::= \"four\"\
    \n      P10: I2 ::= \"*\" I2\n      P11: I2 ::=\n   This grammar leads to the\
    \ following sets and predicates:\n      First(P2) = { \"two\" }\n      First(P3)\
    \ = { \"*\" }\n      Preselected(P2) = Preselected(P3) = Empty(P2) = false\n \
    \     Empty(P3) = true\n      Follow(one) = { \"four\", \"*\", \"$\" }\n     \
    \ Select(P2) = First(P2) = { \"two\" }\n      Select(P3) = First(P3) + Follow(one)\
    \ = { \"*\", \"four\", \"$\" }\n      First(P5) = { \"*\" }\n      First(P6) =\
    \ { }\n      Preselected(P5) = Preselected(P6) = Empty(P5) = false\n      Empty(P6)\
    \ = true\n      Follow(I1) = { \"four\", \"*\", \"$\" }\n      Select(P5) = First(P5)\
    \ = { \"*\" }\n      Select(P6) = First(P6) + Follow(I1) = { \"four\", \"*\",\
    \ \"$\" }\n      First(P7) = { \"four\" }\n      First(P8) = { \"*\" }\n     \
    \ Preselected(P7) = Preselected(P8) = Empty(P7) = false\n      Empty(P8) = true\n\
    \      Follow(three) = { \"$\" }\n      Select(P7) = First(P7) = { \"four\" }\n\
    \      Select(P8) = First(P8) + Follow(three) = { \"*\", \"$\" }\n      First(P10)\
    \ = { \"*\" }\n      First(P11) = { }\n      Preselected(P10) = Preselected(P11)\
    \ = Empty(P10) = false\n      Empty(P11) = true\n      Follow(I2) = { \"$\" }\n\
    \      Select(P10) = First(P10) = { \"*\" }\n      Select(P11) = First(P11) +\
    \ Follow(I2) = { \"$\" }\n   The intersection of Select(P5) and Select(P6) is\
    \ not empty; hence,\n   the grammar is not deterministic, and the type definition\
    \ is not\n   valid.  If the first child element is an unrecognized element, then\
    \ a\n   decoder cannot determine whether to associate it with extension\n   insertion\
    \ point I1, or to associate it with extension insertion point\n   I2 by assuming\
    \ that the \"one\" component has an unknown extension that\n   generates no elements.\n\
    \   The non-determinism can be resolved with either a SINGULAR-INSERTIONS\n  \
    \ or UNIFORM-INSERTIONS encoding instruction.  Consider this revised\n   type\
    \ definition using the SINGULAR-INSERTIONS encoding instruction:\n      SEQUENCE\
    \ {\n          one    [GROUP] [SINGULAR-INSERTIONS] CHOICE {\n              two\
    \    UTF8String,\n              ... -- Extension insertion point (I1).\n     \
    \     },\n          three  [GROUP] CHOICE {\n              four   UTF8String,\n\
    \              ... -- Extension insertion point (I2).\n          }\n      }\n\
    \   The associated grammar is:\n      P1:  S ::= one three\n      P2:  one ::=\
    \ two\n      P12: one ::= \"*\"\n      P4:  two ::= \"two\"\n      P7:  three\
    \ ::= four\n      P8:  three ::= I2\n      P9:  four ::= \"four\"\n      P10:\
    \ I2 ::= \"*\" I2\n      P11: I2 ::=\n   With the addition of the SINGULAR-INSERTIONS\
    \ encoding instruction,\n   the P5 and P6 productions are no longer generated.\
    \  The grammar leads\n   to the following sets and predicates for the P2 and P12\
    \ productions:\n      First(P2) = { \"two\" }\n      First(P12) = { \"*\" }\n\
    \      Preselected(P2) = Preselected(P12) = false\n      Empty(P2) = Empty(P12)\
    \ = false\n      Follow(one) = { \"four\", \"*\", \"$\" }\n      Select(P2) =\
    \ First(P2) = { \"two\" }\n      Select(P12) = First(P12) = { \"*\" }\n   The\
    \ sets for P5 and P6 are no longer generated, and the remaining\n   sets are unchanged.\n\
    \   The intersection of Select(P2) and Select(P12) is empty, as is the\n   intersection\
    \ of Select(P7) and Select(P8) and the intersection of\n   Select(P10) and Select(P11);\
    \ hence, the grammar is deterministic, and\n   the type definition is valid. \
    \ If the first child element is an\n   unrecognized element, then a decoder will\
    \ now assume that it is\n   associated with extension insertion point I1.  Whatever\
    \ follows,\n   possibly including another unrecognized element, will belong to\
    \ the\n   \"three\" component.\n   Now consider the type definition using the\
    \ UNIFORM-INSERTIONS\n   encoding instruction instead:\n      SEQUENCE {\n   \
    \       one    [GROUP] [UNIFORM-INSERTIONS] CHOICE {\n              two    UTF8String,\n\
    \              ... -- Extension insertion point (I1).\n          },\n        \
    \  three  [GROUP] CHOICE {\n              four   UTF8String,\n              ...\
    \ -- Extension insertion point (I2).\n          }\n      }\n   The associated\
    \ grammar is:\n      P1:  S ::= one three\n      P2:  one ::= two\n      P13:\
    \ one ::= \"*\"\n      P14: one ::= \"*1\" I1\n      P4:  two ::= \"two\"\n  \
    \    P15: I1 ::= \"*1\" I1\n      P6:  I1 ::=\n      P7:  three ::= four\n   \
    \   P8:  three ::= I2\n      P9:  four ::= \"four\"\n      P10: I2 ::= \"*\" I2\n\
    \      P11: I2 ::=\n   This grammar leads to the following sets and predicates\
    \ for the P2,\n   P13, P14, P15, and P6 productions:\n      First(P2) = { \"two\"\
    \ }\n      First(P13) = { \"*\" }\n      First(P14) = { \"*1\" }\n      Preselected(P2)\
    \ = Preselected(P13) = Preselected(P14) = false\n      Empty(P2) = Empty(P13)\
    \ = Empty(P14) = false\n      Follow(one) = { \"four\", \"*\", \"$\" }\n     \
    \ Select(P2) = First(P2) = { \"two\" }\n      Select(P13) = First(P13) = { \"\
    *\" }\n      Select(P14) = First(P14) = { \"*1\" }\n      First(P15) = { \"*1\"\
    \ }\n      First(P6) = { }\n      Preselected(P15) = Preselected(P6) = Empty(P15)\
    \ = false\n      Empty(P6) = true\n      Follow(I1) = { \"four\", \"*\", \"$\"\
    \ }\n      Select(P15) = First(P15) = { \"*1\" }\n      Select(P6) = First(P6)\
    \ + Follow(I1) = { \"four\", \"*\", \"$\" }\n   The remaining sets are unchanged.\n\
    \   The intersection of Select(P2) and Select(P13) is empty, as is the\n   intersection\
    \ of Select(P2) and Select(P14), the intersection of\n   Select(P13) and Select(P14)\
    \ and the intersection of Select(P15) and\n   Select(P6); hence, the grammar is\
    \ deterministic, and the type\n   definition is valid.  If the first child element\
    \ is an unrecognized\n   element, then a decoder will now assume that it and every\
    \ subsequent\n   unrecognized element with the same name are associated with I1.\n\
    \   Whatever follows, possibly including another unrecognized element\n   with\
    \ a different name, will belong to the \"three\" component.\n   A consequence\
    \ of using the UNIFORM-INSERTIONS encoding instruction is\n   that any future\
    \ extension to the \"three\" component will be required\n   to generate elements\
    \ with names that are different from the names of\n   the elements generated by\
    \ the \"one\" component.  With the\n   SINGULAR-INSERTIONS encoding instruction,\
    \ extensions to the \"three\"\n   component are permitted to generate elements\
    \ with names that are the\n   same as the names of the elements generated by the\
    \ \"one\" component.\n"
- title: B.4.  Example 4
  contents:
  - "B.4.  Example 4\n   Consider the following type definition:\n      SEQUENCE OF\
    \ one [GROUP] CHOICE {\n          two    UTF8String,\n          ... -- Extension\
    \ insertion point (I1).\n      }\n   The associated grammar is:\n      P1:  S\
    \ ::= one S\n      P2:  S ::=\n      P3:  one ::= two\n      P4:  one ::= I1\n\
    \      P5:  two ::= \"two\"\n      P6:  I1 ::= \"*\" I1\n      P7:  I1 ::=\n \
    \  This grammar leads to the following sets and predicates:\n      First(P1) =\
    \ { \"two\", \"*\" }\n      First(P2) = { }\n      Preselected(P1) = Preselected(P2)\
    \ = false\n      Empty(P1) = Empty(P2) = true\n      Follow(S) = { \"$\" }\n \
    \     Select(P1) = First(P1) + Follow(S) = { \"two\", \"*\", \"$\" }\n      Select(P2)\
    \ = First(P2) + Follow(S) = { \"$\" }\n      First(P3) = { \"two\" }\n      First(P4)\
    \ = { \"*\" }\n      Preselected(P3) = Preselected(P4) = Empty(P3) = false\n \
    \     Empty(P4) = true\n      Follow(one) = { \"two\", \"*\", \"$\" }\n      Select(P3)\
    \ = First(P3) = { \"two\" }\n      Select(P4) = First(P4) + Follow(one) = { \"\
    *\", \"two\", \"$\" }\n      First(P6) = { \"*\" }\n      First(P7) = { }\n  \
    \    Preselected(P6) = Preselected(P7) = Empty(P6) = false\n      Empty(P7) =\
    \ true\n      Follow(I1) = { \"two\", \"*\", \"$\" }\n      Select(P6) = First(P6)\
    \ = { \"*\" }\n      Select(P7) = First(P7) + Follow(I1) = { \"two\", \"*\", \"\
    $\" }\n   The intersection of Select(P1) and Select(P2) is not empty, as is the\n\
    \   intersection of Select(P3) and Select(P4) and the intersection of\n   Select(P6)\
    \ and Select(P7); hence, the grammar is not deterministic,\n   and the type definition\
    \ is not valid.  If a decoder encounters two or\n   more unrecognized elements\
    \ in a row, then it cannot determine whether\n   this represents one instance\
    \ or more than one instance of the \"one\"\n   component.  Even without unrecognized\
    \ elements, there is still a\n   problem that an encoding could contain an indeterminate\
    \ number of\n   \"one\" components using an extension that generates no elements.\n\
    \   The non-determinism cannot be resolved with a UNIFORM-INSERTIONS\n   encoding\
    \ instruction.  Consider this revised type definition using\n   the UNIFORM-INSERTIONS\
    \ encoding instruction:\n      SEQUENCE OF one [GROUP] [UNIFORM-INSERTIONS] CHOICE\
    \ {\n          two    UTF8String,\n          ... -- Extension insertion point\
    \ (I1).\n      }\n   The associated grammar is:\n      P1:  S ::= one S\n    \
    \  P2:  S ::=\n      P3:  one ::= two\n      P8:  one ::= \"*\"\n      P9:  one\
    \ ::= \"*1\" I1\n      P5:  two ::= \"two\"\n      P10: I1 ::= \"*1\" I1\n   \
    \   P7:  I1 ::=\n   This grammar leads to the following sets and predicates:\n\
    \      First(P1) = { \"two\", \"*\", \"*1\" }\n      First(P2) = { }\n      Preselected(P1)\
    \ = Preselected(P2) = Empty(P1) = false\n      Empty(P2) = true\n      Follow(S)\
    \ = { \"$\" }\n      Select(P1) = First(P1) = { \"two\", \"*\", \"*1\" }\n   \
    \   Select(P2) = First(P2) + Follow(S) = { \"$\" }\n      First(P3) = { \"two\"\
    \ }\n      First(P8) = { \"*\" }\n      First(P9) = { \"*1\" }\n      Preselected(P3)\
    \ = Preselected(P8) = Preselected(P9) = false\n      Empty(P3) = Empty(P8) = Empty(P9)\
    \ = false\n      Follow(one) = { \"two\", \"*\", \"*1\", \"$\" }\n      Select(P3)\
    \ = First(P3) = { \"two\" }\n      Select(P8) = First(P8) = { \"*\" }\n      Select(P9)\
    \ = First(P9) = { \"*1\" }\n      First(P10) = { \"*1\" }\n      First(P7) = {\
    \ }\n      Preselected(P10) = Preselected(P7) = Empty(P10) = false\n      Empty(P7)\
    \ = true\n      Follow(I1) = { \"two\", \"*\", \"*1\", \"$\" }\n      Select(P10)\
    \ = First(P10) = { \"*1\" }\n      Select(P7) = First(P7) + Follow(I1) = { \"\
    two\", \"*\", \"*1\", \"$\" }\n   The intersection of Select(P1) and Select(P2)\
    \ is now empty, but the\n   intersection of Select(P10) and Select(P7) is not;\
    \ hence, the grammar\n   is not deterministic, and the type definition is not\
    \ valid.  The\n   problem of an indeterminate number of \"one\" components from\
    \ an\n   extension that generates no elements has been solved.  However, if a\n\
    \   decoder encounters a series of elements with the same name, it cannot\n  \
    \ determine whether this represents one instance or more than one\n   instance\
    \ of the \"one\" component.\n   The non-determinism can be fully resolved with\
    \ a SINGULAR-INSERTIONS\n   encoding instruction.  Consider this revised type\
    \ definition:\n      SEQUENCE OF one [GROUP] [SINGULAR-INSERTIONS] CHOICE {\n\
    \          two    UTF8String,\n          ... -- Extension insertion point (I1).\n\
    \      }\n   The associated grammar is:\n      P1:  S ::= one S\n      P2:  S\
    \ ::=\n      P3:  one ::= two\n      P8:  one ::= \"*\"\n      P5:  two ::= \"\
    two\"\n   This grammar leads to the following sets and predicates:\n      First(P1)\
    \ = { \"two\", \"*\" }\n      First(P2) = { }\n      Preselected(P1) = Preselected(P2)\
    \ = Empty(P1) = false\n      Empty(P2) = true\n      Follow(S) = { \"$\" }\n \
    \     Select(P1) = First(P1) = { \"two\", \"*\" }\n      Select(P2) = First(P2)\
    \ + Follow(S) = { \"$\" }\n      First(P3) = { \"two\" }\n      First(P8) = {\
    \ \"*\" }\n      Preselected(P3) = Preselected(P8) = false\n      Empty(P3) =\
    \ Empty(P8) = false\n      Follow(one) = { \"two\", \"*\", \"$\" }\n      Select(P3)\
    \ = First(P3) = { \"two\" }\n      Select(P8) = First(P8) = { \"*\" }\n   The\
    \ intersection of Select(P1) and Select(P2) is empty, as is the\n   intersection\
    \ of Select(P3) and Select(P8); hence, the grammar is\n   deterministic, and the\
    \ type definition is valid.  A decoder now knows\n   that every extension to the\
    \ \"one\" component will generate a single\n   element, so the correct number\
    \ of \"one\" components will be decoded.\n"
- title: Appendix C.  Extension and Versioning Examples
  contents:
  - "Appendix C.  Extension and Versioning Examples\n   This appendix is non-normative.\n"
- title: C.1.  Valid Extensions for Insertion Encoding Instructions
  contents:
  - "C.1.  Valid Extensions for Insertion Encoding Instructions\n   The first example\
    \ shows extensions that satisfy the HOLLOW-INSERTIONS\n   encoding instruction.\n\
    \      [HOLLOW-INSERTIONS] CHOICE {\n          one    BOOLEAN,\n          ...,\n\
    \          two    [ATTRIBUTE] INTEGER,\n          three  [GROUP] SEQUENCE {\n\
    \              four  [ATTRIBUTE] UTF8String,\n              five  [ATTRIBUTE]\
    \ INTEGER OPTIONAL,\n              ...\n          },\n          six    [GROUP]\
    \ CHOICE {\n              seven  [ATTRIBUTE] BOOLEAN,\n              eight  [ATTRIBUTE]\
    \ INTEGER\n          }\n      }\n   The \"two\" and \"six\" components generate\
    \ only attributes.\n   The \"three\" component in its current form does not generate\
    \ elements.\n   Any extension to the \"three\" component will need to do likewise\
    \ to\n   avoid breaking forward compatibility.\n   The second example shows extensions\
    \ that satisfy the\n   SINGULAR-INSERTIONS encoding instruction.\n      [SINGULAR-INSERTIONS]\
    \ CHOICE {\n          one    BOOLEAN,\n          ...,\n          two    INTEGER,\n\
    \          three  [GROUP] SEQUENCE {\n              four   [ATTRIBUTE] UTF8String,\n\
    \              five   INTEGER\n          },\n          six    [GROUP] CHOICE {\n\
    \              seven  BOOLEAN,\n              eight  INTEGER\n          }\n  \
    \    }\n   The \"two\" component will always generate a single <two> element.\n\
    \   The \"three\" component will always generate a single <five> element.\n  \
    \ It will also generate a \"four\" attribute, but any number of\n   attributes\
    \ is allowed by the SINGULAR-INSERTIONS encoding\n   instruction.\n   The \"six\"\
    \ component will either generate a single <seven> element or\n   a single <eight>\
    \ element.  Either case will satisfy the requirement\n   that there will be a\
    \ single element in any given encoding of the\n   extension.\n   The third example\
    \ shows extensions that satisfy the\n   UNIFORM-INSERTIONS encoding instruction.\n\
    \      [UNIFORM-INSERTIONS] CHOICE {\n          one    BOOLEAN,\n          ...,\n\
    \          two    INTEGER,\n          three  [GROUP] SEQUENCE SIZE(1..MAX) OF\
    \ four INTEGER,\n          five   [GROUP] SEQUENCE {\n              six    [ATTRIBUTE]\
    \ UTF8String OPTIONAL,\n              seven  INTEGER\n          },\n         \
    \ eight  [GROUP] CHOICE {\n              nine   BOOLEAN,\n              ten  \
    \  [GROUP] SEQUENCE SIZE(1..MAX) OF eleven INTEGER\n          }\n      }\n   The\
    \ \"two\" component will always generate a single <two> element.\n   The \"three\"\
    \ component will always generate one or more <four>\n   elements.\n   The \"five\"\
    \ component will always generate a single <seven> element.\n   It may also generate\
    \ a \"six\" attribute, but any number of attributes\n   is allowed by the UNIFORM-INSERTIONS\
    \ encoding instruction.\n   The \"eight\" component will either generate a single\
    \ <nine> element or\n   one or more <eleven> elements.  Either case will satisfy\
    \ the\n   requirement that there must be one or more elements with the same\n\
    \   name in any given encoding of the extension.\n"
- title: C.2.  Versioning Example
  contents:
  - "C.2.  Versioning Example\n   Making extensions that are not forward compatible\
    \ is permitted\n   provided that the incompatibility is signalled with a version\n\
    \   indicator attribute.\n   Suppose that version 1.0 of a specification contains\
    \ the following\n   type definition:\n      MyMessageType ::= SEQUENCE {\n   \
    \      version  [ATTRIBUTE] [VERSION-INDICATOR]\n                      UTF8String\
    \ (\"1.0\", ...) DEFAULT \"1.0\",\n         one      [GROUP] [SINGULAR-INSERTIONS]\
    \ CHOICE {\n             two  BOOLEAN,\n             ...\n         },\n      \
    \   ...\n      }\n   An attribute is to be added to the CHOICE for version 1.1.\
    \  This\n   change is not forward compatible since it does not satisfy the\n \
    \  SINGULAR-INSERTIONS encoding instruction.  Therefore, the version\n   indicator\
    \ attribute must be updated at the same time (or added if it\n   wasn't already\
    \ present).  This results in the following new type\n   definition for version\
    \ 1.1:\n      MyMessageType ::= SEQUENCE {\n         version  [ATTRIBUTE] [VERSION-INDICATOR]\n\
    \                      UTF8String (\"1.0\", ..., \"1.1\") DEFAULT \"1.0\",\n \
    \        one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {\n             two   \
    \ BOOLEAN,\n             ...,\n             three  [ATTRIBUTE] INTEGER -- Added\
    \ in Version 1.1\n         },\n         ...\n      }\n   If a version 1.1 conformant\
    \ application hasn't used the version 1.1\n   extension in a value of MyMessageType,\
    \ then it is allowed to set the\n   value of the version attribute to \"1.0\"\
    .\n   A pair of elements is added to the CHOICE for version 1.2.  Again the\n\
    \   change does not satisfy the SINGULAR-INSERTIONS encoding instruction.\n  \
    \ The type definition for version 1.2 is:\n      MyMessageType ::= SEQUENCE {\n\
    \         version  [ATTRIBUTE] [VERSION-INDICATOR]\n                      UTF8String\
    \ (\"1.0\", ..., \"1.1\" | \"1.2\")\n                          DEFAULT \"1.0\"\
    ,\n         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {\n             two\
    \    BOOLEAN,\n             ...,\n             three  [ATTRIBUTE] INTEGER, --\
    \ Added in Version 1.1\n             four   [GROUP] SEQUENCE {\n             \
    \    five  UTF8String,\n                 six   GeneralizedTime\n             }\
    \ -- Added in version 1.2\n         },\n         ...\n      }\n   If a version\
    \ 1.2 conformant application hasn't used the version 1.2\n   extension in a value\
    \ of MyMessageType, then it is allowed to set the\n   value of the version attribute\
    \ to \"1.1\".  If it hasn't used either of\n   the extensions, then it is allowed\
    \ to set the value of the version\n   attribute to \"1.0\".\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Dr. Steven Legg\n   eB2Bcom\n   Suite 3, Woodhouse Corporate\
    \ Centre\n   935 Station Street\n   Box Hill North, Victoria 3129\n   AUSTRALIA\n\
    \   Phone: +61 3 9896 7830\n   Fax:   +61 3 9896 7801\n   EMail: steven.legg@eb2bcom.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
