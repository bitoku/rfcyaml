- title: __initial_text__
  contents:
  - '         The RC5, RC5-CBC, RC5-CBC-Pad, and RC5-CTS Algorithms

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   We would like to thank Steve Dusse, Victor Chang, Tim Mathews,\
    \ Brett\n   Howard, and Burt Kaliski for helpful suggestions.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n     7.        Description of RC5-CBC and RC5-CBC-Pad .. 12\n"
- title: 1.  Executive Summary
  contents:
  - "1.  Executive Summary\n   This document defines four ciphers with enough detail\
    \ to ensure\n   interoperability between different implementations.  The first\
    \ cipher\n   is the raw RC5 block cipher.  The RC5 cipher takes a fixed size input\n\
    \   block and produces a fixed sized output block using a transformation\n   that\
    \ depends on a key.  The second cipher, RC5-CBC, is the Cipher\n   Block Chaining\
    \ (CBC) mode for RC5.  It can process messages whose\n   length is a multiple\
    \ of the RC5 block size.  The third cipher, RC5-\n   CBC-Pad, handles plaintext\
    \ of any length, though the ciphertext will\n   be longer than the plaintext by\
    \ at most the size of a single RC5\n   block.  The RC5-CTS cipher is the Cipher\
    \ Text Stealing mode of RC5,\n   which handles plaintext of any length and the\
    \ ciphertext length\n   matches the plaintext length.\n   The RC5 cipher was invented\
    \ by Professor Ronald L. Rivest of the\n   Massachusetts Institute of Technology\
    \ in 1994.  It is a very fast and\n   simple algorithm that is parameterized by\
    \ the block size, the number\n   of rounds, and key length.  These parameters\
    \ can be adjusted to meet\n   different goals for security, performance, and exportability.\n\
    \   RSA Data Security Incorporated has filed a patent application on the\n   RC5\
    \ cipher and for trademark protection for RC5, RC5-CBC, RC5-CBC-\n   Pad, RC5-CTS\
    \ and assorted variations.\n"
- title: 2.  Overview
  contents:
  - "2.  Overview\n   This memo is a restatement of existing published material. \
    \ The\n   description of RC5 follows the notation and order of explanation\n \
    \  found in the original RC5 paper by Professor Rivest [2].  The CBC\n   mode\
    \ appears in reference works such as the one by Bruce Schneier\n   [6].  The CBC-Pad\
    \ mode is the same as in the Public Key Cryptography\n   Standard (PKCS) number\
    \ five [5].  Sample C code [8] is included for\n   clarity only and is equivalent\
    \ to the English language descriptions.\n   The ciphers will be explained in a\
    \ bottom up object-oriented fashion.\n   First, RC5 keys will be presented along\
    \ with the key expansion\n   algorithm.  Second, the RC5 block cipher is explained,\
    \ and finally,\n   the RC5-CBC and RC5-CBC-Pad ciphers are specified.  For brevity,\
    \ only\n   the encryption process is described.  Decryption is achieved by\n \
    \  inverting the steps of encryption.\n   The object-oriented description found\
    \ here should make it easier to\n   implement interoperable systems, though it\
    \ is not as terse as the\n   functional descriptions found in the references.\
    \  There are two\n   classes of objects, keys and cipher algorithms.  Both classes\
    \ share\n   operations that create and destroy these objects in a manner that\n\
    \   ensures that secret information is not returned to the memory\n   manager.\n\
    \   Keys also have a \"set\" operation that copies a secret key into the\n   object.\
    \  The \"set\" operation for the cipher objects defines the\n   number of rounds,\
    \ and the initialization vector.\n   There are four operations for the cipher\
    \ objects described in this\n   memo.  There is binding a key to a cipher object,\
    \ setting a new\n   initialization vector for a cipher object without changing\
    \ the key,\n   encrypting part of a message (this would be performed multiple\
    \ times\n   for long messages), and processing the last part of a message which\n\
    \   may add padding or check the length of the message.\n   In summary, the cipher\
    \ will be explained in terms of these\n   operations:\n   RC5_Key_Create     \
    \      - Create a key object.\n   RC5_Key_Destroy          - Destroy a key object.\n\
    \   RC5_Key_Set              - Bind a user key to a key object.\n   RC5_CBC_Create\
    \           - Create a cipher object.\n   RC5_CBC_Destroy          - Destroy a\
    \ cipher object.\n   RC5_CBC_Encrypt_Init     - Bind a key object to a cipher\
    \ object.\n   RC5_CBC_SetIV            - Set a new IV without changing the key.\n\
    \   RC5_CBC_Encrypt_Update   - Process part of a message.\n   RC5_CBC_Encrypt_Final\
    \    - Process the end of a message.\n"
- title: 3.  Terminology and Notation
  contents:
  - "3.  Terminology and Notation\n   The term \"word\" refers to a string of bits\
    \ of a particular length\n   that can be operated on as either an unsigned integer\
    \ or as a bit\n   vector.  For example a \"word\" might be 32 or 64 bits long\
    \ depending\n   on the desired block size for the RC5 cipher.  A 32 bit word will\n\
    \   produce a 64 bit block size.  For best performance the RC5 word size\n   should\
    \ match the register size of the CPU.  The term \"byte\" refers to\n   eight bits.\n\
    \   The following variables will be used throughout this memo with these\n   meanings:\n\
    \  W  This is the word size for RC5 measured in bits.  It is half the\n      block\
    \ size.  The word sizes covered by this memo are 32 and 64.\n  WW This is the\
    \ word size for RC5 measured in bytes.\n  B  This is the block size for RC5 measured\
    \ in bits.  It is twice\n      the word size.  When RC5 is used as a 64 bit block\
    \ cipher, B is\n      64 and W is 32. 0 < B < 257.  In the sample code, B, is\
    \ used as\n      a variable instead of a cipher system parameter, but this usage\n\
    \      should be obvious from context.\n  BB This is the block size for RC5 measured\
    \ in bytes.  BB = B / 8.\n  b  This is the byte length of the secret key.  0 <=\
    \ b < 256.\n  K  This is the secret key which is treated as a sequence of b\n\
    \      bytes indexed by: K[0], ..., K[b-1].\n  R  This is the number of rounds\
    \ of the inner RC5 transform.\n      0 <= R < 256.\n  T  This is the number of\
    \ words in the expanded key table.  It is\n      always 2*(R + 1).  1 < T < 513.\n\
    \  S  This is the expanded key table which is treated as a sequence\n      of\
    \ words indexed by: S[0], ..., S[T-1].\n  N  This is the byte length of the plaintext\
    \ message.\n  P  This is the plaintext message which is treated as a sequence\
    \ of\n      N bytes indexed by: P[0], ..., P[N-1].\n  C  This is the ciphertext\
    \ output which is treated as a sequence of\n      bytes indexed by: C[0], C[1],\
    \ ...\n  I  This is the initialization vector for the CBC mode which is\n    \
    \  treated as a sequence of bytes indexed by: I[0], ..., I[BB-1].\n"
- title: 4.  Description of RC5 Keys
  contents:
  - "4.  Description of RC5 Keys\n   Like most block ciphers, RC5 expands a small\
    \ user key into a table of\n   internal keys.  The byte length of the user key\
    \ is one of the\n   parameters of the cipher, so the RC5 user key object must\
    \ be able to\n   hold variable length keys.  A possible structure for this in\
    \ C is:\n  /* Definition of RC5 user key object. */\n  typedef struct rc5UserKey\n\
    \  {\n    int          keyLength; /* In Bytes. */\n    unsigned char   *keyBytes;\n\
    \  } rc5UserKey;\n   The basic operations on a key are to create, destroy and\
    \ set.  To\n   avoid exposing key material to other parts of an application, the\n\
    \   destroy operation zeros the memory allocated for the key before\n   releasing\
    \ it to the memory manager.  A general key object may support\n   other operations\
    \ such as generating a new random key and deriving a\n   key from key-agreement\
    \ information.\n"
- title: 4.1 Creating an RC5 Key
  contents:
  - "4.1 Creating an RC5 Key\n   To create a key, the memory for the key object must\
    \ be allocated and\n   initialized.  The C code below assumes that a function\
    \ called\n   \"malloc\" will return a block of uninitialized memory from the heap,\n\
    \   or zero indicating an error.\n  /* Allocate and initialize an RC5 user key.\n\
    \   * Return 0 if problems.\n   */\n  rc5UserKey *RC5_Key_Create ()\n  {\n   \
    \ rc5UserKey *pKey;\n    pKey = (rc5UserKey *) malloc (sizeof(*pKey));\n    if\
    \ (pKey != ((rc5UserKey *) 0))\n    {\n        pKey->keyLength = 0;\n        pKey->keyBytes\
    \ = (unsigned char *) 0;\n    }\n    return (pKey);\n  }\n"
- title: 4.2 Destroying an RC5 Key
  contents:
  - "4.2 Destroying an RC5 Key\n   To destroy a key, the memory must be zeroed and\
    \ released to the\n   memory manager.  The C code below assumes that a function\
    \ called\n   \"free\" will return a block of memory to the heap.\n  /* Zero and\
    \ free an RC5 user key.\n   */\n  void RC5_Key_Destroy (pKey)\n    rc5UserKey\
    \      *pKey;\n  {\n    unsigned char   *to;\n    int          count;\n    if\
    \ (pKey == ((rc5UserKey *) 0))\n        return;\n    if (pKey->keyBytes == ((unsigned\
    \ char *) 0))\n        return;\n    to = pKey->keyBytes;\n    for (count = 0 ;\
    \ count < pKey->keyLength ; count++)\n        *to++ = (unsigned char) 0;\n   \
    \ free (pKey->keyBytes);\n    pKey->keyBytes = (unsigned char *) 0;\n    pKey->keyLength\
    \ = 0;\n    free (pKey);\n  }\n"
- title: 4.3 Setting an RC5 Key
  contents:
  - "4.3 Setting an RC5 Key\n   Setting the key object makes a copy of the secret\
    \ key into a block of\n   memory allocated from the heap.\n  /* Set the value\
    \ of an RC5 user key.\n   * Copy the key bytes so the caller can zero and\n  \
    \ * free the original.\n   * Return zero if problems\n   */\n  int RC5_Key_Set\
    \ (pKey, keyLength, keyBytes)\n    rc5UserKey  *pKey;\n    int          keyLength;\n\
    \    unsigned char   *keyBytes;\n  {\n    unsigned char   *keyBytesCopy;\n   \
    \ unsigned char   *from, *to;\n    int          count;\n    keyBytesCopy = (unsigned\
    \ char *) malloc (keyLength);\n    if (keyBytesCopy == ((unsigned char *) 0))\n\
    \        return (0);\n    from = keyBytes;\n    to = keyBytesCopy;\n    for (count\
    \ = 0 ; count < keyLength ; count++)\n        *to++ = *from++;\n    pKey->keyLength\
    \ = count;\n    pKey->keyBytes = keyBytesCopy;\n    return (1);\n  }\n"
- title: 5.  Description of RC5 Key Expansion
  contents:
  - "5.  Description of RC5 Key Expansion\n   This section describes the key expansion\
    \ algorithm.  To be specific,\n   the sample code assumes that the block size\
    \ is 64 bits.  Several\n   programming parameters depend on the block size.\n\
    \  /* Definitions for RC5 as a 64 bit block cipher. */\n  /* The \"unsigned int\"\
    \ will be 32 bits on all but */\n  /* the oldest compilers, which will make it\
    \ 16 bits. */\n  /* On a DEC Alpha \"unsigned long\" is 64 bits, not 32. */\n\
    \  #define RC5_WORD     unsigned int\n  #define W            (32)\n  #define WW\
    \           (W / 8)\n  #define ROT_MASK     (W - 1)\n  #define BB           ((2\
    \ * W) / 8) /* Bytes per block */\n  /* Define macros used in multiple procedures.\
    \ */\n  /* These macros assumes \">>\" is an unsigned operation, */\n  /* and\
    \ that x and s are of type RC5_WORD. */\n  #define SHL(x,s)    ((RC5_WORD)((x)<<((s)&ROT_MASK)))\n\
    \  #define SHR(x,s,w)  ((RC5_WORD)((x)>>((w)-((s)&ROT_MASK))))\n  #define ROTL(x,s,w)\
    \ ((RC5_WORD)(SHL((x),(s))|SHR((x),(s),(w))))\n"
- title: 5.1 Definition of initialization constants
  contents:
  - "5.1 Definition of initialization constants\n   Two constants, Pw and Qw, are\
    \ defined for any word size W by the\n   expressions:\n        Pw = Odd((e-2)*2**W)\n\
    \        Qw = Odd((phi-1)*2**W)\n   where e is the base of the natural logarithm\
    \ (2.71828 ...), and phi\n   is the golden ratio (1.61803 ...), and 2**W is 2\
    \ raised to the power\n   of W, and Odd(x) is equal to x if x is odd, or equal\
    \ to x plus one if\n   x is even.  For W equal to 16, 32, and 64, the Pw and Qw\
    \ constants\n   are the following hexadecimal values:\n  #define P16  0xb7e1\n\
    \  #define Q16  0x9e37\n  #define P32  0xb7e15163\n  #define Q32  0x9e3779b9\n\
    \  #define P64  0xb7e151628aed2a6b\n  #define Q64  0x9e3779b97f4a7c15\n  #if W\
    \ == 16\n  #define Pw   P16 /* Select 16 bit word size */\n  #define Qw   Q16\n\
    \  #endif\n  #if W == 32\n  #define Pw   P32 /* Select 32 bit word size */\n \
    \ #define Qw   Q32\n  #endif\n  #if W == 64\n  #define Pw   P64 /* Select 64 bit\
    \ word size */\n  #define Qw   Q64\n  #endif\n"
- title: 5.2 Interface definition
  contents:
  - "5.2 Interface definition\n   The key expansion routine converts the b-byte secret\
    \ key, K, into an\n   expanded key, S, which is a sequence of T = 2*(R+1) words.\
    \  The\n   expansion algorithm uses two constants that are derived from the\n\
    \   constants, e, and phi.  These are used to initialize S, which is then\n  \
    \ modified using K.  A C code procedure header for this routine could\n   be:\n\
    \  /* Expand an RC5 user key.\n   */\n  void RC5_Key_Expand (b, K, R, S)\n   \
    \ int      b; /* Byte length of secret key */\n    char        *K; /* Secret key\
    \ */\n    int      R; /* Number of rounds */\n    RC5_WORD *S;    /* Expanded\
    \ key buffer, 2*(R+1) words */\n  {\n"
- title: 5.3 Convert secret key from bytes to words
  contents:
  - "5.3 Convert secret key from bytes to words\n   This step converts the b-byte\
    \ key into a sequence of words stored in\n   the array L.  On a little-endian\
    \ processor this is accomplished by\n   zeroing the L array and copying in the\
    \ b bytes of K.  The following C\n   code will achieve this effect on all processors:\n\
    \    int i, j, k, LL, t, T;\n    RC5_WORD    L[256/WW];  /* Based on max key size\
    \ */\n    RC5_WORD    A, B;\n    /* LL is number of elements used in L. */\n \
    \   LL = (b + WW - 1) / WW;\n    for (i = 0 ; i < LL ; i++)  {\n        L[i] =\
    \ 0;\n    }\n    for (i = 0 ; i < b ; i++)  {\n        t = (K[i] & 0xFF) << (8*(i%4));\
    \ /* 0, 8, 16, 24*/\n        L[i/WW] = L[i/WW] + t;\n    }\n"
- title: 5.4 Initialize the expanded key table
  contents:
  - "5.4 Initialize the expanded key table\n   This step fills in the S table with\
    \ a fixed (key independent)\n   pseudo-random pattern using an arithmetic progression\
    \ based on Pw and\n   Qw modulo 2**W.  The element S[i] equals i*Qw + Pw modulo\
    \ 2**W.  This\n   table could be precomputed and copied as needed or computed\
    \ on the\n   fly.  In C code it can be computed by:\n    T = 2*(R+1);\n    S[0]\
    \ = Pw;\n    for (i = 1 ; i < T ; i++)  {\n        S[i] = S[i-1] + Qw;\n    }\n"
- title: 5.5 Mix in the secret key
  contents:
  - "5.5 Mix in the secret key\n   This step mixes the secret key, K, into the expanded\
    \ key, S.  First\n   the number of iterations of the mixing function, k, is set\
    \ to three\n   times the maximum of the number of initialized elements of L, called\n\
    \   LL, and the number of elements in S, called T.  Each iteration is\n   similar\
    \ to an interation of the encryption inner loop in that two\n   variables A and\
    \ B are updated by the first and second halves of the\n   iteration.\n   Initially\
    \ A and B are zero as are the indexes into the S array, i,\n   and the L array,\
    \ j.  In the first half of the iteration, a partial\n   result is computed by\
    \ summing S[i], A and B.  The new value for A is\n   this partial result rotated\
    \ left three bits.  The A value is then\n   placed into S[i].  The second half\
    \ of the iteration computes a second\n   partial result that is the sum of L[j],\
    \ A and B.  The second partial\n   result is then rotated left by A+B bit positions\
    \ and set to be the\n   new value for B.  The new B value is then placed into\
    \ L[j].  At the\n   end of the iteration, i and j are incremented modulo the size\
    \ of\n   their respective arrays.  In C code:\n    i = j = 0;\n    A = B = 0;\n\
    \    if (LL > T)\n        k = 3 * LL; /* Secret key len > expanded key. */\n \
    \   else\n        k = 3 * T;  /* Secret key len < expanded key. */\n    for (\
    \ ; k > 0 ; k--)  {\n        A = ROTL(S[i] + A + B, 3, W);\n        S[i] = A;\n\
    \        B = ROTL(L[j] + A + B, A + B, W);\n        L[j] = B;\n        i = (i\
    \ + 1) % T;\n        j = (j + 1) % LL;\n    }\n    return;\n  } /* End of RC5_Key_Expand\
    \ */\n"
- title: 6.  Description of RC5 Block Cipher
  contents:
  - "6.  Description of RC5 Block Cipher\n   This section describes the RC5 block\
    \ cipher by explaining the steps\n   required to perform an encryption of a single\
    \ input block.  The\n   decryption process is the reverse of these steps so it\
    \ will not be\n   explained.  The RC5 cipher is parameterized by a version number,\
    \ V, a\n   round count, R, and a word size in bits, W.  This description\n   corresponds\
    \ to original version of RC5 (V = 16 decimal) and covers\n   any positive value\
    \ for R and the values 16, 32, and 64 for W.\n   The inputs to this process are\
    \ the expanded key table, S, the number\n   of rounds, R, the input buffer pointer,\
    \ in, and the output buffer\n   pointer, out.  A possible C code procedure header\
    \ for this would be:\n  void RC5_Block_Encrypt (S, R, in, out)\n    RC5_WORD \
    \   *S;\n    int  R;\n    char    *in;\n    char    *out;\n  {\n"
- title: 6.1 Loading A and B values
  contents:
  - "6.1 Loading A and B values\n   This step converts input bytes into two unsigned\
    \ integers called A\n   and B.  When RC5 is used as a 64 bit block cipher A and\
    \ B are 32 bit\n   values.  The first input byte becomes the least significant\
    \ byte of\n   A, the fourth input byte becomes the most significant byte of A,\
    \ the\n   fifth input byte becomes the least significant byte of B and the last\n\
    \   input byte becomes the most significant byte of B.  This conversion\n   can\
    \ be very efficient for little-endian processors such as the Intel\n   family.\
    \  In C code this could be expressed as:\n    int  i;\n    RC5_WORD    A, B;\n\
    \    A  =  in[0] & 0xFF;\n    A += (in[1] & 0xFF) << 8;\n    A += (in[2] & 0xFF)\
    \ << 16;\n    A += (in[3] & 0xFF) << 24;\n    B  =  in[4] & 0xFF;\n    B += (in[5]\
    \ & 0xFF) << 8;\n    B += (in[6] & 0xFF) << 16;\n    B += (in[7] & 0xFF) << 24;\n"
- title: 6.2 Iterating the round function
  contents:
  - "6.2 Iterating the round function\n   This step mixes the expanded key with the\
    \ input to perform the\n   fundamental encryption operation.  The first two words\
    \ of the\n   expanded key are added to A and B respectively, and then the round\n\
    \   function is repeated R times.\n   The first half of the round function computes\
    \ a new value for A based\n   on the values of A, B, and the next unused word\
    \ in the expanded key\n   table.  Specifically, A is XOR'ed with B and then this\
    \ first partial\n   result is rotated to the left by an amount specified by B\
    \ to form the\n   second partial result.  The rotation is performed on a W bit\
    \ boundary\n   (i.e., 32 bit rotation for the version of RC5 that has a 64 bit\
    \ block\n   size).  The actual rotation amount only depends on the least\n   significant\
    \ log base-2 of W bits of B.  The next unused word of the\n   expanded key table\
    \ is then added to the second partial result and\n   this becomes the new value\
    \ for A.\n   The second half of the round function is identical except the roles\n\
    \   of A and B are switched. Specifically, B is exclusive or'ed with A\n   and\
    \ then this first partial result is rotated to the left by an\n   amount specified\
    \ by A to form the second partial result.  The next\n   unused word of the expanded\
    \ key table is then added to the second\n   partial result and this becomes the\
    \ new value for B.\n   One way to express this in C code is:\n    A = A + S[0];\n\
    \    B = B + S[1];\n    for (i = 1 ; i <= R ; i++) {\n        A = A ^ B;\n   \
    \     A = ROTL(A, B, W) + S[2*i];\n        B = B ^ A;\n        B = ROTL(B, A,\
    \ W) + S[(2*i)+1];\n    }\n"
- title: 6.3 Storing the A and B values
  contents:
  - "6.3 Storing the A and B values\n   The final step is to convert A and B back\
    \ into a sequence of bytes.\n   This is the inverse of the load operation.  An\
    \ expression of this in\n   C code could be:\n    out[0] = (A >>  0) & 0xFF;\n\
    \    out[1] = (A >>  8) & 0xFF;\n    out[2] = (A >> 16) & 0xFF;\n    out[3] =\
    \ (A >> 24) & 0xFF;\n    out[4] = (B >>  0) & 0xFF;\n    out[5] = (B >>  8) &\
    \ 0xFF;\n    out[6] = (B >> 16) & 0xFF;\n    out[7] = (B >> 24) & 0xFF;\n    return;\n\
    \  } /* End of RC5_Block_Encrypt */\n"
- title: 7.  Description of RC5-CBC and RC5-CBC-Pad
  contents:
  - "7.  Description of RC5-CBC and RC5-CBC-Pad\n   This section describes the CBC\
    \ and CBC-Pad modes of the RC5 cipher.\n   This description is based on the RC5\
    \ key objects and RC5 block cipher\n   described earlier.\n"
- title: 7.1 Creating cipher objects
  contents:
  - "7.1 Creating cipher objects\n   The cipher object needs to keep track of the\
    \ padding mode, the number\n   of rounds, the expanded key, the initialization\
    \ vector, the CBC\n   chaining block, and an input buffer.  A possible structure\
    \ definition\n   for this in C code would be:\n  /* Definition of the RC5 CBC\
    \ algorithm object.\n   */\n  typedef struct rc5CBCAlg\n  {\n    int         \
    \ Pad;   /* 1 = RC5-CBC-Pad, 0 = RC5-CBC. */\n    int          R;     /* Number\
    \ of rounds. */\n    RC5_WORD        *S;     /* Expanded key. */\n    unsigned\
    \ char    I[BB]; /* Initialization vector. */\n    unsigned char    chainBlock[BB];\n\
    \    unsigned char    inputBlock[BB];\n    int          inputBlockIndex; /* Next\
    \ inputBlock byte. */\n  } rc5CBCAlg;\n   To create a cipher algorithm object,\
    \ the parameters must be checked\n   and then space allocated for the expanded\
    \ key table.  The expanded\n   key is initialized using the method described earlier.\
    \  Finally, the\n   state variables (padding mode, number of rounds, and the input\n\
    \   buffer) are set to their initial values.  In C this could be\n   accomplished\
    \ by:\n  /* Allocate and initialize the RC5 CBC algorithm object.\n   * Return\
    \ 0 if problems.\n   */\n  rc5CBCAlg *RC5_CBC_Create (Pad, R, Version, bb, I)\n\
    \    int      Pad;       /* 1 = RC5-CBC-Pad, 0 = RC5-CBC. */\n    int      R;\
    \         /* Number of rounds. */\n    int      Version;   /* RC5 version number.\
    \ */\n    int      bb;        /* Bytes per RC5 block == IV len. */\n    char \
    \    *I;        /* CBC IV, bb bytes long. */\n  {\n    rc5CBCAlg    *pAlg;\n \
    \   int           index;\n    if ((Version != RC5_FIRST_VERSION) ||\n        (bb\
    \ != BB) ||   (R < 0) || (255 < R))\n        return ((rc5CBCAlg *) 0);\n    pAlg\
    \ = (rc5CBCAlg *) malloc (sizeof(*pAlg));\n    if (pAlg == ((rc5CBCAlg *) 0))\n\
    \        return ((rc5CBCAlg *) 0);\n    pAlg->S = (RC5_WORD *) malloc (BB * (R\
    \ + 1));\n    if (pAlg->S == ((RC5_WORD *) 0))    {\n        free (pAlg);\n  \
    \      return ((rc5CBCAlg *) 0);\n    }\n    pAlg->Pad = Pad;\n    pAlg->R = R;\n\
    \    pAlg->inputBlockIndex = 0;\n    for (index = 0 ; index < BB ; index++)\n\
    \        pAlg->I[index] = I[index];\n    return (pAlg);\n  }\n"
- title: 7.2 Destroying cipher objects
  contents:
  - "7.2 Destroying cipher objects\n   Destroying the cipher object is the inverse\
    \ of creating it with care\n   being take to zero memory before returning it to\
    \ the memory manager.\n   In C this could be accomplished by:\n  /* Zero and free\
    \ an RC5 algorithm object.\n   */\n  void RC5_CBC_Destroy (pAlg)\n    rc5CBCAlg\
    \   *pAlg;\n  {\n    RC5_WORD    *to;\n    int      count;\n    if (pAlg == ((rc5CBCAlg\
    \ *) 0))\n        return;\n    if (pAlg->S == ((RC5_WORD *) 0))\n        return;\n\
    \    to = pAlg->S;\n    for (count = 0 ; count < (1 + pAlg->R) ; count++)\n  \
    \  {\n        *to++ = 0;  /* Two expanded key words per round. */\n        *to++\
    \ = 0;\n    }\n   free (pAlg->S);\n    for (count = 0 ; count < BB ; count++)\n\
    \    {\n        pAlg->I[count] = (unsigned char) 0;\n        pAlg->inputBlock[count]\
    \ = (unsigned char) 0;\n        pAlg->chainBlock[count] = (unsigned char) 0;\n\
    \    }\n    pAlg->Pad = 0;\n    pAlg->R = 0;\n    pAlg->inputBlockIndex = 0;\n\
    \    free (pAlg);\n  }\n"
- title: 7.3 Setting the IV for cipher objects
  contents:
  - "7.3 Setting the IV for cipher objects\n   For CBC cipher objects, the state of\
    \ the algorithm depends on the\n   expanded key, the CBC chain block, and any\
    \ internally buffered input.\n   Often the same key is used with many messages\
    \ that each have a unique\n   initialization vector.  To avoid the overhead of\
    \ creating a new\n   cipher object, it makes more sense to provide an operation\
    \ that\n   allows the caller to change the initialization vector for an existing\n\
    \   cipher object.  In C this could be accomplished by the following\n   code:\n\
    \  /* Setup a new initialization vector for a CBC operation\n   * and reset the\
    \ CBC object.\n   * This can be called after Final without needing to\n   * call\
    \ Init or Create again.\n   * Return zero if problems.\n   */\n  int RC5_CBC_SetIV\
    \ (pAlg, I)\n    rc5CBCAlg   *pAlg;\n    char        *I;     /* CBC Initialization\
    \ vector, BB bytes. */\n  {\n    int     index;\n    pAlg->inputBlockIndex = 0;\n\
    \    for (index = 0 ; index < BB ; index++)\n    {\n        pAlg->I[index] = pAlg->chainBlock[index]\
    \ = I[index];\n        pAlg->inputBlock[index] = (unsigned char) 0;\n    }\n \
    \   return (1);\n  }\n"
- title: 7.4 Binding a key to a cipher object
  contents:
  - "7.4 Binding a key to a cipher object\n   The operation that binds a key to a\
    \ cipher object performs the key\n   expansion.  Key expansion could be an operation\
    \ on keys, but that\n   would not work correctly for ciphers that modify the expanded\
    \ key as\n   they operate.  After expanding the key, this operation must\n   initialize\
    \ the CBC chain block from the initialization vector and\n   prepare the input\
    \ buffer to receive the first character.  In C this\n   could be done by:\n  /*\
    \ Initialize the encryption object with the given key.\n   * After this routine,\
    \ the caller frees the key object.\n   * The IV for this CBC object can be changed\
    \ by calling\n   * the SetIV routine.  The only way to change the key is\n   *\
    \ to destroy the CBC object and create a new one.\n   * Return zero if problems.\n\
    \   */\n  int RC5_CBC_Encrypt_Init (pAlg, pKey)\n    rc5CBCAlg       *pAlg;\n\
    \    rc5UserKey  *pKey;\n  {\n    if ((pAlg == ((rc5CBCAlg *) 0)) ||\n       \
    \ (pKey == ((rc5UserKey *) 0)))\n        return (0);\n    RC5_Key_Expand (Key->keyLength,\
    \ pKey->keyBytes,\n                    pAlg->R, pAlg->S);\n    return (RC5_CBC_SetIV(pAlg,\
    \ pAlg->I));\n  }\n"
- title: 7.5 Processing part of a message
  contents:
  - "7.5 Processing part of a message\n   The encryption process described here uses\
    \ the Init-Update-Final\n   paradigm.  The update operation can be performed on\
    \ a sequence of\n   message parts in order to incrementally produce the ciphertext.\n\
    \   After the last part is processed, the Final operation is called to\n   pick\
    \ up any plaintext bytes or padding that are buffered inside the\n   cipher object.\
    \  An appropriate procedure header for this operation\n   would be:\n  /* Encrypt\
    \ a buffer of plaintext.\n   * The plaintext and ciphertext buffers can be the\
    \ same.\n   * The byte len of the ciphertext is put in *pCipherLen.\n   * Call\
    \ this multiple times passing successive\n   * parts of a large message.\n   *\
    \ After the last part has been passed to Update,\n   * call Final.\n   * Return\
    \ zero if problems like output buffer too small.\n   */\n  int RC5_CBC_Encrypt_Update\
    \ (pAlg, N, P,\n                              pCipherLen, maxCipherLen, C)\n \
    \   rc5CBCAlg   *pAlg;      /* Cipher algorithm object. */\n    int          N;\
    \         /* Byte length of P. */\n    char        *P;         /* Plaintext buffer.\
    \ */\n    int         *pCipherLen;/* Gets byte len of C. */\n    int         \
    \ maxCipherLen;  /* Size of C. */\n    char        *C;         /* Ciphertext buffer.\
    \ */\n  {\n"
- title: 7.5.1   Output buffer size check.
  contents:
  - "7.5.1   Output buffer size check.\n   The first step of plaintext processing\
    \ is to make sure that the\n   output buffer is big enough hold the ciphertext.\
    \  The ciphertext will\n   be produced in multiples of the block size and depends\
    \ on the number\n   of plaintext characters passed to this operation plus any\
    \ characters\n   that are in the cipher object's internal buffer.  In C code this\n\
    \   would be:\n    int      plainIndex, cipherIndex, j;\n    /* Check size of\
    \ the output buffer. */\n    if (maxCipherLen < (((pAlg->inputBlockIndex+N)/BB)*BB))\n\
    \    {\n        *pCipherLen = 0;\n        return (0);\n    }\n"
- title: 7.5.2   Divide plaintext into blocks
  contents:
  - "7.5.2   Divide plaintext into blocks\n   The next step is to add characters to\
    \ the internal buffer until a\n   full block has been constructed.  When that\
    \ happens, the buffer\n   pointers are reset and the input buffer is exclusive-or'ed\
    \ (XORed)\n   with the CBC chaining block.  The byte order of the chaining block\
    \ is\n   the same as the input block.  For example, the ninth input byte is\n\
    \   XOR'ed with the first ciphertext byte.  The result is then passed to\n   the\
    \ RC5 block cipher which was described earlier.  To reduce data\n   movement and\
    \ byte alignment problems, the output of RC5 can be\n   directly written into\
    \ the CBC chaining block.  Finally, this output\n   is copied to the ciphertext\
    \ buffer provided by the user.  Before\n   returning, the actual size of the ciphertext\
    \ is passed back to the\n   caller.  In C, this step can be performed by:\n  \
    \  plainIndex = cipherIndex = 0;\n    while (plainIndex < N)\n    {\n        if\
    \ (pAlg->inputBlockIndex < BB)\n        {\n            pAlg->inputBlock[pAlg->inputBlockIndex]\n\
    \                    = P[plainIndex];\n            pAlg->inputBlockIndex++;\n\
    \            plainIndex++;\n        }\n        if (pAlg->inputBlockIndex == BB)\n\
    \        {   /* Have a complete input block, process it. */\n            pAlg->inputBlockIndex\
    \ = 0;\n            for (j = 0 ; j < BB ; j++)\n            {   /* XOR in the\
    \ chain block. */\n                pAlg->inputBlock[j] = pAlg->inputBlock[j]\n\
    \                                 ^ pAlg->chainBlock[j];\n            }\n    \
    \        RC5_Block_Encrypt(pAlg->S, pAlg->R\n                             pAlg->inputBlock,\n\
    \                             pAlg->chainBlock);\n            for (j = 0 ; j <\
    \ BB ; j++)\n            {   /* Output the ciphertext. */\n                C[cipherIndex]\
    \ = pAlg->chainBlock[j];\n                cipherIndex++;\n            }\n    \
    \    }\n    }\n    *pCipherLen = cipherIndex;\n    return (1);\n  } /* End of\
    \ RC5_CBC_Encrypt_Update */\n"
- title: 7.6 Final block processing
  contents:
  - "7.6 Final block processing\n   This step handles the last block of plaintext.\
    \  For RC5-CBC, this\n   step just performs error checking to ensure that the\
    \ plaintext length\n   was indeed a multiple of the block length.  For RC5-CBC-Pad,\
    \ padding\n   bytes are added to the plaintext.  The pad bytes are all the same\
    \ and\n   are set to a byte that represents the number of bytes of padding.\n\
    \   For example if there are eight bytes of padding, the bytes will all\n   have\
    \ the hexadecimal value 0x08.  There will be between one and BB\n   padding bytes,\
    \ inclusive.  In C code this would be:\n  /* Produce the final block of ciphertext\
    \ including any\n   * padding, and then reset the algorithm object.\n   * Return\
    \ zero if problems.\n   */\n  int RC5_CBC_Encrypt_Final (pAlg, pCipherLen, maxCipherLen,\
    \ C)\n    rc5CBCAlg   *pAlg;\n    int         *pCipherLen;    /* Gets byte len\
    \ of C. */\n    int          maxCipherLen;  /* Len of C buffer. */\n    char \
    \       *C;             /* Ciphertext buffer. */\n  {\n    int     cipherIndex,\
    \ j;\n    int     padLength;\n    /* For non-pad mode error if input bytes buffered.\
    \ */\n    *pCipherLen = 0;\n    if ((pAlg->Pad == 0) && (pAlg->inputBlockIndex\
    \ != 0))\n        return (0);\n    if (pAlg->Pad == 0)\n        return (1);\n\
    \    if (maxCipherLen < BB)\n        return (0);\n    padLength = BB - pAlg->inputBlockIndex;\n\
    \    for (j = 0 ; j < padLength ; j++)\n    {\n        pAlg->inputBlock[pAlg->inputBlockIndex]\n\
    \               = (unsigned char) padLength;\n        pAlg->inputBlockIndex++;\n\
    \    }\n    for (j = 0 ; j < BB ; j++)\n    {   /* XOR the chain block into the\
    \ plaintext block. */\n        pAlg->inputBlock[j] = pAlg->inputBlock[j]\n   \
    \                          ^ pAlg->chainBlock[j];\n    }\n    RC5_Block_Encrypt(pAlg->S,\
    \ pAlg->R,\n                      pAlg->inputBlock, pAlg->chainBlock);\n    cipherIndex\
    \ = 0;\n    for (j = 0 ; j < BB ; j++)\n    {   /* Output the ciphertext. */\n\
    \        C[cipherIndex] = pAlg->chainBlock[j];\n        cipherIndex++;\n    }\n\
    \    *pCipherLen = cipherIndex;\n    /* Reset the CBC algorithm object. */\n \
    \   return (RC5_CBC_SetIV(pAlg, pAlg->I));\n  } /* End of RC5_CBC_Encrypt_Final\
    \ */\n"
- title: 8.  Description of RC5-CTS
  contents:
  - "8.  Description of RC5-CTS\n   The Cipher Text Stealing (CTS) mode for block\
    \ ciphers is described by\n   Schneier on pages 195 and 196 of [6].  This mode\
    \ handles any length\n   of plaintext and produces ciphertext whose length matches\
    \ the\n   plaintext length.  The CTS mode behaves like the CBC mode for all but\n\
    \   the last two blocks of the plaintext.  The following steps describe\n   how\
    \ to handle the last two portions of the plaintext, called Pn-1 and\n   Pn, where\
    \ the length of Pn-1 equals the block size, BB, and the\n   length of the last\
    \ block, Pn, is Ln bytes.  Notice that Ln ranges\n   from 1 to BB, inclusive,\
    \ so Pn could in fact be a complete block.\n   1. Exclusive-or Pn-1 with the previous\
    \ ciphertext\n      block, Cn-2, to create Xn-1.\n   2. Encrypt Xn-1 to create\
    \ En-1.\n   3. Select the first Ln bytes of En-1 to create Cn.\n   4. Pad Pn with\
    \ zeros at the end to create P of length BB.\n   5. Exclusive-or En-1 with P to\
    \ create to create Dn.\n   6. Encrypt Dn to create Cn-1\n   7. The last two parts\
    \ of the ciphertext are Cn-1 and\n      Cn respectively.\n   To implement CTS\
    \ encryption, the RC5-CTS object must hold on to\n   (buffer) at most 2*BB bytes\
    \ of plaintext and process them specially\n   when the RC5_CTS_Encrypt_Final routine\
    \ is called.\n   The following steps describe how to decrypt Cn-1 and Cn.\n  \
    \ 1. Decrypt Cn-1 to create Dn.\n   2. Pad Cn with zeros at the end to create\
    \ C of length BB.\n   3. Exclusive-or Dn with C to create Xn.\n   4. Select the\
    \ first Ln bytes of Xn to create Pn.\n   5. Append the tail (BB minus Ln) bytes\
    \ of Xn to Cn\n      to create En.\n   6. Decrypt En to create Pn-1.\n   7. The\
    \ last two parts of the plaintext are Pn-1 and\n      Pn respectively.\n"
- title: 9.  Test Program and Vectors
  contents:
  - "9.  Test Program and Vectors\n   To help confirm the correctness of an implementation,\
    \ this section\n   gives a test program and results from a set of test vectors.\n"
- title: 9.1 Test Program
  contents:
  - "9.1 Test Program\n   The following test program written in C reads test vectors\
    \ from its\n   input stream and writes results on its output stream.  The following\n\
    \   subsections give a set of test vectors for inputs and the resulting\n   outputs.\n\
    \  #include <stdio.h>\n  #define BLOCK_LENGTH     (8 /* bytes */)\n  #define MAX_KEY_LENGTH\
    \   (64 /* bytes */)\n  #define MAX_PLAIN_LENGTH (128 /* bytes */)\n  #define\
    \ MAX_CIPHER_LENGTH(MAX_PLAIN_LENGTH + BLOCK_LENGTH)\n  #define MAX_ROUNDS   \
    \    (20)\n  #define MAX_S_LENGTH     (2 * (MAX_ROUNDS + 1))\n  typedef struct\
    \ test_vector\n  {\n    int padding_mode;\n    int rounds;\n    char    keytext[2*MAX_KEY_LENGTH+1];\n\
    \    int key_length;\n    char    key[MAX_KEY_LENGTH];\n    char    ivtext[2*BLOCK_LENGTH+1];\n\
    \    int iv_length;\n    char    iv[BLOCK_LENGTH];\n    char    plaintext[2*MAX_PLAIN_LENGTH+1];\n\
    \    int plain_length;\n    char    plain[MAX_PLAIN_LENGTH];\n    char    ciphertext[2*MAX_CIPHER_LENGTH+1];\n\
    \    int cipher_length;\n    char    cipher[MAX_CIPHER_LENGTH];\n    RC5_WORD\
    \    S[MAX_S_LENGTH];\n  } test_vector;\n  void show_banner()\n  {\n    (void)\
    \ printf(\"RC5 CBC Tester.\\n\");\n    (void) printf(\"Each input line should\
    \ contain the following\\n\");\n    (void) printf(\"test parameters separated\
    \ by a single space:\\n\");\n    (void) printf(\"- Padding mode flag.  Use 1 for\
    \ RC5_CBC_Pad, else\n  0.\\n\");\n    (void) printf(\"- Number of rounds for RC5.\\\
    n\");\n    (void) printf(\"- Key bytes in hexadecimal.  Two characters per\n \
    \ byte like '01'.\\n\");\n    (void) printf(\"- IV bytes in hexadecimal.  Must\
    \ be 16 hex\n  characters.\\n\");\n    (void) printf(\"- Plaintext bytes in hexadecimal.\\\
    n\");\n    (void) printf(\"An end of file or format error terminates the\n  tester.\\\
    n\");\n    (void) printf(\"\\n\");\n  }\n  /* Convert a buffer from ascii hex\
    \ to bytes.\n   * Set pTo_length to the byte length of the result.\n   * Return\
    \ 1 if everything went OK.\n   */\n  int hex_to_bytes (from, to, pTo_length)\n\
    \    char    *from, *to;\n    int     *pTo_length;\n  {\n    char    *pHex;  /*\
    \ Ptr to next hex character. */\n    char    *pByte;     /* Ptr to next resulting\
    \ byte. */\n    int  byte_length = 0;\n    int  value;\n    pByte = to;\n    for\
    \ (pHex = from ; *pHex != 0 ; pHex += 2)  {\n        if (1 != sscanf(pHex, \"\
    %02x\", &value))\n            return (0);\n        *pByte++ = ((char)(value &\
    \ 0xFF));\n        byte_length++;\n    }\n    *pTo_length = byte_length;\n   \
    \ return (1);\n  }\n  /* Convert a buffer from bytes to ascii hex.\n   * Return\
    \ 1 if everything went OK.\n   */\n  int bytes_to_hex (from, from_length, to)\n\
    \    char    *from, *to;\n    int from_length;\n  {\n    char    *pHex;  /* Ptr\
    \ to next hex character. */\n    char    *pByte;     /* Ptr to next resulting\
    \ byte. */\n    int  value;\n    pHex = to;\n    for (pByte = from ; from_length\
    \ > 0 ; from_length--)  {\n        value = *pByte++ & 0xFF;\n        (void) sprintf(pHex,\
    \ \"%02x\", value);\n        pHex += 2;\n    }\n    return (1);\n  }\n  /* Return\
    \ 1 if get a valid test vector. */\n  int get_test_vector(ptv)\n    test_vector\
    \ *ptv;\n  {\n    if (1 != scanf(\"%d\", &ptv->padding_mode))\n        return\
    \ (0);\n    if (1 != scanf(\"%d\", &ptv->rounds))\n        return (0);\n    if\
    \ ((ptv->rounds < 0) || (MAX_ROUNDS < ptv->rounds))\n        return (0);\n   \
    \ if (1 != scanf(\"%s\", &ptv->keytext))\n        return (0);\n    if (1 != hex_to_bytes(ptv->keytext,\
    \ ptv->key,\n                         &ptv->key_length))\n        return (0);\n\
    \    if (1 != scanf(\"%s\", &ptv->ivtext))\n        return (0);\n    if (1 !=\
    \ hex_to_bytes(ptv->ivtext, ptv->iv,\n                         &ptv->iv_length))\n\
    \        return (0);\n    if (BLOCK_LENGTH != ptv->iv_length)\n        return\
    \ (0);\n    if (1 != scanf(\"%s\", &ptv->plaintext))\n        return (0);\n  \
    \  if (1 != hex_to_bytes(ptv->plaintext, ptv->plain,\n                       \
    \  &ptv->plain_length))\n        return (0);\n    return (1);\n  }\n  void run_test\
    \ (ptv)\n    test_vector *ptv;\n  {\n    rc5UserKey  *pKey;\n    rc5CBCAlg   \
    \    *pAlg;\n    int          numBytesOut;\n    pKey = RC5_Key_Create ();\n  \
    \  RC5_Key_Set (pKey, ptv->key_length, ptv->key);\n    pAlg = RC5_CBC_Create (ptv->padding_mode,\n\
    \                    ptv->rounds,\n                    RC5_FIRST_VERSION,\n  \
    \                  BB,\n                    ptv->iv);\n    (void) RC5_CBC_Encrypt_Init\
    \ (pAlg, pKey);\n    ptv->cipher_length = 0;\n    (void) RC5_CBC_Encrypt_Update\
    \ (pAlg,\n                    ptv->plain_length, ptv->plain,\n               \
    \     &(numBytesOut),\n                    MAX_CIPHER_LENGTH - ptv->cipher_length,\n\
    \                    &(ptv->cipher[ptv->cipher_length]));\n    ptv->cipher_length\
    \ += numBytesOut;\n    (void) RC5_CBC_Encrypt_Final (pAlg,\n                 \
    \   &(numBytesOut),\n                    MAX_CIPHER_LENGTH - ptv->cipher_length,\n\
    \                    &(ptv->cipher[ptv->cipher_length]));\n    ptv->cipher_length\
    \ += numBytesOut;\n    bytes_to_hex (ptv->cipher, ptv->cipher_length,\n      \
    \           ptv->ciphertext);\n    RC5_Key_Destroy (pKey);\n    RC5_CBC_Destroy\
    \ (pAlg);\n  }\n  void show_results (ptv)\n    test_vector *ptv;\n  {\n    if\
    \ (ptv->padding_mode)\n        printf (\"RC5_CBC_Pad \");\n    else\n        printf\
    \ (\"RC5_CBC     \");\n    printf (\"R = %2d \", ptv->rounds);\n    printf (\"\
    Key = %s \", ptv->keytext);\n    printf (\"IV = %s \", ptv->ivtext);\n    printf\
    \ (\"P = %s \", ptv->plaintext);\n    printf (\"C = %s\", ptv->ciphertext);\n\
    \    printf (\"\\n\");\n  }\n  int main(argc, argv)\n    int argc;\n    char *argv[];\n\
    \  {\n    test_vector tv;\n    test_vector *ptv = &tv;\n    show_banner();\n \
    \   while (get_test_vector(ptv))  {\n        run_test(ptv);\n        show_results(ptv);\n\
    \    }\n    return (0);\n  }\n"
- title: 9.2 Test vectors
  contents:
  - "9.2 Test vectors\n   The following text is an input file to the test program\
    \ presented in\n   the previous subsection.  The output is given in the next subsection.\n\
    \  0 00 00                 0000000000000000 0000000000000000\n  0 00 00      \
    \           0000000000000000 ffffffffffffffff\n  0 00 00                 0000000000000001\
    \ 0000000000000000\n  0 00 00                 0000000000000000 0000000000000001\n\
    \  0 00 00                 0102030405060708 1020304050607080\n  0 01 11      \
    \           0000000000000000 0000000000000000\n  0 02 00                 0000000000000000\
    \ 0000000000000000\n  0 02 00000000           0000000000000000 0000000000000000\n\
    \  0 08 00                 0000000000000000 0000000000000000\n  0 08 00      \
    \           0102030405060708 1020304050607080\n  0 12 00                 0102030405060708\
    \ 1020304050607080\n  0 16 00                 0102030405060708 1020304050607080\n\
    \  0 08 01020304           0000000000000000 ffffffffffffffff\n  0 12 01020304\
    \           0000000000000000 ffffffffffffffff\n  0 16 01020304           0000000000000000\
    \ ffffffffffffffff\n  0 12 0102030405060708   0000000000000000 ffffffffffffffff\n\
    \  0 08 0102030405060708   0102030405060708 1020304050607080\n  0 12 0102030405060708\
    \   0102030405060708 1020304050607080\n  0 16 0102030405060708   0102030405060708\
    \ 1020304050607080\n  0 08 01020304050607081020304050607080\n                \
    \          0102030405060708 1020304050607080\n  0 12 01020304050607081020304050607080\n\
    \                          0102030405060708 1020304050607080\n  0 16 01020304050607081020304050607080\n\
    \                          0102030405060708 1020304050607080\n  0 12 0102030405\
    \         0000000000000000 ffffffffffffffff\n  0 08 0102030405         0000000000000000\
    \ ffffffffffffffff\n  0 08 0102030405         7875dbf6738c6478 0808080808080808\n\
    \  1 08 0102030405         0000000000000000 ffffffffffffffff\n  0 08 0102030405\
    \         0000000000000000 0000000000000000\n  0 08 0102030405         7cb3f1df34f94811\
    \ 1122334455667701\n  1 08 0102030405         0000000000000000\n  ffffffffffffffff7875dbf6738c647811223344556677\n"
- title: 9.3 Test results
  contents:
  - "9.3 Test results\n   The following text is the output produced by the test program\
    \ run on\n   the inputs given in the previous subsection.\n  RC5 CBC Tester.\n\
    \  Each input line should contain the following\n  test parameters separated by\
    \ a single space:\n  - Padding mode flag.  Use 1 for RC5_CBC_Pad, else 0.\n  -\
    \ Number of rounds for RC5.\n  - Key bytes in hexadecimal.  Two characters per\
    \ byte\n    like '01'.\n  - IV bytes in hexadecimal.  Must be 16 hex characters.\n\
    \  - Plaintext bytes in hexadecimal.\n  An end of file or format error terminates\
    \ the tester.\n  RC5_CBC     R =  0 Key = 00 IV = 0000000000000000\n   P = 0000000000000000\
    \ C = 7a7bba4d79111d1e\n  RC5_CBC     R =  0 Key = 00 IV = 0000000000000000\n\
    \   P = ffffffffffffffff C = 797bba4d78111d1e\n  RC5_CBC     R =  0 Key = 00 IV\
    \ = 0000000000000001\n   P = 0000000000000000 C = 7a7bba4d79111d1f\n  RC5_CBC\
    \     R =  0 Key = 00 IV = 0000000000000000\n   P = 0000000000000001 C = 7a7bba4d79111d1f\n\
    \  RC5_CBC     R =  0 Key = 00 IV = 0102030405060708\n   P = 1020304050607080\
    \ C = 8b9ded91ce7794a6\n  RC5_CBC     R =  1 Key = 11 IV = 0000000000000000\n\
    \   P = 0000000000000000 C = 2f759fe7ad86a378\n  RC5_CBC     R =  2 Key = 00 IV\
    \ = 0000000000000000\n   P = 0000000000000000 C = dca2694bf40e0788\n  RC5_CBC\
    \     R =  2 Key = 00000000 IV = 0000000000000000\n   P = 0000000000000000 C =\
    \ dca2694bf40e0788\n  RC5_CBC     R =  8 Key = 00 IV = 0000000000000000\n   P\
    \ = 0000000000000000 C = dcfe098577eca5ff\n  RC5_CBC     R =  8 Key = 00 IV =\
    \ 0102030405060708\n   P = 1020304050607080 C = 9646fb77638f9ca8\n  RC5_CBC  \
    \   R = 12 Key = 00 IV = 0102030405060708\n   P = 1020304050607080 C = b2b3209db6594da4\n\
    \  RC5_CBC     R = 16 Key = 00 IV = 0102030405060708\n   P = 1020304050607080\
    \ C = 545f7f32a5fc3836\n  RC5_CBC     R =  8 Key = 01020304 IV = 0000000000000000\n\
    \   P = ffffffffffffffff C = 8285e7c1b5bc7402\n  RC5_CBC     R = 12 Key = 01020304\
    \ IV = 0000000000000000\n   P = ffffffffffffffff C = fc586f92f7080934\n  RC5_CBC\
    \     R = 16 Key = 01020304 IV = 0000000000000000\n   P = ffffffffffffffff C =\
    \ cf270ef9717ff7c4\n  RC5_CBC     R = 12 Key = 0102030405060708 IV = 0000000000000000\n\
    \   P = ffffffffffffffff C = e493f1c1bb4d6e8c\n  RC5_CBC     R =  8 Key = 0102030405060708\
    \ IV = 0102030405060708\n   P = 1020304050607080 C = 5c4c041e0f217ac3\n  RC5_CBC\
    \     R = 12 Key = 0102030405060708 IV = 0102030405060708\n   P = 1020304050607080\
    \ C = 921f12485373b4f7\n  RC5_CBC     R = 16 Key = 0102030405060708 IV = 0102030405060708\n\
    \   P = 1020304050607080 C = 5ba0ca6bbe7f5fad\n  RC5_CBC     R =  8 Key = 01020304050607081020304050607080\n\
    \   IV = 0102030405060708\n   P = 1020304050607080 C = c533771cd0110e63\n  RC5_CBC\
    \     R = 12 Key = 01020304050607081020304050607080\n   IV = 0102030405060708\n\
    \   P = 1020304050607080 C = 294ddb46b3278d60\n  RC5_CBC     R = 16 Key = 01020304050607081020304050607080\n\
    \   IV = 0102030405060708\n   P = 1020304050607080 C = dad6bda9dfe8f7e8\n  RC5_CBC\
    \     R = 12 Key = 0102030405 IV = 0000000000000000\n   P = ffffffffffffffff C\
    \ = 97e0787837ed317f\n  RC5_CBC     R =  8 Key = 0102030405 IV = 0000000000000000\n\
    \   P = ffffffffffffffff C = 7875dbf6738c6478\n  RC5_CBC     R =  8 Key = 0102030405\
    \ IV = 7875dbf6738c6478\n   P = 0808080808080808 C = 8f34c3c681c99695\n  RC5_CBC_Pad\
    \ R =  8 Key = 0102030405 IV = 0000000000000000\n   P = ffffffffffffffff C = 7875dbf6738c64788f34c3c681c99695\n\
    \  RC5_CBC     R =  8 Key = 0102030405 IV = 0000000000000000\n   P = 0000000000000000\
    \ C = 7cb3f1df34f94811\n  RC5_CBC     R =  8 Key = 0102030405 IV = 7cb3f1df34f94811\n\
    \   P = 1122334455667701 C = 7fd1a023a5bba217\n  RC5_CBC_Pad R =  8 Key = 0102030405\
    \ IV = 0000000000000000\n   P = ffffffffffffffff7875dbf6738c647811223344556677\n\
    \   C = 7875dbf6738c64787cb3f1df34f948117fd1a023a5bba217\n"
- title: 10. Security Considerations
  contents:
  - "10. Security Considerations\n   The RC5 cipher is relatively new so critical\
    \ reviews are still being\n   performed.  However, the cipher's simple structure\
    \ makes it easy to\n   analyze and hopefully easier to assess its strength.  Reviews\
    \ so far\n   are very promising.\n   Early results [1] suggest that for RC5 with\
    \ a 64 bit block size (32\n   bit word size), 12 rounds will suffice to resist\
    \ linear and\n   differential cyptanalysis.  The 128 bit block version has not\
    \ been\n   studied as much as the 64 bit version, but it appears that 16 rounds\n\
    \   would be an appropriate minimum.  Block sizes less than 64 bits are\n   academically\
    \ interesting but should not be used for cryptographic\n   security.  Greater\
    \ security can be achieved by increasing the number\n   of rounds at the cost\
    \ of decreasing the throughput of the cipher.\n   The length of the secret key\
    \ helps determine the cipher's resistance\n   to brute force key searching attacks.\
    \  A key length of 128 bits\n   should give adequate protection against brute\
    \ force key searching by\n   a well funded opponent for a couple decades [7].\
    \  For RC5 with 12\n   rounds, the key setup time and data encryption time are\
    \ the same for\n   all key lengths less than 832 bits, so there is no performance\
    \ reason\n   for choosing short keys.  For larger keys, the key expansion step\n\
    \   will run slower because the user key table, L, will be longer than\n   the\
    \ expanded key table, S.  However, the encryption time will be\n   unchanged since\
    \ it is only a function of the number of rounds.\n   To comply with export regulations\
    \ it may be necessary to choose keys\n   that only have 40 unknown bits.  A poor\
    \ way to do this would be to\n   choose a simple 5 byte key.  This should be avoided\
    \ because it would\n   be easy for an opponent to pre-compute key searching information.\n\
    \   Another common mechanism is to pick a 128 bit key and publish the\n   first\
    \ 88 bits.  This method reveals a large number of the entries in\n   the user\
    \ key table, L, and the question of whether RC5 key expansion\n   provides adequate\
    \ security in this situation has not been studied,\n   though it may be fine.\
    \  A conservative way to conform to a 40 bit\n   limitation is to pick a seed\
    \ value of 128 bits, publish 88 bits of\n   this seed, run the entire seed through\
    \ a hash function like MD5 [4],\n   and use the 128 bit output of the hash function\
    \ as the RC5 key.\n   In the case of 40 unknown key bits with 88 known key bits\
    \ (i.e., 88\n   salt bits) there should still be 12 or more rounds for the 64\
    \ bit\n   block version of RC5, otherwise the value of adding salt bits to the\n\
    \   key is likely to be lost.\n   The lifetime of the key also influences security.\
    \  For high security\n   applications, the key to any 64 bit block cipher should\
    \ be changed\n   after encrypting 2**32 blocks (2**64 blocks for a 128 bit block\n\
    \   cipher).  This helps to guard against linear and differential\n   cryptanalysis.\
    \  For the case of 64 bit blocks, this rule would\n   recommend changing the key\
    \ after 2**40 (i.e. 10**12) bytes are\n   encrypted.  See Schneier [6] page 183\
    \ for further discussion.\n"
- title: 11. ASN.1 Identifiers
  contents:
  - "11. ASN.1 Identifiers\n   For applications that use ASN.1 descriptions, it is\
    \ necessary to\n   define the algorithm identifier for these ciphers along with\
    \ their\n   parameter block formats.  The ASN.1 definition of an algorithm\n \
    \  identifier already exists and is listed below for reference.\n  AlgorithmIdentifier\
    \ ::= SEQUENCE {\n    algorithm    OBJECT IDENTIFIER,\n    parameters   ANY DEFINED\
    \ BY algorithm OPTIONAL\n  }\n  The values for the algorithm field are:\n  RC5_CBC\
    \  OBJECT IDENTIFIER ::=\n    { iso (1) member-body (2) US (840) rsadsi (113549)\n\
    \      encryptionAlgorithm (3) RC5CBC (8) }\n  RC5_CBC_Pad OBJECT IDENTIFIER ::=\n\
    \  { iso (1) member-body (2) US (840) rsadsi (113549)\n    encryptionAlgorithm\
    \ (3) RC5CBCPAD (9) }\n   The structure of the parameters field for these algorithms\
    \ is given\n   below.  NOTE: if the iv field is not included, then the\n   initialization\
    \ vector defaults to a block of zeros whose size depends\n   on the blockSizeInBits\
    \ field.\n  RC5_CBC_Parameters ::= SEQUENCE {\n    version           INTEGER (v1_0(16)),\n\
    \    rounds            INTEGER (8..127),\n    blockSizeInBits   INTEGER (64, 128),\n\
    \    iv                OCTET STRING OPTIONAL\n  }\n"
- title: References
  contents:
  - "References\n   [1] Kaliski, Burton S., and Yinqun Lisa Yin, \"On Differential\
    \ and\n   Linear Cryptanalysis of the RC5 Encryption Algorithm\", In Advances\n\
    \   in Cryptology - Crypto '95, pages 171-184, Springer-Verlag, New\n   York,\
    \ 1995.\n   [2] Rivest, Ronald L., \"The RC5 Encryption Algorithm\", In\n   Proceedings\
    \ of the Second International Workshop on Fast Software\n   Encryption, pages\
    \ 86-96, Leuven Belgium, December 1994.\n   [3] Rivest, Ronald L., \"RC5 Encryption\
    \ Algorithm\", In Dr. Dobbs\n   Journal, number 226, pages 146-148, January 1995.\n\
    \   [4] Rivest, Ronald L., \"The MD5 Message-Digest Algorithm\", RFC\n   1321.\n\
    \   [5] RSA Laboratories, \"Public Key Cryptography Standards (PKCS)\",\n   RSA\
    \ Data Security Inc.  See ftp.rsa.com.\n   [6] Schneier, Bruce, \"Applied Cryptography\"\
    , Second Edition, John\n   Wiley and Sons, New York, 1996.  Errata: on page 195,\
    \ line 13, the\n   reference number should be [402].\n   [7] Business Software\
    \ Alliance, Matt Blaze et al., \"Minimum Key\n   Length for Symmetric Ciphers\
    \ to Provide Adequate Commercial\n   Security\", http://www.bsa.org/bsa/cryptologists.html.\n\
    \   [8] RSA Data Security Inc., \"RC5 Reference Code in C\", See the web\n   site:\
    \ www.rsa.com, for availability.  Not available with the first\n   draft of this\
    \ document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Robert W. Baldwin\n   RSA Data Security, Inc.\n   100\
    \ Marine Parkway\n   Redwood City, CA 94065\n   Phone: (415) 595-8782\n   Fax:\
    \   (415) 595-1873\n   EMail: baldwin@rsa.com, or baldwin@lcs.mit.edu\n   Ronald\
    \ L. Rivest\n   Massachusetts Institute of Technology\n   Laboratory for Computer\
    \ Science\n   NE43-324\n   545 Technology Square\n   Cambridge, MA 02139-1986\n\
    \   Phone: (617) 253-5880\n   EMail: rivest@theory.lcs.mit.edu\n"
