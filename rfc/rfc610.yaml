- title: __initial_text__
  contents:
  - "                  Further Datalanguage Design Concepts\n                    \
    \         Richard Winter\n                              Jeffrey Hill\n       \
    \                      Warren Greiff\n                    Computer Corporation\
    \ of America\n                           December 15, 1973\n                 \
    \            Acknowledgment\nDuring the course of the Datacomputer Project, many\
    \ people have\ncontributed to the development of datalanguage.\nThe suggestions\
    \ and criticisms of Dr. Gordon Everest (University of\nMinnesota), Dr. Robert\
    \ Taylor (University of Massachusetts), Professor\nThomas Cheatham (Harvard University)\
    \ and Professor George Mealy (Harvard\nUniversity) have been particularly useful.\n\
    Within CCA, several people in addition to the authors have participated\nin the\
    \ language design at various stages of the project. Hal Murray,\nBill Bush, David\
    \ Shipman and Dale Stern have been especially helpful.\n1.  Introduction\n1.1\
    \ The Datacomputer System\nThe datacomputer is a large-scale data utility system,\
    \ offering data\nstorage and data management services to other computers.\nThe\
    \ datacomputer differs from traditional data management systems in\nseveral ways.\n\
    First, it is implemented on dedicated hardware, and comprises a separate\ncomputing\
    \ system specialized for data management.\nSecond, the system is implemented on\
    \ a large scale. Data is intended to\nbe stored on mass storage devices, with\
    \ capacities in the range of a\ntrillion bits.  Files on the order of one hundred\
    \ billion bits are to be\nkept online.\nThird, it is intended to support sharing\
    \ of data among processes\noperating in diverse environments.  That is, the programs\
    \ which share a\ngiven data base may be written in different languages, execute\
    \ on\ndifferent hardware under different operating systems, and support end\n\
    users with radically different requirements.  To enable such shared use\nof a\
    \ data base, transformations between various hardware representations\nand data\
    \ structuring concepts must be achieved.\nFinally, the datacomputer is designed\
    \ to function smoothly as a\ncomponent of a much larger system: a computer network.\
    \  In a computer\nnetwork, the datacomputer is a node specialized for data management,\
    \ and\nacting as a data utility for the other nodes.  The Arpanet, for which\n\
    the datacomputer is being developed, is an international network which\nhas over\
    \ 60 nodes.  Of these, some are presently specialized for\nterminal handling,\
    \ others are specialized for computation (e.g., the\nILLIAC IV), some are general\
    \ purpose service nodes (e.g., MULTICS) and\none (CCA) is specialized for data\
    \ management.\n1.2 Datalanguage\nDatalanguage is the language in which all requests\
    \ to the datacomputer\nare stated.  It includes facilities for data description\
    \ and creation,\nfor retrieval of or changes to stored data, and for access to\
    \ a variety\nof auxiliary facilities and services.  In datalanguage it is possible\
    \ to\nspecify any operation the datacomputer is capable of performing.\nDatalanguage\
    \ is the only language accepted by the datacomputer and is\nthe exclusive means\
    \ of access to data and services.\n1.3 Present Design Effort\nWe are now engaged\
    \ in developing complete specifications for\ndatalanguage; this is the second\
    \ iteration in the language design\nprocess.\nA smaller, initial design effort\
    \ developed some concepts and principles\nwhich are described in the third working\
    \ paper in this series.  These\nhave been used as the basis of software implementations\
    \ resulting in an\ninitial network service capability.  A user manual for this\
    \ system was\npublished as working paper number 7.\nAs a result of experience\
    \ gained in implementation and service, through\nfurther study of user requirements\
    \ and work with potential users, and\nthrough investigation of other work in the\
    \ data management field, quite\na few ideas have been developed for the improvement\
    \ of datalanguage.\nThese are being assimilated into the language design in the\
    \ iteration\nnow in progress.\nWhen the language design is complete, it will be\
    \ incorporated into the\nexisting software (requiring changes to the language\
    \ compiler, but\nhaving little impact on the rest of the system).\nDatacomputer\
    \ users will first have access to the new language during\n1975.\n1.4 Purpose\
    \ of this Paper\nThis paper presents concepts and preliminary results, rather\
    \ than a\ncompleted design.  There are two reasons for publishing now.\nThe first\
    \ is to provide information to those planning to use the\ndatacomputer.  They\
    \ may benefit from knowledge of our intentions for\ndevelopment.\nThe second is\
    \ to enable system and language designers to comment on our\nwork before the design\
    \ is frozen.\n1.5 Organization of the Paper\nThe remainder of the paper is divided\
    \ into four sections.\nSection 2 discusses the most global considerations for\
    \ language design.\nThis comprises our view of the problem; it has influenced\
    \ our work to\ndate and will determine most of our actions in completion of the\
    \ design.\nThis section provides background for section 3, and reviews some\n\
    material that will be familiar to those who have been following our work\nclosely.\n\
    Section 3 discusses some of the specific issues we have worked on.  The\nemphasis\
    \ is on solutions and options for solution.\nIn sections 2 and 3 we are presenting\
    \ our \"top-down\" work: this is the\nthinking we have done based on known requirements\
    \ and our conception of\nthe desirable properties of datalanguage.\nWe have also\
    \ been working from the opposite end, developing the\nprimitives from which to\
    \ construct the language.  Section 4 presents our\nwork in this area: a model\
    \ datacomputer which will ultimately provide a\nprecise semantic definition of\
    \ datalanguage.  Section 4 explains that\npart of the model which is complete,\
    \ and relates this to our other work.\nSection 5 discusses work that remains,\
    \ both on the model and in our\ntop-down analysis.\n2.  Considerations for Language\
    \ Design\n2.1 Introduction\nData management is the task of managing data as a\
    \ resource, independent\nof hardware and applications programs.  It can be divided\
    \ it into five\nmajor sub-tasks:\n    (1) _creating_ databases in storage,\n \
    \   (2) making the data _available_ (e.g., satisfying queries),\n    (3) _maintaining_\
    \ the data as information is added, deleted and\n        modified,\n    (4) assuring\
    \ the _integrity_ of the data (e.g., through backup and\n        recovery systems,\
    \ through internal consistency checks),\n    (5) _regulating_access_, to protect\
    \ the databases, the system, and\n        the privacy of users.\nThese are the\
    \ major data-related functions of the datacomputer; while\nthe system will ultimately\
    \ provide other services (such as accounting\nfor use, monitoring performance)\
    \ these are really auxiliary and common\nto all service facilities.\nThis section\
    \ presents global considerations for the design of\ndatalanguage, based on our\
    \ observations about the problem and the\nenvironment in which it is to be solved.\
    \  The central problem is data\nmanagement, and the datacomputer shares the same\
    \ goals as many currently\navailable data management systems.  Several aspects\
    \ of the datacomputer\ncreate a unique set of problems to be solved.\n2.2 Hardware\
    \ Considerations\n2.2.1 Separate Box\nThe datacomputer is a complete data management\
    \ utility in a separate,\nclosed box.  That is, the hardware, the data and the\
    \ data management\nsoftware are segregated from any general-purpose processing\
    \ facilities.\nThere is a separate installation dedicated to data management.\n\
    Datalanguage is the only means users have for communicating with the\ndatacomputer\
    \ and the sole activity of the datacomputer is to process\ndatalanguage requests.\n\
    Dedicating hardware provides an obvious advantage: one can specialize it\nfor\
    \ data management.  The processor(s) can be modified to have data\nmanagement\
    \ \"instructions\"; common low-level software functions can be\nbuilt into the\
    \ hardware.\nA less obvious, but possibly more significant, advantage is gained\
    \ from\nthe separateness itself.  The system can be more easily protected.  A\n\
    fully-developed datacomputer on which there is only maintenance activity\ncan\
    \ provide a very carefully controlled environment.  First, it can be\nmade as\
    \ physically secure as required.  Second, it needs to execute only\nsystem software\
    \ developed at CCA; all user programs are in a high-level\nlanguage (datalanguage)\
    \ which is effectively interpreted by the system.\nHence, only datacomputer system\
    \ software processes the data, and the\nsystem is not very vulnerable to capture\
    \ by a hostile program.  Thus,\nsince there is the potential to develop data privacy\
    \ and integrity\nservices that are not available on general-purpose systems, one\
    \ can\nexpect less difficulty in developing privacy controls (including\nphysical\
    \ ones) for the datacomputer than for the systems it serves.\n2.2.2 Mass Storage\
    \ Hardware\nThe datacomputer will store most of its data on mass storage devices,\n\
    which have distinctive access characteristics.  Two examples of such\nhardware\
    \ are Precision Instruments' Unicon 690 and Ampex Corporation's\nTBM system. \
    \ They are quite different from disks, and differ\nsignificantly from one another.\n\
    However, almost all users will be ignorant of the characteristics of\nthese devices;\
    \ many will not even know that the data they use is at the\ndatacomputer.  Finally,\
    \ as the development of the system progresses,\ndata may be invisibly shunted\
    \ from one datacomputer to another, and as a\nresult be stored in a physical format\
    \ quite different from that\noriginally used.\nIn such an environment, it is clear\
    \ that requests for data should be\nstated in logical, not physical terms.\n2.3\
    \ Network Environment\nThe network environment provides additional requirements\
    \ for\ndatacomputer design.\n2.3.1 Remote Use\nSince the datacomputer is to be\
    \ accessed remotely, the requirement for\neffective data selection techniques\
    \ and good mechanisms for the\nexpression of selection criteria is amplified.\
    \  This is because of the\nnarrow path through which network users communicate\
    \ with the\ndatacomputer.  Presently, a typical process-to-process transfer rate\n\
    over the Arpanet is 30 kilobits per second.  While this can be increased\nthrough\
    \ optimization of software and protocols, and through additional\nexpenditure\
    \ for hardware and communications lines, it seems safe to\nassume that it will\
    \ not soon approach local transfer rates (measured in\nthe megabits per second).\n\
    A typical request calls for either transfer of part of a file to a\nremote site,\
    \ or for selective update to a file already stored at the\ndatacomputer.  In both\
    \ of these situations, good mechanisms for\nspecifying the parts of the data to\
    \ be transmitted or changed will\nreduce the amount of data ordinarily transferred.\
    \  This is extremely\nimportant because with the low per bit cost of storing data\
    \ at the\ndatacomputer, transmission costs will be a significant part of the total\n\
    cost of datacomputer usage.\n2.3.2 Interprocess Use of the Datacomputer System\n\
    Effective use of the network requires that groups of processes, remote\nfrom one\
    \ another, be capable of cooperating to accomplish a given task\nor provide a\
    \ given service.  For example, to solve a given problem which\ninvolves array\
    \ manipulation, data retrieval, interaction with a user at\na terminal, and the\
    \ generalized services of a language like PL/I, it may\nbe most economical to\
    \ have four cooperating processes.  One of these\ncould execute at the ILLIAC\
    \ IV, one at the datacomputer, one at MULTICS,\nand one at a TIP.  While there\
    \ is overhead in setting up these four\nprocesses and in having them communicate,\
    \ each is doing its job on a\nsystem specialized for that job.  In many cases,\
    \ the result of using the\nspecialized system is a gain of several orders of magnitude\
    \ in economy\nor efficiency (for example, online storage at the datacomputer has\
    \ a\ncapital cost two orders of magnitude lower than online costs on\nconventional\
    \ systems).  As a result, there is considerable incentive to\nconsider solutions\
    \ involving cooperating processes on specialized\nsystems.\nTo summarize: the\
    \ datacomputer must be prepared to function as a\ncomponent of small networks\
    \ of specialized processes, in order that it\ncan be used effectively in a network\
    \ in which there are many specialized\nnodes.\n2.3.3 Common Network Data Handling\n\
    A large network can support enough data management hardware to construct\nmore\
    \ than one datacomputer.  While this hardware can be combined into\none even larger\
    \ datacomputer, there are advantages to configuring it as\ntwo (or possibly more)\
    \ systems.  Each system should be large enough to\nobtain economies of scale in\
    \ data storage and to support the data\nmanagement software.  Important data bases\
    \ can be duplicated, with a\ncopy at each datacomputer; if one datacomputer fails,\
    \ or is cut off by\nnetwork failure, the data is still available. Even if duplicating\
    \ the\nfile is not warranted, the description can be kept at the different\ndatacomputers\
    \ so that applications which need to store data constantly\ncan be guaranteed\
    \ that at least one datacomputer is available to receive\ninput.\nThese kinds\
    \ of failure protection involve cooperation between a pair of\ndatacomputers;\
    \ in some sense, they require that the two datacomputers\nfunction as a single\
    \ system.  Given a system of datacomputers (which one\ncan think of as a small\
    \ network of datacomputers), it is obviously\npossible to experiment with providing\
    \ additional services on the\ndatacomputer-network level.  For example, all requests\
    \ could be\naddressed simply to the datacomputer-network; the datacomputer-network\n\
    could then determine where each referenced file was stored (i.e., which\ndatacomputer),\
    \ and how best to satisfy the request.\nHere, two kinds of cooperation in the\
    \ network environment have been\nmentioned: cooperation among processes to solve\
    \ a given problem, and\ncooperation among datacomputers to provide global optimizations\
    \ in the\nnetwork-level data handling problem.  These are only two examples,\n\
    especially interesting because they can be implemented in the near term.\nIn the\
    \ network, much more general kinds of cooperation are possible, if\na little farther\
    \ in the future.  For example, eventually, one might want\nthe datacomputer(s)\
    \ to be part of a network-wide data management system,\nin which data, directories,\
    \ services, and hardware were generally\ndistributed about the network.  The entire\
    \ system could function as a\nwhole under the right circumstances.  Most requests\
    \ would use the data\nand services of only a few nodes.  Within this network-wide\
    \ system,\nthere would be more than one data management system, but all systems\n\
    would be interfaced through a common language.  Because the\ndatacomputers represent\
    \ the largest data management resource in the\nnetwork, they would certainly play\
    \ an important role in any network-wide\nsystem.  The language of the datacomputer\
    \ (datalanguage) is certainly a\nconvenient choice for the common language of\
    \ such a system.\nThus a final, albeit futuristic, requirement imposed by the\
    \ network on\nthe design of the datacomputer system, is that it be a suitable\
    \ major\ncomponent for network-wide data management systems. If feasible, one\n\
    would like datalanguage to be a suitable candidate for the common\nlanguage of\
    \ a network-wide group of cooperating data management systems.\n2.4 Different\
    \ Modes of Datacomputer Usage\nWithin this network environment, the datacomputer\
    \ will play several\nroles.  In this section four such roles are described. Each\
    \ of them\nimposes constraints on the design of datalanguage.  We can analyze\
    \ them\nin terms of four overlapping advantages which the datacomputer provides:\n\
    \    1.  Generalized data management services\n    2.  Large file handling\n \
    \   3.  Shared access\n    4.  Economic volume storage\nOf course, the primary\
    \ reason for using the datacomputer will be the\ndata management services which\
    \ it provides.  However, for some\napplications size will be the dominating factor\
    \ in that the datacomputer\nwill provide for online access to files which are\
    \ so large that\npreviously only offline storage and processing were possible.\
    \  The\nability to share data between different network sites with widely\ndifferent\
    \ hardware is another feature provided only by the datacomputer.\nEconomies of\
    \ scale make the datacomputer a viable substitute for tapes\nin such applications\
    \ as operating system backup.\nNaturally, a combination of the above factors will\
    \ be at work in most\ndatacomputer applications.  The following subsections describe\
    \ some\npossible modes of interaction with the datacomputer.\n2.4.1 Support of\
    \ Large Shared Databases\nThis is the most significant application of the datacomputer,\
    \ in nearly\nevery sense.\nProjects are already underway which will put databases\
    \ of over one\nhundred billion bits online on the Arpanet datacomputer.  Among\
    \ these\nare a database which will ultimately include 10 years of weather\nobservations\
    \ from 5000 weather stations located all over the world.  As\nonline databases,\
    \ these are unprecedented in size. They will be of\ninternational interest and\
    \ be shared by users operating on a wide\nvariety of hardware and in a wide variety\
    \ of languages.\nBecause these databases are online in an international network,\
    \ and\nbecause they are expected to be of considerable interest to researchers\n\
    in the related fields, it seems obvious that there will be extremely\nbroad patterns\
    \ of use.  A strong requirement, then, is a flexible and\ngeneral approach to\
    \ handling them.  This requirement of providing\ndifferent users of a database\
    \ with different views of the data is an\noverriding concern of the datalanguage\
    \ design effort.  It is discussed\nseparately in Section 2.5.\n2.4.2 Extensions\
    \ of Local Data management Systems\nWe imagine local data handling systems (data\
    \ management systems,\napplications-oriented packages, text-handling systems,\
    \ etc.) wanting to\ntake advantage of the datacomputer.  They may do so because\
    \ of the\neconomics of storage, because of the data management services, or\n\
    because they want to take advantage of data already stored at the\ndatacomputer.\
    \  In any case, such systems have some distinctive\nproperties as datacomputer\
    \ users: (1) most would use local data as well\nas datacomputer data, (2) many\
    \ would be concerned with the translation\nof local requests into datalanguage.\n\
    For example, a system which does simple data retrieval and statistical\nanalysis\
    \ for non-programming social scientists might want to use a\ncensus database stored\
    \ at the datacomputer.  Such a system may perform a\nrange of data retrieval functions,\
    \ and may need sophisticated\ninteraction with the datacomputer.  Its usage patterns\
    \ would make quite\na contrast with those of a single application program whose\
    \ sole use of\nthe datacomputer involves printing a specific report based on a\
    \ single\nknown file.\nThis social-science system would also use some local databases,\
    \ which it\nkeeps at its own site because they are small and more efficiently\n\
    accessed locally.  One would like it to be convenient to think of data\nthe same\
    \ way, whether it is stored locally or at the datacomputer.\nCertainly at the\
    \ lower levels of the local software, there will have to\nbe differences in interfacing;\
    \ it would be nice, however, if local\nconcepts and operations could easily be\
    \ translated into datalanguage.\n2.4.3 File Level Use of the Datacomputer\nIn\
    \ this mode of use, other computer systems take advantage of the online\nstorage\
    \ capacity of the datacomputer.  To these systems, datacomputer\nstorage represents\
    \ a new class of storage: cheaper and safer than tape,\nnearly as accessible as\
    \ local disk.  Perhaps they even automatically\nmove files between local online\
    \ storage and the datacomputer, giving\nusers the impression that everything is\
    \ stored locally online.\nThe distinctive feature of this mode of use is that\
    \ the operations are\non whole files.\nA system operating in this mode uses only\
    \ the ability to store,\nretrieve, append, rename, do directory listings and the\
    \ like.  An\nobvious way to make such file level handling easily available to\
    \ the\nnetwork community is to make use of the File Transfer Protocol (see\nNetwork\
    \ Information Center document #17759 -- File Transfer Protocol)\nalready in use\
    \ for host to host file transfer.\nAlthough such \"whole file\" usage of the datacomputer\
    \ would be motivated\nprimarily by economic advantages of scale, data sharing\
    \ at the file\nlevel could also be a concern.  For example, the source files of\
    \ common\nnetwork software might reside at the datacomputer. These files have\n\
    little or no structure, but their common use dictates that they be\navailable\
    \ in a common, always accessible place.  It is taking advantage\nof the economics\
    \ of the datacomputer, more than anything else, since\nmost of these services\
    \ are available on any file system.\nThis mode of use is mentioned here because\
    \ it may account for a large\npercentage of datalanguage requests.  It requires\
    \ only capabilities\nwhich would be present in datalanguage in any case; the only\
    \ special\nrequirement is to make sure it is easy and simple to accomplish these\n\
    tasks.\n2.4.4 Use of Datacomputer for File Archiving\nThis is another economics-oriented\
    \ application.  The basic idea is to\nstore on the datacomputer everything that\
    \ you intend to read rarely, if\never.  This could include backup files, audit\
    \ trails, and the like.\nAn interesting idea related to archiving is incremental\
    \ archiving. A\ntypical practice, with regard to backing up data stored online\
    \ in a\ntime-sharing system, is to write out all the pages which are different\n\
    than they were in the last dump.  It is then possible to recover by\nrestoring\
    \ the last full dump, and then restoring all incremental dumps\nup to the version\
    \ desired.  This system offers a lower cost for dumping\nand storage, and a higher\
    \ cost for recovery; it is appropriate when the\nprobability of needing a recovery\
    \ is low.  Datalanguage, then, should be\ndesigned to permit convenient incremental\
    \ archiving.\nAs in the case of the previous application (file system), archiving\
    \ is\nimportant as a design consideration because of its expected frequency\n\
    and economics, not because it necessarily requires any extra generality\nat the\
    \ language level. It may dictate that specialized mechanisms for\narchiving be\
    \ built into the system.\n2.5 Data Sharing\nControlled sharing of data is a central\
    \ concern of the project. Three\nmajor sub-problems in data sharing are: (1) concurrent\
    \ use, (2)\nindependent concepts of the same database, and (3) varying\nrepresentations\
    \ of the same database.\nConcurrent use of a resource by multiple independent\
    \ processes is\ncommonly implemented for data on the file level in systems in\
    \ which\nfiles are regarded as disjoint, unrelated objects.  It is sometimes\n\
    implemented on the page level.\nConsiderable work on this problem has already\
    \ been done within the\ndatacomputer project.  When this work is complete, it\
    \ will have some\nimpact on the language design; by and large however, we do not\
    \ consider\nthis aspect of concurrent use to be a language problem.\nOther aspects\
    \ of the concurrent use problem, however, may require more\nconscious participation\
    \ by the user.  They relate to the semantics of\ncollections of data objects,\
    \ when such collections span the boundaries\nof files known to the internal operating\
    \ system.  Here the question of\nwhat constitutes an update conflict is more complex.\
    \  Related questions\narise in backup and recovery. If two files are related,\
    \ then perhaps it\nis meaningless to recover an earlier state of one without recovering\
    \ the\ncorresponding state of the other.  These problems are yet to be\ninvestigated.\n\
    Another problem in data sharing is that not all users of a database\nshould have\
    \ the same concept of that database.  Examples: (1) for\nprivacy reasons, some\
    \ users should be aware of only part of the database\n(e.g., scientists doing\
    \ statistical studies on medical files do not need\naccess to name and address),\
    \ (2) for program-data independence, payroll\nprograms should access only data\
    \ of concern in writing paychecks, even\nthough skill inventories may be stored\
    \ in the same database, (3) for\nglobal control of efficiency, simplicity in application\
    \ programming, and\nprogram-data independence each application program should\
    \ \"see\" a data\norganization that is best for its job.\nTo further analyze example\
    \ (3), consider a database which contains\ninformation about students, teachers,\
    \ subjects and also indicates which\nstudents have which teachers for which subjects.\
    \  Depending on the\nproblem to be solved, an application program may have a strong\n\
    requirement for one of the following organizations:\n(1) entries of the form (student,teacher,subject)\
    \ with no concern about\n    redundancy.  In this organization an object of any\
    \ of the three\n    types may occur many times.\n(2) entries of the form\n   \
    \          (student,       (teacher,subject),\n                             (teacher,subject),\n\
    \                             .\n                             .\n            \
    \                 .\n                             (teacher,subject))\n(3) entries\
    \ of the form\n             (teacher,       subject,(student...student),\n   \
    \                          subject,(student...student),\n                    \
    \         subject,(student.. .student))\nand other organizations are certainly\
    \ possible.\nOne approach to this problem is to choose an organization for stored\n\
    data, and then have application programs write requests which organize\noutput\
    \ in the form they want.  The application programmer applies his\ningenuity in\
    \ stating the request so that the process of reorganization\nis combined with\
    \ the process of retrieval, and the result is relatively\nefficient.  There are\
    \ important, practical situations in which this\napproach is adequate; in fact\
    \ there are situations in which it is\ndesirable. In particular, if efficiency\
    \ or cost is an overriding\nconsideration, it may be necessary for every application\
    \ programmer to\nbe aware of all the data access and organization factors.  This\
    \ may be\nthe case for a massive file, in which each retrieval must be tuned to\n\
    the access strategy and organization; any other mode of operation would\nresult\
    \ in unacceptable costs or response times.\nHowever, dependence between application\
    \ programs and data organization\nor access strategy is not a good policy in general.\
    \ In a widely-shared\ndatabase, it can mean enormous cost in the event of database\n\
    reorganization, changes to access software, or even changes in the\nstorage medium.\
    \  Such a change may require reprogramming in hundreds of\napplication programs\
    \ distributed throughout the network.\nAs a result, we see a need for a language\
    \ which supports a spectrum of\noperating modes, including: (1) application program\
    \ is completely\nindependent of storage structure, access technique, and reorganization\n\
    strategy, (2) application program parametrically controls these, (3)\napplication\
    \ program entirely controls them. For a widely-shared\ndatabase, mode (1) would\
    \ be the preferred policy, except when (a) the\napplication programmer could do\
    \ a better job than the system in making\ndecisions, and (b) the need for this\
    \ increment of efficiency outweighed\nthe benefits of program-data independence.\n\
    In evaluating this question for a particular application, it is\nimportant to\
    \ realize the role of global efficiency analysis.  When there\nare many users\
    \ of a database, in some sense the best mode of operation\nis that which minimizes\
    \ the total cost of processing all requests and\nthe total cost of storing the\
    \ data.  When applications come and go, as\nreal-world needs change, then the\
    \ advantages of centralized control are\nmore likely to outweigh the advantages\
    \ of optimization for a particular\napplication program.\nThe third major sub-problem\
    \ arises in connection with item level\nrepresentations.  Because of the environment\
    \ in which it executes, each\napplication program has a preferred set of formatting\
    \ concepts, length\nindicators, padding and alignment conventions, word sizes,\
    \ character\nrepresentations, and so on.  Once again it is better policy for the\n\
    application program to be concerned only with the representations it\nwants and\
    \ not with the stored data representation.  However, there will\nbe cases in which\
    \ efficiency for a given request overrides all other\nfactors.\nAt this level\
    \ of representation, there is at least one additional\nconsideration: potential\
    \ loss of information when conversion takes\nplace.  Whoever initiates a type\
    \ conversion (and this will sometimes be\nthe datacomputer and sometimes the application\
    \ program) must also be\nresponsible for seeing that the intent of the request\
    \ is preserved.\nSince the datacomputer must always be responsible for the consistency\n\
    and the meaning of a shared database, there are some conflicts to be\nresolved\
    \ here.\nTo summarize, it seems that the result of wide sharing of databases is\n\
    that a larger system must be considered in choosing a data management\npolicy\
    \ for a particular database.  This larger system, in the case of\nthe datacomputer,\
    \ consists of a network of geographically distributed\napplications programs,\
    \ a centralized database, and a centralized data\nmanagement system.  The requirement\
    \ for datalanguage is to provide\nflexibility in the management of this larger\
    \ system.  In particular, it\nmust be possible to control when and where conversions,\
    \ data re-\norganizations, and access strategies are made.\n2.6 Need for High\
    \ Level Communication\nAll of the above considerations point to the need for high\
    \ level\ncommunication between the datacomputer and its users.  The complex and\n\
    distinct nature of datacomputer hardware make it imperative that\nrequests be\
    \ put to the datacomputer so that it can make major decisions\nregarding the access\
    \ strategies to be used.  At the same time, the large\namounts of data stored\
    \ and the demand of some users for extremely high\ntransmission bandwidths make\
    \ it necessary to provide for user control of\nsome storage and transmission schemes.\
    \  The fact that databases will be\nused by applications which desire different\
    \ views of the same data and\nwith different constraints means that the datacomputer\
    \ must be capable\nof mapping one users request onto another users data.  Interprocess\
    \ use\nof the datacomputer means that datasharing must be completely\ncontrollable\
    \ to avoid the need for human intervention. Extensive\nfacilities for ensuring\
    \ data integrity and controlling access must be\nprovided.\n2.6.1 Data Description\n\
    Basic to all these needs is the requirement that the data stored at the\ndatacomputer\
    \ be completely described in both functional and physical\nparameters.  A high\
    \ level description of the data is especially\nimportant to provide the sharing\
    \ and control of data.  The datacomputer\nmust be able to map between different\
    \ hardware and different\napplications. In its most trivial form this means being\
    \ able to convert\nbetween floating point number representations on different\
    \ machines.  On\nthe other extreme it means being able to provide matrix data\
    \ for the\nILLIAC IV as well as being able to provide answers to queries from\
    \ a\nnatural language program, both addressed to the same weather data base.\n\
    Data descriptions must provide the ability to specify the bit level\nrepresentations\
    \ and the logical properties and relationships of data.\n2.6.2 Data integrity\
    \ and Access Control\nIn the environment we have been describing, the problems\
    \ of maintaining\ndata integrity and controlling use of data assume extreme importance.\n\
    Shared use of datacomputer files depends on the ability of the\ndatacomputer to\
    \ guarantee that the restrictions on data-access are\nstrictly enforced.  Since\
    \ different users will have different\ndescriptions, the access control mechanism\
    \ must be associated with the\ndescriptions themselves.  One can control access\
    \ to data by controlling\naccess to its various descriptors.  A user can be constrained\
    \ to access\na given data base only through one specific description which limits\
    \ the\ndata he can access.  In a system where the updaters of a database may be\n\
    unknown to each other, and possibly have different views of the data,\nonly the\
    \ datacomputer can assure data integrity.  For this reason, all\nrestrictions\
    \ on possible values of data objects, and on possible or\nnecessary relationships\
    \ between objects must be stated in the data\ndescription.\n2.6.3 Optimization\n\
    The decisions regarding data access strategy must ordinarily be made at\nthe datacomputer,\
    \ where knowledge of the physical considerations is\navailable.  These decisions\
    \ cannot be made intelligently unless the\nrequests for data access are made at\
    \ a high level.\nFor example, compare the following two situations: (1) a request\
    \ calls\nfor output of _all_ weather observations made in California exhibiting\n\
    certain wind and pressure conditions, (2) a series of requests is sent,\neach\
    \ one retrieving California weather observations; when a request\nfinds an observation\
    \ with the required wind and pressure conditions, it\ntransmits this observation\
    \ to a remote system.  Both sessions achieve\nthe same result: the transmission\
    \ of a certain set of observations to a\nremote site for processing.  In the first\
    \ session, however, the\ndatacomputer receives, at the outset, a description of\
    \ the data that is\nneeded; in the second, it processes a series of requests,\
    \ each one of\nwhich is a surprise.\nIn the first case, a smart datacomputer has\
    \ the option of retrieving all\nof the needed data in one access to the mass storage\
    \ device.  It can\nthen buffer this data on disk until the user is ready to accept\
    \ it.  In\nthe second case, the datacomputer lacks the information it needs to\
    \ make\nsuch an optimization.\nThe language should permit and encourage users\
    \ to provide the\ninformation needed to do optimization.  The cost of not doing\
    \ it is much\nhigher with mass storage devices and large files than it is in\n\
    conventional systems.\n2.7 Application Oriented Concerns\nIn the above sections\
    \ we have described a number of features which the\ndatacomputer system must provide.\
    \  In this section we focus on what is\nnecessary to make these features readily\
    \ available to users of the\ndatacomputer.\n2.7.1 Datacomputer-user Interaction\n\
    An application interacts with the datacomputer in a _session_.  A\nsession consists\
    \ of a series of requests.  Each session involves\nconnecting to the datacomputer\
    \ via the network, establishing identities,\nand setting up transmission paths\
    \ for both data and datalanguage.\nDatalanguage is transmitted in character mode\
    \ (using network standard\nASCII) over the datalanguage connection. Error and\
    \ status messages are\nsent over this connection to the application program.\n\
    The data connection (called a PORT) is viewed as a bit stream and is\ngiven its\
    \ own description. These descriptions are similar to those given\nfor stored data.\
    \  At a minimum this description must contain enough\ninformation for the datacomputer\
    \ to parse the incoming bit stream.  It\nalso may contain data validation information\
    \ as well.  To store data at\nthe datacomputer, the stored data must also have\
    \ a description.  The\nuser supplies the mapping between the descriptions of the\
    \ stored and\ntransmitted data.\n _____________________________________\n|   \
    \                                  |        / /\n|  ______     ___________   \
    \          |        \\ \\\n| |      |---|           |            |        / /\n\
    | |      |   |   DATA    |            |        \\ \\\n| |      |   |DESCRIPTION|\
    \   _______  |    DATALANGUAGE     ___________\n| |      |   |___________|  |\
    \       |<-------------------->|           |\n| |STORED|         |________| USER\
    \  | |        PATH        |APPLICATION|\n| | DATA |__________________|REQUEST|\
    \ |                    |  PROGRAM  |\n| |      |                  |_______|<----!--------------->|___________|\n\
    | |      |               ___________  |   !   DATA PATH\n| |      |          \
    \    |           | |   !    / /\n| |      |              |   PORT    |-----! \
    \   \\ \\\n| |      |              |DESCRIPTION| |        / /\n| |______|    \
    \          |___________| |        \\ \\\n|_____________________________________|\
    \        / /\n                                             NETWORK\n         \
    \                      Figure 2-1\n                A Model of Datacomputer/User\
    \ Interaction\n2.7.2 Application Features for Data Sharing\nIn using data stored\
    \ at the datacomputer, users may supply a description\nof the data which is customized\
    \ to the application. This description is\nmapped onto the description of the\
    \ stored data. These descriptions may\nbe at different levels.  That is, one may\
    \ merely rearrange the order of\ncertain items, while another could call for a\
    \ total restructuring of the\nstored representation. So that each user may be\
    \ able to build upon the\ndescriptions of another, data entities should be given\
    \ named types.\nThese type definitions are of course to be stored along with the\
    \ data\nthey describe.  In addition, certain functions are so closely tied to\n\
    the data (in fact may be the data in the virtual description case -- see\nsection\
    \ 3), that they must also reside in the datacomputer and their tie\nwith the data\
    \ items should be maintained by the datacomputer.  For\nexample, one user can\
    \ describe a data base as made up of structures\ncontaining data of the types\
    \ _latitude_ and _longitude_.  He could also\ndescribe functions for comparing\
    \ data of this type.  Other users, not\nconcerned with the structure of the _latitude_\
    \ component itself, but\ninterested in using this information simply to extract\
    \ other fields of\ninterest can then use the commonly provided definitions and\
    \ functions.\nFurthermore, by adopting this strategy as many users as possible\
    \ can be\nmade insensitive to changes in the file which are tangential to their\n\
    main interests.  For example, _latitudes_ could be changed from binary\nrepresentation\
    \ to a character form and if use of that field were\nrestricted to its definitions\
    \ and associated functions, existing\napplication systems would be unaffected.\
    \  Conversion functions could be\ndefined to eliminate the impact on currently\
    \ operating programs.  The\nability of such definitional facilities means that\
    \ groups of users can\ndevelop common functions and descriptions for dealing with\
    \ shared data\nand that conventions for use of shared data can be enforced by\
    \ the\ndatacomputer.  These facilities are discussed under _extensibility_ in\n\
    Section 3.\n ___________________________________________      _______________\n\
    |                             ____________  |    |  ___________  |\n|        \
    \                    |APPLICATION | |    | |APPLICATION| |\n|                \
    \           _|    DATA    |_|____|_|  PROGRAM  | |\n|                        \
    \  | |DESCRIPTIONS| |    | |___________| |\n|                          | |____________|\
    \ |    |_______________|\n|                          |       ^        |      \
    \    HOST 1\n|  ______                  |       |        |\n| |      |       \
    \          |  _____|______  |\n| |      |                 | |    DATA    | |\n\
    | |      |                 | | FUNCTIONS  | |\n| |      |                 | |____________|\
    \ |     _______________\n| |      |   ___________   |  ____________  |    |  ___________\
    \  |\n| |      |  |  STORED   |__| |            | |    | |APPLICATION| |\n| |\
    \      |__|   DATA    |____|            |_|____|_|  PROGRAM  | |\n| |STORED| \
    \ |DESCRIPTION|__  |            | |    | |___________| |\n| | DATA |  |___________|\
    \  | |____________| |    |               |\n| |      |        ^        |  ____________\
    \  |    |  ___________  |\n| |      |        |        | |            | |    |\
    \ |APPLICATION| |\n| |      |   _____|_____   | |            |_|____|_|  PROGRAM\
    \  | |\n| |      |  |   DATA    |  |_|            | |    | |___________| |\n|\
    \ |      |  | FUNCTIONS |    |____________| |    |_______________|\n| |______|\
    \  |___________|                   |          HOST 2\n|___________________________________________|\n\
    \                DATACOMPUTER\n                               Figure 2-2\n   \
    \         Multiple User Interaction with the Datacomputer\n2.7.3 Communication\
    \ Model\nWe intend that datalanguage, while at a high level conceptually, will\
    \ be\nat a low level syntactically.  Datalanguage provides a set of primitive\n\
    functions, and a set of commonly used higher level functions (see\nsection 4 on\
    \ the datalanguage model).  In addition, users can define\ntheir own functions\
    \ so that they can communicate with the datacomputer\nat a level as conceptually\
    \ close to the application as possible.\nThere are two reasons for datalanguage\
    \ being at a low level\nsyntactically.  First, it is undesirable to have programs\
    \ composing\nrequests into an elaborate format only to be decomposed by the\n\
    datacomputer.  Second, by choosing a specific high level syntax, the\ndatacomputer\
    \ would be imposing a set of conventions and terminology\nwhich would not necessarily\
    \ correspond to those of most users.\n   DATACOMPUTER ENVIRONMENT     |      OUTSIDE\
    \ ENVIRONMENT\n                                |           _______\n         \
    \                                  |       |____\n                           \
    \     |        __|GENERAL|____\n                                        |  | \
    \ DMS  |____\n                                |       |  |_______|\n _________\
    \     ________     _________   |\n|         |   | HIGHER |   |         |__|  \
    \ _______     ________\n|PRIMITIVE|___| LEVEL  |___|LOW-LEVEL|_____|COBOL  | \
    \  | COBOL  |\n|LANGUAGE |   |LANGUAGE|   | SYNTAX  |__   |SERVER |___|PROGRAM\
    \ |\n|_________|   |________|   |_________|  |  |_______|   |________|\n     \
    \                           |       |   _______\n                            \
    \            |__|ON LINE|\n                                |          | QUERY\
    \ |_______\n                                           |_______|       |\n   \
    \                             |                       ___|____\n             \
    \                                          |TERMINAL|\n                      \
    \          |                      | USERS  |\n                               \
    \                        |________|\n                                |\n     \
    \                                    APPLICATION  APPLICATIONS\n             \
    \                   |          SERVERS\n                               Figure\
    \ 2-3\n                 Datacomputer/User Working Environment\n2.8 Summary\nIn\
    \ this section we have presented the major considerations which have\ninfluenced\
    \ the current datalanguage design effort.  The datacomputer has\nmuch in common\
    \ with most large-scale shared data management systems, but\nalso has a number\
    \ of overriding concerns unique to the datacomputer\nconcept.  The most important\
    \ of these are the existence of a separate\nbox containing both hardware and software,\
    \ the control of an extremely\nlarge storage device, and embedding in a computer\
    \ network environment.\nData sharing in such an environment is a central concern\
    \ of the design.\nBoth extensive data description facilities and high level communication\n\
    between user and datacomputer are necessary for data integrity and for\ndatacomputer\
    \ optimization of user requests.  In addition, the expected\nuse of the datacomputer\
    \ involves satisfying several conflicting\nconstraints for different modes of\
    \ operation.  One way of satisfying\nvarious user needs is to provide datalanguage\
    \ features so that users may\ndevelop their own application packages within datalanguage.\n\
    3. Principal Language Concepts\nThis section discusses the principal facilities\
    \ of datalanguage.\nSpecific details of the language are not presented, however,\
    \ the\ndiscussion includes the motivation behind the inclusion of the various\n\
    language features and also defines, in an informal way, the terms we\nuse.\n3.1\
    \ Basic Data Items\nBasic data are the atomic level of all data constructions;\
    \ they cannot\nbe decomposed.  All higher level data structures are fundamentally\n\
    composed of basic data items.  Many types of basic data items will be\nprovided.\
    \  The type of an item determines what operations can be\nperformed on the item\
    \ and the meaning of those operations.  Datalanguage\nwill provide those primitive\
    \ types of data items which are commonly used\nin computing systems to model the\
    \ real world.\nThe following basic types of data will be available in datalanguage:\n\
    _fixed_point_numbers_, _floating_point_numbers_, _characters_,\n_booleans_, and\
    \ _bits_. These types of items are \"understood\" by the\ndatacomputer system\
    \ to the extent that operations are based on the type\nof an item.  Datalanguage\
    \ will also include an _uninterpreted_ type of\nitem, for data which will only\
    \ be moved (including transmitted) from one\nplace to another. This type of data\
    \ will only be understood in the\ntrivial sense that the datacomputer can determine\
    \ if two items of the\nuninterpreted type are identical.  Standard operations\
    \ on the basic\ntypes of items will be available.  Operations will be included\
    \ so that\nthe datacomputer user can describe a wide range of data management\n\
    functions.  They are not included with the intent of encouraging use of\nthe datacomputer\
    \ for the solving of highly computational problems.\n3.2 Data Aggregates\nData\
    \ aggregates are compositions of basic data items and possibly other\ndata aggregates.\
    \  The types of data aggregates which are provided allow\nfor the construction\
    \ of hierarchical relationships of data.  The\naggregates which will definitely\
    \ be available are classified as\n_structs_, _arrays_, _strings_, _lists_, and\
    \ _directories_.\nA struct is a static aggregate of data items (called _components_).\
    \  A\nstruct is static in the sense that the components of a struct cannot be\n\
    added or deleted from the struct, they are inextricably bound to the\nstruct.\
    \  Associated with each component of the struct is a name by which\nthat component\
    \ may be referenced relative to the struct.  The struct\naggregate may be used\
    \ to model what is often thought of as a record,\nwith each component being a\
    \ field of that record.  A struct can also be\nused to group components of a record\
    \ which are more strongly related,\nconceptually, than other components and may\
    \ be operated on together.\nArrays allow for repetition in data structures.  An\
    \ array, like a\nstruct, is a static aggregate of data items (called _members_).\
    \ Each\nmember of an array is of the same type.  Associated with each member is\n\
    an index by which that member can be referenced relative to the array.\nArrays\
    \ can he used to model repeating data in a record (repeating\ngroups).\nThe concept\
    \ of string is actually a hybrid of basic data and data\naggregates.  Strings\
    \ are aggregates in that they are compositions\n(similar to arrays) of more primitive\
    \ data (e.g., characters). They are,\nhowever, generally conceived of as basic\
    \ in that they are mostly viewed\nas a unit rather than as a collection of items,\
    \ where each item has\nindividual importance. Also the meaning of a string is\
    \ highly dependent\non the order of the individual components.  In more concrete\
    \ terms,\nthere are operations which are defined on specific types of strings.\n\
    For example, the logical operators (_and_, _or_, etc.) are defined to\noperate\
    \ on strings of bits.  However, there are no operations which are\ndefined on\
    \ arrays of bits, although there are operations defined on both\narrays, in general,\
    \ and on bits.  Strings of characters, bits, and\nuninterpreted data will be available\
    \ in datalanguage.\nLists are like arrays in that they are collection of similar\
    \ members.\nHowever, lists are dynamic rather than static.  Members of a list\
    \ can be\nadded and deleted from the list.  Although, the members of a list are\n\
    ordered (in fact more than one ordering can be defined on a list), the\nlist is\
    \ not intended to be referenced via an index, as is the case with\nan array. \
    \ Members of a list can be referenced via some method of\nsequencing through the\
    \ list.  A list member, or set (see discussion\nunder virtual data) of members,\
    \ can also be referenced, by some method\nof identification by content.  The list\
    \ structure can be used to model\nthe common notion of a file.  Also restrictive\
    \ use of lists as\ncomponents of structs provides power with respect to the construction\
    \ of\ndynamic hierarchical data relationships below the file level.  For\nexample,\
    \ the members of a list may themselves be, in part, composed of\nlists, as in\
    \ a list of families, where each family contains a list of\nchildren as well as\
    \ other information.\nDirectories are dynamic data aggregates which may contain\
    \ any type of\ndata item.  Data items contained in a directory are called _nodes_.\n\
    Associated with each node of a directory is a name by which that data\nitem can\
    \ be referenced relative to the directory. As with lists, items\nmay be dynamically\
    \ added to and deleted from a directory.  The primary\nmotivation behind providing\
    \ the directory capability is to allow the\nuser to group conceptually related\
    \ data together.  Since directories\nneed not contain only file type information,\
    \ \"auxiliary\" data can be\nkept as part of the directory.  For example, \"constant\"\
    \ information,\nlike salary range tables for a corporation data base; or user\
    \ defined\noperations and data types (see below) can be maintained in a directory\n\
    along with the data which may use this information.  Also directories\nmay themselves\
    \ be part of a directory, allowing for a hierarchy of data\ngrouping.\nDirectories\
    \ will also be defined so that system controlled information\ncan be maintained\
    \ with some of the subordinate items (e.g. time of\ncreation, time of update,\
    \ privacy locks, etc.).  It may also be possible\nto allow the data user to define\
    \ and control his own information which\nwould be maintained with the data. At\
    \ the least, the design of\ndatalanguage will allow for parametric control over\
    \ the information\nmanaged by the system.\nDirectories are the most general and\
    \ dynamic type of aggregate data.\nBoth the name and description (see below) of\
    \ directory nodes exist with\nthe nodes themselves, rather than as part of the\
    \ description of the\ndirectory.  Also the level of nesting of a directory is\
    \ dynamic since\ndirectories can be dynamically added to directories.  Directories\
    \ are\nthe only aggregate for which this is true.\nDatalanguage will also provide\
    \ some specific and useful variations of\nthe above data aggregates.  Structs\
    \ will be available which allow for\noptional components. In this case the existence\
    \ of a component would be\nbased on the contents of other components.  It may\
    \ also he possible to\nallow for the existence to be based on information found\
    \ at a higher\nlevel of data hierarchy.  Similarly, components with _unresolved_\
    \ type\nwill be provided.  That is the component may be one of a fixed number\
    \ of\ntypes.  The type of the component would be based on the contents of\nother\
    \ components of the struct.  It is also desirable to allow the type\nor existence\
    \ of a component to be based on information other than the\ncontents of other\
    \ components.  For instance, the type of one component\nmight be based on the\
    \ type of another component.  In general, we would\nlike for datalanguage to allow\
    \ for the attributes (see below) of one\nitem to be a function of the attributes\
    \ of other items.\nWe would also like to provide mixed lists.  Mixed lists are\
    \ lists which\ncontain more than one type of member.  In this case the members\
    \ would\nhave to be self defining.  That is, the type of all member would have\
    \ to\nbe \"alike\" to the degree that information which defines the type of that\n\
    member could be found.\nSimilar to components whose type is unresolved are Arrays\
    \ with\nunresolved length.  In this case, information defining the length of the\n\
    array must be carried with the array or perhaps with other components of\nan aggregate\
    \ which encompasses the array.\nIn all of the above cases the type of an item\
    \ is unresolved to some\ndegree and information which totally resolves the type\
    \ is carried with\nthe item.  It is possible that in some or perhaps all of these\
    \ cases the\ndatacomputer system could be responsible for the maintenance of this\n\
    information, making it invisible to the data user.\n3.3 General Relational Capabilities\n\
    The data aggregates described above allow for the modeling of various\nrelationships\
    \ among data.  All relationships which can be constructed\nare hierarchical.\n\
    Two approaches can he taken to provide the capability of modeling non-\nhierarchical\
    \ relationships.  New types of data aggregates can be\nintroduced which will broaden\
    \ the range of data relationships\nexpressible in datalanguage.  Or, a basic data\
    \ type of \"pointer\" can be\nintroduced which will serve as a primitive out of\
    \ which relations can be\nrepresented.  Pointer would be a data type which establishes\
    \ some kind\nof correspondence from one item to another.  That is, it would be\
    \ a\nmethod of finding one item, given another . Providing the ability to\nhave\
    \ items of type pointer does not necessitate the introduction of the\nconcept\
    \ of address which we deem to be a dangerous step.  For example,\nan item defined\
    \ to point to a record in a personnel file could contain a\nsocial security number\
    \ which is contained in each record of the file and\nuniquely identifies that\
    \ record.  In general a pointer is an item of\ninformation which can be used to\
    \ uniquely identify another item.\nWhile the pointer approach provides the greater\
    \ degree of flexibility,\nit does this at the price of relegating much of the\
    \ work to the user as\nwell as severely limiting the amount of control the datacomputer\
    \ system\nhas over the data.  A hybrid solution is possible, where some new\n\
    aggregate data types are provided as well as a restricted form of\npointer data\
    \ type.  While the approach to be taken is still being\nstudied, the datalanguage\
    \ design will include some method of expressing\nnon-hierarchical data structures.\n\
    3.4 Ordering of Data\nLists are generally viewed as ordered.  It is possible,\
    \ however, that a\nlist can be used to model a dynamic collection of similar items\
    \ which\nare not seen as ordered.  The unordered case is important, in that,\n\
    given this information the datacomputer can be more efficient since new\nmembers\
    \ can be added wherever it is convenient.\nThere are a number of ways a list can\
    \ be ordered.  For instance, the\nordering of a list can be based on the contents\
    \ of its members.  In the\nsimplest case this involves the contents of a basic\
    \ data item.  For\nexample, a list of structs containing information on employees\
    \ of a\ncompany may be ordered on the component which contains the employee's\n\
    social security number. More complex ordering criteria are possible.\nFor example,\
    \ the same list could be ordered alphabetically with respect\nto the employee's\
    \ last name.  In this case the ordering relation is a\nfunction of two items,\
    \ the last and first names.  The user might also\nwant to define his own ordering\
    \ scheme, even for orderings based on\nbasic data items.  An ordering could be\
    \ based on an employee's job title\nwhich might even utilize auxiliary data (i.e.\
    \ data external to the\nlist).  It is also possible to maintain a list in order\
    \ of insertion.\nIn the most general case, the user could dynamically define his\
    \ ordering\nby specification of where an item is to be placed as part of his\n\
    insertion requests.  In all of the above cases, data could be maintained\nin ascending\
    \ or descending order.\nIn addition to maintenance of a list in some order, it\
    \ is possible to\ndefine one or more orderings \"imposed\" on a list.  These orderings\
    \ must\nbe based on the contents of a list's members.  This situation is similar\n\
    to the concept of virtual data (see below) in that the list is not\nphysically\
    \ maintained in a given order, but retrieved as if it were.\nOrderings of this\
    \ type can be dynamically formed (see discussion of set\nunder virtual data).\
    \  Imposed orderings can be accomplished via the\nmaintenance of auxiliary structures\
    \ (see discussion under internal\nrepresentation) or by utilization of a sorting\
    \ strategy on retrievals.\nMuch work has been done with regard to effective implementation\
    \ of the\nmaintenance and imposition of orderings on lists.  This work is\ndescribed\
    \ in working paper number 2.\n3.5 Data Integrity\nAn important feature of any\
    \ data management system is the ability to\nhave the system insure the integrity\
    \ of the data.  Data needs to be\nprotected against erroneous manipulation by\
    \ people and against system\nfailure.\nDatalanguage will provide automatic validity\
    \ checks.  Many flavors need\nto be provided so that appropriate trade-offs can\
    \ be made between the\ndegree of insurance and the cost of validation.  The datalanguage\
    \ user\nwill be able to request constant validation: where validity checks are\n\
    made whenever the data is updated; validation on access: where validity\nchecks\
    \ are performed when data is referenced but before it is retrieved;\nregularly\
    \ scheduled validation: where the data is checked at regular\nintervals; background\
    \ validation: where the system will run checks in\nits spare time; and validation\
    \ on demand.  Constant validation and\nvalidation on access are actually special\
    \ cases of the more general\nconcept of event triggered validation.  In this case\
    \ the user specifies\nan event which will cause data validation procedures to\
    \ be invoked. This\nfeature can be used to accomplish such things as validation\
    \ following a\n\"batch\" of updates.  Also, some mechanism for specifying combinations\
    \ of\nthese types would be useful.\nIn order for some of the data validation techniques\
    \ to be effective, it\nmay be necessary to keep some data validation \"bookkeeping\"\
    \ information\nwith the data.  For example, information which can be used to determine\n\
    whether an item has been checked since it was last updated might be used\nto cause\
    \ validation on access if there has not been a recent background\nvalidation.\
    \  The datacomputer may provide for optional automatic\nmaintenance of such special\
    \ kinds of information.\nIn order for the datacomputer system to insure data validity,\
    \ the user\nmust define what valid is.  Two types of validation can be requested.\
    \ In\nthe first case the user can tell the datacomputer that a specific data\n\
    item may only assume one of a specific set of values.  For example, the\ncolor\
    \ component of a struct may only assume the values 'red', 'green',\nor 'blue'.\
    \  The other case is where some relation must hold between\nmembers of an aggregate.\
    \  For example, if the sex component of a struct\nis 'male' then the number of\
    \ pregnancies component must be 0.\nData validation is only half of the data integrity\
    \ picture. Data\nintegrity involves methods of restoring damaged data.  This requires\n\
    maintenance of redundant information.  Features will be provided which\nwill make\
    \ the datacomputer system responsible for the maintenance of\nredundant data and\
    \ possibly even automatic restoration of damaged data.\nIn section 2 we discussed\
    \ possible uses of the datacomputer for file\nbackup.  All features which are\
    \ provided for this purpose will also be\navailable as methods of maintaining\
    \ backup information for restoration\nof files residing at the datacomputer.\n\
    3.6 Privacy\nDatalanguage will have to provide extensive privacy and protection\n\
    capabilities.  In its simplest form a privacy lock is provided at the\nfile level.\
    \  The lock is opened with a password key.  Associated with\nthis key is a set\
    \ of privileges (reading, updating, etc.). Two degrees\nof generality are sought.\
    \  Privacy should be available at all levels of\ndata.  Therefore, groups of related\
    \ data, including groups of files\ncould be made private by creating private directories.\
    \  Also, specific\nfields of records could be made private by having private components\
    \ of\na struct where other components of the struct are visible to a wider (or\n\
    different) class of users.  We would also like the user to be able to\ndefine\
    \ his own mechanism.  In this way, very personalized, complex, and\nhence secure\
    \ mechanisms can be defined.  Also features such as 'everyone\ncan see his own\
    \ salary' might be possible.\n3.7 Conversion\nMany types of data are related in\
    \ that some or all of the possible\nvalues of one type of data have an \"obvious\"\
    \ translation to the values\nof another.  For example, the character '6' has a\
    \ natural translation to\nthe integer 6, or the six character string 'abc   '\
    \ (three trailing\nblanks) has a natural translation to the four character string\
    \ 'abc '\n(one trailing blank). Datalanguage will provide conversion capabilities\n\
    for the standard, commonly called for, translations. These conversions\ncan be\
    \ explicitly invoked by the user or implicitly invoked when data of\none type\
    \ is needed for an operation but data of another type is\nprovided.  In the case\
    \ of implicit invocation of conversion of data the\nuser will have control over\
    \ whether conversion takes place for a given\ndata item. More generally we would\
    \ like to provide a facility whereby\nthe user could specify conditions which\
    \ determine when an item is to be\nconverted.  Also, the user should be able to\
    \ define his own conversion\noperations, either for a conversion between types\
    \ which is not provided\nby the datacomputer system or to override the standard\
    \ conversion\noperation for some or all items of a given type.\n3.8 Virtual and\
    \ Derived Data\nOften, information important to users of data is embedded in that\
    \ data\nrather than explicitly maintained.  For example, the dollar value of an\n\
    individual's interest in a company in a file of stock holders.  Since\nthe value\
    \ of the company changes frequently, it is not feasible to\nmaintain this information\
    \ with each record. It is useful to be able to\nuse the file as if information\
    \ of this type was part of each record.\nWhen referencing the dollar value field\
    \ of a record, the datacomputer\nsystem would automatically use information in\
    \ the record, such as\npercentage of ownership in the company, possibly in conjunction\
    \ with\ninformation which is not part of the record but is maintained elsewhere,\n\
    such as company assets, to compute the dollar value.  In this way the\ndata user\
    \ need not be concerned with the fact that this information is\nnot actually maintained\
    \ in the record.\nThe _set_, which is a specific type of virtual container in\n\
    datalanguage, deserves special mention.  A set is a virtual list. For\nexample,\
    \ suppose there is a real list of people representing some\npopulation sample.\
    \  By real (or actual) data we mean data which is\nphysically stored at the datacomputer.\
    \  A set could be defined to\ncontain all members of this list who are automobile\
    \ owners.  The set\nconcept provides a powerful feature for viewing data as belonging\
    \ to\nmore than one collection without physical duplication.  Sets are also\n\
    useful, in that, they can be dynamically formed.  Given an actual list,\nsets\
    \ based on that list can be created without having been previously\ndescribed.\n\
    As mentioned above, virtual data can be very economical.  These\neconomies may\
    \ become most important with respect to the use of sets.\nSavings are found not\
    \ only in regard to storage requirements, but also\nin regard to processing efficiency.\
    \ Processing time can be reduced as a\nresult of calculations being performed\
    \ only when the data is accessed.\nThe ability to obtain efficient operation by\
    \ optimization becomes\ngreater when virtual data is defined in terms of other\
    \ virtual data.\nFor sets, large savings may be realized by straight forward\n\
    \"optimization\" of the nested calculations.\nThe above ideas are made more clear\
    \ by example. Having created a set of\nautomobile owners, A, a set of home owners,\
    \ HA, can be defined based on\nA.  The members of HA can be produced very efficiently,\
    \ in one step, by\nretrieving people who are both automobile owners and home owners.\
    \  This\nis more efficient than actually producing the set, A and then using it\n\
    to create HA.  This is true when one or both pieces of information\n(automobile\
    \ ownership and home ownership) are indexed (see discussion\nunder internal representation)\
    \ as well as when neither is indexed.\nThe same gains are achieved when operations\
    \ on virtual data are\nrequested.  For example, if a set, H, had been defined\
    \ as the set of\nhomeowners based on the original list of people, the set, HA,\
    \ could have\nbeen defined as the intersection (see discussion on operators) of\
    \ A and\nH.  In this case too, HA can be calculated in one step.  Use of sets\n\
    allows the user to request data manipulations in a form close to his\nconceptual\
    \ view, leaving the problem of effective processing of his\nrequest to the datacomputer.\n\
    Another use of virtual data is to accomplish data sharing.  An item\ncould be\
    \ defined, virtually, as the contents of another item.  If no\nrestriction is\
    \ placed on what this item can be, we have the ability to\ndefine two paths of\
    \ access to the same data.  Hence, data can be made\nsubordinate to two or more\
    \ aggregate structures. Stated another way,\nthere are two or more paths of access\
    \ to the data.  This capability can\nbe used to model data which is part of more\
    \ than one data relationship.\nFor example, two files could have the same records\
    \ without maintaining\nduplicate copies.\nIt will also be possible, via data sharing\
    \ to look at data in different\nways.  Shared data might behave differently depending\
    \ on how (and\nultimately by whom) it is accessed.  Although, the ability to have\n\
    multiple paths to the same data and the ability to have data which is\ncalculated\
    \ on access are both part of the general virtual data\ncapability, datalanguage\
    \ will probably provide these as separate\nfeatures, since they have different\
    \ usage characteristics.\nDerived data is similar to virtual data in that it is\
    \ redundant data\nwhich can be calculated from other information.  Unlike virtual\
    \ data it\nis physically maintained.  The user can choose between virtual and\n\
    derived data as a result of considering trade-offs based on: estimated\ncost of\
    \ calculation; frequency of update; estimated cost of storage; and\nfrequency\
    \ of access.  For example, suppose a file contains a list of\nbudgets for various\
    \ projects in a department.  The departmental budget\ncan be calculated as a function\
    \ of the individual project budgets.  This\ninformation might be defined as derived\
    \ data since it is expected to be\nupdated infrequently (e.g., once a year), while\
    \ it is expected to be\naccessed relatively often.\nOptions will be provided which\
    \ give the user control with regard to when\nthe calculation of derived data is\
    \ to be done.  These options will be\nsimilar to those provided for control of\
    \ data validity operations.  The\ndata validation and derived data concepts are\
    \ similar in that some\noperation must be performed on related data.  In the case\
    \ of data\nvalidation, the information derived is the condition of data.\n3.9\
    \ Internal Representation\nTo this point, we have discussed only the high level,\
    \ logical, aspects\nof data.  Since data, at any given time, must reside on some\
    \ physical\ndevice a representation of the data must be chosen.  In some cases\
    \ it is\nappropriate to leave this choice to the datacomputer system.  For\nexample,\
    \ the representation of information which is used in the process\nof transmitting\
    \ other data, but which itself resides solely at the\ndatacomputer may not be\
    \ of any concern to the user.\nHowever, it is important that the user be capable\
    \ of controlling the\nchoice of representation.  In any application which requires\
    \ mostly\ntransmission of data rather than interpretation of the data by the\n\
    datacomputer, the data should be maintained in a form consistent with\nthe system\
    \ which communicates with the datacomputer.  With respect to\nbasic types of data,\
    \ datalanguage will provide most representations\ncommonly used in systems with\
    \ which it interacts.  For some types (e.g.,\nfixed point) this will be accomplished\
    \ by providing for parametric\n(e.g., sign convention, size) description of the\
    \ representation.  In\nother cases (e.g., floating point) specific representations\
    \ will be\noffered (e.g., system 360 short floating point, system 360 long floating\n\
    point, pdp-10 floating point, etc.).\nAnother aspect of the internal representation\
    \ problem regards aggregate\nstructures.  The method chosen to represent aggregate\
    \ structures may\nlargely affect the cost of manipulating the data.  The user\
    \ must have\ncontrol over this representation since only he has any idea of how\
    \ the\ndata is to be used.  Datalanguage will provide a variety of\nrepresentational\
    \ options which will allow for efficient implementation\nof data structures. \
    \ This includes the availability of auxiliary\nstructures, automatically maintained\
    \ by the data computer system.  These\nstructures can be used to effect efficient\
    \ retrieval of subsets of data\ncollections based on the contents of the members\
    \ (i.e. the common\nconcept of indices), efficient maintenance of orderings on\
    \ a collection\nof data, maintenance of redundant information for the purpose\
    \ of data\nintegrity, and efficient handling of shared data whose behavioral\n\
    characteristics are dependent on the path of access.  It should be noted\nhere\
    \ that, the datalanguage design effort, will attempt to provide\nmethods whereby\
    \ the data user can describe the expected use of his data,\nso that details of\
    \ internal representation can be left to the\ndatacomputer.\n3.10 Data Attributes\
    \ and Data Classes\nThe type of an item determines the operations which are valid\
    \ on that\nitem and what they mean.  _Data_attributes_ are refinements on the\
    \ type\nof data.  The data attributes affect the meaning of operations. For\n\
    example, we would like to provide for the option of defining fixed point\nitems\
    \ to be scaled.  The scale factor, in this case, would be an\nattribute of fixed\
    \ point data. It effects the meaning of operations on\nthat data. The attribute\
    \ concept is useful in that it allows information\nconcerning the manipulation\
    \ of an item to be associated with the item\nrather than with the invocation of\
    \ all operations on that item.\nThe attribute concept can be applied to aggregate\
    \ as well as basic data.\nFor example, one attribute of a list could define where\
    \ a new member is\nto be inserted.  Options might be: insert at the beginning\
    \ of the list;\ninsert at the end of the list; or insert in some order based on\
    \ the\ncontents of the member.  Adding a new member to a list with one of the\n\
    above attributes could be done by issuing a simple insert request\nwithout having\
    \ to specify where the new member is to be inserted.\nThe _data_class_ concept\
    \ is actually the inverse of the data attribute\nconcept.  A data class is a collection\
    \ of data types.  The data class\nconcept allows for definition of operations,\
    \ independent of specific\ntype of an item.  For example, by defining the data\
    \ class arithmetic to\nbe composed of fixed point and floating point types of\
    \ data, the\ncomparison operators (_equal_, _less_than_, etc.) can be defined\
    \ to\noperate on arithmetic data, independent of whether it is fixed or\nfloating\
    \ point. Also the concept of data aggregate can be seen as a\nclass encompassing\
    \ directories, lists, etc.  As there are operations\ndefined on arithmetic data,\
    \ there are also operations defined on\narbitrary aggregates.\nThe inverse relationship\
    \ between data classes and data attributes is\nvery strong.  For example, the\
    \ concept of list can be seen as a data\nclass, encompassing all types of lists\
    \ (e.g., lists of integers, lists\nof character strings, etc.), independent of\
    \ the types of their members.\nThe type of a list's members (e.g., integer, character\
    \ string, etc.) are\nthen seen as attributes.  Data attributes and classes are\
    \ also relative\nconcepts.  While the concept of list can be viewed as a data\
    \ class, it\ncan also be seen as an attribute, relative to the concept of data\n\
    aggregate.\n3.11 Data Description\nA _data_description_ is a statement of the\
    \ properties (see discussion of\nattributes) of a data item.  Examples of properties\
    \ which are recorded\nin a description are: the name of an item; its size; its\
    \ data type; its\ninternal representation; privacy information; etc.\nDatalanguage\
    \ will contain mechanisms for specifying data descriptions.\nThese descriptions\
    \ will be processed by the data computer, and used\nwhenever the data item is\
    \ referenced.  The user will be able to\nphysically create data only by first\
    \ specifying their descriptions.  The\nproperties of a description can be divided\
    \ into groups according to\ntheir function. Some have the function of specifying\
    \ details of\nrepresentation, which will not be of interest to most users, while\n\
    others, such as the name are of almost universal interest.\nAll user data is a\
    \ part of some larger (user or system) data structure.\nThe structures containing\
    \ data establish a path of access to the data.\nIn the process of following this\
    \ path the datacomputer system must\naccrue a complete description of the data\
    \ item.  For example, the\ndescription of a data item of a directory may be found\
    \ associated with\nthat node of the directory.  Members of a list or array are\
    \ described as\npart of the description of the list or array. We must dispose\
    \ of two\nseeming exceptions.  First, while aspects of data may (on user request)\n\
    be left to the system, those aspects are still described, they are\ndescribed\
    \ by the system.  As discussed above, some data will be, to some\ndegree, self\
    \ describing (e.g. members of mixed lists).  However, it is\nfully described in\
    \ some encompassing structure, in that a method of\ndetermining the full description\
    \ is described.\nIt is worth noting here that the sooner a complete description\
    \ is found\nin the path of access, the more effective the datacomputer is likely\
    \ to\nbe in processing requests which manipulate a data item.  However, the\n\
    ability to have data whose complete description does not exist at high\nlevels\
    \ of the access path provides greater flexibility in the definition\nof data structures.\n\
    3.12 Data Reference\nData cannot be manipulated unless it can be referenced. \
    \ In the same way\nthat data cannot exist without its being described, it cannot\
    \ exist\nunless there is a path of access to the data. The method of data\nreference\
    \ is to define the path of access to the data.  As mentioned\nabove, there is\
    \ a method of referencing any item relative to the data\naggregate which contains\
    \ it.  Nodes of directories and components of\nstructs are referenced via the\
    \ name associated with the node or\ncomponent.  Members of arrays are referenced\
    \ via the index associated\nwith the member.  Members of lists are referenced\
    \ via some method of\nspecifying the position of the member or by uniquely identifying\
    \ the\nmember by content.  To reference any arbitrary data item the path of\n\
    access must be fully defined by either explicit or implicit definition\nof each\
    \ link in the chain.  In the case of virtual data there is an\nextra implicit\
    \ link in the chain, that being the method employed to\nobtain the data from other\
    \ data items.  It should be noted also that if\npointers are provided (see discussion\
    \ on general relational\ncapabilities) they can also serve as a link in the chain\
    \ of access to an\nitem.\nThe design of datalanguage will ease the problem (and\
    \ reduce the cost)\nof referencing data items by providing methods whereby part\
    \ of the\naccess path can be implicitly defined.  For example, datalanguage will\n\
    provide a concept of \"context\".  During the course of interacting with\nthe\
    \ datacomputer, levels of context can be set up so that data can be\nreferenced\
    \ directly, in context.  For example, on initiating a session\nthe user may (in\
    \ fact will probably be required to) define a directory\nwhich will be the context\
    \ of that session.  All items subordinate to\nthis directory can be referenced\
    \ directly in this context.  Another\nfeature will be partial qualification. \
    \ Each level of struct need not be\nmentioned in order to reference an item embedded\
    \ in a deep nest of\nstructs.  Only those intermediate levels which are sufficient\
    \ to\nuniquely identify the item need be specified.\n3.13 Operations\nIn this\
    \ section we discuss the builtin functions of datalanguage which\nare of central\
    \ importance in manipulating data.  Functions which operate\non items, functions\
    \ which operate on aggregates, primitive functions and\nhigh-level functions are\
    \ discussed.\nOf the primitives which operate on items, those of most interest\
    \ are\nassignment, comparisons, logicals, arithmetics and conversion functions.\n\
    Primitive assignment transfers a value from one item to another; these\nitems\
    \ must be of the same type.  When they are of different types,\neither conversion\
    \ must be performed, or some non-primitive form of\nassignment is involved.\n\
    The comparison operators accept a pair of items of the same type, and\nreturn\
    \ a boolean object which indicates whether or not a given condition\nobtains.\
    \  The type determines how many different conditions can be\ncompared for.  A\
    \ pair of numeric items can be compared to see which is\ngreater, while a pair\
    \ of uninterpreted items can be compared only for\nequality.  In general, a concept\
    \ of \"greater than\" is builtin for a\ndatatype only if it is a very widely applied\
    \ concept.  The comparison\noperators are used in the construction of inclusion\
    \ conditions when\ndefining subsets of aggregate data.\nThe result of a comparison\
    \ operation is a boolean item: one whose value\nis either TRUE or FALSE.  Logical\
    \ primitives are provided and\ngeneralized boolean functions can be constructed\
    \ from them.  With\nlogical and comparison operators, complex conditions for inclusion\
    \ of\nobjects in sets can be specified.\nArithmetic operators will be available\
    \ for the manipulation of numeric\ndata.  Here, we are not interested in generalized\
    \ computation, but in\napplications of arithmetic in data selection, space allocation,\n\
    subscript calculation, iteration control, etc.\nConversion is an important part\
    \ of generalized data translation, and we\nare interested in providing a substantial\
    \ builtin conversion facility.\nIn particular, we will want to provide an efficient\
    \ system routine for\neach \"standard\" or widely-used conversion function.  Of\
    \ particular\nimportance are conversions to and from character string data; in\n\
    character string representation of, for example, numeric items, there\nare many\
    \ possible formats corresponding to a single data type.\nConversion between character\
    \ sets and dealing with padding and\ntruncation are viewed as conversion problems.\n\
    There are two principal classes of primitive operators defined on\naggregates:\
    \  those related to data reference (see previous section) and\nthose which add\
    \ and delete components.  Changing an existing component\nis accomplished through\
    \ assignment, and is an operation on the\ncomponent, not the aggregate.\nAddition\
    \ and deletion of components is defined only for aggregates which\nare not inherently\
    \ static in composition.  Thus one can add a component\nto a LIST, but not to\
    \ an ARRAY.  To specify deletion it is necessary to\nspecify which component is\
    \ to be deleted, and from which aggregate (in\nthe case that it is shared).  Addition\
    \ requires specification of new\ncomponent, aggregate, and sometimes auxiliary\
    \ information.  For example,\nsome aggregate types would permit addition of new\
    \ components anywhere in\nthe structure; in these a position must be indicated,\
    \ relative to any\nexisting components.\nOften it is desirable to operate on some\
    \ of the members of a list, or to\ntreat a group of members as a list in its own\
    \ right.  For example, it\nmight be common to transmit to a remote program for\
    \ analysis, the\nmedical history of patients developing heart disease before the\
    \ age of\n30. These may be just a few of the members of a large list of patients.\n\
    In this case, the operation to be performed is transmission to the\nremote system;\
    \ this operation is performed on several members of the\nlist of patients.  The\
    \ ones to be transmitted are thought of as a _set_;\nthe set is specified as containing\
    \ all the members of a given list\nsatisfying two conditions: (1) age less than\
    \ 30, and (2) has heart\ndisease.\nSets can be defined explicitly, or implicitly\
    \ simply with appropriate\nreference mechanisms.  _Definition_ of a set is distinct\
    \ from\n_identification_of_membership_, which is distinct from\n_access_to_membership_.\
    \  Definition involves specifying the candidates\nfor set membership and specifying\
    \ a rule by which members of the set can\nbe distinguished from non-members; for\
    \ example, an inclusion condition\nsuch as \"under 30 with heart disease\".  Identification\
    \ involves\neffective application of the rule to all candidates for membership.\n\
    When the membership has been identified, it can be counted, but the data\nitself\
    \ has not necessarily been accessed. When a member is accessed, its\ncontents\
    \ can be operated on.\nPrimitives to accomplish each of these operations on a\
    \ set will be\nprovided; however, it will ordinarily be optimal for the datacomputer\
    \ to\ndetermine when each step should be performed.  To enable users to\noperate\
    \ at a level at which the datacomputer can optimize effectively,\nhigher-level\
    \ operators on sets will be provided.  Some of these are\nlogical operators, such\
    \ as union and intersection.  These input and\noutput sets.  Also available is\
    \ an operator which complements a set\n(since the definition establishes all possible\
    \ candidates, a set always\nhas a well-defined complement).\nThese higher level\
    \ operators can be applied to any defined set; the set\nmembers need not be identified\
    \ or accessed.  The system will perform\nsuch operations without actually accessing\
    \ members if it can.\nSome of the other operators on sets are counting membership,\n\
    partitioning a set into a set of sets, uniting a set of sets into a set.\nA set\
    \ can be used to reference another set, providing there is a well-\ndefined way\
    \ to identify members of the second set given the first set.\nFor example, a set\
    \ C may contain all the children doing poorly in\nschool.  A set F may be defined,\
    \ where the members of F are the records\nabout families having a child in set\
    \ C.\nSome other useful operations on sets are: adding all the members of a\n\
    set to an aggregate, deleting all the members of a set (frequently such\na massive\
    \ change can be performed far more efficiently than the same set\nof changes individually\
    \ requested), changing all the members of a set in\na given way.\nA set can be\
    \ made into a list, by actually accessing each member and\nphysically collecting\
    \ them.\nSome of the operations on lists are: concatenation of lists into larger\n\
    lists, division of a list into smaller lists, sorting a list, merging a\npair\
    \ of ordered lists (preserving order).\nThis is not intended to be a full enumeration\
    \ of high-level operations,\nbut to be suggestive.  We are planning to build in\
    \ high-level functions\nfor operations which are used very commonly, and can be\
    \ implemented\nwithin the system significantly better than they can be implemented\
    \ by\nusers in the language.  For most of the functions mentioned here,\nconsiderable\
    \ knowledge is accumulated on good implementations.  In\nparticular, the techniques\
    \ used for inverted file access provide many\nset operations to be performed without\
    \ actual access to the data.\n3.14 Control\nThe control features of datalanguage\
    \ are to the basic operations as data\naggregates are to the basic data items.\
    \  Control features are used to\ncreate complex requests out of the basic requests\
    \ provided by\ndatalanguage.\nConditional requests allow the user to alter the\
    \ normal request flow by\nspecifying that certain requests are to be executed\
    \ under certain\nconditions.  In general datalanguage will provide the ability\
    \ to chose\nat most one of a number of requests to be made based on some set of\n\
    conditions or the value of some item.  In its simplest form the\nconditional allows\
    \ for optional execution of a given request.\nIterative requests cause a request\
    \ (called the body) to be executed a\nfixed or variable number of times or until\
    \ a given condition is met.\nDatalanguage will provide iterative requests that\
    \ will allow for similar\nmanipulations to be performed on all members of some\
    \ aggregate structure\nas well as the standard type of iterative request based\
    \ on counters.  By\nproviding a capability of directly expressing manipulations\
    \ on\naggregates which require processing all of the items subordinate to the\n\
    aggregate, the datacomputer can be more efficient in processing user\nrequests.\
    \  For example, a user defined conversion process which operates\non character\
    \ strings, can be implemented far more efficiently if the\ndatacomputer is explicitly\
    \ informed that the process requires sequential\nprocessing of the characters.\
    \  Datalanguage will also provide for\nparallel iteration. For example, the user\
    \ will be able to specify\noperations which require sequencing through two or\
    \ more lists in\nparallel.  This would be done if the contents of one file were\
    \ to be\nupdated based on a file of correction information.\nCompound requests\
    \ are collections of requests which act as one.  They\nare primarily provided\
    \ to allow for the conditional performance of or\niteration on more than one statement.\
    \  Compound requests also provide\nrequest reference points which can be used\
    \ to control the request\nprocessing flow.  That is, compound requests can be\
    \ \"named\". The\ndatalanguage user will be able to specify control information\
    \ which will\nconditionally cause a compound request to be exited. By providing\n\
    naming, the user may cause any number of previously entered compound\nrequests\
    \ to be exited.\nWe do not intend to provide the traditional _goto_ capability.\
    \  By not\nincluding a goto request, the chances for efficient operation (via\n\
    optimization) of the datacomputer are increased. We also hope, in this\nway, to\
    \ force the datalanguage user to specify his data manipulations in\na clear sty1e.\n\
    Two forms of the compound request will be provided, ordered and\nunordered.  In\
    \ the unordered case the user is informing the datacomputer\nthat the requests\
    \ can be performed in any order.  This should allow the\ndatacomputer to perform\
    \ more efficiently and might even allow for\nparallel processing.\nDuring a session\
    \ with the datacomputer it is likely that a user will\nfind a need for temporary\
    \ data.  That is, data which is used to\nremember, for a short term, information\
    \ which is needed for the\nprocessing of requests. This short term might be a\
    \ session or a small\npart of a session. Datalanguage will provide a temporary\
    \ data facility.\nTemporary data will be easy to create, use and dispose of. \
    \ This will be\naccomplished by allowing the system to (optionally) make many\
    \ decisions\nregarding the data.  For example the representation of a temporary\n\
    integer item will often be of no concern to the user.  Some features\nwhich are\
    \ provided for permanent data will be deemed irrelevant with\nregard to temporary\
    \ data.\nTemporary data will be associated with a collection of requests in what\n\
    will be called a block.  A block will be no different than a compound\nrequest\
    \ with the exception that data is defined with the requests which\ncompose it\
    \ and is automatically created on entrance to the block and\ndestroyed on exiting\
    \ the block.\n3.15 Extensibility\nThe goals of datalanguage are to provide facilities\
    \ of data structure at\ntwo levels.  At one level the user may take advantage\
    \ of high level data\ncapabilities which will do much of his data management work\n\
    automatically and which allows for the data computer to operate more\neffectively\
    \ in some cases since it has been given control of the data.\nAt another level,\
    \ however, features are provided which allow the user to\ndescribe his application\
    \ in terms of primitive concepts.  In this way\nthe datacomputer user may compose\
    \ a large variety of data constructs and\nhas great flexibility with respect to\
    \ the manipulations he can perform\non his data. Also by interacting with the\
    \ datacomputer at the primitive\nlevel, the user can exercise a good deal of control\
    \ over the methods\nemployed by the datacomputer which may result in more effective\
    \ usage of\nresources for non-standard applications.  Datalanguage will provide\n\
    features which allow the user to create an environment whereby the\ndatacomputer\
    \ system appears to provide features especially tailored to\nhis application.\n\
    The control features discussed above allow the user to extend the\noperations\
    \ available on data by appropriate composition of the\noperations.  Datalanguage\
    \ will provide a method of defining a composite\nrequest to be a new request (called\
    \ a _function_).  In this way a new\noperation on specific data can be defined\
    \ once and then used repeatedly.\nIn order that the user may define general operations,\
    \ datalanguage will\nprovide functions which can be parameterized.  That is, functions\
    \ will\nnot only be able to operate on specific data but may be defined to work\n\
    on any data of a specific type.  This capability will not be limited to\nbasic\
    \ data types (e.g. integers) or even specific aggregate types (e.g.\narray of\
    \ integers) but will also include the ability to define functions\nwhich operate\
    \ on classes of data.  For example, functions can be defined\nwhich operate on\
    \ lists independent of the type of the list members.\nAlso provided, will be the\
    \ ability to expand and modify existing\nfunctions as well as creating new functions.\
    \  This includes expanding\nthe types of data for which a function is defined\
    \ or modifying the\nbehavior of a function for certain types of data.\nAs with\
    \ operations, the data aggregates discussed above allow the user\nto extend the\
    \ primitive data types by appropriate composition.  For\nexample, a two dimensional\
    \ array of integers can be created by creating\nan array of arrays of integers.\
    \  The situation for data types is\nanalogous to that of operations. Datalanguage\
    \ will provide the ability\nto define a composition of data to be a new data type.\
    \  Also the\ncapability of defining general data structures will be provided by\n\
    essentially parameterizing the new data definition.  This would allow\nthe general\
    \ concept of two dimensional array to be defined as an array\nof arrays. Once\
    \ defined, one could create two dimensional arrays of\nintegers, two dimensional\
    \ arrays of booleans, etc.  As with functions\nthere is also a need to expand\
    \ or modify existing data types.  One might\nwant to expand the attributes which\
    \ apply to a given data type, in that\nhe might want to add new attributes, or\
    \ add new choices for the existing\nattributes.\nThe control features can be extended\
    \ also.  Special control features\nmight be needed to process a data structure\
    \ in a special way or to\nprocess a user defined data structure.  For example,\
    \ if a tree type data\nstructure has been defined in terms of lists of lists,\
    \ the user might\nlike to define a control function which causes a specified operation\
    \ to\nbe performed on each item of a specified tree.  As with data types and\n\
    functions, there is a need to be able to modify and extend existing\ncontrol features\
    \ as well as the ability to create new ones.\nDatalanguage will provide the ability\
    \ to treat data descriptions and\noperations in much the same way that data is\
    \ treated.  One can describe\nand manipulate descriptions and operations in the\
    \ same way that he can\ndescribe and manipulate data.  It is impossible to talk\
    \ about data types\nwithout consideration of operations and equally as impossible\
    \ to talk\nabout operations without an understanding of the data types they operate\n\
    on.  In order for the user to be able to effect the behavior of the\ndatacomputer\
    \ system, the design of datalanguage will include a\ndefinition of the operational\
    \ cycle of the datacomputer.  Precise\ndefinitions of all aspects of data (data\
    \ attributes, data classes,\nrelationship of aggregates to their subordinate items,\
    \ etc.) in terms of\ntheir interaction with datalanguage operations will be made.\
    \  In this\nway the datacomputer can offer tools which will give the datacomputer\n\
    user the ability to be an active participant in the design of the\ndatalanguage\
    \ which he uses.\n4. A Model for Datalanguage Semantics\nFor the purpose of defining\
    \ and experimenting with language semantics\nand with language processing techniques,\
    \ we are developing a model\ndatacomputer.\nThe principal elements of the model\
    \ are the following:\n(1) A set of primitive functions\n(2) An environment in\
    \ which data objects can be created, manipulated and\n    deleted, using the primitives\n\
    (3) A structure for the representation of collections of data values,\n    their\
    \ descriptions, their relationships, and their names.\n(4) An interpreter which\
    \ executes the primitives\n(5) A compiler which inputs requests in a very simple\
    \ language, performs\n    binding and macro expansion operations, and generates\
    \ calls to the\n    internal semantic primitives.\nIf our modeling efforts are\
    \ successful, the model will evolve until it\naccepts a language like the datalanguage\
    \ whose properties we have\ndescribed in sections 2 and 3 of this paper.  Then\
    \ the process of\nwriting the final specification will simply require reconciliation\
    \ of\ndetails not modeled with structure that has been modeled.  One rather\n\
    large detail which we may never handle within the model is syntax; in\nthis case\
    \ reconciliation will be more involved; however, we firmly\nbelieve that the semantic\
    \ structure should determine the syntax rather\nthan the opposite, so we will\
    \ be in the proper position to handle the\nproblem.\nBy constructing a model for\
    \ each of the elements listed above, we are\n\"implementing\" the language as\
    \ we design it, in a very loose sense.  In\neffect, we work in a laboratory, rather\
    \ than working strictly on paper.\nSince we aren't concerned with the performance\
    \ or usability of the\ndatacomputer we are building in the laboratory, we are\
    \ able to build\nwithout becoming involved with some of the most time-consuming\
    \ concerns\nof an implementor.  However, because we are building and tinkering,\n\
    rather than simply working on paper, we do get some of the advantages\nthat normally\
    \ come with the experience of implementing one's ideas.\nThe model datacomputer\
    \ is a program, developed in ECL, using the EL1\nlanguage.  Presently we are interested\
    \ in the process of developing the\nprogram, not running it.  Our primary requirement\
    \ is to have, in advance\nof the existence of datalanguage, a well-defined and\
    \ flexible notation\nin which to specify data structures, function definitions\
    \ and examples.\nEL1 is convenient for this.  Having a program which actually\
    \ works and\nacts like a simple datacomputer is really a by-product of specifying\n\
    semantics in a programming language.  It is not necessary for the\nprogram to\
    \ work, but it does provide some nice features. It enhances the\n\"laboratory\"\
    \ effect, by doing such things as automatically compiling\nstrings of primitives,\
    \ displaying the state of the environment in\ncomplicated examples, automatically\
    \ discovering inconsistencies (in the\nform of bugs), and so on.\nThere are two\
    \ major reasons that EL1 is a convenient notation for\nspecifying datalanguage\
    \ semantics.  One is that the languages have a\ncertain amount in common, in both\
    \ concepts and in goals in data\ndescription.  (In part, this is because EL1 itself\
    \ has been a good\nsource of ideas in attacking the datalanguage problem).  Both\
    \ languages\nemphasize operations on data, independent of underlying representation.\n\
    A second reason that EL1 is a convenient way to specify datalanguage, is\nthat\
    \ EL1 is extensible; in fact, many primitive functions could be\nembedded directly\
    \ into EL1 by using the extension facilities.  At times,\nwe have chosen to embed\
    \ less than we could, to expose problems of\ninterest to us.\nSo far, the model\
    \ has been useful primarily in exposing design issues\nand relationships between\
    \ design decisions.  Also, because it includes\nso many of the elements of the\
    \ full system (compiler, interpreter,\nenvironment, etc.), it encourages a fairly\
    \ complete analysis of any\nproposal.\nIn presenting the model in this section,\
    \ we have chosen to emphasize\nideas and examples, rather than formal definitions\
    \ in EL1.  This is\nbecause the ideas are more permanent and relevant at this\
    \ point (the\nformalisms are changing rather frequently) and because we imagine\
    \ people\nreading the formal definitions only to get at the ideas.  The formal\n\
    definitions may be interesting in themselves when the language is\ncomplete; at\
    \ this point they are probably of interest only to us.\nThe section is organized\
    \ into a large number of sub-sections.  The first\nfew are concerned with the\
    \ basic concepts of data objects, descriptions,\nand relationships between objects.\
    \  We then discuss primitive semantic\nfunctions and present informal definitions\
    \ and examples in sections 4.7\nand 4.8.  Section 4.9 is a brief discussion of\
    \ compilation,\ninterpretation and the execution cycle.  Section 4.10 provides\
    \ a fairly\nelaborate example of how primitive functions can be combined to do\n\
    something of interest: a selective retrieval by content.  The last two\nsections\
    \ wrap up with discussions of high-level functions and some\nconclusions.\n4.1\
    \ Objects\nAn _object_ has a name, a description, and a value. It can be related\
    \ to\nother objects.\nThe _name_ is a symbol, which can be used to access the\
    \ object from\nlanguage functions.\nThe _description_ is a specification of properties\
    \ of the object, many\nof which relate to the meaning or the representation of\
    \ the value.\nThe _value_ is the information of ultimate interest in the object.\n\
    The relationships between objects are hierarchical.  Each object can be\nrelated\
    \ directly to at most four other objects, designated as its\n_parent_, its _child_,\
    \ its _left_sibling_, and its _right_sibling_.\nThis specific concept of relationship\
    \ is all that has been built in to\nthe model to date.  One of our primary objectives\
    \ in the future is to\nexperiment with more general relationships among objects.\n\
    4.2 Descriptions\nA description has the components _name_, _type_ and _type-\n\
    dependent_parameters_.  It can be related hierarchically to other\ndescriptions,\
    \ according to a scheme similar to the one described for\nobjects in 4.1.\nThe\
    \ _name_ has a role in referencing, as in the case of objects.\n_Type_ is an undefined,\
    \ intuitive idea for which we expect to develop a\nprecise meaning within datalanguage(see\
    \ section 3.10 for some of the\nideas about this).  In terms of the present model,\
    \ it simply means one\nof the following: LIST, STRUCT, STRING, BOOL, DESC, DIR,\
    \ FUNC, 0PD.\nEach of these refers to a sort of value corresponding to common\
    \ ideas in\nprogramming (with the exception of OPD, which is explained in section\n\
    4.7), and on which certain operations are defined.\nExamples of _type-dependent_parameters\
    \ are the two items needed to\ndefine a STRING: size option and size.  A STRING\
    \ is a sequence of\ncharacters; the size of the STRING is the number of characters\
    \ in it.\nIf a STRING has a fixed size, then size option is FIXED and size is\
    \ the\nnumber of characters it always contains.  If a STRING has a varying\nsize,\
    \ then size option is VARYING, and size is its maximum (clearly, it\nmight also\
    \ have a minimum in a more refined scheme).\nWhen the description of an object\
    \ has a type of STRING, it is commonly\nsaid that the object is a STRING.\n4.3\
    \ Values\nThe value is the data itself.\nAn object of type BOOL can have only\
    \ either the value TRUE or the value\nFALSE.\nAn object of type STRING has values\
    \ such as 'ABC', 'JOHN', or 'BOSTON'.\nEach value has a representation, in bits.\
    \  Thus a BOOL is represented by\na single bit, which will be a 'one' to represent\
    \ TRUE and a 'zero' to\nrepresent FALSE.\n4.4 Some examples\nHere are some examples\
    \ of structures involving objects, descriptions,\nand values.  In these explanations\
    \ and drawings, the objective is to\nconvey some ideas about these primitive structures;\
    \ considerable detail\nis omitted in the drawings in the interest of clarity.\n\
    Figure 4-1 shows two objects.  X is of type string and has value 'ABC'.\nY is\
    \ of type bool and has value TRUE.\n                _________________\n      \
    \         |                 |\n               |  _____________  |\n          \
    \     | |      X      | |\n               | |_____________| |\n              \
    \ |  NAME           |        ____________\n               |  _____________  |\
    \       |  ________  |\n               | |         ____|_|______\\| | STRING |\
    \ |\n               | |_____________| |      /| |________| |\n               |\
    \  DESCRIPTION    |       |  TYPE      |\n               |  _____________  | \
    \      |____________|\n               | |             | |        DESCRIPTION\n\
    \               | |_________|___| |\n               |  VALUE    |     |      \
    \  ____________\n               |___________|_____|       |            |\n   \
    \             OBJECT     |____________\\|   \"ABC\"    |\n                   \
    \                     /|____________|\n                                      \
    \    VALUE\n                _________________\n               |              \
    \   |\n               |  _____________  |\n               | |      Y      | |\n\
    \               | |_____________| |\n               |  NAME           |      \
    \  ____________\n               |  _____________  |       |  ________  |\n   \
    \            | |         ____|_|______\\| |  BOOL  | |\n               | |_____________|\
    \ |      /| |________| |\n               |  DESCRIPTION    |       |  TYPE   \
    \   |\n               |  _____________  |       |____________|\n             \
    \  | |             | |        DESCRIPTION\n               | |_________|___| |\n\
    \               |  VALUE    |     |        ____________\n               |___________|_____|\
    \       |            |\n                OBJECT     |____________\\|    TRUE  \
    \  |\n                                        /|____________|\n              \
    \                            VALUE\n                               Figure 4-1\n\
    \                         Two elementary objects\nFigure 4-2 illustrates an object\
    \ of type dir (a _directory_) and related\nobjects. The directory has name SMITH.\
    \  There are two objects entered in\nthis directory, named X and Y.\n        \
    \       _________________\n              |  _____________  |\n              |\
    \ |    SMITH    | |\n              | |_____________| |\n              |  NAME\
    \           |        ____________\n              |  _____________  |       | \
    \ ________  |\n              | |         ____|_|______\\| |  DIR   | |\n     \
    \         | |_____________| |      /| |________| |\n              |  DESCRIPTION\
    \    |       |  TYPE      |\n              |  _____________  |       |____________|\n\
    \              | |             | |        DESCRIPTION\n              | |_________|___|\
    \ |\n              |  CHILD    |     |\n              |___________|_____|\n  \
    \             OBJECT     |\n               ___________V_____\n              |\
    \  _____________  |\n              | |      X      | |\n              | |_____________|\
    \ |\n              |  NAME           |       _________________\n             \
    \ |  _____________  |      |  _____________  |\n         _____|_|____        \
    \ | |      | |      Y      | |\n        |     | |_____________| |      | |_____________|\
    \ |\n        |     |  DESCRIPTION    |      |  NAME           |\n        |   \
    \  |  _____________  |      |  _____________  |\n        |   __|_|____       \
    \  | |      | |         ____|_|_____\n        |  |  | |_____________| |      |\
    \ |_____________| |     |\n        |  |  |  VALUE          |      |  DESCRIPTION\
    \    |     |\n        |  |  |  _____________  |      |  _____________  |     |\n\
    \        |  |  | |         ____|_|_____\\| |         ____|_|__   |\n        |\
    \  |  | |_____________| |     /| |_____________| |  |  |\n        |  |  |  SIBLING\
    \        |      |  VALUE          |  |  |\n        |  |  |_________________| \
    \     |_________________|  |  |\n        |  |   OBJECT                   OBJECT\
    \              |  |\n        |  |   _________________        _________________\
    \   |  |\n        |  |_\\|      \"ABC\"      |      |      FALSE      |/_|  |\n\
    \        |    /|_________________|      |_________________|\\    |\n        |\
    \      VALUE                    VALUE                  |\n        |      _________________\
    \        _________________      |\n        |     |  _____________  |      |  _____________\
    \  |     |\n        |     | |    STRING   | |      | |     BOOL    | |     |\n\
    \        |____\\| |_____________| |      | |_____________| |/____|\n         \
    \    /|  TYPE           |      |  TYPE           |\\\n              |_________________|\
    \      |_________________|\n               DESCRIPTION              DESCRIPTION\n\
    \                Figure 4-2: A directory with two members\nThe idea of a dir is\
    \ similar to the idea of a file directory in most\nsystems.  A directory is a\
    \ place where one can store named objects,\nfreely adding and deleting them. \
    \ The entries in the directory are all\nobjects whose parent is that directory.\
    \  Figure 4-3 shows a more rigidly\nstructured group of objects.  Here we have\
    \ R, a struct, and A and B, a\npair of strings.  Note that the boxes labeled 'object'\
    \ in figure 4-3\nbear precisely the same relationships to one another as those\
    \ labeled\n'object' in 4-2.  However, there are two conditions which hold for\
    \ 4-3\nbut do not hold for 4-2: (1) the value of R contains the values of A and\n\
    B, and (2) the descriptions of R, A and B are all related.\nStructs have the following\
    \ properties:  (1) name and description of each\ncomponent in the struct is established\
    \ when the struct is created, and\n(2) in a value of the struct, the order of\
    \ occurrence of component\nvalues is fixed.\n       _________________        \
    \ _________________\n      |  _____________  |       |  _____________  |\n   \
    \   | |      R      | |       | |    STRUCT   | |\n      | |_____________| | \
    \      | |_____________| |\n      |  NAME           |       |  TYPE          \
    \ |\n      |  _____________  |       |  _____________  |\n      | |         ____|_|______\\\
    | |             | |\n      | |_____________| |      /| |__________|__| |\n   \
    \   |  DESCRIPTION    |       |  CHILD     |    |\n      |  _____________  | \
    \      |____________|____|\n _____|_|____         | |        DESCRIPTION |\n|\
    \     | |_____________| |        ____________V____\n|     |  VALUE          |\
    \       |  _____________  |\n|     |  _____________  |       | |    STRING   |\
    \ |\n|     | |             | |       | |_____________| |\n|     | |_________|___|\
    \ |   ___\\|  TYPE           |        _____________\n|     |  CHILD    |     |\
    \  |   /|  _____________  |       |  _________  |\n|     |___________|_____| \
    \ |    | |         ____|_|______\\| | STRING  | |\n|      OBJECT     |       \
    \ |    | |_____________| |      /| |_________| |\n|                 |        |\
    \    |  SIBLING        |       |  TYPE       |\n|      ___________V_____   | \
    \   |_________________|       |_____________|\n|     |  _____________  |  |  \
    \   DESCRIPTION           DESCRIPTION    A\n|     | |      A      | |  |     \
    \                                     |\n|     | |_____________| |  |     _________________\
    \                    |\n|     |  NAME           |  |    |  _____________  |  \
    \                 |\n|     |  _____________  |  |    | |      B      | |     \
    \              |\n|     | |         ____|_|__|    | |_____________| |        \
    \           |\n|     | |_____________| |       |  NAME           |           \
    \        |\n|     |  DESCRIPTION    |       |  _____________  |              \
    \     |\n|     |  _____________  |       | |         ____|_|___________________|\n\
    |   __|_|____         | |       | |_____________| |\n|  |  | |_____________| |\
    \       |  DESCRIPTION    |\n|  |  |  VALUE          |       |  _____________\
    \  |\n|  |  |  _____________  |       | |         ____|_|____\n|  |  | |     \
    \    ____|_|______\\| |_____________| |    |\n|  |  | |_____________| |      /|\
    \  VALUE          |    |\n|  |  |  SIBLING        |       |  _____________  |\
    \    |\n|  |  |_________________|       | |             | |    |\n|  |   OBJECT\
    \                   | |_____________| |    |\n|  |                           \
    \ |  SIBLING        |    |\n|  |                            |_________________|\
    \    |\n|  |__________                   OBJECT   _____________|\n|      _______|__________________________|_______\n\
    |____\\|  _____V_______            _______V_____  |\n     /| |    \"ABC\"    |\
    \          |     FALSE   | |      Figure 4-3\n      | |_____________|        \
    \  |_____________| |     A STRUCT with\n      |__________________________________________|\
    \      two members\nFigure 4-4 shows a list named L.  Here a similar structure\
    \ of objects is\nimplied, but because of the regularity of the structure, not\
    \ all the\nboxes labeled 'object' are actually present.\n               _________________\n\
    \              |  _____________  |\n              | |      L      | |\n      \
    \        | |_____________| |\n              |  NAME           |        ____________\n\
    \              |  _____________  |       |  ________  |\n              | |   \
    \      ____|_|______\\| |  LIST  | |\n              | |_____________| |      /|\
    \ |________| |\n              |  DESCRIPTION    |       |  TYPE      |\n     \
    \         |  _____________  |       |  ________  |\n              | |        \
    \     | |       | |        | |\n              | |_______|_____| |       | |______|_|\
    \ |\n              |  VALUE  |       |       |  CHILD |   |\n              |_________|_______|\
    \       |________|___|\n               OBJECT   |          DESCRIPTION |\n   \
    \                     |                      |\n               _________V_______\
    \         ________V___\n              |                 |       |  ________  |\n\
    \              |  _____________  |       | | STRING | |\n              | |   \
    \ \"ABC\"    | |       | |________| |\n              | |_____________| |     \
    \  |  TYPE      |\n              |  _____________  |       |____________|\n  \
    \            | |     \"XY\"    | |        DESCRIPTION\n              | |_____________|\
    \ |\n              |  _____________  |\n              | |    \"ZLM\"    | |\n\
    \              | |_____________| |\n              |        :        |\n      \
    \        |        :        |\n              |  _____________  |\n            \
    \  | |    \"BBBF\"   | |\n              | |_____________| |\n              |_________________|\n\
    \               VALUE\n                               Figure 4-4\n           \
    \                      A LIST\nL has a variable number of components, all satisfying\
    \ the description\nsubordinate to L's description.\nWe could imagine an 'object'\
    \ box for each string in L.  Each of these\nboxes would point to its respective\
    \ string and to the common description\nof these strings.  Instead, we think in\
    \ terms of creating such boxes as\nwe need them.\n4.5 Definitions of types\nFollowing\
    \ are some more precise definitions of types, in terms of the\npresent model.\
    \  These serve the purpose of establishing more firmly the\nsemantics of our structure\
    \ of objects, descriptions and values; however,\nthey should not be thought of\
    \ as providing a definition for the\ncompleted language specification.\nAn object\
    \ of type STRING has a value which is a sequence of characters\n(figure 4-1).\n\
    An object of type BOOL has a value which is a truth value (TRUE or FALSE\n-- figure\
    \ 4-1).\nAn object of type DIR has subordinate objects, each having its own\n\
    description and value.  Subordinate objects can be added and deleted at\nwill\
    \ (figure 4-2).\nAn object of type STRUCT has subordinate objects, each of which\
    \ has a\ndescription which is subordinate to the STRUCT's description, and a\n\
    value contained in the STRUCT's value.  The number, order and\ndescription of\
    \ components is fixed when the STRUCT is created (figure\n4-3).\nAn object of\
    \ type LIST may be thought of as having imaginary subordinate\nobjects, whose\
    \ existence is simulated by the use of appropriate\ntechniques in processing the\
    \ LIST.  Each of these has the same\ndescription, which is subordinate to the\
    \ description of the LIST. Each\nhas a distinct value, contained in the value\
    \ of the LIST.  In fact, only\nthe LIST object, the LIST and component descriptions,\
    \ and the values\nexist (figure 4-4).\nAn object of type DESC has a description\
    \ as its value.  This value is\nthe same sort of entity which serves as the description\
    \ of other\nobjects.\nAn object of type FUNC has a function call as its value.\
    \  We will be\nable to say more about this after functions have been discussed.\n\
    An object of type OPD has an operation descriptor as its value. (see 4.7\nfor\
    \ details).\n4.6 Object environment\nThere are three categories of objects in\
    \ the model datacomputer.  These\nare p/objects, t/objects, and i/objects.\nP/objects\
    \ are permanent objects created explicitly with language\nfunctions.  They correspond\
    \ to the idea of stored data in the real\ndatacomputer.  There are three special\
    \ objects.  These are special only\nin that they are created as part of initializing\
    \ the environment, rather\nthan as the result of executing a language function.\
    \  These are named\nSTAR, BLOCK and TOP/LEVEL.  All three are of type DIR.\nAn\
    \ object is a p/object if it is subordinate to STAR; it is a t/object\nif it is\
    \ subordinate to BLOCK.  TOP/LEVEL is subordinate to BLOCK. (see\nfigures 4-5\
    \ and 4-6).\n               _________________\n              |               \
    \  |\n              |  _____________  |\n              | |     STAR    | |\n \
    \             | |_____________| |\n              |  NAME           |        ____________\n\
    \              |  _____________  |       |  ________  |\n              | |   \
    \      ____|_|______\\| |  DIR   | |\n              | |_____________| |      /|\
    \ |________| |\n              |  DESCRIPTION    |       |  TYPE      |\n     \
    \         |  _____________  |       |____________|\n              | |        \
    \     | |        DESCRIPTION\n              | |_________|___| |\n            \
    \  |  CHILD    |     |\n              |___________|_____|\n               OBJECT\
    \     |\n                          |\n                          |\n          \
    \                |\n                          V\n                    ALL P/OBJECTS\n\
    \                               Figure 4-5\n                           STAR and\
    \ p/objects\nT/objects are temporary objects, also created explicitly with language\n\
    functions.  However, these correspond to user-defined temporaries, both\nlocal\
    \ to requests and \"top-level\" (i.e. not local to any request, but\nexisting\
    \ until deletion or logout.)\n                _________________\n            \
    \   |                 |\n               |  _____________  |\n               |\
    \ |    BLOCK    | |\n               | |_____________| |\n               |  NAME\
    \           |        ____________\n               |  _____________  |       |\
    \  ________  |\n               | |         ____|_|______\\| |  DIR   | |\n   \
    \            | |_____________| |      /| |________| |\n               |  DESCRIPTION\
    \    |       |  TYPE      |\n               |  _____________  |       |____________|\n\
    \               | |             | |        DESCRIPTION\n               | |_________|___|\
    \ |\n               |  VALUE    |     |\n               |___________|_____|\n\
    \                OBJECT     |\n                           |\n                \
    \           |\n                ___________V_____\n               |           \
    \      |\n               |  _____________  |\n               | |  TOP/LEVEL  |\
    \ |\n               | |_____________| |\n               |  NAME           |  \
    \      ____________\n               |  _____________  |       |  ________  |\n\
    \               | |         ____|_|______\\| |  DIR   | |\n               | |_____________|\
    \ |      /| |________| |\n               |  DESCRIPTION    |       |  TYPE   \
    \   |\n               |  _____________  |       |____________|\n             \
    \  | |         ____|_|___     DESCRIPTION\n               | |_____________| |\
    \   |\n               |  SIBLING        |   |\n               |  _____________\
    \  |   |___\\ ALL BLOCKS AND\n               | |             | |       / LOCAL\
    \ T/OBJECTS\n               | |_________|___| |\n               |  CHILD    |\
    \     |\n               |___________|_____|\n                           |\n  \
    \                         |\n                           V\n                  \
    \    ALL GLOBAL\n                      T/OBJECTS\n                           \
    \    Figure 4-6\n                     BLOCK, TOP/LEVEL and t/objects\nI/objects\
    \ are internal, system-defined objects whose creation and\ndeletion is implicit\
    \ in the execution of some language function.\nI/objects are hung directly off\
    \ of function calls (objects of type\nFUNC), and are always local to the execution\
    \ of such function calls.\nThey correspond to the notions of (1) literal, and\
    \ (2) compiler- or\ninterpreter-generated temporary.\n4.7 Primitive Language Functions\n\
    Here we discuss the primitive language functions presently implemented\nin the\
    \ model and likely to be of most interest.  In this section, the\nemphasis is\
    \ on relating functions to one another. Section 4.8 contains\nmore detail and\
    \ examples.\n_Assign_ operates on a pair of objects, called the target and the\n\
    source. The value of the source is copied into the value of the target.\nFigure\
    \ 4-7 shows a pair of objects, X and Y, before and after execution\nof an assignment\
    \ having X as target and Y as source.  Presently,\nassignment is defined only\
    \ for objects of type BOOL and objects of type\nSTRING.  The objects involved\
    \ must have identical descriptions.\n               _________________        _________________\n\
    \              |                 |      |                 |\n              | \
    \ _____________  |      |  _____________  |\n              | |             | |\
    \      | |             | |\n              | |      X      | |      | |      Y\
    \      | |\n              | |_____________| |      | |_____________| |\n     \
    \         |  NAME           |      |  NAME           |\n              |  _____________\
    \  |      |  _____________  |\n              | |             | |      | |    \
    \         | |\n              | |_______|_____| |      | |_______|_____| |\n  \
    \            |  VALUE  |       |      |  VALUE  |       |\n              |_________|_______|\
    \      |_________|_______|\n               OBJECT   |             OBJECT     |\n\
    \                        |                        |\n               _________V_______\
    \        _________V_______\n              |                 |      |         \
    \        |\n              |      \"ABC\"      |      |      \"DEF\"      |\n \
    \             |_________________|      |_________________|\n               VALUE\
    \                    VALUE\n                           BEFORE ASSIGNMENT\n   \
    \            _________________        _________________\n              |     \
    \            |      |                 |\n              |  _____________  |   \
    \   |  _____________  |\n              | |             | |      | |          \
    \   | |\n              | |     X       | |      | |     Y       | |\n        \
    \      | |_____________| |      | |_____________| |\n              |  NAME   \
    \        |      |  NAME           |\n              |  _____________  |      |\
    \  _____________  |\n              | |             | |      | |             |\
    \ |\n              | |_______|_____| |      | |_______|_____| |\n            \
    \  |  VALUE  |       |      |  VALUE  |       |\n              |_________|_______|\
    \      |_________|_______|\n               OBJECT   |             OBJECT     |\n\
    \                        |                        |\n               _________V_______\
    \        _________V_____\n              |                 |      |           \
    \      |\n              |     \"DEF\"       |      |     \"DEF\"       |\n   \
    \           |_________________|      |_________________|\n               VALUE\
    \                    VALUE\n                           AFTER ASSIGNMENT\n    \
    \                           Figure 4-7\n                          Effect of assignment\n\
    A class of primitive functions for manipulating LISTs is defined. These\nare called\
    \ _listops_.  All listops input a special object called an\n_operation_descriptor_\
    \ or OPD.\nTo accomplish a complete operation on a LIST, a sequence of listops\
    \ must\nbe executed.  There are semantic restrictions on the composition of such\n\
    sequences, and it is best to think of the entire sequence as one large\noperation.\
    \  The state of such an operation is maintained in the OPD.\nRefer back to figure\
    \ 4-4.  There is one box labeled \"object\" in this\npicture; this box represents\
    \ the list as a whole.  To operate on any\ngiven member we need an object box\
    \ to represent that member.  Figure 4-8\nshows the structure with an additional\
    \ object box; the new box\nrepresents one member at any given moment.  Its value\
    \ is one of the\ncomponents of the LIST value; its description is subordinate\
    \ to the LIST\ndescription. In 4-8, the name of this object is M.\nIn 4-8 we have\
    \ enough structure to provide a description and value for\nM, and this is sufficient\
    \ to permit the execution of operations on M as\nan item.  However, there is no\
    \ direct link between object M and object\nL.  The structure is completed by the\
    \ addition of an OPD, shown in\nfigure 4-9.\n       _________________        \
    \ _________________\n      |                 |       |  _____________  |\n   \
    \   |  _____________  |       | |             | |\n      | |      L      | | \
    \      | |_____________| |\n      | |_____________| |       |  TYPE          \
    \ |\n      |  NAME           |       |  _____________  |\n      |  _____________\
    \  |       | |             | |\n      | |         ____|_|______\\| |__________|__|\
    \ |\n      | |_____________| |      /|  CHILD     |    |\n      |  DESCRIPTION\
    \    |       |____________|____|\n      |  _____________  |        DESCRIPTION\
    \ |\n      | |             | |                    |\n      | |_________|___| |\
    \        ____________V____\n      |  VALUE    |     |       |  _____________ \
    \ |\n      |___________|_____|       | |    STRING   | |/___\n       OBJECT  \
    \   |             | |_____________| |\\   |\n                  |             |\
    \  TYPE           |    |\n       ___________V_____        |_________________|\
    \    |\n      |                 |        DESCRIPTION           |\n      |  _____________\
    \  |                              |\n      | |    \"ABC\"    | |        _________________\
    \     |\n      | |_____________| |       |                 |    |\n      |  _____________\
    \  |       |  _____________  |    |\n      | |     \"XY\"    | |       | |   \
    \   M      | |    |\n      | |_____________| |       | |_____________| |    |\n\
    \      |  _____________  |       |  NAME           |    |\n      | |    \"ZLM\"\
    \    |/|___    |  _____________  |    |\n      | |_____________|\\|   |   | |\
    \         ____|_|____|\n      |        :        |   |   | |_____________| |\n\
    \      |        :        |   |   |  DESCRIPTION    |\n      |  _____________ \
    \ |   |   |  _____________  |\n      | |    \"BBBF\"   | |   |___|_|____     \
    \    | |\n      | |_____________| |       | |_____________| |\n      |_________________|\
    \       |  VALUE          |\n       VALUE                    |_________________|\n\
    \                                 OBJECT\n                               Figure\
    \ 4-8\n                        LIST and member objects\n       _________________\
    \         _________________\n      |  _____________  |       |  _____________\
    \  |\n      | |      L      | |       | |             | |\n      | |_____________|\
    \ |       | |_____________| |\n      |  NAME           |       |  TYPE       \
    \    |\n      |  _____________  |       |  _____________  |\n      | |       \
    \  ____|_|______\\| |             | |\n      | |_____________| |      /| |__________|__|\
    \ |\n      |  DESCRIPTION    |       |  CHILD     |    |\n      |  _____________\
    \  |       |____________|____|\n      | |             | |/__     DESCRIPTION |\n\
    \      | |_________|___| |\\  |    ____________V____\n      |  VALUE    |    \
    \ |   |   |  _____________  |\n      |___________|_____|   |   | |    STRING \
    \  | |/___\n       OBJECT     |         |   | |_____________| |\\   |\n      \
    \            |         |   |  TYPE           |    |\n       ___________V_____\
    \    |   |_________________|    |\n      |  _____________  |   |    DESCRIPTION\
    \           |\n      | |    \"ABC\"    | |   |    _________________     |\n  \
    \    | |_____________| |   |   |                 |    |\n      |  _____________\
    \  |   |   |  _____________  |    |\n      | |     \"XY\"    | |   |___|_|____\
    \         | |    |\n      | |_____________| |       | |_____________| |    |\n\
    \      |  _____________  |       |  LIST           |    |\n      | |    \"ZLM\"\
    \    | |       |  _____________  |    |\n      | |_____________| |       | | \
    \            | |    |\n      |        :        |       | |_________|___| |   \
    \ |\n      |        :        |       |  MEMBER   |     |    |\n      |  _____________\
    \  |       |     :     |     |    |\n      | |    \"BBBF\"   |/|___    |     :\
    \     |     |    |\n      | |_____________|\\|   |   |___________|_____|    |\n\
    \      |_________________|   |    OPD        |          |\n       VALUE      \
    \          |    ___________V_____     |\n                            |   |  _____________\
    \  |    |\n                            |   | |      M      | |    |\n        \
    \                    |   | |_____________| |    |\n                          \
    \  |   |  NAME           |    |\n                            |   |  _____________\
    \  |    |\n                            |   | |         ____|_|____|\n        \
    \                    |   | |_____________| |\n                            |  \
    \ |  DESCRIPTION    |\n                            |   |  _____________  |\n \
    \                           |___|_|____         | |\n                        \
    \        | |_____________| |\n         Figure 4-9             |  VALUE       \
    \   |\n    OPD, LIST and member        |_________________|\n                 \
    \                OBJECT\nThe OPD establishes the object relationship, and contains\
    \ information\nabout the sequence of primitive listops in progress.  When sufficient\n\
    information is maintained in the OPD, we have in 4-9 a structure which\nis adequate\
    \ for the maintenance of the integrity of the LIST and of the\nglobal list operation.\
    \  In addition to LIST and member pointers, the OPD\ncontains information indicating:\
    \ (1) which suboperations are enabled for\nthe sequence, (2) the current suboperation,\
    \ (3) the instance number of\nthe current LIST member, (4) an end-of-list indicator.\
    \  The\nsuboperations are add/member, delete/member, change/member and\nget/member.\
    \  All apply to the current member.  Only suboperations which\nhave been enabled\
    \ at the beginning of a sequence may be executed during\nthat sequence; eventually,\
    \ the advance knowledge of intentions that is\nimplied by this will provide important\
    \ information for concurrency\ncontrol and optimization.\nPresently, an OPD relates\
    \ a single member object to a single LIST\nobject.  This imposes an important\
    \ restriction on the class of operation\nsequences which can be expressed.  Any\
    \ LIST transformation requiring\nsimultaneous access to more than one member must\
    \ be represented as more\nthan one sequence. (And we do not yet solve the problems\
    \ implied in\nconcurrent execution of such sequences, even when both are controlled\
    \ by\none process.)\nAny transformation of a LIST can still be achieved by storing\n\
    intermediate results in temporary objects; however, it is certainly more\ndesirable\
    \ to incorporate the idea of multiple current members into the\nsemantics of the\
    \ language, than it is to use such temporaries.  An\nimportant future extension\
    \ of the listops will deal with this problem.\nThere are six listops: listop/begin,\
    \ listop/end, which/member,\nend/of/list, open/member and close/member.\nListop/begin\
    \ and listop/end perform the obvious functions of beginning\nand terminating a\
    \ sequence of listops.  Listop/begin inputs LIST and\nmember objects, an OPD,\
    \ and a specification of suboperations to enable.\nIt initializes the OPD, including\
    \ establishment of the links to LIST and\nMEMBER objects.  After the OPD-LIST-member\
    \ relationship has been\nestablished, it is only necessary to supply the OPD and\
    \ auxiliary\nparameters as input to a listop in the sequence. From the OPD everything\n\
    else can be derived.\nListop/end clears the OPD and frees any resources acquired\
    \ by\nlistop/begin.\nWhich/member establishes the current member for any suboperations.\
    \  This\nis either the first LIST member, the last LIST member, or the next LIST\n\
    member.  This listop merely identifies which member is to be operated\non; it\
    \ does not make the contents of the member accessible.\nOpen/member and close/member\
    \ bracket a suboperation.  The suboperation\nis indicated as an argument to open/member.\
    \  Open/member always\nestablishes a pointer from the member object to the member\
    \ value;\nclose/member always clears this pointer.  In addition, each of these\n\
    listops may take some action, depending on the suboperation.\nThe details of the\
    \ action would be dependent on the representation of\nthe LIST in storage, the\
    \ size of a LIST member, and choices made in\nimplementation.\nBetween execution\
    \ of the open/member and the close/member, the data is\naccessible.  It can always\
    \ be read; in the case of the add/member and\nchange/member suboperations, it\
    \ can also be written into.\nEnd/of/list tests a flag in the OPD and returns an\
    \ object of type BOOL.\nThe value of the object is the same as the value of the\
    \ flag; it is TRUE\nif a get/member, change/member or delete/member would be unsuccessful\n\
    due to a which/member having moved \"beyond the end\". T his listop is\nprovided\
    \ so that it is possible to write procedures which terminate\nconditionally when\
    \ all members have been processed.\nGet/struct/member provides the ability to\
    \ handle STRUCTs.  Given a\nSTRUCT object which points to the STRUCT value, it\
    \ will establish a\npointer from a given member object to the member value.  (The\
    \ pointer it\nestablishes is represented by a dashed line in figure 4-10).\n _________________\
    \         _________________\n|  _____________  |       |  _____________  |\n|\
    \ |      F      | |       | |   STRUCT    | |\n| |_____________| |       | |_____________|\
    \ |\n|  NAME           |       |  TYPE           |\n|  _____________  |      \
    \ |  _____________  |\n| |         ____|_|______\\| |             | |\n| |_____________|\
    \ |      /| |__________|__| |\n|  DESCRIPTION    |       |  CHILD     |    |\n\
    |  _____________  |       |____________|____|\n| |             | |        DESCRIPTION\
    \ |\n| |___________|_| |        ____________V____         _________________\n\
    |  VALUE      |   |       |  _____________  |       |  _____________  |\n|  ___________|_\
    \  |       | |    STRING   | |       | |    STRING   | |\n| |           | | |\
    \       | |_____________| |       | |_____________| |\n| |_________|_|_| |   \
    \    |  TYPE           |       |  TYPE           |\n|  CHILD    | |   |      \
    \ |  _____________  |       |  _____________  |\n|___________|_|___|  ____\\|\
    \ |             | |       | |             | |\n OBJECT     | |     |    /| |_____________|\
    \ |       | |_____________| |\n            | |     |     |  SIBLING        | \
    \      |  SIBLING        |\n            | |     |     |_________________|    \
    \   |_________________|\n            | |     |      DESCRIPTION              \
    \ DESCRIPTION    A\n            | |     |      ______________________________________\
    \   |\n            | |     |     |  ____________          ____________  |  |\n\
    \            | |     |     | |    \"ABC\"   |        |    FALSE   | |  |\n   \
    \         | |_____|_____| |____________|        |____________| |  |\n        \
    \    |       |     |________A_____________________________|  |\n            |\
    \       |  ............:                        VALUE   |\n ___________V_____\
    \  |  :   _________________                        |\n|  _____________  | |  :\
    \  |  _____________  |                       |\n| |      A      | | |  :  | |\
    \      B      | |                       |\n| |_____________| | |  :  | |_____________|\
    \ |                       |\n|  NAME           | |  :  |  NAME           |   \
    \                    |\n|  _____________  | |  :  |  _____________  |        \
    \               |\n| |         ____|_|_|  :  | |         ____|_|_______________________|\n\
    | |_____________| |    :  | |_____________| |\n|  DESCRIPTION    |    :  |  DESCRIPTION\
    \    |\n|  _____________  |    :  |  _____________  |\n| |         ....|.|....:\
    \  | |             | |\n| |_____________| |       | |_____________| |\n|  VALUE\
    \          |       |  VALUE          |\n|  _____________  |       |  _____________\
    \  |\n| |         ____|_|______\\| |             | |\n| |_____________| |    \
    \  /| |_____________| |\n|  SIBLING        |       |  SIBLING        |\n|_________________|\
    \       |_________________|        Figure 4-10\n OBJECT                    OBJECT\
    \            Effect of GET/STRUCT/MEMBER\nThe primitives discussed so far (assign,\
    \ listops, and get/struct/member)\nprovide a basic facility for operating on structures\
    \ of LISTs, STRUCTs\nand elementary items.  Using only them, it is possible to\
    \ transfer the\ncontents of one hierarchical structure to another, to append structures,\n\
    to delete portions of structures, and so on.  To perform more\ninteresting operations\
    \ facilities for control and selection are needed.\nA rudimentary control facility\
    \ is provided through the primitives\nif/then, if/then/else, till and while. \
    \ All of these evaluate one\nprimitive function call, which must return a BOOL.\
    \  Based on the value\nof this BOOL some action is taken.\nLet A and B be function\
    \ calls.  If/then(A,B) will execute B if A returns\nTRUE.  If/then/else(A,B,C)\
    \ will execute B if A returns TRUE; it will\nexecute C if A returns FALSE.  The\
    \ while and till operators iterate,\nexecuting first A then B. While terminates\
    \ the loop when A returns\nFALSE; till terminates the loop when A returns TRUE.\
    \  If this happens\nthe first time, B is never executed.\nSo far, we have mentioned\
    \ one function which returns a BOOL: the listop,\nend/of/list.  Two other classes\
    \ of functions which have this property\nare the booleans and the comparisons.\
    \  There are 3 primitive booleans\n(and, or, not) and six primitive comparisons\
    \ (equal, less/than,\ngreater/than, not/equal, less/than/or/equal, greater/than/or/equal\
    \ --\nonly equal is implemented at time of publication).\nThe booleans input and\
    \ output BOOLs; the comparisons input pairs of\nelementary objects having the\
    \ same description and output BOOLs.\nExpressions composed of booleans and comparisons\
    \ on item contents are\none of the principal tools used in selectively referencing\
    \ data in data\nmanagement systems.\nWith the booleans, the comparisons, and the\
    \ primitives identified\nearlier, we can perform selective \"retrievals\".  That\
    \ is, we can\ntransfer to LIST B all items in LIST A having a value of 'ABC'.\
    \  In\nfact, we now have a (semantically) general ability to perform content-\n\
    based retrievals and updates on arbitrary hierarchical structures.  We\ncan even\
    \ program something as complex as the processing of a list of\ntransactions against\
    \ a master list, which is one of the typical\napplications in business data processing.\n\
    Of course, we would not expect users of datalanguage to express requests\nat the\
    \ level of listops.  Further, the listops defined here are not a\nvery efficient\
    \ way of performing some of the tasks we have mentioned.\nTo get good solutions,\
    \ we need both higher-level operators and other\nprimitives which use other techniques\
    \ in processing.\nIn addition to those already discussed, the model contains functions\n\
    for: (1) referencing an object by qualified name, (2) generating a\nconstant,\
    \ (3) generating data descriptions, (4) writing compound\nfunctions and blocks\
    \ with local variables, (5) creating objects.\nThe facilities for generating constants\
    \ and data descriptions (which are\na special case of constants) are marginal,\
    \ and have no features of\nspecial interest. Obviously, data description will\
    \ be an important\nconcern in the modeling effort later on.\nObject referencing\
    \ functions permit reference to t/objects and p/objects\n(these terms are defined\
    \ in 4.6).  A p/object is referenced by giving\nthe pathname from STAR to it.\
    \  A t/object is referenced by giving the\npathname from the block directory in\
    \ which it is defined to it.\nCompound/function permits a sequence of function\
    \ calls to be treated\nsyntactically as a single call.  Thus, for example, in\
    \ if/then(A,B), B\nis frequently a call to compound/function, which in turn calls\
    \ a\nsequence of other functions.\nCreate takes two inputs: a superior object\
    \ and a description.  The\nsuperior must be a directory.  The new object is created\
    \ as the leftmost\nchild of the directory; its name is determined by the description.\n\
    4.8 Details of primitive language functions\nThis section provides specifications\
    \ for the primitives discussed in the\nprevious section.  We are still omitting\
    \ details when we judge them to\nbe of no general interest; the objective is to\
    \ provide enough\ninformation for the reader to examine examples.\nMost of the\
    \ primitives occur at two levels in the model.  The internal\nprimitives are called\
    \ i/functions and the external, or language\nprimitives are called l/functions.\
    \  The relationship between the two\ntypes are explained in 4.9. In this section\
    \ we discuss i/functions.\nL/functions input and output _forms_, which are tree\
    \ structures whose\nterminal nodes are atoms.  The atoms are such things as function\
    \ names,\nobject names, literal string constants, truth va1ues and delimiters.\n\
    Calls to i/functions are also expressed as forms.\nAny form can be evaluated,\
    \ yielding some object.  A form which is an\ni/function call yields the value\
    \ returned by the i/function: another\nform.  In general, the form returned by\
    \ an i/function call will, when\nevaluated, yield a datalanguage object (that\
    \ is, the sort of object we\nhave been represented by an \"object box\" in the\
    \ drawings).\n4.8.1 Name recognition functions\nThese return a form which evaluates\
    \ to an object.\nL/TOBJ\nInput must name a temporary object subordinate either\
    \ to TOP/LEVEL or a\nblock directory.\nL/POBJ\nInput must name a permanent object\
    \ (i.e., an object subordinate to\nSTAR).\nTypical calls are L/POBJ(X.Y.Z) and\
    \ L/TOBJ(A).\n4.8.2 Constant generators\nEach of these inputs an atomic symbol\
    \ yielding a value for a constant to\nbe created.  Each returns a form which will\
    \ evaluate to an object having\nthe specified value and an appropriate description.\n\
    LC/STRING - a typical call is LC/STRING('ABC')\nLC/BOOL - a typical call is LC/BOOL(TRUE)\n\
    4.8.3 Elementary item functions\nThese input and output forms evaluating to elementary\
    \ objects (objects\nwhich can have no subordinate object -- in effect, objects\
    \ whose value\nis regarded as atomic).  Eventually all the comparison operators\
    \ will be\nimplemented.\nL/ASSIGN\nInputs must evaluate either to STRINGs or BOOLs.\
    \ Outputs a form which\ntransfers the value of the second to the first.  Typical\
    \ call:\n    L/ASSIGN(L/TOBJ(A),LC/STRING('XYZ'))\nThe output form, when evaluated,\
    \ will copy 'XYZ' into A's value.\nL/EQUAL\nInputs a pair of forms evaluating\
    \ to objects, which must have identical\ndescriptions and be BOOLs or STRINGs.\
    \  Returns a form evaluating to an\nobject of type BOOL.  Value of this object\
    \ is TRUE if inputs have\nidentical descriptions and values; otherwise it is false.\
    \ Typical call:\n    L/EQUAL(L/TOBJ(X),LC/STRING('DEF'))\nL/AND, L/OR, L/NOT\n\
    The standard boolean operators.  Inputs are forms evaluating to BOOLs;\noutput\
    \ is a form evaluating to a BOOL.  L/AND and L/OR take two inputs;\nL/NOT one.\
    \  Typical call:\n    L/AND( L/EQUAL(L/TOBJ(X),LC/STRING('DEF')),\n          \
    \         L/EQUAL(T/TOBJ(Y),LC/STRING('GHI')) )\nThe form returned will, when\
    \ evaluated, return TRUE if both X has value\n'DEF' and Y has value 'GHI'.\n4.8.4\
    \ Data description functions\nThese all return a form evaluating to a description\
    \ (i.e. that which is\nrepresented in our drawings by a box labeled \"description\"\
    ).\nLD/STRING\nInputs 3 parameters specifying the name, size option and size for\
    \ the\nstring. Typical call:\n    LD/STRING(X,FIXED,3)\nThis call returns a form\
    \ evaluating to a description for a fixed-length\n3-character string named X.\n\
    LD/LIST\nInputs two forms.  The first is the name of the LIST and the second\n\
    evaluates to a description of the LIST member.  Typical call:\n    LD/LIST(L,LD/STRING(M,FIXED,3))\n\
    Creates the structure shown in figure 4-11, and returns a form\nevaluating to\
    \ the description represented by the upper box.\n               _________________\n\
    \              |  _____________  |\n              | |      L      | |\n      \
    \        | |_____________| |\n              |  NAME           |\n            \
    \  |  _____________  |\n              | |     LIST    | |\n              | |_____________|\
    \ |\n              |  TYPE           |\n              |  _____________  |\n  \
    \            | |             | |\n              | |________|____| |\n        \
    \      |  CHILD   |      |\n              |__________|______|\n             DESCRIPTION\
    \ |\n                         |\n               __________V______\n          \
    \    |  _____________  |\n              | |      M      | |\n              | |_____________|\
    \ |\n              |  NAME           |\n              |  _____________  |\n  \
    \            | |    STRING   | |\n              | |_____________| |\n        \
    \      |  TYPE           |\n              |  _____________  |\n              |\
    \ |  _________  | |\n              | | |  FIXED  | | |\n              | | |_________|\
    \ | |\n              | |  _________  | |\n              | | |    3    | | |\n\
    \              | | |_________| | |\n              | |_____________| |\n      \
    \        |  PARAMETERS     |\n              |_________________|\n            \
    \   DESCRIPTION\n                              Figure 4-11\n                 \
    \     LIST and member descriptions\nLD/STRUCT\nInputs a form to use as the name\
    \ for the STRUCT and one or more forms\nevaluating to descriptions; these are\
    \ taken as the descriptions of the\nmembers.  Typical call:\n    LD/STRUCT(R,\n\
    \            LD/STRING(A,FIXED,3)\n            LD/BOOL(B) )\nproduces the structure\
    \ shown in 4-12; returns a form evaluating to the\ntop box.\n               _________________\n\
    \              |  _____________  |\n              | |      R      | |\n      \
    \        | |_____________| |\n              |  NAME           |\n            \
    \  |  _____________  |\n              | |    STRUCT   | |\n              | |_____________|\
    \ |\n              |  TYPE           |\n              |  _____________  |\n  \
    \            | |             | |\n              | |_________|___| |\n        \
    \      |  CHILD    |     |\n              |___________|_____|\n             DESCRIPTION\
    \  |\n                          |\n               ___________V_____\n        \
    \      |  _____________  |\n              | |      A      | |\n              |\
    \ |_____________| |\n              |  NAME           |\n              |  _____________\
    \  |\n              | |    STRING   | |\n              | |_____________| |\n \
    \             |  TYPE           |        _________________\n              |  _____________\
    \  |       |  _____________  |\n              | |             | |       | |  \
    \    B      | |\n              | |_____________| |       | |_____________| |\n\
    \              |  PARAMETER      |       |  NAME           |\n              |\
    \  _____________  |       |  _____________  |\n              | |         ____|_|______\\\
    | |    BOOL     | |\n              | |_____________| |      /| |_____________|\
    \ |\n              |  SIBLING        |       |  TYPE           |\n           \
    \   |_________________|       |_________________|\n               DESCRIPTION\
    \               DESCRIPTION\n                              Figure 4-12\n     \
    \                STRUCT and member descriptions\nLD/BOOL, LB/DIR, LD/OPD, LD/FUNC,\
    \ LD/DESC\nEach inputs a name and produces a single description; each returns\
    \ a\nform evaluating to the description produced.  Typical call:\n    LD/BOOL(X)\n\
    4.8.5 Data creation\nL/CREATE\nInputs two forms and evaluates them.  First must\
    \ yield an object of type\nDIR; second must yield a description for the object\
    \ to be created.\nCreates the object and returns a form, which, when evaluated,\
    \ will\ngenerate a value for the new object.  A simple example:\n    L/CREATE(L/TOBJ(X),LD/B0OL(Y))\n\
    Figure 4-13 shows the directory X before execution of the above call. It\ncontains\
    \ only an OPD.  After execution, the directory appears as in 4-\n14. Creation\
    \ of a value for Y occurs when the form returned by L/CREATE\nis evaluated (covered\
    \ in section 4.9).\n                _________________\n               |      \
    \           |\n               |  _____________  |\n               | |      X \
    \     | |\n               | |_____________| |\n               |  NAME        \
    \   |        ____________\n               |  _____________  |       |  ________\
    \  |\n               | |         ____|_|______\\| |   DIR  | |\n             \
    \  | |_____________| |      /| |________| |\n               |  DESCRIPTION   \
    \ |       |  TYPE      |\n               |  _____________  |       |____________|\n\
    \               | |             | |        DESCRIPTION\n               | |_________|___|\
    \ |\n               |  CHILD    |     |\n               |___________|_____|\n\
    \                OBJECT     |\n                           |\n                \
    \           |\n                ___________V_____\n               |           \
    \      |\n               |  _____________  |\n               | |      Z      |\
    \ |\n               | |_____________| |\n               |  NAME           |  \
    \      ____________\n               |  _____________  |       |  ________  |\n\
    \               | |         ____|_|______\\| |  OPD   | |\n               | |_____________|\
    \ |      /| |________| |\n               |  DESCRIPTION    |       |  TYPE   \
    \   |\n               |  _____________  |       |____________|\n             \
    \  | |             | |        DESCRIPTION\n               | |_________|___| |\n\
    \               |  VALUE    |     |        ____________\n               |___________|_____|\
    \       |            |\n                OBJECT     |____________\\|          \
    \  |\n                                        /|____________|\n              \
    \                            OPD\n                              Figure 4-13\n\
    \                      X and Z before creation of Y\n _________________\n|  _____________\
    \  |\n| |      X      | |\n| |_____________| |        _________________\n|  NAME\
    \           |       |  _____________  |\n|  _____________  |       | |     DIR\
    \     | |\n| |         ____|_|______\\| |_____________| |\n| |_____________| |\
    \      /|  TYPE           |\n|  DESCRIPTION    |       |_________________|\n|\
    \  _____________  |        DESCRIPTION\n| |             | |\n| |_________|___|\
    \ |\n|  VALUE    |     |\n|___________|_____|\n OBJECT     |\n ___________V_____\n\
    |  _____________  |\n| |      Y      | |\n| |_____________| |        _________________\n\
    |  NAME           |       |  _____________  |\n|  _____________  |       | | \
    \    BOOL    | |\n| |         ____|_|______\\| |_____________| |\n| |_____________|\
    \ |      /|  TYPE           |\n|  DESCRIPTION    |       |_________________|\n\
    |  _____________  |        DESCRIPTION\n| |             | |\n| |_____________|\
    \ |\n|  VALUE          |\n|  _____________  |\n| |         ____|_|______________\n\
    | |_____________| |              |\n|  SIBLING        |              |\n|_________________|\
    \        ______V__________         _________________\n       OBJECT          \
    \   |  _____________  |       |  _____________  |\n                          |\
    \ |      Z      | |       | |     OPD     | |\n                          | |_____________|\
    \ |    __\\| |_____________| |\n                          |  NAME           |\
    \   |  /|  TYPE           |\n                          |  _____________  |   |\
    \   |_________________|\n                          | |         ____|_|___|   \
    \ DESCRIPTION\n                          | |_____________| |\n               \
    \           |  DESCRIPTION    |\n                          |  _____________  |\
    \        _________________\n                          | |         ____|_|______\\\
    |                 |\n       Figure 4-14        | |_____________| |      /|_________________|\n\
    \    X, Y, and Z after     |  VALUE          |        OPD\n        L/CREATE  \
    \        |_________________|\n                           OBJECT\n4.8.6 Control\n\
    L/IF/THEN, L/IF/THEN/ELSE\nUsed to request conditional evaluation of a form. Typical\
    \ call:\n    L/IF/THEN(L/EQUAL(L/TOBJ(A),LC/STRING('ABC'),\n            L/ASSIGN(L/TOBJ(B),LC/STRING('DE')))\n\
    The form returned will do the following, when evaluated: if A has value\n'ABC',\
    \ then store 'DE' in the value of B.\nL/WHILE, L/TILL\nThese iterate conditionally,\
    \ as explained in the previous section.\nExamples appear later.\nL/CF\nCompound\
    \ function: it inputs one or more forms and returns a form which,\nwhen evaluated,\
    \ will evaluate each input in sequence.  Typical call:\n    L/CF(L/ASSIGN(L/TOBJ(R.A),LC/STRING('XX')),\n\
    \            L/ASSIGN(L/TOBJ(R.B),LC/STRING('YY')))\nWhen the output of L/CF is\
    \ evaluated, it will assign new values to R.A\nand R.B.\n4.8.7 Listops\nThese\
    \ primitives are executed in sequences in order to perform\noperations on LISTs.\
    \  With the exception of L/END/OF/LIST these\nfunctions output forms which are\
    \ evaluated for effect only; that is, the\noutput forms do not themselves return\
    \ values.\nL/LISTOP/BEGIN\nInputs forms evaluating to: (1) a LIST, (2) an object\
    \ to represent the\ncurrent LIST member, (3) an OPD.  Also, inputs a list of atomic\
    \ forms\nwhose values are taken as suboperations to enable. Typical call:\n  \
    \  L/LISTOP/BEGIN(L/POBJ(F),L/TOBJ(R),\n                    L/TOBJ(OPF),ADD,DELETE)\n\
    This returns a form that will initialize a sequence of listops to be\nperformed\
    \ on F.  Caller has previously created R and OPF. He intends to\nADD and DELETE\
    \ list members.\nAll subsequent calls in this sequence of listops need specify\
    \ only the\nOPD and auxiliary parameters.\nL/LISTOP/END\nInputs a form evaluating\
    \ to an OPD.  Outputs a form which, when\nevaluated, clears OPD and breaks relationships\
    \ between OPD, LIST and\nmember objects.\nL/WHICH/MEMBER\nInputs two forms.  First\
    \ evaluates to an OPD; second is one of FIRST,\nLAST, NEXT. The form output, when\
    \ evaluated, will establish a new\ncurrent member for the next suboperation. \
    \ Note: this does not make the\nvalue of the member accessible, it simply identifies\
    \ it by setting the\ninstance number in the OPD.  A typical call:\n    L/WHICH/MEMBER(L/TOBJ(OPF),NEXT)\n\
    When a which/member causes advance beyond the end of the list, a flag is\nset\
    \ in the OPD.\nL/END/OF/LIST\nInputs a form evaluating to an OPD.  Outputs a form\
    \ which, when\nevaluated, returns a BOOL.  This has value TRUE if the end of list\
    \ flag\nin the OPD is on.\nL/OPEN/MEMBER\nInputs a form evaluating to an OPD and\
    \ a form which must be one of ADD,\nDELETE, GET, CHANGE.  Outputs a form which,\
    \ when evaluated, will\ninitiate the requested suboperation on the current LIST\
    \ member.  The\nsuboperation always establishes the pointer from the member object\
    \ to\nthe current member value instance.  In addition, in the case of ADD this\n\
    value must be created.  Typical call:\n    L/OPEN/MEMBER (L/TOBJ (OPF) ,ADD)\n\
    L/CLOSE/MEMBER\nInputs a form evaluating to an OPD.  Outputs a form which, when\n\
    evaluated, will complete the suboperation in progress.  A typical call:\n    L/CLOSE/MEMBER(L/TOBJ(OPF))\n\
    Always clears the pointer from member object to member value.  In\naddition, in\
    \ the case of DELETE, removes the member value from the LIST.\nIn the case of\
    \ ADD enters the member value in the LIST.  Makes the\nmember added the current\
    \ member, so that a sequence of ADDs executed\nwithout intervening which/members\
    \ will add the new members in sequence.\nAn elaborate example, involving listops\
    \ and several other primitives,\nappears in section 4.10.\n4.9 Execution cycle\n\
    The model datacomputer has a two-part execution cycle: it first compiles\nrequests,\
    \ then interprets them.  A \"request\" is an l/function call;\n\"compilation\"\
    \ is the aggregate result of executing all the l/function\ncalls involved in the\
    \ request (typically this is many calls, as there\nare usually several levels\
    \ of nested calls, with the results of the\ninner calls being delivered as arguments\
    \ to the next level of calls).\nUsually, the process of executing an l/function\
    \ involves a simple macro\nexpansion, preceded by some binding, checking and (eventually)\n\
    optimization.\nThe compiled form consists wholly of atomic symbols and i/function\n\
    calls.  The i/functions are internal primitives which input and output\ndatalanguage\
    \ objects (the entities represented by the boxes labeled\n\"object\" in the drawings).\n\
    Each of the l/functions discussed compiles into a single i/function;\nthus the\
    \ macro expansion aspect of compilation is presently trivial.\nHowever, this will\
    \ not be true in general; it is only that these are\n_primitive_ l/functions that\
    \ makes it true now.\nThe decision to use a compile-and-interpret cycle calls\
    \ for some\nexplanation.  The way to understand this, is to think in terms of\
    \ the\nfunctions that would be performed in a strictly interpretive system.\n\
    There would still be a requirement to perform global checks on the\nvalidity of\
    \ the request in advance of the execution of any part of it.\nThis is because\
    \ partial execution of an incorrect request can leave a\ndatabase in an inconsistent\
    \ state; if this is a large or complex\ndatabase, the cost of recovery will be\
    \ considerable.  Thus it pays to do\nas much checking as is possible; when the\
    \ system is fully developed,\nthis will include a certain element of simple prediction\
    \ of execution\nflow; in any case, much more than syntactic checking is implied.\n\
    Since any such global checks will be performed in advance of actual\nexecution,\
    \ they are effectively not part of the execution itself, for\nany given form.\
    \  By performing them as part of a separate compilation\nprocess, we only formalize\
    \ a modularity which already effectively\nexists.\nThere will still be cases,\
    \ however, in which checking, binding and\noptimization functions must be executed\
    \ during interpretation, if at\nall.  This will occur when the information needed\
    \ is not available until\nsome of the data has been accessed. When practical,\
    \ we will provide for\nsuch occurrences by designing most functions so that they\
    \ can be\nexecuted as part of either \"half\" of the cycle.\nAs the model develops,\
    \ we expect to get a better feel for this problem;\nit is certainly reasonable\
    \ to end up with a structure in which there are\nmany cycles of compilation and\
    \ interpretation, perhaps forming a\nstructure in which nesting of cycles within\
    \ cycles occurs.\n4.10 Examples of operations on LISTs\nHere we develop an example\
    \ of an operation on a LIST using primitive\nl/functions.  We first show the function\
    \ calls required to create a LIST\nnamed F and give it a few member values.  We\
    \ then selectively copy\ncertain members to a second LIST G.\nTo create F:\nL/CREATE(\"\
    STAR\",LD/LIST(F,\n                        LD/STRUCT(R,\n                    \
    \            LD/STRING(A,FIXED,2),\n                                LD/STRING(B,FIXED,2))))\n\
    This creates F as a member of the permanent directory STAR (see section\n4.6 for\
    \ details about STAR).  The symbol STAR has a special status in\nthe \"language\"\
    , in that it is one of the few atomic symbols to evaluate\ndirectly to an object.\
    \  (Recall that most permanent objects are\nreferenced through a call to L/POBJ;\
    \ reserving the symbol STAR is\nequivalent to reserving STAR as a name and writing\
    \ L/POBJ(STAR).  The\nsolution we choose here is easier to write.)  Execution\
    \ of this call\nbuilds the structure shown in 4-15 (except for STAR, which existed\
    \ in\nadvance of the call).  The value initially created for F is an empty\nLIST--a\
    \ LIST of zero members.\n _________________         _________________\n|  _____________\
    \  |       |  _____________  |\n| |     STAR    | |       | |      F      | |\n\
    | |_____________| |       | |_____________| |\n|  NAME           |       |  NAME\
    \           |\n|  _____________  |       |  _____________  |\n| |            \
    \ | |       | |     LIST    | |\n| |_________|___| |       | |_____________| |\n\
    |  CHILD    |     |       |  TYPE           |\n|___________|_____|       |  _____________\
    \  |\n OBJECT     |             | |             | |\n            |           \
    \  | |___________|_| |\n ___________V_____     __\\|  CHILD      |   |\n|  _____________\
    \  |   |  /|_____________|___|\n| |      F      | |   |    DESCRIPTION  |\n| |_____________|\
    \ |   |                 |\n|  NAME           |   |    _____________V___\n|  _____________\
    \  |   |   |  _____________  |\n| |         ____|_|   |   | |      R      | |\n\
    | |_____________| |___|   | |_____________| |\n|  DESCRIPTION    |       |  NAME\
    \           |\n|  _____________  |       |  _____________  |\n| |            \
    \ | |       | |    STRUCT   | |\n| |_________|___| |       | |_____________| |\n\
    |  VALUE    |     |       |  TYPE           |\n|___________|_____|       |  _____________\
    \  |\n OBJECT     |             | |             | |\n            |           \
    \  | |___________|_| |\n ___________V_____        |  CHILD      |   |\n|     \
    \            |       |_____________|___|\n|                 |        DESCRIPTION\
    \  |\n|_________________|        _____________V___\n VALUE                   \
    \ |  _____________  |\n                          | |      A      | |\n       \
    \                   | |_____________| |\n                          |  NAME   \
    \        |       _________________\n                          |  _____________\
    \  |      |  _____________  |\n                          | |    STRING   | | \
    \     | |      B      | |\n                          | |_____________| |     \
    \ | |_____________| |\n                          |  TYPE           |      |  NAME\
    \           |\n                          |  _____________  |      |  _____________\
    \  |\n                          | |         ____|_|_____\\| |  STRING     | |\n\
    \       Figure 4-15        | |_____________| |     /| |_____________| |\n   F\
    \ immediately after    |  SIBLING        |      |  TYPE           |\n        creation\
    \          |_________________|      |_________________|\n                    \
    \       DESCRIPTION              DESCRIPTION\nTo add members to F, we need to\
    \ use listops, and for this we must create\ntwo more objects: an object to represent\
    \ the current member and an\noperation descriptor (OPD).  These are temporaries\
    \ rather than permanent\nobjects; they are also \"top level\" (i.e., not local\
    \ to a request).\nTemporary, top level objects are created as members of the directory\n\
    TOP/LEVEL. The calls to create them are:\n    L/CREATE(L/TOBJ(TOP/LEVEL),\n  \
    \                  LD/STRUCT(M,\n                            LD/STRING(A,FIXED,2),\n\
    \                            LD/STRING(B,FIXED,2)))\n    L/CREATE(L/TOBJ(TOP/LEVEL),LD/OPD(OPF))\n\
    We create M to represent the current member; its description is the same\nas the\
    \ one input for a member of F (see the call which created F). The\nproper way\
    \ to accomplish this is with a mechanism which shares the\nactual LIST member\
    \ description with M; however, this mechanism does not\nyet exist in our model.\n\
    We now wish to add some data to F; each member will be a STRUCT\ncontaining two\
    \ two-character STRINGs.\nTo begin the listop sequence:\n    L/LISTOP/BEGIN(L/POBJ(F),L/TOBJ(M),\n\
    \                            L/TOBJ(OPF),ADD)\nThis call establishes the structure\
    \ shown in figure 4-16. It initializes\nthe OPD, making it point to F and M and\
    \ recording that only the ADD\nsuboperation is enabled.\n _________________  \
    \       _________________\n|  _____________  |       |  _____________  |\n| |\
    \     STAR    | |       | |     OPF     | |\n| |_____________| |       | |_____________|\
    \ |\n|  NAME           |       |  NAME           |\n|  _____________  |      \
    \ |  _____________  |\n| |             | |       | |             | |\n| |_________|___|\
    \ |       | |_______|_____| |\n|  CHILD    |     |       |  VALUE  |       |\n\
    |___________|_____|       |_________|_______|\n OBJECT     |              OBJECT\
    \   |\n ___________V_____         _________V______\n|  _____________  |      \
    \ |  _____________  |\n| |      F      | |/______|_|____         | |\n| |_____________|\
    \ |\\      | |_____________| |\n|  NAME           |       |  LIST           |\n\
    |  _____________  |       |  _____________  |\n| |             | |       | | \
    \            | |\n| |_________|___| |       | |________|____| |\n|  VALUE    |\
    \     |       |  MEMBER  |      |\n|___________|_____|       |__________|______|\n\
    \ OBJECT     |              VALUE     | OPD\n            |              __________V______\n\
    \ ___________V_____        |  _____________  |\n|                 |       | |\
    \      M      | |\n|       LIS       |       | |_____________| |\n|_________________|\
    \       |  NAME           |\n VALUE                    |  _____________  |\n \
    \                         | |             | |\n                          | |________|____|\
    \ |\n                          |  CHILD   |      |\n                         \
    \ |__________|______|\n                           OBJECT    |\n              \
    \             __________V______        _________________\n                   \
    \       |  _____________  |      |  _____________  |\n                       \
    \   | |      A      | |      | |      B      | |\n                          |\
    \ |_____________| |      | |_____________| |\n                          |  NAME\
    \           |      |  NAME           |\n                          |  _____________\
    \  |      |  _____________  |\n                          | |         ____|_|_____\\\
    | |             | |\n                          | |_____________| |     /| |_____________|\
    \ |\n                          |  SIBLING        |      |                 |\n\
    \                          |_________________|      |_________________|\n    \
    \                       OBJECT                   OBJECT\n                    \
    \          Figure 4-16\n                   F, OPF and M after L/BEGIN/LISTOP\n\
    Next we must establish a current member.  We want to add members to the\nend (in\
    \ this case, adding them anywhere would get the same effect, since\nthe LIST is\
    \ empty), which is done by making LAST the current member.\n    L/WHICH/MEMBER(L/TOBJ(OP1),LAST)\n\
    Now, to add a new member to F, we can execute the following:\n    L/OPEN/MEMBER(L/TOBJ(OPF),ADD)\n\
    \    L/ASSIGN(L/TOBJ(M.A),LC/STRING('AB'))\n    L/ASSIGN(L/TOBJ(M.B),LC/STRING('CD'))\n\
    \    L/CLOSE/MEMBER(L/TOBJ(OPF))\nL/OPEN/MEMBER creates a STRUCT value for M.\
    \  It does not affect the\nvalue of F.  Each member of the STRUCT value is initialized\
    \ when the\nSTRUCT is created.  The result is shown in 4-17; notice that the STRUCT\n\
    member values are as yet unrelated to the objects M.A and M.B.\nFigure 4-18 shows\
    \ the changes accomplished by the first L/ASSIGN; the\npointer from the object\
    \ M.A to the value was set up by a\nGET/STRUCT/MEMBER compiled by L/TOBJ(M.A).\
    \  The value was filled in by\nthe assign operator.  The second assign has similar\
    \ effect, filling in\nthe second value.  The call to L/CLOSE/MEMBER takes the\
    \ value shown for\nM in 4-18 (with the second member value filled in) and adds\
    \ it to the\nvalue of F.  The result is shown in 4-19; compare with 4-16.\n  \
    \     _________________         _________________\n      |  _____________  | \
    \      |  _____________  |\n      | |      M      | |       | |    STRUC    |\
    \ |\n      | |_____________| |       | |_____________| |\n      |  NAME      \
    \     |       |  TYPE           |\n      |  _____________  |       |  _____________\
    \  |\n      | |         ____|_|______\\| |             | |\n      | |_____________|\
    \ |      /| |__________|__| |\n      |  DESCRIPTION    |       |  CHILD     |\
    \    |\n      |  _____________  |       |____________|____|\n _____|_|____   \
    \      | |        DESCRIPTION |\n|     | |_____________| |                   \
    \ |\n|     |  VALUE          |        ____________V____\n|     |  _____________\
    \  |       |  _____________  |\n|     | |             | |       | |    STRING\
    \   | |\n|     | |_________|___| |       | |_____________| |\n|     |  CHILD \
    \   |     |   ___\\|  TYPE           |        _____________\n|     |___________|_____|\
    \  |   /|  _____________  |       |  _________  |\n|      OBJECT     |       \
    \ |    | |         ____|_|______\\| | STRING  | |\n|                 |       \
    \ |    | |_____________| |      /| |_________| |\n|      ___________V_____   |\
    \    |  SIBLING        |       |  TYPE       |\n|     |  _____________  |  | \
    \   |_________________|       |_____________|\n|     | |      A      | |  |  \
    \   DESCRIPTION           DESCRIPTION    A\n|     | |_____________| |  |     \
    \                                     |\n|     |  NAME           |  |     _________________\
    \                    |\n|     |  _____________  |  |    |  _____________  |  \
    \                 |\n|     | |         ____|_|__|    | |      B      | |     \
    \              |\n|     | |_____________| |       | |_____________| |        \
    \           |\n|     |  DESCRIPTION    |       |  NAME           |           \
    \        |\n|     |  _____________  |       |  _____________  |              \
    \     |\n|     | |             | |       | |         ____|_|___________________|\n\
    |     | |_____________| |       | |_____________| |\n|     |  VALUE          |\
    \       |  DESCRIPTION    |\n|     |  _____________  |       |  _____________\
    \  |\n|     | |         ____|_|______\\| |             | |\n|     | |_____________|\
    \ |      /| |_____________| |\n|     |  SIBLING        |       |  VALUE      \
    \    |\n|     |_________________|       |_________________|\n|      OBJECT   \
    \                 OBJECT\n|___________________________\n                     \
    \       |\n       _____________________V____________________\n      |  _____________\
    \            _____________  |\n      | |             |          |            \
    \ | |\n      | |_____________|          |_____________| |\n      |__________________________________________|\
    \       Figure 4-17\n       VALUE                                         After\
    \ L/OPEN/MEMBER\n       _________________         _________________\n      | \
    \ _____________  |       |  _____________  |\n      | |      M      | |      \
    \ | |    STRUC    | |\n      | |_____________| |       | |_____________| |\n \
    \     |  NAME           |       |  TYPE           |\n      |  _____________  |\
    \       |  _____________  |\n      | |         ____|_|______\\| |            \
    \ | |\n      | |_____________| |      /| |__________|__| |\n      |  DESCRIPTION\
    \    |       |  CHILD     |    |\n      |  _____________  |       |____________|____|\n\
    \ _____|_|____         | |        DESCRIPTION |\n|     | |_____________| |   \
    \                 |\n|     |  VALUE          |        ____________V____\n|   \
    \  |  _____________  |       |  _____________  |\n|     | |             | |  \
    \     | |    STRING   | |\n|     | |_________|___| |       | |_____________| |\n\
    |     |  CHILD    |     |   ___\\|  TYPE           |        _____________\n| \
    \    |___________|_____|  |   /|  _____________  |       |  _________  |\n|  \
    \    OBJECT     |        |    | |         ____|_|______\\| | STRING  | |\n|  \
    \               |        |    | |_____________| |      /| |_________| |\n|   \
    \   ___________V_____   |    |  SIBLING        |       |  TYPE       |\n|    \
    \ |  _____________  |  |    |_________________|       |_____________|\n|     |\
    \ |      A      | |  |     DESCRIPTION           DESCRIPTION    A\n|     | |_____________|\
    \ |  |                                          |\n|     |  NAME           | \
    \ |     _________________                    |\n|     |  _____________  |  | \
    \   |  _____________  |                   |\n|     | |         ____|_|__|    |\
    \ |      B      | |                   |\n|     | |_____________| |       | |_____________|\
    \ |                   |\n|     |  DESCRIPTION    |       |  NAME           | \
    \                  |\n|     |  _____________  |       |  _____________  |    \
    \               |\n|   __|_|____         | |       | |         ____|_|___________________|\n\
    |  |  | |_____________| |       | |_____________| |\n|  |  |  VALUE          |\
    \       |  DESCRIPTION    |\n|  |  |  _____________  |       |  _____________\
    \  |\n|  |  | |         ____|_|______\\| |             | |\n|  |  | |_____________|\
    \ |      /| |_____________| |\n|  |  |  SIBLING        |       |  VALUE      \
    \    |\n|  |  |_________________|       |_________________|\n|  |  OBJECT    \
    \                OBJECT\n|  |___________\n|              |\n|      ________|_________________________________\n\
    |     |  ______V______            _____________  |\n|____\\| |   \"AB\"      |\
    \          |             | |\n     /| |_____________|          |_____________|\
    \ |\n      |__________________________________________|       Figure 4-18\n  \
    \     VALUE                                        After first L/ASSIGN\n    _________________\
    \         _________________\n   |  _____________  |       |  _____________  |\n\
    \   | |     STAR    | |       | |     OPF     | |\n   | |_____________| |    \
    \   | |_____________| |\n   |  NAME           |       |  NAME           |\n  \
    \ |  _____________  |       |  _____________  |\n   | |             | |      \
    \ | |             | |\n   | |_________|___| |       | |___________|_| |\n   |\
    \  CHILD    |     |       |  VALUE      |   |\n   |___________|_____|       |_____________|___|\n\
    \    OBJECT     |              OBJECT       |\n    ___________V_____         _____________V___\n\
    \   |  _____________  |       |  _____________  |\n   | |      F      | |/______|_|____\
    \         | |\n   | |_____________| |\\      | |_____________| |\n   |  NAME \
    \          |       |  LIST           |\n   |  _____________  |       |  _____________\
    \  |\n   | |             | |       | |             | |\n   | |_________|___| |\
    \       | |___________|_| |\n   |  VALUE    |     |       |  MEMBER     |   |\n\
    \   |___________|_____|       |_____________|___|\n    OBJECT     |          \
    \    VALUE        | OPD\n               |              _____________V___\n ______________V_________\
    \    |  _____________  |\n| ______________________ |   | |      M      | |\n||\
    \ _________  _________ ||   | |_____________| |\n|||  \"AB\"   ||  \"CD\"   |||\
    \   |  NAME           |\n|||_________||_________|||   |  _____________  |\n||______________________||\
    \   | |             | |\n|                 /      |   | |___________|_| |\n| \
    \               /       |   |_____________|___|\n|_______________/________|  \
    \  OBJECT       |\n VALUE         /       /      _____________V___        _________________\n\
    \              /       /      |  _____________  |      |  _____________  |\n \
    \            /       /       | |             | |      | |      B      | |\n  \
    \          /      LIST      | |_____________| |      | |_____________| |\n   \
    \        /                 |  NAME           |      |  NAME           |\n    \
    \      /                  |  _____________  |      |  _____________  |\n NEW MEMBER\
    \ VALUE            | |         ____|_|_____\\| |             | |\n           \
    \                  | |_____________| |     /| |_____________| |\n            \
    \                 |_________________|      |_________________|\n             \
    \                 OBJECT                   OBJECT\n                          \
    \    Figure 4-19\n                          After L/CLOSE/MEMBER\nBy executing\
    \ similar groups of four primitives, varying only values of\nconstants, we can\
    \ build up the LIST F shown in 4-20.  The calls required\nare shown below:\n \
    \   L/OPEN/MEMBER(L/TOBJ(OPF),ADD)\n    L/ASSIGN(L/TOBJ(M.A),LC/STRING('FF'))\n\
    \    L/ASSIGN(L/TOBJ(M.B),LC/STRING('GH'))\n    L/CLOSE/MEMBER(L/TOBJ(OPF))\n\
    \    L/OPEN/MEMBER(L/TOBJ(OPF),ADD)\n    L/ASSIGN(L/TOBJ(M.A),LC/STRING('AB'))\n\
    \    L/ASSIGN(L/TOBJ(M.B),LC/STRING('IJ'))\n    L/CLOSE/MEMBER(L/TOBJ(OPF))\n\
    \    L/OPEN/MEMBER(L/TOBJ(OPF),ADD)\n    L/ASSIGN(L/TOBJ(M.A),LC/STRING('CD'))\n\
    \    L/ASSIGN(L/TOBJ(M.B),LC/STRING('LM'))\n    L/CLOSE/MEMBER(L/TOBJ(OPF))\n\
    The add suboperation has the effect of making the member just added, the\ncurrent\
    \ member; thus no L/WHICH/MEMBER calls are needed in this\nsequence.\nTo terminate\
    \ the sequence of listops:\n    L/END/LISTOP(L/TOBJ(OPF))\n                  \
    \    _________________\n                     |  _____________  |\n           \
    \          | |      F      | |\n                     | |_____________| |\n   \
    \                  |  NAME           |\n                     |  _____________\
    \  |\n                     | |         ____|_|_________\\\n                  \
    \   | |_____________| |         /\n                     |  DESCRIPTION    |\n\
    \                     |  _____________  |\n                     | |          \
    \   | |\n                     | |_________|___| |\n                     |  VALUE\
    \    |     |\n                     |___________|_____|\n                     \
    \ OBJECT     |\n                                 |\n                  _______________V______________\n\
    \                 |  __________________________  |\n                 | |  _________\
    \    _________  | |\n                 | | |         |  |         | | |\n     \
    \            | | |  \"AB\"   |  |  \"CD\"   | | |\n                 | | |_________|\
    \  |_________| | |\n                 | |__________________________| |\n      \
    \           |  __________________________  |\n                 | |  _________\
    \    _________  | |\n                 | | |         |  |         | | |\n     \
    \            | | |  \"EF\"   |  |  \"GH\"   | | |\n                 | | |_________|\
    \  |_________| | |\n                 | |__________________________| |\n      \
    \           |  __________________________  |\n                 | |  _________\
    \    _________  | |\n                 | | |         |  |         | | |\n     \
    \            | | |  \"AB\"   |  |  \"IJ\"   | | |\n                 | | |_________|\
    \  |_________| | |\n                 | |__________________________| |\n      \
    \           |  __________________________  |\n                 | |  _________\
    \    _________  | |\n                 | | |         |  |         | | |\n     \
    \            | | |  \"CD\"   |  |  \"LM\"   | | |\n                 | | |_________|\
    \  |_________| | |\n                 | |__________________________| |\n      \
    \           |______________________________|\n                  VALUE\n      \
    \                        Figure 4-20\n                           After L/END/LISTOP\n\
    A slightly more interesting exercise is to construct calls which create\na LIST\
    \ named G, having the same description as F, and then to copy into\nG all members\
    \ of F having A equal to 'AB'.\nWe must first create G, an OPD and an object to\
    \ represent the current\nmember.\n   L/CREATE(\"STAR\",LD/LIST(G,\n          \
    \                 LD/STRUCT(R,\n                                   LD/STRING(A,STRING,2),\n\
    \                                   LD/STRING(B,STRING,2)))\n    L/CREATE(L/TOBJ(TOP/LEVEL),LD/OPD(OPG))\n\
    \    L/CREATE(L/TOBJ(TOP/LEVEL) ,LD/STRUCT(GM,\n                             \
    \      LD/STRING(A,STRING,2),\n                                   LD/STRING(B,STRING,2)))\n\
    We now need to initiate two sequences of listops, one on G and one on F.\n   \
    \ L/BEGIN/LISTOP(L/POBJ(F),L/TOBJ(M),\n                     L/TOBJ(OPF),GET)\n\
    \    L/BEGIN/LISTOP(L/POBJ(G),L/TOBJ(GM),\n                     L/TOBJ(OPG),ADD)\n\
    \    L/WHICH/MEMBER(L/TOBJ(OPF),FIRST)\n    L/WHICH/MEMBER(L/TOBJ(OPG),LAST)\n\
    We will now sequence through the members of F; whenever the current\nmember has\
    \ A equal to 'AB', we will add a member to G.  We then copy the\nvalues of the\
    \ current member of F into the newly added member of G.\nWhen the current member\
    \ does not meet this criterion, we do nothing with\nit.\nFirst, to write a loop\
    \ that will execute until we get to the end of F:\n    L/TILL(L/END/OF/LIST(L/TOBJ(OPF)),x)\n\
    Whatever we put in this call to replace \"x\" will execute repeatedly\nuntil the\
    \ end/of/list flag has been set in OPF.\nWe must replace \"x\" with a single function\
    \ call to in order to give\nL/TILL what it is looking for.  However, we will be\
    \ executing \"x\" once\nfor each member of F, and will need to execute several\
    \ listops each\ntime.  The solution is to use L/CF, the compound-function function:\n\
    \    L/TILL(L/END/OF/LIST(L/TOBJ(OPF)),L/CF(y))\nWe can now replace \"y\" with\
    \ a sequence of function calls.\nEach time we iterate, we need to process a new\
    \ member of F; initially we\nare set up to get the first member.  The following\
    \ sequence, then, is\nneeded:\n    L/CF(   L/OPEN/MEMBER(L/TOBJ(OPF),GET),\n \
    \           z\n            L/CLOSE/MEMBER(L/TOBJ(OPF)),\n            L/WHICH/MEMBER(L/TOBJ(OPF),NEXT)\
    \ )\nThe above is a compound function which will open the current member of\n\
    F, do something to it (represented above by \"z\"), close it, and ask for\nthe\
    \ next member.\nWe want to replace \"z\" by a function call which tests the contents\
    \ of A\nin the current member of F, and either does nothing or adds a member to\n\
    G, copying the values of the current member of F.  If \"w\" represents the\naction\
    \ of adding a member to G and copying the values, then we can\nexpress this:\n\
    \    L/IF(L/EQUAL(L/TOBJ(M.A),LC/STRING('AB')),w)\nA suitable way to express \"\
    add a member and copy values\" is:\n    L/CF(L/OPEN/MEMBER(L/TOBJ(OPG),ADD),\n\
    \            L/ASSIGN(L/TOBJ(GM.A),L/TOBJ(M.A)),\n            L/ASSIGN(L/TOBJ(GM.B),L/TOBJ(M.B)),\n\
    \            L/CLOSE/MEMBER(L/TOBJ(OPG))\nThis is similar enough to the previous\
    \ example so that no explanation\nshould be necessary.\nPutting this all together,\
    \ we get:\n    L/TILL(L/END/OF/LIST(L/TOBJ(OPF)),\n     L/CF(  L/OPEN/MEMBER(L/TOBJ(OPF),GET),\n\
    \            L/IF(L/EQUAL(L/TOBJ(A),LC/STRING('AB')),\n                    L/CF(\
    \   L/OPEN/MEMBER(L/TOBJ(OPG),ADD),\n                            L/ASSIGN(L/TOBJ(GM.A),L/TOBJ(M.A)),\n\
    \                            L/ASSIGN(L/TOBJ(GM.B),L/TOBJ(M.B)),\n           \
    \                 L/CLOSE/MEMBER/L/TOBJ(OPG)) ) )\n            L/CLOSE/MEMBER(L/TOBJ(OPF)),\n\
    \            L/WHICH/MEMBER(L/TOBJ(OPF),NEXT) ) )\nTo conclude the operation,\
    \ we execute:\n    L/LISTOP/END(L/TOBJ(OPG))\n    L/LISTOP/END(L/TOBJ(OPF))\n\
    The result is a LIST G whose first member has value ('AB','CD'), and\nwhose second\
    \ member has value ('AB','IJ').  With a few variations on the\nabove example,\
    \ quite a few LIST operations can be performed.\n4.11    Higher level functions\n\
    While these primitive i/functions are useful, we would not ordinarily\nexpect\
    \ users to operate in datalanguage at this low level.  We want to\nmake these\
    \ primitives available to users so that they can handle the\nexceptional case,\
    \ and so that they can construct their own high-level\nfunctions for atypical\
    \ applications.  Ordinarily, they ought to operate\nat least at the level of the\
    \ following construction (which is legal in\nthe real datalanguage currently implemented):\n\
    \    FOR G.R,F.R WITH A EQ 'AB'\n            G.R=F.R\n            END\nThis relatively\
    \ concise expression accomplishes the same result as the\nelaborate construction\
    \ of i/functions given at the close of the\npreceding section.  We could define\
    \ i/functions very similar to the\nsemantic functions used in the running software,\
    \ and write the above\nrequest as:\n    L/FOR(L/POBJ(G),R\n            L/POBJ(F),R,L/WITH(L/EQUAL(L/TOBJ(A),\n\
    \                                    LC/STRING('AB')))\nThe differences between\
    \ the i/function call and the datalanguage request\nabove it are principally syntactic.\n\
    In designing functions such as L/FOR and L/WITH, the central problems\nhave to\
    \ do with choosing the right restrictions.  One cannot have all\nthe generality\
    \ available at the primitive level.  Some important choices\nfor these particular\
    \ functions are: (1) handling multiple inputs and\noutputs, (2) when FORs are\
    \ nested, how outer FORs restrict the options\navailable to inner FORs, (3) generality\
    \ of selection functions (may then\nin turn generate FORs?), (4) options with\
    \ regard to where processing\nshould start (are we updating, replacing or appending\
    \ to the output\nlist(s)?).\nFinally, this problem is related to the more general\
    \ problem of dealing\nwith _sets_, which are a generalization of the idea of a\
    \ collection of\nmembers in a LIST having common properties.  FOR is only one\
    \ of many\noperators that can input sets.\n4.12    Conclusion\nThe present model,\
    \ though embryonic, already contains enough primitives\nand data types to permit\
    \ definition and generalized manipulation of\nhierarchical data structures.  Common\
    \ data management operations, such\nas retrieval by content and selective update\
    \ can be expressed.\nThe use of this model in developing these primitives has\
    \ resulted in\nprecise, well-defined and internally consistent specifications\
    \ for\nlanguage elements and processing functions.  Operating in the laboratory\n\
    environment provided by the model seems to be a substantial benefit.\n5.     \
    \ Further Work\nIn this section, we review what has been accomplished so far in\
    \ the\ndesign and describe what work remains to be done before this design\niteration\
    \ of datalanguage is complete.\n5.1     A Review\nMost important, among our accomplishments,\
    \ we feel that we have\ndelineated the problems and presented the broad outlines\
    \ of a solution\nto development of a language for the datacomputer system.  Key\
    \ elements\nof our approach are the primacy of data description in capturing all\
    \ the\naspects of the data, the separation of logical and physical\ncharacteristics\
    \ of data description, the ability of users to define\ndifferent views of the\
    \ same data, the ability to associate functions\nwith different uses of data items,\
    \ an attempt to capture common aspects\nof data at every possible level, and the\
    \ ability of users to communicate\nwith the datacomputer in as high a level as\
    \ their application permits.\n5.2     Topics for Further Research\nAlthough more\
    \ work needs to be done in general to turn out a finished\ndesign for datalanguage,\
    \ we can single out certain issues which in\nparticular need further investigation.\n\
    So far, only hierarchal data structures (i.e. those that can be modeled\nby physical\
    \ containment) have been developed to any extent.  We also\nintend to investigate\
    \ and provide other types of data structures. We are\nconfident that our language\
    \ framework does not make assumptions that\nwould prohibit such additions.\nOur\
    \ current work on access regulation centers on the use of multiple\ndescriptions\
    \ for data.  We need to do more work on both the technical\nand administrative\
    \ aspects of access regulation.  Problems of encrypting\ndata for both transmission\
    \ and storage will also be investigated.\nAnother issue requiring further research\
    \ is the protocol requirement for\nprocess interaction with the datacomputer.\n\
    Separation of the description into independent modules needs further\nresearch.\
    \  In particular, we need to look into work which has already\nbeen done on separate\
    \ specifications of logical descriptions, physical\ndescriptions, and mappings\
    \ between the two.\n5.3     Datalanguage Syntax\nWe have not yet proposed a syntax\
    \ for the datalanguage we are\ndeveloping.  Certainly the most difficult parts\
    \ of the problem have been\nthe semantic and pragmatic issues.  We are confident\
    \ that various\nsyntactic forms can be chosen and implemented without excessive\n\
    difficulty.  It may be best to develop different syntactic forms for the\nlanguage\
    \ for different types of users or even for the various subparts\nof the language\
    \ itself.  As discussed in section 2, the user syntax for\nthe datacomputer is\
    \ supposed to be at a low level.  It should be easy\nfor _programs_ to generate\
    \ datalanguage requests in this syntax.\n5.4     Further Work on the Datalanguage\
    \ Model\nThe model provides an excellent foundation on which to build up a\nlanguage\
    \ with the facilities described in section 3.  Much work is yet\nto be done.\n\
    For a while, emphasis will be on sets, high-level operators, language\nextension\
    \ and data description.\nWe expect to model sets as a new datatype, whose value\
    \ is ordinarily\nshared with other objects.  Some further work on binding and\
    \ sharing of\nvalues is needed to support this.\nSets can be regarded as a special\
    \ case of generalized relations, which\nwill come somewhat later.\nHigh-level\
    \ operators such as FOR will be constructed from the existing\nprimitives, and\
    \ will eventually be defined to have one effect but\nseveral possible expansions.\
    \  The expansion will depend on the\nrepresentation of the data and the presence\
    \ of auxiliary structures.\nAlternate expansions will be possible when the data\
    \ description has been\nbroken up into its various modules.  This, also, requires\
    \ some further\nresearch.\nWe feel that the language extension problem is much\
    \ more easily attacked\nin the environment provided by the model datacomputer.\
    \  In particular,\nwe expect the laboratory environment to be helpful in evaluating\
    \ the\ncomplex interactions and pervasive effects of operators in the language\n\
    which extend the language.\nData description work in the near term will focus\
    \ on the isolation of\nattributes, the representation of variable structure in\
    \ description, the\ndescription of descriptions and the development of a sufficient\
    \ set of\nbuiltin data types.\nLater, we expect to model the semantics of pointers\
    \ as a datatype, when\nthe representation of the pointer and the semantics of\
    \ the address space\ninto which it points are specified in the description of\
    \ the pointer.\nA large number of lower-level issues will be attacked, including\
    \ some of\nthe problems discovered in the modeling to date.  Some of these are\n\
    pointed out in the discussions in section 4.\n5.5     Applications Support\nThe\
    \ datalanguage we are designing is intended to provide services to\nsub-systems\
    \ solving a broad class of problems related to data\nmanagement.  Examples of\
    \ such sub-systems are: report generators, online\nquery systems for non-programmers,\
    \ document-handling systems,\ntransaction processing systems, real-time data collection\
    \ systems, and\nlibrary and bibliographic systems.  There are many more.\nThe\
    \ idea is that such systems will run on other machines, reference or\nstore data\
    \ at the datacomputer, and make heavy use of datalanguage.\nSuch a system would\
    \ not be written entirely in datalanguage, but a large\ncomponent of its function\
    \ would be expressed in datalanguage requests;\nsome controlling module would\
    \ build the requests and perform the non-\ndatalanguage functions.\nWhile we have\
    \ experience with such applications in other environments,\nand we talk to potential\
    \ users, it will require some work to determine\nthat our language is actually\
    \ adequate for them.  That is, we are not\nattacking directly the problem of building\
    \ a human-oriented online query\nsystem; we are trying to provide the tools which\
    \ will make it easy to\nbuild one. There is a definite need to analyze whether\
    \ the tools are\nlikely to be good enough. Of course, the ultimate test will be\
    \ in actual\nuse, but we want to filter out as many problems as we can before\n\
    implementation.\nAn important component of supporting applications is that the\
    \ using\nprograms will frequently be written in high-level languages such as\n\
    FORTRAN, COBOL or PL/1.  We will want to investigate the ability of\ndatalanguage\
    \ to support such users, while the design is taking shape.\n5.6     Future Plans\n\
    This paper has laid the foundations for a new design of datalanguage.\nSection\
    \ 3 provides an outline for a datalanguage design, which will be\nfilled in during\
    \ the coming months.  Following the issue of a detailed\nspecification, we anticipate\
    \ extensive review, revisions, and\nincorporation into the implementation plans.\
    \  Implementation will occur\nin stages, compatible with the established plans\
    \ for development of\ndatacomputer service and data management capabilities.\n\
    \       [ This RFC was put into machine readable form for entry ]\n       [ into\
    \ the online RFC archives by Alex McKenzie with    ]\n       [ support from GTE,\
    \ formerly BBN Corp.           1/2000 ]\n"
