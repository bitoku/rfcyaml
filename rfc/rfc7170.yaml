- contents:
  - '       Tunnel Extensible Authentication Protocol (TEAP) Version 1

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines the Tunnel Extensible Authentication Protocol\n
    \  (TEAP) version 1.  TEAP is a tunnel-based EAP method that enables\n   secure
    communication between a peer and a server by using the\n   Transport Layer Security
    (TLS) protocol to establish a mutually\n   authenticated tunnel.  Within the tunnel,
    TLV objects are used to\n   convey authentication-related data between the EAP
    peer and the EAP\n   server.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7170.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   5\n     1.1.  Specification Requirements  . . . . . . . . . . . .
    . . .   5\n     1.2.  Terminology . . . . . . . . . . . . . . . . . . . . . .
    .   6\n   2.  Protocol Overview . . . . . . . . . . . . . . . . . . . . . .   6\n
    \    2.1.  Architectural Model . . . . . . . . . . . . . . . . . . .   7\n     2.2.
    \ Protocol-Layering Model . . . . . . . . . . . . . . . . .   8\n   3.  TEAP Protocol
    . . . . . . . . . . . . . . . . . . . . . . . .   9\n     3.1.  Version Negotiation
    . . . . . . . . . . . . . . . . . . .   9\n     3.2.  TEAP Authentication Phase
    1: Tunnel Establishment . . . .  10\n       3.2.1.  TLS Session Resume Using Server
    State . . . . . . . .  11\n       3.2.2.  TLS Session Resume Using a PAC  . .
    . . . . . . . . .  12\n       3.2.3.  Transition between Abbreviated and Full
    TLS Handshake  13\n     3.3.  TEAP Authentication Phase 2: Tunneled Authentication
    \ . .  14\n       3.3.1.  EAP Sequences . . . . . . . . . . . . . . . . . . .
    .  14\n       3.3.2.  Optional Password Authentication  . . . . . . . . . .  15\n
    \      3.3.3.  Protected Termination and Acknowledged Result\n               Indication
    \ . . . . . . . . . . . . . . . . . . . . .  15\n     3.4.  Determining Peer-Id
    and Server-Id . . . . . . . . . . . .  16\n     3.5.  TEAP Session Identifier
    . . . . . . . . . . . . . . . . .  17\n     3.6.  Error Handling  . . . . . .
    . . . . . . . . . . . . . . .  17\n       3.6.1.  Outer-Layer Errors  . . . .
    . . . . . . . . . . . . .  18\n       3.6.2.  TLS Layer Errors  . . . . . . .
    . . . . . . . . . . .  18\n       3.6.3.  Phase 2 Errors  . . . . . . . . . .
    . . . . . . . . .  19\n     3.7.  Fragmentation . . . . . . . . . . . . . . .
    . . . . . . .  19\n     3.8.  Peer Services . . . . . . . . . . . . . . . . .
    . . . . .  20\n       3.8.1.  PAC Provisioning  . . . . . . . . . . . . . . .
    . . .  21\n       3.8.2.  Certificate Provisioning within the Tunnel  . . . .
    .  22\n       3.8.3.  Server Unauthenticated Provisioning Mode  . . . . . .  23\n
    \      3.8.4.  Channel Binding . . . . . . . . . . . . . . . . . . .  23\n   4.
    \ Message Formats . . . . . . . . . . . . . . . . . . . . . . .  24\n     4.1.
    \ TEAP Message Format . . . . . . . . . . . . . . . . . . .  24\n     4.2.  TEAP
    TLV Format and Support . . . . . . . . . . . . . . .  26\n       4.2.1.  General
    TLV Format  . . . . . . . . . . . . . . . . .  28\n       4.2.2.  Authority-ID
    TLV  . . . . . . . . . . . . . . . . . .  29\n       4.2.3.  Identity-Type TLV
    . . . . . . . . . . . . . . . . . .  30\n       4.2.4.  Result TLV  . . . . .
    . . . . . . . . . . . . . . . .  31\n       4.2.5.  NAK TLV . . . . . . . . .
    . . . . . . . . . . . . . .  32\n       4.2.6.  Error TLV . . . . . . . . . .
    . . . . . . . . . . . .  33\n       4.2.7.  Channel-Binding TLV . . . . . . .
    . . . . . . . . . .  36\n       4.2.8.  Vendor-Specific TLV . . . . . . . . .
    . . . . . . . .  37\n       4.2.9.  Request-Action TLV  . . . . . . . . . . .
    . . . . . .  38\n       4.2.10. EAP-Payload TLV . . . . . . . . . . . . . . .
    . . . .  40\n       4.2.11. Intermediate-Result TLV . . . . . . . . . . . . .
    . .  41\n       4.2.12. PAC TLV Format  . . . . . . . . . . . . . . . . . . .
    \ 42\n         4.2.12.1.  Formats for PAC Attributes . . . . . . . . . . .  43\n
    \        4.2.12.2.  PAC-Key  . . . . . . . . . . . . . . . . . . . .  44\n         4.2.12.3.
    \ PAC-Opaque . . . . . . . . . . . . . . . . . . .  44\n         4.2.12.4.  PAC-Info
    . . . . . . . . . . . . . . . . . . . .  45\n         4.2.12.5.  PAC-Acknowledgement
    TLV  . . . . . . . . . . . .  47\n         4.2.12.6.  PAC-Type TLV . . . . . .
    . . . . . . . . . . . .  48\n       4.2.13. Crypto-Binding TLV  . . . . . . .
    . . . . . . . . . .  48\n       4.2.14. Basic-Password-Auth-Req TLV . . . . .
    . . . . . . . .  51\n       4.2.15. Basic-Password-Auth-Resp TLV  . . . . . .
    . . . . . .  52\n       4.2.16. PKCS#7 TLV  . . . . . . . . . . . . . . . . .
    . . . .  53\n       4.2.17. PKCS#10 TLV . . . . . . . . . . . . . . . . . . .
    . .  54\n       4.2.18. Trusted-Server-Root TLV . . . . . . . . . . . . . . .
    \ 55\n     4.3.  TLV Rules . . . . . . . . . . . . . . . . . . . . . . . .  56\n
    \      4.3.1.  Outer TLVs  . . . . . . . . . . . . . . . . . . . . .  57\n       4.3.2.
    \ Inner TLVs  . . . . . . . . . . . . . . . . . . . . .  57\n   5.  Cryptographic
    Calculations  . . . . . . . . . . . . . . . . .  58\n     5.1.  TEAP Authentication
    Phase 1: Key Derivations  . . . . . .  58\n     5.2.  Intermediate Compound Key
    Derivations . . . . . . . . . .  59\n     5.3.  Computing the Compound MAC  .
    . . . . . . . . . . . . . .  61\n     5.4.  EAP Master Session Key Generation
    . . . . . . . . . . . .  61\n   6.  IANA Considerations . . . . . . . . . . .
    . . . . . . . . . .  62\n   7.  Security Considerations . . . . . . . . . . .
    . . . . . . . .  66\n     7.1.  Mutual Authentication and Integrity Protection
    \ . . . . .  67\n     7.2.  Method Negotiation  . . . . . . . . . . . . . . .
    . . . .  67\n     7.3.  Separation of Phase 1 and Phase 2 Servers . . . . . .
    . .  67\n     7.4.  Mitigation of Known Vulnerabilities and Protocol\n           Deficiencies
    \ . . . . . . . . . . . . . . . . . . . . . .  68\n       7.4.1.  User Identity
    Protection and Verification . . . . . .  69\n       7.4.2.  Dictionary Attack
    Resistance  . . . . . . . . . . . .  70\n       7.4.3.  Protection against Man-in-the-Middle
    Attacks  . . . .  70\n       7.4.4.  PAC Binding to User Identity  . . . . . .
    . . . . . .  71\n     7.5.  Protecting against Forged Cleartext EAP Packets .
    . . . .  71\n     7.6.  Server Certificate Validation . . . . . . . . . . . .
    . .  72\n     7.7.  Tunnel PAC Considerations . . . . . . . . . . . . . . . .
    \ 72\n     7.8.  Security Claims . . . . . . . . . . . . . . . . . . . . .  73\n
    \  8.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  74\n   9.
    \ References  . . . . . . . . . . . . . . . . . . . . . . . . .  75\n     9.1.
    \ Normative References  . . . . . . . . . . . . . . . . . .  75\n     9.2.  Informative
    References  . . . . . . . . . . . . . . . . .  76\n   Appendix A.  Evaluation
    against Tunnel-Based EAP Method\n                Requirements . . . . . . . .
    . . . . . . . . . . . .  79\n     A.1.  Requirement 4.1.1: RFC Compliance . .
    . . . . . . . . . .  79\n     A.2.  Requirement 4.2.1: TLS Requirements . . .
    . . . . . . . .  79\n     A.3.  Requirement 4.2.1.1.1: Ciphersuite Negotiation
    \ . . . . .  79\n     A.4.  Requirement 4.2.1.1.2: Tunnel Data Protection Algorithms
    \  79\n     A.5.  Requirement 4.2.1.1.3: Tunnel Authentication and Key\n           Establishment
    . . . . . . . . . . . . . . . . . . . . . .  79\n     A.6.  Requirement 4.2.1.2:
    Tunnel Replay Protection . . . . . .  79\n     A.7.  Requirement 4.2.1.3: TLS
    Extensions . . . . . . . . . . .  80\n     A.8.  Requirement 4.2.1.4: Peer Identity
    Privacy  . . . . . . .  80\n     A.9.  Requirement 4.2.1.5: Session Resumption
    . . . . . . . . .  80\n     A.10. Requirement 4.2.2: Fragmentation  . . . . .
    . . . . . . .  80\n     A.11. Requirement 4.2.3: Protection of Data External to
    Tunnel   80\n     A.12. Requirement 4.3.1: Extensible Attribute Types . . . .
    . .  80\n     A.13. Requirement 4.3.2: Request/Challenge Response Operation .
    \ 80\n     A.14. Requirement 4.3.3: Indicating Criticality of Attributes .  80\n
    \    A.15. Requirement 4.3.4: Vendor-Specific Support  . . . . . . .  81\n     A.16.
    Requirement 4.3.5: Result Indication  . . . . . . . . . .  81\n     A.17. Requirement
    4.3.6: Internationalization of Display\n           Strings . . . . . . . . . .
    . . . . . . . . . . . . . . .  81\n     A.18. Requirement 4.4: EAP Channel-Binding
    Requirements . . . .  81\n     A.19. Requirement 4.5.1.1: Confidentiality and
    Integrity  . . .  81\n     A.20. Requirement 4.5.1.2: Authentication of Server
    . . . . . .  81\n     A.21. Requirement 4.5.1.3: Server Certificate Revocation\n
    \          Checking  . . . . . . . . . . . . . . . . . . . . . . . .  81\n     A.22.
    Requirement 4.5.2: Internationalization . . . . . . . . .  81\n     A.23. Requirement
    4.5.3: Metadata . . . . . . . . . . . . . . .  82\n     A.24. Requirement 4.5.4:
    Password Change  . . . . . . . . . . .  82\n     A.25. Requirement 4.6.1: Method
    Negotiation . . . . . . . . . .  82\n     A.26. Requirement 4.6.2: Chained Methods
    \ . . . . . . . . . . .  82\n     A.27. Requirement 4.6.3: Cryptographic Binding
    with the TLS\n           Tunnel  . . . . . . . . . . . . . . . . . . . . . . .
    . .  82\n     A.28. Requirement 4.6.4: Peer-Initiated EAP Authentication  . .
    \ 82\n     A.29. Requirement 4.6.5: Method Metadata  . . . . . . . . . . .  82\n
    \  Appendix B.  Major Differences from EAP-FAST  . . . . . . . . . .  83\n   Appendix
    C.  Examples . . . . . . . . . . . . . . . . . . . . . .  83\n     C.1.  Successful
    Authentication . . . . . . . . . . . . . . . .  83\n     C.2.  Failed Authentication
    . . . . . . . . . . . . . . . . . .  85\n     C.3.  Full TLS Handshake Using Certificate-Based
    Ciphersuite  .  86\n     C.4.  Client Authentication during Phase 1 with Identity\n
    \          Privacy . . . . . . . . . . . . . . . . . . . . . . . . .  88\n     C.5.
    \ Fragmentation and Reassembly  . . . . . . . . . . . . . .  89\n     C.6.  Sequence
    of EAP Methods . . . . . . . . . . . . . . . . .  91\n     C.7.  Failed Crypto-Binding
    . . . . . . . . . . . . . . . . . .  94\n     C.8.  Sequence of EAP Method with
    Vendor-Specific TLV Exchange   95\n     C.9.  Peer Requests Inner Method after
    Server Sends Result TLV   97\n     C.10. Channel Binding . . . . . . . . . . .
    . . . . . . . . . .  99\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   A tunnel-based Extensible Authentication Protocol (EAP)
    method is an\n   EAP method that establishes a secure tunnel and executes other
    EAP\n   methods under the protection of that secure tunnel.  A tunnel-based\n
    \  EAP method can be used in any lower-layer protocol that supports EAP\n   authentication.
    \ There are several existing tunnel-based EAP methods\n   that use Transport Layer
    Security (TLS) [RFC5246] to establish the\n   secure tunnel.  EAP methods supporting
    this include Protected EAP\n   (PEAP) [PEAP], EAP Tunneled Transport Layer Security
    (EAP-TTLS)\n   [RFC5281], and EAP Flexible Authentication via Secure Tunneling
    (EAP-\n   FAST) [RFC4851].  However, they all are either vendor-specific or\n
    \  informational, and the industry calls for a Standards Track tunnel-\n   based
    EAP method.  [RFC6678] outlines the list of requirements for a\n   standard tunnel-based
    EAP method.\n   Since its introduction, EAP-FAST [RFC4851] has been widely adopted
    in\n   a variety of devices and platforms.  It has been adopted by the EMU\n   working
    group as the basis for the standard tunnel-based EAP method.\n   This document
    describes the Tunnel Extensible Authentication Protocol\n   (TEAP) version 1,
    based on EAP-FAST [RFC4851] with some minor changes\n   to meet the requirements
    outlined in [RFC6678] for a standard tunnel-\n   based EAP method.\n"
  - contents:
    - "1.1.  Specification Requirements\n   The key words \"MUST\", \"MUST NOT\",
      \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
      \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be
      interpreted as described in\n   [RFC2119].\n"
    title: 1.1.  Specification Requirements
  - contents:
    - "1.2.  Terminology\n   Much of the terminology in this document comes from [RFC3748].\n
      \  Additional terms are defined below:\n   Protected Access Credential (PAC)\n
      \     Credentials distributed to a peer for future optimized network\n      authentication.
      \ The PAC consists of a minimum of two components:\n      a shared secret and
      an opaque element.  The shared secret\n      component contains the pre-shared
      key between the peer and the\n      authentication server.  The opaque part
      is provided to the peer\n      and is presented to the authentication server
      when the peer wishes\n      to obtain access to network resources.  The opaque
      element and\n      shared secret are used with TLS stateless session resumption\n
      \     defined in [RFC5077] to establish a protected TLS session.  The\n      secret
      key and opaque part may be distributed using [RFC5077]\n      messages or using
      TLVs within the TEAP tunnel.  Finally, a PAC may\n      optionally include other
      information that may be useful to the\n      peer.\n   Type-Length-Value (TLV)\n
      \     The TEAP protocol utilizes objects in TLV format.  The TLV format\n      is
      defined in Section 4.2.\n"
    title: 1.2.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Protocol Overview\n   TEAP authentication occurs in two phases after the
    initial EAP\n   Identity request/response exchange.  In the first phase, TEAP
    employs\n   the TLS [RFC5246] handshake to provide an authenticated key exchange\n
    \  and to establish a protected tunnel.  Once the tunnel is established,\n   the
    second phase begins with the peer and server engaging in further\n   conversations
    to establish the required authentication and\n   authorization policies.  TEAP
    makes use of TLV objects to carry out\n   the inner authentication, results, and
    other information, such as\n   channel-binding information.\n   TEAP makes use
    of the TLS SessionTicket extension [RFC5077], which\n   supports TLS session resumption
    without requiring session-specific\n   state stored at the server.  In this document,
    the SessionTicket is\n   referred to as the Protected Access Credential opaque
    data (or PAC-\n   Opaque).  The PAC-Opaque may be distributed through the use
    of the\n   NewSessionTicket message or through a mechanism that uses TLVs within\n
    \  Phase 2 of TEAP.  The secret key used to resume the session in TEAP\n   is
    referred to as the Protected Access Credential key (or PAC-Key).\n   When the
    NewSessionTicket message is used to distribute the PAC-\n   Opaque, the PAC-Key
    is the master secret for the session.  If TEAP\n   Phase 2 is used to distribute
    the PAC-Opaque, then the PAC-Key is\n   distributed along with the PAC-Opaque.
    \ TEAP implementations MUST\n   support the [RFC5077] mechanism for distributing
    a PAC-Opaque, and it\n   is RECOMMENDED that implementations support the capability
    to\n   distribute the ticket and secret key within the TEAP tunnel.\n   The TEAP
    conversation is used to establish or resume an existing\n   session to typically
    establish network connectivity between a peer\n   and the network.  Upon successful
    execution of TEAP, the EAP peer and\n   EAP server both derive strong session
    key material that can then be\n   communicated to the network access server (NAS)
    for use in\n   establishing a link-layer security association.\n"
  - contents:
    - "2.1.  Architectural Model\n   The network architectural model for TEAP usage
      is shown below:\n    +----------+      +----------+      +----------+      +----------+\n
      \   |          |      |          |      |          |      |  Inner   |\n    |
      \  Peer   |<---->|  Authen- |<---->|   TEAP   |<---->|  Method  |\n    |          |
      \     |  ticator |      |  server  |      |  server  |\n    |          |      |
      \         |      |          |      |          |\n    +----------+      +----------+
      \     +----------+      +----------+\n                         TEAP Architectural
      Model\n   The entities depicted above are logical entities and may or may not\n
      \  correspond to separate network components.  For example, the TEAP\n   server
      and inner method server might be a single entity; the\n   authenticator and
      TEAP server might be a single entity; or the\n   functions of the authenticator,
      TEAP server, and inner method server\n   might be combined into a single physical
      device.  For example,\n   typical IEEE 802.11 deployments place the authenticator
      in an access\n   point (AP) while a RADIUS server may provide the TEAP and inner\n
      \  method server components.  The above diagram illustrates the division\n   of
      labor among entities in a general manner and shows how a\n   distributed system
      might be constructed; however, actual systems\n   might be realized more simply.
      \ The security considerations in\n   Section 7.3 provide an additional discussion
      of the implications of\n   separating the TEAP server from the inner method
      server.\n"
    title: 2.1.  Architectural Model
  - contents:
    - "2.2.  Protocol-Layering Model\n   TEAP packets are encapsulated within EAP;
      EAP in turn requires a\n   transport protocol.  TEAP packets encapsulate TLS,
      which is then used\n   to encapsulate user authentication information.  Thus,
      TEAP messaging\n   can be described using a layered model, where each layer
      encapsulates\n   the layer above it.  The following diagram clarifies the relationship\n
      \  between protocols:\n    +---------------------------------------------------------------+\n
      \   |       Inner EAP Method     |     Other TLV information        |\n    |---------------------------------------------------------------|\n
      \   |                 TLV Encapsulation (TLVs)                      |\n    |---------------------------------------------------------------|\n
      \   |                TLS         |     Optional Outer TLVs          |\n    |---------------------------------------------------------------|\n
      \   |                         TEAP                                  |\n    |---------------------------------------------------------------|\n
      \   |                         EAP                                   |\n    |---------------------------------------------------------------|\n
      \   |    Carrier Protocol (EAP over LAN, RADIUS, Diameter, etc.)    |\n    +---------------------------------------------------------------+\n
      \                         Protocol-Layering Model\n   The TLV layer is a payload
      with TLV objects as defined in\n   Section 4.2.  The TLV objects are used to
      carry arbitrary parameters\n   between an EAP peer and an EAP server.  All conversations
      in the TEAP\n   protected tunnel are encapsulated in a TLV layer.\n   TEAP packets
      may include TLVs both inside and outside the TLS tunnel.\n   The term \"Outer
      TLVs\" is used to refer to optional TLVs outside the\n   TLS tunnel, which are
      only allowed in the first two messages in the\n   TEAP protocol.  That is the
      first EAP-server-to-peer message and\n   first peer-to-EAP-server message.  If
      the message is fragmented, the\n   whole set of messages is counted as one message.
      \ The term \"Inner\n   TLVs\" is used to refer to TLVs sent within the TLS tunnel.
      \ In TEAP\n   Phase 1, Outer TLVs are used to help establish the TLS tunnel,
      but no\n   Inner TLVs are used.  In Phase 2 of the TEAP conversation, TLS\n
      \  records may encapsulate zero or more Inner TLVs, but no Outer TLVs.\n   Methods
      for encapsulating EAP within carrier protocols are already\n   defined.  For
      example, IEEE 802.1X [IEEE.802-1X.2013] may be used to\n   transport EAP between
      the peer and the authenticator; RADIUS\n   [RFC3579] or Diameter [RFC4072] may
      be used to transport EAP between\n   the authenticator and the EAP server.\n"
    title: 2.2.  Protocol-Layering Model
  title: 2.  Protocol Overview
- contents:
  - "3.  TEAP Protocol\n   The operation of the protocol, including Phase 1 and Phase
    2, is the\n   topic of this section.  The format of TEAP messages is given in\n
    \  Section 4, and the cryptographic calculations are given in Section 5.\n"
  - contents:
    - "3.1.  Version Negotiation\n   TEAP packets contain a 3-bit Version field, following
      the TLS Flags\n   field, which enables future TEAP implementations to be backward\n
      \  compatible with previous versions of the protocol.  This\n   specification
      documents the TEAP version 1 protocol; implementations\n   of this specification
      MUST use a Version field set to 1.\n   Version negotiation proceeds as follows:\n
      \  1.   In the first EAP-Request sent with EAP type=TEAP, the EAP server\n        MUST
      set the Version field to the highest version it supports.\n   2a.  If the EAP
      peer supports this version of the protocol, it\n        responds with an EAP-Response
      of EAP type=TEAP, including the\n        version number proposed by the TEAP
      server.\n   2b.  If the TEAP peer does not support the proposed version but\n
      \       supports a lower version, it responds with an EAP-Response of\n        EAP
      type=TEAP and sets the Version field to its highest\n        supported version.\n
      \  2c.  If the TEAP peer only supports versions higher than the version\n        proposed
      by the TEAP server, then use of TEAP will not be\n        possible.  In this
      case, the TEAP peer sends back an EAP-Nak\n        either to negotiate a different
      EAP type or to indicate no other\n        EAP types are available.\n   3a.  If
      the TEAP server does not support the version number proposed\n        by the
      TEAP peer, it MUST either terminate the conversation with\n        an EAP Failure
      or negotiate a new EAP type.\n   3b.  If the TEAP server does support the version
      proposed by the TEAP\n        peer, then the conversation continues using the
      version proposed\n        by the TEAP peer.\n   The version negotiation procedure
      guarantees that the TEAP peer and\n   server will agree to the latest version
      supported by both parties.\n   If version negotiation fails, then use of TEAP
      will not be possible,\n   and another mutually acceptable EAP method will need
      to be negotiated\n   if authentication is to proceed.\n   The TEAP version is
      not protected by TLS and hence can be modified in\n   transit.  In order to
      detect a modification of the TEAP version, the\n   peers MUST exchange the TEAP
      version number received during version\n   negotiation using the Crypto-Binding
      TLV described in Section 4.2.13.\n   The receiver of the Crypto-Binding TLV
      MUST verify that the version\n   received in the Crypto-Binding TLV matches
      the version sent by the\n   receiver in the TEAP version negotiation.  If the
      Crypto-Binding TLV\n   fails to be validated, then it is a fatal error and is
      handled as\n   described in Section 3.6.3.\n"
    title: 3.1.  Version Negotiation
  - contents:
    - "3.2.  TEAP Authentication Phase 1: Tunnel Establishment\n   TEAP relies on
      the TLS handshake [RFC5246] to establish an\n   authenticated and protected
      tunnel.  The TLS version offered by the\n   peer and server MUST be TLS version
      1.2 [RFC5246] or later.  This\n   version of the TEAP implementation MUST support
      the following TLS\n   ciphersuites:\n      TLS_RSA_WITH_AES_128_CBC_SHA [RFC5246]\n
      \     TLS_DHE_RSA_WITH_AES_128_CBC_SHA [RFC5246]\n   This version of the TEAP
      implementation SHOULD support the following\n   TLS ciphersuite:\n      TLS_RSA_WITH_AES_256_CBC_SHA
      [RFC5246]\n   Other ciphersuites MAY be supported.  It is REQUIRED that anonymous\n
      \  ciphersuites such as TLS_DH_anon_WITH_AES_128_CBC_SHA [RFC5246] only\n   be
      used in the case when the inner authentication method provides\n   mutual authentication,
      key generation, and resistance to man-in-the-\n   middle and dictionary attacks.
      \ TLS ciphersuites that do not provide\n   confidentiality MUST NOT be used.
      \ During the TEAP Phase 1\n   conversation, the TEAP endpoints MAY negotiate
      TLS compression.\n   During TLS tunnel establishment, TLS extensions MAY be
      used.  For\n   instance, the Certificate Status Request extension [RFC6066]
      and the\n   Multiple Certificate Status Request extension [RFC6961] can be used\n
      \  to leverage a certificate-status protocol such as Online Certificate\n   Status
      Protocol (OCSP) [RFC6960] to check the validity of server\n   certificates.
      \ TLS renegotiation indications defined in RFC 5746\n   [RFC5746] MUST be supported.\n
      \  The EAP server initiates the TEAP conversation with an EAP request\n   containing
      a TEAP/Start packet.  This packet includes a set Start (S)\n   bit, the TEAP
      version as specified in Section 3.1, and an authority\n   identity TLV.  The
      TLS payload in the initial packet is empty.  The\n   authority identity TLV
      (Authority-ID TLV) is used to provide the peer\n   a hint of the server's identity
      that may be useful in helping the\n   peer select the appropriate credential
      to use.  Assuming that the\n   peer supports TEAP, the conversation continues
      with the peer sending\n   an EAP-Response packet with EAP type of TEAP with
      the Start (S) bit\n   clear and the version as specified in Section 3.1.  This
      message\n   encapsulates one or more TLS handshake messages.  If the TEAP version\n
      \  negotiation is successful, then the TEAP conversation continues until\n   the
      EAP server and EAP peer are ready to enter Phase 2.  When the\n   full TLS handshake
      is performed, then the first payload of TEAP Phase\n   2 MAY be sent along with
      a server-finished handshake message to\n   reduce the number of round trips.\n
      \  TEAP implementations MUST support mutual peer authentication during\n   tunnel
      establishment using the TLS ciphersuites specified in this\n   section.  The
      TEAP peer does not need to authenticate as part of the\n   TLS exchange but
      can alternatively be authenticated through\n   additional exchanges carried
      out in Phase 2.\n   The TEAP tunnel protects peer identity information exchanged
      during\n   Phase 2 from disclosure outside the tunnel.  Implementations that\n
      \  wish to provide identity privacy for the peer identity need to\n   carefully
      consider what information is disclosed outside the tunnel\n   prior to Phase
      2.  TEAP implementations SHOULD support the immediate\n   renegotiation of a
      TLS session to initiate a new handshake message\n   exchange under the protection
      of the current ciphersuite.  This\n   allows support for protection of the peer's
      identity when using TLS\n   client authentication.  An example of the exchanges
      using TLS\n   renegotiation to protect privacy is shown in Appendix C.\n   The
      following sections describe resuming a TLS session based on\n   server-side
      or client-side state.\n"
    - contents:
      - "3.2.1.  TLS Session Resume Using Server State\n   TEAP session resumption
        is achieved in the same manner TLS achieves\n   session resume.  To support
        session resumption, the server and peer\n   minimally cache the Session ID,
        master secret, and ciphersuite.  The\n   peer attempts to resume a session
        by including a valid Session ID\n   from a previous TLS handshake in its ClientHello
        message.  If the\n   server finds a match for the Session ID and is willing
        to establish a\n   new connection using the specified session state, the server
        will\n   respond with the same Session ID and proceed with the TEAP Phase
        1\n   tunnel establishment based on a TLS abbreviated handshake.  After a\n
        \  successful conclusion of the TEAP Phase 1 conversation, the\n   conversation
        then continues on to Phase 2.\n"
      title: 3.2.1.  TLS Session Resume Using Server State
    - contents:
      - "3.2.2.  TLS Session Resume Using a PAC\n   TEAP supports the resumption of
        sessions based on server state being\n   stored on the client side using the
        TLS SessionTicket extension\n   techniques described in [RFC5077].  This version
        of TEAP supports the\n   provisioning of a ticket called a Protected Access
        Credential (PAC)\n   through the use of the NewSessionTicket handshake described
        in\n   [RFC5077], as well as provisioning of a PAC inside the protected\n
        \  tunnel.  Implementations MUST support the TLS Ticket extension\n   [RFC5077]
        mechanism for distributing a PAC and may provide additional\n   ways to provision
        the PAC, such as manual configuration.  Since the\n   PAC mentioned here is
        used for establishing the TLS tunnel, it is\n   more specifically referred
        to as the Tunnel PAC.  The Tunnel PAC is a\n   security credential provided
        by the EAP server to a peer and\n   comprised of:\n   1.  PAC-Key: this is
        the key used by the peer as the TLS master\n       secret to establish the
        TEAP Phase 1 tunnel.  The PAC-Key is a\n       strong, high-entropy, at minimum
        48-octet key and is typically\n       the master secret from a previous TLS
        session.  The PAC-Key is a\n       secret and MUST be treated accordingly.
        \ Otherwise, if leaked, it\n       could lead to user credentials being compromised
        if sent within\n       the tunnel established using the PAC-Key.  In the case
        that a\n       PAC-Key is provisioned to the peer through another means, it
        MUST\n       have its confidentiality and integrity protected by a mechanism,\n
        \      such as the TEAP Phase 2 tunnel.  The PAC-Key MUST be stored\n       securely
        by the peer.\n   2.  PAC-Opaque: this is a variable-length field containing
        the ticket\n       that is sent to the EAP server during the TEAP Phase 1
        tunnel\n       establishment based on [RFC5077].  The PAC-Opaque can only
        be\n       interpreted by the EAP server to recover the required information\n
        \      for the server to validate the peer's identity and\n       authentication.
        \ The PAC-Opaque includes the PAC-Key and other\n       TLS session parameters.
        \ It may contain the PAC's peer identity.\n       The PAC-Opaque format and
        contents are specific to the PAC\n       issuing server.  The PAC-Opaque may
        be presented in the clear, so\n       an attacker MUST NOT be able to gain
        useful information from the\n       PAC-Opaque itself.  The server issuing
        the PAC-Opaque needs to\n       ensure it is protected with strong cryptographic
        keys and\n       algorithms.  The PAC-Opaque may be distributed using the\n
        \      NewSessionTicket message defined in [RFC5077], or it may be\n       distributed
        through another mechanism such as the Phase 2 TLVs\n       defined in this
        document.\n   3.  PAC-Info: this is an optional variable-length field used
        to\n       provide, at a minimum, the authority identity of the PAC issuer.\n
        \      Other useful but not mandatory information, such as the PAC-Key\n       lifetime,
        may also be conveyed by the PAC-issuing server to the\n       peer during
        PAC provisioning or refreshment.  PAC-Info is not\n       included if the
        NewSessionTicket message is used to provision the\n       PAC.\n   The use
        of the PAC is based on the SessionTicket extension defined in\n   [RFC5077].
        \ The EAP server initiates the TEAP conversation as normal.\n   Upon receiving
        the Authority-ID TLV from the server, the peer checks\n   to see if it has
        an existing valid PAC-Key and PAC-Opaque for the\n   server.  If it does,
        then it obtains the PAC-Opaque and puts it in\n   the SessionTicket extension
        in the ClientHello.  It is RECOMMENDED in\n   TEAP that the peer include an
        empty Session ID in a ClientHello\n   containing a PAC-Opaque.  This version
        of TEAP supports the\n   NewSessionTicket Handshake message as described in
        [RFC5077] for\n   distribution of a new PAC, as well as the provisioning of
        PAC inside\n   the protected tunnel.  If the PAC-Opaque included in the\n
        \  SessionTicket extension is valid and the EAP server permits the\n   abbreviated
        TLS handshake, it will select the ciphersuite from\n   information within
        the PAC-Opaque and finish with the abbreviated TLS\n   handshake.  If the
        server receives a Session ID and a PAC-Opaque in\n   the SessionTicket extension
        in a ClientHello, it should place the\n   same Session ID in the ServerHello
        if it is resuming a session based\n   on the PAC-Opaque.  The conversation
        then proceeds as described in\n   [RFC5077] until the handshake completes
        or a fatal error occurs.\n   After the abbreviated handshake completes, the
        peer and the server\n   are ready to commence Phase 2.\n"
      title: 3.2.2.  TLS Session Resume Using a PAC
    - contents:
      - "3.2.3.  Transition between Abbreviated and Full TLS Handshake\n   If session
        resumption based on server-side or client-side state\n   fails, the server
        can gracefully fall back to a full TLS handshake.\n   If the ServerHello received
        by the peer contains an empty Session ID\n   or a Session ID that is different
        than in the ClientHello, the server\n   may fall back to a full handshake.
        \ The peer can distinguish the\n   server's intent to negotiate a full or
        abbreviated TLS handshake by\n   checking the next TLS handshake messages
        in the server response to\n   the ClientHello.  If ChangeCipherSpec follows
        the ServerHello in\n   response to the ClientHello, then the server has accepted
        the session\n   resumption and intends to negotiate the abbreviated handshake.\n
        \  Otherwise, the server intends to negotiate the full TLS handshake.  A\n
        \  peer can request that a new PAC be provisioned after the full TLS\n   handshake
        and mutual authentication of the peer and the server.  A\n   peer SHOULD NOT
        request that a new PAC be provisioned after the\n   abbreviated handshake,
        as requesting a new session ticket based on\n   resumed session is not permitted.
        \ In order to facilitate the\n   fallback to a full handshake, the peer SHOULD
        include ciphersuites\n   that allow for a full handshake and possibly PAC
        provisioning so the\n   server can select one of these in case session resumption
        fails.  An\n   example of the transition is shown in Appendix C.\n"
      title: 3.2.3.  Transition between Abbreviated and Full TLS Handshake
    title: '3.2.  TEAP Authentication Phase 1: Tunnel Establishment'
  - contents:
    - "3.3.  TEAP Authentication Phase 2: Tunneled Authentication\n   The second portion
      of the TEAP authentication occurs immediately\n   after successful completion
      of Phase 1.  Phase 2 occurs even if both\n   peer and authenticator are authenticated
      in the Phase 1 TLS\n   negotiation.  Phase 2 MUST NOT occur if the Phase 1 TLS
      handshake\n   fails, as that will compromise the security as the tunnel has
      not\n   been established successfully.  Phase 2 consists of a series of\n   requests
      and responses encapsulated in TLV objects defined in\n   Section 4.2.  Phase
      2 MUST always end with a Crypto-Binding TLV\n   exchange described in Section
      4.2.13 and a protected termination\n   exchange described in Section 3.3.3.
      \ The TLV exchange may include\n   the execution of zero or more EAP methods
      within the protected tunnel\n   as described in Section 3.3.1.  A server MAY
      proceed directly to the\n   protected termination exchange if it does not wish
      to request further\n   authentication from the peer.  However, the peer and
      server MUST NOT\n   assume that either will skip inner EAP methods or other
      TLV\n   exchanges, as the other peer might have a different security policy.\n
      \  The peer may have roamed to a network that requires conformance with\n   a
      different authentication policy, or the peer may request the server\n   take
      additional action (e.g., channel binding) through the use of the\n   Request-Action
      TLV as defined in Section 4.2.9.\n"
    - contents:
      - "3.3.1.  EAP Sequences\n   EAP [RFC3748] prohibits use of multiple authentication
        methods within\n   a single EAP conversation in order to limit vulnerabilities
        to man-\n   in-the-middle attacks.  TEAP addresses man-in-the-middle attacks\n
        \  through support for cryptographic protection of the inner EAP\n   exchange
        and cryptographic binding of the inner authentication\n   method(s) to the
        protected tunnel.  EAP methods are executed serially\n   in a sequence.  This
        version of TEAP does not support initiating\n   multiple EAP methods simultaneously
        in parallel.  The methods need\n   not be distinct.  For example, EAP-TLS
        could be run twice as an inner\n   method, first using machine credentials
        followed by a second instance\n   using user credentials.\n   EAP method messages
        are carried within EAP-Payload TLVs defined in\n   Section 4.2.10.  If more
        than one method is going to be executed in\n   the tunnel, then upon method
        completion, the server MUST send an\n   Intermediate-Result TLV indicating
        the result.  The peer MUST respond\n   to the Intermediate-Result TLV indicating
        its result.  If the result\n   indicates success, the Intermediate-Result
        TLV MUST be accompanied by\n   a Crypto-Binding TLV.  The Crypto-Binding TLV
        is further discussed in\n   Sections 4.2.13 and 5.3.  The Intermediate-Result
        TLVs can be\n   included with other TLVs such as EAP-Payload TLVs starting
        a new EAP\n   conversation or with the Result TLV used in the protected termination\n
        \  exchange.\n   If both peer and server indicate success, then the method
        is\n   considered complete.  If either indicates failure, then the method
        is\n   considered failed.  The result of failure of an EAP method does not\n
        \  always imply a failure of the overall authentication.  If one\n   authentication
        method fails, the server may attempt to authenticate\n   the peer with a different
        method.\n"
      title: 3.3.1.  EAP Sequences
    - contents:
      - "3.3.2.  Optional Password Authentication\n   The use of EAP-FAST-GTC as defined
        in RFC 5421 [RFC5421] is NOT\n   RECOMMENDED with TEAPv1 because EAP-FAST-GTC
        is not compliant with\n   EAP-GTC defined in [RFC3748].  Implementations should
        instead make\n   use of the password authentication TLVs defined in this\n
        \  specification.  The authentication server initiates password\n   authentication
        by sending a Basic-Password-Auth-Req TLV defined in\n   Section 4.2.14.  If
        the peer wishes to participate in password\n   authentication, then it responds
        with a Basic-Password-Auth-Resp TLV\n   as defined in Section 4.2.15 that
        contains the username and password.\n   If it does not wish to perform password
        authentication, then it\n   responds with a NAK TLV indicating the rejection
        of the Basic-\n   Password-Auth-Req TLV.  Upon receiving the response, the
        server\n   indicates the success or failure of the exchange using an\n   Intermediate-Result
        TLV.  Multiple round trips of password\n   authentication requests and responses
        MAY be used to support some\n   \"housecleaning\" functions such as a password
        or pin change before a\n   user is authenticated.\n"
      title: 3.3.2.  Optional Password Authentication
    - contents:
      - "3.3.3.  Protected Termination and Acknowledged Result Indication\n   A successful
        TEAP Phase 2 conversation MUST always end in a\n   successful Crypto-Binding
        TLV and Result TLV exchange.  A TEAP server\n   may initiate the Crypto-Binding
        TLV and Result TLV exchange without\n   initiating any EAP conversation in
        TEAP Phase 2.  After the final\n   Result TLV exchange, the TLS tunnel is
        terminated, and a cleartext\n   EAP Success or EAP Failure is sent by the
        server.  Peers implementing\n   TEAP MUST NOT accept a cleartext EAP Success
        or failure packet prior\n   to the peer and server reaching synchronized protected
        result\n   indication.\n   The Crypto-Binding TLV exchange is used to prove
        that both the peer\n   and server participated in the tunnel establishment
        and sequence of\n   authentications.  It also provides verification of the
        TEAP type,\n   version negotiated, and Outer TLVs exchanged before the TLS
        tunnel\n   establishment.  The Crypto-Binding TLV MUST be exchanged and verified\n
        \  before the final Result TLV exchange, regardless of whether or not\n   there
        is an inner EAP method authentication.  The Crypto-Binding TLV\n   and Intermediate-Result
        TLV MUST be included to perform cryptographic\n   binding after each successful
        EAP method in a sequence of one or more\n   EAP methods.  The server may send
        the final Result TLV along with an\n   Intermediate-Result TLV and a Crypto-Binding
        TLV to indicate its\n   intention to end the conversation.  If the peer requires
        nothing more\n   from the server, it will respond with a Result TLV indicating
        success\n   accompanied by a Crypto-Binding TLV and Intermediate-Result TLV
        if\n   necessary.  The server then tears down the tunnel and sends a\n   cleartext
        EAP Success or EAP Failure.\n   If the peer receives a Result TLV indicating
        success from the server,\n   but its authentication policies are not satisfied
        (for example, it\n   requires a particular authentication mechanism be run
        or it wants to\n   request a PAC), it may request further action from the
        server using\n   the Request-Action TLV.  The Request-Action TLV is sent with
        a Status\n   field indicating what EAP Success/Failure result the peer would\n
        \  expect if the requested action is not granted.  The value of the\n   Action
        field indicates what the peer would like to do next.  The\n   format and values
        for the Request-Action TLV are defined in\n   Section 4.2.9.\n   Upon receiving
        the Request-Action TLV, the server may process the\n   request or ignore it,
        based on its policy.  If the server ignores the\n   request, it proceeds with
        termination of the tunnel and sends the\n   cleartext EAP Success or Failure
        message based on the Status field of\n   the peer's Request-Action TLV.  If
        the server honors and processes\n   the request, it continues with the requested
        action.  The\n   conversation completes with a Result TLV exchange.  The Result
        TLV\n   may be included with the TLV that completes the requested action.\n
        \  Error handling for Phase 2 is discussed in Section 3.6.3.\n"
      title: 3.3.3.  Protected Termination and Acknowledged Result Indication
    title: '3.3.  TEAP Authentication Phase 2: Tunneled Authentication'
  - contents:
    - "3.4.  Determining Peer-Id and Server-Id\n   The Peer-Id and Server-Id [RFC5247]
      may be determined based on the\n   types of credentials used during either the
      TEAP tunnel creation or\n   authentication.  In the case of multiple peer authentications,
      all\n   authenticated peer identities and their corresponding identity types\n
      \  (Section 4.2.3) need to be exported.  In the case of multiple server\n   authentications,
      all authenticated server identities need to be\n   exported.\n   When X.509
      certificates are used for peer authentication, the Peer-Id\n   is determined
      by the subject and subjectAltName fields in the peer\n   certificate.  As noted
      in [RFC5280]:\n     The subject field identifies the entity associated with
      the public\n     key stored in the subject public key field.  The subject name
      MAY\n     be carried in the subject field and/or the subjectAltName\n     extension.
      . . . If subject naming information is present only in\n     the subjectAltName
      extension (e.g., a key bound only to an email\n     address or URI), then the
      subject name MUST be an empty sequence\n     and the subjectAltName extension
      MUST be critical.\n     Where it is non-empty, the subject field MUST contain
      an X.500\n     distinguished name (DN).\n   If an inner EAP method is run, then
      the Peer-Id is obtained from the\n   inner method.\n   When the server uses
      an X.509 certificate to establish the TLS\n   tunnel, the Server-Id is determined
      in a similar fashion as stated\n   above for the Peer-Id, e.g., the subject
      and subjectAltName fields in\n   the server certificate define the Server-Id.\n"
    title: 3.4.  Determining Peer-Id and Server-Id
  - contents:
    - "3.5.  TEAP Session Identifier\n   The EAP session identifier [RFC5247] is constructed
      using the tls-\n   unique from the Phase 1 outer tunnel at the beginning of
      Phase 2 as\n   defined by Section 3.1 of [RFC5929].  The Session-Id is defined
      as\n   follows:\n     Session-Id = teap_type || tls-unique\n     where teap_type
      is the EAP Type assigned to TEAP\n     tls-unique = tls-unique from the Phase
      1 outer tunnel at the\n     beginning of Phase 2 as defined by Section 3.1 of
      [RFC5929]\n     || means concatenation\n"
    title: 3.5.  TEAP Session Identifier
  - contents:
    - "3.6.  Error Handling\n   TEAP uses the error-handling rules summarized below:\n
      \  1.  Errors in the outer EAP packet layer are handled as defined in\n       Section
      3.6.1.\n   2.  Errors in the TLS layer are communicated via TLS alert messages\n
      \      in all phases of TEAP.\n   3.  The Intermediate-Result TLVs carry success
      or failure indications\n       of the individual EAP methods in TEAP Phase 2.
      \ Errors within the\n       EAP conversation in Phase 2 are expected to be handled
      by\n       individual EAP methods.\n   4.  Violations of the Inner TLV rules
      are handled using Result TLVs\n       together with Error TLVs.\n   5.  Tunnel-compromised
      errors (errors caused by a failed or missing\n       Crypto-Binding) are handled
      using Result TLVs and Error TLVs.\n"
    - contents:
      - "3.6.1.  Outer-Layer Errors\n   Errors on the TEAP outer-packet layer are
        handled in the following\n   ways:\n   1.  If Outer TLVs are invalid or contain
        unknown values, they will be\n       ignored.\n   2.  The entire TEAP packet
        will be ignored if other fields (version,\n       length, flags, etc.) are
        inconsistent with this specification.\n"
      title: 3.6.1.  Outer-Layer Errors
    - contents:
      - "3.6.2.  TLS Layer Errors\n   If the TEAP server detects an error at any point
        in the TLS handshake\n   or the TLS layer, the server SHOULD send a TEAP request
        encapsulating\n   a TLS record containing the appropriate TLS alert message
        rather than\n   immediately terminating the conversation so as to allow the
        peer to\n   inform the user of the cause of the failure and possibly allow
        for a\n   restart of the conversation.  The peer MUST send a TEAP response
        to\n   an alert message.  The EAP-Response packet sent by the peer may\n   encapsulate
        a TLS ClientHello handshake message, in which case the\n   TEAP server MAY
        allow the TEAP conversation to be restarted, or it\n   MAY contain a TEAP
        response with a zero-length message, in which case\n   the server MUST terminate
        the conversation with an EAP Failure\n   packet.  It is up to the TEAP server
        whether or not to allow\n   restarts, and, if allowed, how many times the
        conversation can be\n   restarted.  Per TLS [RFC5246], TLS restart is only
        allowed for non-\n   fatal alerts.  A TEAP server implementing restart capability
        SHOULD\n   impose a limit on the number of restarts, so as to protect against\n
        \  denial-of-service attacks.  If the TEAP server does not allow\n   restarts,
        it MUST terminate the conversation with an EAP Failure\n   packet.\n   If
        the TEAP peer detects an error at any point in the TLS layer, the\n   TEAP
        peer SHOULD send a TEAP response encapsulating a TLS record\n   containing
        the appropriate TLS alert message.  The server may restart\n   the conversation
        by sending a TEAP request packet encapsulating the\n   TLS HelloRequest handshake
        message.  The peer may allow the TEAP\n   conversation to be restarted, or
        it may terminate the conversation by\n   sending a TEAP response with a zero-length
        message.\n"
      title: 3.6.2.  TLS Layer Errors
    - contents:
      - "3.6.3.  Phase 2 Errors\n   Any time the peer or the server finds a fatal
        error outside of the\n   TLS layer during Phase 2 TLV processing, it MUST
        send a Result TLV of\n   failure and an Error TLV with the appropriate error
        code.  For errors\n   involving the processing of the sequence of exchanges,
        such as a\n   violation of TLV rules (e.g., multiple EAP-Payload TLVs), the
        error\n   code is Unexpected TLVs Exchanged.  For errors involving a tunnel\n
        \  compromise, the error code is Tunnel Compromise Error.  Upon sending\n
        \  a Result TLV with a fatal Error TLV, the sender terminates the TLS\n   tunnel.
        \ Note that a server will still wait for a message from the\n   peer after
        it sends a failure; however, the server does not need to\n   process the contents
        of the response message.\n   For the inner method, retransmission is not needed
        and SHOULD NOT be\n   attempted, as the Outer TLS tunnel can be considered
        a reliable\n   transport.  If there is a non-fatal error handling the inner
        method,\n   instead of silently dropping the inner method request or response
        and\n   not responding, the receiving side SHOULD use an Error TLV with error\n
        \  code Inner Method Error to indicate an error processing the current\n   inner
        method.  The side receiving the Error TLV MAY decide to start a\n   new inner
        method instead or send back a Result TLV to terminate the\n   TEAP authentication
        session.\n   If a server receives a Result TLV of failure with a fatal Error
        TLV,\n   it MUST send a cleartext EAP Failure.  If a peer receives a Result\n
        \  TLV of failure, it MUST respond with a Result TLV indicating failure.\n
        \  If the server has sent a Result TLV of failure, it ignores the peer\n   response,
        and it MUST send a cleartext EAP Failure.\n"
      title: 3.6.3.  Phase 2 Errors
    title: 3.6.  Error Handling
  - contents:
    - "3.7.  Fragmentation\n   A single TLS record may be up to 16384 octets in length,
      but a TLS\n   message may span multiple TLS records, and a TLS certificate message\n
      \  may, in principle, be as long as 16 MB.  This is larger than the\n   maximum
      size for a message on most media types; therefore, it is\n   desirable to support
      fragmentation.  Note that in order to protect\n   against reassembly lockup
      and denial-of-service attacks, it may be\n   desirable for an implementation
      to set a maximum size for one such\n   group of TLS messages.  Since a typical
      certificate chain is rarely\n   longer than a few thousand octets, and no other
      field is likely to be\n   anywhere near as long, a reasonable choice of maximum
      acceptable\n   message length might be 64 KB.  This is still a fairly large
      message\n   packet size so a TEAP implementation MUST provide its own support
      for\n   fragmentation and reassembly.  Section 3.1 of [RFC3748] discusses\n
      \  determining the MTU usable by EAP, and Section 4.3 discusses\n   retransmissions
      in EAP.\n   Since EAP is a lock-step protocol, fragmentation support can be
      added\n   in a simple manner.  In EAP, fragments that are lost or damaged in\n
      \  transit will be retransmitted, and since sequencing information is\n   provided
      by the Identifier field in EAP, there is no need for a\n   fragment offset field.\n
      \  TEAP fragmentation support is provided through the addition of flag\n   bits
      within the EAP-Response and EAP-Request packets, as well as a\n   Message Length
      field of four octets.  Flags include the Length\n   included (L), More fragments
      (M), and TEAP Start (S) bits.  The L\n   flag is set to indicate the presence
      of the four-octet Message Length\n   field and MUST be set for the first fragment
      of a fragmented TLS\n   message or set of messages.  It MUST NOT be present
      for any other\n   message.  The M flag is set on all but the last fragment.
      \ The S flag\n   is set only within the TEAP start message sent from the EAP
      server to\n   the peer.  The Message Length field is four octets and provides
      the\n   total length of the message that may be fragmented over the data\n   fields
      of multiple packets; this simplifies buffer allocation.\n   When a TEAP peer
      receives an EAP-Request packet with the M bit set,\n   it MUST respond with
      an EAP-Response with EAP Type of TEAP and no\n   data.  This serves as a fragment
      ACK.  The EAP server MUST wait until\n   it receives the EAP-Response before
      sending another fragment.  In\n   order to prevent errors in processing of fragments,
      the EAP server\n   MUST increment the Identifier field for each fragment contained\n
      \  within an EAP-Request, and the peer MUST include this Identifier\n   value
      in the fragment ACK contained within the EAP-Response.\n   Retransmitted fragments
      will contain the same Identifier value.\n   Similarly, when the TEAP server
      receives an EAP-Response with the M\n   bit set, it responds with an EAP-Request
      with EAP Type of TEAP and no\n   data.  This serves as a fragment ACK.  The
      EAP peer MUST wait until\n   it receives the EAP-Request before sending another
      fragment.  In\n   order to prevent errors in the processing of fragments, the
      EAP\n   server MUST increment the Identifier value for each fragment ACK\n   contained
      within an EAP-Request, and the peer MUST include this\n   Identifier value in
      the subsequent fragment contained within an EAP-\n   Response.\n"
    title: 3.7.  Fragmentation
  - contents:
    - "3.8.  Peer Services\n   Several TEAP services, including server unauthenticated
      provisioning,\n   PAC provisioning, certificate provisioning, and channel binding,\n
      \  depend on the peer trusting the TEAP server.  Peers MUST authenticate\n   the
      server before these peer services are used.  TEAP peer\n   implementations MUST
      have a configuration where authentication fails\n   if server authentication
      cannot be achieved.  In many cases, the\n   server will want to authenticate
      the peer before providing these\n   services as well.\n   TEAP peers MUST track
      whether or not server authentication has taken\n   place.  Server authentication
      results if the peer trusts the provided\n   server certificate.  Typically,
      this involves both validating the\n   certificate to a trust anchor and confirming
      the entity named by the\n   certificate is the intended server.  Server authentication
      also\n   results when the procedures in Section 3.2 are used to resume a\n   session
      in which the peer and server were previously mutually\n   authenticated.  Alternatively,
      peer services can be used if an inner\n   EAP method providing mutual authentication
      and an Extended Master\n   Session Key (EMSK) is executed and cryptographic
      binding with the\n   EMSK Compound Message Authentication Code (MAC) is correctly\n
      \  validated (Section 4.2.13).  This is further described in\n   Section 3.8.3.\n
      \  An additional complication arises when a tunnel method authenticates\n   multiple
      parties such as authenticating both the peer machine and the\n   peer user to
      the EAP server.  Depending on how authentication is\n   achieved, only some
      of these parties may have confidence in it.  For\n   example, if a strong shared
      secret is used to mutually authenticate\n   the user and the EAP server, the
      machine may not have confidence that\n   the EAP server is the authenticated
      party if the machine cannot trust\n   the user not to disclose the shared secret
      to an attacker.  In these\n   cases, the parties who participate in the authentication
      need to be\n   considered when evaluating whether to use peer services.\n"
    - contents:
      - "3.8.1.  PAC Provisioning\n   To request provisioning of a PAC, a peer sends
        a PAC TLV as defined\n   in Section 4.2.12 containing a PAC Attribute as defined
        in\n   Section 4.2.12.1 of PAC-Type set to the appropriate value.  The peer\n
        \  MUST successfully authenticate the EAP server and validate the\n   Crypto-Binding
        TLV as defined in Section 4.2.13 before issuing the\n   request.  The peer
        MUST send separate PAC TLVs for each type of PAC\n   it wants to be provisioned.
        \ Multiple PAC TLVs can be sent in the\n   same packet or in different packets.
        \ The EAP server will send the\n   PACs after its internal policy has been
        satisfied, or it MAY ignore\n   the request or request additional authentications
        if its policy\n   dictates.  The server MAY cache the request and provision
        the PACs\n   requested after all of its internal policies have been satisfied.
        \ If\n   a peer receives a PAC with an unknown type, it MUST ignore it.\n
        \  A PAC TLV containing a PAC-Acknowledge attribute MUST be sent by the\n
        \  peer to acknowledge the receipt of the Tunnel PAC.  A PAC TLV\n   containing
        a PAC-Acknowledge attribute MUST NOT be used by the peer\n   to acknowledge
        the receipt of other types of PACs.  If the peer\n   receives a PAC TLV with
        an unknown attribute, it SHOULD ignore the\n   unknown attribute.\n"
      title: 3.8.1.  PAC Provisioning
    - contents:
      - "3.8.2.  Certificate Provisioning within the Tunnel\n   Provisioning of a
        peer's certificate is supported in TEAP by\n   performing the Simple PKI Request/Response
        from [RFC5272] using\n   PKCS#10 and PKCS#7 TLVs, respectively.  A peer sends
        the Simple PKI\n   Request using a PKCS#10 CertificateRequest [RFC2986] encoded
        into the\n   body of a PKCS#10 TLV (see Section 4.2.17).  The TEAP server
        issues a\n   Simple PKI Response using a PKCS#7 [RFC2315] degenerate \"Certificates\n
        \  Only\" message encoded into the body of a PKCS#7 TLV (see\n   Section 4.2.16),
        only after an authentication method has run and\n   provided an identity proof
        on the peer prior to a certificate is\n   being issued.\n   In order to provide
        linking identity and proof-of-possession by\n   including information specific
        to the current authenticated TLS\n   session within the signed certification
        request, the peer generating\n   the request SHOULD obtain the tls-unique
        value from the TLS subsystem\n   as defined in \"Channel Bindings for TLS\"
        [RFC5929].  The TEAP peer\n   operations between obtaining the tls_unique
        value through generation\n   of the Certification Signing Request (CSR) that
        contains the current\n   tls_unique value and the subsequent verification
        of this value by the\n   TEAP server are the \"phases of the application protocol
        during which\n   application-layer authentication occurs\" that are protected
        by the\n   synchronization interoperability mechanism described in the\n   interoperability
        note in \"Channel Bindings for TLS\" ([RFC5929],\n   Section 3.1).  When performing
        renegotiation, TLS\n   \"secure_renegotiation\" [RFC5746] MUST be used.\n
        \  The tls-unique value is base-64-encoded as specified in Section 4 of\n
        \  [RFC4648], and the resulting string is placed in the certification\n   request
        challengePassword field ([RFC2985], Section 5.4.1).  The\n   challengePassword
        field is limited to 255 octets (Section 7.4.9 of\n   [RFC5246] indicates that
        no existing ciphersuite would result in an\n   issue with this limitation).
        \ If tls-unique information is not\n   embedded within the certification request,
        the challengePassword\n   field MUST be empty to indicate that the peer did
        not include the\n   optional channel-binding information (any value submitted
        is verified\n   by the server as tls-unique information).\n   The server SHOULD
        verify the tls-unique information.  This ensures\n   that the authenticated
        TEAP peer is in possession of the private key\n   used to sign the certification
        request.\n   The Simple PKI Request/Response generation and processing rules
        of\n   [RFC5272] SHALL apply to TEAP, with the exception of error\n   conditions.
        \ In the event of an error, the TEAP server SHOULD respond\n   with an Error
        TLV using the most descriptive error code possible; it\n   MAY ignore the
        PKCS#10 request that generated the error.\n"
      title: 3.8.2.  Certificate Provisioning within the Tunnel
    - contents:
      - "3.8.3.  Server Unauthenticated Provisioning Mode\n   In Server Unauthenticated
        Provisioning Mode, an unauthenticated\n   tunnel is established in Phase 1,
        and the peer and server negotiate\n   an EAP method in Phase 2 that supports
        mutual authentication and key\n   derivation that is resistant to attacks
        such as man-in-the-middle and\n   dictionary attacks.  This provisioning mode
        enables the bootstrapping\n   of peers when the peer lacks the ability to
        authenticate the server\n   during Phase 1.  This includes both cases in which
        the ciphersuite\n   negotiated does not provide authentication and in which
        the\n   ciphersuite negotiated provides the authentication but the peer is\n
        \  unable to validate the identity of the server for some reason.\n   Upon
        successful completion of the EAP method in Phase 2, the peer and\n   server
        exchange a Crypto-Binding TLV to bind the inner method with\n   the outer
        tunnel and ensure that a man-in-the-middle attack has not\n   been attempted.\n
        \  Support for the Server Unauthenticated Provisioning Mode is optional.\n
        \  The ciphersuite TLS_DH_anon_WITH_AES_128_CBC_SHA is RECOMMENDED when\n
        \  using Server Unauthenticated Provisioning Mode, but other anonymous\n   ciphersuites
        MAY be supported as long as the TLS pre-master secret is\n   generated from
        contribution from both peers.  Phase 2 EAP methods\n   used in Server Unauthenticated
        Provisioning Mode MUST provide mutual\n   authentication, provide key generation,
        and be resistant to\n   dictionary attack.  Example inner methods include
        EAP-pwd [RFC5931]\n   and EAP-EKE [RFC6124].\n"
      title: 3.8.3.  Server Unauthenticated Provisioning Mode
    - contents:
      - "3.8.4.  Channel Binding\n   [RFC6677] defines EAP channel bindings to solve
        the \"lying NAS\" and\n   the \"lying provider\" problems, using a process
        in which the EAP peer\n   gives information about the characteristics of the
        service provided\n   by the authenticator to the Authentication, Authorization,
        and\n   Accounting (AAA) server protected within the EAP method.  This allows\n
        \  the server to verify the authenticator is providing information to\n   the
        peer that is consistent with the information received from this\n   authenticator
        as well as the information stored about this\n   authenticator.\n   TEAP supports
        EAP channel binding using the Channel-Binding TLV\n   defined in Section 4.2.7.
        \ If the TEAP server wants to request the\n   channel-binding information
        from the peer, it sends an empty Channel-\n   Binding TLV to indicate the
        request.  The peer responds to the\n   request by sending a Channel-Binding
        TLV containing a channel-binding\n   message as defined in [RFC6677].  The
        server validates the channel-\n   binding message and sends back a Channel-Binding
        TLV with a result\n   code.  If the server didn't initiate the channel-binding
        request and\n   the peer still wants to send the channel-binding information
        to the\n   server, it can do that by using the Request-Action TLV along with
        the\n   Channel-Binding TLV.  The peer MUST only send channel-binding\n   information
        after it has successfully authenticated the server and\n   established the
        protected tunnel.\n"
      title: 3.8.4.  Channel Binding
    title: 3.8.  Peer Services
  title: 3.  TEAP Protocol
- contents:
  - "4.  Message Formats\n   The following sections describe the message formats used
    in TEAP.\n   The fields are transmitted from left to right in network byte order.\n"
  - contents:
    - "4.1.  TEAP Message Format\n   A summary of the TEAP Request/Response packet
      format is shown below.\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Code      |   Identifier  |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |   Flags | Ver |        Message Length         :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  :         Message Length        |         Outer TLV Length\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  :     Outer TLV Length          |         TLS Data...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |       Outer TLVs...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Code\n      The
      Code field is one octet in length and is defined as follows:\n         1 Request\n
      \        2 Response\n   Identifier\n      The Identifier field is one octet
      and aids in matching responses\n      with requests.  The Identifier field MUST
      be changed on each\n      Request packet.  The Identifier field in the Response
      packet MUST\n      match the Identifier field from the corresponding request.\n
      \  Length\n      The Length field is two octets and indicates the length of
      the EAP\n      packet including the Code, Identifier, Length, Type, Flags, Ver,\n
      \     Message Length, TLS Data, and Outer TLVs fields.  Octets outside\n      the
      range of the Length field should be treated as Data Link Layer\n      padding
      and should be ignored on reception.\n   Type\n      55 for TEAP\n   Flags\n
      \         0 1 2 3 4\n         +-+-+-+-+-+\n         |L M S O R|\n         +-+-+-+-+-+\n
      \     L  Length included; set to indicate the presence of the four-octet\n         Message
      Length field.  It MUST be present for the first\n         fragment of a fragmented
      message.  It MUST NOT be present for\n         any other message.\n      M  More
      fragments; set on all but the last fragment.\n      S  TEAP start; set in a
      TEAP Start message sent from the server to\n         the peer.\n      O  Outer
      TLV length included; set to indicate the presence of the\n         four-octet
      Outer TLV Length field.  It MUST be present only in\n         the initial request
      and response messages.  If the initial\n         message is fragmented, then
      it MUST be present only on the\n         first fragment.\n      R  Reserved
      (MUST be zero and ignored upon receipt)\n   Ver\n      This field contains the
      version of the protocol.  This document\n      describes version 1 (001 in binary)
      of TEAP.\n   Message Length\n      The Message Length field is four octets and
      is present only if the\n      L bit is set.  This field provides the total length
      of the message\n      that may be fragmented over the data fields of multiple
      packets.\n   Outer TLV Length\n      The Outer TLV Length field is four octets
      and is present only if\n      the O bit is set.  This field provides the total
      length of the\n      Outer TLVs if present.\n   TLS Data\n      When the TLS
      Data field is present, it consists of an encapsulated\n      TLS packet in TLS
      record format.  A TEAP packet with Flags and\n      Version fields, but with
      zero length TLS Data field, is used to\n      indicate TEAP acknowledgement
      for either a fragmented message, a\n      TLS Alert message, or a TLS Finished
      message.\n   Outer TLVs\n      The Outer TLVs consist of the optional data used
      to help establish\n      the TLS tunnel in TLV format.  They are only allowed
      in the first\n      two messages in the TEAP protocol.  That is the first EAP-server-\n
      \     to-peer message and first peer-to-EAP-server message.  The start\n      of
      the Outer TLVs can be derived from the EAP Length field and\n      Outer TLV
      Length field.\n"
    title: 4.1.  TEAP Message Format
  - contents:
    - "4.2.  TEAP TLV Format and Support\n   The TLVs defined here are TLV objects.
      \ The TLV objects could be used\n   to carry arbitrary parameters between an
      EAP peer and EAP server\n   within the protected TLS tunnel.\n   The EAP peer
      may not necessarily implement all the TLVs supported by\n   the EAP server.
      \ To allow for interoperability, TLVs are designed to\n   allow an EAP server
      to discover if a TLV is supported by the EAP peer\n   using the NAK TLV.  The
      mandatory bit in a TLV indicates whether\n   support of the TLV is required.
      \ If the peer or server does not\n   support a TLV marked mandatory, then it
      MUST send a NAK TLV in the\n   response, and all the other TLVs in the message
      MUST be ignored.  If\n   an EAP peer or server finds an unsupported TLV that
      is marked as\n   optional, it can ignore the unsupported TLV.  It MUST NOT send
      a NAK\n   TLV for a TLV that is not marked mandatory.  If all TLVs in a message\n
      \  are marked optional and none are understood by the peer, then a NAK\n   TLV
      or Result TLV could be sent to the other side in order to\n   continue the conversation.\n
      \  Note that a peer or server may support a TLV with the mandatory bit\n   set
      but may not understand the contents.  The appropriate response to\n   a supported
      TLV with content that is not understood is defined by the\n   individual TLV
      specification.\n   EAP implementations compliant with this specification MUST
      support\n   TLV exchanges as well as the processing of mandatory/optional\n
      \  settings on the TLV.  Implementations conforming to this\n   specification
      MUST support the following TLVs:\n      Authority-ID TLV\n      Identity-Type
      TLV\n      Result TLV\n      NAK TLV\n      Error TLV\n      Request-Action
      TLV\n      EAP-Payload TLV\n      Intermediate-Result TLV\n      Crypto-Binding
      TLV\n      Basic-Password-Auth-Req TLV\n      Basic-Password-Auth-Resp TLV\n"
    - contents:
      - "4.2.1.  General TLV Format\n   TLVs are defined as described below.  The
        fields are transmitted from\n   left to right.\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|            TLV Type       |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                              Value...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      0  Optional TLV\n      1  Mandatory TLV\n   R\n      Reserved,
        set to zero (0)\n   TLV Type\n      A 14-bit field, denoting the TLV type.
        \ Allocated types include:\n      0  Unassigned\n      1  Authority-ID TLV
        (Section 4.2.2)\n      2  Identity-Type TLV (Section 4.2.3)\n      3  Result
        TLV (Section 4.2.4)\n      4  NAK TLV (Section 4.2.5)\n      5  Error TLV
        (Section 4.2.6)\n      6  Channel-Binding TLV (Section 4.2.7)\n      7  Vendor-Specific
        TLV (Section 4.2.8)\n      8  Request-Action TLV (Section 4.2.9)\n      9
        \ EAP-Payload TLV (Section 4.2.10)\n      10 Intermediate-Result TLV (Section
        4.2.11)\n      11 PAC TLV (Section 4.2.12)\n      12 Crypto-Binding TLV (Section
        4.2.13)\n      13 Basic-Password-Auth-Req TLV (Section 4.2.14)\n      14 Basic-Password-Auth-Resp
        TLV (Section 4.2.15)\n      15 PKCS#7 TLV (Section 4.2.16)\n      16 PKCS#10
        TLV (Section 4.2.17)\n      17 Trusted-Server-Root TLV (Section 4.2.18)\n
        \  Length\n      The length of the Value field in octets.\n   Value\n      The
        value of the TLV.\n"
      title: 4.2.1.  General TLV Format
    - contents:
      - "4.2.2.  Authority-ID TLV\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                              ID...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      Mandatory, set to one (1)\n   R\n      Reserved, set to zero (0)\n
        \  TLV Type\n      1 - Authority-ID\n   Length\n      The Length field is
        two octets and contains the length of the ID\n      field in octets.\n   ID\n
        \     Hint of the identity of the server to help the peer to match the\n      credentials
        available for the server.  It should be unique across\n      the deployment.\n"
      title: 4.2.2.  Authority-ID TLV
    - contents:
      - "4.2.3.  Identity-Type TLV\n   The Identity-Type TLV allows an EAP server
        to send a hint to help the\n   EAP peer select the right type of identity,
        for example, user or\n   machine.  TEAPv1 implementations MUST support this
        TLV.  Only one\n   Identity-Type TLV SHOULD be present in the TEAP request
        or response\n   packet.  The Identity-Type TLV request MUST come with an EAP-Payload\n
        \  TLV or Basic-Password-Auth-Req TLV.  If the EAP peer does have an\n   identity
        corresponding to the identity type requested, then the peer\n   SHOULD respond
        with an Identity-Type TLV with the requested type.  If\n   the Identity-Type
        field does not contain one of the known values or\n   if the EAP peer does
        not have an identity corresponding to the\n   identity type requested, then
        the peer SHOULD respond with an\n   Identity-Type TLV with the one of available
        identity types.  If the\n   server receives an identity type in the response
        that does not match\n   the requested type, then the peer does not possess
        the requested\n   credential type, and the server SHOULD proceed with authentication\n
        \  for the credential type proposed by the peer, proceed with requesting\n
        \  another credential type, or simply apply the network policy based on\n
        \  the configured policy, e.g., sending Result TLV with Failure.\n   The Identity-Type
        TLV is defined as follows:\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |         Identity-Type         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      0 (Optional)\n   R\n      Reserved, set to zero (0)\n   TLV Type\n
        \     2 - Identity-Type TLV\n   Length\n      2\n   Identity-Type\n      The
        Identity-Type field is two octets.  Values include:\n      1  User\n      2
        \ Machine\n"
      title: 4.2.3.  Identity-Type TLV
    - contents:
      - "4.2.4.  Result TLV\n   The Result TLV provides support for acknowledged success
        and failure\n   messages for protected termination within TEAP.  If the Status
        field\n   does not contain one of the known values, then the peer or EAP server\n
        \  MUST treat this as a fatal error of Unexpected TLVs Exchanged.  The\n   behavior
        of the Result TLV is further discussed in Sections 3.3.3 and\n   3.6.3.  A
        Result TLV indicating failure MUST NOT be accompanied by\n   the following
        TLVs: NAK, EAP-Payload TLV, or Crypto-Binding TLV.  The\n   Result TLV is
        defined as follows:\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |             Status            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      Mandatory, set to one (1)\n   R\n      Reserved, set to zero (0)\n
        \  TLV Type\n      3 - Result TLV\n   Length\n      2\n   Status\n      The
        Status field is two octets.  Values include:\n      1  Success\n      2  Failure\n"
      title: 4.2.4.  Result TLV
    - contents:
      - "4.2.5.  NAK TLV\n   The NAK TLV allows a peer to detect TLVs that are not
        supported by\n   the other peer.  A TEAP packet can contain 0 or more NAK
        TLVs.  A NAK\n   TLV should not be accompanied by other TLVs.  A NAK TLV MUST
        NOT be\n   sent in response to a message containing a Result TLV, instead
        a\n   Result TLV of failure should be sent indicating failure and an Error\n
        \  TLV of Unexpected TLVs Exchanged.  The NAK TLV is defined as follows:\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                          Vendor-Id                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |            NAK-Type           |           TLVs...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      Mandatory, set to one (1)\n   R\n      Reserved, set to zero (0)\n
        \  TLV Type\n      4 - NAK TLV\n   Length\n      >=6\n   Vendor-Id\n      The
        Vendor-Id field is four octets and contains the Vendor-Id of\n      the TLV
        that was not supported.  The high-order octet is 0, and\n      the low-order
        three octets are the Structure of Management\n      Information (SMI) Network
        Management Private Enterprise Number of\n      the Vendor in network byte
        order.  The Vendor-Id field MUST be\n      zero for TLVs that are not Vendor-Specific
        TLVs.\n   NAK-Type\n      The NAK-Type field is two octets.  The field contains
        the type of\n      the TLV that was not supported.  A TLV of this type MUST
        have been\n      included in the previous packet.\n   TLVs\n      This field
        contains a list of zero or more TLVs, each of which\n      MUST NOT have the
        mandatory bit set.  These optional TLVs are for\n      future extensibility
        to communicate why the offending TLV was\n      determined to be unsupported.\n"
      title: 4.2.5.  NAK TLV
    - contents:
      - "4.2.6.  Error TLV\n   The Error TLV allows an EAP peer or server to indicate
        errors to the\n   other party.  A TEAP packet can contain 0 or more Error
        TLVs.  The\n   Error-Code field describes the type of error.  Error codes
        1-999\n   represent successful outcomes (informative messages), 1000-1999\n
        \  represent warnings, and 2000-2999 represent fatal errors.  A fatal\n   Error
        TLV MUST be accompanied by a Result TLV indicating failure, and\n   the conversation
        is terminated as described in Section 3.6.3.\n   Many of the error codes below
        refer to errors in inner method\n   processing that may be retrieved if made
        available by the inner\n   method.  Implementations MUST take care that error
        messages do not\n   reveal too much information to an attacker.  For example,
        the usage\n   of error message 1031 (User account credentials incorrect) is
        NOT\n   RECOMMENDED, because it allows an attacker to determine valid\n   usernames
        by differentiating this response from other responses.  It\n   should only
        be used for troubleshooting purposes.\n   The Error TLV is defined as follows:\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                           Error-Code                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      Mandatory, set to one (1)\n   R\n      Reserved, set to zero (0)\n
        \  TLV Type\n      5 - Error TLV\n   Length\n      4\n   Error-Code\n      The
        Error-Code field is four octets.  Currently defined values for\n      Error-Code
        include:\n      1     User account expires soon\n      2     User account
        credential expires soon\n      3     User account authorizations change soon\n
        \     4     Clock skew detected\n      5     Contact administrator\n      6
        \    User account credentials change required\n      1001  Inner Method Error\n
        \     1002  Unspecified authentication infrastructure problem\n      1003
        \ Unspecified authentication failure\n      1004  Unspecified authorization
        failure\n      1005  User account credentials unavailable\n      1006  User
        account expired\n      1007  User account locked: try again later\n      1008
        \ User account locked: admin intervention required\n      1009  Authentication
        infrastructure unavailable\n      1010  Authentication infrastructure not
        trusted\n      1011  Clock skew too great\n      1012  Invalid inner realm\n
        \     1013  Token out of sync: administrator intervention required\n      1014
        \ Token out of sync: PIN change required\n      1015  Token revoked\n      1016
        \ Tokens exhausted\n      1017  Challenge expired\n      1018  Challenge algorithm
        mismatch\n      1019  Client certificate not supplied\n      1020  Client
        certificate rejected\n      1021  Realm mismatch between inner and outer identity\n
        \     1022  Unsupported Algorithm In Certificate Signing Request\n      1023
        \ Unsupported Extension In Certificate Signing Request\n      1024  Bad Identity
        In Certificate Signing Request\n      1025  Bad Certificate Signing Request\n
        \     1026  Internal CA Error\n      1027  General PKI Error\n      1028  Inner
        method's channel-binding data required but not\n            supplied\n      1029
        \ Inner method's channel-binding data did not include required\n            information\n
        \     1030  Inner method's channel binding failed\n      1031  User account
        credentials incorrect [USAGE NOT RECOMMENDED]\n      2001  Tunnel Compromise
        Error\n      2002  Unexpected TLVs Exchanged\n"
      title: 4.2.6.  Error TLV
    - contents:
      - "4.2.7.  Channel-Binding TLV\n   The Channel-Binding TLV provides a mechanism
        for carrying channel-\n   binding data from the peer to the EAP server and
        a channel-binding\n   response from the EAP server to the peer as described
        in [RFC6677].\n   TEAPv1 implementations MAY support this TLV, which cannot
        be\n   responded to with a NAK TLV.  If the Channel-Binding data field does\n
        \  not contain one of the known values or if the EAP server does not\n   support
        this TLV, then the server MUST ignore the value.  The\n   Channel-Binding
        TLV is defined as follows:\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |            Data ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      0 (Optional)\n   R\n      Reserved, set to zero (0)\n   TLV Type\n
        \     6 - Channel-Binding TLV\n   Length\n      variable\n   Data\n      The
        data field contains a channel-binding message as defined in\n      Section
        5.3 of [RFC6677].\n"
      title: 4.2.7.  Channel-Binding TLV
    - contents:
      - "4.2.8.  Vendor-Specific TLV\n   The Vendor-Specific TLV is available to allow
        vendors to support\n   their own extended attributes not suitable for general
        usage.  A\n   Vendor-Specific TLV attribute can contain one or more TLVs,
        referred\n   to as Vendor TLVs.  The TLV type of a Vendor-TLV is defined by
        the\n   vendor.  All the Vendor TLVs inside a single Vendor-Specific TLV\n
        \  belong to the same vendor.  There can be multiple Vendor-Specific\n   TLVs
        from different vendors in the same message.  Error handling in\n   the Vendor
        TLV could use the vendor's own specific error-handling\n   mechanism or use
        the standard TEAP error codes defined.\n   Vendor TLVs may be optional or
        mandatory.  Vendor TLVs sent with\n   Result TLVs MUST be marked as optional.
        \ If the Vendor-Specific TLV\n   is marked as mandatory, then it is expected
        that the receiving side\n   needs to recognize the vendor ID, parse all Vendor
        TLVs within, and\n   deal with error handling within the Vendor-Specific TLV
        as defined by\n   the vendor.\n   The Vendor-Specific TLV is defined as follows:\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                          Vendor-Id                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                         Vendor TLVs....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      0 or 1\n   R\n      Reserved, set to zero (0)\n   TLV Type\n      7
        - Vendor-Specific TLV\n   Length\n      4 + cumulative length of all included
        Vendor TLVs\n   Vendor-Id\n      The Vendor-Id field is four octets and contains
        the Vendor-Id of\n      the TLV.  The high-order octet is 0, and the low-order
        3 octets\n      are the SMI Network Management Private Enterprise Number of
        the\n      Vendor in network byte order.\n   Vendor TLVs\n      This field
        is of indefinite length.  It contains Vendor-Specific\n      TLVs, in a format
        defined by the vendor.\n"
      title: 4.2.8.  Vendor-Specific TLV
    - contents:
      - "4.2.9.  Request-Action TLV\n   The Request-Action TLV MAY be sent by both
        the peer and the server in\n   response to a successful or failed Result TLV.
        \ It allows the peer or\n   server to request the other side to negotiate
        additional EAP methods\n   or process TLVs specified in the response packet.
        \ The receiving side\n   MUST process this TLV.  The processing for the TLV
        is as follows:\n      The receiving entity MAY choose to process any of the
        TLVs that\n      are included in the message.\n      If the receiving entity
        chooses NOT to process any TLV in the\n      list, then it sends back a Result
        TLV with the same code in the\n      Status field of the Request-Action TLV.\n
        \     If multiple Request-Action TLVs are in the request, the session\n      can
        continue if any of the TLVs in any Request-Action TLV are\n      processed.\n
        \     If multiple Request-Action TLVs are in the request and none of\n      them
        is processed, then the most fatal status should be used in\n      the Result
        TLV returned.  If a status code in the Request-Action\n      TLV is not understood
        by the receiving entity, then it should be\n      treated as a fatal error.\n
        \     After processing the TLVs or EAP method in the request, another\n      round
        of Result TLV exchange would occur to synchronize the final\n      status
        on both sides.\n   The peer or the server MAY send multiple Request-Action
        TLVs to the\n   other side.  Two Request-Action TLVs MUST NOT occur in the
        same TEAP\n   packet if they have the same Status value.  The order of processing\n
        \  multiple Request-Action TLVs is implementation dependent.  If the\n   receiving
        side processes the optional (non-fatal) items first, it is\n   possible that
        the fatal items will disappear at a later time.  If the\n   receiving side
        processes the fatal items first, the communication\n   time will be shorter.\n
        \  The peer or the server MAY return a new set of Request-Action TLVs\n   after
        one or more of the requested items has been processed and the\n   other side
        has signaled it wants to end the EAP conversation.\n   The Request-Action
        TLV is defined as follows:\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |     Status   |      Action    |                TLVs....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-\n
        \  M\n      Mandatory, set to one (1)\n   R\n      Reserved, set to zero (0)\n
        \  TLV Type\n      8 - Request-Action TLV\n   Length\n      2 + cumulative
        length of all included TLVs\n   Status\n      The Status field is one octet.
        \ This indicates the result if the\n      server does not process the action
        requested by the peer.  Values\n      include:\n      1  Success\n      2
        \ Failure\n   Action\n      The Action field is one octet.  Values include:\n
        \     1  Process-TLV\n      2  Negotiate-EAP\n   TLVs\n      This field is
        of indefinite length.  It contains TLVs that the\n      peer wants the server
        to process.\n"
      title: 4.2.9.  Request-Action TLV
    - contents:
      - "4.2.10.  EAP-Payload TLV\n   To allow piggybacking an EAP request or response
        with other TLVs, the\n   EAP-Payload TLV is defined, which includes an encapsulated
        EAP packet\n   and a list of optional TLVs.  The optional TLVs are provided
        for\n   future extensibility to provide hints about the current EAP\n   authentication.
        \ Only one EAP-Payload TLV is allowed in a message.\n   The EAP-Payload TLV
        is defined as follows:\n   0                   1                   2                   3\n
        \  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                          EAP packet...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                             TLVs...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      Mandatory, set to one (1)\n   R\n      Reserved, set to zero (0)\n
        \  TLV Type\n      9 - EAP-Payload TLV\n   Length\n      length of embedded
        EAP packet + cumulative length of additional\n      TLVs\n   EAP packet\n
        \     This field contains a complete EAP packet, including the EAP\n      header
        (Code, Identifier, Length, Type) fields.  The length of\n      this field
        is determined by the Length field of the encapsulated\n      EAP packet.\n
        \  TLVs\n      This (optional) field contains a list of TLVs associated with
        the\n      EAP packet field.  The TLVs MUST NOT have the mandatory bit set.\n
        \     The total length of this field is equal to the Length field of the\n
        \     EAP-Payload TLV, minus the Length field in the EAP header of the\n      EAP
        packet field.\n"
      title: 4.2.10.  EAP-Payload TLV
    - contents:
      - "4.2.11.  Intermediate-Result TLV\n   The Intermediate-Result TLV provides
        support for acknowledged\n   intermediate Success and Failure messages between
        multiple inner EAP\n   methods within EAP.  An Intermediate-Result TLV indicating
        success\n   MUST be accompanied by a Crypto-Binding TLV.  The optional TLVs\n
        \  associated with this TLV are provided for future extensibility to\n   provide
        hints about the current result.  The Intermediate-Result TLV\n   is defined
        as follows:\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |             Status            |        TLVs...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      Mandatory, set to one (1)\n   R\n      Reserved, set to zero (0)\n
        \  TLV Type\n      10 - Intermediate-Result TLV\n   Length\n      2 + cumulative
        length of the embedded associated TLVs\n   Status\n      The Status field
        is two octets.  Values include:\n      1  Success\n      2  Failure\n   TLVs\n
        \     This field is of indeterminate length and contains zero or more of\n
        \     the TLVs associated with the Intermediate Result TLV.  The TLVs in\n
        \     this field MUST NOT have the mandatory bit set.\n"
      title: 4.2.11.  Intermediate-Result TLV
    - contents:
      - "4.2.12.  PAC TLV Format\n   The PAC TLV provides support for provisioning
        the Protected Access\n   Credential (PAC).  The PAC TLV carries the PAC and
        related\n   information within PAC attribute fields.  Additionally, the PAC
        TLV\n   MAY be used by the peer to request provisioning of a PAC of the type\n
        \  specified in the PAC-Type PAC attribute.  The PAC TLV MUST only be\n   used
        in a protected tunnel providing encryption and integrity\n   protection.  A
        general PAC TLV format is defined as follows:\n   0                   1                   2
        \                  3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
        5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                        PAC Attributes...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      0 or 1\n   R\n      Reserved, set to zero (0)\n   TLV Type\n      11
        - PAC TLV\n   Length\n      Two octets containing the length of the PAC Attributes
        field in\n      octets.\n   PAC Attributes\n      A list of PAC attributes
        in the TLV format.\n"
      - contents:
        - "4.2.12.1.  Formats for PAC Attributes\n   Each PAC attribute in a PAC TLV
          is formatted as a TLV defined as\n   follows:\n    0                   1
          \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |            Type               |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |                              Value...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Type\n      The Type field is two octets, denoting the attribute type.\n
          \     Allocated types include:\n         1 - PAC-Key\n         2 - PAC-Opaque\n
          \        3 - PAC-Lifetime\n         4 - A-ID\n         5 - I-ID\n         6
          - Reserved\n         7 - A-ID-Info\n         8 - PAC-Acknowledgement\n         9
          - PAC-Info\n         10 - PAC-Type\n   Length\n      Two octets containing
          the length of the Value field in octets.\n   Value\n      The value of the
          PAC attribute.\n"
        title: 4.2.12.1.  Formats for PAC Attributes
      - contents:
        - "4.2.12.2.  PAC-Key\n   The PAC-Key is a secret key distributed in a PAC
          attribute of type\n   PAC-Key.  The PAC-Key attribute is included within
          the PAC TLV\n   whenever the server wishes to issue or renew a PAC that
          is bound to a\n   key such as a Tunnel PAC.  The key is a randomly generated
          octet\n   string that is 48 octets in length.  The generator of this key
          is the\n   issuer of the credential, which is identified by the Authority\n
          \  Identifier (A-ID).\n    0                   1                   2                   3\n
          \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |            Type               |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |                                                               |\n   ~
          \                             Key                              ~\n   |                                                               |\n
          \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Type\n
          \     1 - PAC-Key\n   Length\n      2-octet length indicating the length
          of the key.\n   Key\n      The value of the PAC-Key.\n"
        title: 4.2.12.2.  PAC-Key
      - contents:
        - "4.2.12.3.  PAC-Opaque\n   The PAC-Opaque attribute is included within the
          PAC TLV whenever the\n   server wishes to issue or renew a PAC.\n   The
          PAC-Opaque is opaque to the peer, and thus the peer MUST NOT\n   attempt
          to interpret it.  A peer that has been issued a PAC-Opaque by\n   a server
          stores that data and presents it back to the server\n   according to its
          PAC-Type.  The Tunnel PAC is used in the ClientHello\n   SessionTicket extension
          field defined in [RFC5077].  If a peer has\n   opaque data issued to it
          by multiple servers, then it stores the data\n   issued by each server separately
          according to the A-ID.  This\n   requirement allows the peer to maintain
          and use each opaque datum as\n   an independent PAC pairing, with a PAC-Key
          mapping to a PAC-Opaque\n   identified by the A-ID.  As there is a one-to-one
          correspondence\n   between the PAC-Key and PAC-Opaque, the peer determines
          the PAC-Key\n   and corresponding PAC-Opaque based on the A-ID provided
          in the\n   TEAP/Start message and the A-ID provided in the PAC-Info when
          it was\n   provisioned with a PAC-Opaque.\n   The PAC-Opaque attribute format
          is summarized as follows:\n    0                   1                   2
          \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |            Type               |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |                              Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Type\n      2 - PAC-Opaque\n   Length\n      The Length field is two
          octets, which contains the length of the\n      Value field in octets.\n
          \  Value\n      The Value field contains the actual data for the PAC-Opaque.
          \ It\n      is specific to the server implementation.\n"
        title: 4.2.12.3.  PAC-Opaque
      - contents:
        - "4.2.12.4.  PAC-Info\n   The PAC-Info is comprised of a set of PAC attributes
          as defined in\n   Section 4.2.12.1.  The PAC-Info attribute MUST contain
          the A-ID,\n   A-ID-Info, and PAC-Type attributes.  Other attributes MAY
          be included\n   in the PAC-Info to provide more information to the peer.
          \ The\n   PAC-Info attribute MUST NOT contain the PAC-Key, PAC-Acknowledgement,\n
          \  PAC-Info, or PAC-Opaque attributes.  The PAC-Info attribute is\n   included
          within the PAC TLV whenever the server wishes to issue or\n   renew a PAC.\n
          \   0                   1                   2                   3\n    0
          1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |            Type               |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |                           Attributes...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Type\n      9 - PAC-Info\n   Length\n      2-octet field containing the
          length of the Attributes field in\n      octets.\n   Attributes\n      The
          Attributes field contains a list of PAC attributes.  Each\n      mandatory
          and optional field type is defined as follows:\n      3 - PAC-Lifetime\n
          \        This is a 4-octet quantity representing the expiration time of\n
          \        the credential expressed as the number of seconds, excluding\n
          \        leap seconds, after midnight UTC, January 1, 1970.  This\n         attribute
          MAY be provided to the peer as part of the PAC-Info.\n      4 - A-ID\n         The
          A-ID is the identity of the authority that issued the PAC.\n         The
          A-ID is intended to be unique across all issuing servers to\n         avoid
          namespace collisions.  The A-ID is used by the peer to\n         determine
          which PAC to employ.  The A-ID is treated as an\n         opaque octet string.
          \ This attribute MUST be included in the\n         PAC-Info attribute.  The
          A-ID MUST match the Authority-ID the\n         server used to establish
          the tunnel.  One method for generating\n         the A-ID is to use a high-quality
          random number generator to\n         generate a random number.  An alternate
          method would be to take\n         the hash of the public key or public key
          certificate belonging\n         to a server represented by the A-ID.\n      5
          - I-ID\n         Initiator Identifier (I-ID) is the peer identity associated\n
          \        with the credential.  This identity is derived from the inner\n
          \        authentication or from the client-side authentication during\n
          \        tunnel establishment if inner authentication is not used.  The\n
          \        server employs the I-ID in the TEAP Phase 2 conversation to\n         validate
          that the same peer identity used to execute TEAP Phase\n         1 is also
          used in at minimum one inner authentication in TEAP\n         Phase 2.  If
          the server is enforcing the I-ID validation on the\n         inner authentication,
          then the I-ID MUST be included in the\n         PAC-Info, to enable the
          peer to also enforce a unique PAC for\n         each unique user.  If the
          I-ID is missing from the PAC-Info, it\n         is assumed that the Tunnel
          PAC can be used for multiple users\n         and the peer will not enforce
          the unique-Tunnel-PAC-per-user\n         policy.\n      7 - A-ID-Info\n
          \        Authority Identifier Information is intended to provide a user-\n
          \        friendly name for the A-ID.  It may contain the enterprise name\n
          \        and server name in a human-readable format.  This TLV serves as\n
          \        an aid to the peer to better inform the end user about the\n         A-ID.
          \ The name is encoded in UTF-8 [RFC3629] format.  This\n         attribute
          MUST be included in the PAC-Info.\n      10 - PAC-Type\n         The PAC-Type
          is intended to provide the type of PAC.  This\n         attribute SHOULD
          be included in the PAC-Info.  If the PAC-Type\n         is not present,
          then it defaults to a Tunnel PAC (Type 1).\n"
        title: 4.2.12.4.  PAC-Info
      - contents:
        - "4.2.12.5.  PAC-Acknowledgement TLV\n   The PAC-Acknowledgement is used
          to acknowledge the receipt of the\n   Tunnel PAC by the peer.  The peer
          includes the PAC-Acknowledgement\n   TLV in a PAC TLV sent to the server
          to indicate the result of the\n   processing and storing of a newly provisioned
          Tunnel PAC.  This TLV\n   is only used when Tunnel PAC is provisioned.\n
          \   0                   1                   2                   3\n    0
          1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |            Type               |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |            Result             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Type\n      8 - PAC-Acknowledgement\n   Length\n      The length of this
          field is two octets containing a value of 2.\n   Result\n      The resulting
          value MUST be one of the following:\n         1 - Success\n         2 -
          Failure\n"
        title: 4.2.12.5.  PAC-Acknowledgement TLV
      - contents:
        - "4.2.12.6.  PAC-Type TLV\n   The PAC-Type TLV is a TLV intended to specify
          the PAC-Type.  It is\n   included in a PAC TLV sent by the peer to request
          PAC provisioning\n   from the server.  Its format is described below:\n
          \   0                   1                   2                   3\n    0
          1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |            Type               |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |         PAC-Type              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Type\n      10 - PAC-Type\n   Length\n      2-octet field with a value
          of 2.\n   PAC-Type\n      This 2-octet field defines the type of PAC being
          requested or\n      provisioned.  The following values are defined:\n               1
          - Tunnel PAC\n"
        title: 4.2.12.6.  PAC-Type TLV
      title: 4.2.12.  PAC TLV Format
    - contents:
      - "4.2.13.  Crypto-Binding TLV\n   The Crypto-Binding TLV is used to prove that
        both the peer and server\n   participated in the tunnel establishment and
        sequence of\n   authentications.  It also provides verification of the TEAP
        type,\n   version negotiated, and Outer TLVs exchanged before the TLS tunnel\n
        \  establishment.\n   The Crypto-Binding TLV MUST be exchanged and verified
        before the\n   final Result TLV exchange, regardless of whether there is an
        inner\n   EAP method authentication or not.  It MUST be included with the\n
        \  Intermediate-Result TLV to perform cryptographic binding after each\n   successful
        EAP method in a sequence of EAP methods, before proceeding\n   with another
        inner EAP method.  The Crypto-Binding TLV is valid only\n   if the following
        checks pass:\n   o  The Crypto-Binding TLV version is supported.\n   o  The
        MAC verifies correctly.\n   o  The received version in the Crypto-Binding
        TLV matches the version\n      sent by the receiver during the EAP version
        negotiation.\n   o  The subtype is set to the correct value.\n   If any of
        the above checks fails, then the TLV is invalid.  An\n   invalid Crypto-Binding
        TLV is a fatal error and is handled as\n   described in Section 3.6.3\n   The
        Crypto-Binding TLV is defined as follows:\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |    Reserved   |    Version    |  Received Ver.| Flags|Sub-Type|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                                               |\n   ~
        \                            Nonce                             ~\n   |                                                               |\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |
        \                                                              |\n   ~                   EMSK
        Compound MAC                           ~\n   |                                                               |\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |
        \                                                              |\n   ~                    MSK
        Compound MAC                           ~\n   |                                                               |\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   M\n
        \     Mandatory, set to one (1)\n   R\n      Reserved, set to zero (0)\n   TLV
        Type\n      12 - Crypto-Binding TLV\n   Length\n      76\n   Reserved\n      Reserved,
        set to zero (0)\n   Version\n      The Version field is a single octet, which
        is set to the version\n      of Crypto-Binding TLV the TEAP method is using.
        \ For an\n      implementation compliant with this version of TEAP, the version\n
        \     number MUST be set to one (1).\n   Received Ver\n      The Received
        Ver field is a single octet and MUST be set to the\n      TEAP version number
        received during version negotiation.  Note\n      that this field only provides
        protection against downgrade\n      attacks, where a version of EAP requiring
        support for this TLV is\n      required on both sides.\n   Flags\n      The
        Flags field is four bits.  Defined values include\n      1  EMSK Compound
        MAC is present\n      2  MSK Compound MAC is present\n      3  Both EMSK and
        MSK Compound MAC are present\n   Sub-Type\n      The Sub-Type field is four
        bits.  Defined values include\n      0  Binding Request\n      1  Binding
        Response\n   Nonce\n      The Nonce field is 32 octets.  It contains a 256-bit
        nonce that is\n      temporally unique, used for Compound MAC key derivation
        at each\n      end.  The nonce in a request MUST have its least significant
        bit\n      set to zero (0), and the nonce in a response MUST have the same\n
        \     value as the request nonce except the least significant bit MUST\n      be
        set to one (1).\n   EMSK Compound MAC\n      The EMSK Compound MAC field is
        20 octets.  This can be the Server\n      MAC (B1_MAC) or the Client MAC (B2_MAC).
        \ The computation of the\n      MAC is described in Section 5.3.\n   MSK Compound
        MAC\n      The MSK Compound MAC field is 20 octets.  This can be the Server\n
        \     MAC (B1_MAC) or the Client MAC (B2_MAC).  The computation of the\n      MAC
        is described in Section 5.3.\n"
      title: 4.2.13.  Crypto-Binding TLV
    - contents:
      - "4.2.14.  Basic-Password-Auth-Req TLV\n   The Basic-Password-Auth-Req TLV
        is used by the authentication server\n   to request a username and password
        from the peer.  It contains an\n   optional user prompt message for the request.
        \ The peer is expected\n   to obtain the username and password and send them
        in a Basic-\n   Password-Auth-Resp TLV.\n   The Basic-Password-Auth-Req TLV
        is defined as follows:\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Prompt ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      0 (Optional)\n   R\n      Reserved, set to zero (0)\n   TLV Type\n
        \     13 - Basic-Password-Auth-Req TLV\n   Length\n      variable\n   Prompt\n
        \     optional user prompt message in UTF-8 [RFC3629] format\n"
      title: 4.2.14.  Basic-Password-Auth-Req TLV
    - contents:
      - "4.2.15.  Basic-Password-Auth-Resp TLV\n   The Basic-Password-Auth-Resp TLV
        is used by the peer to respond to a\n   Basic-Password-Auth-Req TLV with a
        username and password.  The TLV\n   contains a username and password.  The
        username and password are in\n   UTF-8 [RFC3629] format.\n   The Basic-Password-Auth-Resp
        TLV is defined as follows:\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Userlen     |             Username\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \        ...     Username    ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Passlen     |             Password\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \        ...     Password    ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  M\n      0 (Optional)\n   R\n      Reserved, set to zero (0)\n   TLV Type\n
        \     14 - Basic-Password-Auth-Resp TLV\n   Length\n      variable\n   Userlen\n
        \     Length of Username field in octets\n   Username\n      Username in UTF-8
        [RFC3629] format\n   Passlen\n      Length of Password field in octets\n   Password\n
        \     Password in UTF-8 [RFC3629] format\n"
      title: 4.2.15.  Basic-Password-Auth-Resp TLV
    - contents:
      - "4.2.16.  PKCS#7 TLV\n   The PKCS#7 TLV is used by the EAP server to deliver
        certificate(s) to\n   the peer.  The format consists of a certificate or certificate
        chain\n   in binary DER encoding [X.690] in a degenerate Certificates Only\n
        \  PKCS#7 SignedData Content as defined in [RFC5652].\n   When used in response
        to a Trusted-Server-Root TLV request from the\n   peer, the EAP server MUST
        send the PKCS#7 TLV inside a Trusted-\n   Server-Root TLV.  When used in response
        to a PKCS#10 certificate\n   enrollment request from the peer, the EAP server
        MUST send the PKCS#7\n   TLV without a Trusted-Server-Root TLV.  The PKCS#7
        TLV is always\n   marked as optional, which cannot be responded to with a
        NAK TLV.\n   TEAP implementations that support the Trusted-Server-Root TLV
        or the\n   PKCS#10 TLV MUST support this TLV.  Peers MUST NOT assume that
        the\n   certificates in a PKCS#7 TLV are in any order.\n   TEAP servers MAY
        return self-signed certificates.  Peers that handle\n   self-signed certificates
        or trust anchors MUST NOT implicitly trust\n   these certificates merely due
        to their presence in the certificate\n   bag.  Note: Peers are advised to
        take great care in deciding whether\n   to use a received certificate as a
        trust anchor.  The authenticated\n   nature of the tunnel in which a PKCS#7
        bag is received can provide a\n   level of authenticity to the certificates
        contained therein.  Peers\n   are advised to take into account the implied
        authority of the EAP\n   server and to constrain the trust it can achieve
        through the trust\n   anchor received in a PKCS#7 TLV.\n   The PKCS#7 TLV
        is defined as follows:\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |           PKCS#7 Data...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n
        \  M\n      0 - Optional TLV\n   R\n      Reserved, set to zero (0)\n   TLV
        Type\n      15 - PKCS#7 TLV\n   Length\n      The length of the PKCS#7 Data
        field.\n   PKCS#7 Data\n      This field contains the DER-encoded X.509 certificate
        or\n      certificate chain in a Certificates-Only PKCS#7 SignedData\n      message.\n"
      title: 4.2.16.  PKCS#7 TLV
    - contents:
      - "4.2.17.  PKCS#10 TLV\n   The PKCS#10 TLV is used by the peer to initiate
        the \"simple PKI\"\n   Request/Response from [RFC5272].  The format of the
        request is as\n   specified in Section 6.4 of [RFC4945].  The PKCS#10 TLV
        is always\n   marked as optional, which cannot be responded to with a NAK
        TLV.\n   The PKCS#10 TLV is defined as follows:\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |           PKCS#10 Data...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n
        \  M\n      0 - Optional TLV\n   R\n      Reserved, set to zero (0)\n   TLV
        Type\n      16 - PKCS#10 TLV\n   Length\n      The length of the PKCS#10 Data
        field.\n   PKCS#10 Data\n      This field contains the DER-encoded PKCS#10
        certificate request.\n"
      title: 4.2.17.  PKCS#10 TLV
    - contents:
      - "4.2.18.  Trusted-Server-Root TLV\n   Trusted-Server-Root TLV facilitates
        the request and delivery of a\n   trusted server root certificate.  The Trusted-Server-Root
        TLV can be\n   exchanged in regular TEAP authentication mode or provisioning
        mode.\n   The Trusted-Server-Root TLV is always marked as optional and cannot\n
        \  be responded to with a Negative Acknowledgement (NAK) TLV.  The\n   Trusted-Server-Root
        TLV MUST only be sent as an Inner TLV (inside the\n   protection of the tunnel).\n
        \  After the peer has determined that it has successfully authenticated\n
        \  the EAP server and validated the Crypto-Binding TLV, it MAY send one\n
        \  or more Trusted-Server-Root TLVs (marked as optional) to request the\n
        \  trusted server root certificates from the EAP server.  The EAP server\n
        \  MAY send one or more root certificates with a Public Key\n   Cryptographic
        System #7 (PKCS#7) TLV inside the Trusted-Server-Root\n   TLV.  The EAP server
        MAY also choose not to honor the request.\n   The Trusted-Server-Root TLV
        allows the peer to send a request to the\n   EAP server for a list of trusted
        roots.  The server may respond with\n   one or more root certificates in PKCS#7
        [RFC2315] format.\n   If the EAP server sets the credential format to PKCS#7-Server-\n
        \  Certificate-Root, then the Trusted-Server-Root TLV should contain the\n
        \  root of the certificate chain of the certificate issued to the EAP\n   server
        packaged in a PKCS#7 TLV.  If the server certificate is a\n   self-signed
        certificate, then the root is the self-signed\n   certificate.\n   If the
        Trusted-Server-Root TLV credential format contains a value\n   unknown to
        the peer, then the EAP peer should ignore the TLV.\n   The Trusted-Server-Root
        TLV is defined as follows:\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |M|R|         TLV Type          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |           Credential-Format   |     Cred TLVs...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n
        \  M\n      0 - Optional TLV\n   R\n      Reserved, set to zero (0)\n   TLV
        Type\n      17 - Trusted-Server-Root TLV\n   Length\n      >=2 octets\n   Credential-Format\n
        \     The Credential-Format field is two octets.  Values include:\n      1
        - PKCS#7-Server-Certificate-Root\n   Cred TLVs\n      This field is of indefinite
        length.  It contains TLVs associated\n      with the credential format.  The
        peer may leave this field empty\n      when using this TLV to request server
        trust roots.\n"
      title: 4.2.18.  Trusted-Server-Root TLV
    title: 4.2.  TEAP TLV Format and Support
  - contents:
    - "4.3.  TLV Rules\n   To save round trips, multiple TLVs can be sent in a single
      TEAP\n   packet.  However, multiple EAP Payload TLVs, multiple Basic Password\n
      \  Authentication TLVs, or an EAP Payload TLV with a Basic Password\n   Authentication
      TLV within one single TEAP packet is not supported in\n   this version and MUST
      NOT be sent.  If the peer or EAP server\n   receives multiple EAP Payload TLVs,
      then it MUST terminate the\n   connection with the Result TLV.  The order of
      TLVs in TEAP does not\n   matter, except one should always process the Identity-Type
      TLV before\n   processing the EAP TLV or Basic Password Authentication TLV as
      the\n   Identity-Type TLV is a hint to the type of identity that is to be\n
      \  authenticated.\n   The following define the meaning of the table entries
      in the sections\n   below:\n   0     This TLV MUST NOT be present in the message.\n
      \  0+    Zero or more instances of this TLV MAY be present in the\n         message.\n
      \  0-1   Zero or one instance of this TLV MAY be present in the message.\n   1
      \    Exactly one instance of this TLV MUST be present in the\n         message.\n"
    - contents:
      - "4.3.1.  Outer TLVs\n   The following table provides a guide to which TLVs
        may be included in\n   the TEAP packet outside the TLS channel, which kind
        of packets, and\n   in what quantity:\n   Request  Response    Success   Failure
        \  TLVs\n   0-1      0           0         0         Authority-ID\n   0-1
        \     0-1         0         0         Identity-Type\n   0+       0+          0
        \        0         Vendor-Specific\n   Outer TLVs MUST be marked as optional.
        \ Vendor-TLVs inside Vendor-\n   Specific TLV MUST be marked as optional when
        included in Outer TLVs.\n   Outer TLVs MUST NOT be included in messages after
        the first two TEAP\n   messages sent by peer and EAP-server respectively.
        \ That is the first\n   EAP-server-to-peer message and first peer-to-EAP-server
        message.  If\n   the message is fragmented, the whole set of messages is counted
        as\n   one message.  If Outer TLVs are included in messages after the first\n
        \  two TEAP messages, they MUST be ignored.\n"
      title: 4.3.1.  Outer TLVs
    - contents:
      - "4.3.2.  Inner TLVs\n   The following table provides a guide to which Inner
        TLVs may be\n   encapsulated in TLS in TEAP Phase 2, in which kind of packets,
        and in\n   what quantity.  The messages are as follows: Request is a TEAP\n
        \  Request, Response is a TEAP Response, Success is a message containing\n
        \  a successful Result TLV, and Failure is a message containing a failed\n
        \  Result TLV.\n   Request  Response    Success   Failure   TLVs\n   0-1      0-1
        \        0         0         Identity-Type\n   0-1      0-1         1         1
        \        Result\n   0+       0+          0         0         NAK\n   0+       0+
        \         0+        0+        Error\n   0-1      0-1         0         0         Channel-Binding\n
        \  0+       0+          0+        0+        Vendor-Specific\n   0+       0+
        \         0+        0+        Request-Action\n   0-1      0-1         0         0
        \        EAP-Payload\n   0-1      0-1         0-1       0-1       Intermediate-Result\n
        \  0+       0+          0+        0         PAC TLV\n   0-1      0-1         0-1
        \      0-1       Crypto-Binding\n   0-1      0           0         0         Basic-Password-Auth-Req\n
        \  0        0-1         0         0         Basic-Password-Auth-Resp\n   0-1
        \     0           0-1       0         PKCS#7\n   0        0-1         0         0
        \        PKCS#10\n   0-1      0-1         0-1       0         Trusted-Server-Root\n
        \  NOTE: Vendor TLVs (included in Vendor-Specific TLVs) sent with a\n   Result
        TLV MUST be marked as optional.\n"
      title: 4.3.2.  Inner TLVs
    title: 4.3.  TLV Rules
  title: 4.  Message Formats
- contents:
  - "5.  Cryptographic Calculations\n   For key derivation and crypto-binding, TEAP
    uses the Pseudorandom\n   Function (PRF) and MAC algorithms negotiated in the
    underlying TLS\n   session.  Since these algorithms depend on the TLS version
    and\n   ciphersuite, TEAP implementations need a mechanism to determine the\n
    \  version and ciphersuite in use for a particular session.  The\n   implementation
    can then use this information to determine which PRF\n   and MAC algorithm to
    use.\n"
  - contents:
    - "5.1.  TEAP Authentication Phase 1: Key Derivations\n   With TEAPv1, the TLS
      master secret is generated as specified in TLS.\n   If a PAC is used, then the
      master secret is obtained as described in\n   [RFC5077].\n   TEAPv1 makes use
      of the TLS Keying Material Exporters defined in\n   [RFC5705] to derive the
      session_key_seed.  The label used in the\n   derivation is \"EXPORTER: teap
      session key seed\".  The length of the\n   session key seed material is 40 octets.
      \ No context data is used in\n   the export process.\n   The session_key_seed
      is used by the TEAP authentication Phase 2\n   conversation to both cryptographically
      bind the inner method(s) to\n   the tunnel as well as generate the resulting
      TEAP session keys.  The\n   other TLS keying materials are derived and used
      as defined in\n   [RFC5246].\n"
    title: '5.1.  TEAP Authentication Phase 1: Key Derivations'
  - contents:
    - "5.2.  Intermediate Compound Key Derivations\n   The session_key_seed derived
      as part of TEAP Phase 2 is used in TEAP\n   Phase 2 to generate an Intermediate
      Compound Key (IMCK) used to\n   verify the integrity of the TLS tunnel after
      each successful inner\n   authentication and in the generation of Master Session
      Key (MSK) and\n   Extended Master Session Key (EMSK) defined in [RFC3748].  Note
      that\n   the IMCK MUST be recalculated after each successful inner EAP method.\n
      \  The first step in these calculations is the generation of the base\n   compound
      key, IMCK[n] from the session_key_seed, and any session keys\n   derived from
      the successful execution of nth inner EAP methods.  The\n   inner EAP method(s)
      may provide Inner Method Session Keys (IMSKs),\n   IMSK1..IMSKn, corresponding
      to inner method 1 through n.\n   If an inner method supports export of an Extended
      Master Session Key\n   (EMSK), then the IMSK SHOULD be derived from the EMSK
      as defined in\n   [RFC5295].  The usage label used is \"TEAPbindkey@ietf.org\",
      and the\n   length is 64 octets.  Optional data parameter is not used in the\n
      \  derivation.\n     IMSK = First 32 octets of TLS-PRF(EMSK, \"TEAPbindkey@ietf.org\"
      |\n     \"\\0\" | 64)\n     where \"|\" denotes concatenation, EMSK is the EMSK
      from the inner\n     method, \"TEAPbindkey@ietf.org\" consists the ASCII value
      for the\n     label \"TEAPbindkey@ietf.org\" (without quotes), \"\\0\" = is
      a NULL\n     octet (0x00 in hex), length is the 2-octet unsigned integer in\n
      \    network byte order, and TLS-PRF is the PRF negotiated as part of\n     TLS
      handshake [RFC5246].\n   If an inner method does not support export of an Extended
      Master\n   Session Key (EMSK), then IMSK is the MSK of the inner method.  The\n
      \  MSK is truncated at 32 octets if it is longer than 32 octets or\n   padded
      to a length of 32 octets with zeros if it is less than 32\n   octets.\n   However,
      it's possible that the peer and server sides might not have\n   the same capability
      to export EMSK.  In order to maintain maximum\n   flexibility while prevent
      downgrading attack, the following mechanism\n   is in place.\n   On the sender
      of the Crypto-Binding TLV side:\n     If the EMSK is not available, then the
      sender computes the Compound\n     MAC using the MSK of the inner method.\n
      \    If the EMSK is available and the sender's policy accepts MSK-based\n     MAC,
      then the sender computes two Compound MAC values.  The first\n     is computed
      with the EMSK.  The second one is computed using the\n     MSK.  Both MACs are
      then sent to the other side.\n     If the EMSK is available but the sender's
      policy does not allow\n     downgrading to MSK-generated MAC, then the sender
      SHOULD only send\n     EMSK-based MAC.\n   On the receiver of the Crypto-Binding
      TLV side:\n     If the EMSK is not available and an MSK-based Compound MAC was\n
      \    sent, then the receiver validates the Compound MAC and sends back\n     an
      MSK-based Compound MAC response.\n     If the EMSK is not available and no MSK-based
      Compound MAC was\n     sent, then the receiver handles like an invalid Crypto-Binding
      TLV\n     with a fatal error.\n     If the EMSK is available and an EMSK-based
      Compound MAC was sent,\n     then the receiver validates it and creates a response
      Compound MAC\n     using the EMSK.\n     If the EMSK is available but no EMSK-based
      Compound MAC was sent\n     and its policy accepts MSK-based MAC, then the receiver
      validates\n     it using the MSK and, if successful, generates and returns an
      MSK-\n     based Compound MAC.\n     If the EMSK is available but no EMSK Compound
      MAC was sent and its\n     policy does not accept MSK-based MAC, then the receiver
      handles\n     like an invalid Crypto-Binding TLV with a fatal error.\n   If
      the ith inner method does not generate an EMSK or MSK, then IMSKi\n   is set
      to zero (e.g., MSKi = 32 octets of 0x00s).  If an inner method\n   fails, then
      it is not included in this calculation.  The derivation\n   of S-IMCK is as
      follows:\n      S-IMCK[0] = session_key_seed\n      For j = 1 to n-1 do\n           IMCK[j]
      = TLS-PRF(S-IMCK[j-1], \"Inner Methods Compound Keys\",\n                IMSK[j],
      60)\n           S-IMCK[j] = first 40 octets of IMCK[j]\n           CMK[j] =
      last 20 octets of IMCK[j]\n   where TLS-PRF is the PRF negotiated as part of
      TLS handshake\n   [RFC5246].\n"
    title: 5.2.  Intermediate Compound Key Derivations
  - contents:
    - "5.3.  Computing the Compound MAC\n   For authentication methods that generate
      keying material, further\n   protection against man-in-the-middle attacks is
      provided through\n   cryptographically binding keying material established by
      both TEAP\n   Phase 1 and TEAP Phase 2 conversations.  After each successful
      inner\n   EAP authentication, EAP EMSK and/or MSKs are cryptographically\n   combined
      with key material from TEAP Phase 1 to generate a Compound\n   Session Key (CMK).
      \ The CMK is used to calculate the Compound MAC as\n   part of the Crypto-Binding
      TLV described in Section 4.2.13, which\n   helps provide assurance that the
      same entities are involved in all\n   communications in TEAP.  During the calculation
      of the Compound MAC,\n   the MAC field is filled with zeros.\n   The Compound
      MAC computation is as follows:\n      CMK = CMK[j]\n      Compound-MAC = MAC(
      CMK, BUFFER )\n   where j is the number of the last successfully executed inner
      EAP\n   method, MAC is the MAC function negotiated in TLS 1.2 [RFC5246], and\n
      \  BUFFER is created after concatenating these fields in the following\n   order:\n
      \  1  The entire Crypto-Binding TLV attribute with both the EMSK and MSK\n      Compound
      MAC fields zeroed out.\n   2  The EAP Type sent by the other party in the first
      TEAP message.\n   3  All the Outer TLVs from the first TEAP message sent by
      EAP server\n      to peer.  If a single TEAP message is fragmented into multiple\n
      \     TEAP packets, then the Outer TLVs in all the fragments of that\n      message
      MUST be included.\n   4  All the Outer TLVs from the first TEAP message sent
      by the peer to\n      the EAP server.  If a single TEAP message is fragmented
      into\n      multiple TEAP packets, then the Outer TLVs in all the fragments
      of\n      that message MUST be included.\n"
    title: 5.3.  Computing the Compound MAC
  - contents:
    - "5.4.  EAP Master Session Key Generation\n   TEAP authentication assures the
      Master Session Key (MSK) and Extended\n   Master Session Key (EMSK) output from
      the EAP method are the result\n   of all authentication conversations by generating
      an Intermediate\n   Compound Key (IMCK).  The IMCK is mutually derived by the
      peer and\n   the server as described in Section 5.2 by combining the MSKs from\n
      \  inner EAP methods with key material from TEAP Phase 1.  The resulting\n   MSK
      and EMSK are generated as part of the IMCKn key hierarchy as\n   follows:\n
      \     MSK  = TLS-PRF(S-IMCK[j], \"Session Key Generating Function\", 64)\n      EMSK
      = TLS-PRF(S-IMCK[j],\n           \"Extended Session Key Generating Function\",
      64)\n   where j is the number of the last successfully executed inner EAP\n
      \  method.\n   The EMSK is typically only known to the TEAP peer and server
      and is\n   not provided to a third party.  The derivation of additional keys
      and\n   transportation of these keys to a third party are outside the scope\n
      \  of this document.\n   If no EAP methods have been negotiated inside the tunnel
      or no EAP\n   methods have been successfully completed inside the tunnel, the
      MSK\n   and EMSK will be generated directly from the session_key_seed meaning\n
      \  S-IMCK = session_key_seed.\n"
    title: 5.4.  EAP Master Session Key Generation
  title: 5.  Cryptographic Calculations
- contents:
  - "6.  IANA Considerations\n   This section provides guidance to the Internet Assigned
    Numbers\n   Authority (IANA) regarding registration of values related to the TEAP\n
    \  protocol, in accordance with BCP 26 [RFC5226].\n   The EAP Method Type number
    55 has been assigned for TEAP.\n   The document defines a registry for TEAP TLV
    types, which may be\n   assigned by Specification Required as defined in [RFC5226].\n
    \  Section 4.2 defines the TLV types that initially populate the\n   registry.
    \ A summary of the TEAP TLV types is given below:\n   0  Unassigned\n   1  Authority-ID
    TLV\n   2  Identity-Type TLV\n   3  Result TLV\n   4  NAK TLV\n   5  Error TLV\n
    \  6  Channel-Binding TLV\n   7  Vendor-Specific TLV\n   8  Request-Action TLV\n
    \  9  EAP-Payload TLV\n   10 Intermediate-Result TLV\n   11 PAC TLV\n   12 Crypto-Binding
    TLV\n   13 Basic-Password-Auth-Req TLV\n   14 Basic-Password-Auth-Resp TLV\n   15
    PKCS#7 TLV\n   16 PKCS#10 TLV\n   17 Trusted-Server-Root TLV\n   The Identity-Type
    defined in Section 4.2.3 contains an identity type\n   code that is assigned on
    a Specification Required basis as defined in\n   [RFC5226].  The initial types
    defined are:\n   1  User\n   2  Machine\n   The Result TLV defined in Section
    4.2.4, Request-Action TLV defined\n   in Section 4.2.9, and Intermediate-Result
    TLV defined in\n   Section 4.2.11 contain a Status code that is assigned on a\n
    \  Specification Required basis as defined in [RFC5226].  The initial\n   types
    defined are:\n   1  Success\n   2  Failure\n   The Error-TLV defined in Section
    4.2.6 requires an error code.  TEAP\n   Error-TLV error codes are assigned based
    on a Specification Required\n   basis as defined in [RFC5226].  The initial list
    of error codes is as\n   follows:\n   1     User account expires soon\n   2     User
    account credential expires soon\n   3     User account authorizations change soon\n
    \  4     Clock skew detected\n   5     Contact administrator\n   6     User account
    credentials change required\n   1001  Inner Method Error\n   1002  Unspecified
    authentication infrastructure problem\n   1003  Unspecified authentication failure\n
    \  1004  Unspecified authorization failure\n   1005  User account credentials
    unavailable\n   1006  User account expired\n   1007  User account locked: try
    again later\n   1008  User account locked: admin intervention required\n   1009
    \ Authentication infrastructure unavailable\n   1010  Authentication infrastructure
    not trusted\n   1011  Clock skew too great\n   1012  Invalid inner realm\n   1013
    \ Token out of sync: administrator intervention required\n   1014  Token out of
    sync: PIN change required\n   1015  Token revoked\n   1016  Tokens exhausted\n
    \  1017  Challenge expired\n   1018  Challenge algorithm mismatch\n   1019  Client
    certificate not supplied\n   1020  Client certificate rejected\n   1021  Realm
    mismatch between inner and outer identity\n   1022  Unsupported Algorithm In Certificate
    Signing Request\n   1023  Unsupported Extension In Certificate Signing Request\n
    \  1024  Bad Identity In Certificate Signing Request\n   1025  Bad Certificate
    Signing Request\n   1026  Internal CA Error\n   1027  General PKI Error\n   1028
    \ Inner method's channel-binding data required but not supplied\n   1029  Inner
    method's channel-binding data did not include required\n         information\n
    \  1030  Inner method's channel binding failed\n   1031  User account credentials
    incorrect [USAGE NOT RECOMMENDED]\n   2001  Tunnel Compromise Error\n   2002  Unexpected
    TLVs Exchanged\n   The Request-Action TLV defined in Section 4.2.9 contains an
    action\n   code that is assigned on a Specification Required basis as defined
    in\n   [RFC5226].  The initial actions defined are:\n   1  Process-TLV\n   2  Negotiate-EAP\n
    \  The PAC Attribute defined in Section 4.2.12.1 contains a Type code\n   that
    is assigned on a Specification Required basis as defined in\n   [RFC5226].  The
    initial types defined are:\n   1  PAC-Key\n   2  PAC-Opaque\n   3  PAC-Lifetime\n
    \  4  A-ID\n   5  I-ID\n   6  Reserved\n   7  A-ID-Info\n   8  PAC-Acknowledgement\n
    \  9  PAC-Info\n   10 PAC-Type\n   The PAC-Type defined in Section 4.2.12.6 contains
    a type code that is\n   assigned on a Specification Required basis as defined
    in [RFC5226].\n   The initial type defined is:\n   1  Tunnel PAC\n   The Trusted-Server-Root
    TLV defined in Section 4.2.18 contains a\n   Credential-Format code that is assigned
    on a Specification Required\n   basis as defined in [RFC5226].  The initial type
    defined is:\n   1  PKCS#7-Server-Certificate-Root\n   The various values under
    the Vendor-Specific TLV are assigned by\n   Private Use and do not need to be
    assigned by IANA.\n   TEAP registers the label \"EXPORTER: teap session key seed\"
    in the TLS\n   Exporter Label Registry [RFC5705].  This label is used in derivation\n
    \  as defined in Section 5.1.\n   TEAP registers a TEAP binding usage label from
    the \"User Specific\n   Root Keys (USRK) Key Labels\" name space defined in [RFC5295]
    with a\n   value \"TEAPbindkey@ietf.org\".\n"
  title: 6.  IANA Considerations
- contents:
  - "7.  Security Considerations\n   TEAP is designed with a focus on wireless media,
    where the medium\n   itself is inherent to eavesdropping.  Whereas in wired media
    an\n   attacker would have to gain physical access to the wired medium,\n   wireless
    media enables anyone to capture information as it is\n   transmitted over the
    air, enabling passive attacks.  Thus, physical\n   security can not be assumed,
    and security vulnerabilities are far\n   greater.  The threat model used for the
    security evaluation of TEAP\n   is defined in EAP [RFC3748].\n"
  - contents:
    - "7.1.  Mutual Authentication and Integrity Protection\n   As a whole, TEAP provides
      message and integrity protection by\n   establishing a secure tunnel for protecting
      the authentication\n   method(s).  The confidentiality and integrity protection
      is defined\n   by TLS and provides the same security strengths afforded by TLS\n
      \  employing a strong entropy shared master secret.  The integrity of\n   the
      key generating authentication methods executed within the TEAP\n   tunnel is
      verified through the calculation of the Crypto-Binding TLV.\n   This ensures
      that the tunnel endpoints are the same as the inner\n   method endpoints.\n
      \  The Result TLV is protected and conveys the true Success or Failure\n   of
      TEAP, and it should be used as the indicator of its success or\n   failure respectively.
      \ However, as EAP terminates with either a\n   cleartext EAP Success or Failure,
      a peer will also receive a\n   cleartext EAP Success or Failure.  The received
      cleartext EAP Success\n   or Failure MUST match that received in the Result
      TLV; the peer\n   SHOULD silently discard those cleartext EAP Success or Failure\n
      \  messages that do not coincide with the status sent in the protected\n   Result
      TLV.\n"
    title: 7.1.  Mutual Authentication and Integrity Protection
  - contents:
    - "7.2.  Method Negotiation\n   As is true for any negotiated EAP protocol, NAK
      packets used to\n   suggest an alternate authentication method are sent unprotected
      and,\n   as such, are subject to spoofing.  During unprotected EAP method\n
      \  negotiation, NAK packets may be interjected as active attacks to\n   negotiate
      down to a weaker form of authentication, such as EAP-MD5\n   (which only provides
      one-way authentication and does not derive a\n   key).  Both the peer and server
      should have a method selection policy\n   that prevents them from negotiating
      down to weaker methods.  Inner\n   method negotiation resists attacks because
      it is protected by the\n   mutually authenticated TLS tunnel established.  Selection
      of TEAP as\n   an authentication method does not limit the potential inner\n
      \  authentication methods, so TEAP should be selected when available.\n   An
      attacker cannot readily determine the inner EAP method used,\n   except perhaps
      by traffic analysis.  It is also important that peer\n   implementations limit
      the use of credentials with an unauthenticated\n   or unauthorized server.\n"
    title: 7.2.  Method Negotiation
  - contents:
    - "7.3.  Separation of Phase 1 and Phase 2 Servers\n   Separation of the TEAP
      Phase 1 from the Phase 2 conversation is NOT\n   RECOMMENDED.  Allowing the
      Phase 1 conversation to be terminated at a\n   different server than the Phase
      2 conversation can introduce\n   vulnerabilities if there is not a proper trust
      relationship and\n   protection for the protocol between the two servers.  Some\n
      \  vulnerabilities include:\n   o  Loss of identity protection\n   o  Offline
      dictionary attacks\n   o  Lack of policy enforcement\n   o  Man-in-the-middle
      attacks (as described in [RFC7029])\n   There may be cases where a trust relationship
      exists between the\n   Phase 1 and Phase 2 servers, such as on a campus or between
      two\n   offices within the same company, where there is no danger in\n   revealing
      the inner identity and credentials of the peer to entities\n   between the two
      servers.  In these cases, using a proxy solution\n   without end-to-end protection
      of TEAP MAY be used.  The TEAP\n   encrypting/decrypting gateway MUST, at a
      minimum, provide support for\n   IPsec, TLS, or similar protection in order
      to provide confidentiality\n   for the portion of the conversation between the
      gateway and the EAP\n   server.  In addition, separation of the inner and outer
      method\n   servers allows for crypto-binding based on the inner method MSK to
      be\n   thwarted as described in [RFC7029].  Implementation and deployment\n
      \  SHOULD adopt various mitigation strategies described in [RFC7029].\n   If
      the inner method is deriving EMSK, then this threat is mitigated\n   as TEAP
      utilizes the mutual crypto-binding based on EMSK as described\n   in [RFC7029].\n"
    title: 7.3.  Separation of Phase 1 and Phase 2 Servers
  - contents:
    - "7.4.  Mitigation of Known Vulnerabilities and Protocol Deficiencies\n   TEAP
      addresses the known deficiencies and weaknesses in the EAP\n   method.  By employing
      a shared secret between the peer and server to\n   establish a secured tunnel,
      TEAP enables:\n   o  Per-packet confidentiality and integrity protection\n   o
      \ User identity protection\n   o  Better support for notification messages\n
      \  o  Protected EAP inner method negotiation\n   o  Sequencing of EAP methods\n
      \  o  Strong mutually derived MSKs\n   o  Acknowledged success/failure indication\n
      \  o  Faster re-authentications through session resumption\n   o  Mitigation
      of dictionary attacks\n   o  Mitigation of man-in-the-middle attacks\n   o  Mitigation
      of some denial-of-service attacks\n   It should be noted that in TEAP, as in
      many other authentication\n   protocols, a denial-of-service attack can be mounted
      by adversaries\n   sending erroneous traffic to disrupt the protocol.  This
      is a problem\n   in many authentication or key agreement protocols and is therefore\n
      \  noted for TEAP as well.\n   TEAP was designed with a focus on protected authentication
      methods\n   that typically rely on weak credentials, such as password-based\n
      \  secrets.  To that extent, the TEAP authentication mitigates several\n   vulnerabilities,
      such as dictionary attacks, by protecting the weak\n   credential-based authentication
      method.  The protection is based on\n   strong cryptographic algorithms in TLS
      to provide message\n   confidentiality and integrity.  The keys derived for
      the protection\n   relies on strong random challenges provided by both peer
      and server\n   as well as an established key with strong entropy.  Implementations\n
      \  should follow the recommendation in [RFC4086] when generating random\n   numbers.\n"
    - contents:
      - "7.4.1.  User Identity Protection and Verification\n   The initial identity
        request response exchange is sent in cleartext\n   outside the protection
        of TEAP.  Typically, the Network Access\n   Identifier (NAI) [RFC4282] in
        the identity response is useful only\n   for the realm of information that
        is used to route the authentication\n   requests to the right EAP server.
        \ This means that the identity\n   response may contain an anonymous identity
        and just contain realm\n   information.  In other cases, the identity exchange
        may be eliminated\n   altogether if there are other means for establishing
        the destination\n   realm of the request.  In no case should an intermediary
        place any\n   trust in the identity information in the identity response since
        it\n   is unauthenticated and may not have any relevance to the\n   authenticated
        identity.  TEAP implementations should not attempt to\n   compare any identity
        disclosed in the initial cleartext EAP Identity\n   response packet with those
        Identities authenticated in Phase 2.\n   Identity request/response exchanges
        sent after the TEAP tunnel is\n   established are protected from modification
        and eavesdropping by\n   attackers.\n   Note that since TLS client certificates
        are sent in the clear, if\n   identity protection is required, then it is
        possible for the TLS\n   authentication to be renegotiated after the first
        server\n   authentication.  To accomplish this, the server will typically
        not\n   request a certificate in the server_hello; then, after the\n   server_finished
        message is sent and before TEAP Phase 2, the server\n   MAY send a TLS hello_request.
        \ This allows the peer to perform client\n   authentication by sending a client_hello
        if it wants to or send a\n   no_renegotiation alert to the server indicating
        that it wants to\n   continue with TEAP Phase 2 instead.  Assuming that the
        peer permits\n   renegotiation by sending a client_hello, then the server
        will respond\n   with server_hello, certificate, and certificate_request messages.\n
        \  The peer replies with certificate, client_key_exchange, and\n   certificate_verify
        messages.  Since this renegotiation occurs within\n   the encrypted TLS channel,
        it does not reveal client certificate\n   details.  It is possible to perform
        certificate authentication using\n   an EAP method (for example, EAP-TLS)
        within the TLS session in TEAP\n   Phase 2 instead of using TLS handshake
        renegotiation.\n"
      title: 7.4.1.  User Identity Protection and Verification
    - contents:
      - "7.4.2.  Dictionary Attack Resistance\n   TEAP was designed with a focus on
        protected authentication methods\n   that typically rely on weak credentials,
        such as password-based\n   secrets.  TEAP mitigates dictionary attacks by
        allowing the\n   establishment of a mutually authenticated encrypted TLS tunnel\n
        \  providing confidentiality and integrity to protect the weak\n   credential-based
        authentication method.\n"
      title: 7.4.2.  Dictionary Attack Resistance
    - contents:
      - "7.4.3.  Protection against Man-in-the-Middle Attacks\n   Allowing methods
        to be executed both with and without the protection\n   of a secure tunnel
        opens up a possibility of a man-in-the-middle\n   attack.  To avoid man-in-the-middle
        attacks it is recommended to\n   always deploy authentication methods with
        the protection of TEAP.\n   TEAP provides protection from man-in-the-middle
        attacks even if a\n   deployment chooses to execute inner EAP methods both
        with and without\n   TEAP protection.  TEAP prevents this attack in two ways:\n
        \  1.  By using the PAC-Key to mutually authenticate the peer and server\n
        \      during TEAP authentication Phase 1 establishment of a secure\n       tunnel.\n
        \  2.  By using the keys generated by the inner authentication method\n       (if
        the inner methods are key generating) in the crypto-binding\n       exchange
        and in the generation of the key material exported by\n       the EAP method
        described in Section 5.\n   TEAP crypto binding does not guarantee man-in-the-middle
        protection\n   if the client allows a connection to an untrusted server, such
        as in\n   the case where the client does not properly validate the server's\n
        \  certificate.  If the TLS ciphersuite derives the master secret solely\n
        \  from the contribution of secret data from one side of the\n   conversation
        (such as ciphersuites based on RSA key transport), then\n   an attacker who
        can convince the client to connect and engage in\n   authentication can impersonate
        the client to another server even if a\n   strong inner method is executed
        within the tunnel.  If the TLS\n   ciphersuite derives the master secret from
        the contribution of\n   secrets from both sides of the conversation (such
        as in ciphersuites\n   based on Diffie-Hellman), then crypto binding can detect
        an attacker\n   in the conversation if a strong inner method is used.\n"
      title: 7.4.3.  Protection against Man-in-the-Middle Attacks
    - contents:
      - "7.4.4.  PAC Binding to User Identity\n   A PAC may be bound to a user identity.
        \ A compliant implementation of\n   TEAP MUST validate that an identity obtained
        in the PAC-Opaque field\n   matches at minimum one of the identities provided
        in the TEAP Phase 2\n   authentication method.  This validation provides another
        binding to\n   ensure that the intended peer (based on identity) has successfully\n
        \  completed the TEAP Phase 1 and proved identity in the Phase 2\n   conversations.\n"
      title: 7.4.4.  PAC Binding to User Identity
    title: 7.4.  Mitigation of Known Vulnerabilities and Protocol Deficiencies
  - contents:
    - "7.5.  Protecting against Forged Cleartext EAP Packets\n   EAP Success and EAP
      Failure packets are, in general, sent in\n   cleartext and may be forged by
      an attacker without detection.  Forged\n   EAP Failure packets can be used to
      attempt to convince an EAP peer to\n   disconnect.  Forged EAP Success packets
      may be used to attempt to\n   convince a peer that authentication has succeeded,
      even though the\n   authenticator has not authenticated itself to the peer.\n
      \  By providing message confidentiality and integrity, TEAP provides\n   protection
      against these attacks.  Once the peer and authentication\n   server (AS) initiate
      the TEAP authentication Phase 2, compliant TEAP\n   implementations MUST silently
      discard all cleartext EAP messages,\n   unless both the TEAP peer and server
      have indicated success or\n   failure using a protected mechanism.  Protected
      mechanisms include\n   the TLS alert mechanism and the protected termination
      mechanism\n   described in Section 3.3.3.\n   The success/failure decisions
      within the TEAP tunnel indicate the\n   final decision of the TEAP authentication
      conversation.  After a\n   success/failure result has been indicated by a protected
      mechanism,\n   the TEAP peer can process unprotected EAP Success and EAP Failure\n
      \  messages; however, the peer MUST ignore any unprotected EAP Success\n   or
      Failure messages where the result does not match the result of the\n   protected
      mechanism.\n   To abide by [RFC3748], the server sends a cleartext EAP Success
      or\n   EAP Failure packet to terminate the EAP conversation.  However, since\n
      \  EAP Success and EAP Failure packets are not retransmitted, the final\n   packet
      may be lost.  While a TEAP-protected EAP Success or EAP\n   Failure packet should
      not be a final packet in a TEAP conversation,\n   it may occur based on the
      conditions stated above, so an EAP peer\n   should not rely upon the unprotected
      EAP Success and Failure\n   messages.\n"
    title: 7.5.  Protecting against Forged Cleartext EAP Packets
  - contents:
    - "7.6.  Server Certificate Validation\n   As part of the TLS negotiation, the
      server presents a certificate to\n   the peer.  The peer SHOULD verify the validity
      of the EAP server\n   certificate and SHOULD also examine the EAP server name
      presented in\n   the certificate in order to determine whether the EAP server
      can be\n   trusted.  When performing server certificate validation,\n   implementations
      MUST provide support for the rules in [RFC5280] for\n   validating certificates
      against a known trust anchor.  In addition,\n   implementations MUST support
      matching the realm portion of the peer's\n   NAI against a SubjectAltName of
      type dNSName within the server\n   certificate.  However, in certain deployments,
      this might not be\n   turned on.  Please note that in the case where the EAP
      authentication\n   is remote, the EAP server will not reside on the same machine
      as the\n   authenticator, and therefore, the name in the EAP server's\n   certificate
      cannot be expected to match that of the intended\n   destination.  In this case,
      a more appropriate test might be whether\n   the EAP server's certificate is
      signed by a certification authority\n   (CA) controlling the intended domain
      and whether the authenticator\n   can be authorized by a server in that domain.\n"
    title: 7.6.  Server Certificate Validation
  - contents:
    - "7.7.  Tunnel PAC Considerations\n   Since the Tunnel PAC is stored by the peer,
      special care should be\n   given to the overall security of the peer.  The Tunnel
      PAC MUST be\n   securely stored by the peer to prevent theft or forgery of any
      of the\n   Tunnel PAC components.  In particular, the peer MUST securely store\n
      \  the PAC-Key and protect it from disclosure or modification.\n   Disclosure
      of the PAC-Key enables an attacker to establish the TEAP\n   tunnel; however,
      disclosure of the PAC-Key does not reveal the peer\n   or server identity or
      compromise any other peer's PAC credentials.\n   Modification of the PAC-Key
      or PAC-Opaque components of the Tunnel\n   PAC may also lead to denial of service
      as the tunnel establishment\n   will fail.  The PAC-Opaque component is the
      effective TLS ticket\n   extension used to establish the tunnel using the techniques
      of\n   [RFC5077].  Thus, the security considerations defined by [RFC5077]\n
      \  also apply to the PAC-Opaque.  The PAC-Info may contain information\n   about
      the Tunnel PAC such as the identity of the PAC issuer and the\n   Tunnel PAC
      lifetime for use in the management of the Tunnel PAC.  The\n   PAC-Info should
      be securely stored by the peer to protect it from\n   disclosure and modification.\n"
    title: 7.7.  Tunnel PAC Considerations
  - contents:
    - "7.8.  Security Claims\n   This section provides the needed security claim requirement
      for EAP\n   [RFC3748].\n   Auth. mechanism:         Certificate-based, shared-secret-based,
      and\n                            various tunneled authentication mechanisms.\n
      \  Ciphersuite negotiation: Yes\n   Mutual authentication:   Yes\n   Integrity
      protection:    Yes.  Any method executed within the TEAP\n                            tunnel
      is integrity protected.  The\n                            cleartext EAP headers
      outside the tunnel are\n                            not integrity protected.\n
      \  Replay protection:       Yes\n   Confidentiality:         Yes\n   Key derivation:
      \         Yes\n   Key strength:            See Note 1 below.\n   Dictionary
      attack prot.: Yes\n   Fast reconnect:          Yes\n   Cryptographic binding:
      \  Yes\n   Session independence:    Yes\n   Fragmentation:           Yes\n   Key
      Hierarchy:           Yes\n   Channel binding:         Yes\n   Notes\n   1.  BCP
      86 [RFC3766] offers advice on appropriate key sizes.  The\n       National Institute
      for Standards and Technology (NIST) also\n       offers advice on appropriate
      key sizes in [NIST-SP-800-57].\n       [RFC3766], Section 5 advises use of the
      following required RSA or\n       DH (Diffie-Hellman) module and DSA (Digital
      Signature Algorithm)\n       subgroup size in bits for a given level of attack
      resistance in\n       bits.  Based on the table below, a 2048-bit RSA key is
      required\n       to provide 112-bit equivalent key strength:\n       Attack
      Resistance     RSA or DH Modulus            DSA subgroup\n        (bits)                  size
      (bits)                size (bits)\n       -----------------     -----------------
      \           ------------\n          70                        947                        129\n
      \         80                       1228                        148\n          90
      \                      1553                        167\n         100                       1926
      \                       186\n         150                       4575                        284\n
      \        200                       8719                        383\n         250
      \                     14596                        482\n"
    title: 7.8.  Security Claims
  title: 7.  Security Considerations
- contents:
  - "8.  Acknowledgements\n   This specification is based on EAP-FAST [RFC4851], which
    included the\n   ideas and efforts of Nancy Cam-Winget, David McGrew, Joe Salowey,
    Hao\n   Zhou, Pad Jakkahalli, Mark Krischer, Doug Smith, and Glen Zorn of\n   Cisco
    Systems, Inc.\n   The TLV processing was inspired from work on the Protected Extensible\n
    \  Authentication Protocol version 2 (PEAPv2) with Ashwin Palekar, Dan\n   Smith,
    Sean Turner, and Simon Josefsson.\n   The method for linking identity and proof-of-possession
    by placing\n   the tls-unique value in the challengePassword field of the CSR
    as\n   described in Section 3.8.2 was inspired by the technique described in\n
    \  \"Enrollment over Secure Transport\" [RFC7030].\n   Helpful review comments
    were provided by Russ Housley, Jari Arkko,\n   Ilan Frenkel, Jeremy Steiglitz,
    Dan Harkins, Sam Hartman, Jim Schaad,\n   Barry Leiba, Stephen Farrell, Chris
    Lonvick, and Josh Howlett.\n"
  title: 8.  Acknowledgements
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC3748]  Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and
      H.\n              Levkowetz, \"Extensible Authentication Protocol (EAP)\", RFC\n
      \             3748, June 2004.\n   [RFC5077]  Salowey, J., Zhou, H., Eronen,
      P., and H. Tschofenig,\n              \"Transport Layer Security (TLS) Session
      Resumption without\n              Server-Side State\", RFC 5077, January 2008.\n
      \  [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA
      Considerations Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246, August 2008.\n   [RFC5295]  Salowey, J., Dondeti,
      L., Narayanan, V., and M. Nakhjiri,\n              \"Specification for the Derivation
      of Root Keys from an\n              Extended Master Session Key (EMSK)\", RFC
      5295, August\n              2008.\n   [RFC5705]  Rescorla, E., \"Keying Material
      Exporters for Transport\n              Layer Security (TLS)\", RFC 5705, March
      2010.\n   [RFC5746]  Rescorla, E., Ray, M., Dispensa, S., and N. Oskov,\n              \"Transport
      Layer Security (TLS) Renegotiation Indication\n              Extension\", RFC
      5746, February 2010.\n   [RFC5929]  Altman, J., Williams, N., and L. Zhu, \"Channel
      Bindings\n              for TLS\", RFC 5929, July 2010.\n   [RFC6677]  Hartman,
      S., Clancy, T., and K. Hoeper, \"Channel-Binding\n              Support for
      Extensible Authentication Protocol (EAP)\n              Methods\", RFC 6677,
      July 2012.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [IEEE.802-1X.2013]\n              IEEE, \"Local
      and Metropolitan Area Networks: Port-Based\n              Network Access Control\",
      IEEE Standard 802.1X, December\n              2013.\n   [NIST-SP-800-57]\n              National
      Institute of Standards and Technology,\n              \"Recommendation for Key
      Management\", NIST Special\n              Publication 800-57, July 2012.\n   [PEAP]
      \    Microsoft Corporation, \"[MS-PEAP]: Protected Extensible\n              Authentication
      Protocol (PEAP)\", February 2014.\n   [RFC2315]  Kaliski, B., \"PKCS #7: Cryptographic
      Message Syntax\n              Version 1.5\", RFC 2315, March 1998.\n   [RFC2985]
      \ Nystrom, M. and B. Kaliski, \"PKCS #9: Selected Object\n              Classes
      and Attribute Types Version 2.0\", RFC 2985,\n              November 2000.\n
      \  [RFC2986]  Nystrom, M. and B. Kaliski, \"PKCS #10: Certification\n              Request
      Syntax Specification Version 1.7\", RFC 2986,\n              November 2000.\n
      \  [RFC3579]  Aboba, B. and P. Calhoun, \"RADIUS (Remote Authentication\n              Dial
      In User Service) Support For Extensible\n              Authentication Protocol
      (EAP)\", RFC 3579, September 2003.\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation
      format of ISO\n              10646\", STD 63, RFC 3629, November 2003.\n   [RFC3766]
      \ Orman, H. and P. Hoffman, \"Determining Strengths For\n              Public
      Keys Used For Exchanging Symmetric Keys\", BCP 86,\n              RFC 3766,
      April 2004.\n   [RFC4017]  Stanley, D., Walker, J., and B. Aboba, \"Extensible\n
      \             Authentication Protocol (EAP) Method Requirements for\n              Wireless
      LANs\", RFC 4017, March 2005.\n   [RFC4072]  Eronen, P., Hiller, T., and G.
      Zorn, \"Diameter Extensible\n              Authentication Protocol (EAP) Application\",
      RFC 4072,\n              August 2005.\n   [RFC4086]  Eastlake, D., Schiller,
      J., and S. Crocker, \"Randomness\n              Requirements for Security\",
      BCP 106, RFC 4086, June 2005.\n   [RFC4282]  Aboba, B., Beadles, M., Arkko,
      J., and P. Eronen, \"The\n              Network Access Identifier\", RFC 4282,
      December 2005.\n   [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64
      Data\n              Encodings\", RFC 4648, October 2006.\n   [RFC4851]  Cam-Winget,
      N., McGrew, D., Salowey, J., and H. Zhou, \"The\n              Flexible Authentication
      via Secure Tunneling Extensible\n              Authentication Protocol Method
      (EAP-FAST)\", RFC 4851, May\n              2007.\n   [RFC4945]  Korver, B.,
      \"The Internet IP Security PKI Profile of IKEv1\n              /ISAKMP, IKEv2,
      and PKIX\", RFC 4945, August 2007.\n   [RFC4962]  Housley, R. and B. Aboba,
      \"Guidance for Authentication,\n              Authorization, and Accounting
      (AAA) Key Management\", BCP\n              132, RFC 4962, July 2007.\n   [RFC5247]
      \ Aboba, B., Simon, D., and P. Eronen, \"Extensible\n              Authentication
      Protocol (EAP) Key Management Framework\",\n              RFC 5247, August 2008.\n
      \  [RFC5272]  Schaad, J. and M. Myers, \"Certificate Management over CMS\n              (CMC)\",
      RFC 5272, June 2008.\n   [RFC5280]  Cooper, D., Santesson, S., Farrell, S.,
      Boeyen, S.,\n              Housley, R., and W. Polk, \"Internet X.509 Public
      Key\n              Infrastructure Certificate and Certificate Revocation List\n
      \             (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5281]  Funk, P. and
      S. Blake-Wilson, \"Extensible Authentication\n              Protocol Tunneled
      Transport Layer Security Authenticated\n              Protocol Version 0 (EAP-TTLSv0)\",
      RFC 5281, August 2008.\n   [RFC5421]  Cam-Winget, N. and H. Zhou, \"Basic Password
      Exchange\n              within the Flexible Authentication via Secure Tunneling\n
      \             Extensible Authentication Protocol (EAP-FAST)\", RFC 5421,\n              March
      2009.\n   [RFC5652]  Housley, R., \"Cryptographic Message Syntax (CMS)\", STD
      70,\n              RFC 5652, September 2009.\n   [RFC5931]  Harkins, D. and
      G. Zorn, \"Extensible Authentication\n              Protocol (EAP) Authentication
      Using Only a Password\", RFC\n              5931, August 2010.\n   [RFC6066]
      \ Eastlake, D., \"Transport Layer Security (TLS) Extensions:\n              Extension
      Definitions\", RFC 6066, January 2011.\n   [RFC6124]  Sheffer, Y., Zorn, G.,
      Tschofenig, H., and S. Fluhrer, \"An\n              EAP Authentication Method
      Based on the Encrypted Key\n              Exchange (EKE) Protocol\", RFC 6124,
      February 2011.\n   [RFC6678]  Hoeper, K., Hanna, S., Zhou, H., and J. Salowey,\n
      \             \"Requirements for a Tunnel-Based Extensible Authentication\n
      \             Protocol (EAP) Method\", RFC 6678, July 2012.\n   [RFC6960]  Santesson,
      S., Myers, M., Ankney, R., Malpani, A.,\n              Galperin, S., and C.
      Adams, \"X.509 Internet Public Key\n              Infrastructure Online Certificate
      Status Protocol - OCSP\",\n              RFC 6960, June 2013.\n   [RFC6961]
      \ Pettersen, Y., \"The Transport Layer Security (TLS)\n              Multiple
      Certificate Status Request Extension\", RFC 6961,\n              June 2013.\n
      \  [RFC7029]  Hartman, S., Wasserman, M., and D. Zhang, \"Extensible\n              Authentication
      Protocol (EAP) Mutual Cryptographic\n              Binding\", RFC 7029, October
      2013.\n   [RFC7030]  Pritikin, M., Yee, P., and D. Harkins, \"Enrollment over\n
      \             Secure Transport\", RFC 7030, October 2013.\n   [X.690]    ITU-T,
      \"ASN.1 encoding rules: Specification of Basic\n              Encoding Rules
      (BER), Canonical Encoding Rules (CER) and\n              Distinguished Encoding
      Rules (DER)\", ITU-T Recommendation\n              X.690, November 2008.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Appendix A.  Evaluation against Tunnel-Based EAP Method Requirements\n   This
    section evaluates all tunnel-based EAP method requirements\n   described in [RFC6678]
    against TEAP version 1.\n"
  - contents:
    - "A.1.  Requirement 4.1.1: RFC Compliance\n   TEAPv1 meets this requirement by
      being compliant with RFC 3748\n   [RFC3748], RFC 4017 [RFC4017], RFC 5247 [RFC5247],
      and RFC 4962\n   [RFC4962].  It is also compliant with the \"cryptographic algorithm\n
      \  agility\" requirement by leveraging TLS 1.2 for all cryptographic\n   algorithm
      negotiation.\n"
    title: 'A.1.  Requirement 4.1.1: RFC Compliance'
  - contents:
    - "A.2.  Requirement 4.2.1: TLS Requirements\n   TEAPv1 meets this requirement
      by mandating TLS version 1.2 support as\n   defined in Section 3.2.\n"
    title: 'A.2.  Requirement 4.2.1: TLS Requirements'
  - contents:
    - "A.3.  Requirement 4.2.1.1.1: Ciphersuite Negotiation\n   TEAPv1 meets this
      requirement by using TLS to provide protected\n   ciphersuite negotiation.\n"
    title: 'A.3.  Requirement 4.2.1.1.1: Ciphersuite Negotiation'
  - contents:
    - "A.4.  Requirement 4.2.1.1.2: Tunnel Data Protection Algorithms\n   TEAPv1 meets
      this requirement by mandating\n   TLS_RSA_WITH_AES_128_CBC_SHA as a mandatory-to-implement
      ciphersuite\n   as defined in Section 3.2.\n"
    title: 'A.4.  Requirement 4.2.1.1.2: Tunnel Data Protection Algorithms'
  - contents:
    - "A.5.  Requirement 4.2.1.1.3: Tunnel Authentication and Key Establishment\n
      \  TEAPv1 meets this requirement by mandating\n   TLS_RSA_WITH_AES_128_CBC_SHA
      as a mandatory-to-implement ciphersuite\n   that provides certificate-based
      authentication of the server and is\n   approved by NIST.  The mandatory-to-implement
      ciphersuites only\n   include ciphersuites that use strong cryptographic algorithms.
      \ They\n   do not include ciphersuites providing mutually anonymous\n   authentication
      or static Diffie-Hellman ciphersuites as defined in\n   Section 3.2.\n"
    title: 'A.5.  Requirement 4.2.1.1.3: Tunnel Authentication and Key Establishment'
  - contents:
    - "A.6.  Requirement 4.2.1.2: Tunnel Replay Protection\n   TEAPv1 meets this requirement
      by using TLS to provide sufficient\n   replay protection.\n"
    title: 'A.6.  Requirement 4.2.1.2: Tunnel Replay Protection'
  - contents:
    - "A.7.  Requirement 4.2.1.3: TLS Extensions\n   TEAPv1 meets this requirement
      by allowing TLS extensions, such as TLS\n   Certificate Status Request extension
      [RFC6066] and SessionTicket\n   extension [RFC5077], to be used during TLS tunnel
      establishment.\n"
    title: 'A.7.  Requirement 4.2.1.3: TLS Extensions'
  - contents:
    - "A.8.  Requirement 4.2.1.4: Peer Identity Privacy\n   TEAPv1 meets this requirement
      by establishment of the TLS tunnel and\n   protection identities specific to
      the inner method.  In addition, the\n   peer certificate can be sent confidentially
      (i.e., encrypted).\n"
    title: 'A.8.  Requirement 4.2.1.4: Peer Identity Privacy'
  - contents:
    - "A.9.  Requirement 4.2.1.5: Session Resumption\n   TEAPv1 meets this requirement
      by mandating support of TLS session\n   resumption as defined in Section 3.2.1
      and TLS session resume using a\n   PAC as defined in Section 3.2.2 .\n"
    title: 'A.9.  Requirement 4.2.1.5: Session Resumption'
  - contents:
    - "A.10.  Requirement 4.2.2: Fragmentation\n   TEAPv1 meets this requirement by
      leveraging fragmentation support\n   provided by TLS as defined in Section 3.7.\n"
    title: 'A.10.  Requirement 4.2.2: Fragmentation'
  - contents:
    - "A.11.  Requirement 4.2.3: Protection of Data External to Tunnel\n   TEAPv1
      meets this requirement by including the TEAP version number\n   received in
      the computation of the Crypto-Binding TLV as defined in\n   Section 4.2.13.\n"
    title: 'A.11.  Requirement 4.2.3: Protection of Data External to Tunnel'
  - contents:
    - "A.12.  Requirement 4.3.1: Extensible Attribute Types\n   TEAPv1 meets this
      requirement by using an extensible TLV data layer\n   inside the tunnel as defined
      in Section 4.2.\n"
    title: 'A.12.  Requirement 4.3.1: Extensible Attribute Types'
  - contents:
    - "A.13.  Requirement 4.3.2: Request/Challenge Response Operation\n   TEAPv1 meets
      this requirement by allowing multiple TLVs to be sent in\n   a single EAP request
      or response packet, while maintaining the half-\n   duplex operation typical
      of EAP.\n"
    title: 'A.13.  Requirement 4.3.2: Request/Challenge Response Operation'
  - contents:
    - "A.14.  Requirement 4.3.3: Indicating Criticality of Attributes\n   TEAPv1 meets
      this requirement by having a mandatory bit in each TLV\n   to indicate whether
      it is mandatory to support or not as defined in\n   Section 4.2.\n"
    title: 'A.14.  Requirement 4.3.3: Indicating Criticality of Attributes'
  - contents:
    - "A.15.  Requirement 4.3.4: Vendor-Specific Support\n   TEAPv1 meets this requirement
      by having a Vendor-Specific TLV to\n   allow vendors to define their own attributes
      as defined in\n   Section 4.2.8.\n"
    title: 'A.15.  Requirement 4.3.4: Vendor-Specific Support'
  - contents:
    - "A.16.  Requirement 4.3.5: Result Indication\n   TEAPv1 meets this requirement
      by having a Result TLV to exchange the\n   final result of the EAP authentication
      so both the peer and server\n   have a synchronized state as defined in Section
      4.2.4.\n"
    title: 'A.16.  Requirement 4.3.5: Result Indication'
  - contents:
    - "A.17.  Requirement 4.3.6: Internationalization of Display Strings\n   TEAPv1
      meets this requirement by supporting UTF-8 format in the\n   Basic-Password-Auth-Req
      TLV as defined in Section 4.2.14 and the\n   Basic-Password-Auth-Resp TLV as
      defined in Section 4.2.15.\n"
    title: 'A.17.  Requirement 4.3.6: Internationalization of Display Strings'
  - contents:
    - "A.18.  Requirement 4.4: EAP Channel-Binding Requirements\n   TEAPv1 meets this
      requirement by having a Channel-Binding TLV to\n   exchange the EAP channel-binding
      data as defined in Section 4.2.7.\n"
    title: 'A.18.  Requirement 4.4: EAP Channel-Binding Requirements'
  - contents:
    - "A.19.  Requirement 4.5.1.1: Confidentiality and Integrity\n   TEAPv1 meets
      this requirement by running the password authentication\n   inside a protected
      TLS tunnel.\n"
    title: 'A.19.  Requirement 4.5.1.1: Confidentiality and Integrity'
  - contents:
    - "A.20.  Requirement 4.5.1.2: Authentication of Server\n   TEAPv1 meets this
      requirement by mandating authentication of the\n   server before establishment
      of the protected TLS and then running\n   inner password authentication as defined
      in Section 3.2.\n"
    title: 'A.20.  Requirement 4.5.1.2: Authentication of Server'
  - contents:
    - "A.21.  Requirement 4.5.1.3: Server Certificate Revocation Checking\n   TEAPv1
      meets this requirement by supporting TLS Certificate Status\n   Request extension
      [RFC6066] during tunnel establishment.\n"
    title: 'A.21.  Requirement 4.5.1.3: Server Certificate Revocation Checking'
  - contents:
    - "A.22.  Requirement 4.5.2: Internationalization\n   TEAPv1 meets this requirement
      by supporting UTF-8 format in Basic-\n   Password-Auth-Req TLV as defined in
      Section 4.2.14 and Basic-\n   Password-Auth-Resp TLV as defined in Section 4.2.15.\n"
    title: 'A.22.  Requirement 4.5.2: Internationalization'
  - contents:
    - "A.23.  Requirement 4.5.3: Metadata\n   TEAPv1 meets this requirement by supporting
      Identity-Type TLV as\n   defined in Section 4.2.3 to indicate whether the authentication
      is\n   for a user or a machine.\n"
    title: 'A.23.  Requirement 4.5.3: Metadata'
  - contents:
    - "A.24.  Requirement 4.5.4: Password Change\n   TEAPv1 meets this requirement
      by supporting multiple Basic-Password-\n   Auth-Req TLV and Basic-Password-Auth-Resp
      TLV exchanges within a\n   single EAP authentication, which allows \"housekeeping\"\"
      functions\n   such as password change.\n"
    title: 'A.24.  Requirement 4.5.4: Password Change'
  - contents:
    - "A.25.  Requirement 4.6.1: Method Negotiation\n   TEAPv1 meets this requirement
      by supporting inner EAP method\n   negotiation within the protected TLS tunnel.\n"
    title: 'A.25.  Requirement 4.6.1: Method Negotiation'
  - contents:
    - "A.26.  Requirement 4.6.2: Chained Methods\n   TEAPv1 meets this requirement
      by supporting inner EAP method chaining\n   within protected TLS tunnels as
      defined in Section 3.3.1.\n"
    title: 'A.26.  Requirement 4.6.2: Chained Methods'
  - contents:
    - "A.27.  Requirement 4.6.3: Cryptographic Binding with the TLS Tunnel\n   TEAPv1
      meets this requirement by supporting cryptographic binding of\n   the inner
      EAP method keys with the keys derived from the TLS tunnel\n   as defined in
      Section 4.2.13.\n"
    title: 'A.27.  Requirement 4.6.3: Cryptographic Binding with the TLS Tunnel'
  - contents:
    - "A.28.  Requirement 4.6.4: Peer-Initiated EAP Authentication\n   TEAPv1 meets
      this requirement by supporting the Request-Action TLV as\n   defined in Section
      4.2.9 to allow a peer to initiate another inner\n   EAP method.\n"
    title: 'A.28.  Requirement 4.6.4: Peer-Initiated EAP Authentication'
  - contents:
    - "A.29.  Requirement 4.6.5: Method Metadata\n   TEAPv1 meets this requirement
      by supporting the Identity-Type TLV as\n   defined in Section 4.2.3 to indicate
      whether the authentication is\n   for a user or a machine.\n"
    title: 'A.29.  Requirement 4.6.5: Method Metadata'
  title: Appendix A.  Evaluation against Tunnel-Based EAP Method Requirements
- contents:
  - "Appendix B.  Major Differences from EAP-FAST\n   This document is a new standard
    tunnel EAP method based on revision\n   of EAP-FAST version 1 [RFC4851] that contains
    improved flexibility,\n   particularly for negotiation of cryptographic algorithms.
    \ The major\n   changes are:\n   1.  The EAP method name has been changed from
    EAP-FAST to TEAP; this\n       change thus requires that a new EAP Type be assigned.\n
    \  2.  This version of TEAP MUST support TLS 1.2 [RFC5246].\n   3.  The key derivation
    now makes use of TLS keying material exporters\n       [RFC5705] and the PRF and
    hash function negotiated in TLS.  This\n       is to simplify implementation and
    better support cryptographic\n       algorithm agility.\n   4.  TEAP is in full
    conformance with TLS ticket extension [RFC5077]\n       as described in Section
    3.2.2.\n   5.  Support is provided for passing optional Outer TLVs in the first\n
    \      two message exchanges, in addition to the Authority-ID TLV data\n       in
    EAP-FAST.\n   6.  Basic password authentication on the TLV level has been added
    in\n       addition to the existing inner EAP method.\n   7.  Additional TLV types
    have been defined to support EAP channel\n       binding and metadata.  They are
    the Identity-Type TLV and\n       Channel-Binding TLVs, defined in Section 4.2.\n"
  title: Appendix B.  Major Differences from EAP-FAST
- contents:
  - 'Appendix C.  Examples

    '
  - contents:
    - "C.1.  Successful Authentication\n   The following exchanges show a successful
      TEAP authentication with\n   basic password authentication and optional PAC
      refreshment.  The\n   conversation will appear as follows:\n       Authenticating
      Peer     Authenticator\n       -------------------     -------------\n                               <-
      EAP-Request/\n                               Identity\n       EAP-Response/\n
      \      Identity (MyID1) ->\n                               <- EAP-Request/\n
      \                              EAP-Type=TEAP, V=1\n                               (TEAP
      Start, S bit set, Authority-ID)\n       EAP-Response/\n       EAP-Type=TEAP,
      V=1\n       (TLS client_hello with\n        PAC-Opaque in SessionTicket extension)->\n
      \                              <- EAP-Request/\n                               EAP-Type=TEAP,
      V=1\n                               (TLS server_hello,\n                               (TLS
      change_cipher_spec,\n                                TLS finished)\n       EAP-Response/\n
      \      EAP-Type=TEAP, V=1 ->\n       (TLS change_cipher_spec,\n        TLS finished)\n
      \      TLS channel established\n       (messages sent within the TLS channel)\n
      \                             <- Basic-Password-Auth-Req TLV, Challenge\n       Basic-Password-Auth-Resp
      TLV, Response with both\n       username and password) ->\n       optional additional
      exchanges (new pin mode,\n       password change, etc.) ...\n                            <-
      Crypto-Binding TLV (Request),\n                                Result TLV (Success),\n
      \                               (Optional PAC TLV)\n       Crypto-Binding TLV(Response),\n
      \      Result TLV (Success),\n       (PAC-Acknowledgement TLV) ->\n       TLS
      channel torn down\n       (messages sent in cleartext)\n                               <-
      EAP-Success\n"
    title: C.1.  Successful Authentication
  - contents:
    - "C.2.  Failed Authentication\n   The following exchanges show a failed TEAP
      authentication due to\n   wrong user credentials.  The conversation will appear
      as follows:\n       Authenticating Peer     Authenticator\n       -------------------
      \    -------------\n                               <- EAP-Request/Identity\n
      \      EAP-Response/\n       Identity (MyID1) ->\n                               <-
      EAP-Request/\n                               EAP-Type=TEAP, V=1\n                               (TEAP
      Start, S bit set, Authority-ID)\n       EAP-Response/\n       EAP-Type=TEAP,
      V=1\n       (TLS client_hello with\n        PAC-Opaque in SessionTicket extension)->\n
      \                              <- EAP-Request/\n                               EAP-Type=TEAP,
      V=1\n                               (TLS server_hello,\n                               (TLS
      change_cipher_spec,\n                                TLS finished)\n       EAP-Response/\n
      \      EAP-Type=TEAP, V=1 ->\n       (TLS change_cipher_spec,\n        TLS finished)\n
      \      TLS channel established\n       (messages sent within the TLS channel)\n
      \                             <- Basic-Password-Auth-Req TLV, Challenge\n       Basic-Password-Auth-Resp
      TLV, Response with both\n       username and password) ->\n                               <-
      Result TLV (Failure)\n       Result TLV (Failure) ->\n       TLS channel torn
      down\n       (messages sent in cleartext)\n                               <-
      EAP-Failure\n"
    title: C.2.  Failed Authentication
  - contents:
    - "C.3.  Full TLS Handshake Using Certificate-Based Ciphersuite\n   In the case
      within TEAP Phase 1 where an abbreviated TLS handshake is\n   tried, fails,
      and falls back to the certificate-based full TLS\n   handshake, the conversation
      will appear as follows:\n      Authenticating Peer    Authenticator\n      -------------------
      \   -------------\n                             <- EAP-Request/Identity\n      EAP-Response/\n
      \     Identity (MyID1) ->\n      // Identity sent in the clear.  May be a hint
      to help route\n         the authentication request to EAP server, instead of
      the\n         full user identity.\n                              <- EAP-Request/\n
      \                             EAP-Type=TEAP, V=1\n                              (TEAP
      Start, S bit set, Authority-ID)\n      EAP-Response/\n      EAP-Type=TEAP, V=1\n
      \     (TLS client_hello with\n      PAC-Opaque in SessionTicket extension)->\n
      \     // Peer sends PAC-Opaque of Tunnel PAC along with a list of\n         ciphersuites
      supported.  If the server rejects the PAC-\n         Opaque, it falls through
      to the full TLS handshake.\n                              <- EAP-Request/\n
      \                             EAP-Type=TEAP, V=1\n                              (TLS
      server_hello,\n                               TLS certificate,\n                              [TLS
      server_key_exchange,]\n                              [TLS certificate_request,]\n
      \                              TLS server_hello_done)\n      EAP-Response/\n
      \     EAP-Type=TEAP, V=1\n      ([TLS certificate,]\n       TLS client_key_exchange,\n
      \     [TLS certificate_verify,]\n       TLS change_cipher_spec,\n       TLS
      finished) ->\n                              <- EAP-Request/\n                              EAP-Type=TEAP,
      V=1\n                              (TLS change_cipher_spec,\n                               TLS
      finished,\n                               EAP-Payload-TLV[EAP-Request/\n                               Identity])\n
      \     // TLS channel established\n         (messages sent within the TLS channel)\n
      \     // First EAP Payload TLV is piggybacked to the TLS Finished as\n         Application
      Data and protected by the TLS tunnel.\n      EAP-Payload-TLV\n      [EAP-Response/Identity
      (MyID2)]->\n      // identity protected by TLS.\n                               <-
      EAP-Payload-TLV\n                               [EAP-Request/EAP-Type=X]\n      EAP-Payload-TLV\n
      \     [EAP-Response/EAP-Type=X] ->\n      // Method X exchanges followed by
      Protected Termination\n                           <- Intermediate-Result-TLV
      (Success),\n                               Crypto-Binding TLV (Request),\n                               Result
      TLV (Success)\n      Intermediate-Result-TLV (Success),\n      Crypto-Binding
      TLV (Response),\n      Result-TLV (Success) ->\n      // TLS channel torn down\n
      \     (messages sent in cleartext)\n                              <- EAP-Success\n"
    title: C.3.  Full TLS Handshake Using Certificate-Based Ciphersuite
  - contents:
    - "C.4.  Client Authentication during Phase 1 with Identity Privacy\n   In the
      case where a certificate-based TLS handshake occurs within\n   TEAP Phase 1
      and client certificate authentication and identity\n   privacy is desired (and
      therefore TLS renegotiation is being used to\n   transmit the peer credentials
      in the protected TLS tunnel), the\n   conversation will appear as follows:\n
      \     Authenticating Peer     Authenticator\n      -------------------     -------------\n
      \                            <- EAP-Request/Identity\n      EAP-Response/\n
      \     Identity (MyID1) ->\n      // Identity sent in the clear.  May be a hint
      to help route\n         the authentication request to EAP server, instead of
      the\n         full user identity.\n                              <- EAP-Request/\n
      \                             EAP-Type=TEAP, V=1\n                              (TEAP
      Start, S bit set, Authority-ID)\n      EAP-Response/\n      EAP-Type=TEAP, V=1\n
      \     (TLS client_hello)->\n                              <- EAP-Request/\n
      \                             EAP-Type=TEAP, V=1\n                              (TLS
      server_hello,\n                               TLS certificate,\n                              [TLS
      server_key_exchange,]\n                              [TLS certificate_request,]\n
      \                              TLS server_hello_done)\n      EAP-Response/\n
      \     EAP-Type=TEAP, V=1\n      (TLS client_key_exchange,\n       TLS change_cipher_spec,\n
      \      TLS finished) ->\n                              <- EAP-Request/\n                              EAP-Type=TEAP,
      V=1\n                              (TLS change_cipher_spec,\n                               TLS
      finished,\n                               EAP-Payload-TLV[EAP-Request/\n                               Identity])\n
      \     // TLS channel established\n         (EAP Payload messages sent within
      the TLS channel)\n      // peer sends TLS client_hello to request TLS renegotiation\n
      \     TLS client_hello ->\n                              <- TLS server_hello,\n
      \                              TLS certificate,\n                               [TLS
      server_key_exchange,]\n                               [TLS certificate_request,]\n
      \                              TLS server_hello_done\n      [TLS certificate,]\n
      \      TLS client_key_exchange,\n      [TLS certificate_verify,]\n       TLS
      change_cipher_spec,\n       TLS finished ->\n                              <-
      TLS change_cipher_spec,\n                                 TLS finished,\n                                 Crypto-Binding
      TLV (Request),\n                                 Result TLV (Success)\n      Crypto-Binding
      TLV (Response),\n      Result-TLV (Success)) ->\n      //TLS channel torn down\n
      \     (messages sent in cleartext)\n                              <- EAP-Success\n"
    title: C.4.  Client Authentication during Phase 1 with Identity Privacy
  - contents:
    - "C.5.  Fragmentation and Reassembly\n   In the case where TEAP fragmentation
      is required, the conversation\n   will appear as follows:\n      Authenticating
      Peer     Authenticator\n      -------------------     -------------\n                              <-
      EAP-Request/\n                              Identity\n      EAP-Response/\n
      \     Identity (MyID) ->\n                              <- EAP-Request/\n                              EAP-Type=TEAP,
      V=1\n                              (TEAP Start, S bit set, Authority-ID)\n      EAP-Response/\n
      \     EAP-Type=TEAP, V=1\n      (TLS client_hello)->\n                              <-
      EAP-Request/\n                              EAP-Type=TEAP, V=1\n                              (TLS
      server_hello,\n                               TLS certificate,\n                              [TLS
      server_key_exchange,]\n                              [TLS certificate_request,]\n
      \                              TLS server_hello_done)\n                              (Fragment
      1: L, M bits set)\n      EAP-Response/\n      EAP-Type=TEAP, V=1 ->\n                              <-
      EAP-Request/\n                                 EAP-Type=TEAP, V=1\n                              (Fragment
      2: M bit set)\n      EAP-Response/\n      EAP-Type=TEAP, V=1 ->\n                              <-
      EAP-Request/\n                              EAP-Type=TEAP, V=1\n                              (Fragment
      3)\n      EAP-Response/\n      EAP-Type=TEAP, V=1\n      ([TLS certificate,]\n
      \      TLS client_key_exchange,\n      [TLS certificate_verify,]\n       TLS
      change_cipher_spec,\n       TLS finished)\n       (Fragment 1: L, M bits set)->\n
      \                              <- EAP-Request/\n                              EAP-Type=TEAP,
      V=1\n      EAP-Response/\n      EAP-Type=TEAP, V=1\n      (Fragment 2)->\n                             <-
      EAP-Request/\n                              EAP-Type=TEAP, V=1\n                              (TLS
      change_cipher_spec,\n                               TLS finished,\n                              [EAP-Payload-TLV[\n
      \                             EAP-Request/Identity]])\n      // TLS channel
      established\n         (messages sent within the TLS channel)\n      // First
      EAP Payload TLV is piggybacked to the TLS Finished as\n         Application
      Data and protected by the TLS tunnel.\n      EAP-Payload-TLV\n      [EAP-Response/Identity
      (MyID2)]->\n      // identity protected by TLS.\n                               <-
      EAP-Payload-TLV\n                               [EAP-Request/EAP-Type=X]\n      EAP-Payload-TLV\n
      \     [EAP-Response/EAP-Type=X] ->\n      // Method X exchanges followed by
      Protected Termination\n                           <- Intermediate-Result-TLV
      (Success),\n                               Crypto-Binding TLV (Request),\n                               Result
      TLV (Success)\n      Intermediate-Result-TLV (Success),\n      Crypto-Binding
      TLV (Response),\n      Result-TLV (Success) ->\n      // TLS channel torn down\n
      \     (messages sent in cleartext)\n                              <- EAP-Success\n"
    title: C.5.  Fragmentation and Reassembly
  - contents:
    - "C.6.  Sequence of EAP Methods\n   When TEAP is negotiated with a sequence of
      EAP method X followed by\n   method Y, the conversation will occur as follows:\n
      \     Authenticating Peer     Authenticator\n      -------------------     -------------\n
      \                             <- EAP-Request/\n                              Identity\n
      \     EAP-Response/\n      Identity (MyID1) ->\n                              <-
      EAP-Request/\n                              EAP-Type=TEAP, V=1\n                              (TEAP
      Start, S bit set, Authority-ID)\n      EAP-Response/\n      EAP-Type=TEAP, V=1\n
      \     (TLS client_hello)->\n                              <- EAP-Request/\n
      \                             EAP-Type=TEAP, V=1\n                              (TLS
      server_hello,\n                               TLS certificate,\n                              [TLS
      server_key_exchange,]\n                              [TLS certificate_request,]\n
      \                              TLS server_hello_done)\n      EAP-Response/\n
      \     EAP-Type=TEAP, V=1\n      ([TLS certificate,]\n       TLS client_key_exchange,\n
      \     [TLS certificate_verify,]\n       TLS change_cipher_spec,\n       TLS
      finished) ->\n                             <- EAP-Request/\n                              EAP-Type=TEAP,
      V=1\n                              (TLS change_cipher_spec,\n                               TLS
      finished,\n                               Identity-Type TLV,\n                              EAP-Payload-TLV[\n
      \                             EAP-Request/Identity])\n      // TLS channel established\n
      \        (messages sent within the TLS channel)\n      // First EAP Payload
      TLV is piggybacked to the TLS Finished as\n         Application Data and protected
      by the TLS tunnel\n      Identity_Type TLV\n      EAP-Payload-TLV\n      [EAP-Response/Identity]
      ->\n                              <- EAP-Payload-TLV\n                            [EAP-Request/EAP-Type=X]\n
      \     EAP-Payload-TLV\n      [EAP-Response/EAP-Type=X] ->\n             // Optional
      additional X Method exchanges...\n                             <- EAP-Payload-TLV\n
      \                           [EAP-Request/EAP-Type=X]\n      EAP-Payload-TLV\n
      \     [EAP-Response/EAP-Type=X]->\n                              <- Intermediate
      Result TLV (Success),\n                               Crypto-Binding TLV (Request),\n
      \                              Identity-Type TLV,\n                               EAP
      Payload TLV [EAP-Type=Y],\n      // Next EAP conversation started after successful
      completion\n         of previous method X.  The Intermediate-Result and Crypto-\n
      \        Binding TLVs are sent in next packet to minimize round\n         trips.
      \ In this example, an identity request is not sent\n         before negotiating
      EAP-Type=Y.\n      // Compound MAC calculated using keys generated from\n         EAP
      method X and the TLS tunnel.\n      Intermediate Result TLV (Success),\n      Crypto-Binding
      TLV (Response),\n      EAP-Payload-TLV [EAP-Type=Y] ->\n             // Optional
      additional Y Method exchanges...\n                             <- EAP Payload
      TLV [\n                             EAP-Type=Y]\n      EAP Payload TLV\n      [EAP-Type=Y]
      ->\n                             <- Intermediate-Result-TLV (Success),\n                               Crypto-Binding
      TLV (Request),\n                               Result TLV (Success)\n      Intermediate-Result-TLV
      (Success),\n      Crypto-Binding TLV (Response),\n      Result-TLV (Success)
      ->\n      // Compound MAC calculated using keys generated from EAP\n         methods
      X and Y and the TLS tunnel.  Compound keys are\n         generated using keys
      generated from EAP methods X and Y\n         and the TLS tunnel.\n      // TLS
      channel torn down (messages sent in cleartext)\n                              <-
      EAP-Success\n"
    title: C.6.  Sequence of EAP Methods
  - contents:
    - "C.7.  Failed Crypto-Binding\n   The following exchanges show a failed crypto-binding
      validation.  The\n   conversation will appear as follows:\n   Authenticating
      Peer     Authenticator\n   -------------------     -------------\n                           <-
      EAP-Request/\n                           Identity\n   EAP-Response/\n   Identity
      (MyID1) ->\n                           <- EAP-Request/\n                           EAP-Type=TEAP,
      V=1\n                           (TEAP Start, S bit set, Authority-ID)\n   EAP-Response/\n
      \  EAP-Type=TEAP, V=1\n   (TLS client_hello without\n   PAC-Opaque in SessionTicket
      extension)->\n                           <- EAP-Request/\n                           EAP-Type=TEAP,
      V=1\n                           (TLS Server Key Exchange\n                            TLS
      Server Hello Done)\n   EAP-Response/\n   EAP-Type=TEAP, V=1 ->\n   (TLS Client
      Key Exchange\n    TLS change_cipher_spec,\n    TLS finished)\n                           <-
      EAP-Request/\n                           EAP-Type=TEAP, V=1\n                           (TLS
      change_cipher_spec\n                            TLS finished)\n                            EAP-Payload-TLV[\n
      \                           EAP-Request/Identity])\n      // TLS channel established\n
      \        (messages sent within the TLS channel)\n      // First EAP Payload
      TLV is piggybacked to the TLS Finished as\n         Application Data and protected
      by the TLS tunnel.\n   EAP-Payload TLV/\n   EAP Identity Response ->\n                          <-
      \ EAP Payload TLV, EAP-Request,\n                              (EAP-MSCHAPV2,
      Challenge)\n   EAP Payload TLV, EAP-Response,\n   (EAP-MSCHAPV2, Response) ->\n
      \                         <-  EAP Payload TLV, EAP-Request,\n                              (EAP-MSCHAPV2,
      Success Request)\n   EAP Payload TLV, EAP-Response,\n   (EAP-MSCHAPV2, Success
      Response) ->\n                        <- Intermediate-Result-TLV (Success),\n
      \                           Crypto-Binding TLV (Request),\n                               Result
      TLV (Success)\n      Intermediate-Result-TLV (Success),\n      Result TLV (Failure)\n
      \     Error TLV with\n      (Error Code = 2001) ->\n   // TLS channel torn down\n
      \     (messages sent in cleartext)\n                           <- EAP-Failure\n"
    title: C.7.  Failed Crypto-Binding
  - contents:
    - "C.8.  Sequence of EAP Method with Vendor-Specific TLV Exchange\n   When TEAP
      is negotiated with a sequence of EAP methods followed by a\n   Vendor-Specific
      TLV exchange, the conversation will occur as follows:\n      Authenticating
      Peer     Authenticator\n      -------------------     -------------\n                              <-
      EAP-Request/\n                              Identity\n      EAP-Response/\n
      \     Identity (MyID1) ->\n                              <- EAP-Request/\n                              EAP-Type=TEAP,
      V=1\n                              (TEAP Start, S bit set, Authority-ID)\n      EAP-Response/\n
      \     EAP-Type=TEAP, V=1\n      (TLS client_hello)->\n                              <-
      EAP-Request/\n                              EAP-Type=TEAP, V=1\n                              (TLS
      server_hello,\n                               TLS certificate,\n                       [TLS
      server_key_exchange,]\n                       [TLS certificate_request,]\n                           TLS
      server_hello_done)\n      EAP-Response/\n      EAP-Type=TEAP, V=1\n      ([TLS
      certificate,]\n       TLS client_key_exchange,\n      [TLS certificate_verify,]\n
      \      TLS change_cipher_spec,\n       TLS finished) ->\n                             <-
      EAP-Request/\n                              EAP-Type=TEAP, V=1\n                              (TLS
      change_cipher_spec,\n                               TLS finished,\n                              EAP-Payload-TLV[\n
      \                             EAP-Request/Identity])\n      // TLS channel established\n
      \        (messages sent within the TLS channel)\n      // First EAP Payload
      TLV is piggybacked to the TLS Finished as\n         Application Data and protected
      by the TLS tunnel.\n      EAP-Payload-TLV\n      [EAP-Response/Identity] ->\n
      \                           <- EAP-Payload-TLV\n                            [EAP-Request/EAP-Type=X]\n
      \     EAP-Payload-TLV\n      [EAP-Response/EAP-Type=X] ->\n                             <-
      EAP-Payload-TLV\n                            [EAP-Request/EAP-Type=X]\n      EAP-Payload-TLV\n
      \     [EAP-Response/EAP-Type=X]->\n                              <- Intermediate
      Result TLV (Success),\n                               Crypto-Binding TLV (Request),\n
      \                              Vendor-Specific TLV,\n      // Vendor-Specific
      TLV exchange started after successful\n         completion of previous method
      X.  The Intermediate-Result\n         and Crypto-Binding TLVs are sent with
      Vendor-Specific TLV\n         in next packet to minimize round trips.\n      //
      Compound MAC calculated using keys generated from\n         EAP method X and
      the TLS tunnel.\n      Intermediate Result TLV (Success),\n      Crypto-Binding
      TLV (Response),\n      Vendor-Specific TLV ->\n          // Optional additional
      Vendor-Specific TLV exchanges...\n                             <- Vendor-Specific
      TLV\n      Vendor-Specific TLV ->\n                             <- Result TLV
      (Success)\n      Result-TLV (Success) ->\n      // TLS channel torn down (messages
      sent in cleartext)\n                              <- EAP-Success\n"
    title: C.8.  Sequence of EAP Method with Vendor-Specific TLV Exchange
  - contents:
    - "C.9.  Peer Requests Inner Method after Server Sends Result TLV\n   In the case
      where the peer is authenticated during Phase 1 and the\n   server sends back
      a Result TLV but the peer wants to request another\n   inner method, the conversation
      will appear as follows:\n      Authenticating Peer    Authenticator\n      -------------------
      \   -------------\n                             <- EAP-Request/Identity\n      EAP-Response/\n
      \     Identity (MyID1) ->\n      // Identity sent in the clear.  May be a hint
      to help route\n         the authentication request to EAP server, instead of
      the\n         full user identity.\n                              <- EAP-Request/\n
      \                             EAP-Type=TEAP, V=1\n                              (TEAP
      Start, S bit set, Authority-ID)\n      EAP-Response/\n      EAP-Type=TEAP, V=1\n
      \     (TLS client_hello)->\n                              <- EAP-Request/\n
      \                             EAP-Type=TEAP, V=1\n                              (TLS
      server_hello,\n                               TLS certificate,\n                              [TLS
      server_key_exchange,]\n                              [TLS certificate_request,]\n
      \                              TLS server_hello_done)\n      EAP-Response/\n
      \     EAP-Type=TEAP, V=1\n      [TLS certificate,]\n       TLS client_key_exchange,\n
      \     [TLS certificate_verify,]\n       TLS change_cipher_spec,\n       TLS
      finished ->\n                              <- EAP-Request/\n                              EAP-Type=TEAP,
      V=1\n                              (TLS change_cipher_spec,\n                               TLS
      finished,\n                               Crypto-Binding TLV (Request),\n                                Result
      TLV (Success))\n      // TLS channel established\n         (TLV Payload messages
      sent within the TLS channel)\n       Crypto-Binding TLV(Response),\n       Request-Action
      TLV\n       (Status=Failure, Action=Negotiate-EAP)->\n                            <-
      EAP-Payload-TLV\n                                [EAP-Request/Identity]\n      EAP-Payload-TLV\n
      \     [EAP-Response/Identity] ->\n                            <- EAP-Payload-TLV\n
      \                           [EAP-Request/EAP-Type=X]\n      EAP-Payload-TLV\n
      \     [EAP-Response/EAP-Type=X] ->\n                             <- EAP-Payload-TLV\n
      \                           [EAP-Request/EAP-Type=X]\n      EAP-Payload-TLV\n
      \     [EAP-Response/EAP-Type=X]->\n                              <- Intermediate
      Result TLV (Success),\n                                 Crypto-Binding TLV (Request),\n
      \                                Result TLV (Success)\n      Intermediate Result
      TLV (Success),\n      Crypto-Binding TLV (Response),\n      Result-TLV (Success))
      ->\n      // TLS channel torn down\n      (messages sent in cleartext)\n                              <-
      EAP-Success\n"
    title: C.9.  Peer Requests Inner Method after Server Sends Result TLV
  - contents:
    - "C.10.  Channel Binding\n   The following exchanges show a successful TEAP authentication
      with\n   basic password authentication and channel binding using a Request-\n
      \  Action TLV.  The conversation will appear as follows:\n       Authenticating
      Peer     Authenticator\n       -------------------     -------------\n                               <-
      EAP-Request/\n                               Identity\n       EAP-Response/\n
      \      Identity (MyID1) ->\n                               <- EAP-Request/\n
      \                              EAP-Type=TEAP, V=1\n                               (TEAP
      Start, S bit set, Authority-ID)\n       EAP-Response/\n       EAP-Type=TEAP,
      V=1\n       (TLS client_hello with\n        PAC-Opaque in SessionTicket extension)->\n
      \                              <- EAP-Request/\n                               EAP-Type=TEAP,
      V=1\n                               (TLS server_hello,\n                               (TLS
      change_cipher_spec,\n                                TLS finished)\n       EAP-Response/\n
      \      EAP-Type=TEAP, V=1 ->\n       (TLS change_cipher_spec,\n        TLS finished)\n
      \      TLS channel established\n       (messages sent within the TLS channel)\n
      \                             <- Basic-Password-Auth-Req TLV, Challenge\n       Basic-Password-Auth-Resp
      TLV, Response with both\n       username and password) ->\n       optional additional
      exchanges (new pin mode,\n       password change, etc.) ...\n                            <-
      Crypto-Binding TLV (Request),\n                                Result TLV (Success),\n
      \      Crypto-Binding TLV(Response),\n       Request-Action TLV\n       (Status=Failure,
      Action=Process-TLV,\n       TLV=Channel-Binding TLV)->\n                                <-
      Channel-Binding TLV (Response),\n                                Result TLV
      (Success),\n       Result-TLV (Success) ->\n       TLS channel torn down\n       (messages
      sent in cleartext)\n                               <- EAP-Success\n"
    title: C.10.  Channel Binding
  title: Appendix C.  Examples
- contents:
  - "Authors' Addresses\n   Hao Zhou\n   Cisco Systems\n   4125 Highlander Parkway\n
    \  Richfield, OH  44286\n   US\n   EMail: hzhou@cisco.com\n   Nancy Cam-Winget\n
    \  Cisco Systems\n   3625 Cisco Way\n   San Jose, CA  95134\n   US\n   EMail:
    ncamwing@cisco.com\n   Joseph Salowey\n   Cisco Systems\n   2901 3rd Ave\n   Seattle,
    WA  98121\n   US\n   EMail: jsalowey@cisco.com\n   Stephen Hanna\n   Infineon
    Technologies\n   79 Parsons Street\n   Brighton, MA  02135\n   US\n   EMail: steve.hanna@infineon.com\n"
  title: Authors' Addresses
