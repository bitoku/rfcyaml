This RFC defines a proposed standard protocol to support NetBIOS services in a TCP/IP environment.
Both local network and internet operation are supported.
Various node types are defined to accommodate local and internet topologies and to allow operation with or without the use of IP broadcast.
This RFC gives the detailed specifications of the NetBIOS over TCP packets, protocols, and defined constants and variables.
A more general overview is found in a companion RFC, "Protocol Standard For a NetBIOS Service on a TCP/UDP Transport: Concepts and Methods".
7 4.2.1  GENERAL FORMAT OF NAME SERVICE PACKETS
15 4.2.5  POSITIVE NAME REGISTRATION RESPONSE
4.2.7  END NODE CHALLENGE REGISTRATION RESPONSE
NAME RELEASE REQUEST & DEMAND
WAIT FOR ACKNOWLEDGEMENT (WACK) RESPONSE
27 4.3  SESSION SERVICE PACKETS
GENERAL FORMAT OF SESSION PACKETS
30 4.3.3  POSITIVE SESSION RESPONSE PACKET
31 4.3.5  SESSION RETARGET RESPONSE PACKET
32 4.4.1  NetBIOS DATAGRAM HEADER
DIRECT UNIQUE, DIRECT GROUP, & BROADCAST
39 5.1.2  P NODE ACTIVITY
P NODE ADD GROUP NAME
P NODE TIMER INITIATED PROCESSING
M NODE ADD GROUP NAME
72 5.2.2.2  RECEIVED PACKET PROCESSING
5.3.2  P AND M NODE TRANSMISSION OF NetBIOS DATAGRAMS
76 5.3.3  RECEPTION OF NetBIOS DATAGRAMS BY ALL NODES
This RFC specifies a proposed standard for the DARPA Internet community.
Since this topic is new to the Internet community, discussions and suggestions are specifically requested.
Please send written comments to:
Karl Auerbach Epilogue Technology Corporation P.O. Box
5432 Redwood City, CA   94063 Please send online comments to: Avnish Aggarwal Internet:
ucbvax!mtxinu!excelan!avnish Distribution of this memorandum is unlimited.
This RFC has been developed under the auspices of the Internet Activities Board.
The system proposed by this RFC does not reflect any existing Netbios over TCP implementation.
However, the design incorporates considerable knowledge obtained from prior implementations.
Special thanks goes to the following organizations which have provided this invaluable information:
This RFC contains the detailed packet formats and protocol specifications for NetBIOS over TCP.
This RFC is a companion to RFC 1001, "Protocol Standard For a NetBIOS Service on a TCP/UDP Transport: Concepts and Methods" [1].
PACKET DESCRIPTIONS Bit and byte
ordering are defined by the most recent version of "Assigned Numbers" [2].
The NetBIOS name representation in all NetBIOS packets (for NAME, SESSION, and DATAGRAM services) is defined in the Domain Name Service RFC 883[3] as "compressed" name messages.
This format is called "second level encoding" in the section entitled "Representation of NetBIOS Names" in the Concepts and Methods document.
For ease of description, the first two paragraphs from page 31, the section titled "Domain name representation and compression", of RFC 883 are replicated here:
Domain names messages are expressed in terms of a sequence of labels.
Each label is represented as a one octet length field followed by that number of octets.
Since every domain name ends with the null label of the root, a compressed domain name is terminated by a length byte of zero.
The high order two bits of the length field must be zero, and the remaining six bits of the length field limit the label to 63 octets or less.
To simplify implementations, the total length of label octets and label length octets that make up a domain name is restricted to 255 octets or less.
The following is the uncompressed representation of the NetBIOS name "FRED ", which is the 4 ASCII characters, F, R, E, D, followed by 12 space characters (0x20).
This name has the SCOPE ID: "
This uncompressed representation of names is called "first level encoding" in the section entitled "Representation of NetBIOS Names" in the Concepts and Methods document.
The following is a pictographic representation of the compressed representation of the previous uncompressed Domain Name representation.
Each section of a domain name is called a label [7 (page 31)].
A label can be a maximum of 63 bytes.
The first byte of a label in compressed representation is the number of bytes in the label.
For the above example, the first 0x20 is the number of bytes in the left most label, EGFCEFEECACACACACACACACACACACACA, of the domain name.
The bytes following the label length count are the characters of the label.
The following labels are in sequence after the first label, which is the encoded NetBIOS name, until a zero (0x00) length count.
The zero length count represents the root label, which is always null.
A label length count is actually a 6 bit field in the label length field.
The most significant 2 bits of the field, bits 7 and 6, are flags allowing an escape from the above compressed representation.
If bits 7 and 6 are both set (11), the following 14 bits are an offset pointer into the full message to the actual label string from another domain name that belongs in this name.
This label pointer allows for a further compression of a domain name in a packet.
NetBIOS implementations can only use label string pointers in Name Service packets.
They cannot be used in Session or Datagram Service packets.
The other two possible values for bits 7 and 6 (01 and 10) of a label length field are reserved for future use by RFC 883[2 (page 32)].
Note that the first octet of a compressed name must contain one of the following bit patterns.
(An "x" indicates a bit whose value may be either 0 or 1.)
: 00100000  Netbios name, length must be 32 (decimal)
11xxxxxx  Label string pointer 10xxxxxx
GENERAL FORMAT OF NAME SERVICE
The NetBIOS Name Service packets follow the packet structure defined in the Domain Name Service (DNS) RFC 883 [7 (pg 26 31)].
The structures are compatible with the existing DNS packet formats, however, additional types and codes have been added to work with NetBIOS.
If Name Service packets are sent over a TCP connection they are preceded by a 16 bit unsigned integer representing the length of the Name Service packet.
HEADER 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
Transaction ID for Name Service Transaction.
Requestor places a unique value for each active transaction.
Responder puts NAME TRN ID value from request packet in response packet.
Table of RCODE values for each response packet below.
Unsigned 16 bit integer specifying the number of entries in the question section of a Name Service packet.
Always zero (0) for responses.
Must be non zero for all NetBIOS Name requests.
Unsigned 16 bit integer specifying the number of resource records in the authority section of a Name Service packet.
The OPCODE field is defined as: 0
query 5   registration 6   release 7
if bit   0 then request packet
if bit   1 then response packet.
The NM FLAGS field is defined as: 0
AA  TC  RD  RA   0
: packet was broadcast or multicast   0:
Only valid in responses from a NetBIOS Name Server   must be zero in all other responses.
If one (1) then the NBNS supports recursive query, registration, and release.
then the end node must iterate for query and challenge for registration.
May only be set on a request to a NetBIOS Name Server.
The NBNS will copy its state into the response packet.
the NBNS will iterate on the query, registration, or release.
Set if this message was truncated because the datagram carrying it would be greater than 576 bytes in length.
Use TCP to get the information from the NetBIOS Name Server.
Must be zero (0) if R flag of OPCODE is zero (0).
If R flag is one (1)
then if AA is one (1) then the node responding is an authority for the domain name.
End nodes responding to queries always set this bit in responses.
The compressed name representation of the NetBIOS name for the request.
The values for this field are specified for each request.
The class of the request.
The values for this field are specified for each request.
NetBIOS general Name Service Resource Record NBSTAT
NetBIOS NODE STATUS Resource Record
RESOURCE RECORD 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
The compressed name representation of the NetBIOS name corresponding to this resource record.
The Time To Live of a the resource record's name.
Contains the resource information for the NetBIOS name.
RESOURCE RECORD RR TYPE field definitions:
(See REDIRECT NAME QUERY RESPONSE)
(See REDIRECT NAME QUERY RESPONSE)
(See WAIT FOR ACKNOWLEDGEMENT RESPONSE)
NetBIOS general Name Service Resource Record
(See NB FLAGS and NB ADDRESS, below)
NetBIOS NODE STATUS Resource Record
RESOURCE RECORD RR CLASS field definitions:
Internet class NB FLAGS field of the RESOURCE RECORD RDATA field for RR TYPE of "NB": 1
3 15   Reserved for future use.
Reserved for future use For registration requests
this is the claimant's type.
For responses this is the actual owner's type.
If one (1) then the RR NAME is a GROUP NetBIOS name.
If zero (0) then the RR NAME is a UNIQUE NetBIOS name.
The NB ADDRESS field of the RESOURCE RECORD RDATA field for RR TYPE of "NB" is the IP address of the name's owner.
NAME REGISTRATION REQUEST 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
0 0 1 0 0
Since the RR NAME is the same name as the QUESTION NAME, the RR NAME representation must use pointers to the QUESTION NAME name's labels to guarantee the length of the datagram is less than the maximum 576 bytes.
See section above on name formats and also page 31 and 32 of RFC 883, Domain Names Implementation and Specification, for a complete description of compressed name label pointers.
NAME OVERWRITE REQUEST & DEMAND 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
POSITIVE NAME REGISTRATION RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
1 0 1 1 0 0
NEGATIVE NAME REGISTRATION RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
1 0 1 1 0 0 0
Problem with NBNS, cannot process name.
Allowable only for challenging NBNS when gets an Update type registration request.
For policy reasons server will not register this name from this host.
Name is owned by another node.
A UNIQUE name is owned by more than one node.
REGISTRATION RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
1 0 1 0 0 0
NAME CONFLICT DEMAND 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
1 0 1 1 0 0
This packet is identical to a NEGATIVE NAME REGISTRATION RESPONSE with RCODE   CFT ERR.
NAME RELEASE REQUEST & DEMAND 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
Since the RR NAME is the same name as the QUESTION NAME, the RR NAME representation must use label string pointers to the QUESTION NAME labels to guarantee the length of the datagram is less than the maximum 576 bytes.
This is the same condition as with the NAME REGISTRATION REQUEST.
POSITIVE NAME RELEASE RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
1 0 0 0 0 0
NEGATIVE NAME RELEASE RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
1 0 0 0 0 0
Problem with NBNS, cannot process name.
For policy reasons server will not release this name from this host.
Name is owned by another node.
Only that node may release it.
A NetBIOS Name Server can optionally allow a node to release a name it does not own.
This would facilitate detection of inactive names for nodes that went down silently.
REQUEST 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
0 0 1 0 0
POSITIVE NAME QUERY RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
The ADDR ENTRY ARRAY a sequence of zero or more ADDR ENTRY records.
Each ADDR ENTRY record represents an owner of a name.
For group names there may be multiple entries.
However, the list may be incomplete due to packet size limitations.
Bit 22, "T", will be set to indicate truncated data.
NEGATIVE NAME QUERY RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
Problem with NBNS, cannot process name.
The name requested does not exist.
Allowable only for challenging NBNS when gets an Update type registration request.
For policy reasons server will not register this name from this host.
NAME QUERY RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
0 0 1 0 0
An end node responding to a NAME QUERY REQUEST always responds with the AA and RA bits set for both the NEGATIVE and POSITIVE NAME QUERY RESPONSE packets.
An end node never sends a REDIRECT NAME QUERY RESPONSE packet.
When the requestor receives the REDIRECT
NAME QUERY RESPONSE it must reiterate the NAME QUERY REQUEST to the NBNS specified by the NSD IP ADDR field of the A type RESOURCE RECORD in the ADDITIONAL section of the response packet.
This is an optional packet for the NBNS.
The NSD NAME and the RR NAME in the ADDITIONAL section of the response packet are the same name.
Space can be optimized if label string pointers are used in the RR NAME which point to the labels in the NSD NAME.
The RR NAME in the AUTHORITY section is the name of the domain the NBNS called by NSD NAME has authority over.
RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
1 0 0 0 0 0
The NAME TRN ID of the WACK RESPONSE packet is the same NAME TRN ID of the request that the NBNS is telling the requestor to wait longer to complete.
The RR NAME is the name from the request, if any.
If no name is available from the request then it is a null name, single byte of zero.
The TTL field of the ResourceRecord is the new time to wait, in seconds, for the request to complete.
The RDATA field contains the OPCODE and NM FLAGS of the request.
A TTL value of 0 means that the NBNS can not estimate the time it may take to complete a response.
1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
1 0 0 0 0 0
The NODE NAME ARRAY is an array of zero or more NUM NAMES entries of NODE NAME records.
Each NODE NAME entry represents an active name in the same NetBIOS scope as the requesting name in the local name table of the responder.
RR NAME is the requesting name.
NODE NAME Entry: 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
The NAME FLAGS field: 1
If one (1) then entry is for the permanent node name.
Flag is zero (0) for all other names.
All entries have this flag set to one (1).
then name on this node is in conflict.
If one (1) then this name is in the process of being deleted.
If one (1) then the name is a GROUP NetBIOS name.
If zero (0) then it is a UNIQUE NetBIOS name.
STATISTICS Field of the NODE STATUS RESPONSE:
GENERAL FORMAT OF SESSION PACKETS
All session service messages are sent over a TCP connection.
The TYPE, FLAGS, and LENGTH fields are present in every session packet.
The LENGTH field is the number of bytes following the LENGTH field.
In other words, LENGTH is the combined size of the TRAILER field(s).
For example, the POSITIVE SESSION RESPONSE packet always has a LENGTH field value of zero (0000) while the RETARGET SESSION RESPONSE always has a LENGTH field value of six (0006).
One of the bits of the FLAGS field acts as an additional, high  order bit for the LENGTH field.
Thus the cumulative size of the trailer field(s) may range from 0 to 128K bytes.
Session Packet Types (in hexidecimal): 00
SESSION REQUEST 82  POSITIVE SESSION RESPONSE 83
SESSION KEEP ALIVE Bit definitions of the FLAGS field:
6   Reserved, must be zero (0) 4.3.2.
SESSION REQUEST PACKET 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
NEGATIVE SESSION RESPONSE PACKET 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
Not listening on called name 81
Not listening for calling name 82
Called name not present 83
Called name present, but insufficient resources 8F  Unspecified error 4.3.5.
SESSION MESSAGE PACKET 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
PACKET 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0
1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
MSG TYPE values (in hexidecimal): 10  DIRECT UNIQUE DATAGRAM 11  DIRECT GROUP DATAGRAM 12  BROADCAST DATAGRAM 13
DATAGRAM ERROR 14  DATAGRAM QUERY
REQUEST 15  DATAGRAM POSITIVE QUERY RESPONSE 16  DATAGRAM NEGATIVE QUERY RESPONSE Bit definitions of the FLAGS field:
MORE flag, If set then more NetBIOS datagram fragments follow.
3   Reserved, must be zero (0)
82  DESTINATION NAME NOT PRESENT 83
INVALID SOURCE NAME FORMAT 84
INVALID DESTINATION NAME FORMAT 4.4.4.
DATAGRAM POSITIVE AND NEGATIVE QUERY RESPONSE 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
A REQUEST packet is always sent to the well known UDP port NAME SERVICE UDP PORT.
The destination address is normally either the IP broadcast address or the address of the NBNS the address of the NBNS server it set up at initialization time.
In rare cases, a request packet will be sent to an end node,
e.g.  a NAME QUERY REQUEST sent to "challenge" a node.
A RESPONSE packet is always sent to the source UDP port and source IP address of the request packet.
A DEMAND packet must always be sent to the well known UDP port NAME SERVICE UDP PORT.
There is no restriction on the target IP address.
This is a value composed from the requestor's IP address and a unique 16 bit value generated by the originator of the transaction.
ADD NAME PROCEDURE add name(newname)
/ broadcast NAME UPDATE REQUEST packet
/ return success; END /  no response  / ELSE BEGIN /  got response
against tid sent in request
request tid THEN BEGIN ignore response packet; END ELSE CASE packet type OF NEGATIVE NAME REGISTRATION RESPONSE:
B nodes should normally not get this   response.
B NODE ADD GROUP NAME PROCEDURE add
NAME PROCEDURE find name(name) /
/ pause(BCAST REQ RETRY TIMEOUT); UNTIL response packet received OR max transmit threshold exceeded IF no response packet received THEN return failure; ELSE IF NOT response tid
Be prepared to detect conflict if   any more response packets are received.
/ save response as authoritative response; start timer(CONFLICT TIMER); return success; NEGATIVE NAME QUERY RESPONSE:
REDIRECT NAME QUERY RESPONSE: /
B Node should normally not get either   response.
/ ignore response packet; END /  case  / END /  procedure  / 5.1.1.4.
B NODE NAME RELEASE PROCEDURE delete name (name) BEGIN
B NODE INCOMING PACKET PROCESSING
Following processing is done when broadcast or unicast packets are received at the NAME SERVICE UDP PORT.
Processing initiated by incoming packets for a B node  / BEGIN /
response packets are always sent   to:   source IP address of request packet   source UDP port of request packet  / CASE packet type OF NAME REGISTRATION REQUEST (UNIQUE): IF name exists in local name table THEN send NEGATIVE NAME REGISTRATION RESPONSE ; NAME REGISTRATION REQUEST (GROUP):
IF name exists in local name table THEN BEGIN IF local entry is a unique name THEN send NEGATIVE NAME REGISTRATION RESPONSE ;
END NAME QUERY REQUEST: IF name exists in local name table THEN BEGIN build response packet; send POSITIVE NAME QUERY RESPONSE; POSITIVE NAME QUERY RESPONSE:
IF name conflict timer is not active THEN
packet  / return; END ELSE /  timer is active  /
IF a response for this name has previously been received THEN BEGIN /
If so, send out a conflict packet.
Note: detecting conflict does NOT   affect any existing sessions.
No further session will be accepted on   that name.
No datagrams can be sent against that name.
Such an entry will not be used for   purposes of processing incoming request   packets.
The only valid user NetBIOS operation   against such a name is DELETE NAME.
/ END NAME RELEASE REQUEST:
IF caching is being done THEN BEGIN remove entry from cache;
All packets sent or received by P nodes are unicast UDP packets.
A P node sends name service requests to the NBNS node that is specified in the P node configuration.
P NODE ADD NAME PROCEDURE add name(newname)
IF receive a WACK RESPONSE
pause(time from TTL field of response); ELSE pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet is received OR retransmit count has been exceeded IF no response packet was received THEN BEGIN /  no response
/ ELSE BEGIN /  response
The response packet has in it the   address of the presumed owner of the   name.
If owner either does not   respond or indicates that he no longer   owns the name, claim the name.
Otherwise, the name cannot be claimed.
unicast NAME QUERY REQUEST packet to the address contained in the END NODE CHALLENGE RESPONSE packet
/ pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet is received or retransmit count has been exceeded IF no response packet is received OR NEGATIVE NAME QUERY RESPONSE packet received THEN BEGIN /
IF receive a WACK RESPONSE
pause(time from TTL field of response); ELSE pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet is received or retransmit count has been exceeded IF no response packet received THEN BEGIN /  no response
END /  end node challenge
P NODE ADD GROUP NAME PROCEDURE add
NAME PROCEDURE find name(name) /
IF receive a WACK RESPONSE
pause(time from TTL field of response); ELSE pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet received OR max transmit threshold exceeded IF no response packet received THEN return failure; ELSE IF NOT response tid
request tid THEN ignore packet; ELSE CASE packet type OF POSITIVE NAME QUERY RESPONSE: return success; REDIRECT NAME QUERY RESPONSE: /
NBNS node wants this end node   to use some other NBNS node   to resolve the query.
/ repeat query with NBNS address in the response packet; NEGATIVE NAME QUERY RESPONSE:
return failure; END /  case  / END /  procedure  / 5.1.2.4.
P NODE DELETE NAME PROCEDURE delete name (name) /
/ unicast NAME RELEASE REQUEST packet
; IF receive a WACK RESPONSE
pause(time from TTL field of response); ELSE pause(UCAST REQ RETRY TIMEOUT); UNTIL retransmit count has been exceeded or response been received IF response has been received THEN CASE packet type OF POSITIVE NAME RELEASE RESPONSE:
does want node to delete this   name !!!
/ return failure; END /  case  / END /  procedure
PACKET PROCESSING Processing initiated by reception of packets at a P node PROCEDURE process incoming packet(packet)
IF packet was sent as a broadcast THEN BEGIN ignore packet; return; END CASE packet type of NAME CONFLICT DEMAND: IF name exists in local name table THEN mark name as in conflict; return; NAME QUERY REQUEST:
END /  does not exist  / NODE
Send only those names that are   in the same scope as the scope   in the request packet.
/ send NODE STATUS RESPONSE; END NAME RELEASE REQUEST:
This will be received if the NBNS wants to flush the   name from the local name table, or from the local   cache.
/ IF name exists in the local name table THEN BEGIN delete name from local name table; inform user that name has been deleted; END ELSE
IF name has been cached locally THEN BEGIN remove entry from cache:
END END /  case  / END /  procedure  / 5.1.2.6.
PROCESSING Processing initiated by timer expiration.
the   TTL which has expired.
/ REPEAT build NAME REFRESH REQUEST packet; REPEAT send packet to NBNS; IF receive a WACK RESPONSE
pause(time from TTL field of response); ELSE pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet is received or retransmit count has been exceeded CASE packet type OF POSITIVE NAME REGISTRATION RESPONSE:
/ UNTIL request sent for all names for which TTL has expired END /  procedure  / 5.1.3.
M NODE ACTIVITY M nodes behavior is similar to that of P nodes with the addition of some B node like broadcast actions.
M node name service proceeds in two steps:
1.Use broadcast UDP based name service.
Depending on the operation, goto step 2.
2.Use directed UDP name service.
The following code for M nodes is exactly the same as for a P node, with the exception that broadcast operations are done before P type operation is attempted.
M NODE ADD NAME PROCEDURE add name(newname)
broadcast NAME REGISTRATION REQUEST packet; pause(BCAST REQ RETRY TIMEOUT); UNTIL response packet is received or retransmit count has been  exceeded IF valid response received THEN BEGIN /
cannot claim name  / return failure; END /
No objections received within the   broadcast area.
Send request to name server.
IF receive a WACK RESPONSE
pause(time from TTL field of response); ELSE pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet is received or retransmit count has been exceeded IF no response packet was received THEN BEGIN /  no response
/ ELSE BEGIN /  response
The response packet has in it the   address of the presumed owner of the   name.
If owner either does not   respond or indicates that he no longer   owns the name, claim the name.
Otherwise, the name cannot be claimed.
/ pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet is received or retransmit count has been exceeded IF no response packet is received THEN BEGIN /  no response
IF receive a WACK RESPONSE
pause(time from TTL field of response); ELSE pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet is received or retransmit count has been exceeded IF no response packet received THEN BEGIN /  no response
/ return failure; END /  case  / END /  no response  / ELSE
/ return failure; NEGATIVE NAME QUERY: /
remote node no longer has name  / return success;
END /  case  / END /  end node challenge
/ END /  case  / END /  response
M NODE ADD GROUP NAME PROCEDURE add
NAME PROCEDURE find name(name) /
/ REPEAT /  build packet  /
... broadcast NAME QUERY REQUEST packet; pause(BCAST REQ RETRY TIMEOUT); UNTIL response packet received OR max transmit threshold exceeded IF valid response received THEN
IF receive a WACK RESPONSE
pause(time from TTL field of response); ELSE pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet received OR max transmit threshold exceeded IF no response packet received THEN return failure; ELSE IF NOT response tid
request tid THEN ignore packet; ELSE CASE packet type OF POSITIVE NAME QUERY RESPONSE: return success; REDIRECT NAME QUERY RESPONSE: /
NBNS node wants this end node   to use some other NBNS node   to resolve the query.
/ repeat query with NBNS address in the response packet; NEGATIVE NAME QUERY RESPONSE:
return failure; END /  case  / END /  procedure  / 5.1.3.4.
M NODE DELETE NAME PROCEDURE delete name (name) /
Host initiated processing for a P node  / BEGIN
/ unicast NAME RELEASE REQUEST packet to NBNS
; IF receive a WACK RESPONSE
/ return failure; END /  case  / END /  procedure
PACKET PROCESSING Processing initiated by reception of packets at a M node PROCEDURE process incoming packet(packet)
Processing initiated by incoming packets at a M node  / BEGIN CASE packet type of NAME CONFLICT DEMAND: IF name exists in local name table THEN mark name as in conflict; return; NAME QUERY REQUEST:
END /  does not exist  / NODE
IF name in local name table OR name
Send only those names that are   in the same scope as the scope   in the request packet.
/ send NODE STATUS RESPONSE; END NAME RELEASE REQUEST:
This will be received if the NBNS wants to flush the   name from the local name table, or from the local   cache.
/ IF name exists in the local name table THEN BEGIN delete name from local name table; inform user that name has been deleted; END ELSE
IF name has been cached locally THEN BEGIN remove entry from cache: END NAME REGISTRATION REQUEST (UNIQUE):
IF name exists in local name table THEN send NEGATIVE NAME REGISTRATION RESPONSE ; NAME REGISTRATION REQUEST (GROUP):
IF name exists in local name table THEN BEGIN IF local entry is a unique name THEN send NEGATIVE NAME REGISTRATION RESPONSE ; END END /  case  / END /  procedure  / 5.1.3.6.
the   TTL which has expired.
/ REPEAT build NAME REFRESH REQUEST packet; REPEAT send packet to NBNS; IF receive a WACK RESPONSE
pause(time from TTL field of response); ELSE pause(UCAST REQ RETRY TIMEOUT); UNTIL response packet is received or retransmit count has been exceeded CASE packet type OF POSITIVE NAME REGISTRATION RESPONSE:
/ UNTIL request sent for all names for which TTL has expired END /  procedure  / 5.1.4.
A NBNS node will receive directed packets from P and M nodes.
Reply packets are always sent as directed packets to the source IP address and UDP port number.
Received broadcast packets must be ignored.
INCOMING PACKET PROCESSING PROCEDURE process incoming packet(packet)
Incoming packet processing on a NS node  / BEGIN IF packet was sent as a broadcast THEN BEGIN discard packet; return; END CASE packet type of NAME REGISTRATION REQUEST (UNIQUE): IF unique name exists in data base THEN BEGIN /  unique name exists
Such a NBNS node is   called a "non secure" server.
A "secure" server will do the   challenging before it sends   back a response packet.
/ REPEAT send NAME QUERY REQUEST; pause(UCAST REQ RETRY TIMEOUT); UNTIL response has been received or retransmit count has been exceeded IF no response was received THEN BEGIN /
node down  / update data base remove entry; update data base add new entry; send POSITIVE NAME REGISTRATION RESPONSE; return; END ELSE BEGIN /
a response packet  / CASE packet type POSITIVE NAME QUERY RESPONSE: /
The NBNS will need to   keep track (based on transaction id) of   the IP address and port number   of the original requestor.
/ END /  challenged node replied  / END /  unique name exists in data base
Make the assumption that   at least some of the group members   are still alive.
Refresh mechanism will   allow the NBNS to detect when all   members of a group no longer use that   name  / send NEGATIVE NAME REGISTRATION RESPONSE; END /  group name exists
/ ELSE BEGIN /  name does not exist
This code applies to both non secure   and secure server.
IF name exists in data base THEN BEGIN
IF local entry is a unique name THEN BEGIN /  local is unique
THEN BEGIN send  END NODE CHALLENGE NAME REGISTRATION RESPONSE;
return; END REPEAT send NAME QUERY REQUEST; pause(UCAST REQ RETRY TIMEOUT); UNTIL response received or retransmit count exceeded IF no response received or NEGATIVE NAME QUERY RESPONSE received THEN BEGIN update data base remove entry; update data base add new entry; send POSITIVE NAME REGISTRATION RESPONSE; return; END ELSE
/ ELSE BEGIN /  local is
/ update data base remove entry; update data base add new entry; send POSITIVE NAME REGISTRATION RESPONSE; return; END /  local is group  / END /  names exists
/ ELSE BEGIN /  does not exist  /
/  name does not exist in data base  / update data base add new entry; send POSITIVE NAME REGISTRATION RESPONSE; return;
END /  does not exist
/ update data base remove entry; send POSITIVE NAME RELEASE RESPONSE; return; NAME UPDATE
End node completed a successful challenge,
IF secure server THEN send NEGATIVE NAME REGISTRATION RESPONSE; ELSE BEGIN /  new entry  /
IF entry already exists THEN update data base remove entry; update data base add new entry; send POSITIVE NAME REGISTRATION RESPONSE; start timer(TTL); END NAME REFRESH REQUEST: check for consistency; IF node not allowed to have name THEN BEGIN
/ send POSITIVE NAME REGISTRATION; start timer(TTL); END return; END /  case  / END /  procedure
A NS node uses timers to flush out entries from the data base.
Each entry in the data base is removed when its timer expires.
This time value is a multiple of the refresh
TTL established when the name was registered.
If such a request is sent, and   no response is received, it can   be assumed that the node is down.
/ remove entry from data base; END 5.2.
The following are variables and should be configurable by the NetBIOS user.
The default values of these variables is found in "Defined Constants and Variables" in the Detailed Specification.)
The maximum number TCP connection attempts allowable per a single NetBIOS call request.
SSN CLOSE TIMEOUT is the time period to wait when closing the NetBIOS session before killing the TCP connection if session sends are outstanding.
The following are Defined Constants for the NetBIOS Session Service.
(See "Defined Constants and Variables" in the Detailed Specification for the value of these constants):
SSN SRVC TCP PORT is the globally well known TCP port allocated for the NetBIOS Session Service.
The service accepts TCP connections on this port to establish NetBIOS Sessions.
The TCP connection established to this port by the caller is initially used for the exchange of NetBIOS control information.
The actual NetBIOS data connection may also pass through this port or, through the retargetting facility, through another port.
listen(listening name, caller name) /
User initiated processing for B, P and M nodes
This procedure assumes that an incoming session will be   retargetted here by a session server.
/ Read SESSION REQUEST packet from connection Process session request (see section on processing initiated by the reception of session service packets); Inform Session Service that NetBIOS listen is complete
This algorithm assumes that the called name is a unique name.
If the called name is a group name, the call() procedure   needs to cycle through the members of the group   until either (retry count   SSN RETRY COUNT) or   the list has been exhausted.
TRUE: caller is being retargetted  / name query   TRUE;  /
IF name query THEN BEGIN
do name discovery, returns IP address;
/ establish TCP connection with remote party, use an ephemeral port as source TCP port; IF connection refused THEN BEGIN
IF retarget THEN BEGIN /  retry
/ retarget   FALSE; use original IP address and TCP port; goto LOOP; END /  retry for just missed TCP listen  / pause(SESSION RETRY TIMER); establish TCP connection, again use ephemeral port as source TCP port; IF connection refused OR connection timed out THEN return failure; END ELSE
IF connection timed out THEN BEGIN IF retarget THEN BEGIN /  retry
/ retarget   FALSE; use original IP address and TCP port; goto LOOP; END ELSE
/ inform name discovery process of possible error; name query   TRUE; goto LOOP
: NOT LISTENING FOR CALLING NAME:
BEGIN kill TCP connection; return failure; END CALLED NAME
/ inform name discovery procedure of possible error; IF this is a P or M node THEN BEGIN /
it has returned incorrect   information.
/ send NAME RELEASE REQUEST for called name and IP address to NetBIOS Name Server; END /  retry from beginning
/ retarget   FALSE; name query
TRUE; goto LOOP; END /  called name not present
/ END /  case  / END /  negative response
BEGIN close TCP connection; extract IP address and TCP port from response; retarget   TRUE; END /  retarget response
retry count   1; UNTIL (retry count > SSN RETRY COUNT); return failure; END /  procedure  / 5.2.1.2.
These are packets received on a TCP connection before a session has been established.
The listen routines attached to a NetBIOS user process need not implement the RETARGET response section.
The user process version, separate from a shared Session Service, need only accept (POSITIVE SESSION RESPONSE) or reject (NEGATIVE SESSION RESPONSE) a session request.
Assumes the TCP connection has been accepted.
/ BEGIN CASE packet type SESSION REQUEST:
BEGIN IF called name does not exist on node THEN BEGIN send NEGATIVE SESSION RESPONSE with CALLED NAME
NOT PRESENT error code; close TCP connection; END Search for a listen with CALLING NAME for CALLED NAME; IF matching listen is found THEN BEGIN IF port of listener process is
port TCP connection is on THEN BEGIN send POSITIVE SESSION RESPONSE; Hand off connection to client process and/or inform user session is established; END ELSE BEGIN send RETARGET SESSION RESPONSE with listener's IP address and TCP port; close TCP connection; END END ELSE BEGIN /
no matching listen pending  / send NEGATIVE SESSION RESPONSE with either NOT LISTENING ON CALLED NAME or NOT LISTENING FOR CALLING NAME error code; close TCP connection; END END /  session request  / END /  case
/ END /  procedure  / 5.2.2.
SESSION DATA TRANSFER PROTOCOLS 5.2.2.1.
USER REQUEST PROCESSING PROCEDURE send message(user message)
These are packets received after a session has been established.
/ BEGIN CASE packet type OF SESSION  MESSAGE:
BEGIN process message header; read in user data; reset and restart keep alive timer; deliver data to user; END /  session message
discard packet; END /  case  / END /  procedure  / 5.2.2.3.
when session keep alive timer expires
/ BEGIN send SESSION KEEP ALIVE, if configured; IF send fails THEN BEGIN /  remote node, or path to it, is down  / abort TCP connection; close NetBIOS session; inform user that session is lost; return; END END /  procedure  / 5.2.3.
the TCP connection; WAIT for the connection to close or SSN CLOSE TIMEOUT to expire; IF time out expired THEN abort TCP connection; END /  procedure
RECEPTION INDICATION PROCESSING PROCEDURE close indication()
/ BEGIN close gracefully TCP connection; close NetBIOS session; inform user session closed by remote partner; END /  procedure  / 5.3.
The following are GLOBAL variables and should be NetBIOS user configurable
: SCOPE ID: the non leaf section of the domain name preceded by a '.'
which represents the domain of the NetBIOS scope for the NetBIOS name.
The following protocol description only supports single scope operation.
the maximum length of an IP datagram.
The minimal maximum length defined in for IP is 576 bytes.
This value is used when determining whether to fragment a NetBIOS datagram.
Implementations are expected to be capable of receiving unfragmented NetBIOS datagrams up to their maximum size.
the IP address B nodes use to send datagrams with group name destinations and broadcast datagrams.
The default is the IP broadcast address for a single IP network.
The following are Defined Constants for the NetBIOS Datagram Service: DGM SRVC UDP PORT:
the globally well known UDP port allocated where the NetBIOS Datagram Service receives UDP packets.
See section 6, "Defined Constants", for its value.
B NODE TRANSMISSION OF NetBIOS DATAGRAMS PROCEDURE send datagram(data, source, destination, broadcast)
this nodes IP address; SOURCE PORT    DGM SRVC UDP PORT; IF NetBIOS broadcast THEN BEGIN
END MSG TYPE   select one from set {BROADCAST, DIRECT UNIQUE
, DIRECT GROUP} DGM ID
id for Datagrams; DGM LENGTH   length of data
/ Put names into 1st UDP packet and any data that fits after names; Set MORE and FIRST bits in 1st UDP packet's FLAGS;
OFFSET in 1st UDP   0; Replicate NetBIOS Datagram header from 1st UDP packet into 2nd UDP packet; Put rest of data in 2nd UDP packet; Clear MORE and FIRST bits in 2nd UDP packet's FLAGS; OFFSET in 2nd UDP   DGM LENGTH number of name and data bytes in 1st UDP; END BEGIN /
Only need one UDP packet  / USER DATA   data;
Clear MORE bit and set FIRST bit in FLAGS; OFFSET   0; END IF (group   TRUE) OR (NetBIOS broadcast)
THEN BEGIN send UDP packet(s) to BROADCAST ADDRESS;
END ELSE BEGIN send UDP packet(s) to IP address returned by name discovery; END END /  procedure  / 5.3.2.
P AND M NODE TRANSMISSION OF NetBIOS DATAGRAMS PROCEDURE send datagram(data, source, destination, broadcast)
This processing is the same as for B nodes except for   sending broadcast and multicast NetBIOS datagrams.
this nodes IP address; SOURCE PORT    DGM SRVC UDP PORT; IF NetBIOS broadcast THEN BEGIN
END MSG TYPE   select one from set {BROADCAST, DIRECT UNIQUE
, DIRECT GROUP} DGM ID
id for Datagrams; DGM LENGTH   length of data
/ Put names into 1st UDP packet and any data that fits after names; Set MORE and FIRST bits in 1st UDP packet's FLAGS;
OFFSET in 1st UDP   0; Replicate NetBIOS Datagram header from 1st UDP packet into 2nd UDP packet; Put rest of data in 2nd UDP packet; Clear MORE and FIRST bits in 2nd UDP packet's FLAGS; OFFSET in 2nd UDP   DGM LENGTH number of name and data bytes in 1st UDP; END BEGIN /
Only need one UDP packet  / USER DATA   data;
Clear MORE bit and set FIRST bit in FLAGS; OFFSET   0; END IF (group   TRUE) OR (NetBIOS broadcast)
Sending of following query is optional.
Node may send datagram to NBDD immediately   but NBDD may discard the datagram.
/ send DATAGRAM QUERY REQUEST to NBDD; IF response is POSITIVE QUERY RESPONSE THEN send UDP packet(s) to NBDD Server IP address; ELSE BEGIN
get list of destination nodes from NBNS; FOR EACH node in list BEGIN send UDP packet(s) to this node's IP address; END END END ELSE
BEGIN send UDP packet(s) to IP address returned by name discovery; END /  procedure  / 5.3.3.
RECEPTION OF NetBIOS DATAGRAMS BY ALL NODES
The following algorithm discards out of order NetBIOS Datagram fragments.
An implementation which reassembles out of order NetBIOS Datagram fragments conforms to this specification.
The fragment discard timer is initialized to the value FRAGMENT TO.
This value should be user configurable.
The default value is given in Section 6, "Defined Constants and Variables".
IF this is a P node AND incoming packet is a broadcast packet THEN BEGIN discard packet; END CASE packet type OF DATAGRAM SERVICE
: BEGIN IF FIRST bit in FLAGS is set
IF MORE bit in FLAGS is set THEN BEGIN
Save 1st UDP packet of the Datagram
; Set this Datagram's fragment discard timer to FRAGMENT TO; return; END ELSE Datagram is composed of a single UDP packet; END ELSE BEGIN /  Have the second fragment of a Datagram  / Search for 1st fragment by source IP address and DGM ID; IF found 1st fragment
THEN Process both UDP packets; ELSE BEGIN discard 2nd fragment UDP packet; return; END END
IF DESTINATION NAME is ' '
NetBIOS broadcast  / deliver USER DATA from UDP packet(s) to all outstanding receive broadcast datagram requests; return; END ELSE BEGIN /
IF DESTINATION NAME is not present in the local name table
non broadcast  / END /  datagram service  / DATAGRAM ERROR:
/ inform local name service that incorrect information was provided; IF this is a P or M node
The key to NetBIOS Datagram forwarding service is the packet delivered to the destination end node must have the same NetBIOS header as if the source end node sent the packet directly to the destination end node.
Consequently, the NBDD does not reassemble NetBIOS Datagrams.
It forwards the UDP packet as is.
/ BEGIN CASE packet type OF DATAGRAM SERVICE:
combination of 1) and 2)
combination of 1) and 2)
END END /  datagram service  / DATAGRAM ERROR:
/ send DELETE NAME REQUEST with incorrect name and IP address to NetBIOS Name Server; END /  datagram error  / DATAGRAM QUERY REQUEST:
NBDD is NOT able to relay Datagrams for   this name  / send NEGATIVE DATAGRAM QUERY RESPONSE to REQUEST source IP address and UDP port with request's DGM ID;
END END /  datagram query request
/ END /  case  / END /  procedure  / 6.
DEFINED CONSTANTS AND VARIABLES GENERAL:
The name of the NetBIOS scope.
This is expressed as a character string meeting the requirements of the domain name system and without a leading or trailing "dot".
An implementation may elect to make this a single global value for the node or allow it to be specified with each separate NetBIOS name (thus permitting cross scope references.)
An IP address composed of the nodes's network and subnetwork numbers with all remaining bits set to one.
I.e. "Specific subnet" broadcast addressing according to section 2.3 of RFC 950.
An adaptive timer may be used.
An adaptive timer may be used.
Negotiated with NBNS for each name.
1 second Implementations may chose a longer value.
(decimal) NAME SERVICE UDP PORT
60 seconds, recommended, may be set to a higher value.
(Session keep alives are used only if configured.)
REFERENCES [1]  "Protocol Standard For a NetBIOS Service on a TCP/UDP Transport: Concepts and Methods", RFC 1001, March 1987.
[2]  J. Reynolds, J. Postel, "Assigned Numbers", RFC 990, November 1986.
[3]  P. Mockapetris, "Domain Names Implementation and Specification", RFC 883, November 1983.
