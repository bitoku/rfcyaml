- title: __initial_text__
  contents:
  - "             Data Link Switching: Switch-to-Switch Protocol\n       AIW DLSw\
    \ RIG: DLSw Closed Pages, DLSw Standard Version 1.0\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This RFC describes use of Data Link Switching over TCP/IP. The RFC\
    \ is\n   being distributed to members of the Internet community in order to\n\
    \   solicit their reactions to the proposals contained in it.  While the\n   issues\
    \ discussed may not be directly relevant to the research\n   problems of the Internet,\
    \ they may be interesting to a number of\n   researchers and Implementers.\n \
    \  This RFC was created as a joint effort of the Advanced Peer-to-Peer\n   Networking\
    \ (APPN) Implementers Workshop (AIW) Data Link Switching\n   (DLSw) Related Interest\
    \ Group (RIG).  The APPN Implementers Workshop\n   is a group sponsored by IBM\
    \ and consists of representatives of member\n   companies implementing current\
    \ and future IBM Networking\n   interoperable products. The DLSw Related Interest\
    \ Group was formed in\n   this forum in order to produce a single version of the\
    \ Switch to\n   Switch Protocol (SSP) which could be implemented by all vendors,\n\
    \   which would fix documentation problems with the existing RFC 1434,\n   and\
    \ which would enhance and evolve the protocol to add new functions\n   and features.\n\
    \   This document is based on RFC 1434.  This document contains\n   significant\
    \ changes to RFC 1434 and therefore obsoletes that\n   document.\n   Any questions\
    \ or comments relative to the contents of this RFC should\n   be sent to the following\
    \ Internet address:\n   aiw-dlsw@networking.raleigh.ibm.com.\n   NOTE 1: This\
    \ is a widely subscribed mailing list and messages sent to\n   this address will\
    \ be sent to all members of the DLSw mailing list.\n   For specific questions\
    \ relating to subscribing to the AIW and any of\n   it's working groups send email\
    \ to: appn@vnet.ibm.com\n   Information regarding all of the AIW working groups\
    \ and the work they\n   are producing can be obtained by copying, via anonymous\
    \ ftp, the file\n   aiwinfo.psbin or aiwinfo.txt from the Internet host\n   networking.raleigh.ibm.com,\
    \ located in directory aiw.\n   NOTE 2:  These mailing lists and addresses are\
    \ subject to change.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Data Link Switching (DLSw) is a forwarding mechanism for\
    \ the IBM SNA\n   (Systems Network Architecture) and IBM NetBIOS (Network Basic\
    \ Input\n   Output Services) protocols.  This memo documents the Switch-to-Switch\n\
    \   Protocol (SSP) that is used between Data Link Switches.  This\n   protocol\
    \ does not provide full routing, but instead provides\n   switching at the SNA\
    \ Data Link layer (i.e., layer 2 in the SNA\n   architecture) and encapsulation\
    \ in TCP/IP for transport over the\n   Internet.  This RFC documents the frame\
    \ formats and protocols for\n   multiplexing data between Data Link Switches.\
    \ The initial\n   implementation of SSP uses TCP as the reliable transport between\
    \ Data\n   Link Switches.  However, other transport connections such as OSI TP4\n\
    \   could be used in the future.\n   A Data Link Switch (abbreviated also as DLSw\
    \ in this document) can\n   support  SNA (Physical Unit (PU) 2, PU 2.1 and PU\
    \ 4) systems and\n   optionally NetBIOS systems attached to IEEE 802.2 compliant\
    \ Local\n   Area Networks, as well as SNA (PU 2 (primary or secondary) and PU2.1)\n\
    \   systems attached to IBM Synchronous Data Link Control (SDLC) links.\n   For\
    \ the latter case, the SDLC attached systems are provided with a\n   LAN appearance\
    \ within the Data Link Switch (each SDLC PU is presented\n   to the SSP protocol\
    \ as a unique MAC/SAP address pair).  For the\n   Token-Ring LAN attached systems,\
    \ the Data Link Switch appears as a\n   source-routing bridge.  Token-Ring Remote\
    \ systems that are accessed\n   through the Data Link Switch appear as systems\
    \ attached to an\n   adjacent ring.  This ring is a virtual ring that is manifested\
    \ within\n   each Data Link Switch.\n"
- title: 1.1  Backwards Compatibility with RFC 1434
  contents:
  - "1.1  Backwards Compatibility with RFC 1434\n   This document defines significant\
    \ changes to RFC 1434 and does not\n   state details on how to interoperate with\
    \ RFC 1434 or \"enhanced\"\n   implementations (e.g., those that added enter and\
    \ exit busy flow\n   control).  It is up to the implementer to refer to RFC 1434\
    \ and/or\n   any other vendor's documentation in order to interoperate with a\n\
    \   given vendor's implementation, if interoperability with pre-AIW DLSw\n   RIG\
    \ standards is desired.\n"
- title: 2.  Overview
  contents:
  - "2.  Overview\n   Data Link Switching was developed to provide support for SNA\
    \ and\n   NetBIOS in multi-protocol routers.  Since SNA and NetBIOS are\n   basically\
    \ connection oriented protocols, the Data Link Control\n   procedure that they\
    \ use on the LAN is IEEE 802.2 Logical Link Control\n   (LLC) Type 2.  Data Link\
    \ Switching also accommodates SNA protocols\n   over WAN (Wide Area Network) links\
    \ via the SDLC protocol.\n   IEEE 802.2 LLC Type 2 was designed with the assumption\
    \ that the\n   network transit delay would be predictable (i.e., a local LAN).\n\
    \   Therefore the LLC Type 2 elements of procedure use a fixed timer for\n   detecting\
    \ lost frames.  When remote bridging is used over wide area\n   lines (especially\
    \ at lower speeds), the network delay is larger and\n   it can vary greatly based\
    \ upon congestion.  When the delay exceeds\n   the time-out value LLC Type 2 attempts\
    \ to retransmit.  If the frame\n   is not actually lost, only delayed, it is possible\
    \ for the LLC Type 2\n   procedures to become confused.  And as a result, the\
    \ link may be\n   eventually taken down if the delay exceeds the T1 timer times\
    \ N2\n   retry count.\n   Given the use of LLC Type 2 services, Data Link Switching\
    \ addresses\n   the following bridging problems:\n             DLC Time-outs\n\
    \             DLC Acknowledgments over the WAN\n             Flow and Congestion\
    \ Control\n             Broadcast Control of Search Packets\n             Source-Route\
    \ Bridging Hop Count Limits\n   NetBIOS also makes extensive use of datagram services\
    \ that use\n   connectionless LLC Type 1 service.  In this case, Data Link Switching\n\
    \   addresses the last two problems in the above list.\n   The principal difference\
    \ between Data Link Switching and bridging is\n   that for connection-oriented\
    \ data DLSw terminates the Data Link Control\n   whereas bridging does not. The\
    \ following figure illustrates this\n   difference based upon two end systems\
    \ operating with LLC Type 2\n   services.\n   Bridging\n   --------\n        \
    \            Bridge           Bridge\n   +------+         +----+           +----+\
    \         +------+\n   | End  | +-----+ |    +-----/     |    | +-----+ | End\
    \  |\n   |System+-+ LAN +-+    |    /------+    +-+ LAN +-+System|\n   |     \
    \ | +-----+ |    |  TCP/IP   |    | +-----+ |      |\n   +------+         +----+\
    \           +----+         +------+\n      Info----------------------------------------------->\n\
    \          <-----------------------------------------------RR\n   Data Link Switching\n\
    \   -------------------\n   +------+         +----+           +----+         +------+\n\
    \   | End  | +-----+ |    +-----/     |    | +-----+ | End  |\n   |System+-+ LAN\
    \ +-+DLSw|    /------+DLSw+-+ LAN +-+System|\n   |      | +-----+ |    |  TCP/IP\
    \   |    | +-----+ |      |\n   +------+         +----+           +----+     \
    \    +------+\n    Info--------------->   -------------> Info\n      <---------------RR\
    \                 ------------>\n                                         <------------RR\n\
    \   In traditional bridging, the Data Link Control is end-to-end.  Data\n   Link\
    \ Switching terminates the LLC Type 2 connection at the switch.\n   This means\
    \ that the LLC Type 2 connections do not cross the wide area\n   network.  The\
    \ DLSw multiplexes LLC connections onto a TCP connection\n   to another DLSw.\
    \  Therefore, the LLC connections at each end are\n   totally independent of each\
    \ other.  It is the responsibility of the\n   Data Link Switch to deliver frames\
    \ that it has received from a LLC\n   connection to the other end.  TCP is used\
    \ between the Data Link\n   Switches to guarantee delivery of frames.\n   As a\
    \ result of this design, LLC time-outs are limited to the local\n   LAN (i.e.,\
    \ they do not traverse the wide area).  Also, the LLC Type 2\n   acknowledgments\
    \ (RR's) do not traverse the WAN, thereby reducing\n   traffic across the wide\
    \ area links.  For SDLC links, polling and poll\n   response occurs locally, not\
    \ over the WAN.  Broadcast of search\n   frames is controlled by the Data Link\
    \ Switches once the location of a\n   target system is discovered.  Finally, the\
    \ switches can now apply\n   back pressure to the end systems to provide flow\
    \ and congestion\n   control.\n   Only one copy of an Link Protocol Data Unit\
    \ (LPDU) is sent between\n   Data Link Switches in SSP messages (XIDFRAME and\
    \ INFOFRAME).  Retries\n   of the LPDU are absorbed by Data Link Switch that receives\
    \ it.  The\n   Data Link Switch that transmits the LPDU received in an SSP message\n\
    \   to a local DLC, will perform retries in a manner appropriate for the\n   local\
    \ DLC. This may involve running a reply timer and maintaining a\n   poll retry\
    \ count.  The length of the timer and the number of retries\n   is an implementation\
    \ choice based on user configuration parameters\n   and the DLC type.\n   Data\
    \ Link Switching uses LAN addressing to set up connections between\n   SNA systems.\
    \  SDLC attached devices are defined with MAC and SAP\n   addresses to enable\
    \ them to communicate with LAN attached devices.\n   For NetBIOS systems, Data\
    \ Link Switching uses the NetBIOS name to\n   forward datagrams and to set up\
    \ connections for NetBIOS sessions.\n   For LLC type 2 connection establishment,\
    \ SNA systems send TEST (or in\n   some cases, XID) frames to the null (0x00)\
    \ SAP.  NetBIOS systems have\n   an address resolution procedure, based upon the\
    \ Name Query and Name\n   Recognized frames, that is used to establish an end-to-end\
    \ circuit.\n   Since Data Link Switching may be implemented in multi-protocol\n\
    \   routers, there may be situations where both bridging and switching\n   are\
    \ enabled. SNA frames can be identified by their link SAP.  Typical\n   SAP values\
    \ for SNA are 0x04, 0x08, and 0x0C.  NetBIOS always uses a\n   link SAP value\
    \ of 0xF0.\n"
- title: 3.  Transport Connection
  contents:
  - "3.  Transport Connection\n   Data Link Switches can be in used in pairs or by\
    \ themselves.\n   A Single DLSw internally switches one data link to another without\n\
    \   using TCP (DLC(1) to DLC(2) in the figure below).  This RFC does not\n   go\
    \ into details on how to implement this feature and it is not a\n   requirement\
    \ to support this RFC.\n   A paired DLSw multiplexes data links over a reliable\
    \ transport using\n   a Switch-to-Switch Protocol (SSP).\n   +-------------------------------------------+Switch-to-Switch\n\
    \   |              DLC Interfaces               | Protocol (SSP)\n   |+-----------+\
    \   DLC Request  +-----------+ |\n   ||   Data    |<---------------|         \
    \  | |Send SSP Frame\n   ||   Link    | DLC Indication |           | |-------------->\n\
    \   || Control 1 |--------------->|           | |\n   |+-----------+         \
    \       | Data Link | |\n   |+-----------+   DLC Request  |  Switch   | |\n  \
    \ ||   Data    |<-------------- |           | |Rec. SSP Frame\n   ||   Link  \
    \  | DLC Indication |           | |<-------------\n   || Control 2 | -------------->|\
    \           | |\n   |+-----------+                +-----------+ |\n   |      \
    \      Multi-Protocol Router          |\n   +-------------------------------------------+\n\
    \   Before Data Link Switching can occur between two routers, they must\n   establish\
    \ two TCP connections between them.  Each Data Link Switch\n   will maintain a\
    \ list of DLSw capable routers and their status\n   (active/inactive).  After\
    \ the TCP connection is established, SSP\n   messages are exchanged to establish\
    \ the capabilities of the two Data\n   Link Switches.  Once the exchange is complete,\
    \  the DLSw will employ\n   SSP control messages to establish end-to-end circuits\
    \ over the\n   transport connection.  Within the transport connection, DLSw SSP\n\
    \   messages are exchanged.  The message formats and types for these SSP\n   messages\
    \ are documented in the following sections.\n   The default parameters associated\
    \ with the TCP connections between\n   Data Link Switches are as follows:\n  \
    \ Socket Family     AF_INET        (Internet protocols)\n   Socket Type      \
    \ SOCK_STREAM    (stream socket)\n   Read Port Number  2065\n   Write Port Number\
    \ 2067\n   Two or more Data Link Switches may be attached to the same LAN,\n \
    \  consisting of a number of token-ring segments interconnected by\n   source-routing\
    \ bridges.  In this case, a TCP connection is not\n   defined between bridges\
    \ attached to the same LAN.  This will allow\n   using systems to select one of\
    \ the possible Data Link Switches in a\n   similar manner to the selection of\
    \ a bridge path through a source-\n   routed bridged network.  The virtual ring\
    \ segment in each Data Link\n   Switch attached to a common LAN must be configured\
    \ with the same ring\n   number.  This will prevent LAN frames sent by one Data\
    \ Link Switch\n   from being propagated through the other Data Link Switches.\n"
- title: 3.1  SSP Frame Formats
  contents:
  - "3.1  SSP Frame Formats\n   The following diagrams show the two message header\
    \ formats exchanged\n   between Data Link Switches, Control and Information. \
    \ The Control\n   message header is used for all messages except Information Frames\n\
    \   (INFOFRAME) and Independent Flow Control Messages (IFCM), which are\n   sent\
    \ in Information header format.  The INFOFRAME, KEEPALIVE and IFCM\n   message\
    \ headers are 16 bytes long, and the control message header is\n   72 bytes long.\
    \  The fields in the first sixteen bytes of all message\n   headers are the same.\n\
    \    CONTROL MESSAGES (72 Bytes)\n    (zero based offsets below shown in decimal\
    \ (xx) )\n   +-----------------------------+-----------------------------+\n \
    \  | (00) Version Number         | (01) Header Length (= 72)   |\n   +-----------------------------+-----------------------------+\n\
    \   | (02) Message Length                                       |\n   +-----------------------------+-----------------------------+\n\
    \   | (04) Remote Data Link Correlator                          |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (08) Remote DLC Port ID                                   |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (12) Reserved Field                                       |\n   +-----------------------------+-----------------------------+\n\
    \   | (14) Message Type           | (15) Flow Control Byte      |\n   +-----------------------------+-----------------------------+\n\
    \   | (16) Protocol ID            | (17) Header Number          |\n   +-----------------------------+-----------------------------+\n\
    \   | (18) Reserved                                             |\n   +-----------------------------+-----------------------------+\n\
    \   | (20) Largest Frame Size     | (21) SSP Flags              |\n   +-----------------------------+-----------------------------+\n\
    \   | (22) Circuit Priority       | (23) Message Type (see note)|\n   +-----------------------------+-----------------------------+\n\
    \   | (24) Target MAC Address  (non-canonical format)           |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -|\n   |                 \
    \                                          |\n   +- - - - - - - - - - - - - -\
    \ -+- - - - - - - - - - - - - - -+\n   |                                     \
    \                      |\n   +-----------------------------+-----------------------------+\n\
    \   | (30) Origin MAC Address  (non-canonical format)           |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -|\n   |                 \
    \                                          |\n   +- - - - - - - - - - - - - -\
    \ -+- - - - - - - - - - - - - - -+\n   |            .                        \
    \      .               |\n   +-----------------------------+-----------------------------+\n\
    \   | (36) Origin Link SAP        | (37) Target Link SAP        |\n   +-----------------------------+-----------------------------+\n\
    \   | (38) Frame Direction        | (39) Reserved               |\n   +-----------------------------+-----------------------------+\n\
    \   | (40) Reserved                                             |\n   +-----------------------------+-----------------------------+\n\
    \   | (42) DLC Header Length                                    |\n   +-----------------------------+-----------------------------+\n\
    \   | (44) Origin DLC Port ID                                   |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (48) Origin Data Link Correlator                          |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (52) Origin Transport ID                                  |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (56) Target DLC Port ID                                   |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (60) Target Data Link Correlator                          |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (64) Target Transport ID                                  |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (68) Reserved Field                                       |\n   +-----------------------------+-----------------------------+\n\
    \   | (70) Reserved Field                                       |\n   +-----------------------------+-----------------------------+\n\
    \            (Even Byte)                     (Odd Byte)\n    INFORMATION MESSAGE\
    \ (16 Bytes)\n   +-----------------------------+-----------------------------+\n\
    \   | (00) Version Number         | (01) Header Length (= 16)   |\n   +-----------------------------+-----------------------------+\n\
    \   | (02) Message Length                                       |\n   +-----------------------------+-----------------------------+\n\
    \   | (04) Remote Data Link Correlator                          |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (08) Remote DLC Port ID                                   |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   | (12) Reserved Field                                       |\n   +-----------------------------+-----------------------------+\n\
    \   | (14) Message Type           | (15) Flow Control Byte      |\n   +-----------------------------+-----------------------------+\n\
    \            (Even Byte)                    (Odd Byte)\n   The first sixteen bytes\
    \ of control and information message headers\n   contain identical fields.  A\
    \ brief description of some of the fields\n   in an SSP message are shown below\
    \ (if not defined below, the fields\n   and/or their values are described in subsequent\
    \ sections).\n   The Version Number field (offset 0) is set to 0x31 (ASCII '1'),\n\
    \   indicating a decimal value of 49.  This is used to indicate DLSw\n   version\
    \ 1.\n   The Header Length field (offset 1) is 0x48 for control messages,\n  \
    \ indicating a decimal value of 72 bytes, and 0x10 for information and\n   Independent\
    \ Flow Control messages, indicating a decimal value of 16\n   bytes.\n   The Message\
    \ Length field (offset 2) defines the number of bytes\n   within the data field\
    \ following the header.\n   The Flow Control Byte field (offset 15)  is described\
    \ in section 8.\n   The Header Number field (offset 17) is 0x01, indicating a\
    \ value of\n   one.\n   The Circuit Priority field (offset 22) is described in\
    \ section 4.\n   The Frame Direction field (offset 38) is set to 0x01 for frames\
    \ sent\n   from the origin DLSw to the target DLSw, and is set to 0x02 for\n \
    \  frames sent from the target DLSw to the origin DLSw.\n   Note:  The Remote\
    \ Data Link Correlator and Remote DLC Port ID are set\n   equal to the Target\
    \ Data Link Correlator and Target DLC Port ID if\n   the Frame Direction field\
    \ is set to 0x01, and are set equal to the\n   Origin Data Link Correlator and\
    \ Origin DLC Port ID if the Direction\n   Field is set to 0x02.\n   The Protocol\
    \ ID field is set to 0x42, indicating a decimal value of\n   66.\n   The DLC Header\
    \ Length is set to zero for SNA and is set to 0x23 for\n   NetBIOS datagrams,\
    \ indicating a length of 35 bytes.  This includes\n   the Access Control (AC)\
    \ field, the Frame Control (FC) field,\n   Destination MAC Address (DA), the Source\
    \ MAC Address (SA), the\n   Routing Information (RI) field (padded to 18 bytes),\
    \ the Destination\n   link SAP (DSAP), the Source link SAP (SSAP), and the LLC\
    \ control\n   field (UI).\n   NOTE:  The values for the Message Type field are\
    \ defined in section\n   3.5. Note that this value is specified in two different\
    \ fields\n   (offset 14 and 23 decimal) of the control message header.  Only the\n\
    \   first field is to be used when parsing a received SSP message.  The\n   second\
    \ field is to be ignored by new implementations on reception.\n   The second field\
    \ was left in for backwards compatibility with RFC\n   1434 implementations and\
    \ this field may be used in future versions if\n   needed.\n   The SSP Flags field\
    \ contains additional information related to the\n   SSP message.  The flags are\
    \ defined as follows (bit 7 being the most\n   significant bit and bit 0 the least\
    \ significant bit of the octet):\n   Bit(s)\n   76543210    Name    Meaning\n\
    \   ---------   -----   -------\n   x.......    SSPex   1 = explorer message (CANUREACH\
    \ and ICANREACH)\n   Reserved fields are set to zero upon transmission and should\
    \ be\n   ignored upon receipt.\n"
- title: 3.2  Address Parameters
  contents:
  - "3.2  Address Parameters\n   A data link is defined as a logical association between\
    \ the two end\n   stations using Data Link Switching.  It is identified by a Data\
    \ Link\n   ID (14 bytes) consisting of the pair of attachment addresses\n   associated\
    \ with each end system.  Each attachment address is\n   represented by the concatenation\
    \ of the MAC address (6 bytes) and the\n   LLC address (1 byte).  Each attachment\
    \ address is classified as\n   either \"Target\" in the context of the Destination\
    \ MAC/SAP addresses\n   of an explorer frame sent in the first frame used to establish\
    \ a\n   circuit, or \"Origin\" in the context of the Source MAC/SAP addresses.\n\
    \   All MAC addresses are expressed in non-canonical (Token-Ring) format.\n  \
    \  DATA LINK ID  (14 Bytes @ Control message offset 24 decimal)\n   +-----------------------------+-----------------------------+\n\
    \   | Target MAC Address                                        |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +- - - - - - - - - - - - - -\
    \ -+- - - - - - - - - - - - - - -+\n   |                                     \
    \                      |\n   +-----------------------------+-----------------------------+\n\
    \   | Origin MAC Address                                        |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +- - - - - - - - - - - - - -\
    \ -+- - - - - - - - - - - - - - -+\n   |                                     \
    \                      |\n   +-----------------------------+-----------------------------+\n\
    \   | Origin Link SAP             | Target Link SAP             |\n   +-----------------------------+-----------------------------+\n\
    \   An end-to-end circuit is identified by a pair of Circuit ID's.  A\n   Circuit\
    \ ID is a 64 bit number that identifies the DLC circuit within\n   a single DLSw.\
    \  It consists of a DLC Port ID (4 bytes), and a Data\n   Link Correlator (4 bytes).\
    \  The Circuit ID must be unique in a single\n   DLSw and is assigned locally.\
    \  The pair of Circuit ID's along with\n   the Data Link IDs,  uniquely identify\
    \ a single end-to-end circuit.\n   Each DLSw must keep a table of these Circuit\
    \ ID pairs, one for the\n   local end of the circuit and the other for the remote\
    \ end of the\n   circuit.  In order to identify which Data Link Switch originated\
    \ the\n   establishment of a circuit, the terms, \"Origin\" DLSw and \"Target\"\
    \n   DLSw, will be employed in this document.\n    CIRCUIT ID   (8 Bytes)\n  \
    \ +-----------------------------+-----------------------------+\n   | DLC Port\
    \ ID                                               |\n   +- - - - - - - - - -\
    \ - - - - -+- - - - - - - - - - - - - - -+\n   |                             \
    \                              |\n   +-----------------------------+-----------------------------+\n\
    \   | Data Link Correlator                                      |\n   +- - - -\
    \ - - - - - - - - - - -+- - - - - - - - - - - - - - -+\n   |                 \
    \                                          |\n   +-----------------------------+-----------------------------+\n\
    \   The Origin Transport ID and the Target Transport ID fields in the\n   message\
    \ header are used to identify the individual TCP/IP port on a\n   Data Link Switch.\
    \  The values have only local significance.  However,\n   each Data Link Switch\
    \ is required to reflect the values contained in\n   these two fields, along with\
    \ the associated values for DLC Port ID\n   and the Data Link Correlator, when\
    \ returning a message to the other\n   Data Link Switch.\n   The following figure\
    \ shows the use of the addressing parameters\n   during the establishment of an\
    \ end-to-end connection.  The CANUREACH,\n   ICANREACH, and REACH_ACK message\
    \ types all carry the Data Link ID,\n   consisting of the MAC and Link SAP addresses\
    \ associated with the two\n   end stations.  The CANUREACH and ICANREACH messages\
    \ are qualified by\n   the SSPex flag into CANUREACH_ex, ICANREACH_ex (explorer\
    \ messages)\n   and CANUREACH_cs, ICANREACH_cs (circuit start).  The CANUREACH_ex\
    \ is\n   used to find a remote MAC and Link SAP address without establishing\n\
    \   an SSP circuit.  Upon receipt of a CANUREACH_cs message, the target\n   DLSw\
    \ starts a data link for each port, thereby obtaining a Data Link\n   Correlator.\
    \  If the target station can be reached, an ICANREACH_cs\n   message is returned\
    \ to the origin DLSw containing the Target Circuit\n   ID parameter.  Upon receipt,\
    \ the origin DLSw starts a data link and\n   returns the Origin Circuit ID to\
    \ the target DLSw within the REACH_ACK\n   message.  (Note for a full list of\
    \ message types, see section 3.5.)\n   +------------+                        \
    \        +------------+\n   |Disconnected|                                |Disconnected|\n\
    \   +------------+   CANUREACH_cs (Data Link ID)  +------------+\n       ------------------------------------------------->\n\
    \         ICANREACH_cs (Data Link ID, Target Circuit ID)\n       <------------------------------------------------\n\
    \     REACH_ACK (Data Link ID, Origin Cir ID, Target Cir ID)\n       ------------------------------------------------->\n\
    \   +------------+                                +------------+\n   |Circuit\
    \ Est.|                                |Circuit Est.|\n   +------------+     \
    \                           +------------+\n     XIDFRAME (Data Link ID, Origin\
    \ Cir ID, Target Cir ID)\n       <------------------------------------------------>\n\
    \      CONTACT (Data Link ID, Origin Cir ID, Target Cir ID)\n       ------------------------------------------------->\n\
    \     CONTACTED (Data Link ID, Origin Cir ID, Target Cir ID)\n       <-------------------------------------------------\n\
    \   +------------+                                +------------+\n   | Connected\
    \  |                                | Connected  |\n   +------------+        \
    \                        +------------+\n        INFOFRAME (Remote Circuit ID\
    \ = Target Circuit ID)\n       ------------------------------------------------->\n\
    \        INFOFRAME (Remote Circuit ID = Origin Circuit ID)\n       <-------------------------------------------------\n\
    \   During the exchange of the XIDFRAME, CONTACT, and CONTACTED messages,\n  \
    \ the pair of Circuit ID parameters is included in the message format\n   along\
    \ with the DATA LINK ID parameter.  Once the connection has been\n   established,\
    \ the INFOFRAME messages are exchanged with the shorter\n   header.  This header\
    \ contains only the Circuit ID associated with the\n   remote DLSw.  The Remote\
    \ Data Link Correlator and the Remote DLC Port\n   ID are set equal to the Data\
    \ Link Correlator and the DLC Port ID that\n   are associated with the origin\
    \ or target Data Link Switch, dependent\n   upon the direction of the packet.\n"
- title: 3.3  Correlators
  contents:
  - "3.3  Correlators\n   The local use, and contents of the Data Link Correlator,\
    \ Port ID and\n   Transport ID fields in SSP messages is an implementation choice.\n\
    \   These fields have local significance only.  The values received from\n   a\
    \ partner DLSw must not be interpreted by the DLSw that receives them\n   and\
    \ should be echoed \"as is\" to a partner DLSw in subsequent\n   messages.  All\
    \ implementations must obey the following rules in this\n   section (3.3) on the\
    \ assignment and fixing of these correlator fields\n   for each transport connection\
    \ or circuit:\n   The Transport ID fields are learned from the first SSP message\n\
    \   exchanged with a DLSw partner (the Capabilities exchange).  This\n   field\
    \ should not be varied by a DLSw after the capabilities exchange\n   and must\
    \ be reflected to the partner DLSw in every SSP control\n   message.\n   The Target\
    \ Data Link Correlator, Target Port ID and Target Transport\n   ID must remain\
    \ the same once the Target DLSw has sent the\n   ICANREACH_cs for a given circuit.\
    \  The Origin DLSw must store the\n   values specified in the ICANREACH_cs and\
    \ use these on all subsequent\n   SSP messages for this circuit.\n   The Origin\
    \ DLSw must allow these fields to vary until the\n   ICANREACH_cs is received.\
    \  Each SSP message issued for a circuit must\n   reflect the values specified\
    \ by the Target DLSw in the last SSP\n   message for this circuit received by\
    \ the Origin DLSw.  Binary zero\n   should be used if no such message has yet\
    \ been received for a given\n   circuit (apart from the Target Transport ID which\
    \ will have been\n   learnt as specified above).\n   The Origin Data Link Correlator,\
    \ Origin Port ID and Origin Transport\n   ID must remain the same once the Origin\
    \ DLSw has issued the REACH_ACK\n   for a given circuit.  The Target DLSw must\
    \ store the values specified\n   in the REACH_ACK and use these on all subsequent\
    \ SSP messages for\n   this circuit.\n   The Target DLSw must allow these fields\
    \ to vary until the REACH_ACK\n   is received.  Each SSP message issued for a\
    \ circuit must reflect the\n   values specified by the Origin DLSw in the last\
    \ SSP message for this\n   circuit received by the Target DLSw.  Binary zero should\
    \ be used if\n   no such message has yet been received for a given circuit (apart\
    \ from\n   the Origin Transport ID which will have been learnt as specified\n\
    \   above).\n   For the purposes of correlator exchange, explorer messages form\
    \ a\n   separate circuit.  Both DLSw partners must reflect the last received\n\
    \   correlator values as specified above.  However correlators learned on\n  \
    \ explorer messages need not be carried over to a subsequent circuit\n   setup\
    \ attempt.  In particular, the Origin DLSw may elect to use the\n   same values\
    \ for the Origin Data Link Correlator and Origin Port ID\n   when it issues a\
    \ CANUREACH_cs after receiving an ICANREACH_ex or\n   NETBIOS_NR_ex. However the\
    \ Target DLSw must not assume that the\n   CANUREACH_cs will specify any of the\
    \ Target Data Link Correlator or\n   Target Port ID that were exchanged on the\
    \ explorer messages.\n   Received SSP messages that require a valid Remote Circuit\
    \ ID but\n   cannot be associated with an existing circuit should be rejected\
    \ with\n   a HALT_DL_NOACK message.  This is done to prevent a situation where\n\
    \   one DLSw partner has a circuit defined while the other partner does\n   not.\
    \ The exception would be a HALT_DL_NOACK message with an invalid\n   Remote Circuit\
    \ ID.  The HALT_DL_NOACK message is typically used in\n   error situations where\
    \ a response is not appropriate.\n   The SSP messages requiring a valid Remote\
    \ Circuit ID are all messages\n   except the following: CANUREACH_ex, CANUREACH_cs,\
    \ ICANREACH_ex,\n   ICANREACH_cs, NETBIOS_NQ_cs, NETBIOS_NR_cs, DATAFRAME, NETBIOS_ANQ,\n\
    \   NETBIOS_ANR, KEEPALIVE and CAP_EXCHANGE.\n"
- title: 3.4  Largest Frame Size Field
  contents:
  - "3.4  Largest Frame Size Field\n   The Largest Frame Size (LF Size) field in the\
    \ SSP Control Header is\n   used to carry the LF Size bits across the DLSw connection.\
    \  This\n   should be used to ensure that the two end-stations always negotiate\
    \ a\n   frame size to be used on a circuit that does not require the Origin\n\
    \   and Target DLSw partners to re-segment frames.\n   This field is valid on\
    \ CANUREACH_ex, CANUREACH_cs, ICANREACH_ex,\n   ICANREACH_cs, NETBIOS_NQ_ex and\
    \ NETBIOS_NR_ex messages only. The\n   contents of this field should be ignored\
    \ on all other frames.\n   Every DLSw forwarding a SSP frame to its DLSw partner\
    \ must ensure\n   that the contents of this frame reflect the minimum capability\
    \ of the\n   route to its local end-station or any limit imposed by the DLSw\n\
    \   itself.\n   The bit-wise definition of this field is as follows (bit 7 is\
    \ the\n   most significant bit, bit 0 is the least significant bit):\n     7 \
    \  6   5   4   3   2   1   0\n   +-------------------------------+\n   | c | r\
    \ | b | b | b | e | e | e |\n   +-------------------------------+\n     c   .\
    \   .   .   .   .   .   .  LF Size Control flag\n                            \
    \        (significant on messages\n                                    from Origin\
    \ to Target\n                                    DLSw only)\n                \
    \                    0=fail circuit if route\n                               \
    \       obtained requires a\n                                      smaller LF\
    \ size\n                                    1=don't fail the circuit\n       \
    \                               but return the LF size\n                     \
    \                 obtained even if it is\n                                   \
    \   smaller\n     .   r   .   .   .   .   .   .  Reserved\n     .   .   b   .\
    \   .   .   .   .  Largest Frame Bit Base\n     .   .   .   b   .   .   .   .\
    \  Largest Frame Bit Base\n     .   .   .   .   b   .   .   .  Largest Frame Bit\
    \ Base\n     .   .   .   .   .   e   .   .  Largest Frame Bit Extended\n     .\
    \   .   .   .   .   .   e   .  Largest Frame Bit Extended\n     .   .   .   .\
    \   .   .   .   e  Largest Frame Bit Extended\n             <----- LF Bits ----->\n\
    \   Refer to IEEE 802.1D Standard, Annex C for encoding of Largest Frame\n   base\
    \ and extended bit values.\n   The Origin DLSw \"Size Control\" flag informs a\
    \ Target DLSw that\n   chooses to reply to *_cs messages on the basis of cached\
    \ information\n   that it may safely return a smaller LF Size on the ICANREACH_cs\
    \ frame\n   if it has had to choose an alternative route on which to initialize\n\
    \   the circuit.  If this bit is set to 1, the Origin DLSw takes\n   responsibility\
    \ for ensuring that the end-stations negotiate a\n   suitable frame size for the\
    \ circuit. If this bit is set to 0, the\n   Target DLSw must not reply to the\
    \ CANUREACH_cs if it cannot obtain a\n   route to the Target end station that\
    \ support an LF Size at least as\n   large as that specified in the CANUREACH_cs\
    \ frame.\n"
- title: 3.5  Message Types
  contents:
  - "3.5  Message Types\n   The following table lists the protocol data units that\
    \ are exchanged\n   between Data Link Switches.  All values not listed are reserved\
    \ for\n   potential use in follow-on releases.\n   Command          Description\
    \                       Type   flags/notes\n   -------          --------     \
    \                    ------  -----------\n   CANUREACH_ex     Can U Reach Station-explorer\
    \      0x03   SSPex\n   CANUREACH_cs     Can U Reach Station-circuit start 0x03\n\
    \   ICANREACH_ex     I Can Reach Station-explorer      0x04   SSPex\n   ICANREACH_cs\
    \     I Can Reach Station-circuit start 0x04\n   REACH_ACK        Reach Acknowledgment\
    \              0x05\n   DGRMFRAME        Datagram Frame                    0x06\
    \   (note 1)\n   XIDFRAME         XID Frame                         0x07\n   CONTACT\
    \          Contact Remote Station            0x08\n   CONTACTED        Remote\
    \ Station Contacted          0x09\n   RESTART_DL       Restart Data Link     \
    \            0x10\n   DL_RESTARTED     Data Link Restarted               0x11\n\
    \   ENTER_BUSY       Enter Busy                        0x0C   (note 2)\n   EXIT_BUSY\
    \        Exit Busy                         0x0D   (note 2)\n   INFOFRAME     \
    \   Information (I) Frame             0x0A\n   HALT_DL          Halt Data Link\
    \                    0x0E\n   DL_HALTED        Data Link Halted              \
    \    0x0F\n   NETBIOS_NQ_ex    NETBIOS Name Query-explorer       0x12   SSPex\n\
    \   NETBIOS_NQ_cs    NETBIOS Name Query-circuit setup  0x12   (note 3)\n   NETBIOS_NR_ex\
    \    NETBIOS Name Recognized-explorer  0x13   SSPex\n   NETBIOS_NR_cs    NETBIOS\
    \ Name Recog-circuit setup  0x13   (note 3)\n   DATAFRAME        Data Frame  \
    \                      0x14   (note 1)\n   HALT_DL_NOACK    Halt Data Link with\
    \ no Ack        0x19\n   NETBIOS_ANQ      NETBIOS Add Name Query            0x1A\n\
    \   NETBIOS_ANR      NETBIOS Add Name Response         0x1B\n   KEEPALIVE    \
    \    Transport Keepalive Message       0x1D   (note 4)\n   CAP_EXCHANGE     Capabilities\
    \ Exchange             0x20\n   IFCM             Independent Flow Control Message\
    \  0x21\n   TEST_CIRCUIT_REQ Test Circuit Request              0x7A\n   TEST_CIRCUIT_RSP\
    \ Test Circuit Response             0x7B\n   Note 1: Both the DGRMFRAME and DATAFRAME\
    \ messages are used to carry\n   information received by the DLC entity within\
    \ UI frames.  The\n   DGRMFRAME message is addressed according to a pair of Circuit\
    \ IDs,\n   while the DATAFRAME message is addressed according to a Data Link ID,\n\
    \   being composed of a pair of MAC addresses and a pair of link SAP\n   addresses.\
    \ The latter is employed prior to the establishment of an\n   end-to-end circuit\
    \ when Circuit IDs have yet to be established or\n   during circuit restart when\
    \ Data Links are reset.\n   Note 2: These messages are not used for the DLSw Standard\
    \ but may be\n   used by older DLSw implementations.  They are listed here for\n\
    \   informational purposes.  These messages were added after publication\n   of\
    \ RFC 1434 and were deleted in this standard (adaptive pacing is now\n   used\
    \ instead).\n   Note 3: These messages are not normally issued by a Standard DLSw,\n\
    \   which uses the NB_*_ex messages as shown in section 5.4.  However if\n   a\
    \ Standard DLSw attempts to interoperate with older DLSw\n   implementations,\
    \ these messages correspond to the NETBIOS_NQ and\n   NETBIOS_NR messages used\
    \ in RFC1434 both to locate the resource and\n   to setup a circuit.  This document\
    \ does not attempt to provide a\n   complete specification of the use of these\
    \ messages.\n   Note 4:  A KEEPALIVE message may be sent by a DLSw to a partner\
    \ DLSw\n   in order to verify the TCP connection (or other future SSP carrying\n\
    \   protocol) is still functioning.  If received by a DLSw, this message\n   is\
    \ discarded and ignored.  Use of this message is optional.\n   For the exchange\
    \ of NetBIOS control messages, the entire DLC header\n   is carried as part of\
    \ the message unit.  This includes the MAC\n   header, with the routing information\
    \ field padded to 18 bytes, and\n   the LLC header. The following message types\
    \ are affected:\n   NETBIOS_NQ, NETBIOS_NR, NETBIOS_ANQ, NETBIOS_ANR, and DATAFRAME\
    \ when\n   being used by NetBIOS systems.  The routing information in the DLC\n\
    \   header is not used by the remote Data Link Switch upon receiving the\n   above\
    \ five messages.\n   Any SSP message types not defined above if received by a\
    \ DLSw are to\n   be ignored (i.e., no error action is to be performed).  A Data\
    \ Link\n   Switch should quietly drop any SSP message with a Message Type that\n\
    \   is not recognized or not supported.  Receipt of such a message should\n  \
    \ not cause the termination of the transport connection to the message\n   sender.\n"
- title: 4.  Circuit Priority
  contents:
  - "4.  Circuit Priority\n   At circuit start time, each circuit end point will provide\
    \ priority\n   information to its circuit partner.  The initiator of the circuit\n\
    \   will choose which circuit priority will be effective for the life of\n   the\
    \ circuit.  If Priority is not implemented by the Data Link Switch,\n   then \"\
    Unsupported\" priority is used.\n"
- title: 4.1  Frame format
  contents:
  - "4.1  Frame format\n   Circuit priority will be valid in the CANUREACH_cs, ICANREACH_cs,\
    \ and\n   REACH_ACK frames only. The relevant header field is shown below.  The\n\
    \   Circuit Priority value is a byte value at offset 22 in an SSP Control\n  \
    \ Message.\n   The following describes the format of the Circuit Priority byte.\n\
    \     7   6   5   4   3   2   1   0\n   +-------------------+-----------+\n  \
    \ |   reserved        |    CP     |\n   +-------------------+-----------+\n  \
    \ CP: Circuit Priority bits\n           000 - Unsupported       (note 1)\n   \
    \        001 - Low Priority\n           010 - Medium Priority\n           011\
    \ - High Priority\n           100 - Highest Priority\n           101 to 111 are\
    \ reserved for future use\n   Note 1: Unsupported means that the Data Link Switch\
    \ that originates\n   the circuit does not implement priority.  Actions taken\
    \ on\n   Unsupported priority are vendor specific.\n"
- title: 4.2  Circuit Startup
  contents:
  - "4.2  Circuit Startup\n   The sender of a CANUREACH_cs is responsible for setting\
    \ the CP bits\n   to reflect the priority it would like to use for the circuit\
    \ being\n   requested.  The mechanism for choosing an appropriate value is\n \
    \  implementation dependent.  The sender of an ICANREACH_cs frame will\n   set\
    \ the CP bits to reflect the priority it would like to use for the\n   circuit\
    \ being requested, with the mechanism for choosing the\n   appropriate value being\
    \ implementation dependent.  The receiver of\n   the ICANREACH_cs will select\
    \ from the priorities in the CANUREACH_cs\n   and ICANREACH_cs frames, and will\
    \ set the value in the CP field of\n   the REACH_ACK frame that follows to the\
    \ value to be used for this\n   circuit.  This priority will be used for the life\
    \ of the circuit.  A\n   CANUREACH_cs or ICANREACH_cs with the circuit priority\
    \ value set to\n   Unsupported (CP=000) indicates that the sender does not support\
    \ the\n   circuit priority function.\n   Flow:\n      DLSw A               DLSw\
    \ B\n   CANUREACH_cs (CP=011) ----->           Circuit initiator requests\n  \
    \                                        high Priority.\n        <--------- ICANREACH_cs\
    \ (CP=010)  Circuit target requests\n                                        \
    \  medium priority.\n   REACH_ACK (CP=010) -------->           Circuit initiator\
    \ sets\n                                          the priority for this\n    \
    \                                      circuit to medium. The\n              \
    \                            circuit initiator could\n                       \
    \                   choose either high or\n                                  \
    \        medium in this example.\n"
- title: 5.  DLSw State Machine
  contents:
  - "5.  DLSw State Machine\n   The following state tables describe the states for\
    \ a single circuit\n   through the Data Link Switch.  State information is kept\
    \ for each\n   connection.  The initial state for a connection is DISCONNECTED.\
    \  The\n   steady state is either CIRCUIT_ESTABLISHED or CONNECTED.  In the former\n\
    \   state, an end-to-end circuit has been established allowing the support\n \
    \  of Type 1 LLC between the end systems.  The latter state exists when an\n \
    \  end-to-end connection has been established for the support of Type 2 LLC\n\
    \   services between the end systems.\n   For SNA, LLC type 2 connection establishment\
    \ is via the use of IEEE\n   802.2 Test or XID  frames.  SNA devices send these\
    \ frames to the null\n   SAP in order to determine the source route information\
    \ in support of\n   bridging.  Normally SNA devices use SAP 0x04, 0x08, or 0x0C\
    \  (most SNA\n   LLC2 devices that have a single PU per MAC address use a default\
    \ of\n   0x04).  Typically the SAP would be used to determine if the Test frames\n\
    \   should be sent to the DLSw code in the router.  If both bridging and\n   DLSw\
    \ are enabled, this allows the product to ensure that SNA frames are\n   not both\
    \ bridged and switched.  Note that although typically SNA uses a\n   DSAP and\
    \ SSAP of 0x04, it allows for other SAPs to be configured and\n   supports unequal\
    \ SAPs.  This allows multiple PUs to share connections\n   between two given MAC\
    \ addresses (each PU to PU session uses one LLC2\n   connection).\n   For NetBIOS,\
    \ LLC type 2 connection establishment is via the Name Query\n   and Name Recognized\
    \ frames.  These frames are used for both address\n   resolution and source route\
    \ determination.  NetBIOS devices use SAP\n   0xF0.\n"
- title: 5.1  Data Link Switch States
  contents:
  - "5.1  Data Link Switch States\n   The Switch-to-Switch Protocol is formally defined\
    \ through the state\n   machines described in this chapter.  The following table\
    \ lists the\n   thirteen possible states for the main circuit FSM.  A separate\
    \ state\n   machine instance is employed for each end-to-end circuit that is\n\
    \   maintained by the Data Link Switch.\n   State Name            Description\n\
    \   ----------            -----------\n   CIRCUIT_ESTABLISHED   The end-to-end\
    \ circuit has been\n                         established.  At this time LLC Type\
    \ 1\n                         services are available from end-to-end.\n   CIRCUIT_PENDING\
    \       The target DLSw is awaiting a REACH_ACK\n                         response\
    \ to an ICANREACH_cs message.\n   CIRCUIT_RESTART       The DLSw that originated\
    \ the reset is\n                         awaiting the restart of the data link\n\
    \                         and the DL_RESTARTED response to a\n               \
    \          RESTART_DL message.\n   CIRCUIT_START         The origin DLSw is awaiting\
    \ a\n                         ICANREACH_cs in response to a\n                \
    \         CANUREACH_cs message.\n   CONNECTED             The end-to-end connection\
    \ has\n                         been established thereby allowing\n          \
    \               LLC Type 2 services from end-to-end\n                        \
    \ in addition to LLC Type 1 services.\n   CONNECT_PENDING       The origin DLSw\
    \ is awaiting the\n                         CONTACTED response to a CONTACT\n\
    \                         message.\n   CONTACT_PENDING       The target DLSw is\
    \ awaiting the\n                         DLC_CONTACTED confirmation to a\n   \
    \                      DLC_CONTACT signal (i.e., DLC\n                       \
    \  is waiting for a UA response to\n                         an SABME command).\n\
    \   DISCONNECTED          The initial state with no circuit\n                \
    \         or connection established, the\n                         DLSw is awaiting\
    \ either a\n                         CANUREACH_cs, or an ICANREACH_cs.\n   DISCONNECT_PENDING\
    \    The DLSw that originated the\n                         disconnect is awaiting\
    \ the DL_HALTED\n                         response to a HALT_DL message.\n   HALT_PENDING\
    \          The remote DLSw is awaiting the\n                         DLC_DL_HALTED\
    \ indication following\n                         the DLC_HALT_DL request (i.e.,\
    \ DLC\n                         is waiting for a UA response to a\n          \
    \               DISC command), due to receiving a\n                         HALT_DL\
    \ message.\n   HALT_PENDING_NOACK    The remote DLSw is awaiting the\n       \
    \                  DLC_DL_HALTED indication following\n                      \
    \   the DLC_HALT_DL request (i.e., DLC\n                         is waiting for\
    \ a UA response to a\n                         DISC command), due to receiving\
    \ a\n                         HALT_DL_NOACK message.\n   RESTART_PENDING     \
    \  The remote DLSw is awaiting the\n                         DLC_DL_HALTED indication\
    \ following\n                         the DLC_HALT_DL request (i.e., DLC\n   \
    \                      is waiting for a UA response to a\n                   \
    \      DISC command), and the restart of\n                         the data link.\n\
    \   RESOLVE_PENDING       The target DLSw is awaiting\n                      \
    \   the DLC_DL_STARTED indication\n                         following the DLC_START_DL\
    \ request\n                         (i.e., DLC is waiting for a Test\n       \
    \                  response as a result of sending a\n                       \
    \  Test command).\n   The DISCONNECTED state is the initial state for a new circuit.\
    \  One\n   end station starts the connection via an XID or SABME command (i.e.,\n\
    \   DLC_XID or DLC_CONTACTED).  Upon receipt, the Data Link Switches\n   exchange\
    \ a set of CANUREACH_cs, ICANREACH_cs and REACH_ACK messages.\n   Upon completion\
    \ of this three-legged exchange both Data Link Switches\n   will be in the CIRCUIT_ESTABLISHED\
    \ state.  Three pending states also\n   exist during this exchange.  The CIRCUIT_START\
    \ state is entered by\n   the origin Data Link Switch after it has sent the CANUREACH_cs\n\
    \   message.  The RESOLVE_PENDING state is entered by the target Data\n   Link\
    \ Switch awaiting a Test response to a Test Command.  And lastly,\n   the CIRCUIT_PENDING\
    \ state is entered by the target DLSw awaiting the\n   REACH_ACK reply to an ICANREACH_cs\
    \ message.\n   The CIRCUIT_ESTABLISHED state allows for the exchange of LLC Type\
    \ 1\n   frames such as the XID exchanges between SNA stations that occurs\n  \
    \ prior to the establishment of a connection.  Also, datagram traffic\n   (i.e.,\
    \ UI frames)  may be sent and received between the end stations.\n   These exchanges\
    \ use the XIDFRAME and DGRMFRAME messages sent between\n   the Data Link Switches.\n\
    \   In the CIRCUIT_ESTABLISHED state, the receipt of a SABME command\n   (i.e.,\
    \ DLC_CONTACTED) causes the origin DLSw to issue a CONTACT\n   message, to send\
    \ an RNR supervisory frame (i.e., DLC_ENTER_BUSY) to\n   the origin station, and\
    \ to enter the CONNECT_PENDING state awaiting a\n   CONTACTED message.  The target\
    \ DLSw, upon the receipt of a CONTACT\n   message, will issue a SABME command\
    \ (i.e., DLC_CONTACT) and enter the\n   Contact Pending state.  Once the UA response\
    \ is received (i.e.,\n   DLC_CONTACTED), the target DLSw sends a CONTACTED message\
    \ and enters\n   the CONNECTED state. When received, the origin DLSw enters the\n\
    \   CONNECTED state and sends an RR supervisory frame (i.e.,\n   DLC_EXIT_BUSY).\n\
    \   The CONNECTED state is the steady state for normal data flow once a\n   connection\
    \ has been established.  Information frames (i.e., INFOFRAME\n   messages) are\
    \ simply sent back and forth between the end points of\n   the connection.  This\
    \ is the path that should be optimized for\n   performance.\n   The connection\
    \ is terminated upon the receipt of a DISC frame or\n   under some other error\
    \ condition detected by DLC (i.e., DLC_ERROR).\n   Upon receipt of this indication,\
    \ the DLSw will halt the local data\n   link, send a HALT_DL message to the remote\
    \ DLSw, and enter the\n   DISCONNECT_PENDING State.  When the HALT_DL frame is\
    \ received by the\n   other DLSw, the local DLC is halted for this data link,\
    \ a DL_HALTED\n   message is returned, and the DISCONNECTED state is entered.\
    \  Receipt\n   of this DL_HALTED message causes the other DLSw to also enter the\n\
    \   DISCONNECTED state.\n   The CIRCUIT_RESTART state is entered if one of the\
    \ Data Link Switches\n   receives a SABME command  (i.e., DLC_RESET) after data\
    \ transfer while\n   in the CONNECTED state.  This causes a DM command to be returned\
    \ to\n   the origin station and a RESTART_DL message to be sent to the remote\n\
    \   Data Link Switch. This causes the remote data link to be halted and\n   then\
    \ restarted.  The remote DLSw will then send a DL_RESTARTED\n   message back to\
    \ the first DLSw.  The receipt of the DL_RESTARTED\n   message causes the first\
    \ DLSw to issue a new CONTACT message,\n   assuming that the local DLC has been\
    \ contacted (i.e., the origin\n   station has resent the SABME command).  This\
    \ is eventually responded\n   to by a CONTACTED message. Following this exchange,\
    \ both Data Link\n   Switches will return to the CONNECTED state.  If the local\
    \ DLC has\n   not been contacted, the receipt of a DL_RESTARTED command causes\
    \ the\n   Data Link Switch to enter the CIRCUIT_ESTABLISHED state awaiting the\n\
    \   receipt of a SABME command (i.e., DLC_CONTACTED signal).\n   The HALT_PENDING,\
    \ HALT_PENDING_NOACK and RESTART_PENDING states\n   correspond to the cases when\
    \ the Data Link Switch is awaiting\n   responses from the local station on the\
    \ adjacent LAN (e.g., a UA\n   response to a DISC command). Also in the RESTART_PENDING\
    \ state, the\n   Data Link Switch will attempt to restart the data link prior\
    \ to\n   sending a DL_RESTARTED message.  For some implementations, the start\n\
    \   of a data link involves the exchange of a Test command/response on\n   the\
    \ adjacent LAN (i.e., DLC_START_DL).  For other implementations,\n   this additional\
    \ exchange may not be required.\n"
- title: 5.2  State Transition Tables
  contents:
  - "5.2  State Transition Tables\n   This section provides a detailed representation\
    \ of the Data Link\n   Switch, as documented by a single state machine.  Many\
    \ of the\n   transitions are dependent upon local signals between the Data Link\n\
    \   Switch entity and one of the DLC entities.  These signals and their\n   definitions\
    \ are given in the following tables.\n   DLC Events:\n   Event Name      Description\n\
    \   ----------      -----------\n   DLC_CONTACTED   Contact Indication:  DLC has\
    \ received an SABME\n                   command or DLC has received a UA response\
    \ as a\n                   result of sending an SABME command.\n   DLC_DGRM  \
    \      Datagram Indication:  DLC has received a UI frame.\n   DLC_ERROR      \
    \ Error condition indicated by DLC:  Such a\n                   condition occurs\
    \ when a DISC command is received\n                   or when DLC experiences\
    \ an unrecoverable error.\n   DLC_INFO        Information Indication:  DLC has\
    \ received an\n                   Information (I) frame.\n   DLC_DL_HALTED   Data\
    \ Link Halted Indication:  DLC has\n                   received a UA response\
    \ to a DISC command.\n   DLC_DL_STARTED  Data Link Started Indication:  DLC has\n\
    \                   received a Test response from the null SAP.\n   DLC_RESET\
    \       Reset Indication:  DLC has received an SABME\n                   command\
    \ during the time a connection is\n                   currently active and has\
    \ responded with DM.\n   DLC_RESOLVE_C   Resolve Command Indication:  DLC has\
    \ received\n                   a Test command addressed to the null SAP, or an\n\
    \                   XID command addressed to the null SAP.\n   DLC_RESOLVED  \
    \  Resolve request:  DLC has received a TEST response\n                   frame\
    \ (or equivalent for non-LAN DLCs) but has not\n                   reserved the\
    \ resources required for a circuit yet.\n   DLC_XID         XID Indication:  DLC\
    \ has received an XID command\n                   or response to a non-null SAP.\n\
    \   Other Events:\n   Event Name      Description\n   ----------      -----------\n\
    \   XPORT_FAILURE   Failure of the transport connection used by the\n        \
    \           circuit.\n   CS_TIMER_EXP    The CIRCUIT_START timer (started when\
    \ the circuit\n                   went into CIRCUIT_START state) has expired.\n\
    \   DLC Actions:\n   Action Name     Description\n   -----------     -----------\n\
    \   DLC_CONTACT     Contact Station Request:  DLC will send a SABME\n        \
    \           command or a UA response to an outstanding SABME\n               \
    \    command.\n   DLC_DGRM        Datagram Request:  DLC will send a UI frame.\n\
    \   DLC_ENTER_BUSY  Enter Link Station Busy:  DLC will send an\n             \
    \      RNR supervisory frame.\n   DLC_EXIT_BUSY   Exit Link Station Busy:  DLC\
    \ will send an RR\n                   supervisory frame.\n   DLC_HALT_DL     Halt\
    \ Data Link Request:  DLC will send a DISC\n                   command.\n   DLC_INFO\
    \        Information Request:  DLC will send an I frame.\n   DLC_RESOLVE     Resolve\
    \ request:  DLC should issue a TEST (or\n                   appropriate equivalent\
    \ for non-LAN DLCs) but need\n                   not reserve the resources required\
    \ for a circuit yet.\n   DLC_RESOLVE_R   Resolve Response Request:  DLC will send\
    \ a\n                   Test response or XID response from the null SAP.\n   DLC_START_DL\
    \    Start Data Link Request:  DLC will send a Test\n                   command\
    \ to the null SAP.\n   DLC_XID         XID Request:  DLC will send an XID command\
    \ or an\n                   XID response.\n   Other Actions:\n   Action Name \
    \    Description\n   ----------      -----------\n   START_CS_TIMER  Start the\
    \ CIRCUIT_START timer.\n   DLC_RESOLVE_R and DLC_START_DL actions require the\
    \ DLC to reserve the\n   resources necessary for a link station as they are used\
    \ only when a\n   circuit is about to be started.  The DLC_RESOLVE action is used\
    \ for\n   topology explorer traffic and does not require such resources to be\n\
    \   reserved, though a DLC implementation may choose not to distinguish\n   this\
    \ from the DLC_START_DL action.  See section 5.4 for details of\n   the actions\
    \ and events for explorer frames.\n   The Data Link Switch is described by a state\
    \ transition table as\n   documented in the following sections.  Each of the states\
    \ is\n   described below in terms of the events, actions, and next state for\n\
    \   each transition. If a particular event is not listed for a given\n   state,\
    \ no action and no state transition should occur for that event.\n   Any significant\
    \ comments concerning the transitions within a given\n   state are given immediately\
    \ following the table representing the\n   state.\n   A separate state machine\
    \ instance is maintained by the Data Link\n   Switch for each end-to-end circuit.\
    \  The number of circuits that may\n   be supported by each Data Link Switch is\
    \ a local implementation\n   option.\n   The CANUREACH_ex, ICANREACH_ex, NETBIOS_NQ_ex,\
    \ and NETBIOS_NR_ex are\n   SSP messages that are not associated with a particular\
    \ circuit.  The\n   processing of these messages is covered in section 5.4.\n"
- title: 5.2.1  DISCONNECTED State
  contents:
  - "5.2.1  DISCONNECTED State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive CANUREACH_cs | DLC_START_DL        | RESOLVE_PENDING      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DATAFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_XID              | If source route     | If CANUREACH_cs was  |\n   |  \
    \                    | bridged frame with  | sent:                |\n   |    \
    \                  | broadcast indicated:|   CIRCUIT_START      |\n   |      \
    \                |   Send CANUREACH_ex |                      |\n   |        \
    \              | else:               |                      |\n   |          \
    \            |   Send CANUREACH_cs |                      |\n   |            \
    \          |   START_CS_TIMER    |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM             | If NETBIOS          |                      |\n  \
    \ |                      | NAME_QUERY:         |                      |\n   |\
    \                      |  Send NETBIOS_NQ_ex |                      |\n   |  \
    \                    | else:               |                      |\n   |    \
    \                  |  Send DATAFRAME     |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_CONTACTED        | Send CANUREACH_cs   | CIRCUIT_START        |\n  \
    \ +----------------------+---------------------+----------------------+\n   It\
    \ is assumed that each Data Link Switch will build a set of topology\n   tables\
    \ giving the identity of each Data Link Switch that can reach a\n   specific MAC\
    \ address or a specific NetBIOS name.  This table can be\n   built  using the\
    \ explorer frames, as per the Explorer FSM in section\n   5.4.  As a consequence,\
    \ the amount of search traffic can be kept to a\n   minimum.\n   Upon receipt\
    \ of a TEST command, broadcast XID or NetBIOS NAME_QUERY,\n   the Data Link Switch\
    \ checks the topology table for the target MAC/SAP\n   or NetBIOS name.  If there\
    \ is no matching entry in the table, the\n   Data Link Switch uses the explorer\
    \ FSMs in section 5.4 to locate the\n   target MAC/SAP or NetBIOS name.\n   When\
    \ the first non-broadcast XID or SABME flows,  the Data Link\n   Switch issues\
    \ a CANUREACH_cs to attempt to start a circuit.  The\n   CANUREACH_cs message\
    \ is sent to only those Data Link Switches that\n   are known to be able to reach\
    \ the given MAC address.  The mechanism\n   by which a topology table entry is\
    \ determined to be out-of-date and\n   is deleted from the table is implementation\
    \ specific.\n   The DISCONNECTED state is exited upon the sending of a CANUREACH_cs\n\
    \   by the origin DLSw or the receipt of a CANUREACH_cs message by a\n   prospective\
    \ target Data Link Switch.  In the latter case, the Data\n   Link Switch will\
    \ issue a Test command to the target station (i.e.,\n   DLC_START_DL signal is\
    \ presented to DLC).\n"
- title: 5.2.2  RESOLVE_PENDING State
  contents:
  - "5.2.2  RESOLVE_PENDING State\n   +-------------------+-----------------------+-----------------------+\n\
    \   |        Event      |      Action(s)        |      Next State       |\n  \
    \ +-------------------+-----------------------+-----------------------+\n   |\
    \ Receive DATAFRAME | DLC_DGRM              |                       |\n   +-------------------+-----------------------+-----------------------+\n\
    \   | DLC_DL_STARTED    | If LF value of        | If LF value of        |\n  \
    \ |                   | DLC_DL_STARTED        | DLC_DL_STARTED        |\n   |\
    \                   | is greater than or    | is greater than or    |\n   |  \
    \                 | equal to LF Size of   | equal to LF Size of   |\n   |    \
    \               | CANUREACH_cs or LF    | CANUREACH_cs or LF    |\n   |      \
    \             | Size Control bit set: | Size Control bit set: |\n   |        \
    \           |   Send ICANREACH_cs   |   CIRCUIT_PENDING     |\n   |          \
    \         | else:                 | else:                 |\n   |            \
    \       |   Send DLC_HALT_DL    |   HALT_PENDING_NOACK  |\n   +-------------------+-----------------------+-----------------------+\n\
    \   | DLC_ERROR         |                       | DISCONNECTED          |\n  \
    \ +-------------------+-----------------------+-----------------------+\n   |\
    \ DLC_DGRM          | Send DATAFRAME        |                       |\n   +-------------------+-----------------------+-----------------------+\n\
    \   The RESOLVE_PENDING state is entered upon receipt of a CANUREACH_cs\n   message\
    \ by the target DLSw.  A data link is started, causing a Test\n   command to be\
    \ sent by the DLC.\n   Several CANUREACH_cs messages can be received in the RESOLVE_PENDING\n\
    \   state.  The Data Link Switch may update its topology information\n   based\
    \ upon the origin MAC address information in each CANUREACH_cs\n   message.\n\
    \   Upon the receipt of a DLC_DL_STARTED signal in the RESOLVE_PENDING\n   state,\
    \ the Data Link Switch may update its topology table base upon\n   the remote\
    \ MAC address information.  The ICANREACH_cs message must be\n   returned to the\
    \ first partner DLSw from which a CANUREACH_cs was\n   received for this circuit,\
    \ or an implementation may optionally reply\n   to all partners from which the\
    \ CANUREACH_cs was received.\n   The RESOLVE_PENDING state is exited once the\
    \ data link has been\n   started (i.e., a DLC_DL_STARTED signal is received as\
    \ a result of a\n   Test response received by the DLC).  The target Data Link\
    \ Switch then\n   enters the CIRCUIT_PENDING state.\n"
- title: 5.2.3  CIRCUIT_START State
  contents:
  - "5.2.3  CIRCUIT_START State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive CANUREACH_cs | If origin MAC addr  | If DLC_START_DL      |\n   | for\
    \ circuit in       | in CANUREACH_cs is  | issued:              |\n   | opposite\
    \ direction   | greater than origin |   RESOLVE_PENDING    |\n   |           \
    \           | MAC addr of circuit:|                      |\n   |             \
    \         |   DLC_START_DL      |                      |\n   |               \
    \       | else:               |                      |\n   |                 \
    \     |   no action taken   |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive ICANREACH_cs | If LF Size Control  | If LF Size Control   |\n  \
    \ |                      | bit set and LF Size | bit set and LF Size  |\n   |\
    \                      | is not negotiable:  | is not negotiable:   |\n   |  \
    \                    |   Send HALT_DL_NOACK|   DISCONNECTED       |\n   |    \
    \                  | else:               | else if Connected:   |\n   |      \
    \                |   Send REACH_ACK,   |   CONNECT_PENDING    |\n   |        \
    \              |   Send appropriate  | else:                |\n   |          \
    \            |   SSP message based |   CIRCUIT_ESTABLISHED|\n   |            \
    \          |   on the event      |                      |\n   |              \
    \        |   that generated    |                      |\n   |                \
    \      |   CANUREACH_cs      |                      |\n   |                  \
    \    |   (see Note)        |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM             | Send DATAFRAME      |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_ERROR            |                     | DISCONNECTED         |\n   +----------------------+---------------------+----------------------+\n\
    \   | CS_TIMER_EXP         |                     | DISCONNECTED         |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ XPORT_FAILURE        |                     | DISCONNECTED         |\n   +----------------------+---------------------+----------------------+\n\
    \   The CIRCUIT_START state is entered by the origin Data Link Switch\n   when\
    \ a DLC_XID or DLC_CONTACTED signal has been received from the\n   DLC.\n   The\
    \ CIRCUIT_START state is exited upon receipt of an ICANREACH_cs\n   message. \
    \ A REACH_ACK message is returned to the target Data Link\n   Switch.  If the\
    \ CIRCUIT_START state was entered due to a DLC_XID\n   signal, an XIDFRAME message\
    \ containing the XID is sent to the target\n   Data Link Switch.  If the CIRCUIT_START\
    \ state was entered due to a\n   DLC_CONTACTED signal, a CONTACT message is sent\
    \ to the target Data\n   Link Switch.\n"
- title: 5.2.4  CIRCUIT_PENDING State
  contents:
  - "5.2.4  CIRCUIT_PENDING State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive CONTACT      | DLC_CONTACT         | CONTACT_PENDING      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive HALT_DL      | DLC_HALT_DL         | HALT_PENDING         |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive HALT_DL_NOACK| DLC_HALT_DL         | HALT_PENDING_NOACK   |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive REACH_ACK    | If Connected:       | If Connected:        |\n  \
    \ |                      |  Send CONTACT       |  CONNECT_PENDING,    |\n   |\
    \                      |                     | else:                |\n   |  \
    \                    |                     |  CIRCUIT_ESTABLISHED |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive XIDFRAME     | DLC_XID             |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive DGRMFRAME    | DLC_DGRM            |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DATAFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_CONTACTED        | If UA is sent in    |                      |\n   |  \
    \                    | response to SABME:  |                      |\n   |    \
    \                  |   DLC_ENTER_BUSY    |                      |\n   |      \
    \                | else:               |                      |\n   |        \
    \              |   no action taken   |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_ERROR            |                     | DISCONNECTED         |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_XID              | Drop or hold until  |                      |\n   |  \
    \                    | REACH_ACK received  |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM             | Send DATAFRAME      |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ XPORT_FAILURE        | DLC_HALT_DL         | HALT_PENDING_NOACK   |\n   +----------------------+---------------------+----------------------+\n\
    \   The CIRCUIT_PENDING state is entered by the target Data Link Switch\n   following\
    \ the sending of an ICANREACH_cs message.  In this state it\n   is awaiting the\
    \ reception of a REACH_ACK message from the origin Data\n   Link Switch.\n   If\
    \ the target Data Link Switch happens to receive a SABME command\n   from the\
    \ target station while in the CIRCUIT_PENDING state (i.e., a\n   DLC_CONTACTED\
    \ signal received from the DLC), the reception of the\n   REACH_ACK message causes\
    \ the target Data Link Switch to enter the\n   CONNECT_PENDING state and to send\
    \ a CONTACT message to the origin\n   Data Link Switch.\n   If no such SABME is\
    \ received, the receipt of the REACH_ACK causes the\n   Data Link Switch to enter\
    \ CIRCUIT_ESTABLISHED state.\n"
- title: 5.2.5  CONNECT_PENDING State
  contents:
  - "5.2.5  CONNECT_PENDING State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive CONTACTED    | If UA was sent in   | CONNECTED            |\n   |  \
    \                    | response to SABME:  |                      |\n   |    \
    \                  |   DLC_EXIT_BUSY     |                      |\n   |      \
    \                | else:               |                      |\n   |        \
    \              |   DLC_CONTACT       |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive HALT_DL      | DLC_HALT_DL         | HALT_PENDING         |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive HALT_DL_NOACK| DLC_HALT_DL         | HALT_PENDING_NOACK   |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DGRMFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive DATAFRAME    | DLC_DGRM            |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive ICANREACH_cs | Send HALT_DL_NOACK  |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_RESET            | Send RESTART_DL     | CIRCUIT_RESTART      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_ERROR            | Send HALT_DL        | DISCONNECT_PENDING   |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_DGRM             | Send DGRMFRAME      |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | XPORT_FAILURE        | DLC_HALT_DL         | HALT_PENDING_NOACK   |\n  \
    \ +----------------------+---------------------+----------------------+\n   The\
    \ CONNECT_PENDING state is entered when a DLC_CONTACTED signal has\n   been received\
    \ from the DLC (i.e., a SABME command has been received).\n   A CONTACT message\
    \ it then  issued.  The state is exited upon the\n   receipt of a CONTACTED message.\
    \  If a DLC_RESET signal is received,\n   the local data link is restarted and\
    \ a RESTART_DL message is sent to\n   the remote DLSw.\n   An ICANREACH_cs received\
    \ after the transition to CONNECT_PENDING\n   state indicates that more than one\
    \ CANUREACH_cs was sent at circuit\n   establishment time and the target station\
    \ was found by more than one\n   Data Link Switch partner.  A HALT_DL_NOACK is\
    \ sent to halt the\n   circuit started by the Data Link Switch partner that originated\
    \ each\n   such ICANREACH_cs.\n   Note:  Some implementations will also send a\
    \ Test command in order to\n   restart the data link to the station that sent\
    \ the SABME command\n   (i.e., a DLC_START_DL will be issued).\n"
- title: 5.2.6  CIRCUIT_ESTABLISHED State
  contents:
  - "5.2.6  CIRCUIT_ESTABLISHED State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive CONTACT      | DLC_CONTACT         | CONTACT_PENDING      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive HALT_DL      | DLC_HALT_DL         | HALT_PENDING         |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive HALT_DL_NOACK| DLC_HALT_DL         | HALT_PENDING_NOACK   |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive XIDFRAME     | DLC_XID             |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive DGRMFRAME    | DLC_DGRM            |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DATAFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive ICANREACH_cs | Send HALT_DL_NOACK  |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_CONTACTED        | Send CONTACT        | CONNECT_PENDING      |\n  \
    \ |                      | If UA is sent in    |                      |\n   |\
    \                      | response to SABME:  |                      |\n   |  \
    \                    |   DLC_ENTER_BUSY    |                      |\n   |    \
    \                  | else:               |                      |\n   |      \
    \                |   no action taken   |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_ERROR            | Send HALT_DL        | DISCONNECT_PENDING   |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_DGRM             | Send DGRMFRAME      |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_XID              | Send XIDFRAME       |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ XPORT_FAILURE        | DLC_HALT_DL         | HALT_PENDING_NOACK   |\n   +----------------------+---------------------+----------------------+\n\
    \   The CIRCUIT_ESTABLISHED state is entered by the origin Data Link\n   Switch\
    \ from the CIRCUIT_START state, and by the target Data Link\n   Switch from the\
    \ CIRCUIT_PENDING state.  The state is exited when a\n   connection is started\
    \ (i.e., DLC receives a SABME command) or CONTACT\n   is received. The next state\
    \ is CONTACT_PENDING or CONNECT_PENDING.\n   An ICANREACH_cs received after the\
    \ transition to CIRCUIT_ESTABLISHED\n   state indicates that more than one CANUREACH_cs\
    \ was sent at circuit\n   establishment time and the target station was found\
    \ by more than one\n   Data Link Switch partner.  A HALT_DL_NOACK is sent to halt\
    \ the\n   circuit started by the Data Link Switch partner that originated each\n\
    \   such ICANREACH_cs.\n"
- title: 5.2.7  CONTACT_PENDING State
  contents:
  - "5.2.7  CONTACT_PENDING State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive HALT_DL      | DLC_HALT_DL         | HALT_PENDING         |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive HALT_DL_NOACK| DLC_HALT_DL         | HALT_PENDING_NOACK   |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive RESTART_DL   | DLC_HALT_DL         | RESTART_PENDING      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DGRMFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive DATAFRAME    | DLC_DGRM            |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_CONTACTED        | Send CONTACTED      | CONNECTED            |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_ERROR            | Send HALT_DL        | DISCONNECT_PENDING   |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM             | Send DGRMFRAME      |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ XPORT_FAILURE        | DLC_HALT_DL         | HALT_PENDING_NOACK   |\n   +----------------------+---------------------+----------------------+\n\
    \   The CONTACT_PENDING state is entered upon the receipt of a CONTACT\n   message,\
    \ which causes the Data Link Switch to issue a DLC_CONTACT\n   signal to the DLC\
    \ (i.e., DLC sends a SABME command).  This state is\n   then exited upon the receipt\
    \ of a DLC_CONTACTED signal from the DLC\n   (i.e., a UA response received).\n\
    \   If a RESTART_DL message is received, indicating that the remote Data\n   Link\
    \ Switch has received a DLC_RESET signal, the local Data Link\n   Switch sends\
    \ a DISC command frame on the adjacent LAN (i.e.,\n   DLC_HALT_DL signal) and\
    \ enter the RESTART_PENDING state.\n   An ICANREACH_cs received after the transition\
    \ to CONTACT_PENDING\n   state indicates that more than one CANUREACH_cs was sent\
    \ at circuit\n   establishment time and the target station was found by more than\
    \ one\n   Data Link Switch partner.  A HALT_DL_NOACK is sent to halt the data\n\
    \   link started by the Data Link Switch partner that originated this\n   ICANREACH_cs.\n"
- title: 5.2.8  CONNECTED State
  contents:
  - "5.2.8  CONNECTED State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive HALT_DL      | DLC_HALT_DL         | HALT_PENDING         |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive HALT_DL_NOACK| DLC_HALT_DL         | HALT_PENDING_NOACK   |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive RESTART_DL   | DLC_HALT_DL         | RESTART_PENDING      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DGRMFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive INFOFRAME    | DLC_INFO            |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DATAFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive XIDFRAME     | If non-activation   |                      |\n   |  \
    \                    | XID3:               |                      |\n   |    \
    \                  |   DLC_XID           |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive ICANREACH_cs | Send HALT_DL_NOACK  |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive ENTER_BUSY   | DLC_ENTER_BUSY      |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive EXIT_BUSY    | DLC_EXIT_BUSY       |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Rec TEST_CIRCUIT_REQ | Snd TEST_CIRCUIT_RSP|                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_RESET            | Send RESTART_DL     | CIRCUIT_RESTART      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_ERROR            | Send HALT_DL        | DISCONNECT_PENDING   |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM             | Send DGRMFRAME      |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_INFO             | Send INFOFRAME      |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_XID              | If non-activation   |                      |\n  \
    \ |                      | XID3:               |                      |\n   |\
    \                      |   Send XIDFRAME     |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | XPORT_FAILURE        | DLC_HALT_DL         | HALT_PENDING_NOACK   |\n  \
    \ +----------------------+---------------------+----------------------+\n   The\
    \ CONNECTED state is entered from the CONNECT_PENDING state upon\n   the receipt\
    \ of a CONTACTED message or from the CONTACT_PENDING state\n   upon the receipt\
    \ of a DLC_CONTACTED signal.\n   The CONNECTED state is exited usually under one\
    \ of two conditions: a\n   DLC_ERROR signal received from the DLC (e.g., a DISC\
    \ command received\n   by the local DLC), or a HALT_DL message received from the\
    \ other Data\n   Link Switch (e.g., a DISC command received by the remote DLC).\n\
    \   A SABME command (i.e., a DLC_RESET signal) received by either Data\n   Link\
    \ Switch will also cause the two Data Link Switches to leave the\n   CONNECTED\
    \ state and attempt to restart the circuit.  Following the\n   receipt of a SABME,\
    \ the local Data Link Switch sends a RESTART_DL\n   message to the other Data\
    \ Link Switch and enters the CIRCUIT_RESTART\n   state.  Upon the receipt of the\
    \ RESTART_DL message, the remote Data\n   Link Switch sends a DISC command (i.e.,\
    \ DLC_HALT_DL signal) and\n   enters the RESTART_PENDING state.\n   An ICANREACH_cs\
    \ received after the transition to CONNECTED state\n   indicates that more than\
    \ one CANUREACH_cs was sent at circuit\n   establishment time and the target station\
    \ was found by more than one\n   Data Link Switch partner.  A HALT_DL_NOACK is\
    \ sent to halt the\n   circuit started by the Data Link Switch partner that originated\
    \ each\n   such ICANREACH_cs.\n   Note:  Some implementations will also send a\
    \ Test command in order to\n   restart the data link to the station that sent\
    \ the SABME command\n   (i.e., a DLC_START_DL will be issued).\n"
- title: 5.2.9  CIRCUIT_RESTART State
  contents:
  - "5.2.9  CIRCUIT_RESTART State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive DL_RESTARTED | If Connected:       | If Connected:        |\n   |  \
    \                    |  Send CONTACT       |  CONNECT_PENDING,    |\n   |    \
    \                  |                     | else:                |\n   |      \
    \                |                     |  CIRCUIT_ESTABLISHED |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive HALT_DL_NOACK| DLC_HALT_DL         | HALT_PENDING_NOACK   |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive DGRMFRAME    | DLC_DGRM            |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_ERROR            | Send HALT_DL        | DISCONNECT_PENDING   |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_DGRM             | Send DGRMFRAME      |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | XPORT_FAILURE        | DLC_HALT_DL         | HALT_PENDING_NOACK   |\n  \
    \ +----------------------+---------------------+----------------------+\n   The\
    \ CIRCUIT_RESTART state is entered if a DLC_RESET signal is\n   received from\
    \ the local DLC.  This was caused by the receipt of a\n   SABME command while\
    \ a connection was currently active.  A DM response\n   will be issued to the\
    \ SABME command and the Data Link Switch will\n   attempt to restart the end-to-end\
    \ circuit.\n   The CIRCUIT_RESTART state is exited through one of two transitions.\n\
    \   The next state depends upon the time the local DLC has reached the\n   contacted\
    \ state (i.e., a DLC_CONTACTED signal is presented) relative\n   to the receipt\
    \ of the DL_RESTARTED message.  This signal is caused by\n   the origin station\
    \ resending the SABME command that initially caused\n   the Data Link Switch to\
    \ enter the CIRCUIT_RESTART state.  The two\n   cases are as follows:\n      1)\
    \ DL_RESTARTED message received before the DLC_CONTACTED signal-\n         In\
    \ this case, the CIRCUIT_ESTABLISHED state is entered.\n      2) DL_RESTARTED\
    \ message received after the DLC_CONTACTED signal-\n         In this case, the\
    \ CONNECT_PENDING state is entered.\n"
- title: 5.2.10  DISCONNECT_PENDING State
  contents:
  - "5.2.10  DISCONNECT_PENDING State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive DL_HALTED    |                     | DISCONNECTED         |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive HALT_DL      | Send DL_HALTED      |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive HALT_DL_NOACK|                     | DISCONNECTED         |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DATAFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_DGRM             | Send DATAFRAME      |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | XPORT_FAILURE        |                     | DISCONNECTED         |\n  \
    \ +----------------------+---------------------+----------------------+\n   The\
    \ DISCONNECT_PENDING state is entered when a DLC_ERROR signal is\n   received\
    \ from the local DLC.  Upon receipt of this signal, a HALT_DL\n   message is sent.\
    \  Once an DL_HALTED message is received, the state is\n   exited, and the Data\
    \ Link Switch enters the DISCONNECTED state.\n"
- title: 5.2.11  RESTART_PENDING State
  contents:
  - "5.2.11  RESTART_PENDING State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive HALT_DL_NOACK|                     | HALT_PENDING_NOACK   |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DGRMFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_DL_HALTED        | Send DL_RESTARTED   | CIRCUIT_ESTABLISHED  |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_ERROR            | Send HALT_DL        | DISCONNECT_PENDING   |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_DGRM             | Send DGRMFRAME      |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | XPORT_FAILURE        | DLC_HALT_DL         | HALT_PENDING_NOACK   |\n  \
    \ +----------------------+---------------------+----------------------+\n   The\
    \ RESTART_PENDING state is entered upon the receipt of a RESTART_DL\n   message\
    \ from the remote DLSw while the local Data Link Switch is in\n   either the CONTACT_PENDING\
    \ state or the CONNECTED state, which causes\n   the local DLSw to issue a DISC\
    \ command to the DLC.  Upon the receipt\n   of the UA response (DLC_DL_HALTED),\
    \ the data link is restarted, a\n   DL_RESTARTED message is returned to the remote\
    \ DLSw, and the\n   CIRCUIT_ESTABLISHED state is entered.\n   Note:  Some implementations\
    \ will send a Test command in order to\n   restart the data link to the target\
    \ station (i.e., a DLC_START_DL\n   will be issued) prior to sending the DL_RESTARTED\
    \ message.\n"
- title: 5.2.12  HALT_PENDING State
  contents:
  - "5.2.12  HALT_PENDING State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive HALT_DL_NOACK|                     | HALT_PENDING_NOACK   |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive DATAFRAME    | DLC_DGRM            |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_DL_HALTED        | Send DL_HALTED      | DISCONNECTED         |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_ERROR            | Send DL_HALTED      | DISCONNECTED         |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_DGRM             | Send DATAFRAME      |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | XPORT_FAILURE        |                     | HALT_PENDING_NOACK   |\n  \
    \ +----------------------+---------------------+----------------------+\n   The\
    \ HALT_PENDING state is entered upon the receipt of a HALT_DL\n   message. This\
    \ causes the local DLC to issue a DISC command.  Upon the\n   receipt of the UA\
    \ response (DLC_DL_HALTED), a DL_HALTED message is\n   returned to the remote\
    \ DLSw and the DISCONNECTED state is entered.\n"
- title: 5.2.13  HALT_PENDING_NOACK State
  contents:
  - "5.2.13  HALT_PENDING_NOACK State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive DATAFRAME    | DLC_DGRM            |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DL_HALTED        |                     | DISCONNECTED         |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_ERROR            |                     | DISCONNECTED         |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM             | Send DATAFRAME      |                      |\n  \
    \ +----------------------+---------------------+----------------------+\n   The\
    \ HALT_PENDING_NOACK state is entered upon the receipt of a\n   HALT_DL_NOACK\
    \ message.  This causes the local DLC to issue a DISC\n   command.  Upon the receipt\
    \ of the UA response (DLC_DL_HALTED), the\n   DISCONNECTED state is entered.\n"
- title: 5.3  NetBIOS Datagrams
  contents:
  - "5.3  NetBIOS Datagrams\n   The NetBIOS protocols use a number of UI frames for\
    \ directory\n   services and the transmission of datagrams.  Most of these frames\
    \ are\n   directed to a group MAC address (GA) with the routing information\n\
    \   field indicating spanning tree explorer (STE) (a.k.a. Single Route\n   Broadcast).\
    \  The NB_Add_Name_Response and NB_Name_Recognized frames\n   are directed to\
    \ a specific MAC address with the routing information\n   field indicating an\
    \ all routes explorer frame (ARE) (a.k.a. All\n   Routes Broadcast)  The NB_Status_Response\
    \ frame, is directed to a\n   specific MAC address with the routing information\
    \ field indicating a\n   specifically routed frame (SRF). The handling of these\
    \ frames is\n   summarized in the following table.\n   +---------------------------+------------------+--------------------+\n\
    \   |          Event            |     Action(s)    |      Comment       |\n  \
    \ +---------------------------+------------------+--------------------+\n   |\
    \ DLC_DGRM for NETBIOS      | Send NETBIOS_ANQ | Transmitted to all |\n   |  group\
    \ address:           |                  |   remote DLSw      |\n   |   NB_Add_Name_Query\
    \       |                  |                    |\n   +---------------------------+------------------+--------------------+\n\
    \   | DLC_DGRM for a specific   | Send NETBIOS_ANR | Transmitted to     |\n  \
    \ |  address:                 |                  |   specific DLSw    |\n   |\
    \   NB_Add_Name_Response    |                  |                    |\n   +---------------------------+------------------+--------------------+\n\
    \   | DLC_DGRM for a specific   | Send DATAFRAME   | Transmitted to all |\n  \
    \ |  address:                 |                  |   remote DLSw      |\n   |\
    \   NB_Status_Response      |                  |                    |\n   +---------------------------+------------------+--------------------+\n\
    \   | DLC_DGRM for NETBIOS      | Send DATAFRAME   | Transmitted to all |\n  \
    \ |  group address:           |                  |   remote DLSw      |\n   |\
    \   NB_Name_in_Conflict     |                  |                    |\n   |  \
    \ NB_Add_Group_Name_Query |                  |                    |\n   |   NB_Datagram,\
    \            |                  |                    |\n   |   NB_Datagram_Broadcast\
    \   |                  |                    |\n   |   NB_Status_Query        \
    \ |                  |                    |\n   |   NB_Terminate_Trace      |\
    \                  |                    |\n   +---------------------------+------------------+--------------------+\n\
    \   The above actions do not apply in the following states:\n   CIRCUIT_ESTABLISHED,\
    \ CONTACT_PENDING, CONNECT_PENDING, CONNECTED, and\n   CIRCUIT_PENDING.  The handling\
    \ of the remaining two UI frames used by\n   NetBIOS systems, NB_Name_Query and\
    \ NB_Name_Recognized, are documented\n   as part of the DLSw state machine in\
    \ the previous section (i.e.,\n   DISCONNECTED and RESOLVE_PENDING states).  Furthermore,\
    \ the handling\n   of NetBIOS datagrams (i.e., NB_Datagram) sent to a specific\
    \ MAC\n   address is also governed by the DLSw state machine.\n   Note:  Some\
    \ implementations also issue Test frames during the\n   exchange of the NetBIOS,\
    \ NB_Name_Query and NB_Name_Recognized.  This\n   exchange of protocol data units\
    \ occurs during the start of a data\n   link and is used to determine the routing\
    \ information.  Most other\n   implementations of NetBIOS will use the\n   NB_Name_Query/NB_Name_Recognized\
    \ exchange to determine routes in\n   conjunction with resolving the NetBIOS names.\
    \ These differences are\n   not reflected in the SSP protocols.\n   The handling\
    \ of the NetBIOS specific SSP messages is given in the\n   following table.\n\
    \   +---------------+-------------------------+-------------------------+\n  \
    \ |     Event     |        Action(s)        |         Comment         |\n   +---------------+-------------------------+-------------------------+\n\
    \   | NETBIOS_ANQ   | DLC_DGRM:               | Routed STE              |\n  \
    \ |               |    NB_Add_Name_Query    | (NETBIOS Group Address) |\n   +---------------+-------------------------+-------------------------+\n\
    \   | NETBIOS_ANR   | DLC_DGRM:               | Routed ARE              |\n  \
    \ |               |    NB_Add_Name_Response | (Specific MAC Address)  |\n   +---------------+-------------------------+-------------------------+\n\
    \   | NETBIOS_NQ_ex | DLC_DGRM:               | Routed STE              |\n  \
    \ |               |    NB_Name_Query        | (NETBIOS Group Address) |\n   +---------------+-------------------------+-------------------------+\n\
    \   | NETBIOS_NQ_cs | DLC_DGRM:               | Routed STE              |\n  \
    \ |               |    NB_Name_Query        | (NETBIOS Group Address) |\n   +---------------+-------------------------+-------------------------+\n\
    \   | NETBIOS_NR_ex | DLC_DGRM:               | Routed ARE              |\n  \
    \ |               |    NB_Name_Recognized   | (Specific MAC Address)  |\n   +---------------+-------------------------+-------------------------+\n\
    \   | NETBIOS_NR_cs | DLC_DGRM:               | Routed ARE              |\n  \
    \ |               |    NB_Name_Recognized   | (Specific MAC Address)  |\n   +---------------+-------------------------+-------------------------+\n\
    \   | DATAFRAME     | DLC_DGRM                | If NB_Status_Response:  |\n  \
    \ |               |                         |  Routed ARE             |\n   |\
    \               |                         |  (Specific MAC Address) |\n   |  \
    \             |                         | Else:                   |\n   |    \
    \           |                         |  Routed STE             |\n   |      \
    \         |                         |  (NETBIOS Group Address)|\n   +---------------+-------------------------+-------------------------+\n\
    \   The above actions apply to all DLSw states.  The handling of NetBIOS\n   datagrams\
    \ sent within DGRMFRAME messages is governed by the DLSw\n   state machine.  The\
    \ DGRMFRAME message type is employed instead of the\n   DATAFRAME message type\
    \ once the end-to-end circuit has been\n   established. At that time, the message\
    \ is addressed according to the\n   pair of Circuit IDs in the message header\
    \ instead of relying upon the\n   MAC address information in the token ring header.\n"
- title: 5.4  Explorer Traffic
  contents:
  - "5.4  Explorer Traffic\n   The CANUREACH_ex, ICANREACH_ex, NETBIOS_NQ_ex, and\
    \ NETBIOS_NR_ex SSP\n   messages explore the topology of the DLSw cloud and the\
    \ networks\n   attached to it.  These explorer frames are used to determine the\
    \ DLSw\n   partners through which a MAC or NetBIOS name can be accessed.  This\n\
    \   information may optionally be cached to reduce explorer traffic in\n   the\
    \ DLSw cloud.\n   If a DLSw is aware from cached information that a given MAC\
    \ address\n   or NetBIOS name is accessible through a given partner DLSw, it should\n\
    \   direct all circuit setup attempts to that partner.  If the circuit\n   setup\
    \ fails, or no such data is available in the MAC or name cache\n   database, the\
    \ DLSw may fallback to issuing the setup attempt to all\n   DLSw partners on the\
    \ assumption that the cached data is now out of\n   date.  The mechanism for determining\
    \ when to use such a fallback is\n   implementation defined.\n   DLSw implementations\
    \ may also use a local MAC cache to enable\n   responses to CANUREACH_ex requests\
    \ to be issued without the need for\n   TEST frame exchange (or equivalent) until\
    \ the CANUREACH_cs is\n   received.  Again, the fallback mechanism for determining\
    \ when such\n   local cache data is out-of-date is implementation defined.\n \
    \  The use of either cache is an optional function in DLSw.  An\n   implementation\
    \ may choose to always issue explorer frames or to use\n   either or both types\
    \ of cache.\n   The following sections describe the FSMs used for explorer frames.\n\
    \   The DLC events and actions are a subset of those described in section\n  \
    \ 5.2 for the main circuit FSM.\n"
- title: 5.4.1  CANUREACH/ICANREACH Explorer FSM
  contents:
  - "5.4.1  CANUREACH/ICANREACH Explorer FSM\n   The FSM described below is used to\
    \ handle explorer frames routed by\n   MAC address.  There is one instance of\
    \ this FSM for each Data Link ID\n   (Target and Origin MAC/SAP pair) for which\
    \ explorer traffic is\n   flowing. The states in this FSM are as follows.\n  \
    \ State Name            Description\n   ----------            -----------\n  \
    \ RESET                 The initial state.\n   SENT_EX               Local DLSw\
    \ has issued an explorer message\n   RECEIVED_EX           Local DLSw has received\
    \ an explorer message\n"
- title: 5.4.1.1  RESET State
  contents:
  - "5.4.1.1  RESET State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive CANUREACH_ex | If replying from    | If DLC_RESOLVE sent, |\n   |  \
    \                    | cache, send         |   RECEIVED_EX        |\n   |    \
    \                  | ICANREACH_ex        |                      |\n   |      \
    \                | else if allowed to  |                      |\n   |        \
    \              | test availability,  |                      |\n   |          \
    \            | issue DLC_RESOLVE.  |                      |\n   |            \
    \          | Optionally update   |                      |\n   |              \
    \        | cache.              |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive ICANREACH_ex | Optionally update   | RESET                |\n  \
    \ |                      | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_RESOLVE_C        | Send CANUREACH_ex   | SENT_EX              |\n  \
    \ +----------------------+---------------------+----------------------+\n   RESET\
    \ is the initial state for the CANUREACH/ICANREACH explorer FSM.\n   This state\
    \ is exited when a DLC_RESOLVE_C request is received from\n   the DLC or a CANUREACH_ex\
    \ is received from a remote DLSw.\n   A DLSw implementation may optionally reply\
    \ from to CANUREACH_ex\n   messages on the basis of cached topology information,\
    \ in which case\n   the DLC_RESOLVE exchange (i.e., TEST) is not required.  If\
    \ cache is\n   not used, or no match is found, and the DLC permits the use of\
    \ TEST,\n   DLC_RESOLVE is issued to locate the target MAC and the state changes\n\
    \   to RECEIVED_EX. If no cache entry is available and TEST is not\n   allowed\
    \ by the DLC, a received CANUREACH_ex frame is ignored.\n"
- title: 5.4.1.2  SENT_EX State
  contents:
  - "5.4.1.2  SENT_EX State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive ICANREACH_ex | DLC_RESOLVE_R       | RESET                |\n   |  \
    \                    | Optionally update   |                      |\n   |    \
    \                  | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_RESOLVE_C        |                     | SENT_EX              |\n  \
    \ +----------------------+---------------------+----------------------+\n   SENT_EX\
    \ is entered when the DLSw has issued a CANUREACH_ex message to\n   locate a MAC\
    \ address.  This state is exited when a remote DLSw\n   returns a matching ICANREACH_ex,\
    \ or after an implementation defined\n   timeout. DLC_RESOLVE events received\
    \ in this state correspond to TEST\n   retries by the origin DLC station and are\
    \ absorbed.\n   An implementation may choose whether to handle explorer frame\n\
    \   crossover either by using entirely separate FSM instances and simply\n   allowing\
    \ both ends to issue TEST frames, or by detecting a reverse\n   CANUREACH_ex frame\
    \ here and issuing an ICANREACH_ex message and\n   DLC_RESOLVE_R action.\n"
- title: 5.4.1.3  RECEIVED_EX State
  contents:
  - "5.4.1.3  RECEIVED_EX State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive CANUREACH_ex | Optionally update   | RECEIVED_EX          |\n   |  \
    \                    | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive ICANREACH_ex |                     | RECEIVED_EX          |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_RESOLVED         | Send ICANREACH_ex   | RESET                |\n   |  \
    \                    | Optionally update   |                      |\n   |    \
    \                  | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   RECEIVED_EX is entered when the DLSw has received a CANUREACH_ex from\n  \
    \ a remote DLSw and has issued a DLC_RESOLVE to locate the MAC address.\n   This\
    \ state is exited when the DLC_RESOLVED response is received, or\n   after an\
    \ implementation defined timeout.\n   If the target MAC is located, the DLSw must\
    \ reply to the first\n   received CANUREACH_ex that caused the move to this state.\
    \  If\n   additional CANUREACH_ex messages are received in this state from\n \
    \  other remote DLSw partners, the DLSw may optionally reply to these\n   messages\
    \ too but it is not required to do so.\n   An implementation may choose whether\
    \ to handle explorer frame\n   crossover either by using entirely separate FSM\
    \ instances and simply\n   allowing both ends to issue TEST frames, or by detecting\
    \ such a\n   reverse DLC_RESOLVE_C event here and issuing an ICANREACH_ex message\n\
    \   and DLC_RESOLVE_R action.\n"
- title: 5.4.2  NETBIOS_NQ/NR Explorer FSM
  contents:
  - "5.4.2  NETBIOS_NQ/NR Explorer FSM\n   The FSM described below is used to handle\
    \ explorer frames routed by\n   NetBIOS names  There is one instance of this FSM\
    \ for each unique\n   combination of Source Name, Destination Name, Data 2 field\
    \ and\n   Response Correlator.\n   State Name            Description\n   ----------\
    \            -----------\n   RESET                 The initial state.\n   SENT_EX\
    \               Local DLSw has issued an explorer\n                         message\n\
    \   RECEIVED_EX           Local DLSw has received an explorer\n              \
    \           message\n   SENT_REC_EX           An explorer frame has been both\
    \ sent\n                         and received for the same (potential)\n     \
    \                    NetBIOS circuit.\n"
- title: 5.4.2.1  RESET State
  contents:
  - "5.4.2.1  RESET State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive NETBIOS_NQ_ex| DLC_DGRM(NAME_QUERY)| RECEIVED_EX          |\n   |  \
    \                    | Optionally update   |                      |\n   |    \
    \                  | cache.              |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive NETBIOS_NR_ex| Optionally update   | RESET                |\n  \
    \ |                      | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM (NAME_QUERY)| Send NETBIOS_NQ_ex  | SENT_EX              |\n  \
    \ +----------------------+---------------------+----------------------+\n   The\
    \ RESET state is the initial state for the NETBIOS_NQ/NR explorer\n   FSM. It\
    \ is exited when the DLC receives either a NETBIOS_NQ_ex or a\n   DLC_DGRM containing\
    \ a NetBIOS NAME_QUERY frame.  If a NETBIOS_NQ_ex\n   message is received, the\
    \ NAME_QUERY is propagated to the DLC and this\n   FSM moves to state RECEIVED_EX.\
    \  If a NetBIOS NAME_QUERY frame is\n   received, the NETBIOS_NQ_ex is propagated\
    \ either to the appropriate\n   DLSw partners (see below), and this FSM moves\
    \ to state SENT_EX.\n   Unlike SNA traffic where the CANUREACH_ex/ICANREACH_ex\
    \ exchange can\n   be omitted if the MAC location is already cached,\n   NETBIOS_NQ_ex/NETBIOS_NR_ex\
    \ frames must always be issued during\n   NetBIOS session setup in order that\
    \ the NetBIOS session numbers are\n   exchanged correctly between the DLC end\
    \ stations.  If the location of\n   a NetBIOS name is known from cached data,\
    \ the NETBIOS_NQ_ex need only\n   be issued to the cached DLSw partners.  Otherwise\
    \ the NETBIOS_NQ_ex\n   should be issued to all partners that support NetBIOS.\n"
- title: 5.4.2.2  SENT_EX State
  contents:
  - "5.4.2.2  SENT_EX State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive NETBIOS_NQ_ex| DLC_DGRM(NAME_QUERY)| SENT_REC_EX          |\n   |  \
    \                    | Optionally update   |                      |\n   |    \
    \                  | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive NETBIOS_NR_ex| DLC_DGRM(NAME_RECOG)| RESET                |\n  \
    \ |                      | Optionally update   |                      |\n   |\
    \                      | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM (NAME_QUERY)| Send NETBIOS_NQ_ex  | SENT_EX              |\n  \
    \ | (different local     | Optionally update   |                      |\n   |\
    \  session number than | cache               |                      |\n   |  existing\
    \ searches)  |                     |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   SENT_EX is entered when the local DLSw issues a NETBIOS_NQ_ex to its\n   remote\
    \ DLSw partners.  This state is exited when a NETBIOS_NR_ex is\n   received from\
    \ a remote DLSw, or if a matching NETBIOS_NQ_ex is\n   received from a remote\
    \ DLSw (i.e., a NETBIOS_NQ_ex crossover case).\n   If the local NetBIOS end station\
    \ issues a NAME_QUERY with a different\n   session number from any previous NAME_QUERY\
    \ for this search, the\n   NAME_QUERY is propagated to the DLSw partners to ensure\
    \ that the\n   exchange of NetBIOS session numbers is handled correctly.\n"
- title: 5.4.2.3  RECEIVED_EX State
  contents:
  - "5.4.2.3  RECEIVED_EX State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive NETBIOS_NQ_ex| DLC_DGRM(NAME_QUERY)| RECEIVED_EX          |\n   |  \
    \                    | Optionally update   |                      |\n   |    \
    \                  | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive NETBIOS_NR_ex|                     | RECEIVED_EX          |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ DLC_DGRM (NAME_QUERY)| Send NETBIOS_NQ_ex  | SENT_REC_EX          |\n   |  \
    \                    | Optionally update   |                      |\n   |    \
    \                  | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM (NAME_RECOG)| Send NETBIOS_NR_ex  | RESET                |\n  \
    \ |                      | Optionally update   |                      |\n   |\
    \                      | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   RECEIVED_EX is entered when the local DLSw receives a NETBIOS_NQ_ex\n   message\
    \ from a remote DLSw.  This state is exited when a\n   NAME_RECOGNIZED NetBIOS\
    \ frame is received from the DLC, completing\n   the query, or when a matching\
    \ NAME_QUERY is received from DLC (i.e.,\n   NAME_QUERY crossover).\n"
- title: 5.4.2.4  SENT_REC_EX State
  contents:
  - "5.4.2.4  SENT_REC_EX State\n   +----------------------+---------------------+----------------------+\n\
    \   |        Event         |      Action(s)      |      Next State      |\n  \
    \ +----------------------+---------------------+----------------------+\n   |\
    \ Receive NETBIOS_NQ_ex| DLC_DGRM(NAME_QUERY)| SENT_REC_EX          |\n   |  \
    \                    | Optionally update   |                      |\n   |    \
    \                  | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | Receive NETBIOS_NR_ex| DLC_DGRM(NAME_RECOG)| RECEIVED_EX          |\n  \
    \ |                      | Optionally update   |                      |\n   |\
    \                      | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM (NAME_QUERY)| Send NETBIOS_NQ_ex  | SENT_REC_EX          |\n  \
    \ | (different local     | Optionally update   |                      |\n   |\
    \  session number than | cache               |                      |\n   |  existing\
    \ searches)  |                     |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   | DLC_DGRM (NAME_RECOG)| Send NETBIOS_NR_ex  | SENT_EX              |\n  \
    \ |                      | Optionally update   |                      |\n   |\
    \                      | cache               |                      |\n   +----------------------+---------------------+----------------------+\n\
    \   This state is required if an implementation wishes to manage NQ/NR\n   crossover\
    \ cases from a single FSM instance by detecting 'opposite'\n   NAME_QUERY attempts\
    \ between the same two NetBIOS names.  If separate\n   FSM instances are used\
    \ instead, this state is not required and the\n   transitions to it from other\
    \ states can be removed.\n   SENT_RCV_EX is exited when the NAME_QUERY search\
    \ in either direction\n   is resolved.  If the local NetBIOS end station issues\
    \ a NAME_QUERY\n   with a different session number from any previous NAME_QUERY\
    \ it has\n   issued for this search, the NAME_QUERY is propagated to the DLSw\n\
    \   partners to ensure that the exchange of NetBIOS session numbers is\n   correctly\
    \ handled.\n"
- title: 5.4.2.5  NetBIOS Session Numbers
  contents:
  - "5.4.2.5  NetBIOS Session Numbers\n   NetBIOS NAME_QUERY and NAME_RECOGNIZED frames\
    \ exchange NetBIOS session\n   numbers between the end stations.  For correct\
    \ NetBIOS operation over\n   DLSw, it is important that all SSP NETBIOS_NQ_ex\
    \ frames received by a\n   DLSw cause NetBIOS NAME_QUERY frames to flow on the\
    \ LAN with the new\n   session number from the NETBIOS_NQ_ex.  These frames cannot\
    \ be replied\n   to from a cache of locally available NetBIOS names in the same\
    \ way that\n   MAC addresses and CANUREACH_ex messages can be handled.\n   Also,\
    \ NAME_QUERY messages are normally retried several times on the LAN.\n   The generation\
    \ and absorption of such frames is outside the scope of the\n   FSM defined above.\n"
- title: 6.  Protocol Flow Diagrams
  contents:
  - "6.  Protocol Flow Diagrams\n   The Switch-to-Switch Protocol is used to setup\
    \ and take down circuits\n   between a pair of Data Link Switches.  Once a circuit\
    \ is established,\n   the end stations on the local networks can employ LLC Type\
    \ 1\n   (connectionless UI frames) protocols end-to-end.  In addition, the end\n\
    \   systems can establish an end-to-end connection for support of LLC Type 2\n\
    \   (connection oriented I frames) protocols (Type 2 I frames go end-to-end,\n\
    \   supervisory frames are handled locally).\n   The term, Data Link, is used\
    \ in this document to refer to both a\n   \"logical data link\" when supporting\
    \ Type 1 LLC services, and a \"data\n   link connection\" when supporting Type\
    \ 2 LLC services.  In both cases,\n   the Data Link is identified by the Data\
    \ Link ID defined in section 3.2.\n   NOTE:  THIS SECTION CONTAINS EXAMPLES ONLY.\
    \  IT CANNOT AND DOES NOT SHOW\n   ALL POSSIBLE VARIATIONS AND OPTIONS ON PROTOCOL\
    \ FLOWS FOR SNA/SDLC, SSP,\n   AND LLC PROTOCOLS.\n"
- title: 6.1  Connect Protocols
  contents:
  - "6.1  Connect Protocols\n   The two basic startup flows from a pure FSM perspective\
    \ are shown below.\n   The first flow is a startup involving XIDs and the second\
    \ is one without\n   XIDs.\n"
- title: 'Flow #1 - DLSw Startup With XIDs'
  contents:
  - "Flow #1 - DLSw Startup With XIDs\n ======                            ___    \
    \                       ======\n |    |        ---------        __/   \\__   \
    \    ---------        |    |\n |    |      __|  _|_  |__     /   IP    \\    __|\
    \  _|_  |__      |    |\n ======        |   |   |      <  Network  >     |   |\
    \   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw      Target\n Station\
    \        partner                          partner        Station\n           \
    \   disconnected                    disconnected\n              DLC_RESOLVE_C\
    \   CANUREACH_ex\n              ----------->    ----------->\n              DLC_RESOLVE_R\
    \     ICANREACH_ex\n               <-----------     <-----------\n           \
    \   DLC_XID         CANUREACH_cs    DLC_START_DL\n              -----------> \
    \   ----------->    ----------->\n              circuit_start                \
    \   resolve_pending\n                                ICANREACH_cs    DLC_DL_STARTED\n\
    \                                <-----------    <-----------\n          circuit_established\
    \                 circuit_pending\n                              REACH_ACK\n \
    \                             ----------->   circuit_established\n           \
    \                   XIDFRAME        DLC_XID\n                              ----------->\
    \    ----------->\n                     DLC_XID        XIDFRAME         DLC_XID\n\
    \                <-----------    <-----------    <-----------\n              DLC_XID\
    \         XIDFRAME        DLC_XID\n              ----------->    ----------->\
    \    ----------->\n                 DLC_XIDs       XIDFRAMEs        DLC_XIDs\n\
    \              <------------>  <------------>  <------------>\n              DLC_CONTACTED\
    \   CONTACT         DLC_CONTACT\n              ----------->    ----------->  \
    \  ----------->\n              connect_pending                 contact_pending\n\
    \                 DLC_CONTACT       CONTACTED    DLC_CONTACTED\n             \
    \   <-----------    <-----------    <-----------\n                 connected \
    \                      connected\n                DLC_INFOs        IFRAMEs   \
    \     DLC_INFOs\n              <------------>  <------------>  <------------>\n\
    \   Mapping LAN events to the DLC events and actions on Flow #1 produces\n   the\
    \ following flows shown below:\n ======                            ___       \
    \                    ======\n |    |        ---------        __/   \\__      \
    \ ---------        |    |\n |    |      __|  _|_  |__     /   IP    \\    __|\
    \  _|_  |__      |    |\n ======        |   |   |      <  Network  >     |   |\
    \   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw      Target\n Station\
    \        partner                          partner        Station\n           \
    \   disconnected                    disconnected\n"
- title: TEST_cmd      DLC_RESOLVE_C    CANUREACH_ex               TEST_cmd
  contents:
  - 'TEST_cmd      DLC_RESOLVE_C    CANUREACH_ex               TEST_cmd

    '
- title: '----------->  ----------->     ----------->               ---------->'
  contents:
  - "----------->  ----------->     ----------->               ---------->\n   TEST_rsp\
    \   DLC_RESOLVE_R     ICANREACH_ex                 TEST_rsp\n <---------    <-----------\
    \   <-----------             <-----------\n"
- title: null XID      DLC_XID          CANUREACH_cs    DLC_START_DL
  contents:
  - 'null XID      DLC_XID          CANUREACH_cs    DLC_START_DL

    '
- title: '----------->  ----------->     ----------->    ----------->'
  contents:
  - "----------->  ----------->     ----------->    ----------->\n              circuit_start\
    \                   resolve_pending\n                                ICANREACH_cs\
    \    DLC_DL_STARTED\n                                <-----------    <-------------\n\
    \           circuit_established                circuit_pending\n             \
    \                 REACH_ACK\n                              ----------->  circuit_established\n\
    \                              XIDFRAME         DLC_XID       null XID\n     \
    \                         ----------->     --------->    -------->\n        XID\
    \        DLC_XID        XIDFRAME         DLC_XID          XID\n  <--------   <-----------\
    \    <-----------    <-----------    <--------\n    XIDs         DLC_XIDs    \
    \  XIDFRAMEs        DLC_XIDs         XIDs\n"
- title: <---------->  <---------->  <------------>  <------------>  <--------->
  contents:
  - '<---------->  <---------->  <------------>  <------------>  <--------->

    '
- title: SABME         DLC_CONTACTED   CONTACT         DLC_CONTACT     SABME
  contents:
  - 'SABME         DLC_CONTACTED   CONTACT         DLC_CONTACT     SABME

    '
- title: '----------->  ----------->    ----------->    ----------->    -------->'
  contents:
  - "----------->  ----------->    ----------->    ----------->    -------->\n   \
    \           connect_pending                 contact_pending\n          UA    \
    \ DLC_CONTACT     CONTACTED    DLC_CONTACTED          UA\n  <---------   <-----------\
    \   <-----------    <-----------    <--------\n                  connected   \
    \                     connected\n  IFRAMEs       DLC_INFOs        IFRAMEs    \
    \    DLC_INFOs       IFRAMEs\n"
- title: <---------->  <----------->  <------------>  <------------>  <-------->
  contents:
  - '<---------->  <----------->  <------------>  <------------>  <-------->

    '
- title: Those implementations that prefer to respond to the SABME immediately
  contents:
  - 'Those implementations that prefer to respond to the SABME immediately

    '
- title: 'could use the same events to do that:'
  contents:
  - 'could use the same events to do that:

    '
- title: SABME         DLC_CONTACTED   CONTACT         DLC_CONTACT     SABME
  contents:
  - 'SABME         DLC_CONTACTED   CONTACT         DLC_CONTACT     SABME

    '
- title: '----------->  ----------->    ----------->    ----------->    -------->'
  contents:
  - "----------->  ----------->    ----------->    ----------->    -------->\n   \
    \       UA  connect_pending                 contact_pending\n  <---------\n"
- title: RR
  contents:
  - 'RR

    '
- title: '----------->'
  contents:
  - "----------->\n         RNR\n  <---------\n          RR    DLC_CONTACT       CONTACTED\
    \    DLC_CONTACTED          UA\n  <---------   <-----------    <-----------  \
    \  <-----------    <--------\n                 connected                     \
    \   connected\n   IFRAMEs      DLC_INFOs        IFRAMEs        DLC_INFOs     \
    \ IFRAMEs\n"
- title: <---------->  <------------>  <------------>  <------------>  <-------->
  contents:
  - '<---------->  <------------>  <------------>  <------------>  <-------->

    '
- title: 'Flow #2 - DLSw Startup Without XIDs (circuit setup)'
  contents:
  - "Flow #2 - DLSw Startup Without XIDs (circuit setup)\n ======                \
    \            ___                           ======\n |    |        ---------  \
    \      __/   \\__       ---------        |    |\n |    |      __|  _|_  |__  \
    \   /   IP    \\    __|  _|_  |__      |    |\n ======        |   |   |      <\
    \  Network  >     |   |   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw      Target\n Station\
    \        partner                          partner        Station\n           \
    \   disconnected                    disconnected\n              DLC_CONTACTED\
    \   CANUREACH_cs    DLC_START_DL\n              ----------->    -----------> \
    \   ----------->\n              circuit_start                   resolve_pending\n\
    \                                ICANREACH_cs    DLC_DL_STARTED\n            \
    \                    <-----------    <-----------\n          circuit_established\
    \                 circuit_pending\n                              REACH_ACK\n \
    \                             ----------->   circuit_established\n           \
    \                   CONTACT         DLC_CONTACT\n                            \
    \  ----------->    ----------->\n              connect_pending               \
    \  contact_pending\n                 DLC_CONTACT       CONTACTED    DLC_CONTACTED\n\
    \                <-----------    <-----------    <-----------\n              \
    \   connected                       connected\n                DLC_INFOs     \
    \   IFRAMEs        DLC_INFOs\n              <------------>  <------------>  <------------>\n\
    \   Mapping LAN events to the DLC events and actions on Flow #2 (and\n   adding\
    \ a NETBIOS_NQ and NETBIOS_NR_ex) produces:\n ======                         \
    \   ___                           ======\n |    |        ---------        __/\
    \   \\__       ---------        |    |\n |    |      __|  _|_  |__     /   IP\
    \    \\    __|  _|_  |__      |    |\n ======        |   |   |      <  Network\
    \  >     |   |   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw      Target\n Station\
    \        partner                          partner        Station\n           \
    \   disconnected                     disconnected\n"
- title: NAME_QUERY    DLC_DGRM        NETBIOS_NQ_ex   DLC_DGRM       NAME_QUERY
  contents:
  - 'NAME_QUERY    DLC_DGRM        NETBIOS_NQ_ex   DLC_DGRM       NAME_QUERY

    '
- title: '----------->  ----------->    ----------->    ----------->   --------->'
  contents:
  - "----------->  ----------->    ----------->    ----------->   --------->\n   NAME_RECOG\
    \    DLC_DGRM      NETBIOS_NR_ex     DLC_DGRM    NAME_RECOG\n <-----------  <------------\
    \   <-----------    <-----------  <---------\n"
- title: SABME         DLC_CONTACTED   CANUREACH_cs    DLC_START_DL
  contents:
  - 'SABME         DLC_CONTACTED   CANUREACH_cs    DLC_START_DL

    '
- title: '----------->  ----------->    ----------->    ----------->'
  contents:
  - "----------->  ----------->    ----------->    ----------->\n               circuit_start\
    \                 resolve_pending\n                                ICANREACH_cs\
    \    DLC_DL_STARTED\n                                <-----------    <-----------\n\
    \            circuit_established                circuit_pending\n            \
    \                  REACH_ACK\n                              ----------->   circuit_established\n\
    \                              CONTACT         DLC_CONTACT     SABME\n       \
    \                       ----------->    ----------->    --------->\n         \
    \    connect_pending                 contact_pending\n          UA   DLC_CONTACT\
    \       CONTACTED    DLC_CONTACTED           UA\n  <---------  <-----------  \
    \  <-----------    <-----------    <---------\n                connected     \
    \                  connected\n   IFRAMEs       DLC_INFOs       IFRAMEs       \
    \ DLC_INFOs       IFRAMEs\n"
- title: <------------> <------------> <------------>  <------------>  <-------->
  contents:
  - "<------------> <------------> <------------>  <------------>  <-------->\n  \
    \ In keeping with a paradigm of 'DLSw is a big 802.2 LAN', all other\n   DLC types\
    \ (SDLC for now, QLLC, channel, or whatever in the future)\n   would be handled\
    \ by a 'DLC transformation layer' that would transform\n   the specific protocol's\
    \ events into the appropriate DLSw DLC events\n   and DLSw DLC actions into the\
    \ appropriate protocol actions.  The XIDs\n   that flow in the SSP XIDFRAME should\
    \ stay 802.2ish (i.e., ABM bit\n   set) and leave it up to the DLC transformation\
    \ layer to suit the XID\n   to its particular DLC type.\n   Here is an example\
    \ of a leased SDLC PU 2.0 device as the origin\n   station. It should use Flow\
    \ #2 since it is not known if the other\n   side is a LAN, a switched line or\
    \ a leased line.\n ======                            ___                     \
    \      ======\n |    |        ---------        __/   \\__       ---------    \
    \    |    |\n |    |      __|  _|_  |__     /   IP    \\    __|  _|_  |__    \
    \  |    |\n ======        |   |   |      <  Network  >     |   |   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw      Target\n Station\
    \        partner                          partner        Station\n           \
    \   disconnected                     disconnected\n"
- title: implementer's  DLC_RESOLVE_C   CANUREACH_ex
  contents:
  - 'implementer''s  DLC_RESOLVE_C   CANUREACH_ex

    '
- title: choice (power  ----------->    ----------->
  contents:
  - 'choice (power  ----------->    ----------->

    '
- title: up, configuration
  contents:
  - 'up, configuration

    '
- title: change,        DLC_RESOLVE_R   ICANREACH_ex
  contents:
  - 'change,        DLC_RESOLVE_R   ICANREACH_ex

    '
- title: never,          <-----------    <-----------
  contents:
  - 'never,          <-----------    <-----------

    '
- title: connect timer,etc.)
  contents:
  - 'connect timer,etc.)

    '
- title: PU 2.0 is
  contents:
  - 'PU 2.0 is

    '
- title: configured
  contents:
  - 'configured

    '
- title: in DLSw to    DLC_XID(null)   CANUREACH_cs    DLC_START_DL
  contents:
  - 'in DLSw to    DLC_XID(null)   CANUREACH_cs    DLC_START_DL

    '
- title: call in       ----------->    ----------->    ----------->
  contents:
  - "call in       ----------->    ----------->    ----------->\n              circuit_start\
    \                   resolve_pending\n                                ICANREACH_cs\
    \   DLC_DL_STARTED\n                                <-----------   <-----------\n\
    \           circuit_established                circuit_pending\n             \
    \                   REACH_ACK\n                                ----------->  \
    \ circuit_established\n                              XIDFRAME        DLC_XID\n\
    \                              ----------->    ----------->\n                \
    \    DLC_XID        XIDFRAME         DLC_XID\n"
- title: respond with   <-----------    <-----------    <-----------
  contents:
  - 'respond with   <-----------    <-----------    <-----------

    '
- title: XID configured
  contents:
  - 'XID configured

    '
- title: for station or
  contents:
  - 'for station or

    '
- title: forward XID to
  contents:
  - 'forward XID to

    '
- title: station and
  contents:
  - 'station and

    '
- title: send response  DLC_XID        XIDFRAME        DLC_XID
  contents:
  - "send response  DLC_XID        XIDFRAME        DLC_XID\n               ----------->\
    \   ----------->    ----------->\n        SNRM    DLC_CONTACT       CONTACT  \
    \    DLC_CONTACTED\n  <---------   <-----------    <-----------    <------------\n\
    \              contact_pending                    connect_pending\n"
- title: UA            DLC_CONTACTED    CONTACTED       DLC_CONTACT
  contents:
  - 'UA            DLC_CONTACTED    CONTACTED       DLC_CONTACT

    '
- title: '---------->    ----------->    ----------->    ----------->'
  contents:
  - "---------->    ----------->    ----------->    ----------->\n               \
    \ connected                       connected\n   IFRAMEs       DLC_INFOs      \
    \  IFRAMEs        DLC_INFOs\n"
- title: <----------->  <------------>  <------------>  <------------>
  contents:
  - "<----------->  <------------>  <------------>  <------------>\n   Here is an\
    \ example of a switched SDLC PU 2.0 device as the origin\n   station.\n ======\
    \                            ___                           ======\n |    |   \
    \     ---------        __/   \\__       ---------        |    |\n |    |     \
    \ __|  _|_  |__     /   IP    \\    __|  _|_  |__      |    |\n ======       \
    \ |   |   |      <  Network  >     |   |   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw      Target\n Station\
    \        partner                          partner        Station\n           \
    \   disconnected                     disconnected\n"
- title: implementer's  DLC_RESOLVE_C   CANUREACH_ex
  contents:
  - 'implementer''s  DLC_RESOLVE_C   CANUREACH_ex

    '
- title: choice (power  ----------->    ----------->
  contents:
  - 'choice (power  ----------->    ----------->

    '
- title: up, configuration
  contents:
  - 'up, configuration

    '
- title: change,        DLC_RESOLVE_R   ICANREACH_ex
  contents:
  - 'change,        DLC_RESOLVE_R   ICANREACH_ex

    '
- title: never,          <-----------    <-----------
  contents:
  - 'never,          <-----------    <-----------

    '
- title: connect timer,etc.)
  contents:
  - 'connect timer,etc.)

    '
- title: XID(null)     DLC_XID(null)   CANUREACH_cs    DLC_START_DL
  contents:
  - 'XID(null)     DLC_XID(null)   CANUREACH_cs    DLC_START_DL

    '
- title: '----------->  ----------->    ----------->    ----------->'
  contents:
  - "----------->  ----------->    ----------->    ----------->\n              circuit_start\
    \                   resolve_pending\n                                ICANREACH_cs\
    \    DLC_DL_STARTED\n                                <-----------    <-----------\n\
    \            circuit_established                 circuit_pending\n           \
    \                     REACH_ACK\n                                ----------->\
    \   circuit_established\n                                XIDFRAME      DLC_XID\n\
    \                                ----------->  ----------->\n         XID    \
    \    DLC_XID         XIDFRAME         DLC_XID\n  <---------   <-----------   \
    \  <-----------    <-----------\n"
- title: XID           DLC_XID         XIDFRAME        DLC_XID
  contents:
  - 'XID           DLC_XID         XIDFRAME        DLC_XID

    '
- title: '--------->    ----------->    ----------->    ----------->'
  contents:
  - "--------->    ----------->    ----------->    ----------->\n        SNRM    DLC_CONTACT\
    \       CONTACT      DLC_CONTACTED\n  <---------   <-----------    <-----------\
    \    <-----------\n              contact_pending                 connect_pending\n"
- title: UA            DLC_CONTACTED   CONTACTED       DLC_CONTACT
  contents:
  - 'UA            DLC_CONTACTED   CONTACTED       DLC_CONTACT

    '
- title: '--------->    ----------->    ----------->    ----------->'
  contents:
  - "--------->    ----------->    ----------->    ----------->\n                \
    \ connected                      connected\n   IFRAMEs      DLC_INFOs        IFRAMEs\
    \        DLC_INFOs\n"
- title: <---------->  <------------>  <------------>  <------------>
  contents:
  - "<---------->  <------------>  <------------>  <------------>\n   Here is an example\
    \ of a leased SDLC PU 2.0 device as the target\n   station.\n ======         \
    \                   ___                           ======\n |    |        ---------\
    \        __/   \\__       ---------        |    |\n |    |      __|  _|_  |__\
    \     /   IP    \\    __|  _|_  |__      |    |\n ======        |   |   |    \
    \  <  Network  >     |   |   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw       Target\n Station\
    \        partner                          partner         Station\n          \
    \                                                       (SDLC)\n             \
    \ disconnected                    disconnected\n              DLC_RESOLVE_C  \
    \ CANUREACH_ex\n              ----------->    ----------->   reply if virtual\
    \ MAC/SAP\n                                             for SDLC station is\n\
    \                                             configured, if SDLC\n          \
    \                                   station responds to\n              DLC_RESOLVE_R\
    \    ICANREACH_ex  TEST/SNRM/DISC, etc.\n               <-----------    <-----------\n\
    \              DLC_XID         CANUREACH_cs    DLC_START_DL    SNRM\n        \
    \      ----------->    ----------->    ----------->    --------->\n          \
    \    circuit_start                   resolve_pending\n                       \
    \         ICANREACH_cs    DLC_DL_STARTED        UA\n                         \
    \       <-----------    <-----------    <-------\n          circuit_established\
    \                 circuit_pending\n                                          \
    \                    RNR\n                              REACH_ACK            \
    \           --------->\n                              ----------->   circuit_established\n\
    \                              XIDFRAME        DLC_XID\n                     \
    \         ----------->    -----------> respond with\n                        \
    \                                   XID configured\n                         \
    \                                  for station\n                             \
    \                              or forward\n                                  \
    \                         XID to\n                                           \
    \                station and\n                                               \
    \            send\n                   DLC_XID        XIDFRAME         DLC_XID\
    \ response\n              <-----------    <-----------    <-----------\n     \
    \         DLC_CONTACTED   CONTACT         DLC_CONTACT     RR\n              ----------->\
    \    ----------->    ----------->    --------->\n             connect_pending\
    \                contact_pending\n                 DLC_CONTACT       CONTACTED\
    \    DLC_CONTACTED\n                <-----------    <-----------    <-----------\n\
    \                connected                        connected\n                DLC_INFOs\
    \        IFRAMEs        DLC_INFOs       IFRAMEs\n              <------------>\
    \  <------------>  <------------>  <------->\n   Here is an example of a switched\
    \ SDLC PU 2.0 device as the target\n   station.\n ======                     \
    \       ___                           ======\n |    |        ---------       \
    \ __/   \\__       ---------        |    |\n |    |      __|  _|_  |__     / \
    \  IP    \\    __|  _|_  |__      |    |\n ======        |   |   |      <  Network\
    \  >     |   |   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw       Target\n Station\
    \        partner                          partner         Station\n          \
    \                                                       (SDLC)\n             \
    \ disconnected                    disconnected\n              DLC_RESOLVE_C  \
    \ CANUREACH_ex\n              ----------->    ----------->    reply if virtual\
    \ MAC/SAP\n                                              for SDLC station is\n\
    \                                              configured, if SDLC\n         \
    \                                     station responds to\n              DLC_RESOLVE_R\
    \     ICANREACH_ex  TEST/XID/SNRM/DISC, etc.\n               <-----------    \
    \ <-----------\n              DLC_XID         CANUREACH_cs    DLC_START_DL   \
    \ XID\n              ----------->    ----------->    ----------->    --------->\n\
    \              circuit_start                   resolve_pending\n             \
    \                   ICANREACH_cs   DLC_DL_STARTED        XID\n               \
    \                 <-----------   <-----------    <--------\n          circuit_established\
    \                 circuit_pending\n                              REACH_ACK\n \
    \                             ----------->   circuit_established\n           \
    \                     XIDFRAME        DLC_XID\n                              \
    \  ----------->    -----------> respond\n                                    \
    \                         with XID\n                                         \
    \                    received\n                     DLC_XID        XIDFRAME  \
    \      DLC_XID  above\n                <-----------    <-----------     <---------\n\
    \             DLC_CONTACTED   CONTACT         DLC_CONTACT     SNRM\n         \
    \    ----------->    ----------->    ----------->    --------->\n            \
    \ connect_pending                  contact_pending\n                DLC_CONTACT\
    \       CONTACTED    DLC_CONTACTED          UA\n               <-----------  \
    \  <-----------    <-----------    <--------\n                connected      \
    \                  connected\n                DLC_INFOs        IFRAMEs       \
    \ DLC_INFOs       IFRAMEs\n              <------------>  <------------>  <------------>\
    \  <-------->\n   Here is an example of an SDLC T2.1 device as the target station.\n\
    \   (SDLC T2.1 origin station would look just like the LAN T2.1 origin\n   station)\n\
    \ ======                            ___                           ======\n | \
    \   |        ---------        __/   \\__       ---------        |    |\n |   \
    \ |      __|  _|_  |__     /   IP    \\    __|  _|_  |__      |    |\n ======\
    \        |   |   |      <  Network  >     |   |   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw      Target\n Station\
    \        partner                          partner        Station\n           \
    \   disconnected                    disconnected\n              DLC_RESOLVE_C\
    \   CANUREACH_ex\n              ----------->    ----------->    implementer's\
    \ choice\n                                              (virtual MAC/SAP\n   \
    \                                            configured,\n                   \
    \                            check to see if station\n                       \
    \                        is powered up using\n              DLC_RESOLVE_R    \
    \ ICANREACH_ex   TEST/XID/DISC, etc.)\n               <-----------     <-----------\n\
    \              DLC_XID         CANUREACH_cs    DLC_START_DL    null XID\n    \
    \          ----------->    ----------->    ----------->    --------->\n      \
    \        circuit_start                   resolve_pending\n                   \
    \             ICANREACH_cs    DLC_DL_STARTED       XID\n                     \
    \           <-----------    <-----------    <-------\n          circuit_established\
    \                 circuit_pending\n                              REACH_ACK\n \
    \                             ----------->   circuit_established\n           \
    \                   XIDFRAME        DLC_XID\n                              ----------->\
    \    ----------->  respond with\n                                            \
    \                XID received\n                     DLC_XID        XIDFRAME  \
    \      DLC_XID above\n                <-----------    <-----------    <----------\n\
    \                 DLC_XIDs       XIDFRAMEs        DLC_XIDs         XIDs\n    \
    \          <------------>  <------------>  <------------>  <-------->\n      \
    \        DLC_CONTACTED   CONTACT         DLC_CONTACT     SNRM\n              ----------->\
    \    ----------->    ----------->    --------->\n              connect_pending\
    \                 contact_pending\n                 DLC_CONTACT       CONTACTED\
    \    DLC_CONTACTED         UA\n                <-----------    <-----------  \
    \  <-----------    <-------\n                connected                       \
    \ connected\n                DLC_INFOs        IFRAMEs        DLC_INFOs       IFRAMEs\n\
    \              <------------>  <------------>  <------------>  <-------->\n"
- title: 6.2  Link Restart Protocols
  contents:
  - "6.2  Link Restart Protocols\n   The following figure depicts the protocol flows\
    \ that result from\n   restarting the end-to-end connection.  This causes the\
    \ Data Link\n   Switches to terminate the existing connection and to enter the\n\
    \   Circuit Established state awaiting the start of a new connection.\n     Data\
    \ Link   Data Link                     Data Link   Data Link\n      Control  \
    \   Switch                        Switch      Control\n     ---------------------\
    \                     ---------------------\n          +-----------+         \
    \                    +-----------+\n          | Connected |                  \
    \           | Connected |\n    SABME +-----------+                           \
    \  +-----------+\n   ----------->                 RESTART_DL\n      DM       \
    \    ------------------------------------->     DISC\n   <-----------        \
    \                                       -------->\n                          \
    \                                     UA\n                         DL_RESTARTED\
    \ (Case 1)              <--------\n                   <-------------------------------------\n\
    \          +-----------+                             +-----------+\n         \
    \ |Circuit Est|                             |Circuit Est|\n          +-----------+\
    \                             +-----------+\n                        ...........\
    \ or ...........\n    SABME\n   ----------->           DL_RESTARTED (Case 2)\n\
    \       UA          <-------------------------------------\n   <-----------  \
    \                                   +-----------+\n                          \
    \                          |Circuit Est|\n                                CONTACT\
    \             +-----------+\n      RNR           ------------------------------------>\n\
    \   <----------\n              Figure 5.  DLSw Link Restart Message Protocols\n\
    \   Upon receipt of a SABME command from the origin station, the origin\n   DLSw\
    \ will send a RESTART_DL message to the target DLSw.  A DM\n   response is also\
    \ returned to the origin station and the data link is\n   restarted.\n   Upon\
    \ receipt of the RESTART_DL message, the target DLSw will issue a\n   DISC command\
    \ to the target station.  The target station is expected\n   to return a UA response.\
    \  The target DLSw will then restart its data\n   link and send an DL_RESTARTED\
    \ message back to the origin DLSw.\n   During this exchange of messages, both\
    \ Data Link Switches change\n   states from Connected state to Circuit Established\
    \ state.\n   If the origin station now resends the SABME command, the origin DLSw\n\
    \   will send a CONTACT message to the target DLSw.  If the SABME command\n  \
    \ is received prior to the receipt of the DL_RESTARTED message (case 2\n   in\
    \ the figure), the CONNECT message is delayed until the DL_RESTARTED\n   message\
    \ is received.  The resulting protocol flows at this point\n   parallel those\
    \ given above for the connect sequence.\n"
- title: 6.3  Disconnect Protocols
  contents:
  - "6.3  Disconnect Protocols\n   The following figure depicts the protocol flows\
    \ that result from the\n   end system terminating an existing connection.  Not\
    \ only is the\n   connection terminated, but the circuit between the Data Link\
    \ Switches\n   is taken down.\n     Data Link  Data Link                     \
    \ Data Link  Data Link\n      Control    Switch                         Switch\
    \     Control\n     --------------------                      --------------------\n\
    \          +-----------+                             +-----------+\n         \
    \ | Connected |                             | Connected |\n          +-----------+\
    \                             +-----------+\n      DISC\n   ---------->      \
    \            HALT_DL\n       UA         ------------------------------------->\
    \      DISC\n   <----------                                              --------->\n\
    \                                                               UA\n         \
    \                      DL_HALTED                    <--------\n              \
    \    <-------------------------------------\n          +-----------+         \
    \                    +-----------+\n          |Disconnectd|                  \
    \           |Disconnectd|\n          +-----------+                           \
    \  +-----------+\n                          ......... or ..........\n        \
    \  +-----------+                             +-----------+\n          | Connected\
    \ |                             | Connected |\n          +-----------+       \
    \                      +-----------+\n       DISC              TCP Connection\
    \ Failure               DISC\n   <--------     <------------------------------------>\
    \    --------->\n        UA                                                  \
    \   UA\n    -------->                                               <--------\n\
    \          +-----------+                             +-----------+\n         \
    \ |Disconnectd|                             |Disconnectd|\n          +-----------+\
    \                             +-----------+\n               Figure 6.  DLSw Disconnect\
    \ Message Protocols\n   Upon receipt of a DISC command from the origin station,\
    \ the origin\n   DLSw will reply with a UA response and issue a HALT_DL message\
    \ to the\n   target DLSw.  Upon receipt of the HALT_DL message, the target DLSw\n\
    \   will send a DISC command to the target station.  The target station\n   will\
    \ then respond with a UA response, causing the target DLSw to\n   return a DL_HALTED\
    \ message to the origin DLSw.  During this exchange\n   of messages, both Data\
    \ Link Switches change states from the Connected\n   state to the Disconnected\
    \ state.\n   If the TCP connection between two Data Link Switches fails, all\n\
    \   connections that are currently multiplexed on the failed TCP\n   connection\
    \ will be taken down.  This implies that both Data Link\n   Switches will send\
    \ DISC commands to all the local systems that are\n   associated with the failed\
    \ connections.  Upon sending the DISC\n   command, the Data Link Switch will enter\
    \ the DISCONNECTED state for\n   each circuit.\n"
- title: 7.0  Capabilities Exchange Formats/Protocol
  contents:
  - "7.0  Capabilities Exchange Formats/Protocol\n   The Data Link Switching Capabilities\
    \ Exchange is a special DLSw\n   Switch-to-Switch control message that describes\
    \ the capabilities of\n   the sending data link switch. This control message is\
    \ sent after the\n   switch-to-switch connection is established and optionally\
    \ during run\n   time if certain operational parameters have changed and need\
    \ to be\n   communicated to the partner switch.\n   The actual contents of the\
    \ Capabilities Exchange is in the data field\n   following the SSP message header.\
    \  The Capabilities Exchange itself\n   is formatted as a single General Data\
    \ Stream (GDS) Variable with\n   multiple type \"LT\" structured subfields.\n\
    \   The SSP Message Header has the following fields set for the\n   Capabilities\
    \ Exchange:\n   Offset   Field                 Value\n   ------   -----      \
    \           -----\n   0x00     Version Number        0x31\n   0x01     Header\
    \ Length         0x48 (decimal 72)\n   0x02     Message Length        same as\
    \ LL in GDS Variable\n   0x14     Message Type          0x20 (CAP_EXCHANGE)\n\
    \   0x16     Protocol Id           0x42\n   0x17     Header Number         0x01\n\
    \   0x23     Message Type          0x20 (CAP_EXCHANGE)\n   0x38     Direction\
    \             0x01 for CapEx request\n                                  0x02 for\
    \ CapEx response\n   Other fields in the SSP header are not referenced and should\
    \ be set\n   to zero.\n   The DLSw Capabilities Exchange Request has the following\
    \ overall\n   format:\n   +----+----+-----------------+\n   | LL | ID | Control\
    \ Vectors |\n   +----+----+-----------------+\n   0-1         Length, in binary,\
    \ of the DLSw Capabilities\n               Exchange\n               Request GDS\
    \ Variable.  The value of LL is\n               the sum of the length of all fields\
    \ in the\n               GDS Variable (i.e., length of LL + length of ID\n   \
    \            + length of Control Vectors).\n   2-3         GDS Id: 0x1520\n  \
    \ 4-n         Control Vectors consisting of type LT structured\n             \
    \  subfields (i.e., the DLSw Capabilities Exchange\n               Structured\
    \ Subfields)\n   Type LT structured subfields consist of a 1-byte length field\
    \ (the\n   \"L\"), a 1-byte type field (the \"T\") and n-bytes of data.  The length\n\
    \   field includes itself as well as the structured subfield.  The\n   structured\
    \ subfield consists of the type field and data so the length\n   is n + 2. This\
    \ imposes a length restriction of 253 bytes on all data\n   contained in a structured\
    \ subfield.\n"
- title: 7.1  Control Vector Id Range
  contents:
  - "7.1  Control Vector Id Range\n   Control Vector identifiers (i.e., Type) in the\
    \ range of 0x80 through\n   0xCF are reserved for use by the Data Link Switching\
    \ standard.\n   Control Vector identifiers (i.e., Type) in the range of 0xD0 through\n\
    \   0xFD are used for vendor-specific purposes.\n   Currently defined vectors\
    \ are:\n   Vector Description                       Hex Value\n   Vendor Id Control\
    \ Vector                 0x81\n   DLSw Version Control Vector              0x82\n\
    \   Initial Pacing Window Control Vector     0x83\n   Version String Control Vector\
    \            0x84\n   Mac Address Exclusivity Control Vector   0x85\n   Supported\
    \ SAP List Control Vector        0x86\n   TCP Connections Control Vector     \
    \      0x87\n   NetBIOS Name Exclusivity Control Vector  0x88\n   MAC Address\
    \ List Control Vector          0x89\n   NetBIOS Name List Control Vector     \
    \    0x8A\n   Vendor Context Control Vector            0x8B\n   Reserved for future\
    \ use                  0x8C - 0xCF\n   Vendor Specific                       \
    \   0xD0 - 0xFD\n"
- title: 7.2  Control Vector Order and Continuity
  contents:
  - "7.2  Control Vector Order and Continuity\n   Since their contents can greatly\
    \ affect the parsing of the\n   Capabilities Exchange GDS Variable, the required\
    \ control vectors must\n   occur first and appear in the following order:  Vendor\
    \ Id, DLSw\n   Version Number, Initial Pacing Window, Supported SAP List. The\n\
    \   remainder of the Control Vectors can occur in any order.\n   Control Vectors\
    \ that can be repeated within the same message (e.g.,\n   MAC Address List Control\
    \ Vector and NetBIOS Name List Control Vector)\n   are not necessarily adjacent.\
    \  It is advisable, but not required, to\n   have the Exclusivity Control Vector\
    \ occur prior to either of the\n   above two vectors so that the use of the individual\
    \ MAC addresses or\n   NetBIOS names will be known prior to parsing them.\n  \
    \ Both the Vendor Context and Vendor Specific control vectors can be\n   repeated.\
    \  If there are multiple instances of the Vendor Context\n   control vector, the\
    \ specified context remains in effect for all\n   Vendor Specific control vectors\
    \ until the next Vendor Context control\n   vector is encountered in the Capabilities\
    \ Exchange.\n"
- title: 7.3  Initial Capabilities Exchange
  contents:
  - "7.3  Initial Capabilities Exchange\n   Capabilities exchange is always the first\
    \ SSP message sent on a new\n   SSP connection between two DLSw switches.  This\
    \ initial Capabilities\n   Exchange is used to identify the DLSw version that\
    \ each switch is\n   running and other required information, plus details of any\
    \ optional\n   extensions that the switches are capable of supporting.\n   If\
    \ a DLSw receives an initial capabilities message that is\n   incorrectly formatted\
    \ or contains invalid or unsupported data that\n   prevents correct interoperation\
    \ with the partner DLSw, it should\n   issue a Capabilities Exchange negative\
    \ response.\n   If a DLSw receives a negative response to its initial capabilities\n\
    \   message, it should take down its TCP connections with the offended\n   partner.\n\
    \   Note:  Pre v1.0 DLSw implementations do not send or respond to\n   capabilities\
    \ messages and can be identified by the lack of\n   capabilities exchange as the\
    \ first message on a new SSP connnection.\n   This document does not attempt to\
    \ specify how to interoperate with\n   back-level DLSw implementations.\n"
- title: 7.4  Run-Time Capabilities Exchange
  contents:
  - "7.4  Run-Time Capabilities Exchange\n   Capabilities exchange always occurs when\
    \ the SSP connection is\n   started between two DLSw switches.  Capabilities Exchange\
    \ can also\n   occur at run-time, typically when a configuration change is made.\n\
    \   Support for run-time Capabilities Exchange is optional.  If a node\n   does\
    \ not support receiving/using Run-Time Capabilities Exchange and\n   receives\
    \ one, it should discard it quietly (not send back a negative\n   response). \
    \ If a node supports receipt of run-time capabilities, it\n   should send a positive\
    \ or negative response as appropriate.  The\n   receiver of a negative response\
    \ to a run-time capabilities message is\n   not required to take down its TCP\
    \ connections with the offended\n   partner.\n   Run-time Capabilities Exchange\
    \ can consist of one or more of the\n   following control vectors.  Note that\
    \ the control vectors required at\n   start-up are not present in a run-time Capabilities\
    \ Exchange.\n        1. MAC Address Exclusivity CV,\n        2. NetBIOS Name Exclusivity\
    \ CV,\n        3. MAC Address List CV,\n        4. NetBIOS Name List CV,\n   \
    \     5. Supported SAP List CV,\n        6. Vendor Context CV,\n        7. Vendor\
    \ Specific CVs\n   A run-time capabilities exchange is a replacement operation.\
    \  As\n   such, all pertinent MAC addresses and NetBIOS names must be specified\n\
    \   in the run-time exchange. In addition, run-time changes in\n   capabilities\
    \ will not effect existing link station circuits.\n"
- title: 7.5  Capabilities Exchange Filtering Responsibilities
  contents:
  - "7.5  Capabilities Exchange Filtering Responsibilities\n   Recipients of the SAP,\
    \ MAC, and NetBIOS lists are not required to\n   actually use them to filter traffic,\
    \ etc., either initially or at\n   run-time.\n"
- title: 7.6  DLSw Capabilities Exchange Structured Subfields
  contents:
  - "7.6  DLSw Capabilities Exchange Structured Subfields\n   The Capabilities Exchange\
    \ Subfields are listed in the table below and\n   are described in the following\
    \ sections:\n         Required                      Allowed @\n    ID   @ Startup\
    \  Length  Repeatable* Runtime  Order  Content\n   ====  =========  ======  ==========\
    \  =======  =====  ===============\n   0x81     Y        0x05        N       \
    \  N       1    Vendor ID\n   0x82     Y        0x04        N         N      \
    \ 2    DLSw Version\n   0x83     Y        0x04        N         N       3    Initial\
    \ pacing\n                                                        window\n   0x84\
    \     N      >=0x02        N         N       5+   Version String\n   0x85    \
    \ N        0x03        N         Y       5+   MAC Address\n                  \
    \                                      Exclusivity\n   0x86     Y        0x12\
    \        N         Y       4    Supported SAP\n                              \
    \                          List\n   0x87     N        0x03        N         N\
    \       5+   TCP Connections\n   0x88     N        0x03        N         Y   \
    \    5+   NetBIOS Name\n                                                     \
    \   Exclusivity\n   0x89     N        0x0E        Y         Y       5+   MAC Address\n\
    \                                                        List\n   0x8A     N \
    \     <=0x13        Y         Y       5+   NetBIOS Name\n                    \
    \                                    List\n   0x8B     N        0x05        Y\
    \         Y       5+   Vendor Context\n   0xD0     N       varies       Y    \
    \     Y       5+   Vendor Specific\n   *Note: \"Repeatable\" means a Control Vector\
    \ is repeatable within a single\n   message.\n"
- title: 7.6.1  Vendor Id (0x81) Control Vector
  contents:
  - "7.6.1  Vendor Id (0x81) Control Vector\n   The Vendor Id control vector identifies\
    \ the manufacturer's IEEE\n   assigned Organizationally Unique Identifier (OUI)\
    \ of the Data Link\n   Switch sending the DLSw Capabilities Exchange.  The OUI\
    \ is sent in\n   non-canonical (Token-Ring) format.  This control vector is required\n\
    \   and must be the first control vector.\n   Offset  Length  Value  Contents\n\
    \   ------  ------  -----  --------\n      0       1    0x05   Length of the Vendor\
    \ Id structured\n                          subfield\n      1       1    0x81 \
    \  key = 0x81  that identifies this as the\n                          Vendor Id\
    \ structured subfield\n     2-4      3           the 3-byte Organizationally Unique\n\
    \                          Identifier (OUI) for the vendor\n                 \
    \         (non-canonical format)\n"
- title: 7.6.2  DLSw Version (0x82) Control Vector
  contents:
  - "7.6.2  DLSw Version (0x82) Control Vector\n   The DLSw Version control vector\
    \ identifies the particular version of\n   the DLSw standard supported by the\
    \ sending Data Link Switch.  This\n   control vector is required and must follow\
    \ the Vendor Id Control\n   Vector.\n   Offset  Length  Value  Contents\n   ------\
    \  ------  -----  --------\n      0       1    0x04   Length of the Version String\
    \ structured\n                          subfield\n      1       1    0x82   key\
    \ = 0x82  that identifies this as the\n                          DLSw Version\
    \ structured subfield\n      2       1           the hexadecimal value representing\
    \ the\n                          DLSw standard Version number of the\n       \
    \                   sending Data Link Switch.\n                            0x01\
    \ (indicates version 1 - closed pages)\n      3       1           the hexadecimal\
    \ value representing the\n                          DLSw standard Release number\
    \ of the\n                          sending Data Link Switch.\n              \
    \              0x00 (indicates release 0)\n"
- title: 7.6.3  Initial Pacing Window (0x83) Control Vector
  contents:
  - "7.6.3  Initial Pacing Window (0x83) Control Vector\n   The Initial Pacing Window\
    \ control vector specifies the initial value\n   of the receive pacing window\
    \ size for the sending Data Link Switch.\n   This control vector is required and\
    \ must follow the DLSw Version\n   Control Vector.\n   Offset  Length  Value \
    \ Contents\n   ------  ------  -----  --------\n      0       1    0x04   Length\
    \ of the Initial Pacing Window\n                          structured subfield\n\
    \      1       1    0x83   key = 0x83  that identifies this\n                \
    \          as the Initial Pacing Window\n                          structured\
    \ subfield\n     2-3      2           the pacing window size, specified\n    \
    \                      in byte normal form..\n   Note:  The pacing window size\
    \ must be non-zero.\n"
- title: 7.6.4  Version String (0x84) Control Vector
  contents:
  - "7.6.4  Version String (0x84) Control Vector\n   The Version String control vector\
    \ identifies the particular version\n   number of the sending Data Link Switch.\
    \  The format of the actual\n   version string is vendor-defined.  This control\
    \ vector is optional.\n   Offset  Length  Value  Contents\n   ------  ------ \
    \ -----  --------\n      0       1    0xn    Length of the Version String\n  \
    \                        structured subfield\n      1       1    0x84   key =\
    \ 0x84  that identifies\n                          this as the Version String\n\
    \                          structured subfield\n     2-n     n-2          the\
    \ ASCII string that identifies\n                          the software version\
    \ for the\n                          sending DLSw.\n"
- title: 7.6.5  MAC Address Exclusivity (0x85) Control Vector
  contents:
  - "7.6.5  MAC Address Exclusivity (0x85) Control Vector\n   The MAC Address Exclusivity\
    \ control vector identifies how the MAC\n   Address List control vector data is\
    \ to be interpreted.  Specifically,\n   this control vector identifies whether\
    \ the MAC addresses in the MAC\n   Address List control vectors are the only ones\
    \ accessible via the\n   sending Data Link Switch.\n   If a MAC Address List control\
    \ vector is specified and the MAC Address\n   Exclusivity control vector is missing,\
    \ then the MAC addresses are not\n   assumed to be the only ones accessible via\
    \ this switch.\n   A node may specify that it supports no local MAC addresses\
    \ by\n   including in its capabilities the MAC Address List Exclusivity CV\n \
    \  (with byte 2 == 0x01), and not including any instances of the MAC\n   Address\
    \ List CV.\n   Offset  Length  Value  Contents\n   ------  ------  -----  --------\n\
    \      0       1    0x03   Length of the Exclusivity structured\n            \
    \              subfield\n      1       1    0x85   key = 0x85 that identifies\
    \ this as the\n                          MAC address Exclusivity structured\n\
    \                          subfield\n      2       1           an indicator of\
    \ the relationship of the\n                          MAC addresses to the sending\
    \ Data Link\n                          Switch.\n                            0x00\
    \     the MAC addresses specified in\n                                     this\
    \ Capabilities Exchange\n                                     can be accessed\
    \ via this\n                                     switch but are not the\n    \
    \                                 exclusive set (i.e., other\n               \
    \                      entities are accessible in\n                          \
    \           addition to the ones specified)\n                            0x01\
    \     the MAC addresses specified in\n                                     this\
    \ Capabilities Exchange\n                                     are the only ones\
    \ accessible\n                                     via this switch.\n"
- title: 7.6.6  SAP List Support (0x86) Control Vector
  contents:
  - "7.6.6  SAP List Support (0x86) Control Vector\n   The SAP List Support control\
    \ vector identifies support for Logical\n   Link Control SAPs (DSAPs and SSAPs)\
    \ by the sending Data Link Switch.\n   This is used by the DLSw that sent the\
    \ SAP List Support control\n   vector to indicate which SAPs can be used to support\
    \ SNA and\n   optionally NetBIOS traffic.  This may be used by the DLSw that\n\
    \   receives the SAP list to filter explorer traffic (TEST, XID, or\n   NetBIOS\
    \ UI frames) from the DLSw state machine.  For SNA, a DLSw\n   should set bits\
    \ for all SAP values (SSAP or DSAP) that may be used\n   for SNA traffic.  For\
    \ NetBIOS support, the bit for SAP 0xF0 should be\n   set (if not supported then\
    \ the same bit should be cleared).\n   Each bit in the SAP control vector data\
    \ field represents a SAP as\n   defined below.  This vector is required and must\
    \ follow the Initial\n   Pacing Window Control Vector.\n   Offset  Length  Value\
    \  Contents\n   ------  ------  -----  --------\n      0       1     0x12  Length\
    \ of the Supported SAP List structured\n                          subfield\n \
    \     1       1     0x86  key = 0x86 that identifies this as the\n           \
    \               Supported SAP List structured subfield\n     2-17    16      \
    \     the 16-byte bit vector describing all\n                          even numbered\
    \ SAPs enabled.\n                          Each Bit within the 16 byte bit vector\
    \ will\n                          indicate whether an even numbered SAP is\n \
    \                         enabled (b'1') or disabled (b'0').\n               \
    \           Each Byte within the 16 byte bit vector\n                        \
    \  will be numbered from 0 - F. (Most\n                          significant byte\
    \ first).\n                          Byte 0   1   2   3   ...   F\n          \
    \                     XX  XX  XX  XX  ...   XX\n                          The\
    \ bits in each byte indicate whether an\n                          even numbered\
    \ SAP is enabled (b'1') or\n                          disabled (b'0'). (Most significant\
    \ bit first)\n                          Bits 7   6   5   4   ...   0\n       \
    \                   SAP  0   2   4   6   ...   E\n                          By\
    \ combining the byte label with the enabled\n                          bits, all\
    \ supported SAPs can be determined.\n                          In the following\
    \ diagram, 'n' would equal 0\n                          through F depending on\
    \ which byte was being\n                          interpreted.\n             \
    \             Bit ordering is shown below with bit\n                         \
    \ 7 being the most significant bit and bit\n                          0 the least\
    \ significant bit.\n                          7654 3210\n                    \
    \      bbbb bbbb....\n                          |||| ||||\n                  \
    \        |||| |||SAP 0xnE enabled or not\n                          |||| |||\n\
    \                          |||| ||SAP 0xnC enabled or not\n                  \
    \        |||| ||\n                          |||| |SAP 0xnA enabled or not\n  \
    \                        |||| |\n                          |||| SAP 0xn8 enabled\
    \ or not\n                          ||||\n                          |||SAP 0xn6\
    \ enabled or not\n                          |||\n                          ||SAP\
    \ 0xn4 enabled or not\n                          ||\n                        \
    \  |SAP 0xn2 enabled or not\n                          |\n                   \
    \       SAP 0xn0 enabled or not\n   An example of using all User Definable SAPs\
    \ of 0x04 to 0xEC for SNA\n   Data Link Switching and SAP 0xF0 for NetBIOS Data\
    \ Link Switching\n   would be as follows:\n   Offset  SAPs          Binary   \
    \    Hex\n   0       4,8,C         0010 1010    0x2A\n   1       10,14,18,1C \
    \  1010 1010    0xAA\n   2       20,24,28,2C   1010 1010    0xAA\n   3       30,34,38,3C\
    \   1010 1010    0xAA\n   4       40,44,48,4C   1010 1010    0xAA\n   5      \
    \ 50,54,58,5C   1010 1010    0xAA\n   6       60,64,68,6C   1010 1010    0xAA\n\
    \   7       70,74,78,7C   1010 1010    0xAA\n   8       80,84,88,8C   1010 1010\
    \    0xAA\n   9       90,94,98,9C   1010 1010    0xAA\n   A       A0,A4,A8,AC\
    \   1010 1010    0xAA\n   B       B0,B4,B8,BC   1010 1010    0xAA\n   C      \
    \ C0,C4,C8,CC   1010 1010    0xAA\n   D       D0,D4,D8,DC   1010 1010    0xAA\n\
    \   E       E0,E4,E8,EC   1010 1010    0xAA\n   F       F0            1000 0000\
    \    0x80\n"
- title: 7.6.7  TCP Connections (0x87) Control Vector
  contents:
  - "7.6.7  TCP Connections (0x87) Control Vector\n   The TCP Connections control\
    \ vector indicates the support of an\n   alternate number of TCP Connections for\
    \ the Data Link Switching\n   traffic.  The base implementation of Data Link Switching\
    \ supports two\n   TCP Connections, one for each direction of data traffic.\n\
    \   This control vector is optional.  If it is omitted in a DLSw\n   Capabilities\
    \ Exchange, then two TCP Connections are assumed.  It is\n   further assumed that\
    \ if a Data Link  Switch can support one TCP\n   Connection, it can support two\
    \ TCP Connections.\n   If TCP Connections CV values agree and the number of connections\
    \ is\n   one, then the  DLSw with the higher IP address must tear down the TCP\n\
    \   connections on its local port 2065.\n   The format of the TCP Connections\
    \ Control Vector is shown below:\n   Offset  Length  Value  Contents\n   ------\
    \  ------  -----  --------\n      0       1    0x03   Length of the TCP Connections\
    \ structured\n                          subfield\n      1       1    0x87   key\
    \ = 0x87  that identifies this as the\n                          TCP Connections\
    \ structured subfield\n      2       1           an indicator of the support for\
    \ an\n                          alternate number of TCP Connections by\n     \
    \                     the sending Data Link Switch.\n                        \
    \    0x01      the number of TCP Connections\n                               \
    \       may be brought down to one\n                                      after\
    \ Capabilities Exchange\n                                      is completed.\n\
    \                            0x02      the number of TCP Connections\n       \
    \                               will remain at two for\n                     \
    \                 the duration of the DLSw\n                                 \
    \     connection.\n"
- title: 7.6.8  NetBIOS Name Exclusivity (0x88) Control Vector
  contents:
  - "7.6.8  NetBIOS Name Exclusivity (0x88) Control Vector\n   The NetBIOS Name Exclusivity\
    \ control vector identifies how the\n   NetBIOS Name List control vector data\
    \ is to be interpreted.\n   Specifically, this control vector identifies whether\
    \ the NetBIOS\n   Names in the NetBIOS Name List control vectors are the only\
    \ ones\n   accessible via the sending Data Link Switch.\n   If a NetBIOS Name\
    \ List control vector is specified and the NetBIOS\n   Name Exclusivity control\
    \ vector is missing, then the NetBIOS Names\n   are not assumed to be the only\
    \  ones accessible via this switch.\n   A node may specify that it supports no\
    \ local NetBIOS names by\n   including in its  capabilities the NetBIOS Name List\
    \ Exclusivity CV\n   (with byte 2 == 0x01), and not including any instances of\
    \ the NetBIOS\n   Name List CV.\n   Offset  Length  Value  Contents\n   ------\
    \  ------  -----  --------\n      0       1    0x03   Length of the Exclusivity\
    \ structured\n                          subfield\n      1       1    0x88   key\
    \ = 0x88 that identifies this as the\n                          NetBIOS Name Exclusivity\
    \ structured\n                          subfield\n      2       1           an\
    \ indicator of the relationship of the\n                          NetBIOS Names\
    \ to the sending Data Link\n                          Switch.\n              \
    \              0x00     the NetBIOS Names specified in\n                     \
    \                this Capabilities Exchange\n                                \
    \     can be accessed via this\n                                     switch but\
    \ are not the\n                                     exclusive set (i.e., other\n\
    \                                     entities are accessible in\n           \
    \                          addition to the ones specified)\n                 \
    \           0x01     the NetBIOS Names specified in\n                        \
    \             this Capabilities Exchange\n                                   \
    \  are the only ones accessible\n                                     via this\
    \ switch.\n"
- title: 7.6.9  MAC Address List (0x89) Control Vector
  contents:
  - "7.6.9  MAC Address List (0x89) Control Vector\n   The MAC Address List control\
    \ vector identifies one or more MAC\n   addresses that are accessible through\
    \ the sending Data Link Switch.\n   This control vector specifies a single MAC\
    \ address value and MAC\n   address mask value to identify the MAC address or\
    \ range of MAC\n   addresses.  MAC addresses and masks are in non-canonical (Token-Ring)\n\
    \   format in this control vector.\n   This control vector is optional and can\
    \ be repeated if necessary.\n   Note 1: If a particular MAC address, <mac-addr>,\
    \ satisfies the\n   following algorithm, then <mac-addr> is assumed to be accessible\
    \ via\n   the sending Data Link Switch:\n   <mac-addr> & <mac-addr-mask> == <mac-addr-value>\n\
    \   where:  <mac-addr-value> is the MAC Address\n                            Value\
    \ specified in\n                            this control vector\n           <mac-addr-mask>\
    \  is the MAC Address\n                            Mask specified in\n       \
    \                     this control vector\n   Note 2:  If an individual MAC Address\
    \ is desired, then <mac-addr-\n   value> should be the individual MAC address\
    \ and <mac-addr-mask>\n   should be 0xFFFFFFFFFFFF.\n   Offset  Length  Value\
    \  Contents\n   ------  ------  -----  --------\n      0       1    0x0E   Length\
    \ of the MAC Address List\n                          structured subfield\n   \
    \   1       1    0x89   key = 0x89  that identifies this as the\n            \
    \              MAC Address List structured subfield\n     2-7      6         \
    \  the 6-byte MAC Address Value,\n                          <mac-addr-value> in\
    \ the above formula\n     8-13     6           the 6-byte MAC Address Mask,\n\
    \                          <mac-addr-mask> in the above formula\n"
- title: 7.6.10  NetBIOS Name List (0x8A) Control Vector
  contents:
  - "7.6.10  NetBIOS Name List (0x8A) Control Vector\n   The NetBIOS Name List control\
    \ vector identifies one or more NetBIOS\n   names that are accessible through\
    \ the sending Data Link Switch.  This\n   control vector specifies a single NetBIOS\
    \ name in ASCII.  However,\n   the NetBIOS name can consist of \"don't care\"\
    \ and \"wildcard\"\n   characters to match on a number of NetBIOS names.  If an\
    \ individual\n   character position in the NetBIOS name in this control vector\n\
    \   contains a '?', then the corresponding character position in real\n   NetBIOS\
    \ name is a \"don't care\".  If a NetBIOS name in this control\n   vector ends\
    \ in '*', then the remainder of real NetBIOS names is a\n   \"don't care\".  '*'\
    \ is only considered a wildcard if it appears at the\n   end of a name.\n   All\
    \ blanks or nulls at the end of NetBIOS names in this control\n   vector are ignored.\
    \   NetBIOS names which have fewer than 16 bytes\n   and which do not end with\
    \  '*' are not assumed to have a trailing\n   '*'; the \"wildcard\" character\
    \ must be explicit.\n   NetBIOS group names can exist across several LANs/networks.\
    \  As such,\n   NetBIOS  group names received in a NetBIOS Name List Control Vector\n\
    \   can not be treated the same as NetBIOS individual names.  The\n   Individual/Group\
    \ Flag allows Data  Link Switches to distinguish\n   between the two.\n   This\
    \ control vector is optional and can be repeated if necessary.\n   Offset  Length\
    \  Value  Contents\n   ------  ------  -----  --------\n      0       1    0xn\
    \    Length of the NetBIOS Name List\n                          structured subfield\
    \ (maximum = 0x13)\n      1       1    0x8A   key = 0x8A  that identifies this\
    \ as the\n                          NetBIOS Name List structured subfield\n  \
    \    2       1           Individual/Group Flag\n                            0x00\
    \ - Individual NetBIOS Name\n                            0x01 - Group NetBIOS\
    \ Name\n     3-n     n-3          the NetBIOS name with possible embedded\n  \
    \                        '?' and terminating '*'.\n"
- title: 7.6.11  Vendor Context (0x8B) Control Vector
  contents:
  - "7.6.11  Vendor Context (0x8B) Control Vector\n   The Vendor Context control vector\
    \ identifies the manufacturer's IEEE\n   assigned Organizationally Unique Identifier\
    \ (OUI) of the Data Link\n   Switch sending the DLSw Capabilities Exchange.  The\
    \ OUI is sent in\n   non-canonical (Token-Ring) format.\n   This control vector\
    \ is optional and is used to provide the context\n   for any Vendor Specific control\
    \ vectors that follow in the\n   Capabilities Exchange.  If there are multiple\
    \ instances of the Vendor\n   Context control vector, the specified context remains\
    \ in effect for\n   all Vendor Specific control vectors until the next Vendor\
    \ Context\n   control vector is encountered.\n      Offset  Length  Value  Contents\n\
    \      ------  ------  -----  --------\n         0       1    0x05   Length of\
    \ the Vendor Context structured\n                             subfield\n     \
    \    1       1    0x8B   key = 0x8B  that identifies this as the\n           \
    \                  Vendor Context structured subfield\n        2-4      3    \
    \       the 3-byte Organizationally Unique\n                             Identifier\
    \ (OUI) for the vendor\n                             (non-canonical format)\n"
- title: 7.7  Capabilities Exchange Responses
  contents:
  - "7.7  Capabilities Exchange Responses\n   There are two kinds of DLSw Capabilities\
    \ Exchange Responses: positive\n   and negative.  A positive response is returned\
    \ to the sending Data\n   Link Switch if there were no errors encountered in the\
    \ DLSw\n   Capabilities Exchange Request.  A negative response is returned if\n\
    \   there is at least one error encountered.\n   A positive DLSw Capabilities\
    \ Exchange Response has the following\n   overall format:\n   +----+----+\n  \
    \ | LL | ID |\n   +----+----+\n   0-1    Length, in binary, of the DLSw Capabilities\n\
    \          Exchange Response GDS Variable.  The value of\n          LL in this\
    \ case is 0x0004.\n   2-3    GDS Id: 0x1521\n   A negative DLSw Capabilities Exchange\
    \ Response has the following\n   overall format:\n   +----+----+--------+--------+\n\
    \   | LL | ID | Offset | Reason |\n   +----+----+--------+--------+\n   0-1  \
    \  Length, in binary, of the DLSw Capabilities Exchange\n          Response GDS\
    \ Variable.  The value of LL is the sum of\n          the length of all fields\
    \ in the GDS Variable (i.e.,\n          length of LL + length of ID + length of\
    \ Offsets/Reasons).\n   2-3    GDS Id: 0x1522\n   4-5    Offset into the DLSw\
    \ Capabilities Exchange Request of the\n          error.  Offset should always\
    \ point to the start of the\n          GDS Variable or a specific control vector.\n\
    \   6-7    Reason code that uniquely identifies the error.  Specific\n       \
    \   values for the reason code are:\n            0x0001        invalid GDS length\
    \ for a DLSw Capabilities\n                          Exchange Request.  (The value\
    \ of Offset\n                          is ignored.)\n            0x0002      \
    \  invalid GDS id for a DLSw Capabilities\n                          Exchange\
    \ Request.  (The value of Offset\n                          is ignored.)\n   \
    \         0x0003        Vendor Id control vector is missing.  (The\n         \
    \                 value of Offset is ignored.)\n            0x0004        DLSw\
    \ Version control vector is missing. (The\n                          value of\
    \ Offset is ignored.)\n            0x0005        Initial Pacing Window control\
    \ vector is\n                          missing.  (The value of Offset is ignored.)\n\
    \            0x0006        length of control vectors doesn't correlate\n     \
    \                     to the length of the GDS variable\n            0x0007  \
    \      invalid control vector id\n            0x0008        length of control\
    \ vector invalid\n            0x0009        invalid control vector data value\n\
    \            0x000A        duplicate control vector (for non-repeating\n     \
    \                     control vectors)\n            0x000B        out-of-sequence\
    \ control vector (for\n                          repeating control vector)\n \
    \           0x000C        DLSw Supported SAP List control vector is\n        \
    \                  missing.\n                          (The value of Offset is\
    \ ignored.)\n   Note:  Multiple Offset, Reason pairs can be returned with one\
    \ pair\n   for each error encountered.\n"
- title: 8.  Pacing/Flow Control
  contents:
  - "8.  Pacing/Flow Control\n   This section describes the required Pacing and Flow\
    \ Control\n   mechanisms used by a Data Link Switch.\n   While it is beyond the\
    \ scope of this document to specify a policy for\n   how an implementation maps\
    \ SSP flow control to the native data link\n   flow control at the edges, the\
    \ following paragraphs describe a\n   general philosophical overview of how the\
    \ mechanism is to be applied.\n   There are two types of flows which are covered\
    \ by the flow control\n   mechanism: connection-oriented and connectionless. \
    \ In the first,\n   connection-oriented flows, the implementer is to map the native\
    \ flow\n   control mechanism of the two data links at the boundaries to the SSP\n\
    \   flow control mechanism thus presenting an end-to-end flow control\n   mechanism\
    \ which \"pushes back\" all the way to the originating station\n   in either direction.\n\
    \   However, in the case of connectionless traffic, this is not possible\n   at\
    \ the data link level because there is no native flow control\n   mechanism for\
    \ connectionless data links.  At first glance it is\n   tempting to allow connectionless\
    \ traffic to flow the DLSw cloud\n   unthrottled.  However, the rationale for\
    \ subjecting these flows to\n   flow control within the DLSw cloud is to \"push\"\
    \ the discarding of\n   frames (should this become necessary) back to the ingress\
    \ of the DLSw\n   cloud.  This \"early discarding\" of excessive DATAGRAMs should\
    \ allow\n   the cloud to remain deterministic without wasting network bandwidth.\n"
- title: 8.1  Basic Overview
  contents:
  - "8.1  Basic Overview\n   Each circuit consists of two data flows, one in each\
    \ direction.  Each\n   data flow has its own independent flow control mechanism.\
    \  For each\n   data flow there is an entity that originates traffic, referred\
    \ to as\n   the sender, and a target entity which receives the traffic, referred\n\
    \   to as the receiver.\n   A sender may only send data when its receiver has\
    \ granted explicit\n   permission to send a discrete number of data units.  Data\
    \ units are\n   defined as either a DGRMFRAME or an INFOFRAME.\n   The receiver\
    \ grants permission to send data units by sending a Flow\n   Control Indicator\
    \ (FCIND- defined later).  The sender must\n   acknowledge all FCINDs by sending\
    \ a Flow Control Acknowledgment\n   (FCACK- defined later).\n   A sending implementation\
    \ must maintain these values:\n   1. GrantedUnits - The number of units (frames)\
    \ which the sender\n      currently has permission to send.\n   2. CurrentWindow\
    \ - This is a discrete number of units, controlled by\n      the receiver, which\
    \ is basis for granting additional units.\n   3. InitialWindowSize - Global for\
    \ all circuits on a transport\n      connection.  Learned in capabilities exchange\
    \ when the transport\n      connection is established.  It specifies an initial\
    \ value for\n      CurrentWindow when each circuit is established.\n   A receiving\
    \ implementation must maintain these values:\n   1. CurrentWindow - This is a\
    \ discrete number of units, controlled by\n      the receiver, which is basis\
    \ for granting additional units.\n   2. InitialWindowSize - Global for all circuits\
    \ on a transport\n      connection.  Sent in capabilities exchange when the transport\n\
    \      connection is established.  It specifies an initial value for\n      CurrentWindow\
    \ when each circuit is established.\n   3. FCACKOwed - The sender owes an FCACK.\
    \  If true, no FCIND may be\n      sent.\n"
- title: 8.2  Frame Format
  contents:
  - "8.2  Frame Format\n   The Flow control Byte is contained at offset 15 in both\
    \ the\n   Information and Control SSP messages.  From a flow control\n   perspective,\
    \ the flow control information in the two frames are\n   handled identically.\n\
    \   The following diagram describes the format of the Flow Control Byte\n   (Bit\
    \ 7 is the most significant and Bit 0 is the Least significant bit\n   of the\
    \ octet):\n      bit   7   6   5   4   3   2   1   0\n          +---+---+---+---+---+---+---+---+\n\
    \          |FCI|FCA| reserved  |    FCO    |\n          +---+---+---+---+---+---+---+---+\n\
    \      FCI : Flow Control Indicator\n      FCA : Flow Control Ack\n      FCO :\
    \ Flow Control Operator Bits\n            000 - Repeat Window Operator\n     \
    \       001 - Increment Window Operator\n            010 - Decrement Window Operator\n\
    \            011 - Reset Window Operator\n            100 - Halve Window Operator\n\
    \            101 - Reserved\n            110 - Reserved\n            111 - Reserved\n\
    \   A frame with the FCI bit set is referred to as a Flow Control\n   Indication\
    \ (FCIND).  An FCIND is used to manage the flow in the\n   opposite direction\
    \ of the frame which bears it.\n   A frame with the FCA bit set is referred to\
    \ as a Flow Control\n   Acknowledgment (FCACK).  An FCACK is used to manage the\
    \ flow in the\n   same direction of the frame which bears it.\n   NOTE:  A frame\
    \ may be both a FCIND and an FCACK.\n   A frame bearing an FCIND or FCACK may\
    \ also contain data for the flow\n   in the direction it is traveling.  In such\
    \ a frame, the FCIND or\n   FCACK are said to be piggy-backed.  A non-piggy-backed\
    \ FCIND is\n   called an Independent Flow Control Indication (IFCIND) and a non-\n\
    \   piggy-backed FCACK is called an Independent Flow Control\n   Acknowledgment\
    \ (IFCACK). IFCIND and IFCACK messages are sent in a\n   Independent Flow Control\
    \ SSP message (type 0x21).\n   NOTE:  A frame may be both an IFCIND and an IFCACK.\n\
    \   It is desirable to carry information in control messages so as to\n   reduce\
    \ the need to send a flow control only message.  The diagram\n   below shows the\
    \ messages that may carry valid flow control\n   information:\n ======       \
    \                     ___                           ======\n |    |        ---------\
    \        __/   \\__       ---------        |    |\n |    |      __|  _|_  |__\
    \     /   IP    \\    __|  _|_  |__      |    |\n ======        |   |   |    \
    \  <  Network  >     |   |   |        ======\n"
- title: /______\       ---------       \__     __/      ---------       /______\
  contents:
  - "/______\\       ---------       \\__     __/      ---------       /______\\\n\
    \ Origin       Origin DLSw         \\___/        Target DLSw      Target\n Station\
    \        partner                          partner        Station\n   May have\
    \ valid\n    FCI/FCA/FCO    Data carrying\n         N             N          CANUREACH_cs\n\
    \                                  ----------->\n         Y*            N    \
    \        ICANREACH_cs\n                                    <-----------\n    \
    \     Y             N          REACH_ACK\n                                  ----------->\n\
    \         Y             Y            XIDFRAMEs\n                             \
    \     <------------>\n         Y             Y            DGRMFRAMEs\n       \
    \                           <------------>\n         Y             N         \
    \ CONTACT\n                                  ----------->\n         Y        \
    \     N               CONTACTED\n                                    <-----------\n\
    \         Y             Y             INFOFRAMEs\n                           \
    \       <------------>\n         Y             N          RESTART_DL\n       \
    \                           ----------->\n         Y             N           \
    \    DL_RESTARTED\n                                    <-----------\n        \
    \ Y             N          CONTACT\n                                  ----------->\n\
    \         Y             N               CONTACTED\n                          \
    \          <-----------\n         N             N          HALT_DL\n         \
    \                         ----------->\n         N             N             \
    \  DL_HALTED\n                                    <-----------\n   *Note: ICANREACH_cs\
    \ cannot carry FCA, as there could not be an\n   outstanding FCI.\n"
- title: 8.3  Granting Permission to Send Data
  contents:
  - "8.3  Granting Permission to Send Data\n   A receiver grants a sender permission\
    \ to send units of data by\n   sending FCIND.  Each FCIND is further qualified\
    \ by a flow control\n   operator, which is encoded in the FCO bits of the FCIND\
    \ header. With\n   one exception (the Reset Window operator) all operators may\
    \ be either\n   piggy-backed or carried in a IFCIND.\n   The five flow control\
    \ operators are outlined below:\n"
- title: 8.3.1  Repeat Window Operator
  contents:
  - "8.3.1  Repeat Window Operator\n   This operator is processed as follows:\n  \
    \         (CurrentWindow unchanged)\n           GrantedUnits += CurrentWindow\n"
- title: 8.3.2  Increment Window Operator
  contents:
  - "8.3.2  Increment Window Operator\n   This operator is processed as follows:\n\
    \           CurrentWindow++\n           GrantedUnits += CurrentWindow\n"
- title: 8.3.3  Decrement Window Operator
  contents:
  - "8.3.3  Decrement Window Operator\n   This operator is processed as follows:\n\
    \           CurrentWindow--\n           GrantedUnits += CurrentWindow\n   NOTE:\
    \  This operator may only be sent if CurrentWindow is greater\n   than one.\n"
- title: 8.3.4  Reset Window Operator
  contents:
  - "8.3.4  Reset Window Operator\n   This operator is processed as follows:\n   \
    \        CurrentWindow = 0;\n           GrantedUnits  = 0;\n   NOTE:  This operator\
    \ may only flow on an independent pacing\n   indication (may NOT be piggy-backed).\n\
    \   NOTE:  After sending this operator, the only legal subsequent\n   operator\
    \ is Increment Window.\n"
- title: 8.3.5  Halve Window Operator
  contents:
  - "8.3.5  Halve Window Operator\n   This operator shall be processed as follows:\n\
    \           IF CurrentWindow > 1 THEN\n               CurrentWindow = CurrentWindow\
    \ / 2\n           ENDIF\n           GrantedUnits += CurrentWindow\n   Note:  The\
    \ divide by two operation is an unsigned integer divide\n   (round down) or bit\
    \ shift right operation.\n"
- title: 8.4  Acknowledging a Flow Control Operator
  contents:
  - "8.4  Acknowledging a Flow Control Operator\n   Each sender must acknowledge each\
    \ FCIND with an FCACK which is\n   piggy-backed on the next frame in the opposite\
    \ direction in all cases\n   except the Reset Window Operator.\n   The receiver\
    \ may have no more than one unacknowledged FCIND\n   outstanding at any time with\
    \ one exception:  A Reset Window Operator\n   may be sent while another FCIND\
    \ is pending acknowledgment.\n   NOTE: The FCI and FCO bits of the FCACK are used\
    \ independently by the\n   flow in the opposite direction\n"
- title: 8.4.1  Acknowledging a Reset Window Operator
  contents:
  - "8.4.1  Acknowledging a Reset Window Operator\n   Since this operator revokes\
    \ all previously granted units, the sender\n   must acknowledge this FCIND using\
    \ an IFCACK (Independent Flow Control\n   Acknowledgment).  This is the only case\
    \ where IFCACK is used.\n   Should a sender receive a non-reset FCIND followed\
    \ by a Reset Window\n   FCIND before acknowledging the first, it only acknowledges\
    \ the Reset\n   Window.\n   NOTE: The FCI and FCO bits on these frames are used\
    \ independently by\n   the flow in the opposite direction.\n"
- title: 8.5  Capabilities Exchange Initial Window Size
  contents:
  - "8.5  Capabilities Exchange Initial Window Size\n   When two nodes establish a\
    \ transport connection, they engage in a\n   capabilities exchange (this is a\
    \ requirement).  Refer to the\n   Capabilities Exchange section 7 for further\
    \ details.  The two nodes\n   are required to exchange the following parameter:\n\
    \   InitialWindowSize -  This indicates to the partner what\n                \
    \        the sending flow entity initializes\n                        its CurrentWindow\
    \ value to for each\n                        multiplexed circuit subsequently\n\
    \                        established on that transport\n                     \
    \   connection.  This value must be\n                        non-zero.\n"
- title: 8.6  Circuit Startup
  contents:
  - "8.6  Circuit Startup\n   Process as follows:\n          CurrentWindow = InitialWindowSize\n\
    \          GrantedUnits  = 0\n   NOTE: The InitialWindow Size variable has a scope\
    \ of one per DLSw\n   transport connection, while CurrentWindow and Granted units\
    \ are\n   maintained on a per circuit basis.  At circuit startup, a sender may\n\
    \   not send data units until the receiver grants explicit permission\n   with\
    \ an FCIND message.  This grant may be an independent FCIND\n   message or the\
    \ FCIND may be piggy-backed on any of the message types\n   listed in section\
    \ 8.2.\n"
- title: 8.7  Example Receiving Implementations
  contents:
  - "8.7  Example Receiving Implementations\n   The following two examples illustrate\
    \ receiving implementations of\n   varying degrees of complexity.  These are not\
    \ meant to be complete\n   implementations but rather serve to illustrate the\
    \ protocol.\n   NOTE: The examples are independent of the buffering model ( buffers\n\
    \   may be deterministicly or statistically committed)\n   NOTE: The examples\
    \ assume a process model where each event processes\n   to completion without\
    \ being preempted by another event.\n"
- title: 8.7.1  Fixed Pacing Example
  contents:
  - "8.7.1  Fixed Pacing Example\n   Consider the following variables, in addition\
    \ to InitialWindowSize\n   and CurrentWindow and FCACKOwed:\n          GrantDelayed\
    \     - Boolean\n          GrantedUnits     - Outstanding Units\n   The following\
    \ section describes how various events are processed in\n   this example implementation:\n"
- title: 8.7.1.1  Circuit Startup
  contents:
  - "8.7.1.1  Circuit Startup\n          CurrentWindow    = InitialWindowSize\n  \
    \        FCACKOwed        = FALSE\n          GrantDelayed     = FALSE\n      \
    \    GrantedUnits     = 0\n          Repeat Window Operator\n"
- title: 8.7.1.2  Check Buffers Available
  contents:
  - "8.7.1.2  Check Buffers Available\n   Can my implementation afford to grant CurrentWindow\
    \ just now?\n"
- title: 8.7.1.3  Buffers Become Available
  contents:
  - "8.7.1.3  Buffers Become Available\n          IF Check Buffers Available THEN\n\
    \             Send FCIND( Repeat Window)\n             GrantDelayed = FALSE\n\
    \          ELSE\n             Wait on buffers to become available (LIFO)\n   \
    \       ENDIF\n"
- title: 8.7.1.4  Repeat Window Operator
  contents:
  - "8.7.1.4  Repeat Window Operator\n          IF Check Buffers Available THEN\n\
    \              Send FCIND( Repeat Window)\n          ELSE\n             GrantDelayed\
    \ = TRUE\n             Wait on buffers to become available (FIFO)\n          ENDIF\n"
- title: 8.7.1.5  Send FCIND( operator)
  contents:
  - "8.7.1.5  Send FCIND( operator)\n          GrantedUnits += CurrentWindow\n   \
    \       FCACKOwed     = TRUE\n          Encode and Transmit FCIND piggybacked\
    \ or as IFCIND\n"
- title: 8.7.1.6  A Frame Arrives from Sender
  contents:
  - "8.7.1.6  A Frame Arrives from Sender\n          GrantedUnits--;\n          IF\
    \ frame is FCACK THEN\n             IF FCACKOwed THEN\n                FCACKOwed\
    \ = FALSE\n             ELSE\n                Protocol Violation\n           \
    \  ENDIF\n          ENDIF\n          IF NOT GrantDelayed THEN\n             IF\
    \ GrantedUnits <= CurrentWindow THEN\n                 IF FCACKOwed THEN\n   \
    \                Protocol Violation\n                 ELSE\n                 \
    \  Repeat Window Operator\n                 ENDIF\n             ENDIF\n      \
    \    ENDIF\n"
- title: 8.7.2  Adaptive Pacing Example
  contents:
  - "8.7.2  Adaptive Pacing Example\n   The following example illustrates a receiving\
    \ implementation that\n   adjusts the window size and granted units based on buffer\n\
    \   availability and transport utilization.\n   NOTE: This example ignores other\
    \ factors which might compel the\n   receiving implementation to adjust the window\
    \ size (i.e., Outbound\n   queue length, traffic priority, ...)\n   Consider the\
    \ following variables, in addition to InitialWindowSize,\n   CurrentWindow and\
    \ FCACKOwed:\n          GrantDelayed     - Boolean\n          GrantedUnits   \
    \  - Outstanding Units\n"
- title: 8.7.2.1  Circuit Startup
  contents:
  - "8.7.2.1  Circuit Startup\n          CurrentWindow    = InitialWindowSize\n  \
    \        FCACK            = FALSE\n          GrantDelayed     = FALSE\n      \
    \    GrantedUnits     = 0\n          Repeat Window Operator\n"
- title: 8.7.2.2  Check Buffers Available ( X)
  contents:
  - "8.7.2.2  Check Buffers Available ( X)\n           Can my implementation afford\
    \ to grant X units just now?\n"
- title: 8.7.2.3  Buffers Become Available
  contents:
  - "8.7.2.3  Buffers Become Available\n          IF Check Buffers Available THEN\n\
    \             CurrentWindow--;\n             Send FCIND( Decrement Window)\n \
    \            GrantDelayed = FALSE\n          ELSE\n             Wait on buffers\
    \ to become available (LIFO)\n          ENDIF\n"
- title: 8.7.2.4  Repeat Window Operator
  contents:
  - "8.7.2.4  Repeat Window Operator\n          IF Check Buffers Available (CurrentWindow)\
    \ THEN\n              Send FCIND( Repeat Window)\n          ELSE\n           \
    \  GrantDelayed = TRUE\n             Wait on buffers to become available (FIFO)\n\
    \          ENDIF\n"
- title: 8.7.2.5  Increment Window Operator
  contents:
  - "8.7.2.5  Increment Window Operator\n          IF Check Buffers Available ( CurrentWindow\
    \ + 1) THEN\n              CurrentWindow++\n              Send FCIND( Increment\
    \ Window)\n          ELSE\n              Repeat Window Operator\n          ENDIF\n"
- title: 8.7.2.6  Send FCIND( operator)
  contents:
  - "8.7.2.6  Send FCIND( operator)\n          FCACKOwed     = TRUE\n          GrantedUnits\
    \ += CurrentWindow\n          Encode and Transmit FCIND piggybacked or as IFCIND\n"
- title: 8.7.2.7  An FCACK Arrives from Sender
  contents:
  - "8.7.2.7  An FCACK Arrives from Sender\n          GrantedUnits--;\n          IF\
    \ NOT FCACKOwed THEN\n             Protocol Violation\n          ENDIF\n     \
    \     FCACKOwed = FALSE;\n          IF NOT GrantDelayed THEN\n             IF\
    \ GrantedUnits < CurrentWindow THEN\n                 Increment Window Operator\n\
    \             ELSE IF GrantedUnits == CurrentWindow THEN\n                 Repeat\
    \ Window Operator\n             END\n          ENDIF\n"
- title: 8.7.2.8  A Non-FCACK Frame Arrives from Sender
  contents:
  - "8.7.2.8  A Non-FCACK Frame Arrives from Sender\n          GrantedUnits--;\n \
    \         IF NOT GrantDelayed THEN\n             IF FCACKOwed THEN\n         \
    \       IF GrantedUnits < CurrentWindow THEN\n                   Protocol Violation\n\
    \                END\n             ELSE\n                IF GrantedUnits <= CurrentWindow\
    \ THEN\n                   Repeat Window Operator\n                ENDIF\n   \
    \          ENDIF\n          ENDIF\n"
- title: 8.8  Adaptive Pacing Example Flow Diagrams
  contents:
  - '8.8  Adaptive Pacing Example Flow Diagrams

    '
- title: 8.8.1  Example Flows from the Above Implementation
  contents:
  - "8.8.1  Example Flows from the Above Implementation\n   The following diagram\
    \ illustrates the use of adaptive pacing (use of\n   Halve Window, and Reset operation\
    \ are shown in subsequent diagrams).\n   -----SENDER-----                    \
    \ ----RECEIVER----\n   Granted   Window                     Window   Granted\n\
    \     0         2   circuit established    2         0\n     2         2   <--------\
    \ FCIND(Rpt)   2         2\n     1         2   FCACK-------------->   2      \
    \   1\n     4         3   <-------- FCIND(Inc)   3         4\n     3         3\
    \   FCACK-------------->   3         3\n                          +- FCIND(Rpt)\
    \   3         6\n     2         3   DATA---|----------->   3         5\n     1\
    \         3   DATA---|----------->   3         4\n     4         3   <------+\n\
    \     3         3   FCACK-------------->   3         3\n     6         3   <--------\
    \ FCIND(Rpt)   3         6\n     5         3   FCACK-------------->   3      \
    \   5\n     4         3   DATA--------------->   3         4\n     3         3\
    \   DATA--------------->   3         3\n                          +- FCIND(Rpt)\
    \   3         6\n     2         3   DATA---|----------->   3         5\n     1\
    \         3   DATA---|----------->   3         4\n     0         3   DATA---|----------->\
    \   3         3\n     3         3   <------+\n     2         3   FCACK-------------->\
    \   3         2\n     6         4   <-------- FCIND(Inc)   4         6\n     5\
    \         4   FCACK-------------->   4         5\n     4         4   DATA--------------->\
    \   4         4\n                                        Waiting on Buffer\n \
    \                         +- FCIND(Dec)   3         7\n     3         4   DATA---|----------->\
    \   3         6\n     2         4   DATA---|----------->   3         5\n     1\
    \         4   DATA---|----------->   3         4\n     0         4   DATA---|----------->\
    \   3         3\n     3         3   <------+\n     2         3   FCACK-------------->\
    \   3         2\n                                        Waiting on Buffer\n \
    \                         +- FCIND(Dec)   2         4\n     1         3   DATA---|----------->\
    \   2         3\n     0         3   DATA---|----------->   2         2\n     2\
    \         2   <------+\n     1         2   FCACK-------------->   2         1\n\
    \     4         3   <-------- FCIND(Inc)   3         4\n     3         3   FCACK-------------->\
    \   3         3\n     6         3   <-------- FCIND(Rpt)   3         6\n     5\
    \         3   FCACK-------------->   3         5\n     4         3   DATA--------------->\
    \   3         4\n     3         3   DATA--------------->   3         3\n     6\
    \         3   <-------- FCIND(Rpt)   3         6\n"
- title: 8.8.2  Example Halve Window Flow
  contents:
  - "8.8.2  Example Halve Window Flow\n   The following flow illustrates the use of\
    \ the Halve Window Operator:\n      -----SENDER-----                     ----RECEIVER----\n\
    \      Granted   Window                     Window   Granted\n        0      \
    \   2   circuit established    2         0\n        2         2   <-------- FCIND(Rpt)\
    \   2         2\n        1         2   FCACK-------------->   2         1\n  \
    \      4         3   <-------- FCIND(Inc)   3         4\n        3         3 \
    \  FCACK-------------->   3         3\n                                      \
    \       Resource Shortage\n        2         3   DATA--------------->   1    \
    \     2\n        1         3   DATA--------------->   1         1\n        0 \
    \        3   DATA--------------->   1         0\n        1         1   <--------\
    \ FCIND(Hlv)   1         1\n        0         1   FCACK-------------->   1   \
    \      0\n   NOTE: The Halve Window Operator could have been sent before the\n\
    \   granted units fell to zero.  The implementer may make a choice based\n   on\
    \ the severity of the condition.\n"
- title: 8.8.3  Example Reset Window Flows
  contents:
  - "8.8.3  Example Reset Window Flows\n   The following flow diagram illustrates\
    \ the ResetWindow operation if\n   the receiver has no FCIND outstanding.\n  \
    \ -----SENDER-----                     ----RECEIVER----\n   Granted   Window \
    \                    Window   Granted\n     0         2   circuit established\
    \    2         0\n     2         2   <-------- FCIND(Rpt)   2         2\n    \
    \ 1         2   FCACK-------------->   2         1\n     4         3   <--------\
    \ FCIND(Inc)   3         4\n     3         3   FCACK-------------->   3      \
    \   3\n                          +- FCIND(Rpt)   3         6\n     2         3\
    \   DATA---|----------->   3         5\n     1         3   DATA---|----------->\
    \   3         4\n     4         3   <------+\n     3         3   FCACK-------------->\
    \   3         3\n     6         3   <-------- FCIND(Rpt)   3         6\n     5\
    \         3   FCACK-------------->   3         5\n                           \
    \               Resource shortage!\n     0         0   <-------- FCIND(Rst)  \
    \ 0         5 (note still\n   committed)\n     0         0   IFCACK------------->\
    \   0         0\n                                          Condition eases\n \
    \    1         1   <-------- FCIND(Inc)   1         1\n     0         1   FCACK-------------->\
    \   1         0\n     2         2   <-------- FCIND(Inc)   2         2\n     1\
    \         2   FCACK-------------->   3         4\n   The next two flows  illustrate\
    \ the Reset Window operation if the\n   receiver has an outstanding FCIND.\n \
    \  -----SENDER-----                     ----RECEIVER----\n   Granted   Window\
    \                     Window   Granted\n     0         2   circuit established\
    \    2         0\n     2         2   <-------- FCIND(Rpt)   2         2\n    \
    \ 1         2   FCACK-------------->   2         1\n     4         3   <--------\
    \ FCIND(Inc)   3         4\n     3         3   FCACK-------------->   3      \
    \   3\n                          +- FCIND(Rpt)   3         6\n     2         3\
    \   DATA---|----------->   3         5\n                          |          \
    \     Resource shortage!\n                          |+-FCIND(Rst)   0        \
    \ 5\n     1         3   DATA---||---------->   0         4\n     4         3 \
    \  <------+|\n     3         3   FCACK---+---------->   0         3 (Not IFCACK!)\n\
    \     2         3   DATA----|---------->   0         2\n     0         0   <-------+\n\
    \     0         0   IFCACK------------->   0         0\n                     \
    \                     Condition eases\n     1         1   <-------- FCIND(Inc)\
    \   1         1\n     0         1   FCACK-------------->   1         0\n     2\
    \         2   <-------- FCIND(Inc)   2         2\n     1         2   FCACK-------------->\
    \   3         4\n   -----SENDER-----                     ----RECEIVER----\n  \
    \ Granted   Window                     Window   Granted\n     0         2   circuit\
    \ established    2         0\n     2         2   <-------- FCIND(Rpt)   2    \
    \     2\n     1         2   FCACK-------------->   2         1\n     4       \
    \  3   <-------- FCIND(Inc)   3         4\n     3         3   FCACK-------------->\
    \   3         3\n                          +- FCIND(Rpt)   3         6\n     2\
    \         3   DATA---|----------->   3         5\n                          |\
    \               Resource shortage!\n                          |+-FCIND(Rst)  \
    \ 0         5\n     1         3   DATA---||---------->   0         4\n     4 \
    \        3   <------+|\n     0         0   <-------+\n     0         0   IFCACK------------->\
    \   0         0\n                                          Condition eases\n \
    \    1         1   <-------- FCIND(Inc)   1         1\n     0         1   FCACK-------------->\
    \   1         0\n     2         2   <-------- FCIND(Inc)   2         2\n     1\
    \         2   FCACK-------------->   3         4\n"
- title: 8.9  Other Considerations
  contents:
  - '8.9  Other Considerations

    '
- title: 8.9.1  Protocol Violations
  contents:
  - "8.9.1  Protocol Violations\n   The following events are considered protocol violations:\n\
    \   1. Sender exceeds granted units or does not acknowledge FCIND on\n      first\
    \ frame after its receipt (the receiver can not discern the\n      difference\
    \ between the two).\n   2. Receiver does not follow a Reset Window Operator with\
    \ an Increment\n      Window Operator.\n   3. Receiver has two unacknowledged\
    \ FCINDs ( other than Reset Window)\n      outstanding.\n   4. Receiver sends\
    \ Decrement Window Operator with a window size of one.\n   5. Receiver attempts\
    \ to increment the window size beyond 0xFFFF.\n   Actions taken in response to\
    \ protocol violations are left to the\n   implementation of the node which discovers\
    \ the violation.  If an\n   implementation chooses to take down the circuit on\
    \ which the\n   violation occurred, HALT_DL is the appropriate action.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Original RFC 1434 Authors:\n      Roy C. Dixon, IBM\n   \
    \   David M. Kushi, IBM\n   Chair of APPN Implementers Workshop Data Link Switching\
    \ Related\n   Interest Group:\n      Louise Herndon Wells, Internetworking Technology\
    \ Institute\n   Working Group Chairs (and significant contributors to this document):\n\
    \      Connect/Disconnect (State Machines): Steve Klein, IBM\n      Capabilities\
    \ Exchange: Wayne Clark, Cisco Systems\n      Flow Control (Adaptive Pacing):\
    \ Shannon Nix, Metaplex\n      Priority/Class of Service: Gene Cox, IBM\n   Other\
    \ significant contributors:\n      Peter Gayek, IBM\n      Paul Brittain, Data\
    \ Connection Limited\n"
- title: References
  contents:
  - "References\n   1) ISO 8802-2/IEEE Std 802.2 International Standard, Information\n\
    \      Processing Systems, Local Area Networks, Part 2: Logical Link\n      Control,\
    \ December 31, 1989.\n   2) IBM LAN Technical Reference IEEE 802.2 and NETBIOS\
    \ Application\n      Program Interfaces SC30-3587-00, December 1993.\n   3) ISO/IEC\
    \ DIS 10038 DAM 2, MAC Bridging, Source Routing Supplement,\n      December 1991.\n\
    \   4) ISO 8802-2/IEEE Std 802.1D International Standard, Information\n      Processing\
    \ Systems, Local Area Networks, Part 2: MAC layer\n      Bridging.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: Chair's Address
  contents:
  - "Chair's Address\n   Louise Wells\n   Internetwork Technology Institute\n   2021\
    \ Stratford Dr.\n   Milpitas, CA  95035\n   EMail: lhwells@cup.portal.com\n"
- title: Editor's Address
  contents:
  - "Editor's Address\n   Alan K. Bartky\n   Manager of Technology\n   Sync Research\
    \ Inc.\n   7 Studebaker\n   Irvine, CA 91728-2013\n   Phone: 1-714-588-2070\n\
    \   EMail: alan@sync.com\n   Note: Any questions or comments relative to the contents\
    \ of this RFC\n   should be sent to the following Internet address:\n   aiw-dlsw@networking.raleigh.ibm.com.\n\
    \   This address will be used to coordinate the handling of responses.\n   NOTE\
    \ 1:  This is a widely subscribed mailing list and messages sent to\n        \
    \    this address will be sent to all members of the DLSw mailing\n          \
    \  list.  For specific questions relating to subscribing to the\n            AIW\
    \ and any of it's working groups send email to:\n            appn@vnet.ibm.com\n\
    \            Information regarding all of the AIW working groups and the\n   \
    \         work they are producing can be obtained by copying, via\n          \
    \  anonymous ftp, the file aiwinfo.psbin or aiwinfo.txt from the\n           \
    \ Internet host networking.raleigh.ibm.com, located in\n            directory\
    \ aiw.\n   NOTE 2: These mailing lists and addresses are subject to change.\n"
