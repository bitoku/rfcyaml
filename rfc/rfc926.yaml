- title: __initial_text__
  contents:
  - "    Protocol for Providing the Connectionless-Mode Network Services\n       \
    \                  (Informally - ISO IP)\n                              ISO DIS\
    \ 8473\n"
- title: 'Status of this Memo:'
  contents:
  - "Status of this Memo:\n This document is distributed as an RFC for information\
    \ only.  It does\n not specify a standard for the ARPA-Internet.  Distribution\
    \ of this\n memo is unlimited.\n"
- title: 'Note:'
  contents:
  - "Note:\n This document has been prepared by retyping the text of ISO DIS 8473\
    \ of\n May 1984, which is currently undergoing voting within ISO as a Draft\n\
    \ International Standard (DIS).  Although this RFC has been reviewed\n after typing,\
    \ and is believed to be substantially correct, it is\n possible that typographic\
    \ errors not present in the ISO document have\n been overlooked.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \                         TABLE OF CONTENTS\n 1   SCOPE AND FIELD OF APPLICATION........................\
    \ 2\n 2   REFERENCES............................................ 3\n 3   DEFINITIONS...........................................\
    \ 4\n 3.1   Reference Model Definitions......................... 4\n 3.2   Service\
    \ Conventions Definitions..................... 4\n 3.3   Network Layer Architecture\
    \ Definitions.............. 4\n 3.4   Network Layer Addressing Definitions................\
    \ 5\n 3.5   Additional Definitions.............................. 5\n 4   SYMBOLS\
    \ AND ABBREVIATIONS............................. 7\n 4.1   Data Units..........................................\
    \ 7\n 4.2   Protocol Data Units................................. 7\n 4.3   Protocol\
    \ Data Unit Fields........................... 7\n 4.4   Parameters..........................................\
    \ 8\n 4.5   Miscellaneous....................................... 8\n 5   OVERVIEW\
    \ OF THE PROTOCOL.............................. 9\n 5.1   Internal Organization\
    \ of the Network Layer.......... 9\n 5.2   Subsets of the Protocol.............................\
    \ 9\n 5.3   Addressing......................................... 10\n 5.4   Service\
    \ Provided by the Network Layer.............. 10\n 5.5   Service Assumed from\
    \ the Subnetwork Service\n    Provider..............................................\
    \ 11\n 5.5.1   Subnetwork Addresses............................. 12\n 5.5.2  \
    \ Subnetwork Quality of Service.................... 12\n 5.5.3   Subnetwork User\
    \ Data............................. 13\n 5.5.4   Subnetwork Dependent Convergence\
    \ Functions....... 13\n 5.6   Service Assumed from Local Evironment..............\
    \ 14\n 6   PROTOCOL FUNCTIONS................................... 16\n 6.1   PDU\
    \ Composition Function........................... 16\n 6.2   PDU Decomposition\
    \ Function......................... 17\n 6.3   Header Format Analysis Function....................\
    \ 17\n 6.4   PDU Lifetime Control Function...................... 18\n 6.5   Route\
    \ PDU Function................................. 18\n 6.6   Forward PDU Function...............................\
    \ 19\n 6.7   Segmentation Function.............................. 19\n 6.8   Reassembly\
    \ Function................................ 20\n 6.9   Discard PDU Function...............................\
    \ 21\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 6.10\
    \   Error Reporting Function.......................... 22\n 6.10.1   Overview........................................\
    \ 22\n 6.10.2   Requirements.................................... 23\n 6.10.3 \
    \  Processing of Error Reports..................... 24\n 6.11   PDU Header Error\
    \ Detection........................ 25\n 6.12   Padding Function..................................\
    \ 26\n 6.13   Security.......................................... 26\n 6.14   Source\
    \ Routing Function........................... 27\n 6.15   Record Route Function.............................\
    \ 28\n 6.16   Quality of Service Maintenance Function........... 29\n 6.17   Classification\
    \ of Functions....................... 29\n 7   STRUCTURE AND ENCODING OF PDUS.......................\
    \ 32\n 7.1   Structure.......................................... 32\n 7.2   Fixed\
    \ Part......................................... 34\n 7.2.1   General..........................................\
    \ 34\n 7.2.2   Network Layer Protocol Identifier................ 34\n 7.2.3  \
    \ Length Indicator................................. 35\n 7.2.4   Version/Protocol\
    \ Identifier Extension............ 35\n 7.2.5   PDU Lifetime.....................................\
    \ 35\n 7.2.6   Flags............................................ 36\n 7.2.6.1\
    \   Segmentation Permitted and More Segments Flags. 36\n 7.2.6.2   Error Report\
    \ Flag.............................. 37\n 7.2.7   Type Code........................................\
    \ 37\n 7.2.8   PDU Segment Length............................... 37\n 7.2.9  \
    \ PDUChecksum...................................... 38\n 7.3   Address Part.......................................\
    \ 38\n 7.3.1   General.......................................... 38\n 7.3.1.1\
    \     Destination and Source Address Information... 39\n 7.4   Segmentation Part..................................\
    \ 40\n 7.4.1   Data Unit Identifier............................. 41\n 7.4.2  \
    \ Segment Offset................................... 41\n 7.4.3   PDU Total Length.................................\
    \ 41\n 7.5   Options Part....................................... 41\n 7.5.1  \
    \ General.......................................... 41\n 7.5.2   Padding..........................................\
    \ 43\n 7.5.3   Security......................................... 43\n 7.5.4  \
    \ Source Routing................................... 44\n 7.5.5   Recording of\
    \ Route............................... 45\n 7.5.6   Quality of Service Maintenance...................\
    \ 46\n 7.6   Priority........................................... 47\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 7.7\
    \   Data Part.......................................... 47\n 7.8   Data (DT) PDU......................................\
    \ 49\n 7.8.1   Structure........................................ 49\n 7.8.1.1\
    \   Fixed Part..................................... 50\n 7.8.1.2   Addresses......................................\
    \ 50\n 7.8.1.3   Segmentation................................... 50\n 7.8.1.4\
    \   Options........................................ 50\n 7.8.1.5   Data...........................................\
    \ 50\n 7.9   Inactive Network Layer Protocol.................... 51\n 7.9.1  \
    \ Network Layer Protocol Id........................ 51\n 7.9.2   Data Field.......................................\
    \ 51\n 7.10   Error Report PDU (ER)............................. 52\n 7.10.1 \
    \  Structure....................................... 52\n 7.10.1.1   Fixed Part....................................\
    \ 53\n 7.10.1.2   Addresses..................................... 53\n 7.10.1.3\
    \   Segmentation.................................. 53\n 7.10.1.4   Options.......................................\
    \ 54\n 7.10.1.5   Reason for Discard............................ 54\n 7.10.1.6\
    \   Error Report Data Field....................... 55\n 8   FORMAL DESCRIPTION...................................\
    \ 56\n 8.1   Values of the State Variable....................... 57\n 8.2   Atomic\
    \ Events...................................... 57\n 8.2.1   N.UNITDATA_request\
    \ and N.UNITDATA_indication..... 57\n 8.2.2   SN.UNITDATA_request and SN.UNITDATA_indication...\
    \ 58\n 8.2.3   TIMER Atomic Events.............................. 59\n 8.3   Operation\
    \ of the Finite State Automation........... 59\n 8.3.1   Type and Constant Definitions....................\
    \ 61\n 8.3.2   Interface Definitions............................ 65\n 8.3.3  \
    \ Formal Machine Definition........................ 67\n 9   CONFORMANCE..........................................\
    \ 84\n 9.1   Provision of Functions for Conformance............. 84\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: INTRODUCTION
  contents:
  - "INTRODUCTION\n This Protocol is one of a set of International Standards produced\
    \ to\n facilitate the interconnection of open systems. The set of standards\n\
    \ covers the services and protocols required to achieve such\n interconnection.\n\
    \ This Protocol Standard is positioned with respect to other related\n standards\
    \ by the layers defined in the Reference Model for Open Systems\n Interconnection\
    \ (ISO 7498). In particular, it is a protocol of the\n Network Layer. The Protocol\
    \ herein described is a Subnetwork\n Independent Convergence Protocol combined\
    \ with relay and routing\n functions as described in the Internal Organization\
    \ of the Network\n Layer (ISO iiii). This Protocol provides the connectionless-mode\n\
    \ Network Service as defined in ISO 8348/DAD1, Addendum to the Network\n Service\
    \ Definition Covering Connectionless-mode Transmission, between\n Network Service\
    \ users and/or Network Layer relay systems.\n The interrelationship of these standards\
    \ is illustrated in Figure 0-1\n below:\n      ______________OSI Network Service\
    \ Definition______________  \n                    |                          \
    \   ^               \n                                                  |    \
    \           \n                    |                             |            \
    \   \n         Protocol     Reference to aims __________|               \n   \
    \                 |                                             \n      Specification\
    \ | Reference to assumptions ___                \n                           \
    \                       |               \n                    |              \
    \               |               \n                                           \
    \       |               \n                    |                             |\
    \               \n                                                  |        \
    \       \n                    |                             v               \n\
    \      ______________Subnetwork Service Definition(s) ___________  \n        \
    \      Figure 0-1.  Interrelationship of Standards\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: 1  SCOPE AND FIELD OF APPLICATION
  contents:
  - "1  SCOPE AND FIELD OF APPLICATION\n This International Standard specifies a protocol\
    \ which is used to\n provide the Connectionless-mode Network Service as described\
    \ in ISO\n 8348/DAD1, Addendum to the Network Service Definition Covering\n Connectionless-mode\
    \ Transmission. The protocol herein described relies\n upon the provision of a\
    \ connectionless-mode subnetwork service.\n This Standard specifies:\n  a)  procedures\
    \ for the connectionless transmission of data and control\n      information from\
    \ one network-entity to a peer network-entity;\n  b)  the encoding of the protocol\
    \ data units used for the transmission\n      of data and control information,\
    \ comprising a variable-length\n      protocol header format;\n  c)  procedures\
    \ for the correct interpretation of protocol control\n      information; and\n\
    \  d)  the functional requirements for implementations claiming\n      conformance\
    \ to the Standard.\n The procedures are defined in terms of:\n  a)  the interactions\
    \ among peer network-entities through the exchange\n      of protocol data units;\n\
    \  b)  the interactions between a network-entity and a Network Service\n     \
    \ user through the exchange of Network Service primitives; and\n  c)  the interactions\
    \ between a network-entity and a subnetwork service\n      provider through the\
    \ exchange of subnetwork service primitives.\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: 2  REFERENCES
  contents:
  - "2  REFERENCES\n ISO 7498       Information Processing Systems - Open Systems\n\
    \                Interconnection - Basic Reference Model\n DP 8524        Information\
    \ Processing Systems - Open Systems\n                Interconnection - Addendum\
    \ to ISO 7498 Covering\n                Connectionless-Mode Transmission\n DIS\
    \ 8348       Information Processing Systems - Data Communications -\n        \
    \        Network Service Definition\n ISO 8348/DAD1  Information Processing Systems\
    \ - Data Communications -\n                Addendum to the Network Service Definition\
    \ Covering\n                Connectionless-Mode Transmission\n ISO 8348/DAD2 \
    \ Information Processing Systems - Data Communications -\n                Addendum\
    \ to the Network Service Definition Covering\n                Network Layer Addressing\n\
    \ DP iiii        Information Processing Systems - Data Communications -\n    \
    \            Internal Organization of the Network Layer\n DP 8509        Information\
    \ Processing Systems - Open Systems\n                Interconnection - Service\
    \ Conventions\n ISO TC97/SC16  A Formal Description Technique based on an N1825\n\
    \                Extended State Transition Model\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: SECTION ONE.  GENERAL
  contents:
  - 'SECTION ONE.  GENERAL

    '
- title: 3  DEFINITIONS
  contents:
  - "3  DEFINITIONS\n 3.1  Reference Model Definitions\n  This document makes use\
    \ of the following concepts defined in ISO 7498:\n   a) Network layer\n   b) Network\
    \ service\n   c) Network service access point\n   d) network service access point\
    \ address\n   e) Network entity\n   f) Routing\n   f) Service\n   h) Network protocol\n\
    \   i) Network relay\n   j) Network protocol data unit\n   k) End system\n 3.2\
    \  Service Conventions Definitions\n  This document makes use of the following\
    \ concepts from the OSI Service\n  Conventions (ISO 8509):\n   l) Service user\n\
    \   m) Service provider\n 3.3  Network Layer Architecture Definitions\n  This\
    \ document makes use of the following concepts from the Internal\n  Organization\
    \ of the Network Layer (ISO iiii):\n   n) Subnetwork\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ o) Relay system\n   p) Intermediate system\n   q) Subnetwork service\n 3.4 \
    \ Network Layer Addressing Definitions\n  This document makes use of the following\
    \ concepts from DIS 8348/DAD2,\n  Addendum to the Network Service Definition Covering\
    \ Network layer\n  addressing:\n   r) Network entity title\n   s) Network protocol\
    \ address information\n   t) Subnetwork address\n   u) Domain\n 3.5  Additional\
    \ Definitions\n  For the purposes of this document, the following definitions\
    \ apply:\n   a) automaton    -  a machine designed to follow automatically a\n\
    \                      predetermined sequence of operations or to respond\n  \
    \                    to encoded instructions.\n   b) local matter -  a decision\
    \ made by a system concerning its\n                      behavior in the Network\
    \ Layer that is not subject\n                      to the requirements of this\
    \ Protocol.\n   c) segment      -  part of the user data provided in the N_UNITDATA\n\
    \                      request and delivered in the N_UNITDATA\n             \
    \         indication.\n   d) initial PDU  -  a protocol data unit carrying the\
    \ whole of the\n                      user data from an N_UNITDATA request.\n\
    \   e) derived PDU  -  a  protocol data unit whose fields are identical\n    \
    \                  to those of an initial PDU, except that it carries\n      \
    \                only a segment of the user data from an N_UNITDATA\n        \
    \              request.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ f) segmentation -  the act of generating two or more derived PDUS\n        \
    \              from an initial or derived PDU.  The derived PDUs\n           \
    \           together carry the entire user data of the initial\n             \
    \         or derived PDU from which they were generated.\n                   \
    \   [Note: it is possible that such an initial PDU\n                      will\
    \ never actually be generated for a particular\n                      N_UNITDATA\
    \ request, owing to the immediate\n                      application of segmentation.]\n\
    \   g) reassembly   -  the act of regenerating an initial PDU (in order\n    \
    \                  to issue an N_UNITDATA indication) from two or\n          \
    \            more derived PDUs produced by segmentation.\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: 4  SYMBOLS AND ABBREVIATIONS
  contents:
  - "4  SYMBOLS AND ABBREVIATIONS\n 4.1  Data Units\n  PDU          Protocol Data\
    \ Unit\n  NSDU         Network Service Data Unit\n  SNSDU        Subnetwork Service\
    \ Data Unit\n 4.2  Protocol Data Units\n  DT PDU       Data Protocol Data Unit\n\
    \  ER PDU       Error Report Protocol Data Unit\n 4.3  Protocol Data Unit Fields\n\
    \  NPID         Network Layer Protocol Identifier\n  LI           Length Indicator\n\
    \  V/P          Version/protocol Identifier Extension\n  LT           Lifetime\n\
    \  SP           Segmentation Permitted Flag\n  MS           More Segments Flag\n\
    \  E/R          Error Report Flag\n  TP           Type\n  SL           Segment\
    \ Length\n  CS           Checksum\n  DAL          Destination Address Length\n\
    \  DA           Destination Address\n  SAL          Source Address Length\n  SA\
    \           Source Address\n  DUID         Data Unit Identifier\n  SO        \
    \   Segment Offset\n  TL           Total Length\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 4.4\
    \  Parameters\n  DA           Destination Address\n  SA           Source Address\n\
    \  QOS          Quality of Service\n 4.5  Miscellaneous\n  SNICP        Subnetwork\
    \ Independent Convergence Protocol\n  SNDCP        Subnetwork Dependent Convergence\
    \ Protocol\n  SNAcP        Subnetwork Access Protocol\n  SN           Subnetwork\n\
    \  P            Protocol\n  NSAP         Network Service Access Point\n  SNSAP\
    \        Subnetwork Service Access Point\n  NPAI         Network Protocol Address\
    \ Information\n  NS           Network Service\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: 5  OVERVIEW OF THE PROTOCOL
  contents:
  - "5  OVERVIEW OF THE PROTOCOL\n 5.1  Internal Organization of the Network Layer\n\
    \  The architecture of the Network Layer is described in a separate\n  document,\
    \ Internal Organization of the Network Layer (ISO iiii), in\n  which an OSI Network\
    \ Layer structure is defined, and a structure to\n  classify protocols as an aid\
    \ to the progression toward that structure\n  is presented. This protocol is designed\
    \ to be used in the context of\n  the internetworking protocol approach defined\
    \ in that document,\n  between Network Service users and/or Network Layer relay\
    \ systems. As\n  described in the Internal Organization of the Network Layer,\
    \ the\n  protocol herein described is a Subnetwork Independent Convergence\n \
    \ Protocol combined with relay and routing functions designed to allow\n  the\
    \ incorporation of existing network standards within the OSI\n  framework.\n \
    \ A Subnetwork Independent Convergence Protocol is one which can be\n  defined\
    \ on a subnetwork independent basis and which is necessary to\n  support the uniform\
    \ appearance of the OSI Connectionless-mode Network\n  Service between Network\
    \ Service users and/or Network Layer relay\n  systems over a set of interconnected\
    \ homogeneous or heterogeneous\n  subnetworks. This protocol is defined in just\
    \ such a subnetwork\n  independent way so as to minimize variability where subnetwork\n\
    \  dependent and/or subnetwork access protocols do not provide the OSI\n  Network\
    \ Service.\n  The subnetwork service required from the lower sublayers by the\n\
    \  protocol described herein is identified in Section 5.5.\n 5.2  Subsets of the\
    \ Protocol\n  Two proper subsets of the full protocol are also defined which permit\n\
    \  the use of known subnetwork characteristics, and are therefore not\n  subnetwork\
    \ independent.\n  One protocol subset is for use where it is known that the source\
    \ and\n  destination end-systems are connected by a single subnetwork. This is\n\
    \  known as the \"Inactive Network Layer Protocol\" subset. A second subset\n\
    \  permits simplification of the header where it is known that the source\n  and\
    \ destination end-systems are connected by subnetworks whose\n  subnetwork service\
    \ data unit (SNSDU) sizes are greater than or equal\n  to a known bound large\
    \ enough for segmentation not to be required.\n  This subset, selected by setting\
    \ the \"segmentation permitted\" flag to\n  zero, is known as the \"non-segmenting\"\
    \ protocol subset.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 5.3\
    \  Addressing\n  The Source Address and Destination Address parameters referred\
    \ to in\n  Section 7.3 of this International Standard are OSI Network Service\n\
    \  Access Point Addresses. The syntax and semantics of an OSI Network\n  Service\
    \ Access Point Address, the syntax and encoding of the Network\n  Protocol Address\
    \ Information employed by this Protocol, and the\n  relationship between the NSAP\
    \ and the NPAI is described in a separate\n  document, ISO 8348/DAD2, Addendum\
    \ to the Network Service Definition\n  covering Network Layer Addressing.\n  The\
    \ syntax and semantics of the titles and addresses used for relaying\n  and routing\
    \ are also described in ISO 8348/DAD2.\n 5.4  Service Provided by the Network\
    \ Layer\n  The service provided by the protocol herein described is a\n  connectionless-mode\
    \ Network Service. The connectionless-mode Network\n  Service is described in\
    \ document ISO 8348/DAD1, Addendum to the\n  Network Service Definition Covering\
    \ Connectionless-mode Transmission.\n  The Network Service primitives provided\
    \ are summarized below:\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \               Primitives                Parameters          \n      +--------------------------------------------------------+\
    \ \n      |                           |                            | \n      |\
    \ N_UNITDATA Request        | NS_Destination_Address,    | \n      |         \
    \   Indication     | NS_Source_Address,         | \n      |                  \
    \         | NS_Quality_of_Service,     | \n      |                           |\
    \ NS_Userdata                | \n      +--------------------------------------------------------+\
    \ \n                 Table 5-1.  Network Service Primitives\n  The Addendum to\
    \ the Network Service Definition Covering\n  Connectionless-mode Transmission\
    \ (ISO 8348/DAD1) states that the\n  maximum size of a connectionless-mode Network-service-data-unit\
    \ is\n  limited to 64512 octets.\n 5.5  Service Assumed from the Subnetwork Service\
    \ provider\n  The subnetwork service required to support this protocol is defined\
    \ as\n  comprising the following primitives:\n                Primitives     \
    \             Parameters           \n      +--------------------------------------------------------+\
    \ \n      |                           |                            | \n      |\
    \ SN_UNITDATA Request       | SN_Destination_Address,    | \n      |         \
    \    Indication    | SN_Source_Address,         | \n      |                  \
    \         | SN_Quality_of_Service,     | \n      |                           |\
    \ SN_Userdata                | \n      +--------------------------------------------------------+\
    \ \n               Table 5-2.  Subnetwork Service Primitives\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  5.5.1\
    \  Subnetwork Addresses\n   The source and destination addresses specify the points\
    \ of attachment\n   to a public or private subnetwork(s) involved in the transmission.\n\
    \   Subnetwork addresses are defined in the Service Definition of each\n   individual\
    \ subnetwork.\n   The syntax and semantics of subnetwork addresses are not defined\
    \ in\n   this Protocol Standard.\n  5.5.2  Subnetwork Quality of Service\n   Subnetwork\
    \ Quality of Service describes aspects of a subnetwork\n   connectionless-mode\
    \ service which are attributable solely to the\n   subnetwork service provider.\n\
    \   Associated with each subnetwork connectionless-mode transmission,\n   certain\
    \ measures of quality of service are requested when the\n   primitive action is\
    \ initiated. These requested measures (or parameter\n   values and options) are\
    \ based on a priori knowledge by the Network\n   Service provider of the service(s)\
    \ made available to it by the\n   subnetwork. Knowledge of the nature and type\
    \ of service available is\n   typically obtained prior to an invocation of the\
    \ subnetwork\n   connectionless-mode service.\n    Note:\n     The quality of\
    \ service parameters identified for the subnetwork\n     connectionless-mode service\
    \ may in some circumstances be directly\n     derivable from or mappable onto\
    \ those identified in the\n     connectionless-mode Network Service; e.g., the\
    \ parameters\n      a)  transit delay;\n      b)  protection against unauthorized\
    \ access;\n      c)  cost determinants;\n      d)  priority; and\n      e)  residual\
    \ error probability\n     as defined in ISO 8348/DAD1, Addendum to the Network\
    \ Service\n     Definition Covering Connectionless-mode Transmission, may be\n\
    \     employed.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \   For those subnetworks which do not inherently provide Quality of\n     Service\
    \ as a parameter when the primitive action is initiated, it\n     is a local matter\
    \ as to how the semantics of the service requested\n     might be preserved. In\
    \ particular, there may be instances in which\n     the Quality of Service requested\
    \ cannot be maintained. In such\n     circumstances, the subnetwork service provider\
    \ shall attempt to\n     deliver the protocol data unit at whatever Quality of\
    \ Service is\n     available.\n  5.5.3  Subnetwork User Data\n   The SN_Userdata\
    \ is an ordered multiple of octets, and is transferred\n   transparently between\
    \ the specified subnetwork service access points.\n   The subnetwork service is\
    \ required to support a subnetwork service\n   data unit size of at least the\
    \ maximum size of the Data PDU header\n   plus one octet of NS-Userdata. This\
    \ requires a minimum subnetwork\n   service data unit size of 256 octets.\n  \
    \ Where the subnetwork service can support a subnetwork service data\n   unit\
    \ (SNSDU) size greater than the size of the Data PDU header plus\n   one octet\
    \ of NS_Userdata, the protocol may take advantage of this. In\n   particular,\
    \ if all SNSDU sizes of the subnetworks involved are known\n   to be large enough\
    \ that segmentation is not required, then the\n   \"non-segmenting\" protocol\
    \ subset may be used.\n  5.5.4  Subnetwork Dependent Convergence Functions\n \
    \  Subnetwork Dependent Convergence Functions may be performed to\n   provide\
    \ a connectionless-mode subnetwork service in the case where\n   subnetworks also\
    \ provide a connection-oriented subnetwork service. If\n   a subnetwork provides\
    \ a connection-oriented service, some subnetwork\n   dependent function is assumed\
    \ to provide a mapping into the required\n   subnetwork service described in the\
    \ preceding text.\n   A Subnetwork Dependent Convergence Protocol may also be\
    \ employed in\n   those cases where functions assumed from the subnetwork service\n\
    \   provider are not performed.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 5.6\
    \  Service Assumed from Local Evironment\n  A timer service is provided to allow\
    \ the protocol entity to schedule\n  events.\n  There are three primitives associated\
    \ with the S_TIMER service:\n   1)  the S-TIMER request;\n   2)  the S_TIMER response;\
    \ and\n   3)  the S_TIMER cancel.\n  The S_TIMER request primitive indicates to\
    \ the local environment that\n  it should initiate a timer of the specified name\
    \ and subscript and\n  maintain it for the duration specified by the time parameter.\n\
    \  The S_TIMER response primitive is initiated by the local environment\n  to\
    \ indicate that the delay requested by the corresponding S_TIMER\n  request primitive\
    \ has elapsed.\n  The S_TIMER cancel primitive is an indication to the local environment\n\
    \  that the specified timer(s) should be cancelled. If the subscript\n  parameter\
    \ is not specified, then all timers with the specified name\n  are cancelled;\
    \ otherwise, the timer of the given name and subscript is\n  cancelled. If no\
    \ timers correspond to the parameters specified, the\n  local environment takes\
    \ no action.\n  The parameters of the S_TIMER service primitives are:\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \          Primitives                  Parameters             \n      +--------------------------------------------------------+\
    \ \n      |                           |                            | \n      |\
    \ S_TIMER Request           | S_Time                     | \n      |         \
    \                  | S_Name                     | \n      |                  \
    \         | S_Subscript                | \n      |                           |\
    \                            | \n      | S_TIMER Response          | S_Name  \
    \                   | \n      |         Cancel            | S_Subscript      \
    \          | \n      +--------------------------------------------------------+\
    \ \n                      Table 5-3.  Timer Primitives\n  The time parameter indicates\
    \ the time duration of the specified timer.\n  An identifying label is associated\
    \ with a timer by means of the name\n  parameter. The subscript parameter specifies\
    \ a value to distinguish\n  timers with the same name. The name and subscript\
    \ taken together\n  constitute a unique reference to the timer.\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: SECTION TWO.  SPECIFICATION OF THE PROTOCOL
  contents:
  - 'SECTION TWO.  SPECIFICATION OF THE PROTOCOL

    '
- title: 6  PROTOCOL FUNCTIONS
  contents:
  - "6  PROTOCOL FUNCTIONS\n This section describes the functions performed as part\
    \ of the Protocol.\n Not all of the functions must be performed by every implementation.\n\
    \ Section 6.17 specifies which functions may be omitted and the correct\n behavior\
    \ where requested functions are not implemented.\n 6.1  PDU Composition Function\n\
    \  This function is responsible for the construction of a protocol data\n  unit\
    \ according to the rules of protocol given in Section 7. Protocol\n  Control Information\
    \ required for delivering the data unit to its\n  destination is determined from\
    \ current state information and from the\n  parameters provided with the N_UNITDATA\
    \ Request; e.g., source and\n  destination addresses, QOS, etc. User data passed\
    \ from the Network\n  Service user in the N_UNITDATA Request forms the Data field\
    \ of the\n  protocol data unit.\n  During the composition of the protocol data\
    \ unit, a Data Unit\n  Identifier is assigned to identify uniquely all segments\
    \ of the\n  corresponding NS_Userdata. The \"Reassemble PDU\" function considers\n\
    \  PDUs to correspond to the same Initial PDU, and hence N_UNITDATA\n  request,\
    \ if they have the same Source and Destination Addresses and\n  Data Unit Identifier.\n\
    \  The Data Unit Identifier is available for ancillary functions such as\n  error\
    \ reporting. The originator of the PDU must choose the Data Unit\n  Identifier\
    \ so that it remains unique (for this Source and Destination\n  Address pair)\
    \ for the maximum lifetime of the PDU (or any Derived\n  PDUs) in the network.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  During\
    \ the composition of the PDU, a value of the total length of the\n  PDU is determined\
    \ by the originator and placed in the Total Length\n  field of the PDU header.\
    \ This field is not changed in any Derived PDU\n  for the lifetime of the protocol\
    \ data unit.\n  Where the non-segmenting subset is employed, neither the Total\
    \ Length\n  field nor the Data Unit Identifier field is present. During the\n\
    \  composition of the protocol data unit, a value of the total length of\n  the\
    \ PDU is determined by the originator and placed in the Segment\n  Length field\
    \ of the PDU header. This field is not changed for the\n  lifetime of the PDU.\n\
    \ 6.2  PDU Decomposition Function\n  This function is responsible for removing\
    \ the Protocol Control\n  Information from the protocol data unit. During this\
    \ process,\n  information pertinent to the generation of the N_UNITDATA Indication\n\
    \  is retained. The data field of the PDU received is reserved until all\n  segments\
    \ of the original service data unit have been received; this is\n  the NS_Userdata\
    \ parameter of the N_UNITDATA Indication.\n 6.3  Header Format Analysis Function\n\
    \  This function determines whether the full Protocol described in this\n  Standard\
    \ is employed, or one of the defined proper subsets thereof. If\n  the protocol\
    \ data unit has a Network Layer Protocol Identifier\n  indicating that this is\
    \ a standard version of the Protocol, this\n  function determines whether a PDU\
    \ received has reached its destination\n  using the destination address provided\
    \ in the PDU is the same as the\n  one which addresses an NSAP served by this\
    \ network-entity, then the\n  PDU has reached its destination; if not, it must\
    \ be forwarded.\n  If the protocol data unit has a Network Layer Protocol Identifier\n\
    \  indicating that the Inactive Network Layer Protocol subset is in use,\n  then\
    \ no further analysis of the PDU header is required. The\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  network-entity\
    \ in this case determines that either the network address\n  encoded in the network\
    \ protocol address information of a supporting\n  subnetwork protocol corresponds\
    \ to a network Service Access Point\n  address served by this network-entity,\
    \ or that an error has occurred.\n  If the subnetwork PDU has been delivered correctly,\
    \ then the protocol\n  data unit may be decomposed according to the procedure\
    \ described for\n  that particular subnetwork protocol.\n 6.4  PDU Lifetime Control\
    \ Function\n  This function is used to enforce the maximum PDU lifetime. It is\n\
    \  closely associated with the \"Header Format Analysis\" function. This\n  function\
    \ determines whether a PDU received may be forwarded or whether\n  its assigned\
    \ lifetime has expired, in which case it must be discarded.\n  The operation of\
    \ the Lifetime Control function depends upon the\n  Lifetime field in the PDU\
    \ header. This field contains, at any time,\n  the remaining lifetime of the PDU\
    \ (represented in units of 500\n  Milliseconds). The Lifetime of the Initial PDU\
    \ is determined by the\n  originating network-entity, and placed in the Lifetime\
    \ field of the\n  PDU.\n 6.5  Route PDU Function\n  This function determines the\
    \ network-entity to which a protocol data\n  unit should be forwarded, using the\
    \ destination NSAP address\n  parameters, Quality of Service parameter, and/or\
    \ other parameters. It\n  determines the subnetwork which must be transited to\
    \ reach that\n  network-entity. Where segmentation occurs, it further determines\
    \ which\n  subnetwork(s) the segments may transit to reach that network-entity.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 6.6\
    \  Forward PDU Function\n  This function issues a subnetwork service primitive\
    \ (see Section 5.5)\n  supplying the subnetwork identified by the \"Route PDU\"\
    \ function with\n  the protocol data unit as an SNSDU, and the address information\n\
    \  required by that subnetwork to identify the \"next\" intermediate-system\n\
    \  within the subnetwork-specific address domain.\n  When an Error Report PDU\
    \ is to be forwarded, and is longer than the\n  maximum user data acceptable by\
    \ the subnetwork, it shall be truncated\n  to the maximum acceptable length ad\
    \ forwarded with no other change.\n  When a Data PDU is to be forwarded ad is\
    \ longer than the maximum user\n  data acceptable by the subnetwork, the Segmentation\
    \ function is\n  applied (See Section 6.7, which follows).\n 6.7  Segmentation\
    \ Function\n  Segmentation is performed when the size of the protocol data unit\
    \ is\n  greater than the maximum size of the user data parameter field of the\n\
    \  subnetwork service primitive.\n  Segmentation consists of composing two or\
    \ more new PDUs (Derived PDUs)\n  from the PDU received. The PDU received may\
    \ be the Initial PDU, or it\n  may be a Derived PDU. The Protocol Control Information\
    \ required to\n  identify, route, and forward a PDU is duplicated in each PDU\
    \ derived\n  from the Initial PDU. The user data encapsulated within the PDU\n\
    \  received is divided such that the Derived PDUs satisfy the size\n  requirements\
    \ of the user data parameter field of the subnetwork\n  service primitive.\n \
    \ Derived PDUs are identified as being from the same Initial PDU by\n  means of\n\
    \   a)  the source address,\n   b)  the destination address, and\n   c)  the data\
    \ unit identifier.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  The\
    \ following fields of the PDU header are used in conjunction with\n  the Segmentation\
    \ function:\n   a)  Segment Offset - identifies at which octet in the data field\
    \ of\n       the Initial PDU the segment begins;\n   b)  Segment Length - specifies\
    \ the number of octets in the Derived\n       PDU, including both header and data;\n\
    \   c)  More Segments Flag - set to one if this Derived PDU does not\n       contain,\
    \ as its final octet of user data, the final octet of the\n       Initial PDU;\
    \ and\n   d)  Total Length - specifies the entire length of the Initial PDU,\n\
    \       including both header and data.\n  Derived PDUs may be further segmented\
    \ without constraining the routing\n  of the individual Derived PDUs.\n  A Segmentation\
    \ Permitted flag is set to one to indicate that\n  segmentation is permitted.\
    \ If the Initial PDU is not to be segmented\n  at any point during its lifetime\
    \ in the network, the flag is set to\n  zero.\n  When the \"Segmentation Permitted\"\
    \ flag is set to zero, the non-\n  segmenting protocol subset is in use.\n 6.8\
    \  Reassembly Function\n  The Reassembly Function reconstructs the Initial PDU\
    \ transmitted to\n  the destination network-entity from the Derived PDUs generated\
    \ during\n  the lifetime of the Initial PDU.\n  A bound on the time during which\
    \ segments (Derived PDUs) of an Initial\n  PDU will be held at a reassembly point\
    \ is provided so that resources\n  may be released when it is no longer expected\
    \ that any outstanding\n  segments of the Initial PDU will arrive at the reassembly\
    \ point. When\n  such an event occurs, segments (Derived PDUs) of the Initial\
    \ PDU held\n  at the reassembly point are discarded, the resources allocated for\n\
    \  those segments are freed,\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  and\
    \ if selected, an Error Report is generated.\n   Note:\n    The design of the\
    \ Segmentation and Reassembly functions is intended\n    principally to be used\
    \ such that reassembly takes place at the\n    destination. However, other schemes\
    \ which\n     a)  interact with the routing algorithm to favor paths on which\n\
    \         fewer segments are generated,\n     b)  generate more segments than\
    \ absolutely required in order to\n         avoid additional segmentation at some\
    \ subsequent point, or\n     c)  allow partial/full reassembly at some point along\
    \ the route\n         where it is known that the subnetwork with the smallest\
    \ PDU\n         size has been transited\n    are not precluded. The information\
    \ necessary to enable the use of\n    one of these alternative strategies may\
    \ be made available through\n    the operation of a Network Layer Management function.\n\
    \    While the exact relationship between reassembly lifetime and PDU\n    lifetime\
    \ is a local matter, the reassembly algorithm must preserve\n    the intent of\
    \ the PDU lifetime. Consequently, the reassembly\n    function must discard PDUs\
    \ whose lifetime would otherwise have\n    expired had they not been under the\
    \ control of the reassembly\n    function.\n 6.9  Discard PDU Function\n  This\
    \ function performs all of the actions necessary to free the\n  resources reserved\
    \ by the network-entity in any of the following\n  situations (Note: the list\
    \ is not exhaustive):\n   a)  A violation of protocol procedure has occurred.\n\
    \   b)  A PDU is received whose checksum is inconsistent with its\n       contents.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ c)  A PDU is received, but due to congestion, it cannot be processed.\n   d)\
    \  A PDU is received whose header cannot be analyzed.\n   e)  A PDU is received\
    \ which cannot be segmented and cannot be\n       forwarded because its length\
    \ exceeds the maximum subnetwork\n       service data unit size.\n   f)  A PDU\
    \ is received whose destination address is unreachable or\n       unknown.\n \
    \  g)  Incorrect or invalid source routing was specified. This may\n       include\
    \ a syntax error in the source routing field, and unknown\n       or unreachable\
    \ address in the source routing field, or a path\n       which is not acceptable\
    \ for other reasons.\n   h)  A PDU is received whose PDU lifetime has expired\
    \ or the lifetime\n       expires during reassembly.\n   i)  A PDU is received\
    \ which contains an unsupported option.\n 6.10  Error Reporting Function\n  6.10.1\
    \  Overview\n   This function causes the return of an Error Report PDU to the\
    \ source\n   network-entity when a protocol data unit is discarded. An \"error\n\
    \   report flag\" in the original PDU is set by the source network-entity\n  \
    \ to indicate whether or not Error Report PDUs are to be returned.\n   The Error\
    \ Report PDU identifies the discarded PDU, specifies the type\n   of error detected,\
    \ and identifies the location at which the error was\n   detected. Part or all\
    \ of the discarded PDU is included in the data\n   field of the Error Report PDU.\n\
    \   The address of the originator of the Data Protocol Data Unit is\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ conveyed as both the destination address of the Error Report PDU as\n   well\
    \ as the source address of the original Data PDU; the latter is\n   contained\
    \ in the Data field of the Error Report PDU. The address of\n   the originator\
    \ of the Error Report PDU is contained in the source\n   address field of the\
    \ header of the Error Report PDU.\n    Note:\n     Non-receipt of an Error Report\
    \ PDU does not imply correct delivery\n     of a PDU issued by a source network-entity.\n\
    \  6.10.2  Requirements\n   An Error Report PDU shall not be generated to report\
    \ the discarding\n   of a PDU that itself contains an Error Report.\n   An Error\
    \ Report PDU shall not be generated upon discarding of a PDU\n   unless that PDU\
    \ has the Error Report flag set to allow Error Reports.\n   If a Data PDU is discarded,\
    \ and has the Error Report flag set to\n   allow Error Reports, an Error Report\
    \ PDU shall be generated if the\n   reason for discard (See Section 6.9)  is\n\
    \    a)  destination address unreachable,\n    b)  source routing failure,\n \
    \   c)  unsupported options, or\n    d)  protocol violation.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \  Note:\n     It is intended that this list shall include all nontransient\n\
    \     reasons for discard; the list may therefore need to be amended or\n    \
    \ extended in the light of any changes made in the definitions of\n     such reasons.\n\
    \   If a Data PDU with the Error Report flag set to allow Error Reports\n   is\
    \ discarded for any other reason, an Error Report PDU may be\n   generated (as\
    \ an implementation option).\n  6.10.3  Processing of Error Reports\n   Error\
    \ Report PDUs are forwarded by intermediate network-entities in\n   the same way\
    \ as Data PDUs. It is possible that an Error Report PDU\n   may be longer than\
    \ the maximum user data size of a subnetwork that\n   must be traversed to reach\
    \ the origin of the discarded PDU. In this\n   case, the Forward PDU function\
    \ shall truncate the PDU to the maximum\n   size acceptable.\n   The entire header\
    \ of the discarded data unit shall be included in the\n   data field of the Error\
    \ Report PDU. Some or all of the data field of\n   the discarded data unit may\
    \ also be included.\n    Note:\n     Since the suppression of Error Report PDUs\
    \ is controlled by the\n     originating network-entity and not by the NS User,\
    \ care should be\n     exercised by the originator with regard to suppressing\
    \ ER PDUs so\n     that error reporting is not suppressed for every PDU generated.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 6.11\
    \  PDU Header Error Detection\n  The PDU Header Error Detection function protects\
    \ against failure of\n  intermediate or end-system network-entities due to the\
    \ processing of\n  erroneous information in the PDU header. The function is realized\
    \ by a\n  checksum computed on the PDU header. The checksum is verified at each\n\
    \  point at which the PDU header is processed. If PDU header fields are\n  modified\
    \ (for example, due to lifetime function), then the checksum is\n  modified so\
    \ that the checksum remains valid.\n  An intermediate system network-entity must\
    \ not recompute the checksum\n  for the entire header, even if fields are modified.\n\
    \   Note:\n    This is to ensure that inadvertent modification of a header while\
    \ a\n    PDU is being processed by an intermediate system (for example, due\n\
    \    to a memory fault) may still be detected by the PDU Header Error\n    function.\n\
    \  The use of this function is optional, and is selected by the\n  originating\
    \ network-entity. If the function is not used, the checksum\n  field of the PDU\
    \ header is set to zero.\n  If the function is selected by the originating network-entity,\
    \ the\n  value of the checksum field causes the following formulae to be\n  satisfied:\n\
    \     L\n   (SUM)     a   = 0  (modulo 255)\n              i\n     i=1\n     L\n\
    \   (SUM)     (L-i+1) a   = 0 (modulo 255)\n                       i\n     i=1\n\
    \    Where L = the number of octets in the PDU header, and\n          a = value\
    \ of octet at position i.\n           i\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  When\
    \ the function is in use, neither octet of the checksum field may\n  be set to\
    \ zero.\n  Annex C contains descriptions of algorithms which may be used to\n\
    \  calculate the correct value of the checksum field when the PDU is\n  created,\
    \ and to update the checksum field when the header is modified.\n 6.12  Padding\
    \ Function\n  The padding function is provided to allow space to be reserved in\
    \ the\n  PDU header which is not used to support any other function. Octet\n \
    \ alignment must be maintained.\n   Note:\n    An example of the use of this function\
    \ is to cause the data field of\n    a PDU to begin on a convenient boundary for\
    \ the originating\n    network-entity, such as a computer word boundary.\n 6.13\
    \  Security\n  An issue related to the quality of the network service is the\n\
    \  protection of information flowing between transport-entities. A system\n  may\
    \ wish to control the distribution of secure data by assigning\n  levels of security\
    \ to PDUs. As a local consideration, the Network\n  Service user could be authenticated\
    \ to ascertain whether the user has\n  permission to engage in communication at\
    \ a particular security level\n  before sending the PDU. While no protocol exchange\
    \ is required in the\n  authentication process, the optional security parameter\
    \ in the options\n  part of the PDU header may be employed to convey the particular\n\
    \  security level between peer network-entities.\n  The syntax and semantics of\
    \ the security parameter are not specified\n  by this Standard. The security parameter\
    \ is related to the \"protection\n  from unauthorized access\" Quality of service\
    \ parameter described in\n  ISO 8348/DAD1, Addendum to the Network Service Definition\
    \ Covering\n  Connectionless-mode Transmission. However, to facilitate\n  interoperation\
    \ between end-systems and relay-systems by avoiding\n  different interpretations\
    \ of the same encoding, a mechanism is\n  provided to distinguish user-defined\
    \ security encoding from\n  standardized security encoding.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 6.14\
    \  Source Routing Function\n  The Source Routing function allows the originator\
    \ to specify the path\n  a generated PDU must take. Source routing can only be\
    \ selected by the\n  originator of a PDU. Source Routing is accomplished using\
    \ a list of\n  intermediate system addresses (or titles, see Section 5.3 and 5.5.1)\n\
    \  held in a parameter within the options part of the PDU Header. The\n  size\
    \ of the option field is determined by the originating\n  network-entity. The\
    \ length of this option does not change as the PDU\n  traverses the network. Associated\
    \ with this list is an indicator which\n  identifies the next entry in the list\
    \ to be used; this indicator is\n  advanced by the receiver of the PDU when the\
    \ next address matches its\n  own address. The indicator is updated as the PDU\
    \ is forwarded so as to\n  identify the appropriate entry at each stage of relaying.\n\
    \  Two forms of the source routing option are provided. The first form,\n  referred\
    \ to as complete source routing, requires that the specified\n  path must be taken;\
    \ if the specified path cannot be taken, the PDU\n  must be discarded. The source\
    \ may be informed of the discard using the\n  Error Reporting function described\
    \ in Section 6.10.\n  The second form is referred to as partial source routing.\
    \ Again, each\n  address in the list must be visited in the order specified while\
    \ on\n  route to the destination. However, with this form of source routing\n\
    \  the PDU may take any path necessary to arrive at the next address in\n  the\
    \ list. The PDU will not be discarded (for source routing related\n  causes) unless\
    \ one of the addresses specified cannot be reached by any\n  available route.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 6.15\
    \  Record Route Function\n  The Record Route function permits the exact recording\
    \ of the paths\n  taken by a PDU as it traverses a series of interconnected subnetworks.\n\
    \  A recorded route is composed of a list of intermediate system\n  addresses\
    \ held in a parameter within the options part of the PDU\n  header. The size of\
    \ the option field is determined by the originating\n  network-entity. The length\
    \ of this option does not change as the PDU\n  traverses the network.\n  The list\
    \ is constructed as the PDU traverses a set of interconnected\n  subnetworks.\
    \ Only intermediate system addresses are included in the\n  recorded route. The\
    \ address of the originator of the PDU is not\n  recorded in the list. When an\
    \ intermediate system network-entity\n  processes a PDU containing the record\
    \ route parameter, the system\n  inserts its own address (or titles, see Sections\
    \ 5.3 or 5.5.1) into\n  the list of recorded addresses.\n  The record route option\
    \ contains an indicator which identifies the\n  next available octet to be used\
    \ for recording of route. This\n  identifier is updated as entries are added to\
    \ the list. If the\n  addition of the current address to the list would exceed\
    \ the size of\n  the option field, the indicator is set to show that recording\
    \ of route\n  has terminated. The PDU may still be forwarded to its final\n  destination,\
    \ without further addition of intermediate system\n  addresses.\n   Note:\n  \
    \  The Record Route function is principally intended to be used in the\n    diagnosis\
    \ of network problems. Its mechanism has been designed on\n    this basis, and\
    \ may provide a return path.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 6.16\
    \  Quality of Service Maintenance Function\n  In order to support the Quality\
    \ of Service requested by Network\n  Service users, the Protocol may need to make\
    \ QOS information available\n  at intermediate systems. This information may be\
    \ used by network\n  entities in intermediate systems to make routing decisions\
    \ where such\n  decisions affect the overall QOS provided to NS users.\n  In those\
    \ instances where the QOS indicated cannot be maintained, the\n  NS provider will\
    \ attempt to deliver the PDU at a QOS less than that\n  indicated. The NS provider\
    \ will not necessarily provide a notification\n  of failure to meet the indicated\
    \ quality of service.\n 6.17  Classification of Functions\n  Implementations do\
    \ not have to support all of the functions described\n  in Section 6. Functions\
    \ are divided into three categories:\n   Type 1:  These functions must be supported.\n\
    \   Type 2:  These functions may or may not be supported. If an\n            implementation\
    \ does not support a Type 2 function, and the\n            function is selected\
    \ by a PDU, then the PDU shall be\n            discarded, and an Error Report\
    \ PDU shall be generated and\n            forwarded to the originating network-entity,\
    \ providing that\n            the Error Report flag is set.\n   Type 3:  These\
    \ functions may or may not be supported. If an\n            implementation does\
    \ not support a Type 3 function, and the\n            function is selected by\
    \ a PDU, then the function is not\n            performed and the PDU is processed\
    \ exactly as though the\n            function was not selected. The protocol data\
    \ unit shall not\n            be discarded.\n  Table 6-1 shows how the functions\
    \ are divided into these three\n  categories:\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \       +---------------------------------------------------+\n         | Function\
    \                       |  Type            |\n         |--------------------------------|------------------|\n\
    \         |                                |                  |\n         | PDU\
    \ Composition                |  1               |\n         | PDU Decomposition\
    \              |  1               |\n         | Header Format Analysis       \
    \  |  1               |\n         | PDU Lifetime Control           |  1      \
    \         |\n         | Route PDU                      |  1               |\n\
    \         | Forward PDU                    |  1               |\n         | Segment\
    \ PDU                    |  1               |\n         | Reassemble PDU     \
    \            |  1               |\n         | Discard PDU                    |\
    \  1               |\n         | Error Reporting                |  1 (note 1)\
    \      |\n         | PDU Header Error Detection     |  1 (note 1)      |\n   \
    \      | Padding                        |  1 (notes 1   2) |\n         | Security\
    \                       |  2               |\n         | Complete Source Routing\
    \        |  2               |\n         | Partial Source Routing         |  3\
    \               |\n         | Priority                       |  3            \
    \   |\n         | Record Route                   |  3               |\n      \
    \   | Quality of Service Maintenance |  3               |\n         +---------------------------------------------------+\n\
    \            Table 6-1.  Categorization of Protocol Functions\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  Notes:\n\
    \   1)  While the Padding, Error Reporting, and Header Error Detection\n     \
    \  functions must be provided, they are provided only when selected\n       by\
    \ the sending Network Service user.\n   2)  The correct treatment of the Padding\
    \ function involves no\n       processing. Therefore, this could equally be described\
    \ as a Type\n       3 function.\n   3)  The rationale for the inclusion of type\
    \ 3 functions is that in\n       the case of some functions it is more important\
    \ to forward the\n       PDUs between intermediate systems or deliver them to\
    \ an\n       end-system than it is to support the functions. Type 3 functions\n\
    \       should be used in those cases where they are of an advisory\n       nature\
    \ and should not be the cause of the discarding of a PDU\n       when not supported.\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: 7  STRUCTURE AND ENCODING OF PDUS
  contents:
  - "7  STRUCTURE AND ENCODING OF PDUS\n 7.1 Structure\n  All Protocol Data Units\
    \ shall contain an integral number of octets.\n  The octets in a PDU are numbered\
    \ starting from one (1) and increasing\n  in the order in which they are put into\
    \ an SNSDU. The bits in an octet\n  are numbered from one (1) to eight (8), where\
    \ bit one (1) is the\n  low-order bit.\n  When consecutive octets are used to\
    \ represent a binary number, the\n  lower octet number has the most significant\
    \ value.\n  Any subnetwork supporting this protocol is required to state in its\n\
    \  specification the way octets are transferred, using the terms \"most\n  significant\
    \ bit\" and \"least significant bit.\" The PDUs of this\n  protocol are defined\
    \ using the terms \"most significant bit\" and \"least\n  significant bit.\"\n\
    \   Note:\n    When the encoding of a PDU is represented using a diagram in this\n\
    \    section, the following representation is used:\n     a)  octets are shown\
    \ with the lowest numbered octet to the left,\n         higher number octets being\
    \ further to the right;\n     b)  within an octet, bits are shown with bit eight\
    \ (8) to the left\n         and bit one (1) to the right.\n  PDUs shall contain,\
    \ in the following order:\n   1)  the header, comprising:\n    a)  the fixed part;\n\
    \    b)  the address part;\n    c)  the segmentation part, if present;\n    d)\
    \  the options part, if present\n   and\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ 2)  the data field, if present.\n  This structure is illustrated below:\n  \
    \                     Part:                Described in:  \n            +-------------------+\
    \                          \n            |    Fixed Part     |            Section\
    \ 7.2   \n            +-------------------+                          \n      \
    \      +-------------------+                          \n            |   Address\
    \ Part    |            Section 7.3   \n            +-------------------+     \
    \                     \n            +-------------------+                    \
    \      \n            | Segmentation Part |            Section 7.4   \n       \
    \     +-------------------+                          \n            +-------------------+\
    \                          \n            |   Options Part    |            Section\
    \ 7.5   \n            +-------------------+                          \n      \
    \      +-------------------+                          \n            |       Data\
    \        |            Section 7.6   \n            +-------------------+      \
    \                    \n                       Figure 7-1.  PDU Structure\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 7.2\
    \ Fixed Part\n  7.2.1 General\n   The fixed part contains frequently occuring\
    \ parameters including the\n   type code (DT or ER) of the protocol data unit.\
    \ The length and the\n   structure of the fixed part are defined by the PDU code.\n\
    \   The fixed part has the following format:\n                               \
    \                       Octet \n            +------------------------------------+\
    \          \n            | Network Layer Protocol Identifier  |     1    \n  \
    \          |------------------------------------|          \n            |   \
    \      Length Indicator           |     2    \n            |------------------------------------|\
    \          \n            |   Version/Protocol Id Extension    |     3    \n  \
    \          |------------------------------------|          \n            |   \
    \         Lifetime                |     4    \n            |------------------------------------|\
    \          \n            |S |M |E/R|         Type             |     5    \n  \
    \          | P| S|   |                          |          \n            |------------------------------------|\
    \          \n            |          Segment Length            |    6,7   \n  \
    \          |------------------------------------|          \n            |   \
    \          Checksum               |    8,9   \n            +------------------------------------+\
    \          \n                  Figure 7-2.  PDU Header--Fixed Part\n  7.2.2 Network\
    \ Layer Protocol Identifier\n   The value of this field shall be binary 1000 0001.\
    \ This field\n   identifies this Network Layer Protocol as ISO 8473, Protocol\
    \ for\n   Providing the Connectionless-mode Network Service.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  7.2.3\
    \ Length Indicator\n   The length is indicated by a binary number, with a maximum\
    \ value of\n   254 (1111 1110). The length indicated is the length in octets of\
    \ the\n   header, as described in Section 7.1, Structure. The value 255 (1111\n\
    \   1111) is reserved for possible future extensions.\n    Note:\n     The rules\
    \ for forwarding and segmentation ensure that the header\n     length is the same\
    \ for all segments (Derived PDUs) of the Initial\n     PDU, and is the same as\
    \ the header length of the Initial PDU.\n  7.2.4 Version/Protocol Identifier Extension\n\
    \   The value of this field is binary 0000 0001. This Identifies a\n   standard\
    \ version of ISO 8473, Protocol for Providing the\n   Connectionless-mode Network\
    \ Service.\n  7.2.5 PDU Lifetime\n   The Lifetime field is encoded as a binary\
    \ number representing the\n   remaining lifetime of the PDU, in units of 500 milliseconds.\n\
    \   The Lifetime field is set by the originating network-entity, and is\n   decremented\
    \ by every network-entity which processes the PDU. The PDU\n   shall be discarded\
    \ if the value of the field reaches zero.\n   When a network-entity processes\
    \ a PDU, it decrements the Lifetime by\n   at least one. The Lifetime shall be\
    \ decremented by more than one if\n   the sum of:\n    1)  the transit delay in\
    \ the subnetwork from which the PDU was\n        received; and\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \  2)  the delay within the system processing the PDU\n   exceeds or is estimated\
    \ to exceed 500 milliseconds. In this case, the\n   lifetime field should be decremented\
    \ by one for each additional 500\n   milliseconds of delay. The determination\
    \ of delay need not be\n   precise, but where error exists the value used shall\
    \ be an\n   overestimate, not an underestimate.\n   If the Lifetime reaches a\
    \ value of zero before the PDU is delivered\n   to the destination, the PDU shall\
    \ be discarded. The Error Reporting\n   function shall be invoked, as described\
    \ in Section 6.10, Error\n   Reporting Function, and may result in the generation\
    \ of an ER PDU. It\n   is a local matter whether the destination network-entity\
    \ performs the\n   Lifetime Control function.\n   When the Segmentation function\
    \ is applied to a PDU, the Lifetime\n   field is copied into all of the Derived\
    \ PDUs.\n  7.2.6 Flags\n   7.2.6.1 Segmentation Permitted and More Segments Flags\n\
    \    The Segmentation Permitted flag determines whether segmentation is\n    permitted.\
    \ A value of one indicates that segmentation is permitted.\n    A value of zero\
    \ indicates that the non-segmenting protocol subset is\n    employed. Where this\
    \ is the case, the segmentation part of the PDU\n    header is not present, and\
    \ the Segment Length field serves as the\n    Total Length field.\n    The More\
    \ Segments flag indicates whether the data segment in this\n    PDU contains (as\
    \ its last octet) the last octet of the User Data in\n    the NSDU. When the More\
    \ Segments flag is set to one (1) then\n    segmentation has taken place and the\
    \ last octet of the NSDU is not\n    contained in this PDU. The More Segments\
    \ flag cannot be set to one\n    (1) if the Segmentation Permitted flag is not\
    \ set to one (1).\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \  When the More Segments flag is set to zero (0) the last octet of the\n    Data\
    \ Part of the PDU is the last octet of the NSDU.\n   7.2.6.2 Error Report Flag\n\
    \    When the Error Report flag is set to one, the rules in Section 6.10\n   \
    \ are used to determine whether to generate an Error Report PDU upon\n    discard\
    \ of the PDU.\n    When the Error Report flag is set to zero, discard of the PDU\
    \ will\n    not cause the generation of an Error Report PDU.\n  7.2.7 Type Code\n\
    \   The Type code field identifies the type of the protocol data unit.\n   Allowed\
    \ values are given in Table 7-1:\n                                Bits    5 4\
    \ 3 2 1   \n                    +-----------------------------+ \n           \
    \         |  DT PDU  |        1 1 1 0 0 | \n                    |-----------------------------|\
    \ \n                    |  ER PDU  |        0 0 0 0 1 | \n                   \
    \ +-----------------------------+ \n                      Table 7-1.  Valid PDU\
    \ Types\n  7.2.8 PDU Segment Length\n   The Segment Length field specifies the\
    \ entire length of the PDU\n   segment including both header and data, if present.\
    \ When the full\n   protocol is employed and a PDU is not segmented, then the\
    \ value of\n   this field is identical to the value of the Total Length field\n\
    \   located in the Segmentation Part of the header.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ When the Non-segmenting protocol subset is employed, no segmentation\n   part\
    \ is present in the header. In this subset, the Segment Length\n   field serves\
    \ as the Total Length field of the header (see Section\n   7.4.3).\n  7.2.9 PDU\
    \ Checksum\n   The checksum is computed on the entire PDU header. This includes\
    \ the\n   segmentation and options parts, if present. A checksum value of zero\n\
    \   is reserved to indicate that the checksum is to be ignored. The\n   operation\
    \ of the PDU Header Error Detection function ensures that the\n   value zero does\
    \ not represent a valid checksum. A non-zero value\n   indicates that the checksum\
    \ must be processed or the PDU must be\n   discarded.\n 7.3 Address Part\n  7.3.1\
    \ General\n   Address parameters are distinguished by their location, immediately\n\
    \   following the fixed part of the PDU header. The address part is\n   illustrated\
    \ below:\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \                                                    Octet  \n          +--------------------------------------+\
    \           \n          |                                      |           \n\
    \          | Destination Address Length Indicator |      10   \n          |  \
    \                                    |           \n          |--------------------------------------|\
    \           \n          |                                      |      11   \n\
    \          |         Destination Address          |           \n          |  \
    \                                    |      m-1  \n          |--------------------------------------|\
    \           \n          |                                      |           \n\
    \          |   Source Address Length Indicator    |       m   \n          |  \
    \                                    |           \n          |--------------------------------------|\
    \           \n          |                                      |      m+1  \n\
    \          |           Source Address             |           \n          |  \
    \                                    |      n-1  \n          +--------------------------------------+\
    \           \n                 Figure 7-3.  PDU header--Address Part\n   7.3.1.1\
    \ Destination and Source Address Information\n    The Destination and Source addresses\
    \ are Network Service Access\n    Point addresses as defined in ISO 8348/DAD2,\
    \ Addendum to the Network\n    Service Definition Covering Network Layer Addressing.\n\
    \    The Destination and Source Address information is of variable\n    length.\n\
    \    The Destination Address Length Indicator field specifies the length\n   \
    \ of the Destination Address in number of octets. The Destination\n    Address\
    \ field follows the Destination Address Length Indicator\n    field. The Source\
    \ Address Length Indicator field specifies the\n    length of the Source Address\
    \ in number of octets. The Source Address\n    Length Indicator field follows\
    \ the Destination Address field. The\n    Source Address field follows the Source\
    \ Address Length Indicator\n    field.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \  Each address parameter is encoded as follows:\n                      Bits \
    \  8   7   6   5   4   3   2   1  \n            +---------------------------------------------+\
    \ \n            | Octet  | Address parameter Length Indicator | \n           \
    \ |   n    |           (e.g., 'm')              | \n            |---------------------------------------------|\
    \ \n            | Octets |                                    | \n           \
    \ |  n+1   |     Address Parameter Value        | \n            | thru   |   \
    \                                 | \n            |  n+m   |                 \
    \                   | \n            +---------------------------------------------+\
    \ \n                     Table 7-2.  Address Parameters\n 7.4 Segmentation Part\n\
    \  If the Segmentation Permitted Flag in the Fixed Part of the PDU Header\n  (Octet\
    \ 4, Bit 8) is set to one, the segmentation part of the header,\n  illustrated\
    \ below, must be present:\n                                               Octet\
    \   \n                +------------------------+             \n              \
    \  |  Data Unit Identifier  |     n,n+1   \n                |------------------------|\
    \             \n                |     Segment Offset     |    n+2,n+3  \n    \
    \            |------------------------|             \n                |      Total\
    \ Length      |    n+4,n+5  \n                +------------------------+     \
    \        \n               Figure 7-4.  PDU Header--Segmentation Part\n  Where\
    \ the \"Segmentation Permitted\" flag is set to zero, the\n  nonsegmenting protocol\
    \ subset is in use.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  7.4.1\
    \ Data Unit Identifier\n   The Data Unit Identifier identifies an Initial PDU\
    \ (and hence, its\n   Derived PDUs) so that a segmented data unit may be correctly\n\
    \   reassembled by the destination network-entity. The Data Unit\n   Identifier\
    \ size is two octets.\n  7.4.2 Segment Offset\n   For each segment the Segment\
    \ Offset field specifies the relative\n   position of the segment in the data\
    \ part of the Initial PDU with\n   respect to the start of the data field. The\
    \ offset is measured in\n   units of octets. The offset of the first segment is\
    \ zero.\n  7.4.3 PDU Total Length\n   The Total Length field specifies the entire\
    \ length of the Initial\n   PDU, including both the header and data. This field\
    \ is not changed in\n   any segment (Derived PDU) for the lifetime of the PDU.\n\
    \ 7.5 Options Part\n  7.5.1 General\n   The options part is used to convey optional\
    \ parameters. If the\n   options part is present, it contains one or more parameters.\
    \ The\n   number of parameters that may be contained in the options part is\n\
    \   indicated by the length of the options part which is:\n    PDU Header Length\
    \ - (length of fixed part +\n                         length of address part +\n\
    \                         length of segmentation part).\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ The options part of the PDU header is illustrated below:\n                 \
    \                              Octet \n                   +--------------------+\
    \            \n                   |                    |       n+6  \n       \
    \            |      Options       |            \n                   |        \
    \            |       p    \n                   +--------------------+        \
    \    \n                 Figure 7-5.  PDU Header--Options Part\n   Each parameter\
    \ contained within the options part of the PDU header is\n   encoded as follows:\n\
    \                          BITS    8  7  6  5  4  3  2  1  \n             +------------------------------------------+\
    \ \n             |  Octets  |                               | \n             |\
    \    n     |  Parameter Code               | \n             |------------------------------------------|\
    \ \n             |   n+1    |  Parameter Length (e.g., 'm') | \n             |------------------------------------------|\
    \ \n             |   n+2    |  Parameter Value              | \n             |\
    \  n+m+1   |                               | \n             +------------------------------------------+\
    \ \n                   Table 7-3.  Encoding of Parameters\n   The parameter code\
    \ field is coded in binary and, without extensions,\n   provides a maximum number\
    \ of 255 different parameters. However, as\n   noted below, bits 8 and 7 cannot\
    \ take every possible value, so the\n   practical maximum number of different\
    \ parameters is less. A parameter\n   code of 255 (binary 1111 1111) is reserved\
    \ for possible extensions of\n   the parameter code.\n   The parameter length\
    \ field indicates the length, in octets, of the\n   parameter value field. The\
    \ length is indicated by a binary number,\n   'm', with a theoretical maximum\
    \ value of 255. The practical maximum\n   value of 'm' is lower. For example,\
    \ in the case of a single parameter\n   contained within the options part, two\
    \ octets are required for the\n   parameter code and the parameter length indication\
    \ itself. Thus, the\n   value of 'm' is limited to:\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \   253 - (length of fixed part +\n     length of address part +\n     length\
    \ of segmentation part).\n   For each succeeding parameter the maximum value of\
    \ 'm' decreases.\n   The parameter value field contains the value of the parameter\n\
    \   identified in the parameter code field.\n   No parameter codes use bits 8\
    \ and 7 with the value 00.\n   Implementations shall accept the parameters defined\
    \ in the options\n   part in any order. Duplication of options (where detected)\
    \ is not\n   permitted. Receipt of a PDU with an option duplicated should be\n\
    \   treated as a protocol error. The rules governing the treatment of\n   protocol\
    \ errors are described in Section 6.10, Error Reporting\n   Function.\n   The\
    \ following parameters are permitted in the options part.\n  7.5.2 Padding\n \
    \  The padding parameter is used to lengthen the PDU header to a\n   convenient\
    \ size (See Section 6.12).\n    Parameter Code:       1100 1100\n    Parameter\
    \ Length:     variable\n    Parameter Value:      any value is allowed\n  7.5.3\
    \ Security\n   This parameter is user defined.\n    Parameter Code:       1100\
    \ 0101\n    Parameter Length:     variable\n    Parameter Value:\n     High order\
    \ bit of first octet is Security Domain bit, S, to be\n     interpreted as follows:\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \    S=0\n       +---------------------------\n       | S | User Defined     \
    \   ----\n       +------------------------\n      S=1\n       +---------------------------\n\
    \       | S | CODE | ORGANIZATION ----\n       +------------------------\n   \
    \   where\n       CODE = This field contains a geographic or non-geographic code\
    \ to\n              which the option applies.\n       ORGANIZATION = This is a\
    \ further subdivision of the CODE field\n                      and is determined\
    \ by an administrator of the\n                      geographic or non-geographic\
    \ domain identified by\n                      the value of CODE.\n  7.5.4 Source\
    \ Routing\n   The source routing parameter specifies, either completely or\n \
    \  partially, the route to be taken from Source Network Address to\n   Destination\
    \ Network Address.\n    Parameter Code:      1100 1000\n    Parameter Length:\
    \    variable\n    Parameter Value:     2 octet control information\n        \
    \                 succeeded by a concatenation\n                         of ordered\
    \ address fields\n                         (ordered from source to destination)\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ The first octet of the parameter value is the type code. This has the\n   following\
    \ significance.\n    0000 0001     complete source routing\n    0000 0000    \
    \ partial source routing\n    <all other values reserved>\n   The second octet\
    \ indicates the octet offset of the next address to be\n   processed in the list.\
    \ A value of three (3) indicates that the next\n   address begins immediately\
    \ after this control octet. Successive\n   octets are indicated by correspondingly\
    \ larger values of this\n   indicator.\n   The third octet begins the intermediate-system\
    \ address list. The\n   address list consists of variable length address fields.\
    \ The first\n   octet of each address field identifies the length of the address\n\
    \   which comprises the remainder of the address field.\n  7.5.5 Recording of\
    \ Route\n   The recording of route parameter identifies the route of intermediate\n\
    \   systems traversed by the PDU.\n    Parameter Code:       1100 1011\n    Parameter\
    \ Length:     variable\n    Parameter Value:      two octets control information\n\
    \                          succeeded  by a concatenation of\n                \
    \          ordered addresses\n   The first octet is used to indicate that the\
    \ recording of route has\n   been terminated owing to lack of space in the option.\
    \ It has the\n   following significance:\n    0000 0000     Recording of Route\
    \ still in progress\n    1111 1111     Recording of Route terminated\n    <all\
    \ other values reserved>\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ The second octet identifies the next octet which may be used to\n   record an\
    \ address. It is encoded relative to the start of the\n   parameter, such that\
    \ a value of three (3) indicates that the octet\n   after this one is the next\
    \ to be used.\n   The third octet begins the address list. The address list consists\
    \ of\n   variable length address fields. The first octet of each address field\n\
    \   identifies the length of the address which comprises the remainder of\n  \
    \ the field. Address fields are always added to the beginning of the\n   address\
    \ list; i.e., the most recently added field will begin in the\n   third octet\
    \ of the parameter value.\n  7.5.6 Quality of Service Maintenance\n   The Quality\
    \ of Service parameter conveys information about the\n   quality of service requested\
    \ by the originating Network Service user.\n   At intermediate systems, Network\
    \ Layer relay entities may (but are\n   not required to) make use of this information\
    \ as an aid in selecting\n   a route when more than one route satisfying other\
    \ routing criteria is\n   available and the available routes are known to differ\
    \ with respect\n   to Quality of Service (see Section 6.16).\n    Parameter Code:\
    \       1100 0011\n    Parameter Length:     one octet\n    Parameter Value: \
    \     Bit 8:  transit delay vs. cost\n                          Bit 7:  residual\
    \ error probability vs.\n                                  transit delay\n   \
    \                       Bit 6:  residual error probability vs.\n             \
    \                     cost\n                          Bits 5 thru 0 are not specified.\n\
    \   Bit 8 is set to one indicates that where possible, routing decision\n   should\
    \ favor low transit delay over low cost. A value of 0 indicates\n   that routing\
    \ decisions should favor low cost over low transit delay.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ Bit 7 set to one indicates that where possible, routing decisions\n   should\
    \ favor low residual error probability over low transit delay. A\n   value of\
    \ zero indicates that routing decisions should favor low\n   transit delay over\
    \ low residual error probability.\n   Bit 6 is set to one indicates that where\
    \ possible, routing decisions\n   should favor low residual error probability\
    \ over low cost. A value of\n   0 indicates that routing decisions should favor\
    \ low cost over low\n   residual error probability.\n 7.6 Priority\n  The priority\
    \ parameter carries the relative priority of the protocol\n  data unit. Intermediate\
    \ systems that support this option should make\n  use of this information in routing\
    \ and in ordering PDUs for\n  transmission.\n   Parameter Code:       1100 1100\n\
    \   Parameter Length:     one octet\n   Parameter Value:      0000 0000 - Normal\
    \ (Default)\n                         thru\n                         0000 1111\
    \ - Highest\n  The values 0000 0001 through 0000 1111 are to be used for higher\n\
    \  priority protocol data units. If an intermediate system does not\n  support\
    \ this option then all PDUs shall be treated as if the field had\n  the value\
    \ 0000 0000.\n 7.7 Data Part\n  The Data part of the PDU is structured as an ordered\
    \ multiple of\n  octets, which is identical to the same ordered multiple of octets\n\
    \  specified for the NS_Userdata parameter of the N_UNITDATA Request and\n  Indication\
    \ primitives. The data field is illustrated below:\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \                                           Octet \n                  +------------------+\
    \                \n                  |                  |      p+1       \n  \
    \                |       Data       |                \n                  |   \
    \               |       z        \n                  +------------------+    \
    \            \n                  Figure 7-6.  PDU header--Data Field\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 7.8\
    \ Data (DT) PDU\n  7.8.1 Structure\n   The DT PDU has the following format:\n\
    \                                                  Octet           \n     +--------------------------------------+\
    \                     \n     |  Network Layer Protocol Identifier   |      1 \
    \             \n     |--------------------------------------|                \
    \     \n     |           Length Indicator           |      2              \n \
    \    |--------------------------------------|                     \n     |   Version/Protocol\
    \ Id Extension      |      3              \n     |--------------------------------------|\
    \                     \n     |              Lifetime                |      4 \
    \             \n     |--------------------------------------|                \
    \     \n     |SP|MS|E/R|      Type                  |      5              \n \
    \    |--------------------------------------|                     \n     |   \
    \        Segment Length             |     6,7             \n     |--------------------------------------|\
    \                     \n     |              Checksum                |     8,9\
    \             \n     |--------------------------------------|                \
    \     \n     | Destination Address Length Indicator |     10              \n \
    \    |--------------------------------------|                     \n     |   \
    \      Destination Address          |     11 through m-1  \n     |--------------------------------------|\
    \                     \n     |    Source Address Length Indicator   |      m \
    \             \n     |--------------------------------------|                \
    \     \n     |            Source Address            |     m+1 through n-1 \n \
    \    |--------------------------------------|                     \n     |   \
    \      Data Unit Identifier         |     n,n+1           \n     |--------------------------------------|\
    \                     \n     |            Segment Offset            |     n+2,n+3\
    \         \n     |--------------------------------------|                    \
    \ \n     |             Total Length             |     n+4,n+5         \n     |--------------------------------------|\
    \                     \n     |                Options               |     n+6\
    \ through p   \n     |--------------------------------------|                \
    \     \n     |                 Data                 |     p+1 through z   \n \
    \    +--------------------------------------+                     \n         \
    \            Figure 7-7.  PDU Header Format\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ 7.8.1.1 Fixed Part\n    1) Network Layer Protocol Identifier   See Section 7.2.2.\n\
    \    2) Length Indicator                    See Section 7.2.3.\n    3) Version/Protocol\
    \ Id Extension       See Section 7.2.4.\n    4) Lifetime                     \
    \       See Section 7.2.5.\n    5) SP, MS, E/R                         See Section\
    \ 7.2.6.\n    6) Type Code                           See Section 7.2.7.\n    7)\
    \ Segment Length                      See Section 7.2.8.\n    8) Checksum    \
    \                        See Section 7.2.9.\n   7.8.1.2 Addresses\n    See Section\
    \ 7.3.\n   7.8.1.3 Segmentation\n    See Section 7.4.\n   7.8.1.4 Options\n  \
    \  See Section 7.5.\n   7.8.1.5 Data\n    See Section 7.7.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 7.9\
    \ Inactive Network Layer Protocol\n                                          \
    \    Octet         \n            +-----------------------------+             \
    \    \n            |  Network Layer Protocol Id  |     1           \n        \
    \    |-----------------------------|                 \n            |         \
    \  Data              |     2 through n \n            +-----------------------------+\
    \                 \n              Figure 7-9.  Inactive Network Layer Protocol\n\
    \  7.9.1 Network Layer Protocol Id\n   The value of the Network Layer Protocol\
    \ Identifier field is binary\n   zero (0000 0000).\n  7.9.2 Data Field\n   See\
    \ Section 7.7.\n   The length of the NS_Userdata parameter is constrained to be\
    \ less\n   than or equal to the value of the length of the SN_Userdata parameter\n\
    \   minus one.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 7.10\
    \ Error Report PDU (ER)\n  7.10.1 Structure\n                                \
    \                  Octet           \n     +--------------------------------------+\
    \                     \n     |   Network Layer Protocol Identifier  |       1\
    \             \n     |--------------------------------------|                \
    \     \n     |           Length Indicator           |       2             \n \
    \    |--------------------------------------|                     \n     |   \
    \  Version/Protocol Id Extension    |       3             \n     |--------------------------------------|\
    \                     \n     |               Lifetime               |       4\
    \             \n     |--------------------------------------|                \
    \     \n     |SP|MS|E/R|       Type                 |       5             \n \
    \    |--------------------------------------|                     \n     |   \
    \          Segment Length           |      6,7            \n     |--------------------------------------|\
    \                     \n     |                Checksum              |      8,9\
    \            \n     |--------------------------------------|                 \
    \    \n     | Destination Address Length Indicator |      10             \n  \
    \   |--------------------------------------|                     \n     |    \
    \     Destination Address          |     10 through m-1  \n     |--------------------------------------|\
    \                     \n     |     Source Address Length Indicator  |       m\
    \             \n     |--------------------------------------|                \
    \     \n     |             Source Address           |     m+1 through n-1 \n \
    \    |--------------------------------------|                     \n     |   \
    \       Data Unit Identifier        |     n,n+1           \n     |--------------------------------------|\
    \                     \n     |             Segment Offset           |     n+2,n+3\
    \         \n     |--------------------------------------|                    \
    \ \n     |              Total Length            |     n+4,n+5         \n     |--------------------------------------|\
    \                     \n     |                Options               |     n+6\
    \ through p-1 \n     |--------------------------------------|                \
    \     \n     |           Reason for Discard         |     p through q-1   \n \
    \    |--------------------------------------|                     \n     |   \
    \    Error Report Data Field        |       z             \n     +--------------------------------------+\
    \                     \n                     Figure 7-10.  Error Report PDU\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ 7.10.1.1 Fixed Part\n    The fixed part of the Error Report Protocol Data Unit\
    \ is set as\n    though this is a new (Initial) PDU. Thus, references are provided\
    \ to\n    precious sections describing the composition of the fields\n    comprising\
    \ the fixed part:\n    1) Network Layer Protocol Identifier   See Section 7.2.2.\n\
    \    2) Length Indicator                    See Section 7.2.3.\n    3) Version/Protocol\
    \ Id Extension       See Section 7.2.4.\n    4) Lifetime                     \
    \       See Section 7.2.5.\n    5) SP, MS, E/R                         See Section\
    \ 7.2.6.\n    6) Type Code                           See Section 7.2.7.\n    7)\
    \ Segment Length                      See Section 7.2.8.\n    8) Checksum    \
    \                        See Section 7.2.9.\n   7.10.1.2 Addresses\n    See Section\
    \ 7.3.\n    The Destination Address specifies the original source of the\n   \
    \ discarded PDU. The Source Address specifies the intermediate system\n    or\
    \ end system network-entity initiating the Error Report PDU.\n   7.10.1.3 Segmentation\n\
    \    See Section 7.4.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ 7.10.1.4 Options\n    See Section 7.5.\n   7.10.1.5 Reason for Discard\n   \
    \ This parameter is only valid for the Error Report PDU. It provides a\n    report\
    \ on the discarded protocol data unit.\n    Parameter Code:\n     1100 0001\n\
    \    Parameter Length:\n     two octets\n     type of error encoded in binary:\n\
    \      0000 0000:  Reason not specified.\n      0000 0001:  Protocol Procedure\
    \ Error.\n                  other than below:\n      0000 0010:  Incorrect checksum.\n\
    \      0000 0011:  PDU discarded due to congestion.\n      0000 0100:  Header\
    \ syntax error (header cannot\n                  be parsed).\n      0000 0101:\
    \  Segmentation is needed but is not\n                  permitted.\n      1000\
    \ xxxx:  Addressing Error:\n                  0000 0000:  Destination Address\n\
    \                              Unreachable.\n                  1000 0001:  Destination\
    \ Address\n                              Unknown.\n      1001 xxxx:  Source Routing\
    \ Error:\n                  1001 0000:  Unspecified Source\n                 \
    \             Routing error.\n                  1001 0001:  Syntax error in Source\n\
    \                              Routing field.\n                  1001 0010:  Unknown\
    \ Address in\n                              Source Routing field.\n          \
    \        1001 0011:  Path not acceptable.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \    1010 xxxx:  Lifetime Expiration:\n                  1010 0000:  Lifetime\
    \ expired while\n                              data unit in transit.\n       \
    \           1010 0001:  Lifetime expired\n                              during\
    \ reassembly.\n      1011 xxxx:  PDU discarded due to unsupported\n          \
    \        option:\n                  1011 0000:  unsupported option not\n     \
    \                         specified.\n                  1011 0001:  unsupported\
    \ padding\n                              option.\n                  1011 0010:\
    \  unsupported security\n                              option.\n             \
    \     1011 0011:  unsupported source\n                              routing option.\n\
    \                  1011 0100:  unsupported recording\n                       \
    \       of route option.\n                  1011 0101:  unsupported QoS\n    \
    \                          Maintenance option.\n     The second octet contains\
    \ a pointer to the field in the associated\n     discarded PDU which caused the\
    \ error. If no one particular field\n     can be associated with the error, then\
    \ this field contains the\n     value of zero.\n   7.10.1.6 Error Report Data\
    \ Field\n    This field provides all or a portion of the discarded PDU. The\n\
    \    octets comprising this field contain the rejected or discarded PDU\n    up\
    \ to and including the octet which caused the rejection/discard.\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: 8  FORMAL DESCRIPTION
  contents:
  - "8  FORMAL DESCRIPTION\n The operation of the protocol is modelled as a finite\
    \ state automaton\n governed by a state variable with three values. The behavior\
    \ of the\n automaton is defined with respect to individual independent Protocol\n\
    \ Data Units. A transition of the automaton is prompted by the occurrence\n of\
    \ an atomic event at one of three interfaces:\n  1) an interface to the Transport\
    \ Layer, defined by the service\n      primitives of the Addendum to the Network\
    \ Service Definition\n      Covering Connectionless-mode Transmission;\n  2) an\
    \ interface to the subnetwork service provider, defined by the\n      SN_UNITDATA\
    \ primitive of Section 5.5 of this Standard;\n  3) an interface to an implementation-dependent\
    \ timer function defined\n      by the TIMER primitives described in Section 5.6\
    \ of this Standard.\n In addition, a transition of the automaton may be prompted\
    \ by the\n occurrence of a condition of the automaton.\n The atomic events are\
    \ defined in Section 8.2. The occurrence of an\n atomic event is not in itself\
    \ sufficient to cause a transition to take\n place; other conditions, called \"\
    enabling conditions\" may also have to\n be met before a particular transition\
    \ can take place. Enabling\n conditions are boolean expressions that depend on\
    \ the values of\n parameters associated with the corresponding atomic event (that\
    \ is, the\n parameters of some primitive), and on the values of locally maintained\n\
    \ variables.\n More than one enabling condition -- and therefore, more than one\n\
    \ possible transition -- may be associated with a single atomic event. In\n every\
    \ such case, the enabling conditions are mutually exclusive, so\n that for any\
    \ given combination of atomic event and parameter values,\n only one state transition\
    \ can take place.\n Associated with each transition is an action, or \"output.\"\
    \ Actions\n consist of changes to the values of local variables and the sequential\n\
    \ performance of zero or more functions. The operation of the finite\n state automaton\
    \ is completely specified in Section 8.3 by defining the\n action associated with\
    \ every possible transition.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n 8.1\
    \  Values of the State Variable\n  The protocol state variable has three values:\n\
    \  1)  INITIAL       The automaton is created in the INITIAL state.  No\n    \
    \                transition may carry the automaton into the INITIAL\n       \
    \             state.\n  2)  REASSEMBLING  The automaton is in the REASSEMBLING\
    \ state for the\n                    period in which it is assembling PDU segments\
    \ into a\n                    complete PDU.\n  3)  CLOSED        The final state\
    \ of the automaton is the  CLOSED\n                    state.  When the automaton\
    \ enters the CLOSED state\n                    it ceases to exist.\n 8.2  Atomic\
    \ Events\n  An atomic event is the transfer of a unit of information across an\n\
    \  interface.  The description of an atomic event specifies a primitive\n  (such\
    \ as an N_UNITDATA.Request), and the service boundary at which it\n  is invoked\
    \ (such as the Network Service boundary). The direction of\n  information flow\
    \ across the boundary is implied by the definition of\n  each of the primitives.\n\
    \  8.2.1  N.UNITDATA_request and N.UNITDATA_indication\n   The N.UNITDATA_request\
    \ and N.UNITDATA_indication atomic events occur\n   at the Network Service boundary.\
    \ They are defined by the Addendum to\n   the Network Service Definition Covering\
    \ Connectionless Data\n   Transmission (ISO 8348/DAD1).\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ N.UNITDATA_request    (NS Source_Address,\n                          NS_Destination_Address,\n\
    \                          NS_Quality_of_Service,\n                          NS_Userdata)\n\
    \   N.UNITDATA_indication (NS_Source_Address,\n                          NS_Destination_Address,\n\
    \                          NS_Quality_of_Service, NS_Userdata)\n   The     parameters\
    \     of     the     N.UNITDATA_request      and\n   N.UNITDATA_indication  are\
    \  collectively  referred  to as Network\n   Service Data Unit (NSDUs).\n  8.2.2\
    \  SN.UNITDATA_request and SN.UNITDATA_indication\n   The SN.UNITDATA_request\
    \ and SN.UNITDATA_indication atomic events\n   occur at the interface between\
    \ the Protocol described herein and a\n   subnetwork service provider. They are\
    \ defined in Section 5.5 of this\n   Standard.\n   SN.UNITDATA_request    (SN_Source_Address,\n\
    \                           SN_Destination_Address,\n                        \
    \   SN_Quality_of_Service,\n                           SN_Userdata)\n   SN.UNITDATA_indication\
    \ (SN_Source_Address,\n                           SN_Destination_Address,\n  \
    \                         SN_Quality_of_Service,\n                           SN_Userdata)\n\
    \   The parameters of the SN_UNITDATA request and SN_UNITDATA Indication\n   are\
    \ collectively referred to as Subnetwork Service Data Units\n   (SNSDUs).\n  \
    \ The value of the SN_Userdata parameter may represent an Initial PDU\n   or a\
    \ Derived PDU.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  8.2.3\
    \  TIMER Atomic Events\n   The TIMER atomic events occur at the interface between\
    \ the Protocol\n   described herein and its local environment. They are defined\
    \ in\n   Section 5.6 of this Standard.\n    S.TIMER_request  (Time,\n        \
    \              Name,\n                      Subscript)\n    S.TIMER_cancel   (Name\n\
    \                      Subscript)\n    S.TIMER_response (Name,\n             \
    \         Subscript)\n 8.3  Operation of the Finite State Automation\n  The operation\
    \ of the automaton is defined by use of the formal\n  description technique and\
    \ notation specified in ISO/TC97/SC16 N1347.\n  This technique is based on an\
    \ extended finite state transition model\n  and the Pascal programming language.\
    \ The technique makes use of strong\n  variable typing to reduce ambiguity in\
    \ interpretation of the\n  specification.\n  This specification formally specifies\
    \ an abstract machine which\n  provides a single instance of the Connectionless-Mode\
    \ Network Service\n  by use of the Protocol For Providing the Connectionless-Mode\
    \ Network\n  Service. It should be emphasized that this formal specification does\n\
    \  not in any way constrain the internal operation or design of any\n  actual\
    \ implementation. For example, it is not required that the\n  program segments\
    \ contained in the state transitions will actually\n  appear as part of an actual\
    \ implementation. A formal protocol\n  specification is useful in that it goes\
    \ as far as possible to\n  eliminate any degree of ambiguity or vagueness in the\
    \ specification of\n  a protocol standard.\n  The formal specification contained\
    \ here specifies the behavior of a\n  single finite-state machine, which provides\
    \ the protocol\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  behavior\
    \ corresponding to a single independent service request. It is\n  expected that\
    \ any actual implementation will be able to handle\n  behavior corresponding to\
    \ many simultaneous finite state machines.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  8.3.1\
    \  Type and Constant Definitions\n   const\n    ZERO  = 0;\n    max_user_data\
    \ = 64512;\n   type\n    NSAP_addr_type  = ...;\n     { NSAP_addr_type defines\
    \ the data type for NSAP addresses, as\n     passed across the Network Service\
    \ Boundary. }\n    NPAI_addr_type  = ...;\n     { NPAI_addr_type defines the data\
    \ type for the addresses carried in\n     PDUs. }\n    SN_addr_type    = ...;\n\
    \     { SN_addr_type defines the data type for addresses in the\n     underlying\
    \ service used by this protocol. }\n    quality_of_service_type = ...;\n     {\
    \ Quality_of_service_type defines the data type for the QOS\n     parameter passed\
    \ across the Network Service boundary. }\n    SN_QOS_type     = ...;\n     { SN_QOS_type\
    \ defines the data type for the QOS parameter, if any,\n     passed to the underlying\
    \ service used by this protocol. }\n    data_type       = ...;\n     { Data_type\
    \ defines the data type for user data. Conceptually this\n     is equivalent to\
    \ a variable length binary string. }\n    buffer_type     = ...;\n     { Buffer_type\
    \ defines the data type for the memory resources used\n     in sending and receiving\
    \ of user data.  This provides capabilities\n     required for segmentation and\
    \ reassembly. }\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \  timer_name_type = (lifetime_timer);\n    timer_data_type = ...;\n    network_layer_protocol_id_type\
    \ = (ISO_8473_protocol_id);\n    version_id_type  = (version1);\n    pdu_tp_type\
    \      = (DT, ER);\n    options_type    = ...;\n     { Options_type defines the\
    \ data type used to store the options part\n     of the PDU header. }\n    subnet_id_type\
    \  = ...;\n     { The subnet_id_type defines the data type used to locally identify\n\
    \     a particular underlying service used by this protocol.  In general\n   \
    \  there may be multiple underlying subnetwork (or data link)\n     services.\
    \ }\n    error_type      = (NO_ERROR,\n                       TOO_MUCH_USER_DATA,\n\
    \                       PROTOCOL_PROCEDURE_ERROR,\n                       INCORRECT_CHECKSUM,\
    \ CONGESTION,\n                       SYNTAX_ERROR,\n                       SEG_NEEDED_AND_NOT_PERMITTED,\n\
    \                       DESTINATION_UNREACHABLE,\n                       DESTINATION_UNKNOWN,\n\
    \                       UNSPECIFIED_SRC_ROUTING_ERROR,\n                     \
    \  SYNTAX_ERROR_IN_SRC_ROUTING,\n                       UNKNOWN_ADDRESS_IN_SRC_ROUTING,\n\
    \                       PATH_NOT_ACCEPTABLE_IN_SRC_ROUTING,\n                \
    \       LIFETIME_EXPIRED_IN_TRANSIT,\n                       LIFETIME_EXPIRED_IN_REASSEMBLY,\n\
    \                       UNSUPPORTED_OPTION_NOT_SPECIFIED,\n                  \
    \     UNSUPPORTED_PADDING_OPTION,\n                       UNSUPPORTED_SECURITY_OPTION,\n\
    \                       UNSUPPORTED_SRC_ROUTING_OPTION,\n                    \
    \   UNSUPPORTED_RECORDING_OF_ROUTE_OPTION,\n                       UNSUPPORTED_QOS_MAINTENANCE_OPTION);\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ nsdu_type = record\n                   da   : NSAP_addr_type;\n            \
    \       sa   : NSAP_addr_type;\n                   qos  : quality_of_service_type;\n\
    \                   data : data_type;\n                end;\n   pdu_type = record\n\
    \                   nlp_id   : network_layer_protocol_id_type;\n             \
    \      hli      : integer;\n                   vp_id    : version_id_type; lifetime\
    \ : integer;\n                   sp       : boolean;\n                   ms  \
    \     : boolean;\n                   er_flag  : boolean;\n                   pdu_tp\
    \   : pdu_tp_type;\n                   seg_len  : integer;\n                 \
    \  checksum : integer;\n                   da_len   : integer;\n             \
    \      da       : NPAI_addr_type;\n                   sa_len   : integer;\n  \
    \                 sa       : NPAI_addr_type;\n                   du_id    : optional\
    \ integer;\n                   so       : optional integer;\n                \
    \   tot_len  : optional integer;\n                      { du_id, so, and tot_len\
    \ are present\n                       only if sp has the value TRUE. }\n     \
    \              options  : options_type;\n                   data     : data_type;\n\
    \                end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ route_result_type =\n               record\n            subnet_id    : subnet_id_type;\n\
    \            sn_da        : SN_addr_type;\n            sn_sa        : SN_addr_type;\n\
    \            segment_size : integer;\n         end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  8.3.2\
    \  Interface Definitions\n   channel Network_access_point (User, Provider);\n\
    \    by User:\n        UNITDATA_request\n           (NS_Destination_address :\
    \ NSAP_addr_type;\n            NS_Source_address      : NSAP_addr_type;\n    \
    \        NS_Quality_of_Service  : quality_of_service_type;\n            NS_Userdata\
    \            : data_type);\n    by Provider:\n        UNITDATA_indication\n  \
    \         (NS_Destination_address : NSAP_addr_type;\n            NS_Source_address\
    \      : NSAP_addr_type;\n            NS_Quality_of_Service  : quality_of_service_type;\n\
    \            NS_Userdata            : data_type);\n   channel Subnetwork_access_point\
    \ (User, Provider);\n    by User:\n        UNITDATA_request\n           (SN_Destination_address\
    \ : SN_addr_type;\n            SN_Source_address      : SN_addr_type;\n      \
    \      SN_Quality_of_Service  : SN_QOS_type;\n            SN_Userdata        \
    \    : pdu_type);\n    by Provider:\n        UNITDATA_indication\n           (SN_Destination_address\
    \ : SN_addr_type;\n            SN_Source_address      : SN_addr_type;\n      \
    \      SN_Quality_of_Service  : SN_QOS_type;\n            SN_Userdata        \
    \    : pdu_type);\n   channel System_access_point (User, Provider);\n    by User:\n\
    \        TIMER_request\n           (Time      : integer;\n            Name   \
    \   : timer_name_type;\n            Subscript : integer);\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \      TIMER_cancel\n             (Name      : timer_name_type;\n            \
    \  Subscript : integer);\n    by Provider:\n        TIMER_indication\n       \
    \    (Name      : timer_name_type;\n            Subscript : integer);\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  8.3.3\
    \  Formal Machine Definition\n   module Connectionless_Network_Protocol_Machine\n\
    \        (N:  Network_access_point (Provider) common queue;\n         SN: array\
    \ [subnet_id_type] of Subnetwork_access_point\n                              \
    \            (User) common queue;\n         S:  System_access_point (User) individual\
    \ queue );\n   var\n       nsdu    : nsdu_type;\n       pdu     : pdu_type;\n\
    \       rcv_buf : buffer_type;\n   state : (INITIAL, REASSEMBLING, CLOSED);\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ procedure send_error_report (error : error_type;\n                         \
    \       pdu   : pdu_type);\n    var\n        er_pdu : pdu_type;\n    begin\n \
    \    if (pdu.er_flag) then\n      begin\n       er_pdu.nlp_id   := ISO_8473_protocol_id;\n\
    \       er_pdu.vp_id    := version1;\n       er_pdu.lifetime := get_er_lifetime(pdu.sa);\n\
    \       er_pdu.sp       := get_er_seg_per(pdu);\n       er_pdu.ms       := FALSE;\n\
    \       er_pdu.er_flag  := FALSE;\n       er_pdu.pdu_tp   := ER;\n       er_pdu.da_len\
    \   := pdu.sa_len;\n       er_pdu.da       := pdu.sa;\n       er_pdu.sa_len  \
    \ := get_local_NPAI_addr_len;\n       er_pdu.sa       := get_local_NPAI_addr;\n\
    \       er_pdu.options  := get_er_options\n                          (error,\n\
    \                          er_pdu.da,\n                          pdu.options);\n\
    \       er_pdu.hli      := get_header_length\n                          (er_pdu.da_len,\
    \ er_pdu.sa_len,\n                           er_pdu.sp,\n                    \
    \       er_pdu.options);\n       er_pdu.data     := get_er_data_field(error, pdu);\n\
    \       if (er_pdu.sp) then\n                        begin\n                 \
    \          er_pdu.du_id   :=\n                           get_data_unit_id(er_pdu.da);\n\
    \                           er_pdu.so      := ZERO;\n                        \
    \   er_pdu.tot_len := er_pdu.hli +\n                           size(er_pdu.data);\n\
    \                        end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \     if (NPAI_addr_local(er_pdu.da))\n                        then\n        \
    \                   post_error_report(er_pdu)\n                        else\n\
    \                           send_pdu(er_pdu);\n      end;\n    end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ procedure send_pdu (pdu : pdu_type);\n    var\n     rte_result   : route_result_type;\n\
    \     error_code   : error_type;\n     send_buf     : buffer_type;\n     data_maxsize\
    \ : integer;\n     more_seg     : boolean;\n     sn_qos       : SN_QOS_type;\n\
    \    begin\n     send_buf := make_buffer(pdu.data);\n     more_seg := pdu.ms;\n\
    \     repeat\n      begin\n       error_code := check_parameters\n           \
    \          (pdu.hli,\n                      pdu.sp,\n                      pdu.da,\n\
    \                      pdu.options,\n                      size(pdu.data));\n\
    \       if (error_code = NO_ERROR) then\n                        begin\n     \
    \                      rte_result := route(pdu.hli,\n                        \
    \                       pdu.sp,\n                                            \
    \   pdu.da,\n                                               pdu.options,\n   \
    \                                            size(pdu.data));\n              \
    \             data_maxsize := rte_result.segment_size -\n                    \
    \       pdu.hli;\n                           pdu.data     := extract(send_buf,\n\
    \                           data_maxsize);\n                           pdu.seg_len\
    \  := pdu.hli + size(pdu.data);\n                           if (size(send_buf)\
    \ = ZERO) then\n                               pdu.ms   := more_seg\n        \
    \                   else\n                               pdu.ms   := TRUE;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \                         pdu.checksum := get_checksum(pdu);\n               \
    \            sn_qos       := get_sn_qos\n                           (rte_result.subnet_id,\n\
    \                                                       pdu.options);\n      \
    \                     out SN[rte_result.subnet_id].UNITDATA_request\n        \
    \                              (rte_result.sn_da,\n                          \
    \             rte_result.sn_sa,\n                                       sn_qos,\n\
    \                                       pdu);\n                           pdu.so\
    \ := pdu.so + data_maxsize;\n                        end\n       else if (error_code\
    \ = CONGESTION) then\n                        begin\n                        \
    \   if (send_er_on_congestion (pdu)) then\n                               send_error_report(CONGESTION,\
    \ pdu);\n                        end\n       else\n                        send_error_report(error_code,\
    \ pdu);\n      end;\n     until (size_buf(data_buf) = ZERO) or\n           (error_code\
    \ <> NO_ERROR);\n    end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ procedure allocate_reassembly_resources\n            (pdu_tot_len : integer);\n\
    \   primitive;\n    { This procedure allocates resources required for reassembly\
    \ of a\n    PDU of the specified total length.  If this requires discarding of\
    \ a\n    PDU in which the ER flag is set, then an error report is returned to\n\
    \    the source of the discarded data unit. }\n   function check_parameters\n\
    \        (hli     : integer;\n         sp      : boolean;\n         da      :\
    \ NPAI_addr_type;\n         options : options_type;\n         datalen : integer)\
    \ : error_type;\n   primitive;\n    { This function examines various parameters\
    \ associated with a PDU,\n    to determine whether forwarding of the PDU can continue.\
    \  If a\n    result of NO_ERROR is returned, then the primitive route can be\n\
    \    called to specify the route and segment size.  Otherwise this\n    function\
    \ specifies the reason that an error has occurred. }\n   function data_unit_complete\n\
    \        (buf : buffer_type) : boolean;\n   primitive;\n    { This function returns\
    \ a boolean value specifying whether the PDU\n    stored in the specified buffer\
    \ has been completely received. }\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ function elapsed_time : integer;\n   primitive;\n    { This function returns\
    \ an estimate of the time elapsed, in 500\n    microsecond increments, since the\
    \ PDU was transmitted by the\n    previous peer network entity.  This estimate\
    \ includes both time\n    spent in transit, and any time to be spent in buffers\
    \ within the\n    local system.  Although this estimate need not be precise,\n\
    \    overestimates are preferable to underestimates, as underestimating\n    the\
    \ time elapsed may defeat the intent of the lifetime function. }\n   procedure\
    \ empty_buffer\n        (buf : buffer_type);\n   primitive;\n    { This procedure\
    \ empties the specified buffer. }\n   function extract\n        (buf    : buffer_type;\n\
    \         amount : integer) : data_type;\n   primitive;\n    { This function removes\
    \ the specified amount of data from\n    the specified buffer, and returns this\
    \ data as the function\n    value. }\n   procedure free_reassembly_resources;\n\
    \   primitive;\n    { This procedure releases the resources that had been previously\n\
    \    allocated by the procedure allocate_reassembly_resources. }\n   function\
    \ get_checksum\n        (pdu : pdu_type) : integer;\n   primitive;\n    { This\
    \ function returns the 16 bit integer value to be placed in the\n    checksum\
    \ field of the PDU.  If the checksum facility is not being\n    used, then this\
    \ function returns the value zero.  The algorithm for\n    producing a correct\
    \ checksum value is specified in Annex A. }\n   function get_data_unit_id\n  \
    \      (da : NPAI_addr_type) : integer;\n   primitive;\n    { This function returns\
    \ a data unit identifier which is unique for\n    the specified destination address.\
    \ }\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ function get_er_data_field\n        (error : error_type;\n         pdu   : pdu_type)\
    \ : data_type;\n   primitive;\n    { This function returns the correct data field\
    \ for an error report,\n    based on the information that the specified PDU is\
    \ being discarded\n    due to the specified error.  The data field of an error\
    \ report must\n    include the header of the discarded PDU, and may optionally\
    \ contain\n    additional user data. }\n   function get_er_flag\n        (nsdu\
    \ : nsdu_type) : boolean;\n   primitive;\n    { This function returns a boolean\
    \ value to be used as the error\n    report flag in a PDU which transmits the\
    \ specified nsdu.  If the PDU\n    must be discarded at some future time, an error\
    \ report can be\n    returned only if this value is set to TRUE. }\n   function\
    \ get_er_lifetime\n        (da : NPAI_addr_type) : integer;\n   primitive;\n \
    \   { This function returns the lifetime value to be used for an error\n    report\
    \ being sent to the specified destination address. }\n   function get_er_options\n\
    \        (error   : error_type;\n         da      : NPAI_addr_type;\n        \
    \ options : options_type) : options_type;\n   primitive;\n    { This function\
    \ returns the options field of an error report, based\n    on the reason for discard,\
    \ and the destination address and options\n    field of the discarded PDU.  The\
    \ options field contains the reason\n    for discard option, and may contain other\
    \ optional fields. }\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ function get_er_seg_per\n        (pdu     : pdu_type) : boolean;\n   primitive;\n\
    \    { This function returns the boolean value which will be used for the\n  \
    \  segmentation permitted flag of an error report. }\n   function get_header_len\n\
    \        (da_len  : integer;\n         sa_len  : integer;\n         sp      :\
    \ boolean;\n         options : options_type) : integer;\n   primitive;\n    {\
    \ This function returns the header length, in octets.  This depends\n    upon\
    \ the lengths of the source and destination addresses, whether\n    the segmentation\
    \ part of the header is present, and the length of\n    the options part. }\n\
    \   function get_lifetime\n        (da  : NSAP_addr_type;\n         qos : quality_of_service_type)\
    \ : lifetime_type;\n   primitive;\n    { This function returns the lifetime value\
    \ to be used for a PDU,\n    based upon the destination address and requested\
    \ quality of service.\n    }\n   function get_local_NPAI_addr : NPAI_addr_type;\n\
    \   primitive;\n    { This functions returns the local address as used in the\
    \ protocol\n    header. }\n   function get_local_NPAI_addr_len : integer;\n  \
    \ primitive;\n    { This functions returns the length of the local address as\
    \ used in\n    the protocol header. }\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ function get_NPAI\n        (addr : NSAP_addr_type) : NPAI_addr_type;\n   primitive;\n\
    \    { This function returns the network address as used in the protocol\n   \
    \ header, or \"Network Protocol Addressing Information\", corresponding\n    to\
    \ the specified NSAP address. }\n   function get_NPAI_len\n        (addr : NSAP_addr_type)\
    \ : integer;\n   primitive;\n    { This function returns the length of the network\
    \ address\n    corresponding to a specified NSAP address. }\n   function get_NSAP_addr\n\
    \        (addr : NPAI_addr_type;\n         len  : integer) : NSAP_addr_type;\n\
    \   primitive;\n    { This function returns the NSAP address corresponding to\
    \ the\n    network protocol addressing information (as it appears in the\n   \
    \ protocol header) of the specified length. }\n   function get_options\n     \
    \   (da  : NSAP_addr_type;\n         qos : quality_of_service_type) : options_type;\n\
    \   primitive;\n    { This function returns the options field for a PDU, based\
    \ on the\n    requested destination address and quality of service. }\n   function\
    \ get_seg_permitted\n        (da : NSAP_addr_type;\n         qos : quality_of_service_type)\
    \ : boolean;\n   primitive;\n    { This function returns the boolean value to\
    \ be used in the\n    segmentation permitted field of a PDU.  This value may depend\
    \ upon\n    the destination address, requested quality of service, and the\n \
    \   length of the user data. }\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ function get_sn_qos\n        (subnet_id : subnet_id_type;\n          options\
    \   : options_type) : SN_QOS_type;\n   primitive;\n    { This function returns\
    \ the quality of service to be used on the\n    specified subnetwork, in order\
    \ to obtain the quality of service (if\n    any) and other parameters requested\
    \ in the options part of the PDU.\n    }\n   function get_qos\n        (options\
    \ : options_type) : quality_of_service_type;\n   primitive;\n    { This function\
    \ determines, to the extent possible, the quality of\n    service that was obtained\
    \ for a particular PDU, based upon the\n    quality of service and other information\
    \ contained in the options\n    part of the PDU header. }\n   function make_buffer\n\
    \        (data : data_type) : buffer_type;\n   primitive;\n    { This function\
    \ places the specified data in a newly created buffer.\n    The precise manner\
    \ of handling buffers is implementation specific.\n    This newly created buffer\
    \ is returned as the function value. }\n   procedure merge_seg\n        (buf \
    \  : buffer_type;\n         so    : integer;\n         data  : data_type);\n \
    \  primitive;\n    { This procedure merges the specified data into the specified\n\
    \    buffer, based on the specified segment offset of the data. }\n   function\
    \ NPAI_addr_local\n        (addr : NPAI_addr_type) : boolean;\n   primitive;\n\
    \    { This function returns the boolean value TRUE only if the specified\n  \
    \  network protocol addressing information specifies a local address. }\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ function NSAP_addr_local\n        (addr : NSAP_addr_type) : boolean;\n   primitive;\n\
    \    { This function returns the boolean value TRUE only if the specified\n  \
    \  NSAP address specifies a local address. }\n   procedure post_error_report\n\
    \        (er_pdu : pdu_type);\n   primitive;\n    { This procedure posts the specified\
    \ error report (ER) type PDU to\n    the appropriate local entity that handles\
    \ error reports. }\n   function route\n        (hli     : integer;\n         sp\
    \      : boolean;\n         da      : NPAI_addr_type;\n         options : options_type;\n\
    \         datalen : integer) : route_result_type;\n   primitive;\n    { This function\
    \ determines the route to be followed by a PDU\n    segment, as well as the segment\
    \ size.  Note that in general, the\n    segment size and route may be mutually\
    \ dependent.  This\n    determination is made on the basis of the header length,\
    \ the\n    segmentation permitted flag, the destination address, several\n   \
    \ parameters (such as source routing) contained in the options part of\n    the\
    \ PDU header, and the length of data.  This function returns a\n    structure\
    \ that specifies the subnetwork on which the segment should\n    be transmitted,\
    \ the source and destination addresses to be used on\n    the subnetwork, and\
    \ the segment size.  This routine may only be\n    called if the primitive function\
    \ check_parameters has already\n    determined that an error will not occur. }\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ function send_er_on_congestion\n       (pdu : pdu_type) : boolean;\n   primitive;\n\
    \    { This function returns the boolean value true if an error report\n    should\
    \ be sent when the indicated data unit is discarded due to\n    congestion.  Note\
    \ that if the value true is returned, then the\n    er_flag field of the discarded\
    \ data unit must still be checked\n    before an error report can be sent. }\n\
    \   function size\n       (data : data_type) : integer;\n   primitive;\n    {\
    \ This function returns the length, in octets, of the specified\n    data. }\n\
    \   function size_buf\n       (buf : buffer_type) : integer;\n   primitive;\n\
    \    { This function returns the length, in octets, of the data contained\n  \
    \  in the specified buffer. }\n   initialize\n    begin\n        state to INITIAL;\n\
    \    end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ trans  (* begin transitions *)\n   from INITIAL  to  CLOSED\n   when      N.UNITDATA_request\n\
    \   provided  not NSAP_addr_local(NS_Destination_Address)\n   begin\n     nsdu.da\
    \   := NS_Destination_Address;\n     nsdu.sa   := NS_Source_Address;\n     nsdu.qos\
    \  := NS_Quality_o  _Service;\n     nsdu.data := NS_Userdata;\n     pdu.nlp_id\
    \   := ISO_8473_protocol_id;\n     pdu.vp_id    := version1;\n     pdu.lifetime\
    \ := get_lifetime(nsdu.da, nsdu.qos);\n     pdu.sp       := get_seg_permitted(nsdu.da,\
    \ nsdu.qos);\n     pdu.ms       := FALSE;\n     pdu.er_flag  := get_er_flag(nsdu);\n\
    \     pdu.pdu_tp   := DT;\n     pdu.da_len   := get_NPAI_len(nsdu.da);\n     pdu.da\
    \       := get_NPAI(nsdu.da);\n     pdu.sa_len   := get_NPAI_len(nsdu.sa);\n \
    \    pdu.sa       := get_NPAI(nsdu.sa);\n     pdu.options  := get_options(nsdu.da,\
    \ nsdu.qos);\n     pdu.data     := nsdu.data;\n     pdu.hli      := get_header_len(pdu.da_len,\n\
    \                                    pdu.sa_len,\n                           \
    \         pdu.sp,\n                                    pdu.options);\n     if\
    \ (pdu.sp) then\n           begin\n             pdu.du_id    := get_data_unit_id(pdu.da);\n\
    \             pdu.so       := ZERO;\n             pdu.tot_len  := pdu.hli  + \
    \ size(pdu.data);\n           end;\n     if (size(pdu.data) > max_user_data) then\n\
    \           send_error_report(TOO_MUCH_USER_DATA, pdu)\n     else\n          \
    \ send_pdu(pdu);\n   end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ from INITIAL  to  CLOSED\n   when      N.UNITDATA_request\n   provided  NSAP_addr_local(NS_Destination_Address)\n\
    \   begin\n     nsdu.da   := NS_Destination_Address;\n     nsdu.sa   := NS_Source_Address;\n\
    \     nsdu.qos  := NS_Quality_of_Service;\n     nsdu.data := NS_Userdata;\n  \
    \   out N.UNITDATA_indication\n         (nsdu.da, nsdu.sa, nsdu.qos, nsdu.data);\n\
    \   end;\n   from INITIAL  to  CLOSED\n   when      SN[subnet_id].UNITDATA_indication\n\
    \   provided  NPAI_addr_local(SN_Userdata.da)  and\n             SN_Userdata.so\
    \       =  ZERO     and\n             not  SN_Userdata.ms\n   begin\n     pdu\
    \ := SN_Userdata;\n     if (pdu.pdu_tp = DT) then\n         out N.UNITDATA_indication\n\
    \            (get_NSAP_addr(pdu.da_len, pdu.da),\n             get_NSAP_addr(pdu.sa_len,\
    \ pdu.sa),\n             get_qos(pdu.options),\n             pdu.data)\n     else\n\
    \         post_error_report(pdu);\n   end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ from INITIAL  to  REASSEMBLING\n   when      SN[subnet_id].UNITDATA_indication\n\
    \   provided  NPAI_addr_local(SN_Userdata.da)    and\n             ((SN_Userdata.so\
    \ > ZERO) or (SN_Userdata.ms))\n   begin\n     pdu := SN_Userdata;\n     allocate_reassembly_resources(pdu.tot_len);\n\
    \     empty_buffer(rcv_buf);\n     merge_seg\n        (rcv_buf,\n         pdu.so,\n\
    \         pdu.data);\n     out S.TIMER_request\n        (pdu.lifetime,\n     \
    \    lifetime_timer,\n         ZERO);\n   end;\n   from INITIAL  to  CLOSED\n\
    \   when      SN[subnet_id].UNITDATA_indication\n   provided  not NPAI_addr_local(SN_Userdata.da)\n\
    \   begin\n     pdu := SN_Userdata;\n     if (pdu.lifetime > elapsed_time) then\n\
    \       begin\n         pdu.lifetime := pdu.lifetime - elapsed_time;\n       \
    \  send_pdu(pdu);\n       end\n   else\n       send_error_report(LIFETIME_EXPIRED,\
    \ pdu);\n   end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ from REASSEMBLING  to  REASSEMBLING\n   when      SN[subnet_id].UNITDATA_indication\n\
    \   provided  (SN_Userdata.du_id   = pdu.du_id)   and\n             (SN_Userdata.da_len\
    \  = pdu.da_len)  and\n             (SN_Userdata.da      = pdu.da)      and\n\
    \             (SN_Userdata.sa_len  = pdu.sa_len)  and\n             (SN_Userdata.sa\
    \      = pdu.sa)\n   begin\n     merge_seg\n        (rcv_buf,\n         SN_Userdata.so,\n\
    \         SN_Userdata.data);\n   end;\n   from REASSEMBLING  to  CLOSED\n   provided\
    \  data_unit_complete(rcv_buf)\n   no delay\n   begin\n     if (pdu.pdu_tp = DT)\
    \ then\n         out N.UNITDATA_indication\n            (get_NSAP_addr(pdu.da_len,\
    \ pdu.da),\n             get_NSAP_addr(pdu.sa_len, pdu.sa),\n             get_qos(pdu.options),\n\
    \             extract (rcv_buf, size_buf(rcv_buf)))\n    else\n        post_error_report(pdu);\n\
    \    out S.TIMER_cancel(lifetime_timer,ZERO);\n    free_reassembly_resources;\n\
    \   end;\n   from REASSEMBLING  to  CLOSED\n   when      S.TIMER_indication\n\
    \   begin\n     send_error_report(LIFETIME_EXPIRED, pdu);\n   end;\n"
- title: RFC 926                                                    December 1984
  contents:
  - 'RFC 926                                                    December 1984

    '
- title: 9  CONFORMANCE
  contents:
  - "9  CONFORMANCE\n For conformance to this International Standard, the ability\
    \ to\n originate, manipulate, and receive PDUs in accordance with the full\n protocol\
    \ (as opposed to the \"non-segmenting\" or \"Inactive Network Layer\n Protocol\"\
    \ subsets) is required.\n Additionally, the provision of the optional functions\
    \ described in\n Section 6.17 and enumerated in Table 9-1 must meet the requirements\n\
    \ described therein.\n Additionally, conformance to the Standard requires adherence\
    \ to the\n formal description of Section 8 and to the structure and encoding of\n\
    \ PDUs of Section 7.\n If and only if the above requirements are met is there\
    \ conformance to\n this International Standard.\n 9.1  Provision of Functions\
    \ for Conformance\n  The following table categorizes the functions in Section\
    \ 6 with\n  respect to the type of system providing the function:\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  +---------------------------------------------------------+\n\
    \  | Function                   |  Send  | Forward | Receive |\n  |---------------------------------------------------------|\n\
    \  | PDU Composition            |   M    |    -    |    -    |\n  | PDU Decomposition\
    \          |   M    |    -    |    M    |\n  | Header Format Analysis     |  \
    \ -    |    M    |    M    |\n  | PDU Lifetime Control       |   -    |    M \
    \   |    I    |\n  | Route PDU                  |   -    |    M    |    -    |\n\
    \  | Forward PDU                |   M    |    M    |    -    |\n  | Segment PDU\
    \                |   M    | (note 1)|    -    |\n  | Reassemble PDU          \
    \   |   -    |    I    |    M    |\n  | Discard PDU                |   -    |\
    \    M    |    M    |\n  | Error Reporting            |   -    |    M    |   \
    \ M    |\n  | PDU Header Error Detection |   M    |    M    |    M    |\n  | Padding\
    \                    |(note 2)| (note 2)| (note 2)|\n  | Security            \
    \       |   -    | (note 3)| (note 3)|\n  | Complete Source Routing    |   - \
    \   | (note 3)|    -    |\n  | Partial Source Routing     |   -    | (note 4)|\
    \    -    |\n  | Record Route               |   -    | (note 4)|    -    |\n \
    \ | QoS Maintenance            |   -    | (note 4)|    -    |\n  +---------------------------------------------------------+\n\
    \                Table 9-1.  Categorization of Functions\n  +---------------------------------------------------------+\n\
    \  | KEY:                                                    |\n  |       M :\
    \ Mandatory Function; must be implemented       |\n  |       - : Not applicable\
    \                                |\n  |       I : Implementation option, as described\
    \ in text   |\n  +---------------------------------------------------------+\n\
    \  Notes:\n   1)  The Segment PDU function is in general mandatory for an\n  \
    \     intermediate system. However, a system which is to be connected\n      \
    \ only to subnetworks all offering the same maximum SNSDU size\n       (such as\
    \ identical Local Area Networks) will not need to perform\n       this function\
    \ and therefore does not need to implement it.\n       If this function is not\
    \ implemented, this shall be stated as part\n       of the specification of the\
    \ implementation.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ 2)  The correct treatment of the padding function requires no\n       processing.\
    \ A conforming implementation shall support the\n       function, to the extent\
    \ of ignoring this parameter wherever it\n       may appear.\n   3)  This function\
    \ may or may not be supported. If an implementation\n       does not support this\
    \ function, and the function is selected by a\n       PDU, then the PDU shall\
    \ be discarded, and an ER PDU shall be\n       generated and forwarded to the\
    \ originating network-entity if the\n       Error Report flag is set.\n   4) \
    \ This function may or may not be supported. If an implementation\n       does\
    \ not support this function, and the function is selected by a\n       PDU, then\
    \ the function is not provided and the PDU is processed\n       exactly as though\
    \ the function was not selected. The PDU shall\n       not be discarded.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \                              ANNEXES\n (These annexes are provided for information\
    \ for implementors and are\n not an integral part of the body of the Standard.)\n\
    \                ANNEX A.  SUPPORTING TECHNICAL MATERIAL\n A.1  Data Unit Lifetime\n\
    \  There are two primary purposes of providing a PDU lifetime capability\n  in\
    \ the ISO 8473 Protocol. One purpose is to ensure against unlimited\n  looping\
    \ of protocol data units. Although the routing algorithm should\n  ensure that\
    \ it will be very rare for data to loop, the PDU lifetime\n  field provides additional\
    \ assurance that loops will be limited in\n  extent.\n  The other important purpose\
    \ of the lifetime capability is to provide\n  for a means by which the originating\
    \ network entity can limit the\n  Maximum NSDU lifetime. ISO Transport Protocol\
    \ Class 4 assumes that\n  there is a particular Maximum NSDU Lifetime in order\
    \ to protect\n  against certain error states in the connection establishment and\n\
    \  termination phases. If a TPDU does not arrive within this time, then\n  there\
    \ is no chance that it will ever arrive. It is necessary to make\n  this assumption,\
    \ even if the Network Layer does not guarantee any\n  particular upper bound on\
    \ NSDU lifetime. It is much easier for\n  Transport Protocol Class 4 to deal with\
    \ occasional lost TPDUs than to\n  deal with occasional very late TPDUs. For this\
    \ reason, it is\n  preferable to discard very late TPDUs than to deliver them.\
    \ Note that\n  NSDU lifetime is not directly associated with the retransmission\
    \ of\n  lost TPDUs, but relates to the problem of distinguishing old\n  (duplicate)\
    \ TPDUs from new TPDUs.\n  Maximum NSDU Lifetime must be provided to transport\
    \ protocol entity in\n  units of time; a transport entity cannot count \"hops\"\
    . Thus NSDU\n  lifetime must be calculated in units of time in order to be useful\
    \ in\n  determining Transport timer values.\n  In the absence of any guaranteed\
    \ bound, it is common to simply guess\n  some value which seems like a reasonable\
    \ compromise. In essence one is\n  simply assuming that \"surely no TPDU would\
    \ ever take more than 'x'\n  seconds to traverse the network.\" This value is\
    \ probably chosen by\n  observation of past performance, and may\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  vary\
    \ with source and destination.\n  Three possible ways to deal with the requirement\
    \ for a limit on the\n  maximum NSDU lifetime are: (1) specify lifetime in units\
    \ of time,\n  thereby requiring intermediate systems to decrement the lifetime\
    \ field\n  by a value which is an upper bound on the time spent since the\n  previous\
    \ intermediate system, and have the Network Layer discard\n  protocol data units\
    \ whose lifetime has expired; (2) provide a\n  mechanism in the Transport Layer\
    \ to recognize and discard old TPDUs;\n  or (3) ignore the problem, anticipating\
    \ that the resulting\n  difficulties will be rare. Which solution should be followed\
    \ depends\n  in part upon how difficult it is to implement solutions (1) and (2),\n\
    \  and how strong the transport requirement for a bounded time to live\n  really\
    \ is.\n  There is a problem with solution (2) above, in that transport entities\n\
    \  are inherently transient. In case of a computer system outage or other\n  error,\
    \ or in the case where one of the two endpoints of a connection\n  closes without\
    \ waiting for a sufficient period of time (approximately\n  twice Maximum NSDU\
    \ Lifetime), it is possible for the Transport Layer\n  to have no way to know\
    \ whether a particular TPDU is old unless\n  globally synchronized clocks are\
    \ used (which is unlikely). On the\n  other hand, it is expected that intermediate\
    \ systems will be\n  comparatively stable. In addition, even if intermediate systems\
    \ do\n  fail and resume processing without memory of the recent past, it will\n\
    \  still be possible (in most instances) for the intermediate system to\n  easily\
    \ comply with lifetime in units of time, as discussed below.\n  It is not necessary\
    \ for each intermediate system to subtract a precise\n  measure of the time that\
    \ has passed since an NPDU (containing the TPDU\n  or a segment thereof) has left\
    \ the previous intermediate system. It is\n  sufficient to subtract an upper bound\
    \ on the time taken. In most\n  cases, an intermediate system may simply subtract\
    \ a constant value\n  which depends upon the typical near-maximum delays that\
    \ are\n  encountered in a specific subnetwork. It is only necessary to make an\n\
    \  accurate estimate on a per NPDU basis for those subnetworks which have\n  both\
    \ a relatively large maximum delay, and a relatively large\n  variation in delay.\n\
    \  As an example, assume that a particular local area network has short\n  average\
    \ delays, with overall delays generally in the 1 to 5\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  millisecond\
    \ range and with occasional delays up to 20 milliseconds. In\n  this case, although\
    \ the relative range in delays might be large (a\n  factor of 20), it would still\
    \ not be necessary to measure the delay\n  for actual NPDUs. A constant value\
    \ of 20 milliseconds (or more) can be\n  subtracted for all delays ranging from\
    \ .5 seconds to .6 seconds (.5\n  seconds for the propagation delay, 0 to .1 seconds\
    \ for queueing delay)\n  then the constant value .6 seconds could be used.\n \
    \ If a third subnetwork had normal delays ranging from .1 to 1 second,\n  but\
    \ occasionally delivered an NPDU after a delay of 15 seconds, the\n  intermediate\
    \ system attached to this subnetwork might be required to\n  determine how long\
    \ it has actually take the PDU to transit the\n  subnetwork. In this last example,\
    \ it is likely to be more useful to\n  have the intermediate systems determine\
    \ when the delays are extreme ad\n  discard very old NPDUs, as occasional large\
    \ delays are precisely what\n  causes the Transport Protocol the most trouble.\n\
    \  In addition to the time delay within each subnetwork, it is important\n  to\
    \ consider the time delay within intermediate systems. It should be\n  relatively\
    \ simple for those gateways which expect to hold on to some\n  data-units for\
    \ significant periods of time to decrement the lifetime\n  appropriately.\n  Having\
    \ observed that (i) the Transport Protocol requires Maximum NSDU\n  to be calculated\
    \ in units of time; (ii) in the great majority of\n  cases, it is not difficult\
    \ for intermediate systems to determine a\n  valid upper bound on subnetwork transit\
    \ time; and (iii) those few\n  cases where the gateways must actually measure\
    \ the time take by a NPDU\n  are precisely the cases where such measurement truly\
    \ needs to be made,\n  it can be concluded that NSDU lifetime should in fact be\
    \ measured in\n  units of time, and that intermediate systems should required\
    \ to\n  decrement the lifetime field of the ISO 8473 Protocol by a value which\n\
    \  represents an upper bound on the time actually taken since the\n  lifetime\
    \ field was last decremented.\n A.2  Reassembly Lifetime Control\n  In order to\
    \ ensure a bound on the lifetime of NSDUs, and to\n  effectively manage reassembly\
    \ buffers in the Network Layer, the\n  Reassembly Function described in Section\
    \ 6 must control the\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  lifetime\
    \ of segments representing partially assembled PDUs. This annex\n  discusses methods\
    \ of bounding reassembly lifetime and suggests some\n  implementation guidelines\
    \ for the reassembly function.\n  When segments of a PDU arrive at a destination\
    \ network-entity, they\n  are buffered until an entire PDU is received, assembled,\
    \ and passed to\n  the PDU Decomposition Function. The connectionless Internetwork\n\
    \  Protocol does not guarantee the delivery of PDUs; hence, it is\n  possible\
    \ for some segments of a PDU to be lost or delayed such that\n  the entire PDU\
    \ cannot be assembled in a reasonable length of time. In\n  the case of loss of\
    \ a PDU \"segment\", for example, this could be\n  forever. There are a number\
    \ of possible schemes to prevent this:\n   a)  Per-PDU reassembly timers,\n  \
    \ b)  Extension of the PDU Lifetime control function, and\n   c)  Coupling of\
    \ the Transport Retransmission timers.\n  Each of these methods is discussed in\
    \ the subsections which follow.\n  A.2.1  Method (a)\n   assigns a \"reassembly\
    \ lifetime\" to each PDU received and identified\n   by its Data-unit Identifier.\
    \ This is a local, real time which is\n   assigned by the reassembly function\
    \ and decremented while some, but\n   not all segments of the PDU are being buffered\
    \ by the destination\n   network-entity. If the timer expires, all segments of\
    \ the PDU are\n   discarded, thus freeing the reassembly buffers and preventing\
    \ a \"very\n   old\" PDU from being confused with a newer one bearing the same\n\
    \   Data-unit Identifier. For this scheme to function properly, the\n   timers\
    \ must be assigned in such a fashion as to prevent the\n   phenomenon of Reassembly\
    \ Interference (discussed below). In\n   particular, the following guidelines\
    \ should be followed:\n    1)  The Reassembly Lifetime must be much less than\
    \ the maximum PDU\n        lifetime of the network (to prevent the confusion of\
    \ old and new\n        data-units).\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \  2)  The lifetime should be less than the Transport protocol's\n        retransmission\
    \ timers minus the average transit time of the\n        network. If this is not\
    \ done, extra buffers are tied up holding\n        data which has already been\
    \ retransmitted by the Transport\n        Protocol. (Note that an assumption has\
    \ been made that such\n        timers are integral to the Transport Protocol,\
    \ which in some\n        sense, dictates that retransmission functions must exist\
    \ in the\n        Transport Protocol employed).\n  A.2.2  Method (b)\n   is feasible\
    \ if the PDU lifetime control function operates based on\n   real or virtual time\
    \ rather than hop-count. In this scheme, the\n   lifetime field of all PDU segments\
    \ of a Data-unit continues to be\n   decremented by the reassembly function of\
    \ the destination\n   network-entity as if the PdU were still in transit (in a\
    \ sense, it\n   still is). When the lifetime of any segment of a partially\n \
    \  reassembled PDU expires, all segments of that PDU are discarded. This\n   scheme\
    \ is attractive since the delivery behavior of the ISO 8473\n   Protocol would\
    \ be identical for segmented and unsegmented PDUs.\n  A.2.3  Method (c)\n   couples\
    \ the reassembly lifetime directly to the Transport Protocol's\n   retransmission\
    \ timers, and requires that Transport Layer management\n   make known to Network\
    \ Layer Management (and hence, the Reassembly\n   Function) the values of its\
    \ retransmission timers for each source\n   from which it expects to be receiving\
    \ traffic. When a PDU segment is\n   received from a source, the retransmission\
    \ time minus the anticipated\n   transit time becomes the reassembly lifetime\
    \ of that PDU. If this\n   timer expires before the entire PDU has been reassembled,\
    \ all\n   segments of the PDU are discarded. This scheme is attractive since it\n\
    \   has a low probability of holding PDU segments that have already been\n   retransmitted\
    \ by the source Transport-entity; it has, however, the\n   disadvantage of depending\
    \ on reliable operation of the Transport\n   Protocol to work effectively. If\
    \ the retransmission timers are not\n   set correctly, it is possible that all\
    \ PDUs would be discarded too\n   soon, and the Transport Protocol would make\
    \ no progress.\n A.3  The Power of the Header Error Detection Function\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  A.3.1\
    \  General\n   The form of the checksum used for PDU header error detection is\
    \ such\n   that it is easily calculated in software or firmware using only two\n\
    \   additions per octet of header, yet it has an error detection power\n   approaching\
    \ (but not quite equalling) that of techniques (such as\n   cyclic polynomial\
    \ checks) which involve calculations that are much\n   more time- or space-consuming.\
    \ This annex discusses the power of this\n   error detection function.\n   The\
    \ checksum consists of two octets, either of which can assume any\n   value except\
    \ zero. That is, 255 distinct values for each octet are\n   possible. The calculation\
    \ of the two octets is such that the value of\n   either is independent of the\
    \ value of the other, so the checksum has\n   a total of 255 x 255 = 65025 values.\
    \ If one considers all ways in\n   which the PDU header might be corrupted as\
    \ equally likely, then there\n   is only one chance in 65025 that the checksum\
    \ will have the correct\n   value for any particular corruption. This corresponds\
    \ to 0.0015  of\n   all possible errors.\n   The remainder of this annex considers\
    \ particular classes of errors\n   that are likely to be encountered. The hope\
    \ is that the error\n   detection function will be found to be more powerful,\
    \ or at least no\n   less powerful, against these classes as compared to errors\
    \ in\n   general.\n  A.3.2  Bit Alteration Errors\n   First considered are classes\
    \ of errors in which bits are altered, but\n   no bits are inserted nor deleted.\
    \ This section does not consider the\n   case where the checksum itself is erroneously\
    \ set to be all zero;\n   this case is discussed in section A.3.4.\n   A burst\
    \ error of length b is a corruption of the header in which all\n   of the altered\
    \ bits (no more than b in number) are within a single\n   span of consecutively\
    \ transmitted bits that is b bits long. Checksums\n   are usually expected to\
    \ do well against burst errors of a length not\n   exceeding the number of bits\
    \ in the header error detection parameter\n   (16 for the PDU header). The PDU\
    \ header error detection parameter in\n   fact fails to detect only 0.000019 \
    \ of all such errors, each distinct\n   burst error of length 16 or less being\
    \ considered to be equally\n   likely. In particular,\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ it cannot detect an 8-bit burst in which an octet of zero is altered\n   to\
    \ an octet of 255 (all bits = 1) or vice versa. Similarly, it fails\n   to detect\
    \ the swapping of two adjacent octets only if one is zero and\n   the other is\
    \ 255.\n   The PDU header error detection, as should be expected, detects all\n\
    \   errors involving only a single altered bit.\n   Undetected errors involving\
    \ only two altered bits should occur only\n   if the two bits are widely separated\
    \ (and even then only rarely). The\n   PDU header error detection detects all\
    \ double bit errors for which\n   the spacing between the two altered bits is\
    \ less than 2040 bits = 255\n   octets. Since this separation exceeds the maximum\
    \ header length, all\n   double bit errors are detected.\n   The power to detect\
    \ double bit errors is an advantage of the checksum\n   algorithm used for the\
    \ protocol, versus a simple modulo 65536\n   summation of the header split into\
    \ 16 bit fields. This simple\n   summation would not catch all such double bit\
    \ errors. In fact, double\n   bit errors with a spacing as little as 16 bits apart\
    \ could go\n   undetected.\n  A.3.3  Bit Insertion/Deletion Errors\n   Although\
    \ errors involving the insertion or deletion of bits are in\n   general neither\
    \ more nor less likely to go undetected than are all\n   other kinds of general\
    \ errors, at least one class of such errors is\n   of special concern. If octets,\
    \ all equal to either zero or 255, are\n   inserted at a point such that the simple\
    \ sum CO in the running\n   calculation (described in Annex C) happens to equal\
    \ zero, then the\n   error will go undetected. This is of concern primarily because\
    \ there\n   are two points in the calculation for which this value for the sum\
    \ is\n   not a rare happenstance, but is expected; namely, at the beginning\n\
    \   and the end. That is, if the header is preceded or followed by\n   inserted\
    \ octets all equal to zero or 255 then no error is detected.\n   Both cases are\
    \ examined separately.\n   Insertion of erroneous octets at the beginning of the\
    \ header\n   completely misaligns the header fields, causing them to be\n   misinterpreted.\
    \ In particular, the first inserted octet is\n   interpreted as the network layer\
    \ protocol identifier, probably\n   eliminating any knowledge that the data unit\
    \ is related to the\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ ISO 8473 Protocol, and thereby eliminating any attempt to perform the\n   checksum\
    \ calculation or invoking a different form of checksum\n   calculation. An initial\
    \ octet of zero is reserved for the Inactive\n   Network Layer Protocol. This\
    \ is indeed a problem but not one which\n   can be ascribed to the form of checksum\
    \ being used. Therefore, it is\n   not discussed further here.\n   Insertion of\
    \ erroneous octets at the end of the header, in the\n   absence of other errors,\
    \ is impossible because the length field\n   unequivocally defines where the header\
    \ ends. Insertion or deletion of\n   octets at the end of the header requires\
    \ an alteration in the value\n   of the octet defining the header length. Such\
    \ an alteration implies\n   that the value of the calculated sum at the end of\
    \ the header would\n   not be expected to have the dangerous value of zero and\
    \ consequently\n   that the error is just as likely to be detected as is any error\
    \ in\n   general.\n   Insertion of an erroneous octet in the middle of the header\
    \ is\n   primarily of concern if the inserted octet has either the value zero\n\
    \   or 255, and if the variable CO happens to have the value zero at this\n  \
    \ point. In most cases, this error will completely destroy the parsing\n   of\
    \ the header, which will cause the data unit to e discarded. In\n   addition,\
    \ in the absence of any other error, the last octet of the\n   header will be\
    \ thought to be data. This in turn will cause the header\n   to end in the wrong\
    \ place. In the case where the header otherwise can\n   parse correctly, the last\
    \ field will be found to be missing. Even in\n   the case where necessary, the\
    \ length field is the padding option, and\n   therefore not necessary, the length\
    \ field for the padding function\n   will be inconsistent with the header length\
    \ field, and therefore the\n   error can be detected.\n  A.3.4  Checksum Non-calculation\
    \ Errors\n   Use of the header error detection function is optional. The choice\
    \ of\n   not using it is indicated by a checksum parameter value of zero. This\n\
    \   creates the possibility that the two octets of the checksum parameter\n  \
    \ (neither of which is generated as being zero) could both be altered\n   to zero.\
    \ This would in effect be an error not detected by the\n   checksum since the\
    \ check would not be made. One of three\n   possibilities exists:\n    1)  A burst\
    \ error of length sixteen (16) which sets the entire\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \  checksum to zero. Such an error could not be detected; however, it\n      \
    \  requires a particular positioning of the burst within the\n        header.\
    \ [A calculation of its effect on overall detectability of\n        burst errors\
    \ depends upon the length of the header.]\n    2)  All single bit errors are detected.\
    \ Since both octets of the\n        checksum field must be non-zero when the checksum\
    \ is being used,\n        no single bit error can set the checksum to zero.\n\
    \    3)  Where each of the two octets of the checksum parameter has a\n      \
    \  value that is a power of two, such that only one bit in each\n        equals\
    \ one (1), then a zeroing of the checksum parameter could\n        result in an\
    \ undetected double bit error. Furthermore, the two\n        altered bits have\
    \ a separation of less than sixteen (16), and\n        could be consecutive. This\
    \ is clearly a decline from the\n        complete detectability previously described.\n\
    \   Where a particular administration is highly concerned about the\n   possibility\
    \ of accidental zeroing of the checksum among data units\n   within its domain,\
    \ then the administration may impose the restriction\n   that all data units whose\
    \ source or destination lie within its domain\n   must make use of the header\
    \ error detection function. Any data units\n   which do not could be discarded,\
    \ nor would they be allowed outside\n   the domain. This protects against errors\
    \ that occur within the\n   domain, and would protect all data units whose source\
    \ or destination\n   lies within the domain, even where the data path between\
    \ all such\n   pairs crosses other domains (errors outside the protected domain\n\
    \   notwithstanding).\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \                    ANNEX B.  NETWORK MANAGEMENT\n The following topics are considered\
    \ to be major components of Network\n Layer management:\n  A.  Routing\n   Considered\
    \ by many to be the most crucial element of Network Layer\n   management, since\
    \ management of the Routing algorithms for networking\n   seem to be an absolutely\
    \ necessary prerequisite to a practical\n   networking scheme.\n   Routing management\
    \ consists of three parts; forwarding, decision, and\n   update. Management of\
    \ forwarding is the process of interpreting the\n   Network Layer address to properly\
    \ forward NSDUs on its next network\n   hop on a route through the network. Management\
    \ of decision is the\n   process of choosing routes for either connections or\
    \ NSDUs, depending\n   on whether the network is operating a connection-oriented\
    \ or\n   connectionless protocol. The decision component will be driven by a\n\
    \   number of considerations, not the least of which are those associated\n  \
    \ with Quality of Service. Management of update is the management\n   protocol(s)\
    \ used to exchange information among\n   intermediate-systems/network- entities\
    \ which is used in the decision\n   component to determine routes.\n   To what\
    \ extent is it desirable and/or practical to pursue a single\n   OSI network routing\
    \ algorithm and associated Management protocol(s)?\n   It is generally understood\
    \ that it is impractical to expect ISO to\n   adopt a single global routing algorithm.\
    \ On the other hand, it is\n   recognized that having no standard at all upon\
    \ which to make routing\n   decisions effectively prevents an internetwork protocol\
    \ from working\n   at all. One possible compromise would be to define the principles\
    \ for\n   the behavior of an internetwork routing algorithm. A possible next\n\
    \   step would be to specify the types of information that must be\n   propagated\
    \ among the intermediate-systems/network-entities via their\n   update procedures.\
    \ The details of the updating protocol might then be\n   left to bilateral agreements\
    \ among the cooperating administrations.\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  B.\
    \  Statistical Analysis\n   These management functions relate to the gathering\
    \ and reporting of\n   information about the real-time behavior of the global\
    \ network. They\n   consist of Data counts such as number of PDUs forwarded, entering\n\
    \   traffic, etc., and Event Counts such as topology changes, quality of\n   service\
    \ changes, etc.\n  C.  Network Control\n   These management functions are those\
    \ related to the control of the\n   global network, and possibly could be performed\
    \ by a Network Control\n   Center(s). The control functions needed are not al\
    \ all clear. Neither\n   are the issues relating to what organization(s) is/are\
    \ responsible\n   for the management of the environment. Should there be a Network\n\
    \   Control Center distinct from those provided by the subnetwork\n   administrations?\
    \ What subnetwork management information is needed by\n   the network management\
    \ components to perform their functions?\n  D.  Directory Mapping Functions\n\
    \   Does the Network layer contain a Directory function as defined in the\n  \
    \ Reference Model? Current opinion is that the Network Layer restricts\n   itself\
    \ to the function of mapping NSAP addresses to routes.\n  E.  Congestion Control\n\
    \   Does this come under the umbrella of Network Layer management? How?\n  F.\
    \  Configuration Control\n   This is tightly associated with the concepts of Resource\
    \ Management,\n   and is generally considered to be somehow concerned with the\
    \ control\n   of the resources used in the management of the global network. The\n\
    \   resources which have to be managed are Bandwidth (use of subnetwork\n   resources),\
    \ Processor (CPU), and Memory (buffers). Where is the\n   responsibility for resources\
    \ assigned, and are they appropriate for\n   standardization? It appears that\
    \ these\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ functions are tightly related to how one signals changes in Quality\n   of Service.\n\
    \  G.  Accounting\n   What entities, administrations, etc., are responsible for\
    \ network\n   accounting? How does this happen? What accounting information, if\n\
    \   any, is required from the subnetworks in order to charge for network\n   resources?\
    \ Who is charged? To what degree is this to be standardized?\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \    ANNEX C.  ALGORITHMS FOR PDU HEADER ERROR DETECTION FUNCTION\n This Annex\
    \ describes algorithm which may be used to computer, check and\n update the checksum\
    \ field of the PDU Header in order to provide the PDU\n Header Error Detection\
    \ function described in Section 6.11.\n C.1  Symbols used in algorithms\n  CO,C1\
    \  variables used in the algorithms\n  i      number (i.e., position) of an octet\
    \ within the header\n  n      number (i.e., position) of the first octet of the\
    \ checksum\n         parameter (n=8)\n  L      length of the PDU header in octets\n\
    \  X      value of octet one of the checksum parameter\n  Y      value of octet\
    \ two of the checksum parameter\n  a      octet occupying position i of the PDU\
    \ header\n C.2  Arithmetic Conventions\n  Addition is performed in one of the\
    \ two following modes:\n   a)  modulo 255 arithmetic;\n   b)  eight-bit one's\
    \ complement arithmetic in which, if any of the\n       variables has the value\
    \ minus zero (i.e., 255) it shall be\n       regarded as though it was plus zero\
    \ (i.e., 0).\n C.3  Algorithm for Generating Checksum Parameters\n  A:  Construct\
    \ the complete PDU header with the value of the checksum\n      parameter field\
    \ set to zero;\n  B:  Initialize C0 and C1 to zero;\n  C:  Process each octet\
    \ of the PDU header sequentially from i = 1 to L\n      by\n   a)  adding the\
    \ value of the octet to C0; then\n   b)  adding the value of C0 to C1;\n  D: \
    \ Calculate X = (L-8)C0 - C1 (modulo 255) and Y = (L-7) (-C0) + C1\n      (modulo\
    \ 255)\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  E:\
    \  If X = 0, set X = 255;\n  F:  If Y = 0, set Y = 255;\n  G:  Place the values\
    \ X and Y in octets 8 and 9 respectively.\n C.4  Algorithm for Checking Checksum\
    \ Parameters\n  A:  If octets 8 and 9 of PDU header both contain 0 (all bits off),\n\
    \      then the checksum calculation has succeeded; otherwise initialize\n   \
    \   C1 = 0, C0 - 0 and proceed;\n  B:  process each octet of the PDU header sequentially\
    \ from i = 1 to L\n      by\n   a)  adding the value of the octet to C0; then\n\
    \   b)  adding the value of C0 to C1;\n  C:  If, when all the octets have been\
    \ processed, C0 = C1 = 0 (modulo\n      255) then the checksum calculation has\
    \ succeeded; otherwise, the\n      checksum calculation has failed.\n C.5  Algorithm\
    \ to adjust checksum parameter when an octet is altered\n  This algorithm adjusts\
    \ the checksum when an octet (such as the\n  lifetime field) is altered. Suppose\
    \ the value in octet k is changed by\n  Z = new_value - old_value.\n  If X and\
    \ Y denote the checksum values held in octets n and n+1,\n  respectively, then\
    \ adjust X and Y as follows:\n   If X = 0 and Y = 0 do nothing, else;\n      \
    \  X := (k-n-1)Z + X (modulo 255) and\n        Y := (n-k)Z + Y   (modulo 255).\n\
    \   If X is equal to zero, then set it to 255; and\n   similarly for Y.\n  For\
    \ this Protocol, n = 8. If the octet being altered is the lifetime\n  field, k\
    \ = 4. For the case where the lifetime is decreased by 1 unit\n  (Z = -1), the\
    \ results simplify to\n"
- title: RFC 926                                                    December 1984
  contents:
  - "RFC 926                                                    December 1984\n  \
    \ X := X + 5 (modulo 255) and\n   Y := Y - 4 (modulo 255).\n   Note:\n    To derive\
    \ this result, assume that when octet k has the value Z\n    added to it then\
    \ X and Y have values ZX and ZY added to them. For\n    the checksum parameters\
    \ to satisfy the conditions of Section 6.11\n    both before and after the values\
    \ are added, the following is\n    required:\n     Z + ZX + ZY = 0 (modulo 255)\
    \ and\n     (L-k+1)Z + (L-n+1)ZX + (L-n)ZY = 0 (modulo 255).\n  Solving these\
    \ equations simultaneously yields ZX = (k-n-1)Z and ZY +\n  (m-k)Z.\n"
