- title: __initial_text__
  contents:
  - '                 Peer-to-Peer (P2P) Overlay Diagnostics

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes mechanisms for Peer-to-Peer (P2P) overlay\n\
    \   diagnostics.  It defines extensions to the REsource LOcation And\n   Discovery\
    \ (RELOAD) base protocol to collect diagnostic information\n   and details the\
    \ protocol specifications for these extensions.  Useful\n   diagnostic information\
    \ for connection and node status monitoring is\n   also defined.  The document\
    \ also describes the usage scenarios and\n   provides examples of how these methods\
    \ are used to perform\n   diagnostics.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7851.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   5\n   3.  Diagnostic Scenarios  . . . . . . . . . . . . . . . . .\
    \ . . .   5\n   4.  Data Collection Mechanisms  . . . . . . . . . . . . . . .\
    \ . .   6\n     4.1.  Overview of Operations  . . . . . . . . . . . . . . . .\
    \ .   6\n     4.2.  \"Ping-like\" Behavior: Extending Ping  . . . . . . . . .\
    \ .   8\n       4.2.1.  RELOAD Request Extension: Ping  . . . . . . . . . . .\
    \   9\n     4.3.  \"Traceroute-like\" Behavior: The PathTrack Method  . . . .\
    \   9\n       4.3.1.  New RELOAD Request: PathTrack . . . . . . . . . . . .  10\n\
    \     4.4.  Error Code Extensions . . . . . . . . . . . . . . . . . .  12\n  \
    \ 5.  Diagnostic Data Structures  . . . . . . . . . . . . . . . . .  13\n    \
    \ 5.1.  DiagnosticsRequest Data Structure . . . . . . . . . . . .  13\n     5.2.\
    \  DiagnosticsResponse Data Structure  . . . . . . . . . . .  15\n     5.3.  dMFlags\
    \ and Diagnostic Kind ID Types  . . . . . . . . . .  16\n   6.  Message Processing\
    \  . . . . . . . . . . . . . . . . . . . . .  19\n     6.1.  Message Creation\
    \ and Transmission . . . . . . . . . . . .  19\n     6.2.  Message Processing:\
    \ Intermediate Peers  . . . . . . . . .  20\n     6.3.  Message Response Creation\
    \ . . . . . . . . . . . . . . . .  21\n     6.4.  Interpreting Results  . . .\
    \ . . . . . . . . . . . . . . .  22\n   7.  Authorization through Overlay Configuration\
    \ . . . . . . . . .  23\n   8.  Security Considerations . . . . . . . . . . .\
    \ . . . . . . . .  23\n   9.  IANA Considerations . . . . . . . . . . . . . .\
    \ . . . . . . .  24\n     9.1.  Diagnostics Flag  . . . . . . . . . . . . . .\
    \ . . . . . .  24\n     9.2.  Diagnostic Kind ID  . . . . . . . . . . . . . .\
    \ . . . . .  25\n     9.3.  Message Codes . . . . . . . . . . . . . . . . . .\
    \ . . . .  26\n     9.4.  Error Code  . . . . . . . . . . . . . . . . . . . .\
    \ . . .  26\n     9.5.  Message Extension . . . . . . . . . . . . . . . . . .\
    \ . .  26\n     9.6.  XML Name Space Registration . . . . . . . . . . . . . .\
    \ .  27\n   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \  27\n     10.1.  Normative References . . . . . . . . . . . . . . . . . .  27\n\
    \     10.2.  Informative References . . . . . . . . . . . . . . . . .  28\n  \
    \ Appendix A.  Examples . . . . . . . . . . . . . . . . . . . . . .  29\n    \
    \ A.1.  Example 1 . . . . . . . . . . . . . . . . . . . . . . . .  29\n     A.2.\
    \  Example 2 . . . . . . . . . . . . . . . . . . . . . . . .  29\n     A.3.  Example\
    \ 3 . . . . . . . . . . . . . . . . . . . . . . . .  29\n   Appendix B.  Problems\
    \ with Generating Multiple Responses on Path   29\n   Acknowledgments . . . .\
    \ . . . . . . . . . . . . . . . . . . . . .  30\n   Authors' Addresses  . . .\
    \ . . . . . . . . . . . . . . . . . . . .  30\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In the last few years, overlay networks have rapidly evolved\
    \ and\n   emerged as a promising platform for deployment of new applications\n\
    \   and services in the Internet.  One of the reasons overlay networks\n   are\
    \ seen as an excellent platform for large-scale distributed systems\n   is their\
    \ resilience in the presence of failures.  This resilience has\n   three aspects:\
    \ data replication, routing recovery, and static\n   resilience.  Routing recovery\
    \ algorithms are used to repopulate the\n   routing table with live nodes when\
    \ failures are detected.  Static\n   resilience measures the extent to which an\
    \ overlay can route around\n   failures even before the recovery algorithm repairs\
    \ the routing\n   table.  Both routing recovery and static resilience rely on\
    \ accurate\n   and timely detection of failures.\n   There are a number of situations\
    \ in which some nodes in a Peer-to-\n   Peer (P2P) overlay may malfunction or\
    \ behave badly.  For example,\n   these nodes may be disabled, congested, or may\
    \ be misrouting\n   messages.  The impact of these malfunctions on the overlay\
    \ network\n   may be a degradation of quality of service provided collectively\
    \ by\n   the peers in the overlay network or an interruption of the overlay\n\
    \   services.  It is desirable to identify malfunctioning or badly\n   behaving\
    \ peers through diagnostic tools and exclude or reject them\n   from the P2P system.\
    \  Node failures may also be caused by failures of\n   underlying layers.  For\
    \ example, recovery from an incorrect overlay\n   topology may be slow when the\
    \ speed at which IP routing recovers\n   after link failures is very slow.  Moreover,\
    \ if a backbone link fails\n   and the failover is slow, the network may be partitioned,\
    \ leading to\n   partitions of overlay topologies and inconsistent routing results\n\
    \   between different partitioned components.\n   Some keep-alive algorithms based\
    \ on periodic probe and acknowledge\n   mechanisms enable accurate and timely\
    \ detection of failures of one\n   node's neighbors [Overlay-Failure-Detection],\
    \ but these algorithms by\n   themselves can only detect the disabled neighbors\
    \ using the periodic\n   method.  This may not be sufficient for the service provider\n\
    \   operating the overlay network.\n   A P2P overlay diagnostic framework supporting\
    \ periodic and on-demand\n   methods for detecting node failures and network failures\
    \ is\n   desirable.  This document describes a general P2P overlay diagnostic\n\
    \   extension to the base protocol RELOAD [RFC6940] and is intended as a\n   complement\
    \ to keep-alive algorithms in the P2P overlay itself.\n   Readers are advised\
    \ to consult [P2PSIP-CONCEPTS] for further\n   background on the problem domain.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This document uses the concepts defined in RELOAD [RFC6940].\
    \  In\n   addition, the following terms are used in the document:\n   overlay\
    \ hop:\n         One overlay hop is one portion of path between the initiator\n\
    \         node and the destination peer in a RELOAD overlay.  Each time\n    \
    \     packets are passed to the next node in the RELOAD overlay, one\n       \
    \  overlay hop occurs.\n   underlay hop:\n         An underlay hop is one portion\
    \ of the path between source and\n         destination in the IP layer.  Each\
    \ time packets are passed to\n         the next IP-layer device, an underlay hop\
    \ occurs.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"\
    SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"\
    OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
- title: 3.  Diagnostic Scenarios
  contents:
  - "3.  Diagnostic Scenarios\n   P2P systems are self-organizing, and ideally the\
    \ setup and\n   configuration of individual P2P nodes requires no network management\n\
    \   in the traditional sense.  However, users of an overlay as well as\n   P2P\
    \ service providers may contemplate usage scenarios where some\n   monitoring\
    \ and diagnostics are required.  We present a simple\n   connectivity test and\
    \ some useful diagnostic information that may be\n   used in such diagnostics.\n\
    \   The common usage scenarios for P2P diagnostics can be broadly\n   categorized\
    \ in three classes:\n   a.  Automatic diagnostics built into the P2P overlay routing\n\
    \       protocol.  Nodes perform periodic checks of known neighbors and\n    \
    \   remove those nodes from the routing tables that fail to respond\n       to\
    \ connectivity checks [Handling_Churn_in_a_DHT].  Unresponsive\n       nodes may\
    \ only be temporarily disabled, for example, due to a\n       local cryptographic\
    \ processing overload, disk processing\n       overload, or link overload.  It\
    \ is therefore useful to repeat the\n       connectivity checks to see nodes have\
    \ recovered and can be again\n       placed in the routing tables.  This process\
    \ is known as 'failed\n       node recovery' and can be optimized as described\
    \ in the paper\n       \"Handling Churn in a DHT\" [Handling_Churn_in_a_DHT].\n\
    \   b.  Diagnostics used by a particular node to follow up on an\n       individual\
    \ user complaint or failure.  For example, a technical\n       support staff member\
    \ may use a desktop sharing application (with\n       the permission of the user)\
    \ to remotely determine the health of,\n       and possible problems with, the\
    \ malfunctioning node.  Part of the\n       remote diagnostics may consist of\
    \ simple connectivity tests with\n       other nodes in the P2P overlay and retrieval\
    \ of statistics from\n       nodes in the overlay.  The simple connectivity tests\
    \ are not\n       dependent on the type of P2P overlay.  Note that other tests\
    \ may\n       be required as well, including checking the health and\n       performance\
    \ of the user's computer or mobile device and checking\n       the bandwidth of\
    \ the link connecting the user to the Internet.\n   c.  P2P system-wide diagnostics\
    \ used to check the overall health of\n       the P2P overlay network.  These\
    \ include checking the consumption\n       of network bandwidth, checking for\
    \ the presence of problem links,\n       and checking for abusive or malicious\
    \ nodes.  This is not a\n       trivial problem and has been studied in detail\
    \ for content and\n       streaming P2P overlays [Diagnostic_Framework] and has\
    \ not been\n       addressed in earlier documents.  While this is a difficult\n\
    \       problem, a great deal of information that can help in diagnosing\n   \
    \    these problems can be obtained by obtaining basic diagnostic\n       information\
    \ for peers and the network.  This document provides a\n       framework for obtaining\
    \ this information.\n"
- title: 4.  Data Collection Mechanisms
  contents:
  - '4.  Data Collection Mechanisms

    '
- title: 4.1.  Overview of Operations
  contents:
  - "4.1.  Overview of Operations\n   The diagnostic mechanisms described in this\
    \ document are primarily\n   intended to detect and locate failures or monitor\
    \ performance in P2P\n   overlay networks.  It provides mechanisms to detect and\
    \ locate\n   malfunctioning or badly behaving nodes including disabled nodes,\n\
    \   congested nodes, and misrouting peers.  It provides a mechanism to\n   detect\
    \ direct connectivity or connectivity to a specified node, a\n   mechanism to\
    \ detect the availability of specified resource records,\n   and a mechanism to\
    \ discover P2P overlay topology and the underlay\n   topology failures.\n   The\
    \ RELOAD diagnostics extensions define two mechanisms to collect\n   data.  The\
    \ first is an extension to the RELOAD Ping mechanism that\n   allows diagnostic\
    \ data to be queried from a node as well as to\n   diagnose the path to that node.\
    \  The second is a new method,\n   PathTrack, for collecting diagnostic information\
    \ iteratively.\n   Payloads for these mechanisms allowing diagnostic data to be\n\
    \   collected and represented are presented, and additional error codes\n   are\
    \ introduced.  Essentially, this document reuses the RELOAD\n   specification\
    \ [RFC6940] and extends it to introduce the new\n   diagnostics methods.  The\
    \ extensions strictly follow how RELOAD\n   specifies message routing, transport,\
    \ NAT traversal, and other RELOAD\n   protocol features.\n   This document primarily\
    \ describes how to detect and locate failures\n   including disabled nodes, congested\
    \ nodes, misrouting behaviors, and\n   underlying network faults in P2P overlay\
    \ networks through a simple\n   and efficient mechanism.  This mechanism is modeled\
    \ after the ping/\n   traceroute paradigm: ping [RFC792] is used for connectivity\
    \ checks,\n   and traceroute is used for hop-by-hop fault localization as well\
    \ as\n   path tracing.  This document specifies a \"ping-like\" mode (by\n   extending\
    \ the RELOAD Ping method to gather diagnostics) and a\n   \"traceroute-like\"\
    \ mode (by defining the new PathTrack method) for\n   diagnosing P2P overlay networks.\n\
    \   One way these tools can be used is to detect the connectivity to the\n   specified\
    \ node or the availability of the specified resource record\n   through the extended\
    \ Ping operation.  Once the overlay network\n   receives some alarms about overlay\
    \ service degradation or\n   interruption, a Ping is sent.  If the Ping fails,\
    \ one can then send a\n   PathTrack to determine where the fault lies.\n   The\
    \ diagnostic information can only be provided to authorized nodes.\n   Some diagnostic\
    \ information can be provided to all the participants\n   in the P2P overlay,\
    \ and some other diagnostic information can only be\n   provided to the nodes\
    \ authorized by the local or overlay policy.  The\n   authorization depends on\
    \ the type of the diagnostic information and\n   the administrative considerations\
    \ and is application specific.\n   This document considers the general administrative\
    \ scenario based on\n   diagnostic Kind, where a whole overlay can authorize a\
    \ certain kind\n   of diagnostic information to a small list of particular nodes\
    \ (e.g.,\n   administrative nodes).  That means if a node gets the authorization\n\
    \   to access a diagnostic Kind, it can access that information from all\n   nodes\
    \ in the overlay network.  It leaves the scenario where a\n   particular node\
    \ authorizes its diagnostic information to a particular\n   list of nodes out\
    \ of scope.  This could be achieved by extension of\n   this document if there\
    \ is a requirement in the near future.  The\n   default policy or access rule\
    \ for a type of diagnostic information is\n   \"deny\" unless specified in the\
    \ diagnostics extension document.  As\n   the RELOAD protocol already requires\
    \ that each message carries the\n   message signature of the sender, the receiver\
    \ of the diagnostics\n   requests can use the signature to identify the sender.\
    \  It can then\n   use the overlay configuration file with this signature to determine\n\
    \   which types of diagnostic information that node is authorized for.\n   In\
    \ the remainder of this section we define mechanisms for collecting\n   data,\
    \ as well as the specific protocol extensions (message\n   extensions, new methods,\
    \ and error codes) required to collect this\n   information.  In Section 5 we\
    \ discuss the format of the data\n   collected, and in Section 6 we discuss detailed\
    \ message processing.\n   It is important to note that the mechanisms described\
    \ in this\n   document do not guarantee that the information collected is in fact\n\
    \   related to the previous failures.  However, using the information\n   from\
    \ previous traversed nodes, the user (or management system) may be\n   able to\
    \ infer the problem.  Symmetric routing can be achieved by\n   using the Via List\
    \ [RFC6940] (or an alternate DHT routing algorithm),\n   but the response path\
    \ is not guaranteed to be the same.\n"
- title: '4.2.  "Ping-like" Behavior: Extending Ping'
  contents:
  - "4.2.  \"Ping-like\" Behavior: Extending Ping\n   To provide \"ping-like\" behavior,\
    \ the RELOAD Ping method is extended\n   to collect diagnostic data along the\
    \ path.  The request message is\n   forwarded by the intermediate peers along\
    \ the path and then\n   terminated by the responsible peer.  After optional local\n\
    \   diagnostics, the responsible peer returns a response message.  If an\n   error\
    \ is found when routing, an error response is sent to the\n   initiator node by\
    \ the intermediate peer.\n   The message flow of a Ping message (with diagnostic\
    \ extensions) is as\n   follows:\n    Peer A              Peer B             \
    \  Peer C             Peer D\n      |                    |                   \
    \ |                    |\n      |(1). PingReq        |                    |  \
    \                  |\n      |------------------->|(2). PingReq        |      \
    \              |\n      |                    |------------------->|(3). PingReq\
    \        |\n      |                    |                    |------------------->|\n\
    \      |                    |                    |                    |\n    \
    \  |                    |                    |<-------------------|\n      | \
    \                   |<-------------------|(4). PingAns        |\n      |<-------------------|(5).\
    \ PingAns        |                    |\n      |(6). PingAns        |        \
    \            |                    |\n      |                    |            \
    \        |                    |\n                  Figure 1: Ping Diagnostic Message\
    \ Flow\n"
- title: '4.2.1.  RELOAD Request Extension: Ping'
  contents:
  - "4.2.1.  RELOAD Request Extension: Ping\n   To extend the Ping request for use\
    \ in diagnostics, a new extension of\n   RELOAD is defined.  The structure for\
    \ a MessageExtension in RELOAD is\n   defined as:\n            struct {\n    \
    \          MessageExtensionType  type;\n              Boolean               critical;\n\
    \              opaque                extension_contents<0..2^32-1>;\n        \
    \    } MessageExtension;\n   For the Ping request extension, we define a new MessageExtensionType,\n\
    \   extension 0x2 named \"Diagnostic_Ping\", as specified in Table 4.  The\n \
    \  extension contents consists of a DiagnosticsRequest structure,\n   defined\
    \ in Section 5.1.  This extension MAY be used for new requests\n   of the Ping\
    \ method and MUST NOT be included in requests using any\n   other method.\n  \
    \ This extension is not critical.  If a peer does not support the\n   extension,\
    \ they will simply ignore the diagnostic portion of the\n   message and will treat\
    \ the message as if it were a normal ping.\n   Senders MUST accept a response\
    \ that lacks diagnostic information and\n   SHOULD NOT resend the message expecting\
    \ a reply.  Receivers who\n   receive a method other than Ping including this\
    \ extension MUST ignore\n   the extension.\n"
- title: '4.3.  "Traceroute-like" Behavior: The PathTrack Method'
  contents:
  - "4.3.  \"Traceroute-like\" Behavior: The PathTrack Method\n   We define a simple\
    \ PathTrack method for retrieving diagnostic\n   information iteratively.\n  \
    \ The operation of this request is shown below in Figure 2.  The\n   initiator\
    \ node A asks its neighbor B which is the next hop peer to\n   the destination\
    \ ID, and B returns a message with the next hop peer C\n   information, along\
    \ with optional diagnostic information for B to the\n   initiator node.  Then\
    \ the initiator node A asks the next hop peer C\n   (direct response routing [RFC7263]\
    \ or via symmetric routing) to\n   return next hop peer D information and diagnostic\
    \ information of C.\n   Unless a failure prevents the message from being forwarded,\
    \ this step\n   can be repeated until the request reaches responsible peer D for\
    \ the\n   destination ID and retrieves the diagnostic information of peer D.\n\
    \   The message flow of a PathTrack message (with diagnostic extensions)\n   is\
    \ as follows:\n   Peer-A              Peer-B               Peer-C            \
    \ Peer-D\n     |                    |                    |                   \
    \ |\n     |(1).PathTrackReq    |                    |                    |\n \
    \    |------------------->|                    |                    |\n     |(2).PathTrackAns\
    \    |                    |                    |\n     |<-------------------|\
    \                    |                    |\n     |                    |(3).PathTrackReq\
    \    |                    |\n     |--------------------|------------------->|\
    \                    |\n     |                    |(4).PathTrackAns    |     \
    \               |\n     |<-------------------|--------------------|          \
    \          |\n     |                    |                    |(5).PathTrackReq\
    \    |\n     |--------------------|--------------------|------------------->|\n\
    \     |                    |                    |(6).PathTrackAns    |\n     |<-------------------|--------------------|--------------------|\n\
    \     |                    |                    |                    |\n     \
    \           Figure 2: PathTrack Diagnostic Message Flow\n   There have been proposals\
    \ that RouteQuery and a series of Fetch\n   requests can be used to replace the\
    \ PathTrack mechanism; however, in\n   the presence of high rates of churn, such\
    \ an operation would not,\n   strictly speaking, provide identical results, as\
    \ the path may change\n   between RouteQuery and Fetch operations.  While obviously\
    \ the path\n   could change between steps of PathTrack as well, with a single\n\
    \   message rather than two messages for query and fetch, less\n   inconsistency\
    \ is likely, and thus the use of a single message is\n   preferred.\n   Given\
    \ that in a typical diagnostic scenario the peer sending the\n   PathTrack request\
    \ desires to obtain information about the current\n   path to the destination,\
    \ in the event that successive calls to\n   PathTrack return different paths,\
    \ the results should be discarded and\n   the request resent, ensuring that the\
    \ second request traverses the\n   appropriate path.\n"
- title: '4.3.1.  New RELOAD Request: PathTrack'
  contents:
  - "4.3.1.  New RELOAD Request: PathTrack\n   This document defines a new RELOAD\
    \ method, PathTrack, to retrieve the\n   diagnostic information from the intermediate\
    \ peers along the routing\n   path.  At each step of the PathTrack request, the\
    \ responsible peer\n   responds to the initiator node with requested status information.\n\
    \   Status information can include a peer's congestion state, processing\n   power,\
    \ available bandwidth, the number of entries in its neighbor\n   table, uptime,\
    \ identity, network address information, and next hop\n   peer information.\n\
    \   A PathTrack request specifies which diagnostic information is\n   requested\
    \ using a DiagnosticsRequest data structure, which is defined\n   and discussed\
    \ in detail in Section 5.1.  Base information is\n   requested by setting the\
    \ appropriate flags in the data structure in\n   the request.  If all flags are\
    \ clear (no bits are set), then the\n   PathTrack request is only used for requesting\
    \ the next hop\n   information.  In this case, the iterative mode of PathTrack\
    \ is\n   degraded to a RouteQuery method that is only used for checking the\n\
    \   liveness of the peers along the routing path.  The PathTrack request\n   can\
    \ be routed using direct response routing or other routing methods\n   chosen\
    \ by the initiator node.\n   A response to a successful PathTrackReq is a PathTrackAns\
    \ message.\n   The PathTrackAns contains general diagnostic information in the\n\
    \   payload, returned using a DiagnosticResponse data structure.  This\n   data\
    \ structure is defined and discussed in detail in Section 5.2.\n   The information\
    \ returned is determined based on the information\n   requested in the flags in\
    \ the corresponding request.\n"
- title: 4.3.1.1.  PathTrack Request
  contents:
  - "4.3.1.1.  PathTrack Request\n   The structure of the PathTrack request is as\
    \ follows:\n                           struct{\n                             \
    \  Destination destination;\n                               DiagnosticsRequest\
    \ request;\n                           }PathTrackReq;\n   The fields of the PathTrackReq\
    \ are as follows:\n   destination:  The destination that the initiator node is\
    \ interested\n      in.  This may be any valid destination object, including a\
    \ NodeID,\n      opaque ids, or ResourceID.  One example should be noted that,\
    \ for\n      debugging purposes, the initiator will use the destination ID as\n\
    \      it was used when failure happened.\n   request:  A DiagnosticsRequest,\
    \ as discussed in Section 5.1.\n"
- title: 4.3.1.2.  PathTrack Response
  contents:
  - "4.3.1.2.  PathTrack Response\n   The structure of the PathTrack response is as\
    \ follows:\n                             struct{\n                           \
    \       Destination next_hop;\n                                  DiagnosticsResponse\
    \ response;\n                              }PathTrackAns;\n   The fields of the\
    \ PathTrackAns are as follows:\n   next_hop:  The information of the next hop\
    \ node from the responding\n      intermediate peer to the destination.  If the\
    \ responding peer is\n      the responsible peer for the destination ID, then\
    \ the next_hop\n      node ID equals the responding node ID, and after receiving\
    \ a\n      PathTrackAns where the next_hop node ID equals the responding node\n\
    \      ID, the initiator MUST stop the iterative process.\n   response:  A DiagnosticsResponse,\
    \ as discussed in Section 5.2.\n"
- title: 4.4.  Error Code Extensions
  contents:
  - "4.4.  Error Code Extensions\n   This document extends the error response method\
    \ defined in the RELOAD\n   specification to support error cases resulting from\
    \ diagnostic\n   queries.  When an error is encountered in RELOAD, the Message\
    \ Code\n   0xffff is returned.  The ErrorResponse structure includes an error\n\
    \   code.  We define new error codes to report possible error conditions\n   detected\
    \ while performing diagnostics:\n      Code Value     Error Code Name\n      \
    \   0x15        Error_Underlay_Destination_Unreachable\n         0x16        Error_Underlay_Time_Exceeded\n\
    \         0x17        Error_Message_Expired\n         0x18        Error_Upstream_Misrouting\n\
    \         0x19        Error_Loop_Detected\n         0x1a        Error_TTL_Hops_Exceeded\n\
    \   The error code is returned by the upstream node before the failure\n   node.\
    \  The upstream node uses the normal ping to detect the failure\n   type and return\
    \ it to the initiator node, which will help the user\n   (initiator node) to understand\
    \ where the failure happened and what\n   kind of error happened, as the failure\
    \ may happen at the same\n   location and for the same reason when sending the\
    \ normal message and\n   the diagnostics message.\n   As defined in RELOAD, additional\
    \ information may be stored (in an\n   implementation-specific way) in the optional\
    \ error_info byte string.\n   While the specifics are obviously left to the implementation,\
    \ as an\n   example, in the case of 0x15, the error_field could be used to\n \
    \  provide additional information as to why the underlay destination is\n   unreachable\
    \ (net unreachable, host unreachable, fragmentation needed,\n   etc.).\n"
- title: 5.  Diagnostic Data Structures
  contents:
  - "5.  Diagnostic Data Structures\n   Both the extended Ping method and PathTrack\
    \ method use the following\n   common diagnostics data structures to collect data.\
    \  Two common\n   structures are defined: DiagnosticsRequest for requesting data\
    \ and\n   DiagnosticsResponse for returning the information.\n"
- title: 5.1.  DiagnosticsRequest Data Structure
  contents:
  - "5.1.  DiagnosticsRequest Data Structure\n   The DiagnosticsRequest data structure\
    \ is used to request diagnostic\n   information and has the following form:\n\
    \          enum{ (2^16-1) } DiagnosticKindId;\n          struct{\n           \
    \   DiagnosticKindId kind;\n              opaque  diagnostic_extension_contents<0..2^32-1>;\n\
    \          }DiagnosticExtension;\n          struct{\n              uint64 expiration;\n\
    \              uint64 timestamp_initiated;\n              uint64 dMFlags;\n  \
    \            uint32 ext_length;\n              DiagnosticExtension diagnostic_extensions_list<0..2^32-1>;\n\
    \           }DiagnosticsRequest;\n   The fields in the DiagnosticsRequest are\
    \ as follows:\n   expiration:  The time when the request will expire represented\
    \ as the\n      number of milliseconds elapsed since midnight Jan 1, 1970 UTC\
    \ (not\n      counting leap seconds).  This will have the same values for\n  \
    \    seconds as standard UNIX time or POSIX time.  More information can\n    \
    \  be found at \"Unix time\" in Wikipedia [UnixTime].  This value MUST\n     \
    \ have a value between 1 and 600 seconds in the future.  This value\n      is\
    \ used to prevent replay attacks.\n   timestamp_initiated:  The time when the\
    \ diagnostics request was\n      initiated, represented as the number of milliseconds\
    \ elapsed since\n      midnight Jan 1, 1970 UTC (not counting leap seconds). \
    \ This will\n      have the same values for seconds as standard UNIX time or POSIX\n\
    \      time.\n   dMFlags:  A mandatory field that is an unsigned 64-bit integer\n\
    \      indicating which base diagnostic information the request initiator\n  \
    \    node is interested in.  The initiator sets different bits to\n      retrieve\
    \ different kinds of diagnostic information.  If dMFlags is\n      set to zero,\
    \ then no base diagnostic information is conveyed in\n      the PathTrack response.\
    \  If dMFlags is set to all \"1\"s, then all\n      base diagnostic information\
    \ values are requested.  A request may\n      set any number of the flags to request\
    \ the corresponding\n      diagnostic information.\n      Note this memo specifies\
    \ the initial set of flags; the flags can\n      be extended.  The dMflags indicate\
    \ general diagnostic information.\n      The mapping between the bits in the dMFlags\
    \ and the diagnostic\n      Kind ID presented is as described in Section 9.1.\n\
    \   ext_length:  The length of the extended diagnostic request\n      information\
    \ in bytes.  If the value is greater than or equal to 1,\n      then some extended\
    \ diagnostic information is being requested on\n      the assumption this information\
    \ will be included in the response\n      if the recipient understands the extended\
    \ request and is willing\n      to provide it.  The specific diagnostic information\
    \ requested is\n      defined in the diagnostic_extensions_list below.  A value\
    \ of zero\n      indicates no extended diagnostic information is being requested.\n\
    \      The value of ext_length MUST NOT be negative.  Note that it is not\n  \
    \    the length of the entire DiagnosticsRequest data structure, but of\n    \
    \  the data making up the diagnostic_extensions_list.\n   diagnostic_extensions_list:\
    \  Consists of one or more\n      DiagnosticExtension structures (see below) documenting\
    \ additional\n      diagnostic information being requested.  Each DiagnosticExtension\n\
    \      consists of the following fields:\n      kind:  A numerical code indicating\
    \ the type of extension\n         diagnostic information (see Section 9.2).  Note\
    \ that kinds\n         0xf000 - 0xfffe are reserved for overlay specific diagnostics\n\
    \         and may be used without IANA registration for local diagnostic\n   \
    \      information.  Kinds from 0x0000 to 0x003f MUST NOT be indicated\n     \
    \    in the diagnostic_extensions_list in the message request, as\n         they\
    \ may be represented using the dMFlags in a much simpler\n         (and more space\
    \ efficient) way.\n      diagnostic_extension_contents:  The opaque data containing\
    \ the\n         request for this particular extension.  This data is extension\n\
    \         dependent.\n"
- title: 5.2.  DiagnosticsResponse Data Structure
  contents:
  - "5.2.  DiagnosticsResponse Data Structure\n   The DiagnosticsResponse data structure\
    \ is used to return the\n   diagnostic information and has the following form:\n\
    \               enum { (2^16-1) } DiagnosticKindId;\n               struct{\n\
    \                   DiagnosticKindId kind;\n                   opaque diagnostic_info_contents<0..2^16-1>;\n\
    \               }DiagnosticInfo;\n               struct{\n                   uint64\
    \ expiration;\n                   uint64 timestamp_initiated;\n              \
    \     uint64 timestamp_received;\n                   uint8 hop_counter;\n    \
    \               uint32 ext_length;\n                   DiagnosticInfo diagnostic_info_list<0..2^32-1>;\n\
    \               }DiagnosticsResponse;\n   The fields in the DiagnosticsResponse\
    \ are as follows:\n   expiration:  The time when the response will expire represented\
    \ as\n      the number of milliseconds elapsed since midnight Jan 1, 1970 UTC\n\
    \      (not counting leap seconds).  This will have the same values for\n    \
    \  seconds as standard UNIX time or POSIX time.  This value MUST have\n      a\
    \ value between 1 and 600 seconds in the future.\n   timestamp_initiated:  This\
    \ value is copied from the diagnostics\n      request message.  The benefit of\
    \ containing such a value in the\n      response message is that the initiator\
    \ node does not have to\n      maintain the state.\n   timestamp_received:  The\
    \ time when the diagnostic request was\n      received represented as the number\
    \ of milliseconds elapsed since\n      midnight Jan 1, 1970 UTC (not counting\
    \ leap seconds).  This will\n      have the same values for seconds as standard\
    \ UNIX time or POSIX\n      time.\n   hop_counter:  This field only appears in\
    \ diagnostic responses.  It\n      MUST be exactly copied from the TTL field of\
    \ the forwarding header\n      in the received request.  This information is sent\
    \ back to the\n      request initiator, allowing it to compute the number of hops\
    \ that\n      the message traversed in the overlay.\n   ext_length:  The length\
    \ of the returned DiagnosticInfo information in\n      bytes.  If the value is\
    \ greater than or equal to 1, then some\n      extended diagnostic information\
    \ (as specified in the\n      DiagnosticsRequest) was available and is being returned.\
    \  In that\n      case, this value indicates the length of the returned information.\n\
    \      A value of zero indicates no extended diagnostic information is\n     \
    \ included either because none was requested or the request could\n      not be\
    \ accommodated.  The value of ext_length MUST NOT be\n      negative.  Note that\
    \ it is not the length of the entire\n      DiagnosticsRequest data structure\
    \ but of the data making up the\n      diagnostic_info_list.\n   diagnostic_info_list:\
    \  consists of one or more DiagnosticInfo\n      structures containing the requested\
    \ diagnostic_info_contents.  The\n      fields in the DiagnosticInfo structure\
    \ are as follows:\n      kind:  A numeric code indicating the type of information\
    \ being\n         returned.  For base data requested using the dMFlags, this code\n\
    \         corresponds to the dMFlag set and is described in Section 5.1.\n   \
    \      For diagnostic extensions, this code will be identical to the\n       \
    \  value of the DiagnosticKindId set in the \"kind\" field of the\n         DiagnosticExtension\
    \ of the request.  See Section 9.2.\n      diagnostic_info_contents:  Data containing\
    \ the value for the\n         diagnostic information being reported.  Various\
    \ kinds of\n         diagnostic information can be retrieved.  Please refer to\n\
    \         Section 5.3 for details of the diagnostic Kind ID for the base\n   \
    \      diagnostic information that may be reported.\n"
- title: 5.3.  dMFlags and Diagnostic Kind ID Types
  contents:
  - "5.3.  dMFlags and Diagnostic Kind ID Types\n   The dMFlags field described above\
    \ is a 64-bit field that allows\n   initiator nodes to identify up to 62 items\
    \ of base information to\n   request in a request message (the first and last\
    \ flags being\n   reserved).  The dMFlags also reserves all \"0\"s, which means\
    \ nothing\n   is requested, and all \"1\"s, which means everything is requested.\
    \  But\n   at the same time, the first and last bits cannot be used for other\n\
    \   purposes, and they MUST be set to 0 when other particular diagnostic\n   Kind\
    \ IDs are requested.  When the requested base information is\n   returned in the\
    \ response, the value of the diagnostic Kind ID will\n   correspond to the numeric\
    \ field marked in the dMFlags in the request.\n   The values for the dMFlags are\
    \ defined in Section 9.1 and the\n   diagnostic Kind IDs are defined in Section\
    \ 9.2.  The information\n   contained for each value is described in this section.\
    \  Access to\n   each kind of diagnostic information MUST NOT be allowed unless\n\
    \   compliant to the rules defined in Section 7.\n   STATUS_INFO (8 bits):  A\
    \ single-value element containing an unsigned\n      byte representing whether\
    \ or not the node is in congestion status.\n      An example usage of STATUS_INFO\
    \ is for congestion-aware routing.\n      In this scenario, each peer has to update\
    \ its congestion status\n      periodically.  An intermediate peer in the Distributed\
    \ Hash\n      Table (DHT) network will choose its next hop according to both the\n\
    \      DHT routing algorithm and the status information.  This is done to\n  \
    \    avoid increasing load on congested peers.  The rightmost 4 bits\n      are\
    \ used and other bits MUST be cleared to \"0\"s for future use.\n      There are\
    \ 16 levels of congestion status, with 0x00 representing\n      zero load and\
    \ 0x0f representing congestion.  This document does\n      not provide a specific\
    \ method for congestion and leaves this\n      decision to each overlay implementation.\
    \  One possible option for\n      an overlay implementation would be to take node's\
    \ CPU/memory/\n      bandwidth usage percentage in the past 600 seconds and normalize\n\
    \      the highest value to the range from 0x00 to 0x0f.  An overlay\n      implementation\
    \ can also decide to not use all the 16 values from\n      0x00 to 0x0f.  A future\
    \ document may define an objective measure\n      or specific algorithm for this.\n\
    \   ROUTING_TABLE_SIZE (32 bits):  A single-value element containing an\n    \
    \  unsigned 32-bit integer representing the number of peers in the\n      peer's\
    \ routing table.  The administrator of the overlay may be\n      interested in\
    \ statistics of this value for reasons such as routing\n      efficiency.\n  \
    \ PROCESS_POWER (64 bits):  A single-value element containing an\n      unsigned\
    \ 64-bit integer specifying the processing power of the\n      node with MIPS\
    \ as the unit.  Fractional values are rounded up.\n   UPSTREAM_BANDWIDTH (64 bits):\
    \  A single-value element containing an\n      unsigned 64-bit integer specifying\
    \ the upstream network bandwidth\n      (provisioned or maximum, not available)\
    \ of the node with units of\n      kbit/s.  Fractional values are rounded up.\
    \  For multihomed hosts,\n      this should be the link used to send the response.\n\
    \   DOWNSTREAM_BANDWIDTH (64 bits):  A single-value element containing an\n  \
    \    unsigned 64-bit integer specifying the downstream network\n      bandwidth\
    \ (provisioned or maximum, not available) of the node with\n      kbit/s as the\
    \ unit.  Fractional values are rounded up.  For\n      multihomed hosts, this\
    \ should be the link the request was received\n      from.\n   SOFTWARE_VERSION:\
    \  A single-value element containing a US-ASCII\n      string that identifies\
    \ the manufacture, model, operating system\n      information, and the version\
    \ of the software.  Given that there\n      are a very large number of peers in\
    \ some networks, and no peer is\n      likely to know all other peer's software,\
    \ this information may be\n      very useful to help determine if the cause of\
    \ certain groups of\n      misbehaving peers is related to specific software versions.\
    \  While\n      the format is peer defined, a suggested format is as follows:\n\
    \      \"ApplicationProductToken (Platform; OS-or-CPU) VendorProductToken\n  \
    \    (VendorComment)\", for example, \"MyReloadApp/1.0 (Unix; Linux\n      x86_64)\
    \ libreload-java/0.7.0 (Stonyfish Inc.)\".  The string is a\n      C-style string\
    \ and MUST be terminated by \"\\0\".\"\\0\" MUST NOT be\n      included in the\
    \ string itself to prevent confusion with the\n      delimiter.\n   MACHINE_UPTIME\
    \ (64 bits):  A single-value element containing an\n      unsigned 64-bit integer\
    \ specifying the time the node's underlying\n      system has been up (in seconds).\n\
    \   APP_UPTIME (64 bits):  A single-value element containing an unsigned\n   \
    \   64-bit integer specifying the time the P2P application has been up\n     \
    \ (in seconds).\n   MEMORY_FOOTPRINT (64 bits):  A single-value element containing\
    \ an\n      unsigned 64-bit integer representing the memory footprint of the\n\
    \      peer program in kilobytes (1024 bytes).  Fractional values are\n      rounded\
    \ up.\n   DATASIZE_STORED (64 bits):  An unsigned 64-bit integer representing\n\
    \      the number of bytes of data being stored by this node.\n   INSTANCES_STORED:\
    \  An array element containing the number of\n      instances of each kind stored.\
    \  The array is indexed by Kind-ID.\n      Each entry is an unsigned 64-bit integer.\n\
    \   MESSAGES_SENT_RCVD:  An array element containing the number of\n      messages\
    \ sent and received.  The array is indexed by method code.\n      Each entry in\
    \ the array is a pair of unsigned 64-bit integers\n      (packed end to end) representing\
    \ sent and received.\n   EWMA_BYTES_SENT (32 bits):  A single-value element containing\
    \ an\n      unsigned 32-bit integer representing an exponential weighted\n   \
    \   average of bytes sent per second by this peer:\n      sent = alpha x sent_present\
    \ + (1 - alpha) x sent_last\n      where sent_present represents the bytes sent\
    \ per second since the\n      last calculation and sent_last represents the last\
    \ calculation of\n      bytes sent per second.  A suitable value for alpha is\
    \ 0.8 (or\n      another value as determined by the implementation).  This value\
    \ is\n      calculated every five seconds (or another time period as\n      determined\
    \ by the implementation).  The value for the very first\n      time period should\
    \ simply be the average of bytes sent in that\n      time period.\n   EWMA_BYTES_RCVD\
    \ (32 bits):  A single-value element containing an\n      unsigned 32-bit integer\
    \ representing an exponential weighted\n      average of bytes received per second\
    \ by this peer:\n      rcvd = alpha x rcvd_present + (1 - alpha) x rcvd_last\n\
    \      where rcvd_present represents the bytes received per second since\n   \
    \   the last calculation and rcvd_last represents the last calculation\n     \
    \ of bytes received per second.  A suitable value for alpha is 0.8\n      (or\
    \ another value as determined by the implementation).  This\n      value is calculated\
    \ every five seconds (or another time period as\n      determined by the implementation).\
    \  The value for the very first\n      time period should simply be the average\
    \ of bytes received in that\n      time period.\n   UNDERLAY_HOP (8 bits):  Indicates\
    \ the IP-layer hops from the\n      intermediate peer, which receives the diagnostics\
    \ message to the\n      next-hop peer for this message.  (Note: RELOAD does not\
    \ require\n      the intermediate peers to look into the message body.  So, here\
    \ we\n      use PathTrack to gather underlay hops for diagnostics purpose).\n\
    \   BATTERY_STATUS (8 bits):  The leftmost bit is used to indicate\n      whether\
    \ this peer is using a battery or not.  If this bit is clear\n      (set to \"\
    0\"), then the peer is using a battery for power.  The\n      other 7 bits are\
    \ to be determined by specific applications.\n"
- title: 6.  Message Processing
  contents:
  - '6.  Message Processing

    '
- title: 6.1.  Message Creation and Transmission
  contents:
  - "6.1.  Message Creation and Transmission\n   When constructing either a Ping message\
    \ with diagnostic extensions or\n   a PathTrack message, the sender first creates\
    \ and populates a\n   DiagnosticsRequest data structure.  The timestamp_initiated\
    \ field is\n   set to the current time, and the expiration field is constructed\n\
    \   based on this time.  The sender includes the dMFlags field in the\n   structure,\
    \ setting any number (including all) of the flags to request\n   particular diagnostic\
    \ information.  The sender MAY leave all the bits\n   unset, thereby requesting\
    \ no particular diagnostic information.\n   The sender MAY also include diagnostic\
    \ extensions in the\n   DiagnosticsRequest data structure to request additional\
    \ information.\n   If the sender includes any extensions, it MUST calculate the\
    \ length\n   of these extensions and set the ext_length field to this value. \
    \ If\n   no extensions are included, the sender MUST set ext_length to zero.\n\
    \   The format of the DiagnosticRequest data structure and its fields\n   MUST\
    \ follow the restrictions defined in Section 5.1.\n   When constructing a Ping\
    \ message with diagnostic extensions, the\n   sender MUST create a MessageExtension\
    \ structure as defined in RELOAD\n   [RFC6940], setting the value of type to 0x2\
    \ and the value of critical\n   to FALSE.  The value of extension_contents MUST\
    \ be a\n   DiagnosticsRequest structure as defined above.  The message MAY be\n\
    \   directed to a particular NodeID or ResourceID but MUST NOT be sent to\n  \
    \ the broadcast NodeID.\n   When constructing a PathTrack message, the sender\
    \ MUST set the\n   message_code for the RELOAD MessageContents structure to\n\
    \   path_track_req 0x27.  The request field of the PathTrackReq MUST be\n   set\
    \ to the DiagnosticsRequest data structure defined above.  The\n   destination\
    \ field MUST be set to the desired destination, which MAY\n   be either a NodeID\
    \ or ResourceID but SHOULD NOT be the broadcast\n   NodeID.\n"
- title: '6.2.  Message Processing: Intermediate Peers'
  contents:
  - "6.2.  Message Processing: Intermediate Peers\n   When a request arrives at a\
    \ peer, if the peer's responsible ID space\n   does not cover the destination\
    \ ID of the request, then the peer MUST\n   continue processing this request according\
    \ to the overlay specified\n   routing mode from RELOAD protocol.\n   In P2P overlay,\
    \ error responses to a message can be generated by\n   either an intermediate\
    \ peer or the responsible peer.  When a request\n   is received at a peer, the\
    \ peer may find connectivity failures or\n   malfunctioning peers through the\
    \ predefined rules of the overlay\n   network, e.g., by analyzing the Via List\
    \ or underlay error messages.\n   In this case, the intermediate peer returns\
    \ an error response to the\n   initiator node, reporting any malfunction node\
    \ information available\n   in the error message payload.  All error responses\
    \ generated MUST\n   contain the appropriate error code.\n   Each intermediate\
    \ peer receiving a Ping message with extensions (and\n   that understands the\
    \ extension) or receiving a PathTrack request /\n   response MUST check the expiration\
    \ value (Unix time format) to\n   determine if the message is expired.  If the\
    \ message expired, the\n   intermediate peer MUST generate a response with error\
    \ code 0x17\n   \"Error_Message_Expired\", return the response to the initiator\
    \ node,\n   and discard the message.\n   The intermediate peer MUST return an\
    \ error response with the error\n   code 0x15 \"Error_Underlay_Destination_Unreachable\"\
    \ when it receives\n   an ICMP message with \"Destination Unreachable\" information\
    \ after\n   forwarding the received request to the destination peer.\n   The intermediate\
    \ peer MUST return an error response with the error\n   code 0x16 \"Error_Underlay_Time_Exceeded\"\
    \ when it receives an ICMP\n   message with \"Time Exceeded\" information after\
    \ forwarding the\n   received request.\n   The peer MUST return an error response\
    \ with error code 0x18\n   \"Error_Upstream_Misrouting\" when it finds its upstream\
    \ peer disobeys\n   the routing rules defined in the overlay.  The immediate upstream\n\
    \   peer information MUST also be conveyed to the initiator node.\n   The peer\
    \ MUST return an error response with error code 0x19\n   \"Error_Loop_Detected\"\
    \ when it finds a loop through the analysis of\n   the Via List.\n   The peer\
    \ MUST return an error response with error code 0x1a\n   \"Error_TTL_Hops_Exceeded\"\
    \ when it finds that the TTL field value is\n   no more than 0 when forwarding.\n"
- title: 6.3.  Message Response Creation
  contents:
  - "6.3.  Message Response Creation\n   When a diagnostic request message arrives\
    \ at a peer, it is\n   responsible for the destination ID specified in the forwarding\n\
    \   header, and assuming it understands the extension (in the case of\n   Ping)\
    \ or the new request type PathTrack, it MUST follow the\n   specifications defined\
    \ in RELOAD to form the response header, and\n   perform the following operations:\n\
    \   o  When constructing a PathTrack response, the sender MUST set the\n     \
    \ message_code for the RELOAD MessageContents structure to\n      path_track_ans\
    \ 0x28.\n   o  The receiver MUST check the expiration value (Unix time format)\
    \ in\n      the DiagnosticsRequest to determine if the message is expired.  If\n\
    \      the message is expired, the peer MUST generate a response with the\n  \
    \    error code 0x17 \"Error_Message_Expired\", return the response to\n     \
    \ the initiator node, and discard the message.\n   o  If the message is not expired,\
    \ the receiver MUST construct a\n      DiagnosticsResponse structure as follows:\
    \ 1) the TTL value from\n      the forwarding header is copied to the hop_counter\
    \ field of the\n      DiagnosticsResponse structure (note that the default value\
    \ for TTL\n      at the beginning represents 100 hops unless the overlay\n   \
    \   configuration has overridden the value), and 2) the receiver\n      generates\
    \ a Unix time format timestamp for the current time of day\n      and places it\
    \ in the timestamp_received field and constructs a new\n      expiration time\
    \ and places it in the expiration field of the\n      DiagnosticsResponse.\n \
    \  o  The destination peer MUST check if the initiator node has the\n      authority\
    \ to request specific types of diagnostic information, and\n      if appropriate,\
    \ append the diagnostic information requested in the\n      dMFlags and diagnostic_extensions\
    \ (if any) using the\n      diagnostic_info_list field to the DiagnosticsResponse\
    \ structure.\n      If any information is returned, the receiver MUST calculate\
    \ the\n      length of the response and set ext_length appropriately.  If no\n\
    \      diagnostic information is returned, ext_length MUST be set to\n      zero.\n\
    \   o  The format of the DiagnosticResponse data structure and its fields\n  \
    \    MUST follow the restrictions defined in Section 5.2.\n   o  In the event\
    \ of an error, an error response containing the error\n      code followed by\
    \ the description (if they exist) MUST be created\n      and sent to the sender.\
    \  If the initiator node asks for diagnostic\n      information that they are\
    \ not authorized to query, the receiving\n      peer MUST return an error response\
    \ with the error code 2\n      \"Error_Forbidden\".\n"
- title: 6.4.  Interpreting Results
  contents:
  - "6.4.  Interpreting Results\n   The initiator node, as well as the responding\
    \ peer, may compute the\n   overlay One-Way-Delay time through the value in timestamp_received\n\
    \   and the timestamp_initiated field.  However, for a single hop\n   measurement,\
    \ the traditional measurement methods (IP-layer ping) MUST\n   be used instead\
    \ of the overlay layer diagnostics methods.\n   The P2P overlay network using\
    \ the diagnostics methods specified in\n   this document MUST enforce time synchronization\
    \ with a central time\n   server.  The Network Time Protocol [RFC5905] can usually\
    \ maintain\n   time to within tens of milliseconds over the public Internet and\
    \ can\n   achieve better than one millisecond accuracy in local area networks\n\
    \   under ideal conditions.  However, this document does not specify the\n   choice\
    \ for time resolution and synchronization, leaving it to the\n   implementation.\n\
    \   The initiator node receiving the Ping response may check the\n   hop_counter\
    \ field and compute the overlay hops to the destination\n   peer for the statistics\
    \ of connectivity quality from the perspective\n   of overlay hops.\n"
- title: 7.  Authorization through Overlay Configuration
  contents:
  - "7.  Authorization through Overlay Configuration\n   Different level of access\
    \ control can be made for different users/\n   nodes.  For example, diagnostic\
    \ information A can be accessed by\n   nodes 1 and 2, but diagnostic information\
    \ B can only be accessed by\n   node 2.\n   The overlay configuration file MUST\
    \ contain the following XML\n   elements for authorizing a node to access the\
    \ relative diagnostic\n   Kinds.\n   diagnostic-kind:  This has the attribute\
    \ \"kind\" with the hexadecimal\n      number indicating the diagnostic Kind ID.\
    \  This attribute has the\n      same value with Section 9.2 and at least one\
    \ subelement \"access-\n      node\".\n   access-node:  This element contains\
    \ one hexadecimal number indicating\n      a NodeID, and the node with this NodeID\
    \ is allowed to access the\n      diagnostic \"kind\" under the same diagnostic-kind\
    \ element.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The authorization for diagnostic information\
    \ must be designed with\n   care to prevent it becoming a method to retrieve information\
    \ for both\n   attacks.  It should also be noted that attackers can use diagnostics\n\
    \   to analyze overlay information to attack certain key peers.  For\n   example,\
    \ diagnostic information might be used to fingerprint a peer\n   where the peer\
    \ will lose its anonymity characteristics, but anonymity\n   might be very important\
    \ for some P2P overlay networks, and defenses\n   against such fingerprinting\
    \ are probably very hard.  As such,\n   networks where anonymity is of very high\
    \ importance may find\n   implementation of diagnostics problematic or even undesirable,\n\
    \   despite the many advantages it offers.  As this document is a RELOAD\n   extension,\
    \ it follows RELOAD message header and routing\n   specifications.  The common\
    \ security considerations described in the\n   base document [RFC6940] are also\
    \ applicable to this document.\n   Overlays may define their own requirements\
    \ on who can collect/share\n   diagnostic information.\n"
- title: 9.  IANA Considerations
  contents:
  - '9.  IANA Considerations

    '
- title: 9.1.  Diagnostics Flag
  contents:
  - "9.1.  Diagnostics Flag\n   IANA has created a \"RELOAD Diagnostics Flag\" registry\
    \ under protocol\n   RELOAD.  Entries in this registry are 1-bit flags contained\
    \ in a\n   64-bit integer dMFlags denoting diagnostic information to be\n   retrieved\
    \ as described in Section 4.3.1.  New entries SHALL be\n   defined via Standards\
    \ Action as per [RFC5226].  The initial contents\n   of this registry are:\n \
    \    +-------------------------+----------------------------+----------+\n   \
    \  |  Diagnostic Information |Diagnostic Flag in dMFlags  | Reference|\n     |-------------------------+----------------------------+----------|\n\
    \     |Reserved All 0s value    | 0x 0000 0000 0000 0000     | RFC 7851 |\n  \
    \   |Reserved First Bit       | 0x 0000 0000 0000 0001     | RFC 7851 |\n    \
    \ |STATUS_INFO              | 0x 0000 0000 0000 0002     | RFC 7851 |\n     |ROUTING_TABLE_SIZE\
    \       | 0x 0000 0000 0000 0004     | RFC 7851 |\n     |PROCESS_POWER       \
    \     | 0x 0000 0000 0000 0008     | RFC 7851 |\n     |UPSTREAM_BANDWIDTH    \
    \   | 0x 0000 0000 0000 0010     | RFC 7851 |\n     |DOWNSTREAM_ BANDWIDTH   \
    \ | 0x 0000 0000 0000 0020     | RFC 7851 |\n     |SOFTWARE_VERSION         |\
    \ 0x 0000 0000 0000 0040     | RFC 7851 |\n     |MACHINE_UPTIME           | 0x\
    \ 0000 0000 0000 0080     | RFC 7851 |\n     |APP_UPTIME               | 0x 0000\
    \ 0000 0000 0100     | RFC 7851 |\n     |MEMORY_FOOTPRINT         | 0x 0000 0000\
    \ 0000 0200     | RFC 7851 |\n     |DATASIZE_STORED          | 0x 0000 0000 0000\
    \ 0400     | RFC 7851 |\n     |INSTANCES_STORED         | 0x 0000 0000 0000 0800\
    \     | RFC 7851 |\n     |MESSAGES_SENT_RCVD       | 0x 0000 0000 0000 1000  \
    \   | RFC 7851 |\n     |EWMA_BYTES_SENT          | 0x 0000 0000 0000 2000    \
    \ | RFC 7851 |\n     |EWMA_BYTES_RCVD          | 0x 0000 0000 0000 4000     |\
    \ RFC 7851 |\n     |UNDERLAY_HOP             | 0x 0000 0000 0000 8000     | RFC\
    \ 7851 |\n     |BATTERY_STATUS           | 0x 0000 0000 0001 0000     | RFC 7851\
    \ |\n     |Reserved Last Bit        | 0x 8000 0000 0000 0000     | RFC 7851 |\n\
    \     |Reserved All 1s value    | 0x ffff ffff ffff ffff     | RFC 7851 |\n  \
    \   +-------------------------+----------------------------+----------+\n"
- title: 9.2.  Diagnostic Kind ID
  contents:
  - "9.2.  Diagnostic Kind ID\n   IANA has created a \"RELOAD Diagnostic Kind ID\"\
    \ registry under\n   protocol RELOAD.  Entries in this registry are 16-bit integers\n\
    \   denoting diagnostics extension data kinds carried in the diagnostic\n   request\
    \ and response messages, as described in Sections and 5.1 and\n   5.2.  Code points\
    \ from 0x0001 to 0x003e are asked to be assigned\n   together with flags within\
    \ the \"RELOAD Diagnostics Flag\" registry.\n   The registration procedure for\
    \ the \"RELOAD Diagnostic Kind ID\"\n   registry is Standards Action as defined\
    \ in RFC 5226.\n         +----------------------+---------------+---------------+\n\
    \         | Diagnostic Kind      |      Code     | Specification |\n         +----------------------+---------------+---------------+\n\
    \         | Reserved             |     0x0000    |    RFC 7851   |\n         |\
    \ STATUS_INFO          |     0x0001    |    RFC 7851   |\n         | ROUTING_TABLE_SIZE\
    \   |     0x0002    |    RFC 7851   |\n         | PROCESS_POWER        |     0x0003\
    \    |    RFC 7851   |\n         | UPSTREAM_BANDWIDTH   |     0x0004    |    RFC\
    \ 7851   |\n         | DOWNSTREAM_BANDWIDTH |     0x0005    |    RFC 7851   |\n\
    \         | SOFTWARE_VERSION     |     0x0006    |    RFC 7851   |\n         |\
    \ MACHINE_UPTIME       |     0x0007    |    RFC 7851   |\n         | APP_UPTIME\
    \           |     0x0008    |    RFC 7851   |\n         | MEMORY_FOOTPRINT   \
    \  |     0x0009    |    RFC 7851   |\n         | DATASIZE_STORED      |     0x000a\
    \    |    RFC 7851   |\n         | INSTANCES_STORED     |     0x000b    |    RFC\
    \ 7851   |\n         | MESSAGES_SENT_RCVD   |     0x000c    |    RFC 7851   |\n\
    \         | EWMA_BYTES_SENT      |     0x000d    |    RFC 7851   |\n         |\
    \ EWMA_BYTES_RCVD      |     0x000e    |    RFC 7851   |\n         | UNDERLAY_HOP\
    \         |     0x000f    |    RFC 7851   |\n         | BATTERY_STATUS       |\
    \     0x0010    |    RFC 7851   |\n         | Unassigned           | 0x0011-0x003e\
    \ |    RFC 7851   |\n         | local use (Reserved) | 0xf000-0xfffe |    RFC\
    \ 7851   |\n         | Reserved             |     0xffff    |    RFC 7851   |\n\
    \         +----------------------+---------------+---------------+\n         \
    \                Table 1: Diagnostic Kind\n"
- title: 9.3.  Message Codes
  contents:
  - "9.3.  Message Codes\n   This document introduces two new types of messages and\
    \ their\n   responses, so the following additions have been made to the \"RELOAD\n\
    \   Message Codes\" registry defined in RELOAD [RFC6940].\n               +-------------------+------------+----------+\n\
    \               | Message Code Name | Code Value |   RFC    |\n              \
    \ +-------------------+------------+----------+\n               |   path_track_req\
    \  |    0x27    | RFC 7851 |\n               |   path_track_ans  |    0x28   \
    \ | RFC 7851 |\n               +-------------------+------------+----------+\n\
    \                Table 2: Extensions to RELOAD Message Codes\n"
- title: 9.4.  Error Code
  contents:
  - "9.4.  Error Code\n   This document introduces the following new error codes,\
    \ which have\n   been added to the \"RELOAD Error Codes\" registry.\n    +----------------------------------------+------------+-----------+\n\
    \    | Error Code Name                        | Code Value | Reference |\n   \
    \ +----------------------------------------+------------+-----------+\n    | Error_Underlay_Destination_Unreachable\
    \ |    0x15    |  RFC 7851 |\n    | Error_Underlay_Time_Exceeded           | \
    \   0x16    |  RFC 7851 |\n    | Error_Message_Expired                  |    0x17\
    \    |  RFC 7851 |\n    | Error_Upstream_Misrouting              |    0x18   \
    \ |  RFC 7851 |\n    | Error_Loop_Detected                    |    0x19    | \
    \ RFC 7851 |\n    | Error_TTL_Hops_Exceeded                |    0x1A    |  RFC\
    \ 7851 |\n    +----------------------------------------+------------+-----------+\n\
    \                        Table 3: RELOAD Error Codes\n"
- title: 9.5.  Message Extension
  contents:
  - "9.5.  Message Extension\n   This document introduces the following new RELOAD\
    \ extension code:\n                  +-----------------+------+-----------+\n\
    \                  |  Extension Name | Code | Reference |\n                  +-----------------+------+-----------+\n\
    \                  | Diagnostic_Ping | 0x2  |  RFC 7851 |\n                  +-----------------+------+-----------+\n\
    \                    Table 4: New RELOAD Extension Code\n"
- title: 9.6.  XML Name Space Registration
  contents:
  - "9.6.  XML Name Space Registration\n   This document registers a URI for the config-diagnostics\
    \ XML\n   namespace in the IETF XML registry defined in [RFC3688].  All the\n\
    \   elements defined in this document belong to this namespace.\n   URI: urn:ietf:params:xml:ns:p2p:config-diagnostics\n\
    \   Registrant Contact: The IESG.\n   XML: N/A; the requested URIs are XML namespaces\n\
    \   The overlay configuration file MUST contain the following XML\n   language\
    \ declaring P2P diagnostics as a mandatory extension to\n   RELOAD.\n   <mandatory-extension>\n\
    \                 urn:ietf:params:xml:ns:p2p:config-diagnostics\n   </mandatory-extension>\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC792]   Postel, J., \"Internet Control Message\
    \ Protocol\", STD 5,\n              RFC 792, DOI 10.17487/RFC0792, September 1981,\n\
    \              <http://www.rfc-editor.org/info/rfc792>.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n       \
    \       <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3688]  Mealling, M.,\
    \ \"The IETF XML Registry\", BCP 81, RFC 3688,\n              DOI 10.17487/RFC3688,\
    \ January 2004,\n              <http://www.rfc-editor.org/info/rfc3688>.\n   [RFC5226]\
    \  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA\
    \ Considerations Section in RFCs\", BCP 26, RFC 5226,\n              DOI 10.17487/RFC5226,\
    \ May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC5905]\
    \  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n              \"Network\
    \ Time Protocol Version 4: Protocol and Algorithms\n              Specification\"\
    , RFC 5905, DOI 10.17487/RFC5905, June 2010,\n              <http://www.rfc-editor.org/info/rfc5905>.\n\
    \   [RFC6940]  Jennings, C., Lowekamp, B., Ed., Rescorla, E., Baset, S.,\n   \
    \           and H. Schulzrinne, \"REsource LOcation And Discovery\n          \
    \    (RELOAD) Base Protocol\", RFC 6940, DOI 10.17487/RFC6940,\n             \
    \ January 2014, <http://www.rfc-editor.org/info/rfc6940>.\n   [RFC7263]  Zong,\
    \ N., Jiang, X., Even, R., and Y. Zhang, \"An Extension\n              to the\
    \ REsource LOcation And Discovery (RELOAD) Protocol\n              to Support\
    \ Direct Response Routing\", RFC 7263,\n              DOI 10.17487/RFC7263, June\
    \ 2014,\n              <http://www.rfc-editor.org/info/rfc7263>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [UnixTime] Wikipedia, \"Unix time\", April\
    \ 2016,\n              <https://en.wikipedia.org/w/\n              index.php?title=Unix_time&oldid=715503178>.\n\
    \   [P2PSIP-CONCEPTS]\n              Bryan, D., Matthews, P., Shim, E., Willis,\
    \ D., and S.\n              Dawkins, \"Concepts and Terminology for Peer to Peer\
    \ SIP\",\n              Work in Progress, draft-ietf-p2psip-concepts-09, April\n\
    \              2016.\n   [Overlay-Failure-Detection]\n              Zhuang, S.,\
    \ Geels, D., Stoica, I., and R. Katz, \"On\n              failure detection algorithms\
    \ in overlay networks\", In\n              Proceedings of the IEEE INFOCOM 2005,\
    \ pp. 2112-2123,\n              DOI 10.1109/INFCOM.2005.1498487, March 2005.\n\
    \   [Handling_Churn_in_a_DHT]\n              Rhea, S., Geels, D., Roscoe, T.,\
    \ and J. Kubiatowicz,\n              \"Handling Churn in a DHT\", In Proceedings\
    \ of the\n              USENIX Annual Technical Conference, June 2004.\n   [Diagnostic_Framework]\n\
    \              Jin, X., Xiong, Y., Zhang, Q., and S. Chan, \"A Diagnostic\n  \
    \            Framework for Peer-to-peer Streaming\", IEEE ICME 2006,\n       \
    \       July 2006.\n"
- title: Appendix A.  Examples
  contents:
  - "Appendix A.  Examples\n   Below, we sketch how these metrics can be used.\n"
- title: A.1.  Example 1
  contents:
  - "A.1.  Example 1\n   A peer may set EWMA_BYTES_SENT and EWMA_BYTES_RCVD flags\
    \ in the\n   PathTrackReq to its direct neighbors.  A peer can use EWMA_BYTES_SENT\n\
    \   and EWMA_BYTES_RCVD of another peer to infer whether it is acting as\n   a\
    \ media relay.  It may then choose not to forward any requests for\n   media relay\
    \ to this peer.  Similarly, among the various candidates\n   for filling up a\
    \ routing table, a peer may prefer a peer with a large\n   UPTIME value, small\
    \ RTT, and small LAST_CONTACT value.\n"
- title: A.2.  Example 2
  contents:
  - "A.2.  Example 2\n   A peer may set the STATUS_INFO Flag in the PathTrackReq to\
    \ a remote\n   destination peer.  The overlay has its own threshold definition\
    \ for\n   congestion.  The peer can obtain knowledge of all the status\n   information\
    \ of the intermediate peers along the path, then it can\n   choose other paths\
    \ to that node for the subsequent requests.\n"
- title: A.3.  Example 3
  contents:
  - "A.3.  Example 3\n   A peer may use Ping to evaluate the average overlay hops\
    \ to other\n   peers by sending PingReq to a set of random resource or node IDs\
    \ in\n   the overlay.  A peer may adjust its timeout value according to the\n\
    \   change of average overlay hops.\n"
- title: Appendix B.  Problems with Generating Multiple Responses on Path
  contents:
  - "Appendix B.  Problems with Generating Multiple Responses on Path\n   An earlier\
    \ draft version of this document considered an approach\n   where a response was\
    \ generated by each intermediate peer as the\n   message traversed the overlay.\
    \  This approach was discarded.  One\n   reason this approach was discarded was\
    \ that it could provide a DoS\n   mechanism, whereby an attacker could send an\
    \ arbitrary message\n   claiming to be from a spoofed \"sender\" the real sender\
    \ wished to\n   attack.  As a result of sending this one message, many messages\
    \ would\n   be generated and sent back to the spoofed \"sender\" -- one from each\n\
    \   intermediate peer on the message path.  While authentication\n   mechanisms\
    \ could reduce some risk of this attack, it still resulted\n   in a fundamental\
    \ break from the request-response nature of the RELOAD\n   protocol, as multiple\
    \ responses are generated to a single request.\n   Although one request with responses\
    \ from all the peers in the route\n   will be more efficient, it was determined\
    \ to be too great a security\n   risk and a deviation from the RELOAD architecture.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   We would like to thank Zheng Hewen for the contribution of\
    \ the\n   initial draft version of this document.  We would also like to thank\n\
    \   Bruce Lowekamp, Salman Baset, Henning Schulzrinne, Jiang Haifeng, and\n  \
    \ Marc Petit-Huguenin for the email discussion and their valued\n   comments,\
    \ and special thanks to Henry Sinnreich for contributing to\n   the usage scenarios\
    \ text.  We would like to thank the authors of the\n   RELOAD protocol for transferring\
    \ text about diagnostics to this\n   document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Haibin Song\n   Huawei\n   Email: haibin.song@huawei.com\n\
    \   Jiang Xingfeng\n   Huawei\n   Email: jiangxingfeng@huawei.com\n   Roni Even\n\
    \   Huawei\n   14 David Hamelech\n   Tel Aviv 64953\n   Israel\n   Email: ron.even.tlv@gmail.com\n\
    \   David A. Bryan\n   ethernot.org\n   Cedar Park, Texas\n   United States\n\
    \   Email: dbryan@ethernot.org\n   Yi Sun\n   ICT\n   Email: sunyi@ict.ac.cn\n"
