- title: __initial_text__
  contents:
  - "           Forwarding and Control Element Separation (ForCES)\n             \
    \           Forwarding Element Model\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines the forwarding element (FE) model used in\
    \ the\n   Forwarding and Control Element Separation (ForCES) protocol.  The\n\
    \   model represents the capabilities, state, and configuration of\n   forwarding\
    \ elements within the context of the ForCES protocol, so\n   that control elements\
    \ (CEs) can control the FEs accordingly.  More\n   specifically, the model describes\
    \ the logical functions that are\n   present in an FE, what capabilities these\
    \ functions support, and how\n   these functions are or can be interconnected.\
    \  This FE model is\n   intended to satisfy the model requirements specified in\
    \ RFC 3654.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5812.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \      1.1. Requirements on the FE Model ...............................5\n  \
    \    1.2. The FE Model in Relation to FE Implementations .............6\n    \
    \  1.3. The FE Model in Relation to the ForCES Protocol ............6\n      1.4.\
    \ Modeling Language for the FE Model .........................7\n      1.5. Document\
    \ Structure .........................................8\n   2. Definitions .....................................................8\n\
    \   3. ForCES Model Concepts ..........................................10\n  \
    \    3.1. ForCES Capability Model and State Model ...................12\n    \
    \       3.1.1. FE Capability Model and State Model ................12\n      \
    \     3.1.2. Relating LFB and FE Capability and State Model .....14\n      3.2.\
    \ Logical Functional Block (LFB) Modeling ...................14\n           3.2.1.\
    \ LFB Outputs ........................................18\n           3.2.2. LFB\
    \ Inputs .........................................21\n           3.2.3. Packet\
    \ Type ........................................24\n           3.2.4. Metadata\
    \ ...........................................24\n           3.2.5. LFB Events\
    \ .........................................27\n           3.2.6. Component Properties\
    \ ...............................28\n           3.2.7. LFB Versioning .....................................29\n\
    \           3.2.8. LFB Inheritance ....................................29\n  \
    \    3.3. ForCES Model Addressing ...................................30\n    \
    \       3.3.1. Addressing LFB Components: Paths and Keys ..........32\n      3.4.\
    \ FE Data Path Modeling .....................................32\n           3.4.1.\
    \ Alternative Approaches for Modeling FE Data Paths ..33\n           3.4.2. Configuring\
    \ the LFB Topology .......................37\n   4. Model and Schema for LFB Classes\
    \ ...............................41\n      4.1. Namespace .................................................42\n\
    \      4.2. <LFBLibrary> Element ......................................42\n  \
    \    4.3. <load> Element ............................................44\n    \
    \  4.4. <frameDefs> Element for Frame Type Declarations ...........45\n      4.5.\
    \ <dataTypeDefs> Element for Data Type Definitions ..........45\n           4.5.1.\
    \ <typeRef> Element for Renaming Existing\n                  Data Types .........................................49\n\
    \           4.5.2. <atomic> Element for Deriving New Atomic Types .....49\n  \
    \         4.5.3. <array> Element to Define Arrays ...................50\n    \
    \       4.5.4. <struct> Element to Define Structures ..............54\n      \
    \     4.5.5. <union> Element to Define Union Types ..............56\n        \
    \   4.5.6. <alias> Element ....................................56\n          \
    \ 4.5.7. Augmentations ......................................57\n      4.6. <metadataDefs>\
    \ Element for Metadata Definitions ...........58\n      4.7. <LFBClassDefs> Element\
    \ for LFB Class Definitions ..........59\n           4.7.1. <derivedFrom> Element\
    \ to Express LFB Inheritance ...62\n           4.7.2. <inputPorts> Element to\
    \ Define LFB Inputs ..........62\n           4.7.3. <outputPorts> Element to Define\
    \ LFB Outputs ........65\n           4.7.4. <components> Element to Define LFB\n\
    \                  Operational Components .............................67\n  \
    \         4.7.5. <capabilities> Element to Define LFB\n                  Capability\
    \ Components ..............................70\n           4.7.6. <events> Element\
    \ for LFB Notification Generation ...71\n           4.7.7. <description> Element\
    \ for LFB Operational\n                  Specification ......................................79\n\
    \      4.8. Properties ................................................79\n  \
    \         4.8.1. Basic Properties ...................................79\n    \
    \       4.8.2. Array Properties ...................................81\n      \
    \     4.8.3. String Properties ..................................81\n        \
    \   4.8.4. Octetstring Properties .............................82\n          \
    \ 4.8.5. Event Properties ...................................83\n           4.8.6.\
    \ Alias Properties ...................................87\n      4.9. XML Schema\
    \ for LFB Class Library Documents ................88\n   5. FE Components and\
    \ Capabilities .................................99\n      5.1. XML for FEObject\
    \ Class Definition .........................99\n      5.2. FE Capabilities ..........................................106\n\
    \           5.2.1. ModifiableLFBTopology .............................106\n  \
    \         5.2.2. SupportedLFBs and SupportedLFBType ................106\n    \
    \  5.3. FE Components ............................................110\n      \
    \     5.3.1. FEState ...........................................110\n        \
    \   5.3.2. LFBSelectors and LFBSelectorType ..................110\n          \
    \ 5.3.3. LFBTopology and LFBLinkType .......................110\n           5.3.4.\
    \ FENeighbors and FEConfiguredNeighborType ..........111\n   6. Satisfying the\
    \ Requirements on the FE Model ...................111\n   7. Using the FE Model\
    \ in the ForCES Protocol .....................112\n      7.1. FE Topology Query\
    \ ........................................115\n      7.2. FE Capability Declarations\
    \ ...............................116\n      7.3. LFB Topology and Topology Configurability\
    \ Query ..........116\n      7.4. LFB Capability Declarations ..............................116\n\
    \      7.5. State Query of LFB Components ............................118\n  \
    \    7.6. LFB Component Manipulation ...............................118\n    \
    \  7.7. LFB Topology Reconfiguration .............................118\n   8. Example\
    \ LFB Definition ........................................119\n      8.1. Data\
    \ Handling ............................................126\n           8.1.1.\
    \ Setting Up a DLCI .................................127\n           8.1.2. Error\
    \ Handling ....................................127\n      8.2. LFB Components\
    \ ...........................................128\n      8.3. Capabilities .............................................128\n\
    \      8.4. Events ...................................................129\n  \
    \ 9. IANA Considerations ...........................................130\n    \
    \  9.1. URN Namespace Registration ...............................130\n      9.2.\
    \ LFB Class Names and LFB Class Identifiers ................130\n   10. Authors\
    \ Emeritus .............................................132\n   11. Acknowledgments\
    \ ..............................................132\n   12. Security Considerations\
    \ ......................................132\n   13. References ...................................................132\n\
    \      13.1. Normative References ....................................132\n  \
    \    13.2. Informative References ..................................133\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   RFC 3746 [RFC3746] specifies a framework by which control\
    \ elements\n   (CEs) can configure and manage one or more separate forwarding\n\
    \   elements (FEs) within a network element (NE) using the ForCES\n   protocol.\
    \  The ForCES architecture allows forwarding elements of\n   varying functionality\
    \ to participate in a ForCES network element.\n   The implication of this varying\
    \ functionality is that CEs can make\n   only minimal assumptions about the functionality\
    \ provided by FEs in\n   an NE.  Before CEs can configure and control the forwarding\
    \ behavior\n   of FEs, CEs need to query and discover the capabilities and states\
    \ of\n   their FEs.  RFC 3654 [RFC3654] mandates that the capabilities, states\n\
    \   and configuration information be expressed in the form of an FE\n   model.\n\
    \   RFC 3444 [RFC3444] observed that information models (IMs) and data\n   models\
    \ (DMs) are different because they serve different purposes.\n   \"The main purpose\
    \ of an IM is to model managed objects at a\n   conceptual level, independent\
    \ of any specific implementations or\n   protocols used\".  \"DMs, conversely,\
    \ are defined at a lower level of\n   abstraction and include many details.  They\
    \ are intended for\n   implementors and include protocol-specific constructs\"\
    .  Sometimes it\n   is difficult to draw a clear line between the two.  The FE\
    \ model\n   described in this document is primarily an information model, but\n\
    \   also includes some aspects of a data model, such as explicit\n   definitions\
    \ of the LFB (Logical Functional Block) class schema and FE\n   schema.  It is\
    \ expected that this FE model will be used as the basis\n   to define the payload\
    \ for information exchange between the CE and FE\n   in the ForCES protocol.\n"
- title: 1.1.  Requirements on the FE Model
  contents:
  - "1.1.  Requirements on the FE Model\n   RFC 3654 [RFC3654] defines requirements\
    \ that must be satisfied by a\n   ForCES FE model.  To summarize, an FE model\
    \ must define:\n   o  Logically separable and distinct packet forwarding operations\
    \ in\n      an FE data path (Logical Functional Blocks or LFBs);\n   o  The possible\
    \ topological relationships (and hence the sequence of\n      packet forwarding\
    \ operations) between the various LFBs;\n   o  The possible operational capabilities\
    \ (e.g., capacity limits,\n      constraints, optional features, granularity of\
    \ configuration) of\n      each type of LFB;\n   o  The possible configurable\
    \ parameters (e.g., components) of each\n      type of LFB; and\n   o  Metadata\
    \ that may be exchanged between LFBs.\n"
- title: 1.2.  The FE Model in Relation to FE Implementations
  contents:
  - "1.2.  The FE Model in Relation to FE Implementations\n   The FE model proposed\
    \ here is based on an abstraction using distinct\n   Logical Functional Blocks\
    \ (LFBs), which are interconnected in a\n   directed graph, and receive, process,\
    \ modify, and transmit packets\n   along with metadata.  The FE model is designed,\
    \ and any defined LFB\n   classes should be designed, such that different implementations\
    \ of\n   the forwarding data path can be logically mapped onto the model with\n\
    \   the functionality and sequence of operations correctly captured.\n   However,\
    \ the model is not intended to directly address how a\n   particular implementation\
    \ maps to an LFB topology.  It is left to the\n   forwarding plane vendors to\
    \ define how the FE functionality is\n   represented using the FE model.  Our\
    \ goal is to design the FE model\n   such that it is flexible enough to accommodate\
    \ most common\n   implementations.\n   The LFB topology model for a particular\
    \ data path implementation must\n   correctly capture the sequence of operations\
    \ on the packet.  Metadata\n   generation by certain LFBs MUST always precede\
    \ any use of that\n   metadata by subsequent LFBs in the topology graph; this\
    \ is required\n   for logically consistent operation.  Further, modification of\
    \ packet\n   fields that are subsequently used as inputs for further processing\n\
    \   MUST occur in the order specified in the model for that particular\n   implementation\
    \ to ensure correctness.\n"
- title: 1.3.  The FE Model in Relation to the ForCES Protocol
  contents:
  - "1.3.  The FE Model in Relation to the ForCES Protocol\n   The ForCES base protocol\
    \ [RFC5810] is used by the CEs and FEs to\n   maintain the communication channel\
    \ between the CEs and FEs.  The\n   ForCES protocol may be used to query and discover\
    \ the intra-FE\n   topology.  The details of a particular data path implementation\n\
    \   inside an FE, including the LFB topology, along with the operational\n   capabilities\
    \ and attributes of each individual LFB, are conveyed to\n   the CE within information\
    \ elements in the ForCES protocol.  The model\n   of an LFB class should define\
    \ all of the information that needs to be\n   exchanged between an FE and a CE\
    \ for the proper configuration and\n   management of that LFB.\n   Specifying\
    \ the various payloads of the ForCES messages in a\n   systematic fashion is difficult\
    \ without a formal definition of the\n   objects being configured and managed\
    \ (the FE and the LFBs within).\n   The FE model document defines a set of classes\
    \ and components for\n   describing and manipulating the state of the LFBs within\
    \ an FE.\n   These class definitions themselves will generally not appear in the\n\
    \   ForCES protocol.  Rather, ForCES protocol operations will reference\n   classes\
    \ defined in this model, including relevant components and the\n   defined operations.\n\
    \   Section 7 provides more detailed discussion on how the FE model\n   should\
    \ be used by the ForCES protocol.\n"
- title: 1.4.  Modeling Language for the FE Model
  contents:
  - "1.4.  Modeling Language for the FE Model\n   Even though not absolutely required,\
    \ it is beneficial to use a formal\n   data modeling language to represent the\
    \ conceptual FE model described\n   in this document.  Use of a formal language\
    \ can help to enforce\n   consistency and logical compatibility among LFBs.  A\
    \ full\n   specification will be written using such a data modeling language.\n\
    \   The formal definition of the LFB classes may facilitate the eventual\n   automation\
    \ of some of the code generation process and the functional\n   validation of\
    \ arbitrary LFB topologies.  These class definitions form\n   the LFB library.\
    \  Documents that describe LFB classes are therefore\n   referred to as LFB library\
    \ documents.\n   Human readability was the most important factor considered when\n\
    \   selecting the specification language, whereas encoding, decoding, and\n  \
    \ transmission performance were not a selection factor.  The encoding\n   method\
    \ for over-the-wire transport is not dependent on the\n   specification language\
    \ chosen and is outside the scope of this\n   document and up to the ForCES protocol\
    \ to define.\n   XML is chosen as the specification language in this document,\
    \ because\n   XML has the advantage of being both human and machine readable with\n\
    \   widely available tools support.  This document uses an XML schema to\n   define\
    \ the structure of the LFB library documents, as defined in\n   [RFC3470] and\
    \ [Schema1] and [Schema2].  While these LFB class\n   definitions are not sent\
    \ in the ForCES protocol, these definitions\n   comply with the recommendations\
    \ in RFC 3470 [RFC3470] on the use of\n   XML in IETF protocols.\n   By using\
    \ an XML schema to define the structure for the LFB library\n   documents, we\
    \ have a very clear set of syntactic restrictions to go\n   with the desired semantic\
    \ descriptions and restrictions covered in\n   this document.  As a corollary\
    \ to that, if it is determined that a\n   change in the syntax is needed, then\
    \ a new schema will be required.\n   This would be identified by a different URN\
    \ to identify the namespace\n   for such a new schema.\n"
- title: 1.5.  Document Structure
  contents:
  - "1.5.  Document Structure\n   Section 3 provides a conceptual overview of the\
    \ FE model, laying the\n   foundation for the more detailed discussion and specifications\
    \ in the\n   sections that follow.  Section 4 and Section 5 constitute the core\
    \ of\n   the FE model, detailing the two major aspects of the FE model: a\n  \
    \ general LFB model and a definition of the FE Object LFB, with its\n   components,\
    \ including FE capabilities and LFB topology information.\n   Section 6 directly\
    \ addresses the model requirements imposed by the\n   ForCES requirements defined\
    \ in RFC 3654 [RFC3654], while Section 7\n   explains how the FE model should\
    \ be used in the ForCES protocol.\n"
- title: 2.  Definitions
  contents:
  - "2.  Definitions\n   The use of compliance terminology (MUST, SHOULD, MAY, MUST\
    \ NOT) is\n   used in accordance with RFC 2119 [RFC2119].  Such terminology is\
    \ used\n   in describing the required behavior of ForCES forwarding elements or\n\
    \   control elements in supporting or manipulating information described\n   in\
    \ this model.\n   Terminology associated with the ForCES requirements is defined\
    \ in RFC\n   3654 [RFC3654] and is not copied here.  The following list of\n \
    \  terminology relevant to the FE model is defined in this section.\n   FE Model:\
    \  The FE model is designed to model the logical processing\n      functions of\
    \ an FE.  The FE model proposed in this document\n      includes three components;\
    \ the LFB modeling of individual Logical\n      Functional Block (LFB model),\
    \ the logical interconnection between\n      LFBs (LFB topology), and the FE-level\
    \ attributes, including FE\n      capabilities.  The FE model provides the basis\
    \ to define the\n      information elements exchanged between the CE and the FE\
    \ in the\n      ForCES protocol [RFC5810].\n   Data Path:  A conceptual path taken\
    \ by packets within the forwarding\n      plane inside an FE.  Note that more\
    \ than one data path can exist\n      within an FE.\n   LFB (Logical Functional\
    \ Block) Class (or type):  A template that\n      represents a fine-grained, logically\
    \ separable aspect of FE\n      processing.  Most LFBs relate to packet processing\
    \ in the data\n      path.  LFB classes are the basic building blocks of the FE\
    \ model.\n   LFB Instance:  As a packet flows through an FE along a data path,\
    \ it\n      flows through one or multiple LFB instances, where each LFB is an\n\
    \      instance of a specific LFB class.  Multiple instances of the same\n   \
    \   LFB class can be present in an FE's data path.  Note that we often\n     \
    \ refer to LFBs without distinguishing between an LFB class and LFB\n      instance\
    \ when we believe the implied reference is obvious for the\n      given context.\n\
    \   LFB Model:  The LFB model describes the content and structures in an\n   \
    \   LFB, plus the associated data definition.  XML is used to provide\n      a\
    \ formal definition of the necessary structures for the modeling.\n      Four\
    \ types of information are defined in the LFB model.  The core\n      part of\
    \ the LFB model is the LFB class definitions; the other\n      three types of\
    \ information define constructs associated with and\n      used by the class definition.\
    \  These are reusable data types,\n      supported frame (packet) formats, and\
    \ metadata.\n   Element:  Element is generally used in this document in accordance\n\
    \      with the XML usage of the term.  It refers to an XML tagged part\n    \
    \  of an XML document.  For a precise definition, please see the full\n      set\
    \ of XML specifications from the W3C.  This term is included in\n      this list\
    \ for completeness because the ForCES formal model uses\n      XML.\n   Attribute:\
    \  Attribute is used in the ForCES formal modeling in\n      accordance with standard\
    \ XML usage of the term, i.e., to provide\n      attribute information included\
    \ in an XML tag.\n   LFB Metadata:  Metadata is used to communicate per-packet\
    \ state from\n      one LFB to another, but is not sent across the network.  The\
    \ FE\n      model defines how such metadata is identified, produced, and\n   \
    \   consumed by the LFBs, but not how the per-packet state is\n      implemented\
    \ within actual hardware.  Metadata is sent between the\n      FE and the CE on\
    \ redirect packets.\n   ForCES Component:  A ForCES Component is a well-defined,\
    \ uniquely\n      identifiable and addressable ForCES model building block.  A\n\
    \      component has a 32-bit ID, name, type, and an optional synopsis\n     \
    \ description.  These are often referred to simply as components.\n   LFB Component:\
    \  An LFB component is a ForCES component that defines\n      the Operational\
    \ parameters of the LFBs that must be visible to the\n      CEs.\n   Structure\
    \ Component:  A ForCES component that is part of a complex\n      data structure\
    \ to be used in LFB data definitions.  The individual\n      parts that make up\
    \ a structured set of data are referred to as\n      structure components.  These\
    \ can themselves be of any valid data\n      type, including tables and structures.\n\
    \   Property:  ForCES components have properties associated with them,\n     \
    \ such as readability.  Other examples include lengths for variable-\n      sized\
    \ components.  These properties are accessed by the CE for\n      reading (or,\
    \ where appropriate, writing.)  Details on the ForCES\n      properties are found\
    \ in Section 4.8.\n   LFB Topology:  LFB topology is a representation of the logical\n\
    \      interconnection and the placement of LFB instances along the data\n   \
    \   path within one FE.  Sometimes this representation is called\n      intra-FE\
    \ topology, to be distinguished from inter-FE topology.\n      LFB topology is\
    \ outside of the LFB model, but is part of the FE\n      model.\n   FE Topology:\
    \  FE topology is a representation of how multiple FEs\n      within a single\
    \ network element (NE) are interconnected.\n      Sometimes this is called inter-FE\
    \ topology, to be distinguished\n      from intra-FE topology (i.e., LFB topology).\
    \  An individual FE\n      might not have the global knowledge of the full FE\
    \ topology, but\n      the local view of its connectivity with other FEs is considered\
    \ to\n      be part of the FE model.  The FE topology is discovered by the\n \
    \     ForCES base protocol or by some other means.\n   Inter-FE Topology:  See\
    \ FE Topology.\n   Intra-FE Topology:  See LFB Topology.\n   LFB Class Library:\
    \  The LFB class library is a set of LFB classes\n      that has been identified\
    \ as the most common functions found in\n      most FEs and hence should be defined\
    \ first by the ForCES Working\n      Group.\n"
- title: 3.  ForCES Model Concepts
  contents:
  - "3.  ForCES Model Concepts\n   Some of the important ForCES concepts used throughout\
    \ this document\n   are introduced in this section.  These include the capability\
    \ and\n   state abstraction, the FE and LFB model construction, and the unique\n\
    \   addressing of the different model structures.  Details of these\n   aspects\
    \ are described in Section 4 and Section 5.  The intent of this\n   section is\
    \ to discuss these concepts at the high level and lay the\n   foundation for the\
    \ detailed description in the following sections.\n   The ForCES FE model includes\
    \ both a capability and a state\n   abstraction.\n   o  The FE/LFB capability\
    \ model describes the capabilities and\n      capacities of an FE/LFB by specifying\
    \ the variation in functions\n      supported and any limitations.  Capacity describes\
    \ the limits of\n      specific components (an example would be a table size limit).\n\
    \   o  The state model describes the current state of the FE/LFB, that\n     \
    \ is, the instantaneous values or operational behavior of the FE/\n      LFB.\n\
    \   Section 3.1 explains the difference between a capability model and a\n   state\
    \ model, and describes how the two can be combined in the FE\n   model.\n   The\
    \ ForCES model construction laid out in this document allows an FE\n   to provide\
    \ information about its structure for operation.  This can\n   be thought of as\
    \ FE-level information and information about the\n   individual instances of LFBs\
    \ provided by the FE.\n   o  The ForCES model includes the constructions for defining\
    \ the class\n      of Logical Functional Blocks (LFBs) that an FE may support.\
    \  These\n      classes are defined in this and other documents.  The definition\n\
    \      of such a class provides the information content for monitoring\n     \
    \ and controlling instances of the LFB class for ForCES purposes.\n      Each\
    \ LFB model class formally defines the operational LFB\n      components, LFB\
    \ capabilities, and LFB events.  Essentially,\n      Section 3.2 introduces the\
    \ concept of LFBs as the basic functional\n      building blocks in the ForCES\
    \ model.\n   o  The FE model also provides the construction necessary to monitor\n\
    \      and control the FE as a whole for ForCES purposes.  For\n      consistency\
    \ of operation and simplicity, this information is\n      represented as an LFB,\
    \ the FE Object LFB class and a singular LFB\n      instance of that class, defined\
    \ using the LFB model.  The FE\n      Object class defines the components to provide\
    \ information at the\n      FE level, particularly the capabilities of the FE\
    \ at a coarse\n      level, i.e., not all possible capabilities or all details\
    \ about\n      the capabilities of the FE.  Part of the FE-level information is\n\
    \      the LFB topology, which expresses the logical inter-connection\n      between\
    \ the LFB instances along the data path(s) within the FE.\n      Section 3.3 discusses\
    \ the LFB topology.  The FE Object also\n      includes information about what\
    \ LFB classes the FE can support.\n   The ForCES model allows for unique identification\
    \ of the different\n   constructs it defines.  This includes identification of\
    \ the LFB\n   classes, and of LFB instances within those classes, as well as\n\
    \   identification of components within those instances.\n   The ForCES protocol\
    \ [RFC5810] encapsulates target address(es) to\n   eventually get to a fine-grained\
    \ entity being referenced by the CE.\n   The addressing hierarchy is broken into\
    \ the following:\n   o  An FE is uniquely identified by a 32-bit FEID.\n   o \
    \ Each class of LFB is uniquely identified by a 32-bit LFB ClassID.\n      The\
    \ LFB ClassIDs are global within the network element and may be\n      issued\
    \ by IANA.\n   o  Within an FE, there can be multiple instances of each LFB class.\n\
    \      Each LFB class instance is identified by a 32-bit identifier that\n   \
    \   is unique within a particular LFB class on that FE.\n   o  All the components\
    \ within an LFB instance are further defined\n      using 32-bit identifiers.\n\
    \   Refer to Section 3.3 for more details on addressing.\n"
- title: 3.1.  ForCES Capability Model and State Model
  contents:
  - "3.1.  ForCES Capability Model and State Model\n   Capability and state modeling\
    \ applies to both the FE and LFB\n   abstraction.\n   Figure 1 shows the concepts\
    \ of FE state, capabilities, and\n   configuration in the context of CE-FE communication\
    \ via the ForCES\n   protocol.\n   +-------+                                 \
    \         +-------+\n   |       | FE capabilities: what it can/cannot do.  | \
    \      |\n   |       |<-----------------------------------------|       |\n  \
    \ |       |                                          |       |\n   |   CE  | FE\
    \ state: what it is now.                |  FE   |\n   |       |<-----------------------------------------|\
    \       |\n   |       |                                          |       |\n \
    \  |       | FE configuration: what it should be.     |       |\n   |       |----------------------------------------->|\
    \       |\n   +-------+                                          +-------+\n \
    \   Figure 1: Illustration of FE capabilities, state, and configuration\n    \
    \    exchange in the context of CE-FE communication via ForCES.\n"
- title: 3.1.1.  FE Capability Model and State Model
  contents:
  - "3.1.1.  FE Capability Model and State Model\n   Conceptually, the FE capability\
    \ model tells the CE which states are\n   allowed on an FE, with capacity information\
    \ indicating certain\n   quantitative limits or constraints.  Thus, the CE has\
    \ general\n   knowledge about configurations that are applicable to a particular\n\
    \   FE.\n"
- title: 3.1.1.1.  FE Capability Model
  contents:
  - "3.1.1.1.  FE Capability Model\n   The FE capability model may be used to describe\
    \ an FE at a coarse\n   level.  For example, an FE might be defined as follows:\n\
    \   o  the FE can handle IPv4 and IPv6 forwarding;\n   o  the FE can perform classification\
    \ based on the following fields:\n      source IP address, destination IP address,\
    \ source port number,\n      destination port number, etc.;\n   o  the FE can\
    \ perform metering;\n   o  the FE can handle up to N queues (capacity); and\n\
    \   o  the FE can add and remove encapsulating headers of types including\n  \
    \    IPsec, GRE, L2TP.\n   While one could try to build an object model to fully\
    \ represent the\n   FE capabilities, other efforts found this approach to be a\n\
    \   significant undertaking.  The main difficulty arises in describing\n   detailed\
    \ limits, such as the maximum number of classifiers, queues,\n   buffer pools,\
    \ and meters that the FE can provide.  We believe that a\n   good balance between\
    \ simplicity and flexibility can be achieved for\n   the FE model by combining\
    \ coarse-level-capability reporting with an\n   error reporting mechanism.  That\
    \ is, if the CE attempts to instruct\n   the FE to set up some specific behavior\
    \ it cannot support, the FE\n   will return an error indicating the problem. \
    \ Examples of similar\n   approaches include Diffserv PIB RFC 3317 [RFC3317] and\
    \ framework PIB\n   RFC 3318 [RFC3318].\n"
- title: 3.1.1.2.  FE State Model
  contents:
  - "3.1.1.2.  FE State Model\n   The FE state model presents the snapshot view of\
    \ the FE to the CE.\n   For example, using an FE state model, an FE might be described\
    \ to its\n   corresponding CE as the following:\n   o  on a given port, the packets\
    \ are classified using a given\n      classification filter;\n   o  the given\
    \ classifier results in packets being metered in a certain\n      way and then\
    \ marked in a certain way;\n   o  the packets coming from specific markers are\
    \ delivered into a\n      shared queue for handling, while other packets are delivered\
    \ to a\n      different queue; and\n   o  a specific scheduler with specific behavior\
    \ and parameters will\n      service these collected queues.\n"
- title: 3.1.1.3.  LFB Capability and State Model
  contents:
  - "3.1.1.3.  LFB Capability and State Model\n   Both LFB capability and state information\
    \ are defined formally using\n   the LFB modeling XML schema.\n   Capability information\
    \ at the LFB level is an integral part of the\n   LFB model and provides for powerful\
    \ semantics.  For example, when\n   certain features of an LFB class are optional,\
    \ the CE needs to be\n   able to determine whether those optional features are\
    \ supported by a\n   given LFB instance.  The schema for the definition of LFB\
    \ classes\n   provides a means for identifying such components.\n   State information\
    \ is defined formally using LFB component constructs.\n"
- title: 3.1.2.  Relating LFB and FE Capability and State Model
  contents:
  - "3.1.2.  Relating LFB and FE Capability and State Model\n   Capability information\
    \ at the FE level describes the LFB classes that\n   the FE can instantiate, the\
    \ number of instances of each that can be\n   created, the topological (linkage)\
    \ limitations between these LFB\n   instances, etc.  Section 5 defines the FE-level\
    \ components including\n   capability information.  Since all information is represented\
    \ as\n   LFBs, this is provided by a single instance of the FE Object LFB\n  \
    \ class.  By using a single instance with a known LFB class and a known\n   instance\
    \ identification, the ForCES protocol can allow a CE to access\n   this information\
    \ whenever it needs to, including while the CE is\n   establishing the control\
    \ of the FE.\n   Once the FE capability is described to the CE, the FE state\n\
    \   information can be represented at two levels.  The first level is the\n  \
    \ logically separable and distinct packet processing functions, called\n   LFBs.\
    \  The second level of information describes how these individual\n   LFBs are\
    \ ordered and placed along the data path to deliver a complete\n   forwarding\
    \ plane service.  The interconnection and ordering of the\n   LFBs is called LFB\
    \ topology.  Section 3.2 discusses high-level\n   concepts around LFBs, whereas\
    \ Section 3.3 discusses LFB topology\n   issues.  This topology information is\
    \ represented as components of\n   the FE Object LFB instance, to allow the CE\
    \ to fetch and manipulate\n   this.\n"
- title: 3.2.   Logical Functional Block (LFB) Modeling
  contents:
  - "3.2.   Logical Functional Block (LFB) Modeling\n   Each LFB performs a well-defined\
    \ action or computation on the packets\n   passing through it.  Upon completion\
    \ of its prescribed function,\n   either the packets are modified in certain ways\
    \ (e.g., decapsulator,\n   marker), or some results are generated and stored,\
    \ often in the form\n   of metadata (e.g., classifier).  Each LFB typically performs\
    \ a single\n   action.  Classifiers, shapers, and meters are all examples of such\n\
    \   LFBs.  Modeling LFBs at such a fine granularity allows us to use a\n   small\
    \ number of LFBs to express the higher-order FE functions (such\n   as an IPv4\
    \ forwarder) precisely, which in turn can describe more\n   complex networking\
    \ functions and vendor implementations of software\n   and hardware.  These fine-grained\
    \ LFBs will be defined in detail in\n   one or more documents to be published\
    \ separately, using the material\n   in this model.\n   It is also the case that\
    \ LFBs may exist in order to provide a set of\n   components for control of FE\
    \ operation by the CE (i.e., a locus of\n   control), without tying that control\
    \ to specific packets or specific\n   parts of the data path.  An example of such\
    \ an LFB is the FE Object,\n   which provides the CE with information about the\
    \ FE as a whole, and\n   allows the FE to control some aspects of the FE, such\
    \ as the data\n   path itself.  Such LFBs will not have the packet-oriented properties\n\
    \   described in this section.\n   In general, multiple LFBs are contained in\
    \ one FE, as shown in\n   Figure 2, and all the LFBs share the same ForCES protocol\
    \ (Fp)\n   termination point that implements the ForCES protocol logic and\n \
    \  maintains the communication channel to and from the CE.\n                 \
    \            +-----------+\n                             |    CE     |\n     \
    \                        +-----------+\n                                   ^\n\
    \                                   | Fp reference point\n                   \
    \                |\n        +--------------------------|-----------------------------------+\n\
    \        | FE                       |                                   |\n  \
    \      |                          v                                   |\n    \
    \    | +----------------------------------------------------------+ |\n      \
    \  | |                ForCES protocol                           | |\n        |\
    \ |                   termination point                      | |\n        | +----------------------------------------------------------+\
    \ |\n        |           ^                            ^                     |\n\
    \        |           :                            : Internal control    |\n  \
    \      |           :                            :                     |\n    \
    \    |       +---:----------+             +---:----------|          |\n      \
    \  |       |   :LFB1      |             |   :     LFB2 |          |\n        |\
    \ =====>|   v          |============>|   v          |======>...|\n        | Inputs|\
    \ +----------+ |Outputs      | +----------+ |          |\n        | (P,M) | |Components|\
    \ |(P',M')      | |Components| |(P\",M\")   |\n        |       | +----------+\
    \ |             | +----------+ |          |\n        |       +--------------+\
    \             +--------------+          |\n        |                         \
    \                                     |\n        +--------------------------------------------------------------+\n\
    \                      Figure 2: Generic LFB diagram.\n   An LFB, as shown in\
    \ Figure 2, may have inputs, outputs, and\n   components that can be queried and\
    \ manipulated by the CE via an Fp\n   reference point (defined in RFC 3746 [RFC3746])\
    \ and the ForCES\n   protocol termination point.  The horizontal axis is in the\
    \ forwarding\n   plane for connecting the inputs and outputs of LFBs within the\
    \ same\n   FE.  P (with marks to indicate modification) indicates a data packet,\n\
    \   while M (with marks to indicate modification) indicates the metadata\n   associated\
    \ with a packet.  The vertical axis between the CE and the\n   FE denotes the\
    \ Fp reference point where bidirectional communication\n   between the CE and\
    \ FE occurs: the CE-to-FE communication is for\n   configuration, control, and\
    \ packet injection, while the FE-to-CE\n   communication is used for packet redirection\
    \ to the control plane,\n   reporting of monitoring and accounting information,\
    \ reporting of\n   errors, etc.  Note that the interaction between the CE and\
    \ the LFB is\n   only abstract and indirect.  The result of such an interaction\
    \ is for\n   the CE to manipulate the components of the LFB instances.\n   An\
    \ LFB can have one or more inputs.  Each input takes a pair of a\n   packet and\
    \ its associated metadata.  Depending upon the LFB input\n   port definition,\
    \ the packet or the metadata may be allowed to be\n   empty (or equivalently to\
    \ not be provided).  When input arrives at an\n   LFB, either the packet or its\
    \ associated metadata must be non-empty\n   or there is effectively no input.\
    \  (LFB operation generally may be\n   triggered by input arrival, by timers,\
    \ or by other system state.  It\n   is only in the case where the goal is to have\
    \ input drive operation\n   that the input must be non-empty.)\n   The LFB processes\
    \ the input, and produces one or more outputs, each\n   of which is a pair of\
    \ a packet and its associated metadata.  Again,\n   depending upon the LFB output\
    \ port definition, either the packet or\n   the metadata may be allowed to be\
    \ empty (or equivalently to be\n   absent).  Metadata attached to packets on output\
    \ may be metadata that\n   was received, or may be information about the packet\
    \ processing that\n   may be used by later LFBs in the FEs packet processing.\n\
    \   A namespace is used to associate a unique name and ID with each LFB\n   class.\
    \  The namespace MUST be extensible so that a new LFB class can\n   be added later\
    \ to accommodate future innovation in the forwarding\n   plane.\n   LFB operation\
    \ is specified in the model to allow the CE to understand\n   the behavior of\
    \ the forwarding data path.  For instance, the CE needs\n   to understand at what\
    \ point in the data path the IPv4 header TTL is\n   decremented by the FE.  That\
    \ is, the CE needs to know if a control\n   packet could be delivered to it either\
    \ before or after this point in\n   the data path.  In addition, the CE needs\
    \ to understand where and\n   what type of header modifications (e.g., tunnel\
    \ header append or\n   strip) are performed by the FEs.  Further, the CE works\
    \ to verify\n   that the various LFBs along a data path within an FE are compatible\n\
    \   to link together.  Connecting incompatible LFB instances will produce\n  \
    \ a non-working data path.  So the model is designed to provide\n   sufficient\
    \ information for the CE to make this determination.\n   Selecting the right granularity\
    \ for describing the functions of the\n   LFBs is an important aspect of this\
    \ model.  There is value to vendors\n   if the operation of LFB classes can be\
    \ expressed in sufficient detail\n   so that physical devices implementing different\
    \ LFB functions can be\n   integrated easily into an FE design.  However, the\
    \ model, and the\n   associated library of LFBs, must not be so detailed and so\
    \ specific\n   as to significantly constrain implementations.  Therefore, a semi-\n\
    \   formal specification is needed; that is, a text description of the\n   LFB\
    \ operation (human readable), but sufficiently specific and\n   unambiguous to\
    \ allow conformance testing and efficient design, so\n   that interoperability\
    \ between different CEs and FEs can be achieved.\n   The LFB class model specifies\
    \ the following, among other information:\n   o  number of inputs and outputs\
    \ (and whether they are configurable)\n   o  metadata read/consumed from inputs\n\
    \   o  metadata produced at the outputs\n   o  packet types accepted at the inputs\
    \ and emitted at the outputs\n   o  packet content modifications (including encapsulation\
    \ or\n      decapsulation)\n   o  packet routing criteria (when multiple outputs\
    \ on an LFB are\n      present)\n   o  packet timing modifications\n   o  packet\
    \ flow ordering modifications\n   o  LFB capability information components\n \
    \  o  events that can be detected by the LFB, with notification to the\n     \
    \ CE\n   o  LFB operational components\n   Section 4 of this document provides\
    \ a detailed discussion of the LFB\n   model with a formal specification of LFB\
    \ class schema.  The rest of\n   Section 3.2 only intends to provide a conceptual\
    \ overview of some\n   important issues in LFB modeling, without covering all\
    \ the specific\n   details.\n"
- title: 3.2.1.  LFB Outputs
  contents:
  - "3.2.1.  LFB Outputs\n   An LFB output is a conceptual port on an LFB that can\
    \ send\n   information to another LFB.  The information sent on that port is a\n\
    \   pair of a packet and associated metadata, one of which may be empty.\n   (If\
    \ both were empty, there would be no output.)\n   A single LFB output can be connected\
    \ to only one LFB input.  This is\n   required to make the packet flow through\
    \ the LFB topology\n   unambiguous.\n   Some LFBs will have a single output, as\
    \ depicted in Figure 3.a.\n    +---------------+               +-----------------+\n\
    \    |               |               |                 |\n    |              \
    \ |               |             OUT +-->\n    ...          OUT +-->          \
    \ ...               |\n    |               |               |    EXCEPTIONOUT +-->\n\
    \    |               |               |                 |\n    +---------------+\
    \               +-----------------+\n    a. One output               b. Two distinct\
    \ outputs\n    +---------------+               +-----------------+\n    |    \
    \           |               |    EXCEPTIONOUT +-->\n    |         OUT:1 +--> \
    \           |                 |\n    ...       OUT:2 +-->           ...      \
    \    OUT:1 +-->\n    |         ...   +...            |           OUT:2 +-->\n\
    \    |         OUT:n +-->            |           ...   +...\n    +---------------+\
    \               |           OUT:n +-->\n                                    +-----------------+\n\
    \    c. One output group       d. One output and one output group\n       Figure\
    \ 3: Examples of LFBs with various output combinations.\n   To accommodate a non-trivial\
    \ LFB topology, multiple LFB outputs are\n   needed so that an LFB class can fork\
    \ the data path.  Two mechanisms\n   are provided for forking: multiple singleton\
    \ outputs and output\n   groups, which can be combined in the same LFB class.\n\
    \   Multiple separate singleton outputs are defined in an LFB class to\n   model\
    \ a predetermined number of semantically different outputs.  That\n   is, the\
    \ LFB class definition MUST include the number of outputs,\n   implying the number\
    \ of outputs is known when the LFB class is\n   defined.  Additional singleton\
    \ outputs cannot be created at LFB\n   instantiation time, nor can they be created\
    \ on the fly after the LFB\n   is instantiated.\n   For example, an IPv4 LPM (Longest-Prefix-Matching)\
    \ LFB may have one\n   output (OUT) to send those packets for which the LPM look-up\
    \ was\n   successful, passing a META_ROUTEID as metadata; and have another\n \
    \  output (EXCEPTIONOUT) for sending exception packets when the LPM\n   look-up\
    \ failed.  This example is depicted in Figure 3.b.  Packets\n   emitted by these\
    \ two outputs not only require different downstream\n   treatment, but they are\
    \ a result of two different conditions in the\n   LFB and each output carries\
    \ different metadata.  This concept assumes\n   that the number of distinct outputs\
    \ is known when the LFB class is\n   defined.  For each singleton output, the\
    \ LFB class definition defines\n   the types of frames (packets) and metadata\
    \ the output emits.\n   An output group, on the other hand, is used to model the\
    \ case where a\n   flow of similar packets with an identical set of permitted\
    \ metadata\n   needs to be split into multiple paths.  In this case, the number\
    \ of\n   such paths is not known when the LFB class is defined because it is\n\
    \   not an inherent property of the LFB class.  An output group consists\n   of\
    \ a number of outputs, called the output instances of the group,\n   where all\
    \ output instances share the same frame (packet) and metadata\n   emission definitions\
    \ (see Figure 3.c).  Each output instance can\n   connect to a different downstream\
    \ LFB, just as if they were separate\n   singleton outputs, but the number of\
    \ output instances can differ\n   between LFB instances of the same LFB class.\
    \  The class definition\n   may include a lower and/or an upper limit on the number\
    \ of outputs.\n   In addition, for configurable FEs, the FE capability information\
    \ may\n   define further limits on the number of instances in specific output\n\
    \   groups for certain LFBs.  The actual number of output instances in a\n   group\
    \ is a component of the LFB instance, which is read-only for\n   static topologies,\
    \ and read-write for dynamic topologies.  The output\n   instances in a group\
    \ are numbered sequentially, from 0 to N-1, and\n   are addressable from within\
    \ the LFB.  To use Output Port groups, the\n   LFB has to have a built-in mechanism\
    \ to select one specific output\n   instance for each packet.  This mechanism\
    \ is described in the textual\n   definition of the class and is typically configurable\
    \ via some\n   attributes of the LFB.\n   For example, consider a redirector LFB,\
    \ whose sole purpose is to\n   direct packets to one of N downstream paths based\
    \ on one of the\n   metadata associated with each arriving packet.  Such an LFB\
    \ is fairly\n   versatile and can be used in many different places in a topology.\n\
    \   For example, given LFBs that record the type of packet in a FRAMETYPE\n  \
    \ metadatum, or a packet rate class in a COLOR metadatum, one may uses\n   these\
    \ metadata for branching.  A redirector can be used to divide the\n   data path\
    \ into an IPv4 and an IPv6 path based on a FRAMETYPE\n   metadatum (N=2), or to\
    \ fork into rate-specific paths after metering\n   using the COLOR metadatum (red,\
    \ yellow, green; N=3), etc.\n   Using an output group in the above LFB class provides\
    \ the desired\n   flexibility to adapt each instance of this class to the required\n\
    \   operation.  The metadata to be used as a selector for the output\n   instance\
    \ is a property of the LFB.  For each packet, the value of the\n   specified metadata\
    \ may be used as a direct index to the output\n   instance.  Alternatively, the\
    \ LFB may have a configurable selector\n   table that maps a metadatum value to\
    \ output instance.\n   Note that other LFBs may also use the output group concept\
    \ to build\n   in similar adaptive forking capability.  For example, a classifier\n\
    \   LFB with one input and N outputs can be defined easily by using the\n   output\
    \ group concept.  Alternatively, a classifier LFB with one\n   singleton output\
    \ in combination with an explicit N-output re-director\n   LFB models the same\
    \ processing behavior.  The decision of whether to\n   use the output group model\
    \ for a certain LFB class is left to the LFB\n   class designers.\n   The model\
    \ allows the output group to be combined with other singleton\n   output(s) in\
    \ the same class, as demonstrated in Figure 3.d.  The LFB\n   here has two types\
    \ of outputs, OUT, for normal packet output, and\n   EXCEPTIONOUT, for packets\
    \ that triggered some exception.  The normal\n   OUT has multiple instances; thus,\
    \ it is an output group.\n   In summary, the LFB class may define one output,\
    \ multiple singleton\n   outputs, one or more output groups, or a combination\
    \ thereof.\n   Multiple singleton outputs should be used when the LFB must provide\n\
    \   for forking the data path and at least one of the following\n   conditions\
    \ hold:\n   o  the number of downstream directions is inherent from the\n    \
    \  definition of the class and hence fixed\n   o  the frame type and set of permitted\
    \ metadata emitted on any of the\n      outputs are different from what is emitted\
    \ on the other outputs\n      (i.e., they cannot share their frametype and permitted\
    \ metadata\n      definitions)\n   An output group is appropriate when the LFB\
    \ must provide for forking\n   the data path and at least one of the following\
    \ conditions hold:\n   o  the number of downstream directions is not known when\
    \ the LFB\n      class is defined\n   o  the frame type and set of metadata emitted\
    \ on these outputs are\n      sufficiently similar or, ideally, identical, such\
    \ they can share\n      the same output definition\n"
- title: 3.2.2.  LFB Inputs
  contents:
  - "3.2.2.  LFB Inputs\n   An LFB input is a conceptual port on an LFB on which the\
    \ LFB can\n   receive information from other LFBs.  The information is typically\
    \ a\n   pair of a packet and its associated metadata.  Either the packet or\n\
    \   the metadata may for some LFBs and some situations be empty.  They\n   cannot\
    \ both be empty, as then there is no input.\n   For LFB instances that receive\
    \ packets from more than one other LFB\n   instance (fan-in), there are three\
    \ ways to model fan-in, all\n   supported by the LFB model and can all be combined\
    \ in the same LFB:\n   o  Implicit multiplexing via a single input\n   o  Explicit\
    \ multiplexing via multiple singleton inputs\n   o  Explicit multiplexing via\
    \ a group of inputs (input group)\n   The simplest form of multiplexing uses a\
    \ singleton input\n   (Figure 4.a).  Most LFBs will have only one singleton input.\n\
    \   Multiplexing into a single input is possible because the model allows\n  \
    \ more than one LFB output to connect to the same LFB input.  This\n   property\
    \ applies to any LFB input without any special provisions in\n   the LFB class.\
    \  Multiplexing into a single input is applicable when\n   the packets from the\
    \ upstream LFBs are similar in frametype and\n   accompanying metadata, and require\
    \ similar processing.  Note that\n   this model does not address how potential\
    \ contention is handled when\n   multiple packets arrive simultaneously.  If contention\
    \ handling needs\n   to be explicitly modeled, one of the other two modeling solutions\n\
    \   must be used.\n   The second method to model fan-in uses individually defined\
    \ singleton\n   inputs (Figure 4.b).  This model is meant for situations where\
    \ the\n   LFB needs to handle distinct types of packet streams, requiring\n  \
    \ input-specific handling inside the LFB, and where the number of such\n   distinct\
    \ cases is known when the LFB class is defined.  For example,\n   an LFB that\
    \ can perform both Layer 2 decapsulation (to Layer 3) and\n   Layer 3 encapsulation\
    \ (to Layer 2) may have two inputs, one for\n   receiving Layer 2 frames for decapsulation,\
    \ and one for receiving\n   Layer 3 frames for encapsulation.  This LFB type expects\
    \ different\n   frames (L2 versus L3) at its inputs, each with different sets\
    \ of\n   metadata, and would thus apply different processing on frames\n   arriving\
    \ at these inputs.  This model is capable of explicitly\n   addressing packet\
    \ contention by defining how the LFB class handles\n   the contending packets.\n\
    \   +--------------+       +------------------------+\n   | LFB X        +---+\
    \   |                        |\n   +--------------+   |   |                  \
    \      |\n                      |   |                        |\n   +--------------+\
    \   v   |                        |\n   | LFB Y        +---+-->|input     Meter\
    \ LFB     |\n   +--------------+   ^   |                        |\n          \
    \            |   |                        |\n   +--------------+   |   |     \
    \                   |\n   | LFB Z        |---+   |                        |\n\
    \   +--------------+       +------------------------+\n   (a) An LFB connects\
    \ with multiple upstream LFBs via a single input.\n   +--------------+       +------------------------+\n\
    \   | LFB X        +---+   |                        |\n   +--------------+   +-->|layer2\
    \                  |\n   +--------------+       |                        |\n \
    \  | LFB Y        +------>|layer3     LFB          |\n   +--------------+    \
    \   +------------------------+\n   (b) An LFB connects with multiple upstream\
    \ LFBs via two separate\n   singleton inputs.\n   +--------------+       +------------------------+\n\
    \   | Queue LFB #1 +---+   |                        |\n   +--------------+   |\
    \   |                        |\n                      |   |                  \
    \      |\n   +--------------+   +-->|in:0   \\                |\n   | Queue LFB\
    \ #2 +------>|in:1   | input group    |\n   +--------------+       |...    | \
    \               |\n                      +-->|in:N-1 /                |\n   ...\
    \                |   |                        |\n   +--------------+   |   | \
    \                       |\n   | Queue LFB #N |---+   |     Scheduler LFB     \
    \ |\n   +--------------+       +------------------------+\n   (c) A Scheduler\
    \ LFB uses an input group to differentiate which queue\n   LFB packets are coming\
    \ from.\n        Figure 4: Examples of LFBs with various input combinations.\n\
    \   The third method to model fan-in uses the concept of an input group.\n   The\
    \ concept is similar to the output group introduced in the previous\n   section\
    \ and is depicted in Figure 4.c.  An input group consists of a\n   number of input\
    \ instances, all sharing the properties (same frame and\n   metadata expectations).\
    \  The input instances are numbered from 0 to\n   N-1.  From the outside, these\
    \ inputs appear as normal inputs, i.e.,\n   any compatible upstream LFB can connect\
    \ its output to one of these\n   inputs.  When a packet is presented to the LFB\
    \ at a particular input\n   instance, the index of the input where the packet\
    \ arrived is known to\n   the LFB and this information may be used in the internal\
    \ processing.\n   For example, the input index can be used as a table selector,\
    \ or as\n   an explicit precedence selector to resolve contention.  As with\n\
    \   output groups, the number of input instances in an input group is not\n  \
    \ defined in the LFB class.  However, the class definition may include\n   restrictions\
    \ on the range of possible values.  In addition, if an FE\n   supports configurable\
    \ topologies, it may impose further limitations\n   on the number of instances\
    \ for particular port group(s) of a\n   particular LFB class.  Within these limitations,\
    \ different instances\n   of the same class may have a different number of input\
    \ instances.\n   The number of actual input instances in the group is a component\n\
    \   defined in the LFB class, which is read-only for static topologies,\n   and\
    \ is read-write for configurable topologies.\n   As an example for the input group,\
    \ consider the Scheduler LFB\n   depicted in Figure 4.c.  Such an LFB receives\
    \ packets from a number\n   of Queue LFBs via a number of input instances, and\
    \ uses the input\n   index information to control contention resolution and scheduling.\n\
    \   In summary, the LFB class may define one input, multiple singleton\n   inputs,\
    \ one or more input groups, or a combination thereof.  Any\n   input allows for\
    \ implicit multiplexing of similar packet streams via\n   connecting multiple\
    \ outputs to the same input.  Explicit multiple\n   singleton inputs are useful\
    \ when either the contention handling must\n   be handled explicitly or when the\
    \ LFB class must receive and process\n   a known number of distinct types of packet\
    \ streams.  An input group\n   is suitable when contention handling must be modeled\
    \ explicitly, but\n   the number of inputs is not inherent from the class (and\
    \ hence is not\n   known when the class is defined), or when it is critical for\
    \ LFB\n   operation to know exactly on which input the packet was received.\n"
- title: 3.2.3.  Packet Type
  contents:
  - "3.2.3.  Packet Type\n   When LFB classes are defined, the input and output packet\
    \ formats\n   (e.g., IPv4, IPv6, Ethernet) MUST be specified.  These are the types\n\
    \   of packets that a given LFB input is capable of receiving and\n   processing,\
    \ or that a given LFB output is capable of producing.  This\n   model requires\
    \ that distinct packet types be uniquely labeled with a\n   symbolic name and/or\
    \ ID.\n   Note that each LFB has a set of packet types that it operates on, but\n\
    \   does not care whether the underlying implementation is passing a\n   greater\
    \ portion of the packets.  For example, an IPv4 LFB might only\n   operate on\
    \ IPv4 packets, but the underlying implementation may or may\n   not be stripping\
    \ the L2 header before handing it over.  Whether or\n   not such processing is\
    \ happening is opaque to the CE.\n"
- title: 3.2.4.  Metadata
  contents:
  - "3.2.4.  Metadata\n   Metadata is state that is passed from one LFB to another\
    \ alongside a\n   packet.  The metadata passed with the packet assists subsequent\
    \ LFBs\n   to process that packet.\n   The ForCES model defines metadata as precise\
    \ atomic definitions in\n   the form of label, value pairs.\n   The ForCES model\
    \ provides to the authors of LFB classes a way to\n   formally define how to achieve\
    \ metadata creation, modification,\n   reading, as well as consumption (deletion).\n\
    \   Inter-FE metadata, i.e., metadata crossing FEs, while it is likely to\n  \
    \ be semantically similar to this metadata, is out of scope for this\n   document.\n\
    \   Section 4 has informal details on metadata.\n"
- title: 3.2.4.1.  Metadata Lifecycle within the ForCES Model
  contents:
  - "3.2.4.1.  Metadata Lifecycle within the ForCES Model\n   Each metadatum is modeled\
    \ as a <label, value> pair, where the label\n   identifies the type of information\
    \ (e.g., \"color\"), and its value\n   holds the actual information (e.g., \"\
    red\").  The label here is shown\n   as a textual label, but for protocol processing\
    \ it is associated with\n   a unique numeric value (identifier).\n   To ensure\
    \ inter-operability between LFBs, the LFB class specification\n   must define\
    \ what metadata the LFB class \"reads\" or \"consumes\" on its\n   input(s) and\
    \ what metadata it \"produces\" on its output(s).  For\n   maximum extensibility,\
    \ this definition should specify neither which\n   LFBs the metadata is expected\
    \ to come from for a consumer LFB nor\n   which LFBs are expected to consume metadata\
    \ for a given producer LFB.\n"
- title: 3.2.4.2.  Metadata Production and Consumption
  contents:
  - "3.2.4.2.  Metadata Production and Consumption\n   For a given metadatum on a\
    \ given packet path, there MUST be at least\n   one producer LFB that creates\
    \ that metadatum and SHOULD be at least\n   one consumer LFB that needs that metadatum.\n\
    \   In the ForCES model, the producer and consumer LFBs of a metadatum\n   are\
    \ not required to be adjacent.  In addition, there may be multiple\n   producers\
    \ and consumers for the same metadatum.  When a packet path\n   involves multiple\
    \ producers of the same metadatum, then subsequent\n   producers overwrite that\
    \ metadatum value.\n   The metadata that is produced by an LFB is specified by\
    \ the LFB class\n   definition on a per-output-port-group basis.  A producer may\
    \ always\n   generate the metadata on the port group, or may generate it only\n\
    \   under certain conditions.  We call the former \"unconditional\"\n   metadata,\
    \ whereas the latter is \"conditional\" metadata.  For example,\n   deep packet\
    \ inspection LFB might produce several pieces of metadata\n   about the packet.\
    \  The first metadatum might be the IP protocol (TCP,\n   UDP, SCTP, ...) being\
    \ carried, and two additional metadata items\n   might be the source and destination\
    \ port number.  These additional\n   metadata items are conditional on the value\
    \ of the first metadatum\n   (IP carried protocol) as they are only produced for\
    \ protocols that\n   use port numbers.  In the case of conditional metadata, it\
    \ should be\n   possible to determine from the definition of the LFB when\n  \
    \ \"conditional\" metadata is produced.  The consumer behavior of an LFB,\n  \
    \ that is, the metadata that the LFB needs for its operation, is\n   defined in\
    \ the LFB class definition on a per-input-port-group basis.\n   An input port\
    \ group may \"require\" a given metadatum, or may treat it\n   as \"optional\"\
    \ information.  In the latter case, the LFB class\n   definition MUST explicitly\
    \ define what happens if any optional\n   metadata is not provided.  One approach\
    \ is to specify a default value\n   for each optional metadatum, and assume that\
    \ the default value is\n   used for any metadata that is not provided with the\
    \ packet.\n   When specifying the metadata tags, some harmonization effort must\
    \ be\n   made so that the producer LFB class uses the same tag as its intended\n\
    \   consumer(s).\n"
- title: 3.2.4.3.  LFB Operations on Metadata
  contents:
  - "3.2.4.3.  LFB Operations on Metadata\n   When the packet is processed by an LFB\
    \ (i.e., between the time it is\n   received and forwarded by the LFB), the LFB\
    \ may perform read, write,\n   and/or consume operations on any active metadata\
    \ associated with the\n   packet.  If the LFB is considered to be a black box,\
    \ one of the\n   following operations is performed on each active metadatum.\n\
    \      *  IGNORE: ignores and forwards the metadatum\n      *  READ: reads and\
    \ forwards the metadatum\n      *  READ/RE-WRITE: reads, over-writes, and forwards\
    \ the metadatum\n      *  WRITE: writes and forwards the metadatum (can also be\
    \ used to\n         create new metadata)\n      *  READ-AND-CONSUME: reads and\
    \ consumes the metadatum\n      *  CONSUME: consumes metadatum without reading\n\
    \   The last two operations terminate the life-cycle of the metadatum,\n   meaning\
    \ that the metadatum is not forwarded with the packet when the\n   packet is sent\
    \ to the next LFB.\n   In the ForCES model, a new metadatum is generated by an\
    \ LFB when the\n   LFB applies a WRITE operation to a metadatum type that was\
    \ not\n   present when the packet was received by the LFB.  Such implicit\n  \
    \ creation may be unintentional by the LFB; that is, the LFB may apply\n   the\
    \ WRITE operation without knowing or caring whether or not the\n   given metadatum\
    \ existed.  If it existed, the metadatum gets over-\n   written; if it did not\
    \ exist, the metadatum is created.\n   For LFBs that insert packets into the model,\
    \ WRITE is the only\n   meaningful metadata operation.\n   For LFBs that remove\
    \ the packet from the model, they may either READ-\n   AND-CONSUME (read) or CONSUME\
    \ (ignore) each active metadatum\n   associated with the packet.\n"
- title: 3.2.5.  LFB Events
  contents:
  - "3.2.5.  LFB Events\n   During operation, various conditions may occur that can\
    \ be detected\n   by LFBs.  Examples range from link failure or restart to timer\n\
    \   expiration in special purpose LFBs.  The CE may wish to be notified\n   of\
    \ the occurrence of such events.  The description of how such\n   messages are\
    \ sent, and their format, is part of the Forwarding and\n   Control Element Separation\
    \ (ForCES) protocol [RFC5810] document.\n   Indicating how such conditions are\
    \ understood is part of the job of\n   this model.\n   Events are declared in\
    \ the LFB class definition.  The LFB event\n   declaration constitutes:\n   o\
    \  a unique 32-bit identifier.\n   o  An LFB component that is used to trigger\
    \ the event.  This entity\n      is known as the event target.\n   o  A condition\
    \ that will happen to the event target that will result\n      in a generation\
    \ of an event to the CE.  Examples of a condition\n      include something getting\
    \ created or deleted, a config change,\n      etc.\n   o  What should be reported\
    \ to the CE by the FE if the declared\n      condition is met.\n   The declaration\
    \ of an event within an LFB class essentially defines\n   what part of the LFB\
    \ component(s) need to be monitored for events,\n   what condition on the LFB\
    \ monitored LFB component an FE should detect\n   to trigger such an event, and\
    \ what to report to the CE when the event\n   is triggered.\n   While events may\
    \ be declared by the LFB class definition, runtime\n   activity is controlled\
    \ using built-in event properties using LFB\n   component properties (discussed\
    \ in Section 3.2.6).  A CE subscribes\n   to the events on an LFB class instance\
    \ by setting an event property\n   for subscription.  Each event has a subscription\
    \ property that is by\n   default off.  A CE wishing to receive a specific event\
    \ needs to turn\n   on the subscription property at runtime.\n   Event properties\
    \ also provide semantics for runtime event filtering.\n   A CE may set an event\
    \ property to further suppress events to which it\n   has already subscribed.\
    \  The LFB model defines such filters to\n   include threshold values, hysteresis,\
    \ time intervals, number of\n   events, etc.\n   The contents of reports with\
    \ events are designed to allow for the\n   common, closely related information\
    \ that the CE can be strongly\n   expected to need to react to the event.  It\
    \ is not intended to carry\n   information that the CE already has, large volumes\
    \ of information, or\n   information related in complex fashions.\n   From a conceptual\
    \ point of view, at runtime, event processing is\n   split into:\n   1.  Detection\
    \ of something happening to the (declared during LFB\n       class definition)\
    \ event target.  Processing the next step happens\n       if the CE subscribed\
    \ (at runtime) to the event.\n   2.  Checking of the (declared during LFB class\
    \ definition) condition\n       on the LFB event target.  If the condition is\
    \ met, proceed with\n       the next step.\n   3.  Checking (runtime set) event\
    \ filters if they exist to see if the\n       event should be reported or suppressed.\
    \  If the event is to be\n       reported, proceed to the next step.\n   4.  Submitting\
    \ of the declared report to the CE.\n   Section 4.7.6 discusses events in more\
    \ details.\n"
- title: 3.2.6.  Component Properties
  contents:
  - "3.2.6.  Component Properties\n   LFBs and structures are made up of components,\
    \ containing the\n   information that the CE needs to see and/or change about\
    \ the\n   functioning of the LFB.  These components, as described in detail in\n\
    \   Section 4.7, may be basic values, complex structures (containing\n   multiple\
    \ components themselves, each of which can be values,\n   structures, or tables),\
    \ or tables (which contain values, structures,\n   or tables).  Components may\
    \ be defined such that their appearance in\n   LFB instances is optional.  Components\
    \ may be readable or writable at\n   the discretion of the FE implementation.\
    \  The CE needs to know these\n   properties.  Additionally, certain kinds of\
    \ components (arrays /\n   tables, aliases, and events) have additional property\
    \ information\n   that the CE may need to read or write.  This model defines the\n\
    \   structure of the property information for all defined data types.\n   Section\
    \ 4.8 describes properties in more details.\n"
- title: 3.2.7.  LFB Versioning
  contents:
  - "3.2.7.  LFB Versioning\n   LFB class versioning is a method to enable incremental\
    \ evolution of\n   LFB classes.  In general, an FE is not allowed to contain an\
    \ LFB\n   instance for more than one version of a particular class.\n   Inheritance\
    \ (discussed next in Section 3.2.8) has special rules.  If\n   an FE data path\
    \ model containing an LFB instance of a particular\n   class C also simultaneously\
    \ contains an LFB instance of a class C'\n   inherited from class C; C could have\
    \ a different version than C'.\n   LFB class versioning is supported by requiring\
    \ a version string in\n   the class definition.  CEs may support multiple versions\
    \ of a\n   particular LFB class to provide backward compatibility, but FEs MUST\n\
    \   NOT support more than one version of a particular class.\n   Versioning is\
    \ not restricted to making backward-compatible changes.\n   It is specifically\
    \ expected to be used to make changes that cannot be\n   represented by inheritance.\
    \  Often this will be to correct errors,\n   and hence may not be backward compatible.\
    \  It may also be used to\n   remove components that are not considered useful\
    \ (particularly if\n   they were previously mandatory, and hence were an implementation\n\
    \   impediment).\n"
- title: 3.2.8.  LFB Inheritance
  contents:
  - "3.2.8.  LFB Inheritance\n   LFB class inheritance is supported in the FE model\
    \ as a method to\n   define new LFB classes.  This also allows FE vendors to add\
    \ vendor-\n   specific extensions to standardized LFBs.  An LFB class specification\n\
    \   MUST specify the base class and version number it inherits from (the\n   default\
    \ is the base LFB class).  Multiple inheritance is not allowed,\n   however, to\
    \ avoid unnecessary complexity.\n   Inheritance should be used only when there\
    \ is significant reuse of\n   the base LFB class definition.  A separate LFB class\
    \ should be\n   defined if little or no reuse is possible between the derived\
    \ and the\n   base LFB class.\n   An interesting issue related to class inheritance\
    \ is backward\n   compatibility between a descendant and an ancestor class.  Consider\n\
    \   the following hypothetical scenario where a standardized LFB class\n   \"\
    L1\" exists.  Vendor A builds an FE that implements LFB \"L1\", and\n   vendor\
    \ B builds a CE that can recognize and operate on LFB \"L1\".\n   Suppose that\
    \ a new LFB class, \"L2\", is defined based on the existing\n   \"L1\" class by\
    \ extending its capabilities incrementally.  Let us\n   examine the FE backward-compatibility\
    \ issue by considering what would\n   happen if vendor B upgrades its FE from\
    \ \"L1\" to \"L2\" and vendor C's\n   CE is not changed.  The old L1-based CE\
    \ can interoperate with the new\n   L2-based FE if the derived LFB class \"L2\"\
    \ is indeed backward\n   compatible with the base class \"L1\".\n   The reverse\
    \ scenario is a much less problematic case, i.e., when CE\n   vendor B upgrades\
    \ to the new LFB class \"L2\", but the FE is not\n   upgraded.  Note that as long\
    \ as the CE is capable of working with\n   older LFB classes, this problem does\
    \ not affect the model; hence we\n   will use the term \"backward compatibility\"\
    \ to refer to the first\n   scenario concerning FE backward compatibility.\n \
    \  Backward compatibility can be designed into the inheritance model by\n   constraining\
    \ LFB inheritance to require that the derived class be a\n   functional superset\
    \ of the base class (i.e., the derived class can\n   only add functions to the\
    \ base class, but not remove functions).\n   Additionally, the following mechanisms\
    \ are required to support FE\n   backward compatibility:\n   1.  When detecting\
    \ an LFB instance of an LFB type that is unknown to\n       the CE, the CE MUST\
    \ be able to query the base class of such an\n       LFB from the FE.\n   2. \
    \ The LFB instance on the FE SHOULD support a backward-\n       compatibility\
    \ mode (meaning the LFB instance reverts itself back\n       to the base class\
    \ instance), and the CE SHOULD be able to\n       configure the LFB to run in\
    \ such a mode.\n"
- title: 3.3.  ForCES Model Addressing
  contents:
  - "3.3.  ForCES Model Addressing\n   Figure 5 demonstrates the abstraction of the\
    \ different ForCES model\n   entities.  The ForCES protocol provides the mechanism\
    \ to uniquely\n   identify any of the LFB class instance components.\n       \
    \ FE Address = FE01\n        +--------------------------------------------------------------+\n\
    \        |                                                              |\n  \
    \      | +--------------+             +--------------+                |\n    \
    \    | | LFB ClassID 1|             |LFB ClassID 91|                |\n      \
    \  | | InstanceID 3 |============>|InstanceID 3  |======>...      |\n        |\
    \ | +----------+ |             | +----------+ |                |\n        | |\
    \ |Components| |             | |Components| |                |\n        | | +----------+\
    \ |             | +----------+ |                |\n        | +--------------+\
    \             +--------------+                |\n        |                   \
    \                                           |\n        +--------------------------------------------------------------+\n\
    \                      Figure 5: FE entity hierarchy.\n   At the top of the addressing\
    \ hierarchy is the FE identifier.  In the\n   example above, the 32-bit FE identifier\
    \ is illustrated with the\n   mnemonic FE01.  The next 32-bit entity selector\
    \ is the LFB ClassID.\n   In the illustration above, two LFB classes with identifiers\
    \ 1 and 91\n   are demonstrated.  The example above further illustrates one instance\n\
    \   of each of the two classes.  The scope of the 32-bit LFB class\n   instance\
    \ identifier is valid only within the LFB class.  To emphasize\n   that point,\
    \ each of class 1 and 91 has an instance of 3.\n   Using the described addressing\
    \ scheme, a message could be sent to\n   address FE01, LFB ClassID 1, LFB InstanceID\
    \ 3, utilizing the ForCES\n   protocol.  However, to be effective, such a message\
    \ would have to\n   target entities within an LFB.  These entities could be carrying\n\
    \   state, capability, etc.  These are further illustrated in Figure 6\n   below.\n\
    \          LFB Class ID 1,InstanceID 3 Components\n          +-------------------------------------+\n\
    \          |                                     |\n          | LFB ComponentID\
    \ 1                   |\n          | +----------------------+            |\n \
    \         | |                      |            |\n          | +----------------------+\
    \            |\n          |                                     |\n          |\
    \ LFB ComponentID 31                  |\n          | +----------------------+\
    \            |\n          | |                      |            |\n          |\
    \ +----------------------+            |\n          |                         \
    \            |\n          | LFB ComponentID 51                  |\n          |\
    \ +----------------------+            |\n          | | LFB ComponentID 89   |\
    \            |\n          | | +-----------------+  |            |\n          |\
    \ | |                 |  |            |\n          | | +-----------------+  |\
    \            |\n          | +----------------------+            |\n          |\
    \                                     |\n          |                         \
    \            |\n          +-------------------------------------+\n          \
    \               Figure 6: LFB hierarchy.\n   Figure 6 zooms into the components\
    \ carried by LFB Class ID 1, LFB\n   InstanceID 3 from Figure 5.\n   The example\
    \ shows three components with 32-bit component identifiers\n   1, 31, and 51.\
    \  LFB ComponentID 51 is a complex structure\n   encapsulating within it an entity\
    \ with LFB ComponentID 89.  LFB\n   ComponentID 89 could be a complex structure\
    \ itself, but is restricted\n   in the example for the sake of clarity.\n"
- title: '3.3.1.  Addressing LFB Components: Paths and Keys'
  contents:
  - "3.3.1.  Addressing LFB Components: Paths and Keys\n   As mentioned above, LFB\
    \ components could be complex structures, such\n   as a table, or even more complex\
    \ structures such as a table whose\n   cells are further tables, etc.  The ForCES\
    \ model XML schema\n   (Section 4) allows for uniquely identifying anything with\
    \ such\n   complexity, utilizing the concept of dot-annotated static paths and\n\
    \   content addressing of paths as derived from keys.  As an example, if\n   LFB\
    \ ComponentID 51 were a structure, then the path to LFB ComponentID\n   89 above\
    \ will be 51.89.\n   LFB ComponentID 51 might represent a table (an array).  In\
    \ that case,\n   to select the LFB component with ID 89 from within the 7th entry\
    \ of\n   the table, one would use the path 51.7.89.  In addition to supporting\n\
    \   explicit table element selection by including an index in the dotted\n   path,\
    \ the model supports identifying table elements by their\n   contents.  This is\
    \ referred to as using keys, or key indexing.  So,\n   as a further example, if\
    \ ComponentID 51 was a table that was key\n   index-able, then a key describing\
    \ content could also be passed by the\n   CE, along with path 51 to select the\
    \ table, and followed by the path\n   89 to select the table structure element,\
    \ which upon computation by\n   the FE would resolve to the LFB ComponentID 89\
    \ within the specified\n   table entry.\n"
- title: 3.4.  FE Data Path Modeling
  contents:
  - "3.4.  FE Data Path Modeling\n   Packets coming into the FE from ingress ports\
    \ generally flow through\n   one or more LFBs before leaving out of the egress\
    \ ports.  How an FE\n   treats a packet depends on many factors, such as type\
    \ of the packet\n   (e.g., IPv4, IPv6, or MPLS), header values, time of arrival,\
    \ etc.\n   The result of LFB processing may have an impact on how the packet is\n\
    \   to be treated in downstream LFBs.  This differentiation of packet\n   treatment\
    \ downstream can be conceptualized as having alternative data\n   paths in the\
    \ FE.  For example, the result of a 6-tuple classification\n   performed by a\
    \ classifier LFB could control which rate meter is\n   applied to the packet by\
    \ a rate meter LFB in a later stage in the\n   data path.\n   LFB topology is\
    \ a directed graph representation of the logical data\n   paths within an FE,\
    \ with the nodes representing the LFB instances and\n   the directed link depicting\
    \ the packet flow direction from one LFB to\n   the next.  Section 3.4.1 discusses\
    \ how the FE data paths can be\n   modeled as LFB topology, while Section 3.4.2\
    \ focuses on issues\n   related to LFB topology reconfiguration.\n"
- title: 3.4.1.  Alternative Approaches for Modeling FE Data Paths
  contents:
  - "3.4.1.  Alternative Approaches for Modeling FE Data Paths\n   There are two basic\
    \ ways to express the differentiation in packet\n   treatment within an FE; one\
    \ represents the data path directly and\n   graphically (topological approach)\
    \ and the other utilizes metadata\n   (the encoded state approach).\n   o  Topological\
    \ Approach\n   Using this approach, differential packet treatment is expressed\
    \ by\n   splitting the LFB topology into alternative paths.  In other words,\n\
    \   if the result of an LFB operation controls how the packet is further\n   processed,\
    \ then such an LFB will have separate output ports, one for\n   each alternative\
    \ treatment, connected to separate sub-graphs, each\n   expressing the respective\
    \ treatment downstream.\n   o  Encoded State Approach\n   An alternate way of\
    \ expressing differential treatment is by using\n   metadata.  The result of the\
    \ operation of an LFB can be encoded in a\n   metadatum, which is passed along\
    \ with the packet to downstream LFBs.\n   A downstream LFB, in turn, can use the\
    \ metadata and its value (e.g.,\n   as an index into some table) to determine\
    \ how to treat the packet.\n   Theoretically, either approach could substitute\
    \ for the other, so one\n   could consider using a single pure approach to describe\
    \ all data\n   paths in an FE.  However, neither model by itself results in the\
    \ best\n   representation for all practically relevant cases.  For a given FE\n\
    \   with certain logical data paths, applying the two different modeling\n   approaches\
    \ will result in very different looking LFB topology graphs.\n   A model using\
    \ only the topological approach may require a very large\n   graph with many links\
    \ or paths, and nodes (i.e., LFB instances) to\n   express all alternative data\
    \ paths.  On the other hand, a model using\n   only the encoded state model would\
    \ be restricted to a string of LFBs,\n   which is not an intuitive way to describe\
    \ different data paths (such\n   as MPLS and IPv4).  Therefore, a mix of these\
    \ two approaches will\n   likely be used for a practical model.  In fact, as we\
    \ illustrate\n   below, the two approaches can be mixed even within the same LFB.\n\
    \   Using a simple example of a classifier with N classification outputs\n   followed\
    \ by other LFBs, Figure 7.a shows what the LFB topology looks\n   like when using\
    \ the pure topological approach.  Each output from the\n   classifier goes to\
    \ one of the N LFBs where no metadata is needed.\n   The topological approach\
    \ is simple, straightforward, and graphically\n   intuitive.  However, if N is\
    \ large and the N nodes following the\n   classifier (LFB#1, LFB#2, ..., LFB#N)\
    \ all belong to the same LFB type\n   (e.g., meter), but each has its own independent\
    \ components, the\n   encoded state approach gives a much simpler topology representation,\n\
    \   as shown in Figure 7.b.  The encoded state approach requires that a\n   table\
    \ of N rows of meter components be provided in the Meter node\n   itself, with\
    \ each row representing the attributes for one meter\n   instance.  A metadatum\
    \ M is also needed to pass along with the packet\n   P from the classifier to\
    \ the meter, so that the meter can use M as a\n   look-up key (index) to find\
    \ the corresponding row of the attributes\n   that should be used for any particular\
    \ packet P.\n   What if those N nodes (LFB#1, LFB#2, ..., LFB#N) are not of the\
    \ same\n   type?  For example, if LFB#1 is a queue while the rest are all\n  \
    \ meters, what is the best way to represent such data paths?  While it\n   is\
    \ still possible to use either the pure topological approach or the\n   pure encoded\
    \ state approach, the natural combination of the two\n   appears to be the best\
    \ option.  Figure 7.c depicts two different\n   functional data paths using the\
    \ topological approach while leaving\n   the N-1 meter instances distinguished\
    \ by metadata only, as shown in\n   Figure 7.c.\n                            \
    \       +----------+\n                            P      |   LFB#1  |\n      \
    \                  +--------->|(Compon-1)|\n   +-------------+      |        \
    \  +----------+\n   |            1|------+   P      +----------+\n   |       \
    \     2|---------------->|   LFB#2  |\n   | classifier 3|                 |(Compon-2)|\n\
    \   |          ...|...              +----------+\n   |            N|------+  \
    \        ...\n   +-------------+      |   P      +----------+\n              \
    \          +--------->|   LFB#N  |\n                                   |(Compon-N)|\n\
    \                                   +----------+\n   (a) Using pure topological\
    \ approach\n   +-------------+                 +-------------+\n   |         \
    \   1|                 |   Meter     |\n   |            2|   (P, M)        | (Compon-1)\
    \  |\n   |            3|---------------->| (Compon-2)  |\n   |          ...| \
    \                |   ...       |\n   |            N|                 | (Compon-N)\
    \  |\n   +-------------+                 +-------------+\n   (b) Using pure encoded\
    \ state approach to represent the LFB\n   topology in 5(a), if LFB#1, LFB#2, ...,\
    \ and LFB#N are of the\n   same type (e.g., meter).\n                        \
    \        +-------------+\n   +-------------+ (P, M)       | queue       |\n  \
    \ |            1|------------->| (Compon-1)  |\n   |            2|           \
    \   +-------------+\n   |            3| (P, M)       +-------------+\n   |   \
    \       ...|------------->|   Meter     |\n   |            N|              | (Compon-2)\
    \  |\n   +-------------+              |   ...       |\n                      \
    \          | (Compon-N)  |\n                                +-------------+\n\
    \   (c) Using a combination of the two, if LFB#1, LFB#2, ..., and\n   LFB#N are\
    \ of different types (e.g., queue and meter).\n            Figure 7: An example\
    \ of how to model FE data paths.\n   From this example, we demonstrate that each\
    \ approach has a distinct\n   advantage depending on the situation.  Using the\
    \ encoded state\n   approach, fewer connections are typically needed between a\
    \ fan-out\n   node and its next LFB instances of the same type because each packet\n\
    \   carries metadata the following nodes can interpret and hence invoke a\n  \
    \ different packet treatment.  For those cases, a pure topological\n   approach\
    \ forces one to build elaborate graphs with many more\n   connections and often\
    \ results in an unwieldy graph.  On the other\n   hand, a topological approach\
    \ is the most intuitive for representing\n   functionally different data paths.\n\
    \   For complex topologies, a combination of the two is the most\n   flexible.\
    \  A general design guideline is provided to indicate which\n   approach is best\
    \ used for a particular situation.  The topological\n   approach should primarily\
    \ be used when the packet data path forks to\n   distinct LFB classes (not just\
    \ distinct parameterizations of the same\n   LFB class), and when the fan-outs\
    \ do not require changes, such as\n   adding/removing LFB outputs, or require\
    \ only very infrequent changes.\n   Configuration information that needs to change\
    \ frequently should be\n   expressed by using the internal attributes of one or\
    \ more LFBs (and\n   hence using the encoded state approach).\n              \
    \        +---------------------------------------------+\n                   \
    \   |                                             |\n        +----------+  V \
    \     +----------+           +------+        |\n        |          |  |      |\
    \          |if IP-in-IP|      |        |\n   ---->| ingress  |->+----->|classifier|---------->|Decap.|---->---+\n\
    \        | ports    |         |          |---+       |      |\n        +----------+\
    \         +----------+   |others +------+\n                                  \
    \          |\n                                            V\n   (a)  The LFB topology\
    \ with a logical loop\n       +-------+   +-----------+            +------+  \
    \ +-----------+\n       |       |   |           |if IP-in-IP |      |   |    \
    \       |\n   --->|ingress|-->|classifier1|----------->|Decap.|-->+classifier2|->\n\
    \       | ports |   |           |----+       |      |   |           |\n      \
    \ +-------+   +-----------+    |others +------+   +-----------+\n            \
    \                        |\n                                    V\n   (b) The\
    \ LFB topology without the loop utilizing two independent\n              classifier\
    \ instances.\n                    Figure 8: An LFB topology example.\n   It is\
    \ important to point out that the LFB topology described here is\n   the logical\
    \ topology, not the physical topology of how the FE\n   hardware is actually laid\
    \ out.  Nevertheless, the actual\n   implementation may still influence how the\
    \ functionality is mapped to\n   the LFB topology.  Figure 8 shows one simple\
    \ FE example.  In this\n   example, an IP-in-IP packet from an IPsec application\
    \ like VPN may go\n   to the classifier first and have the classification done\
    \ based on the\n   outer IP header.  Upon being classified as an IP-in-IP packet,\
    \ the\n   packet is then sent to a decapsulator to strip off the outer IP\n  \
    \ header, followed by a classifier again to perform classification on\n   the\
    \ inner IP header.  If the same classifier hardware or software is\n   used for\
    \ both outer and inner IP header classification with the same\n   set of filtering\
    \ rules, a logical loop is naturally present in the\n   LFB topology, as shown\
    \ in Figure 8.a.  However, if the classification\n   is implemented by two different\
    \ pieces of hardware or software with\n   different filters (i.e., one set of\
    \ filters for the outer IP header\n   and another set for the inner IP header),\
    \ then it is more natural to\n   model them as two different instances of classifier\
    \ LFB, as shown in\n   Figure 8.b.\n"
- title: 3.4.2.   Configuring the LFB Topology
  contents:
  - "3.4.2.   Configuring the LFB Topology\n   While there is little doubt that an\
    \ individual LFB must be\n   configurable, the configurability question is more\
    \ complicated for\n   LFB topology.  Since the LFB topology is really the graphic\n\
    \   representation of the data paths within an FE, configuring the LFB\n   topology\
    \ means dynamically changing the data paths, including\n   changing the LFBs along\
    \ the data paths on an FE (e.g., creating/\n   instantiating, updating, or deleting\
    \ LFBs) and setting up or deleting\n   interconnections between outputs of upstream\
    \ LFBs to inputs of\n   downstream LFBs.\n   Why would the data paths on an FE\
    \ ever change dynamically?  The data\n   paths on an FE are set up by the CE to\
    \ provide certain data plane\n   services (e.g., Diffserv, VPN) to the network\
    \ element's (NE)\n   customers.  The purpose of reconfiguring the data paths is\
    \ to enable\n   the CE to customize the services the NE is delivering at run time.\n\
    \   The CE needs to change the data paths when the service requirements\n   change,\
    \ such as adding a new customer or when an existing customer\n   changes their\
    \ service.  However, note that not all data path changes\n   result in changes\
    \ in the LFB topology graph.  Changes in the graph\n   are dependent on the approach\
    \ used to map the data paths into LFB\n   topology.  As discussed in Section 3.4.1,\
    \ the topological approach\n   and encoded state approach can result in very different\
    \ looking LFB\n   topologies for the same data paths.  In general, an LFB topology\n\
    \   based on a pure topological approach is likely to experience more\n   frequent\
    \ topology reconfiguration than one based on an encoded state\n   approach.  However,\
    \ even an LFB topology based entirely on an encoded\n   state approach may have\
    \ to change the topology at times, for example,\n   to bypass some LFBs or insert\
    \ new LFBs.  Since a mix of these two\n   approaches is used to model the data\
    \ paths, LFB topology\n   reconfiguration is considered an important aspect of\
    \ the FE model.\n   We want to point out that allowing a configurable LFB topology\
    \ in the\n   FE model does not mandate that all FEs are required to have this\n\
    \   capability.  Even if an FE supports configurable LFB topology, the FE\n  \
    \ may impose limitations on what can actually be configured.\n   Performance-optimized\
    \ hardware implementations may have zero or very\n   limited configurability,\
    \ while FE implementations running on network\n   processors may provide more\
    \ flexibility and configurability.  It is\n   entirely up to the FE designers\
    \ to decide whether or not the FE\n   actually implements reconfiguration and\
    \ if so, how much.  Whether a\n   simple runtime switch is used to enable or disable\
    \ (i.e., bypass)\n   certain LFBs, or more flexible software reconfiguration is\
    \ used, is\n   an implementation detail internal to the FE and outside the scope\
    \ of\n   the FE model.  In either case, the CE(s) MUST be able to learn the\n\
    \   FE's configuration capabilities.  Therefore, the FE model MUST\n   provide\
    \ a mechanism for describing the LFB topology configuration\n   capabilities of\
    \ an FE.  These capabilities may include (see Section 5\n   for full details):\n\
    \   o  Which LFB classes the FE can instantiate\n   o  The maximum number of instances\
    \ of the same LFB class that can be\n      created\n   o  Any topological limitations,\
    \ for example:\n      *  The maximum number of instances of the same class or\
    \ any class\n         that can be created on any given branch of the graph\n \
    \     *  Ordering restrictions on LFBs (e.g., any instance of LFB class\n    \
    \     A must be always downstream of any instance of LFB class B)\n   The CE needs\
    \ some programming help in order to cope with the range of\n   complexity.  In\
    \ other words, even when the CE is allowed to configure\n   LFB topology for the\
    \ FE, the CE is not expected to be able to\n   interpret an arbitrary LFB topology\
    \ and determine which specific\n   service or application (e.g., VPN, Diffserv)\
    \ is supported by the FE.\n   However, once the CE understands the coarse capability\
    \ of an FE, the\n   CE MUST configure the LFB topology to implement the network\
    \ service\n   the NE is supposed to provide.  Thus, the mapping the CE has to\n\
    \   understand is from the high-level NE service to a specific LFB\n   topology,\
    \ not the other way around.  The CE is not expected to have\n   the ultimate intelligence\
    \ to translate any high-level service policy\n   into the configuration data for\
    \ the FEs.  However, it is conceivable\n   that within a given network service\
    \ domain, a certain amount of\n   intelligence can be programmed into the CE to\
    \ give the CE a general\n   understanding of the LFBs involved to allow the translation\
    \ from a\n   high-level service policy to the low-level FE configuration to be\n\
    \   done automatically.  Note that this is considered an implementation\n   issue\
    \ internal to the control plane and outside the scope of the FE\n   model.  Therefore,\
    \ it is not discussed any further in this document.\n         +----------+   \
    \  +-----------+\n    ---->| Ingress  |---->|classifier |--------------+\n   \
    \      |          |     |chip       |              |\n         +----------+  \
    \   +-----------+              |\n                                           \
    \          v\n                         +-------------------------------------------+\n\
    \           +--------+    |   Network Processor                       |\n    \
    \  <----| Egress |    |   +------+    +------+   +-------+        |\n        \
    \   +--------+    |   |Meter |    |Marker|   |Dropper|        |\n            \
    \     ^       |   +------+    +------+   +-------+        |\n                \
    \ |       |                                           |\n      +----------+-------+\
    \                                           |\n      |          |            \
    \                                       |\n      |    +---------+       +---------+\
    \   +------+    +---------+   |\n      |    |Forwarder|<------|Scheduler|<--|Queue\
    \ |    |Counter  |   |\n      |    +---------+       +---------+   +------+  \
    \  +---------+   |\n      +--------------------------------------------------------------+\n\
    \         Figure 9: The capability of an FE as reported to the CE.\n   Figure\
    \ 9 shows an example where a QoS-enabled (quality-of-service)\n   router has several\
    \ line cards that have a few ingress ports and\n   egress ports, a specialized\
    \ classification chip, and a network\n   processor containing codes for FE blocks\
    \ like meter, marker, dropper,\n   counter, queue, scheduler, and IPv4 forwarder.\
    \  Some of the LFB\n   topology is already fixed and has to remain static due\
    \ to the\n   physical layout of the line cards.  For example, all of the ingress\n\
    \   ports might be hardwired into the classification chip so all packets\n   flow\
    \ from the ingress port into the classification engine.  On the\n   other hand,\
    \ the LFBs on the network processor and their execution\n   order are programmable.\
    \  However, certain capacity limits and linkage\n   constraints could exist between\
    \ these LFBs.  Examples of the capacity\n   limits might be:\n   o  8 meters\n\
    \   o  16 queues in one FE\n   o  the scheduler can handle at most up to 16 queues\n\
    \   o  The linkage constraints might dictate that:\n      *  the classification\
    \ engine may be followed by:\n         +  a meter\n         +  marker\n      \
    \   +  dropper\n         +  counter\n         +  queue or IPv4 forwarder, but\
    \ not a scheduler\n      *  queues can only be followed by a scheduler\n     \
    \ *  a scheduler must be followed by the IPv4 forwarder\n      *  the last LFB\
    \ in the data path before going into the egress\n         ports must be the IPv4\
    \ forwarder\n           +-----+    +-------+                      +---+\n    \
    \       |    A|--->|Queue1 |--------------------->|   |\n    ------>|     |  \
    \  +-------+                      |   |  +---+\n           |     |           \
    \                        |   |  |   |\n           |     |    +-------+      +-------+\
    \       |   |  |   |\n           |    B|--->|Meter1 |----->|Queue2 |------>| \
    \  |->|   |\n           |     |    |       |      +-------+       |   |  |   |\n\
    \           |     |    |       |--+                   |   |  |   |\n         \
    \  +-----+    +-------+  |   +-------+       |   |  +---+\n         classifier\
    \              +-->|Dropper|       |   |  IPv4\n                             \
    \        +-------+       +---+  Fwd.\n                                       \
    \           Scheduler\n                 Figure 10: An LFB topology as configured\n\
    \                     by the CE and accepted by the FE.\n   Once the FE reports\
    \ these capabilities and capacity limits to the CE,\n   it is now up to the CE\
    \ to translate the QoS policy into a desirable\n   configuration for the FE. \
    \ Figure 9 depicts the FE capability, while\n   Figure 10 and Figure 11 depict\
    \ two different topologies that the CE\n   may request the FE to configure.  Note\
    \ that Figure 11 is not fully\n   drawn, as inter-LFB links are included to suggest\
    \ potential\n   complexity, without drawing in the endpoints of all such links.\n\
    \                                             Queue1\n                     +---+\
    \                    +--+\n                     |  A|------------------->|  |--+\n\
    \                  +->|   |                    |  |  |\n                  |  |\
    \  B|--+  +--+   +--+    +--+  |\n                  |  +---+  |  |  |   |  | \
    \         |\n                  | Meter1  +->|  |-->|  |          |\n         \
    \         |            |  |   |  |          |\n                  |           \
    \ +--+   +--+          |          IPv4\n                  |         Counter1 Dropper1\
    \ Queue2|    +--+  Fwd.\n          +---+   |                           +--+  +--->|A\
    \ |  +-+\n          |  A|---+                           |  |------>|B |  | |\n\
    \   ------>|  B|------------------------------>|  |   +-->|C |->| |->\n      \
    \    |  C|---+                           +--+   | +>|D |  | |\n          |  D|-+\
    \ |                                  | | +--+  +-+\n          +---+ | |    +---+\
    \                  Queue3 | |Scheduler\n      Classifier1 | |  |  A|------------>\
    \       +--+ | |\n                  | +->|   |                    |  |-+ |\n \
    \                 |    |  B|--+  +--+ +-------->|  |   |\n                  |\
    \    +---+  |  |  | |         +--+   |\n                  |  Meter2   +->|  |-+\
    \                |\n                  |              |  |                  |\n\
    \                  |              +--+           Queue4 |\n                  |\
    \            Marker1          +--+   |\n                  +---------------------------->|\
    \  |---+\n                                                |  |\n             \
    \                                   +--+\n               Figure 11: Another LFB\
    \ topology as configured\n                     by the CE and accepted by the FE.\n\
    \   Note that both the ingress and egress are omitted in Figure 10 and\n   Figure\
    \ 11 to simplify the representation.  The topology in Figure 11\n   is considerably\
    \ more complex than Figure 10, but both are feasible\n   within the FE capabilities,\
    \ and so the FE should accept either\n   configuration request from the CE.\n"
- title: 4.   Model and Schema for LFB Classes
  contents:
  - "4.   Model and Schema for LFB Classes\n   The main goal of the FE model is to\
    \ provide an abstract, generic,\n   modular, implementation-independent representation\
    \ of the FEs.  This\n   is facilitated using the concept of LFBs, which are instantiated\
    \ from\n   LFB classes.  LFB classes and associated definitions will be provided\n\
    \   in a collection of XML documents.  The collection of these XML\n   documents\
    \ is called an LFB class library, and each document is called\n   an LFB class\
    \ library document (or library document, for short).  Each\n   of the library\
    \ documents MUST conform to the schema presented in this\n   section.  The schema\
    \ here and the rules for conforming to the schema\n   are those defined by the\
    \ W3C in the definitions of XML schema in XML\n   schema [Schema1] and XML schema\
    \ DataTypes [Schema2].  The root\n   element of the library document is the <LFBLibrary>\
    \ element.\n   It is not expected that library documents will be exchanged between\n\
    \   FEs and CEs \"over-the-wire\".  But the model will serve as an\n   important\
    \ reference for the design and development of the CEs\n   (software) and FEs (mostly\
    \ the software part).  It will also serve as\n   a design input when specifying\
    \ the ForCES protocol elements for CE-FE\n   communication.\n   The following\
    \ sections describe the portions of an LFBLibrary XML\n   document.  The descriptions\
    \ primarily provide the necessary semantic\n   information to understand the meaning\
    \ and uses of the XML elements.\n   The XML schema below provides the final definition\
    \ on what elements\n   are permitted, and their base syntax.  Unfortunately, due\
    \ to the\n   limitations of English and XML, there are constraints described in\n\
    \   the semantic sections that are not fully captured in the XML schema,\n   so\
    \ both sets of information need to be used to build a compliant\n   library document.\n"
- title: 4.1.  Namespace
  contents:
  - "4.1.  Namespace\n   A namespace is needed to uniquely identify the LFB type in\
    \ the LFB\n   class library.  The reference to the namespace definition is\n \
    \  contained in Section 9, IANA Considerations.\n"
- title: 4.2.  <LFBLibrary> Element
  contents:
  - "4.2.  <LFBLibrary> Element\n   The <LFBLibrary> element serves as a root element\
    \ of all library\n   documents.  A library document contains a sequence of top-level\n\
    \   elements.  The following is a list of all the elements that can occur\n  \
    \ directly in the <LFBLibrary> element.  If they occur, they must occur\n   in\
    \ the order listed.\n   o  <description> providing a text description of the purpose\
    \ of the\n      library document,\n   o  <load> for loading information from other\
    \ library documents,\n   o  <frameDefs> for the frame declarations,\n   o  <dataTypeDefs>\
    \ for defining common data types,\n   o  <metadataDefs> for defining metadata,\
    \ and\n   o  <LFBClassDefs> for defining LFB classes.\n   Each element is optional.\
    \  One library document may contain only\n   metadata definitions, another may\
    \ contain only LFB class definitions,\n   and yet another may contain all of the\
    \ above.\n   A library document can import other library documents if it needs\
    \ to\n   refer to definitions contained in the included document.  This\n   concept\
    \ is similar to the \"#include\" directive in the C programming\n   language.\
    \  Importing is expressed by the use of <load> elements,\n   which must precede\
    \ all the above elements in the document.  For\n   unique referencing, each LFBLibrary\
    \ instance document has a unique\n   label defined in the \"provide\" attribute\
    \ of the LFBLibrary element.\n   Note that what this performs is a ForCES inclusion,\
    \ not an XML\n   inclusion.  The semantic content of the library referenced by\
    \ the\n   <load> element is included, not the xml content.  Also, in terms of\n\
    \   the conceptual processing of <load> elements, the total set of\n   documents\
    \ loaded is considered to form a single document for\n   processing.  A given\
    \ document is included in this set only once, even\n   if it is referenced by\
    \ <load> elements several times, even from\n   several different files.  As the\
    \ processing of LFBLibrary information\n   is not order dependent, the order for\
    \ processing loaded elements is\n   up to the implementor, as long as the total\
    \ effect is as if all of\n   the information from all the files were available\
    \ for referencing\n   when needed.  Note that such computer processing of ForCES\
    \ model\n   library documents may be helpful for various implementations, but\
    \ is\n   not required to define the libraries, or for the actual operation of\n\
    \   the protocol itself.\n   The following is a skeleton of a library document:\n\
    \       <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n       <LFBLibrary xmlns=\"\
    urn:ietf:params:xml:ns:forces:lfbmodel:1.0\"\n         provides=\"this_library\"\
    >\n         <description>\n         </description>\n         <!-- Loading external\
    \ libraries (optional) -->\n         <load library=\"another_library\"/>\n   \
    \       ...\n         <!-- FRAME TYPE DEFINITIONS (optional) -->\n         <frameDefs>\n\
    \          ...\n         </frameDefs>\n         <!-- DATA TYPE DEFINITIONS (optional)\
    \ -->\n         <dataTypeDefs>\n          ...\n         </dataTypeDefs>\n    \
    \     <!-- METADATA DEFINITIONS (optional) -->\n         <metadataDefs>\n    \
    \      ...\n         </metadataDefs>\n         <!--\n           -\n          \
    \ -\n            LFB CLASS DEFINITIONS (optional) -->\n         <LFBCLassDefs>\n\
    \         </LFBCLassDefs>\n         </LFBLibrary>\n"
- title: 4.3.  <load> Element
  contents:
  - "4.3.  <load> Element\n   This element is used to refer to another LFB library\
    \ document.\n   Similar to the \"#include\" directive in C, this makes the objects\n\
    \   (metadata types, data types, etc.) defined in the referred library\n   document\
    \ available for referencing in the current document.\n   The load element MUST\
    \ contain the label of the library document to be\n   included and MAY contain\
    \ a URL to specify where the library can be\n   retrieved.  The load element can\
    \ be repeated unlimited times.  Below\n   are three examples for the <load> elements:\n\
    \   <load library=\"a_library\"/>\n   <load library=\"another_library\" location=\"\
    another_lib.xml\"/>\n   <load library=\"yetanother_library\"\n    location=\"\
    http://www.example.com/forces/1.0/lfbmodel/lpm.xml\"/>\n"
- title: 4.4.  <frameDefs> Element for Frame Type Declarations
  contents:
  - "4.4.  <frameDefs> Element for Frame Type Declarations\n   Frame names are used\
    \ in the LFB definition to define the types of\n   frames the LFB expects at its\
    \ input port(s) and emits at its output\n   port(s).  The <frameDefs> optional\
    \ element in the library document\n   contains one or more <frameDef> elements,\
    \ each declaring one frame\n   type.\n   Each frame definition MUST contain a\
    \ unique name (NMTOKEN) and a\n   brief synopsis.  In addition, an optional detailed\
    \ description MAY be\n   provided.\n   Uniqueness of frame types MUST be ensured\
    \ among frame types defined\n   in the same library document and in all directly\
    \ or indirectly\n   included library documents.\n   The following example defines\
    \ two frame types:\n   <frameDefs>\n     <frameDef>\n      <name>ipv4</name>\n\
    \      <synopsis>IPv4 packet</synopsis>\n      <description>\n       This frame\
    \ type refers to an IPv4 packet.\n     </description>\n    </frameDef>\n     <frameDef>\n\
    \     <name>ipv6</name>\n     <synopsis>IPv6 packet</synopsis>\n     <description>\n\
    \       This frame type refers to an IPv6 packet.\n     </description>\n    </frameDef>\n\
    \     ...\n   </frameDefs>\n"
- title: 4.5.  <dataTypeDefs> Element for Data Type Definitions
  contents:
  - "4.5.  <dataTypeDefs> Element for Data Type Definitions\n   The (optional) <dataTypeDefs>\
    \ element can be used to define commonly\n   used data types.  It contains one\
    \ or more <dataTypeDef> elements,\n   each defining a data type with a unique\
    \ name.  Such data types can be\n   used in several places in the library documents,\
    \ including:\n   o  Defining other data types\n   o  Defining components of LFB\
    \ classes\n   This is similar to the concept of having a common header file for\n\
    \   shared data types.\n   Each <dataTypeDef> element MUST contain a unique name\
    \ (NMTOKEN), a\n   brief synopsis, and a type definition element.  The name MUST\
    \ be\n   unique among all data types defined in the same library document and\n\
    \   in any directly or indirectly included library documents.  The\n   <dataTypeDef>\
    \ element MAY also include an optional longer\n   description, for example:\n\
    \   <dataTypeDefs>\n     <dataTypeDef>\n       <name>ieeemacaddr</name>\n    \
    \    <synopsis>48-bit IEEE MAC address</synopsis>\n         ... type definition\
    \ ...\n     </dataTypeDef>\n     <dataTypeDef>\n       <name>ipv4addr</name>\n\
    \        <synopsis>IPv4 address</synopsis>\n        ... type definition ...\n\
    \     </dataTypeDef>\n     ...\n   </dataTypeDefs>\n   There are two kinds of\
    \ data types: atomic and compound.  Atomic data\n   types are appropriate for\
    \ single-value variables (e.g., integer,\n   string, byte array).\n   The following\
    \ built-in atomic data types are provided, but additional\n   atomic data types\
    \ can be defined with the <typeRef> and <atomic>\n   elements:\n          <name>\
    \                   Meaning\n          ----                     -------\n    \
    \      char                     8-bit signed integer\n          uchar        \
    \            8-bit unsigned integer\n          int16                    16-bit\
    \ signed integer\n          uint16                   16-bit unsigned integer\n\
    \          int32                    32-bit signed integer\n          uint32  \
    \                 32-bit unsigned integer\n          int64                   \
    \ 64-bit signed integer\n          uint64                   64-bit unsigned integer\n\
    \          boolean                  A true / false value where\n             \
    \                      0 = false, 1 = true\n          string[N]              \
    \  A UTF-8 string represented in at most\n                                   N\
    \ octets\n          string                   A UTF-8 string without a configured\n\
    \                                   storage length limit\n          byte[N]  \
    \                A byte array of N bytes\n          octetstring[N]           A\
    \ buffer of N octets, which MAY\n                                   contain fewer\
    \ than N octets.  Hence\n                                   the encoded value\
    \ will always have\n                                   a length.\n          float32\
    \                  32-bit IEEE floating point number\n          float64      \
    \            64-bit IEEE floating point number\n   These built-in data types can\
    \ be readily used to define metadata or\n   LFB attributes, but can also be used\
    \ as building blocks when defining\n   new data types.  The boolean data type\
    \ is defined here because it is\n   so common, even though it can be built by\
    \ sub-ranging the uchar data\n   type, as defined under atomic types (Section\
    \ 4.5.2).\n   Compound data types can build on atomic data types and other compound\n\
    \   data types.  Compound data types can be defined in one of four ways.\n   They\
    \ may be defined as an array of components of some compound or\n   atomic data\
    \ type.  They may be a structure of named components of\n   compound or atomic\
    \ data types (cf. C structures).  They may be a\n   union of named components\
    \ of compound or atomic data types (cf. C\n   unions).  They may also be defined\
    \ as augmentations (explained in\n   Section 4.5.7) of existing compound data\
    \ types.\n   Given that the ForCES protocol will be getting and setting component\n\
    \   values, all atomic data types used here must be able to be conveyed\n   in\
    \ the ForCES protocol.  Further, the ForCES protocol will need a\n   mechanism\
    \ to convey compound data types.  However, the details of\n   such representations\
    \ are for the ForCES protocol [RFC5810] document\n   to define, not the model\
    \ document.  Strings and octetstrings must be\n   conveyed by the protocol with\
    \ their length, as they are not\n   delimited, the value does not itself include\
    \ the length, and these\n   items are variable length.\n   With regard to strings,\
    \ this model defines a small set of\n   restrictions and definitions on how they\
    \ are structured.  String and\n   octetstring length limits can be specified in\
    \ the LFB class\n   definitions.  The component properties for string and octetstring\n\
    \   components also contain actual lengths and length limits.  This\n   duplication\
    \ of limits is to allow for implementations with smaller\n   limits than the maximum\
    \ limits specified in the LFB class definition.\n   In all cases, these lengths\
    \ are specified in octets, not in\n   characters.  In terms of protocol operation,\
    \ as long as the specified\n   length is within the FE's supported capabilities,\
    \ the FE stores the\n   contents of a string exactly as provided by the CE, and\
    \ returns those\n   contents when requested.  No canonicalization, transformations,\
    \ or\n   equivalences are performed by the FE.  Components of type string (or\n\
    \   string[n]) MAY be used to hold identifiers for correlation with\n   components\
    \ in other LFBs.  In such cases, an exact octet for octet\n   match is used. \
    \ No equivalences are used by the FE or CE in\n   performing that matching.  The\
    \ ForCES protocol [RFC5810] does not\n   perform or require validation of the\
    \ content of UTF-8 strings.\n   However, UTF-8 strings SHOULD be encoded in the\
    \ shortest form to\n   avoid potential security issues described in [UNICODE].\
    \  Any entity\n   displaying such strings is expected to perform its own validation\n\
    \   (for example, for correct multi-byte characters, and for ensuring\n   that\
    \ the string does not end in the middle of a multi-byte sequence).\n   Specific\
    \ LFB class definitions MAY restrict the valid contents of a\n   string as suited\
    \ to the particular usage (for example, a component\n   that holds a DNS name\
    \ would be restricted to hold only octets valid\n   in such a name).  FEs should\
    \ validate the contents of SET requests\n   for such restricted components at\
    \ the time the set is performed, just\n   as range checks for range-limited components\
    \ are performed.  The\n   ForCES protocol behavior defines the normative processing\
    \ for\n   requests using that protocol.\n   For the definition of the actual type\
    \ in the <dataTypeDef> element,\n   the following elements are available: <typeRef>,\
    \ <atomic>, <array>,\n   <struct>, and <union>.\n   The predefined type alias\
    \ is somewhere between the atomic and\n   compound data types.  Alias is used\
    \ to allow a component inside an\n   LFB to be an indirect reference to another\
    \ component inside the same\n   or a different LFB class or instance.  The alias\
    \ component behaves\n   like a structure, one component of which has special behavior.\
    \  Given\n   that the special behavior is tied to the other parts of the\n   structure,\
    \ the compound result is treated as a predefined construct.\n"
- title: 4.5.1.  <typeRef> Element for Renaming Existing Data Types
  contents:
  - "4.5.1.  <typeRef> Element for Renaming Existing Data Types\n   The <typeRef>\
    \ element refers to an existing data type by its name.\n   The referred data type\
    \ MUST be defined either in the same library\n   document or in one of the included\
    \ library documents.  If the\n   referred data type is an atomic data type, the\
    \ newly defined type\n   will also be regarded as atomic.  If the referred data\
    \ type is a\n   compound type, the new type will also be compound.  Some usage\n\
    \   examples follow:\n   <dataTypeDef>\n     <name>short</name>\n     <synopsis>Alias\
    \ to int16</synopsis>\n     <typeRef>int16</typeRef>\n   </dataTypeDef>\n   <dataTypeDef>\n\
    \     <name>ieeemacaddr</name>\n     <synopsis>48-bit IEEE MAC address</synopsis>\n\
    \     <typeRef>byte[6]</typeRef>\n   </dataTypeDef>\n"
- title: 4.5.2.  <atomic> Element for Deriving New Atomic Types
  contents:
  - "4.5.2.  <atomic> Element for Deriving New Atomic Types\n   The <atomic> element\
    \ allows the definition of a new atomic type from\n   an existing atomic type,\
    \ applying range restrictions and/or providing\n   special enumerated values.\
    \  Note that the <atomic> element can only\n   use atomic types as base types,\
    \ and its result MUST be another atomic\n   type.\n   For example, the following\
    \ snippet defines a new \"dscp\" data type:\n   <dataTypeDef>\n     <name>dscp</name>\n\
    \     <synopsis>Diffserv code point.</synopsis>\n     <atomic>\n       <baseType>uchar</baseType>\n\
    \       <rangeRestriction>\n         <allowedRange min=\"0\" max=\"63\"/>\n  \
    \     </rangeRestriction>\n       <specialValues>\n         <specialValue value=\"\
    0\">\n           <name>DSCP-BE</name>\n           <synopsis>Best Effort</synopsis>\n\
    \         </specialValue>\n          ...\n       </specialValues>\n     </atomic>\n\
    \    </dataTypeDef>\n"
- title: 4.5.3.  <array> Element to Define Arrays
  contents:
  - "4.5.3.  <array> Element to Define Arrays\n   The <array> element can be used\
    \ to create a new compound data type as\n   an array of a compound or an atomic\
    \ data type.  Depending upon\n   context, this document and others refer to such\
    \ arrays as tables or\n   arrays interchangeably, without semantic or syntactic\
    \ implication.\n   The type of the array entry can be specified either by referring\
    \ to\n   an existing type (using the <typeRef> element) or defining an unnamed\n\
    \   type inside the <array> element using any of the <atomic>, <array>,\n   <struct>,\
    \ or <union> elements.\n   The array can be \"fixed-size\" or \"variable-size\"\
    , which is specified\n   by the \"type\" attribute of the <array> element.  The\
    \ default is\n   \"variable-size\".  For variable-size arrays, an optional \"\
    maxlength\"\n   attribute specifies the maximum allowed length.  This attribute\n\
    \   should be used to encode semantic limitations, not implementation\n   limitations.\
    \  The latter (support for implementation constraints)\n   should be handled by\
    \ capability components of LFB classes, and should\n   never be included as the\
    \ maxlength in a data type array that is\n   regarded as being of unlimited size.\n\
    \   For fixed-size arrays, a \"length\" attribute MUST be provided that\n   specifies\
    \ the constant size of the array.\n   The result of this construct is always a\
    \ compound type, even if the\n   array has a fixed size of 1.\n   Arrays MUST\
    \ only be subscripted by integers, and will be presumed to\n   start with index\
    \ 0.\n   In addition to their subscripts, arrays MAY be declared to have\n   content\
    \ keys.  Such a declaration has several effects:\n   o  Any declared key can be\
    \ used in the ForCES protocol to select a\n      component for operations (for\
    \ details, see the ForCES protocol\n      [RFC5810]).\n   o  In any instance of\
    \ the array, each declared key MUST be unique\n      within that instance.  That\
    \ is, no two components of an array may\n      have the same values on all the\
    \ fields that make up a key.\n   Each key is declared with a keyID for use in\
    \ the ForCES protocol\n   [RFC5810], where the unique key is formed by combining\
    \ one or more\n   specified key fields.  To support the case where an array of\
    \ an\n   atomic type with unique values can be referenced by those values, the\n\
    \   key field identifier MAY be \"*\" (i.e., the array entry is the key).\n  \
    \ If the value type of the array is a structure or an array, then the\n   key\
    \ is one or more components of the value type, each identified by\n   name.  Since\
    \ the field MAY be a component of the contained structure,\n   a component of\
    \ a component of a structure, or further nested, the\n   field name is actually\
    \ a concatenated sequence of component\n   identifiers, separated by decimal points\
    \ (\".\").  The syntax for key\n   field identification is given following the\
    \ array examples.\n   The following example shows the definition of a fixed-size\
    \ array with\n   a predefined data type as the array content type:\n     <dataTypeDef>\n\
    \           <name>dscp-mapping-table</name>\n           <synopsis>\n         \
    \     A table of 64 DSCP values, used to re-map code space.\n           </synopsis>\n\
    \           <array type=\"fixed-size\" length=\"64\">\n              <typeRef>dscp</typeRef>\n\
    \           </array>\n         </dataTypeDef>\n   The following example defines\
    \ a variable-size array with an upper\n   limit on its size:\n         <dataTypeDef>\n\
    \           <name>mac-alias-table</name>\n           <synopsis>A table with up\
    \ to 8 IEEE MAC addresses</synopsis>\n           <array type=\"variable-size\"\
    \ maxlength=\"8\">\n               <typeRef>ieeemacaddr</typeRef>\n          \
    \ </array>\n         </dataTypeDef>\n   The following example shows the definition\
    \ of an array with a local\n   (unnamed) content type definition:\n         <dataTypeDef>\n\
    \           <name>classification-table</name>\n           <synopsis>\n       \
    \      A table of classification rules and result opcodes.\n           </synopsis>\n\
    \           <array type=\"variable-size\">\n             <struct>\n          \
    \     <component componentID=\"1\">\n                 <name>rule</name>\n    \
    \             <synopsis>The rule to match</synopsis>\n                 <typeRef>classrule</typeRef>\n\
    \               </component>\n               <component componentID=\"2\">\n \
    \                <name>opcode</name>\n                 <synopsis>The result code</synopsis>\n\
    \                 <typeRef>opcode</typeRef>\n               </component>\n   \
    \         </struct>\n           </array>\n         </dataTypeDef>\n   In the above\
    \ example, each entry of the array is a <struct> of two\n   components (\"rule\"\
    \ and \"opcode\").\n   The following example shows a table of IP prefix information\
    \ that can\n   be accessed by a multi-field content key on the IP address, prefix\n\
    \   length, and information source.  This means that in any instance of\n   this\
    \ table, no two entries can have the same IP address, prefix\n   length, and information\
    \ source.\n      <dataTypeDef>\n        <name>ipPrefixInfo_table</name>\n    \
    \    <synopsis>\n          A table of information about known prefixes\n     \
    \   </synopsis>\n        <array type=\"variable-size\">\n          <struct>\n\
    \            <component componentID=\"1\">\n              <name>address-prefix</name>\n\
    \              <synopsis>the prefix being described</synopsis>\n             \
    \ <typeRef>ipv4Prefix</typeRef>\n            </component>\n            <component\
    \ componentID=\"2\">\n              <name>source</name>\n              <synopsis>\n\
    \                  the protocol or process providing this information\n      \
    \        </synopsis>\n              <typeRef>uint16</typeRef>\n            </component>\n\
    \            <component componentID=\"3\">\n              <name>prefInfo</name>\n\
    \              <synopsis>the information we care about</synopsis>\n          \
    \    <typeRef>hypothetical-info-type</typeRef>\n            </component>\n   \
    \       </struct>\n          <contentKey contentKeyID=\"1\">\n            <contentKeyField>\
    \ address-prefix.ipv4addr</contentKeyField>\n            <contentKeyField> address-prefix.prefixlen</contentKeyField>\n\
    \            <contentKeyField> source</contentKeyField>\n          </contentKey>\n\
    \        </array>\n      </dataTypeDef>\n   Note that the keyField elements could\
    \ also have been simply address-\n   prefix and source, since all of the fields\
    \ of address-prefix are\n   being used.\n"
- title: 4.5.3.1.  Key Field References
  contents:
  - "4.5.3.1.  Key Field References\n   In order to use key declarations, one must\
    \ refer to components that\n   are potentially nested inside other components\
    \ in the array.  If\n   there are nested arrays, one might even use an array element\
    \ as a key\n   (but great care would be needed to ensure uniqueness).\n   The\
    \ key is the combination of the values of each field declared in a\n   keyField\
    \ element.\n   Therefore, the value of a keyField element MUST be a concatenated\n\
    \   sequence of field identifiers, separated by a \".\" (period) character.\n\
    \   Whitespace is permitted and ignored.\n   A valid string for a single field\
    \ identifier within a keyField\n   depends upon the current context.  Initially,\
    \ in an array key\n   declaration, the context is the type of the array.  Progressively,\n\
    \   the context is whatever type is selected by the field identifiers\n   processed\
    \ so far in the current key field declaration.\n   When the current context is\
    \ an array (e.g., when declaring a key for\n   an array whose content is an array),\
    \ then the only valid value for\n   the field identifier is an explicit number.\n\
    \   When the current context is a structure, the valid values for the\n   field\
    \ identifiers are the names of the components of the structure.\n   In the special\
    \ case of declaring a key for an array containing an\n   atomic type, where that\
    \ content is unique and is to be used as a key,\n   the value \"*\" MUST be used\
    \ as the single key field identifier.\n   In reference array or structure elements,\
    \ it is possible to construct\n   keyFields that do not exist. keyField references\
    \ SHOULD never\n   reference optional structure components.  For references to\
    \ array\n   elements, care must be taken to ensure that the necessary array\n\
    \   elements exist when creating or modifying the overall array element.\n   Failure\
    \ to do so will result in FEs returning errors on the creation\n   attempt.\n"
- title: 4.5.4.  <struct> Element to Define Structures
  contents:
  - "4.5.4.  <struct> Element to Define Structures\n   A structure is composed of\
    \ a collection of data components.  Each\n   data component has a data type (either\
    \ an atomic type or an existing\n   compound type) and is assigned a name unique\
    \ within the scope of the\n   compound data type being defined.  These serve the\
    \ same function as\n   \"struct\" in C, etc.  These components are defined using\
    \ <component>\n   elements.  A <struct> element MAY contain an optional derivation\n\
    \   indication, a <derivedFrom> element.  The structure definition MUST\n   contain\
    \ a sequence of one or more <component> elements.\n   The actual type of the component\
    \ can be defined by referring to an\n   existing type (using the <typeRef> element),\
    \ or can be a locally\n   defined (unnamed) type created by any of the <atomic>,\
    \ <array>,\n   <struct>, or <union> elements.\n   The <component> element MUST\
    \ include a componentID attribute.  This\n   provides the numeric ID for this\
    \ component, for use by the protocol.\n   The <component> MUST contain a component\
    \ name and a synopsis.  It MAY\n   contain a <description> element giving a textual\
    \ description of the\n   component.  The definition MAY also include an <optional>\
    \ element,\n   which indicates that the component being defined is optional. \
    \ The\n   definition MUST contain elements to define the data type of the\n  \
    \ component, as described above.\n   For a dataTypeDef of a struct, the structure\
    \ definition MAY be\n   inherited from, and augment, a previously defined structured\
    \ type.\n   This is indicated by including the optional derivedFrom attribute\
    \ in\n   the struct declaration before the definition of the augmenting or\n \
    \  replacing components.  Section 4.5.7 describes how this is done in\n   more\
    \ detail.\n   The componentID attribute for different components in a structure\
    \ (or\n   in an LFB) MUST be distinct.  They do not need to be in order, nor do\n\
    \   they need to be sequential.  For clarity of human readability, and\n   ease\
    \ of maintenance, it is usual to define at least sequential sets\n   of values.\
    \  But this is for human ease, not a model or protocol\n   requirement.\n   The\
    \ result of this construct is always a compound type, even when the\n   <struct>\
    \ contains only one field.\n   An example is the following:\n   <dataTypeDef>\n\
    \    <name>ipv4prefix</name>\n    <synopsis>\n     IPv4 prefix defined by an address\
    \ and a prefix length\n    </synopsis>\n    <struct>\n     <component componentID=\"\
    1\">\n      <name>address</name>\n      <synopsis>Address part</synopsis>\n  \
    \    <typeRef>ipv4addr</typeRef>\n     </component>\n     <component componentID=\"\
    2\">\n      <name>prefixlen</name>\n      <synopsis>Prefix length part</synopsis>\n\
    \      <atomic>\n       <baseType>uchar</baseType>\n       <rangeRestriction>\n\
    \        <allowedRange min=\"0\" max=\"32\"/>\n       </rangeRestriction>\n  \
    \    </atomic>\n     </component>\n    </struct>\n   </dataTypeDef>\n"
- title: 4.5.5.  <union> Element to Define Union Types
  contents:
  - "4.5.5.  <union> Element to Define Union Types\n   Similar to the union declaration\
    \ in C, this construct allows the\n   definition of overlay types.  Its format\
    \ is identical to the <struct>\n   element.\n   The result of this construct is\
    \ always a compound type, even when the\n   union contains only one element.\n"
- title: 4.5.6.  <alias> Element
  contents:
  - "4.5.6.  <alias> Element\n   It is sometimes necessary to have a component in\
    \ an LFB or structure\n   refer to information (a component) in other LFBs.  This\
    \ can, for\n   example, allow an ARP LFB to share the IP->MAC Address table with\
    \ the\n   local transmission LFB, without duplicating information.  Similarly,\n\
    \   it could allow a traffic measurement LFB to share information with a\n   traffic\
    \ enforcement LFB.  The <alias> declaration creates the\n   constructs for this.\
    \  This construct tells the CE and FE that any\n   manipulation of the defined\
    \ data is actually manipulation of data\n   defined to exist in some specified\
    \ part of some other LFB instance.\n   The content of an <alias> element MUST\
    \ be a named type.  Whatever\n   component the alias references (which is determined\
    \ by the alias\n   component properties, as described below), that component must\
    \ be of\n   the same type as that declared for the alias.  Thus, when the CE or\n\
    \   FE dereferences the alias component, the type of the information\n   returned\
    \ is known.  The type can be a base type or a derived type.\n   The actual value\
    \ referenced by an alias is known as its target.  When\n   a GET or SET operation\
    \ references the alias element, the value of the\n   target is returned or replaced.\
    \  Write access to an alias element is\n   permitted if write access to both the\
    \ alias and the target is\n   permitted.\n   The target of a component declared\
    \ by an <alias> element is\n   determined by the information in the component's\
    \ properties.  Like\n   all components, the properties include the support / read\
    \ / write\n   permission for the alias.  In addition, there are several fields\n\
    \   (components) in the alias properties that define the target of the\n   alias.\
    \  These components are the ID of the LFB class of the target,\n   the ID of the\
    \ LFB instance of the target, and a sequence of integers\n   representing the\
    \ path within the target LFB instance to the target\n   component.  The type of\
    \ the target element must match the declared\n   type of the alias.  Details of\
    \ the alias property structure are\n   described in Section 4.8 of this document,\
    \ on properties.\n   Note that the read / write property of the alias refers to\
    \ the value.\n   The CE can only determine if it can write the target selection\n\
    \   properties of the alias by attempting such a write operation.\n   (Property\
    \ components do not themselves have properties.)\n"
- title: 4.5.7.  Augmentations
  contents:
  - "4.5.7.  Augmentations\n   Compound types can also be defined as augmentations\
    \ of existing\n   compound types.  If the existing compound type is a structure,\n\
    \   augmentation MAY add new elements to the type.  The type of an\n   existing\
    \ component MAY be replaced in the definition of an augmenting\n   structure,\
    \ but MAY only be replaced with an augmentation derived from\n   the current type\
    \ of the existing component.  An existing component\n   cannot be deleted.  If\
    \ the existing compound type is an array,\n   augmentation means augmentation\
    \ of the array element type.\n   Augmentation MUST NOT be applied to unions.\n\
    \   One consequence of this is that augmentations are backward compatible\n  \
    \ with the compound type from which they are derived.  As such,\n   augmentations\
    \ are useful in defining components for LFB subclasses\n   with backward compatibility.\
    \  In addition to adding new components to\n   a class, the data type of an existing\
    \ component MAY be replaced by an\n   augmentation of that component, and still\
    \ meet the compatibility\n   rules for subclasses.  This compatibility constraint\
    \ is why\n   augmentations cannot be applied to unions.\n   For example, consider\
    \ a simple base LFB class A that has only one\n   component (comp1) of type X.\
    \  One way to derive class A1 from A can\n   be by simply adding a second component\
    \ (of any type).  Another way to\n   derive a class A2 from A can be by replacing\
    \ the original component\n   (comp1) in A of type X with one of type Y, where\
    \ Y is an augmentation\n   of X.  Both classes A1 and A2 are backward compatible\
    \ with class A.\n   The syntax for augmentations is to include a <derivedFrom>\
    \ element in\n   a structure definition, indicating what structure type is being\n\
    \   augmented.  Component names and component IDs for new components\n   within\
    \ the augmentation MUST NOT be the same as those in the\n   structure type being\
    \ augmented.  For those components where the data\n   type of an existing component\
    \ is being replaced with a suitable\n   augmenting data type, the existing component\
    \ name and component ID\n   MUST be used in the augmentation.  Other than the\
    \ constraint on\n   existing elements, there is no requirement that the new component\
    \ IDs\n   be sequential with, greater than, or in any other specific\n   relationship\
    \ to the existing component IDs except different.  It is\n   expected that using\
    \ values sequential within an augmentation, and\n   distinct from the previously\
    \ used values, will be a common method to\n   enhance human readability.\n"
- title: 4.6.   <metadataDefs> Element for Metadata Definitions
  contents:
  - "4.6.   <metadataDefs> Element for Metadata Definitions\n   The (optional) <metadataDefs>\
    \ element in the library document\n   contains one or more <metadataDef> elements.\
    \  Each <metadataDef>\n   element defines a metadatum.\n   Each <metadataDef>\
    \ element MUST contain a unique name (NMTOKEN).\n   Uniqueness is defined to be\
    \ over all metadata defined in this library\n   document and in all directly or\
    \ indirectly included library\n   documents.  The <metadataDef> element MUST also\
    \ contain a brief\n   synopsis, the tag value to be used for this metadata, and\
    \ value type\n   definition information.  Only atomic data types can be used as\
    \ value\n   types for metadata.  The <metadataDef> element MAY contain a detailed\n\
    \   description element.\n   Two forms of type definitions are allowed.  The first\
    \ form uses the\n   <typeRef> element to refer to an existing atomic data type\
    \ defined in\n   the <dataTypeDefs> element of the same library document or in\
    \ one of\n   the included library documents.  The usage of the <typeRef> element\n\
    \   is identical to how it is used in the <dataTypeDef> elements, except\n   here\
    \ it can only refer to atomic types.  The latter restriction is\n   not enforced\
    \ by the XML schema.\n   The second form is an explicit type definition using\
    \ the <atomic>\n   element.  This element is used here in the same way as in the\n\
    \   <dataTypeDef> elements.\n   The following example shows both usages:\n   <metadataDefs>\n\
    \    <metadataDef>\n     <name>NEXTHOPID</name>\n     <synopsis>Refers to a Next\
    \ Hop entry in NH LFB</synopsis>\n     <metadataID>17</metadataID>\n     <typeRef>int32</typeRef>\n\
    \    </metadataDef>\n    <metadataDef>\n     <name>CLASSID</name>\n     <synopsis>\n\
    \      Result of classification (0 means no match).\n     </synopsis>\n     <metadataID>21</metadataID>\n\
    \     <atomic>\n      <baseType>int32</baseType>\n      <specialValues>\n    \
    \   <specialValue value=\"0\">\n        <name>NOMATCH</name>\n        <synopsis>\n\
    \         Classification didn't result in match.\n        </synopsis>\n      \
    \ </specialValue>\n      </specialValues>\n     </atomic>\n    </metadataDef>\n\
    \   </metadataDefs>\n"
- title: 4.7.  <LFBClassDefs> Element for LFB Class Definitions
  contents:
  - "4.7.  <LFBClassDefs> Element for LFB Class Definitions\n   The (optional) <LFBClassDefs>\
    \ element can be used to define one or\n   more LFB classes using <LFBClassDef>\
    \ elements.  Each <LFBClassDef>\n   element MUST define an LFB class and include\
    \ the following elements:\n   o  <name> provides the symbolic name of the LFB\
    \ class.  Example:\n      \"ipv4lpm\".\n   o  <synopsis> provides a short synopsis\
    \ of the LFB class.  Example:\n      \"IPv4 Longest Prefix Match Lookup LFB\"\
    .\n   o  <version> is the version indicator.\n   o  <derivedFrom> is the inheritance\
    \ indicator.\n   o  <inputPorts> lists the input ports and their specifications.\n\
    \   o  <outputPorts> lists the output ports and their specifications.\n   o  <components>\
    \ defines the operational components of the LFB.\n   o  <capabilities> defines\
    \ the capability components of the LFB.\n   o  <description> contains the operational\
    \ specification of the LFB.\n   o  The LFBClassID attribute of the LFBClassDef\
    \ element defines the ID\n      for this class.  These must be globally unique.\n\
    \   o  <events> defines the events that can be generated by instances of\n   \
    \   this LFB.\n   LFB class names must be unique, in order to enable other documents\
    \ to\n   reference the classes by name, and to enable human readers to\n   understand\
    \ references to class names.  While a complex naming\n   structure could be created,\
    \ simplicity is preferred.  As given in the\n   IANA Considerations section of\
    \ this document, the IANA maintains a\n   registry of LFB class names and class\
    \ identifiers, along with a\n   reference to the document defining the class.\n\
    \   Below is a skeleton of an example LFB class definition.  Note that in\n  \
    \ order to keep from complicating the XML schema, the order of elements\n   in\
    \ the class definition is fixed.  Elements, if they appear, must\n   appear in\
    \ the order shown.\n   <LFBClassDefs>\n    <LFBClassDef LFBClassID=\"12345\">\n\
    \     <name>ipv4lpm</name>\n     <synopsis>IPv4 Longest Prefix Match Lookup LFB</synopsis>\n\
    \     <version>1.0</version>\n     <derivedFrom>baseclass</derivedFrom>\n    \
    \ <inputPorts>\n      ...\n     </inputPorts>\n     <outputPorts>\n      ...\n\
    \     </outputPorts>\n     <components>\n      ...\n     </components>\n     <capabilities>\n\
    \      ...\n     </capabilities>\n     <events>\n      ...\n     </events>\n \
    \    <description>\n      This LFB represents the IPv4 longest prefix match lookup\n\
    \      operation.\n      The modeled behavior is as follows:\n      Blah-blah-blah.\n\
    \     </description>\n    </LFBClassDef>\n    ...\n   </LFBClassDefs>\n   The\
    \ individual components and capabilities will have componentIDs for\n   use by\
    \ the ForCES protocol.  These parallel the componentIDs used in\n   structs, and\
    \ are used the same way.  Component and capability\n   componentIDs must be unique\
    \ within the LFB class definition.\n   Note that the <name>, <synopsis>, and <version>\
    \ elements are\n   required; all other elements are optional in <LFBClassDef>.\
    \  However,\n   when they are present, they must occur in the above order.\n \
    \  The componentID attribute for different items in an LFB class\n   definition\
    \ (or components in a struct) MUST be distinct.  They do not\n   need to be in\
    \ order, nor do they need to be sequential.  For clarity\n   of human readability,\
    \ and ease of maintenance, it is usual to define\n   at least sequential sets\
    \ of values.  But this is for human ease, not\n   a model or protocol requirement.\n"
- title: 4.7.1.  <derivedFrom> Element to Express LFB Inheritance
  contents:
  - "4.7.1.  <derivedFrom> Element to Express LFB Inheritance\n   The optional <derivedFrom>\
    \ element can be used to indicate that this\n   class is a derivative of some\
    \ other class.  The content of this\n   element MUST be the unique name (<name>)\
    \ of another LFB class.  The\n   referred LFB class MUST be defined in the same\
    \ library document or in\n   one of the included library documents.  In the absence\
    \ of a\n   <derivedFrom>, the class is conceptually derived from the common,\n\
    \   empty, base class.\n   It is assumed that a derived class is backward compatible\
    \ with its\n   base class.  A derived class MAY add components to a parent class,\n\
    \   but cannot delete components.  This also applies to input and output\n   ports,\
    \ events, and capabilities.\n"
- title: 4.7.2.  <inputPorts> Element to Define LFB Inputs
  contents:
  - "4.7.2.  <inputPorts> Element to Define LFB Inputs\n   The optional <inputPorts>\
    \ element is used to define input ports.  An\n   LFB class MAY have zero, one,\
    \ or more inputs.  If the LFB class has\n   no input ports, the <inputPorts> element\
    \ MUST be omitted.  The\n   <inputPorts> element can contain one or more <inputPort>\
    \ elements,\n   one for each port or port group.  We assume that most LFBs will\
    \ have\n   exactly one input.  Multiple inputs with the same input type are\n\
    \   modeled as one input group.  Input groups are defined the same way as\n  \
    \ input ports by the <inputPort> element, differentiated only by an\n   optional\
    \ \"group\" attribute.\n   Multiple inputs with different input types should be\
    \ avoided if\n   possible (see discussion in Section 4.7.3).  Some special LFBs\
    \ will\n   have no inputs at all.  For example, a packet generator LFB does not\n\
    \   need an input.\n   Single input ports and input port groups are both defined\
    \ by the\n   <inputPort> element; they are differentiated only by an optional\n\
    \   \"group\" attribute.\n   The <inputPort> element MUST contain the following\
    \ elements:\n   o  <name> provides the symbolic name of the input.  Example: \"\
    in\".\n      Note that this symbolic name must be unique only within the scope\n\
    \      of the LFB class.\n   o  <synopsis> contains a brief description of the\
    \ input.  Example:\n      \"Normal packet input\".\n   o  <expectation> lists\
    \ all allowed frame formats.  Example: {\"ipv4\"\n      and \"ipv6\"}.  Note that\
    \ this list should refer to names specified\n      in the <frameDefs> element\
    \ of the same library document or in any\n      included library documents.  The\
    \ <expectation> element can also\n      provide a list of required metadata. \
    \ Example: {\"classid\",\n      \"vpnid\"}.  This list should refer to names of\
    \ metadata defined in\n      the <metadataDefs> element in the same library document\
    \ or in any\n      included library documents.  For each metadatum, it must be\n\
    \      specified whether the metadatum is required or optional.  For each\n  \
    \    optional metadatum, a default value must be specified, which is\n      used\
    \ by the LFB if the metadatum is not provided with a packet.\n   In addition,\
    \ the optional \"group\" attribute of the <inputPort>\n   element can specify\
    \ if the port can behave as a port group, i.e., it\n   is allowed to be instantiated.\
    \  This is indicated by a \"true\" value\n   (the default value is \"false\").\n\
    \   An example <inputPorts> element, defining two input ports, the second\n  \
    \ one being an input port group is the following:\n   <inputPorts>\n    <inputPort>\n\
    \     <name>in</name>\n     <synopsis>Normal input</synopsis>\n     <expectation>\n\
    \      <frameExpected>\n       <ref>ipv4</ref>\n       <ref>ipv6</ref>\n     \
    \ </frameExpected>\n      <metadataExpected>\n       <ref>classid</ref>\n    \
    \   <ref>vifid</ref>\n       <ref dependency=\"optional\" defaultValue=\"0\">vrfid</ref>\n\
    \      </metadataExpected>\n     </expectation>\n    </inputPort>\n    <inputPort\
    \ group=\"true\">\n     ... another input port ...\n    </inputPort>\n   </inputPorts>\n\
    \   For each <inputPort>, the frame type expectations are defined by the\n   <frameExpected>\
    \ element using one or more <ref> elements (see example\n   above).  When multiple\
    \ frame types are listed, it means that \"one of\n   these\" frame types is expected.\
    \  A packet of any other frame type is\n   regarded as incompatible with this\
    \ input port of the LFB class.  The\n   above example lists two frames as expected\
    \ frame types: \"ipv4\" and\n   \"ipv6\".\n   Metadata expectations are specified\
    \ by the <metadataExpected>\n   element.  In its simplest form, this element can\
    \ contain a list of\n   <ref> elements, each referring to a metadatum.  When multiple\n\
    \   instances of metadata are listed by <ref> elements, it means that\n   \"all\
    \ of these\" metadata must be received with each packet (except\n   metadata that\
    \ are marked as \"optional\" by the \"dependency\" attribute\n   of the corresponding\
    \ <ref> element).  For a metadatum that is\n   specified \"optional\", a default\
    \ value MUST be provided using the\n   \"defaultValue\" attribute.  The above\
    \ example lists three metadata as\n   expected metadata, two of which are mandatory\
    \ (\"classid\" and\n   \"vifid\"), and one being optional (\"vrfid\").\n   The\
    \ schema also allows for more complex definitions of metadata\n   expectations.\
    \  For example, using the <one-of> element, a list of\n   metadata can be specified\
    \ to express that at least one of the\n   specified metadata must be present with\
    \ any packet.  An example is\n   the following:\n   <metadataExpected>\n    <one-of>\n\
    \     <ref>prefixmask</ref>\n     <ref>prefixlen</ref>\n    </one-of>\n   </metadataExpected>\n\
    \   The above example specifies that either the \"prefixmask\" or the\n   \"prefixlen\"\
    \ metadata must be provided with any packet.\n   The two forms can also be combined,\
    \ as shown in the following\n   example:\n   <metadataExpected>\n    <ref>classid</ref>\n\
    \    <ref>vifid</ref>\n    <ref dependency=\"optional\" defaultValue=\"0\">vrfid</ref>\n\
    \    <one-of>\n     <ref>prefixmask</ref>\n     <ref>prefixlen</ref>\n    </one-of>\n\
    \   </metadataExpected>\n   Although the schema is constructed to allow even more\
    \ complex\n   definitions of metadata expectations, we do not discuss those here.\n"
- title: 4.7.3.  <outputPorts> Element to Define LFB Outputs
  contents:
  - "4.7.3.  <outputPorts> Element to Define LFB Outputs\n   The optional <outputPorts>\
    \ element is used to define output ports.\n   An LFB class MAY have zero, one,\
    \ or more outputs.  If the LFB class\n   has no output ports, the <outputPorts>\
    \ element MUST be omitted.  The\n   <outputPorts> element MUST contain one or\
    \ more <outputPort> elements,\n   one for each port or port group.  If there are\
    \ multiple outputs with\n   the same output type, we model them as an output port\
    \ group.  Some\n   special LFBs have no outputs at all (e.g., Dropper).\n   Single\
    \ output ports and output port groups are both defined by the\n   <outputPort>\
    \ element; they are differentiated only by an optional\n   \"group\" attribute.\n\
    \   The <outputPort> element MUST contain the following elements:\n   o  <name>\
    \ provides the symbolic name of the output.  Example: \"out\".\n      Note that\
    \ the symbolic name must be unique only within the scope\n      of the LFB class.\n\
    \   o  <synopsis> contains a brief description of the output port.\n      Example:\
    \ \"Normal packet output\".\n   o  <product> lists the allowed frame formats.\
    \  Example: {\"ipv4\",\n      \"ipv6\"}.  Note that this list should refer to\
    \ symbols specified in\n      the <frameDefs> element in the same library document\
    \ or in any\n      included library documents.  The <product> element MAY also\n\
    \      contain the list of emitted (generated) metadata.  Example:\n      {\"\
    classid\", \"color\"}.  This list should refer to names of metadata\n      specified\
    \ in the <metadataDefs> element in the same library\n      document or in any\
    \ included library documents.  For each generated\n      metadatum, it should\
    \ be specified whether the metadatum is always\n      generated or generated only\
    \ in certain conditions.  This\n      information is important when assessing\
    \ compatibility between\n      LFBs.\n   In addition, the optional \"group\" attribute\
    \ of the <outputPort>\n   element can specify if the port can behave as a port\
    \ group, i.e., it\n   is allowed to be instantiated.  This is indicated by a \"\
    true\" value\n   (the default value is \"false\").\n   The following example specifies\
    \ two output ports, the second being an\n   output port group:\n   <outputPorts>\n\
    \    <outputPort>\n     <name>out</name>\n     <synopsis>Normal output</synopsis>\n\
    \     <product>\n      <frameProduced>\n       <ref>ipv4</ref>\n       <ref>ipv4bis</ref>\n\
    \      </frameProduced>\n      <metadataProduced>\n       <ref>nhid</ref>\n  \
    \     <ref>nhtabid</ref>\n      </metadataProduced>\n     </product>\n    </outputPort>\n\
    \    <outputPort group=\"true\">\n     <name>exc</name>\n     <synopsis>Exception\
    \ output port group</synopsis>\n     <product>\n      <frameProduced>\n      \
    \ <ref>ipv4</ref>\n       <ref>ipv4bis</ref>\n      </frameProduced>\n      <metadataProduced>\n\
    \       <ref availability=\"conditional\">errorid</ref>\n      </metadataProduced>\n\
    \     </product>\n    </outputPort>\n   </outputPorts>\n   The types of frames\
    \ and metadata the port produces are defined inside\n   the <product> element\
    \ in each <outputPort>.  Within the <product>\n   element, the list of frame types\
    \ the port produces is listed in the\n   <frameProduced> element.  When more than\
    \ one frame is listed, it\n   means that \"one of\" these frames will be produced.\n\
    \   The list of metadata that is produced with each packet is listed in\n   the\
    \ optional <metadataProduced> element of the <product>.  In its\n   simplest form,\
    \ this element can contain a list of <ref> elements,\n   each referring to a metadatum\
    \ type.  The meaning of such a list is\n   that \"all of\" these metadata are\
    \ provided with each packet, except\n   those that are listed with the optional\
    \ \"availability\" attribute set\n   to \"conditional\".  Similar to the <metadataExpected>\
    \ element of the\n   <inputPort>, the <metadataProduced> element supports more\
    \ complex\n   forms, which we do not discuss here further.\n"
- title: 4.7.4.  <components> Element to Define LFB Operational Components
  contents:
  - "4.7.4.  <components> Element to Define LFB Operational Components\n   Operational\
    \ parameters of the LFBs that must be visible to the CEs\n   are conceptualized\
    \ in the model as the LFB components.  These\n   include, for example, flags,\
    \ single parameter arguments, complex\n   arguments, and tables.  Note that the\
    \ components here refer to only\n   those operational parameters of the LFBs that\
    \ must be visible to the\n   CEs.  Other variables that are internal to LFB implementation\
    \ are not\n   regarded as LFB components and hence are not covered.\n   Some examples\
    \ for LFB components are:\n   o  Configurable flags and switches selecting between\
    \ operational\n      modes of the LFB\n   o  Number of inputs or outputs in a\
    \ port group\n   o  Various configurable lookup tables, including interface tables,\n\
    \      prefix tables, classification tables, DSCP mapping tables, MAC\n      address\
    \ tables, etc.\n   o  Packet and byte counters\n   o  Various event counters\n\
    \   o  Number of current inputs or outputs for each input or output group\n  \
    \ The ForCES model supports the definition of access permission\n   restrictions\
    \ on what the CE can do with an LFB component.  The\n   following categories are\
    \ supported by the model:\n   o  No-access components.  This is useful for completeness,\
    \ and to\n      allow for defining objects that are used by other things, but\
    \ not\n      directly referencable by the CE.  It is also useful for an FE that\n\
    \      is reporting that certain defined, and typically accessible,\n      components\
    \ are not supported for CE access by a reporting FE.\n   o  Read-only components.\n\
    \   o  Read-write components.\n   o  Write-only components.  This could be any\
    \ configurable data for\n      which read capability is not provided to the CEs\
    \ (e.g., the\n      security key information).\n   o  Read-reset components. \
    \ The CE can read and reset this resource,\n      but cannot set it to an arbitrary\
    \ value.  Example: Counters.\n   o  Firing-only components.  A write attempt to\
    \ this resource will\n      trigger some specific actions in the LFB, but the\
    \ actual value\n      written is ignored.\n   The LFB class MUST define only one\
    \ possible access mode for a given\n   component.\n   The components of the LFB\
    \ class are listed in the <components>\n   element.  Each component is defined\
    \ by an <component> element.  A\n   <component> element contains some or all of\
    \ the following elements,\n   some of which are mandatory:\n   o  <name> MUST\
    \ occur, and defines the name of the component.  This\n      name must be unique\
    \ among the components of the LFB class.\n      Example: \"version\".\n   o  <synopsis>\
    \ is also mandatory, and provides a brief description of\n      the purpose of\
    \ the component.\n   o  <optional/> is an optional element, and if present indicates\
    \ that\n      this component is optional.\n   o  The data type of the component\
    \ can be defined either via a\n      reference to a predefined data type or by\
    \ providing a local\n      definition of the type.  The former is provided by\
    \ using the\n      <typeRef> element, which must refer to the unique name of an\n\
    \      existing data type defined in the <dataTypeDefs> element in the\n     \
    \ same library document or in any of the included library documents.\n      When\
    \ the data type is defined locally (unnamed type), one of the\n      following\
    \ elements can be used: <atomic>, <array>, <struct>, or\n      <union>.  Their\
    \ usage is identical to how they are used inside\n      <dataTypeDef> elements\
    \ (see Section 4.5).  Some form of data type\n      definition MUST be included\
    \ in the component definition.\n   o  The <defaultValue> element is optional,\
    \ and if present is used to\n      specify a default value for a component.  If\
    \ a default value is\n      specified, the FE must ensure that the component has\
    \ that value\n      when the LFB is initialized or reset.  If a default value\
    \ is not\n      specified for a component, the CE MUST make no assumptions as\
    \ to\n      what the value of the component will be upon initialization.  The\n\
    \      CE must either read the value or set the value, if it needs to\n      know\
    \ what it is.\n   o  The <description> element MAY also appear.  If included,\
    \ it\n      provides a longer description of the meaning or usage of the\n   \
    \   particular component being defined.\n   The <component> element also MUST\
    \ have a componentID attribute, which\n   is a numeric value used by the ForCES\
    \ protocol.\n   In addition to the above elements, the <component> element includes\n\
    \   an optional \"access\" attribute, which can take any of the following\n  \
    \ values: \"read-only\", \"read-write\", \"write-only\", \"read-reset\", and\n\
    \   \"trigger-only\".  The default access mode is \"read-write\".\n   Whether\
    \ optional components are supported, and whether components\n   defined as read-write\
    \ can actually be written, can be determined for\n   a given LFB instance by the\
    \ CE by reading the property information of\n   that component.  An access control\
    \ setting of \"trigger-only\" means\n   that this component is included only for\
    \ use in event detection.\n   The following example defines two components for\
    \ an LFB:\n   <components>\n    <component access=\"read-only\" componentID=\"\
    1\">\n     <name>foo</name>\n     <synopsis>number of things</synopsis>\n    \
    \ <typeRef>uint32</typeRef>\n    </component>\n    <component access=\"read-write\"\
    \ componentID=\"2\">\n     <name>bar</name>\n     <synopsis>number of this other\
    \ thing</synopsis>\n     <atomic>\n      <baseType>uint32</baseType>\n      <rangeRestriction>\n\
    \       <allowedRange min=\"10\" max=\"2000\"/>\n      </rangeRestriction>\n \
    \    </atomic>\n     <defaultValue>10</defaultValue>\n    </component>\n   </components>\n\
    \   The first component (\"foo\") is a read-only 32-bit unsigned integer,\n  \
    \ defined by referring to the built-in \"uint32\" atomic type.  The\n   second\
    \ component (\"bar\") is also an integer, but uses the <atomic>\n   element to\
    \ provide additional range restrictions.  This component has\n   access mode of\
    \ read-write allowing it to be both read and written.  A\n   default value of\
    \ 10 is provided for bar.  Although the access for bar\n   is read-write, some\
    \ implementations MAY offer only more restrictive\n   access, and this would be\
    \ reported in the component properties.\n   Note that not all components are likely\
    \ to exist at all times in a\n   particular implementation.  While the capabilities\
    \ will frequently\n   indicate this non-existence, CEs may attempt to reference\
    \ non-\n   existent or non-permitted components anyway.  The ForCES protocol\n\
    \   mechanisms should include appropriate error indicators for this case.\n  \
    \ The mechanism defined above for non-supported components can also\n   apply\
    \ to attempts to reference non-existent array elements or to set\n   read-only\
    \ components.\n"
- title: 4.7.5.  <capabilities> Element to Define LFB Capability Components
  contents:
  - "4.7.5.  <capabilities> Element to Define LFB Capability Components\n   The LFB\
    \ class specification provides some flexibility for the FE\n   implementation\
    \ regarding how the LFB class is implemented.  For\n   example, the instance may\
    \ have some limitations that are not inherent\n   from the class definition, but\
    \ rather the result of some\n   implementation limitations.  Some of these limitations\
    \ are captured\n   by the property information of the LFB components.  The model\
    \ allows\n   for the notion of additional capability information.\n   Such capability-related\
    \ information is expressed by the capability\n   components of the LFB class.\
    \  The capability components are always\n   read-only attributes, and they are\
    \ listed in a separate\n   <capabilities> element in the <LFBClassDef>.  The <capabilities>\n\
    \   element contains one or more <capability> elements, each defining one\n  \
    \ capability component.  The format of the <capability> element is\n   almost\
    \ the same as the <component> element.  It differs in two\n   aspects: it lacks\
    \ the access mode attribute (because it is always\n   read-only), and it lacks\
    \ the <defaultValue> element (because default\n   value is not applicable to read-only\
    \ attributes).\n   Some examples of capability components follow:\n   o  The version\
    \ of the LFB class with which this LFB instance complies\n   o  Supported optional\
    \ features of the LFB class\n   o  Maximum number of configurable outputs for\
    \ an output group\n   o  Metadata pass-through limitations of the LFB\n   o  Additional\
    \ range restriction on operational components\n   The following example lists\
    \ two capability attributes:\n   <capabilities>\n    <capability componentID=\"\
    3\">\n     <name>version</name>\n     <synopsis>\n      LFB class version this\
    \ instance is compliant with.\n     </synopsis>\n     <typeRef>version</typeRef>\n\
    \    </capability>\n    <capability componentID=\"4\">\n     <name>limitBar</name>\n\
    \     <synopsis>\n      Maximum value of the \"bar\" attribute.\n     </synopsis>\n\
    \     <typeRef>uint16</typeRef>\n    </capability>\n   </capabilities>\n"
- title: 4.7.6.  <events> Element for LFB Notification Generation
  contents:
  - "4.7.6.  <events> Element for LFB Notification Generation\n   The <events> element\
    \ contains the information about the occurrences\n   for which instances of this\
    \ LFB class can generate notifications to\n   the CE.  High-level view on the\
    \ declaration and operation of LFB\n   events is described in Section 3.2.5.\n\
    \   The <events> element contains 0 or more <event> elements, each of\n   which\
    \ declares a single event.  The <event> element has an eventID\n   attribute giving\
    \ the unique (per LFB class) ID of the event.  The\n   element will include:\n\
    \   o  <eventTarget> element indicating which LFB field (component) is\n     \
    \ tested to generate the event.\n   o  <condition> element indicating what condition\
    \ on the field will\n      generate the event from a list of defined conditions.\n\
    \   o  <eventReports> element indicating what values are to be reported\n    \
    \  in the notification of the event.\n   The example below demonstrates the different\
    \ constructs.\n   The <events> element has a baseID attribute value, which is\
    \ normally\n   <events baseID=\"number\">.  The value of the baseID is the starting\n\
    \   componentID for the path that identifies events.  It must not be the\n   same\
    \ as the componentID of any top-level components (including\n   capabilities)\
    \ of the LFB class.  In derived LFBs (i.e., ones with a\n   <derivedFrom> element)\
    \ where the parent LFB class has an events\n   declaration, the baseID must not\
    \ be present in the derived LFB\n   <events> element.  Instead, the baseID value\
    \ from the parent LFB\n   class is used.  In the example shown, the baseID is\
    \ 7.\n   <events baseID=\"7\">\n    <event eventID=\"7\">\n      <name>Foochanged</name>\n\
    \      <synopsis>\n          An example event for a scalar\n      </synopsis>\n\
    \      <eventTarget>\n        <eventField>foo</eventField>\n      </eventTarget>\n\
    \      <eventChanged/>\n      <eventReports>\n        <!-- report the new state\
    \ -->\n        <eventReport>\n          <eventField>foo</eventField>\n       \
    \ </eventReport>\n      </eventReports>\n    </event>\n    <event eventID=\"8\"\
    >\n      <name>Goof1changed</name>\n      <synopsis>\n          An example event\
    \ for a complex structure\n      </synopsis>\n      <eventTarget>\n        <!--\
    \ target is goo.f1 -->\n        <eventField>goo</eventField>\n        <eventField>f1</eventField>\n\
    \      </eventTarget>\n      <eventChanged/>\n      <eventReports>\n        <!--\
    \ report the new state of goo.f1 -->\n        <eventReport>\n        <eventField>goo</eventField>\n\
    \        <eventField>f1</eventField>\n        </eventReport>\n      </eventReports>\n\
    \    </event>\n    <event eventID=\"9\">\n      <name>NewbarEntry</name>\n   \
    \   <synopsis>\n          Event for a new entry created on table bar\n      </synopsis>\n\
    \      <eventTarget>\n        <eventField>bar</eventField>\n        <eventSubscript>_barIndex_</eventSubscript>\n\
    \      </eventTarget>\n      <eventCreated/>\n      <eventReports>\n        <eventReport>\n\
    \         <eventField>bar</eventField>\n         <eventSubscript>_barIndex_</eventSubscript>\n\
    \       </eventReport>\n       <eventReport>\n        <eventField>foo</eventField>\n\
    \       </eventReport>\n      </eventReports>\n    </event>\n    <event eventID=\"\
    10\">\n      <name>Gah11changed</name>\n      <synopsis>\n          Event for\
    \ table gah, entry index 11 changing\n      </synopsis>\n      <eventTarget>\n\
    \        <eventField>gah</eventField>\n        <eventSubscript>11</eventSubscript>\n\
    \      </eventTarget>\n      <eventChanged/>\n      <eventReports>\n        <eventReport>\n\
    \         <eventField>gah</eventField>\n         <eventSubscript>11</eventSubscript>\n\
    \       </eventReport>\n      </eventReports>\n    </event>\n    <event eventID=\"\
    11\">\n      <name>Gah10field1</name>\n      <synopsis>\n          Event for table\
    \ gah, entry index 10, column field1 changing\n      </synopsis>\n      <eventTarget>\n\
    \        <eventField>gah</eventField>\n        <eventSubscript>10</eventSubscript>\n\
    \        <eventField>field1</eventField>\n      </eventTarget>\n      <eventChanged/>\n\
    \      <eventReports>\n        <eventReport>\n         <eventField>gah</eventField>\n\
    \         <eventSubscript>10</eventSubscript>\n        </eventReport>\n      </eventReports>\n\
    \    </event>\n   </events>\n"
- title: 4.7.6.1.  <eventTarget> Element
  contents:
  - "4.7.6.1.  <eventTarget> Element\n   The <eventTarget> element contains information\
    \ identifying a field in\n   the LFB that is to be monitored for events.\n   The\
    \ <eventTarget> element contains one or more <eventField>s each of\n   which MAY\
    \ be followed by one or more <eventSubscript> elements.  Each\n   of these two\
    \ elements represents the textual equivalent of a path\n   select component of\
    \ the LFB.\n   The <eventField> element contains the name of a component in the\
    \ LFB\n   or a component nested in an array or structure within the LFB.  The\n\
    \   name used in <eventField> MUST identify a valid component within the\n   containing\
    \ LFB context.  The first element in an <eventTarget> MUST\n   be an <eventField>\
    \ element.  In the example shown, four LFB\n   components foo, goo, bar, and gah\
    \ are used as <eventField>s.\n   In the simple case, an <eventField> identifies\
    \ an atomic component.\n   This is the case illustrated in the event named Foochanged.\n\
    \   <eventField> is also used to address complex components such as\n   arrays\
    \ or structures.\n      The first defined event, Foochanged, demonstrates how\
    \ a scalar LFB\n      component, foo, could be monitored to trigger an event.\n\
    \      The second event, Goof1changed, demonstrates how a member of the\n    \
    \  complex structure goo could be monitored to trigger an event.\n      The events\
    \ named NewbarEntry, Gah11changed, and Gah10field1\n      represent monitoring\
    \ of arrays bar and gah in differing details.\n   If an <eventField> identifies\
    \ a complex component, then a further\n   <eventField> MAY be used to refine the\
    \ path to the target element.\n   Defined event Goof1changed demonstrates how\
    \ a second <eventField> is\n   used to point to member f1 of the structure goo.\n\
    \   If an <eventField> identifies an array, then the following rules\n   apply:\n\
    \   o  <eventSubscript> elements MUST be present as the next XML element\n   \
    \   after an <eventField> that identifies an array component.\n      <eventSubscript>\
    \ MUST NOT occur other than after an array\n      reference, as it is only meaningful\
    \ in that context.\n   o  An <eventSubscript> contains either:\n      *  A numeric\
    \ value to indicate that the event applies to a\n         specific entry (by index)\
    \ of the array.  As an example, event\n         Gah11changed shows how table gah's\
    \ index 11 is being targeted\n         for monitoring.\n   Or\n      *  It is\
    \ expected that the more common usage is to have the event\n         being defined\
    \ across all elements of the array (i.e., a\n         wildcard for all indices).\
    \  In that case, the value of the\n         <eventSubscript> MUST be a name rather\
    \ than a numeric value.\n         That same name can then be used as the value\
    \ of\n         <eventSubscript> in <eventReport> elements as described below.\n\
    \         An example of a wild card table index is shown in event\n         NewBarentry\
    \ where the <eventSubscript> value is named\n         _barIndex_\n   o  An <eventField>\
    \ MAY follow an <eventSubscript> to further refine\n      the path to the target\
    \ element.  (Note: this is in the same spirit\n      as the case where <eventField>\
    \ is used to further refine\n      <eventField> in the earlier example of a complex\
    \ structure example\n      of Goof1changed.)  The example event Gah10field1 illustrates\
    \ how\n      the column field1 of table gah is monitored for changes.\n   It should\
    \ be emphasized that the name in an <eventSubscript> element\n   in defined event\
    \ NewbarEntry is not a component name.  It is a\n   variable name for use in the\
    \ <eventReport> elements (described in\n   Section 4.7.6.3) of the given LFB definition.\
    \  This name MUST be\n   distinct from any component name that can validly occur\
    \ in the\n   <eventReport> clause.\n"
- title: 4.7.6.2.  <eventCondition> Element
  contents:
  - "4.7.6.2.  <eventCondition> Element\n   The event condition element represents\
    \ a condition that triggers a\n   notification.  The list of conditions is:\n\
    \   <eventCreated/>:  The target must be an array, ending with a\n           \
    \          subscript indication.  The event is generated when\n              \
    \       an entry in the array is created.  This occurs even\n                \
    \     if the entry is created by CE direction.  The event\n                  \
    \   example NewbarEntry demonstrates the\n                     <eventCreated/>\
    \ condition.\n   <eventDeleted/>:  The target must be an array, ending with a\n\
    \                     subscript indication.  The event is generated when\n   \
    \                  an entry in the array is destroyed.  This occurs\n        \
    \             even if the entry is destroyed by CE direction.\n   <eventChanged/>:\
    \  The event is generated whenever the target\n                     component\
    \ changes in any way.  For binary\n                     components such as up/down,\
    \ this reflects a change\n                     in state.  It can also be used\
    \ with numeric\n                     attributes, in which case any change in value\n\
    \                     results in a detected trigger.  Event examples\n       \
    \              Foochanged, Gah11changed, and Gah10field1\n                   \
    \  illustrate the <eventChanged/> condition.\n   <eventGreaterThan/>:  The event\
    \ is generated whenever the target\n                         component becomes\
    \ greater than the threshold.\n                         The threshold is an event\
    \ property.\n   <eventLessThan/>:  The event is generated whenever the target\n\
    \                      component becomes less than the threshold.  The\n     \
    \                 threshold is an event property.\n"
- title: 4.7.6.3.  <eventReports> Element
  contents:
  - "4.7.6.3.  <eventReports> Element\n   The <eventReports> element of an <event>\
    \ declares the information to\n   be delivered by the FE along with the notification\
    \ of the occurrence\n   of the event.\n   The <eventReports> element contains\
    \ one or more <eventReport>\n   elements.  Each <eventReport> element identifies\
    \ a piece of data from\n   the LFB class to be reported.  The notification carries\
    \ that data as\n   if the collection of <eventReport> elements had been defined\
    \ in a\n   structure.  The syntax is exactly the same as used in the\n   <eventTarget>\
    \ element, using <eventField> and <eventSubscript>\n   elements, and so the same\
    \ rules apply.  Each <eventReport> element\n   thus MUST identify a component\
    \ in the LFB class. <eventSubcript> MAY\n   contain integers.  If they contain\
    \ names, they MUST be names from\n   <eventSubscript> elements of the <eventTarget>\
    \ in the event.  The\n   selection for the report will use the value for the subscript\
    \ that\n   identifies that specific element triggering the event.  This can be\n\
    \   used to reference the component causing the event, or to reference\n   related\
    \ information in parallel tables.\n   In the example shown, in the case of the\
    \ event Foochanged, the report\n   will carry the value of foo.  In the case of\
    \ the defined event\n   NewbarEntry acting on LFB component bar, which is an array,\
    \ there are\n   two items that are reported as indicated by the two <eventReport>\n\
    \   declarations:\n   o  The first <eventReport> details what new entry was added\
    \ in the\n      table bar.  Recall that _barIndex_ is declared as the event's\n\
    \      <eventTarget> <eventSubcript> and that by virtue of using a name\n    \
    \  instead of a numeric value, the <eventSubcript> is implied to be a\n      wildcard\
    \ and will carry whatever index of the new entry.\n   o  The second <eventReport>\
    \ includes the value of LFB component foo\n      at the time the new entry was\
    \ created in bar.  Reporting foo in\n      this case is provided to demonstrate\
    \ the flexibility of event\n      reporting.\n   This event reporting structure\
    \ is designed to allow the LFB designer\n   to specify information that is likely\
    \ not known a priori by the CE\n   and is likely needed by the CE to process the\
    \ event.  While the\n   structure allows for pointing at large blocks of information\
    \ (full\n   arrays or complex structures), this is not recommended.  Also, the\n\
    \   variable reference/subscripting in reporting only captures a small\n   portion\
    \ of the kinds of related information.  Chaining through index\n   fields stored\
    \ in a table, for example, is not supported.  In general,\n   the <eventReports>\
    \ mechanism is an optimization for cases that have\n   been found to be common,\
    \ saving the CE from having to query for\n   information it needs to understand\
    \ the event.  It does not represent\n   all possible information needs.\n   If\
    \ any components referenced by the eventReport are optional, then\n   the report\
    \ MUST use a protocol format that supports optional elements\n   and allows for\
    \ the non-existence of such elements.  Any components\n   that do not exist are\
    \ not reported.\n"
- title: 4.7.6.4.  Runtime Control of Events
  contents:
  - "4.7.6.4.  Runtime Control of Events\n   The high-level view of the declaration\
    \ and operation of LFB events is\n   described in Section 3.2.5.\n   The <eventTarget>\
    \ provides additional components used in the path to\n   reference the event.\
    \  The path constitutes the baseID for events,\n   followed by the ID for the\
    \ specific event, followed by a value for\n   each <eventSubscript> element if\
    \ it exists in the <eventTarget>.\n   The event path will uniquely identify a\
    \ specific occurrence of the\n   event in the event notification to the CE.  In\
    \ the example provided\n   above, at the end of Section 4.7.6, a notification\
    \ with path of 7.7\n   uniquely identifies the event to be that caused by the\
    \ change of foo;\n   an event with path 7.9.100 uniquely identifies the event\
    \ to be that\n   caused by a creation of table bar entry with index/subscript\
    \ 100.\n   As described in Section 4.8.5, event elements have properties\n   associated\
    \ with them.  These properties include the subscription\n   information indicating\
    \ whether the CE wishes the FE to generate event\n   reports for the event at\
    \ all, thresholds for events related to level\n   crossing, and filtering conditions\
    \ that may reduce the set of event\n   notifications generated by the FE.  Details\
    \ of the filtering\n   conditions that can be applied are given in that section.\
    \  The\n   filtering conditions allow the FE to suppress floods of events that\n\
    \   could result from oscillation around a condition value.  For FEs that\n  \
    \ do not wish to support filtering, the filter properties can be either\n   read-only\
    \ or not supported.\n   In addition to identifying the event sources, the CE also\
    \ uses the\n   event path to activate runtime control of the event via the event\n\
    \   properties (defined in Section 4.8.5) utilizing SET-PROP as defined\n   in\
    \ the ForCES protocol [RFC5810] operation.\n   To activate event generation on\
    \ the FE, a SET-PROP message\n   referencing the event and registration property\
    \ of the event is\n   issued to the FE by the CE with any prefix of the path of\
    \ the event.\n   So, for an event defined on the example table bar, a SET-PROP\
    \ with a\n   path of 7.9 will subscribe the CE to all occurrences of that event\
    \ on\n   any entry of the table.  This is particularly useful for the\n   <eventCreated/>\
    \ and <eventDestroyed/> conditions on tables.  Events\n   using those conditions\
    \ will generally be defined with a field/\n   subscript sequence that identifies\
    \ an array and ends with an\n   <eventSubscript> element.  Thus, the event notification\
    \ will indicate\n   which array entry has been created or destroyed.  A typical\n\
    \   subscriber will subscribe for the array, as opposed to a specific\n   entry\
    \ in an array, so it will use a shorter path.\n   In the example provided, subscribing\
    \ to 7.8 implies receiving all\n   declared events from table bar.  Subscribing\
    \ to 7.8.100 implies\n   receiving an event when subscript/index 100 table entry\
    \ is created.\n   Threshold and filtering conditions can only be applied to individual\n\
    \   events.  For events defined on elements of an array, this\n   specification\
    \ does not allow for defining a threshold or filtering\n   condition on an event\
    \ for all elements of an array.\n"
- title: 4.7.7.  <description> Element for LFB Operational Specification
  contents:
  - "4.7.7.  <description> Element for LFB Operational Specification\n   The <description>\
    \ element of the <LFBClass> provides unstructured\n   text (in XML sense) to explain\
    \ what the LFB does to a human user.\n"
- title: 4.8.  Properties
  contents:
  - "4.8.  Properties\n   Components of LFBs have properties that are important to\
    \ the CE.  The\n   most important property is the existence / readability / writeability\n\
    \   of the element.  Depending on the type of the component, other\n   information\
    \ may be of importance.\n   The model provides the definition of the structure\
    \ of property\n   information.  There is a base class of property information.\
    \  For the\n   array, alias, and event components, there are subclasses of property\n\
    \   information providing additional fields.  This information is\n   accessed\
    \ by the CE (and updated where applicable) via the ForCES\n   protocol.  While\
    \ some property information is writeable, there is no\n   mechanism currently\
    \ provided for checking the properties of a\n   property element.  Writeability\
    \ can only be checked by attempting to\n   modify the value.\n"
- title: 4.8.1.  Basic Properties
  contents:
  - "4.8.1.  Basic Properties\n   The basic property definition, along with the scalar\
    \ dataTypeDef for\n   accessibility, is below.  Note that this access permission\n\
    \   information is generally read-only.\n                <dataTypeDef>\n     \
    \             <name>accessPermissionValues</name>\n                  <synopsis>\n\
    \                    The possible values of component access permission\n    \
    \              </synopsis>\n                  <atomic>\n                    <baseType>uchar</baseType>\n\
    \                    <specialValues>\n                      <specialValue value=\"\
    0\">\n                        <name>None</name>\n                        <synopsis>Access\
    \ is prohibited</synopsis>\n                      </specialValue>\n          \
    \             <specialValue value=\"1\">\n                        <name> Read-Only\
    \ </name>\n                        <synopsis>\n                          Access\
    \ to the component is read only\n                        </synopsis>\n       \
    \               </specialValue>\n                      <specialValue value=\"\
    2\">\n                        <name>Write-Only</name>\n                      \
    \  <synopsis>\n                          The component MAY be written, but not\
    \ read\n                        </synopsis>\n                      </specialValue>\n\
    \                      <specialValue value=\"3\">\n                        <name>Read-Write</name>\n\
    \                        <synopsis>\n                          The component MAY\
    \ be read or written\n                        </synopsis>\n                  \
    \    </specialValue>\n                    </specialValues>\n                 \
    \ </atomic>\n                </dataTypeDef>\n                <dataTypeDef>\n \
    \                 <name>baseElementProperties</name>\n                  <synopsis>basic\
    \ properties, accessibility</synopsis>\n                  <struct>\n         \
    \           <component componentID=\"1\">\n                      <name>accessibility</name>\n\
    \                      <synopsis>\n                          does the component\
    \ exist, and\n                          can it be read or written\n          \
    \            </synopsis>\n                      <typeRef>accessPermissionValues</typeRef>\n\
    \                    </component>\n                  </struct>\n             \
    \   </dataTypeDef>\n"
- title: 4.8.2.  Array Properties
  contents:
  - "4.8.2.  Array Properties\n   The properties for an array add a number of important\
    \ pieces of\n   information.  These properties are also read-only.\n         <dataTypeDef>\n\
    \           <name>arrayElementProperties</name>\n           <synopsis>Array Element\
    \ Properties definition</synopsis>\n           <struct>\n             <derivedFrom>baseElementProperties</derivedFrom>\n\
    \             <component componentID=\"2\">\n               <name>entryCount</name>\n\
    \               <synopsis>the number of entries in the array</synopsis>\n    \
    \           <typeRef>uint32</typeRef>\n             </component>\n           \
    \  <component componentID=\"3\">\n               <name>highestUsedSubscript</name>\n\
    \               <synopsis>the last used subscript in the array</synopsis>\n  \
    \             <typeRef>uint32</typeRef>\n             </component>\n         \
    \    <component componentID=\"4\">\n               <name>firstUnusedSubscript</name>\n\
    \               <synopsis>\n                 The subscript of the first unused\
    \ array element\n               </synopsis>\n               <typeRef>uint32</typeRef>\n\
    \             </component>\n           </struct>\n         </dataTypeDef>\n"
- title: 4.8.3.  String Properties
  contents:
  - "4.8.3.  String Properties\n   The properties of a string specify the actual octet\
    \ length and the\n   maximum octet length for the element.  The maximum length\
    \ is included\n   because an FE implementation MAY limit a string to be shorter\
    \ than\n   the limit in the LFB class definition.\n           <dataTypeDef>\n\
    \             <name>stringElementProperties</name>\n             <synopsis>string\
    \ Element Properties definition </synopsis>\n             <struct>\n         \
    \      <derivedFrom>baseElementProperties</derivedFrom>\n               <component\
    \ componentID=\"2\">\n                 <name>stringLength</name>\n           \
    \      <synopsis>the number of octets in the string</synopsis>\n             \
    \    <typeRef>uint32</typeRef>\n               </component>\n               <component\
    \ componentID=\"3\">\n                 <name>maxStringLength</name>\n        \
    \         <synopsis>\n                   the maximum number of octets in the string\n\
    \                   </synopsis>\n                 <typeRef>uint32</typeRef>\n\
    \               </component>\n             </struct>\n           </dataTypeDef>\n"
- title: 4.8.4.  Octetstring Properties
  contents:
  - "4.8.4.  Octetstring Properties\n   The properties of an octetstring specify the\
    \ actual length and the\n   maximum length, since the FE implementation MAY limit\
    \ an octetstring\n   to be shorter than the LFB class definition.\n          \
    \    <dataTypeDef>\n                <name>octetstringElementProperties</name>\n\
    \                <synopsis>octetstring Element Properties definition\n       \
    \         </synopsis>\n                <struct>\n                  <derivedFrom>baseElementProperties</derivedFrom>\n\
    \                  <component componentID=\"2\">\n                    <name>octetstringLength</name>\n\
    \                    <synopsis>\n                      the number of octets in\
    \ the octetstring\n                    </synopsis>\n                    <typeRef>uint32</typeRef>\n\
    \                  </component>\n                  <component componentID=\"3\"\
    >\n                    <name>maxOctetstringLength</name>\n                   \
    \ <synopsis>\n                      the maximum number of octets in the octetstring\n\
    \                    </synopsis>\n                    <typeRef>uint32</typeRef>\n\
    \                  </component>\n                </struct>\n              </dataTypeDef>\n"
- title: 4.8.5.  Event Properties
  contents:
  - "4.8.5.  Event Properties\n   The properties for an event add three (usually)\
    \ writeable fields.\n   One is the subscription field. 0 means no notification\
    \ is generated.\n   Any non-zero value (typically 1 is used) means that a notification\
    \ is\n   generated.  The hysteresis field is used to suppress generation of\n\
    \   notifications for oscillations around a condition value, and is\n   described\
    \ below (Section 4.8.5.2).  The threshold field is used for\n   the <eventGreaterThan/>\
    \ and <eventLessThan/> conditions.  It\n   indicates the value to compare the\
    \ event target against.  Using the\n   properties allows the CE to set the level\
    \ of interest.  FEs that do\n   not support setting the threshold for events will\
    \ make this field\n   read-only.\n            <dataTypeDef>\n              <name>eventElementProperties</name>\n\
    \              <synopsis>event Element Properties definition</synopsis>\n    \
    \          <struct>\n                <derivedFrom>baseElementProperties</derivedFrom>\n\
    \                <component componentID=\"2\">\n                  <name>registration</name>\n\
    \                  <synopsis>\n                    has the CE registered to be\
    \ notified of this event\n                  </synopsis>\n                  <typeRef>uint32</typeRef>\n\
    \                </component>\n                <component componentID=\"3\">\n\
    \                  <name>threshold</name>\n                  <synopsis> comparison\
    \ value for level crossing events\n                  </synopsis>\n           \
    \       <optional/>\n                  <typeRef>uint32</typeRef>\n           \
    \     </component>\n                <component componentID=\"4\">\n          \
    \        <name>eventHysteresis</name>\n                  <synopsis> region to\
    \ suppress event recurrence notices\n                  </synopsis>\n         \
    \         <optional/>\n                  <typeRef>uint32</typeRef>\n         \
    \       </component>\n                <component componentID=\"5\">\n        \
    \          <name>eventCount</name>\n                  <synopsis> number of occurrences\
    \ to suppress\n                  </synopsis>\n                  <optional/>\n\
    \                  <typeRef>uint32</typeRef>\n                </component>\n \
    \               <component componentID=\"6\">\n                  <name>eventInterval</name>\n\
    \                  <synopsis> time interval in ms between notifications\n    \
    \              </synopsis>\n                  <optional/>\n                  <typeRef>uint32</typeRef>\n\
    \                </component>\n              </struct>\n            </dataTypeDef>\n"
- title: 4.8.5.1.  Common Event Filtering
  contents:
  - "4.8.5.1.  Common Event Filtering\n   The event properties have values for controlling\
    \ several filter\n   conditions.  Support of these conditions is optional, but\
    \ all\n   conditions SHOULD be supported.  Events that are reliably known not\n\
    \   to be subject to rapid occurrence or other concerns MAY not support\n   all\
    \ filter conditions.\n   Currently, three different filter condition variables\
    \ are defined.\n   These are eventCount, eventInterval, and eventHysteresis. \
    \ Setting\n   the condition variables to 0 (their default value) means that the\n\
    \   condition is not checked.\n   Conceptually, when an event is triggered, all\
    \ configured conditions\n   are checked.  If no filter conditions are triggered,\
    \ or if any\n   trigger conditions are met, the event notification is generated.\
    \  If\n   there are filter conditions, and no condition is met, then no event\n\
    \   notification is generated.  Event filter conditions have reset\n   behavior\
    \ when an event notification is generated.  If any condition\n   is passed, and\
    \ the notification is generated, the notification reset\n   behavior is performed\
    \ on all conditions, even those that had not\n   passed.  This provides a clean\
    \ definition of the interaction of the\n   various event conditions.\n   An example\
    \ of the interaction of conditions is an event with an\n   eventCount property\
    \ set to 5 and an eventInterval property set to 500\n   milliseconds.  Suppose\
    \ that a burst of occurrences of this event is\n   detected by the FE.  The first\
    \ occurrence will cause a notification\n   to be sent to the CE.  Then, if four\
    \ more occurrences are detected\n   rapidly (less than 0.5 seconds) they will\
    \ not result in\n   notifications.  If two more occurrences are detected, then\
    \ the second\n   of those will result in a notification.  Alternatively, if more\
    \ than\n   500 milliseconds has passed since the notification and an occurrence\n\
    \   is detected, that will result in a notification.  In either case, the\n  \
    \ count and time interval suppression is reset no matter which\n   condition actually\
    \ caused the notification.\n"
- title: 4.8.5.2.   Event Hysteresis Filtering
  contents:
  - "4.8.5.2.   Event Hysteresis Filtering\n   Events with numeric conditions can\
    \ have hysteresis filters applied to\n   them.  The hysteresis level is defined\
    \ by a property of the event.\n   This allows the FE to notify the CE of the hysteresis\
    \ applied, and if\n   it chooses, the FE can allow the CE to modify the hysteresis.\
    \  This\n   applies to <eventChanged/> for a numeric field, and to\n   <eventGreaterThan/>\
    \ and <eventLessThan/>.  The content of a\n   <variance> element is a numeric\
    \ value.  When supporting hysteresis,\n   the FE MUST track the value of the element\
    \ and make sure that the\n   condition has become untrue by at least the hysteresis\
    \ from the event\n   property.  To be specific, if the hysteresis is V, then:\n\
    \   o  For an <eventChanged/> condition, if the last notification was for\n  \
    \    value X, then the <changed/> notification MUST NOT be generated\n      until\
    \ the value reaches X +/- V.\n   o  For an <eventGreaterThan/> condition with\
    \ threshold T, once the\n      event has been generated at least once it MUST\
    \ NOT be generated\n      again until the field first becomes less than or equal\
    \ to T - V,\n      and then exceeds T.\n   o  For an <eventLessThan/> condition\
    \ with threshold T, once the event\n      has been generate at least once it MUST\
    \ NOT be generated again\n      until the field first becomes greater than or\
    \ equal to T + V, and\n      then becomes less than T.\n"
- title: 4.8.5.3.  Event Count Filtering
  contents:
  - "4.8.5.3.  Event Count Filtering\n   Events MAY have a count filtering condition.\
    \  This property, if set\n   to a non-zero value, indicates the number of occurrences\
    \ of the event\n   that should be considered redundant and not result in a notification.\n\
    \   Thus, if this property is set to 1, and no other conditions apply,\n   then\
    \ every other detected occurrence of the event will result in a\n   notification.\
    \  This particular meaning is chosen so that the value 1\n   has a distinct meaning\
    \ from the value 0.\n   A conceptual implementation (not required) for this might\
    \ be an\n   internal suppression counter.  Whenever an event is triggered, the\n\
    \   counter is checked.  If the counter is 0, a notification is\n   generated.\
    \  Whether or not a notification is generated, the counter\n   is incremented.\
    \  If the counter exceeds the configured value, it is\n   set to 0.\n"
- title: 4.8.5.4.  Event Time Filtering
  contents:
  - "4.8.5.4.  Event Time Filtering\n   Events MAY have a time filtering condition.\
    \  This property represents\n   the minimum time interval (in the absence of some\
    \ other filtering\n   condition being passed) between generating notifications\
    \ of detected\n   events.  This condition MUST only be passed if the time since\
    \ the\n   last notification of the event is longer than the configured interval\n\
    \   in milliseconds.\n   Conceptually, this can be thought of as a stored timestamp\
    \ that is\n   compared with the detection time, or as a timer that is running\
    \ that\n   resets a suppression flag.  In either case, if a notification is\n\
    \   generated due to passing any condition then the time interval\n   detection\
    \ MUST be restarted.\n"
- title: 4.8.6.  Alias Properties
  contents:
  - "4.8.6.  Alias Properties\n   The properties for an alias add three (usually)\
    \ writeable fields.\n   These combine to identify the target component to which\
    \ the subject\n   alias refers.\n          <dataTypeDef>\n            <name>aliasElementProperties</name>\n\
    \            <synopsis>alias Element Properties definition</synopsis>\n      \
    \      <struct>\n              <derivedFrom>baseElementProperties</derivedFrom>\n\
    \              <component componentID=\"2\">\n                <name>targetLFBClass</name>\n\
    \                <synopsis>the class ID of the alias target</synopsis>\n     \
    \           <typeRef>uint32</typeRef>\n              </component>\n          \
    \    <component componentID=\"3\">\n                <name>targetLFBInstance</name>\n\
    \                <synopsis>the instance ID of the alias target</synopsis>\n  \
    \              <typeRef>uint32</typeRef>\n              </component>\n       \
    \       <component componentID=\"4\">\n                <name>targetComponentPath</name>\n\
    \                <synopsis>\n                  the path to the component target\n\
    \                  each 4 octets is read as one path element,\n              \
    \    using the path construction in the ForCES protocol,\n                  [2].\n\
    \                </synopsis>\n                <typeRef>octetstring[128]</typeRef>\n\
    \              </component>\n            </struct>\n          </dataTypeDef>\n"
- title: 4.9.  XML Schema for LFB Class Library Documents
  contents:
  - "4.9.  XML Schema for LFB Class Library Documents\n      <?xml version=\"1.0\"\
    \ encoding=\"UTF-8\"?>\n      <xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\
    \n       xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\"\n       xmlns:lfb=\"\
    urn:ietf:params:xml:ns:forces:lfbmodel:1.0\"\n       targetNamespace=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\"\
    \n       attributeFormDefault=\"unqualified\"\n       elementFormDefault=\"qualified\"\
    >\n      <xsd:annotation>\n        <xsd:documentation xml:lang=\"en\">\n     \
    \   Schema for Defining LFB Classes and associated types (frames,\n        data\
    \ types for LFB attributes, and metadata).\n        </xsd:documentation>\n   \
    \   </xsd:annotation>\n      <xsd:element name=\"description\" type=\"xsd:string\"\
    />\n      <xsd:element name=\"synopsis\" type=\"xsd:string\"/>\n      <!-- Document\
    \ root element: LFBLibrary -->\n      <xsd:element name=\"LFBLibrary\">\n    \
    \    <xsd:complexType>\n          <xsd:sequence>\n            <xsd:element ref=\"\
    description\" minOccurs=\"0\"/>\n            <xsd:element name=\"load\" type=\"\
    loadType\" minOccurs=\"0\"\n                      maxOccurs=\"unbounded\"/>\n\
    \         <xsd:element name=\"frameDefs\" type=\"frameDefsType\"\n           \
    \           minOccurs=\"0\"/>\n         <xsd:element name=\"dataTypeDefs\" type=\"\
    dataTypeDefsType\"\n                      minOccurs=\"0\"/>\n         <xsd:element\
    \ name=\"metadataDefs\" type=\"metadataDefsType\"\n                      minOccurs=\"\
    0\"/>\n         <xsd:element name=\"LFBClassDefs\" type=\"LFBClassDefsType\"\n\
    \                      minOccurs=\"0\"/>\n       </xsd:sequence>\n       <xsd:attribute\
    \ name=\"provides\" type=\"xsd:Name\" use=\"required\"/>\n     </xsd:complexType>\n\
    \     <!-- Uniqueness constraints -->\n     <xsd:key name=\"frame\">\n      <xsd:selector\
    \ xpath=\"lfb:frameDefs/lfb:frameDef\"/>\n       <xsd:field xpath=\"lfb:name\"\
    />\n     </xsd:key>\n     <xsd:key name=\"dataType\">\n      <xsd:selector xpath=\"\
    lfb:dataTypeDefs/lfb:dataTypeDef\"/>\n       <xsd:field xpath=\"lfb:name\"/>\n\
    \     </xsd:key>\n     <xsd:key name=\"metadataDef\">\n       <xsd:selector xpath=\"\
    lfb:metadataDefs/lfb:metadataDef\"/>\n       <xsd:field xpath=\"lfb:name\"/>\n\
    \     </xsd:key>\n     <xsd:key name=\"LFBClassDef\">\n       <xsd:selector xpath=\"\
    lfb:LFBClassDefs/lfb:LFBClassDef\"/>\n       <xsd:field xpath=\"lfb:name\"/>\n\
    \     </xsd:key>\n   </xsd:element>\n   <xsd:complexType name=\"loadType\">\n\
    \     <xsd:attribute name=\"library\" type=\"xsd:Name\" use=\"required\"/>\n \
    \    <xsd:attribute name=\"location\" type=\"xsd:anyURI\" use=\"optional\"/>\n\
    \   </xsd:complexType>\n   <xsd:complexType name=\"frameDefsType\">\n     <xsd:sequence>\n\
    \       <xsd:element name=\"frameDef\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n\
    \        <xsd:sequence>\n             <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"\
    />\n             <xsd:element ref=\"synopsis\"/>\n             <xsd:element ref=\"\
    description\" minOccurs=\"0\"/>\n           </xsd:sequence>\n         </xsd:complexType>\n\
    \       </xsd:element>\n     </xsd:sequence>\n   </xsd:complexType>\n   <xsd:complexType\
    \ name=\"dataTypeDefsType\">\n     <xsd:sequence>\n          <xsd:element name=\"\
    dataTypeDef\" maxOccurs=\"unbounded\">\n            <xsd:complexType>\n      \
    \        <xsd:sequence>\n                <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"\
    />\n                <xsd:element ref=\"synopsis\"/>\n                <xsd:element\
    \ ref=\"description\" minOccurs=\"0\"/>\n                <xsd:group ref=\"typeDeclarationGroup\"\
    />\n              </xsd:sequence>\n            </xsd:complexType>\n          </xsd:element>\n\
    \        </xsd:sequence>\n      </xsd:complexType>\n      <!--\n         Predefined\
    \ (built-in) atomic data-types are:\n             char, uchar, int16, uint16,\
    \ int32, uint32, int64, uint64,\n             string[N], string, byte[N], boolean,\
    \ octetstring[N],\n             float32, float64\n      -->\n      <xsd:group\
    \ name=\"typeDeclarationGroup\">\n        <xsd:choice>\n          <xsd:element\
    \ name=\"typeRef\" type=\"typeRefNMTOKEN\"/>\n          <xsd:element name=\"atomic\"\
    \ type=\"atomicType\"/>\n          <xsd:element name=\"array\" type=\"arrayType\"\
    />\n          <xsd:element name=\"struct\" type=\"structType\"/>\n          <xsd:element\
    \ name=\"union\" type=\"structType\"/>\n          <xsd:element name=\"alias\"\
    \ type=\"typeRefNMTOKEN\"/>\n        </xsd:choice>\n      </xsd:group>\n     \
    \ <xsd:simpleType name=\"typeRefNMTOKEN\">\n        <xsd:restriction base=\"xsd:token\"\
    >\n          <xsd:pattern value=\"\\c+\"/>\n          <xsd:pattern value=\"string\\\
    [\\d+\\]\"/>\n          <xsd:pattern value=\"byte\\[\\d+\\]\"/>\n          <xsd:pattern\
    \ value=\"octetstring\\[\\d+\\]\"/>\n        </xsd:restriction>\n      </xsd:simpleType>\n\
    \      <xsd:complexType name=\"atomicType\">\n        <xsd:sequence>\n       \
    \   <xsd:element name=\"baseType\" type=\"typeRefNMTOKEN\"/>\n          <xsd:element\
    \ name=\"rangeRestriction\"\n                       type=\"rangeRestrictionType\"\
    \ minOccurs=\"0\"/>\n          <xsd:element name=\"specialValues\" type=\"specialValuesType\"\
    \n                       minOccurs=\"0\"/>\n        </xsd:sequence>\n      </xsd:complexType>\n\
    \      <xsd:complexType name=\"rangeRestrictionType\">\n        <xsd:sequence>\n\
    \          <xsd:element name=\"allowedRange\" maxOccurs=\"unbounded\">\n     \
    \       <xsd:complexType>\n           <xsd:attribute name=\"min\" type=\"xsd:integer\"\
    \n   use=\"required\"/>\n           <xsd:attribute name=\"max\" type=\"xsd:integer\"\
    \n   use=\"required\"/>\n         </xsd:complexType>\n       </xsd:element>\n\
    \     </xsd:sequence>\n   </xsd:complexType>\n   <xsd:complexType name=\"specialValuesType\"\
    >\n     <xsd:sequence>\n       <xsd:element name=\"specialValue\" maxOccurs=\"\
    unbounded\">\n         <xsd:complexType>\n           <xsd:sequence>\n        \
    \     <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n             <xsd:element\
    \ ref=\"synopsis\"/>\n           </xsd:sequence>\n           <xsd:attribute name=\"\
    value\" type=\"xsd:token\"/>\n         </xsd:complexType>\n       </xsd:element>\n\
    \     </xsd:sequence>\n   </xsd:complexType>\n   <xsd:complexType name=\"arrayType\"\
    >\n     <xsd:sequence>\n       <xsd:group ref=\"typeDeclarationGroup\"/>\n   \
    \    <xsd:element name=\"contentKey\" minOccurs=\"0\"\n                    maxOccurs=\"\
    unbounded\">\n         <xsd:complexType>\n           <xsd:sequence>\n        \
    \     <xsd:element name=\"contentKeyField\" maxOccurs=\"unbounded\"\n        \
    \                  type=\"xsd:string\"/>\n           </xsd:sequence>\n       \
    \    <xsd:attribute name=\"contentKeyID\" use=\"required\"\n                 \
    \         type=\"xsd:integer\"/>\n         </xsd:complexType>\n         <!--declare\
    \ keys to have unique IDs -->\n         <xsd:key name=\"contentKeyID\">\n    \
    \       <xsd:selector xpath=\"lfb:contentKey\"/>\n           <xsd:field xpath=\"\
    @contentKeyID\"/>\n         </xsd:key>\n       </xsd:element>\n     </xsd:sequence>\n\
    \     <xsd:attribute name=\"type\" use=\"optional\"\n                    default=\"\
    variable-size\">\n       <xsd:simpleType>\n         <xsd:restriction base=\"xsd:string\"\
    >\n           <xsd:enumeration value=\"fixed-size\"/>\n           <xsd:enumeration\
    \ value=\"variable-size\"/>\n         </xsd:restriction>\n       </xsd:simpleType>\n\
    \        </xsd:attribute>\n        <xsd:attribute name=\"length\" type=\"xsd:integer\"\
    \ use=\"optional\"/>\n        <xsd:attribute name=\"maxLength\" type=\"xsd:integer\"\
    \n                       use=\"optional\"/>\n      </xsd:complexType>\n      <xsd:complexType\
    \ name=\"structType\">\n        <xsd:sequence>\n          <xsd:element name=\"\
    derivedFrom\" type=\"typeRefNMTOKEN\"\n                       minOccurs=\"0\"\
    />\n          <xsd:element name=\"component\" maxOccurs=\"unbounded\">\n     \
    \       <xsd:complexType>\n              <xsd:sequence>\n                <xsd:element\
    \ name=\"name\" type=\"xsd:NMTOKEN\"/>\n                <xsd:element ref=\"synopsis\"\
    />\n                <xsd:element ref=\"description\" minOccurs=\"0\"/>\n     \
    \           <xsd:element name=\"optional\" minOccurs=\"0\"/>\n               \
    \ <xsd:group ref=\"typeDeclarationGroup\"/>\n              </xsd:sequence>\n \
    \             <xsd:attribute name=\"componentID\" use=\"required\"\n         \
    \                    type=\"xsd:unsignedInt\"/>\n            </xsd:complexType>\n\
    \            <!-- key declaration to make componentIDs unique in a struct\n  \
    \          -->\n            <xsd:key name=\"structComponentID\">\n           \
    \   <xsd:selector xpath=\"lfb:component\"/>\n              <xsd:field xpath=\"\
    @componentID\"/>\n            </xsd:key>\n          </xsd:element>\n        </xsd:sequence>\n\
    \      </xsd:complexType>\n      <xsd:complexType name=\"metadataDefsType\">\n\
    \        <xsd:sequence>\n          <xsd:element name=\"metadataDef\" maxOccurs=\"\
    unbounded\">\n            <xsd:complexType>\n              <xsd:sequence>\n  \
    \              <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n           \
    \     <xsd:element ref=\"synopsis\"/>\n                <xsd:element name=\"metadataID\"\
    \ type=\"xsd:integer\"/>\n                <xsd:element ref=\"description\" minOccurs=\"\
    0\"/>\n                <xsd:choice>\n                  <xsd:element name=\"typeRef\"\
    \ type=\"typeRefNMTOKEN\"/>\n                  <xsd:element name=\"atomic\" type=\"\
    atomicType\"/>\n                </xsd:choice>\n              </xsd:sequence>\n\
    \            </xsd:complexType>\n          </xsd:element>\n        </xsd:sequence>\n\
    \      </xsd:complexType>\n      <xsd:complexType name=\"LFBClassDefsType\">\n\
    \        <xsd:sequence>\n          <xsd:element name=\"LFBClassDef\" maxOccurs=\"\
    unbounded\">\n            <xsd:complexType>\n              <xsd:sequence>\n  \
    \              <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n           \
    \     <xsd:element ref=\"synopsis\"/>\n                <xsd:element name=\"version\"\
    \ type=\"versionType\"/>\n                <xsd:element name=\"derivedFrom\" type=\"\
    xsd:NMTOKEN\"\n                             minOccurs=\"0\"/>\n              \
    \  <xsd:element name=\"inputPorts\" type=\"inputPortsType\"\n                \
    \             minOccurs=\"0\"/>\n                <xsd:element name=\"outputPorts\"\
    \ type=\"outputPortsType\"\n                             minOccurs=\"0\"/>\n \
    \               <xsd:element name=\"components\" type=\"LFBComponentsType\"\n\
    \                             minOccurs=\"0\"/>\n                <xsd:element\
    \ name=\"capabilities\"\n                             type=\"LFBCapabilitiesType\"\
    \ minOccurs=\"0\"/>\n                <xsd:element name=\"events\"\n          \
    \                   type=\"eventsType\" minOccurs=\"0\"/>\n                <xsd:element\
    \ ref=\"description\" minOccurs=\"0\"/>\n              </xsd:sequence>\n     \
    \         <xsd:attribute name=\"LFBClassID\" use=\"required\"\n              \
    \               type=\"xsd:unsignedInt\"/>\n            </xsd:complexType>\n \
    \           <!-- Key constraint to ensure unique attribute names within\n    \
    \             a class:\n            -->\n            <xsd:key name=\"components\"\
    >\n              <xsd:selector xpath=\"lfb:components/lfb:component\"/>\n    \
    \          <xsd:field xpath=\"lfb:name\"/>\n            </xsd:key>\n         \
    \   <xsd:key name=\"capabilities\">\n              <xsd:selector xpath=\"lfb:capabilities/lfb:capability\"\
    />\n              <xsd:field xpath=\"lfb:name\"/>\n            </xsd:key>\n  \
    \          <xsd:key name=\"componentIDs\">\n              <xsd:selector xpath=\"\
    lfb:components/lfb:component\"/>\n              <xsd:field xpath=\"@componentID\"\
    />\n            </xsd:key>\n            <xsd:key name=\"capabilityIDs\">\n   \
    \           <xsd:selector xpath=\"lfb:capabilities/lfb:capability\"/>\n      \
    \        <xsd:field xpath=\"@componentID\"/>\n            </xsd:key>\n       \
    \   </xsd:element>\n        </xsd:sequence>\n      </xsd:complexType>\n    <xsd:simpleType\
    \ name=\"versionType\">\n      <xsd:restriction base=\"xsd:NMTOKEN\">\n      \
    \  <xsd:pattern value=\"[1-9][0-9]*\\.([1-9][0-9]*|0)\"/>\n      </xsd:restriction>\n\
    \    </xsd:simpleType>\n    <xsd:complexType name=\"inputPortsType\">\n      <xsd:sequence>\n\
    \        <xsd:element name=\"inputPort\" type=\"inputPortType\"\n            \
    \         maxOccurs=\"unbounded\"/>\n      </xsd:sequence>\n    </xsd:complexType>\n\
    \    <xsd:complexType name=\"inputPortType\">\n      <xsd:sequence>\n        <xsd:element\
    \ name=\"name\" type=\"xsd:NMTOKEN\"/>\n        <xsd:element ref=\"synopsis\"\
    />\n        <xsd:element name=\"expectation\" type=\"portExpectationType\"/>\n\
    \        <xsd:element ref=\"description\" minOccurs=\"0\"/>\n      </xsd:sequence>\n\
    \      <xsd:attribute name=\"group\" type=\"xsd:boolean\" use=\"optional\"\n \
    \                    default=\"0\"/>\n    </xsd:complexType>\n    <xsd:complexType\
    \ name=\"portExpectationType\">\n      <xsd:sequence>\n        <xsd:element name=\"\
    frameExpected\" minOccurs=\"0\">\n          <xsd:complexType>\n            <xsd:sequence>\n\
    \            <!-- ref must refer to a name of a defined frame type -->\n     \
    \       <xsd:element name=\"ref\" type=\"xsd:string\"\n                      \
    \     maxOccurs=\"unbounded\"/>\n            </xsd:sequence>\n          </xsd:complexType>\n\
    \        </xsd:element>\n        <xsd:element name=\"metadataExpected\" minOccurs=\"\
    0\">\n          <xsd:complexType>\n            <xsd:choice maxOccurs=\"unbounded\"\
    >\n              <!-- ref must refer to a name of a defined metadata -->\n   \
    \           <xsd:element name=\"ref\" type=\"metadataInputRefType\"/>\n      \
    \        <xsd:element name=\"one-of\"\n                           type=\"metadataInputChoiceType\"\
    />\n            </xsd:choice>\n          </xsd:complexType>\n        </xsd:element>\n\
    \      </xsd:sequence>\n    </xsd:complexType>\n    <xsd:complexType name=\"metadataInputChoiceType\"\
    >\n      <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\">\n        <!-- ref\
    \ must refer to a name of a defined metadata -->\n        <xsd:element name=\"\
    ref\" type=\"xsd:NMTOKEN\"/>\n        <xsd:element name=\"one-of\" type=\"metadataInputChoiceType\"\
    />\n        <xsd:element name=\"metadataSet\" type=\"metadataInputSetType\"/>\n\
    \      </xsd:choice>\n    </xsd:complexType>\n    <xsd:complexType name=\"metadataInputSetType\"\
    >\n      <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\">\n        <!-- ref\
    \ must refer to a name of a defined metadata -->\n        <xsd:element name=\"\
    ref\" type=\"metadataInputRefType\"/>\n        <xsd:element name=\"one-of\" type=\"\
    metadataInputChoiceType\"/>\n      </xsd:choice>\n    </xsd:complexType>\n   \
    \ <xsd:complexType name=\"metadataInputRefType\">\n      <xsd:simpleContent>\n\
    \        <xsd:extension base=\"xsd:NMTOKEN\">\n          <xsd:attribute name=\"\
    dependency\" use=\"optional\"\n                         default=\"required\">\n\
    \            <xsd:simpleType>\n              <xsd:restriction base=\"xsd:string\"\
    >\n                <xsd:enumeration value=\"required\"/>\n                <xsd:enumeration\
    \ value=\"optional\"/>\n              </xsd:restriction>\n            </xsd:simpleType>\n\
    \          </xsd:attribute>\n          <xsd:attribute name=\"defaultValue\" type=\"\
    xsd:token\"\n                         use=\"optional\"/>\n        </xsd:extension>\n\
    \      </xsd:simpleContent>\n    </xsd:complexType>\n    <xsd:complexType name=\"\
    outputPortsType\">\n      <xsd:sequence>\n        <xsd:element name=\"outputPort\"\
    \ type=\"outputPortType\"\n                     maxOccurs=\"unbounded\"/>\n  \
    \    </xsd:sequence>\n    </xsd:complexType>\n    <xsd:complexType name=\"outputPortType\"\
    >\n      <xsd:sequence>\n        <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"\
    />\n        <xsd:element ref=\"synopsis\"/>\n        <xsd:element name=\"product\"\
    \ type=\"portProductType\"/>\n        <xsd:element ref=\"description\" minOccurs=\"\
    0\"/>\n      </xsd:sequence>\n      <xsd:attribute name=\"group\" type=\"xsd:boolean\"\
    \ use=\"optional\"\n                     default=\"0\"/>\n    </xsd:complexType>\n\
    \    <xsd:complexType name=\"portProductType\">\n      <xsd:sequence>\n      \
    \  <xsd:element name=\"frameProduced\">\n         <xsd:complexType>\n        \
    \    <xsd:sequence>\n              <!-- ref must refer to a name of a defined\
    \ frame type\n                   -->\n                  <xsd:element name=\"ref\"\
    \ type=\"xsd:NMTOKEN\"\n                             maxOccurs=\"unbounded\"/>\n\
    \              </xsd:sequence>\n            </xsd:complexType>\n          </xsd:element>\n\
    \          <xsd:element name=\"metadataProduced\" minOccurs=\"0\">\n         \
    \   <xsd:complexType>\n              <xsd:choice maxOccurs=\"unbounded\">\n  \
    \              <!-- ref must refer to a name of a defined metadata\n         \
    \       -->\n                <xsd:element name=\"ref\" type=\"metadataOutputRefType\"\
    />\n                <xsd:element name=\"one-of\"\n                           \
    \  type=\"metadataOutputChoiceType\"/>\n              </xsd:choice>\n        \
    \    </xsd:complexType>\n          </xsd:element>\n        </xsd:sequence>\n \
    \     </xsd:complexType>\n      <xsd:complexType name=\"metadataOutputChoiceType\"\
    >\n        <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\">\n          <!--\
    \ ref must refer to a name of a defined metadata -->\n          <xsd:element name=\"\
    ref\" type=\"xsd:NMTOKEN\"/>\n          <xsd:element name=\"one-of\" type=\"metadataOutputChoiceType\"\
    />\n          <xsd:element name=\"metadataSet\" type=\"metadataOutputSetType\"\
    />\n        </xsd:choice>\n      </xsd:complexType>\n      <xsd:complexType name=\"\
    metadataOutputSetType\">\n        <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\"\
    >\n          <!-- ref must refer to a name of a defined metadata -->\n       \
    \   <xsd:element name=\"ref\" type=\"metadataOutputRefType\"/>\n          <xsd:element\
    \ name=\"one-of\" type=\"metadataOutputChoiceType\"/>\n        </xsd:choice>\n\
    \      </xsd:complexType>\n      <xsd:complexType name=\"metadataOutputRefType\"\
    >\n        <xsd:simpleContent>\n          <xsd:extension base=\"xsd:NMTOKEN\"\
    >\n            <xsd:attribute name=\"availability\" use=\"optional\"\n       \
    \                    default=\"unconditional\">\n              <xsd:simpleType>\n\
    \                <xsd:restriction base=\"xsd:string\">\n                  <xsd:enumeration\
    \ value=\"unconditional\"/>\n                  <xsd:enumeration value=\"conditional\"\
    />\n                </xsd:restriction>\n              </xsd:simpleType>\n    \
    \        </xsd:attribute>\n          </xsd:extension>\n        </xsd:simpleContent>\n\
    \      </xsd:complexType>\n      <xsd:complexType name=\"LFBComponentsType\">\n\
    \        <xsd:sequence>\n          <xsd:element name=\"component\" maxOccurs=\"\
    unbounded\">\n            <xsd:complexType>\n              <xsd:sequence>\n  \
    \              <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n           \
    \     <xsd:element ref=\"synopsis\"/>\n                <xsd:element ref=\"description\"\
    \ minOccurs=\"0\"/>\n                <xsd:element name=\"optional\" minOccurs=\"\
    0\"/>\n                <xsd:group ref=\"typeDeclarationGroup\"/>\n           \
    \     <xsd:element name=\"defaultValue\" type=\"xsd:token\"\n                \
    \             minOccurs=\"0\"/>\n              </xsd:sequence>\n             \
    \ <xsd:attribute name=\"access\" use=\"optional\"\n                          \
    \   default=\"read-write\">\n                <xsd:simpleType>\n              \
    \    <xsd:list itemType=\"accessModeType\"/>\n                </xsd:simpleType>\n\
    \              </xsd:attribute>\n              <xsd:attribute name=\"componentID\"\
    \ use=\"required\"\n                             type=\"xsd:unsignedInt\"/>\n\
    \            </xsd:complexType>\n          </xsd:element>\n        </xsd:sequence>\n\
    \      </xsd:complexType>\n      <xsd:simpleType name=\"accessModeType\">\n  \
    \      <xsd:restriction base=\"xsd:NMTOKEN\">\n          <xsd:enumeration value=\"\
    read-only\"/>\n          <xsd:enumeration value=\"read-write\"/>\n          <xsd:enumeration\
    \ value=\"write-only\"/>\n          <xsd:enumeration value=\"read-reset\"/>\n\
    \          <xsd:enumeration value=\"trigger-only\"/>\n        </xsd:restriction>\n\
    \      </xsd:simpleType>\n      <xsd:complexType name=\"LFBCapabilitiesType\"\
    >\n        <xsd:sequence>\n          <xsd:element name=\"capability\" maxOccurs=\"\
    unbounded\">\n            <xsd:complexType>\n              <xsd:sequence>\n  \
    \              <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n           \
    \     <xsd:element ref=\"synopsis\"/>\n                <xsd:element ref=\"description\"\
    \ minOccurs=\"0\"/>\n                <xsd:element name=\"optional\" minOccurs=\"\
    0\"/>\n                <xsd:group ref=\"typeDeclarationGroup\"/>\n           \
    \   </xsd:sequence>\n              <xsd:attribute name=\"componentID\" use=\"\
    required\"\n                             type=\"xsd:integer\"/>\n            </xsd:complexType>\n\
    \          </xsd:element>\n        </xsd:sequence>\n      </xsd:complexType>\n\
    \      <xsd:complexType name=\"eventsType\">\n        <xsd:sequence>\n       \
    \   <xsd:element name=\"event\" maxOccurs=\"unbounded\">\n            <xsd:complexType>\n\
    \              <xsd:sequence>\n                <xsd:element name=\"name\" type=\"\
    xsd:NMTOKEN\"/>\n                <xsd:element ref=\"synopsis\"/>\n           \
    \     <xsd:element name=\"eventTarget\" type=\"eventPathType\"/>\n           \
    \     <xsd:element ref=\"eventCondition\"/>\n                <xsd:element name=\"\
    eventReports\" type=\"eventReportsType\"\n                             minOccurs=\"\
    0\"/>\n                <xsd:element ref=\"description\" minOccurs=\"0\"/>\n  \
    \            </xsd:sequence>\n              <xsd:attribute name=\"eventID\" use=\"\
    required\"\n                             type=\"xsd:integer\"/>\n            </xsd:complexType>\n\
    \          </xsd:element>\n        </xsd:sequence>\n        <xsd:attribute name=\"\
    baseID\" type=\"xsd:integer\"\n                       use=\"optional\"/>\n   \
    \   </xsd:complexType>\n      <!-- the substitution group for the event conditions\
    \ -->\n      <xsd:element name=\"eventCondition\" abstract=\"true\"/>\n      <xsd:element\
    \ name=\"eventCreated\"\n                  substitutionGroup=\"eventCondition\"\
    />\n      <xsd:element name=\"eventDeleted\"\n                  substitutionGroup=\"\
    eventCondition\"/>\n      <xsd:element name=\"eventChanged\"\n               \
    \   substitutionGroup=\"eventCondition\"/>\n      <xsd:element name=\"eventGreaterThan\"\
    \n                  substitutionGroup=\"eventCondition\"/>\n      <xsd:element\
    \ name=\"eventLessThan\"\n                  substitutionGroup=\"eventCondition\"\
    />\n      <xsd:complexType name=\"eventPathType\">\n        <xsd:sequence>\n \
    \         <xsd:element ref=\"eventPathPart\" maxOccurs=\"unbounded\"/>\n     \
    \   </xsd:sequence>\n      </xsd:complexType>\n      <!-- the substitution group\
    \ for the event path parts -->\n      <xsd:element name=\"eventPathPart\" type=\"\
    xsd:string\"\n                   abstract=\"true\"/>\n      <xsd:element name=\"\
    eventField\" type=\"xsd:string\"\n                   substitutionGroup=\"eventPathPart\"\
    />\n      <xsd:element name=\"eventSubscript\" type=\"xsd:string\"\n         \
    \          substitutionGroup=\"eventPathPart\"/>\n      <xsd:complexType name=\"\
    eventReportsType\">\n        <xsd:sequence>\n          <xsd:element name=\"eventReport\"\
    \ type=\"eventPathType\"\n                       maxOccurs=\"unbounded\"/>\n \
    \       </xsd:sequence>\n      </xsd:complexType>\n      <xsd:simpleType name=\"\
    booleanType\">\n        <xsd:restriction base=\"xsd:string\">\n          <xsd:enumeration\
    \ value=\"0\"/>\n          <xsd:enumeration value=\"1\"/>\n        </xsd:restriction>\n\
    \      </xsd:simpleType>\n      </xsd:schema>\n"
- title: 5.  FE Components and Capabilities
  contents:
  - "5.  FE Components and Capabilities\n   A ForCES forwarding element handles traffic\
    \ on behalf of a ForCES\n   control element.  While the standards will describe\
    \ the protocol and\n   mechanisms for this control, different implementations\
    \ and different\n   instances will have different capabilities.  The CE MUST be\
    \ able to\n   determine what each instance it is responsible for is actually\n\
    \   capable of doing.  As stated previously, this is an approximation.\n   The\
    \ CE is expected to be prepared to cope with errors in requests and\n   variations\
    \ in detail not captured by the capabilities information\n   about an FE.\n  \
    \ In addition to its capabilities, an FE will have information that can\n   be\
    \ used in understanding and controlling the forwarding operations.\n   Some of\
    \ this information will be read-only, while others parts may\n   also be writeable.\n\
    \   In order to make the FE information easily accessible, the\n   information\
    \ is represented in an LFB.  This LFB has a class,\n   FEObject.  The LFBClassID\
    \ for this class is 1.  Only one instance of\n   this class will ever be present\
    \ in an FE, and the instance ID of that\n   instance in the protocol is 1.  Thus,\
    \ by referencing the components\n   of class:1, instance:1 a CE can get the general\
    \ information about the\n   FE.  The FEObject LFB class is described in this section.\n\
    \   There will also be an FEProtocol LFB class.  LFBClassID 2 is reserved\n  \
    \ for that class.  There will be only one instance of that class as\n   well.\
    \  Details of that class are defined in the ForCES protocol\n   [RFC5810] document.\n"
- title: 5.1.   XML for FEObject Class Definition
  contents:
  - "5.1.   XML for FEObject Class Definition\n          <?xml version=\"1.0\" encoding=\"\
    UTF-8\"?>\n          <LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\"\
    \n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      \
    \      provides=\"FEObject\">\n            <dataTypeDefs>\n              <dataTypeDef>\n\
    \                <name>LFBAdjacencyLimitType</name>\n                <synopsis>Describing\
    \ the Adjacent LFB</synopsis>\n                <struct>\n                  <component\
    \ componentID=\"1\">\n                    <name>NeighborLFB</name>\n         \
    \           <synopsis>ID for that LFB class</synopsis>\n                    <typeRef>uint32</typeRef>\n\
    \                  </component>\n                  <component componentID=\"2\"\
    >\n                    <name>ViaPorts</name>\n                    <synopsis>\n\
    \                      the ports on which we can connect\n                   \
    \ </synopsis>\n                    <array type=\"variable-size\">\n          \
    \            <typeRef>string</typeRef>\n                    </array>\n       \
    \           </component>\n                </struct>\n              </dataTypeDef>\n\
    \              <dataTypeDef>\n                <name>PortGroupLimitType</name>\n\
    \                <synopsis>\n                  Limits on the number of ports in\
    \ a given group\n                </synopsis>\n                <struct>\n     \
    \             <component componentID=\"1\">\n                    <name>PortGroupName</name>\n\
    \                    <synopsis>Group Name</synopsis>\n                    <typeRef>string</typeRef>\n\
    \                  </component>\n                  <component componentID=\"2\"\
    >\n                    <name>MinPortCount</name>\n                    <synopsis>Minimum\
    \ Port Count</synopsis>\n                    <optional/>\n                   \
    \ <typeRef>uint32</typeRef>\n                  </component>\n                \
    \  <component componentID=\"3\">\n                    <name>MaxPortCount</name>\n\
    \                    <synopsis>Max Port Count</synopsis>\n                   \
    \ <optional/>\n                    <typeRef>uint32</typeRef>\n               \
    \   </component>\n                </struct>\n              </dataTypeDef>\n  \
    \            <dataTypeDef>\n                <name>SupportedLFBType</name>\n  \
    \              <synopsis>table entry for supported LFB</synopsis>\n          \
    \      <struct>\n                  <component componentID=\"1\">\n           \
    \         <name>LFBName</name>\n                    <synopsis>\n             \
    \         The name of a supported LFB class\n                    </synopsis>\n\
    \                    <typeRef>string</typeRef>\n                  </component>\n\
    \                  <component componentID=\"2\">\n                    <name>LFBClassID</name>\n\
    \                    <synopsis>the id of a supported LFB class</synopsis>\n  \
    \                  <typeRef>uint32</typeRef>\n                  </component>\n\
    \                  <component componentID=\"3\">\n                    <name>LFBVersion</name>\n\
    \                    <synopsis>\n                      The version of the LFB\
    \ class used\n                      by this FE.\n                    </synopsis>\n\
    \                    <typeRef>string</typeRef>\n                  </component>\n\
    \                  <component componentID=\"4\">\n                    <name>LFBOccurrenceLimit</name>\n\
    \                    <synopsis>\n                      the upper limit of instances\
    \ of LFBs of this class\n                    </synopsis>\n                   \
    \ <optional/>\n                    <typeRef>uint32</typeRef>\n               \
    \   </component>\n                  <!-- For each port group, how many ports can\
    \ exist\n                  -->\n                  <component componentID=\"5\"\
    >\n                    <name>PortGroupLimits</name>\n                    <synopsis>Table\
    \ of Port Group Limits</synopsis>\n                    <optional/>\n         \
    \           <array type=\"variable-size\">\n                      <typeRef>PortGroupLimitType</typeRef>\n\
    \                    </array>\n                  </component>\n        <!-- for\
    \ the named LFB Class, the LFB Classes it may follow -->\n                  <component\
    \ componentID=\"6\">\n                    <name>CanOccurAfters</name>\n      \
    \              <synopsis>\n                      List of LFB classes that this\
    \ LFB class can follow\n                    </synopsis>\n                    <optional/>\n\
    \                    <array type=\"variable-size\">\n                      <typeRef>LFBAdjacencyLimitType</typeRef>\n\
    \                    </array>\n                  </component>\n        <!-- for\
    \ the named LFB Class, the LFB Classes that may follow it\n          -->\n   \
    \               <component componentID=\"7\">\n                    <name>CanOccurBefores</name>\n\
    \                    <synopsis>\n                      List of LFB classes that\
    \ can follow this LFB class\n                    </synopsis>\n               \
    \     <optional/>\n                    <array type=\"variable-size\">\n      \
    \                <typeRef>LFBAdjacencyLimitType</typeRef>\n                  \
    \  </array>\n                  </component>\n                  <component componentID=\"\
    8\">\n                    <name>UseableParentLFBClasses</name>\n             \
    \       <synopsis>\n                      List of LFB classes from which this\
    \ class has\n                      inherited, and which the FE is willing to allow\n\
    \                      for references to instances of this class.\n          \
    \          </synopsis>\n                    <optional/>\n                    <array\
    \ type=\"variable-size\">\n                      <typeRef>uint32</typeRef>\n \
    \                   </array>\n                  </component>\n               \
    \ </struct>\n              </dataTypeDef>\n              <dataTypeDef>\n     \
    \           <name>FEStateValues</name>\n                <synopsis>The possible\
    \ values of status</synopsis>\n                <atomic>\n                  <baseType>uchar</baseType>\n\
    \                  <specialValues>\n                    <specialValue value=\"\
    0\">\n                      <name>AdminDisable</name>\n                      <synopsis>\n\
    \                        FE is administratively disabled\n                   \
    \ </synopsis>\n                    </specialValue>\n                    <specialValue\
    \ value=\"1\">\n                      <name>OperDisable</name>\n             \
    \         <synopsis>FE is operatively disabled</synopsis>\n                  \
    \  </specialValue>\n                    <specialValue value=\"2\">\n         \
    \             <name>OperEnable</name>\n                      <synopsis>FE is operating</synopsis>\n\
    \                    </specialValue>\n                  </specialValues>\n   \
    \             </atomic>\n              </dataTypeDef>\n              <dataTypeDef>\n\
    \                <name>FEConfiguredNeighborType</name>\n                <synopsis>Details\
    \ of the FE's Neighbor</synopsis>\n                <struct>\n                \
    \  <component componentID=\"1\">\n                    <name>NeighborID</name>\n\
    \                    <synopsis>Neighbors FEID</synopsis>\n                   \
    \ <typeRef>uint32</typeRef>\n                  </component>\n                \
    \  <component componentID=\"2\">\n                    <name>InterfaceToNeighbor</name>\n\
    \                    <synopsis>\n                      FE's interface that connects\
    \ to this neighbor\n                    </synopsis>\n                    <optional/>\n\
    \                    <typeRef>string</typeRef>\n                  </component>\n\
    \                  <component componentID=\"3\">\n                    <name>NeighborInterface</name>\n\
    \                    <synopsis>\n                      The name of the interface\
    \ on the neighbor to\n                      which this FE is adjacent.  This is\
    \ required\n                      in case two FEs are adjacent on more than\n\
    \                      one interface.\n                    </synopsis>\n     \
    \               <optional/>\n                    <typeRef>string</typeRef>\n \
    \                 </component>\n                </struct>\n              </dataTypeDef>\n\
    \              <dataTypeDef>\n                <name>LFBSelectorType</name>\n \
    \               <synopsis>\n                  Unique identification of an LFB\
    \ class-instance\n                </synopsis>\n                <struct>\n    \
    \              <component componentID=\"1\">\n                    <name>LFBClassID</name>\n\
    \                    <synopsis>LFB Class Identifier</synopsis>\n             \
    \       <typeRef>uint32</typeRef>\n                  </component>\n          \
    \        <component componentID=\"2\">\n                    <name>LFBInstanceID</name>\n\
    \                    <synopsis>LFB Instance ID</synopsis>\n                  \
    \  <typeRef>uint32</typeRef>\n                  </component>\n               \
    \ </struct>\n              </dataTypeDef>\n              <dataTypeDef>\n     \
    \           <name>LFBLinkType</name>\n                <synopsis>\n           \
    \       Link between two LFB instances of topology\n                </synopsis>\n\
    \                <struct>\n                  <component componentID=\"1\">\n \
    \                   <name>FromLFBID</name>\n                    <synopsis>LFB\
    \ src</synopsis>\n                    <typeRef>LFBSelectorType</typeRef>\n   \
    \               </component>\n                  <component componentID=\"2\">\n\
    \                    <name>FromPortGroup</name>\n                    <synopsis>src\
    \ port group</synopsis>\n                    <typeRef>string</typeRef>\n     \
    \             </component>\n                  <component componentID=\"3\">\n\
    \                    <name>FromPortIndex</name>\n                    <synopsis>src\
    \ port index</synopsis>\n                    <typeRef>uint32</typeRef>\n     \
    \             </component>\n                  <component componentID=\"4\">\n\
    \                    <name>ToLFBID</name>\n                    <synopsis>dst LFBID</synopsis>\n\
    \                    <typeRef>LFBSelectorType</typeRef>\n                  </component>\n\
    \                  <component componentID=\"5\">\n                    <name>ToPortGroup</name>\n\
    \                    <synopsis>dst port group</synopsis>\n                   \
    \ <typeRef>string</typeRef>\n                  </component>\n                \
    \  <component componentID=\"6\">\n                    <name>ToPortIndex</name>\n\
    \                    <synopsis>dst port index</synopsis>\n                   \
    \ <typeRef>uint32</typeRef>\n                  </component>\n                </struct>\n\
    \              </dataTypeDef>\n            </dataTypeDefs>\n            <LFBClassDefs>\n\
    \              <LFBClassDef LFBClassID=\"1\">\n                <name>FEObject</name>\n\
    \                <synopsis>Core LFB: FE Object</synopsis>\n                <version>1.0</version>\n\
    \                <components>\n                  <component access=\"read-write\"\
    \ componentID=\"1\">\n                    <name>LFBTopology</name>\n         \
    \           <synopsis>the table of known Topologies</synopsis>\n             \
    \       <array type=\"variable-size\">\n                      <typeRef>LFBLinkType</typeRef>\n\
    \                    </array>\n                  </component>\n              \
    \    <component access=\"read-write\" componentID=\"2\">\n                   \
    \ <name>LFBSelectors</name>\n                    <synopsis>\n                \
    \       table of known active LFB classes and\n                       instances\n\
    \                    </synopsis>\n                    <array type=\"variable-size\"\
    >\n                      <typeRef>LFBSelectorType</typeRef>\n                \
    \    </array>\n                  </component>\n                  <component access=\"\
    read-write\" componentID=\"3\">\n                    <name>FEName</name>\n   \
    \                 <synopsis>name of this FE</synopsis>\n                    <typeRef>string[40]</typeRef>\n\
    \                  </component>\n                  <component access=\"read-write\"\
    \ componentID=\"4\">\n                    <name>FEID</name>\n                \
    \    <synopsis>ID of this FE</synopsis>\n                    <typeRef>uint32</typeRef>\n\
    \                  </component>\n                  <component access=\"read-only\"\
    \ componentID=\"5\">\n                    <name>FEVendor</name>\n            \
    \        <synopsis>vendor of this FE</synopsis>\n                    <typeRef>string[40]</typeRef>\n\
    \                  </component>\n                  <component access=\"read-only\"\
    \ componentID=\"6\">\n                    <name>FEModel</name>\n             \
    \       <synopsis>model of this FE</synopsis>\n                    <typeRef>string[40]</typeRef>\n\
    \                  </component>\n                  <component access=\"read-only\"\
    \ componentID=\"7\">\n                    <name>FEState</name>\n             \
    \       <synopsis>State of this FE</synopsis>\n                    <typeRef>FEStateValues</typeRef>\n\
    \                  </component>\n                  <component access=\"read-write\"\
    \ componentID=\"8\">\n                    <name>FENeighbors</name>\n         \
    \           <synopsis>table of known neighbors</synopsis>\n                  \
    \  <optional/>\n                    <array type=\"variable-size\">\n         \
    \             <typeRef>FEConfiguredNeighborType</typeRef>\n                  \
    \  </array>\n                  </component>\n                </components>\n \
    \               <capabilities>\n                  <capability componentID=\"30\"\
    >\n                    <name>ModifiableLFBTopology</name>\n                  \
    \  <synopsis>\n                      Whether Modifiable LFB is supported\n   \
    \                 </synopsis>\n                    <optional/>\n             \
    \       <typeRef>boolean</typeRef>\n                  </capability>\n        \
    \          <capability componentID=\"31\">\n                    <name>SupportedLFBs</name>\n\
    \                    <synopsis>List of all supported LFBs</synopsis>\n       \
    \             <optional/>\n                    <array type=\"variable-size\">\n\
    \                      <typeRef>SupportedLFBType</typeRef>\n                 \
    \   </array>\n                  </capability>\n                </capabilities>\n\
    \              </LFBClassDef>\n            </LFBClassDefs>\n          </LFBLibrary>\n"
- title: 5.2.  FE Capabilities
  contents:
  - "5.2.  FE Capabilities\n   The FE capability information is contained in the capabilities\n\
    \   element of the class definition.  As described elsewhere, capability\n   information\
    \ is always considered to be read-only.\n   The currently defined capabilities\
    \ are ModifiableLFBTopology and\n   SupportedLFBs.  Information as to which components\
    \ of the FEObject\n   LFB are supported is accessed by the properties information\
    \ for those\n   components.\n"
- title: 5.2.1.   ModifiableLFBTopology
  contents:
  - "5.2.1.   ModifiableLFBTopology\n   This component has a boolean value that indicates\
    \ whether the LFB\n   topology of the FE may be changed by the CE.  If the component\
    \ is\n   absent, the default value is assumed to be true, and the CE presumes\n\
    \   that the LFB topology may be changed.  If the value is present and\n   set\
    \ to false, the LFB topology of the FE is fixed.  If the topology\n   is fixed,\
    \ the SupportedLFBs element may be omitted, and the list of\n   supported LFBs\
    \ is inferred by the CE from the LFB topology\n   information.  If the list of\
    \ supported LFBs is provided when\n   ModifiableLFBTopology is false, the CanOccurBefore\
    \ and CanOccurAfter\n   information should be omitted.\n"
- title: 5.2.2.   SupportedLFBs and SupportedLFBType
  contents:
  - "5.2.2.   SupportedLFBs and SupportedLFBType\n   One capability that the FE should\
    \ include is the list of supported\n   LFB classes.  The SupportedLFBs component,\
    \ is an array that contains\n   the information about each supported LFB class.\
    \  The array structure\n   type is defined as the SupportedLFBType dataTypeDef.\n\
    \   Each entry in the SupportedLFBs array describes an LFB class that the\n  \
    \ FE supports.  In addition to indicating that the FE supports the\n   class,\
    \ FEs with modifiable LFB topology SHOULD include information\n   about how LFBs\
    \ of the specified class may be connected to other LFBs.\n   This information\
    \ SHOULD describe which LFB classes the specified LFB\n   class may succeed or\
    \ precede in the LFB topology.  The FE SHOULD\n   include information as to which\
    \ port groups may be connected to the\n   given adjacent LFB class.  If port group\
    \ information is omitted, it\n   is assumed that all port groups may be used.\
    \  This capability\n   information on the acceptable ordering and connection of\
    \ LFBs MAY be\n   omitted if the implementor concludes that the actual constraints\
    \ are\n   such that the information would be misleading for the CE.\n"
- title: 5.2.2.1.  LFBName
  contents:
  - "5.2.2.1.  LFBName\n   This component has as its value the name of the LFB class\
    \ being\n   described.\n"
- title: 5.2.2.2.  LFBClassID
  contents:
  - "5.2.2.2.  LFBClassID\n   LFBClassID is the numeric ID of the LFB class being\
    \ described.  While\n   conceptually redundant with the LFB name, both are included\
    \ for\n   clarity and to allow consistency checking.\n"
- title: 5.2.2.3.  LFBVersion
  contents:
  - "5.2.2.3.  LFBVersion\n   LFBVersion is the version string specifying the LFB\
    \ class version\n   supported by this FE.  As described above in versioning, an\
    \ FE can\n   support only a single version of a given LFB class.\n"
- title: 5.2.2.4.  LFBOccurrenceLimit
  contents:
  - "5.2.2.4.  LFBOccurrenceLimit\n   This component, if present, indicates the largest\
    \ number of instances\n   of this LFB class the FE can support.  For FEs that\
    \ do not have the\n   capability to create or destroy LFB instances, this can\
    \ either be\n   omitted or be the same as the number of LFB instances of this\
    \ class\n   contained in the LFB list attribute.\n"
- title: 5.2.2.5.  PortGroupLimits and PortGroupLimitType
  contents:
  - "5.2.2.5.  PortGroupLimits and PortGroupLimitType\n   The PortGroupLimits component\
    \ is an array of information about the\n   port groups supported by the LFB class.\
    \  The structure of the port\n   group limit information is defined by the PortGroupLimitType\n\
    \   dataTypeDef.\n   Each PortGroupLimits array entry contains information describing\
    \ a\n   single port group of the LFB class.  Each array entry contains the\n \
    \  name of the port group in the PortGroupName component, the fewest\n   number\
    \ of ports that can exist in the group in the MinPortCount\n   component, and\
    \ the largest number of ports that can exist in the\n   group in the MaxPortCount\
    \ component.\n"
- title: 5.2.2.6.  CanOccurAfters and LFBAdjacencyLimitType
  contents:
  - "5.2.2.6.  CanOccurAfters and LFBAdjacencyLimitType\n   The CanOccurAfters component\
    \ is an array that contains the list of\n   LFBs the described class can occur\
    \ after.  The array entries are\n   defined in the LFBAdjacencyLimitType dataTypeDef.\n\
    \   The array entries describe a permissible positioning of the described\n  \
    \ LFB class, referred to here as the SupportedLFB.  Specifically, each\n   array\
    \ entry names an LFB that can topologically precede that LFB\n   class.  That\
    \ is, the SupportedLFB can have an input port connected to\n   an output port\
    \ of an LFB that appears in the CanOccurAfters array.\n   The LFB class that the\
    \ SupportedLFB can follow is identified by the\n   NeighborLFB component (of the\
    \ LFBAdjacencyLimitType dataTypeDef) of\n   the CanOccurAfters array entry.  If\
    \ this neighbor can only be\n   connected to a specific set of input port groups,\
    \ then the viaPort\n   component is included.  This component is an array, with\
    \ one entry\n   for each input port group of the SupportedLFB that can be connected\n\
    \   to an output port of the NeighborLFB.\n   (For example, within a SupportedLFBs\
    \ entry, each array entry of the\n   CanOccurAfters array must have a unique NeighborLFB,\
    \ and within each\n   such array entry each viaPort must represent a distinct\
    \ and valid\n   input port group of the SupportedLFB.  The LFB class definition\n\
    \   schema does not include these uniqueness constraints.)\n"
- title: 5.2.2.7.  CanOccurBefores and LFBAdjacencyLimitType
  contents:
  - "5.2.2.7.  CanOccurBefores and LFBAdjacencyLimitType\n   The CanOccurBefores array\
    \ holds the information about which LFB\n   classes can follow the described class.\
    \  Structurally, this element\n   parallels CanOccurAfters, and uses the same\
    \ type definition for the\n   array entries.\n   The array entries list those\
    \ LFB classes that the SupportedLFB may\n   precede in the topology.  In this\
    \ component, the entries in the\n   viaPort component of the array value represent\
    \ the output port groups\n   of the SupportedLFB that may be connected to the\
    \ NeighborLFB.  As\n   with CanOccurAfters, viaPort may have multiple entries\
    \ if multiple\n   output ports may legitimately connect to the given NeighborLFB\
    \ class.\n   (And a similar set of uniqueness constraints applies to the\n   CanOccurBefore\
    \ clauses, even though an LFB may occur both in\n   CanOccurAfter and CanOccurBefore.)\n"
- title: 5.2.2.8.  UseableParentLFBClasses
  contents:
  - "5.2.2.8.  UseableParentLFBClasses\n   The UseableParentLFBClasses array, if present,\
    \ is used to hold a list\n   of parent LFB class IDs.  All the entries in the\
    \ list must be IDs of\n   classes from which the SupportedLFB class being described\
    \ has\n   inherited (either directly or through an intermediate parent.)  (If\n\
    \   an FE includes improper values in this list, improper manipulations\n   by\
    \ the CE are likely, and operational failures are likely.)  In\n   addition, the\
    \ FE, by including a given class in the last, is\n   indicating to the CE that\
    \ a given parent class may be used to\n   manipulate an instance of this supported\
    \ LFB class.\n   By allowing such substitution, the FE allows for the case where\
    \ an\n   instantiated LFB may be of a class not known to the CE, but could\n \
    \  still be manipulated.  While it is hoped that such situations are\n   rare,\
    \ it is desirable for this to be supported.  This can occur if an\n   FE locally\
    \ defines certain LFB instances, or if an earlier CE had\n   configured some LFB\
    \ instances.  It can also occur if the FE would\n   prefer to instantiate a more\
    \ recent, more specific and suitable LFB\n   class rather than a common parent.\n\
    \   In order to permit this, the FE MUST be more restrained in assigning\n   LFB\
    \ instance IDs.  Normally, instance IDs are qualified by the LFB\n   class.  However,\
    \ if two LFB classes share a parent, and if that\n   parent is listed in the UseableParentLFBClasses\
    \ for both specific LFB\n   classes, then all the instances of both (or any, if\
    \ multiple classes\n   are listing the common parent) MUST use distinct instances.\
    \  This\n   permits the FE to determine which LFB instance is intended by CE\n\
    \   manipulation operations even when a parent class is used.\n"
- title: 5.2.2.9.   LFBClassCapabilities
  contents:
  - "5.2.2.9.   LFBClassCapabilities\n   While it would be desirable to include class-capability-level\n\
    \   information, this is not included in the model.  While such\n   information\
    \ belongs in the FE Object in the supported class table,\n   the contents of that\
    \ information would be class specific.  The\n   currently expected encoding structures\
    \ for transferring information\n   between the CE and FE are such that allowing\
    \ completely unspecified\n   information would be likely to induce parse errors.\
    \  We could specify\n   that the information be encoded in an octetstring, but\
    \ then we would\n   have to define the internal format of that octet string.\n\
    \   As there also are not currently any defined LFB class-level\n   capabilities\
    \ that the FE needs to report, this information is not\n   present now, but may\
    \ be added in a future version of the FE object.\n   (This is an example of a\
    \ case where versioning, rather than\n   inheritance, would be needed, since the\
    \ FE object must have class ID\n   1 and instance ID 1 so that the protocol behavior\
    \ can start by\n   finding this object.)\n"
- title: 5.3.  FE Components
  contents:
  - "5.3.  FE Components\n   The <components> element is included if the class definition\
    \ contains\n   the definition of the components of the FE object that are not\n\
    \   considered \"capabilities\".  Some of these components are writeable\n   and\
    \ some are read-only, which is determinable by examining the\n   property information\
    \ of the components.\n"
- title: 5.3.1.  FEState
  contents:
  - "5.3.1.  FEState\n   This component carries the overall state of the FE.  The\
    \ possible\n   values are the strings AdminDisable, OperDisable, and OperEnable.\n\
    \   The starting state is OperDisable, and the transition to OperEnable\n   is\
    \ controlled by the FE.  The CE controls the transition from\n   OperEnable to/from\
    \ AdminDisable.  For details, refer to the ForCES\n   protocol document [RFC5810].\n"
- title: 5.3.2.  LFBSelectors and LFBSelectorType
  contents:
  - "5.3.2.  LFBSelectors and LFBSelectorType\n   The LFBSelectors component is an\
    \ array of information about the LFBs\n   currently accessible via ForCES in the\
    \ FE.  The structure of the LFB\n   information is defined by the LFBSelectorType\
    \ dataTypeDef.\n   Each entry in the array describes a single LFB instance in\
    \ the FE.\n   The array entry contains the numeric class ID of the class of the\
    \ LFB\n   instance and the numeric instance ID for this instance.\n"
- title: 5.3.3.  LFBTopology and LFBLinkType
  contents:
  - "5.3.3.  LFBTopology and LFBLinkType\n   The optional LFBTopology component contains\
    \ information about each\n   inter-LFB link inside the FE, where each link is\
    \ described in an\n   LFBLinkType dataTypeDef.  The LFBLinkType component contains\n\
    \   sufficient information to identify precisely the end points of a\n   link.\
    \  The FromLFBID and ToLFBID components specify the LFB instances\n   at each\
    \ end of the link, and MUST reference LFBs in the LFB instance\n   table.  The\
    \ FromPortGroup and ToPortGroup MUST identify output and\n   input port groups\
    \ defined in the LFB classes of the LFB instances\n   identified by FromLFBID\
    \ and ToLFBID.  The FromPortIndex and\n   ToPortIndex components select the entries\
    \ from the port groups that\n   this link connects.  All links are uniquely identified\
    \ by the\n   FromLFBID, FromPortGroup, and FromPortIndex fields.  Multiple links\n\
    \   may have the same ToLFBID, ToPortGroup, and ToPortIndex as this model\n  \
    \ supports fan-in of inter-LFB links but not fan-out.\n"
- title: 5.3.4.   FENeighbors and FEConfiguredNeighborType
  contents:
  - "5.3.4.   FENeighbors and FEConfiguredNeighborType\n   The FENeighbors component\
    \ is an array of information about manually\n   configured adjacencies between\
    \ this FE and other FEs.  The content of\n   the array is defined by the FEConfiguredNeighborType\
    \ dataTypeDef.\n   This array is intended to capture information that may be configured\n\
    \   on the FE and is needed by the CE, where one array entry corresponds\n   to\
    \ each configured neighbor.  Note that this array is not intended to\n   represent\
    \ the results of any discovery protocols, as those will have\n   their own LFBs.\
    \  This component is optional.\n   While there may be many ways to configure neighbors,\
    \ the FE-ID is the\n   best way for the CE to correlate entities.  And the interface\n\
    \   identifier (name string) is the best correlator.  The CE will be able\n  \
    \ to determine the IP address and media-level information about the\n   neighbor\
    \ from the neighbor directly.  Omitting that information from\n   this table avoids\
    \ the risk of incorrect double configuration.\n   Information about the intended\
    \ forms of exchange with a given\n   neighbor is not captured here; only the adjacency\
    \ information is\n   included.\n"
- title: 5.3.4.1.  NeighborID
  contents:
  - "5.3.4.1.  NeighborID\n   This is the ID in some space meaningful to the CE for\
    \ the neighbor.\n"
- title: 5.3.4.2.  InterfaceToNeighbor
  contents:
  - "5.3.4.2.  InterfaceToNeighbor\n   This identifies the interface through which\
    \ the neighbor is reached.\n"
- title: 5.3.4.3.  NeighborInterface
  contents:
  - "5.3.4.3.  NeighborInterface\n   This identifies the interface on the neighbor\
    \ through which the\n   neighbor is reached.  The interface identification is\
    \ needed when\n   either only one side of the adjacency has configuration information\n\
    \   or the two FEs are adjacent on more than one interface.\n"
- title: 6.  Satisfying the Requirements on the FE Model
  contents:
  - "6.  Satisfying the Requirements on the FE Model\n   This section describes how\
    \ the proposed FE model meets the\n   requirements outlined in Section 5 of RFC\
    \ 3654 [RFC3654].  The\n   requirements can be separated into general requirements\
    \ (Section 5,\n   5.1 - 5.4) and the specification of the minimal set of logical\n\
    \   functions that the FE model must support (Section 5.5).\n   The general requirement\
    \ on the FE model is that it be able to express\n   the logical packet processing\
    \ capability of the FE, through both a\n   capability and a state model.  In addition,\
    \ the FE model is expected\n   to allow flexible implementations and be extensible\
    \ to allow defining\n   new logical functions.\n   A major component of the proposed\
    \ FE model is the Logical Functional\n   Block (LFB) model.  Each distinct logical\
    \ function in an FE is\n   modeled as an LFB.  Operational parameters of the LFB\
    \ that must be\n   visible to the CE are conceptualized as LFB components.  These\n\
    \   components express the capability of the FE and support flexible\n   implementations\
    \ by allowing an FE to specify which optional features\n   are supported.  The\
    \ components also indicate whether they are\n   configurable by the CE for an\
    \ LFB class.  Configurable components\n   provide the CE some flexibility in specifying\
    \ the behavior of an LFB.\n   When multiple LFBs belonging to the same LFB class\
    \ are instantiated\n   on an FE, each of those LFBs could be configured with different\n\
    \   component settings.  By querying the settings of the components for\n   an\
    \ instantiated LFB, the CE can determine the state of that LFB.\n   Instantiated\
    \ LFBs are interconnected in a directed graph that\n   describes the ordering\
    \ of the functions within an FE.  This directed\n   graph is described by the\
    \ topology model.  The combination of the\n   components of the instantiated LFBs\
    \ and the topology describe the\n   packet processing functions available on the\
    \ FE (current state).\n   Another key component of the FE model is the FE components.\
    \  The FE\n   components are used mainly to describe the capabilities of the FE,\n\
    \   but they also convey information about the FE state.\n   The FE model includes\
    \ only the definition of the FE Object LFB\n   itself.  Meeting the full set of\
    \ working group requirements requires\n   other LFBs.  The class definitions for\
    \ those LFBs will be provided in\n   other documents.\n"
- title: 7.  Using the FE Model in the ForCES Protocol
  contents:
  - "7.  Using the FE Model in the ForCES Protocol\n   The actual model of the forwarding\
    \ plane in a given NE is something\n   the CE must learn and control by communicating\
    \ with the FEs (or by\n   other means).  Most of this communication will happen\
    \ in the post-\n   association phase using the ForCES protocol.  The following\
    \ types of\n   information must be exchanged between CEs and FEs via the ForCES\n\
    \   protocol [RFC5810]:\n   1.  FE topology query,\n   2.  FE capability declaration,\n\
    \   3.  LFB topology (per FE) and configuration capabilities query,\n   4.  LFB\
    \ capability declaration,\n   5.  State query of LFB components,\n   6.  Manipulation\
    \ of LFB components, and\n   7.  LFB topology reconfiguration.\n   Items 1 through\
    \ 5 are query exchanges, where the main flow of\n   information is from the FEs\
    \ to the CEs.  Items 1 through 4 are\n   typically queried by the CE(s) in the\
    \ beginning of the post-\n   association (PA) phase, though they may be repeatedly\
    \ queried at any\n   time in the PA phase.  Item 5 (state query) will be used\
    \ at the\n   beginning of the PA phase, and often frequently during the PA phase\n\
    \   (especially for the query of statistical counters).\n   Items 6 and 7 are\
    \ \"command\" types of exchanges, where the main flow\n   of information is from\
    \ the CEs to the FEs.  Messages in Item 6 (the\n   LFB re-configuration commands)\
    \ are expected to be used frequently.\n   Item 7 (LFB topology re-configuration)\
    \ is needed only if dynamic LFB\n   topologies are supported by the FEs and it\
    \ is expected to be used\n   infrequently.\n   The inter-FE topology (Item 1 above)\
    \ can be determined by the CE in\n   many ways.  Neither this document nor the\
    \ ForCES protocol [RFC5810]\n   document mandates a specific mechanism.  The LFB\
    \ class definition\n   does include the capability for an FE to be configured\
    \ with, and to\n   provide to the CE in response to a query, the identity of its\n\
    \   neighbors.  There may also be defined specific LFB classes and\n   protocols\
    \ for neighbor discovery.  Routing protocols may be used by\n   the CE for adjacency\
    \ determination.  The CE may be configured with\n   the relevant information.\n\
    \   The relationship between the FE model and the seven post-association\n   messages\
    \ is visualized in Figure 12:\n                                              \
    \            +--------+\n                                             ..........-->|\
    \   CE   |\n                        /----\\               .            +--------+\n\
    \                        \\____/ FE Model      .              ^    |\n       \
    \                 |    |................        (1),2 |    | 6, 7\n          \
    \              |    |  (off-line)   .      3, 4, 5 |    |\n                  \
    \      \\____/               .              |    v\n                         \
    \                    .            +--------+\n                      e.g., RFCs\
    \              ..........-->|   FE   |\n                                     \
    \                     +--------+\n   Figure 12: Relationship between the FE model\
    \ and the ForCES protocol\n     messages, where (1) is part of the ForCES base\
    \ protocol, and the\n                     rest are defined by the FE model.\n\
    \   The actual encoding of these messages is defined by the ForCES\n   protocol\
    \ [RFC5810] document and is beyond the scope of the FE model.\n   Their discussion\
    \ is nevertheless important here for the following\n   reasons:\n   o  These PA\
    \ model components have considerable impact on the FE\n      model.  For example,\
    \ some of the above information can be\n      represented as components of the\
    \ LFBs, in which case such\n      components must be defined in the LFB classes.\n\
    \   o  The understanding of the type of information that must be\n      exchanged\
    \ between the FEs and CEs can help to select the\n      appropriate protocol format\
    \ and the actual encoding method (such\n      as XML, TLVs).\n   o  Understanding\
    \ the frequency of these types of messages should\n      influence the selection\
    \ of the protocol format (efficiency\n      considerations).\n   The remaining\
    \ sub-sections of this section address each of the seven\n   message types.\n"
- title: 7.1.  FE Topology Query
  contents:
  - "7.1.  FE Topology Query\n   An FE may contain zero, one, or more external ingress\
    \ ports.\n   Similarly, an FE may contain zero, one, or more external egress\n\
    \   ports.  In other words, not every FE has to contain any external\n   ingress\
    \ or egress interfaces.  For example, Figure 13 shows two\n   cascading FEs. \
    \ FE #1 contains one external ingress interface but no\n   external egress interface,\
    \ while FE #2 contains one external egress\n   interface but no ingress interface.\
    \  It is possible to connect these\n   two FEs together via their internal interfaces\
    \ to achieve the\n   complete ingress-to-egress packet processing function.  This\
    \ provides\n   the flexibility to spread the functions across multiple FEs and\n\
    \   interconnect them together later for certain applications.\n   While the inter-FE\
    \ communication protocol is out of scope for ForCES,\n   it is up to the CE to\
    \ query and understand how multiple FEs are\n   inter-connected to perform a complete\
    \ ingress-egress packet\n   processing function, such as the one described in\
    \ Figure 13.  The\n   inter-FE topology information may be provided by FEs, may\
    \ be hard-\n   coded into CE, or may be provided by some other entity (e.g., a\
    \ bus\n   manager) independent of the FEs.  So while the ForCES protocol\n   [RFC5810]\
    \ supports FE topology query from FEs, it is optional for the\n   CE to use it,\
    \ assuming that the CE has other means to gather such\n   topology information.\n\
    \            +-----------------------------------------------------+\n       \
    \     |  +---------+   +------------+   +---------+         |\n          input|\
    \         |   |            |   |         | output  |\n         ---+->| Ingress\
    \ |-->|Header      |-->|IPv4     |---------+--->+\n            |  | port    |\
    \   |Decompressor|   |Forwarder| FE      |    |\n            |  +---------+  \
    \ +------------+   +---------+ #1      |    |\n            +-----------------------------------------------------+\
    \    V\n                                                                     \
    \  |\n                 +-----------------------<-----------------------------+\n\
    \                 |\n                 |    +----------------------------------------+\n\
    \                 V    |  +------------+   +----------+         |\n          \
    \       | input |            |   |          | output  |\n                 +->--+->|Header\
    \      |-->| Egress   |---------+-->\n                      |  |Compressor  |\
    \   | port     | FE      |\n                      |  +------------+   +----------+\
    \ #2      |\n                      +----------------------------------------+\n\
    \           Figure 13: An example of two FEs connected together.\n   Once the\
    \ inter-FE topology is discovered by the CE after this query,\n   it is assumed\
    \ that the inter-FE topology remains static.  However, it\n   is possible that\
    \ an FE may go down during the NE operation, or a\n   board may be inserted and\
    \ a new FE activated, so the inter-FE\n   topology will be affected.  It is up\
    \ to the ForCES protocol to\n   provide a mechanism for the CE to detect such\
    \ events and deal with\n   the change in FE topology.  FE topology is outside\
    \ the scope of the\n   FE model.\n"
- title: 7.2.  FE Capability Declarations
  contents:
  - "7.2.  FE Capability Declarations\n   FEs will have many types of limitations.\
    \  Some of the limitations\n   must be expressed to the CEs as part of the capability\
    \ model.  The\n   CEs must be able to query these capabilities on a per-FE basis.\n\
    \   Examples are the following:\n   o  Metadata passing capabilities of the FE.\
    \  Understanding these\n      capabilities will help the CE to evaluate the feasibility\
    \ of LFB\n      topologies, and hence to determine the availability of certain\n\
    \      services.\n   o  Global resource query limitations (applicable to all LFBs\
    \ of the\n      FE).\n   o  LFB supported by the FE.\n   o  LFB class instantiation\
    \ limit.\n   o  LFB topological limitations (linkage constraint, ordering, etc.).\n"
- title: 7.3.  LFB Topology and Topology Configurability Query
  contents:
  - "7.3.  LFB Topology and Topology Configurability Query\n   The ForCES protocol\
    \ must provide the means for the CEs to discover\n   the current set of LFB instances\
    \ in an FE and the interconnections\n   between the LFBs within the FE.  In addition,\
    \ sufficient information\n   should be available to determine whether the FE supports\
    \ any CE-\n   initiated (dynamic) changes to the LFB topology, and if so, determine\n\
    \   the allowed topologies.  Topology configurability can also be\n   considered\
    \ as part of the FE capability query as described in Section\n   7.2.\n"
- title: 7.4.  LFB Capability Declarations
  contents:
  - "7.4.  LFB Capability Declarations\n   LFB class specifications define a generic\
    \ set of capabilities.  When\n   an LFB instance is implemented (instantiated)\
    \ on a vendor's FE, some\n   additional limitations may be introduced.  Note that\
    \ we discuss only\n   those limitations that are within the flexibility of the\
    \ LFB class\n   specification.  That is, the LFB instance will remain compliant\
    \ with\n   the LFB class specification despite these limitations.  For example,\n\
    \   certain features of an LFB class may be optional, in which case it\n   must\
    \ be possible for the CE to determine whether or not an optional\n   feature is\
    \ supported by a given LFB instance.  Also, the LFB class\n   definitions will\
    \ probably contain very few quantitative limits (e.g.,\n   size of tables), since\
    \ these limits are typically imposed by the\n   implementation.  Therefore, quantitative\
    \ limitations should always be\n   expressed by capability arguments.\n   LFB\
    \ instances in the model of a particular FE implementation will\n   possess limitations\
    \ on the capabilities defined in the corresponding\n   LFB class.  The LFB class\
    \ specifications must define a set of\n   capability arguments, and the CE must\
    \ be able to query the actual\n   capabilities of the LFB instance via querying\
    \ the value of such\n   arguments.  The capability query will typically happen\
    \ when the LFB\n   is first detected by the CE.  Capabilities need not be re-queried\
    \ in\n   case of static limitations.  In some cases, however, some\n   capabilities\
    \ may change in time (e.g., as a result of adding/removing\n   other LFBs, or\
    \ configuring certain components of some other LFB when\n   the LFBs share physical\
    \ resources), in which case additional\n   mechanisms must be implemented to inform\
    \ the CE about the changes.\n   The following two broad types of limitations will\
    \ exist:\n   o  Qualitative restrictions.  For example, a standardized multi-\n\
    \      field classifier LFB class may define a large number of\n      classification\
    \ fields, but a given FE may support only a subset of\n      those fields.\n \
    \  o  Quantitative restrictions, such as the maximum size of tables,\n      etc.\n\
    \   The capability parameters that can be queried on a given LFB class\n   will\
    \ be part of the LFB class specification.  The capability\n   parameters should\
    \ be regarded as special components of the LFB.  The\n   actual values of these\
    \ components may, therefore, be obtained using\n   the same component query mechanisms\
    \ as used for other LFB components.\n   Capability components are read-only arguments.\
    \  In cases where some\n   implementations may allow CE modification of the value,\
    \ the\n   information must be represented as an operational component, not a\n\
    \   capability component.\n   Assuming that capabilities will not change frequently,\
    \ the efficiency\n   of the protocol/schema/encoding is of secondary concern.\n\
    \   Much of this restrictive information is captured by the component\n   property\
    \ information, and so can be accessed uniformly for all\n   information within\
    \ the model.\n"
- title: 7.5.  State Query of LFB Components
  contents:
  - "7.5.  State Query of LFB Components\n   This feature must be provided by all\
    \ FEs.  The ForCES protocol and\n   the data schema/encoding conveyed by the protocol\
    \ must together\n   satisfy the following requirements to facilitate state query\
    \ of the\n   LFB components:\n   o  Must permit FE selection.  This is primarily\
    \ to refer to a single\n      FE, but referring to a group of (or all) FEs may\
    \ optionally be\n      supported.\n   o  Must permit LFB instance selection. \
    \ This is primarily to refer to\n      a single LFB instance of an FE, but optionally\
    \ addressing of a\n      group of (or all) LFBs may be supported.\n   o  Must\
    \ support addressing of individual components of an LFB.\n   o  Must provide efficient\
    \ encoding and decoding of the addressing\n      info and the configured data.\n\
    \   o  Must provide efficient data transmission of the component state\n     \
    \ over the wire (to minimize communication load on the CE-FE link).\n"
- title: 7.6.   LFB Component Manipulation
  contents:
  - "7.6.   LFB Component Manipulation\n   The FE model provides for the definition\
    \ of LFB classes.  Each class\n   has a globally unique identifier.  Information\
    \ within the class is\n   represented as components and assigned identifiers within\
    \ the scope\n   of that class.  This model also specifies that instances of LFB\n\
    \   classes have identifiers.  The combination of class identifiers,\n   instance\
    \ identifiers, and component identifiers is used by the\n   protocol to reference\
    \ the LFB information in the protocol operations.\n"
- title: 7.7.  LFB Topology Reconfiguration
  contents:
  - "7.7.  LFB Topology Reconfiguration\n   Operations that will be needed to reconfigure\
    \ LFB topology are as\n   follows:\n   o  Create a new instance of a given LFB\
    \ class on a given FE.\n   o  Connect a given output of LFB x to the given input\
    \ of LFB y.\n   o  Disconnect: remove a link between a given output of an LFB\
    \ and a\n      given input of another LFB.\n   o  Delete a given LFB (automatically\
    \ removing all interconnects to/\n      from the LFB).\n"
- title: 8.  Example LFB Definition
  contents:
  - "8.  Example LFB Definition\n   This section contains an example LFB definition.\
    \  While some\n   properties of LFBs are shown by the FE Object LFB, this endeavors\
    \ to\n   show how a data plane LFB might be build.  This example is a\n   fictional\
    \ case of an interface supporting a coarse WDM optical\n   interface that carries\
    \ frame relay traffic.  The statistical\n   information (including error statistics)\
    \ is omitted.\n   Later portions of this example include references to protocol\n\
    \   operations.  The operations described are operations the protocol\n   needs\
    \ to support.  The exact format and fields are purely\n   informational here,\
    \ as the ForCES protocol [RFC5810] document defines\n   the precise syntax and\
    \ semantics of its operations.\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\
    \        <LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\"\n  \
    \       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         provides=\"\
    LaserFrameLFB\">\n          <frameDefs>\n            <frameDef>\n            \
    \  <name>FRFrame</name>\n              <synopsis>\n                  A frame relay\
    \ frame, with DLCI without\n                  stuffing)\n              </synopsis>\n\
    \            </frameDef>\n            <frameDef>\n              <name>IPFrame</name>\n\
    \               <synopsis>An IP Packet</synopsis>\n            </frameDef>\n \
    \         </frameDefs>\n          <dataTypeDefs>\n            <dataTypeDef>\n\
    \              <name>frequencyInformationType</name>\n              <synopsis>\n\
    \                  Information about a single CWDM frequency\n              </synopsis>\n\
    \              <struct>\n                <component componentID=\"1\">\n     \
    \             <name>LaserFrequency</name>\n                  <synopsis>encoded\
    \ frequency(channel)</synopsis>\n                  <typeRef>uint32</typeRef>\n\
    \                </component>\n                <component componentID=\"2\">\n\
    \                  <name>FrequencyState</name>\n                  <synopsis>state\
    \ of this frequency</synopsis>\n                  <typeRef>PortStatusValues</typeRef>\n\
    \                </component>\n                <component componentID=\"3\">\n\
    \                  <name>LaserPower</name>\n                  <synopsis>current\
    \ observed power</synopsis>\n                  <typeRef>uint32</typeRef>\n   \
    \             </component>\n                <component componentID=\"4\">\n  \
    \                <name>FrameRelayCircuits</name>\n                  <synopsis>\n\
    \                      Information about circuits on this Frequency\n        \
    \          </synopsis>\n                  <array>\n                    <typeRef>frameCircuitsType</typeRef>\n\
    \                  </array>\n                </component>\n              </struct>\n\
    \            </dataTypeDef>\n            <dataTypeDef>\n              <name>frameCircuitsType</name>\n\
    \              <synopsis>\n                  Information about a single Frame\
    \ Relay Circuit\n              </synopsis>\n              <struct>\n         \
    \       <component componentID=\"1\">\n                  <name>DLCI</name>\n \
    \                 <synopsis>DLCI of the circuit</synopsis>\n                 \
    \ <typeRef>uint32</typeRef>\n                </component>\n                <component\
    \ componentID=\"2\">\n                  <name>CircuitStatus</name>\n         \
    \         <synopsis>state of the circuit</synopsis>\n                  <typeRef>PortStatusValues</typeRef>\n\
    \                </component>\n                <component componentID=\"3\">\n\
    \                  <name>isLMI</name>\n                  <synopsis>is this the\
    \ LMI circuit</synopsis>\n                  <typeRef>boolean</typeRef>\n     \
    \           </component>\n                <component componentID=\"4\">\n    \
    \              <name>associatedPort</name>\n                  <synopsis>\n   \
    \                   which input / output port is associated\n                \
    \      with this circuit\n                  </synopsis>\n                  <typeRef>uint32</typeRef>\n\
    \                </component>\n              </struct>\n            </dataTypeDef>\n\
    \            <dataTypeDef>\n              <name>PortStatusValues</name>\n    \
    \          <synopsis>\n                  The possible values of status.  Used\
    \ for both\n                  administrative and operational status\n        \
    \      </synopsis>\n              <atomic>\n                <baseType>uchar</baseType>\n\
    \                <specialValues>\n                  <specialValue value=\"0\"\
    >\n                    <name>Disabled </name>\n                    <synopsis>the\
    \ component is disabled</synopsis>\n                  </specialValue>\n      \
    \            <specialValue value=\"1\">\n                    <name>Enabled</name>\n\
    \                    <synopsis>FE is operatively enabled</synopsis>\n        \
    \          </specialValue>\n                </specialValues>\n              </atomic>\n\
    \            </dataTypeDef>\n          </dataTypeDefs>\n          <metadataDefs>\n\
    \            <metadataDef>\n              <name>DLCI</name>\n              <synopsis>The\
    \ DLCI the frame arrived on</synopsis>\n              <metadataID>12</metadataID>\n\
    \              <typeRef>uint32</typeRef>\n            </metadataDef>\n       \
    \     <metadataDef>\n              <name>LaserChannel</name>\n              <synopsis>The\
    \ index of the laser channel</synopsis>\n              <metadataID>34</metadataID>\n\
    \              <typeRef>uint32</typeRef>\n            </metadataDef>\n       \
    \   </metadataDefs>\n          <LFBClassDefs>\n              <!-- dummy classid,\
    \ but needs to be a valid value -->\n            <LFBClassDef LFBClassID=\"255\"\
    >\n              <name>FrameLaserLFB</name>\n              <synopsis>Fictional\
    \ LFB for Demonstrations</synopsis>\n              <version>1.0</version>\n  \
    \            <inputPorts>\n                <inputPort group=\"true\">\n      \
    \            <name>LMIfromFE</name>\n                  <synopsis>\n          \
    \            Ports for LMI traffic, for transmission\n                  </synopsis>\n\
    \                  <expectation>\n                    <frameExpected>\n      \
    \                <ref>FRFrame</ref>\n                    </frameExpected>\n  \
    \                  <metadataExpected>\n                      <ref>DLCI</ref>\n\
    \                      <ref>LaserChannel</ref>\n                    </metadataExpected>\n\
    \                  </expectation>\n                </inputPort>\n            \
    \    <inputPort>\n                  <name>DatafromFE</name>\n                \
    \  <synopsis>\n                      Ports for data to be sent on circuits\n \
    \                 </synopsis>\n                  <expectation>\n             \
    \       <frameExpected>\n                      <ref>IPFrame</ref>\n          \
    \          </frameExpected>\n                    <metadataExpected>\n        \
    \              <ref>DLCI</ref>\n                      <ref>LaserChannel</ref>\n\
    \                    </metadataExpected>\n                  </expectation>\n \
    \               </inputPort>\n              </inputPorts>\n              <outputPorts>\n\
    \                <outputPort group=\"true\">\n                  <name>LMItoFE</name>\n\
    \                  <synopsis>\n                      Ports for LMI traffic for\
    \ processing\n                  </synopsis>\n                  <product>\n   \
    \                 <frameProduced>\n                      <ref>FRFrame</ref>\n\
    \                    </frameProduced>\n                    <metadataProduced>\n\
    \                      <ref>DLCI</ref>\n                      <ref>LaserChannel</ref>\n\
    \                    </metadataProduced>\n                  </product>\n     \
    \           </outputPort>\n                <outputPort group=\"true\">\n     \
    \             <name>DatatoFE</name>\n                  <synopsis>\n          \
    \            Ports for Data traffic for processing\n                  </synopsis>\n\
    \                  <product>\n                    <frameProduced>\n          \
    \            <ref>IPFrame</ref>\n                    </frameProduced>\n      \
    \              <metadataProduced>\n                      <ref>DLCI</ref>\n   \
    \                   <ref>LaserChannel</ref>\n                    </metadataProduced>\n\
    \                  </product>\n                </outputPort>\n              </outputPorts>\n\
    \              <components>\n                <component access=\"read-write\"\
    \ componentID=\"1\">\n                  <name>AdminPortState</name>\n        \
    \          <synopsis>is this port allowed to function</synopsis>\n           \
    \       <typeRef>PortStatusValues</typeRef>\n                </component>\n  \
    \              <component access=\"read-write\" componentID=\"2\">\n         \
    \         <name>FrequencyInformation</name>\n                  <synopsis>\n  \
    \                    table of information per CWDM frequency\n               \
    \   </synopsis>\n                  <array type=\"variable-size\">\n          \
    \          <typeRef>frequencyInformationType</typeRef>\n                  </array>\n\
    \                </component>\n              </components>\n              <capabilities>\n\
    \                <capability componentID=\"31\">\n                  <name>OperationalState</name>\n\
    \                  <synopsis>\n                      whether the port over all\
    \ is operational\n                  </synopsis>\n                  <typeRef>PortStatusValues</typeRef>\n\
    \                </capability>\n                <capability componentID=\"32\"\
    >\n                  <name>MaximumFrequencies</name>\n                  <synopsis>\n\
    \                      how many laser frequencies are there\n                \
    \  </synopsis>\n                  <typeRef>uint16</typeRef>\n                </capability>\n\
    \                <capability componentID=\"33\">\n                  <name>MaxTotalCircuits</name>\n\
    \                  <synopsis>\n                      Total supportable Frame Relay\
    \ Circuits, across\n                      all laser frequencies\n            \
    \      </synopsis>\n                  <optional/>\n                  <typeRef>uint32</typeRef>\n\
    \                </capability>\n              </capabilities>\n              <events\
    \ baseID=\"61\">\n                <event eventID=\"1\">\n                  <name>FrequencyState</name>\n\
    \                  <synopsis>\n                      The state of a frequency\
    \ has changed\n                  </synopsis>\n                  <eventTarget>\n\
    \                    <eventField>FrequencyInformation</eventField>\n         \
    \           <eventSubscript>_FrequencyIndex_</eventSubscript>\n              \
    \      <eventField>FrequencyState</eventField>\n                  </eventTarget>\n\
    \                  <eventChanged/>\n                  <eventReports>\n       \
    \               <!-- report the new state -->\n                    <eventReport>\n\
    \                      <eventField>FrequencyInformation</eventField>\n       \
    \               <eventSubscript>_FrequencyIndex_</eventSubscript>\n          \
    \            <eventField>FrequencyState</eventField>\n                    </eventReport>\n\
    \                  </eventReports>\n                </event>\n               \
    \ <event eventID=\"2\">\n                  <name>CreatedFrequency</name>\n   \
    \               <synopsis>A new frequency has appeared</synopsis>\n          \
    \        <eventTarget>\n                    <eventField>FrequencyInformation></eventField>\n\
    \                    <eventSubscript>_FrequencyIndex_</eventSubscript>\n     \
    \             </eventTarget>\n                  <eventCreated/>\n            \
    \      <eventReports>\n                    <eventReport>\n                   \
    \   <eventField>FrequencyInformation</eventField>\n                      <eventSubscript>_FrequencyIndex_</eventSubscript>\n\
    \                      <eventField>LaserFrequency</eventField>\n             \
    \       </eventReport>\n                  </eventReports>\n                </event>\n\
    \                <event eventID=\"3\">\n                  <name>DeletedFrequency</name>\n\
    \                  <synopsis>\n                      A frequency Table entry has\
    \ been deleted\n                  </synopsis>\n                  <eventTarget>\n\
    \                    <eventField>FrequencyInformation</eventField>\n         \
    \           <eventSubscript>_FrequencyIndex_</eventSubscript>\n              \
    \    </eventTarget>\n                  <eventDeleted/>\n                 </event>\n\
    \                <event eventID=\"4\">\n                  <name>PowerProblem</name>\n\
    \                  <synopsis>\n                      there are problems with the\
    \ laser power level\n                  </synopsis>\n                  <eventTarget>\n\
    \                    <eventField>FrequencyInformation</eventField>\n         \
    \           <eventSubscript>_FrequencyIndex_</eventSubscript>\n              \
    \      <eventField>LaserPower</eventField>\n                  </eventTarget>\n\
    \                  <eventLessThan/>\n                  <eventReports>\n      \
    \              <eventReport>\n                      <eventField>FrequencyInformation</eventField>\n\
    \                      <eventSubscript>_FrequencyIndex_</eventSubscript>\n   \
    \                   <eventField>LaserPower</eventField>\n                    </eventReport>\n\
    \                    <eventReport>\n                      <eventField>FrequencyInformation</eventField>\n\
    \                      <eventSubscript>_FrequencyIndex_</eventSubscript>\n   \
    \                   <eventField>LaserFrequency</eventField>\n                \
    \    </eventReport>\n                  </eventReports>\n                </event>\n\
    \                <event eventID=\"5\">\n                  <name>FrameCircuitChanged</name>\n\
    \                  <synopsis>\n                      the state of an Fr circuit\
    \ on a frequency\n                      has changed\n                  </synopsis>\n\
    \                  <eventTarget>\n                    <eventField>FrequencyInformation</eventField>\n\
    \                    <eventSubscript>_FrequencyIndex_</eventSubscript>\n     \
    \               <eventField>FrameRelayCircuits</eventField>\n                \
    \    <eventSubscript>FrameCircuitIndex</eventSubscript>\n                    <eventField>CircuitStatus</eventField>\n\
    \                  </eventTarget>\n                  <eventChanged/>\n       \
    \           <eventReports>\n                    <eventReport>\n              \
    \        <eventField>FrequencyInformation</eventField>\n                     \
    \ <eventSubscript>_FrequencyIndex_</eventSubscript>\n                      <eventField>FrameRelayCircuits</eventField>\n\
    \                      <eventSubscript>FrameCircuitIndex</eventSubscript>\n  \
    \                    <eventField>CircuitStatus</eventField>\n                \
    \    </eventReport>\n                    <eventReport>\n                     \
    \ <eventField>FrequencyInformation</eventField>\n                      <eventSubscript>_FrequencyIndex_</eventSubscript>\n\
    \                      <eventField>FrameRelayCircuits</eventField>\n         \
    \             <eventSubscript>FrameCircuitIndex</eventSubscript>\n           \
    \           <eventField>DLCI</eventField>\n                    </eventReport>\n\
    \                  </eventReports>\n                </event>\n              </events>\n\
    \            </LFBClassDef>\n          </LFBClassDefs>\n        </LFBLibrary>\n"
- title: 8.1.  Data Handling
  contents:
  - "8.1.  Data Handling\n   This LFB is designed to handle data packets coming in\
    \ from or going\n   out to the external world.  It is not a full port, and it\
    \ lacks many\n   useful statistics, but it serves to show many of the relevant\n\
    \   behaviors.  The following paragraphs describe a potential operational\n  \
    \ device and how it might use this LFB definition.\n   Packets arriving without\
    \ error from the physical interface come in on\n   a frame relay DLCI on a laser\
    \ channel.  These two values are used by\n   the LFB to look up the handling for\
    \ the packet.  If the handling\n   indicates that the packet is LMI, then the\
    \ output index is used to\n   select an LFB port from the LMItoFE port group.\
    \  The packet is sent\n   as a full frame relay frame (without any bit or byte\
    \ stuffing) on the\n   selected port.  The laser channel and DLCI are sent as\
    \ metadata, even\n   though the DLCI is also still in the packet.\n   Good packets\
    \ that arrive and are not LMI and have a frame relay type\n   indicator of IP\
    \ are sent as IP packets on the port in the DatatoFE\n   port group, using the\
    \ same index field from the table based on the\n   laser channel and DLCI.  The\
    \ channel and DLCI are attached as\n   metadata for other use (classifiers, for\
    \ example).\n   The current definition does not specify what to do if the frame\
    \ relay\n   type information is not IP.\n   Packets arriving on input ports arrive\
    \ with the laser channel and\n   frame relay DLCI as metadata.  As such, a single\
    \ input port could\n   have been used.  With the structure that is defined (which\
    \ parallels\n   the output structure), the selection of channel and DLCI could\
    \ be\n   restricted by the arriving input port group (LMI vs. data) and port\n\
    \   index.  As an alternative LFB design, the structures could require a\n   1-1\
    \ relationship between DLCI and the LFB port, in which case no\n   metadata would\
    \ be needed.  This would however be quite complex and\n   noisy.  The intermediate\
    \ level of structure here allows parallelism\n   between input and output, without\
    \ requiring excessive ports.\n"
- title: 8.1.1.  Setting Up a DLCI
  contents:
  - "8.1.1.  Setting Up a DLCI\n   When a CE chooses to establish a DLCI on a specific\
    \ laser channel, it\n   sends a SET request directed to this LFB.  The request\
    \ might look\n   like\n      T = SET\n        T = PATH-DATA\n          Path: flags\
    \ = none, length = 4, path = 2, channel, 4, entryIdx\n          DataRaw: DLCI,\
    \ Enabled(1), false, out-idx\n   which would establish the DLCI as enabled, with\
    \ traffic going to a\n   specific entry of the output port group DatatoFE.  (The\
    \ CE would\n   ensure that the output port is connected to the right place before\n\
    \   issuing this request.)\n   The response would confirm the creation of the\
    \ specified entry.  This\n   table is structured to use separate internal indices\
    \ and DLCIs.  An\n   alternative design could have used the DLCI as index, trading\
    \ off\n   complexities.\n   One could also imagine that the FE has an LMI LFB.\
    \  Such an LFB would\n   be connected to the LMItoFE and LMIfromFE port groups.\
    \  It would\n   process LMI information.  It might be the LFB's job to set up\
    \ the\n   frame relay circuits.  The LMI LFB would have an alias entry that\n\
    \   points to the frame relay circuits table it manages, so that it can\n   manipulate\
    \ those entities.\n"
- title: 8.1.2.  Error Handling
  contents:
  - "8.1.2.  Error Handling\n   The LFB will receive invalid packets over the wire.\
    \  Many of these\n   will simply result in incrementing counters.  The LFB designer\
    \ might\n   also specify some error rate measures.  This puts more work on the\n\
    \   FE, but allows for more meaningful alarms.\n   There may be some error conditions\
    \ that should cause parts of the\n   packet to be sent to the CE.  The error itself\
    \ is not something that\n   can cause an event in the LFB.  There are two ways\
    \ this can be\n   handled.\n   One way is to define a specific component to count\
    \ the error, and a\n   component in the LFB to hold the required portion of the\
    \ packet.  The\n   component could be defined to hold the portion of the packet\
    \ from the\n   most recent error.  One could then define an event that occurs\n\
    \   whenever the error count changes, and declare that reporting the\n   event\
    \ includes the LFB field with the packet portion.  For rare but\n   extremely\
    \ critical errors, this is an effective solution.  It ensures\n   reliable delivery\
    \ of the notification.  And it allows the CE to\n   control if it wants the notification.\n\
    \   Another approach is for the LFB to have a port that connects to a\n   redirect\
    \ sink.  The LFB would attach the laser channel, the DLCI, and\n   the error indication\
    \ as metadata, and ship the packet to the CE.\n   Other aspects of error handling\
    \ are discussed under events below.\n"
- title: 8.2.  LFB Components
  contents:
  - "8.2.  LFB Components\n   This LFB is defined to have two top-level components.\
    \  One reflects\n   the administrative state of the LFB.  This allows the CE to\
    \ disable\n   the LFB completely.\n   The other component is the table of information\
    \ about the laser\n   channels.  It is a variable-sized array.  Each array entry\
    \ contains\n   an identifier for what laser frequency this entry is associated\
    \ with,\n   whether that frequency is operational, the power of the laser at that\n\
    \   frequency, and a table of information about frame relay circuits on\n   this\
    \ frequency.  There is no administrative status since a CE can\n   disable an\
    \ entry simply by removing it.  (Frequency and laser power\n   of a non-operational\
    \ channel are not particularly useful.  Knowledge\n   about what frequencies can\
    \ be supported would be a table in the\n   capabilities section.)\n   The frame\
    \ relay circuit information contains the DLCI, the\n   operational circuit status,\
    \ whether this circuit is to be treated as\n   carrying LMI information, and which\
    \ port in the output port group of\n   the LFB traffic is to be sent to.  As mentioned\
    \ above, the circuit\n   index could, in some designs, be combined with the DLCI.\n"
- title: 8.3.  Capabilities
  contents:
  - "8.3.  Capabilities\n   The capability information for this LFB includes whether\
    \ the\n   underlying interface is operational, how many frequencies are\n   supported,\
    \ and how many total circuits, across all channels, are\n   permitted.  The maximum\
    \ number for a given laser channel can be\n   determined from the properties of\
    \ the FrameRelayCircuits table.  A\n   GET-PROP on path 2.channel.4 will give\
    \ the CE the properties of that\n   FrameRelayCircuits array which include the\
    \ number of entries used,\n   the first available entry, and the maximum number\
    \ of entries\n   permitted.\n"
- title: 8.4.  Events
  contents:
  - "8.4.  Events\n   This LFB is defined to be able to generate several events in\
    \ which\n   the CE may be interested.  There are events to report changes in\n\
    \   operational state of frequencies, and the creation and deletion of\n   frequency\
    \ entries.  There is an event for changes in status of\n   individual frame relay\
    \ circuits.  So an event notification of\n   61.5.3.11 would indicate that there\
    \ had been a circuit status change\n   on subscript 11 of the circuit table in\
    \ subscript 3 of the frequency\n   table.  The event report would include the\
    \ new status of the circuit\n   and the DLCI of the circuit.  Arguably, the DLCI\
    \ is redundant, since\n   the CE presumably knows the DLCI based on the circuit\
    \ index.  It is\n   included here to show including two pieces of information\
    \ in an event\n   report.\n   As described above, the event declaration defines\
    \ the event target,\n   the event condition, and the event report content.  The\
    \ event\n   properties indicate whether the CE is subscribed to the event, the\n\
    \   specific threshold for the event, and any filter conditions for the\n   event.\n\
    \   Another event shown is a laser power problem.  This event is\n   generated\
    \ whenever the laser falls below the specified threshold.\n   Thus, a CE can register\
    \ for the event of laser power loss on all\n   circuits.  It would do this by:\n\
    \         T = SET-PROP\n           Path-TLV: flags=0, length = 2, path = 61.4\n\
    \             Path-TLV: flags = property-field, length = 1, path = 2\n       \
    \        Content = 1 (register)\n             Path-TLV: flags = property-field,\
    \ length = 1, path = 3\n               Content = 15 (threshold)\n   This would\
    \ set the registration for the event on all entries in the\n   table.  It would\
    \ also set the threshold for the event, causing\n   reporting if the power falls\
    \ below 15.  (Presumably, the CE knows\n   what the scale is for power, and has\
    \ chosen 15 as a meaningful\n   problem level.)\n   If a laser oscillates in power\
    \ near the 15 mark, one could get a lot\n   of notifications.  (If it flips back\
    \ and forth between 14 and 15,\n   each flip down will generate an event.)  Suppose\
    \ that the CE decides\n   to suppress this oscillation somewhat on laser channel\
    \ 5.  It can do\n   this by setting the hysteresis property on that event.  The\
    \ request\n   would look like:\n         T = SET-PROP\n           Path-TLV: flags=0,\
    \ length = 3, path = 61.4.5\n             Path-TLV: flags = property-field, length\
    \ = 1, path = 4\n               Content = 2 (hysteresis)\n   Setting the hysteresis\
    \ to 2 suppresses a lot of spurious\n   notifications.  When the level first falls\
    \ below 10, a notification\n   is generated.  If the power level increases to\
    \ 10 or 11, and then\n   falls back below 10, an event will not be generated.\
    \  The power has\n   to recover to at least 12 and fall back below 10 to generate\
    \ another\n   event.  One common cause of this form of oscillation is when the\n\
    \   actual value is right near the border.  If it is really 9.5, tiny\n   changes\
    \ might flip it back and forth between 9 and 10.  A hysteresis\n   level of 1\
    \ will suppress this sort of condition.  Many other events\n   have oscillations\
    \ that are somewhat wider, so larger hysteresis\n   settings can be used with\
    \ those.\n"
- title: 9.   IANA Considerations
  contents:
  - "9.   IANA Considerations\n   The ForCES model creates the need for a unique XML\
    \ namespace for\n   ForCES library definition usage, and unique class names and\
    \ numeric\n   class identifiers.\n"
- title: 9.1.  URN Namespace Registration
  contents:
  - "9.1.  URN Namespace Registration\n   IANA has registered a new XML namespace,\
    \ as per the guidelines in RFC\n   3688 [RFC3688].\n   URI: The URI for this namespace\
    \ is\n   urn:ietf:params:xml:ns:forces:lfbmodel:1.0\n   Registrant Contact: IESG\n\
    \   XML: none, this is an XML namespace\n"
- title: 9.2.  LFB Class Names and LFB Class Identifiers
  contents:
  - "9.2.  LFB Class Names and LFB Class Identifiers\n   In order to have well defined\
    \ ForCES LFB Classes, and well defined\n   identifiers for those classes, IANA\
    \ has created a registry of LFB\n   class names, corresponding class identifiers,\
    \ and the document that\n   defines the LFB class.  The registry policy is simply\
    \ first come,\n   first served (FCFS) with regard to LFB class names.  With regard\
    \ to\n   LFB class identifiers, identifiers less than 65536 are reserved for\n\
    \   assignment by IETF Standards-Track RFCs.  Identifiers equal to or\n   above\
    \ 65536, in the 32-bit class ID space, are available for\n   assignment on a first\
    \ come, first served basis.  All registry entries\n   must be documented in a\
    \ stable, publicly available form.\n   Since this registry provides for FCFS allocation\
    \ of a portion of the\n   class identifier space, it is necessary to define rules\
    \ for naming\n   classes that are using that space.  As these can be defined by\n\
    \   anyone, the needed rule is to keep the FCFS class names from\n   colliding\
    \ with IETF-defined class names.  Therefore, all FCFS class\n   names MUST start\
    \ with the string \"Ext-\".\n   Table 1 tabulates the above information.\n   IANA\
    \ has created a registry of ForCES LFB Class Names and the\n   corresponding ForCES\
    \ LFB Class Identifiers, with the location of the\n   definition of the ForCES\
    \ LFB Class, in accordance with the rules in\n   the following table.\n   +----------------+------------+---------------+---------------------+\n\
    \   | LFB Class Name |  LFB Class | Place Defined |     Description     |\n  \
    \ |                | Identifier |               |                     |\n   +----------------+------------+---------------+---------------------+\n\
    \   |    Reserved    |      0     |    RFC 5812   |       Reserved      |\n  \
    \ |                |            |               |       --------      |\n   |\
    \    FE Object   |      1     |    RFC 5812   |    Defines ForCES   |\n   |  \
    \              |            |               |  Forwarding Element |\n   |    \
    \            |            |               |     information     |\n   |   FE Protocol\
    \  |      2     |      [2]      |  Defines parameters |\n   |     Object     |\
    \            |               |    for the ForCES   |\n   |                |  \
    \          |               |  protocol operation |\n   |                |    \
    \        |               |       --------      |\n   |  IETF defined  |   3-65535\
    \  |   Standards   |  Reserved for IETF  |\n   |      LFBs      |            |\
    \   Track RFCs  |     defined RFCs    |\n   |                |            |  \
    \             |       --------      |\n   |   ForCES LFB   |   >65535   |  Any\
    \ Publicly |  First Come, First  |\n   |   Class names  |            |   Available\
    \   |  Served for any use |\n   | beginning EXT- |            |    Document  \
    \ |                     |\n   +----------------+------------+---------------+---------------------+\n\
    \                                  Table 1\n"
- title: 10.  Authors Emeritus
  contents:
  - "10.  Authors Emeritus\n   The following are the authors who were instrumental\
    \ in the creation\n   of earlier releases of this document.\n   Ellen Delganes,\
    \ Intel Corp.\n   Lily Yang, Intel Corp.\n   Ram Gopal, Nokia Research Center\n\
    \   Alan DeKok, Infoblox, Inc.\n   Zsolt Haraszti, Clovis Solutions\n"
- title: 11.  Acknowledgments
  contents:
  - "11.  Acknowledgments\n   Many of the colleagues in our companies and participants\
    \ in the\n   ForCES mailing list have provided invaluable input into this work.\n\
    \   Particular thanks to Evangelos Haleplidis for help getting the XML\n   right.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   The FE model describes the representation and\
    \ organization of data\n   sets and components in the FEs.  The ForCES framework\
    \ document\n   [RFC3746] provides a comprehensive security analysis for the overall\n\
    \   ForCES architecture.  For example, the ForCES protocol entities must\n   be\
    \ authenticated per the ForCES requirements before they can access\n   the information\
    \ elements described in this document via ForCES.\n   Access to the information\
    \ contained in the FE model is accomplished\n   via the ForCES protocol, which\
    \ is defined in separate documents, and\n   thus the security issues will be addressed\
    \ there.\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC5810]  Doria, A., Ed., Hadi Salim, J., Ed., Haas, R., Ed.,\n \
    \             Khosravi, H., Ed., Wang, W., Ed., Dong, L., Gopal, R., and\n   \
    \           J. Halpern, \"Forwarding and Control Element Separation\n        \
    \      (ForCES) Protocol Specification\", RFC 5810, March 2010.\n   [RFC3688]\
    \  Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n              January\
    \ 2004.\n   [Schema1]  Thompson, H., Beech, D., Maloney, M., and N. Mendelsohn,\n\
    \              \"XML Schema Part 1: Structures\", W3C REC-xmlschema-1,\n     \
    \         http://www.w3.org/TR/xmlshcema-1/, May 2001.\n   [Schema2]  Biron, P.\
    \ and A. Malhotra, \"XML Schema Part 2: Datatypes\",\n              W3C REC-xmlschema-2,\
    \ http://www.w3.org/TR/xmlschema-2/,\n              May 2001.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [RFC3654]  Khosravi, H. and T. Anderson, \"\
    Requirements for Separation\n              of IP Control and Forwarding\", RFC\
    \ 3654, November 2003.\n   [RFC3746]  Yang, L., Dantu, R., Anderson, T., and R.\
    \ Gopal,\n              \"Forwarding and Control Element Separation (ForCES)\n\
    \              Framework\", RFC 3746, April 2004.\n   [RFC3317]  Chan, K., Sahita,\
    \ R., Hahn, S., and K. McCloghrie,\n              \"Differentiated Services Quality\
    \ of Service Policy\n              Information Base\", RFC 3317, March 2003.\n\
    \   [RFC3318]  Sahita, R., Hahn, S., Chan, K., and K. McCloghrie,\n          \
    \    \"Framework Policy Information Base\", RFC 3318, March 2003.\n   [RFC3444]\
    \  Pras, A. and J. Schoenwaelder, \"On the Difference between\n              Information\
    \ Models and Data Models\", RFC 3444,\n              January 2003.\n   [RFC3470]\
    \  Hollenbeck, S., Rose, M., and L. Masinter, \"Guidelines for\n             \
    \ the Use of Extensible Markup Language (XML)\n              within IETF Protocols\"\
    , BCP 70, RFC 3470, January 2003.\n   [UNICODE]  Davis, M. and M. Suignard, \"\
    UNICODE Security\n              Considerations\",\n              http://www.unicode.org/reports/tr36/tr36-3.html\
    \ ,\n              July 2005.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Joel Halpern\n   Self\n   P.O. Box 6049\n   Leesburg,\
    \ VA  20178\n   USA\n   Phone: +1 703 371 3043\n   EMail: jmh@joelhalpern.com\n\
    \   Jamal Hadi Salim\n   Znyx Networks\n   Ottawa, Ontario\n   Canada\n   EMail:\
    \ hadi@mojatatu.com\n"
