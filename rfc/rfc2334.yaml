- title: __initial_text__
  contents:
  - '              Server Cache Synchronization Protocol (SCSP)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Server Cache Synchronization Protocol\n\
    \   (SCSP) and is written in terms of SCSP's use within Non Broadcast\n   Multiple\
    \ Access (NBMA) networks; although, a somewhat straight\n   forward usage is applicable\
    \ to BMA networks.  SCSP attempts to solve\n   the generalized cache synchronization/cache-replication\
    \ problem for\n   distributed protocol entities.  However, in this document, SCSP\
    \ is\n   couched in terms of the client/server paradigm in which distributed\n\
    \   server entities, which are bound to a Server Group (SG) through some\n   means,\
    \ wish to synchronize the contents (or a portion thereof) of\n   their caches\
    \ which contain information about the state of clients\n   being served.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT,\
    \ SHOULD,\n   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in\
    \ this\n   document, are to be interpreted as described in [10].\n   It is perhaps\
    \ an obvious goal for any protocol to not limit itself to\n   a single point of\
    \ failure such as having a single server in a\n   client/server paradigm.  Even\
    \ when there are redundant servers, there\n   still remains the problem of cache\
    \ synchronization; i.e.,  when one\n   server becomes aware of a change in state\
    \ of cache information then\n   that server must propagate the knowledge of the\
    \ change in state to\n   all servers which are actively mirroring that state information.\n\
    \   Further, this must be done in a timely fashion without putting undue\n   resource\
    \ strains on the servers. Assuming that the state information\n   kept in the\
    \ server cache is the state of clients of the server, then\n   in order to minimize\
    \ the burden placed upon the client it is also\n   highly desirable that clients\
    \ need not have complete knowledge of all\n   servers which they may use.  However,\
    \ any mechanism for\n   synchronization should not preclude a client from having\
    \ access to\n   several (or all) servers.  Of course, any solution must be reasonably\n\
    \   scalable, capable of using some auto-configuration service, and lend\n   itself\
    \ to a wide range of authentication methodologies.\n   This document describes\
    \ the Server Cache Synchronization Protocol\n   (SCSP). SCSP solves the generalized\
    \ server synchronization/cache-\n   replication problem while addressing the issues\
    \ described above.\n   SCSP synchronizes caches (or a portion of the caches) of\
    \ a set of\n   server entities of a particular protocol which are bound to a Server\n\
    \   Group (SG) through some means (e.g., all NHRP servers belonging to a\n   Logical\
    \ IP Subnet (LIS)[1]).  The client/server protocol which a\n   particular server\
    \ uses is identified by a Protocol ID (PID).  SGs are\n   identified by an ID\
    \ which, not surprisingly, is called a SGID. Note,\n   therefore, that the combination\
    \ PID/SGID identifies both the\n   client/server protocol for which the servers\
    \ of the SG are being\n   synchronized as well as the instance of that protocol.\
    \  This implies\n   that multiple instances of the same protocol may be in operation\
    \ at\n   the same time and have their servers synchronized independently of\n\
    \   each other.  An example of types of information that must be\n   synchronized\
    \ can be seen in NHRP[2] using IP where the information\n   includes the registered\
    \ clients' IP to NBMA mappings in the SG LIS.\n   The simplest way to understand\
    \ SCSP is to understand that the\n   algorithm used here is quite similar to that\
    \ used in OSPF[3].  In\n   fact, if the reader wishes to understand more details\
    \ of the\n   tradeoffs and reliability aspects of SCSP, they should refer to the\n\
    \   Hello, Database Synchronization, and Flooding Procedures in OSPF [3].\n  \
    \ As described later, the protocol goes through three phases.  The\n   first,\
    \ very brief phase is the hello phase where two devices\n   determine that they\
    \ can talk to each other.  Following that is\n   database synchronization.  The\
    \ operation of SCSP assumes that up to\n   the point when new information is received,\
    \ two entities have the\n   same data available.  The database synchronization\
    \ phase ensures\n   this.\n   In database synchronization, the two neighbors exchange\
    \ summary\n   information about each entry in their database.  Summaries are used\n\
    \   since the database itself is potentially quite large.  Based on these\n  \
    \ summaries, the neighbors can determine if there is information that\n   each\
    \ needs from the other.  If so, that is requested and provided.\n   Therefore,\
    \ at the end of this phase of operation, the two neighbors\n   have the same data\
    \ in their databases.\n   After that, the entities enter and remain in flooding\
    \ state.  In\n   flooding state, any new information that is learned is sent to\
    \ all\n   neighbors, except the one (if any) that the information was learned\n\
    \   from.  This causes all new information in the system to propagate to\n   all\
    \ nodes, thus restoring the state that everyone knows the same\n   thing.  Flooding\
    \ is done reliably on each link, so no pattern of low\n   rate packet loss will\
    \ cause a disruption.  (Obviously, a sufficiently\n   high rate of packet loss\
    \ will cause the entire neighbor relationship\n   to come down, but if the link\
    \ does not work, then that is what one\n   wants.)\n   Because the database synchronization\
    \ procedure is run whenever a link\n   comes up, the system robustly ensures that\
    \ all participating nodes\n   have all available information.  It properly recovers\
    \ from\n   partitions, and copes with other failures.\n   The SCSP specification\
    \ is not useful as a stand alone protocol.  It\n   must be coupled with the use\
    \ of an SCSP Protocol Specific\n   specification which defines how a given protocol\
    \ would make use of\n   the synchronization primitives supplied by SCSP.  Such\
    \ specification\n   will be done in separate documents; e.g., [8] [9].\n"
- title: 2. Overview
  contents:
  - "2. Overview\n   SCSP places no topological requirements upon the SG.  Obviously,\n\
    \   however, the resultant graph must span the set of servers to be\n   synchronized.\
    \  SCSP borrows its cache distribution mechanism from the\n   link state protocols\
    \ [3,4].  However, unlike those technologies,\n   there is no mandatory Shortest\
    \ Path First (SPF) calculation, and SCSP\n   imposes no additional memory requirements\
    \ above and beyond that which\n   is required to save the cached information which\
    \ would exist\n   regardless of the synchronization technology.\n   In order to\
    \ give a frame of reference for the following discussion,\n   the terms Local\
    \ Server (LS), Directly Connected Server (DCS), and\n   Remote Server (RS) are\
    \ introduced.  The LS is the server under\n   scrutiny; i.e., all statements are\
    \ made from the perspective of the\n   LS when discussing the SCSP protocol. The\
    \ DCS is a server which is\n   directly connected to the LS;  e.g., there exists\
    \ a VC between the LS\n   and DCS.  Thus, every server is a DCS from the point\
    \ of view of every\n   other server which connects to it directly, and every server\
    \ is an LS\n   which has zero or more DCSs directly connected to it. From the\n\
    \   perspective of an LS, an RS is a server, separate from the LS, which\n   is\
    \ not directly connected to the LS (i.e., an RS is always two or\n   more hops\
    \ away from an LS whereas a DCS is always one hop away from\n   an LS).\n   SCSP\
    \ contains three sub protocols: the \"Hello\" protocol, the \"Cache\n   Alignment\"\
    \ protocol, and the \"Cache State Update\" protocol.  The\n   \"Hello\" protocol\
    \ is used to ascertain whether a DCS is operational\n   and whether the connection\
    \ between the LS and DCS is bidirectional,\n   unidirectional, or non-functional.\
    \  The \"Cache Alignment\" (CA)\n   protocol allows an LS to synchronize its entire\
    \ cache with that of\n   the cache of its DCSs. The \"Cache State Update\" (CSU)\
    \ protocol is\n   used to update the state of cache entries in servers for a given\
    \ SG.\n   Sections 2.1, 2.2, and 2.3 contain a more in-depth explanation of the\n\
    \   Hello, CA, and CSU protocols and the messages they use.\n   SCSP based synchronization\
    \ is performed on a per protocol instance\n   basis.  That is, a separate instance\
    \ of SCSP is run for each instance\n   of the given protocol running in a given\
    \ box.  The protocol is\n   identified in SCSP via a Protocol ID and the instance\
    \ of the protocol\n   is identified by a Server Group ID (SGID).  Thus the PID/SGID\
    \ pair\n   uniquely identify an instance of SCSP.  In general, this is not an\n\
    \   issue since it is seldom the case that many instances of a given\n   protocol\
    \ (which is distributed and needs cache synchronization) are\n   running within\
    \ the same physical box.  However, when this is the\n   case, there is a mechanism\
    \ called the Family ID (described briefly in\n   the Hello Protocol) which enables\
    \ a substantial reduction in\n   maintenance traffic at little real cost in terms\
    \ of control.  The use\n   of the Family ID mechanism, when appropriate for a\
    \ given protocol\n   which is using SCSP, will be fully defined in the given SCSP\
    \ protocol\n   specific specification.\n                       +---------------+\n\
    \                       |               |\n              +------->|     DOWN \
    \     |<-------+\n              |        |               |        |\n        \
    \      |        +---------------+        |\n              |            |     \
    \  ^            |\n              |            |       |            |\n       \
    \       |            |       |            |\n              |            |    \
    \   |            |\n              |            @       |            |\n      \
    \        |        +---------------+        |\n              |        |       \
    \        |        |\n              |        |    WAITING    |        |\n     \
    \         |     +--|               |--+     |\n              |     |  +---------------+\
    \  |     |\n              |     |    ^           ^    |     |\n              |\
    \     |    |           |    |     |\n              |     @    |           |  \
    \  @     |\n            +---------------+     +---------------+\n            |\
    \ BIDIRECTIONAL |---->| UNIDIRECTIONAL|\n            |               |     | \
    \              |\n            |  CONNECTION   |<----|  CONNECTION   |\n      \
    \      +---------------+     +---------------+\n          Figure 1: Hello Finite\
    \ State Machine (HFSM)\n"
- title: 2.1  Hello Protocol
  contents:
  - "2.1  Hello Protocol\n   \"Hello\" messages are used to ascertain whether a DCS\
    \ is operational\n   and whether the connections between the LS and DCS are bidirectional,\n\
    \   unidirectional, or non-functional. In order to do this, every LS MUST\n  \
    \ periodically send a Hello message to its DCSs.\n   An LS must be configured\
    \ with a list of NBMA addresses which\n   represent the addresses of peer servers\
    \ in a SG to which the LS\n   wishes to have a direct connection for the purpose\
    \ of running SCSP;\n   that is, these addresses are the addresses of would-be\
    \ DCSs.  The\n   mechanism for the configuration of an LS with these NBMA address\
    \ is\n   beyond the scope of this document; although one possible mechanism\n\
    \   would be an autoconfiguration server.\n   An LS has a Hello Finite State Machine\
    \ (HFSM) associated with each of\n   its DCSs (see Figure 1) for a given SG, and\
    \ the HFSM monitors the\n   state of the connectivity between the servers.\n \
    \  The HFSM starts in the \"Down\" State and transitions to the \"Waiting\"\n\
    \   State after NBMA level connectivity has been established.  Once in\n   the\
    \ Waiting State, the LS starts sending Hello messages to the DCS.\n   The Hello\
    \ message includes: a Sender ID which is set to the LS's ID\n   (LSID), zero or\
    \ more Receiver IDs which identify the DCSs from which\n   the LS has recently\
    \ heard a Hello message (as described below), and a\n   HelloInterval and DeadFactor\
    \ which will be described below.   At this\n   point, the DCS may or may not already\
    \ be sending its own Hello\n   messages to the LS.\n   When the LS receives a\
    \ Hello message from one of its DCSs, the LS\n   checks to see if its LSID is\
    \ in one of the Receiver ID fields of that\n   message which it just received,\
    \ and the LS saves the Sender ID from\n   that Hello message. If the LSID is in\
    \ one of the Receiver ID fields\n   then the LS transitions the HFSM to the Bidirectional\
    \ Connection\n   state otherwise it transitions the HFSM into the Unidirectional\n\
    \   Connection state.  The Sender ID which was saved is the DCS's ID\n   (DCSID).\
    \  At some point before the next time that the LS sends its\n   own Hello message\
    \ to the DCS, the LS will check the saved DCSID\n   against a list of Receiver\
    \ IDs which the LS uses when sending the\n   LS's own Hello messages.  If the\
    \ DCSID is not found in the list of\n   Receiver IDs then it is added to that\
    \ list before the LS sends its\n   Hello message.\n   Hello messages also contain\
    \ a HelloInterval and a DeadFactor.  The\n   Hello interval advertises the time\
    \ (in seconds) between sending of\n   consecutive Hello messages by the server\
    \ which is sending the\n   \"current\" Hello message.  That is, if the time between\
    \ reception of\n   Hello messages from a DCS exceeds the HelloInterval advertised\
    \ by\n   that DCS then the next Hello message is to be considered late by the\n\
    \   LS.  If the LS does not receive a Hello message, which contains the\n   LS's\
    \ LSID in one of the Receiver ID fields, within the interval\n   HelloInterval*DeadFactor\
    \ seconds (where DeadFactor was advertised by\n   the DCS in a previous Hello\
    \ message) then the LS MUST consider the\n   DCS to be stalled.  At which point\
    \ one of two things will happen: 1)\n   if any Hello messages have been received\
    \ during the last\n   HelloInterval*DeadFactor seconds then the LS should transition\
    \ the\n   HFSM for that DCS to the Unidirectional Connection State; otherwise,\n\
    \   the LS should transition the HFSM for that DCS to the Waiting State\n   and\
    \ remove the DCSID from the Receiver ID list.\n   Note that the Hello Protocol\
    \ is on a per PID/SGID basis. Thus, for\n   example, if there are two servers\
    \ (one in SG A and the other in SG B)\n   associated with an NBMA address X and\
    \ another two servers (also one\n   in SG A and the other in SG B) associated\
    \ with NBMA address Y and\n   there is a suitable point-to-point VC between the\
    \ NBMA addresses then\n   there are two HFSMs running on each side of the VC (one\
    \ per\n   PID/SGID).\n   Hello messages contain a list of Receiver IDs instead\
    \ of a single\n   Receiver ID in order to make use of point to multipoint connections.\n\
    \   While there is an HFSM per DCS, an LS MUST send only a single Hello\n   message\
    \ to its DCSs attached as leaves of a point to multipoint\n   connection.  The\
    \ LS does this by including DCSIDs in the list of\n   Receiver IDs when the LS's\
    \ sends its next Hello message.  Only the\n   DCSIDs from non-stalled DCSs from\
    \ which the LS has heard a Hello\n   message are included.\n   Any abnormal event,\
    \ such as receiving a malformed SCSP message,\n   causes the HFSM to transition\
    \ to the Waiting State; however, a loss\n   of NBMA connectivity causes the HFSM\
    \ to transition to the Down State.\n   Until the HFSM is in the Bidirectional\
    \ Connection State, if any\n   properly formed SCSP messages other than Hello\
    \ messages are received\n   then those messages MUST be ignored (this is for the\
    \ case where, for\n   example, there is a point to multipoint connection involved).\n\
    \                   +------------+\n                   |            |\n      \
    \        +--->|    DOWN    |\n              |    |            |\n            \
    \  |    +------------+\n              |          |\n              ^          |\n\
    \              |          @\n              |    +------------+\n             \
    \ |    |Master/Slave|\n              |-<--|            |<---+\n              |\
    \    |Negotiation |    |\n              |    +------------+    |\n           \
    \   |          |           |\n              ^          |           ^\n       \
    \       |          @           |\n              |    +------------+    |\n   \
    \           |    |   Cache    |    |\n              |-<--|            |-->-|\n\
    \              |    | Summarize  |    |\n              |    +------------+   \
    \ |\n              |          |           |\n              ^          |      \
    \     ^\n              |          @           |\n              |    +------------+\
    \    |\n              |    |   Update   |    |\n              |-<--|         \
    \   |-->-|\n              |    |   Cache    |    |\n              |    +------------+\
    \    |\n              |          |           |\n              ^          |   \
    \        ^\n              |          @           |\n              |    +------------+\
    \    |\n              |    |            |    |\n              +-<--|  Aligned\
    \   |-->-+\n                   |            |\n                   +------------+\n\
    \     Figure 2: Cache Alignment Finite State Machine\n"
- title: 2.2 Cache Alignment Protocol
  contents:
  - "2.2 Cache Alignment Protocol\n   \"Cache Alignment\" (CA) messages are used by\
    \ an LS to synchronize its\n   cache with that of the cache of each of its DCSs.\
    \  That is, CA\n   messages allow a booting LS to synchronize with each of its\
    \ DCSs.  A\n   CA message contains a CA header followed by zero or more Cache\
    \ State\n   Advertisement Summary records (CSAS records).\n   An LS has a Cache\
    \ Alignment Finite State Machine (CAFSM) associated\n   (see Figure 2) with each\
    \ of its DCSs on a per PID/SGID basis, and the\n   CAFSM monitors the state of\
    \ the cache alignment between the servers.\n   The CAFSM starts in the Down State.\
    \  The CAFSM is associated with an\n   HFSM, and when that HFSM reaches the Bidirectional\
    \ State, the CAFSM\n   transitions to the Master/Slave Negotiation State.  The\
    \ Master/Slave\n   Negotiation State causes either the LS or DCS to take on the\
    \ role of\n   master over the cache alignment process.  In a sense, the master\n\
    \   server sets the tempo for the cache alignment.\n   When the LS's CAFSM reaches\
    \ the Master/Slave Negotiation State, the\n   LS will send a CA message to the\
    \ DCS associated with the CAFSM.  The\n   format of CA messages are described\
    \ in Section B.2.1.  The first CA\n   message which the LS sends includes no CSAS\
    \ records and a CA header\n   which contains the LSID in the Sender ID field,\
    \ the DCSID in the\n   Receiver ID field, a CA sequence number, and three bits.\
    \  These three\n   bits are the M (Master/Slave) bit, the I (Initialization of\
    \ master)\n   bit, and the O (More) bit. In the first CA message sent by the LS\
    \ to\n   a particular DCS, the M, O, and I bits are set to one.  If the LS\n \
    \  does not receive a CA message from the DCS in CAReXmtInterval seconds\n   then\
    \ it resends the CA message it just sent.  The LS continues to do\n   this until\
    \ the CAFSM transitions to the Cache Summarize State or\n   until the HFSM transitions\
    \ out of the Bidirectional State.  Any time\n   the HFSM transitions out of the\
    \ Bidirectional State, the CAFSM\n   transitions to the Down State.\n"
- title: 2.2.1 Master Slave Negotiation State
  contents:
  - "2.2.1 Master Slave Negotiation State\n   When the LS receives a CA message from\
    \ the DCS while in the\n   Master/Slave Negotiation State, the role the LS plays\
    \ in the exchange\n   depends on packet processing as follows:\n   1) If the CA\
    \ from the DCS has the M, I, and O bits set to one and\n      there are no CSAS\
    \ records in the CA message and the Sender ID\n      as specified in the DCS's\
    \ CA message is larger than the LSID then\n     a) The timer counting down the\
    \ CAReXmtInterval is stopped.\n     b) The CAFSM corresponding to that DCS transitions\
    \ to the\n        Cache Summarize    State and the LS takes on the role of slave.\n\
    \     c) The LS adopts the CA sequence number it received in the CA\n        message\
    \ as its own CA sequence number.\n     d) The LS sends a CA message to the DCS\
    \ which is formated as\n        follows: the M and I bits are set to zero, the\
    \ Sender ID field\n        is set to the LSID, the Receiver ID field is set to\
    \ the DCSID,\n        and the CA sequence number is set to the CA sequence number\
    \ that\n        appeared in the DCS's CA message.  If there are CSAS records to\n\
    \        be sent (i.e., if the LS's cache is not empty), and if all of\n     \
    \   them will not fit into this CA message then the O bit is set to\n        one\
    \ and the initial set of CSAS records are included in the CA\n        message;\
    \ otherwise the O bit is set to zero and if any CSAS\n        Records need to\
    \ be sent then those records are included in the\n        CA message.\n   2) If\
    \ the CA message from the DCS has the M and I bits off and the\n      Sender ID\
    \ as specified in the DCS's CA message is smaller than\n      the LSID then\n\
    \     a) The timer counting down the CAReXmtInterval is stopped.\n     b) The\
    \ CAFSM corresponding to that DCS transitions to the\n        Cache Summarize\
    \ State and the LS takes on the role of master.\n     c) The LS must process the\
    \ received CA message.\n        An explanation of CA message processing is given\
    \ below.\n     d) The LS sends a CA message to the DCS which is formated as\n\
    \        follows: the M bit is set to one, I bit is set to zero, the\n       \
    \ Sender ID field is set to the LSID, the Receiver ID field is set\n        to\
    \ the DCSID, and the LS's current CA sequence number is\n        incremented by\
    \ one and placed in the CA message.   If there are\n        any CSAS records to\
    \ be sent from the LS to the DCS (i.e., if the\n        LS's cache is not empty)\
    \ then the O bit is set to one and the\n        initial set of CSAS records are\
    \ included in the CA message that\n        the LS is sending to the DCS.\n   3)\
    \ Otherwise, the packet must be ignored.\n"
- title: 2.2.2 The Cache Summarize State
  contents:
  - "2.2.2 The Cache Summarize State\n   At any given time, the master or slave have\
    \ at most one outstanding\n   CA message.  Once the LS's CAFSM has transitioned\
    \ to the Cache\n   Summarize State the sequence of exchanges of CA messages occurs\
    \ as\n   follows:\n   1) If the LS receives a CA message with the M bit set incorrectly\n\
    \      (e.g., the M bit is set in the CA of the DCS and the LS is master)\n  \
    \    or if the I bit is set then the CAFSM transitions back to the\n      Master/Slave\
    \ Negotiation State.\n   2) If the LS is master and the LS receives a CA message\
    \ with a\n      CA sequence number which is one less than the LS's current\n \
    \     CA sequence number then the message is a duplicate and the message\n   \
    \   MUST be discarded.\n   3) If the LS is master and the LS receives a CA message\
    \ with a\n      CA sequence number which is equal to the LS's current CA sequence\n\
    \      number then the CA message MUST be processed.  An explanation of\n    \
    \  \"CA message processing\" is given below.  As a result of having\n      received\
    \ the CA message from the DCS the following will occur:\n     a) The timer counting\
    \ down the CAReXmtInterval is stopped.\n     b) The LS must process any CSAS records\
    \ in the received CA message.\n     c) Increment the LS's CA sequence number by\
    \ one.\n     d) The cache exchange continues as follows:\n       1) If the LS\
    \ has no more CSAS records to send and the received CA\n          message has\
    \ the O bit off then the CAFSM transitions to the\n          Update Cache State.\n\
    \       2) If the LS has no more CSAS records to send and the received CA\n  \
    \        message has the O bit on then the LS sends back a CA message\n      \
    \    (with new CA sequence number) which contains no CSAS records\n          and\
    \ with the O bit off.  Reset the timer counting down the\n          CAReXmtInterval.\n\
    \       3) If the LS has more CSAS records to send then the LS sends the\n   \
    \       next CA message with the LS's next set of CSAS records.  If LS\n     \
    \     is sending its last set of CSAS records then the O bit is set\n        \
    \  off otherwise the O bit is set on. Reset the timer counting\n          down\
    \ the CAReXmtInterval.\n   4) If the LS is slave and the LS receives a CA message\
    \ with a\n      CA sequence number which is equal to the LS's current\n      CA\
    \ sequence number then the CA message is a duplicate and the\n      LS MUST resend\
    \ the CA message which it had just sent to the DCS.\n   5) If the LS is slave\
    \ and the LS receives a CA message with a\n      CA sequence number which is one\
    \ more than the LS's current\n      CA sequence number then the message is valid\
    \ and MUST be\n      processed.  An explanation of \"CA message processing\" is\
    \ given\n      below.  As a result of having received the CA message from the\n\
    \      DCS the following will occur:\n     a) The LS must process any CSAS records\
    \ in the received CA message.\n     b) Set the LS's CA sequence number to the\
    \ CA sequence number in the\n        CA message.\n     c) The cache exchange continues\
    \ as follows:\n       1) If the LS had just sent a CA message with the O bit off\
    \ and\n          the received CA message has the O bit off then the CAFSM\n  \
    \        transitions to the Update Cache State and the LS sends a CA\n       \
    \   message with no CSAS records and with the O bit off.\n       2) If the LS\
    \ still has CSAS records to send then the LS MUST send\n          a CA message\
    \ with CSAS records in it.\n         a) If the message being sent from the LS\
    \ to the DCS does not\n            contain the last CSAS records that the LS needs\
    \ to send\n            then the CA message is sent with the O bit on.\n      \
    \   b) If the message being sent from the LS to the DCS does\n            contain\
    \ the last CSAS records that the LS needs to\n            send and the CA message\
    \ just received from the DCS had the\n            O bit off then the CA message\
    \ is sent with the O bit off,\n            and the LS transitions the CAFSM to\
    \ the Update Cache State.\n         c) If the message being sent from the LS to\
    \ the DCS does\n            contain the last CSAS records that the LS needs to\
    \ send\n            and the CA message just received from the DCS had the O bit\n\
    \            on then the CA message is sent with the O bit off and the\n     \
    \       alignment process continues.\n   6) If the LS is slave and the LS receives\
    \ a CA message with a\n      CA sequence number that is neither equal to nor one\
    \ more than\n      the current LS's CA sequence number then an error has occurred\n\
    \      and the CAFSM transitions to the Master/Slave Negotiation State.\n   Note\
    \ that if the LS was slave during the CA process then the LS upon\n   transitioning\
    \ the CAFSM to the Update Cache state MUST keep a copy of\n   the last CA message\
    \ it sent and the LS SHOULD set a timer equal to\n   CAReXmtInterval. If either\
    \ the timer expires or the LS receives a CSU\n   Solicit (CSUS) message (CSUS\
    \ messages are described in Section 2.2.3)\n   from the DCS then the LS releases\
    \ the copy of the CA message.  The\n   reason for this is that if the DCS (which\
    \ is master) loses the last\n   CA message sent by the LS then the DCS will resend\
    \ its previous CA\n   message with the last CA Sequence number used.  If that\
    \ were to occur\n   the LS would need to resend its last sent CA message as well.\n"
- title: '2.2.2.1 "CA message processing":'
  contents:
  - "2.2.2.1 \"CA message processing\":\n   The LS makes a list of those cache entries\
    \ which are more \"up to\n   date\" in the DCS than the LS's own cache.  This\
    \ list is called the\n   CSA Request List (CRL).  See Section 2.4 for a description\
    \ of what it\n   means for a CSA (Client State Advertisement) record or CSAS record\
    \ to\n   be more \"up to date\" than an LS's cache entry.\n"
- title: 2.2.3 The Update Cache State
  contents:
  - "2.2.3 The Update Cache State\n   If the CRL of the associated CAFSM of the LS\
    \ is empty upon transition\n   into the Update Cache State then the CAFSM immediately\
    \ transitions\n   into the Aligned State.\n   If the CRL is not empty upon transition\
    \ into the Update Cache State\n   then the LS solicits the DCS to send the CSA\
    \ records corresponding to\n   the summaries (i.e., CSAS records) which the LS\
    \ holds in its CRL. The\n   solicited CSA records will contain the entirety of\
    \ the cached\n   information held in the DCS's cache for the given cache entry.\
    \  The\n   LS solicits the relevant CSA records by forming CSU Solicit (CSUS)\n\
    \   messages from the CRL. See Section B.2.4 for the description of the\n   CSUS\
    \ message format.  The LS then sends the CSUS messages to the DCS.\n   The DCS\
    \ responds to the CSUS message by sending to the LS one or more\n   CSU Request\
    \ messages containing the entirety of newer cached\n   information identified\
    \ in the CSUS message.  Upon receiving the CSU\n   Request the LS will send one\
    \ or more CSU Replies as described in\n   Section 2.3.  Note that the LS may have\
    \ at most one CSUS message\n   outstanding at any given time.\n   Just before\
    \ the first CSUS message is sent from an LS to the DCS\n   associated with the\
    \ CAFSM, a timer is set to CSUSReXmtInterval\n   seconds.  If all the CSA records\
    \ corresponding to the CSAS records in\n   the CSUS message have not been received\
    \ by the time that the timer\n   expires then a new CSUS message will be created\
    \ which contains all\n   the CSAS records for which no appropriate CSA record\
    \ has been\n   received plus additional CSAS records not covered in the previous\n\
    \   CSUS message.  The new CSUS message is then sent to the DCS.  If, at\n   some\
    \ point before the timer expires, all CSA record updates have been\n   received\
    \ for all the CSAS records included in the previously sent\n   CSUS message then\
    \ the timer is stopped.  Once the timer is stopped,\n   if there are additional\
    \ CSAS records that were not covered in the\n   previous CSUS message but were\
    \ in the CRL then the timer is reset and\n   a new CSUS message is created which\
    \ contains only those CSAS records\n   from the CRL which have not yet been sent\
    \ to the DCS.  This process\n   continues until all the CSA records corresponding\
    \ CSAS records that\n   were in the CRL have been received by the LS.  When the\
    \ LS has a\n   completely updated cache then the LS transitions CAFSM associated\n\
    \   with the DCS to the Aligned State.\n   If an LS receives a CSUS message or\
    \ a CA message with a Receiver ID\n   which is not the LS's LSID then the message\
    \ must be discarded and\n   ignored.  This is necessary since an LS may be a leaf\
    \ of a point to\n   multipoint connection with other servers in the SG.\n"
- title: 2.2.4 The Aligned State
  contents:
  - "2.2.4 The Aligned State\n   While in the Aligned state, an LS will perform the\
    \ Cache State Update\n   Protocol as described in Section 2.3.\n   Note that an\
    \ LS may receive a CSUS message while in the Aligned State\n   and, the LS MUST\
    \ respond to the CSUS message with the appropriate CSU\n   Request message in\
    \ a similar fashion to the method previously\n   described in Section 2.2.3.\n"
- title: 2.3 Cache State Update Protocol
  contents:
  - "2.3 Cache State Update Protocol\n   \"Cache State Update\" (CSU) messages are\
    \ used to dynamically update\n   the state of cache entries in servers on a given\
    \ PID/SGID basis. CSU\n   messages contain zero or more \"Cache State Advertisement\"\
    \ (CSA)\n   records each of which contains its own snapshot of the state of a\n\
    \   particular cache entry.  An LS may send/receive a CSU to/from a DCS\n   only\
    \ when the corresponding CAFSM is in either the Aligned State or\n   the Update\
    \ Cache State.\n   There are two types of CSU messages: CSU Requests and CSU Replies.\n\
    \   See Sections B.2.2 and B.2.3 respectively for message formats.  A CSU\n  \
    \ Request message is sent from an LS to one or more DCSs for one of two\n   reasons:\
    \ either the LS has received a CSUS message and MUST respond\n   only to the DCS\
    \ which originated the CSUS message, or the LS has\n   become aware of a change\
    \ of state of a cache entry.  An LS becomes\n   aware of a change of state of\
    \ a cache entry either through receiving\n   a CSU Request from one of its DCSs\
    \ or as a result of a change of\n   state being observed in a cached entry originated\
    \ by the LS.  In the\n   former case, the LS will send a CSU Request to each of\
    \ its DCSs\n   except the DCS from which the LS became aware of the change in\
    \ state.\n   In the latter case, the LS will send a CSU Request to each of its\n\
    \   DCSs.  The change in state of a particular cache entry is noted in a\n   CSA\
    \ record which is then appended to the end of the CSU Request\n   message mandatory\
    \ part. In this way, state changes are propagated\n   throughout the SG.\n   Examples\
    \ of such changes in state are as follows:\n       1) a server receives a request\
    \ from a client to add an entry to\n          its cache,\n       2) a server receives\
    \ a request from a client to remove an entry\n          from its cache,\n    \
    \   3) a cache entry has timed out in the server's cache, has been\n         \
    \ refreshed in the server's cache, or has been administratively\n          modified.\n\
    \   When an LS receives a CSU Request from one of its DCSs, the LS\n   acknowledges\
    \ one or more CSA Records which were contained in the CSU\n   Request by sending\
    \ a CSU Reply.  The CSU Reply contains one or more\n   CSAS records which correspond\
    \ to those CSA records which are being\n   acknowledged.  Thus, for example, if\
    \ a CSA record is dropped (or\n   delayed in processing) by the LS because there\
    \ are insufficient\n   resources to process it then a corresponding CSAS record\
    \ is not\n   included in the CSU Reply to the DCS.\n   Note that an LS may send\
    \ multiple CSU Request messages before\n   receiving a CSU Reply acknowledging\
    \ any of the CSA Records contained\n   in the CSU Requests.  Note also that a\
    \ CSU Reply may contain\n   acknowledgments for CSA Records from multiple CSU\
    \ Requests.  Thus,\n   the terms \"request\" and \"reply\" may be a bit confusing.\n\
    \   Note that a CSA Record contains a CSAS Record followed by\n   client/server\
    \ protocol specific information contained in a cache\n   entry  (see Section B.2.0.2\
    \ for CSAS record format information and\n   Section B.2.2.1 for CSA record format\
    \ information).  When a CSA\n   record is considered by the LS to represent cached\
    \ information which\n   is more \"up to date\" (see Section 2.4) than the cached\
    \ information\n   contained within the cache of the LS then two things happen:\
    \  1) the\n   LS's cache is updated with the more up to date information, and\
    \ 2)\n   the LS sends a CSU Request containing the CSA Record to each of its\n\
    \   DCSs except the one from which the CSA Record arrived.  In this way,\n   state\
    \ changes are propagated within the PID/SGID.  Of course, at some\n   point, the\
    \ LS will also acknowledge the reception of the CSA Record\n   by sending the\
    \ appropriate DCS a CSU Reply message containing the\n   corresponding CSAS Record.\n\
    \   When an LS sends a new CSU Request, the LS keeps track of the\n   outstanding\
    \ CSA records in that CSU Request and to which DCSs the LS\n   sent the CSU Request.\
    \  For each DCS to which the CSU Request was\n   sent, a timer set to CSUReXmtInterval\
    \ seconds is started just prior\n   to sending the CSU Request.  This timer is\
    \ associated with the CSA\n   Records contained in that CSU Request such that\
    \ if that timer expires\n   prior to having all CSA Records acknowledged from\
    \ that DCS then (and\n   only then) a CSU Request is re-sent by the LS to that\
    \ DCS.  However,\n   the re-sent CSU Request only contains those CSA Records which\
    \ have\n   not yet been acknowledged.  If all CSA Records associated with a\n\
    \   timer becomes acknowledged then the timer is stopped. Note that the\n   re-sent\
    \ CSA Records follow the same time-out and retransmit rules as\n   if they were\
    \ new.  Retransmission will occur a configured number of\n   times for a given\
    \ CSA Record and if acknowledgment fails to occur\n   then an \"abnormal event\"\
    \ has occurred at which point the then the\n   HFSM associated with the DCS is\
    \ transitioned to the Waiting State.\n   A CSA Record instance is said to be on\
    \ a \"DCS retransmit queue\" when\n   it is associated with the previously mentioned\
    \ timer.  Only the most\n   up-to-date CSA Record is permitted to be queued to\
    \ a given DCS\n   retransmit queue.  Thus, if a less up-to-date CSA Record is\
    \ queued to\n   the DCS retransmit queue when a newer CSA Record instance is about\
    \ to\n   be queued to that DCS retransmit queue then the older CSA Record\n  \
    \ instance is dequeued and disassociated with its timer immediately\n   prior\
    \ to enqueuing the newer instance of the CSA Record.\n   When an LS receives a\
    \ CSU Reply from one of its DCSs then the LS\n   checks each CSAS record in the\
    \ CSU Reply against the CSAS Record\n   portion of the CSA Records which are queued\
    \ to the DCS retransmit\n   queue.\n     1) If there exists an exact match between\
    \ the CSAS record portion\n        of the CSA record and a CSAS Record in the\
    \ CSU Reply then\n        that CSA Record is considered to be acknowledged and\
    \ is thus\n        dequeued from the DCS retransmit queue and is\n        disassociated\
    \ with its timer.\n     2) If there exists a match between the CSAS record portion\n\
    \        of the CSA record and a CSAS Record in the CSU Reply except\n       \
    \ for the CSA Sequence number then\n       a) If the CSA Record queued to the\
    \ DCS retransmit queue has a\n          CSA Sequence Number which is greater than\
    \ the\n          CSA Sequence Number in the CSAS Record of the the CSU Reply\n\
    \          then the CSAS Record in the CSU Reply is ignored.\n       b) If the\
    \ CSA Record queued to the DCS retransmit queue has a\n          CSA Sequence\
    \ Number which is less than the\n          CSA Sequence Number in the CSAS Record\
    \ of the the CSU Reply\n          then CSA Record which is queued to the DCS retransmit\
    \ queue is\n          dequeued and the CSA Record is disassociated with its timer.\n\
    \          Further, a CSUS Message is sent to that DCS which sent the\n      \
    \    more up-to-date CSAS Record.  All normal CSUS processing\n          occurs\
    \ as if the CSUS were sent as part of the CA protocol.\n   When an LS receives\
    \ a CSU Request message which contains a CSA Record\n   which contains a CSA Sequence\
    \ Number which is smaller than the CSA\n   Sequence number of the cached CSA then\
    \ the LS MUST acknowledge the\n   CSA record in the CSU Request but it MUST do\
    \ so by sending a CSU\n   Reply message containing the CSAS Record portion of\
    \ the CSA Record\n   stored in the cache and not the CSAS Record portion of the\
    \ CSA Record\n   contained in the CSU Request.\n   An LS responds to CSUS messages\
    \ from its DCSs by sending CSU Request\n   messages containing the appropriate\
    \ CSA records to the DCS.  If an LS\n   receives a CSUS message containing a CSAS\
    \ record for an entry which\n   is no longer in its database (e.g., the entry\
    \ timed out and was\n   discarded after the Cache Alignment exchange completed\
    \ but before the\n   entry was requested through a CSUS message), then the LS\
    \ will respond\n   by copying the CSAS Record from the CSUS message into a CSU\
    \ Request\n   message and the LS will set the N bit signifying that this record\
    \ is\n   a NULL record since the cache entry no longer exists in the LS's\n  \
    \ cache.  Note that in this case, the \"CSA Record\" included in the CSU\n   Request\
    \ to signify the NULL cache entry is literally only a CSAS\n   Record since no\
    \ client/server protocol specific information exists\n   for the cache entry.\n\
    \   If an LS receives a CSA Record in a CSU Request from a DCS for which\n   the\
    \ LS has an identical CSA record posted to the corresponding DCS's\n   DCS retransmit\
    \ queue then the CSA Record on the DCS retransmit queue\n   is considered to be\
    \ implicitly acknowledged.  Thus, the CSA Record is\n   dequeued from the DCS\
    \ retransmit queue and is disassociated with its\n   timer.  The CSA Record sent\
    \ by the DCS MUST still be acknowledged by\n   the LS in a CSU Reply, however.\
    \  This is useful in the case of point\n   to multipoint connections where the\
    \ rule that \"when an LS receives a\n   CSA record from a DCS, that LS floods\
    \ the CSA Record to every DCS\n   except the DCS from which it was received\"\
    \ might be broken.\n   If an LS receives a CSU with a Receiver ID which is not\
    \ equal to the\n   LSID and is not set to all 0xFFs then the CSU must be discarded\
    \ and\n   ignored.  This is necessary since the LS may be a leaf of a point to\n\
    \   multipoint connection with other servers in the LS's SG.\n   An LS MAY send\
    \ a CSU Request to the all 0xFFs Receiver ID when the LS\n   is a root of a point\
    \ to multipoint connection with a set of its DCSs.\n   If an LS receives a CSU\
    \ Request with the all 0xFFs Receiver ID then\n   it MUST use the Sender ID in\
    \ the CSU Request as the Receiver ID of\n   the CSU Reply (i.e., it MUST unicast\
    \ its response to the sender of\n   the request) when responding.  If the LS wishes\
    \ to send a CSU Request\n   to the all 0xFFs Receiver ID then it MUST create a\
    \ time-out and\n   retransmit timer for each of the DCSs which are leaves of the\
    \ point\n   to multipoint connection prior to sending the CSU Request.  If in\n\
    \   this case, the time-out and retransmit timer expires for a given DCS\n   prior\
    \ to acknowledgment of a given CSA Record then the LS MUST use\n   the specific\
    \ DCSID as the Receiver ID rather than the all 0xFFs\n   Receiver ID.  Similarly,\
    \ if it is necessary to re-send a CSA Record\n   then the LS MUST specify the\
    \ specific DCSID as the Receiver ID rather\n   than the all 0xFFs Receiver ID.\n\
    \   Note that if a set of servers are in a full mesh of point to\n   multipoint\
    \ connections, and one server of that mesh sends a CSU\n   Request into that full\
    \ mesh, and the sending server sends the CSA\n   Records in the CSU Request to\
    \ the all 0xFFs Receiver ID then it would\n   not be necessary for every other\
    \ server in the mesh to source their\n   own CSU Request containing those CSA\
    \ Records into the mesh in order\n   to properly flood the CSA Records. This is\
    \ because every server in\n   the mesh would have heard the CSU Request and would\
    \ have processed\n   the included CSA Records as appropriate.  Thus, a server\
    \ in a full\n   mesh could consider the mesh to be a single logical port and so\
    \ the\n   rule that \"when an LS receives a CSA record from a DCS, that LS\n \
    \  floods the CSA Record to every DCS except the DCS from which it was\n   received\"\
    \ is not broken.  A receiving server in the full mesh would\n   still need to\
    \ acknowledge the CSA records with CSU Reply messages\n   which contain the LSID\
    \ of the replying server as the Sender ID and\n   the ID of the server which sent\
    \ the CSU Request as the Receiver ID\n   field.  In the time out and retransmit\
    \ case, the Receiver ID of the\n   CSU Request would be set to the specific DCSID\
    \ which did not\n   acknowledge the CSA Record (as opposed to the all 0xFFs Receiver\
    \ ID).\n   Since a full mesh emulates a broadcast media for the servers attached\n\
    \   to the full mesh, use of SCSP on a broadcast medium might use this\n   technique\
    \ as well.  Further discussion of this use of a full mesh or\n   use of a broadcast\
    \ media is left to the client/server protocol\n   specific documents.\n"
- title: 2.4 The meaning of "More Up To Date"/"Newness"
  contents:
  - "2.4 The meaning of \"More Up To Date\"/\"Newness\"\n   During the cache alignment\
    \ process and during normal CSU processing,\n   a CSAS Record is compared against\
    \ the contents of an LS's cache entry\n   to decide whether the information contained\
    \ in the record is more \"up\n   to date\" than the corresponding cache entry\
    \ of the LS.\n   There are three pieces of information which are used in determining\n\
    \   whether a record contains information which is more \"up to date\" than\n\
    \   the information contained in the cache entry of an LS which is\n   processing\
    \ the record: 1) the Cache Key, 2) the Originator which is\n   described by an\
    \ Originator ID (OID), and 3) the CSA Sequence number.\n   See Section B.2.0.2\
    \ for more information on these fields.\n   Given these three pieces of information,\
    \ a CSAS record (be it part of\n   a CSA Record or be it stand-alone) is considered\
    \ to be more \"up to\n   date\" than the information contained in the cache of\
    \ an LS if all of\n   the following are true:\n     1) The Cache Key in the CSAS\
    \ Record matches the stored Cache Key\n        in the LS's cache entry,\n    \
    \ 2) The OID in the CSAS Record matches the stored OID\n        in the LS's cache\
    \ entry,\n     3) The CSA Sequence Number in the CSAS Record is greater than\n\
    \        CSA Sequence Number in the LS's cache entry.\n"
- title: Discussion and Conclusions
  contents:
  - "Discussion and Conclusions\n   While the above text is couched in terms of synchronizing\
    \ the\n   knowledge of the state of a client within the cache of servers\n   contained\
    \ in a SG, this solution generalizes easily to any number of\n   database synchronization\
    \ problems (e.g., LECS synchronization).\n   SCSP defines a generic flooding protocol.\
    \  There are a number of\n   related issues relative to cache maintenance and\
    \ topology maintenance\n   which are more appropriately defined in the client/server\
    \ protocol\n   specific documents; for example, it might be desirable to define\
    \ a\n   generic cache entry time-out mechanism for a given protocol or to\n  \
    \ advertise adjacency information between servers so that one could\n   obtain\
    \ a topo-map of the servers in a SG.  When mechanisms like these\n   are desirable,\
    \ they will be defined in the client/server protocol\n   specific documents.\n"
- title: 'Appendix A: Terminology and Definitions'
  contents:
  - "Appendix A: Terminology and Definitions\n   CA Message - Cache Alignment Message\n\
    \     These messages allow an LS to synchronize its entire cache with\n     that\
    \ of the cache of one of its DCSs.\n   CAFSM - Cache Alignment Finite State Machine\n\
    \     The CAFSM monitors the state of the cache alignment between an LS\n    \
    \ and a particular DCS.  There exists one CAFSM per DCS as seen from\n     an\
    \ LS.\n   CSA Record - Cache State Advertisement Record\n     A CSA is a record\
    \ within a CSU message which identifies an update\n     to the status of a \"\
    particular\" cache entry.\n   CSAS Record - Cache State Advertisement Summary\
    \ Record\n     A CSAS contains a summary of the information in a CSA.  A server\n\
    \     will send CSAS records describing its cache entries to another\n     server\
    \ during the cache alignment process.  CSAS records are also\n     included in\
    \ a CSUS messages when an LS wants to request the entire\n     CSA from the DCS.\
    \  The LS is requesting the CSA from the DCS\n     because the LS believes that\
    \ the DCS has a more recent view of the\n     state of the cache entry in question.\n\
    \   CSU Message - Cache State Update message\n     This is a message sent from\
    \ an LS to its DCSs when the LS becomes\n     aware of a change in state of a\
    \ cache entry.\n   CSUS Message - Cache State Update Solicit Message\n     This\
    \ message is sent by an LS to its DCS after the LS and DCS have\n     exchanged\
    \ CA messages.   The CSUS message contains one or more CSAS\n     records which\
    \ represent solicitations for entire CSA records (as\n     opposed to just the\
    \ summary information held in the CSAS).\n   DCS - Directly Connected Server\n\
    \     The DCS is a server which is directly connected to the LS; e.g.,\n     there\
    \ exists a VC between the LS and DCS. This term, along with the\n     terms LS\
    \ and RS, is used to give a frame of reference when talking\n     about servers\
    \ and their synchronization.  Unless explicitly stated\n     to the contrary,\
    \ there is no implied difference in functionality\n     between a DCS, LS, and\
    \ RS.\n   HFSM - Hello Finite State Machine\n     An LS has a HFSM associated\
    \ with each of its DCSs.  The HFSM\n     monitors the state of the connectivity\
    \ between the LS and a\n     particular DCS.\n   LS - Local Server\n     The LS\
    \ is the server under scrutiny; i.e., all statements are made\n     from the perspective\
    \ of the LS.  This term, along with the terms\n     DCS and RS, is used to give\
    \ a frame of reference when talking about\n     servers and their synchronization.\
    \  Unless explicitly stated to the\n     contrary, there is no implied difference\
    \ in functionality between a\n     DCS, LS, and RS.\n   LSID - Local Server ID\n\
    \     The LSID is a unique token that identifies an LS.  This value might\n  \
    \   be taken from the protocol address of the LS.\n   PID - Protocol ID\n    \
    \ This field contains an identifier which identifies the\n     client/server protocol\
    \ which is making use of SCSP for the given\n     message.  The assignment of\
    \ Protocol IDs for this field is given\n     over to IANA as described in Section\
    \ C.\n   RS - Remote Server (RS)\n     From the perspective of an LS, an RS is\
    \ a server, separate from the\n     LS, which is not directly connected to the\
    \ LS (i.e., an RS is\n     always two or more hops away from an LS whereas a DCS\
    \ is always one\n     hop away from an LS).  Unless otherwise stated an RS refers\
    \ to a\n     server in the SG.  This term, along with the terms LS and DCS, is\n\
    \     used to give a frame of reference when talking about servers and\n     their\
    \ synchronization.  Unless explicitly stated to the contrary,\n     there is no\
    \ implied difference in functionality between a DCS, LS,\n     and RS.\n   SG\
    \ - Server Group\n     The SCSP synchronizes caches (or a portion of the caches)\
    \ of a set\n     of server entities which are bound to a SG through some means\n\
    \     (e.g., all servers belonging to a Logical IP Subnet (LIS)[1]).\n     Thus\
    \ an SG is just a grouping of servers around some commonality.\n   SGID - Server\
    \ Group ID\n     This ID is a 16 bit identification field that uniquely identifies\n\
    \     the instance client/server protocol for which the servers of the SG\n  \
    \   are being synchronized.  This implies that multiple instances of\n     the\
    \ same protocol may be in operation at the same time and have\n     their servers\
    \ synchronized independently of each other.\n"
- title: 'Appendix B:  SCSP Message Formats'
  contents:
  - "Appendix B:  SCSP Message Formats\n   This section of the appendix includes the\
    \ message formats for SCSP.\n   SCSP protocols are LLC/SNAP encapsulated with\
    \ an LLC=0xAA-AA-03 and\n   OUI=0x00-00-5e and PID=0x00-05.\n   SCSP has 3 parts\
    \ to every packet: the fixed part, the mandatory part,\n   and the extensions\
    \ part.  The fixed part of the message exists in\n   every packet and is shown\
    \ below.  The mandatory part is specific to\n   the particular message type (i.e.,\
    \ CA, CSU Request/Reply, Hello,\n   CSUS) and, it includes (among other packet\
    \ elements) a Mandatory\n   Common Part and zero or more records each of which\
    \ contains\n   information pertinent to the state of a particular cache entry\n\
    \   (except in the case of a Hello message) whose information is being\n   synchronized\
    \ within a SG. The extensions part contains the set of\n   extensions for the\
    \ SCSP message.\n   In the following message formats, the fields marked as \"\
    unused\" MUST\n   be set to zero upon transmission of such a message and ignored\
    \ upon\n   receipt of such a message.\n"
- title: B.1 Fixed Part
  contents:
  - "B.1 Fixed Part\n    0                   1                   2               \
    \    3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \  Version    |  Type Code    |        Packet Size            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Checksum             |      Start Of Extensions      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Version\n     This is the version of the SCSP protocol being used.  The current\n\
    \     version is 1.\n   Type Code\n     This is the code for the message type\
    \ (e.g., Hello (5), CSU\n     Request(2), CSU Reply(3), CSUS (4), CA (1)).\n \
    \  Packet Size\n     The total length of the SCSP packet, in octets (excluding\
    \ link\n     layer and/or other protocol encapsulation).\n   Checksum\n     The\
    \ standard IP checksum over the entire SCSP packet starting at\n     the fixed\
    \ header.  If the packet is an odd number of bytes in\n     length then this calculation\
    \ is performed as if a byte set to 0x00\n     is appended to the end of the packet.\n\
    \   Start Of Extensions\n     This field is coded as zero when no extensions are\
    \ present in the\n     message.  If extensions are present then this field will\
    \ be coded\n     with the offset from the top of the fixed header to the beginning\n\
    \     of the first extension.\n"
- title: B.2.0 Mandatory Part
  contents:
  - "B.2.0 Mandatory Part\n   The mandatory part of the SCSP packet contains the operation\
    \ specific\n   information for a given message type (e.g., SCSP Cache State Update\n\
    \   Request/Reply, etc.), and it includes (among other packet elements) a\n  \
    \ Mandatory Common Part (described in Section B.2.0.1) and zero or more\n   records\
    \ each of which contains information pertinent to the state of\n   a particular\
    \ cache entry (except in the case of a Hello message)\n   whose information is\
    \ being synchronized within a SG.  These records\n   may, depending on the message\
    \ type, be either Cache State\n   Advertisement Summary (CSAS) Records (described\
    \ in Section B.2.0.2)\n   or Cache State Advertisement (CSA) Records (described\
    \ in Section\n   B.2.2.1).  CSA Records contain a summary of a cache entry's\n\
    \   information (i.e., a CSAS Record) plus some additional client/server\n   protocol\
    \ specific information.  The mandatory common part format and\n   CSAS Record\
    \ format is shown immediately below, prior to showing their\n   use in SCSP messages,\
    \ in order to prevent replication within the\n   message descriptions.\n"
- title: B.2.0.1 Mandatory Common Part
  contents:
  - "B.2.0.1 Mandatory Common Part\n   Sections B.2.1 through B.2.5 have a substantial\
    \ overlap in format.\n   This overlapping format is called the mandatory common\
    \ part and its\n   format is shown below:\n    0                   1         \
    \          2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Protocol ID           |        Server Group ID        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            unused             |             Flags             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Sender ID Len | Recvr ID Len  |       Number of Records       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Sender ID (variable length)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Receiver ID (variable length)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Protocol ID\n     This field contains an identifier which identifies the\n\
    \     client/server protocol which is making use of SCSP for the given\n     message.\
    \  The assignment of Protocol IDs for this field is given\n     over to IANA as\
    \ described in Section C.  Protocols with current\n     documents have the following\
    \ defined values:\n       1 - ATMARP\n       2 - NHRP\n       3 - MARS\n     \
    \  4 - DHCP\n       5 - LNNI\n   Server Group ID\n     This ID is uniquely identifies\
    \ the instance of a given\n     client/server protocol for which servers are being\
    \ synchronized.\n   Flags\n     The Flags field is message specific, and its use\
    \ will be described\n     in the specific message format sections below.\n   Sender\
    \ ID Len\n     This field holds the length in octets of the Sender ID.\n   Recvr\
    \ ID Len\n     This field holds the length in octets of the Receiver ID.\n   Number\
    \ of Records\n     This field contains the number of additional records associated\n\
    \     with the given message.  The exact format of these records is\n     specific\
    \ to the message and will be described for each message type\n     in the sections\
    \ below.\n   Sender ID\n     This is an identifier assigned to the server which\
    \ is sending the\n     given message.  One possible assignment might be the protocol\n\
    \     address of the sending server.\n   Receiver ID\n     This is an identifier\
    \ assigned to the server which is to receive\n     the given message.  One possible\
    \ assignment might be the protocol\n     address of the server which is to receive\
    \ the given message.\n"
- title: B.2.0.2 Cache State Advertisement Summary Record (CSAS record)
  contents:
  - "B.2.0.2 Cache State Advertisement Summary Record (CSAS record)\n   CSAS records\
    \ contain a summary of information contained in a cache\n   entry of a given client/server\
    \ database which is being synchronized\n   through the use of SCSP.  The summary\
    \ includes enough information for\n   SCSP to look into the client/server database\
    \ for the appropriate\n   database cache entry and then compare the \"newness\"\
    \ of the summary\n   against the \"newness\" of the cached entry.\n   Note that\
    \ CSAS records do not contain a Server Group ID (SGID) nor do\n   they contain\
    \ a Protocol ID.  These IDs are necessary to identify\n   which protocol and which\
    \ instance of that protocol for which the\n   summary is applicable.  These IDs\
    \ are present in the mandatory common\n   part of each message.\n   Note also\
    \ that the values of the Hop Count and Record Length fields\n   of a CSAS Record\
    \ are dependent on whether the CSAS record exists as a\n   \"stand-alone\" record\
    \ or whether the CSAS record is \"embedded\" in CSA\n   Record.  This is further\
    \ described below.\n    0                   1                   2            \
    \       3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \         Hop Count           |        Record Length          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Cache Key Len |  Orig ID Len  |N|          unused             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       CSA Sequence Number                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Cache Key  ...                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Originator ID   ...                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Hop Count\n     This field represents the number of hops that the record may\
    \ take\n     before being dropped.  Thus, at each server that the record\n   \
    \  traverses, the Hop Count is decremented.  This field is set to 1\n     when\
    \ the CSAS record is a \"stand-alone\" record (i.e., it is not\n     embedded\
    \ within a CSA record) since summaries do not go beyond one\n     hop during the\
    \ cache alignment process.  If a CSAS record is\n     \"embedded\" within a CSA\
    \ record then the Hop Count is set to an\n     administratively defined value\
    \ which is almost certainly greater\n     than or equal to the the cardinality\
    \ of the SG minus one.  Note\n     that an exception to the previous rule occurs\
    \ when the CSA Record\n     is carried within a CSU Request which was sent in\
    \ response to a\n     solicitation (i.e., in response to a CSAS Record which was\
    \ sent in\n     a CSUS message); in which case, the Hop Count SHOULD be set to\
    \ 1.\n   Record Length\n     If the CSAS record is a \"stand-alone\" record then\
    \ this value is\n     12+\"Cache Key Leng\"+\"Orig ID Len\" in bytes; otherwise,\
    \ this value\n     is set to 12+\"Cache Key Leng\"+\"Orig ID Len\"+ sizeof(\"\
    Client/Server\n     Protocol Specific Part for cache entry\").  The size of the\n\
    \     Client/Server Protocol Specific Part may be obtained from the\n     client/server\
    \ protocol specific document for the given Protocol ID.\n   Cache Key Len\n  \
    \   Length of the Cache Key field in bytes.\n   Orig ID Len.\n     Length of the\
    \ Originator ID field in bytes.\n   N\n     The \"N\" bit signifies that this\
    \ CSAS Record is actually a Null\n     record.  This bit is only used in a CSAS\
    \ Record contained in a CSU\n     Request/Reply which is sent in response to a\
    \ CSUS message.  It is\n     possible that an LS may receive a solicitation for\
    \ a CSA record\n     when the cache entry represented by the solicited CSA Record\
    \ no\n     longer exists in the LS's cache (see Section 2.3 for details).  In\n\
    \     this case, the LS copies the CSAS Record directly from the CSUS\n     message\
    \ into the CSU Request, and the LS sets the N bit signifying\n     that the cache\
    \ entry does not exist any longer.  The DCS which\n     solicited the CSA record\
    \ which no longer exists will still respond\n     with a CSU Reply.  This bit\
    \ is usually set to zero.\n   CSA Sequence Number\n     This field contains a\
    \ sequence number that identifies the \"newness\"\n     of a CSA record instance\
    \ being summarized.  A \"larger\" sequence\n     number means a more recent advertisement.\
    \  Thus, if the state of\n     part (or all) of a cache entry needs to be updated\
    \ then the CSA\n     record advertising the new state MUST contain a CSA Sequence\
    \ Number\n     which is larger than the one corresponding to the previous\n  \
    \   advertisement.  This number is assigned by the originator of the\n     CSA\
    \ record.  The CSA Sequence Number may be assigned by the\n     originating server\
    \ or by the client which caused its server to\n     advertise its existence.\n\
    \     The CSA Sequence Number is a signed 32 bit number.  Within the CSA\n   \
    \  Sequence Number space, the number -2^31 (0x80000000) is reserved.\n     Thus,\
    \ the usable portion of the CSA Sequence Number space for a\n     given Cache\
    \ Key is between the numbers -2^31+1 (0x80000001) and\n     2^31-1 (0x7fffffff).\
    \  An LS uses -2^31+1 the first time it\n     originates a CSA Record for a cache\
    \ entry that it created.  Each\n     time the cache entry is modified in some\
    \ manner and when that\n     modification needs to be synchronized with the other\
    \ servers in the\n     SG, the LS increments the CSA Sequence number associated\
    \ with the\n     given Cache Key and uses that new CSA Sequence Number when\n\
    \     advertising the update.  If it is ever the case that a given CSA\n     Sequence\
    \ Number has reached 2^31-2 and the associated cache entry\n     has been modified\
    \ such that an update must be sent to the rest of\n     the servers in the SG\
    \ then the given cache entry MUST first be\n     purged from the SG by the LS\
    \ by sending a CSA Record which causes\n     the cache entry to be removed from\
    \ other servers and this CSA\n     Record carries a CSA Sequence Number of 2^31-1.\
    \  The exact packet\n     format and mechanism by which a cache entry is purged\
    \ is defined in\n     the appropriate protocol specific document.  After the purging\
    \ CSA\n     Record has been acknowledged by each DCS, an LS will then send a\n\
    \     new CSA Record carrying the updated information, and this new CSA\n    \
    \ Record will carry a CSA Sequence Number of -2^31+1.\n     After a restart occurs\
    \ and after the restarting LS's CAFSM has\n     achieved the Aligned state, if\
    \ an update to an existing cache entry\n     needs to be synchronized or a new\
    \ cache entry needs to be\n     synchronized then the ensuing CSA Record MUST\
    \ contain a CSA\n     Sequence Number which is unique within the SG for the given\
    \ OID and\n     Cache Key.  The RECOMMENDED method of obtaining this number (unless\n\
    \     explicitly stated to the contrary in the protocol specific\n     document)\
    \ is to set the CSA Sequence Number in the CSA Record to\n     the CSA Sequence\
    \ Number associated with the existing cache entry\n     (if an out of date cache\
    \ entry already exists and zero if not) plus\n     a configured constant.  Note\
    \ that the protocol specific document\n     may require that all cache entries\
    \ containing the OID of the\n     restarting LS be purged prior to updating the\
    \ cache entries; in\n     this case, the updating CSA Record will still contain\
    \ a CSA\n     Sequence Number set to the CSA Sequence Number associated with the\n\
    \     previously existing cache entry plus a configured constant.\n   Cache Key\n\
    \     This is a database lookup key that uniquely identifies a piece of\n    \
    \ data which the originator of a CSA Record wishes to synchronize\n     with its\
    \ peers for a given \"Protocol ID/Server Group ID\" pair.\n     This key will\
    \ generally be a small opaque byte string which SCSP\n     will associate with\
    \ a given piece of data in a cache.  Thus, for\n     example, an originator might\
    \ assign a particular 4 byte string to\n     the binding of an IP address with\
    \ that of an ATM address.\n     Generally speaking, the originating server of\
    \ a CSA record is\n     responsible for generating a Cache Key for every element\
    \ of data\n     that the the given server originates and which the server wishes\
    \ to\n     synchronize with its peers in the SG.\n   Originator ID\n     This\
    \ field contains an ID administratively assigned to the server\n     which is\
    \ the originator of CSA Records.\n"
- title: B.2.1 Cache Alignment (CA)
  contents:
  - "B.2.1 Cache Alignment (CA)\n   The Cache Alignment (CA) message allows an LS\
    \ to synchronize its\n   entire cache with that of the cache of its DCSs within\
    \ a server\n   group. The CA message type code is 1. The CA message mandatory\
    \ part\n   format is as follows:\n    0                   1                  \
    \ 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     CA  Sequence Number                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Mandatory Common Part                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          CSAS Record                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                .......\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          CSAS Record                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   CA Sequence Number\n     A value which provides a unique identifier to aid\
    \ in the sequencing\n     of the cache alignment process.  A \"larger\" sequence\
    \ number means a\n     more recent CA message.  The slave server always copies\
    \ the\n     sequence number from the master server's previous CA message into\n\
    \     its current CA message which it is sending and the the slave\n     acknowledges\
    \ the master's CA message.  Since the initial CA process\n     is lock-step, if\
    \ the slave does not receive the same sequence\n     number which it previously\
    \ received then the information in the\n     slave's previous CA message is implicitly\
    \ acknowledged. Note that\n     there is a separate CA Sequence Number space associated\
    \ with each\n     CAFSM.\n     Whenever it is necessary to (re)start cache alignment\
    \ and the CAFSM\n     enters the Master/Slave Negotiation state, the CA Sequence\
    \ Number\n     should be set to a value not previously seen by the DCS.  One\n\
    \     possible scheme is to use the machine's time of day counter.\n   Mandatory\
    \ Common Part\n     The mandatory common part is described in detail in Section\n\
    \     B.2.0.1.  There are two fields in the mandatory common part whose\n    \
    \ codings are specific to a given message type.  These fields are the\n     \"\
    Number of Records\" field and the \"Flags\" field.\n     Number of Records\n \
    \      The Number of Records field of the mandatory common part for the\n    \
    \   CA message gives the number of CSAS Records appended to the CA\n       message\
    \ mandatory part.\n     Flags\n       The Flags field of the mandatory common\
    \ part for the CA message\n       has the following format:\n        0       \
    \            1\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |M|I|O|         unused          |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       M\n         This bit is part of the negotiation process for the cache\n\
    \         alignment.  When this bit is set then the sender of the CA\n       \
    \  message is indicating that it wishes to lead the alignment\n         process.\
    \  This bit is the \"Master/Slave bit\".\n       I\n         When set, this bit\
    \ indicates that the sender of the CA message\n         believes that it is in\
    \ a state where it is negotiating for the\n         status of master or slave.\
    \  This bit is the \"Initialization\n         bit\".\n       O\n         This\
    \ bit indicates that the sender of the CA message has more\n         CSAS records\
    \ to send.  This implies that the cache alignment\n         process must continue.\
    \  This bit is the \"mOre bit\" despite its\n         dubious name.\n     All\
    \ other fields of the mandatory common part are coded as\n     described in Section\
    \ B.2.0.1.\n   CSAS record\n     The CA message appends CSAS records to the end\
    \ of its mandatory\n     part.  These CSAS records are NOT embedded in CSA records.\
    \  See\n     Section B.2.0.2 for details on CSAS records.\n"
- title: B.2.2 Cache State Update Request (CSU Request)
  contents:
  - "B.2.2 Cache State Update Request (CSU Request)\n   The Cache State Update Request\
    \ (CSU Request) message is used to\n   update the state of cache entries in servers\
    \ which are directly\n   connected to the server sending the message.   A CSU\
    \ Request message\n   is sent from one server (the LS) to directly connected server\
    \ (the\n   DCS) when the LS observes changes in the state of one or more cache\n\
    \   entries.  An LS observes such a change in state by either receiving a\n  \
    \ CSU request which causes an update to the LS's database or by\n   observing\
    \ a change of state of a cached entry originated by the LS.\n   The change in\
    \ state of a cache entry is noted in a CSU message by\n   appending a \"Cache\
    \ State Advertisement\" (CSA) record to the end of\n   the mandatory part of the\
    \ CSU Request as shown below.\n   The CSU Request message type code is 2.  The\
    \ CSU Request message\n   mandatory part format is as follows:\n    0        \
    \           1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Mandatory Common Part                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         CSA Record                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                              .......\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         CSA Record                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Mandatory Common Part\n     The mandatory common part is described in detail\
    \ in Section\n     B.2.0.1.  There are two fields in the mandatory common part\
    \ whose\n     codings are specific to a given message type.  These fields are\
    \ the\n     \"Number of Records\" field and the \"Flags\" field.\n     Number\
    \ of Records\n       The Number of Records field of the mandatory common part\
    \ for the\n       CSU Request message gives the number of CSA Records appended\
    \ to\n       the CSU Request message mandatory part.\n     Flags\n       Currently,\
    \ there are no flags defined for the Flags field of the\n       mandatory common\
    \ part for the CSU Request message.\n     All other fields of the mandatory common\
    \ part are coded as\n     described in Section B.2.0.1.\n   CSA Record\n     See\
    \ Section B.2.2.1.\n"
- title: B.2.2.1 Cache State Advertisement Record (CSA record)
  contents:
  - "B.2.2.1 Cache State Advertisement Record (CSA record)\n   CSA records contain\
    \ the information necessary to relate the current\n   state of a cache entry in\
    \ an SG to the servers being synchronized.\n   CSA records contain a CSAS Record\
    \ header and a client/server protocol\n   specific part. The CSAS Record includes\
    \ enough information for SCSP\n   to look into the client/server database for\
    \ the appropriate database\n   cache entry and then compare the \"newness\" of\
    \ the summary against the\n   \"newness\" of the cached entry.  If the information\
    \ contained in the\n   CSA is more new than the cached entry of the receiving\
    \ server then\n   the cached entry is updated accordingly with the contents of\
    \ the CSA\n   Record.  The client/server protocol specific part of the CSA Record\n\
    \   is documented separately for each such protocol.  Examples of the\n   protocol\
    \ specific parts for NHRP and ATMARP are shown in [8] and [9]\n   respectively.\n\
    \   The amount of information carried by a specific CSA record may exceed\n  \
    \ the size of a link layer PDU.  Hence, such CSA records MUST be\n   fragmented\
    \ across a number of CSU Request messages. The method by\n   which this is done,\
    \ is client/server protocol specific and is\n   documented in the appropriate\
    \ protocol specific document.\n   The content of a CSA record is as follows:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          CSAS Record                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Client/Server Protocol Specific Part for cache entry ...    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   CSAS Record\n     See Section B.2.0.2 for rules and format for filling out\
    \ a CSAS\n     Record when it is \"embedded\" in a CSA Record.\n   Client/Server\
    \ Protocol Specific Part for cache entry\n     This field contains the fields\
    \ which are specific to the protocol\n     specific portion of SCSP processing.\
    \  The particular set of fields\n     are defined in separate documents for each\
    \ protocol user of SCSP.\n     The Protocol ID, which identifies which protocol\
    \ is using SCSP in\n     the given packet, is located in the mandatory part of\
    \ the message.\n"
- title: B.2.3 Cache State Update Reply (CSU Reply)
  contents:
  - "B.2.3 Cache State Update Reply (CSU Reply)\n   The Cache State Update Reply (CSU\
    \ Reply) message is sent from a DCS\n   to an LS to acknowledge one or more CSA\
    \ records which were received\n   in a CSU Request.  Reception of a CSA record\
    \ in a CSU Request is\n   acknowledged by including a CSAS record in the CSU Reply\
    \ which\n   corresponds to the CSA record being acknowledged.  The CSU Reply\n\
    \   message is the same in format as the CSU Request message except for\n   the\
    \ following: the type code is 3, only CSAS Records (rather than CSA\n   records)\
    \ are returned, and only those CSAS Records for which CSA\n   Records are being\
    \ acknowledged are returned.  This implies that a\n   given LS sending a CSU Request\
    \ may not receive an acknowledgment in a\n   single CSU Reply for all the CSA\
    \ Records included in the CSU Request.\n"
- title: B.2.4 Cache State Update Solicit Message (CSUS message)
  contents:
  - "B.2.4 Cache State Update Solicit Message (CSUS message)\n   This message allows\
    \ one server (LS) to solicit the entirety of CSA\n   record data stored in the\
    \ cache of a directly connected server (DCS).\n   The DCS responds with CSU Request\
    \ messages containing the appropriate\n   CSA records.  The CSUS message type\
    \ code is 4.  The CSUS message\n   format is the same as that of the CSU Reply\
    \ message.  CSUS messages\n   solicit CSU Requests from only one server (the one\
    \ identified by the\n   Receiver ID in the Mandatory Part of the message).\n"
- title: 'B.2.5 Hello:'
  contents:
  - "B.2.5 Hello:\n   The Hello message is used to check connectivity between the\
    \ sending\n   server (the LS) and one of its directly connected neighbor servers\n\
    \   (the DCSs).  The Hello message type code is 5.  The Hello message\n   mandatory\
    \ part format is as follows:\n    0                   1                   2  \
    \                 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         HelloInterval         |          DeadFactor           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            unused             |          Family ID            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Mandatory Common Part                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Additional Receiver ID Record                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                               .........\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Additional Receiver ID Record                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   HelloInterval\n     The hello interval advertises the time between sending\
    \ of\n     consecutive Hello Messages.  If the LS does not receive a Hello\n \
    \    message from the DCS (which contains the LSID as a Receiver ID)\n     within\
    \ the HelloInterval advertised by the DCS then the DCS's Hello\n     is considered\
    \ to be late.  Also, the LS MUST send its own Hello\n     message to a DCS within\
    \ the HelloInterval which it advertised to\n     the DCS in the LS's previous\
    \ Hello message to that DCS (otherwise\n     the DCS would consider the LS's Hello\
    \ to be late).\n   DeadFactor\n     This is a multiplier to the HelloInterval.\
    \ If an LS does not\n     receive a Hello message which contains the LS's LSID\
    \ as a Receiver\n     ID within the interval HelloInterval*DeadFactor from a given\
    \ DCS,\n     which advertised the HelloInterval and DeadFactor in a previous\n\
    \     Hello message, then the LS MUST consider the DCS to be stalled; at\n   \
    \  this point, one of two things MUST happen: 1) if the LS has\n     received\
    \ any Hello messages from the DCS during this time then the\n     LS transitions\
    \ the corresponding HFSM to the Unidirectional State;\n     otherwise, 2) the\
    \ LS transitions the corresponding HFSM to the\n     Waiting State.\n   Family\
    \ ID\n     This is an opaque bit string which is used to refer to an aggregate\n\
    \     of Protocol ID/SGID pairs.  Only a single HFSM is run for all\n     Protocol\
    \ ID/SGID pairs assigned to a Family ID.  Thus, there is a\n     one to many mapping\
    \ between the single HFSM and the CAFSMs\n     corresponding to each of the Protocol\
    \ ID/SGID pairs.  This might\n     have the net effect of substantially reducing\
    \ HFSM maintenance\n     traffic.  See the protocol specific SCSP documents for\
    \ further\n     details.\n   Mandatory Common Part\n     The mandatory common\
    \ part is described in detail in Section\n     B.2.0.1.  There are two fields\
    \ in the mandatory common part whose\n     codings are specific to a given message\
    \ type.  These fields are the\n     \"Number of Records\" field and the \"Flags\"\
    \ field.\n     Number of Records\n       The Number of Records field of the mandatory\
    \ common part for the\n       Hello message contains the number of \"Additional\
    \ Receiver ID\"\n       records which are included in the Hello.  Additional Receiver\
    \ ID\n       records contain a length field and a Receiver ID field.  Note\n \
    \      that the count in \"Number of Records\" does NOT include the\n       Receiver\
    \ ID which is included in the Mandatory Common Part.\n     Flags\n       Currently,\
    \ there are no flags defined for the Flags field of the\n       mandatory common\
    \ part for the Hello message.\n     All other fields of the mandatory common part\
    \ are coded as\n     described in Section B.2.0.1.\n   Additional Receiver ID\
    \ Record\n     This record contains a length field followed by a Receiver ID.\n\
    \     Since it is conceivable that the length of a given Receiver ID may\n   \
    \  vary even within an SG, each additional Receiver ID heard (beyond\n     the\
    \ first one) will have both its length in bytes and value encoded\n     in an\
    \ \"Additional Receiver ID Record\".  Receiver IDs are IDs of a\n     DCS from\
    \ which the LS has heard a recent Hello (i.e., within\n     DeadFactor*HelloInterval\
    \ as advertised by the DCS in a previous\n     Hello message).\n     The format\
    \ for this record is as follows:\n      0                   1                \
    \   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Rec ID Len   |                 Receiver ID                   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   If the\
    \ LS has not heard from any DCS then the LS sets the Hello\n   message fields\
    \ as follows:  Recvr ID Len is set to zero and no\n   storage is allocated for\
    \ the Receiver ID in the Common Mandatory\n   Part,  \"Number of Records\" is\
    \ set to zero, and no storage is\n   allocated for \"Additional Receiver ID Records\"\
    .\n   If the LS has heard from exactly one DCS then the LS sets the Hello\n  \
    \ message fields as follows:  the Receiver ID of the DCS which was\n   heard and\
    \ the length of that Receiver ID are encoded in the Common\n   Mandatory Part,\
    \ \"Number of Records\" is set to zero, and no storage is\n   allocated for \"\
    Additional Receiver ID Records\".\n   If the LS has heard from two or more DCSs\
    \ then the LS sets the Hello\n   message fields as follows:  the Receiver ID of\
    \ the first DCS which\n   was heard and the length of that Receiver ID are encoded\
    \ in the\n   Common Mandatory Part, \"Number of Records\" is set to the number\
    \ of\n   \"Additional\" DCSs heard, and for each additional DCS an \"Additional\n\
    \   Receiver ID Record\" is formed and appended to the end of the Hello\n   message.\n"
- title: B.3  Extensions Part
  contents:
  - "B.3  Extensions Part\n   The Extensions Part, if present, carries one or more\
    \ extensions in\n   {Type, Length, Value} triplets.\n   Extensions have the following\
    \ format:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Type               |           Length              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Value...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Type\n     The extension type code (see below).\n   Length\n     The length\
    \ in octets of the value (not including the Type and\n     Length fields;  a null\
    \ extension will have only an extension header\n     and a length of zero).\n\
    \   When extensions exist, the extensions part is terminated by the End\n   of\
    \ Extensions extension, having Type = 0 and Length = 0.\n   Extensions may occur\
    \ in any order but any particular extension type\n   may occur only once in an\
    \ SCSP packet.  An LS MUST NOT change the\n   order of extensions.\n"
- title: B.3.0  The End Of Extensions
  contents:
  - "B.3.0  The End Of Extensions\n    Type = 0\n    Length = 0\n   When extensions\
    \ exist, the extensions part is terminated by the End\n   Of Extensions extension.\n"
- title: B.3.1 SCSP Authentication Extension
  contents:
  - "B.3.1 SCSP Authentication Extension\n   Type = 1 Length = variable\n   The SCSP\
    \ Authentication Extension is carried in SCSP packets to\n   convey the authentication\
    \ information between an LS and a DCS in the\n   same SG.\n   Authentication is\
    \ done pairwise on an LS to DCS basis; i.e., the\n   authentication extension\
    \ is generated at each LS. If a received\n   packet fails the authentication test\
    \ then an \"abnormal event\" has\n   occurred. The packet is discarded and this\
    \ event is logged.\n   The presence or absence of authentication is a local matter.\n"
- title: B.3.1.1 Header Format
  contents:
  - "B.3.1.1 Header Format\n   The authentication header has the following format:\n\
    \   0                   1                   2                   3\n   0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Security Parameter Index (SPI)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+\
    \ Authentication Data... -+-+-+-+-+-+-+-+-+-+\n   |                          \
    \                                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Security Parameter Index (SPI) can be thought of as an index into a\n   table\
    \ that maintains the keys and other information such as hash\n   algorithm. LS\
    \ and DCS communicate either off-line using manual keying\n   or online using\
    \ a key management protocol to populate this table. The\n   receiving SCSP entity\
    \ always allocates the SPI and the parameters\n   associated with it.\n   The\
    \ authentication data field contains the MAC (Message\n   Authentication Code)\
    \ calculated over the entire SCSP payload. The\n   length of this field is dependent\
    \ on the hash algorithm used to\n   calculate the MAC.\n"
- title: B.3.1.2 Supported Hash Algorithms
  contents:
  - "B.3.1.2 Supported Hash Algorithms\n   The default hash algorithm to be supported\
    \ is HMAC-MD5-128 [11]. HMAC\n   is safer than normal keyed hashes. Other hash\
    \ algorithms MAY be\n   supported by def.\n   IANA will assign the numbers to\
    \ identify the algorithm being used as\n   described in Section C.\n"
- title: B.3.1.3 SPI and Security Parameters Negotiation
  contents:
  - "B.3.1.3 SPI and Security Parameters Negotiation\n   SPI's can be negotiated either\
    \ manually or using an Internet Key\n   Management protocol. Manual keying MUST\
    \ be supported. The following\n   parameters are associated with the tuple <SPI,\
    \ DCS ID>- lifetime,\n   Algorithm, Key. Lifetime indicates the duration in seconds\
    \ for which\n   the key is valid. In case of manual keying, this duration can\
    \ be\n   infinite. Also, in order to better support manual keying, there may\n\
    \   be multiple tuples active at the same time (DCS ID being the same).\n   Any\
    \ Internet standard key management protocol MAY be used to\n   negotiate the SPI\
    \ and parameters.\n"
- title: B.3.1.4 Message Processing
  contents:
  - "B.3.1.4 Message Processing\n   At the time of adding the authentication extension\
    \ header, LS looks\n   up in a table to fetch the SPI and the security parameters\
    \ based on\n   the DCS ID. If there are no entries in the table and if there is\n\
    \   support for key management, the LS initiates the key management\n   protocol\
    \ to fetch the necessary parameters. The LS then calculates\n   the hash by zeroing\
    \ authentication data field before calculating the\n   MAC on the sending end.\
    \ The result replaces in the zeroed\n   authentication data field. If key management\
    \ is not supported and\n   authentication is mandatory, the packet is dropped\
    \ and this\n   information is logged.\n   When receiving traffic, an LS fetches\
    \ the parameters based on the SPI\n   and its ID. The authentication data field\
    \ is extracted before zeroing\n   out to calculate the hash. It computes the hash\
    \ on the entire payload\n   and if the hash does not match, then an \"abnormal\
    \ event\" has\n   occurred.\n"
- title: B.3.1.5 Security Considerations
  contents:
  - "B.3.1.5 Security Considerations\n   It is important that the keys chosen are\
    \ strong as the security of\n   the entire system depends on the keys being chosen\
    \ properly and the\n   correct implementation of the algorithms.\n   SCSP has\
    \ a peer to peer trust model. It is recommended to use an\n   Internet standard\
    \ key management protocol to negotiate the keys\n   between the neighbors. Transmitting\
    \ the keys in clear text, if other\n   methods of negotiation is used, compromises\
    \ the security completely.\n   Data integrity covers the entire SCSP payload.\
    \ This guarantees that\n   the message was not modified and the source is authenticated\
    \ as well.\n   If authentication extension is not used or if the security is\n\
    \   compromised, then SCSP servers are liable to both spoofing attacks,\n   active\
    \ attacks and passive attacks.\n   There is no mechanism to encrypt the messages.\
    \ It is assumed that a\n   standard layer 3 confidentiality mechanism will be\
    \ used to encrypt\n   and decrypt messages.  As integrity is calculated on an\
    \ SCSP message\n   and not on each record, there is an implied trust between all\
    \ the\n   servers in a domain. It is recommend to use the security extension\n\
    \   between all the servers in a domain and not just a subset servers.\n   Any\
    \ SCSP server is susceptible to Denial of Service (DOS) attacks. A\n   rouge host\
    \ can inundate its neighboring SCSP server with SCSP\n   packets. However, if\
    \ the authentication option is used, SCSP\n   databases will not become corrupted,\
    \ as the bogus packets will be\n   discarded when the authentication check fails.\n\
    \   Due to the pairwise authentication model of SCSP, the information\n   received\
    \ from any properly authenticated server is trusted and\n   propagated throughout\
    \ the server group.  Consequently, if security of\n   any SCSP server is compromised,\
    \ the entire database becomes\n   vulnerable to curruption originating from the\
    \ compromised server.\n"
- title: B.3.2  SCSP Vendor-Private Extension
  contents:
  - "B.3.2  SCSP Vendor-Private Extension\n    Type = 2\n    Length = variable\n \
    \  The SCSP Vendor-Private Extension is carried in SCSP packets to\n   convey\
    \ vendor-private information between an LS and a DCS in the same\n   SG and is\
    \ thus of limited use.  If a finer granularity (e.g., CSA\n   record level) is\
    \ desired then then given client/server protocol\n   specific SCSP document MUST\
    \ define such a mechanism.  Obviously,\n   however, such a protocol specific mechanism\
    \ might look exactly like\n   this extension.  The Vendor Private Extension MAY\
    \ NOT appear more\n   than once in an SCSP packet for a given Vendor ID value.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Vendor ID                    |  Data....     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Vendor ID\n     802 Vendor ID as assigned by the IEEE [7].\n   Data\n    \
    \ The remaining octets after the Vendor ID in the payload are\n     vendor-dependent\
    \ data.\n   If the receiver does not handle this extension, or does not match\
    \ the\n   Vendor ID in the extension then the extension may be completely\n  \
    \ ignored by the receiver.\n"
- title: C. IANA Considerations
  contents:
  - "C. IANA Considerations\n   Any and all requests for value assignment from the\
    \ various number\n   spaces described in this document require proper documentation.\n\
    \   Possible forms of documentation include, but are not limited to, RFCs\n  \
    \ or the product of another cooperative standards body (e.g., the MPOA\n   and\
    \ LANE subworking group of the ATM Forum). Other requests may also\n   be accepted,\
    \ under the advice of a \"designated expert\". (Contact the\n   IANA for the contact\
    \ information of the current expert.)\n"
- title: References
  contents:
  - "References\n   [1] Laubach, M., and J. Halpern, \"Classical IP and ARP over ATM\"\
    ,\n   Laubach, RFC 2225, April 1998.\n   [2] Luciani, J., Katz, D., Piscitello,\
    \ D., Cole, B., and N.\n   Doraswamy, \"NMBA Next Hop Resolution Protocol (NHRP)\"\
    , RFC 2332,\n   April 1998.\n   [3] Moy, J., \"OSPF Version 2\", STD 54, RFC 2328,\
    \ April 1998.\n   [4] \"P-NNI V1\", Dykeman, Goguen, 1996.\n   [5] Armitage, G.,\
    \ \"Support for Multicast over UNI 3.0/3.1 based ATM\n   Networks\", RFC 2022,\
    \ November 1996.\n   [6] Keene, \"LAN Emulation over ATM Version 2 - LNNI specification\"\
    ,\n   btd-lane-lnni-02.08\n   [7] Reynolds, J., and J. Postel, \"Assigned Numbers\"\
    , STD 2, RFC 1700,\n   October 1994.\n   [8] Luciani, J., \"A Distributed NHRP\
    \ Service Using SCSP\", RFC 2335,\n   April 1998.\n   [9] Luciani, J., \"A Distributed\
    \ ATMARP Service Using SCSP\", Work In\n   Progress.\n   [10] Bradner, S., \"\
    Key words for use in RFCs to Indicate Requirement\n   Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [11] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed\
    \ Hashing\n   for Message Authentication\", RFC 2104, February 1997.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   This memo is a distillation of issues raised during private\n\
    \   discussions, on the IP-ATM mailing list, and during the Dallas IETF\n   (12/95).\
    \ Thanks to all who have contributed but particular thanks to\n   following people\
    \ (in no particular order): Barbara Fox of Harris and\n   Jeffries; Colin Verrilli\
    \ of IBM; Raj Nair, and Matthew Doar of Ascom\n   Nexion; Andy Malis of Cascade;\
    \ Andre Fredette of Bay Networks; James\n   Watt of Newbridge; and Carl Marcinik\
    \ of Fore.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   James V. Luciani\n   Bay Networks, Inc.\n   3 Federal\
    \ Street, BL3-03\n   Billerica, MA  01821\n   Phone: +1-978-916-4734\n   EMail:\
    \ luciani@baynetworks.com\n   Grenville Armitage\n   Bell Labs Lucent Technologies\n\
    \   101 Crawfords Corner Road\n   Holmdel, NJ 07733\n   Phone: +1 201 829 2635\n\
    \   EMail: gja@lucent.com\n   Joel M. Halpern\n   Newbridge Networks Corp.\n \
    \  593 Herndon Parkway\n   Herndon, VA 22070-5241\n   Phone: +1-703-708-5954\n\
    \   EMail: jhalpern@Newbridge.COM\n   Naganand Doraswamy\n   Bay Networks, Inc.\n\
    \   3 Federal St, BL3-03\n   Billerice, MA 01821\n   Phone: +1-978-916-1323\n\
    \   EMail: naganand@baynetworks.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
