- title: __initial_text__
  contents:
  - '       Recommendations for Transport-Protocol Port Randomization

    '
- title: Abstract
  contents:
  - "Abstract\n   During the last few years, awareness has been raised about a number\n\
    \   of \"blind\" attacks that can be performed against the Transmission\n   Control\
    \ Protocol (TCP) and similar protocols.  The consequences of\n   these attacks\
    \ range from throughput reduction to broken connections\n   or data corruption.\
    \  These attacks rely on the attacker's ability to\n   guess or know the five-tuple\
    \ (Protocol, Source Address, Destination\n   Address, Source Port, Destination\
    \ Port) that identifies the transport\n   protocol instance to be attacked.  This\
    \ document describes a number\n   of simple and efficient methods for the selection\
    \ of the client port\n   number, such that the possibility of an attacker guessing\
    \ the exact\n   value is reduced.  While this is not a replacement for cryptographic\n\
    \   methods for protecting the transport-protocol instance, the\n   aforementioned\
    \ port selection algorithms provide improved security\n   with very little effort\
    \ and without any key management overhead.  The\n   algorithms described in this\
    \ document are local policies that may be\n   incrementally deployed and that\
    \ do not violate the specifications of\n   any of the transport protocols that\
    \ may benefit from them, such as\n   TCP, UDP, UDP-lite, Stream Control Transmission\
    \ Protocol (SCTP),\n   Datagram Congestion Control Protocol (DCCP), and RTP (provided\
    \ that\n   the RTP application explicitly signals the RTP and RTCP port\n   numbers).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo documents an Internet Best Current Practice.\n\
    \   This document is a product of the Internet Engineering Task Force\n   (IETF).\
    \  It represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   BCPs is available in Section\
    \ 2 of RFC 5741.\n   Information about the current status of this document, any\
    \ errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6056.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n   2.  Ephemeral Ports  . . . . . . . . . . . . . . . . . .\
    \ . . . . .  5\n     2.1.  Traditional Ephemeral Port Range . . . . . . . . .\
    \ . . . .  5\n     2.2.  Ephemeral Port Selection . . . . . . . . . . . . . .\
    \ . . .  6\n     2.3.  Collision of instance-ids  . . . . . . . . . . . . . .\
    \ . .  7\n   3.  Obfuscating the Ephemeral Port Selection . . . . . . . . . .\
    \ .  8\n     3.1.  Characteristics of a Good Algorithm for the\n           Obfuscation\
    \ of the Ephemeral Port Selection  . . . . . . .  8\n     3.2.  Ephemeral Port\
    \ Number Range  . . . . . . . . . . . . . . . 10\n     3.3.  Algorithms for the\
    \ Obfuscation of the Ephemeral Port\n           Selection  . . . . . . . . . .\
    \ . . . . . . . . . . . . . . 11\n       3.3.1.  Algorithm 1: Simple Port Randomization\
    \ Algorithm . . . 11\n       3.3.2.  Algorithm 2: Another Simple Port Randomization\n\
    \               Algorithm  . . . . . . . . . . . . . . . . . . . . . . 13\n  \
    \     3.3.3.  Algorithm 3: Simple Hash-Based Port Selection\n               Algorithm\
    \  . . . . . . . . . . . . . . . . . . . . . . 14\n       3.3.4.  Algorithm 4:\
    \ Double-Hash Port Selection Algorithm  . . 16\n       3.3.5.  Algorithm 5: Random-Increments\
    \ Port Selection\n               Algorithm  . . . . . . . . . . . . . . . . .\
    \ . . . . . 18\n     3.4.  Secret-Key Considerations for Hash-Based Port\n   \
    \        Selection Algorithms . . . . . . . . . . . . . . . . . . . 19\n     3.5.\
    \  Choosing an Ephemeral Port Selection Algorithm . . . . . . 20\n   4.  Interaction\
    \ with Network Address Port Translation (NAPT) . . . 22\n   5.  Security Considerations\
    \  . . . . . . . . . . . . . . . . . . . 23\n   6.  Acknowledgements . . . . .\
    \ . . . . . . . . . . . . . . . . . . 24\n   7.  References . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . 24\n     7.1.  Normative References . . .\
    \ . . . . . . . . . . . . . . . . 24\n     7.2.  Informative References . . .\
    \ . . . . . . . . . . . . . . . 25\n   Appendix A.  Survey of the Algorithms in\
    \ Use by Some Popular\n                Implementations . . . . . . . . . . . .\
    \ . . . . . . . 28\n     A.1.  FreeBSD  . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 28\n     A.2.  Linux  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . 28\n     A.3.  NetBSD . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 28\n     A.4.  OpenBSD  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 28\n     A.5.  OpenSolaris  . . . . . . . . . . . . . . . . . . . . .\
    \ . . 28\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Recently, awareness has been raised about a number of \"\
    blind\" attacks\n   (i.e., attacks that can be performed without the need to sniff\
    \ the\n   packets that correspond to the transport protocol instance to be\n \
    \  attacked) that can be performed against the Transmission Control\n   Protocol\
    \ (TCP) [RFC0793] and similar protocols.  The consequences of\n   these attacks\
    \ range from throughput reduction to broken connections\n   or data corruption\
    \ [RFC5927] [RFC4953] [Watson].\n   All these attacks rely on the attacker's ability\
    \ to guess or know the\n   five-tuple (Protocol, Source Address, Source port,\
    \ Destination\n   Address, Destination Port) that identifies the transport protocol\n\
    \   instance to be attacked.\n   Services are usually located at fixed, \"well-known\"\
    \ ports [IANA] at\n   the host supplying the service (the server).  Client applications\n\
    \   connecting to any such service will contact the server by specifying\n   the\
    \ server IP address and service port number.  The IP address and\n   port number\
    \ of the client are normally left unspecified by the client\n   application and\
    \ thus are chosen automatically by the client\n   networking stack.  Ports chosen\
    \ automatically by the networking stack\n   are known as ephemeral ports [Stevens].\n\
    \   While the server IP address, the well-known port, and the client IP\n   address\
    \ may be known by an attacker, the ephemeral port of the client\n   is usually\
    \ unknown and must be guessed.\n   This document describes a number of algorithms\
    \ for the selection of\n   ephemeral port numbers, such that the possibility of\
    \ an off-path\n   attacker guessing the exact value is reduced.  They are not\
    \ a\n   replacement for cryptographic methods of protecting a transport-\n   protocol\
    \ instance such as IPsec [RFC4301], the TCP MD5 signature\n   option [RFC2385],\
    \ or the TCP Authentication Option [RFC5925].  For\n   example, they do not provide\
    \ any mitigation in those scenarios in\n   which the attacker is able to sniff\
    \ the packets that correspond to\n   the transport protocol instance to be attacked.\
    \  However, the\n   proposed algorithms provide improved resistance to off-path\
    \ attacks\n   with very little effort and without any key management overhead.\n\
    \   The mechanisms described in this document are local modifications\n   that\
    \ may be incrementally deployed, and that do not violate the\n   specifications\
    \ of any of the transport protocols that may benefit\n   from them, such as TCP\
    \ [RFC0793], UDP [RFC0768], SCTP [RFC4960], DCCP\n   [RFC4340], UDP-lite [RFC3828],\
    \ and RTP [RFC3550] (provided the RTP\n   application explicitly signals the RTP\
    \ and RTCP port numbers with,\n   e.g., [RFC3605]).\n   Since these mechanisms\
    \ are obfuscation techniques, focus has been on\n   a reasonable compromise between\
    \ the level of obfuscation and the ease\n   of implementation.  Thus, the algorithms\
    \ must be computationally\n   efficient and not require substantial state.\n \
    \  We note that while the technique of mitigating \"blind\" attacks by\n   obfuscating\
    \ the ephemeral port selection is well-known as \"port\n   randomization\", the\
    \ goal of the algorithms described in this document\n   is to reduce the chances\
    \ of an attacker guessing the ephemeral ports\n   selected for new transport protocol\
    \ instances, rather than to\n   actually produce mathematically random sequences\
    \ of ephemeral ports.\n   Throughout this document, we will use the term \"transport-protocol\n\
    \   instance\" as a general term to refer to an instantiation of a\n   transport\
    \ protocol (e.g., a \"connection\" in the case of connection-\n   oriented transport\
    \ protocols) and the term \"instance-id\" as a short-\n   handle to refer to the\
    \ group of values that identify a transport-\n   protocol instance (e.g., in the\
    \ case of TCP, the five-tuple\n   {Protocol, IP Source Address, TCP Source Port,\
    \ IP Destination\n   Address, TCP Destination Port}).\n   The key words \"MUST\"\
    , \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to\
    \ be interpreted as described in RFC 2119 [RFC2119].\n"
- title: 2.  Ephemeral Ports
  contents:
  - '2.  Ephemeral Ports

    '
- title: 2.1.  Traditional Ephemeral Port Range
  contents:
  - "2.1.  Traditional Ephemeral Port Range\n   The Internet Assigned Numbers Authority\
    \ (IANA) assigns the unique\n   parameters and values used in protocols developed\
    \ by the Internet\n   Engineering Task Force (IETF), including well-known ports\
    \ [IANA].\n   IANA has reserved the following use of the 16-bit port range of\
    \ TCP\n   and UDP:\n   o  The Well-Known Ports, 0 through 1023.\n   o  The Registered\
    \ Ports, 1024 through 49151\n   o  The Dynamic and/or Private Ports, 49152 through\
    \ 65535\n   The dynamic port range defined by IANA consists of the 49152-65535\n\
    \   range, and is meant for the selection of ephemeral ports.\n"
- title: 2.2.  Ephemeral Port Selection
  contents:
  - "2.2.  Ephemeral Port Selection\n   As each communication instance is identified\
    \ by the five-tuple\n   {protocol, local IP address, local port, remote IP address,\
    \ remote\n   port}, the selection of ephemeral port numbers must result in a\n\
    \   unique five-tuple.\n   Selection of ephemeral ports such that they result\
    \ in unique\n   instance-ids (five-tuples) is handled by some implementations\
    \ by\n   having a per-protocol global \"next_ephemeral\" variable that is equal\n\
    \   to the previously chosen ephemeral port + 1, i.e., the selection\n   process\
    \ is:\n       /* Initialization at system boot time. Could be random */\n    \
    \   next_ephemeral = min_ephemeral;\n       /* Ephemeral port selection function\
    \ */\n       count = max_ephemeral - min_ephemeral + 1;\n       do {\n       \
    \    port = next_ephemeral;\n           if (next_ephemeral == max_ephemeral) {\n\
    \               next_ephemeral = min_ephemeral;\n           } else {\n       \
    \        next_ephemeral++;\n           }\n           if (check_suitable_port(port))\n\
    \               return port;\n           count--;\n       } while (count > 0);\n\
    \       return ERROR;\n                    Traditional BSD Port Selection Algorithm\n\
    \   Note:\n      check_suitable_port() is a function that checks whether the\n\
    \      resulting port number is acceptable as an ephemeral port.  That\n     \
    \ is, it checks whether the resulting port number is unique and may,\n      in\
    \ addition, check that the port number is not in use for a\n      connection in\
    \ the LISTEN or CLOSED states and that the port number\n      is not in the list\
    \ of port numbers that should not be allocated as\n      ephemeral ports.  In\
    \ BSD-derived systems, the\n      check_suitable_port() would correspond to the\
    \ in_pcblookup_local()\n      function, where all the necessary checks would be\
    \ performed.\n   This algorithm works adequately provided that the number of\n\
    \   transport-protocol instances (for each transport protocol) that have\n   a\
    \ lifetime longer than it takes to exhaust the total ephemeral port\n   range\
    \ is small, so that collisions of instance-ids are rare.\n   However, this method\
    \ has the drawback that the \"next_ephemeral\"\n   variable and thus the ephemeral\
    \ port range is shared between all\n   transport-protocol instances, and the next\
    \ ports chosen by the client\n   are easy to predict.  If an attacker operates\
    \ an \"innocent\" server to\n   which the client connects, it is easy to obtain\
    \ a reference point for\n   the current value of the \"next_ephemeral\" variable.\
    \  Additionally, if\n   an attacker could force a client to periodically establish,\
    \ e.g., a\n   new TCP connection to an attacker-controlled machine (or through\
    \ an\n   attacker-observable path), the attacker could subtract consecutive\n\
    \   source port values to obtain the number of outgoing TCP connections\n   established\
    \ globally by the target host within that time period (up\n   to wrap-around issues\
    \ and instance-id collisions, of course).\n"
- title: 2.3.  Collision of instance-ids
  contents:
  - "2.3.  Collision of instance-ids\n   While it is possible for the ephemeral port\
    \ selection algorithm to\n   verify that the selected port number results in a\
    \ instance-id that is\n   not currently in use by that system, the resulting five-tuple\
    \ may\n   still be in use at a remote system.  For example, consider a scenario\n\
    \   in which a client establishes a TCP connection with a remote web\n   server,\
    \ and the web server performs the active close on the\n   connection.  While the\
    \ state information for this connection will\n   disappear at the client side\
    \ (that is, the connection will be moved\n   to the fictional CLOSED state), the\
    \ instance-id will remain in the\n   TIME-WAIT state at the web server for 2*MSL\
    \ (Maximum Segment\n   Lifetime).  If the same client tried to create a new incarnation\
    \ of\n   the previous connection (that is, a connection with the same\n   instance-id\
    \ as the one in the TIME_WAIT state at the server), an\n   instance-id \"collision\"\
    \ would occur.  The effect of these collisions\n   range from connection-establishment\
    \ failures to TIME-WAIT state\n   assassination (with the potential of data corruption)\
    \ [RFC1337].  In\n   scenarios in which a specific client establishes TCP connections\
    \ with\n   a specific service at a server, these problems become evident.\n  \
    \ Therefore, an ephemeral port selection algorithm should ideally\n   minimize\
    \ the rate of instance-id collisions.\n   A simple approach to minimize the rate\
    \ of these collisions would be\n   to choose port numbers incrementally, so that\
    \ a given port number\n   would not be reused until the rest of the port numbers\
    \ in the\n   ephemeral port range have been used for a transport protocol\n  \
    \ instance.  However, if a single global variable were used to keep\n   track\
    \ of the last ephemeral port selected, ephemeral port numbers\n   would be trivially\
    \ predictable, thus making it easier for an off-path\n   attacker to \"guess\"\
    \ the instance-id in use by a target transport-\n   protocol instance.  Sections\
    \ 3.3.3 and 3.3.4 describe algorithms that\n   select port numbers incrementally,\
    \ while still making it difficult\n   for an off-path attacker to predict the\
    \ ephemeral ports used for\n   future transport-protocol instances.\n   A simple\
    \ but inefficient approach to minimize the rate of collisions\n   of instance-ids\
    \ would be, e.g., in the case of TCP, for both\n   endpoints of a TCP connection\
    \ to keep state about recent connections\n   (e.g., have both endpoints end up\
    \ in the TIME-WAIT state).\n"
- title: 3.  Obfuscating the Ephemeral Port Selection
  contents:
  - '3.  Obfuscating the Ephemeral Port Selection

    '
- title: 3.1.  Characteristics of a Good Algorithm for the Obfuscation of the
  contents:
  - "3.1.  Characteristics of a Good Algorithm for the Obfuscation of the\n      Ephemeral\
    \ Port Selection\n   There are several factors to consider when designing an algorithm\
    \ for\n   selecting ephemeral ports, which include:\n   o  Minimizing the predictability\
    \ of the ephemeral port numbers used\n      for future transport-protocol instances.\n\
    \   o  Minimizing collisions of instance-ids.\n   o  Avoiding conflict with applications\
    \ that depend on the use of\n      specific port numbers.\n   Given the goal of\
    \ improving the transport protocol's resistance to\n   attack by obfuscation of\
    \ the instance-id selection, it is key to\n   minimize the predictability of the\
    \ ephemeral ports that will be\n   selected for new transport-protocol instances.\
    \  While the obvious\n   approach to address this requirement would be to select\
    \ the ephemeral\n   ports by simply picking a random value within the chosen port\
    \ number\n   range, this straightforward policy may lead to collisions of\n  \
    \ instance-ids, which could lead to the interoperability problems\n   (e.g., delays\
    \ in the establishment of new connections, failures in\n   connection establishment,\
    \ or data corruption) discussed in\n   Section 2.3.  As discussed in Section 1,\
    \ it is worth noting that\n   while the technique of mitigating \"blind\" attacks\
    \ by obfuscating the\n   ephemeral port selection is well-known as \"port randomization\"\
    , the\n   goal of the algorithms described in this document is to reduce the\n\
    \   chances that an attacker will guess the ephemeral ports selected for\n   new\
    \ transport-protocol instances, rather than to actually produce\n   sequences\
    \ of mathematically random ephemeral port numbers.\n   It is also worth noting\
    \ that, provided adequate algorithms are in\n   use, the larger the range from\
    \ which ephemeral ports are selected,\n   the smaller the chances of an attacker\
    \ are to guess the selected port\n   number.\n   In scenarios in which a specific\
    \ client establishes transport-\n   protocol instances with a specific service\
    \ at a server, the problems\n   described in Section 2.3 become evident.  A good\
    \ algorithm to\n   minimize the collisions of instance-ids would consider the\
    \ time a\n   given five-tuple was last used, and would avoid reusing the last\n\
    \   recently used five-tuples.  A simple approach to minimize the rate of\n  \
    \ collisions would be to choose port numbers incrementally, so that a\n   given\
    \ port number would not be reused until the rest of the port\n   numbers in the\
    \ ephemeral port range have been used for a transport-\n   protocol instance.\
    \  However, if a single global variable were used to\n   keep track of the last\
    \ ephemeral port selected, ephemeral port\n   numbers would be trivially predictable.\n\
    \   It is important to note that a number of applications rely on binding\n  \
    \ specific port numbers that may be within the ephemeral port range.\n   If such\
    \ an application were run while the corresponding port number\n   were in use,\
    \ the application would fail.  Therefore, ephemeral port\n   selection algorithms\
    \ avoid using those port numbers.\n   Port numbers that are currently in use by\
    \ a TCP in the LISTEN state\n   should not be allowed for use as ephemeral ports.\
    \  If this rule is\n   not complied with, an attacker could potentially \"steal\"\
    \ an incoming\n   connection to a local server application in at least two different\n\
    \   ways.  Firstly, an attacker could issue a connection request to the\n   victim\
    \ client at roughly the same time the client tries to connect to\n   the victim\
    \ server application [CPNI-TCP] [TCP-SEC].  If the SYN\n   segment corresponding\
    \ to the attacker's connection request and the\n   SYN segment corresponding to\
    \ the victim client \"cross each other in\n   the network\", and provided the\
    \ attacker is able to know or guess the\n   ephemeral port used by the client,\
    \ a TCP \"simultaneous open\" scenario\n   would take place, and the incoming\
    \ connection request sent by the\n   client would be matched with the attacker's\
    \ socket rather than with\n   the victim server application's socket.  Secondly,\
    \ an attacker could\n   specify a more specific socket than the \"victim\" socket\
    \ (e.g.,\n   specify both the local IP address and the local TCP port), and thus\n\
    \   incoming SYN segments matching the attacker's socket would be\n   delivered\
    \ to the attacker, rather than to the \"victim\" socket (see\n   Section 10.1\
    \ of [CPNI-TCP]).\n   It should be noted that most applications based on popular\n\
    \   implementations of the TCP API (such as the Sockets API) perform\n   \"passive\
    \ opens\" in three steps.  Firstly, the application obtains a\n   file descriptor\
    \ to be used for inter-process communication (e.g., by\n   issuing a socket()\
    \ call).  Secondly, the application binds the file\n   descriptor to a local TCP\
    \ port number (e.g., by issuing a bind()\n   call), thus creating a TCP in the\
    \ fictional CLOSED state.  Thirdly,\n   the aforementioned TCP is put in the LISTEN\
    \ state (e.g., by issuing a\n   listen() call).  As a result, with such an implementation\
    \ of the TCP\n   API, even if port numbers in use for TCPs in the LISTEN state\
    \ were\n   not allowed for use as ephemeral ports, there is a window of time\n\
    \   between the second and the third steps in which an attacker could be\n   allowed\
    \ to select a port number that would be later used for\n   listening to incoming\
    \ connections.  Therefore, these implementations\n   of the TCP API should enforce\
    \ a stricter requirement for the\n   allocation of port numbers: port numbers\
    \ that are in use by a TCP in\n   the LISTEN or CLOSED states should not be allowed\
    \ for allocation as\n   ephemeral ports [CPNI-TCP] [TCP-SEC].\n   The aforementioned\
    \ issue does not affect SCTP, since most SCTP\n   implementations do not allow\
    \ a socket to be bound to the same port\n   number unless a specific socket option\
    \ (SCTP_REUSE_PORT) is issued on\n   the socket (i.e., this behavior needs to\
    \ be explicitly allowed\n   beforehand).  An example of a typical SCTP socket\
    \ API can be found in\n   [SCTP-SOCKET].\n   DCCP is not affected by the exploitation\
    \ of \"simultaneous opens\" to\n   \"steal\" incoming connections, as the server\
    \ and the client state\n   machines are different [RFC4340].  However, it may\
    \ be affected by the\n   vector involving binding a more specific socket.  As\
    \ a result, those\n   tuples {local IP address, local port, Service Code} that\
    \ are in use\n   by a local socket should not be allowed for allocation as ephemeral\n\
    \   ports.\n"
- title: 3.2.  Ephemeral Port Number Range
  contents:
  - "3.2.  Ephemeral Port Number Range\n   As mentioned in Section 2.1, the dynamic\
    \ ports consist of the range\n   49152-65535.  However, ephemeral port selection\
    \ algorithms should use\n   the whole range 1024-65535.\n   This range includes\
    \ the IANA Registered Ports; thus, some of these\n   port numbers may be needed\
    \ for providing a particular service at the\n   local host, which could result\
    \ in the problems discussed in\n   Section 3.1.  As a result, port numbers that\
    \ may be needed for\n   providing a particular service at the local host SHOULD\
    \ NOT be\n   included in the pool of port numbers available for ephemeral port\n\
    \   randomization.  If the host does not provide a particular service,\n   the\
    \ port can be safely allocated to ordinary processes.\n   A possible workaround\
    \ for this potential problem would be to maintain\n   a local list of the port\
    \ numbers that should not be allocated as\n   ephemeral ports.  Thus, before allocating\
    \ a port number, the\n   ephemeral port selection function would check this list,\
    \ avoiding the\n   allocation of ports that may be needed for specific applications.\n\
    \   Rather than naively excluding all the registered ports,\n   administrators\
    \ should identify services that may be offered by the\n   local host and SHOULD\
    \ exclude only the corresponding registered\n   ports.\n   Ephemeral port selection\
    \ algorithms SHOULD use the largest possible\n   port range, since this reduces\
    \ the chances of an off-path attacker of\n   guessing the selected port numbers.\n"
- title: 3.3.  Algorithms for the Obfuscation of the Ephemeral Port Selection
  contents:
  - "3.3.  Algorithms for the Obfuscation of the Ephemeral Port Selection\n   Ephemeral\
    \ port selection algorithms SHOULD obfuscate the selection of\n   their ephemeral\
    \ ports, since this helps to mitigate a number of\n   attacks that depend on the\
    \ attacker's ability to guess or know the\n   five-tuple that identifies the transport-protocol\
    \ instance to be\n   attacked.\n   The following subsections describe a number\
    \ of algorithms that could\n   be implemented in order to obfuscate the selection\
    \ of ephemeral port\n   numbers.\n"
- title: '3.3.1.  Algorithm 1: Simple Port Randomization Algorithm'
  contents:
  - "3.3.1.  Algorithm 1: Simple Port Randomization Algorithm\n   In order to address\
    \ the security issues discussed in Sections 1 and\n   2.2, a number of systems\
    \ have implemented simple ephemeral port\n   number randomization, as follows:\n\
    \       /* Ephemeral port selection function */\n       num_ephemeral = max_ephemeral\
    \ - min_ephemeral + 1;\n       next_ephemeral = min_ephemeral + (random() % num_ephemeral);\n\
    \       count = num_ephemeral;\n       do {\n           if(check_suitable_port(port))\n\
    \                   return next_ephemeral;\n           if (next_ephemeral == max_ephemeral)\
    \ {\n               next_ephemeral = min_ephemeral;\n           } else {\n   \
    \            next_ephemeral++;\n           }\n           count--;\n       } while\
    \ (count > 0);\n       return ERROR;\n                              Algorithm\
    \ 1\n   Note:\n      random() is a function that returns a 32-bit pseudo-random\n\
    \      unsigned integer number.  Note that the output needs to be\n      unpredictable,\
    \ and typical implementations of POSIX random()\n      function do not necessarily\
    \ meet this requirement.  See [RFC4086]\n      for randomness requirements for\
    \ security.\n      All the variables (in this and all the algorithms discussed\
    \ in\n      this document) are unsigned integers.\n   Since the initially chosen\
    \ port may already be in use with IP\n   addresses and server port that are identical\
    \ to the ones being used\n   for the socket for which the ephemeral port is to\
    \ be selected, the\n   resulting five-tuple might not be unique.  Therefore, multiple\
    \ ports\n   may have to be tried and verified against all existing transport-\n\
    \   protocol instances before a port can be chosen.\n   Web proxy servers, Network\
    \ Address Port Translators (NAPTs)\n   [RFC2663], and other middleboxes aggregate\
    \ multiple peers into the\n   same port space and thus increase the population\
    \ of used ephemeral\n   ports, and hence the chances of collisions of instance-ids.\
    \  However,\n   [Allman] has shown that at least in the network scenarios used\
    \ for\n   measuring the collision properties of the algorithms described in\n\
    \   this document, the collision rate resulting from the use of the\n   aforementioned\
    \ middleboxes is nevertheless very low.\n   Since this algorithm performs port\
    \ selection without taking into\n   account the port numbers previously chosen,\
    \ it has the potential of\n   reusing port numbers too quickly, thus possibly\
    \ leading to collisions\n   of instance-ids.  Even if a given instance-id is verified\
    \ to be\n   unique by the port selection algorithm, the instance-id might still\n\
    \   be in use at the remote system.  In such a scenario, a connection\n   request\
    \ could possibly fail ([Silbersack] describes this problem for\n   the TCP case).\n\
    \   However, this algorithm is biased towards the first available port\n   after\
    \ a sequence of unavailable port numbers.  If the local list of\n   registered\
    \ port numbers that should not be allocated as ephemeral\n   ports (as described\
    \ in Section 3.2) is significant, an attacker may\n   actually have a significantly\
    \ better chance of guessing a port\n   number.\n   This algorithm selects ephemeral\
    \ port numbers randomly and thus\n   reduces the chances that an attacker will\
    \ guess the ephemeral port\n   selected for a target transport-protocol instance.\
    \  Additionally, it\n   prevents attackers from obtaining the number of outgoing\
    \ transport-\n   protocol instances (e.g., TCP connections) established by the\
    \ client\n   in some period of time.\n"
- title: '3.3.2.  Algorithm 2: Another Simple Port Randomization Algorithm'
  contents:
  - "3.3.2.  Algorithm 2: Another Simple Port Randomization Algorithm\n   The following\
    \ pseudo-code illustrates another algorithm for selecting\n   a random port number,\
    \ in which in the event a local instance-id\n   collision is detected, another\
    \ port number is selected randomly:\n       /* Ephemeral port selection function\
    \ */\n       num_ephemeral = max_ephemeral - min_ephemeral + 1;\n       next_ephemeral\
    \ = min_ephemeral + (random() % num_ephemeral);\n       count = num_ephemeral;\n\
    \       do {\n           if(check_suitable_port(port))\n                   return\
    \ next_ephemeral;\n           next_ephemeral = min_ephemeral + (random() % num_ephemeral);\n\
    \           count--;\n       } while (count > 0);\n       return ERROR;\n    \
    \                          Algorithm 2\n   When there are a large number of port\
    \ numbers already in use for the\n   same destination endpoint, this algorithm\
    \ might be unable (with a\n   very small remaining probability) to select an ephemeral\
    \ port (i.e.,\n   it would return \"ERROR\"), even if there are still a few port\
    \ numbers\n   available that would result in unique five-tuples.  However, the\n\
    \   results in [Allman] have shown that in common scenarios, one port\n   choice\
    \ is enough, and in most cases where more than one choice is\n   needed, two choices\
    \ suffice.  Therefore, in those scenarios this\n   would not be problem.\n"
- title: '3.3.3.  Algorithm 3: Simple Hash-Based Port Selection Algorithm'
  contents:
  - "3.3.3.  Algorithm 3: Simple Hash-Based Port Selection Algorithm\n   We would\
    \ like to achieve the port-reuse properties of the traditional\n   BSD port selection\
    \ algorithm (described in Section 2.2), while at the\n   same time achieve the\
    \ unpredictability properties of Algorithm 1 and\n   Algorithm 2.\n   Ideally,\
    \ we would like a \"next_ephemeral\" value for each set of\n   (local IP address,\
    \ remote IP addresses, remote port), so that the\n   port-reuse frequency is the\
    \ lowest possible.  Each of these\n   \"next_ephemeral\" variables should be initialized\
    \ with random values\n   within the ephemeral port range and, together, these\
    \ would thus\n   separate the ephemeral port space of the transport-protocol instances\n\
    \   on a \"per-destination endpoint\" basis (this \"separation of the\n   ephemeral\
    \ port space\" means that transport-protocol instances with\n   different remote\
    \ endpoints will not have different sequences of port\n   numbers, i.e., will\
    \ not be part of the same ephemeral port sequence\n   as in the case of the traditional\
    \ BSD ephemeral port selection\n   algorithm).  Since we do not want to maintain\
    \ in memory all these\n   \"next_ephemeral\" values, we propose an offset function\
    \ F() that can\n   be computed from the local IP address, remote IP address, remote\n\
    \   port, and a secret key.  F() will yield (practically) different\n   values\
    \ for each set of arguments, i.e.:\n       /* Initialization at system boot time.\
    \ Could be random. */\n       next_ephemeral = 0;\n       /* Ephemeral port selection\
    \ function */\n       num_ephemeral = max_ephemeral - min_ephemeral + 1;\n   \
    \    offset = F(local_IP, remote_IP, remote_port, secret_key);\n       count =\
    \ num_ephemeral;\n       do {\n           port = min_ephemeral +\n           \
    \       (next_ephemeral + offset) % num_ephemeral;\n           next_ephemeral++;\n\
    \           if(check_suitable_port(port))\n               return port;\n     \
    \      count--;\n       } while (count > 0);\n       return ERROR;\n         \
    \                     Algorithm 3\n   In other words, the function F() provides\
    \ a \"per-destination\n   endpoint\" fixed offset within the global ephemeral\
    \ port range.  Both\n   the \"offset\" and \"next_ephemeral\" variables may take\
    \ any value within\n   the storage type range since we are restricting the resulting\
    \ port in\n   a similar way as in Algorithm 1 (described in Section 3.3.1).  This\n\
    \   allows us to simply increment the \"next_ephemeral\" variable and rely\n \
    \  on the unsigned integer to wrap around.\n   The function F() should be a cryptographic\
    \ hash function like MD5\n   [RFC1321].  The function should use both IP addresses,\
    \ the remote\n   port, and a secret key value to compute the offset.  The remote\
    \ IP\n   address is the primary separator and must be included in the offset\n\
    \   calculation.  The local IP address and remote port may in some cases\n   be\
    \ constant and thus not improve the ephemeral port space separation;\n   however,\
    \ they should also be included in the offset calculation.\n   Cryptographic algorithms\
    \ stronger than, e.g., MD5 should not be\n   necessary, given that Algorithm 3\
    \ is simply a technique for the\n   obfuscation of the selection of ephemeral\
    \ ports.  The secret should\n   be chosen to be as random as possible (see [RFC4086]\
    \ for\n   recommendations on choosing secrets).\n   Note that on multiuser systems,\
    \ the function F() could include user-\n   specific information, thereby providing\
    \ protection not only on a\n   host-to-host basis, but on a user to service basis.\
    \  In fact, any\n   identifier of the remote entity could be used, depending on\n\
    \   availability and the granularity requested.  With SCTP, both\n   hostnames\
    \ and alternative IP addresses may be included in the\n   association negotiation,\
    \ and either of these could be used in the\n   offset function F().\n   When multiple\
    \ unique identifiers are available, any of these can be\n   chosen as input to\
    \ the offset function F() since they all uniquely\n   identify the remote entity.\
    \  However, in cases like SCTP where the\n   ephemeral port must be unique across\
    \ all IP address permutations, we\n   should ideally always use the same IP address\
    \ to get a single\n   starting offset for each association negotiation with a\
    \ given remote\n   entity to minimize the possibility of collisions.  A simple\
    \ numerical\n   sorting of the IP addresses and always using the numerically lowest\n\
    \   could achieve this.  However, since most protocols will generally\n   report\
    \ the same IP addresses in the same order in each association\n   setup, this\
    \ sorting is most likely not necessary and the \"first one\"\n   can simply be\
    \ used.\n   The ability of hostnames to uniquely define hosts can be discussed,\n\
    \   and since SCTP always includes at least one IP address, we recommend\n   using\
    \ this as input to the offset function F() and ignoring hostname\n   chunks when\
    \ searching for ephemeral ports.\n   It should be noted that, as this algorithm\
    \ uses a global counter\n   (\"next_ephemeral\") for selecting ephemeral ports,\
    \ if an attacker\n   could, e.g., force a client to periodically establish a new\
    \ TCP\n   connection to an attacker-controlled machine (or through an attacker-\n\
    \   observable path), the attacker could subtract consecutive source port\n  \
    \ values to obtain the number of outgoing TCP connections established\n   globally\
    \ by the target host within that time period (up to wrap-\n   around issues and\
    \ five-tuple collisions, of course).\n"
- title: '3.3.4.  Algorithm 4: Double-Hash Port Selection Algorithm'
  contents:
  - "3.3.4.  Algorithm 4: Double-Hash Port Selection Algorithm\n   A trade-off between\
    \ maintaining a single global \"next_ephemeral\"\n   variable and maintaining\
    \ 2**N \"next_ephemeral\" variables (where N is\n   the width of the result of\
    \ F()) could be achieved as follows.  The\n   system would keep an array of TABLE_LENGTH\
    \ short integers, which\n   would provide a separation of the increment of the\
    \ \"next_ephemeral\"\n   variable.  This improvement could be incorporated into\
    \ Algorithm 3 as\n   follows:\n     /* Initialization at system boot time */\n\
    \     for(i = 0; i < TABLE_LENGTH; i++)\n         table[i] = random() % 65536;\n\
    \     /* Ephemeral port selection function */\n     num_ephemeral = max_ephemeral\
    \ - min_ephemeral + 1;\n     offset = F(local_IP, remote_IP, remote_port, secret_key1);\n\
    \     index = G(local_IP, remote_IP, remote_port, secret_key2);\n     count =\
    \ num_ephemeral;\n     do {\n         port = min_ephemeral + (offset + table[index])\
    \ % num_ephemeral;\n         table[index]++;\n         if(check_suitable_port(port))\n\
    \             return port;\n        count--;\n     } while (count > 0);\n    \
    \ return ERROR;\n                            Algorithm 4\n   \"table[]\" could\
    \ be initialized with mathematically random values, as\n   indicated by the initialization\
    \ code in pseudo-code above.  The\n   function G() should be a cryptographic hash\
    \ function like MD5\n   [RFC1321].  It should use both IP addresses, the remote\
    \ port, and a\n   secret key value to compute a value between 0 and (TABLE_LENGTH-1).\n\
    \   Alternatively, G() could take an \"offset\" as input, and perform the\n  \
    \ exclusive-or (XOR) operation between all the bytes in \"offset\".\n   The array\
    \ \"table[]\" assures that successive transport-protocol\n   instances with the\
    \ same remote endpoint will use increasing ephemeral\n   port numbers.  However,\
    \ incrementation of the port numbers is\n   separated into TABLE_LENGTH different\
    \ spaces, and thus the port-reuse\n   frequency will be (probabilistically) lower\
    \ than that of Algorithm 3.\n   That is, a new transport-protocol instance with\
    \ some remote endpoint\n   will not necessarily cause the \"next_ephemeral\" variable\n\
    \   corresponding to other endpoints to be incremented.\n   It is interesting\
    \ to note that the size of \"table[]\" does not limit\n   the number of different\
    \ port sequences, but rather separates the\n   *increments* into TABLE_LENGTH\
    \ different spaces.  The port sequence\n   will result from adding the corresponding\
    \ entry of \"table[]\" to the\n   variable \"offset\", which selects the actual\
    \ port sequence (as in\n   Algorithm 3).  [Allman] has found that a TABLE_LENGTH\
    \ of 10 can\n   result in an improvement over Algorithm 3.  Further increasing\
    \ the\n   TABLE_LENGTH will increase the unpredictability of the resulting port\n\
    \   number, and possibly further decrease the collision rate.\n   An attacker\
    \ can perform traffic analysis for any \"increment space\"\n   into which the\
    \ attacker has \"visibility\" -- namely, the attacker can\n   force the client\
    \ to establish a transport-protocol instance whose\n   G(offset) identifies the\
    \ target \"increment space\".  However, the\n   attacker's ability to perform\
    \ traffic analysis is very reduced when\n   compared to the traditional BSD algorithm\
    \ (described in Section 2.2)\n   and Algorithm 3.  Additionally, an implementation\
    \ can further limit\n   the attacker's ability to perform traffic analysis by\
    \ further\n   separating the increment space (that is, using a larger value for\n\
    \   TABLE_LENGTH).\n"
- title: '3.3.5.  Algorithm 5: Random-Increments Port Selection Algorithm'
  contents:
  - "3.3.5.  Algorithm 5: Random-Increments Port Selection Algorithm\n   [Allman]\
    \ introduced another port selection algorithm, which offers a\n   middle ground\
    \ between the algorithms that select ephemeral ports\n   independently at random\
    \ (such as those described in Sections 3.3.1\n   and 3.3.2), and those that offer\
    \ obfuscation with less randomization\n   (such as those described in Sections\
    \ 3.3.3 and 3.3.4).\n     /* Initialization code at system boot time. */\n   \
    \  next_ephemeral = random() % 65536;   /* Initialization value */\n     N = 500;\
    \                             /* Determines the trade-off */\n     /* Ephemeral\
    \ port selection function */\n     num_ephemeral = max_ephemeral - min_ephemeral\
    \ + 1;\n     count = num_ephemeral;\n     do {\n         next_ephemeral = next_ephemeral\
    \ + (random() % N) + 1;\n         port = min_ephemeral + (next_ephemeral % num_ephemeral);\n\
    \         if(check_suitable_port(port))\n                 return port;\n     \
    \     count--;\n     } while (count > 0);\n     return ERROR;\n              \
    \              Algorithm 5\n   This algorithm aims at producing a monotonically\
    \ increasing sequence\n   to prevent the collision of instance-ids, while avoiding\
    \ the use of\n   fixed increments, which would lead to trivially predictable\n\
    \   sequences.  The value \"N\" allows for direct control of the trade-off\n \
    \  between the level of unpredictability and the port-reuse frequency.\n   The\
    \ smaller the value of \"N\", the more similar this algorithm is to\n   the traditional\
    \ BSD port selection algorithm (described in\n   Section 2.2).  The larger the\
    \ value of \"N\", the more similar this\n   algorithm is to the algorithm described\
    \ in Section 3.3.1 of this\n   document.\n   When the port numbers wrap, there\
    \ is the risk of collisions of\n   instance-ids.  Therefore, \"N\" should be selected\
    \ according to the\n   following criteria:\n   o  It should maximize the wrapping\
    \ time of the ephemeral port space.\n   o  It should minimize collisions of instance-ids.\n\
    \   o  It should maximize the unpredictability of selected port numbers.\n   Clearly,\
    \ these are competing goals, and the decision of which value\n   of \"N\" to use\
    \ is a trade-off.  Therefore, the value of \"N\" should be\n   configurable so\
    \ that system administrators can make the trade-off for\n   themselves.\n"
- title: 3.4.  Secret-Key Considerations for Hash-Based Port Selection Algorithms
  contents:
  - "3.4.  Secret-Key Considerations for Hash-Based Port Selection Algorithms\n  \
    \ Every complex manipulation (like MD5) is no more secure than the\n   input values,\
    \ and in the case of ephemeral ports, the secret key.  If\n   an attacker is aware\
    \ of which cryptographic hash function is being\n   used by the victim (which\
    \ we should expect), and the attacker can\n   obtain enough material (e.g., ephemeral\
    \ ports chosen by the victim),\n   the attacker may simply search the entire secret-key\
    \ space to find\n   matches.\n   To protect against this, the secret key should\
    \ be of a reasonable\n   length.  Key lengths of 128 bits should be adequate.\n\
    \   Another possible mechanism for protecting the secret key is to change\n  \
    \ it after some time.  If the host platform is capable of producing\n   reasonably\
    \ good random data, the secret key can be changed\n   automatically.\n   Changing\
    \ the secret will cause abrupt shifts in the chosen ephemeral\n   ports, and consequently\
    \ collisions may occur.  That is, upon changing\n   the secret, the \"offset\"\
    \ value (see Sections 3.3.3 and 3.3.4) used\n   for each destination endpoint\
    \ will be different from that computed\n   with the previous secret, thus leading\
    \ to the selection of a port\n   number recently used for connecting to the same\
    \ endpoint.\n   Thus, the change in secret key should be done with consideration\
    \ and\n   could be performed whenever one of the following events occur:\n   o\
    \  The system is being bootstrapped.\n   o  Some predefined/random time has expired.\n\
    \   o  The secret key has been used sufficiently often that it should be\n   \
    \   regarded as insecure now.\n   o  There are few active transport-protocol instances\
    \ (i.e.,\n      possibility of a collision is low).\n   o  System load is low\
    \ (i.e., the performance overhead of local\n      collisions is tolerated).\n\
    \   o  There is enough random data available to change the secret key\n      (pseudo-random\
    \ changes should not be done).\n"
- title: 3.5.  Choosing an Ephemeral Port Selection Algorithm
  contents:
  - "3.5.  Choosing an Ephemeral Port Selection Algorithm\n   [Allman] is an empirical\
    \ study of the properties of the algorithms\n   described in this document, which\
    \ has found that all the algorithms\n   described in this document offer low collision\
    \ rates -- at most 0.3%.\n   That is, in those network scenarios assessed by [Allman],\
    \ all of the\n   algorithms described in this document perform well in terms of\n\
    \   collisions of instance-ids.  However, these results may vary\n   depending\
    \ on the characteristics of network traffic and the specific\n   network setup.\n\
    \   The algorithm described in Section 2.2 is the traditional ephemeral\n   port\
    \ selection algorithm implemented in BSD-derived systems.  It\n   generates a\
    \ global sequence of ephemeral port numbers, which makes it\n   trivial for an\
    \ attacker to predict the port number that will be used\n   for a future transport\
    \ protocol instance.  However, it is very simple\n   and leads to a low port-reuse\
    \ frequency.\n   Algorithm 1 and Algorithm 2 have the advantage that they provide\n\
    \   actual randomization of the ephemeral ports.  However, they may\n   increase\
    \ the chances of port number collisions, which could lead to\n   the failure of\
    \ a connection establishment attempt.  [Allman] found\n   that these two algorithms\
    \ show the largest collision rates (among all\n   the algorithms described in\
    \ this document).\n   Algorithm 3 provides complete separation in local and remote\
    \ IP\n   addresses and remote port space, and only limited separation in other\n\
    \   dimensions (see Section 3.4).  However, implementations should\n   consider\
    \ the performance impact of computing the cryptographic hash\n   used for the\
    \ offset.\n   Algorithm 4 improves Algorithm 3, usually leading to a lower port-\n\
    \   reuse frequency, at the expense of more processor cycles used for\n   computing\
    \ G(), and additional kernel memory for storing the array\n   \"table[]\".\n \
    \  Algorithm 5 offers middle ground between the simple randomization\n   algorithms\
    \ (Algorithm 1 and Algorithm 2) and the hash-based\n   algorithms (Algorithm 3\
    \ and Algorithm 4).  The upper limit on the\n   random increments (the value \"\
    N\" in the pseudo-code included in\n   Section 3.3.5) controls the trade-off between\
    \ randomization and port-\n   reuse frequency.\n   Finally, a special case that\
    \ may preclude the utilization of\n   Algorithm 3 and Algorithm 4 should be analyzed.\
    \  There exist some\n   applications that contain the following code sequence:\n\
    \       s = socket();\n       bind(s, IP_address, port = *);\n   In some BSD-derived\
    \ systems, the call to bind() will result in the\n   selection of an ephemeral\
    \ port number.  However, as neither the\n   remote IP address nor the remote port\
    \ will be available to the\n   ephemeral port selection function, the hash function\
    \ F() used in\n   Algorithm 3 and Algorithm 4 will not have all the required arguments,\n\
    \   and thus the result of the hash function will be impossible to\n   compute.\
    \  Transport protocols implementing Algorithm 3 or Algorithm 4\n   should consider\
    \ using Algorithm 2 when facing the scenario just\n   described.\n   An alternative\
    \ to this behavior would be to implement \"lazy binding\"\n   in response to the\
    \ bind() call.  That is, selection of an ephemeral\n   port would be delayed until,\
    \ e.g., connect() or send() are called.\n   Thus, at that point the ephemeral\
    \ port is actually selected, all the\n   necessary arguments for the hash function\
    \ F() are available, and\n   therefore Algorithm 3 and Algorithm 4 could still\
    \ be used in this\n   scenario.  This algorithm has been implemented by Linux\
    \ [Linux].\n"
- title: 4.  Interaction with Network Address Port Translation (NAPT)
  contents:
  - "4.  Interaction with Network Address Port Translation (NAPT)\n   Network Address\
    \ Port Translation (NAPT) translates both the network\n   address and transport-protocol\
    \ port number, thus allowing the\n   transport identifiers of a number of private\
    \ hosts to be multiplexed\n   into the transport identifiers of a single external\
    \ address\n   [RFC2663].\n   In those scenarios in which a NAPT is present between\
    \ the two\n   endpoints of a transport-protocol instance, the obfuscation of the\n\
    \   ephemeral port selection (from the point of view of the external\n   network)\
    \ will depend on the ephemeral port selection function at the\n   NAPT.  Therefore,\
    \ NAPTs should consider obfuscating the selection of\n   ephemeral ports by means\
    \ of any of the algorithms discussed in this\n   document.\n   A NAPT that does\
    \ not implement port preservation [RFC4787] [RFC5382]\n   SHOULD obfuscate selection\
    \ of the ephemeral port of a packet when it\n   is changed during translation\
    \ of that packet.\n   A NAPT that does implement port preservation SHOULD obfuscate\
    \ the\n   ephemeral port of a packet only if the port must be changed as a\n \
    \  result of the port being already in use for some other session.\n   A NAPT\
    \ that performs parity preservation and that must change the\n   ephemeral port\
    \ during translation of a packet SHOULD obfuscate the\n   ephemeral ports.  The\
    \ algorithms described in this document could be\n   easily adapted such that\
    \ the parity is preserved (i.e., force the\n   lowest order bit of the resulting\
    \ port number to 0 or 1 according to\n   whether even or odd parity is desired).\n\
    \   Some applications allocate contiguous ports and expect to see\n   contiguous\
    \ ports in use at their peers.  Clearly, this expectation\n   might be difficult\
    \ to accommodate at a NAPT, since some port numbers\n   might already be in use\
    \ by other sessions, and thus an alternative\n   port might need to be selected,\
    \ thus resulting in a non-contiguous\n   port number sequence (see Section 4.2.3\
    \ of [RFC4787]).  A NAPT that\n   implements a simple port randomization algorithm\
    \ (such as Algorithm\n   1, Algorithm 2, or Algorithm 5) is likely to break this\
    \ assumption,\n   even if the endpoint selecting an ephemeral port does select\n\
    \   ephemeral ports that are contiguous.  However, since a number of\n   different\
    \ ephemeral port selection algorithms have been implemented\n   by deployed NAPTs,\
    \ any application that relies on any specific\n   ephemeral port selection algorithm\
    \ at the NAPT is likely to suffer\n   interoperability problems when a NAPT is\
    \ present between the two\n   endpoints of a transport-protocol instance.  Nevertheless,\
    \ some of\n   the algorithms described in this document (namely Algorithm 3 and\n\
    \   Algorithm 4) select consecutive ephemeral ports such that they are\n   contiguous\
    \ (except when one of the port numbers needed to produce a\n   contiguous sequence\
    \ is already in use by some other NAPT session).\n   Therefore, a NAPT willing\
    \ to produce sequences of contiguous port\n   numbers should consider implementing\
    \ Algorithm 3 or Algorithm 4 of\n   this document.  Section 3.5 provides further\
    \ guidance in choosing a\n   port selection algorithm.\n   It should be noted\
    \ that in some network scenarios, a NAPT may\n   naturally obscure ephemeral port\
    \ selections simply due to the vast\n   range of services with which it establishes\
    \ connections and to the\n   overall rate of the traffic [Allman].\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   Obfuscating the ephemeral port selection is no\
    \ replacement for\n   cryptographic mechanisms, such as IPsec [RFC4301], in terms\
    \ of\n   protecting transport-protocol instances against blind attacks.\n   An\
    \ eavesdropper that can monitor the packets that correspond to the\n   transport-protocol\
    \ instance to be attacked could learn the IP\n   addresses and port numbers in\
    \ use (and also sequence numbers, etc.)\n   and easily perform an attack.  Obfuscation\
    \ of the ephemeral port\n   selection does not provide any additional protection\
    \ against this\n   kind of attack.  In such situations, proper authentication\
    \ mechanisms\n   such as those described in [RFC4301] should be used.\n   This\
    \ specification recommends including the whole range 1024-65535\n   for the selection\
    \ of ephemeral ports, and suggests that an\n   implementation maintains a list\
    \ of those port numbers that should not\n   be made available for ephemeral port\
    \ selection.  If the list of port\n   numbers that are not available is significant,\
    \ Algorithm 1 may be\n   highly biased and generate predictable ports, as noted\
    \ in\n   Section 3.3.1.  In particular, if the list of IANA Registered Ports\n\
    \   is accepted as the local list of port numbers that should not be made\n  \
    \ available, certain ports may result with 500 times the probability of\n   other\
    \ ports.  Systems that support numerous applications resulting in\n   large lists\
    \ of unavailable ports, or that use the IANA Registered\n   Ports without modification,\
    \ MUST NOT use Algorithm 1.\n   If the local offset function F() (in Algorithm\
    \ 3 and Algorithm 4)\n   results in identical offsets for different inputs at\
    \ greater\n   frequency than would be expected by chance, the port-offset mechanism\n\
    \   proposed in this document would have a reduced effect.\n   If random numbers\
    \ are used as the only source of the secret key, they\n   should be chosen in\
    \ accordance with the recommendations given in\n   [RFC4086].\n   If an attacker\
    \ uses dynamically assigned IP addresses, the current\n   ephemeral port offset\
    \ (Algorithm 3 and Algorithm 4) for a given five-\n   tuple can be sampled and\
    \ subsequently used to attack an innocent peer\n   reusing this address.  However,\
    \ this is only possible until a re-\n   keying happens as described above.  Also,\
    \ since ephemeral ports are\n   only used on the client side (e.g., the one initiating\
    \ the transport-\n   protocol communication), both the attacker and the new peer\
    \ need to\n   act as servers in the scenario just described.  While servers using\n\
    \   dynamic IP addresses exist, they are not very common, and with an\n   appropriate\
    \ re-keying mechanism the effect of this attack is limited.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   The offset function used in Algorithm 3 and Algorithm\
    \ 4 was inspired\n   by the mechanism proposed by Steven Bellovin in [RFC1948]\
    \ for\n   defending against TCP sequence number attacks.\n   The authors would\
    \ like to thank (in alphabetical order) Mark Allman,\n   Jari Arkko, Matthias\
    \ Bethke, Stephane Bortzmeyer, Brian Carpenter,\n   Vincent Deffontaines, Ralph\
    \ Droms, Lars Eggert, Pasi Eronen, Gorry\n   Fairhurst, Adrian Farrel, Guillermo\
    \ Gont, David Harrington, Alfred\n   Hoenes, Avshalom Houri, Charlie Kaufman,\
    \ Amit Klein, Subramanian\n   Moonesamy, Carlos Pignataro, Tim Polk, Kacheong\
    \ Poon, Pasi Sarolahti,\n   Robert Sparks, Randall Stewart, Joe Touch, Michael\
    \ Tuexen, Magnus\n   Westerlund, and Dan Wing for their valuable feedback on draft\n\
    \   versions of this document.\n   The authors would like to thank Alfred Hoenes\
    \ for his admirable\n   effort in improving the quality of this document.\n  \
    \ The authors would like to thank FreeBSD's Mike Silbersack for a very\n   fruitful\
    \ discussion about ephemeral port selection techniques.\n   Fernando Gont's attendance\
    \ to IETF meetings was supported by ISOC's\n   \"Fellowship to the IETF\" program.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC0768]      Postel, J., \"User Datagram Protocol\"\
    , STD 6, RFC 768,\n                  August 1980.\n   [RFC0793]      Postel, J.,\
    \ \"Transmission Control Protocol\", STD 7,\n                  RFC 793, September\
    \ 1981.\n   [RFC1321]      Rivest, R., \"The MD5 Message-Digest Algorithm\",\n\
    \                  RFC 1321, April 1992.\n   [RFC2119]      Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n                  Requirement Levels\", BCP\
    \ 14, RFC 2119, March 1997.\n   [RFC2385]      Heffernan, A., \"Protection of\
    \ BGP Sessions via the TCP\n                  MD5 Signature Option\", RFC 2385,\
    \ August 1998.\n   [RFC3550]      Schulzrinne, H., Casner, S., Frederick, R.,\
    \ and V.\n                  Jacobson, \"RTP: A Transport Protocol for Real-Time\n\
    \                  Applications\", STD 64, RFC 3550, July 2003.\n   [RFC3605]\
    \      Huitema, C., \"Real Time Control Protocol (RTCP)\n                  attribute\
    \ in Session Description Protocol (SDP)\",\n                  RFC 3605, October\
    \ 2003.\n   [RFC3828]      Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E.,\n\
    \                  and G. Fairhurst, \"The Lightweight User Datagram\n       \
    \           Protocol (UDP-Lite)\", RFC 3828, July 2004.\n   [RFC4086]      Eastlake,\
    \ D., Schiller, J., and S. Crocker,\n                  \"Randomness Requirements\
    \ for Security\", BCP 106,\n                  RFC 4086, June 2005.\n   [RFC4301]\
    \      Kent, S. and K. Seo, \"Security Architecture for the\n                \
    \  Internet Protocol\", RFC 4301, December 2005.\n   [RFC4340]      Kohler, E.,\
    \ Handley, M., and S. Floyd, \"Datagram\n                  Congestion Control\
    \ Protocol (DCCP)\", RFC 4340,\n                  March 2006.\n   [RFC4787]  \
    \    Audet, F. and C. Jennings, \"Network Address\n                  Translation\
    \ (NAT) Behavioral Requirements for Unicast\n                  UDP\", BCP 127,\
    \ RFC 4787, January 2007.\n   [RFC4960]      Stewart, R., \"Stream Control Transmission\
    \ Protocol\",\n                  RFC 4960, September 2007.\n   [RFC5382]     \
    \ Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P.\n                  Srisuresh,\
    \ \"NAT Behavioral Requirements for TCP\",\n                  BCP 142, RFC 5382,\
    \ October 2008.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [Allman]       Allman, M., \"Comments On Selecting\
    \ Ephemeral Ports\",\n                   ACM Computer Communication Review, 39(2),\
    \ 2009.\n   [CPNI-TCP]     Gont, F., \"CPNI Technical Note 3/2009: Security\n\
    \                  Assessment of the Transmission Control Protocol\n         \
    \         (TCP)\", 2009, <http://www.cpni.gov.uk/Docs/\n                  tn-03-09-security-assessment-TCP.pdf>.\n\
    \   [FreeBSD]      The FreeBSD Project, <http://www.freebsd.org>.\n   [IANA] \
    \        \"IANA Port Numbers\",\n                  <http://www.iana.org/assignments/port-numbers>.\n\
    \   [Linux]        The Linux Project, <http://www.kernel.org>.\n   [NetBSD]  \
    \     The NetBSD Project, <http://www.netbsd.org>.\n   [OpenBSD]      The OpenBSD\
    \ Project, <http://www.openbsd.org>.\n   [OpenSolaris]  OpenSolaris, <http://www.opensolaris.org>.\n\
    \   [RFC1337]      Braden, B., \"TIME-WAIT Assassination Hazards in TCP\",\n \
    \                 RFC 1337, May 1992.\n   [RFC1948]      Bellovin, S., \"Defending\
    \ Against Sequence Number\n                  Attacks\", RFC 1948, May 1996.\n\
    \   [RFC2663]      Srisuresh, P. and M. Holdrege, \"IP Network Address\n     \
    \             Translator (NAT) Terminology and Considerations\",\n           \
    \       RFC 2663, August 1999.\n   [RFC4953]      Touch, J., \"Defending TCP Against\
    \ Spoofing Attacks\",\n                  RFC 4953, July 2007.\n   [RFC5925]  \
    \    Touch, J., Mankin, A., and R. Bonica, \"The TCP\n                  Authentication\
    \ Option\", RFC 5925, June 2010.\n   [RFC5927]      Gont, F., \"ICMP Attacks against\
    \ TCP\", RFC 5927,\n                  July 2010.\n   [SCTP-SOCKET]  Stewart, R.,\
    \ Poon, K., Tuexen, M., Lei, P., and V.\n                  Yasevich, V., \"Sockets\
    \ API Extensions for Stream\n                  Control Transmission Protocol (SCTP)\"\
    , Work in\n                  Progress, January 2011.\n   [Silbersack]   Silbersack,\
    \ M., \"Improving TCP/IP security through\n                  randomization without\
    \ sacrificing interoperability\",\n                  EuroBSDCon 2005 Conference.\n\
    \   [Stevens]      Stevens, W., \"Unix Network Programming, Volume 1:\n      \
    \            Networking APIs: Socket and XTI\", Prentice Hall, 1998.\n   [TCP-SEC]\
    \      Gont, F., \"Security Assessment of the Transmission\n                 \
    \ Control Protocol (TCP)\", Work in Progress,\n                  February 2010.\n\
    \   [Watson]       Watson, P., \"Slipping in the Window: TCP Reset\n         \
    \         Attacks\", CanSecWest 2004 Conference.\n"
- title: Appendix A.  Survey of the Algorithms in Use by Some Popular
  contents:
  - "Appendix A.  Survey of the Algorithms in Use by Some Popular\n             Implementations\n"
- title: A.1.  FreeBSD
  contents:
  - "A.1.  FreeBSD\n   FreeBSD 8.0 implements Algorithm 1, and in response to this\
    \ document\n   now uses a \"min_port\" of 10000 and a \"max_port\" of 65535 [FreeBSD].\n"
- title: A.2.  Linux
  contents:
  - "A.2.  Linux\n   Linux 2.6.15-53-386 implements Algorithm 3, with MD5 as the hash\n\
    \   algorithm.  If the algorithm is faced with the corner-case scenario\n   described\
    \ in Section 3.5, Algorithm 1 is used instead [Linux].\n"
- title: A.3.  NetBSD
  contents:
  - "A.3.  NetBSD\n   NetBSD 5.0.1 does not obfuscate its ephemeral port numbers.\
    \  It\n   selects ephemeral port numbers from the range 49152-65535, starting\n\
    \   from port 65535, and decreasing the port number for each ephemeral\n   port\
    \ number selected [NetBSD].\n"
- title: A.4.  OpenBSD
  contents:
  - "A.4.  OpenBSD\n   OpenBSD 4.2 implements Algorithm 1, with a \"min_port\" of\
    \ 1024 and a\n   \"max_port\" of 49151.  [OpenBSD]\n"
- title: A.5.  OpenSolaris
  contents:
  - "A.5.  OpenSolaris\n   OpenSolaris 2009.06 implements Algorithm 1, with a \"min_port\"\
    \ of\n   32768 and a \"max_port\" of 65535 [OpenSolaris].\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Michael Vittrup Larsen\n   Tieto\n   Skanderborgvej 232\n\
    \   Aarhus  DK-8260\n   Denmark\n   Phone: +45 8938 5100\n   EMail: michael.larsen@tieto.com\n\
    \   Fernando Gont\n   Universidad Tecnologica Nacional / Facultad Regional Haedo\n\
    \   Evaristo Carriego 2644\n   Haedo, Provincia de Buenos Aires  1706\n   Argentina\n\
    \   Phone: +54 11 4650 8472\n   EMail: fernando@gont.com.ar\n"
