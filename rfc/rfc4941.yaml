- title: __initial_text__
  contents:
  - '   Privacy Extensions for Stateless Address Autoconfiguration in IPv6

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   Nodes use IPv6 stateless address autoconfiguration to generate\n\
    \   addresses using a combination of locally available information and\n   information\
    \ advertised by routers.  Addresses are formed by combining\n   network prefixes\
    \ with an interface identifier.  On an interface that\n   contains an embedded\
    \ IEEE Identifier, the interface identifier is\n   typically derived from it.\
    \  On other interface types, the interface\n   identifier is generated through\
    \ other means, for example, via random\n   number generation.  This document describes\
    \ an extension to IPv6\n   stateless address autoconfiguration for interfaces\
    \ whose interface\n   identifier is derived from an IEEE identifier.  Use of the\
    \ extension\n   causes nodes to generate global scope addresses from interface\n\
    \   identifiers that change over time, even in cases where the interface\n   contains\
    \ an embedded IEEE identifier.  Changing the interface\n   identifier (and the\
    \ global scope addresses generated from it) over\n   time makes it more difficult\
    \ for eavesdroppers and other information\n   collectors to identify when different\
    \ addresses used in different\n   transactions actually correspond to the same\
    \ node.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  Conventions Used in This Document  . . . . . . .\
    \ . . . . .  4\n     1.2.  Problem Statement  . . . . . . . . . . . . . . . .\
    \ . . . .  4\n   2.  Background . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  5\n     2.1.  Extended Use of the Same Identifier  . . . . . . . . .\
    \ . .  5\n     2.2.  Address Usage in IPv4 Today  . . . . . . . . . . . . . .\
    \ .  6\n     2.3.  The Concern with IPv6 Addresses  . . . . . . . . . . . . .\
    \  7\n     2.4.  Possible Approaches  . . . . . . . . . . . . . . . . . . .  8\n\
    \   3.  Protocol Description . . . . . . . . . . . . . . . . . . . . .  9\n  \
    \   3.1.  Assumptions  . . . . . . . . . . . . . . . . . . . . . . . 10\n    \
    \ 3.2.  Generation of Randomized Interface Identifiers . . . . . . 10\n      \
    \ 3.2.1.  When Stable Storage Is Present . . . . . . . . . . . . 11\n       3.2.2.\
    \  In The Absence of Stable Storage . . . . . . . . . . . 12\n       3.2.3.  Alternate\
    \ Approaches . . . . . . . . . . . . . . . . . 12\n     3.3.  Generating Temporary\
    \ Addresses . . . . . . . . . . . . . . 13\n     3.4.  Expiration of Temporary\
    \ Addresses  . . . . . . . . . . . . 14\n     3.5.  Regeneration of Randomized\
    \ Interface Identifiers . . . . . 15\n     3.6.  Deployment Considerations  .\
    \ . . . . . . . . . . . . . . . 16\n   4.  Implications of Changing Interface\
    \ Identifiers . . . . . . . . 17\n   5.  Defined Constants  . . . . . . . . .\
    \ . . . . . . . . . . . . . 18\n   6.  Future Work  . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . 18\n   7.  Security Considerations  . . . . . . . .\
    \ . . . . . . . . . . . 19\n   8.  Significant Changes from RFC 3041  . . . .\
    \ . . . . . . . . . . 19\n   9.  Acknowledgments  . . . . . . . . . . . . . .\
    \ . . . . . . . . . 20\n   10. References . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 20\n     10.1. Normative References . . . . . . . . . . . .\
    \ . . . . . . . 20\n     10.2. Informative References . . . . . . . . . . . .\
    \ . . . . . . 20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Stateless address autoconfiguration [ADDRCONF] defines how\
    \ an IPv6\n   node generates addresses without the need for a Dynamic Host\n \
    \  Configuration Protocol for IPv6 (DHCPv6) server.  Some types of\n   network\
    \ interfaces come with an embedded IEEE Identifier (i.e., a\n   link-layer MAC\
    \ address), and in those cases, stateless address\n   autoconfiguration uses the\
    \ IEEE identifier to generate a 64-bit\n   interface identifier [ADDRARCH].  By\
    \ design, the interface identifier\n   is likely to be globally unique when generated\
    \ in this fashion.  The\n   interface identifier is in turn appended to a prefix\
    \ to form a\n   128-bit IPv6 address.  Note that an IPv6 identifier does not\n\
    \   necessarily have to be 64 bits in length, but the algorithm specified\n  \
    \ in this document is targeted towards 64-bit interface identifiers.\n   All nodes\
    \ combine interface identifiers (whether derived from an IEEE\n   identifier or\
    \ generated through some other technique) with the\n   reserved link-local prefix\
    \ to generate link-local addresses for their\n   attached interfaces.  Additional\
    \ addresses can then be created by\n   combining prefixes advertised in Router\
    \ Advertisements via Neighbor\n   Discovery [DISCOVERY] with the interface identifier.\n\
    \   Not all nodes and interfaces contain IEEE identifiers.  In such\n   cases,\
    \ an interface identifier is generated through some other means\n   (e.g., at\
    \ random), and the resultant interface identifier may not be\n   globally unique\
    \ and may also change over time.  The focus of this\n   document is on addresses\
    \ derived from IEEE identifiers because\n   tracking of individual devices, the\
    \ concern being addressed here, is\n   possible only in those cases where the\
    \ interface identifier is\n   globally unique and non-changing.  The rest of this\
    \ document assumes\n   that IEEE identifiers are being used, but the techniques\
    \ described\n   may also apply to interfaces with other types of globally unique\n\
    \   and/or persistent identifiers.\n   This document discusses concerns associated\
    \ with the embedding of\n   non-changing interface identifiers within IPv6 addresses\
    \ and\n   describes extensions to stateless address autoconfiguration that can\n\
    \   help mitigate those concerns for individual users and in environments\n  \
    \ where such concerns are significant.  Section 2 provides background\n   information\
    \ on the issue.  Section 3 describes a procedure for\n   generating alternate\
    \ interface identifiers and global scope\n   addresses.  Section 4 discusses implications\
    \ of changing interface\n   identifiers.  The term \"global scope addresses\"\
    \ is used in this\n   document to collectively refer to \"Global unicast addresses\"\
    \ as\n   defined in [ADDRARCH] and \"Unique local addresses\" as defined in\n\
    \   [ULA].\n"
- title: 1.1.  Conventions Used in This Document
  contents:
  - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 1.2.  Problem Statement
  contents:
  - "1.2.  Problem Statement\n   Addresses generated using stateless address autoconfiguration\n\
    \   [ADDRCONF] contain an embedded interface identifier, which remains\n   constant\
    \ over time.  Anytime a fixed identifier is used in multiple\n   contexts, it\
    \ becomes possible to correlate seemingly unrelated\n   activity using this identifier.\n\
    \   The correlation can be performed by\n   o  An attacker who is in the path\
    \ between the node in question and\n      the peer(s) to which it is communicating,\
    \ and who can view the\n      IPv6 addresses present in the datagrams.\n   o \
    \ An attacker who can access the communication logs of the peers\n      with which\
    \ the node has communicated.\n   Since the identifier is embedded within the IPv6\
    \ address, which is a\n   fundamental requirement of communication, it cannot\
    \ be easily hidden.\n   This document proposes a solution to this issue by generating\n\
    \   interface identifiers that vary over time.\n   Note that an attacker, who\
    \ is on path, may be able to perform\n   significant correlation based on\n  \
    \ o  The payload contents of the packets on the wire\n   o  The characteristics\
    \ of the packets such as packet size and timing\n   Use of temporary addresses\
    \ will not prevent such payload-based\n   correlation.\n"
- title: 2.  Background
  contents:
  - "2.  Background\n   This section discusses the problem in more detail, provides\
    \ context\n   for evaluating the significance of the concerns in specific\n  \
    \ environments and makes comparisons with existing practices.\n"
- title: 2.1.  Extended Use of the Same Identifier
  contents:
  - "2.1.  Extended Use of the Same Identifier\n   The use of a non-changing interface\
    \ identifier to form addresses is a\n   specific instance of the more general\
    \ case where a constant\n   identifier is reused over an extended period of time\
    \ and in multiple\n   independent activities.  Any time the same identifier is\
    \ used in\n   multiple contexts, it becomes possible for that identifier to be\
    \ used\n   to correlate seemingly unrelated activity.  For example, a network\n\
    \   sniffer placed strategically on a link across which all traffic to/\n   from\
    \ a particular host crosses could keep track of which destinations\n   a node\
    \ communicated with and at what times.  Such information can in\n   some cases\
    \ be used to infer things, such as what hours an employee\n   was active, when\
    \ someone is at home, etc.  Although it might appear\n   that changing an address\
    \ regularly in such environments would be\n   desirable to lessen privacy concerns,\
    \ it should be noted that the\n   network prefix portion of an address also serves\
    \ as a constant\n   identifier.  All nodes at, say, a home, would have the same\
    \ network\n   prefix, which identifies the topological location of those nodes.\n\
    \   This has implications for privacy, though not at the same granularity\n  \
    \ as the concern that this document addresses.  Specifically, all nodes\n   within\
    \ a home could be grouped together for the purposes of\n   collecting information.\
    \  If the network contains a very small number\n   of nodes, say, just one, changing\
    \ just the interface identifier will\n   not enhance privacy at all, since the\
    \ prefix serves as a constant\n   identifier.\n   One of the requirements for\
    \ correlating seemingly unrelated\n   activities is the use (and reuse) of an\
    \ identifier that is\n   recognizable over time within different contexts.  IP\
    \ addresses\n   provide one obvious example, but there are more.  Many nodes also\n\
    \   have DNS names associated with their addresses, in which case the DNS\n  \
    \ name serves as a similar identifier.  Although the DNS name\n   associated with\
    \ an address is more work to obtain (it may require a\n   DNS query), the information\
    \ is often readily available.  In such\n   cases, changing the address on a machine\
    \ over time would do little to\n   address the concerns raised in this document,\
    \ unless the DNS name is\n   changed as well (see Section 4).\n   Web browsers\
    \ and servers typically exchange \"cookies\" with each other\n   [COOKIES].  Cookies\
    \ allow Web servers to correlate a current activity\n   with a previous activity.\
    \  One common usage is to send back targeted\n   advertising to a user by using\
    \ the cookie supplied by the browser to\n   identify what earlier queries had\
    \ been made (e.g., for what type of\n   information).  Based on the earlier queries,\
    \ advertisements can be\n   targeted to match the (assumed) interests of the end\
    \ user.\n   The use of a constant identifier within an address is of special\n\
    \   concern because addresses are a fundamental requirement of\n   communication\
    \ and cannot easily be hidden from eavesdroppers and\n   other parties.  Even\
    \ when higher layers encrypt their payloads,\n   addresses in packet headers appear\
    \ in the clear.  Consequently, if a\n   mobile host (e.g., laptop) accessed the\
    \ network from several\n   different locations, an eavesdropper might be able\
    \ to track the\n   movement of that mobile host from place to place, even if the\
    \ upper\n   layer payloads were encrypted.\n"
- title: 2.2.  Address Usage in IPv4 Today
  contents:
  - "2.2.  Address Usage in IPv4 Today\n   Addresses used in today's Internet are\
    \ often non-changing in practice\n   for extended periods of time.  In an increasing\
    \ number of sites,\n   addresses are assigned statically and typically change\
    \ infrequently.\n   Over the last few years, sites have begun moving away from\
    \ static\n   allocation to dynamic allocation via DHCP [DHCP].  In theory, the\n\
    \   address a client gets via DHCP can change over time, but in practice\n   servers\
    \ often return the same address to the same client (unless\n   addresses are in\
    \ such short supply that they are reused immediately\n   by a different node when\
    \ they become free).  Thus, even within sites\n   using DHCP, clients frequently\
    \ end up using the same address for\n   weeks to months at a time.\n   For home\
    \ users accessing the Internet over dial-up lines, the\n   situation is generally\
    \ different.  Such users do not have permanent\n   connections and are often assigned\
    \ temporary addresses each time they\n   connect to their ISP.  Consequently,\
    \ the addresses they use change\n   frequently over time and are shared among\
    \ a number of different\n   users.  Thus, an address does not reliably identify\
    \ a particular\n   device over time spans of more than a few minutes.\n   A more\
    \ interesting case concerns always-on connections (e.g., cable\n   modems, ISDN,\
    \ DSL, etc.) that result in a home site using the same\n   address for extended\
    \ periods of time.  This is a scenario that is\n   just starting to become common\
    \ in IPv4 and promises to become more of\n   a concern as always-on Internet connectivity\
    \ becomes widely\n   available.\n   Finally, it should be noted that nodes that\
    \ need a (non-changing) DNS\n   name generally have static addresses assigned\
    \ to them to simplify the\n   configuration of DNS servers.  Although Dynamic\
    \ DNS [DDNS] can be\n   used to update the DNS dynamically, it may not always\
    \ be available\n   depending on the administrative policy.  In addition, changing\
    \ an\n   address but keeping the same DNS name does not really address the\n \
    \  underlying concern, since the DNS name becomes a non-changing\n   identifier.\
    \  Servers generally require a DNS name (so clients can\n   connect to them),\
    \ and clients often do as well (e.g., some servers\n   refuse to speak to a client\
    \ whose address cannot be mapped into a DNS\n   name that also maps back into\
    \ the same address).  Section 4 describes\n   one approach to this issue.\n"
- title: 2.3.  The Concern with IPv6 Addresses
  contents:
  - "2.3.  The Concern with IPv6 Addresses\n   The division of IPv6 addresses into\
    \ distinct topology and interface\n   identifier portions raises an issue new\
    \ to IPv6 in that a fixed\n   portion of an IPv6 address (i.e., the interface\
    \ identifier) can\n   contain an identifier that remains constant even when the\
    \ topology\n   portion of an address changes (e.g., as the result of connecting\
    \ to a\n   different part of the Internet).  In IPv4, when an address changes,\n\
    \   the entire address (including the local part of the address) usually\n   changes.\
    \  It is this new issue that this document addresses.\n   If addresses are generated\
    \ from an interface identifier, a home\n   user's address could contain an interface\
    \ identifier that remains the\n   same from one dial-up session to the next, even\
    \ if the rest of the\n   address changes.  The way PPP is used today, however,\
    \ PPP servers\n   typically unilaterally inform the client what address they are\
    \ to use\n   (i.e., the client doesn't generate one on its own).  This practice,\n\
    \   if continued in IPv6, would avoid the concerns that are the focus of\n   this\
    \ document.\n   A more troubling case concerns mobile devices (e.g., laptops,\
    \ PDAs,\n   etc.) that move topologically within the Internet.  Whenever they\n\
    \   move, they form new addresses for their current topological point of\n   attachment.\
    \  This is typified today by the \"road warrior\" who has\n   Internet connectivity\
    \ both at home and at the office.  While the\n   node's address changes as it\
    \ moves, the interface identifier\n   contained within the address remains the\
    \ same (when derived from an\n   IEEE Identifier).  In such cases, the interface\
    \ identifier can be\n   used to track the movement and usage of a particular machine.\
    \  For\n   example, a server that logs usage information together with source\n\
    \   addresses, is also recording the interface identifier since it is\n   embedded\
    \ within an address.  Consequently, any data-mining technique\n   that correlates\
    \ activity based on addresses could easily be extended\n   to do the same using\
    \ the interface identifier.  This is of particular\n   concern with the expected\
    \ proliferation of next-generation network-\n   connected devices (e.g., PDAs,\
    \ cell phones, etc.) in which large\n   numbers of devices are, in practice, associated\
    \ with individual users\n   (i.e., not shared).  Thus, the interface identifier\
    \ embedded within\n   an address could be used to track activities of an individual,\
    \ even\n   as they move topologically within the Internet.\n   In summary, IPv6\
    \ addresses on a given interface generated via\n   Stateless Autoconfiguration\
    \ contain the same interface identifier,\n   regardless of where within the Internet\
    \ the device connects.  This\n   facilitates the tracking of individual devices\
    \ (and thus,\n   potentially, users).  The purpose of this document is to define\n\
    \   mechanisms that eliminate this issue in those situations where it is\n   a\
    \ concern.\n"
- title: 2.4.  Possible Approaches
  contents:
  - "2.4.  Possible Approaches\n   One way to avoid having a static non-changing address\
    \ is to use\n   DHCPv6 [DHCPV6] for obtaining addresses.  Section 12 of [DHCPV6]\n\
    \   discusses the use of DHCPv6 for the assignment and management of\n   \"temporary\
    \ addresses\", which are never renewed and provide the same\n   property of temporary\
    \ addresses described in this document with\n   regards to the privacy concern.\n\
    \   Another approach, compatible with the stateless address\n   autoconfiguration\
    \ architecture, would be to change the interface\n   identifier portion of an\
    \ address over time and generate new addresses\n   from the interface identifier\
    \ for some address scopes.  Changing the\n   interface identifier can make it\
    \ more difficult to look at the IP\n   addresses in independent transactions and\
    \ identify which ones\n   actually correspond to the same node, both in the case\
    \ where the\n   routing prefix portion of an address changes and when it does\
    \ not.\n   Many machines function as both clients and servers.  In such cases,\n\
    \   the machine would need a DNS name for its use as a server.  Whether\n   the\
    \ address stays fixed or changes has little privacy implication\n   since the\
    \ DNS name remains constant and serves as a constant\n   identifier.  When acting\
    \ as a client (e.g., initiating\n   communication), however, such a machine may\
    \ want to vary the\n   addresses it uses.  In such environments, one may need\
    \ multiple\n   addresses: a \"public\" (i.e., non-secret) server address, registered\n\
    \   in the DNS, that is used to accept incoming connection requests from\n   other\
    \ machines, and a \"temporary\" address used to shield the identity\n   of the\
    \ client when it initiates communication.  These two cases are\n   roughly analogous\
    \ to telephone numbers and caller ID, where a user\n   may list their telephone\
    \ number in the public phone book, but disable\n   the display of its number via\
    \ caller ID when initiating calls.\n   To make it difficult to make educated guesses\
    \ as to whether two\n   different interface identifiers belong to the same node,\
    \ the\n   algorithm for generating alternate identifiers must include input\n\
    \   that has an unpredictable component from the perspective of the\n   outside\
    \ entities that are collecting information.  Picking\n   identifiers from a pseudo-random\
    \ sequence suffices, so long as the\n   specific sequence cannot be determined\
    \ by an outsider examining\n   information that is readily available or easily\
    \ determinable (e.g.,\n   by examining packet contents).  This document proposes\
    \ the generation\n   of a pseudo-random sequence of interface identifiers via\
    \ an MD5 hash.\n   Periodically, the next interface identifier in the sequence\
    \ is\n   generated, a new set of temporary addresses is created, and the\n   previous\
    \ temporary addresses are deprecated to discourage their\n   further use.  The\
    \ precise pseudo-random sequence depends on both a\n   random component and the\
    \ globally unique interface identifier (when\n   available), to increase the likelihood\
    \ that different nodes generate\n   different sequences.\n"
- title: 3.  Protocol Description
  contents:
  - "3.  Protocol Description\n   The goal of this section is to define procedures\
    \ that:\n   1.  Do not result in any changes to the basic behavior of addresses\n\
    \       generated via stateless address autoconfiguration [ADDRCONF].\n   2. \
    \ Create additional addresses based on a random interface\n       identifier for\
    \ the purpose of initiating outgoing sessions.\n       These \"random\" or temporary\
    \ addresses would be used for a short\n       period of time (hours to days) and\
    \ would then be deprecated.\n       Deprecated address can continue to be used\
    \ for already\n       established connections, but are not used to initiate new\n\
    \       connections.  New temporary addresses are generated periodically\n   \
    \    to replace temporary addresses that expire, with the exact time\n       between\
    \ address generation a matter of local policy.\n   3.  Produce a sequence of temporary\
    \ global scope addresses from a\n       sequence of interface identifiers that\
    \ appear to be random in the\n       sense that it is difficult for an outside\
    \ observer to predict a\n       future address (or identifier) based on a current\
    \ one, and it is\n       difficult to determine previous addresses (or identifiers)\n\
    \       knowing only the present one.\n   4.  By default, generate a set of addresses\
    \ from the same\n       (randomized) interface identifier, one address for each\
    \ prefix\n       for which a global address has been generated via stateless\n\
    \       address autoconfiguration.  Using the same interface identifier\n    \
    \   to generate a set of temporary addresses reduces the number of IP\n      \
    \ multicast groups a host must join.  Nodes join the solicited-node\n       multicast\
    \ address for each unicast address they support, and\n       solicited-node addresses\
    \ are dependent only on the low-order bits\n       of the corresponding address.\
    \  This default behavior was made to\n       address the concern that a node that\
    \ joins a large number of\n       multicast groups may be required to put its\
    \ interface into\n       promiscuous mode, resulting in possible reduced performance.\n\
    \       A node highly concerned about privacy MAY use different interface\n  \
    \     identifiers on different prefixes, resulting in a set of global\n      \
    \ addresses that cannot be easily tied to each other.  For example\n       a node\
    \ MAY create different interface identifiers I1, I2, and I3\n       for use with\
    \ different prefixes P1, P2, and P3 on the same\n       interface.\n"
- title: 3.1.  Assumptions
  contents:
  - "3.1.  Assumptions\n   The following algorithm assumes that each interface maintains\
    \ an\n   associated randomized interface identifier.  When temporary addresses\n\
    \   are generated, the current value of the associated randomized\n   interface\
    \ identifier is used.  While the same identifier can be used\n   to create more\
    \ than one temporary address, the value SHOULD change\n   over time as described\
    \ in Section 3.5.\n   The algorithm also assumes that, for a given temporary address,\
    \ an\n   implementation can determine the prefix from which it was generated.\n\
    \   When a temporary address is deprecated, a new temporary address is\n   generated.\
    \  The specific valid and preferred lifetimes for the new\n   address are dependent\
    \ on the corresponding lifetime values set for\n   the prefix from which it was\
    \ generated.\n   Finally, this document assumes that when a node initiates outgoing\n\
    \   communication, temporary addresses can be given preference over\n   public\
    \ addresses when the device is configured to do so.\n   [ADDR_SELECT] mandates\
    \ implementations to provide a mechanism, which\n   allows an application to configure\
    \ its preference for temporary\n   addresses over public addresses.  It also allows\
    \ for an\n   implementation to prefer temporary addresses by default, so that\
    \ the\n   connections initiated by the node can use temporary addresses without\n\
    \   requiring application-specific enablement.  This document also\n   assumes\
    \ that an API will exist that allows individual applications to\n   indicate whether\
    \ they prefer to use temporary or public addresses and\n   override the system\
    \ defaults.\n"
- title: 3.2.  Generation of Randomized Interface Identifiers
  contents:
  - "3.2.  Generation of Randomized Interface Identifiers\n   We describe two approaches\
    \ for the generation and maintenance of the\n   randomized interface identifier.\
    \  The first assumes the presence of\n   stable storage that can be used to record\
    \ state history for use as\n   input into the next iteration of the algorithm\
    \ across system\n   restarts.  A second approach addresses the case where stable\
    \ storage\n   is unavailable and there is a need to generate randomized interface\n\
    \   identifiers without previous state.\n   The random interface identifier generation\
    \ algorithm, as described in\n   this document, uses MD5 as the hash algorithm.\
    \  The node MAY use\n   another algorithm instead of MD5 to produce the random\
    \ interface\n   identifier.\n"
- title: 3.2.1.  When Stable Storage Is Present
  contents:
  - "3.2.1.  When Stable Storage Is Present\n   The following algorithm assumes the\
    \ presence of a 64-bit \"history\n   value\" that is used as input in generating\
    \ a randomized interface\n   identifier.  The very first time the system boots\
    \ (i.e., out-of-the-\n   box), a random value SHOULD be generated using techniques\
    \ that help\n   ensure the initial value is hard to guess [RANDOM].  Whenever\
    \ a new\n   interface identifier is generated, a value generated by the\n   computation\
    \ is saved in the history value for the next iteration of\n   the algorithm.\n\
    \   A randomized interface identifier is created as follows:\n   1.  Take the\
    \ history value from the previous iteration of this\n       algorithm (or a random\
    \ value if there is no previous value) and\n       append to it the interface\
    \ identifier generated as described in\n       [ADDRARCH].\n   2.  Compute the\
    \ MD5 message digest [MD5] over the quantity created in\n       the previous step.\n\
    \   3.  Take the leftmost 64-bits of the MD5 digest and set bit 6 (the\n     \
    \  leftmost bit is numbered 0) to zero.  This creates an interface\n       identifier\
    \ with the universal/local bit indicating local\n       significance only.\n \
    \  4.  Compare the generated identifier against a list of reserved\n       interface\
    \ identifiers and to those already assigned to an address\n       on the local\
    \ device.  In the event that an unacceptable\n       identifier has been generated,\
    \ the node MUST restart the process\n       at step 1 above, using the rightmost\
    \ 64 bits of the MD5 digest\n       obtained in step 2 in place of the history\
    \ value in step 1.\n   5.  Save the generated identifier as the associated randomized\n\
    \       interface identifier.\n   6.  Take the rightmost 64-bits of the MD5 digest\
    \ computed in step 2)\n       and save them in stable storage as the history value\
    \ to be used\n       in the next iteration of the algorithm.\n   MD5 was chosen\
    \ for convenience, and because its particular properties\n   were adequate to\
    \ produce the desired level of randomization.  The\n   node MAY use another algorithm\
    \ instead of MD5 to produce the random\n   interface identifier\n   In theory,\
    \ generating successive randomized interface identifiers\n   using a history scheme\
    \ as above has no advantages over generating\n   them at random.  In practice,\
    \ however, generating truly random\n   numbers can be tricky.  Use of a history\
    \ value is intended to avoid\n   the particular scenario where two nodes generate\
    \ the same randomized\n   interface identifier, both detect the situation via\
    \ DAD, but then\n   proceed to generate identical randomized interface identifiers\
    \ via\n   the same (flawed) random number generation algorithm.  The above\n \
    \  algorithm avoids this problem by having the interface identifier\n   (which\
    \ will often be globally unique) used in the calculation that\n   generates subsequent\
    \ randomized interface identifiers.  Thus, if two\n   nodes happen to generate\
    \ the same randomized interface identifier,\n   they should generate different\
    \ ones on the follow-up attempt.\n"
- title: 3.2.2.  In The Absence of Stable Storage
  contents:
  - "3.2.2.  In The Absence of Stable Storage\n   In the absence of stable storage,\
    \ no history value will be available\n   across system restarts to generate a\
    \ pseudo-random sequence of\n   interface identifiers.  Consequently, the initial\
    \ history value used\n   above SHOULD be generated at random.  A number of techniques\
    \ might be\n   appropriate.  Consult [RANDOM] for suggestions on good sources\
    \ for\n   obtaining random numbers.  Note that even though machines may not\n\
    \   have stable storage for storing a history value, they will in many\n   cases\
    \ have configuration information that differs from one machine to\n   another\
    \ (e.g., user identity, security keys, serial numbers, etc.).\n   One approach\
    \ to generating a random initial history value in such\n   cases is to use the\
    \ configuration information to generate some data\n   bits (which may remain constant\
    \ for the life of the machine, but will\n   vary from one machine to another),\
    \ append some random data, and\n   compute the MD5 digest as before.\n"
- title: 3.2.3.  Alternate Approaches
  contents:
  - "3.2.3.  Alternate Approaches\n   Note that there are other approaches to generate\
    \ random interface\n   identifiers, albeit with different goals and applicability.\
    \  One such\n   approach is Cryptographically Generated Addresses (CGAs) [CGA],\
    \ which\n   generate a random interface identifier based on the public key of\
    \ the\n   node.  The goal of CGAs is to prove ownership of an address and to\n\
    \   prevent spoofing and stealing of existing IPv6 addresses.  They are\n   used\
    \ for securing neighbor discovery using [SEND].  The CGA random\n   interface\
    \ identifier generation algorithm may not be suitable for\n   privacy addresses\
    \ because of the following properties:\n   o  It requires the node to have a public\
    \ key.  This means that the\n      node can still be identified by its public\
    \ key.\n   o  The random interface identifier process is computationally\n   \
    \   intensive and hence discourages frequent regeneration.\n"
- title: 3.3.  Generating Temporary Addresses
  contents:
  - "3.3.  Generating Temporary Addresses\n   [ADDRCONF] describes the steps for generating\
    \ a link-local address\n   when an interface becomes enabled as well as the steps\
    \ for generating\n   addresses for other scopes.  This document extends [ADDRCONF]\
    \ as\n   follows.  When processing a Router Advertisement with a Prefix\n   Information\
    \ option carrying a global scope prefix for the purposes of\n   address autoconfiguration\
    \ (i.e., the A bit is set), the node MUST\n   perform the following steps:\n \
    \  1.  Process the Prefix Information Option as defined in [ADDRCONF],\n     \
    \  either creating a new public address or adjusting the lifetimes\n       of\
    \ existing addresses, both public and temporary.  If a received\n       option\
    \ will extend the lifetime of a public address, the\n       lifetimes of temporary\
    \ addresses should be extended, subject to\n       the overall constraint that\
    \ no temporary addresses should ever\n       remain \"valid\" or \"preferred\"\
    \ for a time longer than\n       (TEMP_VALID_LIFETIME) or (TEMP_PREFERRED_LIFETIME\
    \ -\n       DESYNC_FACTOR), respectively.  The configuration variables\n     \
    \  TEMP_VALID_LIFETIME and TEMP_PREFERRED_LIFETIME correspond to\n       approximate\
    \ target lifetimes for temporary addresses.\n   2.  One way an implementation\
    \ can satisfy the above constraints is to\n       associate with each temporary\
    \ address a creation time (called\n       CREATION_TIME) that indicates the time\
    \ at which the address was\n       created.  When updating the preferred lifetime\
    \ of an existing\n       temporary address, it would be set to expire at whichever\
    \ time is\n       earlier: the time indicated by the received lifetime or\n  \
    \     (CREATION_TIME + TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR).  A\n       similar\
    \ approach can be used with the valid lifetime.\n   3.  When a new public address\
    \ is created as described in [ADDRCONF],\n       the node SHOULD also create a\
    \ new temporary address.\n   4.  When creating a temporary address, the lifetime\
    \ values MUST be\n       derived from the corresponding prefix as follows:\n \
    \      *  Its Valid Lifetime is the lower of the Valid Lifetime of the\n     \
    \     public address or TEMP_VALID_LIFETIME.\n       *  Its Preferred Lifetime\
    \ is the lower of the Preferred Lifetime\n          of the public address or TEMP_PREFERRED_LIFETIME\
    \ -\n          DESYNC_FACTOR.\n   5.  A temporary address is created only if this\
    \ calculated Preferred\n       Lifetime is greater than REGEN_ADVANCE time units.\
    \  In\n       particular, an implementation MUST NOT create a temporary address\n\
    \       with a zero Preferred Lifetime.\n   6.  New temporary addresses MUST be\
    \ created by appending the\n       interface's current randomized interface identifier\
    \ to the prefix\n       that was received.\n   7.  The node MUST perform duplicate\
    \ address detection (DAD) on the\n       generated temporary address.  If DAD\
    \ indicates the address is\n       already in use, the node MUST generate a new\
    \ randomized interface\n       identifier as described in Section 3.2 above, and\
    \ repeat the\n       previous steps as appropriate up to TEMP_IDGEN_RETRIES times.\
    \  If\n       after TEMP_IDGEN_RETRIES consecutive attempts no non-unique\n  \
    \     address was generated, the node MUST log a system error and MUST\n     \
    \  NOT attempt to generate temporary addresses for that interface.\n       Note\
    \ that DAD MUST be performed on every unicast address\n       generated from this\
    \ randomized interface identifier.\n"
- title: 3.4.  Expiration of Temporary Addresses
  contents:
  - "3.4.  Expiration of Temporary Addresses\n   When a temporary address becomes\
    \ deprecated, a new one MUST be\n   generated.  This is done by repeating the\
    \ actions described in\n   Section 3.3, starting at step 3).  Note that, except\
    \ for the\n   transient period when a temporary address is being regenerated,\
    \ in\n   normal operation at most one temporary address per prefix should be\n\
    \   in a non-deprecated state at any given time on a given interface.\n   Note\
    \ that if a temporary address becomes deprecated as result of\n   processing a\
    \ Prefix Information Option with a zero Preferred\n   Lifetime, then a new temporary\
    \ address MUST NOT be generated.  To\n   ensure that a preferred temporary address\
    \ is always available, a new\n   temporary address SHOULD be regenerated slightly\
    \ before its\n   predecessor is deprecated.  This is to allow sufficient time\
    \ to avoid\n   race conditions in the case where generating a new temporary address\n\
    \   is not instantaneous, such as when duplicate address detection must\n   be\
    \ run.  The node SHOULD start the address regeneration process\n   REGEN_ADVANCE\
    \ time units before a temporary address would actually be\n   deprecated.\n  \
    \ As an optional optimization, an implementation MAY remove a\n   deprecated temporary\
    \ address that is not in use by applications or\n   upper layers as detailed in\
    \ Section 6.\n"
- title: 3.5.  Regeneration of Randomized Interface Identifiers
  contents:
  - "3.5.  Regeneration of Randomized Interface Identifiers\n   The frequency at which\
    \ temporary addresses changes depends on how a\n   device is being used (e.g.,\
    \ how frequently it initiates new\n   communication) and the concerns of the end\
    \ user.  The most egregious\n   privacy concerns appear to involve addresses used\
    \ for long periods of\n   time (weeks to months to years).  The more frequently\
    \ an address\n   changes, the less feasible collecting or coordinating information\n\
    \   keyed on interface identifiers becomes.  Moreover, the cost of\n   collecting\
    \ information and attempting to correlate it based on\n   interface identifiers\
    \ will only be justified if enough addresses\n   contain non-changing identifiers\
    \ to make it worthwhile.  Thus, having\n   large numbers of clients change their\
    \ address on a daily or weekly\n   basis is likely to be sufficient to alleviate\
    \ most privacy concerns.\n   There are also client costs associated with having\
    \ a large number of\n   addresses associated with a node (e.g., in doing address\
    \ lookups, the\n   need to join many multicast groups, etc.).  Thus, changing\
    \ addresses\n   frequently (e.g., every few minutes) may have performance\n  \
    \ implications.\n   Nodes following this specification SHOULD generate new temporary\n\
    \   addresses on a periodic basis.  This can be achieved automatically by\n  \
    \ generating a new randomized interface identifier at least once every\n   (TEMP_PREFERRED_LIFETIME\
    \ - REGEN_ADVANCE - DESYNC_FACTOR) time units.\n   As described above, generating\
    \ a new temporary address REGEN_ADVANCE\n   time units before a temporary address\
    \ becomes deprecated produces\n   addresses with a preferred lifetime no larger\
    \ than\n   TEMP_PREFERRED_LIFETIME.  The value DESYNC_FACTOR is a random value\n\
    \   (different for each client) that ensures that clients don't\n   synchronize\
    \ with each other and generate new addresses at exactly the\n   same time.  When\
    \ the preferred lifetime expires, a new temporary\n   address MUST be generated\
    \ using the new randomized interface\n   identifier.\n   Because the precise frequency\
    \ at which it is appropriate to generate\n   new addresses varies from one environment\
    \ to another, implementations\n   SHOULD provide end users with the ability to\
    \ change the frequency at\n   which addresses are regenerated.  The default value\
    \ is given in\n   TEMP_PREFERRED_LIFETIME and is one day.  In addition, the exact\
    \ time\n   at which to invalidate a temporary address depends on how\n   applications\
    \ are used by end users.  Thus, the suggested default\n   value of one week (TEMP_VALID_LIFETIME)\
    \ may not be appropriate in all\n   environments.  Implementations SHOULD provide\
    \ end users with the\n   ability to override both of these default values.\n \
    \  Finally, when an interface connects to a new link, a new randomized\n   interface\
    \ identifier SHOULD be generated immediately together with a\n   new set of temporary\
    \ addresses.  If a device moves from one ethernet\n   to another, generating a\
    \ new set of temporary addresses from a\n   different randomized interface identifier\
    \ ensures that the device\n   uses different randomized interface identifiers\
    \ for the temporary\n   addresses associated with the two links, making it more\
    \ difficult to\n   correlate addresses from the two different links as being from\
    \ the\n   same node.  The node MAY follow any process available to it, to\n  \
    \ determine that the link change has occurred.  One such process is\n   described\
    \ by Detecting Network Attachment [DNA].\n"
- title: 3.6.  Deployment Considerations
  contents:
  - "3.6.  Deployment Considerations\n   Devices implementing this specification MUST\
    \ provide a way for the\n   end user to explicitly enable or disable the use of\
    \ temporary\n   addresses.  In addition, a site might wish to disable the use\
    \ of\n   temporary addresses in order to simplify network debugging and\n   operations.\
    \  Consequently, implementations SHOULD provide a way for\n   trusted system administrators\
    \ to enable or disable the use of\n   temporary addresses.\n   Additionally, sites\
    \ might wish to selectively enable or disable the\n   use of temporary addresses\
    \ for some prefixes.  For example, a site\n   might wish to disable temporary\
    \ address generation for \"Unique local\"\n   [ULA] prefixes while still generating\
    \ temporary addresses for all\n   other global prefixes.  Another site might wish\
    \ to enable temporary\n   address generation only for the prefixes 2001::/16 and\
    \ 2002::/16,\n   while disabling it for all other prefixes.  To support this behavior,\n\
    \   implementations SHOULD provide a way to enable and disable generation\n  \
    \ of temporary addresses for specific prefix subranges.  This per-\n   prefix\
    \ setting SHOULD override the global settings on the node with\n   respect to\
    \ the specified prefix subranges.  Note that the pre-prefix\n   setting can be\
    \ applied at any granularity, and not necessarily on a\n   per-subnet basis.\n\
    \   The use of temporary addresses may cause unexpected difficulties with\n  \
    \ some applications.  As described below, some servers refuse to accept\n   communications\
    \ from clients for which they cannot map the IP address\n   into a DNS name. \
    \ In addition, some applications may not behave\n   robustly if temporary addresses\
    \ are used and an address expires\n   before the application has terminated, or\
    \ if it opens multiple\n   sessions, but expects them to all use the same addresses.\n\
    \   Consequently, the use of temporary addresses SHOULD be disabled by\n   default\
    \ in order to minimize potential disruptions.  Individual\n   applications, which\
    \ have specific knowledge about the normal duration\n   of connections, MAY override\
    \ this as appropriate.\n   If a very small number of nodes (say, only one) use\
    \ a given prefix\n   for extended periods of time, just changing the interface\
    \ identifier\n   part of the address may not be sufficient to ensure privacy,\
    \ since\n   the prefix acts as a constant identifier.  The procedures described\n\
    \   in this document are most effective when the prefix is reasonably non\n  \
    \ static or is used by a fairly large number of nodes.\n"
- title: 4.  Implications of Changing Interface Identifiers
  contents:
  - "4.  Implications of Changing Interface Identifiers\n   The IPv6 addressing architecture\
    \ goes to some lengths to ensure that\n   interface identifiers are likely to\
    \ be globally unique where easy to\n   do so.  The widespread use of temporary\
    \ addresses may result in a\n   significant fraction of Internet traffic not using\
    \ addresses in which\n   the interface identifier portion is globally unique.\
    \  Consequently,\n   usage of the algorithms in this document may complicate providing\n\
    \   such a future flexibility, if global uniqueness is necessary.\n   The desires\
    \ of protecting individual privacy versus the desire to\n   effectively maintain\
    \ and debug a network can conflict with each\n   other.  Having clients use addresses\
    \ that change over time will make\n   it more difficult to track down and isolate\
    \ operational problems.\n   For example, when looking at packet traces, it could\
    \ become more\n   difficult to determine whether one is seeing behavior caused\
    \ by a\n   single errant machine, or by a number of them.\n   Some servers refuse\
    \ to grant access to clients for which no DNS name\n   exists.  That is, they\
    \ perform a DNS PTR query to determine the DNS\n   name, and may then also perform\
    \ an AAAA query on the returned name to\n   verify that the returned DNS name\
    \ maps back into the address being\n   used.  Consequently, clients not properly\
    \ registered in the DNS may\n   be unable to access some services.  As noted earlier,\
    \ however, a\n   node's DNS name (if non-changing) serves as a constant identifier.\n\
    \   The wide deployment of the extension described in this document could\n  \
    \ challenge the practice of inverse-DNS-based \"authentication,\" which\n   has\
    \ little validity, though it is widely implemented.  In order to\n   meet server\
    \ challenges, nodes could register temporary addresses in\n   the DNS using random\
    \ names (for example, a string version of the\n   random address itself).\n  \
    \ Use of the extensions defined in this document may complicate\n   debugging\
    \ and other operational troubleshooting activities.\n   Consequently, it may be\
    \ site policy that temporary addresses should\n   not be used.  Consequently,\
    \ implementations MUST provide a method for\n   the end user or trusted administrator\
    \ to override the use of\n   temporary addresses.\n"
- title: 5.  Defined Constants
  contents:
  - "5.  Defined Constants\n   Constants defined in this document include:\n   TEMP_VALID_LIFETIME\
    \ -- Default value: 1 week.  Users should be able\n   to override the default\
    \ value.\n   TEMP_PREFERRED_LIFETIME -- Default value: 1 day.  Users should be\n\
    \   able to override the default value.\n   REGEN_ADVANCE -- 5 seconds\n   MAX_DESYNC_FACTOR\
    \ -- 10 minutes.  Upper bound on DESYNC_FACTOR.\n   DESYNC_FACTOR -- A random\
    \ value within the range 0 -\n   MAX_DESYNC_FACTOR.  It is computed once at system\
    \ start (rather than\n   each time it is used) and must never be greater than\n\
    \   (TEMP_VALID_LIFETIME - REGEN_ADVANCE).\n   TEMP_IDGEN_RETRIES -- Default value:\
    \ 3\n"
- title: 6.  Future Work
  contents:
  - "6.  Future Work\n   An implementation might want to keep track of which addresses\
    \ are\n   being used by upper layers so as to be able to remove a deprecated\n\
    \   temporary address from internal data structures once no upper layer\n   protocols\
    \ are using it (but not before).  This is in contrast to\n   current approaches\
    \ where addresses are removed from an interface when\n   they become invalid [ADDRCONF],\
    \ independent of whether or not upper\n   layer protocols are still using them.\
    \  For TCP connections, such\n   information is available in control blocks. \
    \ For UDP-based\n   applications, it may be the case that only the applications\
    \ have\n   knowledge about what addresses are actually in use.  Consequently,\
    \ an\n   implementation generally will need to use heuristics in deciding when\n\
    \   an address is no longer in use.\n   The determination as to whether to use\
    \ public versus temporary\n   addresses can in some cases only be made by an application.\
    \  For\n   example, some applications may always want to use temporary\n   addresses,\
    \ while others may want to use them only in some\n   circumstances or not at all.\
    \  Suitable API extensions will likely\n   need to be developed to enable individual\
    \ applications to indicate\n   with sufficient granularity their needs with regards\
    \ to the use of\n   temporary addresses.  Recommendations on DNS practices to\
    \ avoid the\n   problem described in Section 4 when reverse DNS lookups fail may\
    \ be\n   needed.  [DNSOP] contains a more detailed discussion of the DNS-\n  \
    \ related issues.\n   While this document discusses ways of obscuring a user's\
    \ permanent IP\n   address, the method described is believed to be ineffective\
    \ against\n   sophisticated forms of traffic analysis.  To increase effectiveness,\n\
    \   one may need to consider use of more advanced techniques, such as\n   Onion\
    \ Routing [ONION].\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Ingress filtering has been and is being deployed\
    \ as a means of\n   preventing the use of spoofed source addresses in Distributed\
    \ Denial\n   of Service (DDoS) attacks.  In a network with a large number of\n\
    \   nodes, new temporary addresses are created at a fairly high rate.\n   This\
    \ might make it difficult for ingress filtering mechanisms to\n   distinguish\
    \ between legitimately changing temporary addresses and\n   spoofed source addresses,\
    \ which are \"in-prefix\" (using a\n   topologically correct prefix and non-existent\
    \ interface ID).  This\n   can be addressed by using access control mechanisms\
    \ on a per-address\n   basis on the network egress point.\n"
- title: 8.  Significant Changes from RFC 3041
  contents:
  - "8.  Significant Changes from RFC 3041\n   This section summarizes the changes\
    \ in this document relative to RFC\n   3041 that an implementer of RFC 3041 should\
    \ be aware of.\n   1.  Excluded certain interface identifiers from the range of\n\
    \       acceptable interface identifiers.  Interface IDs such as those\n     \
    \  for reserved anycast addresses [RFC2526], etc.\n   2.  Added a configuration\
    \ knob that provides the end user with a way\n       to enable or disable the\
    \ use of temporary addresses on a per-\n       prefix basis.\n   3.  Added a check\
    \ for denial of service attacks using low valid\n       lifetimes in router advertisements.\n\
    \   4.  DAD is now run on all temporary addresses, not just the first one\n  \
    \     generated from an interface identifier.\n   5.  Changed the default setting\
    \ for usage of temporary addresses to\n       be disabled.\n   6.  The node is\
    \ now allowed to generate different interface\n       identifiers for different\
    \ prefixes, if it so desires.\n   7.  The algorithm used for generating random\
    \ interface identifiers is\n       no longer restricted to just MD5.\n   8.  Reduced\
    \ default number of retries to 3 and added a configuration\n       variable.\n\
    \   9.  Router advertisement (RA) processing algorithm is no longer\n       included\
    \ in the document, and is replaced by a reference to\n       [ADDRCONF].\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   Rich Draves and Thomas Narten were the authors of RFC\
    \ 3041.  They\n   would like to acknowledge the contributions of the ipv6 working\
    \ group\n   and, in particular, Ran Atkinson, Matt Crawford, Steve Deering,\n\
    \   Allison Mankin, and Peter Bieringer.\n   Suresh Krishnan was the sole author\
    \ of this version of the document.\n   He would like to acknowledge the contributions\
    \ of the ipv6 working\n   group and, in particular, Jari Arkko, Pekka Nikander,\
    \ Pekka Savola,\n   Francis Dupont, Brian Haberman, Tatuya Jinmei, and Margaret\
    \ Wasserman\n   for their detailed comments.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [ADDRARCH]     Hinden, R. and S. Deering, \"\
    IP Version 6 Addressing\n                  Architecture\", RFC 4291, February\
    \ 2006.\n   [ADDRCONF]     Thomson, S., Narten, T., and T. Jinmei, \"IPv6\n  \
    \                Stateless Address Autoconfiguration\", RFC 4862,\n          \
    \        September 2007.\n   [DISCOVERY]    Narten, T., Nordmark, E., Simpson,\
    \ W., and H. Soliman,\n                  \"Neighbor Discovery for IP version 6\
    \ (IPv6)\",\n                  RFC 4861, September 2007.\n   [MD5]          Rivest,\
    \ R., \"The MD5 Message-Digest Algorithm\",\n                  RFC 1321, April\
    \ 1992.\n   [RFC2119]      Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \                  Requirement Levels\", RFC 2119, March 1997.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [ADDR_SELECT]  Draves, R., \"Default Address\
    \ Selection for Internet\n                  Protocol version 6 (IPv6)\", RFC 3484,\
    \ February 2003.\n   [CGA]          Aura, T., \"Cryptographically Generated Addresses\n\
    \                  (CGA)\", RFC 3972, March 2005.\n   [COOKIES]      Kristol,\
    \ D. and L. Montulli, \"HTTP State Management\n                  Mechanism\",\
    \ RFC 2965, October 2000.\n   [DDNS]         Vixie, P., Thomson, S., Rekhter,\
    \ Y., and J. Bound,\n                  \"Dynamic Updates in the Domain Name System\
    \ (DNS\n                  UPDATE)\", RFC 2136, April 1997.\n   [DHCP]        \
    \ Droms, R., \"Dynamic Host Configuration Protocol\",\n                  RFC 2131,\
    \ March 1997.\n   [DHCPV6]       Droms, R., Bound, J., Volz, B., Lemon, T., Perkins,\n\
    \                  C., and M. Carney, \"Dynamic Host Configuration\n         \
    \         Protocol for IPv6 (DHCPv6)\", RFC 3315, July 2003.\n   [DNA]       \
    \   Choi, JH. and G. Daley, \"Goals of Detecting Network\n                  Attachment\
    \ in IPv6\", RFC 4135, August 2005.\n   [DNSOP]        Durand, A., Ihren, J.,\
    \ and P. Savola, \"Operational\n                  Considerations and Issues with\
    \ IPv6 DNS\", RFC 4472,\n                  April 2006.\n   [ONION]        Reed,\
    \ MGR., Syverson, PFS., and DMG. Goldschlag,\n                  \"Proxies for\
    \ Anonymous Routing\",  Proceedings of the\n                  12th Annual Computer\
    \ Security Applications Conference,\n                  San Diego, CA, December\
    \ 1996.\n   [RANDOM]       Eastlake, D., Schiller, J., and S. Crocker,\n     \
    \             \"Randomness Requirements for Security\", BCP 106,\n           \
    \       RFC 4086, June 2005.\n   [RFC2526]      Johnson, D. and S. Deering, \"\
    Reserved IPv6 Subnet\n                  Anycast Addresses\", RFC 2526, March 1999.\n\
    \   [SEND]         Arkko, J., Kempf, J., Zill, B., and P. Nikander,\n        \
    \          \"SEcure Neighbor Discovery (SEND)\", RFC 3971,\n                 \
    \ March 2005.\n   [ULA]          Hinden, R. and B. Haberman, \"Unique Local IPv6\
    \ Unicast\n                  Addresses\", RFC 4193, October 2005.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Thomas Narten\n   IBM Corporation\n   P.O. Box 12195\n\
    \   Research Triangle Park, NC\n   USA\n   EMail: narten@us.ibm.com\n   Richard\
    \ Draves\n   Microsoft Research\n   One Microsoft Way\n   Redmond, WA\n   USA\n\
    \   EMail: richdr@microsoft.com\n   Suresh Krishnan\n   Ericsson Research\n  \
    \ 8400 Decarie Blvd.\n   Town of Mount Royal, QC\n   Canada\n   EMail: suresh.krishnan@ericsson.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
