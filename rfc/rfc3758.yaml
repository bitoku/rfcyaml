- contents:
  - "              Stream Control Transmission Protocol (SCTP)\n                     Partial
    Reliability Extension\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This memo describes an extension to the Stream Control Transmission\n
    \  Protocol (SCTP) that allows an SCTP endpoint to signal to its peer\n   that
    it should move the cumulative ack point forward.  When both\n   sides of an SCTP
    association support this extension, it can be used\n   by an SCTP implementation
    to provide partially reliable data\n   transmission service to an upper layer
    protocol.  This memo describes\n   the protocol extensions, which consist of a
    new parameter for INIT\n   and INIT ACK, and a new FORWARD TSN chunk type, and
    provides one\n   example of a partially reliable service that can be provided
    to the\n   upper layer via this mechanism.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  2\n       1.1.  Overview of Protocol Extensions. . . . . . . . .
    . . . .  2\n       1.2.  Overview of New Services Provided to the Upper Layer
    . .  3\n       1.3.  Benefits of PR-SCTP  . . . . . . . . . . . . . . . . . .
    \ 4\n   2.  Conventions. . . . . . . . . . . . . . . . . . . . . . . . . .  5\n
    \  3.  Protocol Changes to support PR-SCTP .  . . . . . . . . . . . .  5\n       3.1.
    \ Forward-TSN-Supported Parameter For INIT and INIT ACK. .  5\n       3.2.  Forward
    Cumulative TSN Chunk Definition (FORWARD TSN). .  5\n       3.3.  Negotiation
    of Forward-TSN-Supported parameter . . . . .  7\n             3.3.1. Sending Forward-TSN-Supported
    param in INIT . . .  7\n             3.3.2. Receipt of Forward-TSN-Supported parameter
    in\n                    INIT or INIT-ACK. . . . . . . . . . . . . . . . .  7\n
    \            3.3.3. Receipt of Op. Error for Forward-TSN-Supported\n                    Param
    . . . . . . . . . . . . . . . . . . . . . .  8\n       3.4.  Definition of \"abandoned\"
    in the context of PR-SCTP. . .  8\n       3.5.  Sender Side Implementation of
    PR-SCTP. . . . . . . . . .  9\n       3.6.  Receiver Side Implementation of PR-SCTP.
    . . . . . . . . 12\n   4.  Services provided by PR-SCTP to the upper layer. .
    . . . . . . 14\n       4.1.  PR-SCTP Service Definition for \"timed reliability\"
    . . . 15\n       4.2.  PR-SCTP Association Establishment. . . . . . . . . . .
    . 16\n       4.3.  Guidelines for defining other PR-SCTP Services . . . . . 17\n
    \      4.4.  Usage Notes. . . . . . . . . . . . . . . . . . . . . . . 19\n   5.
    \ Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n   6.  Acknowledgments.
    . . . . . . . . . . . . . . . . . . . . . . . 19\n   7.  Security Considerations.
    . . . . . . . . . . . . . . . . . . . 19\n   8.  IANA Considerations. . . . .
    . . . . . . . . . . . . . . . . . 20\n   9.  References . . . . . . . . . . .
    . . . . . . . . . . . . . . . 20\n       9.1.  Normative References . . . . .
    . . . . . . . . . . . . . 20\n       9.2.  Informative References . . . . . .
    . . . . . . . . . . . 20\n   10. Authors' Addresses . . . . . . . . . . . . .
    . . . . . . . . . 20\n   11. Full Copyright Statement . . . . . . . . . . . .
    . . . . . . .\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This memo describes an extension to the Stream Control Transmission\n
    \  Protocol (SCTP) RFC 2960 [2] that allows an SCTP sender to signal to\n   its
    peer that it should no longer expect to receive one or more DATA\n   chunks.\n"
  - contents:
    - "1.1.  Overview of Protocol Extensions\n   The protocol extension described
      in this document consists of two new\n   elements:\n   1. a single new parameter
      in the INIT/INIT-ACK exchange that\n      indicates whether the endpoint supports
      the extension\n   2. a single new chunk type, FORWARD TSN, that indicates that
      the\n      receiver should move its cumulative ack point forward (possibly\n
      \     skipping past one or more DATA chunks that may not yet have been\n      received
      and/or acknowledged.)\n"
    title: 1.1.  Overview of Protocol Extensions
  - contents:
    - "1.2.  Overview of New Services Provided to the Upper Layer\n   When this extension
      is supported by both sides of an SCTP\n   association, it can be used to provide
      partially reliable transport\n   service over an SCTP association.  We define
      partially reliable\n   transport service as a service that allows the user to
      specify, on a\n   per message basis, the rules governing how persistent the
      transport\n   service should be in attempting to send the message to the receiver.\n
      \  One example of partially reliable service is specified in this\n   document,
      namely a \"timed reliability\" service.  This service allows\n   the service
      user to indicate a limit on the duration of time that the\n   sender should
      try to transmit/retransmit the message (this is a\n   natural extension of the
      \"lifetime\" parameter already in the base\n   protocol).\n   In addition to
      this example, we will also show that defining the\n   semantics of a particular
      partially reliable service involves two\n   elements, namely:\n   1. how the
      service user indicates the level of reliability required\n      for a particular
      message, and\n   2. how the sender side implementation uses that reliability
      level to\n      determine when to give up on further retransmissions of that\n
      \     message.\n   Note that other than the fact that the FORWARD-TSN chunk
      is required,\n   neither of these two elements impacts the \"on-the-wire\" protocol;\n
      \  only the API and the sender side implementation are affected by the\n   way
      in which the service is defined to the upper layer.  Therefore,\n   in principle,
      it is feasible to implement many varieties of partially\n   reliable services
      in a particular SCTP implementation without\n   changing the on-the-wire protocol.
      \ Also, the SCTP receiver does not\n   necessarily need to know which semantics
      of partially reliable\n   service are being used by the sender, since the receiver's
      only role\n   is to correctly interpret FORWARD TSN chunks, thereby skipping
      past\n   messages that the sender has decided to no longer transmit (or\n   retransmit).\n
      \  Nevertheless, it is recommended that a limited number of standard\n   definitions
      of partially reliable services be standardized by the\n   IETF so that the designers
      of IETF application layer protocols can\n   match the requirements of their
      upper layer protocols to standard\n   service definitions provided by a particular
      SCTP implementation.\n   One such definition, \"timed reliability\", is included
      in this\n   document.  Given the extensions proposed in this document, other\n
      \  definitions may be standardized as the need arises without further\n   changes
      to the on-the-wire protocol.\n"
    title: 1.2.  Overview of New Services Provided to the Upper Layer
  - contents:
    - "1.3.  Benefits of PR-SCTP\n   Hereafter, we use the notation \"Partial Reliable
      Stream Control\n   Transmission Protocol (PR-SCTP)\" to refer to the SCTP protocol,\n
      \  extended as defined in this document.\n   The following are some of the advantages
      for integrating partially\n   reliable data service into SCTP, i.e., benefits
      of PR-SCTP:\n   1. Some application layer protocols may benefit from being able
      to\n      use a single SCTP association to carry both reliable content, --\n
      \     such as text pages, billing and accounting information, setup\n      signaling
      -- and unreliable content, e.g., state that is highly\n      sensitive to timeliness,
      where generating a new packet is more\n      advantageous than transmitting
      an old one [3].\n   2. Partially reliable data traffic carried by PR-SCTP will
      enjoy the\n      same communication failure detection and protection capabilities\n
      \     as the normal reliable SCTP data traffic does.  This includes the\n      ability
      to quickly detect a failed destination address, fail-over\n      to an alternate
      destination address, and be notified if the data\n      receiver becomes unreachable.\n
      \  3. In addition to providing unordered, unreliable data transfer as\n      UDP
      does, PR-SCTP can provide ordered, unreliable data transfer\n      service.\n
      \  4. PR-SCTP employs the same congestion control and congestion\n      avoidance
      for all data traffic, whether reliable or partially\n      reliable - this is
      very desirable since SCTP enforces TCP-\n      friendliness (unlike UDP.)\n
      \  5. Because of the chunk bundling function of SCTP, reliable and\n      unreliable
      messages can be multiplexed over a single PR-SCTP\n      association.  Therefore,
      the number of IP datagrams (and hence the\n      network overhead) can be reduced
      instead of having to send these\n      different types of data using separate
      protocols.  Additionally,\n      this multiplexing allows for port savings versus
      using different\n      ports for reliable and unreliable connections.\n"
    title: 1.3.  Benefits of PR-SCTP
  title: 1.  Introduction
- contents:
  - "2.  Conventions\n   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT,
    SHOULD,\n   SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL, when\n
    \  they appear in this document, are to be interpreted as described in\n   BCP
    14, RFC 2119 [1].\n   Comparisons and arithmetic on Transport Sequence Numbers
    (TSNs) are\n   governed by the rules in Section 1.6 of RFC 2960 [2].\n"
  title: 2.  Conventions
- contents:
  - '3.  Protocol Changes to support PR-SCTP

    '
  - contents:
    - "3.1.  Forward-TSN-Supported Parameter For INIT and INIT ACK\n   The following
      new OPTIONAL parameter is added to the INIT and INIT\n   ACK chunks.\n   Parameter
      Name                       Status     Type Value\n   -------------------------------------------------------------\n
      \  Forward-TSN-Supported               OPTIONAL    49152 (0xC000)\n   At the
      initialization of the association, the sender of the INIT or\n   INIT ACK chunk
      MAY include this OPTIONAL parameter to inform its peer\n   that it is able to
      support the Forward TSN chunk (see Section 3.3 for\n   further details).  The
      format of this parameter is defined as\n   follows:\n    0 1 2 3 4 5 6 7 8 9
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |    Parameter Type = 49152     |  Parameter Length = 4         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type: 16 bit u_int\n      49152, indicating Forward-TSN-Supported parameter\n
      \  Length: 16 bit u_int\n      Indicates the size of the parameter, i.e., 4.\n"
    title: 3.1.  Forward-TSN-Supported Parameter For INIT and INIT ACK
  - contents:
    - "3.2 Forward Cumulative TSN Chunk Definition (FORWARD TSN)\n   The following
      new chunk type is defined:\n   Chunk Type    Chunk Name\n   ------------------------------------------------------\n
      \  192 (0xC0)    Forward Cumulative TSN (FORWARD TSN)\n   This chunk shall be
      used by the data sender to inform the data\n   receiver to adjust its cumulative
      received TSN point forward because\n   some missing TSNs are associated with
      data chunks that SHOULD NOT be\n   transmitted or retransmitted by the sender.\n
      \  Forward Cumulative TSN chunk has the following format:\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   Type = 192  |  Flags = 0x00 |        Length = Variable      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                      New Cumulative TSN                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |         Stream-1              |       Stream Sequence-1       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  \\                                                               /\n   /
      \                                                              \\\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |         Stream-N              |       Stream Sequence-N       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Chunk Flags:\n     Set to all zeros on transmit and ignored on receipt.\n
      \  New Cumulative TSN: 32 bit u_int\n    This indicates the new cumulative TSN
      to the data receiver.  Upon\n    the reception of this value, the data receiver
      MUST consider\n    any missing TSNs earlier than or equal to this value as received,\n
      \   and stop reporting them as gaps in any subsequent SACKs.\n   Stream-N: 16
      bit u_int\n    This field holds a stream number that was skipped by this\n    FWD-TSN.\n
      \  Stream Sequence-N: 16 bit u_int\n    This field holds the sequence number
      associated with the stream\n    that was skipped.  The stream sequence field
      holds the largest\n    stream sequence number in this stream being skipped.
      \ The receiver\n    of the FWD-TSN's can use the Stream-N and Stream Sequence-N
      fields\n    to enable delivery of any stranded TSN's that remain on the stream\n
      \   re-ordering queues.  This field MUST NOT report TSN's corresponding\n    to
      DATA chunks that are marked as unordered.  For ordered DATA\n    chunks this
      field MUST be filled in.\n"
    title: 3.2 Forward Cumulative TSN Chunk Definition (FORWARD TSN)
  - contents:
    - '3.3.  Negotiation of Forward-TSN-Supported parameter

      '
    - contents:
      - "3.3.1.  Sending Forward-TSN-Supported param in INIT\n   If an SCTP endpoint
        supports the FORWARD TSN chunk, then any time it\n   sends an INIT during
        association establishment, it MAY include the\n   Forward-TSN-supported parameter
        in the INIT chunk to indicate this\n   fact to its peer.\n   Note that if
        the endpoint chooses NOT to include the parameter, then\n   at no time during
        the life of the association can it send or process\n   a FORWARD TSN.  It
        MUST instead act as if it does NOT support the\n   FORWARD TSN chunk, returning
        an ERROR to the peer upon receipt of any\n   FORWARD TSN.\n"
      title: 3.3.1.  Sending Forward-TSN-Supported param in INIT
    - contents:
      - "3.3.2.  Receipt of Forward-TSN-Supported parameter in INIT or INIT-ACK\n
        \  When a receiver of an INIT detects a Forward-TSN-Supported parameter\n
        \  and does not support the Forward-TSN chunk type, the receiver MUST\n   follow
        the rules defined in Section 3.3.3 of RFC 2960 [2].\n   When a receiver of
        an INIT-ACK detects a Forward-TSN-Supported\n   parameter and it does not
        support the Forward-TSN chunk type, the\n   receiver MUST follow the rules
        defined in Section 3.3.3 of RFC 2960\n   [2].\n   When a receiver of an INIT
        detects a Forward-TSN-Supported parameter\n   and it does support the Forward-TSN
        chunk type, the receiver MAY\n   respond with a Forward-TSN-supported parameter
        in the INIT-ACK chunk.\n   Note that if the endpoint chooses NOT to include
        the parameter, then\n   at no time during the life of the association can
        it send or process\n   a FORWARD TSN.  It MUST instead act as if it does NOT
        support the\n   FORWARD TSN chunk, returning an ERROR to the peer upon receipt
        of any\n   FORWARD TSN.\n   When an endpoint that supports the FORWARD TSN
        chunk receives an INIT\n   that does not contain the Forward-TSN-Supported
        Parameter, that\n   endpoint:\n   o  MAY include the Forward-TSN-Supported
        parameter in the INIT-ACK,\n   o  SHOULD record the fact that the peer does
        not support the FORWARD\n      TSN chunk,\n   o  MUST NOT send a FORWARD TSN
        chunk at any time during the\n      associations life,\n   o  SHOULD inform
        the upper layer if the upper layer has requested\n      such notification.\n"
      title: 3.3.2.  Receipt of Forward-TSN-Supported parameter in INIT or INIT-ACK
    - contents:
      - "3.3.3.  Receipt of Op. Error for Forward-TSN-Supported Param\n   When an
        SCTP endpoint that desires to use the FORWARD TSN chunk\n   feature for partially
        reliable data transfer receives an operational\n   error from the remote endpoint
        (either bundled with the COOKIE or as\n   an unrecognized parameter in the
        INIT-ACK), indicating that the\n   remote endpoint does not recognize the
        Forward-TSN-Supported\n   parameter, the local endpoint SHOULD inform its
        upper layer of the\n   remote endpoint's inability to support partially reliable
        data\n   transfer.\n   The local endpoint may then choose to either:\n   1)
        end the initiation process (in cases where the initiation process\n      has
        already ended, the endpoint may need to send an ABORT) in\n      consideration
        of the peer's inability to supply the requested\n      features for the new
        association, or\n   2) continue the initiation process (in cases where the
        initiation\n      process has already completed, the endpoint MUST just mark
        the\n      association as not supporting partial reliability), but with the\n
        \     understanding that partially reliable data transmission is not\n      supported.
        \ In this case, the endpoint receiving the operational\n      error SHOULD
        note that the FORWARD TSN chunk is not supported, and\n      MUST NOT transmit
        a FORWARD TSN chunk at any time during the life\n      of the association.\n"
      title: 3.3.3.  Receipt of Op. Error for Forward-TSN-Supported Param
    title: 3.3.  Negotiation of Forward-TSN-Supported parameter
  - contents:
    - "3.4.  Definition of \"abandoned\" in the context of PR-SCTP\n   At some point,
      a sending PR-SCTP implementation MAY determine that a\n   particular data chunk
      SHOULD NOT be transmitted or retransmitted\n   further, in accordance with the
      rules governing some particular PR-\n   SCTP service definition (such as the
      definition of \"timed\n   reliability\" in Section 4.1.)  For purposes of this
      document, we\n   define the term \"abandoned\" to refer to any data chunk about
      which\n   the SCTP sender has made this determination.\n   Each PR-SCTP service
      defines the rules for determining when a TSN is\n   \"abandoned\", and accordingly,
      the rules that govern how, whether, and\n   when to \"abandon\" a TSN may vary
      from one service definition to\n   another.  However, the rules governing the
      actions taken when a TSN\n   is \"abandoned\" do NOT vary between service definitions;
      these rules\n   are included in Section 3.5.\n"
    title: 3.4.  Definition of "abandoned" in the context of PR-SCTP
  - contents:
    - "3.5.  Sender Side Implementation of PR-SCTP\n   The sender side implementation
      of PR-SCTP is identical to that of the\n   base SCTP protocol, except for:\n
      \  o  actions a sending side PR-SCTP implementation must take when a TSN\n      is
      \"abandoned\" (as per the rules of whatever PR-SCTP service\n      definition
      is in effect)\n   o  special actions that a PR-SCTP implementation must take
      upon\n      receipt of SACK\n   o  rules governing the generation of FORWARD
      TSN chunks.\n   In detail, these exceptions are as follows:\n   A1) The sender
      maintains an \"Advanced.Peer.Ack.Point\" for each peer\n       to track a theoretical
      cumulative TSN point of the peer (Note,\n       this is a _new_ protocol variable
      and its value is NOT\n       necessarily the same as the SCTP \"Cumulative TSN
      Ack Point\" as\n       defined in Section 1.4 of RFC 2960 [2], and as discussed\n
      \      throughout that document.)\n   A2) From time to time, as governed by
      the rules of a particular PR-\n       SCTP service definition (see Section 4),
      the SCTP data sender may\n       make a determination that a particular data
      chunk that has\n       already been assigned a TSN SHOULD be \"abandoned\".\n
      \      When a data chunk is \"abandoned\", the sender MUST treat the data\n
      \      chunk as being finally acked and no longer outstanding.\n       The sender
      MUST NOT credit an \"abandoned\" data chunk to the\n       partial_bytes_acked
      as defined in Section 7.2.2 of RFC 2960 [2],\n       and MUST NOT advance the
      cwnd based on this \"abandoned\" data\n       chunk.\n   A3) When a TSN is \"abandoned\",
      if it is part of a fragmented message,\n       all other TSN's within that fragmented
      message MUST be abandoned\n       at the same time.\n   A4) Whenever the data
      sender receives a SACK from the data receiver,\n       it MUST first process
      the SACK using the normal procedures as\n       defined in Section 6.2.1 of
      RFC 2960 [2].\n   The data sender MUST then perform the following additional
      steps:\n       C1) Let SackCumAck be the Cumulative TSN ACK carried in the\n
      \          received SACK.\n           If (Advanced.Peer.Ack.Point < SackCumAck),
      then update\n           Advanced.Peer.Ack.Point to be equal to SackCumAck.\n
      \      C2) Try to further advance the \"Advanced.Peer.Ack.Point\" locally,\n
      \          that is, to move \"Advanced.Peer.Ack.Point\" up as long as the\n
      \          chunk next in the out-queue space is marked as \"abandoned\",\n           as
      shown in the following example:\n       Assuming that a SACK arrived with the
      Cumulative TSN ACK =\n       102 and the Advanced.Peer.Ack.Point is updated
      to this\n       value:\n       out-queue at the end of  ==>   out-queue after
      Adv.Ack.Point\n       normal SACK processing         local advancement\n                    ...
      \                           ...\n       Adv.Ack.Pt-> 102 acked                      102
      acked\n                    103 abandoned                    103 abandoned\n
      \                   104 abandoned        Adv.Ack.P-> 104 abandoned\n                    105
      \                           105\n                    106 acked                      106
      acked\n                    ...                            ...\n       In this
      example, the data sender successfully advanced the\n       \"Advanced.Peer.Ack.Point\"
      from 102 to 104 locally.\n       C3) If, after step C1 and C2, the \"Advanced.Peer.Ack.Point\"
      is\n           greater than the Cumulative TSN ACK carried in the received\n
      \          SACK, the data sender MUST send the data receiver a FORWARD\n           TSN
      chunk containing the latest value of the\n           \"Advanced.Peer.Ack.Point\".
      \ Note that the sender MAY delay\n           the sending of a FORWARD TSN as
      defined in rule F2 below.\n           IMPLEMENTATION NOTE: It is an implementation
      decision as to\n           which destination address it is to be sent to, the
      only\n           restriction being that the address MUST be one that is\n           CONFIRMED.\n
      \      C4) For each \"abandoned\" TSN, the sender of the FORWARD TSN MUST\n
      \          determine if the chunk has a valid stream and sequence number\n           (i.e.,
      it was ordered).  If the chunk has a valid stream and\n           sequence number,
      the sender MUST include the stream and\n           sequence number in the FORWARD
      TSN.  This information will\n           enable the receiver to easily find any
      stranded TSN's waiting\n           on stream reorder queues.  Each stream SHOULD
      only be\n           reported once; this means that if multiple abandoned messages\n
      \          occur in the same stream, then only the highest abandoned\n           stream
      sequence number is reported.  If the total size of the\n           FORWARD TSN
      does NOT fit in a single MTU, then the sender of\n           the FORWARD TSN
      SHOULD lower the Advanced.Peer.Ack.Point to\n           the last TSN that will
      fit in a single MTU.\n       C5) If a FORWARD TSN is sent, the sender MUST assure
      that at\n           least one T3-rtx timer is running.  IMPLEMENTATION NOTE:
      Any\n           destination's timer may be used for the purposes of rule C5.\n
      \  A5) Any time the T3-rtx timer expires, on any destination, the sender\n       SHOULD
      try to advance the \"Advanced.Peer.Ack.Point\" by following\n       the procedures
      outlined in C2 - C5.\n   The following additional rules govern the generation
      of FORWARD TSN\n   chunks:\n   F1) An endpoint MUST NOT use the FORWARD TSN
      for any purposes other\n       than circumstances described in this document.\n
      \  F2) The data sender SHOULD always attempt to bundle an outgoing\n       FORWARD
      TSN with outbound DATA chunks for efficiency.\n       A sender MAY even choose
      to delay the sending of the FORWARD TSN\n       in the hope of bundling it with
      an outbound DATA chunk.\n       IMPLEMENTATION NOTE: An implementation may wish
      to limit the\n       number of duplicate FORWARD TSN chunks it sends by either
      only\n       sending a duplicate FORWARD TSN every other SACK or waiting a\n
      \      full RTT before sending a duplicate FORWARD TSN.\n       IMPLEMENTATION
      NOTE: An implementation may allow the maximum\n       delay for generating a
      FORWARD TSN to be configured either\n       statically or dynamically in order
      to meet the specific timing\n       requirements of the protocol being carried,
      but see the next\n       rule:\n   F3) Any delay applied to the sending of FORWARD
      TSN chunk SHOULD NOT\n       exceed 200ms and MUST NOT exceed 500ms.  In other
      words, an\n       implementation MAY lower this value below 500ms but MUST NOT\n
      \      raise it above 500ms.\n       NOTE: Delaying the sending of FORWARD TSN
      chunks may cause delays\n       in the receiver's ability to deliver other data
      being held at the\n       receiver for re-ordering.  The values of 200ms and
      500ms match\n       the required values for the delayed acknowledgement in RFC
      2960\n       [2] since delaying a FORWARD TSN has the same consequences but
      in\n       the reverse direction.\n   F4) The detection criterion for out-of-order
      SACKs MUST remain the\n       same as stated in RFC 2960, that is, a SACK is
      only considered\n       out-of-order if the Cumulative TSN ACK carried in the
      SACK is\n       earlier than that of the previous received SACK (i.e., the\n
      \      comparison MUST NOT be made against \"Advanced.Peer.Ack.Point\").\n   F5)
      If the decision to \"abandon\" a chunk is made, no matter how such\n       a
      decision is made, the appropriate congestion adjustment MUST be\n       made
      as specified in RFC 2960 if the chunk would have been marked\n       for retransmission
      later (e.g., either by T3-Timeout or by Fast\n       Retransmit).\n"
    title: 3.5.  Sender Side Implementation of PR-SCTP
  - contents:
    - "3.6.  Receiver Side Implementation of PR-SCTP\n   The receiver side implementation
      of PR-SCTP at an SCTP endpoint A is\n   capable of supporting any PR-SCTP service
      definition used by the\n   sender at endpoint B, even if that service definition
      is not\n   supported by the sending side functionality of host A.  All that
      is\n   necessary is that the receiving side correctly handle the Forward-\n
      \  TSN-Supported parameter as specified in Section 3.3, and correctly\n   handle
      the receipt of FORWARD TSN chunks as specified below.\n   DATA chunk arrival
      at a PR-SCTP receiver proceeds exactly as for DATA\n   chunk arrival at a base
      protocol SCTP receiver---that is, the\n   receiver MUST perform the same TSN
      handling, including duplicate\n   detection, gap detection, SACK generation,
      cumulative TSN\n   advancement, etc. as defined in RFC 2960 [2]---with the following\n
      \  exceptions and additions.\n   When a FORWARD TSN chunk arrives, the data
      receiver MUST first update\n   its cumulative TSN point to the value carried
      in the FORWARD TSN\n   chunk, and then MUST further advance its cumulative TSN
      point locally\n   if possible, as shown by the following example:\n      Assuming
      that the new cumulative TSN carried in the arrived\n      FORWARD TSN is 103:\n
      \      in-queue before processing      in-queue after processing\n            the
      FORWARD TSN      ==>   the FORWARD TSN and further\n                                                advancement\n
      \      cum.TSN.Pt-> 102 received                   102 --\n                    103
      missing                    103 --\n                    104 received                   104
      --\n                    105 received      cum.TSN.Pt-> 105 received\n                    106
      missing                    106 missing\n                    107 received                   107
      received\n                    ...                            ...\n      In this
      example, the receiver's cumulative TSN point is first\n      updated to 103
      and then further advanced to 105.\n   After the above processing, the data receiver
      MUST stop reporting any\n   missing TSNs earlier than or equal to the new cumulative
      TSN point.\n   Note, if the \"New Cumulative TSN\" value carried in the arrived\n
      \  FORWARD TSN chunk is found to be behind or at the current cumulative\n   TSN
      point, the data receiver MUST treat this FORWARD TSN as out-of-\n   date and
      MUST NOT update its Cumulative TSN.  The receiver SHOULD\n   send a SACK to
      its peer (the sender of the FORWARD TSN) since such a\n   duplicate may indicate
      the previous SACK was lost in the network.\n   Any time a FORWARD TSN chunk
      arrives, for the purposes of sending a\n   SACK, the receiver MUST follow the
      same rules as if a DATA chunk had\n   been received (i.e., follow the delayed
      sack rules specified in RFC\n   2960 [2] section 6.2).\n   Whenever a DATA chunk
      arrives with the 'U' bit set to '0' (indicating\n   ordered delivery) and is
      out of order, the receiver must hold the\n   chunk for reordering.  Since it
      is possible with PR-SCTP that a DATA\n   chunk being waited upon will not be
      retransmitted, special actions\n   will need to be taken upon the arrival of
      a FORWARD TSN.\n   In particular, during processing of a FORWARD TSN, the receiver
      MUST\n   use the stream sequence information to examine all of the listed\n
      \  stream reordering queues, and immediately make available for delivery\n   stream
      sequence numbers earlier than or equal to the stream sequence\n   number listed
      inside the FORWARD TSN.  Any such stranded data SHOULD\n   be made immediately
      available to the upper layer application.\n   An application using PR-SCTP receiving
      data should be aware of\n   possible missing messages.  The stream sequence
      number can be used,\n   in such a case, to determine that an intervening message
      has been\n   skipped.  When intervening messages are missing, it is an application\n
      \  decision to process the messages or to take some other corrective\n   action.\n
      \  After receiving and processing a FORWARD TSN, the data receiver MUST\n   take
      cautions in updating its re-assembly queue.  The receiver MUST\n   remove any
      partially reassembled message, which is still missing one\n   or more TSNs earlier
      than or equal to the new cumulative TSN point.\n   In the event that the receiver
      has invoked the partial delivery API,\n   a notification SHOULD also be generated
      to inform the upper layer API\n   that the message being partially delivered
      will NOT be completed.\n   Note that after receiving a FORWARD TSN and updating
      the cumulative\n   acknowledgement point, if a TSN that was skipped does arrive
      (i.e.,\n   due to network reordering), then the receiver will follow the normal\n
      \  rules defined in RFC 2960 [2] for handling duplicate data.  This\n   implies
      that the receiver will drop the chunk and report it as a\n   duplicate in the
      next outbound SACK chunk.\n"
    title: 3.6.  Receiver Side Implementation of PR-SCTP
  title: 3.  Protocol Changes to support PR-SCTP
- contents:
  - "4.  Services provided by PR-SCTP to the upper layer\n   As described in Section
    1.2, it is feasible to implement a variety of\n   partially reliable transport
    services using the new protocol\n   mechanisms introduced in Section 3; introducing
    these new services\n   requires making changes only at the sending side API, and
    the sending\n   side protocol implementation.  Thus, there may be a temptation
    to\n   standardize only the protocol, and leave the service definition as\n   \"implementation
    specific\" or leave it to be defined in\n   \"informational\" documents.\n   However,
    for those who may wish to write IETF standards for upper\n   layer protocols implemented
    over PR-SCTP, it is important to be able\n   to refer to a standard definition
    of services provided.  Therefore,\n   this section provides example definitions
    of one such service, while\n   also providing guidelines for the definition of
    additional services\n   as required.  Each such service may be proposed as a separate
    new\n   RFC.\n   Section 4 is organized as follows:\n   o  Section 4.1 provides
    the definition of one specific PR-SCTP\n      service: timed reliability.\n   o
    \ Section 4.2 describes how a particular PR-SCTP service definition\n      is
    requested by the upper layer during association establishment,\n      and how
    the upper layer is notified if that request cannot be\n      satisfied.\n   o
    \ Section 4.3 then provides guidelines for the specification of PR-\n      SCTP
    services other then the one defined in this memo.\n   o  Finally, Section 4.4
    describes some additional usage notes that\n      upper layer protocol designers
    and implementors may find helpful.\n"
  - contents:
    - "4.1.  PR-SCTP Service Definition for \"timed reliability\"\n   The \"timed
      reliability\" service is a natural extension of the\n   \"lifetime\" concept
      already present in the base SCTP protocol.\n   When this service is requested
      for an SCTP association, it changes\n   the meaning of the lifetime parameter
      specified in the SEND primitive\n   (see Section 10.1, part (E) of RFC 2960
      [2]; note that the parameter\n   is spelled \"life time\" in that document.)\n
      \  In the base SCTP protocol, the lifetime parameter is used to avoid\n   sending
      stale data.  When a lifetime value is indicated for a\n   particular message
      and that lifetime expires, SCTP cancels the\n   sending of this message, and
      notifies the ULP if the first\n   transmission of the data does not take place
      (because of rwnd or cwnd\n   limitations, or for any other reason).  However,
      in the base\n   protocol, if SCTP has sent the first transmission before the
      lifetime\n   expires, then the message MUST be sent as a normal reliable message.\n
      \  During episodes of congestion this is particularly unfortunate, as\n   retransmission
      wastes bandwidth that could have been used for other\n   (non-lifetime expired)
      messages.\n   When the \"timed reliability\" service is invoked, this latter\n
      \  restriction is removed.  Specifically, when the \"timed reliability\"\n   service
      is in effect, the following rules govern all messages that\n   are sent with
      a lifetime parameter:\n   TR1) If the lifetime parameter of a message is SCTP_LIFETIME_RELIABLE\n
      \       (or unspecified see Section 5), that message is treated as a\n        normal
      reliable SCTP message, just as in the base SCTP protocol.\n   TR2) If the lifetime
      parameter is not SCTP_LIFETIME_RELIABLE (see\n        Section 5), then the SCTP
      sender MUST treat the message just as\n        if it were a normal reliable
      SCTP message, as long as the\n        lifetime has not yet expired.\n   TR3)
      Before assigning a TSN to any message, the SCTP sender MUST\n        evaluate
      the lifetime of that message.  If it is expired, the\n        SCTP sender MUST
      NOT assign a TSN to that message, but instead,\n        SHOULD issue a notification
      to the upper layer and abandon the\n        message.\n   TR4) Before transmitting
      or retransmitting a message for which a TSN\n        is already assigned, the
      SCTP sender MUST evaluate the lifetime\n        of the message.  If the lifetime
      of the message is expired, the\n        SCTP sender MUST \"abandon\" the message,
      as per the rules\n        specified in Section 3.5 marking that TSN as eligible
      for\n        forward TSN.  Note that this meets the requirement G1 defined in\n
      \       Section 4.3.  IMPLEMENTATION NOTE: An implementation SHOULD\n        delay
      TSN assignment as mentioned in RFC 2960 [2] Section 10.1.\n        In such a
      case, the lifetime parameter should be checked BEFORE\n        assigning a TSN,
      thus allowing a message to be abandoned without\n        the need to send a
      FORWARD TSN.\n   TR5) The sending SCTP MAY evaluate the lifetime of messages
      at\n        anytime.  Expired messages that have not been assigned a TSN MAY\n
      \       be handled as per rule TR3.  Expired messages that HAVE been\n        assigned
      a TSN MAY be handled as per rule TR4.\n   TR6) The sending application MUST
      NOT change the lifetime parameter\n        once the message is passed to the
      sending SCTP.\n   Implementation Note: Rules TR1 through TR4 are designed in
      such a way\n   as to avoid requiring the implementer to maintain a separate
      timer\n   for each message; instead, the lifetime need only be evaluated at\n
      \  points in the life of the message where actions are already being\n   taken,
      such as TSN assignment, transmission, or expiration of a\n   retransmission
      timeout.  Rule TR5 is intended to give the SCTP\n   implementor flexibility
      to evaluate lifetime at any other convenient\n   opportunity, WITHOUT requiring
      that lifetime be evaluated immediately\n   at the point in time where it expires.\n"
    title: 4.1.  PR-SCTP Service Definition for "timed reliability"
  - contents:
    - "4.2.  PR-SCTP Association Establishment\n   An upper layer protocol (ULP) that
      uses PR-SCTP may need to know\n   whether PR-SCTP can be supported on a given
      association.  Therefore,\n   the ULP needs to have some indication of whether
      the FORWARD-TSN\n   chunk is supported by its peer.\n   Section 10.1 of RFC
      2960 [2] describes abstract primitives for the\n   ULP-to-SCTP interface, while
      noting that \"individual implementations\n   must define their own exact format,
      and may provide combinations or\n   subsets of the basic functions in single
      calls.\"\n   In this section, we describe one additional return value that may
      be\n   added to the ASSOCIATE primitive to allow an SCTP service user to\n   indicate
      whether the FORWARD-TSN chunk is supported by its peer.\n   RFC 2960 indicates
      that the ASSOCIATE primitive \"allows the upper\n   layer to initiate an association
      to a specific peer endpoint\".  It is\n   structured as follows:\n   Format:
      ASSOCIATE(local SCTP instance name, destination transport\n         addr, outbound
      stream count)\n   -> association id [,destination transport addr list]\n      [,outbound
      stream count]\n   This extension adds one new OPTIONAL return value, such that
      the new\n   primitive reads as follows:\n   Format: ASSOCIATE(local SCTP instance
      name, destination transport\n         addr, outbound stream count )\n   -> association
      id [,destination transport addr list]\n      [,outbound stream count] [,forward
      tsn supported]\n   NOTE: As per RFC 2960, if the ASSOCIATE primitive is implemented
      as a\n   non-blocking call, the new OPTIONAL return value shall be passed with\n
      \  the association parameters using the COMMUNICATION UP notification.\n   The
      new OPTIONAL parameter \"forward tsn supported\" is a boolean flag:\n   (0)
      false [default] indicates that FORWARD TSN is not enabled by both\n       endpoints.\n
      \  (1) true indicates that FORWARD TSN is enabled on both endpoints.\n   We
      also add a new primitive to allow the user application to enable/\n   disable
      the PR-SCTP service on its endpoint before an association is\n   established.\n
      \  Format: ENABLE_PRSCTP(local SCTP instance name, boolean enable)\n   The boolean
      parameter enable, if set to true, will enable PR-SCTP\n   upon future endpoint
      associations.  If the boolean parameter is set\n   to false, then the local
      endpoint will not advertise support of PR-\n   SCTP and thus disable the feature
      on future associations.  It is\n   recommended that this option be disabled
      by default, i.e., in order\n   to enable PR-SCTP, the user will need to call
      this API option with\n   the enable flag set to \"true\".\n"
    title: 4.2.  PR-SCTP Association Establishment
  - contents:
    - "4.3.  Guidelines for defining other PR-SCTP Services\n   Other PR-SCTP services
      may be defined and implemented as dictated by\n   the needs of upper layer protocols.
      \ If such upper layer protocols\n   are to be standardized and require some
      particular PR-SCTP service\n   other than the one defined in this document (i.e.,
      \"timed\n   reliability\"), then those additional PR-SCTP services should also
      be\n   specified and standardized in a new RFC.\n   It is suggested that any
      such additional service definitions be\n   modeled after the contents of Section
      4.1.  In particular, the\n   service definition should provide:\n   1. A description
      of how the service user specifies any parameters\n      that need to be associated
      with a particular message (and/or any\n      other communication that takes
      place between the application and\n      the SCTP transport sender) that provides
      the SCTP transport sender\n      with the information needed to determine when
      to give up on\n      transmission of a particular message.\n      Preferably,
      this description should reference the primitives in\n      the abstract API
      provided in Section 10 of RFC 2960 [2],\n      indicating any:\n      *  changes
      to the interpretation of the existing parameters of\n         existing primitives,\n
      \     *  additional parameters to be added to existing primitives (these\n         should
      be OPTIONAL, and default values should be indicated),\n      *  additional primitives
      that may be needed.\n   2. A description of the rules used by the sender side
      implementation\n      to determine when to give up on messages that have not
      yet been\n      assigned a TSN.  This description should also indicate what\n
      \     protocol events trigger the evaluation, and what actions to take\n      (e.g.,
      notifications.)\n   3. A description of the rules used by the sender side implementation\n
      \     to determine when to give up on the transmission or retransmission\n      of
      messages that have already been assigned a TSN, and may have\n      been transmitted
      and possibly retransmitted zero or more times.\n   Items (2) and (3) in the
      list above should also indicate what\n   protocol events trigger the evaluation,
      and what actions to take if\n   the determination is made that the sender should
      give up on\n   transmitting the message (e.g., notifications to the ULP.)\n
      \  Note that in any PR-SCTP service, the following rule MUST be\n   specified
      to avoid a protocol deadlock:\n   (G1) When the sender side implementation gives
      up on transmitting a\n        message that has been assigned a TSN (i.e., when
      that message is\n        \"abandoned\", as defined in Section 3.4), the sender
      side MUST\n        mark that TSN as eligible for forward TSN, and the rules
      in\n        Section 3.4 regarding the sending of FORWARD TSN chunks MUST be\n
      \       followed.\n   Finally, a PR-SCTP service definition should specify a
      \"canonical\n   service name\" to uniquely identify the service, and distinguish
      it\n   from other PR-SCTP services.  This name can then be used in upper\n   layer
      protocol standards to indicate which PR-SCTP service definition\n   is required
      by that upper layer protocol.  It can also be used in the\n   documentation
      of APIs of PR-SCTP implementations to indicate how an\n   upper layer indicates
      which definition of PR-SCTP service should\n   apply.  The canonical service
      name for the PR-SCTP service defined in\n   Section 4.1 is \"timed reliability\".\n"
    title: 4.3.  Guidelines for defining other PR-SCTP Services
  - contents:
    - "4.4.  Usage Notes\n   Detecting missing data in a PR-SCTP stream is useful
      for some\n   applications (e.g., Fibre channel or SCSI over IP).  With PR-SCTP,\n
      \  this becomes possible - the upper layer simply needs to examine the\n   stream
      sequence number of the arrived user messages of that stream to\n   detect any
      missing data.  Note, this detection only works when all\n   the messages on
      that stream are sent in order, i.e., the \"U\" bit is\n   not set.\n"
    title: 4.4.  Usage Notes
  title: 4.  Services provided by PR-SCTP to the upper layer
- contents:
  - "5.  Variables\n   This section defines variables used throughout this document:\n
    \  SCTP_LIFETIME_RELIABLE - A user interface indication defined by an\n   implementation
    and used to indicate when a message is to be\n   considered fully reliable.\n"
  title: 5.  Variables
- contents:
  - "6.  Acknowledgments\n   The authors would like to thank Brian Bidulock, Scott
    Bradner, Jon\n   Berger, Armando L. Caro Jr., John Loughney, Jon Peterson, Ivan
    Arias\n   Rodriguez, Ian Rytina, Chip Sharp, and others for their comments.\n"
  title: 6.  Acknowledgments
- contents:
  - "7.  Security Considerations\n   This document does not introduce any new security
    concerns to SCTP\n   other than the ones already documented in RFC 2960 [2].  In\n
    \  particular, this document shares the same security issues as\n   unordered
    data within RFC 2960 [2] identified by RFC 3436 [4].  An\n   application using
    the PR-SCTP extension should not use transport\n   layer security; further details
    can be found in RFC 3436 [4].\n   Note that the ability to cause a message to
    be skipped (i.e, the\n   FORWARD TSN chunk) does not provide any new attack for
    a Man-In-the-\n   Middle (MIM), since the MIM already is capable of changing and/or\n
    \  withholding data, thus effectively skipping messages.  However, the\n   FORWARD
    TSN chunk does provide a mechanism to make it easier for a\n   MIM to skip selective
    messages when the application has this feature\n   enabled since the MIM would
    have less state to maintain.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   IANA has assigned 192 as a new chunk type to SCTP.\n
    \  IANA has assigned 49152 as a new parameter type code to SCTP.\n"
  title: 8.  IANA Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs
      to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n   [2]
      \ Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer,\n        H.,
      Taylor, T., Rytina, I., Kalla, M., Zhang, L. and V. Paxson,\n        \"Stream
      Control Transmission Protocol\", RFC 2960, October 2000.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [3]  Clark, D. and D. Tennenhouse, \"Architectural
      Considerations for\n        a New Generation of Protocols\", SIGCOMM 1990 pp.
      200-208,\n        September 1990.\n   [4]  Jungmaier, A., Rescorla, E. and M.
      Tuexen, \"Transport Layer\n        Security over Stream Control Transmission
      Protocol\", RFC 3436,\n        December 2002.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "10.  Authors' Addresses\n   Randall R. Stewart\n   Cisco Systems, Inc.\n   8725
    West Higgins Road\n   Suite 300\n   Chicago, IL  60631\n   USA\n   Phone: +1-815-477-2127\n
    \  EMail: rrs@cisco.com\n   Michael A. Ramalho\n   Cisco Systems, Inc.\n   1802
    Rue de la Porte\n   Wall Township, NJ  07719-3784\n   USA\n   Phone: +1.732.449.5762\n
    \  EMail: mramalho@cisco.com\n   Qiaobing Xie\n   Motorola, Inc.\n   1501 W. Shure
    Drive, #2309\n   Arlington Heights, IL  60004\n   USA\n   Phone: +1-847-632-3028\n
    \  EMail: qxie1@email.mot.com\n   Michael Tuexen\n   Univ. of Applied Sciences
    Muenster\n   Stegerwaldstr. 39\n   48565 Steinfurt\n   Germany\n   EMail: tuexen@fh-muenster.de\n
    \  Phillip T. Conrad\n   University of Delaware\n   Department of Computer and
    Information Sciences\n   Newark, DE  19716\n   USA\n   Phone: +1 302 831 8622\n
    \  EMail: conrad@acm.org\n   URI:   http://www.cis.udel.edu/~pconrad\n"
  title: 10.  Authors' Addresses
- contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2004).
    \ This document is subject\n   to the rights, licenses and restrictions contained
    in BCP 78, and\n   except as set forth therein, the authors retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: 11.  Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
