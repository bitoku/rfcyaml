- title: __initial_text__
  contents:
  - "               Traversal Using Relays around NAT (TURN):\n     Relay Extensions\
    \ to Session Traversal Utilities for NAT (STUN)\n"
- title: Abstract
  contents:
  - "Abstract\n   If a host is located behind a NAT, then in certain situations it\
    \ can\n   be impossible for that host to communicate directly with other hosts\n\
    \   (peers).  In these situations, it is necessary for the host to use\n   the\
    \ services of an intermediate node that acts as a communication\n   relay.  This\
    \ specification defines a protocol, called TURN (Traversal\n   Using Relays around\
    \ NAT), that allows the host to control the\n   operation of the relay and to\
    \ exchange packets with its peers using\n   the relay.  TURN differs from some\
    \ other relay control protocols in\n   that it allows a client to communicate\
    \ with multiple peers using a\n   single relay address.\n   The TURN protocol\
    \ was designed to be used as part of the ICE\n   (Interactive Connectivity Establishment)\
    \ approach to NAT traversal,\n   though it also can be used without ICE.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5766.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n   2.  Overview of Operation  . . . . . . . . . . . . . . .\
    \ . . . . .  5\n     2.1.  Transports . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  8\n     2.2.  Allocations  . . . . . . . . . . . . . . . . . . . .\
    \ . . .  9\n     2.3.  Permissions  . . . . . . . . . . . . . . . . . . . . .\
    \ . . 11\n     2.4.  Send Mechanism . . . . . . . . . . . . . . . . . . . . .\
    \ . 12\n     2.5.  Channels . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 13\n     2.6.  Unprivileged TURN Servers  . . . . . . . . . . . . . . . . 15\n\
    \     2.7.  Avoiding IP Fragmentation  . . . . . . . . . . . . . . . . 16\n  \
    \   2.8.  RTP Support  . . . . . . . . . . . . . . . . . . . . . . . 17\n    \
    \ 2.9.  Anycast Discovery of Servers . . . . . . . . . . . . . . . 17\n   3. \
    \ Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . 18\n   4.  General\
    \ Behavior . . . . . . . . . . . . . . . . . . . . . . . 19\n   5.  Allocations\
    \  . . . . . . . . . . . . . . . . . . . . . . . . . 22\n   6.  Creating an Allocation\
    \ . . . . . . . . . . . . . . . . . . . . 23\n     6.1.  Sending an Allocate Request\
    \  . . . . . . . . . . . . . . . 23\n     6.2.  Receiving an Allocate Request\
    \  . . . . . . . . . . . . . . 24\n     6.3.  Receiving an Allocate Success Response\
    \ . . . . . . . . . . 28\n     6.4.  Receiving an Allocate Error Response . .\
    \ . . . . . . . . . 29\n   7.  Refreshing an Allocation . . . . . . . . . . .\
    \ . . . . . . . . 31\n     7.1.  Sending a Refresh Request  . . . . . . . . .\
    \ . . . . . . . 31\n     7.2.  Receiving a Refresh Request  . . . . . . . . .\
    \ . . . . . . 31\n     7.3.  Receiving a Refresh Response . . . . . . . . . .\
    \ . . . . . 32\n   8.  Permissions  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 32\n   9.  CreatePermission . . . . . . . . . . . . . . . . . . . .\
    \ . . . 34\n     9.1.  Forming a CreatePermission Request . . . . . . . . . .\
    \ . . 34\n     9.2.  Receiving a CreatePermission Request . . . . . . . . . .\
    \ . 34\n     9.3.  Receiving a CreatePermission Response  . . . . . . . . . .\
    \ 35\n   10. Send and Data Methods  . . . . . . . . . . . . . . . . . . . . 35\n\
    \     10.1. Forming a Send Indication  . . . . . . . . . . . . . . . . 35\n  \
    \   10.2. Receiving a Send Indication  . . . . . . . . . . . . . . . 35\n    \
    \ 10.3. Receiving a UDP Datagram . . . . . . . . . . . . . . . . . 36\n     10.4.\
    \ Receiving a Data Indication  . . . . . . . . . . . . . . . 37\n   11. Channels\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n     11.1. Sending\
    \ a ChannelBind Request  . . . . . . . . . . . . . . 39\n     11.2. Receiving\
    \ a ChannelBind Request  . . . . . . . . . . . . . 39\n     11.3. Receiving a\
    \ ChannelBind Response . . . . . . . . . . . . . 40\n     11.4. The ChannelData\
    \ Message  . . . . . . . . . . . . . . . . . 41\n     11.5. Sending a ChannelData\
    \ Message  . . . . . . . . . . . . . . 41\n     11.6. Receiving a ChannelData\
    \ Message  . . . . . . . . . . . . . 42\n     11.7. Relaying Data from the Peer\
    \  . . . . . . . . . . . . . . . 43\n   12. IP Header Fields . . . . . . . . .\
    \ . . . . . . . . . . . . . . 43\n   13. New STUN Methods . . . . . . . . . .\
    \ . . . . . . . . . . . . . 45\n   14. New STUN Attributes  . . . . . . . . .\
    \ . . . . . . . . . . . . 45\n     14.1. CHANNEL-NUMBER . . . . . . . . . . .\
    \ . . . . . . . . . . . 45\n     14.2. LIFETIME . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 46\n     14.3. XOR-PEER-ADDRESS . . . . . . . . . . . .\
    \ . . . . . . . . . 46\n     14.4. DATA . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 46\n     14.5. XOR-RELAYED-ADDRESS  . . . . . . . . . . . .\
    \ . . . . . . . 46\n     14.6. EVEN-PORT  . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 46\n     14.7. REQUESTED-TRANSPORT  . . . . . . . . . . . . . .\
    \ . . . . . 47\n     14.8. DONT-FRAGMENT  . . . . . . . . . . . . . . . . . .\
    \ . . . . 47\n     14.9. RESERVATION-TOKEN  . . . . . . . . . . . . . . . . .\
    \ . . . 48\n   15. New STUN Error Response Codes  . . . . . . . . . . . . . .\
    \ . . 48\n   16. Detailed Example . . . . . . . . . . . . . . . . . . . . . .\
    \ . 48\n   17. Security Considerations  . . . . . . . . . . . . . . . . . . .\
    \ 55\n     17.1. Outsider Attacks . . . . . . . . . . . . . . . . . . . . . 55\n\
    \       17.1.1.  Obtaining Unauthorized Allocations  . . . . . . . . . 55\n  \
    \     17.1.2.  Offline Dictionary Attacks  . . . . . . . . . . . . . 56\n    \
    \   17.1.3.  Faked Refreshes and Permissions . . . . . . . . . . . 56\n      \
    \ 17.1.4.  Fake Data . . . . . . . . . . . . . . . . . . . . . . 56\n       17.1.5.\
    \  Impersonating a Server  . . . . . . . . . . . . . . . 57\n       17.1.6.  Eavesdropping\
    \ Traffic . . . . . . . . . . . . . . . . 58\n       17.1.7.  TURN Loop Attack\
    \  . . . . . . . . . . . . . . . . . . 58\n     17.2. Firewall Considerations\
    \  . . . . . . . . . . . . . . . . . 59\n       17.2.1.  Faked Permissions . .\
    \ . . . . . . . . . . . . . . . . 59\n       17.2.2.  Blacklisted IP Addresses\
    \  . . . . . . . . . . . . . . 60\n       17.2.3.  Running Servers on Well-Known\
    \ Ports . . . . . . . . . 60\n     17.3. Insider Attacks  . . . . . . . . . .\
    \ . . . . . . . . . . . 60\n       17.3.1.  DoS against TURN Server . . . . .\
    \ . . . . . . . . . . 60\n       17.3.2.  Anonymous Relaying of Malicious Traffic\
    \ . . . . . . . 61\n       17.3.3.  Manipulating Other Allocations  . . . . .\
    \ . . . . . . 61\n     17.4. Other Considerations . . . . . . . . . . . . . .\
    \ . . . . . 61\n   18. IANA Considerations  . . . . . . . . . . . . . . . . .\
    \ . . . . 61\n   19. IAB Considerations . . . . . . . . . . . . . . . . . . .\
    \ . . . 62\n   20. Acknowledgements . . . . . . . . . . . . . . . . . . . . .\
    \ . . 63\n   21. References . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . 64\n     21.1. Normative References . . . . . . . . . . . . . . . . . . .\
    \ 64\n     21.2. Informative References . . . . . . . . . . . . . . . . . . 64\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   A host behind a NAT may wish to exchange packets with other\
    \ hosts,\n   some of which may also be behind NATs.  To do this, the hosts\n \
    \  involved can use \"hole punching\" techniques (see [RFC5128]) in an\n   attempt\
    \ discover a direct communication path; that is, a\n   communication path that\
    \ goes from one host to another through\n   intervening NATs and routers, but\
    \ does not traverse any relays.\n   As described in [RFC5128] and [RFC4787], hole\
    \ punching techniques\n   will fail if both hosts are behind NATs that are not\
    \ well behaved.\n   For example, if both hosts are behind NATs that have a mapping\n\
    \   behavior of \"address-dependent mapping\" or \"address- and port-\n   dependent\
    \ mapping\", then hole punching techniques generally fail.\n   When a direct communication\
    \ path cannot be found, it is necessary to\n   use the services of an intermediate\
    \ host that acts as a relay for the\n   packets.  This relay typically sits in\
    \ the public Internet and relays\n   packets between two hosts that both sit behind\
    \ NATs.\n   This specification defines a protocol, called TURN, that allows a\n\
    \   host behind a NAT (called the TURN client) to request that another\n   host\
    \ (called the TURN server) act as a relay.  The client can arrange\n   for the\
    \ server to relay packets to and from certain other hosts\n   (called peers) and\
    \ can control aspects of how the relaying is done.\n   The client does this by\
    \ obtaining an IP address and port on the\n   server, called the relayed transport\
    \ address.  When a peer sends a\n   packet to the relayed transport address, the\
    \ server relays the packet\n   to the client.  When the client sends a data packet\
    \ to the server,\n   the server relays it to the appropriate peer using the relayed\n\
    \   transport address as the source.\n   A client using TURN must have some way\
    \ to communicate the relayed\n   transport address to its peers, and to learn\
    \ each peer's IP address\n   and port (more precisely, each peer's server-reflexive\
    \ transport\n   address, see Section 2).  How this is done is out of the scope\
    \ of the\n   TURN protocol.  One way this might be done is for the client and\n\
    \   peers to exchange email messages.  Another way is for the client and\n   its\
    \ peers to use a special-purpose \"introduction\" or \"rendezvous\"\n   protocol\
    \ (see [RFC5128] for more details).\n   If TURN is used with ICE [RFC5245], then\
    \ the relayed transport\n   address and the IP addresses and ports of the peers\
    \ are included in\n   the ICE candidate information that the rendezvous protocol\
    \ must\n   carry.  For example, if TURN and ICE are used as part of a multimedia\n\
    \   solution using SIP [RFC3261], then SIP serves the role of the\n   rendezvous\
    \ protocol, carrying the ICE candidate information inside\n   the body of SIP\
    \ messages.  If TURN and ICE are used with some other\n   rendezvous protocol,\
    \ then [MMUSIC-ICE-NONSIP] provides guidance on\n   the services the rendezvous\
    \ protocol must perform.\n   Though the use of a TURN server to enable communication\
    \ between two\n   hosts behind NATs is very likely to work, it comes at a high\
    \ cost to\n   the provider of the TURN server, since the server typically needs\
    \ a\n   high-bandwidth connection to the Internet.  As a consequence, it is\n\
    \   best to use a TURN server only when a direct communication path\n   cannot\
    \ be found.  When the client and a peer use ICE to determine the\n   communication\
    \ path, ICE will use hole punching techniques to search\n   for a direct path\
    \ first and only use a TURN server when a direct path\n   cannot be found.\n \
    \  TURN was originally invented to support multimedia sessions signaled\n   using\
    \ SIP.  Since SIP supports forking, TURN supports multiple peers\n   per relayed\
    \ transport address; a feature not supported by other\n   approaches (e.g., SOCKS\
    \ [RFC1928]).  However, care has been taken to\n   make sure that TURN is suitable\
    \ for other types of applications.\n   TURN was designed as one piece in the larger\
    \ ICE approach to NAT\n   traversal.  Implementors of TURN are urged to investigate\
    \ ICE and\n   seriously consider using it for their application.  However, it\
    \ is\n   possible to use TURN without ICE.\n   TURN is an extension to the STUN\
    \ (Session Traversal Utilities for\n   NAT) protocol [RFC5389].  Most, though\
    \ not all, TURN messages are\n   STUN-formatted messages.  A reader of this document\
    \ should be\n   familiar with STUN.\n"
- title: 2.  Overview of Operation
  contents:
  - "2.  Overview of Operation\n   This section gives an overview of the operation\
    \ of TURN.  It is non-\n   normative.\n   In a typical configuration, a TURN client\
    \ is connected to a private\n   network [RFC1918] and through one or more NATs\
    \ to the public\n   Internet.  On the public Internet is a TURN server.  Elsewhere\
    \ in the\n   Internet are one or more peers with which the TURN client wishes\
    \ to\n   communicate.  These peers may or may not be behind one or more NATs.\n\
    \   The client uses the server as a relay to send packets to these peers\n   and\
    \ to receive packets from these peers.\n                                     \
    \   Peer A\n                                        Server-Reflexive    +---------+\n\
    \                                        Transport Address   |         |\n   \
    \                                     192.0.2.150:32102   |         |\n      \
    \                                      |              /|         |\n         \
    \                 TURN              |            / ^|  Peer A |\n    Client's\
    \              Server            |           /  ||         |\n    Host Transport\
    \        Transport         |         //   ||         |\n    Address          \
    \     Address           |       //     |+---------+\n   10.1.1.2:49721       192.0.2.15:3478\
    \     |+-+  //     Peer A\n            |               |               ||N| /\
    \       Host Transport\n            |   +-+         |               ||A|/    \
    \    Address\n            |   | |         |               v|T|     192.168.100.2:49582\n\
    \            |   | |         |               /+-+\n +---------+|   | |       \
    \  |+---------+   /              +---------+\n |         ||   |N|         || \
    \        | //               |         |\n | TURN    |v   | |         v| TURN \
    \   |/                 |         |\n | Client  |----|A|----------| Server  |------------------|\
    \  Peer B |\n |         |    | |^         |         |^                ^|     \
    \    |\n |         |    |T||         |         ||                ||         |\n\
    \ +---------+    | ||         +---------+|                |+---------+\n     \
    \           | ||                    |                |\n                | || \
    \                   |                |\n                +-+|                 \
    \   |                |\n                   |                    |            \
    \    |\n                   |                    |                |\n         \
    \    Client's                   |            Peer B\n             Server-Reflexive\
    \    Relayed             Transport\n             Transport Address   Transport\
    \ Address   Address\n             192.0.2.1:7000      192.0.2.15:50000     192.0.2.210:49191\n\
    \                                 Figure 1\n   Figure 1 shows a typical deployment.\
    \  In this figure, the TURN client\n   and the TURN server are separated by a\
    \ NAT, with the client on the\n   private side and the server on the public side\
    \ of the NAT.  This NAT\n   is assumed to be a \"bad\" NAT; for example, it might\
    \ have a mapping\n   property of \"address-and-port-dependent mapping\" (see [RFC4787]).\n\
    \   The client talks to the server from a (IP address, port) combination\n   called\
    \ the client's HOST TRANSPORT ADDRESS.  (The combination of an\n   IP address\
    \ and port is called a TRANSPORT ADDRESS.)\n   The client sends TURN messages\
    \ from its host transport address to a\n   transport address on the TURN server\
    \ that is known as the TURN SERVER\n   TRANSPORT ADDRESS.  The client learns the\
    \ TURN server transport\n   address through some unspecified means (e.g., configuration),\
    \ and\n   this address is typically used by many clients simultaneously.\n   Since\
    \ the client is behind a NAT, the server sees packets from the\n   client as coming\
    \ from a transport address on the NAT itself.  This\n   address is known as the\
    \ client's SERVER-REFLEXIVE transport address;\n   packets sent by the server\
    \ to the client's server-reflexive transport\n   address will be forwarded by\
    \ the NAT to the client's host transport\n   address.\n   The client uses TURN\
    \ commands to create and manipulate an ALLOCATION\n   on the server.  An allocation\
    \ is a data structure on the server.\n   This data structure contains, amongst\
    \ other things, the RELAYED\n   TRANSPORT ADDRESS for the allocation.  The relayed\
    \ transport address\n   is the transport address on the server that peers can\
    \ use to have the\n   server relay data to the client.  An allocation is uniquely\n\
    \   identified by its relayed transport address.\n   Once an allocation is created,\
    \ the client can send application data\n   to the server along with an indication\
    \ of to which peer the data is\n   to be sent, and the server will relay this\
    \ data to the appropriate\n   peer.  The client sends the application data to\
    \ the server inside a\n   TURN message; at the server, the data is extracted from\
    \ the TURN\n   message and sent to the peer in a UDP datagram.  In the reverse\n\
    \   direction, a peer can send application data in a UDP datagram to the\n   relayed\
    \ transport address for the allocation; the server will then\n   encapsulate this\
    \ data inside a TURN message and send it to the client\n   along with an indication\
    \ of which peer sent the data.  Since the TURN\n   message always contains an\
    \ indication of which peer the client is\n   communicating with, the client can\
    \ use a single allocation to\n   communicate with multiple peers.\n   When the\
    \ peer is behind a NAT, then the client must identify the peer\n   using its server-reflexive\
    \ transport address rather than its host\n   transport address.  For example,\
    \ to send application data to Peer A\n   in the example above, the client must\
    \ specify 192.0.2.150:32102 (Peer\n   A's server-reflexive transport address)\
    \ rather than 192.168.100.2:\n   49582 (Peer A's host transport address).\n  \
    \ Each allocation on the server belongs to a single client and has\n   exactly\
    \ one relayed transport address that is used only by that\n   allocation.  Thus,\
    \ when a packet arrives at a relayed transport\n   address on the server, the\
    \ server knows for which client the data is\n   intended.\n   The client may have\
    \ multiple allocations on a server at the same\n   time.\n"
- title: 2.1.  Transports
  contents:
  - "2.1.  Transports\n   TURN, as defined in this specification, always uses UDP\
    \ between the\n   server and the peer.  However, this specification allows the\
    \ use of\n   any one of UDP, TCP, or Transport Layer Security (TLS) over TCP to\n\
    \   carry the TURN messages between the client and the server.\n           +----------------------------+---------------------+\n\
    \           | TURN client to TURN server | TURN server to peer |\n           +----------------------------+---------------------+\n\
    \           |             UDP            |         UDP         |\n           |\
    \             TCP            |         UDP         |\n           |        TLS\
    \ over TCP        |         UDP         |\n           +----------------------------+---------------------+\n\
    \   If TCP or TLS-over-TCP is used between the client and the server,\n   then\
    \ the server will convert between these transports and UDP\n   transport when\
    \ relaying data to/from the peer.\n   Since this version of TURN only supports\
    \ UDP between the server and\n   the peer, it is expected that most clients will\
    \ prefer to use UDP\n   between the client and the server as well.  That being\
    \ the case, some\n   readers may wonder: Why also support TCP and TLS-over-TCP?\n\
    \   TURN supports TCP transport between the client and the server because\n  \
    \ some firewalls are configured to block UDP entirely.  These firewalls\n   block\
    \ UDP but not TCP, in part because TCP has properties that make\n   the intention\
    \ of the nodes being protected by the firewall more\n   obvious to the firewall.\
    \  For example, TCP has a three-way handshake\n   that makes in clearer that the\
    \ protected node really wishes to have\n   that particular connection established,\
    \ while for UDP the best the\n   firewall can do is guess which flows are desired\
    \ by using filtering\n   rules.  Also, TCP has explicit connection teardown; while\
    \ for UDP,\n   the firewall has to use timers to guess when the flow is finished.\n\
    \   TURN supports TLS-over-TCP transport between the client and the\n   server\
    \ because TLS provides additional security properties not\n   provided by TURN's\
    \ default digest authentication; properties that\n   some clients may wish to\
    \ take advantage of.  In particular, TLS\n   provides a way for the client to\
    \ ascertain that it is talking to the\n   correct server, and provides for confidentiality\
    \ of TURN control\n   messages.  TURN does not require TLS because the overhead\
    \ of using\n   TLS is higher than that of digest authentication; for example,\
    \ using\n   TLS likely means that most application data will be doubly encrypted\n\
    \   (once by TLS and once to ensure it is still encrypted in the UDP\n   datagram).\n\
    \   There is a planned extension to TURN to add support for TCP between\n   the\
    \ server and the peers [TURN-TCP].  For this reason, allocations\n   that use\
    \ UDP between the server and the peers are known as UDP\n   allocations, while\
    \ allocations that use TCP between the server and\n   the peers are known as TCP\
    \ allocations.  This specification describes\n   only UDP allocations.\n   TURN,\
    \ as defined in this specification, only supports IPv4.  All IP\n   addresses\
    \ in this specification must be IPv4 addresses.  There is a\n   planned extension\
    \ to TURN to add support for IPv6 and for relaying\n   between IPv4 and IPv6 [TURN-IPv6].\n\
    \   In some applications for TURN, the client may send and receive\n   packets\
    \ other than TURN packets on the host transport address it uses\n   to communicate\
    \ with the server.  This can happen, for example, when\n   using TURN with ICE.\
    \  In these cases, the client can distinguish TURN\n   packets from other packets\
    \ by examining the source address of the\n   arriving packet: those arriving from\
    \ the TURN server will be TURN\n   packets.\n"
- title: 2.2.  Allocations
  contents:
  - "2.2.  Allocations\n   To create an allocation on the server, the client uses\
    \ an Allocate\n   transaction.  The client sends an Allocate request to the server,\
    \ and\n   the server replies with an Allocate success response containing the\n\
    \   allocated relayed transport address.  The client can include\n   attributes\
    \ in the Allocate request that describe the type of\n   allocation it desires\
    \ (e.g., the lifetime of the allocation).  Since\n   relaying data has security\
    \ implications, the server requires that the\n   client authenticate itself, typically\
    \ using STUN's long-term\n   credential mechanism, to show that it is authorized\
    \ to use the\n   server.\n   Once a relayed transport address is allocated, a\
    \ client must keep the\n   allocation alive.  To do this, the client periodically\
    \ sends a\n   Refresh request to the server.  TURN deliberately uses a different\n\
    \   method (Refresh rather than Allocate) for refreshes to ensure that\n   the\
    \ client is informed if the allocation vanishes for some reason.\n   The frequency\
    \ of the Refresh transaction is determined by the\n   lifetime of the allocation.\
    \  The default lifetime of an allocation is\n   10 minutes -- this value was chosen\
    \ to be long enough so that\n   refreshing is not typically a burden on the client,\
    \ while expiring\n   allocations where the client has unexpectedly quit in a timely\n\
    \   manner.  However, the client can request a longer lifetime in the\n   Allocate\
    \ request and may modify its request in a Refresh request, and\n   the server\
    \ always indicates the actual lifetime in the response.  The\n   client must issue\
    \ a new Refresh transaction within \"lifetime\" seconds\n   of the previous Allocate\
    \ or Refresh transaction.  Once a client no\n   longer wishes to use an allocation,\
    \ it should delete the allocation\n   using a Refresh request with a requested\
    \ lifetime of 0.\n   Both the server and client keep track of a value known as\
    \ the\n   5-TUPLE.  At the client, the 5-tuple consists of the client's host\n\
    \   transport address, the server transport address, and the transport\n   protocol\
    \ used by the client to communicate with the server.  At the\n   server, the 5-tuple\
    \ value is the same except that the client's host\n   transport address is replaced\
    \ by the client's server-reflexive\n   address, since that is the client's address\
    \ as seen by the server.\n   Both the client and the server remember the 5-tuple\
    \ used in the\n   Allocate request.  Subsequent messages between the client and\
    \ the\n   server use the same 5-tuple.  In this way, the client and server know\n\
    \   which allocation is being referred to.  If the client wishes to\n   allocate\
    \ a second relayed transport address, it must create a second\n   allocation using\
    \ a different 5-tuple (e.g., by using a different\n   client host address or port).\n\
    \      NOTE: While the terminology used in this document refers to\n      5-tuples,\
    \ the TURN server can store whatever identifier it likes\n      that yields identical\
    \ results.  Specifically, an implementation\n      may use a file-descriptor in\
    \ place of a 5-tuple to represent a TCP\n      connection.\n  TURN           \
    \                      TURN           Peer          Peer\n  client           \
    \                    server          A             B\n    |-- Allocate request\
    \ --------------->|             |             |\n    |                       \
    \             |             |             |\n    |<--------------- Allocate failure\
    \ --|             |             |\n    |                 (401 Unauthorized) |\
    \             |             |\n    |                                    |    \
    \         |             |\n    |-- Allocate request --------------->|        \
    \     |             |\n    |                                    |            \
    \ |             |\n    |<---------- Allocate success resp --|             |  \
    \           |\n    |            (192.0.2.15:50000)      |             |      \
    \       |\n    //                                   //            //         \
    \   //\n    |                                    |             |             |\n\
    \    |-- Refresh request ---------------->|             |             |\n    |\
    \                                    |             |             |\n    |<-----------\
    \ Refresh success resp --|             |             |\n    |                \
    \                    |             |             |\n                         \
    \        Figure 2\n   In Figure 2, the client sends an Allocate request to the\
    \ server\n   without credentials.  Since the server requires that all requests\
    \ be\n   authenticated using STUN's long-term credential mechanism, the server\n\
    \   rejects the request with a 401 (Unauthorized) error code.  The client\n  \
    \ then tries again, this time including credentials (not shown).  This\n   time,\
    \ the server accepts the Allocate request and returns an Allocate\n   success\
    \ response containing (amongst other things) the relayed\n   transport address\
    \ assigned to the allocation.  Sometime later, the\n   client decides to refresh\
    \ the allocation and thus sends a Refresh\n   request to the server.  The refresh\
    \ is accepted and the server\n   replies with a Refresh success response.\n"
- title: 2.3.  Permissions
  contents:
  - "2.3.  Permissions\n   To ease concerns amongst enterprise IT administrators that\
    \ TURN could\n   be used to bypass corporate firewall security, TURN includes\
    \ the\n   notion of permissions.  TURN permissions mimic the address-restricted\n\
    \   filtering mechanism of NATs that comply with [RFC4787].\n   An allocation\
    \ can have zero or more permissions.  Each permission\n   consists of an IP address\
    \ and a lifetime.  When the server receives a\n   UDP datagram on the allocation's\
    \ relayed transport address, it first\n   checks the list of permissions.  If\
    \ the source IP address of the\n   datagram matches a permission, the application\
    \ data is relayed to the\n   client, otherwise the UDP datagram is silently discarded.\n\
    \   A permission expires after 5 minutes if it is not refreshed, and\n   there\
    \ is no way to explicitly delete a permission.  This behavior was\n   selected\
    \ to match the behavior of a NAT that complies with [RFC4787].\n   The client\
    \ can install or refresh a permission using either a\n   CreatePermission request\
    \ or a ChannelBind request.  Using the\n   CreatePermission request, multiple\
    \ permissions can be installed or\n   refreshed with a single request -- this\
    \ is important for applications\n   that use ICE.  For security reasons, permissions\
    \ can only be\n   installed or refreshed by transactions that can be authenticated;\n\
    \   thus, Send indications and ChannelData messages (which are used to\n   send\
    \ data to peers) do not install or refresh any permissions.\n   Note that permissions\
    \ are within the context of an allocation, so\n   adding or expiring a permission\
    \ in one allocation does not affect\n   other allocations.\n"
- title: 2.4.  Send Mechanism
  contents:
  - "2.4.  Send Mechanism\n   There are two mechanisms for the client and peers to\
    \ exchange\n   application data using the TURN server.  The first mechanism uses\
    \ the\n   Send and Data methods, the second way uses channels.  Common to both\n\
    \   ways is the ability of the client to communicate with multiple peers\n   using\
    \ a single allocated relayed transport address; thus, both ways\n   include a\
    \ means for the client to indicate to the server which peer\n   should receive\
    \ the data, and for the server to indicate to the client\n   which peer sent the\
    \ data.\n   The Send mechanism uses Send and Data indications.  Send indications\n\
    \   are used to send application data from the client to the server,\n   while\
    \ Data indications are used to send application data from the\n   server to the\
    \ client.\n   When using the Send mechanism, the client sends a Send indication\
    \ to\n   the TURN server containing (a) an XOR-PEER-ADDRESS attribute\n   specifying\
    \ the (server-reflexive) transport address of the peer and\n   (b) a DATA attribute\
    \ holding the application data.  When the TURN\n   server receives the Send indication,\
    \ it extracts the application data\n   from the DATA attribute and sends it in\
    \ a UDP datagram to the peer,\n   using the allocated relay address as the source\
    \ address.  Note that\n   there is no need to specify the relayed transport address,\
    \ since it\n   is implied by the 5-tuple used for the Send indication.\n   In\
    \ the reverse direction, UDP datagrams arriving at the relayed\n   transport address\
    \ on the TURN server are converted into Data\n   indications and sent to the client,\
    \ with the server-reflexive\n   transport address of the peer included in an XOR-PEER-ADDRESS\n\
    \   attribute and the data itself in a DATA attribute.  Since the relayed\n  \
    \ transport address uniquely identified the allocation, the server\n   knows which\
    \ client should receive the data.\n   Send and Data indications cannot be authenticated,\
    \ since the long-\n   term credential mechanism of STUN does not support authenticating\n\
    \   indications.  This is not as big an issue as it might first appear,\n   since\
    \ the client-to-server leg is only half of the total path to the\n   peer.  Applications\
    \ that want proper security should encrypt the data\n   sent between the client\
    \ and a peer.\n   Because Send indications are not authenticated, it is possible\
    \ for an\n   attacker to send bogus Send indications to the server, which will\n\
    \   then relay these to a peer.  To partly mitigate this attack, TURN\n   requires\
    \ that the client install a permission towards a peer before\n   sending data\
    \ to it using a Send indication.\n  TURN                                 TURN\
    \           Peer          Peer\n  client                               server\
    \          A             B\n    |                                    |       \
    \      |             |\n    |-- CreatePermission req (Peer A) -->|           \
    \  |             |\n    |<-- CreatePermission success resp --|             | \
    \            |\n    |                                    |             |     \
    \        |\n    |--- Send ind (Peer A)-------------->|             |         \
    \    |\n    |                                    |=== data ===>|             |\n\
    \    |                                    |             |             |\n    |\
    \                                    |<== data ====|             |\n    |<--------------\
    \ Data ind (Peer A) --|             |             |\n    |                   \
    \                 |             |             |\n    |                       \
    \             |             |             |\n    |--- Send ind (Peer B)-------------->|\
    \             |             |\n    |                                    | dropped\
    \     |             |\n    |                                    |            \
    \ |             |\n    |                                    |<== data ==================|\n\
    \    |                            dropped |             |             |\n    |\
    \                                    |             |             |\n         \
    \                        Figure 3\n   In Figure 3, the client has already created\
    \ an allocation and now\n   wishes to send data to its peers.  The client first\
    \ creates a\n   permission by sending the server a CreatePermission request\n\
    \   specifying Peer A's (server-reflexive) IP address in the XOR-PEER-\n   ADDRESS\
    \ attribute; if this was not done, the server would not relay\n   data between\
    \ the client and the server.  The client then sends data\n   to Peer A using a\
    \ Send indication; at the server, the application\n   data is extracted and forwarded\
    \ in a UDP datagram to Peer A, using\n   the relayed transport address as the\
    \ source transport address.  When\n   a UDP datagram from Peer A is received at\
    \ the relayed transport\n   address, the contents are placed into a Data indication\
    \ and forwarded\n   to the client.  Later, the client attempts to exchange data\
    \ with Peer\n   B; however, no permission has been installed for Peer B, so the\
    \ Send\n   indication from the client and the UDP datagram from the peer are\n\
    \   both dropped by the server.\n"
- title: 2.5.  Channels
  contents:
  - "2.5.  Channels\n   For some applications (e.g., Voice over IP), the 36 bytes\
    \ of overhead\n   that a Send indication or Data indication adds to the application\n\
    \   data can substantially increase the bandwidth required between the\n   client\
    \ and the server.  To remedy this, TURN offers a second way for\n   the client\
    \ and server to associate data with a specific peer.\n   This second way uses\
    \ an alternate packet format known as the\n   ChannelData message.  The ChannelData\
    \ message does not use the STUN\n   header used by other TURN messages, but instead\
    \ has a 4-byte header\n   that includes a number known as a channel number.  Each\
    \ channel\n   number in use is bound to a specific peer and thus serves as a\n\
    \   shorthand for the peer's host transport address.\n   To bind a channel to\
    \ a peer, the client sends a ChannelBind request\n   to the server, and includes\
    \ an unbound channel number and the\n   transport address of the peer.  Once the\
    \ channel is bound, the client\n   can use a ChannelData message to send the server\
    \ data destined for\n   the peer.  Similarly, the server can relay data from that\
    \ peer\n   towards the client using a ChannelData message.\n   Channel bindings\
    \ last for 10 minutes unless refreshed -- this\n   lifetime was chosen to be longer\
    \ than the permission lifetime.\n   Channel bindings are refreshed by sending\
    \ another ChannelBind request\n   rebinding the channel to the peer.  Like permissions\
    \ (but unlike\n   allocations), there is no way to explicitly delete a channel\
    \ binding;\n   the client must simply wait for it to time out.\n  TURN       \
    \                          TURN           Peer          Peer\n  client       \
    \                        server          A             B\n    |              \
    \                      |             |             |\n    |-- ChannelBind req\
    \ ---------------->|             |             |\n    | (Peer A to 0x4001)   \
    \              |             |             |\n    |                          \
    \          |             |             |\n    |<---------- ChannelBind succ resp\
    \ --|             |             |\n    |                                    |\
    \             |             |\n    |-- [0x4001] data ------------------>|    \
    \         |             |\n    |                                    |=== data\
    \ ===>|             |\n    |                                    |            \
    \ |             |\n    |                                    |<== data ====|  \
    \           |\n    |<------------------ [0x4001] data --|             |      \
    \       |\n    |                                    |             |          \
    \   |\n    |--- Send ind (Peer A)-------------->|             |             |\n\
    \    |                                    |=== data ===>|             |\n    |\
    \                                    |             |             |\n    |    \
    \                                |<== data ====|             |\n    |<------------------\
    \ [0x4001] data --|             |             |\n    |                       \
    \             |             |             |\n                                \
    \ Figure 4\n   Figure 4 shows the channel mechanism in use.  The client has already\n\
    \   created an allocation and now wishes to bind a channel to Peer A.  To\n  \
    \ do this, the client sends a ChannelBind request to the server,\n   specifying\
    \ the transport address of Peer A and a channel number\n   (0x4001).  After that,\
    \ the client can send application data\n   encapsulated inside ChannelData messages\
    \ to Peer A: this is shown as\n   \"[0x4001] data\" where 0x4001 is the channel\
    \ number.  When the\n   ChannelData message arrives at the server, the server\
    \ transfers the\n   data to a UDP datagram and sends it to Peer A (which is the\
    \ peer\n   bound to channel number 0x4001).\n   In the reverse direction, when\
    \ Peer A sends a UDP datagram to the\n   relayed transport address, this UDP datagram\
    \ arrives at the server on\n   the relayed transport address assigned to the allocation.\
    \  Since the\n   UDP datagram was received from Peer A, which has a channel number\n\
    \   assigned to it, the server encapsulates the data into a ChannelData\n   message\
    \ when sending the data to the client.\n   Once a channel has been bound, the\
    \ client is free to intermix\n   ChannelData messages and Send indications.  In\
    \ the figure, the client\n   later decides to use a Send indication rather than\
    \ a ChannelData\n   message to send additional data to Peer A.  The client might\
    \ decide\n   to do this, for example, so it can use the DONT-FRAGMENT attribute\n\
    \   (see the next section).  However, once a channel is bound, the server\n  \
    \ will always use a ChannelData message, as shown in the call flow.\n   Note that\
    \ ChannelData messages can only be used for peers to which\n   the client has\
    \ bound a channel.  In the example above, Peer A has\n   been bound to a channel,\
    \ but Peer B has not, so application data to\n   and from Peer B would use the\
    \ Send mechanism.\n"
- title: 2.6.  Unprivileged TURN Servers
  contents:
  - "2.6.  Unprivileged TURN Servers\n   This version of TURN is designed so that\
    \ the server can be\n   implemented as an application that runs in user space\
    \ under commonly\n   available operating systems without requiring special privileges.\n\
    \   This design decision was made to make it easy to deploy a TURN\n   server:\
    \ for example, to allow a TURN server to be integrated into a\n   peer-to-peer\
    \ application so that one peer can offer NAT traversal\n   services to another\
    \ peer.\n   This design decision has the following implications for data relayed\n\
    \   by a TURN server:\n   o  The value of the Diffserv field may not be preserved\
    \ across the\n      server;\n   o  The Time to Live (TTL) field may be reset,\
    \ rather than\n      decremented, across the server;\n   o  The Explicit Congestion\
    \ Notification (ECN) field may be reset by\n      the server;\n   o  ICMP messages\
    \ are not relayed by the server;\n   o  There is no end-to-end fragmentation,\
    \ since the packet is re-\n      assembled at the server.\n   Future work may\
    \ specify alternate TURN semantics that address these\n   limitations.\n"
- title: 2.7.  Avoiding IP Fragmentation
  contents:
  - "2.7.  Avoiding IP Fragmentation\n   For reasons described in [Frag-Harmful],\
    \ applications, especially\n   those sending large volumes of data, should try\
    \ hard to avoid having\n   their packets fragmented.  Applications using TCP can\
    \ more or less\n   ignore this issue because fragmentation avoidance is now a\
    \ standard\n   part of TCP, but applications using UDP (and thus any application\n\
    \   using this version of TURN) must handle fragmentation avoidance\n   themselves.\n\
    \   The application running on the client and the peer can take one of\n   two\
    \ approaches to avoid IP fragmentation.\n   The first approach is to avoid sending\
    \ large amounts of application\n   data in the TURN messages/UDP datagrams exchanged\
    \ between the client\n   and the peer.  This is the approach taken by most VoIP\n\
    \   (Voice-over-IP) applications.  In this approach, the application\n   exploits\
    \ the fact that the IP specification [RFC0791] specifies that\n   IP packets up\
    \ to 576 bytes should never need to be fragmented.\n   The exact amount of application\
    \ data that can be included while\n   avoiding fragmentation depends on the details\
    \ of the TURN session\n   between the client and the server: whether UDP, TCP,\
    \ or TLS transport\n   is used, whether ChannelData messages or Send/Data indications\
    \ are\n   used, and whether any additional attributes (such as the DONT-\n   FRAGMENT\
    \ attribute) are included.  Another factor, which is hard to\n   determine, is\
    \ whether the MTU is reduced somewhere along the path for\n   other reasons, such\
    \ as the use of IP-in-IP tunneling.\n   As a guideline, sending a maximum of 500\
    \ bytes of application data in\n   a single TURN message (by the client on the\
    \ client-to-server leg) or\n   a UDP datagram (by the peer on the peer-to-server\
    \ leg) will generally\n   avoid IP fragmentation.  To further reduce the chance\
    \ of\n   fragmentation, it is recommended that the client use ChannelData\n  \
    \ messages when transferring significant volumes of data, since the\n   overhead\
    \ of the ChannelData message is less than Send and Data\n   indications.\n   The\
    \ second approach the client and peer can take to avoid\n   fragmentation is to\
    \ use a path MTU discovery algorithm to determine\n   the maximum amount of application\
    \ data that can be sent without\n   fragmentation.\n   Unfortunately, because\
    \ servers implementing this version of TURN do\n   not relay ICMP messages, the\
    \ classic path MTU discovery algorithm\n   defined in [RFC1191] is not able to\
    \ discover the MTU of the\n   transmission path between the client and the peer.\
    \  (Even if they did\n   relay ICMP messages, the algorithm would not always work\
    \ since ICMP\n   messages are often filtered out by combined NAT/firewall devices).\n\
    \   So the client and server need to use a path MTU discovery algorithm\n   that\
    \ does not require ICMP messages.  The Packetized Path MTU\n   Discovery algorithm\
    \ defined in [RFC4821] is one such algorithm.\n   The details of how to use the\
    \ algorithm of [RFC4821] with TURN are\n   still under investigation.  However,\
    \ as a step towards this goal,\n   this version of TURN supports a DONT-FRAGMENT\
    \ attribute.  When the\n   client includes this attribute in a Send indication,\
    \ this tells the\n   server to set the DF bit in the resulting UDP datagram that\
    \ it sends\n   to the peer.  Since some servers may be unable to set the DF bit,\
    \ the\n   client should also include this attribute in the Allocate request --\n\
    \   any server that does not support the DONT-FRAGMENT attribute will\n   indicate\
    \ this by rejecting the Allocate request.\n"
- title: 2.8.  RTP Support
  contents:
  - "2.8.  RTP Support\n   One of the envisioned uses of TURN is as a relay for clients\
    \ and\n   peers wishing to exchange real-time data (e.g., voice or video) using\n\
    \   RTP.  To facilitate the use of TURN for this purpose, TURN includes\n   some\
    \ special support for older versions of RTP.\n   Old versions of RTP [RFC3550]\
    \ required that the RTP stream be on an\n   even port number and the associated\
    \ RTP Control Protocol (RTCP)\n   stream, if present, be on the next highest port.\
    \  To allow clients to\n   work with peers that still require this, TURN allows\
    \ the client to\n   request that the server allocate a relayed transport address\
    \ with an\n   even port number, and to optionally request the server reserve the\n\
    \   next-highest port number for a subsequent allocation.\n"
- title: 2.9.  Anycast Discovery of Servers
  contents:
  - "2.9.  Anycast Discovery of Servers\n   This version of TURN has been designed\
    \ to permit the future\n   specification of a method of doing anycast discovery\
    \ of a TURN server\n   over UDP.\n   Specifically, a TURN server can reject an\
    \ Allocate request with the\n   suggestion that the client try an alternate server.\
    \  To avoid certain\n   types of attacks, the client must use the same credentials\
    \ with the\n   alternate server as it would have with the initial server.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [RFC2119].\n   Readers are expected to be familiar with [RFC5389] and the\
    \ terms\n   defined there.\n   The following terms are used in this document:\n\
    \   TURN:  The protocol spoken between a TURN client and a TURN server.\n    \
    \  It is an extension to the STUN protocol [RFC5389].  The protocol\n      allows\
    \ a client to allocate and use a relayed transport address.\n   TURN client: \
    \ A STUN client that implements this specification.\n   TURN server:  A STUN server\
    \ that implements this specification.  It\n      relays data between a TURN client\
    \ and its peer(s).\n   Peer:  A host with which the TURN client wishes to communicate.\
    \  The\n      TURN server relays traffic between the TURN client and its\n   \
    \   peer(s).  The peer does not interact with the TURN server using\n      the\
    \ protocol defined in this document; rather, the peer receives\n      data sent\
    \ by the TURN server and the peer sends data towards the\n      TURN server.\n\
    \   Transport Address:  The combination of an IP address and a port.\n   Host\
    \ Transport Address:  A transport address on a client or a peer.\n   Server-Reflexive\
    \ Transport Address:  A transport address on the\n      \"public side\" of a NAT.\
    \  This address is allocated by the NAT to\n      correspond to a specific host\
    \ transport address.\n   Relayed Transport Address:  A transport address on the\
    \ TURN server\n      that is used for relaying packets between the client and\
    \ a peer.\n      A peer sends to this address on the TURN server, and the packet\
    \ is\n      then relayed to the client.\n   TURN Server Transport Address:  A\
    \ transport address on the TURN\n      server that is used for sending TURN messages\
    \ to the server.  This\n      is the transport address that the client uses to\
    \ communicate with\n      the server.\n   Peer Transport Address:  The transport\
    \ address of the peer as seen by\n      the server.  When the peer is behind a\
    \ NAT, this is the peer's\n      server-reflexive transport address.\n   Allocation:\
    \  The relayed transport address granted to a client\n      through an Allocate\
    \ request, along with related state, such as\n      permissions and expiration\
    \ timers.\n   5-tuple:  The combination (client IP address and port, server IP\n\
    \      address and port, and transport protocol (currently one of UDP,\n     \
    \ TCP, or TLS)) used to communicate between the client and the\n      server.\
    \  The 5-tuple uniquely identifies this communication\n      stream.  The 5-tuple\
    \ also uniquely identifies the Allocation on\n      the server.\n   Channel: \
    \ A channel number and associated peer transport address.\n      Once a channel\
    \ number is bound to a peer's transport address, the\n      client and server\
    \ can use the more bandwidth-efficient ChannelData\n      message to exchange\
    \ data.\n   Permission:  The IP address and transport protocol (but not the port)\n\
    \      of a peer that is permitted to send traffic to the TURN server and\n  \
    \    have that traffic relayed to the TURN client.  The TURN server\n      will\
    \ only forward traffic to its client from peers that match an\n      existing\
    \ permission.\n   Realm:  A string used to describe the server or a context within\
    \ the\n      server.  The realm tells the client which username and password\n\
    \      combination to use to authenticate requests.\n   Nonce:  A string chosen\
    \ at random by the server and included in the\n      message-digest.  To prevent\
    \ reply attacks, the server should\n      change the nonce regularly.\n"
- title: 4.  General Behavior
  contents:
  - "4.  General Behavior\n   This section contains general TURN processing rules\
    \ that apply to all\n   TURN messages.\n   TURN is an extension to STUN.  All\
    \ TURN messages, with the exception\n   of the ChannelData message, are STUN-formatted\
    \ messages.  All the\n   base processing rules described in [RFC5389] apply to\
    \ STUN-formatted\n   messages.  This means that all the message-forming and message-\n\
    \   processing descriptions in this document are implicitly prefixed with\n  \
    \ the rules of [RFC5389].\n   [RFC5389] specifies an authentication mechanism\
    \ called the long-term\n   credential mechanism.  TURN servers and clients MUST\
    \ implement this\n   mechanism.  The server MUST demand that all requests from\
    \ the client\n   be authenticated using this mechanism, or that a equally strong\
    \ or\n   stronger mechanism for client authentication is used.\n   Note that the\
    \ long-term credential mechanism applies only to requests\n   and cannot be used\
    \ to authenticate indications; thus, indications in\n   TURN are never authenticated.\
    \  If the server requires requests to be\n   authenticated, then the server's\
    \ administrator MUST choose a realm\n   value that will uniquely identify the\
    \ username and password\n   combination that the client must use, even if the\
    \ client uses\n   multiple servers under different administrations.  The server's\n\
    \   administrator MAY choose to allocate a unique username to each\n   client,\
    \ or MAY choose to allocate the same username to more than one\n   client (for\
    \ example, to all clients from the same department or\n   company).  For each\
    \ allocation, the server SHOULD generate a new\n   random nonce when the allocation\
    \ is first attempted following the\n   randomness recommendations in [RFC4086]\
    \ and SHOULD expire the nonce\n   at least once every hour during the lifetime\
    \ of the allocation.\n   All requests after the initial Allocate must use the\
    \ same username as\n   that used to create the allocation, to prevent attackers\
    \ from\n   hijacking the client's allocation.  Specifically, if the server\n \
    \  requires the use of the long-term credential mechanism, and if a non-\n   Allocate\
    \ request passes authentication under this mechanism, and if\n   the 5-tuple identifies\
    \ an existing allocation, but the request does\n   not use the same username as\
    \ used to create the allocation, then the\n   request MUST be rejected with a\
    \ 441 (Wrong Credentials) error.\n   When a TURN message arrives at the server\
    \ from the client, the server\n   uses the 5-tuple in the message to identify\
    \ the associated\n   allocation.  For all TURN messages (including ChannelData)\
    \ EXCEPT an\n   Allocate request, if the 5-tuple does not identify an existing\n\
    \   allocation, then the message MUST either be rejected with a 437\n   Allocation\
    \ Mismatch error (if it is a request) or silently ignored\n   (if it is an indication\
    \ or a ChannelData message).  A client\n   receiving a 437 error response to a\
    \ request other than Allocate MUST\n   assume the allocation no longer exists.\n\
    \   [RFC5389] defines a number of attributes, including the SOFTWARE and\n   FINGERPRINT\
    \ attributes.  The client SHOULD include the SOFTWARE\n   attribute in all Allocate\
    \ and Refresh requests and MAY include it in\n   any other requests or indications.\
    \  The server SHOULD include the\n   SOFTWARE attribute in all Allocate and Refresh\
    \ responses (either\n   success or failure) and MAY include it in other responses\
    \ or\n   indications.  The client and the server MAY include the FINGERPRINT\n\
    \   attribute in any STUN-formatted messages defined in this document.\n   TURN\
    \ does not use the backwards-compatibility mechanism described in\n   [RFC5389].\n\
    \   TURN, as defined in this specification, only supports IPv4.  The\n   client's\
    \ IP address, the server's IP address, and all IP addresses\n   appearing in a\
    \ relayed transport address MUST be IPv4 addresses.\n   By default, TURN runs\
    \ on the same ports as STUN: 3478 for TURN over\n   UDP and TCP, and 5349 for\
    \ TURN over TLS.  However, TURN has its own\n   set of Service Record (SRV) names:\
    \ \"turn\" for UDP and TCP, and\n   \"turns\" for TLS.  Either the SRV procedures\
    \ or the ALTERNATE-SERVER\n   procedures, both described in Section 6, can be\
    \ used to run TURN on a\n   different port.\n   To ensure interoperability, a\
    \ TURN server MUST support the use of UDP\n   transport between the client and\
    \ the server, and SHOULD support the\n   use of TCP and TLS transport.\n   When\
    \ UDP transport is used between the client and the server, the\n   client will\
    \ retransmit a request if it does not receive a response\n   within a certain\
    \ timeout period.  Because of this, the server may\n   receive two (or more) requests\
    \ with the same 5-tuple and same\n   transaction id.  STUN requires that the server\
    \ recognize this case\n   and treat the request as idempotent (see [RFC5389]).\
    \  Some\n   implementations may choose to meet this requirement by remembering\n\
    \   all received requests and the corresponding responses for 40 seconds.\n  \
    \ Other implementations may choose to reprocess the request and arrange\n   that\
    \ such reprocessing returns essentially the same response.  To aid\n   implementors\
    \ who choose the latter approach (the so-called \"stateless\n   stack approach\"\
    ), this specification includes some implementation\n   notes on how this might\
    \ be done.  Implementations are free to choose\n   either approach or choose some\
    \ other approach that gives the same\n   results.\n   When TCP transport is used\
    \ between the client and the server, it is\n   possible that a bit error will\
    \ cause a length field in a TURN packet\n   to become corrupted, causing the receiver\
    \ to lose synchronization\n   with the incoming stream of TURN messages.  A client\
    \ or server that\n   detects a long sequence of invalid TURN messages over TCP\
    \ transport\n   SHOULD close the corresponding TCP connection to help the other\
    \ end\n   detect this situation more rapidly.\n   To mitigate either intentional\
    \ or unintentional denial-of-service\n   attacks against the server by clients\
    \ with valid usernames and\n   passwords, it is RECOMMENDED that the server impose\
    \ limits on both\n   the number of allocations active at one time for a given\
    \ username and\n   on the amount of bandwidth those allocations can use.  The\
    \ server\n   should reject new allocations that would exceed the limit on the\n\
    \   allowed number of allocations active at one time with a 486\n   (Allocation\
    \ Quota Exceeded) (see Section 6.2), and should discard\n   application data traffic\
    \ that exceeds the bandwidth quota.\n"
- title: 5.  Allocations
  contents:
  - "5.  Allocations\n   All TURN operations revolve around allocations, and all TURN\
    \ messages\n   are associated with an allocation.  An allocation conceptually\n\
    \   consists of the following state data:\n   o  the relayed transport address;\n\
    \   o  the 5-tuple: (client's IP address, client's port, server IP\n      address,\
    \ server port, transport protocol);\n   o  the authentication information;\n \
    \  o  the time-to-expiry;\n   o  a list of permissions;\n   o  a list of channel\
    \ to peer bindings.\n   The relayed transport address is the transport address\
    \ allocated by\n   the server for communicating with peers, while the 5-tuple\
    \ describes\n   the communication path between the client and the server.  On\
    \ the\n   client, the 5-tuple uses the client's host transport address; on the\n\
    \   server, the 5-tuple uses the client's server-reflexive transport\n   address.\n\
    \   Both the relayed transport address and the 5-tuple MUST be unique\n   across\
    \ all allocations, so either one can be used to uniquely\n   identify the allocation.\n\
    \   The authentication information (e.g., username, password, realm, and\n   nonce)\
    \ is used to both verify subsequent requests and to compute the\n   message integrity\
    \ of responses.  The username, realm, and nonce\n   values are initially those\
    \ used in the authenticated Allocate request\n   that creates the allocation,\
    \ though the server can change the nonce\n   value during the lifetime of the\
    \ allocation using a 438 (Stale Nonce)\n   reply.  Note that, rather than storing\
    \ the password explicitly, for\n   security reasons, it may be desirable for the\
    \ server to store the key\n   value, which is an MD5 hash over the username, realm,\
    \ and password\n   (see [RFC5389]).\n   The time-to-expiry is the time in seconds\
    \ left until the allocation\n   expires.  Each Allocate or Refresh transaction\
    \ sets this timer, which\n   then ticks down towards 0.  By default, each Allocate\
    \ or Refresh\n   transaction resets this timer to the default lifetime value of\
    \ 600\n   seconds (10 minutes), but the client can request a different value in\n\
    \   the Allocate and Refresh request.  Allocations can only be refreshed\n   using\
    \ the Refresh request; sending data to a peer does not refresh an\n   allocation.\
    \  When an allocation expires, the state data associated\n   with the allocation\
    \ can be freed.\n   The list of permissions is described in Section 8 and the\
    \ list of\n   channels is described in Section 11.\n"
- title: 6.  Creating an Allocation
  contents:
  - "6.  Creating an Allocation\n   An allocation on the server is created using an\
    \ Allocate transaction.\n"
- title: 6.1.  Sending an Allocate Request
  contents:
  - "6.1.  Sending an Allocate Request\n   The client forms an Allocate request as\
    \ follows.\n   The client first picks a host transport address.  It is RECOMMENDED\n\
    \   that the client pick a currently unused transport address, typically\n   by\
    \ allowing the underlying OS to pick a currently unused port for a\n   new socket.\n\
    \   The client then picks a transport protocol to use between the client\n   and\
    \ the server.  The transport protocol MUST be one of UDP, TCP, or\n   TLS-over-TCP.\
    \  Since this specification only allows UDP between the\n   server and the peers,\
    \ it is RECOMMENDED that the client pick UDP\n   unless it has a reason to use\
    \ a different transport.  One reason to\n   pick a different transport would be\
    \ that the client believes, either\n   through configuration or by experiment,\
    \ that it is unable to contact\n   any TURN server using UDP.  See Section 2.1\
    \ for more discussion.\n   The client also picks a server transport address, which\
    \ SHOULD be\n   done as follows.  The client receives (perhaps through configuration)\n\
    \   a domain name for a TURN server.  The client then uses the DNS\n   procedures\
    \ described in [RFC5389], but using an SRV service name of\n   \"turn\" (or \"\
    turns\" for TURN over TLS) instead of \"stun\" (or \"stuns\").\n   For example,\
    \ to find servers in the example.com domain, the client\n   performs a lookup\
    \ for '_turn._udp.example.com',\n   '_turn._tcp.example.com', and '_turns._tcp.example.com'\
    \ if the client\n   wants to communicate with the server using UDP, TCP, or TLS-over-TCP,\n\
    \   respectively.\n   The client MUST include a REQUESTED-TRANSPORT attribute\
    \ in the\n   request.  This attribute specifies the transport protocol between\
    \ the\n   server and the peers (note that this is NOT the transport protocol\n\
    \   that appears in the 5-tuple).  In this specification, the REQUESTED-\n   TRANSPORT\
    \ type is always UDP.  This attribute is included to allow\n   future extensions\
    \ to specify other protocols.\n   If the client wishes the server to initialize\
    \ the time-to-expiry\n   field of the allocation to some value other than the\
    \ default\n   lifetime, then it MAY include a LIFETIME attribute specifying its\n\
    \   desired value.  This is just a request, and the server may elect to\n   use\
    \ a different value.  Note that the server will ignore requests to\n   initialize\
    \ the field to less than the default value.\n   If the client wishes to later\
    \ use the DONT-FRAGMENT attribute in one\n   or more Send indications on this\
    \ allocation, then the client SHOULD\n   include the DONT-FRAGMENT attribute in\
    \ the Allocate request.  This\n   allows the client to test whether this attribute\
    \ is supported by the\n   server.\n   If the client requires the port number of\
    \ the relayed transport\n   address be even, the client includes the EVEN-PORT\
    \ attribute.  If\n   this attribute is not included, then the port can be even\
    \ or odd.  By\n   setting the R bit in the EVEN-PORT attribute to 1, the client\
    \ can\n   request that the server reserve the next highest port number (on the\n\
    \   same IP address) for a subsequent allocation.  If the R bit is 0, no\n   such\
    \ request is made.\n   The client MAY also include a RESERVATION-TOKEN attribute\
    \ in the\n   request to ask the server to use a previously reserved port for the\n\
    \   allocation.  If the RESERVATION-TOKEN attribute is included, then the\n  \
    \ client MUST omit the EVEN-PORT attribute.\n   Once constructed, the client sends\
    \ the Allocate request on the\n   5-tuple.\n"
- title: 6.2.  Receiving an Allocate Request
  contents:
  - "6.2.  Receiving an Allocate Request\n   When the server receives an Allocate\
    \ request, it performs the\n   following checks:\n   1.  The server MUST require\
    \ that the request be authenticated.  This\n       authentication MUST be done\
    \ using the long-term credential\n       mechanism of [RFC5389] unless the client\
    \ and server agree to use\n       another mechanism through some procedure outside\
    \ the scope of\n       this document.\n   2.  The server checks if the 5-tuple\
    \ is currently in use by an\n       existing allocation.  If yes, the server rejects\
    \ the request with\n       a 437 (Allocation Mismatch) error.\n   3.  The server\
    \ checks if the request contains a REQUESTED-TRANSPORT\n       attribute.  If\
    \ the REQUESTED-TRANSPORT attribute is not included\n       or is malformed, the\
    \ server rejects the request with a 400 (Bad\n       Request) error.  Otherwise,\
    \ if the attribute is included but\n       specifies a protocol other that UDP,\
    \ the server rejects the\n       request with a 442 (Unsupported Transport Protocol)\
    \ error.\n   4.  The request may contain a DONT-FRAGMENT attribute.  If it does,\n\
    \       but the server does not support sending UDP datagrams with the DF\n  \
    \     bit set to 1 (see Section 12), then the server treats the DONT-\n      \
    \ FRAGMENT attribute in the Allocate request as an unknown\n       comprehension-required\
    \ attribute.\n   5.  The server checks if the request contains a RESERVATION-TOKEN\n\
    \       attribute.  If yes, and the request also contains an EVEN-PORT\n     \
    \  attribute, then the server rejects the request with a 400 (Bad\n       Request)\
    \ error.  Otherwise, it checks to see if the token is\n       valid (i.e., the\
    \ token is in range and has not expired and the\n       corresponding relayed\
    \ transport address is still available).  If\n       the token is not valid for\
    \ some reason, the server rejects the\n       request with a 508 (Insufficient\
    \ Capacity) error.\n   6.  The server checks if the request contains an EVEN-PORT\
    \ attribute.\n       If yes, then the server checks that it can satisfy the request\n\
    \       (i.e., can allocate a relayed transport address as described\n       below).\
    \  If the server cannot satisfy the request, then the\n       server rejects the\
    \ request with a 508 (Insufficient Capacity)\n       error.\n   7.  At any point,\
    \ the server MAY choose to reject the request with a\n       486 (Allocation Quota\
    \ Reached) error if it feels the client is\n       trying to exceed some locally\
    \ defined allocation quota.  The\n       server is free to define this allocation\
    \ quota any way it wishes,\n       but SHOULD define it based on the username\
    \ used to authenticate\n       the request, and not on the client's transport\
    \ address.\n   8.  Also at any point, the server MAY choose to reject the request\n\
    \       with a 300 (Try Alternate) error if it wishes to redirect the\n      \
    \ client to a different server.  The use of this error code and\n       attribute\
    \ follow the specification in [RFC5389].\n   If all the checks pass, the server\
    \ creates the allocation.  The\n   5-tuple is set to the 5-tuple from the Allocate\
    \ request, while the\n   list of permissions and the list of channels are initially\
    \ empty.\n   The server chooses a relayed transport address for the allocation\
    \ as\n   follows:\n   o  If the request contains a RESERVATION-TOKEN, the server\
    \ uses the\n      previously reserved transport address corresponding to the\n\
    \      included token (if it is still available).  Note that the\n      reservation\
    \ is a server-wide reservation and is not specific to a\n      particular allocation,\
    \ since the Allocate request containing the\n      RESERVATION-TOKEN uses a different\
    \ 5-tuple than the Allocate\n      request that made the reservation.  The 5-tuple\
    \ for the Allocate\n      request containing the RESERVATION-TOKEN attribute can\
    \ be any\n      allowed 5-tuple; it can use a different client IP address and\n\
    \      port, a different transport protocol, and even different server IP\n  \
    \    address and port (provided, of course, that the server IP address\n     \
    \ and port are ones on which the server is listening for TURN\n      requests).\n\
    \   o  If the request contains an EVEN-PORT attribute with the R bit set\n   \
    \   to 0, then the server allocates a relayed transport address with\n      an\
    \ even port number.\n   o  If the request contains an EVEN-PORT attribute with\
    \ the R bit set\n      to 1, then the server looks for a pair of port numbers\
    \ N and N+1\n      on the same IP address, where N is even.  Port N is used in\
    \ the\n      current allocation, while the relayed transport address with port\n\
    \      N+1 is assigned a token and reserved for a future allocation.  The\n  \
    \    server MUST hold this reservation for at least 30 seconds, and MAY\n    \
    \  choose to hold longer (e.g., until the allocation with port N\n      expires).\
    \  The server then includes the token in a RESERVATION-\n      TOKEN attribute\
    \ in the success response.\n   o  Otherwise, the server allocates any available\
    \ relayed transport\n      address.\n   In all cases, the server SHOULD only allocate\
    \ ports from the range\n   49152 - 65535 (the Dynamic and/or Private Port range\
    \ [Port-Numbers]),\n   unless the TURN server application knows, through some\
    \ means not\n   specified here, that other applications running on the same host\
    \ as\n   the TURN server application will not be impacted by allocating ports\n\
    \   outside this range.  This condition can often be satisfied by running\n  \
    \ the TURN server application on a dedicated machine and/or by\n   arranging that\
    \ any other applications on the machine allocate ports\n   before the TURN server\
    \ application starts.  In any case, the TURN\n   server SHOULD NOT allocate ports\
    \ in the range 0 - 1023 (the Well-\n   Known Port range) to discourage clients\
    \ from using TURN to run\n   standard services.\n      NOTE: The IETF is currently\
    \ investigating the topic of randomized\n      port assignments to avoid certain\
    \ types of attacks (see\n      [TSVWG-PORT]).  It is strongly recommended that\
    \ a TURN implementor\n      keep abreast of this topic and, if appropriate, implement\
    \ a\n      randomized port assignment algorithm.  This is especially\n      applicable\
    \ to servers that choose to pre-allocate a number of\n      ports from the underlying\
    \ OS and then later assign them to\n      allocations; for example, a server may\
    \ choose this technique to\n      implement the EVEN-PORT attribute.\n   The server\
    \ determines the initial value of the time-to-expiry field\n   as follows.  If\
    \ the request contains a LIFETIME attribute, then the\n   server computes the\
    \ minimum of the client's proposed lifetime and the\n   server's maximum allowed\
    \ lifetime.  If this computed value is greater\n   than the default lifetime,\
    \ then the server uses the computed lifetime\n   as the initial value of the time-to-expiry\
    \ field.  Otherwise, the\n   server uses the default lifetime.  It is RECOMMENDED\
    \ that the server\n   use a maximum allowed lifetime value of no more than 3600\
    \ seconds (1\n   hour).  Servers that implement allocation quotas or charge users\
    \ for\n   allocations in some way may wish to use a smaller maximum allowed\n\
    \   lifetime (perhaps as small as the default lifetime) to more quickly\n   remove\
    \ orphaned allocations (that is, allocations where the\n   corresponding client\
    \ has crashed or terminated or the client\n   connection has been lost for some\
    \ reason).  Also, note that the time-\n   to-expiry is recomputed with each successful\
    \ Refresh request, and\n   thus the value computed here applies only until the\
    \ first refresh.\n   Once the allocation is created, the server replies with a\
    \ success\n   response.  The success response contains:\n   o  An XOR-RELAYED-ADDRESS\
    \ attribute containing the relayed transport\n      address.\n   o  A LIFETIME\
    \ attribute containing the current value of the time-to-\n      expiry timer.\n\
    \   o  A RESERVATION-TOKEN attribute (if a second relayed transport\n      address\
    \ was reserved).\n   o  An XOR-MAPPED-ADDRESS attribute containing the client's\
    \ IP address\n      and port (from the 5-tuple).\n      NOTE: The XOR-MAPPED-ADDRESS\
    \ attribute is included in the response\n      as a convenience to the client.\
    \  TURN itself does not make use of\n      this value, but clients running ICE\
    \ can often need this value and\n      can thus avoid having to do an extra Binding\
    \ transaction with some\n      STUN server to learn it.\n   The response (either\
    \ success or error) is sent back to the client on\n   the 5-tuple.\n      NOTE:\
    \ When the Allocate request is sent over UDP, section 7.3.1 of\n      [RFC5389]\
    \ requires that the server handle the possible\n      retransmissions of the request\
    \ so that retransmissions do not\n      cause multiple allocations to be created.\
    \  Implementations may\n      achieve this using the so-called \"stateless stack\
    \ approach\" as\n      follows.  To detect retransmissions when the original request\
    \ was\n      successful in creating an allocation, the server can store the\n\
    \      transaction id that created the request with the allocation data\n    \
    \  and compare it with incoming Allocate requests on the same\n      5-tuple.\
    \  Once such a request is detected, the server can stop\n      parsing the request\
    \ and immediately generate a success response.\n      When building this response,\
    \ the value of the LIFETIME attribute\n      can be taken from the time-to-expiry\
    \ field in the allocate state\n      data, even though this value may differ slightly\
    \ from the LIFETIME\n      value originally returned.  In addition, the server\
    \ may need to\n      store an indication of any reservation token returned in\
    \ the\n      original response, so that this may be returned in any\n      retransmitted\
    \ responses.\n      For the case where the original request was unsuccessful in\n\
    \      creating an allocation, the server may choose to do nothing\n      special.\
    \  Note, however, that there is a rare case where the\n      server rejects the\
    \ original request but accepts the retransmitted\n      request (because conditions\
    \ have changed in the brief intervening\n      time period).  If the client receives\
    \ the first failure response,\n      it will ignore the second (success) response\
    \ and believe that an\n      allocation was not created.  An allocation created\
    \ in this matter\n      will eventually timeout, since the client will not refresh\
    \ it.\n      Furthermore, if the client later retries with the same 5-tuple but\n\
    \      different transaction id, it will receive a 437 (Allocation\n      Mismatch),\
    \ which will cause it to retry with a different 5-tuple.\n      The server may\
    \ use a smaller maximum lifetime value to minimize\n      the lifetime of allocations\
    \ \"orphaned\" in this manner.\n"
- title: 6.3.  Receiving an Allocate Success Response
  contents:
  - "6.3.  Receiving an Allocate Success Response\n   If the client receives an Allocate\
    \ success response, then it MUST\n   check that the mapped address and the relayed\
    \ transport address are\n   in an address family that the client understands and\
    \ is prepared to\n   handle.  This specification only covers the case where these\
    \ two\n   addresses are IPv4 addresses.  If these two addresses are not in an\n\
    \   address family which the client is prepared to handle, then the\n   client\
    \ MUST delete the allocation (Section 7) and MUST NOT attempt to\n   create another\
    \ allocation on that server until it believes the\n   mismatch has been fixed.\n\
    \      The IETF is currently considering mechanisms for transitioning\n      between\
    \ IPv4 and IPv6 that could result in a client originating an\n      Allocate request\
    \ over IPv6, but the request would arrive at the\n      server over IPv4, or vice\
    \ versa.\n   Otherwise, the client creates its own copy of the allocation data\n\
    \   structure to track what is happening on the server.  In particular,\n   the\
    \ client needs to remember the actual lifetime received back from\n   the server,\
    \ rather than the value sent to the server in the request.\n   The client must\
    \ also remember the 5-tuple used for the request and\n   the username and password\
    \ it used to authenticate the request to\n   ensure that it reuses them for subsequent\
    \ messages.  The client also\n   needs to track the channels and permissions it\
    \ establishes on the\n   server.\n   The client will probably wish to send the\
    \ relayed transport address\n   to peers (using some method not specified here)\
    \ so the peers can\n   communicate with it.  The client may also wish to use the\
    \ server-\n   reflexive address it receives in the XOR-MAPPED-ADDRESS attribute\
    \ in\n   its ICE processing.\n"
- title: 6.4.  Receiving an Allocate Error Response
  contents:
  - "6.4.  Receiving an Allocate Error Response\n   If the client receives an Allocate\
    \ error response, then the\n   processing depends on the actual error code returned:\n\
    \   o  (Request timed out): There is either a problem with the server, or\n  \
    \    a problem reaching the server with the chosen transport.  The\n      client\
    \ considers the current transaction as having failed but MAY\n      choose to\
    \ retry the Allocate request using a different transport\n      (e.g., TCP instead\
    \ of UDP).\n   o  300 (Try Alternate): The server would like the client to use\
    \ the\n      server specified in the ALTERNATE-SERVER attribute instead.  The\n\
    \      client considers the current transaction as having failed, but\n      SHOULD\
    \ try the Allocate request with the alternate server before\n      trying any\
    \ other servers (e.g., other servers discovered using the\n      SRV procedures).\
    \  When trying the Allocate request with the\n      alternate server, the client\
    \ follows the ALTERNATE-SERVER\n      procedures specified in [RFC5389].\n   o\
    \  400 (Bad Request): The server believes the client's request is\n      malformed\
    \ for some reason.  The client considers the current\n      transaction as having\
    \ failed.  The client MAY notify the user or\n      operator and SHOULD NOT retry\
    \ the request with this server until\n      it believes the problem has been fixed.\n\
    \   o  401 (Unauthorized): If the client has followed the procedures of\n    \
    \  the long-term credential mechanism and still gets this error, then\n      the\
    \ server is not accepting the client's credentials.  In this\n      case, the\
    \ client considers the current transaction as having\n      failed and SHOULD\
    \ notify the user or operator.  The client SHOULD\n      NOT send any further\
    \ requests to this server until it believes the\n      problem has been fixed.\n\
    \   o  403 (Forbidden): The request is valid, but the server is refusing\n   \
    \   to perform it, likely due to administrative restrictions.  The\n      client\
    \ considers the current transaction as having failed.  The\n      client MAY notify\
    \ the user or operator and SHOULD NOT retry the\n      same request with this\
    \ server until it believes the problem has\n      been fixed.\n   o  420 (Unknown\
    \ Attribute): If the client included a DONT-FRAGMENT\n      attribute in the request\
    \ and the server rejected the request with\n      a 420 error code and listed\
    \ the DONT-FRAGMENT attribute in the\n      UNKNOWN-ATTRIBUTES attribute in the\
    \ error response, then the\n      client now knows that the server does not support\
    \ the DONT-\n      FRAGMENT attribute.  The client considers the current transaction\n\
    \      as having failed but MAY choose to retry the Allocate request\n      without\
    \ the DONT-FRAGMENT attribute.\n   o  437 (Allocation Mismatch): This indicates\
    \ that the client has\n      picked a 5-tuple that the server sees as already\
    \ in use.  One way\n      this could happen is if an intervening NAT assigned\
    \ a mapped\n      transport address that was used by another client that recently\n\
    \      crashed.  The client considers the current transaction as having\n    \
    \  failed.  The client SHOULD pick another client transport address\n      and\
    \ retry the Allocate request (using a different transaction id).\n      The client\
    \ SHOULD try three different client transport addresses\n      before giving up\
    \ on this server.  Once the client gives up on the\n      server, it SHOULD NOT\
    \ try to create another allocation on the\n      server for 2 minutes.\n   o \
    \ 438 (Stale Nonce): See the procedures for the long-term credential\n      mechanism\
    \ [RFC5389].\n   o  441 (Wrong Credentials): The client should not receive this\
    \ error\n      in response to a Allocate request.  The client MAY notify the user\n\
    \      or operator and SHOULD NOT retry the same request with this server\n  \
    \    until it believes the problem has been fixed.\n   o  442 (Unsupported Transport\
    \ Address): The client should not receive\n      this error in response to a request\
    \ for a UDP allocation.  The\n      client MAY notify the user or operator and\
    \ SHOULD NOT reattempt\n      the request with this server until it believes the\
    \ problem has\n      been fixed.\n   o  486 (Allocation Quota Reached): The server\
    \ is currently unable to\n      create any more allocations with this username.\
    \  The client\n      considers the current transaction as having failed.  The\
    \ client\n      SHOULD wait at least 1 minute before trying to create any more\n\
    \      allocations on the server.\n   o  508 (Insufficient Capacity): The server\
    \ has no more relayed\n      transport addresses available, or has none with the\
    \ requested\n      properties, or the one that was reserved is no longer available.\n\
    \      The client considers the current operation as having failed.  If\n    \
    \  the client is using either the EVEN-PORT or the RESERVATION-TOKEN\n      attribute,\
    \ then the client MAY choose to remove or modify this\n      attribute and try\
    \ again immediately.  Otherwise, the client SHOULD\n      wait at least 1 minute\
    \ before trying to create any more\n      allocations on this server.\n   An unknown\
    \ error response MUST be handled as described in [RFC5389].\n"
- title: 7.  Refreshing an Allocation
  contents:
  - "7.  Refreshing an Allocation\n   A Refresh transaction can be used to either\
    \ (a) refresh an existing\n   allocation and update its time-to-expiry or (b)\
    \ delete an existing\n   allocation.\n   If a client wishes to continue using\
    \ an allocation, then the client\n   MUST refresh it before it expires.  It is\
    \ suggested that the client\n   refresh the allocation roughly 1 minute before\
    \ it expires.  If a\n   client no longer wishes to use an allocation, then it\
    \ SHOULD\n   explicitly delete the allocation.  A client MAY refresh an allocation\n\
    \   at any time for other reasons.\n"
- title: 7.1.  Sending a Refresh Request
  contents:
  - "7.1.  Sending a Refresh Request\n   If the client wishes to immediately delete\
    \ an existing allocation, it\n   includes a LIFETIME attribute with a value of\
    \ 0.  All other forms of\n   the request refresh the allocation.\n   The Refresh\
    \ transaction updates the time-to-expiry timer of an\n   allocation.  If the client\
    \ wishes the server to set the time-to-\n   expiry timer to something other than\
    \ the default lifetime, it\n   includes a LIFETIME attribute with the requested\
    \ value.  The server\n   then computes a new time-to-expiry value in the same\
    \ way as it does\n   for an Allocate transaction, with the exception that a requested\n\
    \   lifetime of 0 causes the server to immediately delete the allocation.\n"
- title: 7.2.  Receiving a Refresh Request
  contents:
  - "7.2.  Receiving a Refresh Request\n   When the server receives a Refresh request,\
    \ it processes as per\n   Section 4 plus the specific rules mentioned here.\n\
    \   The server computes a value called the \"desired lifetime\" as follows:\n\
    \   if the request contains a LIFETIME attribute and the attribute value\n   is\
    \ 0, then the \"desired lifetime\" is 0.  Otherwise, if the request\n   contains\
    \ a LIFETIME attribute, then the server computes the minimum\n   of the client's\
    \ requested lifetime and the server's maximum allowed\n   lifetime.  If this computed\
    \ value is greater than the default\n   lifetime, then the \"desired lifetime\"\
    \ is the computed value.\n   Otherwise, the \"desired lifetime\" is the default\
    \ lifetime.\n   Subsequent processing depends on the \"desired lifetime\" value:\n\
    \   o  If the \"desired lifetime\" is 0, then the request succeeds and the\n \
    \     allocation is deleted.\n   o  If the \"desired lifetime\" is non-zero, then\
    \ the request succeeds\n      and the allocation's time-to-expiry is set to the\
    \ \"desired\n      lifetime\".\n   If the request succeeds, then the server sends\
    \ a success response\n   containing:\n   o  A LIFETIME attribute containing the\
    \ current value of the time-to-\n      expiry timer.\n      NOTE: A server need\
    \ not do anything special to implement\n      idempotency of Refresh requests\
    \ over UDP using the \"stateless\n      stack approach\".  Retransmitted Refresh\
    \ requests with a non-zero\n      \"desired lifetime\" will simply refresh the\
    \ allocation.  A\n      retransmitted Refresh request with a zero \"desired lifetime\"\
    \ will\n      cause a 437 (Allocation Mismatch) response if the allocation has\n\
    \      already been deleted, but the client will treat this as equivalent\n  \
    \    to a success response (see below).\n"
- title: 7.3.  Receiving a Refresh Response
  contents:
  - "7.3.  Receiving a Refresh Response\n   If the client receives a success response\
    \ to its Refresh request with\n   a non-zero lifetime, it updates its copy of\
    \ the allocation data\n   structure with the time-to-expiry value contained in\
    \ the response.\n   If the client receives a 437 (Allocation Mismatch) error response\
    \ to\n   a request to delete the allocation, then the allocation no longer\n \
    \  exists and it should consider its request as having effectively\n   succeeded.\n"
- title: 8.  Permissions
  contents:
  - "8.  Permissions\n   For each allocation, the server keeps a list of zero or more\n\
    \   permissions.  Each permission consists of an IP address and an\n   associated\
    \ time-to-expiry.  While a permission exists, all peers\n   using the IP address\
    \ in the permission are allowed to send data to\n   the client.  The time-to-expiry\
    \ is the number of seconds until the\n   permission expires.  Within the context\
    \ of an allocation, a\n   permission is uniquely identified by its associated\
    \ IP address.\n   By sending either CreatePermission requests or ChannelBind requests,\n\
    \   the client can cause the server to install or refresh a permission\n   for\
    \ a given IP address.  This causes one of two things to happen:\n   o  If no permission\
    \ for that IP address exists, then a permission is\n      created with the given\
    \ IP address and a time-to-expiry equal to\n      Permission Lifetime.\n   o \
    \ If a permission for that IP address already exists, then the time-\n      to-expiry\
    \ for that permission is reset to Permission Lifetime.\n   The Permission Lifetime\
    \ MUST be 300 seconds (= 5 minutes).\n   Each permission's time-to-expiry decreases\
    \ down once per second until\n   it reaches 0; at which point, the permission\
    \ expires and is deleted.\n   CreatePermission and ChannelBind requests may be\
    \ freely intermixed on\n   a permission.  A given permission may be initially\
    \ installed and/or\n   refreshed with a CreatePermission request, and then later\
    \ refreshed\n   with a ChannelBind request, or vice versa.\n   When a UDP datagram\
    \ arrives at the relayed transport address for the\n   allocation, the server\
    \ extracts the source IP address from the IP\n   header.  The server then compares\
    \ this address with the IP address\n   associated with each permission in the\
    \ list of permissions for the\n   allocation.  If no match is found, relaying\
    \ is not permitted, and the\n   server silently discards the UDP datagram.  If\
    \ an exact match is\n   found, then the permission check is considered to have\
    \ succeeded and\n   the server continues to process the UDP datagram as specified\n\
    \   elsewhere (Section 10.3).  Note that only addresses are compared and\n   port\
    \ numbers are not considered.\n   The permissions for one allocation are totally\
    \ unrelated to the\n   permissions for a different allocation.  If an allocation\
    \ expires,\n   all its permissions expire with it.\n      NOTE: Though TURN permissions\
    \ expire after 5 minutes, many NATs\n      deployed at the time of publication\
    \ expire their UDP bindings\n      considerably faster.  Thus, an application\
    \ using TURN will\n      probably wish to send some sort of keep-alive traffic\
    \ at a much\n      faster rate.  Applications using ICE should follow the keep-alive\n\
    \      guidelines of ICE [RFC5245], and applications not using ICE are\n     \
    \ advised to do something similar.\n"
- title: 9.  CreatePermission
  contents:
  - "9.  CreatePermission\n   TURN supports two ways for the client to install or\
    \ refresh\n   permissions on the server.  This section describes one way: the\n\
    \   CreatePermission request.\n   A CreatePermission request may be used in conjunction\
    \ with either the\n   Send mechanism in Section 10 or the Channel mechanism in\
    \ Section 11.\n"
- title: 9.1.  Forming a CreatePermission Request
  contents:
  - "9.1.  Forming a CreatePermission Request\n   The client who wishes to install\
    \ or refresh one or more permissions\n   can send a CreatePermission request to\
    \ the server.\n   When forming a CreatePermission request, the client MUST include\
    \ at\n   least one XOR-PEER-ADDRESS attribute, and MAY include more than one\n\
    \   such attribute.  The IP address portion of each XOR-PEER-ADDRESS\n   attribute\
    \ contains the IP address for which a permission should be\n   installed or refreshed.\
    \  The port portion of each XOR-PEER-ADDRESS\n   attribute will be ignored and\
    \ can be any arbitrary value.  The\n   various XOR-PEER-ADDRESS attributes can\
    \ appear in any order.\n"
- title: 9.2.  Receiving a CreatePermission Request
  contents:
  - "9.2.  Receiving a CreatePermission Request\n   When the server receives the CreatePermission\
    \ request, it processes\n   as per Section 4 plus the specific rules mentioned\
    \ here.\n   The message is checked for validity.  The CreatePermission request\n\
    \   MUST contain at least one XOR-PEER-ADDRESS attribute and MAY contain\n   multiple\
    \ such attributes.  If no such attribute exists, or if any of\n   these attributes\
    \ are invalid, then a 400 (Bad Request) error is\n   returned.  If the request\
    \ is valid, but the server is unable to\n   satisfy the request due to some capacity\
    \ limit or similar, then a 508\n   (Insufficient Capacity) error is returned.\n\
    \   The server MAY impose restrictions on the IP address allowed in the\n   XOR-PEER-ADDRESS\
    \ attribute -- if a value is not allowed, the server\n   rejects the request with\
    \ a 403 (Forbidden) error.\n   If the message is valid and the server is capable\
    \ of carrying out the\n   request, then the server installs or refreshes a permission\
    \ for the\n   IP address contained in each XOR-PEER-ADDRESS attribute as described\n\
    \   in Section 8.  The port portion of each attribute is ignored and may\n   be\
    \ any arbitrary value.\n   The server then responds with a CreatePermission success\
    \ response.\n   There are no mandatory attributes in the success response.\n \
    \     NOTE: A server need not do anything special to implement\n      idempotency\
    \ of CreatePermission requests over UDP using the\n      \"stateless stack approach\"\
    .  Retransmitted CreatePermission\n      requests will simply refresh the permissions.\n"
- title: 9.3.  Receiving a CreatePermission Response
  contents:
  - "9.3.  Receiving a CreatePermission Response\n   If the client receives a valid\
    \ CreatePermission success response,\n   then the client updates its data structures\
    \ to indicate that the\n   permissions have been installed or refreshed.\n"
- title: 10.  Send and Data Methods
  contents:
  - "10.  Send and Data Methods\n   TURN supports two mechanisms for sending and receiving\
    \ data from\n   peers.  This section describes the use of the Send and Data\n\
    \   mechanisms, while Section 11 describes the use of the Channel\n   mechanism.\n"
- title: 10.1.  Forming a Send Indication
  contents:
  - "10.1.  Forming a Send Indication\n   The client can use a Send indication to\
    \ pass data to the server for\n   relaying to a peer.  A client may use a Send\
    \ indication even if a\n   channel is bound to that peer.  However, the client\
    \ MUST ensure that\n   there is a permission installed for the IP address of the\
    \ peer to\n   which the Send indication is being sent; this prevents a third party\n\
    \   from using a TURN server to send data to arbitrary destinations.\n   When\
    \ forming a Send indication, the client MUST include an XOR-PEER-\n   ADDRESS\
    \ attribute and a DATA attribute.  The XOR-PEER-ADDRESS\n   attribute contains\
    \ the transport address of the peer to which the\n   data is to be sent, and the\
    \ DATA attribute contains the actual\n   application data to be sent to the peer.\n\
    \   The client MAY include a DONT-FRAGMENT attribute in the Send\n   indication\
    \ if it wishes the server to set the DF bit on the UDP\n   datagram sent to the\
    \ peer.\n"
- title: 10.2.  Receiving a Send Indication
  contents:
  - "10.2.  Receiving a Send Indication\n   When the server receives a Send indication,\
    \ it processes as per\n   Section 4 plus the specific rules mentioned here.\n\
    \   The message is first checked for validity.  The Send indication MUST\n   contain\
    \ both an XOR-PEER-ADDRESS attribute and a DATA attribute.  If\n   one of these\
    \ attributes is missing or invalid, then the message is\n   discarded.  Note that\
    \ the DATA attribute is allowed to contain zero\n   bytes of data.\n   The Send\
    \ indication may also contain the DONT-FRAGMENT attribute.  If\n   the server\
    \ is unable to set the DF bit on outgoing UDP datagrams when\n   this attribute\
    \ is present, then the server acts as if the DONT-\n   FRAGMENT attribute is an\
    \ unknown comprehension-required attribute\n   (and thus the Send indication is\
    \ discarded).\n   The server also checks that there is a permission installed\
    \ for the\n   IP address contained in the XOR-PEER-ADDRESS attribute.  If no such\n\
    \   permission exists, the message is discarded.  Note that a Send\n   indication\
    \ never causes the server to refresh the permission.\n   The server MAY impose\
    \ restrictions on the IP address and port values\n   allowed in the XOR-PEER-ADDRESS\
    \ attribute -- if a value is not\n   allowed, the server silently discards the\
    \ Send indication.\n   If everything is OK, then the server forms a UDP datagram\
    \ as follows:\n   o  the source transport address is the relayed transport address\
    \ of\n      the allocation, where the allocation is determined by the 5-tuple\n\
    \      on which the Send indication arrived;\n   o  the destination transport\
    \ address is taken from the XOR-PEER-\n      ADDRESS attribute;\n   o  the data\
    \ following the UDP header is the contents of the value\n      field of the DATA\
    \ attribute.\n   The handling of the DONT-FRAGMENT attribute (if present), is\n\
    \   described in Section 12.\n   The resulting UDP datagram is then sent to the\
    \ peer.\n"
- title: 10.3.  Receiving a UDP Datagram
  contents:
  - "10.3.  Receiving a UDP Datagram\n   When the server receives a UDP datagram at\
    \ a currently allocated\n   relayed transport address, the server looks up the\
    \ allocation\n   associated with the relayed transport address.  The server then\n\
    \   checks to see whether the set of permissions for the allocation allow\n  \
    \ the relaying of the UDP datagram as described in Section 8.\n   If relaying\
    \ is permitted, then the server checks if there is a\n   channel bound to the\
    \ peer that sent the UDP datagram (see\n   Section 11).  If a channel is bound,\
    \ then processing proceeds as\n   described in Section 11.7.\n   If relaying is\
    \ permitted but no channel is bound to the peer, then\n   the server forms and\
    \ sends a Data indication.  The Data indication\n   MUST contain both an XOR-PEER-ADDRESS\
    \ and a DATA attribute.  The DATA\n   attribute is set to the value of the 'data\
    \ octets' field from the\n   datagram, and the XOR-PEER-ADDRESS attribute is set\
    \ to the source\n   transport address of the received UDP datagram.  The Data\
    \ indication\n   is then sent on the 5-tuple associated with the allocation.\n"
- title: 10.4.  Receiving a Data Indication
  contents:
  - "10.4.  Receiving a Data Indication\n   When the client receives a Data indication,\
    \ it checks that the Data\n   indication contains both an XOR-PEER-ADDRESS and\
    \ a DATA attribute,\n   and discards the indication if it does not.  The client\
    \ SHOULD also\n   check that the XOR-PEER-ADDRESS attribute value contains an\
    \ IP\n   address with which the client believes there is an active permission,\n\
    \   and discard the Data indication otherwise.  Note that the DATA\n   attribute\
    \ is allowed to contain zero bytes of data.\n      NOTE: The latter check protects\
    \ the client against an attacker who\n      somehow manages to trick the server\
    \ into installing permissions\n      not desired by the client.\n   If the Data\
    \ indication passes the above checks, the client delivers\n   the data octets\
    \ inside the DATA attribute to the application, along\n   with an indication that\
    \ they were received from the peer whose\n   transport address is given by the\
    \ XOR-PEER-ADDRESS attribute.\n"
- title: 11.  Channels
  contents:
  - "11.  Channels\n   Channels provide a way for the client and server to send application\n\
    \   data using ChannelData messages, which have less overhead than Send\n   and\
    \ Data indications.\n   The ChannelData message (see Section 11.4) starts with\
    \ a two-byte\n   field that carries the channel number.  The values of this field\
    \ are\n   allocated as follows:\n      0x0000 through 0x3FFF: These values can\
    \ never be used for channel\n      numbers.\n      0x4000 through 0x7FFF: These\
    \ values are the allowed channel\n      numbers (16,383 possible values).\n  \
    \    0x8000 through 0xFFFF: These values are reserved for future use.\n   Because\
    \ of this division, ChannelData messages can be distinguished\n   from STUN-formatted\
    \ messages (e.g., Allocate request, Send\n   indication, etc.) by examining the\
    \ first two bits of the message:\n      0b00: STUN-formatted message (since the\
    \ first two bits of a STUN-\n      formatted message are always zero).\n     \
    \ 0b01: ChannelData message (since the channel number is the first\n      field\
    \ in the ChannelData message and channel numbers fall in the\n      range 0x4000\
    \ - 0x7FFF).\n      0b10: Reserved\n      0b11: Reserved\n   The reserved values\
    \ may be used in the future to extend the range of\n   channel numbers.  Thus,\
    \ an implementation MUST NOT assume that a TURN\n   message always starts with\
    \ a 0 bit.\n   Channel bindings are always initiated by the client.  The client\
    \ can\n   bind a channel to a peer at any time during the lifetime of the\n  \
    \ allocation.  The client may bind a channel to a peer before\n   exchanging data\
    \ with it, or after exchanging data with it (using Send\n   and Data indications)\
    \ for some time, or may choose never to bind a\n   channel to it.  The client\
    \ can also bind channels to some peers while\n   not binding channels to other\
    \ peers.\n   Channel bindings are specific to an allocation, so that the use of\
    \ a\n   channel number or peer transport address in a channel binding in one\n\
    \   allocation has no impact on their use in a different allocation.  If\n   an\
    \ allocation expires, all its channel bindings expire with it.\n   A channel binding\
    \ consists of:\n   o  a channel number;\n   o  a transport address (of the peer);\
    \ and\n   o  A time-to-expiry timer.\n   Within the context of an allocation,\
    \ a channel binding is uniquely\n   identified either by the channel number or\
    \ by the peer's transport\n   address.  Thus, the same channel cannot be bound\
    \ to two different\n   transport addresses, nor can the same transport address\
    \ be bound to\n   two different channels.\n   A channel binding lasts for 10 minutes\
    \ unless refreshed.  Refreshing\n   the binding (by the server receiving a ChannelBind\
    \ request rebinding\n   the channel to the same peer) resets the time-to-expiry\
    \ timer back to\n   10 minutes.\n   When the channel binding expires, the channel\
    \ becomes unbound.  Once\n   unbound, the channel number can be bound to a different\
    \ transport\n   address, and the transport address can be bound to a different\n\
    \   channel number.  To prevent race conditions, the client MUST wait 5\n   minutes\
    \ after the channel binding expires before attempting to bind\n   the channel\
    \ number to a different transport address or the transport\n   address to a different\
    \ channel number.\n   When binding a channel to a peer, the client SHOULD be prepared\
    \ to\n   receive ChannelData messages on the channel from the server as soon\n\
    \   as it has sent the ChannelBind request.  Over UDP, it is possible for\n  \
    \ the client to receive ChannelData messages from the server before it\n   receives\
    \ a ChannelBind success response.\n   In the other direction, the client MAY elect\
    \ to send ChannelData\n   messages before receiving the ChannelBind success response.\
    \  Doing\n   so, however, runs the risk of having the ChannelData messages dropped\n\
    \   by the server if the ChannelBind request does not succeed for some\n   reason\
    \ (e.g., packet lost if the request is sent over UDP, or the\n   server being\
    \ unable to fulfill the request).  A client that wishes to\n   be safe should\
    \ either queue the data or use Send indications until\n   the channel binding\
    \ is confirmed.\n"
- title: 11.1.  Sending a ChannelBind Request
  contents:
  - "11.1.  Sending a ChannelBind Request\n   A channel binding is created or refreshed\
    \ using a ChannelBind\n   transaction.  A ChannelBind transaction also creates\
    \ or refreshes a\n   permission towards the peer (see Section 8).\n   To initiate\
    \ the ChannelBind transaction, the client forms a\n   ChannelBind request.  The\
    \ channel to be bound is specified in a\n   CHANNEL-NUMBER attribute, and the\
    \ peer's transport address is\n   specified in an XOR-PEER-ADDRESS attribute.\
    \  Section 11.2 describes\n   the restrictions on these attributes.\n   Rebinding\
    \ a channel to the same transport address that it is already\n   bound to provides\
    \ a way to refresh a channel binding and the\n   corresponding permission without\
    \ sending data to the peer.  Note\n   however, that permissions need to be refreshed\
    \ more frequently than\n   channels.\n"
- title: 11.2.  Receiving a ChannelBind Request
  contents:
  - "11.2.  Receiving a ChannelBind Request\n   When the server receives a ChannelBind\
    \ request, it processes as per\n   Section 4 plus the specific rules mentioned\
    \ here.\n   The server checks the following:\n   o  The request contains both\
    \ a CHANNEL-NUMBER and an XOR-PEER-ADDRESS\n      attribute;\n   o  The channel\
    \ number is in the range 0x4000 through 0x7FFE\n      (inclusive);\n   o  The\
    \ channel number is not currently bound to a different transport\n      address\
    \ (same transport address is OK);\n   o  The transport address is not currently\
    \ bound to a different\n      channel number.\n   If any of these tests fail,\
    \ the server replies with a 400 (Bad\n   Request) error.\n   The server MAY impose\
    \ restrictions on the IP address and port values\n   allowed in the XOR-PEER-ADDRESS\
    \ attribute -- if a value is not\n   allowed, the server rejects the request with\
    \ a 403 (Forbidden) error.\n   If the request is valid, but the server is unable\
    \ to fulfill the\n   request due to some capacity limit or similar, the server\
    \ replies\n   with a 508 (Insufficient Capacity) error.\n   Otherwise, the server\
    \ replies with a ChannelBind success response.\n   There are no required attributes\
    \ in a successful ChannelBind\n   response.\n   If the server can satisfy the\
    \ request, then the server creates or\n   refreshes the channel binding using\
    \ the channel number in the\n   CHANNEL-NUMBER attribute and the transport address\
    \ in the XOR-PEER-\n   ADDRESS attribute.  The server also installs or refreshes\
    \ a\n   permission for the IP address in the XOR-PEER-ADDRESS attribute as\n \
    \  described in Section 8.\n      NOTE: A server need not do anything special\
    \ to implement\n      idempotency of ChannelBind requests over UDP using the \"\
    stateless\n      stack approach\".  Retransmitted ChannelBind requests will simply\n\
    \      refresh the channel binding and the corresponding permission.\n      Furthermore,\
    \ the client must wait 5 minutes before binding a\n      previously bound channel\
    \ number or peer address to a different\n      channel, eliminating the possibility\
    \ that the transaction would\n      initially fail but succeed on a retransmission.\n"
- title: 11.3.  Receiving a ChannelBind Response
  contents:
  - "11.3.  Receiving a ChannelBind Response\n   When the client receives a ChannelBind\
    \ success response, it updates\n   its data structures to record that the channel\
    \ binding is now active.\n   It also updates its data structures to record that\
    \ the corresponding\n   permission has been installed or refreshed.\n   If the\
    \ client receives a ChannelBind failure response that indicates\n   that the channel\
    \ information is out-of-sync between the client and\n   the server (e.g., an unexpected\
    \ 400 \"Bad Request\" response), then it\n   is RECOMMENDED that the client immediately\
    \ delete the allocation and\n   start afresh with a new allocation.\n"
- title: 11.4.  The ChannelData Message
  contents:
  - "11.4.  The ChannelData Message\n   The ChannelData message is used to carry application\
    \ data between the\n   client and the server.  It has the following format:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Channel Number        |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                     Application Data                        /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   |                    \
    \           +-------------------------------+\n   |                          \
    \     |\n   +-------------------------------+\n   The Channel Number field specifies\
    \ the number of the channel on which\n   the data is traveling, and thus the address\
    \ of the peer that is\n   sending or is to receive the data.\n   The Length field\
    \ specifies the length in bytes of the application\n   data field (i.e., it does\
    \ not include the size of the ChannelData\n   header).  Note that 0 is a valid\
    \ length.\n   The Application Data field carries the data the client is trying\
    \ to\n   send to the peer, or that the peer is sending to the client.\n"
- title: 11.5.  Sending a ChannelData Message
  contents:
  - "11.5.  Sending a ChannelData Message\n   Once a client has bound a channel to\
    \ a peer, then when the client has\n   data to send to that peer it may use either\
    \ a ChannelData message or\n   a Send indication; that is, the client is not obligated\
    \ to use the\n   channel when it exists and may freely intermix the two message\
    \ types\n   when sending data to the peer.  The server, on the other hand, MUST\n\
    \   use the ChannelData message if a channel has been bound to the peer.\n   The\
    \ fields of the ChannelData message are filled in as described in\n   Section\
    \ 11.4.\n   Over TCP and TLS-over-TCP, the ChannelData message MUST be padded\
    \ to\n   a multiple of four bytes in order to ensure the alignment of\n   subsequent\
    \ messages.  The padding is not reflected in the length\n   field of the ChannelData\
    \ message, so the actual size of a ChannelData\n   message (including padding)\
    \ is (4 + Length) rounded up to the nearest\n   multiple of 4.  Over UDP, the\
    \ padding is not required but MAY be\n   included.\n   The ChannelData message\
    \ is then sent on the 5-tuple associated with\n   the allocation.\n"
- title: 11.6.  Receiving a ChannelData Message
  contents:
  - "11.6.  Receiving a ChannelData Message\n   The receiver of the ChannelData message\
    \ uses the first two bits to\n   distinguish it from STUN-formatted messages,\
    \ as described above.  If\n   the message uses a value in the reserved range (0x8000\
    \ through\n   0xFFFF), then the message is silently discarded.\n   If the ChannelData\
    \ message is received in a UDP datagram, and if the\n   UDP datagram is too short\
    \ to contain the claimed length of the\n   ChannelData message (i.e., the UDP\
    \ header length field value is less\n   than the ChannelData header length field\
    \ value + 4 + 8), then the\n   message is silently discarded.\n   If the ChannelData\
    \ message is received over TCP or over TLS-over-TCP,\n   then the actual length\
    \ of the ChannelData message is as described in\n   Section 11.5.\n   If the ChannelData\
    \ message is received on a channel that is not bound\n   to any peer, then the\
    \ message is silently discarded.\n   On the client, it is RECOMMENDED that the\
    \ client discard the\n   ChannelData message if the client believes there is no\
    \ active\n   permission towards the peer.  On the server, the receipt of a\n \
    \  ChannelData message MUST NOT refresh either the channel binding or\n   the\
    \ permission towards the peer.\n   On the server, if no errors are detected, the\
    \ server relays the\n   application data to the peer by forming a UDP datagram\
    \ as follows:\n   o  the source transport address is the relayed transport address\
    \ of\n      the allocation, where the allocation is determined by the 5-tuple\n\
    \      on which the ChannelData message arrived;\n   o  the destination transport\
    \ address is the transport address to\n      which the channel is bound;\n   o\
    \  the data following the UDP header is the contents of the data\n      field\
    \ of the ChannelData message.\n   The resulting UDP datagram is then sent to the\
    \ peer.  Note that if\n   the Length field in the ChannelData message is 0, then\
    \ there will be\n   no data in the UDP datagram, but the UDP datagram is still\
    \ formed and\n   sent.\n"
- title: 11.7.  Relaying Data from the Peer
  contents:
  - "11.7.  Relaying Data from the Peer\n   When the server receives a UDP datagram\
    \ on the relayed transport\n   address associated with an allocation, the server\
    \ processes it as\n   described in Section 10.3.  If that section indicates that\
    \ a\n   ChannelData message should be sent (because there is a channel bound\n\
    \   to the peer that sent to the UDP datagram), then the server forms and\n  \
    \ sends a ChannelData message as described in Section 11.5.\n"
- title: 12.  IP Header Fields
  contents:
  - "12.  IP Header Fields\n   This section describes how the server sets various\
    \ fields in the IP\n   header when relaying between the client and the peer or\
    \ vice versa.\n   The descriptions in this section apply: (a) when the server\
    \ sends a\n   UDP datagram to the peer, or (b) when the server sends a Data\n\
    \   indication or ChannelData message to the client over UDP transport.\n   The\
    \ descriptions in this section do not apply to TURN messages sent\n   over TCP\
    \ or TLS transport from the server to the client.\n   The descriptions below have\
    \ two parts: a preferred behavior and an\n   alternate behavior.  The server SHOULD\
    \ implement the preferred\n   behavior, but if that is not possible for a particular\
    \ field, then it\n   SHOULD implement the alternative behavior.\n   Time to Live\
    \ (TTL) field\n      Preferred Behavior: If the incoming value is 0, then the\
    \ drop the\n      incoming packet.  Otherwise, set the outgoing Time to Live/Hop\n\
    \      Count to one less than the incoming value.\n      Alternate Behavior: Set\
    \ the outgoing value to the default for\n      outgoing packets.\n   Differentiated\
    \ Services Code Point (DSCP) field [RFC2474]\n      Preferred Behavior: Set the\
    \ outgoing value to the incoming value,\n      unless the server includes a differentiated\
    \ services classifier\n      and marker [RFC2474].\n      Alternate Behavior:\
    \ Set the outgoing value to a fixed value, which\n      by default is Best Effort\
    \ unless configured otherwise.\n      In both cases, if the server is immediately\
    \ adjacent to a\n      differentiated services classifier and marker, then DSCP\
    \ MAY be\n      set to any arbitrary value in the direction towards the\n    \
    \  classifier.\n   Explicit Congestion Notification (ECN) field [RFC3168]\n  \
    \    Preferred Behavior: Set the outgoing value to the incoming value,\n     \
    \ UNLESS the server is doing Active Queue Management, the incoming\n      ECN\
    \ field is ECT(1) (=0b01) or ECT(0) (=0b10), and the server\n      wishes to indicate\
    \ that congestion has been experienced, in which\n      case set the outgoing\
    \ value to CE (=0b11).\n      Alternate Behavior: Set the outgoing value to Not-ECT\
    \ (=0b00).\n   IPv4 Fragmentation fields\n      Preferred Behavior: When the server\
    \ sends a packet to a peer in\n      response to a Send indication containing\
    \ the DONT-FRAGMENT\n      attribute, then set the DF bit in the outgoing IP header\
    \ to 1.  In\n      all other cases when sending an outgoing packet containing\n\
    \      application data (e.g., Data indication, ChannelData message, or\n    \
    \  DONT-FRAGMENT attribute not included in the Send indication), copy\n      the\
    \ DF bit from the DF bit of the incoming packet that contained\n      the application\
    \ data.\n      Set the other fragmentation fields (Identification, More\n    \
    \  Fragments, Fragment Offset) as appropriate for a packet\n      originating\
    \ from the server.\n      Alternate Behavior: As described in the Preferred Behavior,\
    \ except\n      always assume the incoming DF bit is 0.\n      In both the Preferred\
    \ and Alternate Behaviors, the resulting\n      packet may be too large for the\
    \ outgoing link.  If this is the\n      case, then the normal fragmentation rules\
    \ apply [RFC1122].\n   IPv4 Options\n      Preferred Behavior: The outgoing packet\
    \ is sent without any IPv4\n      options.\n      Alternate Behavior: Same as\
    \ preferred.\n"
- title: 13.  New STUN Methods
  contents:
  - "13.  New STUN Methods\n   This section lists the codepoints for the new STUN\
    \ methods defined in\n   this specification.  See elsewhere in this document for\
    \ the semantics\n   of these new methods.\n   0x003  :  Allocate          (only\
    \ request/response semantics defined)\n   0x004  :  Refresh           (only request/response\
    \ semantics defined)\n   0x006  :  Send              (only indication semantics\
    \ defined)\n   0x007  :  Data              (only indication semantics defined)\n\
    \   0x008  :  CreatePermission  (only request/response semantics defined\n   0x009\
    \  :  ChannelBind       (only request/response semantics defined)\n"
- title: 14.  New STUN Attributes
  contents:
  - "14.  New STUN Attributes\n   This STUN extension defines the following new attributes:\n\
    \     0x000C: CHANNEL-NUMBER\n     0x000D: LIFETIME\n     0x0010: Reserved (was\
    \ BANDWIDTH)\n     0x0012: XOR-PEER-ADDRESS\n     0x0013: DATA\n     0x0016: XOR-RELAYED-ADDRESS\n\
    \     0x0018: EVEN-PORT\n     0x0019: REQUESTED-TRANSPORT\n     0x001A: DONT-FRAGMENT\n\
    \     0x0021: Reserved (was TIMER-VAL)\n     0x0022: RESERVATION-TOKEN\n   Some\
    \ of these attributes have lengths that are not multiples of 4.\n   By the rules\
    \ of STUN, any attribute whose length is not a multiple of\n   4 bytes MUST be\
    \ immediately followed by 1 to 3 padding bytes to\n   ensure the next attribute\
    \ (if any) would start on a 4-byte boundary\n   (see [RFC5389]).\n"
- title: 14.1.  CHANNEL-NUMBER
  contents:
  - "14.1.  CHANNEL-NUMBER\n   The CHANNEL-NUMBER attribute contains the number of\
    \ the channel.  The\n   value portion of this attribute is 4 bytes long and consists\
    \ of a 16-\n   bit unsigned integer, followed by a two-octet RFFU (Reserved For\n\
    \   Future Use) field, which MUST be set to 0 on transmission and MUST be\n  \
    \ ignored on reception.\n      0                   1                   2     \
    \              3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |        Channel Number         |         RFFU = 0              |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 14.2.  LIFETIME
  contents:
  - "14.2.  LIFETIME\n   The LIFETIME attribute represents the duration for which\
    \ the server\n   will maintain an allocation in the absence of a refresh.  The\
    \ value\n   portion of this attribute is 4-bytes long and consists of a 32-bit\n\
    \   unsigned integral value representing the number of seconds remaining\n   until\
    \ expiration.\n"
- title: 14.3.  XOR-PEER-ADDRESS
  contents:
  - "14.3.  XOR-PEER-ADDRESS\n   The XOR-PEER-ADDRESS specifies the address and port\
    \ of the peer as\n   seen from the TURN server.  (For example, the peer's server-reflexive\n\
    \   transport address if the peer is behind a NAT.)  It is encoded in the\n  \
    \ same way as XOR-MAPPED-ADDRESS [RFC5389].\n"
- title: 14.4.  DATA
  contents:
  - "14.4.  DATA\n   The DATA attribute is present in all Send and Data indications.\
    \  The\n   value portion of this attribute is variable length and consists of\n\
    \   the application data (that is, the data that would immediately follow\n  \
    \ the UDP header if the data was been sent directly between the client\n   and\
    \ the peer).  If the length of this attribute is not a multiple of\n   4, then\
    \ padding must be added after this attribute.\n"
- title: 14.5.  XOR-RELAYED-ADDRESS
  contents:
  - "14.5.  XOR-RELAYED-ADDRESS\n   The XOR-RELAYED-ADDRESS is present in Allocate\
    \ responses.  It\n   specifies the address and port that the server allocated\
    \ to the\n   client.  It is encoded in the same way as XOR-MAPPED-ADDRESS\n  \
    \ [RFC5389].\n"
- title: 14.6.  EVEN-PORT
  contents:
  - "14.6.  EVEN-PORT\n   This attribute allows the client to request that the port\
    \ in the\n   relayed transport address be even, and (optionally) that the server\n\
    \   reserve the next-higher port number.  The value portion of this\n   attribute\
    \ is 1 byte long.  Its format is:\n      0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n\
    \     |R|    RFFU     |\n     +-+-+-+-+-+-+-+-+\n   The value contains a single\
    \ 1-bit flag:\n   R: If 1, the server is requested to reserve the next-higher\
    \ port\n      number (on the same IP address) for a subsequent allocation.  If\n\
    \      0, no such reservation is requested.\n   The other 7 bits of the attribute's\
    \ value must be set to zero on\n   transmission and ignored on reception.\n  \
    \ Since the length of this attribute is not a multiple of 4, padding\n   must\
    \ immediately follow this attribute.\n"
- title: 14.7.  REQUESTED-TRANSPORT
  contents:
  - "14.7.  REQUESTED-TRANSPORT\n   This attribute is used by the client to request\
    \ a specific transport\n   protocol for the allocated transport address.  The\
    \ value of this\n   attribute is 4 bytes with the following format:\n      0 \
    \                  1                   2                   3\n      0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |    Protocol   |                    RFFU                       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The Protocol\
    \ field specifies the desired protocol.  The codepoints\n   used in this field\
    \ are taken from those allowed in the Protocol field\n   in the IPv4 header and\
    \ the NextHeader field in the IPv6 header\n   [Protocol-Numbers].  This specification\
    \ only allows the use of\n   codepoint 17 (User Datagram Protocol).\n   The RFFU\
    \ field MUST be set to zero on transmission and MUST be\n   ignored on reception.\
    \  It is reserved for future uses.\n"
- title: 14.8.  DONT-FRAGMENT
  contents:
  - "14.8.  DONT-FRAGMENT\n   This attribute is used by the client to request that\
    \ the server set\n   the DF (Don't Fragment) bit in the IP header when relaying\
    \ the\n   application data onward to the peer.  This attribute has no value\n\
    \   part and thus the attribute length field is 0.\n"
- title: 14.9.  RESERVATION-TOKEN
  contents:
  - "14.9.  RESERVATION-TOKEN\n   The RESERVATION-TOKEN attribute contains a token\
    \ that uniquely\n   identifies a relayed transport address being held in reserve\
    \ by the\n   server.  The server includes this attribute in a success response\
    \ to\n   tell the client about the token, and the client includes this\n   attribute\
    \ in a subsequent Allocate request to request the server use\n   that relayed\
    \ transport address for the allocation.\n   The attribute value is 8 bytes and\
    \ contains the token value.\n"
- title: 15.  New STUN Error Response Codes
  contents:
  - "15.  New STUN Error Response Codes\n   This document defines the following new\
    \ error response codes:\n   403  (Forbidden): The request was valid but cannot\
    \ be performed due\n      to administrative or similar restrictions.\n   437 \
    \ (Allocation Mismatch): A request was received by the server that\n      requires\
    \ an allocation to be in place, but no allocation exists,\n      or a request\
    \ was received that requires no allocation, but an\n      allocation exists.\n\
    \   441  (Wrong Credentials): The credentials in the (non-Allocate)\n      request\
    \ do not match those used to create the allocation.\n   442  (Unsupported Transport\
    \ Protocol): The Allocate request asked the\n      server to use a transport protocol\
    \ between the server and the peer\n      that the server does not support.  NOTE:\
    \ This does NOT refer to\n      the transport protocol used in the 5-tuple.\n\
    \   486  (Allocation Quota Reached): No more allocations using this\n      username\
    \ can be created at the present time.\n   508  (Insufficient Capacity): The server\
    \ is unable to carry out the\n      request due to some capacity limit being reached.\
    \  In an Allocate\n      response, this could be due to the server having no more\
    \ relayed\n      transport addresses available at that time, having none with\
    \ the\n      requested properties, or the one that corresponds to the specified\n\
    \      reservation token is not available.\n"
- title: 16.  Detailed Example
  contents:
  - "16.  Detailed Example\n   This section gives an example of the use of TURN, showing\
    \ in detail\n   the contents of the messages exchanged.  The example uses the\
    \ network\n   diagram shown in the Overview (Figure 1).\n   For each message,\
    \ the attributes included in the message and their\n   values are shown.  For\
    \ convenience, values are shown in a human-\n   readable format rather than showing\
    \ the actual octets; for example,\n   \"XOR-RELAYED-ADDRESS=192.0.2.15:9000\"\
    \ shows that the XOR-RELAYED-\n   ADDRESS attribute is included with an address\
    \ of 192.0.2.15 and a\n   port of 9000, here the address and port are shown before\
    \ the xor-ing\n   is done.  For attributes with string-like values (e.g.,\n  \
    \ SOFTWARE=\"Example client, version 1.03\" and\n   NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"\
    ), the value of the attribute\n   is shown in quotes for readability, but these\
    \ quotes do not appear in\n   the actual value.\n  TURN                      \
    \           TURN           Peer          Peer\n  client                      \
    \         server          A             B\n    |                             \
    \       |             |             |\n    |--- Allocate request -------------->|\
    \             |             |\n    |    Transaction-Id=0xA56250D3F17ABE679422DE85\
    \     |             |\n    |    SOFTWARE=\"Example client, version 1.03\"    \
    \   |             |\n    |    LIFETIME=3600 (1 hour)          |             |\
    \             |\n    |    REQUESTED-TRANSPORT=17 (UDP)    |             |    \
    \         |\n    |    DONT-FRAGMENT                   |             |        \
    \     |\n    |                                    |             |            \
    \ |\n    |<-- Allocate error response --------|             |             |\n\
    \    |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |\n    |\
    \    SOFTWARE=\"Example server, version 1.17\"       |             |\n    |  \
    \  ERROR-CODE=401 (Unauthorized)   |             |             |\n    |    REALM=\"\
    example.com\"             |             |             |\n    |    NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"\
    \      |             |\n    |                                    |           \
    \  |             |\n    |--- Allocate request -------------->|             | \
    \            |\n    |    Transaction-Id=0xC271E932AD7446A32C234492     |     \
    \        |\n    |    SOFTWARE=\"Example client 1.03\"  |             |       \
    \      |\n    |    LIFETIME=3600 (1 hour)          |             |           \
    \  |\n    |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |\n\
    \    |    DONT-FRAGMENT                   |             |             |\n    |\
    \    USERNAME=\"George\"               |             |             |\n    |  \
    \  REALM=\"example.com\"             |             |             |\n    |    NONCE=\"\
    adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"      |             |\n    |    MESSAGE-INTEGRITY=...\
    \           |             |             |\n    |                             \
    \       |             |             |\n    |<-- Allocate success response ------|\
    \             |             |\n    |    Transaction-Id=0xC271E932AD7446A32C234492\
    \     |             |\n    |    SOFTWARE=\"Example server, version 1.17\"    \
    \   |             |\n    |    LIFETIME=1200 (20 minutes)      |             |\
    \             |\n    |    XOR-RELAYED-ADDRESS=192.0.2.15:50000          |    \
    \         |\n    |    XOR-MAPPED-ADDRESS=192.0.2.1:7000             |        \
    \     |\n    |    MESSAGE-INTEGRITY=...           |             |            \
    \ |\n   The client begins by selecting a host transport address to use for\n \
    \  the TURN session; in this example, the client has selected 10.1.1.2:\n   49721\
    \ as shown in Figure 1.  The client then sends an Allocate\n   request to the\
    \ server at the server transport address.  The client\n   randomly selects a 96-bit\
    \ transaction id of\n   0xA56250D3F17ABE679422DE85 for this transaction; this\
    \ is encoded in\n   the transaction id field in the fixed header.  The client\
    \ includes a\n   SOFTWARE attribute that gives information about the client's\n\
    \   software; here the value is \"Example client, version 1.03\" to\n   indicate\
    \ that this is version 1.03 of something called the Example\n   client.  The client\
    \ includes the LIFETIME attribute because it wishes\n   the allocation to have\
    \ a longer lifetime than the default of 10\n   minutes; the value of this attribute\
    \ is 3600 seconds, which\n   corresponds to 1 hour.  The client must always include\
    \ a REQUESTED-\n   TRANSPORT attribute in an Allocate request and the only value\
    \ allowed\n   by this specification is 17, which indicates UDP transport between\n\
    \   the server and the peers.  The client also includes the DONT-FRAGMENT\n  \
    \ attribute because it wishes to use the DONT-FRAGMENT attribute later\n   in\
    \ Send indications; this attribute consists of only an attribute\n   header, there\
    \ is no value part.  We assume the client has not\n   recently interacted with\
    \ the server, thus the client does not include\n   USERNAME, REALM, NONCE, or\
    \ MESSAGE-INTEGRITY attribute.  Finally,\n   note that the order of attributes\
    \ in a message is arbitrary (except\n   for the MESSAGE-INTEGRITY and FINGERPRINT\
    \ attributes) and the client\n   could have used a different order.\n   Servers\
    \ require any request to be authenticated.  Thus, when the\n   server receives\
    \ the initial Allocate request, it rejects the request\n   because the request\
    \ does not contain the authentication attributes.\n   Following the procedures\
    \ of the long-term credential mechanism of\n   STUN [RFC5389], the server includes\
    \ an ERROR-CODE attribute with a\n   value of 401 (Unauthorized), a REALM attribute\
    \ that specifies the\n   authentication realm used by the server (in this case,\
    \ the server's\n   domain \"example.com\"), and a nonce value in a NONCE attribute.\
    \  The\n   server also includes a SOFTWARE attribute that gives information\n\
    \   about the server's software.\n   The client, upon receipt of the 401 error,\
    \ re-attempts the Allocate\n   request, this time including the authentication\
    \ attributes.  The\n   client selects a new transaction id, and then populates\
    \ the new\n   Allocate request with the same attributes as before.  The client\n\
    \   includes a USERNAME attribute and uses the realm value received from\n   the\
    \ server to help it determine which value to use; here the client\n   is configured\
    \ to use the username \"George\" for the realm\n   \"example.com\".  The client\
    \ also includes the REALM and NONCE\n   attributes, which are just copied from\
    \ the 401 error response.\n   Finally, the client includes a MESSAGE-INTEGRITY\
    \ attribute as the\n   last attribute in the message, whose value is a Hashed\
    \ Message\n   Authentication Code - Secure Hash Algorithm 1 (HMAC-SHA1) hash over\n\
    \   the contents of the message (shown as just \"...\" above); this HMAC-\n  \
    \ SHA1 computation includes a password value.  Thus, an attacker cannot\n   compute\
    \ the message integrity value without somehow knowing the\n   secret password.\n\
    \   The server, upon receipt of the authenticated Allocate request,\n   checks\
    \ that everything is OK, then creates an allocation.  The server\n   replies with\
    \ an Allocate success response.  The server includes a\n   LIFETIME attribute\
    \ giving the lifetime of the allocation; here, the\n   server has reduced the\
    \ client's requested 1-hour lifetime to just 20\n   minutes, because this particular\
    \ server doesn't allow lifetimes\n   longer than 20 minutes.  The server includes\
    \ an XOR-RELAYED-ADDRESS\n   attribute whose value is the relayed transport address\
    \ of the\n   allocation.  The server includes an XOR-MAPPED-ADDRESS attribute\n\
    \   whose value is the server-reflexive address of the client; this value\n  \
    \ is not used otherwise in TURN but is returned as a convenience to the\n   client.\
    \  The server includes a MESSAGE-INTEGRITY attribute to\n   authenticate the response\
    \ and to ensure its integrity; note that the\n   response does not contain the\
    \ USERNAME, REALM, and NONCE attributes.\n   The server also includes a SOFTWARE\
    \ attribute.\n  TURN                                 TURN           Peer     \
    \     Peer\n  client                               server          A         \
    \    B\n    |--- CreatePermission request ------>|             |             |\n\
    \    |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |\n    |\
    \    XOR-PEER-ADDRESS=192.0.2.150:0  |             |             |\n    |    USERNAME=\"\
    George\"               |             |             |\n    |    REALM=\"example.com\"\
    \             |             |             |\n    |    NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"\
    \      |             |\n    |    MESSAGE-INTEGRITY=...           |           \
    \  |             |\n    |                                    |             | \
    \            |\n    |<-- CreatePermission success resp.--|             |     \
    \        |\n    |    Transaction-Id=0xE5913A8F460956CA277D3319     |         \
    \    |\n    |    MESSAGE-INTEGRITY=...           |             |             |\n\
    \   The client then creates a permission towards Peer A in preparation\n   for\
    \ sending it some application data.  This is done through a\n   CreatePermission\
    \ request.  The XOR-PEER-ADDRESS attribute contains\n   the IP address for which\
    \ a permission is established (the IP address\n   of peer A); note that the port\
    \ number in the attribute is ignored\n   when used in a CreatePermission request,\
    \ and here it has been set to\n   0; also, note how the client uses Peer A's server-reflexive\
    \ IP\n   address and not its (private) host address.  The client uses the same\n\
    \   username, realm, and nonce values as in the previous request on the\n   allocation.\
    \  Though it is allowed to do so, the client has chosen not\n   to include a SOFTWARE\
    \ attribute in this request.\n   The server receives the CreatePermission request,\
    \ creates the\n   corresponding permission, and then replies with a CreatePermission\n\
    \   success response.  Like the client, the server chooses not to include\n  \
    \ the SOFTWARE attribute in its reply.  Again, note how success\n   responses\
    \ contain a MESSAGE-INTEGRITY attribute (assuming the server\n   uses the long-term\
    \ credential mechanism), but no USERNAME, REALM, and\n   NONCE attributes.\n \
    \ TURN                                 TURN           Peer          Peer\n  client\
    \                               server          A             B\n    |--- Send\
    \ indication --------------->|             |             |\n    |    Transaction-Id=0x1278E9ACA2711637EF7D3328\
    \     |             |\n    |    XOR-PEER-ADDRESS=192.0.2.150:32102           \
    \ |             |\n    |    DONT-FRAGMENT                   |             |  \
    \           |\n    |    DATA=...                        |             |      \
    \       |\n    |                                    |-- UDP dgm ->|          \
    \   |\n    |                                    |  data=...   |             |\n\
    \    |                                    |             |             |\n    |\
    \                                    |<- UDP dgm --|             |\n    |    \
    \                                |  data=...   |             |\n    |<-- Data\
    \ indication ----------------|             |             |\n    |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF\
    \     |             |\n    |    XOR-PEER-ADDRESS=192.0.2.150:32102           \
    \ |             |\n    |    DATA=...                        |             |  \
    \           |\n   The client now sends application data to Peer A using a Send\n\
    \   indication.  Peer A's server-reflexive transport address is specified\n  \
    \ in the XOR-PEER-ADDRESS attribute, and the application data (shown\n   here\
    \ as just \"...\") is specified in the DATA attribute.  The client\n   is doing\
    \ a form of path MTU discovery at the application layer and\n   thus specifies\
    \ (by including the DONT-FRAGMENT attribute) that the\n   server should set the\
    \ DF bit in the UDP datagram to send to the peer.\n   Indications cannot be authenticated\
    \ using the long-term credential\n   mechanism of STUN, so no MESSAGE-INTEGRITY\
    \ attribute is included in\n   the message.  An application wishing to ensure\
    \ that its data is not\n   altered or forged must integrity-protect its data at\
    \ the application\n   level.\n   Upon receipt of the Send indication, the server\
    \ extracts the\n   application data and sends it in a UDP datagram to Peer A,\
    \ with the\n   relayed transport address as the source transport address of the\n\
    \   datagram, and with the DF bit set as requested.  Note that, had the\n   client\
    \ not previously established a permission for Peer A's server-\n   reflexive IP\
    \ address, then the server would have silently discarded\n   the Send indication\
    \ instead.\n   Peer A then replies with its own UDP datagram containing application\n\
    \   data.  The datagram is sent to the relayed transport address on the\n   server.\
    \  When this arrives, the server creates a Data indication\n   containing the\
    \ source of the UDP datagram in the XOR-PEER-ADDRESS\n   attribute, and the data\
    \ from the UDP datagram in the DATA attribute.\n   The resulting Data indication\
    \ is then sent to the client.\n  TURN                                 TURN   \
    \        Peer          Peer\n  client                               server   \
    \       A             B\n    |--- ChannelBind request ----------->|          \
    \   |             |\n    |    Transaction-Id=0x6490D3BC175AFF3D84513212     |\
    \             |\n    |    CHANNEL-NUMBER=0x4000           |             |    \
    \         |\n    |    XOR-PEER-ADDRESS=192.0.2.210:49191            |        \
    \     |\n    |    USERNAME=\"George\"               |             |          \
    \   |\n    |    REALM=\"example.com\"             |             |            \
    \ |\n    |    NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"      |             |\n\
    \    |    MESSAGE-INTEGRITY=...           |             |             |\n    |\
    \                                    |             |             |\n    |<-- ChannelBind\
    \ success response ---|             |             |\n    |    Transaction-Id=0x6490D3BC175AFF3D84513212\
    \     |             |\n    |    MESSAGE-INTEGRITY=...           |            \
    \ |             |\n   The client now binds a channel to Peer B, specifying a free\
    \ channel\n   number (0x4000) in the CHANNEL-NUMBER attribute, and Peer B's\n\
    \   transport address in the XOR-PEER-ADDRESS attribute.  As before, the\n   client\
    \ re-uses the username, realm, and nonce from its last request\n   in the message.\n\
    \   Upon receipt of the request, the server binds the channel number to\n   the\
    \ peer, installs a permission for Peer B's IP address, and then\n   replies with\
    \ ChannelBind success response.\n  TURN                                 TURN \
    \          Peer          Peer\n  client                               server \
    \         A             B\n    |--- ChannelData ------------------->|        \
    \     |             |\n    |    Channel-number=0x4000           |--- UDP datagram\
    \ --------->|\n    |    Data=...                        |    Data=...        \
    \       |\n    |                                    |             |          \
    \   |\n    |                                    |<-- UDP datagram ----------|\n\
    \    |                                    |    Data=... |             |\n    |<--\
    \ ChannelData --------------------|             |             |\n    |    Channel-number=0x4000\
    \           |             |             |\n    |    Data=...                 \
    \       |             |             |\n   The client now sends a ChannelData message\
    \ to the server with data\n   destined for Peer B.  The ChannelData message is\
    \ not a STUN message,\n   and thus has no transaction id.  Instead, it has only\
    \ three fields: a\n   channel number, data, and data length; here the channel\
    \ number field\n   is 0x4000 (the channel the client just bound to Peer B).  When\
    \ the\n   server receives the ChannelData message, it checks that the channel\n\
    \   is currently bound (which it is) and then sends the data onward to\n   Peer\
    \ B in a UDP datagram, using the relayed transport address as the\n   source transport\
    \ address and 192.0.2.210:49191 (the value of the XOR-\n   PEER-ADDRESS attribute\
    \ in the ChannelBind request) as the destination\n   transport address.\n   Later,\
    \ Peer B sends a UDP datagram back to the relayed transport\n   address.  This\
    \ causes the server to send a ChannelData message to the\n   client containing\
    \ the data from the UDP datagram.  The server knows\n   to which client to send\
    \ the ChannelData message because of the\n   relayed transport address at which\
    \ the UDP datagram arrived, and\n   knows to use channel 0x4000 because this is\
    \ the channel bound to\n   192.0.2.210:49191.  Note that if there had not been\
    \ any channel\n   number bound to that address, the server would have used a Data\n\
    \   indication instead.\n  TURN                                 TURN         \
    \  Peer          Peer\n  client                               server         \
    \ A             B\n    |--- Refresh request --------------->|             |  \
    \           |\n    |    Transaction-Id=0x0864B3C27ADE9354B4312414     |      \
    \       |\n    |    SOFTWARE=\"Example client 1.03\"  |             |        \
    \     |\n    |    USERNAME=\"George\"               |             |          \
    \   |\n    |    REALM=\"example.com\"             |             |            \
    \ |\n    |    NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"      |             |\n\
    \    |    MESSAGE-INTEGRITY=...           |             |             |\n    |\
    \                                    |             |             |\n    |<-- Refresh\
    \ error response ---------|             |             |\n    |    Transaction-Id=0x0864B3C27ADE9354B4312414\
    \     |             |\n    |    SOFTWARE=\"Example server, version 1.17\"    \
    \   |             |\n    |    ERROR-CODE=438 (Stale Nonce)    |             |\
    \             |\n    |    REALM=\"example.com\"             |             |  \
    \           |\n    |    NONCE=\"npSw1Xw239bBwGYhjNWgz2yH47sxB2j\"       |    \
    \         |\n    |                                    |             |        \
    \     |\n    |--- Refresh request --------------->|             |            \
    \ |\n    |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |\n\
    \    |    SOFTWARE=\"Example client 1.03\"  |             |             |\n  \
    \  |    USERNAME=\"George\"               |             |             |\n    |\
    \    REALM=\"example.com\"             |             |             |\n    |  \
    \  NONCE=\"npSw1Xw239bBwGYhjNWgz2yH47sxB2j\"       |             |\n    |    MESSAGE-INTEGRITY=...\
    \           |             |             |\n    |                             \
    \       |             |             |\n    |<-- Refresh success response -------|\
    \             |             |\n    |    Transaction-Id=0x427BD3E625A85FC731DC4191\
    \     |             |\n    |    SOFTWARE=\"Example server, version 1.17\"    \
    \   |             |\n    |    LIFETIME=600 (10 minutes)       |             |\
    \             |\n   Sometime before the 20 minute lifetime is up, the client refreshes\n\
    \   the allocation.  This is done using a Refresh request.  As before,\n   the\
    \ client includes the latest username, realm, and nonce values in\n   the request.\
    \  The client also includes the SOFTWARE attribute,\n   following the recommended\
    \ practice of always including this attribute\n   in Allocate and Refresh messages.\
    \  When the server receives the\n   Refresh request, it notices that the nonce\
    \ value has expired, and so\n   replies with 438 (Stale Nonce) error given a new\
    \ nonce value.  The\n   client then reattempts the request, this time with the\
    \ new nonce\n   value.  This second attempt is accepted, and the server replies\
    \ with\n   a success response.  Note that the client did not include a LIFETIME\n\
    \   attribute in the request, so the server refreshes the allocation for\n   the\
    \ default lifetime of 10 minutes (as can be seen by the LIFETIME\n   attribute\
    \ in the success response).\n"
- title: 17.  Security Considerations
  contents:
  - "17.  Security Considerations\n   This section considers attacks that are possible\
    \ in a TURN\n   deployment, and discusses how they are mitigated by mechanisms\
    \ in the\n   protocol or recommended practices in the implementation.\n   Most\
    \ of the attacks on TURN are mitigated by the server requiring\n   requests be\
    \ authenticated.  Thus, this specification requires the use\n   of authentication.\
    \  The mandatory-to-implement mechanism is the long-\n   term credential mechanism\
    \ of STUN.  Other authentication mechanisms\n   of equal or stronger security\
    \ properties may be used.  However, it is\n   important to ensure that they can\
    \ be invoked in an inter-operable\n   way.\n"
- title: 17.1.  Outsider Attacks
  contents:
  - "17.1.  Outsider Attacks\n   Outsider attacks are ones where the attacker has\
    \ no credentials in\n   the system, and is attempting to disrupt the service seen\
    \ by the\n   client or the server.\n"
- title: 17.1.1.  Obtaining Unauthorized Allocations
  contents:
  - "17.1.1.  Obtaining Unauthorized Allocations\n   An attacker might wish to obtain\
    \ allocations on a TURN server for any\n   number of nefarious purposes.  A TURN\
    \ server provides a mechanism for\n   sending and receiving packets while cloaking\
    \ the actual IP address of\n   the client.  This makes TURN servers an attractive\
    \ target for\n   attackers who wish to use it to mask their true identity.\n \
    \  An attacker might also wish to simply utilize the services of a TURN\n   server\
    \ without paying for them.  Since TURN services require\n   resources from the\
    \ provider, it is anticipated that their usage will\n   come with a cost.\n  \
    \ These attacks are prevented using the long-term credential mechanism,\n   which\
    \ allows the TURN server to determine the identity of the\n   requestor and whether\
    \ the requestor is allowed to obtain the\n   allocation.\n"
- title: 17.1.2.  Offline Dictionary Attacks
  contents:
  - "17.1.2.  Offline Dictionary Attacks\n   The long-term credential mechanism used\
    \ by TURN is subject to offline\n   dictionary attacks.  An attacker that is capable\
    \ of eavesdropping on\n   a message exchange between a client and server can determine\
    \ the\n   password by trying a number of candidate passwords and seeing if one\n\
    \   of them is correct.  This attack works when the passwords are low\n   entropy,\
    \ such as a word from the dictionary.  This attack can be\n   mitigated by using\
    \ strong passwords with large entropy.  In\n   situations where even stronger\
    \ mitigation is required, TLS transport\n   between the client and the server\
    \ can be used.\n"
- title: 17.1.3.  Faked Refreshes and Permissions
  contents:
  - "17.1.3.  Faked Refreshes and Permissions\n   An attacker might wish to attack\
    \ an active allocation by sending it a\n   Refresh request with an immediate expiration,\
    \ in order to delete it\n   and disrupt service to the client.  This is prevented\
    \ by\n   authentication of refreshes.  Similarly, an attacker wishing to send\n\
    \   CreatePermission requests to create permissions to undesirable\n   destinations\
    \ is prevented from doing so through authentication.  The\n   motivations for\
    \ such an attack are described in Section 17.2.\n"
- title: 17.1.4.  Fake Data
  contents:
  - "17.1.4.  Fake Data\n   An attacker might wish to send data to the client or the\
    \ peer, as if\n   they came from the peer or client, respectively.  To do that,\
    \ the\n   attacker can send the client a faked Data Indication or ChannelData\n\
    \   message, or send the TURN server a faked Send Indication or\n   ChannelData\
    \ message.\n   Since indications and ChannelData messages are not authenticated,\n\
    \   this attack is not prevented by TURN.  However, this attack is\n   generally\
    \ present in IP-based communications and is not substantially\n   worsened by\
    \ TURN.  Consider a normal, non-TURN IP session between\n   hosts A and B.  An\
    \ attacker can send packets to B as if they came\n   from A by sending packets\
    \ towards A with a spoofed IP address of B.\n   This attack requires the attacker\
    \ to know the IP addresses of A and\n   B.  With TURN, an attacker wishing to\
    \ send packets towards a client\n   using a Data indication needs to know its\
    \ IP address (and port), the\n   IP address and port of the TURN server, and the\
    \ IP address and port\n   of the peer (for inclusion in the XOR-PEER-ADDRESS attribute).\
    \  To\n   send a fake ChannelData message to a client, an attacker needs to\n\
    \   know the IP address and port of the client, the IP address and port\n   of\
    \ the TURN server, and the channel number.  This particular\n   combination is\
    \ mildly more guessable than in the non-TURN case.\n   These attacks are more\
    \ properly mitigated by application-layer\n   authentication techniques.  In the\
    \ case of real-time traffic, usage\n   of SRTP [RFC3711] prevents these attacks.\n\
    \   In some situations, the TURN server may be situated in the network\n   such\
    \ that it is able to send to hosts to which the client cannot\n   directly send.\
    \  This can happen, for example, if the server is\n   located behind a firewall\
    \ that allows packets from outside the\n   firewall to be delivered to the server,\
    \ but not to other hosts behind\n   the firewall.  In these situations, an attacker\
    \ could send the server\n   a Send indication with an XOR-PEER-ADDRESS attribute\
    \ containing the\n   transport address of one of the other hosts behind the firewall.\
    \  If\n   the server was to allow relaying of traffic to arbitrary peers, then\n\
    \   this would provide a way for the attacker to attack arbitrary hosts\n   behind\
    \ the firewall.\n   To mitigate this attack, TURN requires that the client establish\
    \ a\n   permission to a host before sending it data.  Thus, an attacker can\n\
    \   only attack hosts with which the client is already communicating,\n   unless\
    \ the attacker is able to create authenticated requests.\n   Furthermore, the\
    \ server administrator may configure the server to\n   restrict the range of IP\
    \ addresses and ports to which it will relay\n   data.  To provide even greater\
    \ security, the server administrator can\n   require that the client use TLS for\
    \ all communication between the\n   client and the server.\n"
- title: 17.1.5.  Impersonating a Server
  contents:
  - "17.1.5.  Impersonating a Server\n   When a client learns a relayed address from\
    \ a TURN server, it uses\n   that relayed address in application protocols to\
    \ receive traffic.\n   Therefore, an attacker wishing to intercept or redirect\
    \ that traffic\n   might try to impersonate a TURN server and provide the client\
    \ with a\n   faked relayed address.\n   This attack is prevented through the long-term\
    \ credential mechanism,\n   which provides message integrity for responses in\
    \ addition to\n   verifying that they came from the server.  Furthermore, an attacker\n\
    \   cannot replay old server responses as the transaction id in the STUN\n   header\
    \ prevents this.  Replay attacks are further thwarted through\n   frequent changes\
    \ to the nonce value.\n"
- title: 17.1.6.  Eavesdropping Traffic
  contents:
  - "17.1.6.  Eavesdropping Traffic\n   TURN concerns itself primarily with authentication\
    \ and message\n   integrity.  Confidentiality is only a secondary concern, as\
    \ TURN\n   control messages do not include information that is particularly\n\
    \   sensitive.  The primary protocol content of the messages is the IP\n   address\
    \ of the peer.  If it is important to prevent an eavesdropper\n   on a TURN connection\
    \ from learning this, TURN can be run over TLS.\n   Confidentiality for the application\
    \ data relayed by TURN is best\n   provided by the application protocol itself,\
    \ since running TURN over\n   TLS does not protect application data between the\
    \ server and the\n   peer.  If confidentiality of application data is important,\
    \ then the\n   application should encrypt or otherwise protect its data.  For\n\
    \   example, for real-time media, confidentiality can be provided by\n   using\
    \ SRTP.\n"
- title: 17.1.7.  TURN Loop Attack
  contents:
  - "17.1.7.  TURN Loop Attack\n   An attacker might attempt to cause data packets\
    \ to loop indefinitely\n   between two TURN servers.  The attack goes as follows.\
    \  First, the\n   attacker sends an Allocate request to server A, using the source\n\
    \   address of server B.  Server A will send its response to server B,\n   and\
    \ for the attack to succeed, the attacker must have the ability to\n   either\
    \ view or guess the contents of this response, so that the\n   attacker can learn\
    \ the allocated relayed transport address.  The\n   attacker then sends an Allocate\
    \ request to server B, using the source\n   address of server A.  Again, the attacker\
    \ must be able to view or\n   guess the contents of the response, so it can send\
    \ learn the\n   allocated relayed transport address.  Using the same spoofed source\n\
    \   address technique, the attacker then binds a channel number on server\n  \
    \ A to the relayed transport address on server B, and similarly binds\n   the\
    \ same channel number on server B to the relayed transport address\n   on server\
    \ A.  Finally, the attacker sends a ChannelData message to\n   server A.\n   The\
    \ result is a data packet that loops from the relayed transport\n   address on\
    \ server A to the relayed transport address on server B,\n   then from server\
    \ B's transport address to server A's transport\n   address, and then around the\
    \ loop again.\n   This attack is mitigated as follows.  By requiring all requests\
    \ to be\n   authenticated and/or by randomizing the port number allocated for\
    \ the\n   relayed transport address, the server forces the attacker to either\n\
    \   intercept or view responses sent to a third party (in this case, the\n   other\
    \ server) so that the attacker can authenticate the requests and\n   learn the\
    \ relayed transport address.  Without one of these two\n   measures, an attacker\
    \ can guess the contents of the responses without\n   needing to see them, which\
    \ makes the attack much easier to perform.\n   Furthermore, by requiring authenticated\
    \ requests, the server forces\n   the attacker to have credentials acceptable\
    \ to the server, which\n   turns this from an outsider attack into an insider\
    \ attack and allows\n   the attack to be traced back to the client initiating\
    \ it.\n   The attack can be further mitigated by imposing a per-username limit\n\
    \   on the bandwidth used to relay data by allocations owned by that\n   username,\
    \ to limit the impact of this attack on other allocations.\n   More mitigation\
    \ can be achieved by decrementing the TTL when relaying\n   data packets (if the\
    \ underlying OS allows this).\n"
- title: 17.2.  Firewall Considerations
  contents:
  - "17.2.  Firewall Considerations\n   A key security consideration of TURN is that\
    \ TURN should not weaken\n   the protections afforded by firewalls deployed between\
    \ a client and a\n   TURN server.  It is anticipated that TURN servers will often\
    \ be\n   present on the public Internet, and clients may often be inside\n   enterprise\
    \ networks with corporate firewalls.  If TURN servers\n   provide a 'backdoor'\
    \ for reaching into the enterprise, TURN will be\n   blocked by these firewalls.\n\
    \   TURN servers therefore emulate the behavior of NAT devices that\n   implement\
    \ address-dependent filtering [RFC4787], a property common in\n   many firewalls\
    \ as well.  When a NAT or firewall implements this\n   behavior, packets from\
    \ an outside IP address are only allowed to be\n   sent to an internal IP address\
    \ and port if the internal IP address\n   and port had recently sent a packet\
    \ to that outside IP address.  TURN\n   servers introduce the concept of permissions,\
    \ which provide exactly\n   this same behavior on the TURN server.  An attacker\
    \ cannot send a\n   packet to a TURN server and expect it to be relayed towards\
    \ the\n   client, unless the client has tried to contact the attacker first.\n\
    \   It is important to note that some firewalls have policies that are\n   even\
    \ more restrictive than address-dependent filtering.  Firewalls\n   can also be\
    \ configured with address- and port-dependent filtering, or\n   can be configured\
    \ to disallow inbound traffic entirely.  In these\n   cases, if a client is allowed\
    \ to connect the TURN server,\n   communications to the client will be less restrictive\
    \ than what the\n   firewall would normally allow.\n"
- title: 17.2.1.  Faked Permissions
  contents:
  - "17.2.1.  Faked Permissions\n   In firewalls and NAT devices, permissions are\
    \ granted implicitly\n   through the traversal of a packet from the inside of\
    \ the network\n   towards the outside peer.  Thus, a permission cannot, by definition,\n\
    \   be created by any entity except one inside the firewall or NAT.  With\n  \
    \ TURN, this restriction no longer holds.  Since the TURN server sits\n   outside\
    \ the firewall, at attacker outside the firewall can now send a\n   message to\
    \ the TURN server and try to create a permission for itself.\n   This attack is\
    \ prevented because all messages that create permissions\n   (i.e., ChannelBind\
    \ and CreatePermission) are authenticated.\n"
- title: 17.2.2.  Blacklisted IP Addresses
  contents:
  - "17.2.2.  Blacklisted IP Addresses\n   Many firewalls can be configured with blacklists\
    \ that prevent a\n   client behind the firewall from sending packets to, or receiving\n\
    \   packets from, ranges of blacklisted IP addresses.  This is\n   accomplished\
    \ by inspecting the source and destination addresses of\n   packets entering and\
    \ exiting the firewall, respectively.\n   This feature is also present in TURN,\
    \ since TURN servers are allowed\n   to arbitrarily restrict the range of addresses\
    \ of peers that they\n   will relay to.\n"
- title: 17.2.3.  Running Servers on Well-Known Ports
  contents:
  - "17.2.3.  Running Servers on Well-Known Ports\n   A malicious client behind a\
    \ firewall might try to connect to a TURN\n   server and obtain an allocation\
    \ which it then uses to run a server.\n   For example, a client might try to run\
    \ a DNS server or FTP server.\n   This is not possible in TURN.  A TURN server\
    \ will never accept\n   traffic from a peer for which the client has not installed\
    \ a\n   permission.  Thus, peers cannot just connect to the allocated port in\n\
    \   order to obtain the service.\n"
- title: 17.3.  Insider Attacks
  contents:
  - "17.3.  Insider Attacks\n   In insider attacks, a client has legitimate credentials\
    \ but defies\n   the trust relationship that goes with those credentials.  These\n\
    \   attacks cannot be prevented by cryptographic means but need to be\n   considered\
    \ in the design of the protocol.\n"
- title: 17.3.1.  DoS against TURN Server
  contents:
  - "17.3.1.  DoS against TURN Server\n   A client wishing to disrupt service to other\
    \ clients might obtain an\n   allocation and then flood it with traffic, in an\
    \ attempt to swamp the\n   server and prevent it from servicing other legitimate\
    \ clients.  This\n   is mitigated by the recommendation that the server limit\
    \ the amount\n   of bandwidth it will relay for a given username.  This won't\
    \ prevent\n   a client from sending a large amount of traffic, but it allows the\n\
    \   server to immediately discard traffic in excess.\n   Since each allocation\
    \ uses a port number on the IP address of the\n   TURN server, the number of allocations\
    \ on a server is finite.  An\n   attacker might attempt to consume all of them\
    \ by requesting a large\n   number of allocations.  This is prevented by the recommendation\
    \ that\n   the server impose a limit of the number of allocations active at a\n\
    \   time for a given username.\n"
- title: 17.3.2.  Anonymous Relaying of Malicious Traffic
  contents:
  - "17.3.2.  Anonymous Relaying of Malicious Traffic\n   TURN servers provide a degree\
    \ of anonymization.  A client can send\n   data to peers without revealing its\
    \ own IP address.  TURN servers may\n   therefore become attractive vehicles for\
    \ attackers to launch attacks\n   against targets without fear of detection. \
    \ Indeed, it is possible\n   for a client to chain together multiple TURN servers,\
    \ such that any\n   number of relays can be used before a target receives a packet.\n\
    \   Administrators who are worried about this attack can maintain logs\n   that\
    \ capture the actual source IP and port of the client, and perhaps\n   even every\
    \ permission that client installs.  This will allow for\n   forensic tracing to\
    \ determine the original source, should it be\n   discovered that an attack is\
    \ being relayed through a TURN server.\n"
- title: 17.3.3.  Manipulating Other Allocations
  contents:
  - "17.3.3.  Manipulating Other Allocations\n   An attacker might attempt to disrupt\
    \ service to other users of the\n   TURN server by sending Refresh requests or\
    \ CreatePermission requests\n   that (through source address spoofing) appear\
    \ to be coming from\n   another user of the TURN server.  TURN prevents this by\
    \ requiring\n   that the credentials used in CreatePermission, Refresh, and\n\
    \   ChannelBind messages match those used to create the initial\n   allocation.\
    \  Thus, the fake requests from the attacker will be\n   rejected.\n"
- title: 17.4.  Other Considerations
  contents:
  - "17.4.  Other Considerations\n   Any relay addresses learned through an Allocate\
    \ request will not\n   operate properly with IPsec Authentication Header (AH)\
    \ [RFC4302] in\n   transport or tunnel mode.  However, tunnel-mode IPsec Encapsulating\n\
    \   Security Payload (ESP) [RFC4303] should still operate.\n"
- title: 18.  IANA Considerations
  contents:
  - "18.  IANA Considerations\n   Since TURN is an extension to STUN [RFC5389], the\
    \ methods,\n   attributes, and error codes defined in this specification are new\n\
    \   methods, attributes, and error codes for STUN.  IANA has added these\n   new\
    \ protocol elements to the IANA registry of STUN protocol elements.\n   The codepoints\
    \ for the new STUN methods defined in this specification\n   are listed in Section\
    \ 13.\n   The codepoints for the new STUN attributes defined in this\n   specification\
    \ are listed in Section 14.\n   The codepoints for the new STUN error codes defined\
    \ in this\n   specification are listed in Section 15.\n   IANA has allocated the\
    \ SRV service name of \"turn\" for TURN over UDP\n   or TCP, and the service name\
    \ of \"turns\" for TURN over TLS.\n   IANA has created a registry for TURN channel\
    \ numbers, initially\n   populated as follows:\n      0x0000 through 0x3FFF: Reserved\
    \ and not available for use, since\n      they conflict with the STUN header.\n\
    \      0x4000 through 0x7FFF: A TURN implementation is free to use\n      channel\
    \ numbers in this range.\n      0x8000 through 0xFFFF: Unassigned.\n   Any change\
    \ to this registry must be made through an IETF Standards\n   Action.\n"
- title: 19.  IAB Considerations
  contents:
  - "19.  IAB Considerations\n   The IAB has studied the problem of \"Unilateral Self\
    \ Address Fixing\"\n   (UNSAF), which is the general process by which a client\
    \ attempts to\n   determine its address in another realm on the other side of\
    \ a NAT\n   through a collaborative protocol-reflection mechanism [RFC3424]. \
    \ The\n   TURN extension is an example of a protocol that performs this type of\n\
    \   function.  The IAB has mandated that any protocols developed for this\n  \
    \ purpose document a specific set of considerations.  These\n   considerations\
    \ and the responses for TURN are documented in this\n   section.\n   Consideration\
    \ 1: Precise definition of a specific, limited-scope\n   problem that is to be\
    \ solved with the UNSAF proposal.  A short-term\n   fix should not be generalized\
    \ to solve other problems.  Such\n   generalizations lead to the prolonged dependence\
    \ on and usage of the\n   supposed short-term fix -- meaning that it is no longer\
    \ accurate to\n   call it \"short-term\".\n   Response: TURN is a protocol for\
    \ communication between a relay (=\n   TURN server) and its client.  The protocol\
    \ allows a client that is\n   behind a NAT to obtain and use a public IP address\
    \ on the relay.  As\n   a convenience to the client, TURN also allows the client\
    \ to determine\n   its server-reflexive transport address.\n   Consideration 2:\
    \ Description of an exit strategy/transition plan.\n   The better short-term fixes\
    \ are the ones that will naturally see less\n   and less use as the appropriate\
    \ technology is deployed.\n   Response: TURN will no longer be needed once there\
    \ are no longer any\n   NATs.  Unfortunately, as of the date of publication of\
    \ this document,\n   it no longer seems very likely that NATs will go away any\
    \ time soon.\n   However, the need for TURN will also decrease as the number of\
    \ NATs\n   with the mapping property of Endpoint-Independent Mapping [RFC4787]\n\
    \   increases.\n   Consideration 3: Discussion of specific issues that may render\n\
    \   systems more \"brittle\".  For example, approaches that involve using\n  \
    \ data at multiple network layers create more dependencies, increase\n   debugging\
    \ challenges, and make it harder to transition.\n   Response: TURN is \"brittle\"\
    \ in that it requires the NAT bindings\n   between the client and the server to\
    \ be maintained unchanged for the\n   lifetime of the allocation.  This is typically\
    \ done using keep-\n   alives.  If this is not done, then the client will lose\
    \ its\n   allocation and can no longer exchange data with its peers.\n   Consideration\
    \ 4: Identify requirements for longer-term, sound\n   technical solutions; contribute\
    \ to the process of finding the right\n   longer-term solution.\n   Response:\
    \ The need for TURN will be reduced once NATs implement the\n   recommendations\
    \ for NAT UDP behavior documented in [RFC4787].\n   Applications are also strongly\
    \ urged to use ICE [RFC5245] to\n   communicate with peers; though ICE uses TURN,\
    \ it does so only as a\n   last resort, and uses it in a controlled manner.\n\
    \   Consideration 5: Discussion of the impact of the noted practical\n   issues\
    \ with existing deployed NATs and experience reports.\n   Response: Some NATs\
    \ deployed today exhibit a mapping behavior other\n   than Endpoint-Independent\
    \ mapping.  These NATs are difficult to work\n   with, as they make it difficult\
    \ or impossible for protocols like ICE\n   to use server-reflexive transport addresses\
    \ on those NATs.  A client\n   behind such a NAT is often forced to use a relay\
    \ protocol like TURN\n   because \"UDP hole punching\" techniques [RFC5128] do\
    \ not work.\n"
- title: 20.  Acknowledgements
  contents:
  - "20.  Acknowledgements\n   The authors would like to thank the various participants\
    \ in the\n   BEHAVE working group for their many comments on this document.  Marc\n\
    \   Petit-Huguenin, Remi Denis-Courmont, Jason Fischl, Derek MacDonald,\n   Scott\
    \ Godin, Cullen Jennings, Lars Eggert, Magnus Westerlund, Benny\n   Prijono, and\
    \ Eric Rescorla have been particularly helpful, with Eric\n   suggesting the channel\
    \ allocation mechanism, Cullen suggesting an\n   earlier version of the EVEN-PORT\
    \ mechanism, and Marc spending many\n   hours implementing the preliminary versions\
    \ to look for problems.\n   Christian Huitema was an early contributor to this\
    \ document and was a\n   co-author on the first few versions.  Finally, the authors\
    \ would like\n   to thank Dan Wing for both his contributions to the text and\
    \ his huge\n   help in restarting progress on this document after work had stalled.\n"
- title: 21.  References
  contents:
  - '21.  References

    '
- title: 21.1.  Normative References
  contents:
  - "21.1.  Normative References\n   [RFC5389]            Rosenberg, J., Mahy, R.,\
    \ Matthews, P., and D.\n                        Wing, \"Session Traversal Utilities\
    \ for NAT\n                        (STUN)\", RFC 5389, October 2008.\n   [RFC2119]\
    \            Bradner, S., \"Key words for use in RFCs to\n                   \
    \     Indicate Requirement Levels\", BCP 14, RFC 2119,\n                     \
    \   March 1997.\n   [RFC2474]            Nichols, K., Blake, S., Baker, F., and\
    \ D. Black,\n                        \"Definition of the Differentiated Services\
    \ Field\n                        (DS Field) in the IPv4 and IPv6 Headers\",\n\
    \                        RFC 2474, December 1998.\n   [RFC3168]            Ramakrishnan,\
    \ K., Floyd, S., and D. Black, \"The\n                        Addition of Explicit\
    \ Congestion Notification\n                        (ECN) to IP\", RFC 3168, September\
    \ 2001.\n   [RFC1122]            Braden, R., \"Requirements for Internet Hosts\
    \ -\n                        Communication Layers\", STD 3, RFC 1122,\n      \
    \                  October 1989.\n"
- title: 21.2.  Informative References
  contents:
  - "21.2.  Informative References\n   [RFC1191]            Mogul, J. and S. Deering,\
    \ \"Path MTU discovery\",\n                        RFC 1191, November 1990.\n\
    \   [RFC0791]            Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n\
    \                        September 1981.\n   [RFC1918]            Rekhter, Y.,\
    \ Moskowitz, R., Karrenberg, D.,\n                        Groot, G., and E. Lear,\
    \ \"Address Allocation for\n                        Private Internets\", BCP 5,\
    \ RFC 1918,\n                        February 1996.\n   [RFC3424]            Daigle,\
    \ L. and IAB, \"IAB Considerations for\n                        UNilateral Self-Address\
    \ Fixing (UNSAF) Across\n                        Network Address Translation\"\
    , RFC 3424,\n                        November 2002.\n   [RFC4787]            Audet,\
    \ F. and C. Jennings, \"Network Address\n                        Translation (NAT)\
    \ Behavioral Requirements for\n                        Unicast UDP\", BCP 127,\
    \ RFC 4787, January 2007.\n   [RFC5245]            Rosenberg, J., \"Interactive\
    \ Connectivity\n                        Establishment (ICE): A Protocol for Network\n\
    \                        Address Translator (NAT) Traversal for\n            \
    \            Offer/Answer Protocols\", RFC 5245, April 2010.\n   [TURN-TCP]  \
    \         Perreault, S. and J. Rosenberg, \"Traversal Using\n                \
    \        Relays around NAT (TURN) Extensions for TCP\n                       \
    \ Allocations\", Work in Progress, March 2010.\n   [TURN-IPv6]          Perreault,\
    \ S., Camarillo, G., and O. Novo,\n                        \"Traversal Using Relays\
    \ around NAT (TURN)\n                        Extension for IPv6\", Work in Progress,\
    \ March\n                        2010.\n   [TSVWG-PORT]         Larsen, M. and\
    \ F. Gont, \"Port Randomization\",\n                        Work in Progress,\
    \ April 2010.\n   [RFC5128]            Srisuresh, P., Ford, B., and D. Kegel,\
    \ \"State of\n                        Peer-to-Peer (P2P) Communication across\
    \ Network\n                        Address Translators (NATs)\", RFC 5128,\n \
    \                       March 2008.\n   [RFC1928]            Leech, M., Ganis,\
    \ M., Lee, Y., Kuris, R.,\n                        Koblas, D., and L. Jones, \"\
    SOCKS Protocol\n                        Version 5\", RFC 1928, March 1996.\n \
    \  [RFC3550]            Schulzrinne, H., Casner, S., Frederick, R., and\n    \
    \                    V. Jacobson, \"RTP: A Transport Protocol for\n          \
    \              Real-Time Applications\", STD 64, RFC 3550,\n                 \
    \       July 2003.\n   [RFC3711]            Baugher, M., McGrew, D., Naslund,\
    \ M., Carrara,\n                        E., and K. Norrman, \"The Secure Real-time\n\
    \                        Transport Protocol (SRTP)\", RFC 3711,\n            \
    \            March 2004.\n   [RFC4302]            Kent, S., \"IP Authentication\
    \ Header\", RFC 4302,\n                        December 2005.\n   [RFC4303]  \
    \          Kent, S., \"IP Encapsulating Security Payload\n                   \
    \     (ESP)\", RFC 4303, December 2005.\n   [RFC4821]            Mathis, M. and\
    \ J. Heffner, \"Packetization Layer\n                        Path MTU Discovery\"\
    , RFC 4821, March 2007.\n   [RFC3261]            Rosenberg, J., Schulzrinne, H.,\
    \ Camarillo, G.,\n                        Johnston, A., Peterson, J., Sparks,\
    \ R., Handley,\n                        M., and E. Schooler, \"SIP: Session Initiation\n\
    \                        Protocol\", RFC 3261, June 2002.\n   [MMUSIC-ICE-NONSIP]\
    \  Rosenberg, J., \"Guidelines for Usage of\n                        Interactive\
    \ Connectivity Establishment (ICE) by\n                        non Session Initiation\
    \ Protocol (SIP)\n                        Protocols\", Work in Progress, July\
    \ 2008.\n   [RFC4086]            Eastlake, D., Schiller, J., and S. Crocker,\n\
    \                        \"Randomness Requirements for Security\", BCP 106,\n\
    \                        RFC 4086, June 2005.\n   [Frag-Harmful]       Kent and\
    \ Mogul, \"Fragmentation Considered\n                        Harmful\".  Proc.\
    \ SIGCOMM '87, vol. 17, No. 5,\n                        October 1987\n   [Port-Numbers]\
    \       \"IANA Port Numbers Registry\",\n                        <http://www.iana.org>.\n\
    \   [Protocol-Numbers]   \"IANA Protocol Numbers Registry\", 2005,\n         \
    \               <http://www.iana.org>.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Rohan Mahy\n   Unaffiliated\n   EMail: rohan@ekabal.com\n\
    \   Philip Matthews\n   Alcatel-Lucent\n   600 March Road\n   Ottawa, Ontario\n\
    \   Canada\n   EMail: philip_matthews@magma.ca\n   Jonathan Rosenberg\n   jdrosen.net\n\
    \   Monmouth, NJ\n   USA\n   EMail: jdrosen@jdrosen.net\n   URI:   http://www.jdrosen.net\n"
