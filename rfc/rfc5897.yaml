- title: __initial_text__
  contents:
  - "               Identification of Communications Services\n                in\
    \ the Session Initiation Protocol (SIP)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document considers the problem of service identification in\
    \ the\n   Session Initiation Protocol (SIP).  Service identification is the\n\
    \   process of determining the user-level use case that is driving the\n   signaling\
    \ being utilized by the user agent (UA).  This document\n   discusses the uses\
    \ of service identification, and outlines several\n   architectural principles\
    \ behind the process.  It identifies perils\n   when service identification is\
    \ not done properly -- including fraud,\n   interoperability failures, and stifling\
    \ of innovation.  It then\n   outlines a set of recommended practices for service\
    \ identification.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc5897.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Services and Service Identification .............................4\n  \
    \ 3. Example Services ................................................6\n    \
    \  3.1. IPTV vs. Multimedia ........................................6\n      3.2.\
    \ Gaming vs. Voice Chat ......................................7\n      3.3. Gaming\
    \ vs. Voice Chat #2 ...................................7\n      3.4. Configuration\
    \ vs. Pager Messaging ..........................7\n   4. Using Service Identification\
    \ ....................................8\n      4.1. Application Invocation in\
    \ the User Agent ...................8\n      4.2. Application Invocation in the\
    \ Network ......................9\n      4.3. Network Quality-of-Service Authorization\
    \ ..................10\n      4.4. Service Authorization .....................................10\n\
    \      4.5. Accounting and Billing ....................................11\n  \
    \    4.6. Negotiation of Service ....................................11\n    \
    \  4.7. Dispatch to Devices .......................................11\n   5. Key\
    \ Principles of Service Identification .......................12\n      5.1. Services\
    \ Are a By-Product of Signaling ....................12\n      5.2. Identical Signaling\
    \ Produces Identical Services ...........13\n      5.3. Do What I Say, Not What\
    \ I Mean ............................14\n      5.4. Declarative Service Identifiers\
    \ Are Redundant .............15\n      5.5. URIs Are Key for Differentiated Signaling\
    \ .................15\n   6. Perils of Declarative Service Identification ...................16\n\
    \      6.1. Fraud .....................................................16\n  \
    \    6.2. Systematic Interoperability Failures ......................17\n    \
    \  6.3. Stifling of Service Innovation ............................18\n   7. Recommendations\
    \ ................................................20\n      7.1. Use Derived Service\
    \ Identification ........................20\n      7.2. Design for SIP's Negotiative\
    \ Expressiveness ...............20\n      7.3. Presence ..................................................21\n\
    \      7.4. Intra-Domain ..............................................21\n  \
    \    7.5. Device Dispatch ...........................................21\n   8.\
    \ Security Considerations ........................................22\n   9. Acknowledgements\
    \ ...............................................22\n   10. Informative References\
    \ ........................................22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Session Initiation Protocol (SIP) [RFC3261] defines\
    \ mechanisms\n   for initiating and managing communications sessions between agents.\n\
    \   SIP allows for a broad array of session types between agents.  It can\n  \
    \ manage audio sessions, ranging from low-bitrate voice-only up to\n   multi-channel\
    \ high-fidelity music.  It can manage video sessions,\n   ranging from small,\
    \ \"talking-head\" style video chat, up to high-\n   definition multipoint video\
    \ conferencing and ranging from low-\n   bandwidth user-generated content, up\
    \ to high-definition movie and TV\n   content.  SIP endpoints can be anything\
    \ -- adaptors that convert an\n   old analog telephone to Voice over IP (VoIP),\
    \ dedicated hardphones,\n   fancy hardphones with rich displays and user entry\
    \ capabilities,\n   softphones on a PC, buddy-list and presence applications on\
    \ a PC,\n   dedicated videoconferencing peripherals, and speakerphones.\n   This\
    \ breadth of applicability is SIP's greatest asset, but it also\n   introduces\
    \ numerous challenges.  One of these is that, when an\n   endpoint generates a\
    \ SIP INVITE for a session, or receives one, that\n   session can potentially\
    \ be within the context of any number of\n   different use cases and endpoint\
    \ types.  For example, a SIP INVITE\n   with a single audio stream could represent\
    \ a Push-To-Talk session\n   between mobile devices, a VoIP session between softphones,\
    \ or audio-\n   based access to stored content on a server.\n   Each of these\
    \ different use cases represents a different service.\n   The service is the user-visible\
    \ use case that is driving the behavior\n   of the user agents and servers in\
    \ the SIP network.\n   The differing services possible with SIP have driven implementors\
    \ and\n   system designers to seek techniques for service identification.\n  \
    \ Service identification is the process of determining and/or signaling\n   the\
    \ specific use case that is driving the signaling being generated\n   by a user\
    \ agent.  At first glance, this seems harmless and easy\n   enough.  It is tempting\
    \ to define a new header, \"Service-ID\", for\n   example, and have a user agent\
    \ populate it with any number of well-\n   known tokens that define what the service\
    \ is.  It could then be\n   consumed for any number of purposes.  A token placed\
    \ into the\n   signaling for this purpose is called a service identifier.\n  \
    \ Service identification and service identifiers, when used properly,\n   can\
    \ be beneficial.  However, when done improperly, service\n   identification can\
    \ lead to fraud, systemic interoperability failures,\n   and a complete stifling\
    \ of the innovation that SIP was meant to\n   achieve.  The purpose of this document\
    \ is to describe service\n   identification in more detail and describe how these\
    \ problems arise.\n   Section 2 begins by defining a service and the service identification\n\
    \   problem.  Section 3 gives some concrete examples of services and why\n   they\
    \ can be challenging to identify.  Section 4 explores the ways in\n   which a\
    \ service identification can be utilized within a network.\n   Next, Section 5\
    \ discusses the key architectural principles of service\n   identification.  Section\
    \ 6 describes what declarative service\n   invocation is, and how it can lead\
    \ to fraud, interoperability\n   failures, and stifling of service innovation.\n\
    \   Consequently, this document concludes that declarative service\n   identification\
    \ -- the process by which a user agent inserts a moniker\n   into a message that\
    \ defines the desired service, separate from\n   explicit and well-defined protocol\
    \ mechanisms -- is harmful.\n   Instead of performing declarative service identification,\
    \ this\n   document recommends derived service identification, and gives several\n\
    \   recommendations around it in Section 7:\n   1.  The identity of a service\
    \ should always be derived from the\n       explicit signaling in the protocol\
    \ messages and other contextual\n       information, and never indicated by the\
    \ user through a separate\n       identifier placed into the message.\n   2. \
    \ The process of service identification based on signaling messages\n       must\
    \ be designed to SIP's negotiative expressiveness, and\n       therefore handle\
    \ heterogeneity and not assume a fixed set of use\n       cases.\n   3.  Presence\
    \ can help in providing URIs that can be utilized to\n       connect to specific\
    \ services, thereby creating explicit\n       indications in the signaling that\
    \ can be used to derive a service\n       identity.\n   4.  Service identities\
    \ placed into signaling messages for the\n       purposes of caching the service\
    \ identity are strictly for intra-\n       domain usage.\n   5.  Device dispatch\
    \ should be based on feature tags that map to well-\n       defined SIP extensions\
    \ and capabilities.  Service dispatch should\n       not be based on abstract\
    \ service identifiers.\n"
- title: 2.  Services and Service Identification
  contents:
  - "2.  Services and Service Identification\n   The problem of identifying services\
    \ within SIP is not a new one.  The\n   problem has been considered extensively\
    \ in the context of presence.\n   In particular, the presence data model for SIP\
    \ [RFC4479] defines the\n   concept of a service as one of the core notions that\
    \ presence\n   describes.  Services are described in Section 3.3 of RFC 4479.\n\
    \   Essentially, the service is the user-visible use case that is driving\n  \
    \ the behavior of the user agents and servers in the SIP network.\n   Being user-visible\
    \ means that there is a difference in user\n   experience between two services\
    \ that are different.  That user\n   experience can be part of the call, or outside\
    \ of the call.  Within a\n   call, the user experience can be based on different\
    \ media types (an\n   audio call vs. a video chat), different content within a\
    \ particular\n   media type (stored content, such as a movie or TV session), different\n\
    \   devices (a wireless device for \"telephony\" vs. a PC application for\n  \
    \ \"voice chat\"), different user interfaces (a buddy-list view of voice\n   on\
    \ a PC application vs. a software emulation of a hardphone),\n   different communities\
    \ that can be accessed (voice chat with other\n   users that have the same voice\
    \ chat client vs. voice communications\n   with any endpoint on the Public Switched\
    \ Telephone Network (PSTN)),\n   or different applications that are invoked by\
    \ the user (manually\n   selecting a Push-To-Talk application from a wireless\
    \ phone vs. a\n   telephony application).  Outside of a call, the difference in\
    \ user\n   experience can be a billing one (cheaper for one service than\n   another),\
    \ a notification feature for one and not another (for\n   example, an IM that\
    \ gets sent whenever a user makes a call), and\n   so on.\n   In some cases, there\
    \ is very little difference in the underlying\n   technology that will support\
    \ two different services, and in other\n   cases, there are big differences. \
    \ However, for the purposes of this\n   discussion, the key definition is that\
    \ two services are distinct when\n   there is a perceived difference by the user\
    \ in the two services.\n   This leads naturally to the desire to perform service\
    \ identification.\n   Service identification is defined as the process of:\n \
    \  1.  determining the underlying service that is driving a particular\n     \
    \  signaling exchange,\n   2.  associating that service with a service identifier,\
    \ and\n   3.  attaching that moniker to a signaling message (typically a SIP\n\
    \       INVITE).\n   Once service identification is performed, the service identifier\
    \ can\n   then be used for various purposes within the network.  Service\n   identification\
    \ can be done in the endpoints, in which case the UA\n   would insert the moniker\
    \ directly into the signaling message based on\n   its awareness of the service.\
    \  Or, it can be done within a server in\n   the network (such as a proxy), based\
    \ on inspection of the SIP\n   message, or based on hints placed into the message\
    \ by the user.\n   When service identification is performed entirely by inspecting\
    \ the\n   signaling, this is called derived service identification.  When it is\n\
    \   done based on knowledge possessed only by the invoking user agent, it\n  \
    \ is called declarative service identification.  Declarative service\n   identification\
    \ can only be done in user agents, by definition.\n"
- title: 3.  Example Services
  contents:
  - "3.  Example Services\n   It is very useful to consider several example services,\
    \ especially\n   ones that appear difficult to differentiate from each other.\
    \  In\n   cases where it is hard to differentiate, service identification --\n\
    \   and in particular, declarative service identification -- appears\n   highly\
    \ attractive (and indeed, required).\n"
- title: 3.1.  IPTV vs. Multimedia
  contents:
  - "3.1.  IPTV vs. Multimedia\n   IP Television (IPTV) is the usage of IP networks\
    \ to access\n   traditional television content, such as movies and shows.  SIP\
    \ can be\n   utilized to establish a session to a media server in a network, which\n\
    \   then serves up multimedia content and streams it as an audio and\n   video\
    \ stream towards the client.  Whether SIP is ideal for IPTV is,\n   in itself,\
    \ a good question.  However, such a discussion is outside\n   the scope of this\
    \ document.\n   Consider multimedia conferencing.  The user accesses a voice and\n\
    \   video conference at a conference server.  The user might join in\n   listen-only\
    \ mode, in which case the user receives audio and video\n   streams, but does\
    \ not send.\n   These two services -- IPTV and listen-only multimedia conferencing\
    \ --\n   clearly appear as different services.  They have different user\n   experiences\
    \ and applications.  A user is unlikely to ever be confused\n   about whether\
    \ a session is IPTV or listen-only multimedia\n   conferencing.  Indeed, they\
    \ are likely to have different software\n   applications or endpoints for the\
    \ two services.\n   However, these two services look remarkably alike based on\
    \ the\n   signaling.  Both utilize audio and video.  Both could utilize the\n\
    \   same codecs.  Both are unidirectional streams (from a server in the\n   network\
    \ to the client).  Thus, it would appear on the surface that\n   there is no way\
    \ to differentiate them, based on inspection of the\n   signaling alone.\n"
- title: 3.2.  Gaming vs. Voice Chat
  contents:
  - "3.2.  Gaming vs. Voice Chat\n   Consider an interactive game, played between\
    \ two users from their\n   mobile devices.  The game involves the users sending\
    \ each other game\n   moves, using a messaging channel, in addition to voice.\
    \  In another\n   service, users have a voice and IM chat conversation using a\
    \ buddy-\n   list application on their PC.\n   In both services, there are two\
    \ media streams -- audio and messaging.\n   The audio uses the same codecs.  Both\
    \ use the Message Session Relay\n   Protocol (MSRP) [RFC4975].  In both cases,\
    \ the caller would send an\n   INVITE to the Address of Record (AOR) of the target\
    \ user.  However,\n   these represent fairly different services, in terms of user\n\
    \   experience.\n"
- title: '3.3.  Gaming vs. Voice Chat #2'
  contents:
  - "3.3.  Gaming vs. Voice Chat #2\n   Consider a variation on the example in Section\
    \ 3.2.  In this\n   variation, two users are playing an interactive game between\
    \ their\n   phones.  However, the game itself is set up and controlled using a\n\
    \   proprietary mechanism -- not using SIP at all.  However, the client\n   application\
    \ allows the user to chat with their opponent.  The chat\n   session is a simple\
    \ voice session set up between the players.\n   Compare this with a basic telephone\
    \ call between the two users.  Both\n   involve a single audio session.  Both\
    \ use the same codecs.  They\n   appear to be identical.  However, different user\
    \ experiences are\n   needed.  For example, we desire traditional telephony features\
    \ (such\n   as call forwarding and call screening) to be applied in the telephone\n\
    \   service, but not in the gaming chat service.\n"
- title: 3.4.  Configuration vs. Pager Messaging
  contents:
  - "3.4.  Configuration vs. Pager Messaging\n   The SIP MESSAGE method [RFC3428]\
    \ provides a way to send one-shot\n   messages to a particular AOR.  This specification\
    \ is primarily aimed\n   at Short Message Service (SMS)-style messaging, commonly\
    \ found in\n   wireless phones.  Receipt of a MESSAGE request would cause the\n\
    \   messaging application on a phone to launch, allowing the user to\n   browse\
    \ the message history and respond.\n   However, a MESSAGE request is sometimes\
    \ used for the delivery of\n   content to a device for other purposes.  For example,\
    \ some providers\n   use it to deliver configuration updates, such as new phone\
    \ settings\n   or parameters, or to indicate that a new version of firmware is\n\
    \   available.  Though not designed for this purpose, the MESSAGE method\n   gets\
    \ used since, in existing wireless networks, SMS is used for this\n   purpose,\
    \ and the MESSAGE request is the SIP equivalent of SMS.\n   Consequently, the\
    \ MESSAGE request sent to a phone can be for two\n   different services.  One\
    \ would require invocation of a messaging app,\n   whereas the other would be\
    \ consumed by the software in the phone,\n   without any user interaction at all.\n"
- title: 4.  Using Service Identification
  contents:
  - "4.  Using Service Identification\n   It is important to understand what the service\
    \ identity would be\n   utilized for, if known.  This section discusses the primary\
    \ uses.\n   These are application invocation in user agents and the network,\n\
    \   Quality of Service authorization, service authorization, accounting\n   and\
    \ billing, service negotiation, and device dispatch.\n"
- title: 4.1.  Application Invocation in the User Agent
  contents:
  - "4.1.  Application Invocation in the User Agent\n   In some of the examples above,\
    \ there were multiple software\n   applications executing on the host.  One common\
    \ way of achieving this\n   is to utilize a common SIP user agent implementation\
    \ that listens for\n   requests on a single port.  When an incoming INVITE or\
    \ MESSAGE\n   arrives, it must be delivered to the appropriate application\n \
    \  software.  When each service is bound to a distinct software\n   application,\
    \ it would seem that the service identity is needed to\n   dispatch the message\
    \ to the appropriate piece of software.  This is\n   shown in Figure 1.\n    \
    \                +---------------------------------+\n                    |  \
    \                               |\n                    | +-------------+ +-------------+\
    \ |\n                    | |     UI      | |     UI      | |\n               \
    \     | +-------------+ +-------------+ |\n                    | +-------------+\
    \ +-------------+ |\n                    | |             | |             | |\n\
    \                    | |  Service 1  | |  Service 2  | |\n                   \
    \ | |             | |             | |\n                    | +-------------+ +-------------+\
    \ |\n                    | +-----------------------------+ |\n               \
    \     | |                             | |\n                    | |           \
    \  SIP             | |\n                    | |            Layer            |\
    \ |\n                    | |                             | |\n               \
    \     | +-----------------------------+ |\n                    |             \
    \                    |\n                    +---------------------------------+\n\
    \                             Physical Device\n                              \
    \   Figure 1\n   The role of the SIP layer is to parse incoming messages, handle\
    \ the\n   SIP state machinery for transactions and dialogs, and then dispatch\n\
    \   requests to the appropriate service.  This software architecture is\n   analogous\
    \ to the way web servers frequently work.  An HTTP server\n   listens on port\
    \ 80 for requests, and based on the HTTP Request-URI,\n   dispatches the request\
    \ to a number of disparate applications.  The\n   same is happening here.  For\
    \ the example services in Section 3.2, an\n   incoming INVITE for the gaming service\
    \ would be delivered to the\n   gaming application software.  An incoming INVITE\
    \ for the voice chat\n   service would be delivered to the voice chat application\
    \ software.\n   The example in Section 3.3 is similar.  For the examples in\n\
    \   Section 3.4, a MESSAGE request for user-to-user messaging would be\n   delivered\
    \ to the messaging or SMS app, and a MESSAGE request\n   containing configuration\
    \ data would be delivered to a configuration\n   update application.\n   Unlike\
    \ the web, however, in all three use cases, the user initiating\n   communications\
    \ has (or appears to have -- more below) only a single\n   identifier for the\
    \ recipient -- their AOR.  Consequently, the SIP\n   Request-URI cannot be used\
    \ for dispatching, as it is identical in all\n   three cases.\n"
- title: 4.2.  Application Invocation in the Network
  contents:
  - "4.2.  Application Invocation in the Network\n   Another usage of a service identifier\
    \ would be to cause servers in\n   the SIP network to provide additional processing,\
    \ based on the\n   service.  For example, an INVITE issued by a user agent for\
    \ IPTV\n   would pass through a server that does some kind of content rights\n\
    \   management, authorizing whether the user is allowed to access that\n   content.\
    \  On the other hand, an INVITE issued by a user for\n   multimedia conferencing\
    \ would pass through a server providing\n   \"traditional\" telephony features,\
    \ such as outbound call screening and\n   call recording.  It would make no sense\
    \ for the INVITE associated\n   with IPTV to have outbound call screening and\
    \ call recording applied,\n   and it would make no sense for the multimedia conferencing\
    \ INVITE to\n   be processed by the content rights management server.  Indeed,\
    \ in\n   these cases, it's not just an efficiency issue (invoking servers when\n\
    \   not needed), but rather, truly incorrect behavior can occur.  For\n   example,\
    \ if an outbound call screening application is set to block\n   outbound calls\
    \ to everything except for the phone numbers of friends\n   and family, an IPTV\
    \ request that gets processed by such a server\n   would be blocked (as it's not\
    \ targeted to the AOR of a friend or\n   family member).  This would block a user's\
    \ attempt to access IPTV\n   services, when that was not the goal at all.\n  \
    \ Similarly, a MESSAGE request as described in Section 3.4 might need\n   to pass\
    \ through a message server for filtering when it is associated\n   with chat,\
    \ but not when it is associated with a configuration update.\n   Consider a filter\
    \ that gets applied to MESSAGE requests, and that\n   filter runs in a server\
    \ in the network.  The filter operation\n   prevents user Joe from sending messages\
    \ to user Bob that contain the\n   words \"stock\" or \"purchase\", due to some\
    \ regulations that disallow\n   Joe and Bob from discussing stock trading.  However,\
    \ a MESSAGE for\n   configuration purposes might contain an XML document that\
    \ uses the\n   token \"stock\" as some kind of attribute.  This configuration\
    \ update\n   would be discarded by the filtering server, when it should not have\n\
    \   been.\n"
- title: 4.3.  Network Quality-of-Service Authorization
  contents:
  - "4.3.  Network Quality-of-Service Authorization\n   The IP network can provide\
    \ differing levels of Quality of Service\n   (QoS) to IP packets.  This service\
    \ can include guaranteed throughput,\n   latency, or loss characteristics.  Typically,\
    \ the user agent will\n   make some kind of QoS request, either using explicit\
    \ signaling\n   protocols (such as the Resource ReSerVation Protocol (RSVP)\n\
    \   [RFC2205]) or through marking of a Diffserv value in packets.  The\n   network\
    \ will need to make a policy decision based on whether or not\n   these QoS treatments\
    \ are authorized.  One common authorization policy\n   is to check if the user\
    \ has invoked a service using SIP that they are\n   authorized to invoke, and\
    \ that this service requires the level of QoS\n   treatment the user has requested.\n\
    \   For example, consider IPTV and multimedia conferencing as described\n   in\
    \ Section 3.1.  IPTV is a non-real-time service.  Consequently,\n   media traffic\
    \ for IPTV would be authorized for bandwidth guarantees,\n   but not for latency\
    \ or loss guarantees.  On the other hand,\n   multimedia conferencing is in real\
    \ time.  Its traffic would require\n   bandwidth, loss, and latency guarantees\
    \ from the network.\n   Consequently, if a user should make an RSVP reservation\
    \ for a media\n   stream, and ask for latency guarantees for that stream, the\
    \ network\n   would choose to be able to authorize it if the service was multimedia\n\
    \   conferencing, but not if it was IPTV.  This would require the server\n   performing\
    \ the QoS authorization to know the service associated with\n   the INVITE that\
    \ set up the session.\n"
- title: 4.4.  Service Authorization
  contents:
  - "4.4.  Service Authorization\n   Frequently, a network administrator will want\
    \ to authorize whether a\n   user is allowed to invoke a particular service. \
    \ Not all users will\n   be authorized to use all services that are provided.\
    \  For example, a\n   user may not be authorized to access IPTV services, whereas\
    \ they are\n   authorized to utilize multimedia processing.  A user might not\
    \ be\n   able to utilize a multiplayer gaming service, whereas they are\n   authorized\
    \ to utilize voice chat services.\n   Consequently, when an INVITE arrives at\
    \ a server in the network, the\n   server will need to determine what the requested\
    \ service is, so that\n   the server can make an authorization decision.\n"
- title: 4.5.  Accounting and Billing
  contents:
  - "4.5.  Accounting and Billing\n   Service authorization and accounting/billing\
    \ go hand in hand.  One of\n   the primary reasons for authorizing that a user\
    \ can utilize a service\n   is that they are being billed differently based on\
    \ the type of\n   service.  Consequently, one of the goals of a service identity\
    \ is to\n   be able to include it in accounting records, so that the appropriate\n\
    \   billing model can be applied.\n   For example, in the case of IPTV, a service\
    \ provider can bill based\n   on the content (US $5 per movie, perhaps), whereas\
    \ for multimedia\n   conferencing, they can bill by the minute.  This requires\
    \ the\n   accounting streams to indicate which service was invoked for the\n \
    \  particular session.\n"
- title: 4.6.  Negotiation of Service
  contents:
  - "4.6.  Negotiation of Service\n   In some cases, when the caller initiates a session,\
    \ they don't\n   actually know which service will be utilized.  Rather, they might\n\
    \   choose to offer up all of the services they have available to the\n   called\
    \ party, and then let the called party decide, or let the system\n   make a decision\
    \ based on overlapping service capabilities.\n   As an example, a user can do\
    \ both the game and the voice chat service\n   described in Section 3.2.  The\
    \ user initiates a session to a target\n   AOR, but the devices used by the target\
    \ can only support voice chat.\n   The called device returns, in its call acceptance,\
    \ an indication that\n   only voice chat can be used.  Consequently, voice chat\
    \ gets utilized\n   for the session.\n"
- title: 4.7.  Dispatch to Devices
  contents:
  - "4.7.  Dispatch to Devices\n   When a user has multiple devices, each with varying\
    \ capabilities in\n   terms of service, it is useful to dispatch an incoming request\
    \ to the\n   right device based on whether the device can support the service\
    \ that\n   has been requested.\n   For example, if a user initiates a gaming session\
    \ with voice chat,\n   and the target user has two devices -- one that can support\
    \ the\n   gaming service, and another that cannot -- the INVITE should be\n  \
    \ dispatched to the device that supports the gaming session.\n"
- title: 5.  Key Principles of Service Identification
  contents:
  - "5.  Key Principles of Service Identification\n   In this section, we describe\
    \ several key principles of service\n   identification:\n   1.  Services are a\
    \ by-product of signaling\n   2.  Identical signaling produces identical services\n\
    \   3.  Declarative service identification is an example of \"Do What I\n    \
    \   Mean\" (DWIM)\n   4.  Declarative service identifiers are redundant\n   5.\
    \  URIs are a key mechanism for producing differentiated signaling\n"
- title: 5.1.  Services Are a By-Product of Signaling
  contents:
  - "5.1.  Services Are a By-Product of Signaling\n   Declarative service identification\
    \ -- the addition of a service\n   identifier by clients in order to inform other\
    \ entities of what the\n   service is -- is a very compelling solution to solving\
    \ the use cases\n   described above.  It provides a clear way for each of the\
    \ use cases\n   to be differentiated.  On the other hand, derived service\n  \
    \ identification appears \"hard\", since the signaling appears to be the\n   same\
    \ for these different services.\n   Declarative service identification misses\
    \ a key point, which cannot\n   be stressed enough, and which represents the core\
    \ architectural\n   principle to be understood here:\n      A service is the byproduct\
    \ of the signaling and the context around\n      it (the user profile, time of\
    \ day, and so on) -- the effects of\n      the signaling message once it is launched\
    \ into the network.  The\n      service identity is therefore always derivable\
    \ from the signaling\n      and its context without additional identifiers.  In\
    \ other words,\n      derived service identification is always possible when signaling\n\
    \      is being properly handled.\n   When a user sends an INVITE request to the\
    \ network and targets that\n   request at an IPTV server, and includes the Session\
    \ Description\n   Protocol (SDP) for audio and video streaming, the *result* of\
    \ sending\n   such an INVITE is that an IPTV session occurs.  The entire purpose\
    \ of\n   the INVITE is to establish such a session, and therefore, invoke the\n\
    \   service.  Thus, a service is not something that is different from the\n  \
    \ rest of the signaling message.  A service is what the user gets after\n   the\
    \ network and other user agents have processed a signaling message.\n   It may\
    \ seem that delayed offers (SIP INVITE requests that lack SDP)\n   make it impossible\
    \ to perform derived service identification.  After\n   all, in some of the cases\
    \ above, the differentiation was done using\n   the SDP in the request.  What\
    \ if it's not there?  The answer is\n   simple -- if it's not there, and the SDP\
    \ is being offered by the\n   called party, you cannot in fact know the service\
    \ at the time of the\n   INVITE.  That's the whole point of delayed offer -- to\
    \ give the\n   called party the chance to offer up what it wants for the session.\n\
    \   In cases where service identification is needed at request time,\n   delayed\
    \ offer cannot be used.\n"
- title: 5.2.  Identical Signaling Produces Identical Services
  contents:
  - "5.2.  Identical Signaling Produces Identical Services\n   This principle is a\
    \ natural conclusion of the previous assertion.  If\n   a service is the byproduct\
    \ of signaling, how can a user have\n   different experiences and different services\
    \ when the signaling\n   message is the same?  They cannot.\n   But how can that\
    \ be?  From the examples in Section 3, it would seem\n   that there are services\
    \ that are different, but have identical\n   signaling.  If we hold true to the\
    \ assertion, there is in fact only\n   one logical conclusion:\n      If two services\
    \ are different, but their signaling appears to be\n      the same, it is because\
    \ one or more of the following is true:\n      1.  there is in fact something\
    \ different that has been overlooked\n      2.  something has been implied from\
    \ the signaling, when in fact it\n          should have been signaled explicitly\n\
    \      3.  the signaling mechanism should be changed so that there is, in\n  \
    \        fact, something that is different\n   To illustrate this, let us take\
    \ each of the example services in\n   Section 3 and investigate whether there\
    \ is, or should be, something\n   different in the signaling in each case.\n \
    \  IPTV vs. Multimedia Conferencing:  The two services described in\n      Section\
    \ 3.1 appear to have identical signaling.  They both involve\n      audio and\
    \ video streams, both of which are unidirectional.  Both\n      might utilize\
    \ the same codecs.  However, there is another\n      important difference in the\
    \ signaling -- the target URI.  In the\n      case of IPTV, the request is targeted\
    \ at a media server or to a\n      particular piece of content to be viewed. \
    \ In the case of\n      multimedia conferencing, the target is a conference server.\
    \  The\n      administrator of the domain can therefore examine the Request-URI\n\
    \      and figure out whether it is targeted for a conference server or a\n  \
    \    content server, and use that to derive the service associated with\n    \
    \  the request.\n   Gaming vs. Voice Chat:  Though both sessions involve MSRP\
    \ and voice,\n      and both are targeted to the same AOR of the called user,\
    \ there is\n      a difference.  The MSRP messages for the gaming session carry\n\
    \      content that is game specific, whereas the MSRP messages for the\n    \
    \  voice chat are just regular text, meant for rendering to a user.\n      Thus,\
    \ the MSRP session in the SDP will indicate the specific\n      content type that\
    \ MSRP is carrying, and this type will differ in\n      both cases.  Even if the\
    \ game moves look like text, since they are\n      being consumed by an automata,\
    \ there is an underlying schema that\n      dictates their content, and therefore,\
    \ this schema represents the\n      actual content type that should be signaled.\n\
    \   Gaming vs. Voice Chat #2:  In this case, both sessions involve only\n    \
    \  voice, and both are targeted at the same AOR.  Indeed, there truly\n      is\
    \ nothing different -- if indeed the signaling works this way.\n      However,\
    \ there is an alternative mechanism for performing the\n      signaling.  For\
    \ the gaming session, the proprietary protocol can\n      be used to exchange\
    \ a URI that can be used to identify the voice\n      chat function on the phone\
    \ that is associated with the game (for\n      example, a Globally Routable User\
    \ Agent URI (GRUU) can be used\n      [RFC5627]).  Indeed, the gaming chat is\
    \ not targeting the USER --\n      it's targeting the gaming instance on the phone.\
    \  Thus, if a\n      special GRUU is used for the gaming chat, this makes the\
    \ signaling\n      different between these two services.\n   Configuration vs.\
    \ Pager Messaging:  Just as in the case of gaming vs.\n      voice chat, the content\
    \ type of the messages differentiates the\n      service that occurs as a consequence\
    \ of the messages.\n"
- title: 5.3.  Do What I Say, Not What I Mean
  contents:
  - "5.3.  Do What I Say, Not What I Mean\n   \"Do What I Mean\", abbreviated as DWIM,\
    \ is a concept in computer\n   science.  It is sometimes used to describe a function\
    \ that tries to\n   intelligently guess at what the user intended.  It is in contrast\
    \ to\n   \"Do What I Say\", or DWIS, which describes a function that behaves\n\
    \   concretely based on the inputs provided.  Systems built on the DWIM\n   concept\
    \ can have unexpected behaviors, because they are driven by\n   unstated rules.\n\
    \   Declarative service identification is an example of DWIM.  The\n   service\
    \ identifier has no well-defined impact on the state machinery\n   or protocols\
    \ in the system; it has various side effects based on an\n   assumption of what\
    \ is meant by the service identifier.  Derived\n   service identification, on\
    \ the other hand, is an expression of the\n   principle of DWIS -- the behavior\
    \ of the system is based entirely on\n   the specifics of the protocol and are\
    \ well defined by the protocol\n   specification.  The service identifier is just\
    \ a shorthand for\n   summarizing things that are well defined by signaling.\n\
    \   As a litmus test to differentiate the two cases, consider the\n   following\
    \ question.  If a request contained a service identifier, and\n   that request\
    \ were processed by a domain that didn't understand the\n   concept of service\
    \ identifiers at all, would the request be rejected\n   if that service were not\
    \ supported, or would it complete but do the\n   wrong thing?  If it is the latter\
    \ case, it's DWIM.  If it's the\n   former, it's DWIS.\n"
- title: 5.4.  Declarative Service Identifiers Are Redundant
  contents:
  - "5.4.  Declarative Service Identifiers Are Redundant\n   Because a declarative\
    \ service identifier is, by definition, inside of\n   the signaling message, and\
    \ because the signaling itself completely\n   defines the behavior of the service,\
    \ another natural conclusion is\n   that a declarative service identifier is redundant\
    \ with the signaling\n   itself.  It says nothing that could not or should not\
    \ otherwise be\n   derived from examination of the signaling.\n"
- title: 5.5.  URIs Are Key for Differentiated Signaling
  contents:
  - "5.5.  URIs Are Key for Differentiated Signaling\n   In the IPTV example and in\
    \ the second gaming example, it was\n   ultimately the Request-URI that was (or\
    \ should be) different between\n   the two services.  This is important.  In many\
    \ cases where services\n   appear the same, it is because the resource that is\
    \ being targeted is\n   not, in fact, the user.  Rather, it is a resource that\
    \ is linked with\n   the user.  This resource might be an instance of a software\n\
    \   application on the particular device of a user, or a resource in the\n   network\
    \ that acts on behalf of the user.\n   The Request-URI is an infinitely large\
    \ namespace for identifying\n   these resources.  It is an ideal mechanism for\
    \ providing\n   differentiation when there would otherwise be none.\n   Returning\
    \ again to the example in Section 3.3, we can see that it\n   does make more sense\
    \ to target the gaming chat session at a software\n   instance on the user's phone,\
    \ rather than at the user themselves.\n   The gaming chat session should really\
    \ only go to the phone on which\n   the user is playing the game.  The software\
    \ instance does indeed live\n   only on that phone, whereas the user themselves\
    \ can be contacted in\n   many ways.  We don't want telephony features invoked\
    \ for the gaming\n   chat session, because those features only make sense when\
    \ someone is\n   trying to communicate with the USER.  When someone is trying\
    \ to\n   communicate with a software instance that acts on behalf of the user,\n\
    \   a different set of rules apply, since the target of the request is\n   completely\
    \ different.\n"
- title: 6.  Perils of Declarative Service Identification
  contents:
  - "6.  Perils of Declarative Service Identification\n   Based on these principles,\
    \ several perils of declarative service\n   identification can be described. \
    \ They are:\n   1.  Declarative service identification can be used for fraud\n\
    \   2.  Declarative service identification can hurt interoperability\n   3.  Declarative\
    \ service identification can stifle service innovation\n"
- title: 6.1.  Fraud
  contents:
  - "6.1.  Fraud\n   Declarative service identification can lead to fraud.  If a provider\n\
    \   uses the service identifier for billing and accounting purposes, or\n   for\
    \ authorization purposes, it opens an avenue for attack.  The user\n   can construct\
    \ the signaling message so that its actual effect (which\n   is the service the\
    \ user will receive), is what the user desires, but\n   the user places a service\
    \ identifier into the request (which is what\n   is used for billing and authorization)\
    \ that identifies a cheaper\n   service, or one that the user is not authorized\
    \ to receive.  In such\n   a case, the user will receive service, and not be billed\
    \ properly for\n   it.\n   If, however, the domain administrator derived the service\
    \ identifier\n   from the signaling itself (derived service identification), the\
    \ user\n   cannot lie.  If they did lie, they wouldn't get the desired service.\n\
    \   Consider the example of IPTV vs. multimedia conferencing.  If\n   multimedia\
    \ conferencing is cheaper, the user could send an INVITE for\n   an IPTV session,\
    \ but include a service identifier that indicates\n   multimedia conferencing.\
    \  The user gets the service associated with\n   IPTV, but at the cost of multimedia\
    \ conferencing.\n   This same principle shows up in other places -- for example,\
    \ in the\n   identification of an emergency services call [ECRIT-FRAMEWORK]. \
    \ It\n   is desirable to give emergency services calls special treatment, such\n\
    \   as being free and authorized even when the user cannot otherwise make\n  \
    \ calls, and to give them priority.  If emergency calls were indicated\n   through\
    \ something other than the target of the call being an\n   emergency services\
    \ URN [RFC5031], it would open an avenue for fraud.\n   The user could place any\
    \ desired URI in the request-URI, and indicate\n   separately, through a declarative\
    \ identifier, that the call is an\n   emergency services call.  This would then\
    \ get special treatment but\n   of course would get routed to the target URI.\
    \  The only way to\n   prevent this fraud is to consider an emergency call as\
    \ any call whose\n   target is an emergency services URN.  Thus, the service\n\
    \   identification here is based on the target of the request.  When the\n   target\
    \ is an emergency services URN, the request can get special\n   treatment.  The\
    \ user cannot lie, since there is no way to separately\n   indicate that this\
    \ is an emergency call, besides targeting it to an\n   emergency URN.\n"
- title: 6.2.  Systematic Interoperability Failures
  contents:
  - "6.2.  Systematic Interoperability Failures\n   How can declarative service identification\
    \ cause loss of\n   interoperability?  When an identifier is used to drive functionality\n\
    \   -- such as dispatch on the phones, in the network, or QoS\n   authorization\
    \ -- it means that the wrong thing can happen when this\n   field is not set properly.\
    \  Consider a user in domain 1, calling a\n   user in domain 2.  Domain 1 provides\
    \ the user with a service they\n   call \"voice chat\", which utilizes voice and\
    \ IM for real-time\n   conversation, driven off of a buddy-list application on\
    \ a PC.\n   Domain 2 provides their users with a service they call \"text\n  \
    \ telephony\", which is a voice service on a wireless device that also\n   allows\
    \ the user to send text messages.  Consider the case where\n   domain 1 and domain\
    \ 2 both have their user agents insert a service\n   identifier into the request,\
    \ and then use that to perform QoS\n   authorization, accounting, and invocation\
    \ of applications in the\n   network and in the device.  The user in domain 1\
    \ calls the user in\n   domain 2, and inserts the identifier \"Voice Chat\" into\
    \ the INVITE.\n   When this arrives at the server in domain 2, the service identifier\n\
    \   is unknown.  Consequently, the request does not get the proper QoS\n   treatment,\
    \ even if the call itself will succeed.\n   If, on the other hand, derived service\
    \ identification were used, the\n   service identifier could be removed by domain\
    \ 2, and then recomputed\n   based on the signaling to match its own notion of\
    \ services.  In this\n   case, domain 2 could derive the \"text telephony\" identifier,\
    \ and the\n   request completes successfully.\n   Declarative service identification,\
    \ used between domains, causes\n   interoperability failures unless all interconnected\
    \ domains agree on\n   exactly the same set of services and how to name them.\
    \  Of course,\n   lack of service identifiers does not guarantee service\n   interoperability.\
    \  However, SIP was built with rich tools for\n   negotiation of capabilities\
    \ at a finely granular level.  One user\n   agent can make a call using audio\
    \ and video, but if the receiving UA\n   only supports audio, SIP allows both\
    \ sides to negotiate down to the\n   lowest common denominator.  Thus, communication\
    \ is still provided.\n   As another example, if one agent initiates a Push-To-Talk\
    \ session\n   (which is audio with a companion floor control mechanism), and the\n\
    \   other side only did regular audio, SIP would be able to negotiate\n   back\
    \ down to a regular voice call.  As another example, if a calling\n   user agent\
    \ is running a high-definition video conferencing endpoint,\n   and the called\
    \ user agent supports just a regular video endpoint, the\n   codecs themselves\
    \ can negotiate downward to a lower rate, picture\n   size, and so on.  Thus,\
    \ interoperability is achieved.  Interestingly,\n   the final \"service\" may\
    \ no longer be well characterized by the\n   service identifier that would have\
    \ been placed in the original\n   INVITE.  For example, in this case, if the original\
    \ INVITE from the\n   caller had contained the service identifier \"hi-fi video\"\
    , but the\n   video gets negotiated down to a lower rate and picture size, the\n\
    \   service identifier is no longer really appropriate.  That is why\n   services\
    \ need to be derived by signaling -- because the signaling\n   itself provides\
    \ negotiation and interoperability between different\n   domains.\n   This illustrates\
    \ another key aspect of the interoperability problem.\n   Declarative service\
    \ identification will result in inconsistencies\n   between its service identifiers\
    \ and the results of any SIP\n   negotiation that might otherwise be applied in\
    \ the session.\n   When a service identifier becomes something that both proxies\
    \ and the\n   user agent need to understand in order to properly treat a request\n\
    \   (which is the case for declarative service identification), it\n   becomes\
    \ equivalent to including a token in the Proxy-Require and\n   Require header\
    \ fields of every single SIP request.  The very reason\n   that [RFC4485] frowns\
    \ upon usage of Require and certainly Proxy-\n   Require is the huge impact on\
    \ interoperability it causes.  It is for\n   this same reason that declarative\
    \ service identification needs to be\n   avoided.\n"
- title: 6.3.  Stifling of Service Innovation
  contents:
  - "6.3.  Stifling of Service Innovation\n   The probability that any two service\
    \ providers end up with the same\n   set of services, and give those services\
    \ the same names, becomes\n   smaller and smaller as the number of providers grow.\
    \  Indeed, it\n   would almost certainly require a centralized authority to identify\n\
    \   what the services are, how they work, and what they are named.  This,\n  \
    \ in turn, leads to a requirement for complete homogeneity in order to\n   facilitate\
    \ interconnection.  Two providers cannot usefully\n   interconnect unless they\
    \ agree on the set of services they are\n   offering to their customers and each\
    \ do the same thing.  This is\n   because each provider has become dependent on\
    \ inclusion of the proper\n   service identifier in the request, in order for\
    \ the overall treatment\n   of the request to proceed correctly.  This is, in\
    \ a very real sense,\n   anathema to the entire notion of SIP, which is built\
    \ on the idea that\n   heterogeneous domains can interconnect and still get\n\
    \   interoperability.\n   Declarative service identification leads to a requirement\
    \ for\n   homogeneity in service definitions across providers that\n   interconnect,\
    \ ruining the very service heterogeneity that SIP was\n   meant to bring.\n  \
    \ Indeed, Metcalfe's Law says that the value of a network grows with\n   the square\
    \ of the number of participants.  As a consequence of this,\n   once a bunch of\
    \ large domains did get together, agree on a set of\n   services, and then agree\
    \ on a set of well-known identifiers for those\n   services, it would force other\
    \ providers to also deploy the same\n   services, in order to obtain the value\
    \ that interconnection brings.\n   This, in turn, will stifle innovation, and\
    \ quickly force the set of\n   services in SIP to become fixed and never expand\
    \ beyond the ones\n   initially agreed upon.  This, too, is anathema to the very\
    \ framework\n   on which SIP is built, and defeats much of the purpose of why\n\
    \   providers have chosen to deploy SIP in their own networks.\n   Consider the\
    \ following example.  Several providers get together and\n   standardize on a\
    \ bunch of service identifiers.  One of these uses\n   audio and video (say, \"\
    multimedia conversation\").  This service is\n   successful and is widely utilized.\
    \  Endpoints look for this\n   identifier to dispatch calls to the right software\
    \ applications, and\n   the network looks for it to invoke features, perform accounting,\
    \ and\n   provide QoS.  A new provider gets the idea for a new service (say,\n\
    \   \"avatar-enhanced multimedia conversation\").  In this service, there\n  \
    \ is audio and video, but there is a third stream, which renders an\n   avatar.\
    \  A caller can press buttons on their phone, to cause the\n   avatar on the other\
    \ person's device to show emotion, make noise, and\n   so on.  This is similar\
    \ to the way emoticons are used today in IM.\n   This service is enabled by adding\
    \ a third media stream (and\n   consequently, a third m-line) to the SDP.\n  \
    \ Normally, this service would be backwards-compatible with a regular\n   audio-video\
    \ endpoint, which would just reject the third media stream.\n   However, because\
    \ a large network has been deployed that is expecting\n   to see the token, \"\
    multimedia conversation\" and its associated audio+\n   video service, it is nearly\
    \ impossible for the new provider to roll\n   out this new service.  If they did,\
    \ it would fail completely, or\n   partially fail, when their users call users\
    \ in other provider\n   domains.\n"
- title: 7.  Recommendations
  contents:
  - "7.  Recommendations\n   From these principles, several recommendations can be\
    \ made.\n"
- title: 7.1.  Use Derived Service Identification
  contents:
  - "7.1.  Use Derived Service Identification\n   Derived service identification --\
    \ where an identifier for a service\n   is obtained by inspection of the signaling\
    \ and of other contextual\n   data (such as subscriber profile) -- is reasonable,\
    \ and when done\n   properly, does not lead to the perils described above.  However,\n\
    \   declarative service identification -- where user agents indicate what\n  \
    \ the service is, separate from the rest of the signaling -- leads to\n   the\
    \ perils described above.\n   If it appears that the signaling currently defined\
    \ in standards is\n   not sufficient to identify the service, it may be due to\
    \ lack of\n   sufficient signaling to convey what is needed, or may be because\n\
    \   request URIs should be used for differentiation and they are not\n   being\
    \ used.  By applying the litmus tests described in Section 5.3,\n   network designers\
    \ can determine whether or not the system is\n   attempting to perform declarative\
    \ service identification.\n"
- title: 7.2.  Design for SIP's Negotiative Expressiveness
  contents:
  - "7.2.  Design for SIP's Negotiative Expressiveness\n   One of SIP's key strengths\
    \ is its ability to negotiate a common view\n   of a session between participants.\
    \  This means that the service that\n   is ultimately received can vary wildly,\
    \ depending on the types of\n   endpoints in the call and their capabilities.\
    \  Indeed, this fact\n   becomes even more evident when calls are set up between\
    \ domains.\n   As such, when performing derived service identification, domains\n\
    \   should be aware that sessions may arrive from different networks and\n   different\
    \ endpoints.  Consequently, the service identification\n   algorithm must be complete\
    \ -- meaning it computes the best answer for\n   any possible signaling message\
    \ that might be received and any session\n   that might be set up.\n   In a homogeneous\
    \ environment, the process of service identification\n   is easy.  The service\
    \ provider will know the set of services they are\n   providing, and based on\
    \ the specific call flows for each specific\n   service, can construct rules to\
    \ differentiate one service from\n   another.  However, when different providers\
    \ interconnect, or when\n   different endpoints are introduced, assumptions about\
    \ what services\n   are used, and how they are signaled, no longer apply.  To\
    \ provide the\n   best user experience possible, a provider doing service\n  \
    \ identification needs to perform a \"best-match\" operation, such that\n   any\
    \ legal SIP signaling -- not just the specific call flows running\n   within their\
    \ own network amongst a limited set of endpoints -- is\n   mapped to the appropriate\
    \ service.\n"
- title: 7.3.  Presence
  contents:
  - "7.3.  Presence\n   Presence can help a great deal with providing unique URIs\
    \ for\n   different services.  When a user wishes to contact another user, and\n\
    \   knows only the AOR for the target (which is usually the case), the\n   user\
    \ can fetch the presence document for the target.  That document,\n   in turn,\
    \ can contain numerous service URIs for contacting the target\n   with different\
    \ services.  Those URIs can then be used in the Request-\n   URI for differentiation.\
    \  When possible, this is the best solution to\n   the problem.\n"
- title: 7.4.  Intra-Domain
  contents:
  - "7.4.  Intra-Domain\n   Service identifiers themselves are not bad; derived service\n\
    \   identification allows each domain to cache the results of the service\n  \
    \ identification process for usage by another network element within\n   the same\
    \ domain.  However, service identifiers are fundamentally\n   useful within a\
    \ particular domain, and any such header must be\n   stripped at a network boundary.\
    \  Consequently, the process of service\n   identification and their associated\
    \ service identifiers is always an\n   intra-domain operation.\n"
- title: 7.5.  Device Dispatch
  contents:
  - "7.5.  Device Dispatch\n   Device dispatch should be done following the principles\
    \ of [RFC3841],\n   using implicit preferences based on the signaling.  For example,\n\
    \   [RFC5688] defines a new UA capability that can be used to dispatch\n   requests\
    \ based on different types of application media streams.\n   However, it is a\
    \ mistake to try and use a service identifier as a UA\n   capability.  Consider\
    \ a service called \"multimedia telephony\", which\n   adds video to the existing\
    \ PSTN experience.  A user has two devices,\n   one of which is used for multimedia\
    \ telephony and the other strictly\n   for a voice-assisted game.  It is tempting\
    \ to have the telephony\n   device include a UA capability [RFC3840] called \"\
    multimedia\n   telephony\" in its registration.  A calling multimedia telephony\n\
    \   device can then include the Accept-Contact header field [RFC3841]\n   containing\
    \ this feature tag.  The proxy serving the called party,\n   applying the basic\
    \ algorithms of [RFC3841], will correctly route the\n   call to the terminating\
    \ device.\n   However, if the calling party is not within the same domain, and\
    \ the\n   calling domain does not know about or use this feature tag, there\n\
    \   will be no Accept-Contact header field, even if the calling party was\n  \
    \ using a service that is a good match for \"multimedia telephony\".  In\n   such\
    \ a case, the call may be delivered to both devices, but it will\n   yield a poorer\
    \ user experience.  That's because device dispatch was\n   done using declarative\
    \ service identification.\n   The best way to avoid this problem is to use feature\
    \ tags that can be\n   matched to well-defined signaling features -- media types,\
    \ required\n   SIP extensions, and so on.  In particular, the golden rule is that\n\
    \   the granularity of feature tags must be equivalent to the granularity\n  \
    \ of individual features that can be signaled in SIP.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Oftentimes, the service associated with a request\
    \ is utilized for\n   purposes such as authorization, accounting, and billing.\
    \  When\n   service identification is not done properly, the possibility of\n\
    \   unauthorized service use and network fraud is introduced.  It is for\n   this\
    \ reason, discussed extensively in Section 6.1, that the usage of\n   declarative\
    \ service identifiers inserted by a UA is not recommended.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   This document is based on discussions with Paul Kyzivat\
    \ and\n   Andrew Allen, who contributed significantly to the ideas here.  Much\n\
    \   of the content in this document is a result of discussions amongst\n   participants\
    \ in the SIPPING mailing list, including Dean Willis,\n   Tom Taylor, Eric Burger,\
    \ Dale Worley, Christer Holmberg, and\n   John Elwell, amongst many others.  Thanks\
    \ to Spencer Dawkins,\n   Tolga Asveren, Mahesh Anjanappa, and Claudio Allochio\
    \ for reviews of\n   this document.\n"
- title: 10.  Informative References
  contents:
  - "10.  Informative References\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G., Johnston,\n              A., Peterson, J., Sparks, R., Handley, M., and\
    \ E.\n              Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n\
    \              June 2002.\n   [RFC4479]  Rosenberg, J., \"A Data Model for Presence\"\
    , RFC 4479,\n              July 2006.\n   [RFC4485]  Rosenberg, J. and H. Schulzrinne,\
    \ \"Guidelines for Authors\n              of Extensions to the Session Initiation\
    \ Protocol (SIP)\",\n              RFC 4485, May 2006.\n   [RFC4975]  Campbell,\
    \ B., Mahy, R., and C. Jennings, \"The Message\n              Session Relay Protocol\
    \ (MSRP)\", RFC 4975, September 2007.\n   [RFC5031]  Schulzrinne, H., \"A Uniform\
    \ Resource Name (URN) for\n              Emergency and Other Well-Known Services\"\
    , RFC 5031,\n              January 2008.\n   [ECRIT-FRAMEWORK]\n             \
    \ Rosen, B., Schulzrinne, H., Polk, J., and A. Newton,\n              \"Framework\
    \ for Emergency Calling using Internet\n              Multimedia\", Work in Progress,\
    \ July 2009.\n   [RFC5627]  Rosenberg, J., \"Obtaining and Using Globally Routable\
    \ User\n              Agent URIs (GRUUs) in the Session Initiation Protocol\n\
    \              (SIP)\", RFC 5627, October 2009.\n   [RFC5688]  Rosenberg, J.,\
    \ \"A Session Initiation Protocol (SIP) Media\n              Feature Tag for MIME\
    \ Application Subtypes\", RFC 5688,\n              January 2010.\n   [RFC3428]\
    \  Campbell, B., Rosenberg, J., Schulzrinne, H., Huitema, C.,\n              and\
    \ D. Gurle, \"Session Initiation Protocol (SIP) Extension\n              for Instant\
    \ Messaging\", RFC 3428, December 2002.\n   [RFC3841]  Rosenberg, J., Schulzrinne,\
    \ H., and P. Kyzivat, \"Caller\n              Preferences for the Session Initiation\
    \ Protocol (SIP)\",\n              RFC 3841, August 2004.\n   [RFC3840]  Rosenberg,\
    \ J., Schulzrinne, H., and P. Kyzivat,\n              \"Indicating User Agent\
    \ Capabilities in the Session\n              Initiation Protocol (SIP)\", RFC\
    \ 3840, August 2004.\n   [RFC2205]  Braden, B., Zhang, L., Berson, S., Herzog,\
    \ S., and S.\n              Jamin, \"Resource ReSerVation Protocol (RSVP) -- Version\
    \ 1\n              Functional Specification\", RFC 2205, September 1997.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Jonathan Rosenberg\n   jdrosen.net\n   Monmouth, NJ\n  \
    \ USA\n   EMail: jdrosen@jdrosen.net\n   URI:   http://www.jdrosen.net\n"
