- contents:
  - '                        DHCPv6 Failover Protocol

    '
  title: __initial_text__
- contents:
  - "Abstract\n   DHCPv6 as defined in \"Dynamic Host Configuration Protocol for IPv6\n
    \  (DHCPv6)\" (RFC 3315) does not offer server redundancy.  This document\n   defines
    a protocol implementation to provide DHCPv6 failover, a\n   mechanism for running
    two servers with the capability for either\n   server to take over clients' leases
    in case of server failure or\n   network partition.  It meets the requirements
    for DHCPv6 failover\n   detailed in \"DHCPv6 Failover Requirements\" (RFC 7031).\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8156.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n
    \  2. Requirements Language ...........................................5\n   3.
    Glossary ........................................................6\n   4. Failover
    Concepts and Mechanisms ...............................10\n      4.1. Required
    Server Configuration .............................10\n      4.2. IPv6 Address
    and Delegable Prefix Allocation ..............10\n           4.2.1. Independent
    Allocation .............................10\n                  4.2.1.1. Independent
    Allocation Algorithm ..........11\n           4.2.2. Proportional Allocation ............................11\n
    \                 4.2.2.1. Reallocating Leases .......................13\n      4.3.
    Lazy Updates ..............................................14\n      4.4. Maximum
    Client Lead Time (MCLT) ...........................14\n           4.4.1. MCLT
    Example .......................................16\n   5. Message and Option Definitions
    .................................19\n      5.1. Message Framing for TCP ...................................19\n
    \     5.2. Failover Message Format ...................................19\n      5.3.
    Messages ..................................................20\n           5.3.1.
    BNDUPD .............................................20\n           5.3.2. BNDREPLY
    ...........................................20\n           5.3.3. POOLREQ ............................................20\n
    \          5.3.4. POOLRESP ...........................................21\n           5.3.5.
    UPDREQ .............................................21\n           5.3.6. UPDREQALL
    ..........................................21\n           5.3.7. UPDDONE ............................................21\n
    \          5.3.8. CONNECT ............................................21\n           5.3.9.
    CONNECTREPLY .......................................22\n           5.3.10. DISCONNECT
    ........................................22\n           5.3.11. STATE .............................................22\n
    \          5.3.12. CONTACT ...........................................22\n      5.4.
    Transaction-id ............................................22\n      5.5. Options
    ...................................................23\n           5.5.1. OPTION_F_BINDING_STATUS
    ............................23\n           5.5.2. OPTION_F_CONNECT_FLAGS .............................24\n
    \          5.5.3. OPTION_F_DNS_REMOVAL_INFO ..........................25\n                  5.5.3.1.
    OPTION_F_DNS_HOST_NAME ....................26\n                  5.5.3.2. OPTION_F_DNS_ZONE_NAME
    ....................26\n                  5.5.3.3. OPTION_F_DNS_FLAGS ........................27\n
    \          5.5.4. OPTION_F_EXPIRATION_TIME ...........................28\n           5.5.5.
    OPTION_F_MAX_UNACKED_BNDUPD ........................29\n           5.5.6. OPTION_F_MCLT
    ......................................29\n           5.5.7. OPTION_F_PARTNER_LIFETIME
    ..........................30\n           5.5.8. OPTION_F_PARTNER_LIFETIME_SENT
    .....................30\n           5.5.9. OPTION_F_PARTNER_DOWN_TIME .........................31\n
    \          5.5.10. OPTION_F_PARTNER_RAW_CLT_TIME .....................32\n           5.5.11.
    OPTION_F_PROTOCOL_VERSION .........................32\n           5.5.12. OPTION_F_KEEPALIVE_TIME
    ...........................33\n           5.5.13. OPTION_F_RECONFIGURE_DATA .........................34\n
    \          5.5.14. OPTION_F_RELATIONSHIP_NAME ........................35\n           5.5.15.
    OPTION_F_SERVER_FLAGS .............................36\n           5.5.16. OPTION_F_SERVER_STATE
    .............................37\n           5.5.17. OPTION_F_START_TIME_OF_STATE
    ......................38\n           5.5.18. OPTION_F_STATE_EXPIRATION_TIME ....................38\n
    \     5.6. Status Codes ..............................................39\n   6.
    Connection Management ..........................................40\n      6.1.
    Creating Connections ......................................40\n           6.1.1.
    Sending a CONNECT Message ..........................41\n           6.1.2. Receiving
    a CONNECT Message ........................42\n           6.1.3. Receiving a CONNECTREPLY
    Message ...................43\n      6.2. Endpoint Identification ...................................44\n
    \     6.3. Sending a STATE Message ...................................45\n      6.4.
    Receiving a STATE Message .................................46\n      6.5. Connection
    Maintenance Parameters .........................46\n      6.6. Unreachability
    Detection ..................................47\n   7. Binding Updates and Acks
    .......................................47\n      7.1. Time Skew .................................................47\n
    \     7.2. Information Model .........................................48\n      7.3.
    Times Required for Exchanging Binding Updates .............52\n      7.4. Sending
    Binding Updates ...................................53\n      7.5. Receiving Binding
    Updates .................................56\n           7.5.1. Monitoring Time
    Skew ...............................56\n           7.5.2. Acknowledging Reception
    ............................56\n           7.5.3. Processing Binding Updates .........................57\n
    \          7.5.4. Accept or Reject? ..................................57\n           7.5.5.
    Accepting Updates ..................................59\n      7.6. Sending Binding
    Replies ...................................61\n      7.7. Receiving Binding Acks
    ....................................63\n      7.8. BNDUPD/BNDREPLY Data Flow .................................65\n
    \  8. Endpoint States ................................................66\n      8.1.
    State Machine Operation ...................................66\n      8.2. State
    Machine Initialization ..............................69\n      8.3. STARTUP State
    .............................................70\n           8.3.1. Operation in
    STARTUP State .........................70\n           8.3.2. Transition out of
    STARTUP State ....................70\n      8.4. PARTNER-DOWN State ........................................72\n
    \          8.4.1. Operation in PARTNER-DOWN State ....................72\n           8.4.2.
    Transition out of PARTNER-DOWN State ...............73\n      8.5. RECOVER State
    .............................................74\n           8.5.1. Operation in
    RECOVER State .........................74\n           8.5.2. Transition out of
    RECOVER State ....................74\n      8.6. RECOVER-WAIT State ........................................76\n
    \          8.6.1. Operation in RECOVER-WAIT State ....................76\n           8.6.2.
    Transition out of RECOVER-WAIT State ...............76\n      8.7. RECOVER-DONE
    State ........................................77\n           8.7.1. Operation
    in RECOVER-DONE State ....................77\n           8.7.2. Transition out
    of RECOVER-DONE State ...............77\n      8.8. NORMAL State ..............................................77\n
    \          8.8.1. Operation in NORMAL State ..........................78\n           8.8.2.
    Transition out of NORMAL State .....................78\n      8.9. COMMUNICATIONS-INTERRUPTED
    State ..........................79\n           8.9.1. Operation in COMMUNICATIONS-INTERRUPTED
    State ......80\n           8.9.2. Transition out of COMMUNICATIONS-INTERRUPTED\n
    \                 State ..............................................80\n      8.10.
    POTENTIAL-CONFLICT State .................................82\n           8.10.1.
    Operation in POTENTIAL-CONFLICT State .............82\n           8.10.2. Transition
    out of POTENTIAL-CONFLICT State ........82\n      8.11. RESOLUTION-INTERRUPTED
    State .............................83\n           8.11.1. Operation in RESOLUTION-INTERRUPTED
    State .........84\n           8.11.2. Transition out of RESOLUTION-INTERRUPTED
    State ....84\n      8.12. CONFLICT-DONE State ......................................84\n
    \          8.12.1. Operation in CONFLICT-DONE State ..................85\n           8.12.2.
    Transition out of CONFLICT-DONE State .............85\n   9. DNS Update Considerations
    ......................................85\n      9.1. Relationship between Failover
    and DNS Update ..............86\n      9.2. Exchanging DNS Update Information
    .........................87\n      9.3. Adding RRs to the DNS .....................................89\n
    \     9.4. Deleting RRs from the DNS .................................90\n      9.5.
    Name Assignment with No Update of DNS .....................91\n   10. Security
    Considerations .......................................91\n   11. IANA Considerations
    ...........................................92\n   12. References ....................................................94\n
    \     12.1. Normative References .....................................94\n      12.2.
    Informative References ...................................96\n   Acknowledgements
    ..................................................96\n   Authors' Addresses ................................................96\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document defines a DHCPv6 failover protocol, which
    is a\n   mechanism for running two DHCPv6 servers [RFC3315] with the\n   capability
    for either server to take over clients' leases in case of\n   server failover
    or network partition.  For a general overview of\n   DHCPv6 failover problems,
    use cases, benefits, and shortcomings, see\n   [RFC7031].\n   The failover protocol
    provides a means for cooperating DHCP servers\n   to work together to provide
    a service to DHCP clients with\n   availability that is increased beyond the availability
    that could be\n   provided by a single DHCP server operating alone.  It is designed
    to\n   protect DHCP clients against server unreachability, including server\n
    \  failure and network partition.  It is possible to deploy exactly two\n   servers
    that are able to continue providing a lease for an IPv6\n   address [RFC3315]
    or on an IPv6 prefix [RFC3633] without the DHCP\n   client experiencing lease
    expiration or a reassignment of a lease to\n   a different IPv6 address or prefix
    in the event of failure by one or\n   the other of the two servers.\n   The failover
    protocol defines an active-passive mode, sometimes also\n   called a \"hot standby\"
    model.  This means that during normal\n   operation one server is active (i.e.,
    it actively responds to\n   clients' requests) while the second is passive (i.e.,
    it receives\n   clients' requests but responds only to those specifically directed
    to\n   it).  The secondary server maintains a copy of the binding database\n   and
    is ready to take over all incoming queries in case the primary\n   server fails.\n
    \  The failover protocol is designed to provide lease stability for\n   leases
    with valid lifetimes beyond a short period.  The DHCPv6\n   failover protocol
    MUST NOT be used for new leases shorter than\n   30 seconds.  Leases reaching
    the end of their lifetimes are not\n   affected by this restriction.\n   The failover
    protocol fulfills all DHCPv6 failover requirements\n   defined in [RFC7031].\n"
  title: 1.  Introduction
- contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
    RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
    as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
    in all\n   capitals, as shown here.\n"
  title: 2.  Requirements Language
- contents:
  - "3.  Glossary\n   This is a supplemental glossary that should be used in combination\n
    \  with the definitions in Section 2 of RFC 7031 [RFC7031].\n   o  Absolute Time\n
    \     \"Absolute time\" refers to the time in seconds since midnight\n      January
    1, 2000 UTC, modulo 2^32.\n   o  Address Lease\n      \"Address lease\" refers
    to a lease involving an IPv6 address.\n      Typically used when it is necessary
    to distinguish the lease for\n      an IPv6 address from a lease for a DHCP prefix.
    \ See the\n      definitions for \"delegated prefix\" and \"prefix lease\" below.\n
    \  o  auto-partner-down\n      \"auto-partner-down\" refers to a capability where
    a failover server\n      will move from COMMUNICATIONS-INTERRUPTED state to PARTNER-DOWN\n
    \     state automatically, without operator intervention.\n   o  Available (Lease
    or Prefix)\n      A lease or delegable prefix is available if it could be allocated\n
    \     for use by a DHCP client.  It is available on the main server when\n      it
    is in the FREE state and available on the secondary server when\n      it is in
    the FREE-BACKUP state.  The term \"available\" is sometimes\n      used when it
    would be awkward to say \"FREE on the primary server\n      and FREE-BACKUP on
    the secondary server\".\n   o  Binding-Status\n      A lease can hold a variety
    of states (see Section 5.5.1 for a\n      list); these are also referred to as
    the \"binding-status\" of the\n      lease.\n   o  Delegable Prefix\n      \"Delegable
    prefix\" refers to a prefix from which other prefixes\n      may be delegated,
    using the mechanisms described in [RFC3633].  A\n      prefix that has been delegated
    is known as a \"delegated prefix\" or\n      a \"prefix lease\".\n   o  Delegated
    Prefix\n      A delegated prefix is a prefix that has been delegated to a DHCP\n
    \     client as described in [RFC3633].  Depending on the context, a\n      delegated
    prefix may also be described as a \"prefix lease\" when it\n      is necessary
    to distinguish it from an \"address lease\".\n   o  DHCP Prefix\n      A DHCP
    prefix is part of the IPv6 address space configured to be\n      managed by a
    DHCP server.\n   o  Failover Endpoint\n      The failover protocol permits a unique
    failover \"endpoint\" for\n      each failover relationship in which a failover
    server\n      participates.  The failover relationship is defined by a\n      relationship
    name and includes\n      *  the failover partner IP address,\n      *  the role
    this server takes with respect to that partner\n         (primary or secondary),
    and\n      *  the prefixes from which addresses can be leased, as well as\n         prefixes
    from which other prefixes can be delegated (delegable\n         prefixes), that
    are associated with that relationship.\n      The failover endpoint can take actions
    and hold unique states.\n      Typically, there is one failover endpoint per partner
    (server),\n      although there may be more.\n   o  Failover Communication\n      \"Failover
    communication\" refers to all messages exchanged between\n      partners.\n   o
    \ Independent Allocation\n      \"Independent allocation\" refers to an allocation
    algorithm that\n      splits the available pool of address leases between the
    primary\n      and secondary servers.  It is used for IPv6 address allocations.\n
    \     See Section 4.2.1.\n   o  Lease\n      A lease is an association of a DHCP
    client with an IPv6 address or\n      delegated prefix.  This might refer to either
    an existing\n      association or a potential association.\n   o  MCLT (Maximum
    Client Lead Time)\n      The fundamental relationship on which much of the correctness
    of\n      the failover protocol depends is that the lease expiration time\n      known
    to a DHCP client MUST NOT be greater by more than the MCLT\n      beyond the later
    of the partner lifetime acknowledged by that\n      server's failover partner
    or the current time (i.e., now).  See\n      Section 4.4.\n   o  Partner\n      The
    other DHCP server that participates in a failover relationship\n      is referred
    to as the \"partner\".  When the role (primary or\n      secondary) is not important,
    the other server is referred to as a\n      \"failover partner\" or sometimes
    simply \"partner\".\n   o  Prefix Lease\n      A prefix lease is a lease involving
    a prefix that is delegated or\n      could be delegated, as opposed to a lease
    for a single IPv6\n      address.  A prefix lease can also be described as a \"delegated\n
    \     prefix\".\n   o  Primary Server\n      The primary server is the first of
    the two DHCP servers that\n      participate in a failover relationship.  When
    both servers are\n      operating, this server handles most of the client traffic.
    \ Its\n      failover partner is referred to as the \"secondary server\".\n   o
    \ Proportional Allocation\n      \"Proportional allocation\" is an allocation
    algorithm that splits\n      the delegable prefixes between the primary and secondary
    servers\n      and maintains a more or less fixed proportion of the delegable\n
    \     prefixes between both servers.  See Section 4.2.2.\n   o  Renew Responsive\n
    \     A server that is \"renew responsive\" will respond to valid DHCP\n      client
    messages that are directed to it by having an\n      OPTION_SERVERID option in
    the message that contains the DHCP\n      Unique Identifier (DUID) of the renew
    responsive server.  See\n      [RFC3315].\n   o  Responsive\n      A server that
    is responsive will respond to all valid DHCP client\n      messages.\n   o  Secondary
    Server\n      The secondary server is the second of the two DHCP servers that\n
    \     participate in a failover relationship.  Its failover partner is\n      referred
    to as the \"primary server\" (as defined above).  When both\n      servers are
    operating, this server (the secondary) typically does\n      not handle client
    traffic and acts as a backup to the primary\n      server.  However, it will respond
    to RENEW requests directed\n      specifically to it.\n   o  Server\n      \"Server\"
    refers to a DHCP server that implements DHCPv6 failover.\n      \"Server\" and
    \"failover endpoint\" are synonymous only if the server\n      participates in
    only one failover relationship.\n   o  State\n      The term \"state\" is used
    in two ways in this document.  A failover\n      endpoint is always in some state,
    and there are a series of states\n      that a failover endpoint can move through.
    \ See Section 8 for\n      details of the failover endpoint states.  A lease also
    has a\n      state, and this is sometimes referred to as a \"binding-status\".\n
    \     See Section 5.5.1 for a list of the states a lease can hold.\n   o  Unresponsive\n
    \     A server that is unresponsive will not respond to DHCP client\n      messages.\n"
  title: 3.  Glossary
- contents:
  - "4.  Failover Concepts and Mechanisms\n   The following concepts and mechanisms
    are necessary for the operation\n   of the failover protocol.  They are not currently
    employed by DHCPv6\n   [RFC3315].  The failover protocol provides support for
    all of these\n   concepts and mechanisms.\n"
  - contents:
    - "4.1.  Required Server Configuration\n   Servers frequently have several kinds
      of leases available on a\n   particular network segment.  The failover protocol
      assumes that both\n   the primary server and the secondary server are configured\n
      \  identically with regard to the prefixes and links involved in DHCP.\n   For
      delegable prefixes (involved in proportional allocation), the\n   primary server
      is responsible for allocating to the secondary server\n   the correct proportion
      of the available delegable prefixes.  IPv6\n   addresses (involved in independent
      allocation) are allocated to the\n   primary and secondary servers algorithmically
      and do not require an\n   explicit message transfer to be distributed.\n"
    title: 4.1.  Required Server Configuration
  - contents:
    - "4.2.  IPv6 Address and Delegable Prefix Allocation\n   Currently, there are
      two allocation algorithms defined: one for\n   address leases and one for prefix
      leases.\n"
    - contents:
      - "4.2.1.  Independent Allocation\n   In this allocation scheme, which is used
        for allocating individual\n   IPv6 addresses, available IPv6 addresses are
        permanently (until\n   server configuration changes) split between servers.
        \ Available IPv6\n   addresses are split between the primary and secondary
        servers as part\n   of initial connection establishment.  Once IPv6 addresses
        are\n   allocated to each server, there is no need to reassign them.  The\n
        \  IPv6 address allocation is algorithmic in nature and does not require\n
        \  a message exchange for each server to know which IPv6 addresses it\n   has
        been allocated.  This algorithm is simpler than proportional\n   allocation,
        since it does not require a rebalancing mechanism.  It\n   also assumes that
        the pool assigned to each server will never be\n   depleted.\n   Once each
        server is assigned a pool of IPv6 addresses during initial\n   connection
        establishment, it may allocate its assigned IPv6 addresses\n   to clients.
        \ Once a client releases a lease or its lease on an IPv6\n   address expires,
        the returned IPv6 address returns to the pool for\n   the server that leased
        it.  A lease on an IPv6 address can be renewed\n   by a responsive server
        or by a renew responsive server.  When an IPv6\n   address goes PENDING-FREE
        (see Section 7.2), it is owned by whichever\n   server it is allocated to
        by the independent allocation algorithm.\n   IPv6 addresses, which use the
        independent allocation approach, will\n   be ignored when a server processes
        a POOLREQ message.\n   During COMMUNICATIONS-INTERRUPTED events, a partner
        MAY continue\n   extending existing address leases as requested by clients.
        \ An\n   operational partner MUST NOT lease IPv6 addresses that were assigned\n
        \  to its downed partner and later expired or that were released or\n   declined
        by a client.  When it is in PARTNER-DOWN state, a server\n   MUST allocate
        new leases from its own pool.  It MUST NOT use its\n   partner's pool to allocate
        new leases.\n"
      - contents:
        - "4.2.1.1.  Independent Allocation Algorithm\n   For each address that can
          be allocated, the primary server MUST\n   allocate only IPv6 addresses when
          the low-order bit (i.e., bit 127)\n   is equal to 1, and the secondary server
          MUST allocate only the IPv6\n   addresses when the low-order bit (i.e.,
          bit 127) is equal to 0.\n"
        title: 4.2.1.1.  Independent Allocation Algorithm
      title: 4.2.1.  Independent Allocation
    - contents:
      - "4.2.2.  Proportional Allocation\n   In this allocation scheme, each server
        has its own pool of prefixes\n   available for delegation, known as \"delegable
        prefixes\".  These\n   delegable prefixes may be prefixes from which other
        prefixes can be\n   delegated, or they may be prefixes that are the correct
        size for\n   delegation but are not, at present, delegated to a particular
        client.\n   Remaining delegable prefixes are split between the primary and\n
        \  secondary servers in a configured proportion.  Note that a delegated\n
        \  prefix (also known as a \"prefix lease\") is not \"owned\" by a\n   particular
        server.  Only a delegable prefix that is available is\n   owned by a particular
        server -- once it has been delegated (leased)\n   to a client, it becomes
        a prefix lease and is not owned by either\n   failover partner.  When it finally
        becomes available again, it will\n   be initially owned by the primary server,
        and it may or may not be\n   allocated to the secondary server by the primary
        server.\n   The flow of a delegable prefix is as follows: initially, the\n
        \  delegable prefix is part of a set of delegable prefixes, all of which\n
        \  are initially owned by the primary server.  A delegable prefix may be\n
        \  allocated to the secondary server, and it is then owned by the\n   secondary
        server.  Either server can allocate and delegate prefixes\n   out of the delegable
        prefixes that they own.  Once these prefixes are\n   delegated (leased) to
        clients, the servers cease to own them, and\n   they are owned by the clients
        to which they have been delegated\n   (leased).  When the client releases
        the delegated prefix or the lease\n   on it expires, the prefix will again
        become available, will again be\n   a delegable prefix, and will be owned
        by the primary.\n   A server delegates prefixes only from its own pool of
        delegable\n   prefixes in all states except for PARTNER-DOWN.  In PARTNER-DOWN\n
        \  state, the operational partner can delegate prefixes from either pool\n
        \  (both its own, and its partner's after some time constraints have\n   elapsed).
        \ The operational partner SHOULD allocate from its own pool\n   before using
        its partner's pool.  The allocation and maintenance of\n   these pools of
        delegable prefixes are important, since the goal is to\n   maintain a more
        or less constant ratio of delegable prefixes between\n   the two servers.\n
        \  Each server knows which delegable prefixes are in its own pool as\n   well
        as which are in its partner's pool, so that it can allocate\n   delegable
        prefixes from its partner's pool without communication with\n   its partner
        if that becomes necessary.\n   The initial allocation of delegable prefixes
        from the primary to the\n   secondary when the servers first integrate is
        triggered by the\n   POOLREQ message from the secondary to the primary.  This
        is followed\n   (at some point) by the POOLRESP message, where the primary
        tells the\n   secondary that it received and processed the POOLREQ message.
        \ The\n   primary sends the allocated delegable prefixes to the secondary
        as\n   prefix leases via BNDUPD messages.  The POOLRESP message may be sent\n
        \  before, during, or at the completion of the BNDUPD message exchanges\n
        \  that were triggered by the POOLREQ message.  The POOLREQ/POOLRESP\n   message
        exchange is a trigger to the primary to perform a scan of its\n   database
        and to ensure that the secondary has enough delegable\n   prefixes (based
        on some configured ratio).\n   The delegable prefixes are sent to the secondary
        as prefix leases\n   using the BNDUPD message containing an OPTION_IAPREFIX
        with a state\n   of FREE-BACKUP, which indicates that the prefix lease is
        now\n   available for allocation by the secondary.  Once the message is sent,\n
        \  the primary MUST NOT use these prefixes for allocation to DHCP\n   clients
        (except when the server is in PARTNER-DOWN state).\n   The POOLREQ/POOLRESP
        message exchange initiated by the secondary is\n   valid at any time both
        partners remain in contact, and the primary\n   server SHOULD, whenever it
        receives the POOLREQ message, scan its\n   database of delegable prefixes
        and determine if the secondary needs\n   more delegable prefixes from any
        of the delegable prefixes that it\n   currently owns.\n   In order to support
        a reasonably dynamic balance of the leases\n   between the failover partners,
        the primary server needs to do\n   additional work to ensure that the secondary
        server has as many\n   delegable prefixes as it needs (but that it doesn't
        have more than\n   it needs).\n   The primary server SHOULD examine the balance
        of delegable prefixes\n   between the primary and secondary for a particular
        prefix whenever\n   the number of possibly delegable prefixes for either the
        primary or\n   secondary changes by more than a predetermined amount.  Typically,\n
        \  this comparison would not involve actually comparing the count of\n   existing
        instances of delegable prefixes but would instead involve\n   determining
        the number of prefixes that could be delegated given the\n   address ranges
        of the delegable prefixes allocated to each server.\n   The primary server
        SHOULD adjust the delegable prefix balance as\n   required to ensure the configured
        delegable prefix balance, except\n   that the primary server SHOULD employ
        some threshold mechanism to\n   such a balance adjustment in order to minimize
        the overhead of\n   maintaining this balance.\n   The primary server can,
        at any time, send an available delegable\n   prefix to the secondary using
        a BNDUPD message with the state\n   FREE-BACKUP.  The primary server can attempt
        to take an available\n   delegable prefix away from the secondary by sending
        a BNDUPD message\n   with the state FREE.  If the secondary accepts the BNDUPD
        message,\n   then the lease is now available to the primary and not available
        to\n   the secondary.  Of course, the secondary MUST reject that BNDUPD\n
        \  message if it has already allocated that lease to a DHCP client.\n"
      - contents:
        - "4.2.2.1.  Reallocating Leases\n   When the server is in PARTNER-DOWN state,
          there is a waiting period\n   after which a delegated prefix can be reallocated
          to another client.\n   For delegable prefixes that are \"available\" when
          the server enters\n   PARTNER-DOWN state, the period is the MCLT from the
          entry into\n   PARTNER-DOWN state.  For delegated prefixes that are not
          available\n   when the server enters PARTNER-DOWN state, the period is the
          MCLT\n   after the later of the following times: the acked-partner-lifetime,\n
          \  the partner-lifetime (if any), the expiration-time, or the entry into\n
          \  PARTNER-DOWN time.\n   In any other state, a server cannot reallocate
          a delegated prefix\n   from one client to another without first notifying
          its partner\n   (through a BNDUPD message) and receiving acknowledgement
          (through a\n   BNDREPLY message) that its partner is aware that the first
          client is\n   not using the lease.\n   Specifically, an \"available\" delegable
          prefix on a server may be\n   allocated to any client.  A prefix that was
          delegated (leased) to a\n   client and that expired or was released by that
          client would take on\n   a new state -- EXPIRED or RELEASED, respectively.
          \ The partner server\n   would then be notified that this delegated prefix
          was EXPIRED or\n   RELEASED through a BNDUPD message.  When the sending
          server received\n   the BNDREPLY message for that delegated prefix showing
          that it was\n   FREE, it would move the lease from EXPIRED or RELEASED to
          FREE, and\n   the prefix would be available for allocation by the primary
          server to\n   any clients.\n   A server MAY reallocate a delegated prefix
          in the EXPIRED or RELEASED\n   state to the same client with no restrictions,
          provided it has not\n   sent a BNDUPD message regarding the delegated prefix
          to its partner.\n   This situation would exist if the prefix lease expired
          or was\n   released after the transition into PARTNER-DOWN state, for instance.\n"
        title: 4.2.2.1.  Reallocating Leases
      title: 4.2.2.  Proportional Allocation
    title: 4.2.  IPv6 Address and Delegable Prefix Allocation
  - contents:
    - "4.3.  Lazy Updates\n   [RFC7031] includes the requirement that failover must
      not introduce\n   significant performance impact on server response times (see\n
      \  Sections 7 and 5.2.2 of [RFC7031]).  In order to realize this\n   requirement,
      a server implementing the failover protocol must be able\n   to respond to a
      DHCP client without waiting to update its failover\n   partner whenever the
      binding database changes.  The \"lazy update\"\n   mechanism allows a server
      to allocate a new lease or extend an\n   existing lease, respond to the DHCP
      client, and then update its\n   failover partner as time permits.\n   Although
      the \"lazy update\" mechanism does not introduce additional\n   delays in server
      response times, it introduces other difficulties.\n   The key problem with lazy
      update is that when a server fails after\n   updating a DHCP client with a particular
      valid lifetime but before\n   updating its failover partner, the failover partner
      will eventually\n   believe that the client's lease has expired -- even though
      the DHCP\n   client still retains a valid lease on that address or prefix.  It
      is\n   also possible that the failover partner will have no record at all of\n
      \  the lease being assigned to the DHCP client.  Both of these issues\n   are
      dealt with by using the MCLT when allocating or extending leases\n   (see Section
      4.4).\n"
    title: 4.3.  Lazy Updates
  - contents:
    - "4.4.  Maximum Client Lead Time (MCLT)\n   In order to handle problems introduced
      by lazy updates (see\n   Section 4.3), a period of time known as the \"Maximum
      Client Lead\n   Time\" (MCLT) is defined and must be known to both the primary
      server\n   and the secondary server.  Proper use of this time interval places
      an\n   upper bound on the difference allowed between the valid lifetime\n   provided
      to a DHCP client by a server and the valid lifetime known by\n   that server's
      failover partner.\n   The MCLT is typically much less than the valid lifetime
      that a server\n   has been configured to offer a client, and so some strategy
      must\n   exist to allow a server to offer the configured valid lifetime to a\n
      \  client.  During a lazy update, the updating server updates its\n   failover
      partner with a partner lifetime that is longer than the\n   valid lifetime previously
      given to the DHCP client and that is longer\n   than the valid lifetime that
      the server has been configured to give a\n   client.  This allows the server
      to give the configured valid lifetime\n   to the client the next time the client
      renews its lease, since the\n   time that it will give to the client will not
      be longer than the MCLT\n   beyond the partner lifetime acknowledged by its
      partner or the\n   current time.\n   The fundamental relationship on which the
      failover protocol depends\n   is as follows: the lease expiration time known
      to a DHCP client\n   MUST NOT be greater by more than the MCLT beyond the later
      of the\n   partner lifetime acknowledged by that server's failover partner or\n
      \  the current time.\n   The remainder of this section makes the above fundamental\n
      \  relationship more explicit.\n   The failover protocol requires a DHCP server
      to deal with several\n   different lease intervals and places specific restrictions
      on their\n   relationships.  The purpose of these restrictions is to allow the\n
      \  partner to be able to make certain assumptions in the absence of an\n   ability
      to communicate between servers.\n   In the following explanation, all of the
      lifetimes are \"valid\"\n   lifetimes, in the context of [RFC3315].\n   The
      different times are as follows:\n   desired lifetime:\n      The desired lifetime
      is the lease interval that a DHCP server\n      would like to give to a DHCP
      client in the absence of any\n      restrictions imposed by the failover protocol.
      \ Its determination\n      is outside of the scope of the failover protocol.
      \ Typically, this\n      is the result of external configuration of a DHCP server.\n
      \  actual lifetime:\n      The actual lifetime is the lease interval that a
      DHCP server gives\n      out to a DHCP client.  It may be shorter than the desired
      lifetime\n      (as explained below).\n   partner lifetime:\n      The partner
      lifetime is the lease expiration interval the local\n      server sends to its
      partner in a BNDUPD message.\n   acknowledged partner lifetime:\n      The acknowledged
      partner lifetime is the partner lifetime the\n      partner server has most
      recently acknowledged in a BNDREPLY\n      message.\n"
    - contents:
      - "4.4.1.  MCLT Example\n   The following example demonstrates the MCLT concept
        in practice.  The\n   values used are arbitrarily chosen and are not a recommendation
        for\n   actual values.  The MCLT in this case is 1 hour.  The desired\n   lifetime
        is 3 days, and its renewal time is half the lifetime.\n   When a server makes
        an offer for a new lease on an IPv6 address to a\n   DHCP client, it determines
        the desired lifetime (in this case,\n   3 days).  It then examines the acknowledged
        partner lifetime (which,\n   in this case, is zero) and determines the remainder
        of the time left\n   to run, which is also zero.  It adds the MCLT to this
        value.  Since\n   the actual lifetime cannot be allowed to exceed the remainder
        of the\n   current acknowledged partner lifetime plus the MCLT, the offer
        made\n   to the client is for the remainder of the current acknowledged\n
        \  partner lifetime (i.e., zero) plus the MCLT.  Thus, the actual\n   lifetime
        is 1 hour (the MCLT).\n   Once the server has sent the REPLY to the DHCP client,
        it will update\n   its failover partner with the lease information using a
        BNDUPD\n   message.  The partner lifetime will be composed of the T1 fraction\n
        \  (1/2) of the actual lifetime added to the desired lifetime.  Thus,\n   the
        failover partner is updated using a BNDUPD message with a partner\n   lifetime
        of 1/2 hour + 3 days.\n   When the primary server receives a BNDREPLY to its
        update of the\n   secondary server's (partner's) partner lifetime, it records
        that as\n   the acknowledged partner lifetime.  A server MUST NOT send a BNDREPLY\n
        \  message in response to a BNDUPD message until it is sure that the\n   information
        in the BNDUPD message has been updated in its lease\n   database.  See Section
        7.5.2.  Thus, the primary server in this case\n   can be sure that the secondary
        server has recorded the partner\n   lifetime in its stable storage when the
        primary server receives a\n   BNDREPLY message from the secondary server.\n
        \  When the DHCP client attempts to renew at T1 (approximately 1/2 hour\n
        \  from the start of the lease), the primary server again determines the\n
        \  desired lifetime, which is still 3 days.  It then compares this with\n
        \  the original acknowledged partner lifetime (1/2 hour + 3 days) and\n   adjusts
        for the time passed since the secondary was last updated\n   (1/2 hour).  Thus,
        the remaining time for the acknowledged partner\n   interval is 3 days.  Adding
        the MCLT to this yields 3 days plus\n   1 hour, which is more than the desired
        lifetime of 3 days.  So, the\n   client may have its lease renewed for the
        desired lifetime -- 3 days.\n   When the primary DHCP server updates the secondary
        DHCP server after\n   the DHCP client's renewal REPLY is complete, it will
        calculate the\n   partner lifetime as the T1 fraction of the actual client
        lifetime\n   (1/2 of 3 days = 1.5 days).  To this it will add the desired
        lifetime\n   of 3 days, yielding a total partner lifetime of 4.5 days.  In
        this\n   way, the primary attempts to have the secondary always \"lead\" the\n
        \  client in its understanding of the client's lifetime so as to be able\n
        \  to always offer the client the desired lifetime.\n   Once the initial actual
        client lifetime of the MCLT has passed, the\n   failover protocol operates
        effectively like DHCP does today in its\n   behavior concerning lifetimes.
        \ However, the guarantee that the\n   actual client lifetime will never exceed
        the partner server's\n   remaining acknowledged partner lifetime by more than
        the MCLT allows\n   full recovery from a variety of DHCP server failures.\n
        Fundamental relationship:\n   lease time = floor( desired lifetime, acked-partner-lifetime
        + MCLT )\n  Initial conditions: MCLT = 1h, desired lifetime = 3d\n             DHCPv6
        \              Primary             Secondary\n      time   Client               Server
        \              Server\n               | >-SOLICIT------>    |                    |\n
        \              |  acknowledged partner lifetime = 0       |\n               |
        \ lease time = floor( 3d, 0 + 1h ) = 1h   |\n               |   <-----ADVERTISE-<
        |                    |\n               |    lease-time = 1h  |                    |\n
        \              | >-REQUEST------>    |                    |\n        t      |
        \  <---------REPLY-< |                    |\n               |    lease-time
        = 1h  |                    |\n               |                     |  >-BNDUPD------>
        \  |\n               |                     |  partner-lifetime = 1/2h + 3d\n
        \              |                     |    <----BNDREPLY-< |\n               |
        \                    |  partner-lifetime = 1/2h + 3d\n               |acknowledged
        partner lifetime = 1/2h + 3d |\n  1/2h passes ...                   ...                  ...\n
        \    t+1/2h    | >-RENEW-------->    |                    |\n               |
        \  acknowledged partner lifetime = 3d     |\n               |   lease time
        = floor( 3d, 3d + 1h ) = 3d |\n               |   <---------REPLY-< |                    |\n
        \              |   lease-time = 3d   |                    |\n               |
        \                    | >-BNDUPD------->   |\n               |                     |
        \ partner-lifetime = 1.5d + 3d\n               |                     |    <----BNDREPLY-<
        |\n               |                     |  partner-lifetime = 1.5d + 3d\n
        \              |acknowledged partner lifetime = 1.5d + 3d |\n  1.5d passes
        ...                   ...                  ...\n               |                     |
        \                   |\n t+1.5d + 1/2h | >-RENEW-------->    |                    |\n
        \              |  acknowledged partner lifetime = 3d      |\n               |
        \  lease time = floor( 3d, 3d + 1h ) = 3d |\n               |   <---------REPLY-<
        |                    |\n               |   lease-time = 3d   |                    |\n
        \              |                     | >-BNDUPD------->   |\n               |
        \                    |  partner-lifetime = 1.5d + 3d\n               |                     |
        \   <----BNDREPLY-< |\n               |                     |  partner-lifetime
        = 1.5d + 3d\n               |acknowledged partner lifetime = 1.5d + 3d |\n
        \                         Figure 1: MCLT Example\n"
      title: 4.4.1.  MCLT Example
    title: 4.4.  Maximum Client Lead Time (MCLT)
  title: 4.  Failover Concepts and Mechanisms
- contents:
  - '5.  Message and Option Definitions

    '
  - contents:
    - "5.1.  Message Framing for TCP\n   Failover communication is conducted over
      a TCP connection established\n   between the partners.  The failover protocol
      uses the framing format\n   specified in Section 5.1 of \"DHCPv6 Bulk Leasequery\"
      [RFC5460] but\n   uses different message types with a different message format,
      as\n   described in Section 5.2 of this document.  The TCP connection\n   between
      failover servers is made to a specific port -- the\n   dhcp-failover port, port
      647.  All information is sent over the\n   connection as typical DHCP messages
      that convey DHCP options,\n   following the format defined in Section 22.1 of
      [RFC3315].\n"
    title: 5.1.  Message Framing for TCP
  - contents:
    - "5.2.  Failover Message Format\n   All failover messages defined below share
      a common format with a\n   fixed-size header and a variable format area for
      options.  All values\n   in the message header and in any included options are
      in network byte\n   order.\n   The following diagram illustrates the format
      (which is compatible\n   with the format described in Section 6 of [RFC3315])
      of DHCP messages\n   exchanged between failover partners:\n     0                   1
      \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |    msg-type   |               transaction-id                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                           sent-time                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               .\n    .
      \                           options                            .\n    .                           (variable)
      \                         .\n    .                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    msg-type
      \            Identifies the DHCP message type; the\n                         available
      message types are listed below.\n    transaction-id       The transaction-id
      for this message exchange.\n    sent-time            The time the message was
      transmitted (set\n                         as close to transmission as practical),\n
      \                        in seconds since midnight (UTC),\n                         January
      1, 2000, modulo 2^32.  Used to\n                         determine the time
      skew of the failover\n                         partners.\n    options              Options
      carried in this message.  These\n                         options are all defined
      in the \"Option Codes\"\n                         sub-registry of the \"Dynamic
      Host\n                         Configuration Protocol for IPv6 (DHCPv6)\"\n
      \                        registry.  A number of existing DHCPv6\n                         options
      are used, and several more are\n                         defined in this document.\n"
    title: 5.2.  Failover Message Format
  - contents:
    - "5.3.  Messages\n   The following sections list the new message types defined
      for\n   failover communication.\n"
    - contents:
      - "5.3.1.  BNDUPD\n   The binding update message, BNDUPD (24), is used to send
        the binding\n   lease changes to the partner.  At most one OPTION_CLIENT_DATA
        option\n   may appear in a BNDUPD message.  Note that not all data in a BNDUPD\n
        \  message is sent in an OPTION_CLIENT_DATA option.  Information about\n   delegable
        prefixes not currently allocated to a particular client is\n   sent in BNDUPD
        messages but not within OPTION_CLIENT_DATA options.\n   The partner is expected
        to respond with a BNDREPLY message.\n"
      title: 5.3.1.  BNDUPD
    - contents:
      - "5.3.2.  BNDREPLY\n   The binding acknowledgement message, BNDREPLY (25),
        is used for\n   confirmation of the received BNDUPD message.  It may contain
        a\n   positive or negative response (e.g., due to a detected lease\n   conflict).\n"
      title: 5.3.2.  BNDREPLY
    - contents:
      - "5.3.3.  POOLREQ\n   The pool request message, POOLREQ (26), is used by the
        secondary\n   server to request allocation of delegable prefixes from the
        primary\n   server.  The primary responds with a POOLRESP message.\n"
      title: 5.3.3.  POOLREQ
    - contents:
      - "5.3.4.  POOLRESP\n   The pool response message, POOLRESP (27), is used by
        the primary\n   server to indicate that it has received the secondary server's\n
        \  request to ensure that delegable prefixes are balanced between the\n   primary
        and secondary servers.  It does not indicate that all of the\n   BNDUPD messages
        that might be created from any rebalancing have been\n   sent or responded
        to; it only indicates reception and acceptance of\n   the task of ensuring
        that the balance is examined and corrected as\n   necessary.\n"
      title: 5.3.4.  POOLRESP
    - contents:
      - "5.3.5.  UPDREQ\n   The update request message, UPDREQ (28), is used by one
        server to\n   request that its partner send all binding database changes that
        have\n   not yet been confirmed.  The partner is expected to respond with
        zero\n   or more BNDUPD messages, followed by an UPDDONE message that signals\n
        \  that all of the BNDUPD messages have been sent and a corresponding\n   BNDREPLY
        message has been received for each of them.\n"
      title: 5.3.5.  UPDREQ
    - contents:
      - "5.3.6.  UPDREQALL\n   The update request all message, UPDREQALL (29), is
        used by one server\n   to request that all binding database information present
        in the other\n   server be sent to the requesting server, in order for the
        requesting\n   server to recover from a total loss of its binding database.
        \ A\n   server receiving this request responds with zero or more BNDUPD\n
        \  messages, followed by an UPDDONE message that signals that all of the\n
        \  BNDUPD messages have been sent and a corresponding BNDREPLY message\n   has
        been received for each of them.\n"
      title: 5.3.6.  UPDREQALL
    - contents:
      - "5.3.7.  UPDDONE\n   The update done message, UPDDONE (30), is used by the
        server\n   responding to an UPDREQ or UPDREQALL message to indicate that all\n
        \  requested updates have been sent by the responding server and acked\n   by
        the requesting server.\n"
      title: 5.3.7.  UPDDONE
    - contents:
      - "5.3.8.  CONNECT\n   The connect message, CONNECT (31), is used by the primary
        server to\n   establish a failover connection with the secondary server and
        to\n   transmit several important configuration attributes between the\n   servers.
        \ The partner is expected to confirm by responding with a\n   CONNECTREPLY
        message.\n"
      title: 5.3.8.  CONNECT
    - contents:
      - "5.3.9.  CONNECTREPLY\n   The connect acknowledgement message, CONNECTREPLY
        (32), is used by\n   the secondary server to respond to a CONNECT message
        from the primary\n   server.\n"
      title: 5.3.9.  CONNECTREPLY
    - contents:
      - "5.3.10.  DISCONNECT\n   The disconnect message, DISCONNECT (33), is used
        by either server\n   when closing a connection and shutting down.  No response
        is required\n   for this message.  The DISCONNECT message SHOULD contain an\n
        \  OPTION_STATUS_CODE option with an appropriate status.  Often, this\n   will
        be ServerShuttingDown.  See Section 5.6.  A server SHOULD\n   include a descriptive
        message as to what caused the disconnect\n   message.\n"
      title: 5.3.10.  DISCONNECT
    - contents:
      - "5.3.11.  STATE\n   The state message, STATE (34), is used by either server
        to inform its\n   partner about a change of failover state.  In some cases,
        it may be\n   used to also inform the partner about the current state, e.g.,
        after\n   connection is established in the COMMUNICATIONS-INTERRUPTED or\n
        \  PARTNER-DOWN states.\n"
      title: 5.3.11.  STATE
    - contents:
      - "5.3.12.  CONTACT\n   The contact message, CONTACT (35), is used by either
        server to ensure\n   that its partner continues to see the connection as operational.
        \ It\n   MUST be transmitted periodically over every established connection
        if\n   other message traffic is not flowing, and it MAY be sent at any time.\n
        \  See Section 6.5.\n"
      title: 5.3.12.  CONTACT
    title: 5.3.  Messages
  - contents:
    - "5.4.  Transaction-id\n   The initiator of a message exchange MUST set the transaction-id
      (see\n   Section 5.2).  This means that all of the messages above except\n   BNDREPLY,
      POOLRESP, UPDDONE, and CONNECTREPLY must set the\n   transaction-id.  The transaction-id
      MUST be unique among all\n   currently outstanding messages sent to the failover
      partner.  A\n   straightforward way to ensure this is to simply use an incrementing\n
      \  value, with one caveat: The UPDREQ and UPDREQALL messages may be\n   separated
      by a considerable time prior to the receipt of an UPDDONE\n   message.  While
      the usual pattern of message exchange would have the\n   partner doing the vast
      majority of message initiation, it is remotely\n   possible that the partner
      that initiated the UPDREQ or UPDREQALL\n   messages might also send enough messages
      to wrap the 24-bit\n   transaction-id and duplicate the transaction-id of the
      outstanding\n   UPDREQ or UPDREQALL messages.  Thus, it is important to ensure
      that\n   the transaction-id of a currently outstanding UPDREQ or UPDREQALL\n
      \  message is not replicated in any message initiated prior to the\n   receipt
      of the corresponding UPDDONE message.\n"
    title: 5.4.  Transaction-id
  - contents:
    - "5.5.  Options\n   The following new options are defined.\n"
    - contents:
      - "5.5.1.  OPTION_F_BINDING_STATUS\n   The binding-status is an implementation-independent
        representation of\n   the status (or the state) of a lease on an IPv6 address
        or prefix.\n   This is an unsigned byte.\n   The code for this option is 114.\n
        \    0                   1                   2                   3\n     0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |    OPTION_F_BINDING_STATUS    |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | binding-status|\n    +-+-+-+-+-+-+-+-+\n    option-code       OPTION_F_BINDING_STATUS
        (114)\n    option-len        1\n    binding-status    The binding-status.
        \ See below:\n      Value   binding-status\n      -----   --------------\n
        \     0       reserved\n      1       ACTIVE\n      2       EXPIRED\n      3
        \      RELEASED\n      4       PENDING-FREE\n      5       FREE\n      6       FREE-BACKUP\n
        \     7       ABANDONED\n      8       RESET\n   The binding-status values
        are discussed in Section 7.2.\n"
      title: 5.5.1.  OPTION_F_BINDING_STATUS
    - contents:
      - "5.5.2.  OPTION_F_CONNECT_FLAGS\n   This option provides flags that indicate
        attributes of the connecting\n   server.\n   This option consists of an unsigned
        16-bit integer in network byte\n   order.\n   The code for this option is
        115.\n     0                   1                   2                   3\n
        \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |    OPTION_F_CONNECT_FLAGS     |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             flags             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code       OPTION_F_CONNECT_FLAGS (115)\n    option-len        2\n
        \   flags             flag bits.  See below:\n       0                   1\n
        \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |           MBZ               |F|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The bits (numbered from the most significant bit in network\n      byte
        order) are used as follows:\n      0-14:   MBZ\n              Must be zero.\n
        \     15 (F): FIXED_PD_LENGTH\n              Set to 1 to indicate that all
        prefixes delegated from a\n              given delegable prefix have the same
        prefix length (size).\n              If this is not set, the prefixes delegated
        from one\n              delegable prefix may have different sizes.\n   If
        the FIXED_PD_LENGTH bit is not set, it indicates that prefixes of\n   a range
        of sizes can be delegated from a given delegable prefix.\n   Note that if
        the FIXED_PD_LENGTH bit is set, each delegable prefix\n   may have its own
        fixed size -- this flag does not imply that all\n   prefixes delegated will
        be the same size, but rather that all\n   prefixes delegated from the same
        delegable prefix will be the\n   same size.\n   If the FIXED_PD_LENGTH bit
        is set, the length used for each prefix is\n   specified independently of
        the failover protocol but must be known to\n   both failover partners.  It
        might be specified in the configuration\n   for each delegable prefix, or
        it might be fixed for the entire\n   server.\n"
      title: 5.5.2.  OPTION_F_CONNECT_FLAGS
    - contents:
      - "5.5.3.  OPTION_F_DNS_REMOVAL_INFO\n   This option contains the information
        necessary to remove a DNS name\n   that was entered by the failover partner.\n
        \  The code for this option is 116.\n     0                   1                   2
        \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |   OPTION_F_DNS_REMOVAL_INFO   |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                      encapsulated-options                     |\n    |
        \                          (variable)                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code       OPTION_F_DNS_REMOVAL_INFO (116)\n    option-len        variable\n
        \   options           Three possible encapsulated options:\n                         OPTION_F_DNS_HOST_NAME\n
        \                        OPTION_F_DNS_ZONE_NAME\n                         OPTION_F_DNS_FLAGS\n"
      - contents:
        - "5.5.3.1.  OPTION_F_DNS_HOST_NAME\n   This option contains the hostname
          that was entered into the DNS by\n   the failover partner.\n   This is a
          DNS name encoded using the format specified in [RFC1035],\n   as also specified
          in Section 8 of [RFC3315].\n   The code for this option is 117.\n     0
          \                  1                   2                   3\n     0 1 2
          3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \   |     OPTION_F_DNS_HOST_NAME    |           option-len          |\n
          \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \   |                                                               .\n
          \   .                                                               .\n
          \   .                           host-name                           .\n
          \   .                           (variable)                          .\n
          \   .                                                               |\n
          \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \   option-code       OPTION_F_DNS_HOST_NAME (117)\n    option-len        length
          of host-name\n    host-name         hostname encoded per RFC 1035\n"
        title: 5.5.3.1.  OPTION_F_DNS_HOST_NAME
      - contents:
        - "5.5.3.2.  OPTION_F_DNS_ZONE_NAME\n   This option contains the zone name
          that was entered into the DNS by\n   the failover partner.\n   This is a
          DNS name encoded using the format specified in [RFC1035],\n   as also specified
          in Section 8 of [RFC3315].\n   The code for this option is 118.\n     0
          \                  1                   2                   3\n     0 1 2
          3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \   |     OPTION_F_DNS_ZONE_NAME    |           option-len          |\n
          \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \   |                                                               .\n
          \   .                                                               .\n
          \   .                           zone-name                           .\n
          \   .                           (variable)                          .\n
          \   .                                                               |\n
          \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \   option-code       OPTION_F_DNS_ZONE_NAME (118)\n    option-len        length
          of zone-name\n    zone-name         zone name encoded per RFC 1035\n"
        title: 5.5.3.2.  OPTION_F_DNS_ZONE_NAME
      - contents:
        - "5.5.3.3.  OPTION_F_DNS_FLAGS\n   This option provides flags that indicate
          what needs to be done to\n   remove this DNS name.\n   This option consists
          of an unsigned 16-bit integer in network byte\n   order.\n   The code for
          this option is 119.\n     0                   1                   2                   3\n
          \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \   |       OPTION_F_DNS_FLAGS      |           option-len          |\n
          \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \   |             flags             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \   option-code       OPTION_F_DNS_FLAGS (119)\n    option-len        2\n
          \   flags             flag bits.  See below:\n       0                   1\n
          \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \     |           MBZ         |U|S|R|F|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \     The bits (numbered from the most significant bit in network\n      byte
          order) are used as follows:\n      0-11:   MBZ\n              Must be zero.\n
          \     12 (U): USING_REQUESTED_FQDN\n              Set to 1 to indicate that
          the name used came from the\n              Fully Qualified Domain Name (FQDN)
          that was received\n              from the client.\n      13 (S): SYNTHESIZED_NAME\n
          \             Set to 1 to indicate that the name was synthesized\n              based
          on some algorithm.\n      14 (R): REV_UPTODATE\n              Set to 1 to
          indicate that the reverse zone is up to date.\n      15 (F): FWD_UPTODATE\n
          \             Set to 1 to indicate that the forward zone is up to date.\n
          \  If both the U bit and the S bit are unset, then the name must have\n
          \  been provided from some alternative configuration, such as client\n   registration
          in some database accessible to the DHCP server.\n"
        title: 5.5.3.3.  OPTION_F_DNS_FLAGS
      title: 5.5.3.  OPTION_F_DNS_REMOVAL_INFO
    - contents:
      - "5.5.4.  OPTION_F_EXPIRATION_TIME\n   This option specifies the greatest lifetime
        that this server has ever\n   acked to its partner in a BNDREPLY message for
        a particular lease or\n   prefix.  This MUST be an absolute time (i.e., seconds
        since midnight\n   January 1, 2000 UTC, modulo 2^32).\n   This is an unsigned
        32-bit integer in network byte order.\n   The code for this option is 120.\n
        \    0                   1                   2                   3\n     0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |   OPTION_F_EXPIRATION_TIME    |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        expiration-time                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code         OPTION_F_EXPIRATION_TIME (120)\n    option-len          4\n
        \   expiration-time     The expiration time.  This MUST be an\n                        absolute
        time (i.e., seconds since midnight\n                        January 1, 2000
        UTC, modulo 2^32).\n"
      title: 5.5.4.  OPTION_F_EXPIRATION_TIME
    - contents:
      - "5.5.5.  OPTION_F_MAX_UNACKED_BNDUPD\n   This option specifies the maximum
        number of BNDUPD messages that this\n   server is prepared to accept over
        the TCP connection without causing\n   the TCP connection to block.\n   This
        is an unsigned 32-bit integer in network byte order.\n   The code for this
        option is 121.\n     0                   1                   2                   3\n
        \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  OPTION_F_MAX_UNACKED_BNDUPD  |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       max-unacked-bndupd                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code           OPTION_F_MAX_UNACKED_BNDUPD (121)\n    option-len
        \           4\n    max-unacked-bndupd    Maximum number of unacked BNDUPD
        messages\n                          allowed\n"
      title: 5.5.5.  OPTION_F_MAX_UNACKED_BNDUPD
    - contents:
      - "5.5.6.  OPTION_F_MCLT\n   The Maximum Client Lead Time (MCLT) is the upper
        bound on the\n   difference allowed between the valid lifetime provided to
        a DHCP\n   client by a server and the valid lifetime known by that server's\n
        \  failover partner.  It is an interval, measured in seconds.  See\n   Section
        4.4.\n   This is an unsigned 32-bit integer in network byte order.\n   The
        code for this option is 122.\n     0                   1                   2
        \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |         OPTION_F_MCLT         |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                              mclt                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code       OPTION_F_MCLT (122)\n    option-len        4\n    mclt
        \             The MCLT, in seconds\n"
      title: 5.5.6.  OPTION_F_MCLT
    - contents:
      - "5.5.7.  OPTION_F_PARTNER_LIFETIME\n   This option specifies the time after
        which the partner can consider\n   an IPv6 address expired and is able to
        reuse the IPv6 address.\n   This MUST be an absolute time (i.e., seconds since
        midnight\n   January 1, 2000 UTC, modulo 2^32).\n   This is an unsigned 32-bit
        integer in network byte order.\n   The code for this option is 123.\n     0
        \                  1                   2                   3\n     0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |   OPTION_F_PARTNER_LIFETIME   |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        partner-lifetime                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code          OPTION_F_PARTNER_LIFETIME (123)\n    option-len           4\n
        \   partner-lifetime     The partner lifetime.  This MUST be an\n                         absolute
        time (i.e., seconds since midnight\n                         January 1, 2000
        UTC, modulo 2^32).\n"
      title: 5.5.7.  OPTION_F_PARTNER_LIFETIME
    - contents:
      - "5.5.8.  OPTION_F_PARTNER_LIFETIME_SENT\n   This option indicates the time
        that was received in an\n   OPTION_F_PARTNER_LIFETIME option (Section 5.5.7).
        \ This is an exact\n   duplicate (echo) of the time received in the\n   OPTION_F_PARTNER_LIFETIME
        option; it is not adjusted in any way.\n   This MUST be an absolute time (i.e.,
        seconds since midnight\n   January 1, 2000 UTC, modulo 2^32).\n   This is
        an unsigned 32-bit integer in network byte order.\n   The code for this option
        is 124.\n     0                   1                   2                   3\n
        \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |OPTION_F_PARTNER_LIFETIME_SENT |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                      partner-lifetime-sent                    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code              OPTION_F_PARTNER_LIFETIME_SENT (124)\n    option-len
        \              4\n    partner-lifetime-sent    The partner-lifetime received
        in an\n                             OPTION_F_PARTNER_LIFETIME option.\n                             This
        MUST be an absolute time\n                             (i.e., seconds since
        midnight\n                             January 1, 2000 UTC, modulo 2^32).\n"
      title: 5.5.8.  OPTION_F_PARTNER_LIFETIME_SENT
    - contents:
      - "5.5.9.  OPTION_F_PARTNER_DOWN_TIME\n   This option specifies the time that
        the server most recently lost\n   communications with its failover partner.
        \ This MUST be an absolute\n   time (i.e., seconds since midnight January
        1, 2000 UTC, modulo 2^32).\n   This is an unsigned 32-bit integer in network
        byte order.\n   The code for this option is 125.\n     0                   1
        \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |   OPTION_F_PARTNER_DOWN_TIME  |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       partner-down-time                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code          OPTION_F_PARTNER_DOWN_TIME (125)\n    option-len
        \          4\n    partner-down-time    Contains the PARTNER-DOWN time.  This
        MUST be\n                         an absolute time (i.e., seconds since midnight\n
        \                        January 1, 2000 UTC, modulo 2^32).\n"
      title: 5.5.9.  OPTION_F_PARTNER_DOWN_TIME
    - contents:
      - "5.5.10.  OPTION_F_PARTNER_RAW_CLT_TIME\n   This option specifies the time
        when the partner most recently\n   interacted with the DHCP client associated
        with this IPv6 address or\n   prefix.  This MUST be an absolute time (i.e.,
        seconds since midnight\n   January 1, 2000 UTC, modulo 2^32).\n   This is
        an unsigned 32-bit integer in network byte order.\n   The code for this option
        is 126.\n     0                   1                   2                   3\n
        \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | OPTION_F_PARTNER_RAW_CLT_TIME |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                      partner-raw-clt-time                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code             OPTION_F_PARTNER_RAW_CLT_TIME (126)\n    option-len
        \             4\n    partner-raw-clt-time    Contains the partner-raw-clt-time.\n
        \                           This MUST be an absolute time\n                            (i.e.,
        seconds since midnight\n                            January 1, 2000 UTC, modulo
        2^32).\n"
      title: 5.5.10.  OPTION_F_PARTNER_RAW_CLT_TIME
    - contents:
      - "5.5.11.  OPTION_F_PROTOCOL_VERSION\n   The protocol version allows one failover
        partner to determine the\n   version of the protocol being used by the other
        partner, to allow for\n   changes and upgrades in the future.  Two components
        are provided, to\n   allow large and small changes to be represented in one
        32-bit number.\n   The intent is that large changes would result in an increment
        of the\n   value of major-version, while small changes would result in an\n
        \  increment of the value of minor-version.  As subsequent updates and\n   extensions
        of this document can define changes to these values in any\n   way deemed
        appropriate, no attempt is made to further define \"large\"\n   and \"small\"
        in this document.\n   This option consists of two unsigned 16-bit integers
        in network byte\n   order.\n   The code for this option is 127.\n     0                   1
        \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |   OPTION_F_PROTOCOL_VERSION   |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |        major-version          |        minor-version          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code       OPTION_F_PROTOCOL_VERSION (127)\n    option-len        4\n
        \   major-version     The major version of the protocol.  Initially 1.\n    minor-version
        \    The minor version of the protocol.  Initially 0.\n"
      title: 5.5.11.  OPTION_F_PROTOCOL_VERSION
    - contents:
      - "5.5.12.  OPTION_F_KEEPALIVE_TIME\n   This option specifies the number of
        seconds (an interval) within\n   which the server must receive a message from
        its partner, or it will\n   assume that communications from the partner are
        not \"OK\".\n   This is an unsigned 32-bit integer in network byte order.\n
        \  The code for this option is 128.\n     0                   1                   2
        \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |    OPTION_F_KEEPALIVE_TIME    |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                         keepalive-time                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code       OPTION_F_KEEPALIVE_TIME (128)\n    option-len        4\n
        \   receive-time      The keepalive-time.  An interval of seconds.\n"
      title: 5.5.12.  OPTION_F_KEEPALIVE_TIME
    - contents:
      - "5.5.13.  OPTION_F_RECONFIGURE_DATA\n   This option contains the information
        necessary for one failover\n   partner to use the reconfigure-key created
        on the other failover\n   partner.\n   The code for this option is 129.\n
        \    0                   1                   2                   3\n     0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |   OPTION_F_RECONFIGURE_DATA   |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        reconfigure-time                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                                                               .\n    .
        \                                                              .\n    .                        reconfigure-key
        \                       .\n    .                           (variable)                          .\n
        \   .                                                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code         OPTION_F_RECONFIGURE_DATA (129)\n    option-len          4
        + length of reconfigure-key\n    reconfigure-time    Time at which reconfigure-key
        was created.\n                        This MUST be an absolute time\n                        (i.e.,
        seconds since midnight\n                        January 1, 2000 UTC, modulo
        2^32).\n    reconfigure-key     The reconfigure key\n"
      title: 5.5.13.  OPTION_F_RECONFIGURE_DATA
    - contents:
      - "5.5.14.  OPTION_F_RELATIONSHIP_NAME\n   This option specifies a name for
        this failover relationship.  It is\n   used to distinguish between relationships
        when there are multiple\n   failover relationships between two failover servers.\n
        \  This is a UTF-8 encoded text string suitable for display to an end\n   user.
        \ It MUST NOT be null-terminated.\n   The code for this option is 130.\n     0
        \                  1                   2                   3\n     0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |   OPTION_F_RELATIONSHIP_NAME  |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                                                               .\n    .
        \                                                              .\n    .                       relationship-name
        \                      .\n    .                           (variable)                          .\n
        \   .                                                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code          OPTION_F_RELATIONSHIP_NAME (130)\n    option-len
        \          length of relationship-name\n    relationship-name    A UTF-8 encoded
        text string suitable for\n                         display to an end user.
        \ MUST NOT be\n                         null-terminated.\n"
      title: 5.5.14.  OPTION_F_RELATIONSHIP_NAME
    - contents:
      - "5.5.15.  OPTION_F_SERVER_FLAGS\n   The OPTION_F_SERVER_FLAGS option specifies
        information associated\n   with the failover endpoint sending the option.\n
        \  This is an unsigned byte.\n   The code for this option is 131.\n     0
        \                  1                   2                   3\n     0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |     OPTION_F_SERVER_FLAGS     |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  server-flags |\n    +-+-+-+-+-+-+-+-+\n    option-code       OPTION_F_SERVER_FLAGS
        (131)\n    option-len        1\n    server-flags      The server flags.  See
        below:\n     0 1 2 3 4 5 6 7\n    +-+-+-+-+-+-+-+-+\n    |   MBZ   |A|S|C|\n
        \   +-+-+-+-+-+-+-+-+\n    The bits (numbered from the most significant bit
        in network\n    byte order) are used as follows:\n    0-4:   MBZ\n           Must
        be zero.\n    5 (A): ACK_STARTUP\n           Set to 1 to indicate that the
        OPTION_F_SERVER_FLAGS option\n           that was most recently received contained
        the\n           STARTUP bit set.\n    6 (S): STARTUP\n           MUST be set
        to 1 whenever the server is in STARTUP state.\n    7 (C): COMMUNICATED\n           Set
        to 1 to indicate that the sending server has\n           communicated with
        its partner.\n"
      title: 5.5.15.  OPTION_F_SERVER_FLAGS
    - contents:
      - "5.5.16.  OPTION_F_SERVER_STATE\n   The OPTION_F_SERVER_STATE option specifies
        the endpoint state of the\n   server sending the option.\n   This is an unsigned
        byte.\n   The code for this option is 132.\n     0                   1                   2
        \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |     OPTION_F_SERVER_STATE     |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  server-state |\n    +-+-+-+-+-+-+-+-+\n    option-code       OPTION_F_SERVER_STATE
        (132)\n    option-len        1\n    server-state      Failover endpoint state\n
        \  Value   Server State\n   -----   -------------------------------------------------------------\n
        \  0       reserved\n   1       STARTUP                      Startup state
        (1)\n   2       NORMAL                       Normal state\n   3       COMMUNICATIONS-INTERRUPTED
        \  Communications interrupted\n   4       PARTNER-DOWN                 Partner
        down\n   5       POTENTIAL-CONFLICT           Synchronizing\n   6       RECOVER
        \                     Recovering bindings from partner\n   7       RECOVER-WAIT
        \                Waiting out MCLT after RECOVER\n   8       RECOVER-DONE                 Interlock
        state prior to NORMAL\n   9       RESOLUTION-INTERRUPTED       Comm. failed
        during resolution\n   10      CONFLICT-DONE                Primary resolved
        its conflicts\n   These states are discussed in detail in Section 8.\n   (1)
        The STARTUP state is never sent to the partner server; it is\n       indicated
        by the STARTUP bit in the OPTION_F_SERVER_FLAGS option\n       (see Section
        8.3).\n"
      title: 5.5.16.  OPTION_F_SERVER_STATE
    - contents:
      - "5.5.17.  OPTION_F_START_TIME_OF_STATE\n   The OPTION_F_START_TIME_OF_STATE
        option specifies the time at which\n   the associated state began to hold
        its current value.  When this\n   option appears in a STATE message, the state
        to which it refers is\n   the server endpoint state.  When it appears in an
        IA_NA-options,\n   IA_TA-options, or IA_PD-options field, the state to which
        it refers\n   is the binding-status value in the OPTION_IA_NA, OPTION_IA_TA,
        or\n   OPTION_IA_PD option, respectively.  This MUST be an absolute time\n
        \  (i.e., seconds since midnight January 1, 2000 UTC, modulo 2^32).\n   This
        is an unsigned 32-bit integer in network byte order.\n   The code for this
        option is 133.\n     0                   1                   2                   3\n
        \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  OPTION_F_START_TIME_OF_STATE |           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                      start-time-of-state                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code            OPTION_F_START_TIME_OF_STATE (133)\n    option-len
        \            4\n    start-time-of-state    The start time of the current state.\n
        \                          This MUST be an absolute time (i.e., seconds\n
        \                          since midnight January 1, 2000 UTC,\n                           modulo
        2^32).\n"
      title: 5.5.17.  OPTION_F_START_TIME_OF_STATE
    - contents:
      - "5.5.18.  OPTION_F_STATE_EXPIRATION_TIME\n   The OPTION_F_STATE_EXPIRATION_TIME
        option specifies the time at which\n   the current state of this lease will
        expire.  This MUST be an\n   absolute time (i.e., seconds since midnight January
        1, 2000 UTC,\n   modulo 2^32).\n   Note that states other than ACTIVE may
        have a time associated with\n   them.  In particular, EXPIRED might have a
        time associated with it,\n   in the event that some sort of \"grace period\"
        existed where the lease\n   would not be reused for a period after the lease
        expired.  The\n   ABANDONED state might have a time associated with it, in
        the event\n   that the servers participating in failover had a time after
        which an\n   ABANDONED lease might be placed back into a pool for allocation
        to a\n   client.  In general, if there is an OPTION_STATE_EXPIRATION_TIME\n
        \  associated with a particular state, that indicates that the\n   associated
        state will expire and move to a different state at\n   that time.\n   This
        is an unsigned 32-bit integer in network byte order.\n   The code for this
        option is 134.\n     0                   1                   2                   3\n
        \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | OPTION_F_STATE_EXPIRATION_TIME|           option-len          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     state-expiration-time                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   option-code              OPTION_F_STATE_EXPIRATION_TIME (134)\n    option-len
        \              4\n    state-expiration-time    The time at which the current
        state of the\n                             lease will expire.  This MUST be
        an\n                             absolute time (i.e., seconds since midnight\n
        \                            January 1, 2000 UTC, modulo 2^32).\n"
      title: 5.5.18.  OPTION_F_STATE_EXPIRATION_TIME
    title: 5.5.  Options
  - contents:
    - "5.6.  Status Codes\n   The following new status codes are defined to be used
      in the\n   OPTION_STATUS_CODE option.\n   AddressInUse (16)\n      One client
      on one server has leases that are in conflict with the\n      leases that the
      client has on another server.  Alternatively, the\n      address could be associated
      with a different Identity Association\n      Identifier (IAID) on each server.\n
      \  ConfigurationConflict (17)\n      The configuration implied by the information
      in a BNDUPD message\n      (e.g., the IPv6 address or prefix address) is in
      direct conflict\n      with the information known to the receiving server.\n
      \  MissingBindingInformation (18)\n      There is insufficient information in
      a BNDUPD message to\n      effectively process it.\n   OutdatedBindingInformation
      (19)\n      The information in a server's binding database conflicts with the\n
      \     information found in an incoming BNDUPD message and the server\n      believes
      that the information in its binding database more\n      accurately reflects
      reality.\n   ServerShuttingDown (20)\n      The server is undergoing an operator-directed
      or otherwise planned\n      shutdown.\n   DNSUpdateNotSupported (21)\n      A
      server receives a BNDUPD message with DNS update information\n      included
      and the server doesn't support DNS update.\n   ExcessiveTimeSkew (22)\n      A
      server detects that the time skew between its current time and\n      its partner's
      current time is greater than 5 seconds.\n"
    title: 5.6.  Status Codes
  title: 5.  Message and Option Definitions
- contents:
  - "6.  Connection Management\n   Communication between failover partners takes place
    over a long-lived\n   TCP connection.  This connection is always initiated by
    the primary\n   server, and if the long-lived connection is lost it is the\n   responsibility
    of the primary server to attempt to reconnect to the\n   secondary server.  The
    detailed process used by the primary server\n   when initiating a connection and
    by the secondary server when\n   responding to a connection attempt as documented
    in Section 6.1 is\n   followed each time a connection is established, regardless
    of any\n   previous connection between the failover partners.\n"
  - contents:
    - "6.1.  Creating Connections\n   Every primary server implementing the failover
      protocol MUST\n   periodically attempt to create a TCP connection to the dhcp-failover\n
      \  port (647) of all of its configured partners, where the period is\n   implementation
      dependent and SHOULD be configurable.  In the event\n   that a connection has
      been rejected by a CONNECTREPLY message with an\n   OPTION_STATUS_CODE option
      contained in it or a DISCONNECT message, a\n   server SHOULD reduce the frequency
      with which it attempts to connect\n   to that server, but it MUST continue to
      attempt to connect\n   periodically.\n   Every secondary server implementing
      the failover protocol MUST listen\n   for TCP connection attempts on the dhcp-failover
      port (647) from a\n   primary server.\n   After a primary server successfully
      establishes a TCP connection to a\n   secondary server, it MUST continue the
      connection process as\n   described in Section 8.2 of [RFC7653].  In the language
      of that\n   section, the primary failover server operates as the \"requestor\"
      and\n   the secondary failover server operates as the \"DHCP server\".  The\n
      \  message that is sent over the newly established connection is a\n   CONNECT
      message, instead of an ACTIVELEASEQUERY message.\n   When a secondary server
      receives a connection attempt, the only\n   information that the secondary server
      has is the IP address of the\n   partner initiating a connection.  If it has
      any relationships with\n   the connecting server for which it is a secondary
      server, it should\n   operate as described in Section 9.1 of [RFC7653], with
      the exception\n   that instead of waiting for an Active Leasequery message it
      will wait\n   for a CONNECT message.  Once it has received the CONNECT message,
      it\n   will use the information in that message to determine which\n   relationship
      this connection is to service.\n   If it has no secondary relationships with
      the connecting server, it\n   MUST drop the connection.\n   To summarize --
      a primary server MUST use a connection that it has\n   initiated in order to
      send a CONNECT message.  Every server that is a\n   secondary server in a relationship
      MUST listen for CONNECT messages\n   from the primary server.\n   When the CONNECT
      and CONNECTREPLY exchange successfully produces a\n   working failover connection,
      the next message sent over a new\n   connection is a STATE message.  See Section
      6.3.  Upon the receipt of\n   the STATE message, the receiver can consider communications
      \"OK\".\n"
    - contents:
      - "6.1.1.  Sending a CONNECT Message\n   The CONNECT message is sent with information
        about the failover\n   configuration on the primary server.  The message MUST
        contain at\n   least the following information in the options area:\n   o
        \ OPTION_F_PROTOCOL_VERSION containing the protocol version that the\n      primary
        server will use when sending failover messages.\n   o  OPTION_F_MCLT containing
        the configured MCLT.\n   o  OPTION_F_KEEPALIVE_TIME containing the number
        of seconds (an\n      interval) within which the server must receive a message
        from its\n      partner, or it will assume that communications from the partner\n
        \     are not \"OK\".\n   o  OPTION_F_MAX_UNACKED_BNDUPD containing the maximum
        number of\n      BNDUPD messages that this server is prepared to accept over
        the\n      failover connection without causing the connection to block.  This\n
        \     implements application-level flow control over the connection, so\n
        \     that a flood of BNDUPD messages does not cause the connection to\n      block
        and thereby prevent other messages from being transmitted\n      over the
        connection and received by the failover partner.\n   o  OPTION_F_RELATIONSHIP_NAME
        containing the name of the failover\n      relationship to which this connection
        applies.  If there is no\n      OPTION_F_RELATIONSHIP_NAME in the CONNECT
        message, it indicates\n      that there is only a single relationship between
        this pair of\n      primary and secondary servers.\n   o  OPTION_F_CONNECT_FLAGS
        containing information about certain\n      attributes of the connecting servers.\n"
      title: 6.1.1.  Sending a CONNECT Message
    - contents:
      - "6.1.2.  Receiving a CONNECT Message\n   A server receiving a CONNECT message
        must process the information in\n   the message and decide whether or not
        to accept the connection.  The\n   processing is performed as follows:\n   o
        \ sent-time - The secondary server checks the sent-time to see if it\n      is
        within 5 seconds of its current time.  See Section 7.1.  If it\n      is not,
        return ExcessiveTimeSkew in the OPTION_STATUS_CODE to\n      reject the CONNECT
        message.\n   o  OPTION_F_PROTOCOL_VERSION - The secondary server decides if
        the\n      protocol version of the primary server is supported by the\n      secondary
        server.  If it is not, return NotSupported in the\n      OPTION_STATUS_CODE
        to reject the CONNECT message.\n   o  OPTION_F_MCLT - Use this MCLT supplied
        by the primary server.\n      Remember this MCLT, and use it until a different
        MCLT is supplied\n      by some subsequent CONNECT message.\n   o  OPTION_F_KEEPALIVE_TIME
        - Remember the keepalive-time as the\n      FO_KEEPALIVE_TIME (Section 6.5)
        when implementing the\n      Unreachability Detection algorithm described
        in Section 6.6.\n   o  OPTION_F_MAX_UNACKED_BNDUPD - Ensure that the maximum
        amount of\n      unacked BNDUPD messages queued to the primary server never
        exceeds\n      the value in the OPTION_F_MAX_UNACKED_BNDUPD option.\n   o
        \ OPTION_F_CONNECT_FLAGS - Ensure that the secondary server can\n      process
        information from the primary server as specified in the\n      flags.  For
        example, if the secondary server cannot process prefix\n      delegation with
        variable-sized prefixes delegated from the same\n      delegable prefix and
        the primary server says that it can, the\n      secondary should reject the
        connection.\n   A CONNECT message SHOULD always be followed by a CONNECTREPLY\n
        \  message, to either (1) accept the connection or (2) reject the\n   connection
        by including an OPTION_STATUS_CODE option with a\n   status-code indicating
        the reason for the rejection.  If accepting\n   the connection attempt, then
        send a CONNECTREPLY message with the\n   following information:\n   o  OPTION_F_PROTOCOL_VERSION
        containing the protocol version being\n      used by the secondary server
        when sending failover messages.\n   o  OPTION_F_MCLT containing the MCLT currently
        in use on the\n      secondary server.  This MUST equal the MCLT that was
        in the\n      OPTION_F_MCLT option in the CONNECT message.\n   o  OPTION_F_KEEPALIVE_TIME
        containing the number of seconds (an\n      interval) within which the server
        must receive a message from its\n      partner, or it will assume that communications
        from the partner\n      are not \"OK\".\n   o  OPTION_F_MAX_UNACKED_BNDUPD
        containing the maximum number of\n      BNDUPD messages that this server is
        prepared to accept over the\n      failover connection without causing the
        connection to block.  This\n      implements application-level flow control
        over the connection, so\n      that a flood of BNDUPD messages does not cause
        the connection to\n      block and thereby prevent other messages from being
        transmitted\n      over the connection and received by the failover partner.\n
        \  o  OPTION_F_CONNECT_FLAGS containing information describing the\n      attributes
        of the secondary server that the primary needs to\n      know about.\n   After
        sending a CONNECTREPLY message to accept the primary server's\n   CONNECT
        message, the secondary server MUST send a STATE message (see\n   Section 6.3).\n"
      title: 6.1.2.  Receiving a CONNECT Message
    - contents:
      - "6.1.3.  Receiving a CONNECTREPLY Message\n   A server receiving a CONNECTREPLY
        message must process the\n   information in the message and decide whether
        or not to continue to\n   employ the connection.  The processing is performed
        as follows:\n   o  OPTION_F_PROTOCOL_VERSION - The primary server decides
        if the\n      protocol version in use by the secondary server is supported
        by\n      the primary server.  If it is not, send a DISCONNECT message and\n
        \     drop the connection.  If it is supported, continue processing.  It\n
        \     is possible that the primary and secondary servers will each be\n      sending
        different versions of the protocol to the other server.\n      The extent
        to which this is supported will be defined partly by\n      as-yet-unknown
        differences in the protocols that the versions\n      represent and partly
        by the capabilities of the two\n      implementations involved in the failover
        relationship.\n   o  OPTION_F_MCLT - Compare the MCLT received with the configured\n
        \     MCLT.  If they are different, send a DISCONNECT message and drop\n      the
        connection.\n   o  OPTION_F_KEEPALIVE_TIME - Remember the keepalive-time as
        the\n      FO_KEEPALIVE_TIME (Section 6.5) when implementing the\n      Unreachability
        Detection algorithm described in Section 6.6.\n   o  OPTION_F_MAX_UNACKED_BNDUPD
        - Ensure that the maximum amount of\n      unacked BNDUPD messages queued
        to the secondary server never\n      exceeds the value in the OPTION_F_MAX_UNACKED_BNDUPD
        option.\n   o  OPTION_F_CONNECT_FLAGS - Ensure that the primary server can\n
        \     process information from the secondary server as specified in the\n
        \     flags.  For example, if the primary server cannot process prefix\n      delegation
        with variable-sized prefixes delegated from the same\n      delegable prefix
        and the secondary server says that it can, the\n      primary should drop
        the connection.\n   After receiving a CONNECTREPLY message that accepted the
        primary\n   server's CONNECT message, the primary server MUST send a STATE\n
        \  message (see Section 6.3).\n"
      title: 6.1.3.  Receiving a CONNECTREPLY Message
    title: 6.1.  Creating Connections
  - contents:
    - "6.2.  Endpoint Identification\n   A failover endpoint is always associated
      with a set of DHCP prefixes\n   that are configured on the DHCP server where
      the endpoint appears.  A\n   DHCP prefix MUST NOT be associated with more than
      one failover\n   endpoint.\n   The failover protocol SHOULD be configured with
      one failover\n   relationship between each pair of failover servers.  In this
      case,\n   there is one failover endpoint for that relationship on each failover\n
      \  partner.  This failover relationship MUST have a unique name.\n   Any failover
      endpoint can take actions and hold unique states.\n   This document frequently
      describes the behavior of the failover\n   protocol in terms of primary and
      secondary servers, not primary and\n   secondary failover endpoints.  However,
      it is important to remember\n   that every \"server\" described in this document
      is in reality a\n   failover endpoint that resides in a particular process and
      that\n   several failover endpoints may reside in the same server process.\n
      \  It is not the case that there is a unique failover endpoint for each\n   prefix
      that participates in a failover relationship.  On one server,\n   there is (typically)
      one failover endpoint per partner, regardless of\n   how many prefixes are managed
      by that combination of partner and\n   role.  On a particular server, any given
      prefix that participates in\n   failover will be associated with exactly one
      failover endpoint.\n   When a connection is received from the partner, the unique
      failover\n   endpoint to which the message is directed is determined solely
      by the\n   IPv6 address of the partner, the relationship name, and the role
      of\n   the receiving server.\n"
    title: 6.2.  Endpoint Identification
  - contents:
    - "6.3.  Sending a STATE Message\n   A server MUST send a STATE message to its
      failover partner whenever\n   the state of the failover endpoint changes.  Sending
      the occasional\n   duplicate STATE message will not cause any problems; note,
      however,\n   that not updating the failover partner with information about a\n
      \  failover endpoint state change can, in many cases, cause the entire\n   failover
      protocol to be inoperative.\n   The STATE message is sent with information about
      the endpoint state\n   of the failover relationship.  The STATE message MUST
      contain at\n   least the following information in the options area:\n   o  OPTION_F_SERVER_STATE
      containing the state of this failover\n      endpoint.\n   o  OPTION_F_SERVER_FLAGS
      containing the flag values associated with\n      this failover endpoint.\n
      \  o  OPTION_F_START_TIME_OF_STATE containing the time when this became\n      the
      state of this failover endpoint.\n   o  OPTION_F_PARTNER_DOWN_TIME containing
      the time that this failover\n      endpoint went into PARTNER-DOWN state if
      this server is in\n      PARTNER-DOWN state.  If this server isn't in PARTNER-DOWN
      state,\n      do not include this option.\n   The server sending a STATE message
      SHOULD ensure that this\n   information is written to stable storage prior to
      enqueuing it to its\n   failover partner.\n"
    title: 6.3.  Sending a STATE Message
  - contents:
    - "6.4.  Receiving a STATE Message\n   A server receiving a STATE message must
      process the information in\n   the message and decide how to react to the information.
      \ The\n   processing is performed as follows:\n   o  OPTION_F_SERVER_STATE -
      If this represents a change in state for\n      the failover partner, react
      according to the instructions in\n      Section 8.1.  If the state is not PARTNER-DOWN,
      clear any memory\n      of the partner-down-time.\n   o  OPTION_F_SERVER_FLAGS
      - Remember these flags in an appropriate\n      data area so they can be referenced
      later.\n   o  OPTION_F_START_TIME_OF_STATE - Remember this information in an\n
      \     appropriate data area so it can be referenced later.\n   o  OPTION_F_PARTNER_DOWN_TIME
      - If the value of the\n      OPTION_F_SERVER_STATE is PARTNER-DOWN, remember
      this information\n      in an appropriate data area so it can be referenced
      later.\n   A server receiving a STATE message SHOULD ensure that this\n   information
      is written to stable storage.\n"
    title: 6.4.  Receiving a STATE Message
  - contents:
    - "6.5.  Connection Maintenance Parameters\n   The following parameters and timers
      are used to ensure the integrity\n   of the connections between two failover
      servers.\n   Parameter                      Default  Description\n   ---------------------------------------------------------------------\n
      \  FO_KEEPALIVE_TIMER             timer    counts down to time\n                                           connection
      assumed dead\n                                           due to lack of messages\n
      \  FO_KEEPALIVE_TIME              60       maximum time server will\n                                           consider
      connection still up\n                                           with no messages\n
      \  FO_CONTACT_PER_KEEPALIVE_TIME  4        number of CONTACT messages\n                                           to
      send during partner's\n                                           FO_KEEPALIVE_TIME
      period\n   FO_SEND_TIMER                  timer    counts down to time to send\n
      \                                          next CONTACT message\n   FO_SEND_TIME
      \                  15       maximum time to wait between\n                                           sending
      CONTACT messages\n                                           if no other traffic.\n
      \                                          Created from partner's\n                                           FO_KEEPALIVE_TIME
      divided by\n                                           FO_CONTACT_PER_KEEPALIVE_TIME\n"
    title: 6.5.  Connection Maintenance Parameters
  - contents:
    - "6.6.  Unreachability Detection\n   Each partner MUST maintain an FO_SEND_TIMER
      for each failover\n   connection.  The FO_SEND_TIMER for a particular connection
      is reset\n   to FO_SEND_TIME every time any message is transmitted on that\n
      \  connection, and the timer counts down once per second.  If the timer\n   reaches
      zero, a CONTACT message is transmitted on that connection and\n   the timer
      for that connection is reset to FO_SEND_TIME.  The CONTACT\n   message may be
      transmitted at any time.  An implementation MAY use\n   additional mechanisms
      to detect partner unreachability.\n   The FO_SEND_TIME is initialized from the
      configured FO_KEEPALIVE_TIME\n   divided by FO_CONTACT_PER_KEEPALIVE_TIME.  When
      a CONNECT or\n   CONNECTREPLY message is received on a connection, the received\n
      \  OPTION_F_KEEPALIVE_TIME option is checked, and the value in that\n   option
      is used to calculate the FO_SEND_TIME for that connection by\n   dividing the
      value received by the configured\n   FO_CONTACT_PER_KEEPALIVE_TIME.\n   Each
      partner MUST maintain an FO_KEEPALIVE_TIMER for each failover\n   connection.
      \ This timer is initialized to FO_KEEPALIVE_TIME and\n   counts down once per
      second.  It is reset to FO_KEEPALIVE_TIME\n   whenever a message is received
      on that connection.  If it ever\n   reaches zero, that connection is considered
      dead.  In addition, the\n   FO_KEEPALIVE_TIME for that connection MUST be sent
      to the failover\n   partner on every CONNECT or CONNECTREPLY message in the\n
      \  OPTION_F_KEEPALIVE_TIME option.\n"
    title: 6.6.  Unreachability Detection
  title: 6.  Connection Management
- contents:
  - '7.  Binding Updates and Acks

    '
  - contents:
    - "7.1.  Time Skew\n   Partners exchange information about known lease states.
      \ To reliably\n   compare a known lease state with an update received from a
      partner,\n   servers must be able to reliably compare the times stored in the\n
      \  known lease state with the times received in the update.  The\n   failover
      protocol adopts the simple approach of requiring that the\n   failover partners
      use some mechanism to synchronize the clocks on the\n   two servers to within
      an accuracy of roughly 5 seconds.\n   A mechanism to measure and track relative
      time differences between\n   servers is necessary to ensure this synchronization.
      \ To do so, each\n   message contains the time of the transmission in the sent-time
      field\n   of the message (see Section 5.2).  The transmitting server MUST set\n
      \  this as close to the actual transmission as possible.  The receiving\n   partner
      MUST store its own timestamp of reception as close to the\n   actual reception
      as possible.  The received timestamp information is\n   then compared with the
      local timestamp.\n"
    title: 7.1.  Time Skew
  - contents:
    - "7.2.  Information Model\n   In most DHCP servers, a lease on an IPv6 address
      or a prefix can take\n   on several different binding-status values, sometimes
      also called\n   \"lease states\".  While no two DHCP server implementations
      will have\n   exactly the same possible binding-status values, [RFC3315] enforces\n
      \  some commonality among the general semantics of the binding-status\n   values
      used by various DHCP server implementations.\n   In order to transmit binding
      database updates between one server and\n   another using the failover protocol,
      some common binding-status\n   values must be defined.  It is not expected that
      these values\n   correspond to any actual implementation of DHCPv6 in a DHCP
      server,\n   but rather that the binding-status values defined in this document\n
      \  should be convertible back and forth between those defined below and\n   those
      in use by many DHCP server implementations.\n   The lease binding-status values
      defined for the failover protocol are\n   listed below.  Unless otherwise noted
      below, there MAY be client\n   information associated with each of these binding-status
      values.\n   ACTIVE - The lease is assigned to a client.  Client identification\n
      \     data MUST appear.\n   EXPIRED - This value indicates that a client's binding
      on a given\n      lease has expired.  When the partner acks the BNDUPD message
      of an\n      expired lease, the server sets its internal state to PENDING-FREE.\n
      \     Client identification SHOULD appear.\n   RELEASED - This value indicates
      that a client sent a RELEASE message.\n      When the partner acks the BNDUPD
      message of a released lease, the\n      server sets its internal state to PENDING-FREE.
      \ Client\n      identification SHOULD appear.\n   PENDING-FREE - Once a lease
      is expired or released, its state becomes\n      PENDING-FREE.  Depending on
      which algorithm was used to allocate a\n      given lease, PENDING-FREE may
      mean either FREE or FREE-BACKUP.\n      Implementations do not have to implement
      this PENDING-FREE state\n      but may choose to switch to the destination state
      directly.  For\n      clarity of representation, this transitional PENDING-FREE
      state is\n      treated as a separate state.\n   FREE - This value is used when
      a DHCP server needs to communicate\n      that a lease is unused by any client,
      but it was not just\n      released, expired, or reset by a network administrator.
      \ When the\n      partner acks the BNDUPD message of a FREE lease, the server
      marks\n      the lease as available for assignment by the primary server.  Note\n
      \     that on a secondary server running in PARTNER-DOWN state, after\n      waiting
      the MCLT, the lease MAY be allocated to a client by the\n      secondary server.
      \ Client identification MAY appear and indicates,\n      as a hint, the last
      client to have used this lease.\n   FREE-BACKUP - This value indicates that
      this lease can be allocated\n      by the secondary server to a client at any
      time.  Note that on the\n      primary server running in PARTNER-DOWN state,
      after waiting the\n      MCLT, the lease MAY be allocated to a client by the
      primary server\n      if the proportional algorithm was used.  Client identification
      MAY\n      appear and indicates, as a hint, the last client to have used this\n
      \     lease.\n   ABANDONED - This value indicates that a lease is considered
      unusable\n      by the DHCP system.  The primary reason for entering such a
      state\n      is the reception of a DECLINE message for the lease.  Client\n
      \     identification MAY appear.\n   RESET - This value indicates that this
      lease was made available by an\n      operator command.  This is a distinct
      state so that the reason\n      that the lease became FREE can be determined.
      \ Client\n      identification MAY appear.\n   Which binding-status values are
      associated with a timeout is\n   implementation dependent.  Some binding-status
      values, such as\n   ACTIVE, will have a timeout value in all implementations,
      while\n   others, such as ABANDONED, will have a timeout value in some\n   implementations
      and not in others.  In some implementations, a\n   binding-status value may
      be associated with a timeout in some\n   circumstances and not in others.  The
      receipt of a BNDUPD message\n   with a particular binding-status value and an\n
      \  OPTION_F_STATE_EXPIRATION_TIME indicates that this particular\n   binding-status
      value is associated with a timeout.\n   The lease state machine is presented
      in Figure 2.  Most states are\n   stationary, i.e., the lease stays in a given
      state until an external\n   event triggers transition to another state.  The
      only transitive\n   state is PENDING-FREE.  Once it is reached, the state machine\n
      \  immediately transitions to either FREE or FREE-BACKUP state.\n                               +---------+\n
      \               /------------->|  ACTIVE |<--------------\\\n                |
      \             +---------+               |\n                |                |
      \ |  |                 |\n                |       /--(8)--/  (3)  \\--(9)-\\
      \        |\n                |      |            |           |        |\n                |
      \     V            V           V        |\n                |  +-------+   +--------+
      \  +---------+  |\n                |  |EXPIRED|   |RELEASED|   |ABANDONED|  |\n
      \               |  +-------+   +--------+   +---------+  |\n                |
      \     |            |            |       |\n                |      |            |
      \          (10)     |\n                |      |            |            V       |\n
      \               |      |            |       +---------+  |\n                |
      \     |            |       |  RESET  |  |\n                |      |            |
      \      +---------+  |\n                |      |            |            |       |\n
      \               |       \\--(4)--\\  (4)  /--(4)--/        |\n                |
      \               |  |  |                 |\n               (1)               V
      \ V  V                (2)\n                |              /---------\\               |\n
      \               |              | PENDING-|               |\n                |
      \             |  FREE   |               |\n                |              \\---------/
      \              |\n                |                 |   |                  |\n
      \               |         /-(5)--/     \\-(6)-\\           |\n                |
      \       |                    |          |\n                |        V                    V
      \         |\n                |    +-------+         +-----------+     |\n                \\----|
      \ FREE |<--(7)-->|FREE-BACKUP|-----/\n                     +-------+         +-----------+\n
      \                         PENDING-FREE transition\n                       Figure
      2: Lease State Machine\n   Transitions between states will result from the following
      events:\n   (1)   The primary server allocates a lease.\n   (2)   The secondary
      server allocates a lease.\n   (3)   The client sends RELEASE, and the lease
      is released.\n   (4)   The partner acknowledges the state change.  This transition
      MAY\n         also occur if the server is in PARTNER-DOWN state and the MCLT\n
      \        has passed since the entry into RELEASED, EXPIRED, or RESET\n         states.\n
      \  (5)   The lease belongs to a pool that is governed by proportional\n         allocation,
      or independent allocation is used and this lease\n         belongs to the primary
      server's pool.\n   (6)   The lease belongs to a pool that is governed by independent\n
      \        allocation, and the lease belongs to the secondary server.\n   (7)
      \  A pool rebalance event occurs (POOLREQ/POOLRESP messages are\n         exchanged).
      \ Delegable prefixes belonging to the primary server\n         can be assigned
      to the secondary server's pool (transition from\n         FREE to FREE-BACKUP)
      or vice versa.\n   (8)   The lease has expired.\n   (9)   A DECLINE message
      is received, or a lease is deemed unusable\n         for other reasons.\n   (10)
      \ An administrative action is taken to restore an abandoned lease\n         to
      a usable state.  This transition MAY occur due to\n         implementation-specific
      handling of an ABANDONED lease.  One\n         possible example of this is a
      Neighbor Discovery or ICMPv6 Echo\n         check to see if the address is still
      in use.\n   The lease that is no longer in use (due to expiration or release)\n
      \  becomes PENDING-FREE.  Depending on what allocation algorithm is\n   used,
      the lease that is no longer in use returns to the primary pool\n   (FREE) or
      the secondary pool (FREE-BACKUP).  The conditions for\n   specific transitions
      are depicted in Figure 3.\n                 +----------------+---------+-----------+\n
      \                | \\   Lease owner|         |           |\n                 |
      \ \\----------\\  | Primary | Secondary |\n                 |Algorithm     \\
      |         |           |\n                 +----------------+---------+-----------+\n
      \                | Proportional   | FREE    |FREE-BACKUP|\n                 |
      Independent    | FREE    |    FREE   |\n                 +----------------+---------+-----------+\n
      \                Figure 3: PENDING-FREE State Transitions\n"
    title: 7.2.  Information Model
  - contents:
    - "7.3.  Times Required for Exchanging Binding Updates\n   Each server must keep
      track of the following specific times beyond\n   those required by the base
      DHCP specification [RFC3315].\n   expiration-time\n      The greatest lifetime
      that this server has ever acked to its\n      failover partner in a BNDREPLY
      message.\n   acked-partner-lifetime\n      The greatest lifetime that the failover
      partner has ever acked to\n      this server in a BNDREPLY message.\n   partner-lifetime\n
      \     The time value that will be sent (or that has been sent) to the\n      partner
      to indicate the time after which the partner can consider\n      the lease expired.
      \ When a BNDUPD message is received, this value\n      can be updated from the
      received OPTION_F_EXPIRATION_TIME.\n   client-last-transaction-time\n      The
      time when this server most recently interacted with the client\n      associated
      with this lease.\n   partner-raw-clt-time\n      The time when the partner most
      recently interacted with the client\n      associated with this lease.  This
      time remains exactly as it was\n      received by this server and MUST NOT be
      adjusted in any way.\n   start-time-of-state\n      The time when the binding-status
      of this lease was changed to its\n      current value.\n   state-expiration-time\n
      \     The time when the current state of this lease will expire.\n"
    title: 7.3.  Times Required for Exchanging Binding Updates
  - contents:
    - "7.4.  Sending Binding Updates\n   Every BNDUPD message contains information
      about either (1) a single\n   client binding in an OPTION_CLIENT_DATA option
      that includes IAADDR\n   or IAPREFIX options associated with that client or
      (2) a single\n   prefix lease in an OPTION_IAPREFIX option for prefixes that
      are\n   currently not associated with any clients.\n   All information about
      a particular client binding MUST be contained\n   in a single OPTION_CLIENT_DATA
      option (see Section 4.1.2.2 of\n   [RFC5007]).  The OPTION_CLIENT_DATA option
      contains at least the data\n   shown below in its client-options section:\n
      \  o  OPTION_CLIENTID containing the DUID of the client most recently\n      associated
      with this lease MUST appear.\n   o  OPTION_LQ_BASE_TIME containing the absolute
      time that the\n      information was placed in this OPTION_CLIENT_DATA option
      (see\n      Section 6.3.1 of [RFC7653]) MUST appear.\n   o  OPTION_VSS (see
      Section 3.4 of [RFC6607]).  This option MUST NOT\n      appear if the information
      in this OPTION_CLIENT_DATA option is\n      associated with the global, default
      VPN.  This option MUST appear\n      if the information in this OPTION_CLIENT_DATA
      option is associated\n      with a VPN other than the global, default VPN.  Support
      of\n      [RFC6607] is not required, and if it is not supported, then an\n      OPTION_VSS
      MUST NOT appear.  If [RFC6607] is supported, then an\n      OPTION_VSS MUST
      appear if and only if a VPN other than the global,\n      default VPN is used.\n
      \  o  OPTION_F_RECONFIGURE_DATA containing the time and reconfigure key,\n      if
      any.\n   o  OPTION_LQ_RELAY_DATA containing information described in\n      Section
      4.1.2.4 of [RFC5007], if any exists.\n   o  OPTION_IA_NA or OPTION_IA_TA for
      an IPv6 address, or OPTION_IA_PD\n      for an IPv6 prefix.  More than one of
      either of these options MAY\n      appear if more than one of them are associated
      with this client.\n      At least one of an OPTION_IA_NA, OPTION_IA_TA, or OPTION_IA_PD\n
      \     must appear.\n      *  IAID - Identity Association used by the client,
      while obtaining\n         a given lease.  Note that (1) one client may use many
      IAIDs\n         simultaneously and (2) IAIDs for OPTION_IA_NA, OPTION_IA_TA,\n
      \        and OPTION_IA_PD are orthogonal number spaces.\n      *  T1 time sent
      to client.\n      *  T2 time sent to client.\n      *  Inside of the IA_NA-options,
      IA_TA-options, or IA_PD-options\n         sections:\n         +  OPTION_IAADDR
      for an IPv6 address or an OPTION_IAPREFIX for\n            an IPv6 prefix MUST
      appear.\n            -  IPv6 address or IPv6 prefix (with length).\n            -
      \ Preferred lifetime sent to client.\n            -  Valid lifetime sent to
      client.\n            -  Inside of the IAaddr-options or IAprefix-options:\n
      \              o  OPTION_F_BINDING_STATUS containing the binding-status\n                  MUST
      appear.\n               o  OPTION_F_START_TIME_OF_STATE containing the\n                  start-time-of-state
      MUST appear.\n               o  OPTION_F_STATE_EXPIRATION_TIME (absolute) containing\n
      \                 the state-expiration-time*.\n               o  OPTION_CLT_TIME
      (relative) containing the\n                  client-last-transaction-time.  See
      [RFC5007] for a\n                  description of this option.\n               o
      \ OPTION_F_PARTNER_LIFETIME (absolute) containing the\n                  partner-lifetime*.\n
      \              o  OPTION_F_PARTNER_RAW_CLT_TIME (absolute) containing\n                  the
      partner-raw-clt-time.\n               o  OPTION_F_EXPIRATION_TIME (absolute)
      containing the\n                  expiration-time*.\n               o  OPTION_CLIENT_FQDN
      containing the FQDN information\n                  associated with this lease
      and client, if any.\n   Information about a prefix lease is contained in a single\n
      \  OPTION_IAPREFIX option.  Only a single OPTION_IAPREFIX option may\n   appear
      in a BNDUPD message outside of an OPTION_CLIENT_DATA option.\n   In detail:\n
      \  o  OPTION_IAPREFIX for a prefix lease.\n      *  IPv6 prefix (with length).\n
      \     *  Inside of the IAprefix-options section:\n         +  OPTION_VSS (see
      Section 3.4 of [RFC6607]).  This option\n            MUST NOT appear if the
      information in this OPTION_IAPREFIX\n            option is associated with the
      global, default VPN.  This\n            option MUST appear if the information
      in this\n            OPTION_IAPREFIX option is associated with a VPN other than\n
      \           the global, default VPN.  Support of [RFC6607] is not\n            required,
      and if it is not supported, then an OPTION_VSS\n            MUST NOT appear.
      \ If [RFC6607] is supported, then an\n            OPTION_VSS MUST appear if
      and only if a VPN other than the\n            global, default VPN is used.\n
      \        +  OPTION_LQ_BASE_TIME containing the absolute time that this\n            information
      was placed in this OPTIONS_IAPREFIX option (see\n            Section 6.3.1 of
      [RFC7653]) MUST appear.\n         +  OPTION_F_BINDING_STATUS containing the
      binding-status MUST\n            appear.\n         +  OPTION_F_START_TIME_OF_STATE
      containing the\n            start-time-of-state MUST appear.\n         +  OPTION_F_STATE_EXPIRATION_TIME
      (absolute) containing the\n            state-expiration-time*.\n         +  OPTION_F_PARTNER_LIFETIME
      (absolute) containing the\n            partner-lifetime*.\n         +  OPTION_F_EXPIRATION_TIME
      (absolute) containing the\n            expiration-time*.\n   Items marked with
      a single asterisk (*) MUST appear only if the value\n   in the OPTION_F_BINDING_STATUS
      is associated with a timeout;\n   otherwise, it MUST NOT appear.  See Section
      7.2 for details.\n   The OPTION_CLT_TIME MUST, if it appears, be the time that
      the server\n   last interacted with the DHCP client.  It MUST NOT be, for instance,\n
      \  the time that the lease expired if there has been no interaction with\n   the
      DHCP client in question.\n   A server SHOULD be prepared to clean up DNS information
      once the\n   lease expires or is released.  See Section 9 for a detailed\n   discussion
      about DNS update.  Another reason the partner may be\n   interested in keeping
      additional data is to enable better support for\n   Leasequery [RFC5007], Bulk
      Leasequery [RFC5460], or Active Leasequery\n   [RFC7653], some of which feature
      queries based on Relay-ID, link\n   address, or Remote-ID.\n"
    title: 7.4.  Sending Binding Updates
  - contents:
    - '7.5.  Receiving Binding Updates

      '
    - contents:
      - "7.5.1.  Monitoring Time Skew\n   The sent-time from the failover message
        is compared with the current\n   time of the receiving server as recorded
        when it received the\n   message.  The difference is noted, and if it is greater
        than\n   5 seconds the receiving server SHOULD drop the connection.  A message\n
        \  SHOULD be logged to signal the reason for the connection being\n   dropped.\n
        \  Any time can be before, after, or essentially the same as another\n   time.
        \ Any time that ends up being +/- 5 seconds of another time\n   SHOULD be
        considered to be representing the same time when performing\n   a comparison
        between two times.\n"
      title: 7.5.1.  Monitoring Time Skew
    - contents:
      - "7.5.2.  Acknowledging Reception\n   Upon acceptance of a binding update,
        the server MUST notify its\n   partner that it has processed the binding update
        (and updated its\n   lease state database if necessary) by sending a BNDREPLY
        message.  A\n   server MUST NOT send the BNDREPLY message before its binding
        database\n   is updated.\n"
      title: 7.5.2.  Acknowledging Reception
    - contents:
      - "7.5.3.  Processing Binding Updates\n   When a BNDUPD message is received,
        it MUST contain either a single\n   OPTION_CLIENT_DATA option or a single
        OPTION_IAPREFIX option.\n   When analyzing a BNDUPD message from a partner
        server, if there is\n   insufficient information in the BNDUPD message to
        process it, then it\n   is rejected with an OPTION_STATUS_CODE of\n   \"MissingBindingInformation\".\n
        \  The server receiving a BNDUPD message from its partner must evaluate\n
        \  the received information in each OPTION_CLIENT_DATA or IAPREFIX\n   option
        to see if it is consistent with the server's already-known\n   state and,
        if it is not, decide to accept or reject the information.\n   Section 7.5.4
        provides details regarding how the server makes this\n   determination.\n
        \  A server receiving a BNDUPD message MUST respond to the sender of\n   that
        message with a BNDREPLY message that contains the same\n   transaction-id
        as the BNDUPD message.  This BNDREPLY message MUST\n   contain either a single
        OPTION_CLIENT_DATA option or a single\n   OPTION_IAPREFIX option, corresponding
        to whatever was received in the\n   BNDUPD message.\n   An OPTION_CLIENT_DATA
        option or an OPTION_IAPREFIX option in the\n   BNDREPLY message that is accepted
        SHOULD NOT contain an\n   OPTION_STATUS_CODE unless a status message needs
        to be sent to the\n   failover partner, in which case it SHOULD include an\n
        \  OPTION_STATUS_CODE option with a status-code indicating success and\n   whatever
        message is needed.\n   To indicate rejection of the information in an OPTION_CLIENT_DATA\n
        \  option or an OPTION_IAPREFIX option, an OPTION_STATUS_CODE SHOULD be\n
        \  included with a status-code indicating an error in the\n   OPTION_CLIENT_DATA
        option or OPTION_IAPREFIX option in the BNDREPLY\n   message.\n"
      title: 7.5.3.  Processing Binding Updates
    - contents:
      - "7.5.4.  Accept or Reject?\n   The first task in processing the information
        in an OPTION_CLIENT_DATA\n   option or OPTION_IAPREFIX option is to extract
        the client information\n   (if any) and lease information out of the option
        and to access the\n   address lease or prefix lease information in the server's
        binding\n   database.\n   If an OPTION_VSS option is specified in the OPTION_CLIENT_DATA
        option\n   or OPTION_IAPREFIX option and the VPN specified in the OPTION_VSS\n
        \  option does not appear in the configuration of the receiving server,\n
        \  then reject the entire OPTION_CLIENT_DATA option or OPTION_IAPREFIX\n   option
        by including an OPTION_STATUS_CODE option with a status-code\n   of \"ConfigurationConflict\".\n
        \  If the lease specified in the OPTION_CLIENT_DATA option or\n   OPTION_IAPREFIX
        option is not a lease associated with the failover\n   endpoint that received
        the OPTION_CLIENT_DATA option, then reject it\n   by including an OPTION_STATUS_CODE
        option with a status-code of\n   \"ConfigurationConflict\".\n   In general,
        acceptance or rejection is based on the comparison of two\n   different time
        values -- one from the OPTION_CLIENT_DATA option or\n   OPTION_IAPREFIX option
        in the BNDUPD message, and one from the\n   receiving server's binding database
        associated with the address or\n   prefix lease found in the BNDUPD message.
        \ The time for the BNDUPD\n   message where the OPTION_F_BINDING_STATUS is
        ACTIVE, EXPIRED, or\n   RELEASED is the OPTION_CLT_TIME if one appears, or
        the\n   OPTION_F_START_TIME_OF_STATE if one does not.  For other\n   binding-status
        values, the time for the BNDUPD message is the\n   later of (1) the OPTION_CLT_TIME
        if one appears or (2) the\n   OPTION_F_START_TIME_OF_STATE.  The time for
        the lease in the server's\n   binding database is the client-last-transaction-time
        if one appears,\n   or the start-time-of-state if one does not.\n   The basic
        approach is to compare these times, and if the one from the\n   BNDUPD message
        is clearly later, then accept the information in the\n   OPTION_CLIENT_DATA
        option or OPTION_IAPREFIX option.  If the one from\n   the server's binding
        database is clearly later, then reject the\n   information in the BNDUPD message.
        \ The challenge comes when they are\n   essentially the same (i.e., +/- 5
        seconds).  In this case, they are\n   considered identical, despite the minor
        differences.  Figure 4 shows\n   a table containing the rules for dealing
        with all of these\n   situations.\n                          binding-status
        in received OPTION_CLIENT_DATA\n                                                     or
        OPTION_IAPREFIX\n   binding-status in\n   receiving server's                                 FREE
        \       RESET\n   lease state DB   ACTIVE   EXPIRED   RELEASED   FREE-BACKUP
        \ ABANDONED\n   ---------------------------------------------------------------------\n
        \  ACTIVE           accept(3) time(1)   accept     time(1)      accept\n   EXPIRED
        \         accept    accept    accept     accept       accept\n   RELEASED
        \        accept    accept    accept     accept       accept\n   FREE/FREE-BACKUP
        accept    accept    accept     accept       accept\n   RESET            time(2)
        \  accept    accept     accept       accept\n   ABANDONED        accept    accept
        \   accept     accept       accept\n                       Figure 4: Conflict
        Resolution\n   accept:  If the time value in the OPTION_CLIENT_DATA option
        or\n      OPTION_IAPREFIX option is later than the time value in the\n      server's
        binding database, accept it, else reject it.\n   time(1):  If the current
        time is later than the receiving server's\n      state-expiration-time, accept
        it, else reject it.\n   time(2):  If the OPTION_CLT_TIME value (if it appears)
        in the\n      OPTION_CLIENT_DATA is later than the start-time-of-state in
        the\n      receiving server's binding, accept it, else reject it.\n   accept,time(1),time(2):
        \ If rejecting, use a status-code of\n      \"OutdatedBindingInformation\".\n
        \  accept(3):  If the clients in an OPTION_CLIENT_DATA option and in a\n      receiving
        server's binding differ, then if time(2) or the\n      receiving server is
        a secondary accept it, else reject it with a\n      status-code of \"AddressInUse\".
        \ If the clients match, accept the\n      update.\n   The lease update may
        be accepted or rejected.  If a lease is rejected\n   with \"OutdatedBindingInformation\",
        then the flag in the lease that\n   indicates that the partner should be updated
        with the information in\n   this lease SHOULD be set; otherwise, it SHOULD
        NOT be changed.  If\n   this flag was previously not set, then an update MAY
        be transmitted\n   immediately to the partner (though the BNDREPLY to this
        BNDUPD\n   message SHOULD be sent first).  If this flag was previously set,
        an\n   update SHOULD NOT be transmitted immediately to the partner.  In this\n
        \  case, an update will be sent during the next periodic scan, but not\n   immediately,
        thus preventing a possible update storm should the\n   servers be unable to
        agree.  Ultimately, the server with the most\n   recent binding information
        should have its update accepted by its\n   partner.\n"
      title: 7.5.4.  Accept or Reject?
    - contents:
      - "7.5.5.  Accepting Updates\n   When the information in an OPTION_CLIENT_DATA
        option or\n   OPTION_IAPREFIX option has been accepted, some of that information
        is\n   stored in the receiving server's binding database, and a\n   corresponding
        OPTION_CLIENT_DATA option or OPTION_IAPREFIX option is\n   entered into a
        BNDREPLY message.  The information to enter into the\n   OPTION_CLIENT_DATA
        option or OPTION_IAPREFIX option in the BNDREPLY\n   message is described
        in Section 7.6.\n   The information contained in an accepted OPTION_CLIENT_DATA
        option is\n   stored in the receiving server's binding database as follows:\n
        \  1.  The OPTION_CLIENTID is used to find the client.\n   2.  The other data
        contained in the top level of the\n       OPTION_CLIENT_DATA option is stored
        with the client as\n       appropriate.\n   3.  For each of the OPTION_IA_NA,
        OPTION_IA_TA, or OPTION_IA_PD\n       options in the OPTION_CLIENT_DATA option
        and for each of the\n       OPTION_IAADDR or OPTION_IAPREFIX options in the
        IA_* options:\n       a.  OPTION_F_BINDING_STATUS is stored as the binding-status.\n
        \      b.  OPTION_F_PARTNER_LIFETIME is stored in the expiration-time.\n       c.
        \ OPTION_F_STATE_EXPIRATION_TIME is stored in the\n           state-expiration-time.\n
        \      d.  OPTION_CLT_TIME [RFC5007] is stored in the\n           partner-raw-clt-time.\n
        \      e.  OPTION_F_PARTNER_RAW_CLT_TIME replaces the\n           client-last-transaction-time
        if it is later than the current\n           client-last-transaction-time.\n
        \      f.  OPTION_F_EXPIRATION_TIME replaces the partner-lifetime if it\n
        \          is later than the current partner-lifetime.\n   The information
        contained in an accepted single OPTION_IAPREFIX\n   option that is not contained
        in an OPTION_CLIENT_DATA option is\n   stored in the receiving server's binding
        database as follows:\n   1.  The IPv6 prefix is used to find the prefix.\n
        \  2.  Inside of the IAprefix-options section:\n       a.  OPTION_F_BINDING_STATUS
        is stored as the binding-status.\n       b.  OPTION_F_PARTNER_LIFETIME (if
        any) is stored in the\n           expiration-time.\n       c.  OPTION_F_STATE_EXPIRATION_TIME
        (if any) is stored in the\n           state-expiration-time.\n       d.  OPTION_F_EXPIRATION_TIME
        (if any) replaces the\n           partner-lifetime if it is later than the
        current\n           partner-lifetime.\n"
      title: 7.5.5.  Accepting Updates
    title: 7.5.  Receiving Binding Updates
  - contents:
    - "7.6.  Sending Binding Replies\n   A server MUST respond to every BNDUPD message
      with a BNDREPLY\n   message.  The BNDREPLY message MUST contain an OPTION_CLIENT_DATA\n
      \  option if the BNDUPD message contained an OPTION_CLIENT_DATA option,\n   or
      it MUST contain an OPTION_IAPREFIX option if the BNDUPD message\n   contained
      an OPTION_IAPREFIX option.  The BNDREPLY message MUST have\n   the same transaction-id
      as the BNDUPD message to which it is a\n   response.\n   Acceptance or rejection
      of all of or a particular part of the BNDUPD\n   message is signaled with an
      OPTION_STATUS_CODE option.  An\n   OPTION_STATUS_CODE option containing a status-code
      representing an\n   error is significant, while an OPTION_STATUS_CODE option
      whose\n   status-code contains success is considered informational but does
      not\n   affect the processing of the BNDREPLY message when it is received by\n
      \  the server that sent the BNDUPD message.\n   Rejection of all of or part
      of the information in a BNDUPD message is\n   signaled in a BNDREPLY message
      by using the OPTION_STATUS_CODE\n   message with an error in the status-code
      field.  This rejection can\n   take place at either of two levels -- the top
      level of the option\n   hierarchy or the bottom level of the option hierarchy:\n
      \  1.  Entire BNDUPD: The OPTION_STATUS_CODE containing an error is\n       present
      in the outermost option of the BNDREPLY message -- either\n       the single
      OPTION_CLIENT_DATA option or the single\n       OPTION_IAPREFIX option.  An
      example of this sort of error might\n       be that an OPTION_VSS option was
      present and specified a VPN that\n       might not exist in the receiving server.\n
      \  2.  Single address or prefix: The OPTION_STATUS_CODE containing an\n       error
      is present in a single IAADDR or IAPREFIX option that is\n       itself contained
      in an OPTION_IA_NA, OPTION_IA_TA, or\n       OPTION_IA_PD option.  An example
      of this sort of error might be\n       that a particular IPv6 address was specified
      in an IAADDR option\n       that doesn't appear in the receiving server's configuration.\n
      \  Rejection occurring at either of these levels indicates rejection of\n   all
      of the information contained in the option (including any other\n   options
      contained in that option) where the OPTION_STATUS_CODE option\n   containing
      an error appears.  The converse is not true -- an\n   OPTION_STATUS_CODE option
      containing success does not signify that\n   all of the contained information
      has been accepted.\n   If the BNDREPLY message contains an OPTION_CLIENT_DATA
      option, then\n   the OPTION_CLIENT_DATA option MUST contain at least the data
      shown\n   below in its client-options section:\n   o  OPTION_CLIENTID containing
      the DUID of the client most recently\n      associated with this IPv6 address.\n
      \  o  OPTION_VSS from the BNDUPD message, if any.\n   o  OPTION_IA_NA or OPTION_IA_TA
      for an IPv6 address or OPTION_IA_PD\n      for an IPv6 prefix.  More than one
      of either of these options MAY\n      appear if there are more than one of them
      associated with this\n      client.\n      *  Inside of the IA_NA-options, IA_TA-options,
      or IA_PD-options\n         sections:\n         +  OPTION_IAADDR for an IPv6
      address or an OPTION_IAPREFIX for\n            an IPv6 prefix.\n            -
      \ IPv6 address or IPv6 prefix (with length).\n            -  Inside of the IAaddr-options
      or IAprefix-options:\n               o  OPTION_STATUS_CODE containing an error
      code, or\n                  containing a success code if a message is required.\n
      \                 An OPTION_STATUS_CODE option SHOULD NOT appear with a\n                  success
      code unless a message associated with the\n                  success code needs
      to be included.  The lack of an\n                  OPTION_STATUS_CODE option
      is an indication of success.\n               o  OPTION_F_BINDING_STATUS containing
      the binding-status\n                  received in the BNDUPD message.\n               o
      \ OPTION_F_STATE_EXPIRATION_TIME (absolute) containing\n                  the
      state-expiration-time received in the BNDUPD\n                  message.\n               o
      \ OPTION_F_PARTNER_LIFETIME_SENT (absolute) containing a\n                  duplicate
      of the OPTION_F_PARTNER_LIFETIME received in\n                  the BNDUPD message.\n
      \  If the BNDREPLY message contains a single OPTION_IAPREFIX option not\n   contained
      in an OPTION_CLIENT_DATA option, then the OPTION_IAPREFIX\n   option MUST contain
      at least the data shown below:\n   o  IPv6 prefix (with length).\n   o  IAprefix-options:\n
      \     *  OPTION_VSS from the BNDUPD message, if any.\n      *  OPTION_STATUS_CODE
      containing an error code, or containing a\n         success code if a message
      is required.  If the information in\n         the corresponding OPTION_IAPREFIX
      in the BNDUPD message was\n         accepted and no status message was required
      (which is the usual\n         case), no OPTION_STATUS_CODE option appears.\n
      \     *  OPTION_F_BINDING_STATUS containing the binding-status received\n         in
      the BNDREPLY message.\n      *  OPTION_F_STATE_EXPIRATION_TIME (absolute) containing
      the\n         state-expiration-time received in the BNDREPLY message.\n      *
      \ OPTION_F_PARTNER_LIFETIME_SENT (absolute) containing a\n         duplicate
      of the OPTION_F_PARTNER_LIFETIME received in the\n         BNDREPLY message.\n"
    title: 7.6.  Sending Binding Replies
  - contents:
    - "7.7.  Receiving Binding Acks\n   When a BNDREPLY message is received, the overall
      OPTION_CLIENT_DATA\n   option or the overall OPTION_IAPREFIX option may contain
      an\n   OPTION_STATUS_CODE containing an error that represents a rejection of\n
      \  the entire BNDUPD message.  An enclosed OPTION_IA_NA, OPTION_IA_TA,\n   or
      OPTION_IA_PD option may also contain an OPTION_STATUS_CODE\n   containing an
      error that indicates that everything in the containing\n   option has been rejected.
      \ Alternatively, an individual IAADDR or\n   IAPREFIX option may contain an
      OPTION_STATUS_CODE option containing\n   an error that indicates that the IAADDR
      or IAPREFIX option has been\n   rejected.  An OPTION_STATUS_CODE containing
      a success code has no\n   bearing on the acceptance status of the BNDREPLY message
      at any\n   level.\n   Receipt of a rejection (or a part of a BNDREPLY message
      that has been\n   rejected) requires no processing, other than remembering that
      it has\n   been encountered.\n   The information contained in the BNDREPLY message
      in an\n   OPTION_CLIENT_DATA that represents an acceptance is stored with the\n
      \  appropriate client and lease, as follows:\n   1.  The OPTION_CLIENTID is
      used to find the client.\n   2.  For each of the OPTION_IA_NA, OPTION_IA_TA,
      or OPTION_IA_PD\n       options in the OPTION_CLIENT_DATA option and for each
      of the\n       OPTION_IAADDR or OPTION_IAPREFIX options they contain:\n       a.
      \ OPTION_F_PARTNER_LIFETIME_SENT is stored in the\n           acked-partner-lifetime.\n
      \      b.  The partner-lifetime is set to 0 to indicate that no more\n           information
      needs to be sent to the partner.\n   Alternatively, the BNDREPLY message may
      contain a single\n   OPTION_IAPREFIX option not contained in an OPTION_CLIENT_DATA
      option,\n   representing information concerning a single prefix lease.  If the\n
      \  IAprefix-options section of the OPTION_IAPREFIX option contains an\n   OPTION_STATUS_CODE
      representing an error, then it is considered a\n   rejection of the corresponding
      BNDUPD message.  If the\n   OPTION_IAPREFIX option does not contain an OPTION_STATUS_CODE
      option\n   or if the OPTION_STATUS_CODE option contains a success status, then\n
      \  the three items in the following list are stored in the lease state\n   database,
      in the section associated with the prefix lease represented\n   by the OPTION_IAPREFIX
      option.\n   1.  OPTION_F_BINDING_STATUS containing the binding-status received
      in\n       the BNDREPLY message.\n   2.  OPTION_F_STATE_EXPIRATION_TIME (absolute)
      containing the\n       state-expiration-time received in the BNDREPLY message.\n
      \  3.  OPTION_F_PARTNER_LIFETIME_SENT (absolute) containing a duplicate\n       of
      the OPTION_F_PARTNER_LIFETIME received in the BNDREPLY\n       message.\n"
    title: 7.7.  Receiving Binding Acks
  - contents:
    - "7.8.  BNDUPD/BNDREPLY Data Flow\n   Figure 5 shows the relationship of the
      times described in Section 7.3\n   to the options used to transmit them.  It
      also relates the times on\n   one failover partner to the other failover partner.\n
      \  ----------------------- BNDUPD ---------------------------------\n     Source
      on            OPTION_F in            Storage on\n    Sending Server  ->   BNDUPD
      message   ->   Receiving Server\n                                     [always
      update]\n   partner-lifetime      PARTNER_LIFETIME      expiration-time\n   client-last-transaction-time
      \ CLT_TIME      partner-raw-clt-time\n   start-time-of-state   START_TIME_OF_STATE
      \  start-time-of-state\n   state-expiration-time STATE_EXPIRATION_TIME state-expiration-time\n
      \                             [update only if received > current]\n   expiration-time
      \      EXPIRATION_TIME       partner-lifetime\n   partner-raw-clt-time  PARTNER_RAW_CLT_TIME\n
      \                                         client-last-transaction-time\n   -----------------------
      BNDREPLY -------------------------------\n     Storage on            OPTION_F
      in           Storage on\n    Receiving Server <-   BNDUPD message   <-   Sending
      Server\n           [always update]\n   acked-partner-lifetime PARTNER_LIFETIME_SENT
      duplicate of received\n                                                  PARTNER_LIFETIME\n
      \  (nothing to update)    STATE_EXPIRATION_TIME state-expiration-time\n   ----------------------------------------------------------------\n
      \               Figure 5: BNDUPD and BNDREPLY Time Handling\n"
    title: 7.8.  BNDUPD/BNDREPLY Data Flow
  title: 7.  Binding Updates and Acks
- contents:
  - '8.  Endpoint States

    '
  - contents:
    - "8.1.  State Machine Operation\n   Each server (or, more accurately, failover
      endpoint) can take on a\n   variety of failover states.  These states play a
      crucial role in\n   determining the actions that a server will perform when
      processing a\n   request from a DHCP client as well as dealing with changing
      external\n   conditions (e.g., loss of connection to a failover partner).\n
      \  The failover state in which a server is running controls the\n   following
      behaviors:\n   o  Responsiveness - the server is either responsive to DHCP client\n
      \     requests, renew responsive, or unresponsive.\n   o  Allocation Pool -
      which pool of addresses (or prefixes) can be\n      used for advertisement on
      receipt of a SOLICIT or allocation on\n      receipt of a REQUEST, RENEW, or
      REBIND message.\n   o  MCLT - ensure that valid lifetimes are not beyond what
      the partner\n      has acked plus the MCLT (unless the failover state doesn't
      require\n      this restriction).\n   A server will transition from one failover
      state to another based on\n   the specific values held by the following state
      variables:\n   o  Current failover state.\n   o  Communications status (\"OK\"
      or not \"OK\").\n   o  Partner's failover state (if known).\n   Whenever any
      of the above state variables change state, the state\n   machine is invoked,
      which may then trigger a change in the current\n   failover state.  Thus, whenever
      the communications status changes,\n   the state machine processing is invoked.
      \ This may or may not result\n   in a change in the current failover state.\n
      \  Whenever a server transitions to a new failover state, the new state\n   MUST
      be communicated to its failover partner in a STATE message if\n   the communications
      status is \"OK\".  In addition, whenever a server\n   makes a transition into
      a new state, it MUST record the new state,\n   its current understanding of
      its partner's state, and the time at\n   which it entered the new state in stable
      storage.\n   The state transition diagram below (Figure 6) gives a condensed
      view\n   of the state machine.  If there are any differences between text\n
      \  describing a particular state and the information shown in Figure 6,\n   the
      text should be considered authoritative.\n   In Figure 6, the terms \"responsive\",
      \"r-responsive\", and\n   \"unresponsive\" appear in the states and refer to
      whether the server\n   in the indicated state is allowed to be responsive, renew
      responsive,\n   or unresponsive, respectively.  The \"+\", \"-\", or \"*\" in
      the upper\n   right corner of each state is a notation about whether communication\n
      \  is ongoing with the other server, with \"+\" meaning that\n   communications
      are \"OK\", \"-\" meaning that communications are\n   interrupted, and \"*\"
      meaning that communications may be either \"OK\"\n   or interrupted.\n       +---------------+
      \ V  +--------------+\n       |    RECOVER  * |  |  |   STARTUP  - |\n       |(unresponsive)
      |  +->+(unresponsive)|\n       +------+--------+     +--------------+\n       +-Comm.
      OK             +-----------------+\n       |     Other State:     |  PARTNER-DOWN
      - +<---------------------+\n       |    RESOLUTION-INTER. | (responsive)    |
      \                     ^\n      All     POTENTIAL-      +----+------------+                      |\n
      \    Others   CONFLICT------------ | --------+                         |\n       |
      \     CONFLICT-DONE     Comm. OK     |     +--------------+    |\n    UPDREQ
      or                 Other State:   |  +--+ RESOLUTION - |    |\n    UPDREQALL
      \                 |       |     |  |  | INTERRUPTED  |    |\n    Rcv UPDDONE
      \            RECOVER    All   |  |  | (responsive) |    |\n       |  +---------------+
      \   |      Others |  |  +------+-----+-+    |\n       +->+RECOVER-WAIT * | RECOVER-
      \  |     |  |         ^     |      |\n          |(unresponsive) |  WAIT or   |
      \    |  Comm.     |    Ext.    |\n          +-----------+---+  DONE      |     |
      \ OK     Comm.   Cmd---->+\n   Comm.---+     Wait MCLT     |       V     V  V
      \    Failed           |\n   Changed |          V    +---+   +---+-----+--+-+
      \      |            |\n    |  +---+----------++   |       | POTENTIAL  + +-------+
      \           |\n    |  |RECOVER-DONE * |  Wait     | CONFLICT     +------+             |\n
      \   +->+(unresponsive) |  for      |(unresponsive)|   Primary          |\n       +------+--------+
      \ Other  +>+----+--------++   resolve    Comm. |\n        Comm. OK          State:
      |      |        ^    conflict  Changed|\n   +---Other State:-+   RECOVER- |
      \  Secondary   |       V       V   | |\n   |    |           |     DONE   |   resolve
      \    |  +----+-------+--++ |\n   | All Others:  POTENT.  |     |   conflict
      \   |  |CONFLICT-DONE * | |\n   | Wait for    CONFLICT--|-----+      |        |
      \ | (responsive)   | |\n   | Other State:          V            V        |  +-------+--------+
      |\n   | NORMAL or RECOVER-   ++------------+---+    | Other State: NORMAL |\n
      \  |    |       DONE      |     NORMAL    + +<--------------+          |\n   |
      \   +--+----------+-->+ pri: responsive +-------External Command-->+\n   |       ^
      \         ^   |sec: r-responsive|    |                     |\n   |       |          |
      \  +--------+--------+    |                     |\n   |       |          |            |
      \            |                     |\n   |   Wait for   Comm. OK  Comm. Failed
      \        |             External\n   |    Other      Other           |             |
      \            Command\n   |    State:     State:     Start Auto         |                or\n
      \  | RECOVER-DONE  NORMAL    Partner Down     Comm. OK           Auto\n   |
      \      |     COMM.-INT.      Timer       Other State:       Partner\n   |    Comm.
      OK      |            V          All Others         Down\n   |   Other State:
      \  |  +---------+--------+    |            expiration\n   |     RECOVER      +--+
      COMMUNICATIONS - +----+                     |\n   |       +-------------+   INTERRUPTED
      \   |                          |\n   RECOVER               |  (responsive)    +------------------------->+\n
      \  RECOVER-WAIT--------->+------------------+\n                 Figure 6: Failover
      Endpoint State Machine\n"
    title: 8.1.  State Machine Operation
  - contents:
    - "8.2.  State Machine Initialization\n   The state machine is characterized by
      storage (in stable storage) of\n   at least the following information:\n   o
      \ Current failover state.\n   o  Previous failover state.\n   o  Start time
      of current failover state.\n   o  Partner's failover state.\n   o  Start time
      of partner's failover state.\n   o  Time most recent message received from partner.\n
      \  The state machine is initialized by reading these data items from\n   stable
      storage and restoring their values from the information saved.\n   If there
      is no information in stable storage concerning these items,\n   then they should
      be initialized as follows:\n   o  Current failover state: Primary: PARTNER-DOWN,
      Secondary: RECOVER.\n   o  Previous failover state: None.\n   o  Start time
      of current failover state: Current time.\n   o  Partner's failover state: None
      until reception of STATE message.\n   o  Start time of partner's failover state:
      None until reception of\n      STATE message.\n   o  Time most recent message
      received from partner: None until message\n      received.\n"
    title: 8.2.  State Machine Initialization
  - contents:
    - "8.3.  STARTUP State\n   The STARTUP state affords an opportunity for a server
      to probe its\n   partner server before starting to service DHCP clients.  When
      in the\n   STARTUP state, a server attempts to learn its partner's state and\n
      \  determine (using that information if it is available) what state it\n   should
      enter.\n   The STARTUP state is not shown with any specific state transitions
      in\n   the state machine diagram (Figure 6) because the processing during\n
      \  the STARTUP state can cause the server to transition to any of the\n   other
      states, so that specific state transition arcs would only\n   obscure other
      information.\n"
    - contents:
      - "8.3.1.  Operation in STARTUP State\n   The server MUST NOT be responsive
        to DHCP clients in STARTUP state.\n   Whenever a STATE message is sent to
        the partner while in STARTUP\n   state, the STARTUP flag MUST be set in the
        OPTION_F_SERVER_FLAGS\n   option and the previously recorded failover state
        MUST be placed in\n   the OPTION_F_SERVER_STATE option, each of which is included
        in the\n   STATE message.\n"
      title: 8.3.1.  Operation in STARTUP State
    - contents:
      - "8.3.2.  Transition out of STARTUP State\n   The algorithm below is followed
        every time the server initializes\n   itself and enters STARTUP state.\n   The
        variables PREVIOUS-STATE and CURRENT-STATE are defined for use in\n   the
        algorithm description below.  PREVIOUS-STATE is simply for\n   storage of
        a state, while CURRENT-STATE not only stores the current\n   state but also
        changes the current state of the failover endpoint to\n   whatever state is
        set in CURRENT-STATE.\n   Step 1: If there is any record of a previous failover
        state in stable\n           storage for this server, then set the PREVIOUS-STATE
        to the\n           last recorded value in stable storage and the TIME-OF-FAILURE\n
        \          to the time the server failed or a time beyond which the\n           server
        could not have been operating, and go to Step 2.\n           If there is no
        record of any previous failover state in\n           stable storage for this
        server, then set the PREVIOUS-STATE\n           to RECOVER, and set the TIME-OF-FAILURE
        to 0.  This will\n           allow two servers that already have lease information
        to\n           synchronize themselves prior to operating.\n           In some
        cases, an existing server will be commissioned as a\n           failover server
        and brought back into operation when its\n           partner is not yet available.
        \ In this case, the newly\n           commissioned failover server will not
        operate until its\n           partner comes online -- but it has operational\n
        \          responsibilities as a DHCP server nonetheless.  To properly\n           handle
        this situation, a server SHOULD be configurable in\n           such a way
        as to move directly into PARTNER-DOWN state after\n           the startup
        period expires if it has been unable to contact\n           its partner during
        the startup period.\n   Step 2: Implementations will differ in the ways that
        they deal with\n           the state machine for failover endpoint states.
        \ In many\n           cases, state transitions will occur when communications
        go\n           from \"OK\" to failed or from failed to \"OK\", and some\n
        \          implementations will implement a portion of their state\n           machine
        processing based on these changes.\n           In these cases, during startup,
        if the PREVIOUS-STATE is one\n           where communications were \"OK\",
        then set the PREVIOUS-STATE\n           to the state that is the result of
        the communication failed\n           state transition when in that state (if
        such a transition\n           exists -- some states don't have a communication
        failed state\n           transition, since they allow both \"communications
        OK\" and\n           \"failed\").\n   Step 3: Start the STARTUP state timer.
        \ The time that a server\n           remains in the STARTUP state (absent
        any communications with\n           its partner) is implementation dependent
        but SHOULD be short.\n           It SHOULD be long enough for a TCP connection
        to a heavily\n           loaded partner to be created across a slow network.\n
        \  Step 4: If the server is a primary server, attempt to create a TCP\n           connection
        to the failover partner.  If the server is a\n           secondary server,
        listen on the failover port and wait for\n           the primary server to
        connect.  See Section 6.1.\n   Step 5: Wait for \"communications OK\".\n           When
        and if communications become \"OK\", clear the STARTUP\n           flag, and
        set the CURRENT-STATE to the PREVIOUS-STATE.\n           If the partner is
        in PARTNER-DOWN state and if the time at\n           which it entered PARTNER-DOWN
        state (as received in the\n           OPTION_F_START_TIME_OF_STATE option
        in the STATE message) is\n           later than the last recorded time of
        operation of this\n           server, then set CURRENT-STATE to RECOVER.  If
        the time at\n           which it entered PARTNER-DOWN state is earlier than
        the last\n           recorded time of operation of this server, then set\n
        \          CURRENT-STATE to POTENTIAL-CONFLICT.\n           Then, transition
        to the CURRENT-STATE and take the\n           \"communications OK\" state
        transition based on the\n           CURRENT-STATE of this server and the partner.\n
        \  Step 6: If the startup time expires prior to communications becoming\n
        \          \"OK\", the server SHOULD transition to PREVIOUS-STATE.\n"
      title: 8.3.2.  Transition out of STARTUP State
    title: 8.3.  STARTUP State
  - contents:
    - "8.4.  PARTNER-DOWN State\n   PARTNER-DOWN state is a state either server can
      enter.  When in this\n   state, the server assumes that it is the only server
      operating and\n   serving the client base.  If one server is in PARTNER-DOWN
      state, the\n   other server MUST NOT be operating.\n   A server can enter PARTNER-DOWN
      state as a result of either\n   (1) operator intervention (when an operator
      determines that the\n   server's partner is, indeed, down) or (2) an optional\n
      \  auto-partner-down capability where PARTNER-DOWN state is entered\n   automatically
      after a server has been in COMMUNICATIONS-INTERRUPTED\n   state for a predetermined
      period of time.\n"
    - contents:
      - "8.4.1.  Operation in PARTNER-DOWN State\n   The server MUST be responsive
        in PARTNER-DOWN state, regardless of\n   whether it is primary or secondary.\n
        \  It will allow renewal of all outstanding leases.\n   For delegable prefixes,
        the server will allocate leases from its own\n   pool, and after a fixed period
        of time (the MCLT interval) has\n   elapsed from entry into PARTNER-DOWN state,
        it may allocate delegable\n   prefixes from the set of all available pools.
        \ The server MUST fully\n   deplete its own pool before starting allocations
        from its downed\n   partner's pool.\n   IPv6 addresses available for independent
        allocation by the other\n   server (upon entering PARTNER-DOWN state) SHOULD
        NOT be allocated to\n   a client.  If one elects to do so anyway, they MUST
        NOT be allocated\n   to a new client until the MCLT beyond the entry into
        PARTNER-DOWN\n   state has elapsed.\n   A server in PARTNER-DOWN state MUST
        NOT allocate a lease to a DHCP\n   client different from the client to which
        it was allocated at the\n   time of entry into PARTNER-DOWN state until the
        MCLT beyond the\n   maximum of the following times: client expiration time,
        most recently\n   transmitted partner-lifetime, most recently received ack
        of the\n   partner-time from the partner, and most recently acked\n   partner-lifetime
        to the partner.  If this time would be earlier than\n   the current time plus
        the MCLT, then the time the server entered\n   PARTNER-DOWN state plus the
        MCLT is used.\n   The server is not restricted by the MCLT when offering valid\n
        \  lifetimes while in PARTNER-DOWN state.\n   In the unlikely case when there
        are two servers operating in\n   PARTNER-DOWN state, there is a chance that
        duplicate leases for the\n   same prefix could be assigned.  This leads to
        a POTENTIAL-CONFLICT\n   (unresponsive) state when the servers reestablish
        contact.  This\n   issue of duplicate leases can be prevented as long as the
        server\n   grants new leases from its own pool; therefore, the server operating\n
        \  in PARTNER-DOWN state MUST use its own pool first for new leases\n   before
        assigning any leases from its downed partner's pool.\n"
      title: 8.4.1.  Operation in PARTNER-DOWN State
    - contents:
      - "8.4.2.  Transition out of PARTNER-DOWN State\n   When a server in PARTNER-DOWN
        state succeeds in establishing a\n   connection to its partner, its actions
        are conditional on the state\n   and flags received in the STATE message from
        the other server as part\n   of the process of establishing the connection.\n
        \  If the STARTUP bit is set in the OPTION_F_SERVER_FLAGS option of a\n   received
        STATE message, a server in PARTNER-DOWN state MUST NOT take\n   any state
        transitions based on reestablishing communications.  If a\n   server is in
        PARTNER-DOWN state, it ignores all STATE messages from\n   its partner that
        have the STARTUP bit set in the\n   OPTION_F_SERVER_FLAGS option of the STATE
        message.\n   If the STARTUP bit is not set in the OPTION_F_SERVER_FLAGS option
        of\n   a STATE message received from its partner, then a server in\n   PARTNER-DOWN
        state takes the following actions, based on the state of\n   the partner as
        received in a STATE message (either immediately after\n   establishing communications
        or at any time later when a new state is\n   received):\n   o  If the partner
        is in NORMAL, COMMUNICATIONS-INTERRUPTED,\n      PARTNER-DOWN, POTENTIAL-CONFLICT,
        RESOLUTION-INTERRUPTED, or\n      CONFLICT-DONE state, then transition to
        POTENTIAL-CONFLICT state.\n   o  If the partner is in RECOVER or RECOVER-WAIT
        state, then stay in\n      PARTNER-DOWN state.\n   o  If the partner is in
        RECOVER-DONE state, then transition to\n      NORMAL state.\n"
      title: 8.4.2.  Transition out of PARTNER-DOWN State
    title: 8.4.  PARTNER-DOWN State
  - contents:
    - "8.5.  RECOVER State\n   This state indicates that the server has no information
      in its stable\n   storage or that it is reintegrating with a server in PARTNER-DOWN\n
      \  state after it has been down.  A server in this state MUST attempt to\n   refresh
      its stable storage from the other server.\n"
    - contents:
      - "8.5.1.  Operation in RECOVER State\n   The server MUST NOT be responsive
        in RECOVER state.\n   A server in RECOVER state will attempt to reestablish
        communications\n   with the other server.\n"
      title: 8.5.1.  Operation in RECOVER State
    - contents:
      - "8.5.2.  Transition out of RECOVER State\n   If the other server is in POTENTIAL-CONFLICT,
        RESOLUTION-INTERRUPTED,\n   or CONFLICT-DONE state when communications are
        reestablished, then\n   the server in RECOVER state will move itself to POTENTIAL-CONFLICT\n
        \  state.\n   If the other server is in any other state, then the server in
        RECOVER\n   state will request an update of missing binding information by\n
        \  sending an UPDREQ message.  If the server has determined that it has\n
        \  lost its stable storage because it has no record of ever having\n   talked
        to its partner even though its partner does have a record of\n   communicating
        with it, it MUST send an UPDREQALL message; otherwise,\n   it MUST send an
        UPDREQ message.\n   It will wait for an UPDDONE message, and upon receipt
        of that message\n   it will transition to RECOVER-WAIT state.\n   If communication
        fails during the reception of the results of the\n   UPDREQ or UPDREQALL message,
        the server will remain in RECOVER state\n   and will reissue the UPDREQ or
        UPDREQALL message when communications\n   are reestablished.\n   If an UPDDONE
        message isn't received within an implementation-\n   dependent amount of time
        and no BNDUPD messages are being received,\n   the connection SHOULD be dropped.\n
        \                  A                                        B\n                 Server
        \                                 Server\n                   |                                        |\n
        \               RECOVER                               PARTNER-DOWN\n                   |
        \                                       |\n                   | >--UPDREQ-------------------->
        \        |\n                   |                                        |\n
        \                  |        <---------------------BNDUPD--< |\n                   |
        >--BNDREPLY------------------>         |\n                  ...                                      ...\n
        \                  |                                        |\n                   |
        \       <---------------------BNDUPD--< |\n                   | >--BNDREPLY------------------>
        \        |\n                   |                                        |\n
        \                  |        <--------------------UPDDONE--< |\n                   |
        \                                       |\n              RECOVER-WAIT                                  |\n
        \                  |                                        |\n                   |
        >--STATE-(RECOVER-WAIT)------>         |\n                   |                                        |\n
        \                  |                                        |\n          Wait
        MCLT from last known                         |\n             time of failover
        operation                     |\n                   |                                        |\n
        \             RECOVER-DONE                                  |\n                   |
        \                                       |\n                   | >--STATE-(RECOVER-DONE)------>
        \        |\n                   |                                     NORMAL\n
        \                  |        <-------------(NORMAL)-STATE--< |\n                NORMAL
        \                                     |\n                   | >---- State-(NORMAL)--------------->
        \  |\n                   |                                        |\n                   |
        \                                       |\n                 Figure 7: Transition
        out of RECOVER State\n   If at any time while a server is in RECOVER state
        communication\n   fails, the server will stay in RECOVER state.  When communications\n
        \  are restored, it will restart the process of transitioning out of\n   RECOVER
        state.\n"
      title: 8.5.2.  Transition out of RECOVER State
    title: 8.5.  RECOVER State
  - contents:
    - "8.6.  RECOVER-WAIT State\n   This state indicates that the server has sent
      an UPDREQ or UPDREQALL\n   message and has received the UPDDONE message indicating
      that it has\n   received all outstanding binding update information.  In the\n
      \  RECOVER-WAIT state, the server will wait for the MCLT in order to\n   ensure
      that any processing that this server might have done prior to\n   losing its
      stable storage will not cause future difficulties.\n"
    - contents:
      - "8.6.1.  Operation in RECOVER-WAIT State\n   The server MUST NOT be responsive
        in RECOVER-WAIT state.\n"
      title: 8.6.1.  Operation in RECOVER-WAIT State
    - contents:
      - "8.6.2.  Transition out of RECOVER-WAIT State\n   Upon entry into RECOVER-WAIT
        state, the server MUST start a timer\n   whose expiration is set to a time
        equal to the time the server went\n   down (the TIME-OF-FAILURE from Section
        8.3.2), if known, or the time\n   the server started (if the TIME-OF-FAILURE
        is unknown), plus the\n   MCLT.  When this timer expires, the server will
        transition into\n   RECOVER-DONE state.\n   This allows any IPv6 addresses
        or prefixes that were allocated by\n   this server prior to the loss of its
        client binding information in\n   stable storage to contact the other server
        or to time out.\n   If the server has never before run failover, then there
        is no need to\n   wait in this state, and the server MAY transition immediately
        to\n   RECOVER-DONE state.  However, to determine if this server has run\n
        \  failover, it is vital that the information provided by the partner be\n
        \  utilized, since the stable storage of this server may have been lost.\n
        \  If communication fails while a server is in RECOVER-WAIT state, it\n   has
        no effect on the operation of this state.  The server SHOULD\n   continue
        to operate its timer, and if the timer expires during the\n   period where
        communications with the other server have failed, then\n   the server SHOULD
        transition to RECOVER-DONE state.  This is rare --\n   failover state transitions
        are not usually made while communications\n   are interrupted, but in this
        case there is no reason to inhibit this\n   transition.\n"
      title: 8.6.2.  Transition out of RECOVER-WAIT State
    title: 8.6.  RECOVER-WAIT State
  - contents:
    - "8.7.  RECOVER-DONE State\n   This state exists to allow an interlocked transition
      for one server\n   from RECOVER state and another server from PARTNER-DOWN or\n
      \  COMMUNICATIONS-INTERRUPTED state into NORMAL state.\n"
    - contents:
      - "8.7.1.  Operation in RECOVER-DONE State\n   A server in RECOVER-DONE state
        SHOULD be renew responsive and MAY\n   respond to RENEW requests but MUST
        only change the state of a lease\n   that appears in the RENEW request.  It
        MUST NOT allocate any\n   additional leases when in RECOVER-DONE state and
        should only respond\n   to RENEW requests where it already has a record of
        the lease.\n"
      title: 8.7.1.  Operation in RECOVER-DONE State
    - contents:
      - "8.7.2.  Transition out of RECOVER-DONE State\n   When a server in RECOVER-DONE
        state determines that its partner\n   server has entered NORMAL or RECOVER-DONE
        state, it will transition\n   into NORMAL state.\n   If the partner server
        enters RECOVER or RECOVER-WAIT state, this\n   server transitions to COMMUNICATIONS-INTERRUPTED.\n
        \  If the partner server enters POTENTIAL-CONFLICT state, this server\n   enters
        POTENTIAL-CONFLICT state as well.\n   If communication fails while in RECOVER-DONE
        state, a server will\n   stay in RECOVER-DONE state.\n"
      title: 8.7.2.  Transition out of RECOVER-DONE State
    title: 8.7.  RECOVER-DONE State
  - contents:
    - "8.8.  NORMAL State\n   NORMAL state is the state used by a server when it is
      communicating\n   with the other server and any required resynchronization has
      been\n   performed.  While some binding database synchronization is performed\n
      \  in NORMAL state, potential conflicts are resolved prior to entry into\n   NORMAL
      state, as is binding database data loss.\n   When entering NORMAL state, a server
      will send to the other server\n   all currently unacknowledged binding updates
      as BNDUPD messages.\n   When the above process is complete, if the server entering
      NORMAL\n   state is a secondary server, then it will request delegable prefixes\n
      \  for allocation using the POOLREQ message.\n"
    - contents:
      - "8.8.1.  Operation in NORMAL State\n   The primary server is responsive in
        NORMAL state.  The secondary is\n   renew responsive in NORMAL state.\n   When
        in NORMAL state, a primary server will operate in the following\n   manner:\n
        \  Valid lifetime calculations\n      As discussed in Section 4.4, the lease
        interval given to a DHCP\n      client can never be more than the MCLT greater
        than the most\n      recently acknowledged partner lifetime received from
        the failover\n      partner or the current time, whichever is later.\n      As
        long as a server adheres to this constraint, the specifics of\n      the lease
        interval that it gives to a DHCP client or the value of\n      the partner
        lifetime sent to its failover partner are\n      implementation dependent.\n
        \  Lazy update of partner server\n      After sending a REPLY that includes
        a lease update to a client,\n      the server servicing a DHCP client request
        attempts to update its\n      partner with the new binding information.  See
        Section 4.3.\n   Reallocation of leases between clients\n      Whenever a
        client binding is released or expires, a BNDUPD message\n      must be sent
        to the partner, setting the binding state to RELEASED\n      or EXPIRED.  However,
        until a BNDREPLY is received for this\n      message, the lease cannot be
        allocated to another client.  It\n      cannot be allocated to the same client
        again if a BNDUPD message\n      was sent; otherwise, it can.  See Section
        4.2.2.1 for details.\n   In NORMAL state, each server receives binding updates
        from its\n   partner server in BNDUPD messages (see Section 7.5.5).  It records\n
        \  these in its binding database in stable storage and then sends a\n   corresponding
        BNDREPLY message to its partner server (see\n   Section 7.6).\n"
      title: 8.8.1.  Operation in NORMAL State
    - contents:
      - "8.8.2.  Transition out of NORMAL State\n   If a server in NORMAL state receives
        an external command informing it\n   that its partner is down, it will transition
        immediately into\n   PARTNER-DOWN state.  Generally, this would be an unusual
        situation,\n   where some external agency knew the partner server was down
        prior to\n   the failover server discovering it on its own.\n   If a server
        in NORMAL state fails to receive acks to messages sent to\n   its partner
        for an implementation-dependent period of time, it MAY\n   move into COMMUNICATIONS-INTERRUPTED
        state.  This situation might\n   occur if the partner server was capable of
        maintaining the TCP\n   connection between the server and also capable of
        sending a CONTACT\n   message periodically but was (for some reason) incapable
        of\n   processing BNDUPD messages.\n   If it is determined that communications
        are not \"OK\" (as defined in\n   Section 6.6), then the server should transition
        into\n   COMMUNICATIONS-INTERRUPTED state.\n   If a server in NORMAL state
        receives any messages from its partner\n   where the partner has changed state
        from that expected by the server\n   in NORMAL state, then the server should
        transition into\n   COMMUNICATIONS-INTERRUPTED state and take the appropriate
        state\n   transition from there.  For example, it would be expected that the\n
        \  partner would transition from POTENTIAL-CONFLICT state into NORMAL\n   state
        but not that the partner would transition from NORMAL state\n   into POTENTIAL-CONFLICT
        state.\n   If a server in NORMAL state receives a DISCONNECT message from
        its\n   partner, then the server should transition into\n   COMMUNICATIONS-INTERRUPTED
        state.\n"
      title: 8.8.2.  Transition out of NORMAL State
    title: 8.8.  NORMAL State
  - contents:
    - "8.9.  COMMUNICATIONS-INTERRUPTED State\n   A server goes into COMMUNICATIONS-INTERRUPTED
      state whenever it is\n   unable to communicate with its partner.  Primary and
      secondary\n   servers cycle automatically (without administrative intervention)\n
      \  between NORMAL state and COMMUNICATIONS-INTERRUPTED state as the\n   network
      connection between them fails and recovers, or as the partner\n   server cycles
      between operational and non-operational.  No allocation\n   of duplicate leases
      can occur while the servers cycle between these\n   states.\n   When a server
      enters COMMUNICATIONS-INTERRUPTED state, if it has been\n   configured to support
      an automatic transition out of\n   COMMUNICATIONS-INTERRUPTED state and into
      PARTNER-DOWN state (i.e.,\n   auto-partner-down has been configured), then a
      timer is started for\n   the length of the configured auto-partner-down period.\n
      \  A server transitioning into the COMMUNICATIONS-INTERRUPTED state from\n   the
      NORMAL state SHOULD raise an alarm condition to alert\n   administrative staff
      to a potential problem in the DHCP subsystem.\n"
    - contents:
      - "8.9.1.  Operation in COMMUNICATIONS-INTERRUPTED State\n   In this state,
        a server MUST respond to all DHCP client requests.\n   When allocating new
        leases, each server allocates from its own pool,\n   where the primary MUST
        allocate only FREE delegable prefixes and the\n   secondary MUST allocate
        only FREE-BACKUP delegable prefixes, and each\n   server allocates from its
        own independent IPv6 address ranges.  When\n   responding to RENEW messages,
        each server will allow continued\n   renewal of a DHCP client's current lease,
        regardless of whether that\n   lease was given out by the receiving server
        or not, although the\n   renewal period MUST NOT exceed the MCLT beyond the
        later of (1) the\n   partner lifetime already acknowledged by the other server
        or (2) now.\n   However, since the server cannot communicate with its partner
        in this\n   state, the acknowledged partner lifetime will not be updated,
        despite\n   continued RENEW message processing.  This is likely to eventually\n
        \  cause the actual lifetimes to converge to the MCLT (unless this is\n   greater
        than the desired lease time, which would be unusual).\n   The server should
        continue to try to establish a connection with its\n   partner.\n"
      title: 8.9.1.  Operation in COMMUNICATIONS-INTERRUPTED State
    - contents:
      - "8.9.2.  Transition out of COMMUNICATIONS-INTERRUPTED State\n   If the auto-partner-down
        timer expires while a server is in\n   COMMUNICATIONS-INTERRUPTED state, it
        will transition immediately into\n   PARTNER-DOWN state.\n   If a server in
        COMMUNICATIONS-INTERRUPTED state receives an external\n   command informing
        it that its partner is down, it will transition\n   immediately into PARTNER-DOWN
        state.\n   If communications with the other server are restored, then the
        server\n   in COMMUNICATIONS-INTERRUPTED state will transition into another\n
        \  state based on the state of the partner:\n   o  NORMAL or COMMUNICATIONS-INTERRUPTED:
        Transition into\n      NORMAL state.\n   o  RECOVER: Stay in COMMUNICATIONS-INTERRUPTED
        state.\n   o  RECOVER-DONE: Transition into NORMAL state.\n   o  PARTNER-DOWN,
        POTENTIAL-CONFLICT, CONFLICT-DONE, or\n      RESOLUTION-INTERRUPTED: Transition
        into POTENTIAL-CONFLICT state.\n   Figure 8 illustrates the transition from
        NORMAL state to\n   COMMUNICATIONS-INTERRUPTED state and then back to NORMAL
        state again.\n             Primary                                Secondary\n
        \             Server                                  Server\n              NORMAL
        \                                 NORMAL\n                | >--CONTACT------------------->
        \        |\n                |        <--------------------CONTACT--< |\n                |
        \        [TCP connection broken]        |\n           COMMUNICATIONS-         :
        \             COMMUNICATIONS-\n             INTERRUPTED           :                INTERRUPTED\n
        \               |      [attempt new TCP connection]      |\n                |
        \        [connection succeeds]          |\n                |                                        |\n
        \               | >--CONNECT------------------->         |\n                |
        \       <---------------CONNECTREPLY--< |\n                | >--STATE--------------------->
        \        |\n                |                                     NORMAL\n
        \               |        <-------------------STATE-----< |\n              NORMAL
        \                                    |\n                |                                        |\n
        \               | >--BNDUPD-------------------->         |\n                |
        \       <-------------------BNDREPLY--< |\n                |                                        |\n
        \               |        <---------------------BNDUPD--< |\n                |
        >------BNDREPLY-------------->         |\n               ...                                      ...\n
        \               |                                        |\n                |
        \       <--------------------POOLREQ--< |\n                | >--POOLRESP------------------>
        \        |\n                |                                        |\n                |
        >--BNDUPD-(#1)--------------->         |\n                |        <-------------------BNDREPLY--<
        |\n                |                                        |\n                |
        >--BNDUPD-(#2)--------------->         |\n                |        <-------------------BNDREPLY--<
        |\n                |                                        |\n                  Figure
        8: Transition from NORMAL State\n               to COMMUNICATIONS-INTERRUPTED
        State and Back\n"
      title: 8.9.2.  Transition out of COMMUNICATIONS-INTERRUPTED State
    title: 8.9.  COMMUNICATIONS-INTERRUPTED State
  - contents:
    - "8.10.  POTENTIAL-CONFLICT State\n   This state indicates that the two servers
      are attempting to\n   reintegrate with each other but at least one of them was
      running in a\n   state that did not guarantee that automatic reintegration would
      be\n   possible.  In POTENTIAL-CONFLICT state, the servers may determine\n   that
      the same lease has been offered and accepted by two different\n   clients.\n
      \  A goal of the failover protocol is to minimize the possibility that\n   POTENTIAL-CONFLICT
      state is ever entered.\n   When a primary server enters POTENTIAL-CONFLICT state,
      it should\n   request that the secondary send it all updates that the primary\n
      \  server has not yet acknowledged by sending an UPDREQ message to the\n   secondary
      server.\n   A secondary server entering POTENTIAL-CONFLICT state will wait for\n
      \  the primary to send it an UPDREQ message.\n"
    - contents:
      - "8.10.1.  Operation in POTENTIAL-CONFLICT State\n   Any server in POTENTIAL-CONFLICT
        state MUST NOT process any incoming\n   DHCP requests.\n"
      title: 8.10.1.  Operation in POTENTIAL-CONFLICT State
    - contents:
      - "8.10.2.  Transition out of POTENTIAL-CONFLICT State\n   If communication
        with the partner fails while in POTENTIAL-CONFLICT\n   state, then the server
        will transition to RESOLUTION-INTERRUPTED\n   state.\n   Whenever either server
        receives an UPDDONE message from its partner\n   while in POTENTIAL-CONFLICT
        state, it MUST transition to a new state.\n   The primary MUST transition
        to CONFLICT-DONE state, and the secondary\n   MUST transition to NORMAL state.
        \ This will cause the primary server\n   to leave POTENTIAL-CONFLICT state
        prior to the secondary, since the\n   primary sends an UPDREQ message and
        receives an UPDDONE message\n   before the secondary sends an UPDREQ message
        and receives its UPDDONE\n   message.\n   When a secondary server receives
        an indication that the primary\n   server has made a transition from POTENTIAL-CONFLICT
        to CONFLICT-DONE\n   state, it SHOULD send an UPDREQ message to the primary
        server.\n             Primary                                Secondary\n             Server
        \                                 Server\n               |                                        |\n
        \        POTENTIAL-CONFLICT                    POTENTIAL-CONFLICT\n               |
        \                                       |\n               | >--UPDREQ-------------------->
        \        |\n               |                                        |\n               |
        \       <---------------------BNDUPD--< |\n               | >--BNDREPLY------------------>
        \        |\n              ...                                      ...\n               |
        \                                       |\n               |        <---------------------BNDUPD--<
        |\n               | >--BNDREPLY------------------>         |\n               |
        \                                       |\n               |        <--------------------UPDDONE--<
        |\n         CONFLICT-DONE                                  |\n               |
        >--STATE--(CONFLICT-DONE)---->         |\n               |        <---------------------UPDREQ--<
        |\n               |                                        |\n               |
        >--BNDUPD-------------------->         |\n               |        <-------------------BNDREPLY--<
        |\n              ...                                      ...\n               |
        >--BNDUPD-------------------->         |\n               |        <-------------------BNDREPLY--<
        |\n               |                                        |\n               |
        >--UPDDONE------------------->         |\n               |                                     NORMAL\n
        \              |        <------------STATE--(NORMAL)--< |\n            NORMAL
        \                                     |\n               | >--STATE--(NORMAL)----------->
        \        |\n               |                                        |\n               |
        \       <--------------------POOLREQ--< |\n               | >------POOLRESP-------------->
        \        |\n               |                                        |\n           Figure
        9: Transition out of POTENTIAL-CONFLICT State\n"
      title: 8.10.2.  Transition out of POTENTIAL-CONFLICT State
    title: 8.10.  POTENTIAL-CONFLICT State
  - contents:
    - "8.11.  RESOLUTION-INTERRUPTED State\n   This state indicates that the two servers
      were attempting to\n   reintegrate with each other in POTENTIAL-CONFLICT state
      but\n   communication failed prior to completion of reintegration.\n   The RESOLUTION-INTERRUPTED
      state exists because servers are not\n   responsive in POTENTIAL-CONFLICT state,
      and if one server drops out\n   of service while both servers are in POTENTIAL-CONFLICT
      state, the\n   server that remains in service will not be able to process DHCP\n
      \  client requests and there will be no DHCP server available to process\n   client
      requests.  The RESOLUTION-INTERRUPTED state is the state that\n   a server moves
      to if its partner disappears while it is in\n   POTENTIAL-CONFLICT state.\n
      \  When a server enters RESOLUTION-INTERRUPTED state, it SHOULD raise an\n   alarm
      condition to alert administrative staff of a problem in the\n   DHCP subsystem.\n"
    - contents:
      - "8.11.1.  Operation in RESOLUTION-INTERRUPTED State\n   In this state, a server
        MUST respond to all DHCP client requests.\n   When allocating new leases,
        each server SHOULD allocate from its own\n   pool (if that can be determined),
        where the primary SHOULD allocate\n   only FREE leases and the secondary SHOULD
        allocate only FREE-BACKUP\n   leases.  When responding to renewal requests,
        each server will allow\n   continued renewal of a DHCP client's current lease,
        independent of\n   whether that lease was given out by the receiving server
        or not,\n   although the renewal period MUST NOT exceed the MCLT beyond the\n
        \  later of (1) the partner lifetime already acknowledged by the other\n   server
        or (2) now.\n   However, since the server cannot communicate with its partner
        in this\n   state, the acknowledged partner lifetime will not be updated in
        any\n   new bindings.\n"
      title: 8.11.1.  Operation in RESOLUTION-INTERRUPTED State
    - contents:
      - "8.11.2.  Transition out of RESOLUTION-INTERRUPTED State\n   If a server in
        RESOLUTION-INTERRUPTED state receives an external\n   command informing it
        that its partner is down, it will transition\n   immediately into PARTNER-DOWN
        state.\n   If communications with the other server are restored, then the
        server\n   in RESOLUTION-INTERRUPTED state will transition into\n   POTENTIAL-CONFLICT
        state.\n"
      title: 8.11.2.  Transition out of RESOLUTION-INTERRUPTED State
    title: 8.11.  RESOLUTION-INTERRUPTED State
  - contents:
    - "8.12.  CONFLICT-DONE State\n   This state indicates that during the process
      where the two servers\n   are attempting to reintegrate with each other, the
      primary server has\n   received all of the updates from the secondary server.
      \ It makes a\n   transition into CONFLICT-DONE state so that it can be totally\n
      \  responsive to the client load.  There is no operational difference\n   between
      CONFLICT-DONE and NORMAL for the primary server, as in both\n   states it responds
      to all clients' requests.  The distinction between\n   CONFLICT-DONE and NORMAL
      states is necessary in the event that a\n   load-balancing extension is ever
      defined.\n"
    - contents:
      - "8.12.1.  Operation in CONFLICT-DONE State\n   A primary server in CONFLICT-DONE
        state is fully responsive to all\n   DHCP clients (similar to the situation
        in COMMUNICATIONS-INTERRUPTED\n   state).\n   If communication fails, remain
        in CONFLICT-DONE state.  If\n   communication becomes \"OK\", remain in CONFLICT-DONE
        state until the\n   conditions for transition out of CONFLICT-DONE state are
        satisfied.\n"
      title: 8.12.1.  Operation in CONFLICT-DONE State
    - contents:
      - "8.12.2.  Transition out of CONFLICT-DONE State\n   If communication with
        the partner fails while in CONFLICT-DONE state,\n   then the server will remain
        in CONFLICT-DONE state.\n   When a primary server determines that the secondary
        server has made a\n   transition into NORMAL state, the primary server will
        also transition\n   into NORMAL state.\n"
      title: 8.12.2.  Transition out of CONFLICT-DONE State
    title: 8.12.  CONFLICT-DONE State
  title: 8.  Endpoint States
- contents:
  - "9.  DNS Update Considerations\n   DHCP servers (and clients) can use \"DNS update\"
    as described in\n   RFC 2136 [RFC2136] to maintain DNS name mappings as they maintain\n
    \  DHCP leases.  Many different administrative models for DHCP-DNS\n   integration
    are possible.  Descriptions of several of these models,\n   and guidelines that
    DHCP servers and clients should follow in\n   carrying them out, are laid out
    in RFC 4704 [RFC4704].\n   The nature of the failover protocol introduces some
    issues concerning\n   DNS updates that are not part of non-failover environments.
    \ This\n   section describes these issues and defines the information that\n   failover
    partners should exchange in order to ensure consistent\n   behavior.  The presence
    of this section should not be interpreted as\n   a requirement that an implementation
    of the DHCPv6 failover protocol\n   also support DNS updates.\n   The purpose
    of this discussion is to clarify the areas where the\n   failover and DHCP DNS
    update protocols intersect for the benefit of\n   implementations that support
    both protocols, not to introduce a new\n   requirement into the DHCPv6 failover
    protocol.  Thus, a DHCP server\n   that implements the failover protocol MAY also
    support DNS updates,\n   but if it does support DNS updates it SHOULD utilize
    the techniques\n   described here in order to correctly distribute them between
    the\n   failover partners.  See RFC 4704 [RFC4704] as well as RFC 4703\n   [RFC4703]
    for information on how DHCP servers deal with potential\n   conflicts when updating
    DNS even without failover.\n   From the standpoint of the failover protocol, there
    is no reason why\n   a server that is utilizing the DNS update protocol to update
    a DNS\n   server should not be a partner with a server that is not utilizing\n
    \  the DNS update protocol to update a DNS server.  However, a server\n   that
    is not able to support DNS update or is not configured to\n   support DNS update
    SHOULD output a warning message when it receives\n   BNDUPD messages that indicate
    that its failover partner is configured\n   to support the DNS update protocol
    to update a DNS server.  An\n   implementation MAY consider this an error and
    refuse to accept the\n   BNDUPD message by returning the status DNSUpdateNotSupported
    in an\n   OPTION_STATUS_CODE option in the BNDREPLY message, or it MAY choose\n
    \  to operate anyway, having warned the administrator of the problem in\n   some
    way.\n"
  - contents:
    - "9.1.  Relationship between Failover and DNS Update\n   The failover protocol
      describes the conditions under which each\n   failover server may renew a lease
      to its current DHCP client and\n   describes the conditions under which it may
      grant a lease to a new\n   DHCP client.  An analogous set of conditions determines
      when a\n   failover server should initiate a DNS update, and when it should\n
      \  attempt to remove records from the DNS.  The failover protocol's\n   conditions
      are based on the desired external behavior: avoiding\n   duplicate address and
      prefix assignments, allowing clients to\n   continue using leases that they
      obtained from one failover partner\n   even if they can only communicate with
      the other partner, and\n   allowing the secondary DHCP server to grant new leases
      even if it is\n   unable to communicate with the primary server.  The desired
      external\n   DNS update behavior for DHCPv6 failover servers is similar to that\n
      \  described above for the failover protocol itself:\n   1.  Allow timely DNS
      updates from the server that grants a lease to a\n       client.  Recognize
      that there is often a DNS update \"lifecycle\"\n       that parallels the DHCP
      lease lifecycle.  This is likely to\n       include the addition of records
      when the lease is granted and the\n       removal of DNS records when the lease
      is subsequently made\n       available for allocation to a different client.\n
      \  2.  Communicate enough information between the two failover servers\n       to
      allow one to complete the DNS update lifecycle even if the\n       other server
      originally granted the lease.\n   3.  Avoid redundant or overlapping DNS updates
      where both failover\n       servers are attempting to perform DNS updates for
      the same\n       lease-client binding.\n   4.  Avoid situations where one partner
      is attempting to add resource\n       records (RRs) related to a lease binding
      while the other partner\n       is attempting to remove RRs related to the same
      lease binding.\n   While DHCPv6 servers configured for DNS update typically
      perform\n   these operations on both the AAAA and the PTR RRs, this is not\n
      \  required.  It is entirely possible that a DHCPv6 server could be\n   configured
      to only update the DNS with PTR records, and the DHCPv6\n   clients could be
      responsible for updating the DNS with their own AAAA\n   records.  In this case,
      the discussions here would apply only to the\n   PTR records.\n"
    title: 9.1.  Relationship between Failover and DNS Update
  - contents:
    - "9.2.  Exchanging DNS Update Information\n   In order for either server to be
      able to complete a DNS update or to\n   remove DNS records that were added by
      its partner, both servers need\n   to know the FQDN associated with the lease-client
      binding.  In\n   addition, to properly handle DNS updates, additional information
      is\n   required.  All of the following information needs to be transmitted\n
      \  between the failover partners:\n   1.  The FQDN that the client requested
      be associated with the lease.\n       If the client doesn't request a particular
      FQDN and one is\n       synthesized by the failover server or if the failover
      server is\n       configured to replace a client-requested FQDN with a different\n
      \      FQDN, then the server-generated value would be used.\n   2.  The FQDN
      that was actually placed in the DNS for this lease.  It\n       may differ from
      the client-requested FQDN due to some form of\n       disambiguation or other
      DHCP server configuration (as described\n       above).\n   3.  The status of
      any DNS update operations in progress or completed.\n   4.  Information sufficient
      to allow the failover partner to remove\n       the FQDN from the DNS, should
      that become necessary.\n   These data items are the minimum necessary set to
      reliably allow two\n   failover partners to successfully share the responsibility
      to keep\n   the DNS up to date with the leases allocated to clients.\n   This
      information would typically be included in BNDUPD messages sent\n   from one
      failover partner to the other.  Failover servers MAY choose\n   not to include
      this information in BNDUPD messages if there has been\n   no change in the status
      of any DNS update related to the lease.\n   The partner server receiving BNDUPD
      messages containing the DNS\n   update information SHOULD compare the status
      information and the FQDN\n   with the current DNS update information it has
      associated with the\n   lease binding and update its notion of the DNS update
      status\n   accordingly.\n   Some implementations will instead choose to send
      a BNDUPD message\n   without waiting for the DNS update to complete and then
      will send a\n   second BNDUPD message once the DNS update is complete.  Other\n
      \  implementations will delay sending the partner a BNDUPD message until\n   the
      DNS update has been acknowledged by the DNS server, or until some\n   time limit
      has elapsed, in order to avoid sending a second BNDUPD\n   message.\n   The
      FQDN option contains the FQDN that will be associated with the\n   AAAA RR (if
      the server is performing a AAAA RR update for the\n   client).  The PTR RR can
      be generated automatically from the IPv6\n   address value.  The FQDN may be
      composed in any of several ways,\n   depending on server configuration and the
      information provided by the\n   client in its DHCP messages.  The client may
      supply a hostname that\n   it would like the server to use in forming the FQDN,
      or it may supply\n   the entire FQDN.  The server may be configured to attempt
      to use the\n   information the client supplies, it may be configured with an
      FQDN to\n   use for the client, or it may be configured to synthesize an FQDN.\n
      \  Since the server interacting with the client may not have completed\n   the
      DNS update at the time it sends the first BNDUPD message about\n   the lease
      binding, there may be cases where the FQDN in later BNDUPD\n   messages does
      not match the FQDN included in earlier messages.  For\n   example, the responsive
      server may be configured to handle situations\n   where two or more DHCP client
      FQDNs are identical by modifying the\n   most-specific label in the FQDNs of
      some of the clients in an attempt\n   to generate unique FQDNs for them (a process
      sometimes called\n   \"disambiguation\").  Alternatively, at sites that use
      some or all of\n   the information that clients supply to form the FQDN, it's
      possible\n   that a client's configuration may be changed so that it begins
      to\n   supply new data.  The server interacting with the client may react by\n
      \  removing the DNS records that it originally added for the client and\n   replacing
      them with records that refer to the client's new FQDN.  In\n   such cases, the
      server SHOULD include the actual FQDN that was used\n   in subsequent DNS update
      options in any BNDUPD messages exchanged\n   between the failover partners.
      \ This server SHOULD include relevant\n   information in its BNDUPD messages.
      \ This information may be\n   necessary in order to allow the non-responsive
      partner to detect\n   client configuration changes that change the hostname
      or FQDN data\n   that the client includes in its DHCPv6 requests.\n"
    title: 9.2.  Exchanging DNS Update Information
  - contents:
    - "9.3.  Adding RRs to the DNS\n   A failover server that is going to perform
      DNS updates SHOULD\n   initiate the DNS update when it grants a new lease to
      a client.  The\n   server that did not grant the lease SHOULD NOT initiate a
      DNS update\n   when it receives the BNDUPD message after the lease has been
      granted.\n   The failover protocol ensures that only one of the partners will\n
      \  grant a lease to any individual client, so it follows that this\n   requirement
      will prevent both partners from initiating updates\n   simultaneously.  The
      server initiating the update SHOULD follow the\n   protocol in RFC 4704 [RFC4704].
      \ The server may be configured to\n   perform a AAAA RR update on behalf of
      its clients, or not.\n   Ordinarily, a failover server will not initiate DNS
      updates when it\n   renews leases.  In two cases, however, a failover server
      MAY initiate\n   a DNS update when it renews a lease to its existing client:\n
      \  1.  When the lease was granted before the server was configured to\n       perform
      DNS updates, the server MAY be configured to perform\n       updates when it
      next renews existing leases.\n   2.  If a server is in PARTNER-DOWN state, it
      can conclude that its\n       partner is no longer attempting to perform an
      update for the\n       existing client.  If the remaining server has not recorded
      that\n       an update for the binding has been successfully completed, the\n
      \      server MAY initiate a DNS update.  It may initiate this update\n       immediately
      upon entry into PARTNER-DOWN state, it may perform\n       this in the background,
      or it may initiate this update upon next\n       hearing from the DHCP client.\n
      \  Note that, regardless of the use of failover, there is a use case for\n   updating
      the DNS on every lease renewal.  If there is a concern that\n   the information
      in the DNS does not match the information in the DHCP\n   server, updating the
      DNS on lease renewal is one way to gradually\n   ensure that the DNS has information
      that corresponds correctly to the\n   information in the DHCP server.\n"
    title: 9.3.  Adding RRs to the DNS
  - contents:
    - "9.4.  Deleting RRs from the DNS\n   The failover server that makes a lease
      PENDING-FREE SHOULD initiate\n   any DNS deletes if it has recorded that DNS
      records were added on\n   behalf of the client.\n   A server not in PARTNER-DOWN
      state \"makes a lease PENDING-FREE\" when\n   it initiates a BNDUPD message
      with a binding-status of FREE,\n   FREE-BACKUP, EXPIRED, or RELEASED.  Its partner
      confirms this status\n   by acking that BNDUPD message, and upon receipt of
      the BNDREPLY\n   message the server has \"made the lease PENDING-FREE\".  Conversely,
      a\n   server in PARTNER-DOWN state \"makes a lease PENDING-FREE\" when it\n
      \  sets the binding-status to FREE, since in PARTNER-DOWN state no\n   communications
      with the partner are required.\n   It is at this point that it should initiate
      the DNS operations to\n   delete RRs from the DNS.  Its partner SHOULD NOT initiate
      DNS deletes\n   for DNS records related to the lease binding as part of sending
      the\n   BNDREPLY message.  The partner MAY have issued BNDUPD messages with
      a\n   binding-status of FREE, EXPIRED, or RELEASED previously, but the\n   other
      server will have rejected these BNDUPD messages.\n   The failover protocol ensures
      that only one of the two partner\n   servers will be able to make a lease PENDING-FREE.
      \ The server making\n   the lease PENDING-FREE may be doing so while it is communicating
      in\n   NORMAL state with its partner, or it may be in PARTNER-DOWN state.\n
      \  If a server is in PARTNER-DOWN state, it may be performing DNS\n   deletes
      for RRs that its partner added originally.  This allows a\n   single remaining
      partner server to assume responsibility for all of\n   the DNS update activity
      that the two servers were undertaking.\n   Another implication of this approach
      is that no DNS RR deletes will\n   be performed while either server is in COMMUNICATIONS-INTERRUPTED\n
      \  state, since no leases are moved into the PENDING-FREE state during\n   that
      period.\n   A failover server SHOULD ensure that a server failure while making
      a\n   lease PENDING-FREE and initiating a DNS delete does not somehow leave\n
      \  the lease with an RR in the DNS with nothing recorded in the lease\n   state
      database to trigger a DNS delete.\n"
    title: 9.4.  Deleting RRs from the DNS
  - contents:
    - "9.5.  Name Assignment with No Update of DNS\n   In some cases, a DHCP server
      is configured to return a name to the\n   DHCP client but not enter that name
      into the DNS.  This is typically\n   a name that it has discovered or generated
      from information it has\n   received from the client.  In this case, this name
      information SHOULD\n   be communicated to the failover partner, if only to ensure
      that they\n   will return the same name in the event the partner becomes the
      server\n   with which the DHCP client begins to interact.\n"
    title: 9.5.  Name Assignment with No Update of DNS
  title: 9.  DNS Update Considerations
- contents:
  - "10.  Security Considerations\n   DHCPv6 failover is an extension of a standard
    DHCPv6 protocol, so all\n   security considerations from Section 23 of [RFC3315]
    and Section 15\n   of [RFC3633] related to the server apply.\n   The use of TCP
    introduces some additional concerns.  Attacks that\n   attempt to exhaust the
    DHCP server's available TCP connection\n   resources can compromise the ability
    of legitimate partners to\n   receive service.  Malicious requestors who succeed
    in establishing\n   connections but who then send invalid messages, partial messages,
    or\n   no messages at all can also exhaust a server's pool of available\n   connections.\n
    \  DHCPv6 failover can operate in secure or insecure mode.  Secure mode\n   (using
    Transport Layer Security (TLS) [RFC5246]) would be indicated\n   when the TCP
    connection between failover partners is open to external\n   monitoring or interception.
    \ Insecure mode should only be used when\n   the TCP connection between failover
    partners remains within a set of\n   protected systems.  Details of such protections
    are beyond the scope\n   of this document.  Failover servers MUST use the approach
    documented\n   in Section 9.1 of [RFC7653] to decide whether or not to use TLS
    when\n   connecting with the failover partner.\n   The threats created by using
    failover directly mirror those from\n   using DHCPv6 itself: information leakage
    through monitoring, and\n   disruption of address assignment and configuration.
    \ Monitoring the\n   failover TCP connection provides no additional data beyond
    that\n   available from monitoring the interactions between DHCPv6 clients and\n
    \  the DHCPv6 server.  Likewise, manipulating the data flow between\n   failover
    servers provides no additional opportunities to disrupt\n   address assignment
    and configuration beyond that provided by acting\n   as a counterfeit DHCP server.
    \ Protection from both threats is easier\n   than with basic DHCPv6, as only a
    single TCP connection needs to be\n   protected.  Either use secure mode to protect
    that TCP connection or\n   ensure that it can only exist with a set of protected
    systems.\n   When operating in secure mode, TLS is used to secure the connection.\n
    \  The recommendations in [RFC7525] SHOULD be followed when negotiating\n   a
    TLS connection.\n   Servers SHOULD offer configuration parameters to limit the
    sources of\n   incoming connections through validation and use of the digital\n
    \  certificates presented to create a TLS connection.  They SHOULD also\n   limit
    the number of accepted connections and limit the period of time\n   during which
    an idle connection will be left open.\n   Authentication for DHCPv6 messages [RFC3315]
    MUST NOT be used to\n   attempt to secure transmission of the messages described
    in this\n   document.  If authentication is desired, secure mode using TLS SHOULD\n
    \  be employed as described in Sections 8.2 and 9.1 of [RFC7653].\n"
  title: 10.  Security Considerations
- contents:
  - "11.  IANA Considerations\n   IANA has assigned values for the following new DHCPv6
    message types\n   in the registry maintained at <http://www.iana.org/assignments/\n
    \  dhcpv6-parameters>:\n   o  BNDUPD (24)\n   o  BNDREPLY (25)\n   o  POOLREQ
    (26)\n   o  POOLRESP (27)\n   o  UPDREQ (28)\n   o  UPDREQALL (29)\n   o  UPDDONE
    (30)\n   o  CONNECT (31)\n   o  CONNECTREPLY (32)\n   o  DISCONNECT (33)\n   o
    \ STATE (34)\n   o  CONTACT (35)\n   IANA has assigned values for the following
    new DHCPv6 option codes in\n   the registry maintained at <http://www.iana.org/assignments/\n
    \  dhcpv6-parameters>:\n   o  OPTION_F_BINDING_STATUS (114)\n   o  OPTION_F_CONNECT_FLAGS
    (115)\n   o  OPTION_F_DNS_REMOVAL_INFO (116)\n   o  OPTION_F_DNS_HOST_NAME (117)\n
    \  o  OPTION_F_DNS_ZONE_NAME (118)\n   o  OPTION_F_DNS_FLAGS (119)\n   o  OPTION_F_EXPIRATION_TIME
    (120)\n   o  OPTION_F_MAX_UNACKED_BNDUPD (121)\n   o  OPTION_F_MCLT (122)\n   o
    \ OPTION_F_PARTNER_LIFETIME (123)\n   o  OPTION_F_PARTNER_LIFETIME_SENT (124)\n
    \  o  OPTION_F_PARTNER_DOWN_TIME (125)\n   o  OPTION_F_PARTNER_RAW_CLT_TIME (126)\n
    \  o  OPTION_F_PROTOCOL_VERSION (127)\n   o  OPTION_F_KEEPALIVE_TIME (128)\n   o
    \ OPTION_F_RECONFIGURE_DATA (129)\n   o  OPTION_F_RELATIONSHIP_NAME (130)\n   o
    \ OPTION_F_SERVER_FLAGS (131)\n   o  OPTION_F_SERVER_STATE (132)\n   o  OPTION_F_START_TIME_OF_STATE
    (133)\n   o  OPTION_F_STATE_EXPIRATION_TIME (134)\n   IANA has assigned values
    for the following new DHCPv6 status codes in\n   the registry maintained at <http://www.iana.org/assignments/\n
    \  dhcpv6-parameters>:\n   o  AddressInUse (16)\n   o  ConfigurationConflict (17)\n
    \  o  MissingBindingInformation (18)\n   o  OutdatedBindingInformation (19)\n
    \  o  ServerShuttingDown (20)\n   o  DNSUpdateNotSupported (21)\n   o  ExcessiveTimeSkew
    (22)\n"
  title: 11.  IANA Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC1035]  Mockapetris, P., \"Domain names
      - implementation and\n              specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035,\n
      \             November 1987, <http://www.rfc-editor.org/info/rfc1035>.\n   [RFC2119]
      \ Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC2136]  Vixie,
      P., Ed., Thomson, S., Rekhter, Y., and J. Bound,\n              \"Dynamic Updates
      in the Domain Name System (DNS UPDATE)\",\n              RFC 2136, DOI 10.17487/RFC2136,
      April 1997,\n              <http://www.rfc-editor.org/info/rfc2136>.\n   [RFC3315]
      \ Droms, R., Ed., Bound, J., Volz, B., Lemon, T., Perkins,\n              C.,
      and M. Carney, \"Dynamic Host Configuration Protocol\n              for IPv6
      (DHCPv6)\", RFC 3315, DOI 10.17487/RFC3315,\n              July 2003, <http://www.rfc-editor.org/info/rfc3315>.\n
      \  [RFC3633]  Troan, O. and R. Droms, \"IPv6 Prefix Options for Dynamic\n              Host
      Configuration Protocol (DHCP) version 6\", RFC 3633,\n              DOI 10.17487/RFC3633,
      December 2003,\n              <http://www.rfc-editor.org/info/rfc3633>.\n   [RFC4703]
      \ Stapp, M. and B. Volz, \"Resolution of Fully Qualified\n              Domain
      Name (FQDN) Conflicts among Dynamic Host\n              Configuration Protocol
      (DHCP) Clients\", RFC 4703,\n              DOI 10.17487/RFC4703, October 2006,\n
      \             <http://www.rfc-editor.org/info/rfc4703>.\n   [RFC4704]  Volz,
      B., \"The Dynamic Host Configuration Protocol for\n              IPv6 (DHCPv6)
      Client Fully Qualified Domain Name (FQDN)\n              Option\", RFC 4704,
      DOI 10.17487/RFC4704, October 2006,\n              <http://www.rfc-editor.org/info/rfc4704>.\n
      \  [RFC5007]  Brzozowski, J., Kinnear, K., Volz, B., and S. Zeng,\n              \"DHCPv6
      Leasequery\", RFC 5007, DOI 10.17487/RFC5007,\n              September 2007,
      <http://www.rfc-editor.org/info/rfc5007>.\n   [RFC5246]  Dierks, T. and E. Rescorla,
      \"The Transport Layer Security\n              (TLS) Protocol Version 1.2\",
      RFC 5246,\n              DOI 10.17487/RFC5246, August 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n
      \  [RFC5460]  Stapp, M., \"DHCPv6 Bulk Leasequery\", RFC 5460,\n              DOI
      10.17487/RFC5460, February 2009,\n              <http://www.rfc-editor.org/info/rfc5460>.\n
      \  [RFC6607]  Kinnear, K., Johnson, R., and M. Stapp, \"Virtual Subnet\n              Selection
      Options for DHCPv4 and DHCPv6\", RFC 6607,\n              DOI 10.17487/RFC6607,
      April 2012,\n              <http://www.rfc-editor.org/info/rfc6607>.\n   [RFC7525]
      \ Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations
      for Secure Use of Transport Layer\n              Security (TLS) and Datagram
      Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,\n
      \             May 2015, <http://www.rfc-editor.org/info/rfc7525>.\n   [RFC7653]
      \ Raghuvanshi, D., Kinnear, K., and D. Kukrety, \"DHCPv6\n              Active
      Leasequery\", RFC 7653, DOI 10.17487/RFC7653,\n              October 2015, <http://www.rfc-editor.org/info/rfc7653>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n              RFC
      2119 Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174, May
      2017,\n              <http://www.rfc-editor.org/info/rfc8174>.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [RFC7031]  Mrugalski, T. and K. Kinnear,
      \"DHCPv6 Failover\n              Requirements\", RFC 7031, DOI 10.17487/RFC7031,\n
      \             September 2013, <http://www.rfc-editor.org/info/rfc7031>.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Acknowledgements\n   This document extensively uses concepts, definitions, and
    other parts\n   of an effort to document failover for DHCPv4.  The authors would
    like\n   to thank Shawn Routhier, Greg Rabil, Bernie Volz, and Marcin\n   Siodelski
    for their significant involvement and contributions.  In\n   particular, Bernie
    Volz and Shawn Routhier provided detailed and\n   substantive technical reviews
    of the document.  The RFC Editor also\n   caught several important technical issues.
    \ The authors would like to\n   thank Vithalprasad Gaitonde, Krzysztof Gierlowski,
    Krzysztof Nowicki,\n   and Michal Hoeft for their insightful comments.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Tomek Mrugalski\n   Internet Systems Consortium, Inc.\n
    \  950 Charter Street\n   Redwood City, California  94063\n   United States of
    America\n   Email: tomasz.mrugalski@gmail.com\n   Kim Kinnear\n   Cisco Systems,
    Inc.\n   200 Beaver Brook Road\n   Boxborough, Massachusetts  01719\n   United
    States of America\n   Phone: +1 978 936 0000\n   Email: kkinnear@cisco.com\n"
  title: Authors' Addresses
