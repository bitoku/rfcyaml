- title: __initial_text__
  contents:
  - '           Internet Protocol, Version 6 (IPv6) Specification

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies version 6 of the Internet Protocol (IPv6).\n\
    \   It obsoletes RFC 2460.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8200.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   5\n   3.  IPv6 Header Format  . . . . . . . . . . . . . . . . . .\
    \ . . .   6\n   4.  IPv6 Extension Headers  . . . . . . . . . . . . . . . . .\
    \ . .   7\n     4.1.  Extension Header Order  . . . . . . . . . . . . . . . .\
    \ .  10\n     4.2.  Options . . . . . . . . . . . . . . . . . . . . . . . . .\
    \  11\n     4.3.  Hop-by-Hop Options Header . . . . . . . . . . . . . . . .  13\n\
    \     4.4.  Routing Header  . . . . . . . . . . . . . . . . . . . . .  14\n  \
    \   4.5.  Fragment Header . . . . . . . . . . . . . . . . . . . . .  15\n    \
    \ 4.6.  Destination Options Header  . . . . . . . . . . . . . . .  23\n     4.7.\
    \  No Next Header  . . . . . . . . . . . . . . . . . . . . .  24\n     4.8.  Defining\
    \ New Extension Headers and Options  . . . . . . .  24\n   5.  Packet Size Issues\
    \  . . . . . . . . . . . . . . . . . . . . .  25\n   6.  Flow Labels . . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  26\n   7.  Traffic Classes . . . .\
    \ . . . . . . . . . . . . . . . . . . .  26\n   8.  Upper-Layer Protocol Issues\
    \ . . . . . . . . . . . . . . . . .  27\n     8.1.  Upper-Layer Checksums . .\
    \ . . . . . . . . . . . . . . . .  27\n     8.2.  Maximum Packet Lifetime . .\
    \ . . . . . . . . . . . . . . .  28\n     8.3.  Maximum Upper-Layer Payload Size\
    \  . . . . . . . . . . . .  29\n     8.4.  Responding to Packets Carrying Routing\
    \ Headers  . . . . .  29\n   9.  IANA Considerations . . . . . . . . . . . . .\
    \ . . . . . . . .  29\n   10. Security Considerations . . . . . . . . . . . .\
    \ . . . . . . .  30\n   11. References  . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  32\n     11.1.  Normative References . . . . . . . . . . . . .\
    \ . . . . .  32\n     11.2.  Informative References . . . . . . . . . . . . .\
    \ . . . .  33\n   Appendix A.  Formatting Guidelines for Options  . . . . . .\
    \ . . .  36\n   Appendix B.  Changes Since RFC 2460 . . . . . . . . . . . . .\
    \ . .  39\n   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  42\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .\
    \  42\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   IP version 6 (IPv6) is a new version of the Internet Protocol\
    \ (IP),\n   designed as the successor to IP version 4 (IPv4) [RFC791].  The\n\
    \   changes from IPv4 to IPv6 fall primarily into the following\n   categories:\n\
    \      o  Expanded Addressing Capabilities\n         IPv6 increases the IP address\
    \ size from 32 bits to 128 bits, to\n         support more levels of addressing\
    \ hierarchy, a much greater\n         number of addressable nodes, and simpler\
    \ autoconfiguration of\n         addresses.  The scalability of multicast routing\
    \ is improved by\n         adding a \"scope\" field to multicast addresses.  And\
    \ a new type\n         of address called an \"anycast address\" is defined; it\
    \ is used\n         to send a packet to any one of a group of nodes.\n      o\
    \  Header Format Simplification\n         Some IPv4 header fields have been dropped\
    \ or made optional, to\n         reduce the common-case processing cost of packet\
    \ handling and\n         to limit the bandwidth cost of the IPv6 header.\n   \
    \   o  Improved Support for Extensions and Options\n         Changes in the way\
    \ IP header options are encoded allows for\n         more efficient forwarding,\
    \ less stringent limits on the length\n         of options, and greater flexibility\
    \ for introducing new options\n         in the future.\n      o  Flow Labeling\
    \ Capability\n         A new capability is added to enable the labeling of sequences\n\
    \         of packets that the sender requests to be treated in the\n         network\
    \ as a single flow.\n      o  Authentication and Privacy Capabilities\n      \
    \   Extensions to support authentication, data integrity, and\n         (optional)\
    \ data confidentiality are specified for IPv6.\n   This document specifies the\
    \ basic IPv6 header and the initially\n   defined IPv6 extension headers and options.\
    \  It also discusses packet\n   size issues, the semantics of flow labels and\
    \ traffic classes, and\n   the effects of IPv6 on upper-layer protocols.  The\
    \ format and\n   semantics of IPv6 addresses are specified separately in [RFC4291].\n\
    \   The IPv6 version of ICMP, which all IPv6 implementations are required\n  \
    \ to include, is specified in [RFC4443].\n   The data transmission order for IPv6\
    \ is the same as for IPv4 as\n   defined in Appendix B of [RFC791].\n   Note:\
    \ As this document obsoletes [RFC2460], any document referenced\n   in this document\
    \ that includes pointers to RFC 2460 should be\n   interpreted as referencing\
    \ this document.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   node         a device that implements IPv6.\n   router  \
    \     a node that forwards IPv6 packets not explicitly\n                addressed\
    \ to itself.  (See Note below.)\n   host         any node that is not a router.\
    \  (See Note below.)\n   upper layer  a protocol layer immediately above IPv6.\
    \  Examples are\n                transport protocols such as TCP and UDP, control\n\
    \                protocols such as ICMP, routing protocols such as OSPF,\n   \
    \             and internet-layer or lower-layer protocols being\n            \
    \    \"tunneled\" over (i.e., encapsulated in) IPv6 such as\n                Internetwork\
    \ Packet Exchange (IPX), AppleTalk, or IPv6\n                itself.\n   link\
    \         a communication facility or medium over which nodes can\n          \
    \      communicate at the link layer, i.e., the layer\n                immediately\
    \ below IPv6.  Examples are Ethernets (simple\n                or bridged); PPP\
    \ links; X.25, Frame Relay, or ATM\n                networks; and internet-layer\
    \ or higher-layer \"tunnels\",\n                such as tunnels over IPv4 or IPv6\
    \ itself.\n   neighbors    nodes attached to the same link.\n   interface    a\
    \ node's attachment to a link.\n   address      an IPv6-layer identifier for an\
    \ interface or a set of\n                interfaces.\n   packet       an IPv6\
    \ header plus payload.\n   link MTU     the maximum transmission unit, i.e., maximum\
    \ packet size\n                in octets, that can be conveyed over a link.\n\
    \   path MTU     the minimum link MTU of all the links in a path between\n   \
    \             a source node and a destination node.\n   Note: it is possible for\
    \ a device with multiple interfaces to be\n   configured to forward non-self-destined\
    \ packets arriving from some\n   set (fewer than all) of its interfaces and to\
    \ discard non-self-\n   destined packets arriving from its other interfaces. \
    \ Such a device\n   must obey the protocol requirements for routers when receiving\n\
    \   packets from, and interacting with neighbors over, the former\n   (forwarding)\
    \ interfaces.  It must obey the protocol requirements for\n   hosts when receiving\
    \ packets from, and interacting with neighbors\n   over, the latter (non-forwarding)\
    \ interfaces.\n"
- title: 3.  IPv6 Header Format
  contents:
  - "3.  IPv6 Header Format\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Version| Traffic Class |           Flow Label                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Payload Length        |  Next Header  |   Hop Limit   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \           Source Address                        +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        Destination Address                      +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Version             4-bit Internet Protocol version number = 6.\n     \
    \ Traffic Class       8-bit Traffic Class field.  See Section 7.\n      Flow Label\
    \          20-bit flow label.  See Section 6.\n      Payload Length      16-bit\
    \ unsigned integer.  Length of the IPv6\n                          payload, i.e.,\
    \ the rest of the packet\n                          following this IPv6 header,\
    \ in octets.  (Note\n                          that any extension headers (see\
    \ Section 4)\n                          present are considered part of the payload,\n\
    \                          i.e., included in the length count.)\n      Next Header\
    \         8-bit selector.  Identifies the type of header\n                   \
    \       immediately following the IPv6 header.  Uses\n                       \
    \   the same values as the IPv4 Protocol field\n                          [IANA-PN].\n\
    \      Hop Limit           8-bit unsigned integer.  Decremented by 1 by\n    \
    \                      each node that forwards the packet.  When\n           \
    \               forwarding, the packet is discarded if Hop\n                 \
    \         Limit was zero when received or is decremented\n                   \
    \       to zero.  A node that is the destination of a\n                      \
    \    packet should not discard a packet with Hop\n                          Limit\
    \ equal to zero; it should process the\n                          packet normally.\n\
    \      Source Address      128-bit address of the originator of the\n        \
    \                  packet.  See [RFC4291].\n      Destination Address 128-bit\
    \ address of the intended recipient of\n                          the packet (possibly\
    \ not the ultimate\n                          recipient, if a Routing header is\
    \ present).\n                          See [RFC4291] and Section 4.4.\n"
- title: 4.  IPv6 Extension Headers
  contents:
  - "4.  IPv6 Extension Headers\n   In IPv6, optional internet-layer information is\
    \ encoded in separate\n   headers that may be placed between the IPv6 header and\
    \ the upper-\n   layer header in a packet.  There is a small number of such extension\n\
    \   headers, each one identified by a distinct Next Header value.\n   Extension\
    \ headers are numbered from IANA IP Protocol Numbers\n   [IANA-PN], the same values\
    \ used for IPv4 and IPv6.  When processing a\n   sequence of Next Header values\
    \ in a packet, the first one that is not\n   an extension header [IANA-EH] indicates\
    \ that the next item in the\n   packet is the corresponding upper-layer header.\
    \  A special \"No Next\n   Header\" value is used if there is no upper-layer header.\n\
    \   As illustrated in these examples, an IPv6 packet may carry zero, one,\n  \
    \ or more extension headers, each identified by the Next Header field\n   of the\
    \ preceding header:\n   +---------------+------------------------\n   |  IPv6\
    \ header  | TCP header + data\n   |               |\n   | Next Header = |\n  \
    \ |      TCP      |\n   +---------------+------------------------\n   +---------------+----------------+------------------------\n\
    \   |  IPv6 header  | Routing header | TCP header + data\n   |               |\
    \                |\n   | Next Header = |  Next Header = |\n   |    Routing   \
    \ |      TCP       |\n   +---------------+----------------+------------------------\n\
    \   +---------------+----------------+-----------------+-----------------\n  \
    \ |  IPv6 header  | Routing header | Fragment header | fragment of TCP\n   | \
    \              |                |                 |  header + data\n   | Next\
    \ Header = |  Next Header = |  Next Header =  |\n   |    Routing    |    Fragment\
    \    |       TCP       |\n   +---------------+----------------+-----------------+-----------------\n\
    \   Extension headers (except for the Hop-by-Hop Options header) are not\n   processed,\
    \ inserted, or deleted by any node along a packet's delivery\n   path, until the\
    \ packet reaches the node (or each of the set of nodes,\n   in the case of multicast)\
    \ identified in the Destination Address field\n   of the IPv6 header.\n   The\
    \ Hop-by-Hop Options header is not inserted or deleted, but may be\n   examined\
    \ or processed by any node along a packet's delivery path,\n   until the packet\
    \ reaches the node (or each of the set of nodes, in\n   the case of multicast)\
    \ identified in the Destination Address field of\n   the IPv6 header.  The Hop-by-Hop\
    \ Options header, when present, must\n   immediately follow the IPv6 header. \
    \ Its presence is indicated by the\n   value zero in the Next Header field of\
    \ the IPv6 header.\n   NOTE: While [RFC2460] required that all nodes must examine\
    \ and\n   process the Hop-by-Hop Options header, it is now expected that nodes\n\
    \   along a packet's delivery path only examine and process the\n   Hop-by-Hop\
    \ Options header if explicitly configured to do so.\n   At the destination node,\
    \ normal demultiplexing on the Next Header\n   field of the IPv6 header invokes\
    \ the module to process the first\n   extension header, or the upper-layer header\
    \ if no extension header is\n   present.  The contents and semantics of each extension\
    \ header\n   determine whether or not to proceed to the next header.  Therefore,\n\
    \   extension headers must be processed strictly in the order they appear\n  \
    \ in the packet; a receiver must not, for example, scan through a\n   packet looking\
    \ for a particular kind of extension header and process\n   that header prior\
    \ to processing all preceding ones.\n   If, as a result of processing a header,\
    \ the destination node is\n   required to proceed to the next header but the Next\
    \ Header value in\n   the current header is unrecognized by the node, it should\
    \ discard the\n   packet and send an ICMP Parameter Problem message to the source\
    \ of\n   the packet, with an ICMP Code value of 1 (\"unrecognized Next Header\n\
    \   type encountered\") and the ICMP Pointer field containing the offset\n   of\
    \ the unrecognized value within the original packet.  The same\n   action should\
    \ be taken if a node encounters a Next Header value of\n   zero in any header\
    \ other than an IPv6 header.\n   Each extension header is an integer multiple\
    \ of 8 octets long, in\n   order to retain 8-octet alignment for subsequent headers.\
    \  Multi-\n   octet fields within each extension header are aligned on their\n\
    \   natural boundaries, i.e., fields of width n octets are placed at an\n   integer\
    \ multiple of n octets from the start of the header, for n = 1,\n   2, 4, or 8.\n\
    \   A full implementation of IPv6 includes implementation of the\n   following\
    \ extension headers:\n      Hop-by-Hop Options\n      Fragment\n      Destination\
    \ Options\n      Routing\n      Authentication\n      Encapsulating Security Payload\n\
    \   The first four are specified in this document; the last two are\n   specified\
    \ in [RFC4302] and [RFC4303], respectively.  The current list\n   of IPv6 extension\
    \ headers can be found at [IANA-EH].\n"
- title: 4.1.  Extension Header Order
  contents:
  - "4.1.  Extension Header Order\n   When more than one extension header is used\
    \ in the same packet, it is\n   recommended that those headers appear in the following\
    \ order:\n      IPv6 header\n      Hop-by-Hop Options header\n      Destination\
    \ Options header (note 1)\n      Routing header\n      Fragment header\n     \
    \ Authentication header (note 2)\n      Encapsulating Security Payload header\
    \ (note 2)\n      Destination Options header (note 3)\n      Upper-Layer header\n\
    \      note 1: for options to be processed by the first destination that\n   \
    \           appears in the IPv6 Destination Address field plus\n             \
    \ subsequent destinations listed in the Routing header.\n      note 2: additional\
    \ recommendations regarding the relative order of\n              the Authentication\
    \ and Encapsulating Security Payload\n              headers are given in [RFC4303].\n\
    \      note 3: for options to be processed only by the final destination\n   \
    \           of the packet.\n   Each extension header should occur at most once,\
    \ except for the\n   Destination Options header, which should occur at most twice\
    \ (once\n   before a Routing header and once before the upper-layer header).\n\
    \   If the upper-layer header is another IPv6 header (in the case of IPv6\n  \
    \ being tunneled over or encapsulated in IPv6), it may be followed by\n   its\
    \ own extension headers, which are separately subject to the same\n   ordering\
    \ recommendations.\n   If and when other extension headers are defined, their\
    \ ordering\n   constraints relative to the above listed headers must be specified.\n\
    \   IPv6 nodes must accept and attempt to process extension headers in\n   any\
    \ order and occurring any number of times in the same packet,\n   except for the\
    \ Hop-by-Hop Options header, which is restricted to\n   appear immediately after\
    \ an IPv6 header only.  Nonetheless, it is\n   strongly advised that sources of\
    \ IPv6 packets adhere to the above\n   recommended order until and unless subsequent\
    \ specifications revise\n   that recommendation.\n"
- title: 4.2.  Options
  contents:
  - "4.2.  Options\n   Two of the currently defined extension headers specified in\
    \ this\n   document -- the Hop-by-Hop Options header and the Destination Options\n\
    \   header -- carry a variable number of \"options\" that are type-length-\n \
    \  value (TLV) encoded in the following format:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ - - - - - - - -\n      |  Option Type  |  Opt Data Len |  Option Data\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -\n      Option Type     \
    \    8-bit identifier of the type of option.\n      Opt Data Len        8-bit\
    \ unsigned integer.  Length of the Option\n                          Data field\
    \ of this option, in octets.\n      Option Data         Variable-length field.\
    \  Option-Type-specific\n                          data.\n   The sequence of options\
    \ within a header must be processed strictly in\n   the order they appear in the\
    \ header; a receiver must not, for\n   example, scan through the header looking\
    \ for a particular kind of\n   option and process that option prior to processing\
    \ all preceding\n   ones.\n   The Option Type identifiers are internally encoded\
    \ such that their\n   highest-order 2 bits specify the action that must be taken\
    \ if the\n   processing IPv6 node does not recognize the Option Type:\n      00\
    \ - skip over this option and continue processing the header.\n      01 - discard\
    \ the packet.\n      10 - discard the packet and, regardless of whether or not\
    \ the\n           packet's Destination Address was a multicast address, send an\n\
    \           ICMP Parameter Problem, Code 2, message to the packet's\n        \
    \   Source Address, pointing to the unrecognized Option Type.\n      11 - discard\
    \ the packet and, only if the packet's Destination\n           Address was not\
    \ a multicast address, send an ICMP Parameter\n           Problem, Code 2, message\
    \ to the packet's Source Address,\n           pointing to the unrecognized Option\
    \ Type.\n   The third-highest-order bit of the Option Type specifies whether or\n\
    \   not the Option Data of that option can change en route to the\n   packet's\
    \ final destination.  When an Authentication header is present\n   in the packet,\
    \ for any option whose data may change en route, its\n   entire Option Data field\
    \ must be treated as zero-valued octets when\n   computing or verifying the packet's\
    \ authenticating value.\n       0 - Option Data does not change en route\n   \
    \    1 - Option Data may change en route\n   The three high-order bits described\
    \ above are to be treated as part\n   of the Option Type, not independent of the\
    \ Option Type.  That is, a\n   particular option is identified by a full 8-bit\
    \ Option Type, not just\n   the low-order 5 bits of an Option Type.\n   The same\
    \ Option Type numbering space is used for both the Hop-by-Hop\n   Options header\
    \ and the Destination Options header.  However, the\n   specification of a particular\
    \ option may restrict its use to only one\n   of those two headers.\n   Individual\
    \ options may have specific alignment requirements, to\n   ensure that multi-octet\
    \ values within Option Data fields fall on\n   natural boundaries.  The alignment\
    \ requirement of an option is\n   specified using the notation xn+y, meaning the\
    \ Option Type must\n   appear at an integer multiple of x octets from the start\
    \ of the\n   header, plus y octets.  For example:\n      2n     means any 2-octet\
    \ offset from the start of the header.\n      8n+2   means any 8-octet offset\
    \ from the start of the header, plus\n             2 octets.\n   There are two\
    \ padding options that are used when necessary to align\n   subsequent options\
    \ and to pad out the containing header to a multiple\n   of 8 octets in length.\
    \  These padding options must be recognized by\n   all IPv6 implementations:\n\
    \   Pad1 option (alignment requirement: none)\n      +-+-+-+-+-+-+-+-+\n     \
    \ |       0       |\n      +-+-+-+-+-+-+-+-+\n      NOTE! the format of the Pad1\
    \ option is a special case -- it does\n            not have length and value fields.\n\
    \      The Pad1 option is used to insert 1 octet of padding into the\n      Options\
    \ area of a header.  If more than one octet of padding is\n      required, the\
    \ PadN option, described next, should be used, rather\n      than multiple Pad1\
    \ options.\n   PadN option (alignment requirement: none)\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ - - - - - - - -\n      |       1       |  Opt Data Len |  Option Data\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -\n      The PadN option is\
    \ used to insert two or more octets of padding\n      into the Options area of\
    \ a header.  For N octets of padding, the\n      Opt Data Len field contains the\
    \ value N-2, and the Option Data\n      consists of N-2 zero-valued octets.\n\
    \   Appendix A contains formatting guidelines for designing new options.\n"
- title: 4.3.  Hop-by-Hop Options Header
  contents:
  - "4.3.  Hop-by-Hop Options Header\n   The Hop-by-Hop Options header is used to\
    \ carry optional information\n   that may be examined and processed by every node\
    \ along a packet's\n   delivery path.  The Hop-by-Hop Options header is identified\
    \ by a Next\n   Header value of 0 in the IPv6 header and has the following format:\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \  Next Header  |  Hdr Ext Len  |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    |                                     \
    \                          |\n    .                                          \
    \                     .\n    .                            Options            \
    \                .\n    .                                                    \
    \           .\n    |                                                         \
    \      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Next Header         8-bit selector.  Identifies the type of header\n  \
    \                        immediately following the Hop-by-Hop Options\n      \
    \                    header.  Uses the same values as the IPv4\n             \
    \             Protocol field [IANA-PN].\n      Hdr Ext Len         8-bit unsigned\
    \ integer.  Length of the\n                          Hop-by-Hop Options header\
    \ in 8-octet units,\n                          not including the first 8 octets.\n\
    \      Options             Variable-length field, of length such that the\n  \
    \                        complete Hop-by-Hop Options header is an\n          \
    \                integer multiple of 8 octets long.  Contains\n              \
    \            one or more TLV-encoded options, as described\n                 \
    \         in Section 4.2.\n   The only hop-by-hop options defined in this document\
    \ are the Pad1 and\n   PadN options specified in Section 4.2.\n"
- title: 4.4.  Routing Header
  contents:
  - "4.4.  Routing Header\n   The Routing header is used by an IPv6 source to list\
    \ one or more\n   intermediate nodes to be \"visited\" on the way to a packet's\n\
    \   destination.  This function is very similar to IPv4's Loose Source\n   and\
    \ Record Route option.  The Routing header is identified by a Next\n   Header\
    \ value of 43 in the immediately preceding header and has the\n   following format:\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \  Next Header  |  Hdr Ext Len  |  Routing Type | Segments Left |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    .\
    \                                                               .\n    .     \
    \                  type-specific data                      .\n    .          \
    \                                                     .\n    |               \
    \                                                |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Next Header         8-bit selector.  Identifies the type of header\n  \
    \                        immediately following the Routing header.\n         \
    \                 Uses the same values as the IPv4 Protocol\n                \
    \          field [IANA-PN].\n      Hdr Ext Len         8-bit unsigned integer.\
    \  Length of the Routing\n                          header in 8-octet units, not\
    \ including the\n                          first 8 octets.\n      Routing Type\
    \        8-bit identifier of a particular Routing\n                          header\
    \ variant.\n      Segments Left       8-bit unsigned integer.  Number of route\n\
    \                          segments remaining, i.e., number of explicitly\n  \
    \                        listed intermediate nodes still to be visited\n     \
    \                     before reaching the final destination.\n      type-specific\
    \ data  Variable-length field, of format determined by\n                     \
    \     the Routing Type, and of length such that the\n                        \
    \  complete Routing header is an integer multiple\n                          of\
    \ 8 octets long.\n   If, while processing a received packet, a node encounters\
    \ a Routing\n   header with an unrecognized Routing Type value, the required behavior\n\
    \   of the node depends on the value of the Segments Left field, as\n   follows:\n\
    \      If Segments Left is zero, the node must ignore the Routing header\n   \
    \   and proceed to process the next header in the packet, whose type\n      is\
    \ identified by the Next Header field in the Routing header.\n      If Segments\
    \ Left is non-zero, the node must discard the packet and\n      send an ICMP Parameter\
    \ Problem, Code 0, message to the packet's\n      Source Address, pointing to\
    \ the unrecognized Routing Type.\n   If, after processing a Routing header of\
    \ a received packet, an\n   intermediate node determines that the packet is to\
    \ be forwarded onto\n   a link whose link MTU is less than the size of the packet,\
    \ the node\n   must discard the packet and send an ICMP Packet Too Big message\
    \ to\n   the packet's Source Address.\n   The currently defined IPv6 Routing Headers\
    \ and their status can be\n   found at [IANA-RH].  Allocation guidelines for IPv6\
    \ Routing Headers\n   can be found in [RFC5871].\n"
- title: 4.5.  Fragment Header
  contents:
  - "4.5.  Fragment Header\n   The Fragment header is used by an IPv6 source to send\
    \ a packet larger\n   than would fit in the path MTU to its destination.  (Note:\
    \ unlike\n   IPv4, fragmentation in IPv6 is performed only by source nodes, not\
    \ by\n   routers along a packet's delivery path -- see Section 5.)  The\n   Fragment\
    \ header is identified by a Next Header value of 44 in the\n   immediately preceding\
    \ header and has the following format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  |   Reserved    |      Fragment Offset    |Res|M|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Identification                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Next Header         8-bit selector.  Identifies the initial header\n  \
    \                        type of the Fragmentable Part of the original\n     \
    \                     packet (defined below).  Uses the same values\n        \
    \                  as the IPv4 Protocol field [IANA-PN].\n      Reserved     \
    \       8-bit reserved field.  Initialized to zero for\n                     \
    \     transmission; ignored on reception.\n      Fragment Offset     13-bit unsigned\
    \ integer.  The offset, in\n                          8-octet units, of the data\
    \ following this\n                          header, relative to the start of the\n\
    \                          Fragmentable Part of the original packet.\n      Res\
    \                 2-bit reserved field.  Initialized to zero for\n           \
    \               transmission; ignored on reception.\n      M flag            \
    \  1 = more fragments; 0 = last fragment.\n      Identification      32 bits.\
    \  See description below.\n   In order to send a packet that is too large to fit\
    \ in the MTU of the\n   path to its destination, a source node may divide the\
    \ packet into\n   fragments and send each fragment as a separate packet, to be\n\
    \   reassembled at the receiver.\n   For every packet that is to be fragmented,\
    \ the source node generates\n   an Identification value.  The Identification must\
    \ be different than\n   that of any other fragmented packet sent recently* with\
    \ the same\n   Source Address and Destination Address.  If a Routing header is\n\
    \   present, the Destination Address of concern is that of the final\n   destination.\n\
    \      *  \"recently\" means within the maximum likely lifetime of a\n       \
    \  packet, including transit time from source to destination and\n         time\
    \ spent awaiting reassembly with other fragments of the same\n         packet.\
    \  However, it is not required that a source node knows\n         the maximum\
    \ packet lifetime.  Rather, it is assumed that the\n         requirement can be\
    \ met by implementing an algorithm that\n         results in a low identification\
    \ reuse frequency.  Examples of\n         algorithms that can meet this requirement\
    \ are described in\n         [RFC7739].\n   The initial, large, unfragmented packet\
    \ is referred to as the\n   \"original packet\", and it is considered to consist\
    \ of three parts, as\n   illustrated:\n   original packet:\n   +------------------+-------------------------+---//----------------+\n\
    \   |  Per-Fragment    | Extension & Upper-Layer |   Fragmentable      |\n   |\
    \    Headers       |       Headers           |      Part           |\n   +------------------+-------------------------+---//----------------+\n\
    \      The Per-Fragment headers must consist of the IPv6 header plus any\n   \
    \   extension headers that must be processed by nodes en route to the\n      destination,\
    \ that is, all headers up to and including the Routing\n      header if present,\
    \ else the Hop-by-Hop Options header if present,\n      else no extension headers.\n\
    \      The Extension headers are all other extension headers that are not\n  \
    \    included in the Per-Fragment headers part of the packet.  For this\n    \
    \  purpose, the Encapsulating Security Payload (ESP) is not\n      considered\
    \ an extension header.  The Upper-Layer header is the\n      first upper-layer\
    \ header that is not an IPv6 extension header.\n      Examples of upper-layer\
    \ headers include TCP, UDP, IPv4, IPv6,\n      ICMPv6, and as noted ESP.\n   \
    \   The Fragmentable Part consists of the rest of the packet after the\n     \
    \ upper-layer header or after any header (i.e., initial IPv6 header\n      or\
    \ extension header) that contains a Next Header value of No Next\n      Header.\n\
    \   The Fragmentable Part of the original packet is divided into\n   fragments.\
    \  The lengths of the fragments must be chosen such that the\n   resulting fragment\
    \ packets fit within the MTU of the path to the\n   packet's destination(s). \
    \ Each complete fragment, except possibly the\n   last (\"rightmost\") one, is\
    \ an integer multiple of 8 octets long.\n   The fragments are transmitted in separate\
    \ \"fragment packets\" as\n   illustrated:\n   original packet:\n   +-----------------+-----------------+--------+--------+-//-+--------+\n\
    \   |  Per-Fragment   |Ext & Upper-Layer|  first | second |    |  last  |\n  \
    \ |    Headers      |    Headers      |fragment|fragment|....|fragment|\n   +-----------------+-----------------+--------+--------+-//-+--------+\n\
    \   fragment packets:\n   +------------------+---------+-------------------+----------+\n\
    \   |  Per-Fragment    |Fragment | Ext & Upper-Layer |  first   |\n   |    Headers\
    \       | Header  |   Headers         | fragment |\n   +------------------+---------+-------------------+----------+\n\
    \   +------------------+--------+-------------------------------+\n   |  Per-Fragment\
    \    |Fragment|    second                     |\n   |    Headers       | Header\
    \ |   fragment                    |\n   +------------------+--------+-------------------------------+\n\
    \                         o\n                         o\n                    \
    \     o\n   +------------------+--------+----------+\n   |  Per-Fragment    |Fragment|\
    \   last   |\n   |    Headers       | Header | fragment |\n   +------------------+--------+----------+\n\
    \   The first fragment packet is composed of:\n      (1)  The Per-Fragment headers\
    \ of the original packet, with the\n           Payload Length of the original\
    \ IPv6 header changed to contain\n           the length of this fragment packet\
    \ only (excluding the length\n           of the IPv6 header itself), and the Next\
    \ Header field of the\n           last header of the Per-Fragment headers changed\
    \ to 44.\n      (2)  A Fragment header containing:\n              The Next Header\
    \ value that identifies the first header\n              after the Per-Fragment\
    \ headers of the original packet.\n              A Fragment Offset containing\
    \ the offset of the fragment,\n              in 8-octet units, relative to the\
    \ start of the\n              Fragmentable Part of the original packet.  The Fragment\n\
    \              Offset of the first (\"leftmost\") fragment is 0.\n           \
    \   An M flag value of 1 as this is the first fragment.\n              The Identification\
    \ value generated for the original\n              packet.\n      (3)  Extension\
    \ headers, if any, and the Upper-Layer header.  These\n           headers must\
    \ be in the first fragment.  Note: This restricts\n           the size of the\
    \ headers through the Upper-Layer header to the\n           MTU of the path to\
    \ the packet's destinations(s).\n      (4)  The first fragment.\n   The subsequent\
    \ fragment packets are composed of:\n      (1)  The Per-Fragment headers of the\
    \ original packet, with the\n           Payload Length of the original IPv6 header\
    \ changed to contain\n           the length of this fragment packet only (excluding\
    \ the length\n           of the IPv6 header itself), and the Next Header field\
    \ of the\n           last header of the Per-Fragment headers changed to 44.\n\
    \      (2)  A Fragment header containing:\n              The Next Header value\
    \ that identifies the first header\n              after the Per-Fragment headers\
    \ of the original packet.\n              A Fragment Offset containing the offset\
    \ of the fragment,\n              in 8-octet units, relative to the start of the\n\
    \              Fragmentable Part of the original packet.\n              An M flag\
    \ value of 0 if the fragment is the last\n              (\"rightmost\") one, else\
    \ an M flag value of 1.\n              The Identification value generated for\
    \ the original\n              packet.\n      (3)  The fragment itself.\n   Fragments\
    \ must not be created that overlap with any other fragments\n   created from the\
    \ original packet.\n   At the destination, fragment packets are reassembled into\
    \ their\n   original, unfragmented form, as illustrated:\n   reassembled original\
    \ packet:\n   +---------------+-----------------+---------+--------+-//--+--------+\n\
    \   | Per-Fragment  |Ext & Upper-Layer|  first  | second |     | last   |\n  \
    \ |    Headers    |     Headers     |frag data|fragment|.....|fragment|\n   +---------------+-----------------+---------+--------+-//--+--------+\n\
    \   The following rules govern reassembly:\n      An original packet is reassembled\
    \ only from fragment packets that\n      have the same Source Address, Destination\
    \ Address, and Fragment\n      Identification.\n      The Per-Fragment headers\
    \ of the reassembled packet consists of all\n      headers up to, but not including,\
    \ the Fragment header of the first\n      fragment packet (that is, the packet\
    \ whose Fragment Offset is\n      zero), with the following two changes:\n   \
    \      The Next Header field of the last header of the Per-Fragment\n        \
    \ headers is obtained from the Next Header field of the first\n         fragment's\
    \ Fragment header.\n         The Payload Length of the reassembled packet is computed\
    \ from\n         the length of the Per-Fragment headers and the length and\n \
    \        offset of the last fragment.  For example, a formula for\n         computing\
    \ the Payload Length of the reassembled original packet\n         is:\n      \
    \      PL.orig = PL.first - FL.first - 8 + (8 * FO.last) + FL.last\n         \
    \   where\n            PL.orig  =  Payload Length field of reassembled packet.\n\
    \            PL.first =  Payload Length field of first fragment packet.\n    \
    \        FL.first =  length of fragment following Fragment header of\n       \
    \                 first fragment packet.\n            FO.last  =  Fragment Offset\
    \ field of Fragment header of last\n                        fragment packet.\n\
    \            FL.last  =  length of fragment following Fragment header of\n   \
    \                     last fragment packet.\n         The Fragmentable Part of\
    \ the reassembled packet is constructed\n         from the fragments following\
    \ the Fragment headers in each of\n         the fragment packets.  The length\
    \ of each fragment is computed\n         by subtracting from the packet's Payload\
    \ Length the length of\n         the headers between the IPv6 header and fragment\
    \ itself; its\n         relative position in Fragmentable Part is computed from\
    \ its\n         Fragment Offset value.\n         The Fragment header is not present\
    \ in the final, reassembled\n         packet.\n         If the fragment is a whole\
    \ datagram (that is, both the Fragment\n         Offset field and the M flag are\
    \ zero), then it does not need\n         any further reassembly and should be\
    \ processed as a fully\n         reassembled packet (i.e., updating Next Header,\
    \ adjust Payload\n         Length, removing the Fragment header, etc.).  Any other\n\
    \         fragments that match this packet (i.e., the same IPv6 Source\n     \
    \    Address, IPv6 Destination Address, and Fragment Identification)\n       \
    \  should be processed independently.\n   The following error conditions may arise\
    \ when reassembling fragmented\n   packets:\n      o  If insufficient fragments\
    \ are received to complete reassembly\n         of a packet within 60 seconds\
    \ of the reception of the first-\n         arriving fragment of that packet, reassembly\
    \ of that packet\n         must be abandoned and all the fragments that have been\
    \ received\n         for that packet must be discarded.  If the first fragment\n\
    \         (i.e., the one with a Fragment Offset of zero) has been\n         received,\
    \ an ICMP Time Exceeded -- Fragment Reassembly Time\n         Exceeded message\
    \ should be sent to the source of that fragment.\n      o  If the length of a\
    \ fragment, as derived from the fragment\n         packet's Payload Length field,\
    \ is not a multiple of 8 octets\n         and the M flag of that fragment is 1,\
    \ then that fragment must\n         be discarded and an ICMP Parameter Problem,\
    \ Code 0, message\n         should be sent to the source of the fragment, pointing\
    \ to the\n         Payload Length field of the fragment packet.\n      o  If the\
    \ length and offset of a fragment are such that the\n         Payload Length of\
    \ the packet reassembled from that fragment\n         would exceed 65,535 octets,\
    \ then that fragment must be\n         discarded and an ICMP Parameter Problem,\
    \ Code 0, message should\n         be sent to the source of the fragment, pointing\
    \ to the Fragment\n         Offset field of the fragment packet.\n      o  If\
    \ the first fragment does not include all headers through an\n         Upper-Layer\
    \ header, then that fragment should be discarded and\n         an ICMP Parameter\
    \ Problem, Code 3, message should be sent to\n         the source of the fragment,\
    \ with the Pointer field set to zero.\n      o  If any of the fragments being\
    \ reassembled overlap with any\n         other fragments being reassembled for\
    \ the same packet,\n         reassembly of that packet must be abandoned and all\
    \ the\n         fragments that have been received for that packet must be\n  \
    \       discarded, and no ICMP error messages should be sent.\n         It should\
    \ be noted that fragments may be duplicated in the\n         network.  Instead\
    \ of treating these exact duplicate fragments\n         as overlapping fragments,\
    \ an implementation may choose to\n         detect this case and drop exact duplicate\
    \ fragments while\n         keeping the other fragments belonging to the same\
    \ packet.\n   The following conditions are not expected to occur frequently but\
    \ are\n   not considered errors if they do:\n      The number and content of the\
    \ headers preceding the Fragment\n      header of different fragments of the same\
    \ original packet may\n      differ.  Whatever headers are present, preceding\
    \ the Fragment\n      header in each fragment packet, are processed when the packets\n\
    \      arrive, prior to queueing the fragments for reassembly.  Only\n      those\
    \ headers in the Offset zero fragment packet are retained in\n      the reassembled\
    \ packet.\n      The Next Header values in the Fragment headers of different\n\
    \      fragments of the same original packet may differ.  Only the value\n   \
    \   from the Offset zero fragment packet is used for reassembly.\n      Other\
    \ fields in the IPv6 header may also vary across the fragments\n      being reassembled.\
    \  Specifications that use these fields may\n      provide additional instructions\
    \ if the basic mechanism of using\n      the values from the Offset zero fragment\
    \ is not sufficient.  For\n      example, Section 5.3 of [RFC3168] describes how\
    \ to combine the\n      Explicit Congestion Notification (ECN) bits from different\n\
    \      fragments to derive the ECN bits of the reassembled packet.\n"
- title: 4.6.  Destination Options Header
  contents:
  - "4.6.  Destination Options Header\n   The Destination Options header is used to\
    \ carry optional information\n   that need be examined only by a packet's destination\
    \ node(s).  The\n   Destination Options header is identified by a Next Header\
    \ value of 60\n   in the immediately preceding header and has the following format:\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \  Next Header  |  Hdr Ext Len  |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    |                                     \
    \                          |\n    .                                          \
    \                     .\n    .                            Options            \
    \                .\n    .                                                    \
    \           .\n    |                                                         \
    \      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Next Header         8-bit selector.  Identifies the type of header\n  \
    \                        immediately following the Destination Options\n     \
    \                     header.  Uses the same values as the IPv4\n            \
    \              Protocol field [IANA-PN].\n      Hdr Ext Len         8-bit unsigned\
    \ integer.  Length of the\n                          Destination Options header\
    \ in 8-octet units,\n                          not including the first 8 octets.\n\
    \      Options             Variable-length field, of length such that the\n  \
    \                        complete Destination Options header is an\n         \
    \                 integer multiple of 8 octets long.  Contains\n             \
    \             one or more TLV-encoded options, as described\n                \
    \          in Section 4.2.\n   The only destination options defined in this document\
    \ are the Pad1\n   and PadN options specified in Section 4.2.\n   Note that there\
    \ are two possible ways to encode optional destination\n   information in an IPv6\
    \ packet: either as an option in the Destination\n   Options header or as a separate\
    \ extension header.  The Fragment\n   header and the Authentication header are\
    \ examples of the latter\n   approach.  Which approach can be used depends on\
    \ what action is\n   desired of a destination node that does not understand the\
    \ optional\n   information:\n      o  If the desired action is for the destination\
    \ node to discard\n         the packet and, only if the packet's Destination Address\
    \ is not\n         a multicast address, send an ICMP Unrecognized Type message\
    \ to\n         the packet's Source Address, then the information may be\n    \
    \     encoded either as a separate header or as an option in the\n         Destination\
    \ Options header whose Option Type has the value 11\n         in its highest-order\
    \ 2 bits.  The choice may depend on such\n         factors as which takes fewer\
    \ octets, or which yields better\n         alignment or more efficient parsing.\n\
    \      o  If any other action is desired, the information must be encoded\n  \
    \       as an option in the Destination Options header whose Option\n        \
    \ Type has the value 00, 01, or 10 in its highest-order 2 bits,\n         specifying\
    \ the desired action (see Section 4.2).\n"
- title: 4.7.  No Next Header
  contents:
  - "4.7.  No Next Header\n   The value 59 in the Next Header field of an IPv6 header\
    \ or any\n   extension header indicates that there is nothing following that\n\
    \   header.  If the Payload Length field of the IPv6 header indicates the\n  \
    \ presence of octets past the end of a header whose Next Header field\n   contains\
    \ 59, those octets must be ignored and passed on unchanged if\n   the packet is\
    \ forwarded.\n"
- title: 4.8.  Defining New Extension Headers and Options
  contents:
  - "4.8.  Defining New Extension Headers and Options\n   Defining new IPv6 extension\
    \ headers is not recommended, unless there\n   are no existing IPv6 extension\
    \ headers that can be used by specifying\n   a new option for that IPv6 extension\
    \ header.  A proposal to specify a\n   new IPv6 extension header must include\
    \ a detailed technical\n   explanation of why an existing IPv6 extension header\
    \ can not be used\n   for the desired new function.  See [RFC6564] for additional\n\
    \   background information.\n   Note: New extension headers that require hop-by-hop\
    \ behavior must not\n   be defined because, as specified in Section 4 of this\
    \ document, the\n   only extension header that has hop-by-hop behavior is the\
    \ Hop-by-Hop\n   Options header.\n   New hop-by-hop options are not recommended\
    \ because nodes may be\n   configured to ignore the Hop-by-Hop Options header,\
    \ drop packets\n   containing a Hop-by-Hop Options header, or assign packets containing\n\
    \   a Hop-by-Hop Options header to a slow processing path.  Designers\n   considering\
    \ defining new hop-by-hop options need to be aware of this\n   likely behavior.\
    \  There has to be a very clear justification why any\n   new hop-by-hop option\
    \ is needed before it is standardized.\n   Instead of defining new extension headers,\
    \ it is recommended that the\n   Destination Options header is used to carry optional\
    \ information that\n   must be examined only by a packet's destination node(s),\
    \ because they\n   provide better handling and backward compatibility.\n   If\
    \ new extension headers are defined, they need to use the following\n   format:\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \  Next Header  |  Hdr Ext Len  |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    |                                     \
    \                          |\n    .                                          \
    \                     .\n    .                  Header-Specific Data         \
    \                .\n    .                                                    \
    \           .\n    |                                                         \
    \      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Next Header           8-bit selector.  Identifies the type of\n       \
    \                     header immediately following the extension\n           \
    \                 header.  Uses the same values as the IPv4\n                \
    \            Protocol field [IANA-PN].\n      Hdr Ext Len           8-bit unsigned\
    \ integer.  Length of the\n                            Destination Options header\
    \ in 8-octet units,\n                            not including the first 8 octets.\n\
    \      Header Specific Data  Variable-length field.  Fields specific to\n    \
    \                        the extension header.\n"
- title: 5.  Packet Size Issues
  contents:
  - "5.  Packet Size Issues\n   IPv6 requires that every link in the Internet have\
    \ an MTU of 1280\n   octets or greater.  This is known as the IPv6 minimum link\
    \ MTU.  On\n   any link that cannot convey a 1280-octet packet in one piece, link-\n\
    \   specific fragmentation and reassembly must be provided at a layer\n   below\
    \ IPv6.\n   Links that have a configurable MTU (for example, PPP links [RFC1661])\n\
    \   must be configured to have an MTU of at least 1280 octets; it is\n   recommended\
    \ that they be configured with an MTU of 1500 octets or\n   greater, to accommodate\
    \ possible encapsulations (i.e., tunneling)\n   without incurring IPv6-layer fragmentation.\n\
    \   From each link to which a node is directly attached, the node must be\n  \
    \ able to accept packets as large as that link's MTU.\n   It is strongly recommended\
    \ that IPv6 nodes implement Path MTU\n   Discovery [RFC8201], in order to discover\
    \ and take advantage of path\n   MTUs greater than 1280 octets.  However, a minimal\
    \ IPv6\n   implementation (e.g., in a boot ROM) may simply restrict itself to\n\
    \   sending packets no larger than 1280 octets, and omit implementation\n   of\
    \ Path MTU Discovery.\n   In order to send a packet larger than a path's MTU,\
    \ a node may use\n   the IPv6 Fragment header to fragment the packet at the source\
    \ and\n   have it reassembled at the destination(s).  However, the use of such\n\
    \   fragmentation is discouraged in any application that is able to\n   adjust\
    \ its packets to fit the measured path MTU (i.e., down to 1280\n   octets).\n\
    \   A node must be able to accept a fragmented packet that, after\n   reassembly,\
    \ is as large as 1500 octets.  A node is permitted to\n   accept fragmented packets\
    \ that reassemble to more than 1500 octets.\n   An upper-layer protocol or application\
    \ that depends on IPv6\n   fragmentation to send packets larger than the MTU of\
    \ a path should\n   not send packets larger than 1500 octets unless it has assurance\
    \ that\n   the destination is capable of reassembling packets of that larger\n\
    \   size.\n"
- title: 6.  Flow Labels
  contents:
  - "6.  Flow Labels\n   The 20-bit Flow Label field in the IPv6 header is used by\
    \ a source to\n   label sequences of packets to be treated in the network as a\
    \ single\n   flow.\n   The current definition of the IPv6 Flow Label can be found\
    \ in\n   [RFC6437].\n"
- title: 7.  Traffic Classes
  contents:
  - "7.  Traffic Classes\n   The 8-bit Traffic Class field in the IPv6 header is used\
    \ by the\n   network for traffic management.  The value of the Traffic Class bits\n\
    \   in a received packet or fragment might be different from the value\n   sent\
    \ by the packet's source.\n   The current use of the Traffic Class field for Differentiated\n\
    \   Services and Explicit Congestion Notification is specified in\n   [RFC2474]\
    \ and [RFC3168].\n"
- title: 8.  Upper-Layer Protocol Issues
  contents:
  - '8.  Upper-Layer Protocol Issues

    '
- title: 8.1.  Upper-Layer Checksums
  contents:
  - "8.1.  Upper-Layer Checksums\n   Any transport or other upper-layer protocol that\
    \ includes the\n   addresses from the IP header in its checksum computation must\
    \ be\n   modified for use over IPv6, to include the 128-bit IPv6 addresses\n \
    \  instead of 32-bit IPv4 addresses.  In particular, the following\n   illustration\
    \ shows the TCP and UDP \"pseudo-header\" for IPv6:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \           Source Address                        +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        Destination Address                      +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Upper-Layer Packet Length                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      zero                     |  Next Header  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      o  If the IPv6 packet contains a Routing header, the Destination\n    \
    \     Address used in the pseudo-header is that of the final\n         destination.\
    \  At the originating node, that address will be in\n         the last element\
    \ of the Routing header; at the recipient(s),\n         that address will be in\
    \ the Destination Address field of the\n         IPv6 header.\n      o  The Next\
    \ Header value in the pseudo-header identifies the\n         upper-layer protocol\
    \ (e.g., 6 for TCP or 17 for UDP).  It will\n         differ from the Next Header\
    \ value in the IPv6 header if there\n         are extension headers between the\
    \ IPv6 header and the upper-\n         layer header.\n      o  The Upper-Layer\
    \ Packet Length in the pseudo-header is the\n         length of the upper-layer\
    \ header and data (e.g., TCP header\n         plus TCP data).  Some upper-layer\
    \ protocols carry their own\n         length information (e.g., the Length field\
    \ in the UDP header);\n         for such protocols, that is the length used in\
    \ the pseudo-\n         header.  Other protocols (such as TCP) do not carry their\
    \ own\n         length information, in which case the length used in the\n   \
    \      pseudo-header is the Payload Length from the IPv6 header, minus\n     \
    \    the length of any extension headers present between the IPv6\n         header\
    \ and the upper-layer header.\n      o  Unlike IPv4, the default behavior when\
    \ UDP packets are\n         originated by an IPv6 node is that the UDP checksum\
    \ is not\n         optional.  That is, whenever originating a UDP packet, an IPv6\n\
    \         node must compute a UDP checksum over the packet and the\n         pseudo-header,\
    \ and, if that computation yields a result of\n         zero, it must be changed\
    \ to hex FFFF for placement in the UDP\n         header.  IPv6 receivers must\
    \ discard UDP packets containing a\n         zero checksum and should log the\
    \ error.\n      o  As an exception to the default behavior, protocols that use\
    \ UDP\n         as a tunnel encapsulation may enable zero-checksum mode for a\n\
    \         specific port (or set of ports) for sending and/or receiving.\n    \
    \     Any node implementing zero-checksum mode must follow the\n         requirements\
    \ specified in \"Applicability Statement for the Use\n         of IPv6 UDP Datagrams\
    \ with Zero Checksums\" [RFC6936].\n   The IPv6 version of ICMP [RFC4443] includes\
    \ the above pseudo-header\n   in its checksum computation; this is a change from\
    \ the IPv4 version\n   of ICMP, which does not include a pseudo-header in its\
    \ checksum.  The\n   reason for the change is to protect ICMP from misdelivery\
    \ or\n   corruption of those fields of the IPv6 header on which it depends,\n\
    \   which, unlike IPv4, are not covered by an internet-layer checksum.\n   The\
    \ Next Header field in the pseudo-header for ICMP contains the\n   value 58, which\
    \ identifies the IPv6 version of ICMP.\n"
- title: 8.2.  Maximum Packet Lifetime
  contents:
  - "8.2.  Maximum Packet Lifetime\n   Unlike IPv4, IPv6 nodes are not required to\
    \ enforce maximum packet\n   lifetime.  That is the reason the IPv4 \"Time-to-Live\"\
    \ field was\n   renamed \"Hop Limit\" in IPv6.  In practice, very few, if any,\
    \ IPv4\n   implementations conform to the requirement that they limit packet\n\
    \   lifetime, so this is not a change in practice.  Any upper-layer\n   protocol\
    \ that relies on the internet layer (whether IPv4 or IPv6) to\n   limit packet\
    \ lifetime ought to be upgraded to provide its own\n   mechanisms for detecting\
    \ and discarding obsolete packets.\n"
- title: 8.3.  Maximum Upper-Layer Payload Size
  contents:
  - "8.3.  Maximum Upper-Layer Payload Size\n   When computing the maximum payload\
    \ size available for upper-layer\n   data, an upper-layer protocol must take into\
    \ account the larger size\n   of the IPv6 header relative to the IPv4 header.\
    \  For example, in\n   IPv4, TCP's Maximum Segment Size (MSS) option is computed\
    \ as the\n   maximum packet size (a default value or a value learned through Path\n\
    \   MTU Discovery) minus 40 octets (20 octets for the minimum-length IPv4\n  \
    \ header and 20 octets for the minimum-length TCP header).  When using\n   TCP\
    \ over IPv6, the MSS must be computed as the maximum packet size\n   minus 60\
    \ octets, because the minimum-length IPv6 header (i.e., an\n   IPv6 header with\
    \ no extension headers) is 20 octets longer than a\n   minimum-length IPv4 header.\n"
- title: 8.4.  Responding to Packets Carrying Routing Headers
  contents:
  - "8.4.  Responding to Packets Carrying Routing Headers\n   When an upper-layer\
    \ protocol sends one or more packets in response to\n   a received packet that\
    \ included a Routing header, the response\n   packet(s) must not include a Routing\
    \ header that was automatically\n   derived by \"reversing\" the received Routing\
    \ header UNLESS the\n   integrity and authenticity of the received Source Address\
    \ and Routing\n   header have been verified (e.g., via the use of an Authentication\n\
    \   header in the received packet).  In other words, only the following\n   kinds\
    \ of packets are permitted in response to a received packet\n   bearing a Routing\
    \ header:\n      o  Response packets that do not carry Routing headers.\n    \
    \  o  Response packets that carry Routing headers that were NOT\n         derived\
    \ by reversing the Routing header of the received packet\n         (for example,\
    \ a Routing header supplied by local\n         configuration).\n      o  Response\
    \ packets that carry Routing headers that were derived\n         by reversing\
    \ the Routing header of the received packet IF AND\n         ONLY IF the integrity\
    \ and authenticity of the Source Address\n         and Routing header from the\
    \ received packet have been verified\n         by the responder.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   RFC 2460 is referenced in a number of IANA registries.\
    \  These\n   include:\n      o  Internet Protocol Version 6 (IPv6) Parameters\
    \ [IANA-6P]\n      o  Assigned Internet Protocol Numbers [IANA-PN]\n      o  ONC\
    \ RPC Network Identifiers (netids) [IANA-NI]\n      o  Network Layer Protocol\
    \ Identifiers (NLPIDs) of Interest\n         [IANA-NL]\n      o  Protocol Registries\
    \ [IANA-PR]\n   The IANA has updated these references to point to this document.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   IPv6, from the viewpoint of the basic format\
    \ and transmission of\n   packets, has security properties that are similar to\
    \ IPv4.  These\n   security issues include:\n      o  Eavesdropping, where on-path\
    \ elements can observe the whole\n         packet (including both contents and\
    \ metadata) of each IPv6\n         datagram.\n      o  Replay, where the attacker\
    \ records a sequence of packets off of\n         the wire and plays them back\
    \ to the party that originally\n         received them.\n      o  Packet insertion,\
    \ where the attacker forges a packet with some\n         chosen set of properties\
    \ and injects it into the network.\n      o  Packet deletion, where the attacker\
    \ removes a packet from the\n         wire.\n      o  Packet modification, where\
    \ the attacker removes a packet from\n         the wire, modifies it, and reinjects\
    \ it into the network.\n      o  Man-in-the-middle (MITM) attacks, where the attacker\
    \ subverts\n         the communication stream in order to pose as the sender to\n\
    \         receiver and the receiver to the sender.\n      o  Denial-of-service\
    \ (DoS) attacks, where the attacker sends large\n         amounts of legitimate\
    \ traffic to a destination to overwhelm it.\n   IPv6 packets can be protected\
    \ from eavesdropping, replay, packet\n   insertion, packet modification, and MITM\
    \ attacks by use of the\n   \"Security Architecture for the Internet Protocol\"\
    \ [RFC4301].  In\n   addition, upper-layer protocols such as Transport Layer Security\n\
    \   (TLS) or Secure Shell (SSH) can be used to protect the application-\n   layer\
    \ traffic running on top of IPv6.\n   There is not any mechanism to protect against\
    \ DoS attacks.  Defending\n   against these type of attacks is outside the scope\
    \ of this\n   specification.\n   IPv6 addresses are significantly larger than\
    \ IPv4 addresses making it\n   much harder to scan the address space across the\
    \ Internet and even on\n   a single network link (e.g., Local Area Network). \
    \ See [RFC7707] for\n   more information.\n   IPv6 addresses of nodes are expected\
    \ to be more visible on the\n   Internet as compared with IPv4 since the use of\
    \ address translation\n   technology is reduced.  This creates some additional\
    \ privacy issues\n   such as making it easier to distinguish endpoints.  See [RFC7721]\
    \ for\n   more information.\n   The design of IPv6 extension header architecture,\
    \ while adding a lot\n   of flexibility, also creates new security challenges.\
    \  As noted\n   below, issues relating to the Fragment extension header have been\n\
    \   resolved, but it's clear that for any new extension header designed\n   in\
    \ the future, the security implications need to be examined\n   thoroughly, and\
    \ this needs to include how the new extension header\n   works with existing extension\
    \ headers.  See [RFC7045] for more\n   information.\n   This version of the IPv6\
    \ specification resolves a number of security\n   issues that were found with\
    \ the previous version [RFC2460] of the\n   IPv6 specification.  These include:\n\
    \      o  Revised the text to handle the case of fragments that are whole\n  \
    \       datagrams (i.e., both the Fragment Offset field and the M flag\n     \
    \    are zero).  If received, they should be processed as a\n         reassembled\
    \ packet.  Any other fragments that match should be\n         processed independently.\
    \  The Fragment creation process was\n         modified to not create whole datagram\
    \ fragments (Fragment\n         Offset field and the M flag are zero).  See [RFC6946]\
    \ and\n         [RFC8021] for more information.\n      o  Removed the paragraph\
    \ in Section 5 that required including a\n         Fragment header to outgoing\
    \ packets if an ICMP Packet Too Big\n         message reporting a Next-Hop MTU\
    \ is less than 1280.  See\n         [RFC6946] for more information.\n      o \
    \ Changed the text to require that IPv6 nodes must not create\n         overlapping\
    \ fragments.  Also, when reassembling an IPv6\n         datagram, if one or more\
    \ of its constituent fragments is\n         determined to be an overlapping fragment,\
    \ the entire datagram\n         (and any constituent fragments) must be silently\
    \ discarded.\n         Includes clarification that no ICMP error message should\
    \ be\n         sent if overlapping fragments are received.  See [RFC5722] for\n\
    \         more information.\n      o  Revised the text to require that all headers\
    \ through the first\n         upper-layer header are in the first fragment.  See\
    \ [RFC7112]\n         for more information.\n      o  Incorporated the updates\
    \ from [RFC5095] and [RFC5871] to remove\n         the description of the Routing\
    \ Header type 0 (RH0), that the\n         allocations guidelines for Routing headers\
    \ are specified in RFC\n         5871, and removed RH0 from the list of required\
    \ extension\n         headers.\n   Security issues relating to other parts of\
    \ IPv6 including addressing,\n   ICMPv6, Path MTU Discovery, etc., are discussed\
    \ in the appropriate\n   specifications.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC791]   Postel, J., \"Internet Protocol\"\
    , STD 5, RFC 791,\n              DOI 10.17487/RFC0791, September 1981,\n     \
    \         <http://www.rfc-editor.org/info/rfc791>.\n   [RFC2474]  Nichols, K.,\
    \ Blake, S., Baker, F., and D. Black,\n              \"Definition of the Differentiated\
    \ Services Field (DS\n              Field) in the IPv4 and IPv6 Headers\", RFC\
    \ 2474,\n              DOI 10.17487/RFC2474, December 1998,\n              <http://www.rfc-editor.org/info/rfc2474>.\n\
    \   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition\n   \
    \           of Explicit Congestion Notification (ECN) to IP\",\n             \
    \ RFC 3168, DOI 10.17487/RFC3168, September 2001,\n              <http://www.rfc-editor.org/info/rfc3168>.\n\
    \   [RFC4291]  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n        \
    \      Architecture\", RFC 4291, DOI 10.17487/RFC4291, February\n            \
    \  2006, <http://www.rfc-editor.org/info/rfc4291>.\n   [RFC4443]  Conta, A., Deering,\
    \ S., and M. Gupta, Ed., \"Internet\n              Control Message Protocol (ICMPv6)\
    \ for the Internet\n              Protocol Version 6 (IPv6) Specification\", STD\
    \ 89,\n              RFC 4443, DOI 10.17487/RFC4443, March 2006,\n           \
    \   <http://www.rfc-editor.org/info/rfc4443>.\n   [RFC6437]  Amante, S., Carpenter,\
    \ B., Jiang, S., and J. Rajahalme,\n              \"IPv6 Flow Label Specification\"\
    , RFC 6437,\n              DOI 10.17487/RFC6437, November 2011,\n            \
    \  <http://www.rfc-editor.org/info/rfc6437>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [Err2541]  RFC Errata, Erratum ID 2541, RFC\
    \ 2460.\n   [Err4279]  RFC Errata, Erratum ID 4279, RFC 2460.\n   [Err4657]  RFC\
    \ Errata, Erratum ID 4657, RFC 2460.\n   [Err4662]  RFC Errata, Erratum ID 4662,\
    \ RFC 2460.\n   [IANA-6P]  IANA, \"Internet Protocol Version 6 (IPv6) Parameters\"\
    ,\n              <https://www.iana.org/assignments/ipv6-parameters>.\n   [IANA-EH]\
    \  IANA, \"IPv6 Extension Header Types\",\n              <https://www.iana.org/assignments/ipv6-parameters>.\n\
    \   [IANA-NI]  IANA, \"ONC RPC Network Identifiers (netids)\",\n             \
    \ <https://www.iana.org/assignments/rpc-netids>.\n   [IANA-NL]  IANA, \"Network\
    \ Layer Protocol Identifiers (NLPIDs) of\n              Interest\", <https://www.iana.org/assignments/nlpids>.\n\
    \   [IANA-PN]  IANA, \"Protocol Numbers\",\n              <https://www.iana.org/assignments/protocol-numbers>.\n\
    \   [IANA-PR]  IANA, \"Protocol Registries\", <https://www.iana.org/\n       \
    \       protocols>.\n   [IANA-RH]  IANA, \"Routing Types\", <https://www.iana.org/assignments/\n\
    \              ipv6-parameters>.\n   [RFC1661]  Simpson, W., Ed., \"The Point-to-Point\
    \ Protocol (PPP)\",\n              STD 51, RFC 1661, DOI 10.17487/RFC1661, July\
    \ 1994,\n              <http://www.rfc-editor.org/info/rfc1661>.\n   [RFC2460]\
    \  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6)\
    \ Specification\", RFC 2460, DOI 10.17487/RFC2460,\n              December 1998,\
    \ <http://www.rfc-editor.org/info/rfc2460>.\n   [RFC4301]  Kent, S. and K. Seo,\
    \ \"Security Architecture for the\n              Internet Protocol\", RFC 4301,\
    \ DOI 10.17487/RFC4301,\n              December 2005, <http://www.rfc-editor.org/info/rfc4301>.\n\
    \   [RFC4302]  Kent, S., \"IP Authentication Header\", RFC 4302,\n           \
    \   DOI 10.17487/RFC4302, December 2005,\n              <http://www.rfc-editor.org/info/rfc4302>.\n\
    \   [RFC4303]  Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n      \
    \        RFC 4303, DOI 10.17487/RFC4303, December 2005,\n              <http://www.rfc-editor.org/info/rfc4303>.\n\
    \   [RFC5095]  Abley, J., Savola, P., and G. Neville-Neil, \"Deprecation\n   \
    \           of Type 0 Routing Headers in IPv6\", RFC 5095,\n              DOI\
    \ 10.17487/RFC5095, December 2007,\n              <http://www.rfc-editor.org/info/rfc5095>.\n\
    \   [RFC5722]  Krishnan, S., \"Handling of Overlapping IPv6 Fragments\",\n   \
    \           RFC 5722, DOI 10.17487/RFC5722, December 2009,\n              <http://www.rfc-editor.org/info/rfc5722>.\n\
    \   [RFC5871]  Arkko, J. and S. Bradner, \"IANA Allocation Guidelines for\n  \
    \            the IPv6 Routing Header\", RFC 5871, DOI 10.17487/RFC5871,\n    \
    \          May 2010, <http://www.rfc-editor.org/info/rfc5871>.\n   [RFC6564] \
    \ Krishnan, S., Woodyatt, J., Kline, E., Hoagland, J., and\n              M. Bhatia,\
    \ \"A Uniform Format for IPv6 Extension Headers\",\n              RFC 6564, DOI\
    \ 10.17487/RFC6564, April 2012,\n              <http://www.rfc-editor.org/info/rfc6564>.\n\
    \   [RFC6936]  Fairhurst, G. and M. Westerlund, \"Applicability Statement\n  \
    \            for the Use of IPv6 UDP Datagrams with Zero Checksums\",\n      \
    \        RFC 6936, DOI 10.17487/RFC6936, April 2013,\n              <http://www.rfc-editor.org/info/rfc6936>.\n\
    \   [RFC6946]  Gont, F., \"Processing of IPv6 \"Atomic\" Fragments\",\n      \
    \        RFC 6946, DOI 10.17487/RFC6946, May 2013,\n              <http://www.rfc-editor.org/info/rfc6946>.\n\
    \   [RFC7045]  Carpenter, B. and S. Jiang, \"Transmission and Processing\n   \
    \           of IPv6 Extension Headers\", RFC 7045,\n              DOI 10.17487/RFC7045,\
    \ December 2013,\n              <http://www.rfc-editor.org/info/rfc7045>.\n  \
    \ [RFC7112]  Gont, F., Manral, V., and R. Bonica, \"Implications of\n        \
    \      Oversized IPv6 Header Chains\", RFC 7112,\n              DOI 10.17487/RFC7112,\
    \ January 2014,\n              <http://www.rfc-editor.org/info/rfc7112>.\n   [RFC7707]\
    \  Gont, F. and T. Chown, \"Network Reconnaissance in IPv6\n              Networks\"\
    , RFC 7707, DOI 10.17487/RFC7707, March 2016,\n              <http://www.rfc-editor.org/info/rfc7707>.\n\
    \   [RFC7721]  Cooper, A., Gont, F., and D. Thaler, \"Security and Privacy\n \
    \             Considerations for IPv6 Address Generation Mechanisms\",\n     \
    \         RFC 7721, DOI 10.17487/RFC7721, March 2016,\n              <http://www.rfc-editor.org/info/rfc7721>.\n\
    \   [RFC7739]  Gont, F., \"Security Implications of Predictable Fragment\n   \
    \           Identification Values\", RFC 7739, DOI 10.17487/RFC7739,\n       \
    \       February 2016, <http://www.rfc-editor.org/info/rfc7739>.\n   [RFC8021]\
    \  Gont, F., Liu, W., and T. Anderson, \"Generation of IPv6\n              Atomic\
    \ Fragments Considered Harmful\", RFC 8021,\n              DOI 10.17487/RFC8021,\
    \ January 2017,\n              <http://www.rfc-editor.org/info/rfc8021>.\n   [RFC8201]\
    \  McCann, J., Deering, S., Mogul, J., and R. Hinden, \"Path\n              MTU\
    \ Discovery for IP version 6\", STD 87, RFC 8201,\n              DOI 10.17487/RFC8201,\
    \ July 2017,\n              <http://www.rfc-editor.org/info/rfc8201>.\n"
- title: Appendix A.  Formatting Guidelines for Options
  contents:
  - "Appendix A.  Formatting Guidelines for Options\n   This appendix gives some advice\
    \ on how to lay out the fields when\n   designing new options to be used in the\
    \ Hop-by-Hop Options header or\n   the Destination Options header, as described\
    \ in Section 4.2.  These\n   guidelines are based on the following assumptions:\n\
    \      o  One desirable feature is that any multi-octet fields within the\n  \
    \       Option Data area of an option be aligned on their natural\n         boundaries,\
    \ i.e., fields of width n octets should be placed at\n         an integer multiple\
    \ of n octets from the start of the\n         Hop-by-Hop or Destination Options\
    \ header, for n = 1, 2, 4, or\n         8.\n      o  Another desirable feature\
    \ is that the Hop-by-Hop or Destination\n         Options header take up as little\
    \ space as possible, subject to\n         the requirement that the header be an\
    \ integer multiple of 8\n         octets long.\n      o  It may be assumed that,\
    \ when either of the option-bearing\n         headers are present, they carry\
    \ a very small number of options,\n         usually only one.\n   These assumptions\
    \ suggest the following approach to laying out the\n   fields of an option: order\
    \ the fields from smallest to largest, with\n   no interior padding, then derive\
    \ the alignment requirement for the\n   entire option based on the alignment requirement\
    \ of the largest field\n   (up to a maximum alignment of 8 octets).  This approach\
    \ is\n   illustrated in the following examples:\n   Example 1\n   If an option\
    \ X required two data fields, one of length 8 octets and\n   one of length 4 octets,\
    \ it would be laid out as follows:\n                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                   | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Its alignment requirement is 8n+2, to ensure that the 8-octet field\n   starts\
    \ at a multiple-of-8 offset from the start of the enclosing\n   header.  A complete\
    \ Hop-by-Hop or Destination Options header\n   containing this one option would\
    \ look as follows:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Example 2\n   If an option Y required three data fields, one of length 4 octets,\n\
    \   one of length 2 octets, and one of length 1 octet, it would be laid\n   out\
    \ as follows:\n                                                   +-+-+-+-+-+-+-+-+\n\
    \                                                   | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Its alignment requirement is 4n+3, to ensure that the 4-octet field\n   starts\
    \ at a multiple-of-4 offset from the start of the enclosing\n   header.  A complete\
    \ Hop-by-Hop or Destination Options header\n   containing this one option would\
    \ look as follows:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  | Hdr Ext Len=1 | Pad1 Option=0 | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Example 3\n   A Hop-by-Hop or Destination Options header containing both options\
    \ X\n   and Y from Examples 1 and 2 would have one of the two following\n   formats,\
    \ depending on which option appeared first:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  | Hdr Ext Len=3 | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=1 |       0       | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Next\
    \ Header  | Hdr Ext Len=3 | Pad1 Option=0 | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=4 |       0       |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       0       |       0       | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: Appendix B.  Changes Since RFC 2460
  contents:
  - "Appendix B.  Changes Since RFC 2460\n   This memo has the following changes from\
    \ RFC 2460.\n   o  Removed IP Next Generation from the Abstract.\n   o  Added\
    \ text in Section 1 that the data transmission order is the\n      same as IPv4\
    \ as defined in RFC 791.\n   o  Clarified the text in Section 3 about decrementing\
    \ the Hop Limit.\n   o  Clarified that extension headers (except for the Hop-by-Hop\n\
    \      Options header) are not processed, inserted, or deleted by any\n      node\
    \ along a packet's delivery path.\n   o  Changed requirement for the Hop-by-Hop\
    \ Options header to a \"may\",\n      and added a note to indicate what is expected\
    \ regarding the\n      Hop-by-Hop Options header.\n   o  Added a paragraph to\
    \ Section 4 to clarify how extension headers\n      are numbered and which are\
    \ upper-layer headers.\n   o  Added a reference to the end of Section 4 to the\
    \ \"IPv6 Extension\n      Header Types\" IANA registry.\n   o  Incorporated the\
    \ updates from RFCs 5095 and 5871 to remove the\n      description of RH0, that\
    \ the allocations guidelines for routing\n      headers are specified in RFC 5871,\
    \ and removed RH0 from the list\n      of required extension headers.\n   o  Revised\
    \ Section 4.5 on IPv6 fragmentation based on updates from\n      RFCs 5722, 6946,\
    \ 7112, and 8021.  This includes:\n      -  Revised the text to handle the case\
    \ of fragments that are whole\n         datagrams (i.e., both the Fragment Offset\
    \ field and the M flag\n         are zero).  If received, they should be processed\
    \ as a\n         reassembled packet.  Any other fragments that match should be\n\
    \         processed independently.  The revised Fragment creation process\n  \
    \       was modified to not create whole datagram fragments (Fragment\n      \
    \   Offset field and the M flag are zero).\n      -  Changed the text to require\
    \ that IPv6 nodes must not create\n         overlapping fragments.  Also, when\
    \ reassembling an IPv6\n         datagram, if one or more its constituent fragments\
    \ is\n         determined to be an overlapping fragment, the entire datagram\n\
    \         (and any constituent fragments) must be silently discarded.\n      \
    \   Includes a clarification that no ICMP error message should be\n         sent\
    \ if overlapping fragments are received.\n      -  Revised the text to require\
    \ that all headers through the first\n         Upper-Layer header are in the first\
    \ fragment.  This changed the\n         text describing how packets are fragmented\
    \ and reassembled and\n         added a new error case.\n      -  Added text to\
    \ the Fragment header process on handling exact\n         duplicate fragments.\n\
    \      -  Updated the Fragmentation header text to correct the inclusion\n   \
    \      of an Authentication Header (AH) and noted No Next Header case.\n     \
    \ -  Changed terminology in the Fragment header section from\n         \"Unfragmentable\
    \ Headers\" to \"Per-Fragment headers\".\n      -  Removed the paragraph in Section\
    \ 5 that required including a\n         Fragment header to outgoing packets if\
    \ an ICMP Packet Too Big\n         message reports a Next-Hop MTU less than 1280.\n\
    \      -  Changed the text to clarify MTU restriction and 8-byte\n         restrictions,\
    \ and noted the restriction on headers in the first\n         fragment.\n   o\
    \  In Section 4.5, added clarification noting that some fields in the\n      IPv6\
    \ header may also vary across the fragments being reassembled,\n      and that\
    \ other specifications may provide additional instructions\n      for how they\
    \ should be reassembled.  See, for example, Section 5.3\n      of [RFC3168].\n\
    \   o  Incorporated the update from RFC 6564 to add a new Section 4.8\n      that\
    \ describes recommendations for defining new extension headers\n      and options.\n\
    \   o  Added text to Section 5 to define \"IPv6 minimum link MTU\".\n   o  Simplified\
    \ the text in Section 6 about Flow Labels and removed\n      what was Appendix\
    \ A (\"Semantics and Usage of the Flow Label\n      Field\"); instead, pointed\
    \ to the current specifications of the\n      IPv6 Flow Label field in [RFC6437]\
    \ and the Traffic Class field in\n      [RFC2474] and [RFC3168].\n   o  Incorporated\
    \ the update made by RFC 6935 (\"IPv6 and UDP Checksums\n      for Tunneled Packets\"\
    ) in Section 8.  Added an exception to the\n      default behavior for the handling\
    \ of UDP packets with zero\n      checksums for tunnels.\n   o  Added instruction\
    \ to Section 9, \"IANA Considerations\", to change\n      references to RFC 2460\
    \ to this document.\n   o  Revised and expanded Section 10, \"Security Considerations\"\
    .\n   o  Added a paragraph to the Acknowledgments section acknowledging the\n\
    \      authors of the updating documents.\n   o  Updated references to current\
    \ versions and assigned references to\n      normative and informative.\n   o\
    \  Made changes to resolve the errata on RFC 2460.  These are:\n         Erratum\
    \ ID 2541 [Err2541]: This erratum notes that RFC 2460\n         didn't update\
    \ RFC 2205 when the length of the flow label was\n         changed from 24 to\
    \ 20 bits from RFC 1883.  This issue was\n         resolved in RFC 6437 where\
    \ the flow label is defined.  This\n         specification now references RFC\
    \ 6437.  No change is required.\n         Erratum ID 4279 [Err4279]: This erratum\
    \ noted that the\n         specification doesn't handle the case of a forwarding\
    \ node\n         receiving a packet with a zero Hop Limit.  This is fixed in\n\
    \         Section 3 of this specification.\n         Erratum ID 4657 [Err4657]:\
    \ This erratum proposed text that\n         extension headers must never be inserted\
    \ by any node other than\n         the source of the packet.  This was resolved\
    \ in Section 4,\n         \"IPv6 Extension Headers\".\n         Erratum ID 4662\
    \ [Err4662]: This erratum proposed text that\n         extension headers, with\
    \ one exception, are not examined,\n         processed, modified, inserted, or\
    \ deleted by any node along a\n         packet's delivery path.  This was resolved\
    \ in Section 4, \"IPv6\n         Extension Headers\".\n         Erratum ID 2843:\
    \ This erratum is marked \"Rejected\".  No change\n         was made.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors gratefully acknowledge the many helpful suggestions\
    \ of\n   the members of the IPng Working Group, the End-to-End Protocols\n   research\
    \ group, and the Internet community at large.\n   The authors would also like\
    \ to acknowledge the authors of the\n   updating RFCs that were incorporated in\
    \ this document to move the\n   IPv6 specification to Internet Standard.  They\
    \ are Joe Abley, Shane\n   Amante, Jari Arkko, Manav Bhatia, Ronald P. Bonica,\
    \ Scott Bradner,\n   Brian Carpenter, P.F. Chimento, Marshall Eubanks, Fernando\
    \ Gont,\n   James Hoagland, Sheng Jiang, Erik Kline, Suresh Krishnan, Vishwas\n\
    \   Manral, George Neville-Neil, Jarno Rajahalme, Pekka Savola, Magnus\n   Westerlund,\
    \ and James Woodyatt.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Stephen E. Deering\n   Retired\n   Vancouver, British\
    \ Columbia\n   Canada\n   Robert M. Hinden\n   Check Point Software\n   959 Skyway\
    \ Road\n   San Carlos, CA  94070\n   United States of America\n   Email: bob.hinden@gmail.com\n"
