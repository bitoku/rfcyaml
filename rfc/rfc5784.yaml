- title: __initial_text__
  contents:
  - '      Sieve Email Filtering:  Sieves and Display Directives in XML

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a way to represent Sieve email filtering\n\
    \   language scripts in XML.  Representing Sieves in XML is intended not\n   as\
    \ an alternate storage format for Sieve but rather as a means to\n   facilitate\
    \ manipulation of scripts using XML tools.\n   The XML representation also defines\
    \ additional elements that have no\n   counterparts in the regular Sieve language.\
    \  These elements are\n   intended for use by graphical user interfaces and provide\
    \ facilities\n   for labeling or grouping sections of a script so they can be\n\
    \   displayed more conveniently.  These elements are represented as\n   specially\
    \ structured comments in regular Sieve format.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5784.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Conventions Used in This Document  . . . . . . . . .\
    \ . . . . .  4\n   3.  Grammatical Structure of Sieve . . . . . . . . . . . .\
    \ . . . .  4\n   4.  XML Representation of Sieve  . . . . . . . . . . . . . .\
    \ . . .  6\n     4.1.  XML Display Directives . . . . . . . . . . . . . . . .\
    \ . .  9\n     4.2.  Structured Comments  . . . . . . . . . . . . . . . . . .\
    \ . 10\n     4.3.  Validation . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 11\n   5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 11\n\
    \   6.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 11\n  \
    \ 7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n    \
    \ 7.1.  Normative References . . . . . . . . . . . . . . . . . . . 12\n     7.2.\
    \  Informative References . . . . . . . . . . . . . . . . . . 13\n   Appendix\
    \ A.  Extended Example  . . . . . . . . . . . . . . . . . . 14\n   Appendix B.\
    \  XML Schema for Sieves in XML  . . . . . . . . . . . . 21\n   Appendix C.  Relax\
    \ NG Schema for Sieves in XML . . . . . . . . . . 24\n   Appendix D.  Stylesheet\
    \ for Conversion from XML  . . . . . . . . . 26\n   Appendix E.  Acknowledgements\
    \  . . . . . . . . . . . . . . . . . . 32\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Sieve [RFC5228] is a language for filtering email messages\
    \ at or\n   around the time of final delivery.  It is designed to be\n   implementable\
    \ on either a mail client or mail server.  It is meant to\n   be extensible, simple,\
    \ and independent of access protocol, mail\n   architecture, and operating system,\
    \ and it is intended to be\n   manipulated by a variety of different user interfaces.\n\
    \   Some user interface environments have extensive existing facilities\n   for\
    \ manipulating material represented in XML [XML].  While adding\n   support for\
    \ alternate data syntaxes may be possible in most if not\n   all of these environments,\
    \ it may not be particularly convenient to\n   do so.  The obvious way to deal\
    \ with this issue is to map Sieves into\n   XML, possibly on a separate back-end\
    \ system, manipulate the XML, and\n   convert it back to normal Sieve format.\n\
    \   The fact that conversion into and out of XML may be done as a\n   separate\
    \ operation on a different system argues strongly for defining\n   a common XML\
    \ representation for Sieve.  This way, different front-end\n   user interfaces\
    \ can be used with different back-end mapping and\n   storage facilities.\n  \
    \ Another issue with the creation and manipulation of Sieve scripts by\n   user\
    \ interfaces is that the language is strictly focused on\n   describing email\
    \ filtering operations.  The language contains no\n   mechanisms for indicating\
    \ how a given script should be presented in a\n   user interface.  Such information\
    \ can be represented in XML very\n   easily, so it makes sense to define a framework\
    \ to do this as part of\n   the XML format.  A structured comment convention is\
    \ then used to\n   retain this information when the script is converted to normal\
    \ Sieve\n   format.\n   It should be noted, however, that the ability for different\
    \ front\n   ends to use the same mapping and storage facilities does not mean\n\
    \   that the additional XML information produced by different front ends\n   will\
    \ interoperate.\n   Various Sieve extensions have already been defined, e.g.,\
    \ [RFC5183],\n   [RFC5229], [RFC5230], [RFC5231], [RFC5232], [RFC5233], [RFC5235],\n\
    \   [RFC5293], and more are planned.  The set of extensions available\n   varies\
    \ from one implementation to the next and may even change as a\n   result of configuration\
    \ choices.  It is therefore essential that the\n   XML representation of Sieve\
    \ be able to accommodate Sieve extensions\n   without requiring schema changes.\
    \  It is also desirable that Sieve\n   extensions not require changes to the code\
    \ that converts to and from\n   the XML representation.\n   This specification\
    \ defines an XML representation for Sieve scripts\n   and explains how the conversion\
    \ process to and from XML works.  The\n   XML representation is capable of accommodating\
    \ any future Sieve\n   extension as long as the underlying Sieve grammar remains\
    \ unchanged.\n   Furthermore, code that converts from XML to the normal Sieve\
    \ format\n   requires no changes to accommodate extensions, while code used to\n\
    \   convert from normal Sieve format to XML only requires changes when\n   new\
    \ control commands are added -- a rare event.  An XML Schema, Relax\n   NG Schema,\
    \ and a sample stylesheet to convert from XML format are\n   also provided in\
    \ the appendices.\n"
- title: 2.  Conventions Used in This Document
  contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n   The term \"processor\" is used throughout this document\
    \ to refer to\n   agents that convert Sieve to and from the XML representation.\
    \  The\n   term \"editor\" refers to agents that operate on, possibly creating\
    \ or\n   modifying, Sieves in XML format.\n"
- title: 3.  Grammatical Structure of Sieve
  contents:
  - "3.  Grammatical Structure of Sieve\n   The Sieve language is designed to be highly\
    \ extensible without making\n   any changes to the basic language syntax.  Accordingly,\
    \ the syntax of\n   Sieve, defined in Section 8 of [RFC5228], is entirely structural\
    \ in\n   nature and employs no reserved words of any sort.\n   Structurally, a\
    \ Sieve script consists of a series of commands.  Each\n   command, in turn, consists\
    \ of an identifier, zero or more arguments,\n   an optional test or test-list,\
    \ and finally an optional block\n   containing another series of commands.  Commands\
    \ are further broken\n   down into controls and actions, although this distinction\
    \ cannot be\n   determined from the grammar.\n   Some example Sieve controls are:\n\
    \   stop;               <-- No arguments, test, or command block\n   require \"\
    fileinto\"; <-- Control with a single argument\n   if true {stop;}     <-- Control\
    \ with test and command block\n   Some examples of Sieve actions are:\n"
- title: discard;            <-- Action with no arguments, test, or command block
  contents:
  - 'discard;            <-- Action with no arguments, test, or command block

    '
- title: fileinto "folder";  <-- Action with an argument
  contents:
  - "fileinto \"folder\";  <-- Action with an argument\n   At the time of this writing,\
    \ there are no controls defined that\n   accept both arguments and a test.  Similarly,\
    \ there are currently no\n   defined actions that allow either a test or a command\
    \ block.\n   Nevertheless, the Sieve grammar allows such constructs to be defined\n\
    \   by some future extension.\n   A test consists of an identifier followed by\
    \ zero or more arguments,\n   then another test or test-list.  Unlike commands,\
    \ tests cannot be\n   followed by a command block.\n   Here are some examples\
    \ of Sieve tests.  Note that such tests have to\n   appear as part of a command\
    \ in order to be syntactically valid:\n   true                <-- Test with no\
    \ argument or subordinate test\n   envelope \"to\" \"me@example.com\" <-- Test\
    \ with several arguments\n   header :is \"from\" \"you@example.com\" <-- Test\
    \ with tagged argument\n   Command or test arguments can be either string lists,\
    \ whole numbers,\n   or tags.  (Tags are simply identifiers preceded by a colon.)\
    \  Note\n   that although the Sieve grammar treats single strings as a degenerate\n\
    \   case of a string list, some tests or actions have arguments that can\n   only\
    \ be individual strings, not lists.\n   Here is an example showing the use of\
    \ both a test-list and a string\n   list:\n   if anyof (not exists [\"From\",\
    \ \"Date\"],\n             header :contains \"from\" \"fool@example.edu\") {\n\
    \     discard;\n   }\n   Extensions can add new controls, actions, tests, or arguments\
    \ to\n   existing controls or actions.  Extensions have also changed how\n   string\
    \ content is interpreted, although this is not relevant to this\n   specification.\
    \  However, it is especially important to note that so\n   far, only one of the\
    \ many defined Sieve extensions -- the\n   foreverypart extension [RFC5703] --\
    \ has added new controls to the\n   language.  It seems safe to assume that, due\
    \ to their nature, future\n   addition of controls will be relatively rare.\n\
    \   Finally, comments are allowed between lexical elements in a Sieve\n   script.\
    \  One important use case for comments is encoding meta-data\n   about the script,\
    \ a facility that is lacking in the Sieve language.\n   Therefore, comments need\
    \ to be preserved in the XML representation.\n"
- title: 4.  XML Representation of Sieve
  contents:
  - "4.  XML Representation of Sieve\n   Sieve controls and actions are represented\
    \ in XML as \"control\" or\n   \"action\" elements, respectively.  The command's\
    \ identifier appears as\n   a name attribute on the element itself.  This is the\
    \ only attribute\n   allowed on controls and actions -- arguments, tests, test-lists,\
    \ and\n   nested command blocks are all represented as nested elements.  While\n\
    \   naming the element after the control or action itself may seem like a\n  \
    \ better choice, doing so would result in extensions requiring frequent\n   corresponding\
    \ schema changes.\n   The example Sieve controls shown in the previous section\
    \ would be\n   represented as these XML fragments:\n    <control name=\"stop\"\
    />\n    <control name=\"require\"><str>fileinto</str></control>\n    <control\
    \ name=\"if\">\n     <test name=\"true\"/><control name=\"stop\"/>\n    </control>\n\
    \   The example Sieve actions shown above would appear in XML as:\n   <action\
    \ name=\"discard\"/>\n   <action name=\"fileinto\"><str>folder</str></action>\n\
    \   The separation of controls from actions in the XML representation\n   means\
    \ that conversion from normal Sieve format to XML has to be able\n   to distinguish\
    \ between controls and actions.  This is easily done by\n   maintaining a list\
    \ of all known controls since experience indicates\n   new controls are rarely\
    \ added.  At the time of this writing, the list\n   of defined controls consists\
    \ of:\n   1.  if [RFC5228],\n   2.  stop [RFC5228],\n   3.  require [RFC5228],\n\
    \   4.  foreverypart [RFC5703], and\n   5.  break [RFC5703].\n   It should be\
    \ noted that with this approach unknown controls will\n   simply be treated as\
    \ actions and can be passed back and forth between\n   the two representations.\
    \  The treatment of a control as an action is\n   unlikely to cause other issues\
    \ since knowledge of a control's\n   language semantics is almost always required\
    \ to take advantage of it.\n   Tests are represented in the same basic way as\
    \ controls and actions,\n   that is, as a \"test\" element with a name attribute\
    \ giving the test\n   identifier.  For example, the following XML fragments show\
    \ various\n   types of tests:\n   <test name=\"true\"/>\n   <test name=\"envelope\"\
    />\n     <str>to</str><str>me@example.com</str>\n   </test>\n   <test name=\"\
    header\"/>\n     <tag>is</tag><str>from</str><str>you@example.com</str>\n   </test>\n\
    \   String, number, and tag arguments are represented as \"str\", \"num\",\n \
    \  and \"tag\" elements, respectively.  The actual string, number, or tag\n  \
    \ identifier appears as text inside the element.  None of these\n   elements have\
    \ any defined attributes.  Several examples of arguments\n   have already appeared\
    \ in the preceding control, action, and test\n   examples.  Any whitespace in\
    \ the str body content MUST be preserved\n   by the processor.  Also, note that\
    \ since strings and tags are\n   represented as element text, any quotes or other\
    \ syntactic elements\n   required in the regular Sieve representation are dropped\
    \ rather than\n   being carried over into the XML.\n   String list arguments are\
    \ represented as a \"list\" element, which in\n   turn contains one or more str\
    \ elements.  Note that this allows the\n   distinction between a single string\
    \ and a string list containing a\n   single string to be preserved.  This is not\
    \ essential since a list\n   containing a single string could simply be mapped\
    \ to a string, but it\n   seems prudent to maintain the distinction when mapping\
    \ to and from\n   XML.\n   Nested command blocks appear as a series of control\
    \ or action\n   elements inside of an outer control or action element.  No block\n\
    \   element is needed since an inner command block can only appear once\n   and\
    \ only after any arguments, tests, or test-lists.  For example:\n   <control name=\"\
    if\">\n     <test name=\"anyof\">\n       <test name=\"not\">\n         <test\
    \ name=\"exists\">\n           <list><str>From</str><str>Date</str></list>\n \
    \        </test>\n       </test>\n       <test name=\"header\">\n         <tag>contains</tag>\n\
    \         <str>from</str>\n         <str>fool@example.edu</str>\n       </test>\n\
    \     </test>\n     <action name=\"discard\"/>\n   </control>\n   Sieve comments\
    \ are mapped to a special \"comment\" element in XML.\n   Both hash and bracketed\
    \ comments are mapped to the same construct so\n   the distinction between the\
    \ two is lost in XML.  XML comments are not\n   used because some XML tools do\
    \ not make it convenient to access\n   comment nodes.\n   Comments are allowed\
    \ between commands and inside \"test\" elements.\n   But comments aren't allowed\
    \ directly inside commands -- due to\n   limitations of XML Schema, special enclosing\
    \ \"preamble\" and\n   \"postamble\" elements are needed:\n   <control name=\"\
    if\">\n     <preamble>\n       <comment>Check to see if message should be discarded</comment>\n\
    \     </preamble>\n     <test name=\"anyof\">\n       <test name=\"not\">\n  \
    \       <test name=\"exists\">\n           <list><str>From</str><str>Date</str></list>\n\
    \         </test>\n       </test>\n       <test name=\"header\">\n         <tag>contains</tag>\n\
    \         <str>from</str>\n         <str>fool@example.edu</str>\n       </test>\n\
    \     </test>\n     <action name=\"discard\"/>\n     <postamble>\n       <comment>End\
    \ of discard check</comment>\n     </postamble>\n   </control>\n"
- title: 4.1.  XML Display Directives
  contents:
  - "4.1.  XML Display Directives\n   Sometimes graphical user interfaces are a convenient\
    \ way to provide\n   Sieve management functions to users.  These interfaces typically\n\
    \   summarize/annotate/group/display Sieve script(s) in an intuitive way\n   for\
    \ end users.\n   To do this effectively, the graphical user interface may require\n\
    \   additional information about the Sieve script itself.  That\n   information\
    \ or \"meta-data\" might include, but is not limited to, a\n   Sieve name (identifying\
    \ the current Sieve), whether the Sieve is\n   enabled or disabled, and the order\
    \ in which the parts of the Sieve\n   are presented to the user.  The graphical\
    \ user interface may also\n   choose to provide mechanisms to allow the user to\
    \ modify the script.\n   It is often useful for a graphical user interface to\
    \ group related\n   Sieve script elements and provide an interface that displays\
    \ these\n   groups separately so they can be managed as a single object.  Some\n\
    \   examples include Sieve statements that together provide vacation\n   responders,\
    \ blacklists/whitelists, and other types of filtering\n   controls.\n   Some advanced\
    \ graphical user interfaces may even provide a natural\n   language representation\
    \ of a Sieve script and/or an advanced\n   interface to present Sieve statements\
    \ directly to the user.\n   A graphical user interface may also choose to support\
    \ only a subset\n   of action commands in the Sieve language (and its extensions),\
    \ and so\n   a mechanism to indicate the extent of support and characterize the\n\
    \   relationships between those supported action commands and the test\n   (with\
    \ its arguments) is immensely useful and probably required for\n   clients that\
    \ may not have complete knowledge of Sieve grammar and\n   semantics.\n   The\
    \ Sieve language contains no mechanisms for indicating how a given\n   script\
    \ should be presented in a user interface.  The language also\n   does not contain\
    \ any specific mechanisms to represent other sorts of\n   meta-data about the\
    \ script.  Providing support for such meta-data as\n   part of a Sieve script\
    \ is currently totally implementation specific\n   and is usually done by imposing\
    \ some type of structure on comments.\n   However, such information can be represented\
    \ in XML very easily, so\n   it makes sense to define a framework to do this as\
    \ part of the XML\n   format.  Implementations MAY choose to use structured comments\
    \ to\n   retain this information when the script is converted to normal Sieve\n\
    \   format.\n   The sample schemata for the XML representation of Sieve allows\
    \ XML in\n   foreign namespaces to be inserted in the same places \"comment\"\n\
    \   elements can appear in Sieve scripts.  This is the preferred means of\n  \
    \ including additional information.  Alternately, the schema defines\n   two display\
    \ directives -- displayblock and displaydata -- as\n   containers for meta-data\
    \ needed by graphical user interfaces.\n   Editors MAY use displayblock, displaydata,\
    \ and foreign namespaces to\n   associate meta-data.  Some editors find it inconvenient\
    \ to preserve\n   this additional data during an editing session.  Editors MAY\
    \ preserve\n   this data during an editing session for compatibility with other\n\
    \   editors.\n   The displayblock element can be used to enclose any number of\
    \ Sieve\n   statements at any level.  It is semantically meaningless to the Sieve\n\
    \   script itself.  It allows an arbitrary set of attributes.\n   Implementations\
    \ MAY use this to provide many simple, display-related\n   meta-data for the Sieve\
    \ such as Sieve identifier, group identifier,\n   order of processing, etc.\n\
    \   The displaydata element supports any number of arbitrary child\n   elements.\
    \  Implementations MAY use this to represent complex data\n   about that Sieve\
    \ such as a natural language representation of Sieve\n   or a way to provide the\
    \ Sieve script directly.\n"
- title: 4.2.  Structured Comments
  contents:
  - "4.2.  Structured Comments\n   Since the XML representation is not intended as\
    \ a storage format,\n   there needs to be a way to preserve the additional information\
    \ that\n   can be included in the XML representation in the normal Sieve syntax.\n\
    \   This is done through the use of three structured comment conventions:\n  \
    \ 1.  XML content in other namespaces is placed in Sieve bracketed\n       comments\
    \ beginning with the string \"/* [/\" and ending with the\n       string \"/]\
    \ */\".\n   2.  The content of displaydata elements is placed in Sieve bracketed\n\
    \       comments beginning with the string \"/* [|\" and ending with the\n   \
    \    string \"|] */\".\n   3.  The beginning of a displayblock element is mapped\
    \ to a bracketed\n       Sieve comment beginning with the string \"/* [*\", which\
    \ then lists\n       any displayblock attribute names and values in XML format.\
    \  The\n       end of a displayblock element is mapped to a comment of the form\n\
    \       \"*] */\".\n   Processors MUST preserve the additional information allowed\
    \ in the\n   XML format and SHOULD use the structured comment format shown above.\n\
    \   Note: If \"*/\" is found in the XML content, when mapped into a\n   comment,\
    \ it would prematurely terminate that comment.  Escaping this\n   sequence would\
    \ often be inconvenient for processors.  Editors SHALL\n   NOT include \"*/\"\
    \ within displayblock, displaydata, or foreign markup.\n   Processors MAY regard\
    \ documents containing \"*/\" in foreign markup,\n   displayblock, or displaydata\
    \ as invalid.\n"
- title: 4.3.  Validation
  contents:
  - "4.3.  Validation\n   A processor MAY validate documents against a schema, and\
    \ it MAY\n   reject any that do not conform.  For any document that a processor\n\
    \   does not reject as invalid, any markup that the processor cannot\n   understand\
    \ by reference to this specification MAY be discarded.\n   Note that example Relax\
    \ NG and XML Schema are given in the appendices\n   below.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   Any syntactically valid Sieve script can be represented\
    \ in XML.\n   Accordingly, all security considerations applicable to Sieve and\
    \ any\n   extensions used also apply to the XML representation.\n   The use of\
    \ XML carries its own security risks.  Section 7 of RFC 3470\n   [RFC3470] discusses\
    \ these risks.\n   It is axiomatic that a Sieve editor must be trusted to do what\
    \ the\n   user specifies.  If XML formats are used, this trust necessarily must\n\
    \   extend to the components involved in converting to and from XML\n   format.\n\
    \   Arbitrary data can be included using other namespaces or placed in\n   the\
    \ extensible displayblock and displaydata constructs defined in\n   this specification,\
    \ possibly including entire scripts and other\n   executable content in languages\
    \ other than Sieve.  Such material will\n   necessarily have its own security\
    \ considerations, which are beyond\n   the scope of this document.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   This section registers a new XML namespace per the\
    \ procedures in RFC\n   3688 [RFC3688].\n   URI:  urn:ietf:params:xml:ns:sieve\n\
    \   Registrant Contact:  IETF Sieve working group\n                        <ietf-mta-filters@imc.org>\n\
    \   XML:\n     BEGIN\n     <?xml version=\"1.0\"?>\n     <!DOCTYPE html PUBLIC\
    \ \"-//W3C//DTD XHTML Basic 1.0//EN\"\n       \"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd\"\
    >\n     <html xmlns=\"http://www.w3.org/1999/xhtml\">\n     <head>\n       <meta\
    \ http-equiv=\"content-type\"\n             content=\"text/html;charset=iso-8859-1\"\
    />\n       <title>Sieve Namespace</title>\n     </head>\n     <body>\n       <h1>Namespace\
    \ for Sieve Language objects expressed in XML</h1>\n       <h2>urn:ietf:params:xml:ns:sieve</h2>\n\
    \       <p>See <a href=\"http://www.rfc-editor.org/rfc/rfc5784.txt\">\n      \
    \  RFC 5784</a>.\n       </p>\n     </body>\n     </html>\n     END\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [OASISRNC]  Clark, J., \"RELAX NG Compact Syntax\"\
    , OASIS Committee\n               Specification rnc, November 2002.\n   [RFC2119]\
    \   Bradner, S., \"Key words for use in RFCs to Indicate\n               Requirement\
    \ Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3470]   Hollenbeck, S., Rose,\
    \ M., and L. Masinter, \"Guidelines\n               for the Use of Extensible\
    \ Markup Language (XML)\n               within IETF Protocols\", BCP 70, RFC 3470,\
    \ January 2003.\n   [RFC3688]   Mealling, M., \"The IETF XML Registry\", BCP 81,\
    \ RFC 3688,\n               January 2004.\n   [RFC5228]   Guenther, P. and T.\
    \ Showalter, \"Sieve: An Email Filtering\n               Language\", RFC 5228,\
    \ January 2008.\n   [XML]       Bray, T., Paoli, J., Sperberg-McQueen, C., Maler,\
    \ E., and\n               F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth\n\
    \               Edition)\", W3C REC-xml-20081126, November 2008,\n           \
    \    <http://www.w3.org/TR/2008/REC-xml-20081126/>.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [RFC5183]   Freed, N., \"Sieve Email Filtering:\
    \ Environment\n               Extension\", RFC 5183, May 2008.\n   [RFC5229] \
    \  Homme, K., \"Sieve Email Filtering: Variables Extension\",\n              \
    \ RFC 5229, January 2008.\n   [RFC5230]   Showalter, T. and N. Freed, \"Sieve\
    \ Email Filtering:\n               Vacation Extension\", RFC 5230, January 2008.\n\
    \   [RFC5231]   Segmuller, W. and B. Leiba, \"Sieve Email Filtering:\n       \
    \        Relational Extension\", RFC 5231, January 2008.\n   [RFC5232]   Melnikov,\
    \ A., \"Sieve Email Filtering: Imap4flags\n               Extension\", RFC 5232,\
    \ January 2008.\n   [RFC5233]   Murchison, K., \"Sieve Email Filtering: Subaddress\n\
    \               Extension\", RFC 5233, January 2008.\n   [RFC5235]   Daboo, C.,\
    \ \"Sieve Email Filtering: Spamtest and Virustest\n               Extensions\"\
    , RFC 5235, January 2008.\n   [RFC5293]   Degener, J. and P. Guenther, \"Sieve\
    \ Email Filtering:\n               Editheader Extension\", RFC 5293, August 2008.\n\
    \   [RFC5703]   Hansen, T. and C. Daboo, \"Sieve Email Filtering: MIME\n     \
    \          Part Tests, Iteration, Extraction, Replacement, and\n             \
    \  Enclosure\", RFC 5703, October 2009.\n"
- title: Appendix A.  Extended Example
  contents:
  - "Appendix A.  Extended Example\n   The example Sieve script given in Section 9\
    \ of [RFC5228] would be\n   represented in XML as the following code component:\n\
    \   <sieve xmlns=\"urn:ietf:params:xml:ns:sieve\">\n     <comment>\n       Example\
    \ Sieve Filter\n       Declare any optional features or extensions used by the\
    \ script\n     </comment>\n     <control name=\"require\">\n       <str>fileinto</str>\n\
    \     </control>\n     <comment>\n       Handle messages from known mailing lists.\n\
    \       Move messages from IETF filter discussion list to filter mailbox.\n  \
    \   </comment>\n     <control name=\"if\">\n       <test name=\"header\">\n  \
    \       <tag>is</tag>\n         <str>Sender</str>\n         <str>owner-ietf-mta-filters@imc.org</str>\n\
    \       </test>\n       <action name=\"fileinto\">\n         <str>filter</str>\n\
    \       </action>\n       <postamble>\n         <comment>move to \"filter\" mailbox</comment>\n\
    \       </postamble>\n     </control>\n     <comment>\n       Keep all messages\
    \ to or from people in my company.\n     </comment>\n     <control name=\"elsif\"\
    >\n       <test name=\"address\">\n         <tag>domain</tag>\n         <tag>is</tag>\n\
    \         <list>\n           <str>From</str>\n           <str>To</str>\n     \
    \    </list>\n         <str>example.com</str>\n       </test>\n       <action\
    \ name=\"keep\"/>\n     </control>\n     <comment>\n       Try and catch unsolicited\
    \ email.  If a message is not to me,\n       or it contains a subject known to\
    \ be spam, file it away.\n     </comment>\n     <control name=\"elsif\">\n   \
    \    <test name=\"anyof\">\n         <test name=\"not\">\n           <test name=\"\
    address\">\n             <tag>all</tag>\n             <tag>contains</tag>\n  \
    \           <list>\n               <str>To</str>\n               <str>Cc</str>\n\
    \               <str>Bcc</str>\n             </list>\n             <str>me@example.com</str>\n\
    \           </test>\n         </test>\n         <test name=\"header\">\n     \
    \      <tag>matches</tag>\n           <str>subject</str>\n           <list>\n\
    \             <str>*make*money*fast*</str>\n             <str>*university*dipl*mas*</str>\n\
    \           </list>\n         </test>\n       </test>\n       <action name=\"\
    fileinto\">\n         <str>spam</str>\n       </action>\n     </control>\n   \
    \  <control name=\"else\">\n       <preamble>\n         <comment>\n          \
    \ Move all other (non-company) mail to \"personal\"\n           mailbox.\n   \
    \      </comment>\n       </preamble>\n       <action name=\"fileinto\">\n   \
    \      <str>personal</str>\n       </action>\n     </control>\n   </sieve>\n \
    \  The same script could be annotated with graphical display hints in a\n   variety\
    \ of ways.  Three possible code components that do this are:\n   <sieve xmlns=\"\
    urn:ietf:params:xml:ns:sieve\">\n     <control name=\"require\">\n       <str>fileinto</str>\n\
    \     </control>\n     <displayblock name=\"File filter list mail\" order=\"1\"\
    \n                   group=\"FILE_TO_FOLDER\" enable=\"true\">\n       <control\
    \ name=\"if\">\n         <test name=\"header\">\n           <tag>is</tag>\n  \
    \         <str>Sender</str>\n           <str>owner-ietf-mta-filters@imc.org</str>\n\
    \         </test>\n         <action name=\"fileinto\">\n           <str>filter</str>\n\
    \         </action>\n       </control>\n     </displayblock>\n     <displayblock\
    \ name=\"Keep all company mail\" order=\"2\"\n                   group=\"KEEP_MESSAGE\"\
    \ enable=\"true\">\n       <control name=\"elsif\">\n         <test name=\"address\"\
    >\n           <tag>domain</tag>\n           <tag>is</tag>\n           <list>\n\
    \             <str>From</str>\n             <str>To</str>\n           </list>\n\
    \           <str>example.com</str>\n         </test>\n         <action name=\"\
    keep\"/>\n      </control>\n     </displayblock>\n     <displayblock name=\"File\
    \ suspected spam\" order=\"3\"\n                   group=\"FILE_TO_FOLDER\" enable=\"\
    true\">\n        <control name=\"elsif\">\n          <test name=\"anyof\">\n \
    \           <test name=\"not\">\n              <test name=\"address\">\n     \
    \           <tag>all</tag>\n                <tag>contains</tag>\n            \
    \    <list>\n                  <str>To</str>\n                  <str>Cc</str>\n\
    \                  <str>Bcc</str>\n                </list>\n                <str>me@example.com</str>\n\
    \              </test>\n            </test>\n            <test name=\"header\"\
    >\n              <tag>matches</tag>\n              <str>subject</str>\n      \
    \        <list>\n                <str>*make*money*fast*</str>\n              \
    \  <str>*university*dipl*mas*</str>\n              </list>\n            </test>\n\
    \          </test>\n          <action name=\"fileinto\">\n            <str>spam</str>\n\
    \          </action>\n        </control>\n      </displayblock>\n     <displayblock\
    \ name=\"File noncompany mail as personal\" order=\"4\"\n                   group=\"\
    FILE_TO_FOLDER\" enable=\"true\">\n       <control name=\"else\">\n         <action\
    \ name=\"fileinto\">\n           <str>personal</str>\n         </action>\n   \
    \    </control>\n     </displayblock>\n   </sieve>\n   Note that since displayblock\
    \ elements are semantically null as far as\n   the script itself is concerned,\
    \ they can be used to group structures\n   like elsif and else that are tied to\
    \ statements in other groups.\n   The representation of this script in regular\
    \ Sieve syntax uses\n   structured comments:\n   require \"fileinto\";\n   /*\
    \ [* name=\"File filter list mail\" order=\"1\"\n         group=\"FILE_TO_FOLDER\"\
    \ enable=\"true\" */\n   if header :is \"Sender\" \"owner-ietf-mta-filters@imc.org\"\
    \n   {\n     fileinto \"filter\";\n   }\n   /* *] */\n   /* [* name=\"Keep all\
    \ company mail\" order=\"2\"\n         group=\"KEEP_MESSAGE\" enable=\"true\"\
    \ */\n   elsif address :domain :is [ \"From\", \"To\" ] \"example.com\"\n   {\n\
    \     keep;\n   }\n   /* *] */\n   /* [* name=\"File suspected spam\" order=\"\
    3\"\n         group=\"FILE_TO_FOLDER\" enable=\"true\" */\n   elsif anyof ( not\
    \ ( address :all :contains [ \"To\", \"Cc\", \"Bcc\" ]\n                     \
    \  \"me@example.com\" ),\n                 header :matches \"subject\" [ \"*make*money*fast*\"\
    ,\n                                             \"*university*dipl*mas*\" ] )\n\
    \   {\n     fileinto \"spam\";\n   }\n   /* *] */\n   /* [* name=\"File noncompany\
    \ mail as personal\" order=\"4\"\n         group=\"FILE_TO_FOLDER\" enable=\"\
    true\" */\n   else\n   {\n     fileinto \"personal\";\n   }\n   /* *] */\n   A\
    \ separate namespace can be used to embed text or structured\n   information:\n\
    \   <sieve xmlns=\"urn:ietf:params:xml:ns:sieve\"\n          xmlns:nls=\"http://example.com/nls\"\
    >\n     <nls:interpretation>\n       If the email header \"Sender\" is owner-ietf-mta-filters@imc.org,\n\
    \       then file it into the \"filter\" folder.\n       Otherwise, if the address\
    \ in the \"From\" or \"To\" has a domain\n       that is \"example.com\", then\
    \ keep it.\n       Otherwise, messages meeting with any of these conditions:\n\
    \       (1) None of the addresses in \"To\", \"Cc\", or \"Bcc\" contain\n    \
    \       the domain \"example.com\".\n       (2) The \"Subject\" field matches\
    \ the pattern *make*money*fast*\n           or *university*dipl*mas*, then file\
    \ it into the \"spam\"\n           folder.\n       If all else fails, then file\
    \ the message in the \"personal\"\n       folder.\n     </nls:interpretation>\n\
    \     ... the actual Sieve script ...\n   </sieve>\n   Alternately, displaydata\
    \ elements can be used to accomplish the same\n   thing:\n   <sieve xmlns=\"urn:ietf:params:xml:ns:sieve\"\
    >\n     <displaydata>\n       <nls-interpretation>\n         If the email header\
    \ \"Sender\" is owner-ietf-mta-filters@imc.org,\n         then file it into the\
    \ \"filter\" folder.\n         Otherwise, if the address in the \"From\" or \"\
    To\" has a domain\n         that is \"example.com\", then keep it.\n         Otherwise,\
    \ messages meeting with any of these conditions:\n         (1) None of the addresses\
    \ in \"To\",\"Cc\", or \"Bcc\" contain\n             the domain \"example.com\"\
    .\n         (2) The \"Subject\" field matches the pattern *make*money*fast*\n\
    \             or *university*dipl*mas*, then file it into the \"spam\"\n     \
    \        folder.\n         If all else fails, then file the message in the \"\
    personal\"\n         folder.\n       </nls-interpretation>\n     </displaydata>\n\
    \     ... the actual Sieve script ...\n   </sieve>\n   Again, structured comments\
    \ are used to represent this in regular\n   Sieve syntax:\n     /* [|\n      \
    \ <nls-interpretation>\n         If the email header \"Sender\" is owner-ietf-mta-filters@imc.org,\n\
    \         then file it into the \"filter\" folder.\n         Otherwise, if the\
    \ address in the \"From\" or \"To\" has a domain\n         that is \"example.com\"\
    , then keep it.\n         Otherwise, messages meeting with any of these conditions:\n\
    \         (1) None of the addresses in \"To\",\"Cc\", or \"Bcc\" contain\n   \
    \          the domain \"example.com\".\n         (2) The \"Subject\" field matches\
    \ the pattern *make*money*fast*\n             or *university*dipl*mas*, then file\
    \ it into the \"spam\"\n             folder.\n         If all else fails, then\
    \ file the message in the \"personal\"\n         folder.\n       </nls-interpretation>\n\
    \     |] */\n     ... the actual Sieve script ...\n"
- title: Appendix B.  XML Schema for Sieves in XML
  contents:
  - "Appendix B.  XML Schema for Sieves in XML\n   This appendix is informative. \
    \ The following code component is an XML\n   Schema for the XML representation\
    \ of Sieve scripts.  Most of the\n   elements employing a complex content model\
    \ allow use of elements in\n   other namespaces, subject to lax XML Schema validation\
    \ rules.\n   Additionally, displaydata elements can be used to encapsulate\n \
    \  arbitrary XML content.  Finally, displayblock elements can be used as\n   a\
    \ general-purpose grouping mechanism -- arbitrary attributes are\n   allowed on\
    \ displayblock elements.\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <xsd:schema\
    \ xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n               xmlns=\"urn:ietf:params:xml:ns:sieve\"\
    \n               targetNamespace=\"urn:ietf:params:xml:ns:sieve\">\n     <xsd:element\
    \ name=\"sieve\">\n       <xsd:complexType>\n         <xsd:sequence>\n       \
    \    <xsd:choice maxOccurs=\"unbounded\" minOccurs=\"0\">\n             <xsd:element\
    \ ref=\"control\"/>\n             <xsd:element ref=\"action\"/>\n            \
    \ <xsd:element ref=\"displayblock\"/>\n             <xsd:element ref=\"displaydata\"\
    />\n             <xsd:element ref=\"comment\"/>\n             <xsd:any namespace=\"\
    ##other\" processContents=\"lax\"/>\n           </xsd:choice>\n         </xsd:sequence>\n\
    \       </xsd:complexType>\n     </xsd:element>\n     <xsd:element name=\"comment\"\
    \ type=\"xsd:string\"/>\n     <xsd:complexType name=\"ambles\">\n       <xsd:choice\
    \ minOccurs=\"0\" maxOccurs=\"unbounded\">\n         <xsd:element ref=\"displaydata\"\
    />\n         <xsd:element ref=\"comment\"/>\n         <xsd:any namespace=\"##other\"\
    \ processContents=\"lax\"/>\n      </xsd:choice>\n     </xsd:complexType>\n  \
    \   <xsd:element name=\"preamble\" type=\"ambles\"/>\n     <xsd:element name=\"\
    postamble\" type=\"ambles\"/>\n     <xsd:complexType name=\"command\">\n     \
    \  <xsd:sequence>\n         <xsd:element ref=\"preamble\" minOccurs=\"0\" maxOccurs=\"\
    1\"/>\n         <xsd:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n       \
    \    <xsd:element ref=\"str\"/>\n           <xsd:element ref=\"num\"/>\n     \
    \      <xsd:element ref=\"list\"/>\n           <xsd:element ref=\"tag\"/>\n  \
    \       </xsd:choice>\n         <xsd:element ref=\"test\" minOccurs=\"0\" maxOccurs=\"\
    1\"/>\n         <xsd:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n       \
    \    <xsd:element ref=\"control\"/>\n           <xsd:element ref=\"action\"/>\n\
    \           <xsd:element ref=\"displayblock\"/>\n         </xsd:choice>\n    \
    \     <xsd:element ref=\"postamble\" minOccurs=\"0\" maxOccurs=\"1\"/>\n     \
    \  </xsd:sequence>\n       <xsd:attribute use=\"required\" name=\"name\" type=\"\
    identifier\"/>\n     </xsd:complexType>\n     <xsd:element name=\"control\" type=\"\
    command\"/>\n     <xsd:element name=\"action\" type=\"command\"/>\n     <xsd:element\
    \ name=\"test\">\n       <xsd:complexType>\n         <xsd:sequence>\n        \
    \   <xsd:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n             <xsd:element\
    \ ref=\"str\"/>\n             <xsd:element ref=\"num\"/>\n             <xsd:element\
    \ ref=\"list\"/>\n             <xsd:element ref=\"tag\"/>\n             <xsd:element\
    \ ref=\"displaydata\"/>\n             <xsd:element ref=\"comment\"/>\n       \
    \      <xsd:any namespace=\"##other\" processContents=\"lax\"/>\n           </xsd:choice>\n\
    \           <xsd:element ref=\"test\" minOccurs=\"0\"\n                      \
    \  maxOccurs=\"unbounded\"/>\n         </xsd:sequence>\n         <xsd:attribute\
    \ use=\"required\" name=\"name\" type=\"identifier\"/>\n       </xsd:complexType>\n\
    \     </xsd:element>\n     <xsd:element name=\"list\">\n       <xsd:complexType>\n\
    \         <xsd:sequence>\n           <xsd:element ref=\"str\" minOccurs=\"1\"\n\
    \                        maxOccurs=\"unbounded\"/>\n         </xsd:sequence>\n\
    \       </xsd:complexType>\n     </xsd:element>\n     <xsd:element name=\"tag\"\
    \ type=\"identifier\"/>\n     <xsd:element name=\"str\" type=\"xsd:string\"/>\n\
    \     <xsd:element name=\"num\" type=\"xsd:nonNegativeInteger\"/>\n     <xsd:simpleType\
    \ name=\"identifier\">\n       <xsd:restriction base=\"xsd:token\">\n        \
    \ <xsd:pattern value=\"[A-Za-z_][A-Za-z0-9_]*\"/>\n       </xsd:restriction>\n\
    \     </xsd:simpleType>\n     <xsd:element name=\"displayblock\">\n       <xsd:complexType>\n\
    \         <xsd:sequence>\n           <xsd:choice minOccurs=\"0\" maxOccurs=\"\
    unbounded\">\n             <xsd:element ref=\"control\"/>\n             <xsd:element\
    \ ref=\"action\"/>\n             <xsd:element ref=\"displayblock\"/>\n       \
    \      <xsd:element ref=\"displaydata\"/>\n             <xsd:element ref=\"comment\"\
    />\n             <xsd:any namespace=\"##other\" processContents=\"lax\"/>\n  \
    \         </xsd:choice>\n         </xsd:sequence>\n         <xsd:anyAttribute\
    \ processContents=\"skip\"/>\n       </xsd:complexType>\n     </xsd:element>\n\
    \     <xsd:element name=\"displaydata\">\n       <xsd:complexType>\n         <xsd:sequence\
    \ minOccurs=\"0\" maxOccurs=\"unbounded\">\n           <xsd:any processContents=\"\
    skip\"/>\n         </xsd:sequence>\n       </xsd:complexType>\n     </xsd:element>\n\
    \   </xsd:schema>\n"
- title: Appendix C.  Relax NG Schema for Sieves in XML
  contents:
  - "Appendix C.  Relax NG Schema for Sieves in XML\n   This appendix is informative.\
    \  The following code component defines a\n   Relax NG Schema using compact notation\
    \ OASISRNC [OASISRNC] for the\n   XML representation of Sieve scripts.  Most of\
    \ the elements employing\n   a complex content model allow unrestricted use of\
    \ elements in other\n   namespaces.  Additionally, displaydata elements can be\
    \ used to\n   encapsulate arbitrary XML content.  Finally, displayblock elements\n\
    \   can be used as a general-purpose grouping mechanism -- arbitrary\n   attributes\
    \ are allowed on displayblock elements.\n   namespace sieve = \"urn:ietf:params:xml:ns:sieve\"\
    \n   start = element sieve:sieve { ( control | action | displayblock |\n     \
    \                              displaydata | comment | ext )* }\n   comment =\
    \ element sieve:comment { xsd:string }\n   ambles =\n      (\n         ( displaydata\
    \ | comment | ext )*\n      ),\n      empty\n   preamble = element sieve:preamble\
    \ { ambles }\n   postamble = element sieve:postamble { ambles }\n   command =\n\
    \      (\n         attribute name {\n           xsd:token {\n             pattern\
    \ = \"[A-Za-z_][A-Za-z0-9_]*\" } },\n         preamble?,\n         ( str | num\
    \ | \\list | tag )*,\n         test?,\n         ( control | action | displayblock)*,\n\
    \         postamble?\n      ),\n      empty\n   control = element sieve:control\
    \ { command }\n   action = element sieve:action { command }\n   test =\n     \
    \ element sieve:test\n      {\n         attribute name {\n           xsd:token\
    \ {\n             pattern = \"[A-Za-z_][A-Za-z0-9_]*\" } },\n         ( str |\
    \ num | \\list | tag | comment | ext )*,\n         test*\n      }\n   \\list =\
    \ element sieve:list { str+ }\n   tag = element sieve:tag {\n           xsd:token\
    \ {\n             pattern = \"[A-Za-z_][A-Za-z0-9_]*\" } }\n   str = element sieve:str\
    \ { xsd:string }\n   num = element sieve:num { xsd:nonNegativeInteger }\n   any\
    \ = ( element * { any } | attribute * { text } | text )*\n   ext = element * -\
    \ sieve:* { any }*\n   displayblock =\n      element sieve:displayblock\n    \
    \  {\n         ( control | action | displayblock |\n           displaydata | comment\
    \ | ext )*,\n         attribute * { text }*\n      }\n   displaydata = element\
    \ sieve:displaydata { any* }\n"
- title: Appendix D.  Stylesheet for Conversion from XML
  contents:
  - "Appendix D.  Stylesheet for Conversion from XML\n   This appendix is informative.\
    \  The following code component is a\n   stylesheet that can be used to convert\
    \ the Sieve in XML\n   representation to regular Sieve format.  Content in other\
    \ namespaces,\n   displaydata, and displayblock elements are converted to structured\n\
    \   comments as appropriate.\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\
    \   <!-- Convert Sieve in XML to standard Sieve syntax -->\n   <xsl:stylesheet\
    \ version=\"1.0\"\n                   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\
    \n                   xmlns:sieve=\"urn:ietf:params:xml:ns:sieve\">\n     <xsl:output\
    \ method=\"text\" encoding=\"UTF-8\"\n                 media-type=\"application/sieve\"\
    />\n     <!-- Only preserve whitespace in str elements -->\n     <xsl:strip-space\
    \ elements=\"*\"/>\n     <xsl:preserve-space elements=\"sieve:str\"/>\n     <!--\
    \ Match top level sieve node,\n          start processing in sieve mode -->\n\
    \     <xsl:template match=\"sieve:sieve\">\n       <xsl:apply-templates select=\"\
    *\" mode=\"sieve\">\n         <xsl:with-param name=\"prefix\" select=\"''\"/>\n\
    \       </xsl:apply-templates>\n     </xsl:template>\n     <!-- Routine to properly\
    \ literalize quotes in Sieve strings -->\n     <xsl:template name=\"quote-string\"\
    >\n       <xsl:param name=\"str\"/>\n       <xsl:choose>\n         <xsl:when test=\"\
    not($str)\"/>\n         <xsl:when test=\"contains($str, '&quot;')\">\n       \
    \    <xsl:call-template name=\"quote-string\">\n             <xsl:with-param name=\"\
    str\"\n                select=\"substring-before($str, '&quot;')\"/>\n       \
    \    </xsl:call-template>\n           <xsl:text>\\&quot;</xsl:text>\n        \
    \   <xsl:call-template name=\"quote-string\">\n             <xsl:with-param name=\"\
    str\"\n                select=\"substring-after($str, '&quot;')\"/>\n        \
    \   </xsl:call-template>\n         </xsl:when>\n         <xsl:when test=\"contains($str,\
    \ '\\')\">\n           <xsl:call-template name=\"quote-string\">\n           \
    \  <xsl:with-param name=\"str\"\n                select=\"substring-before($str,\
    \ '\\')\"/>\n           </xsl:call-template>\n           <xsl:text>\\\\</xsl:text>\n\
    \           <xsl:call-template name=\"quote-string\">\n             <xsl:with-param\
    \ name=\"str\"\n                select=\"substring-after($str, '\\')\"/>\n   \
    \        </xsl:call-template>\n         </xsl:when>\n         <xsl:otherwise>\n\
    \           <xsl:value-of select=\"$str\"/>\n         </xsl:otherwise>\n     \
    \  </xsl:choose>\n     </xsl:template>\n     <!-- Sieve mode processing templates\
    \ -->\n     <xsl:template match=\"sieve:control|sieve:action\" mode=\"sieve\"\
    >\n       <xsl:param name=\"prefix\"/>\n       <xsl:text xml:space=\"preserve\"\
    >\n   </xsl:text>\n       <xsl:value-of select=\"$prefix\"/>\n       <xsl:value-of\
    \ select=\"@name\"/>\n       <xsl:variable name=\"blockbegin\"\n             \
    \  select=\"generate-id(sieve:control|sieve:action)\"/>\n       <xsl:for-each\
    \ select=\"*\">\n         <xsl:choose>\n           <xsl:when test=\"self::sieve:str|self::sieve:num|\n\
    \                           self::sieve:list|self::sieve:tag|\n              \
    \             self::sieve:test\">\n             <xsl:apply-templates select=\"\
    .\" mode=\"sieve\"/>\n           </xsl:when>\n           <xsl:when test=\"generate-id(.)\
    \ = $blockbegin\">\n             <xsl:text xml:space=\"preserve\">\n   </xsl:text>\n\
    \             <xsl:value-of select=\"$prefix\"/>\n             <xsl:text>{</xsl:text>\n\
    \             <xsl:apply-templates select=\".\" mode=\"sieve\">\n            \
    \   <xsl:with-param name=\"prefix\"\n                  select=\"concat($prefix,\
    \ '  ')\"/>\n             </xsl:apply-templates>\n           </xsl:when>\n   \
    \        <xsl:otherwise>\n             <xsl:apply-templates select=\".\" mode=\"\
    sieve\">\n               <xsl:with-param name=\"prefix\"\n                  select=\"\
    concat($prefix, '  ')\"/>\n             </xsl:apply-templates>\n           </xsl:otherwise>\n\
    \         </xsl:choose>\n       </xsl:for-each>\n       <xsl:choose>\n       \
    \  <xsl:when test=\"count(sieve:control|sieve:action) &gt; 0\">\n           <xsl:text\
    \ xml:space=\"preserve\">\n   </xsl:text>\n           <xsl:value-of select=\"\
    $prefix\"/>\n           <xsl:text>}</xsl:text>\n         </xsl:when>\n       \
    \  <xsl:otherwise>\n           <xsl:text>;</xsl:text>\n         </xsl:otherwise>\n\
    \       </xsl:choose>\n     </xsl:template>\n     <xsl:template match=\"sieve:preamble|sieve:postamble\"\
    \ mode=\"sieve\">\n       <xsl:param name=\"prefix\"/>\n       <xsl:apply-templates\
    \ mode=\"sieve\">\n         <xsl:with-param name=\"prefix\" select=\"$prefix\"\
    />\n       </xsl:apply-templates>\n     </xsl:template>\n     <xsl:template match=\"\
    sieve:test\" mode=\"sieve\">\n       <xsl:text xml:space=\"preserve\"> </xsl:text>\n\
    \       <xsl:value-of select=\"@name\"/>\n       <xsl:apply-templates select=\"\
    *[not(self::sieve:test)]\"\n                            mode=\"sieve\"/>\n   \
    \    <xsl:if test=\"count(descendant::sieve:test) &gt; 0\">\n         <xsl:text>\
    \ (</xsl:text>\n         <xsl:for-each select=\"sieve:test\">\n           <xsl:apply-templates\
    \ select=\".\" mode=\"sieve\"/>\n           <xsl:if test=\"count(following-sibling::sieve:test)\
    \ &gt; 0\">\n             <xsl:text>,</xsl:text>\n           </xsl:if>\n     \
    \    </xsl:for-each>\n         <xsl:text> )</xsl:text>\n       </xsl:if>\n   \
    \  </xsl:template>\n     <xsl:template match=\"sieve:str\" mode=\"sieve\">\n \
    \      <xsl:text> &quot;</xsl:text>\n       <xsl:call-template name=\"quote-string\"\
    >\n         <xsl:with-param name=\"str\" select=\"text()\"/>\n       </xsl:call-template>\n\
    \       <xsl:text>&quot;</xsl:text>\n     </xsl:template>\n     <xsl:template\
    \ match=\"sieve:num\" mode=\"sieve\">\n       <xsl:text xml:space=\"preserve\"\
    > </xsl:text>\n       <!-- Use numeric suffixes when possible -->\n       <xsl:choose>\n\
    \         <xsl:when test=\"(number(text()) mod 1073741824) = 0\">\n          \
    \ <xsl:value-of select=\"number(text()) div 1073741824\"/>\n           <xsl:text>G</xsl:text>\n\
    \         </xsl:when>\n         <xsl:when test=\"(number(text()) mod 1048576)\
    \ = 0\">\n           <xsl:value-of select=\"number(text()) div 1048576\"/>\n \
    \          <xsl:text>M</xsl:text>\n         </xsl:when>\n         <xsl:when test=\"\
    (number(text()) mod 1024) = 0\">\n           <xsl:value-of select=\"number(text())\
    \ div 1024\"/>\n           <xsl:text>K</xsl:text>\n         </xsl:when>\n    \
    \     <xsl:otherwise>\n           <xsl:value-of select=\"text()\"/>\n        \
    \ </xsl:otherwise>\n       </xsl:choose>\n     </xsl:template>\n     <xsl:template\
    \ match=\"sieve:list\" mode=\"sieve\">\n       <xsl:text> [</xsl:text>\n     \
    \  <xsl:for-each select=\"sieve:str\">\n         <xsl:apply-templates select=\"\
    .\" mode=\"sieve\"/>\n         <xsl:if test=\"count(following-sibling::sieve:str)\
    \ &gt; 0\">\n           <xsl:text>,</xsl:text>\n         </xsl:if>\n       </xsl:for-each>\n\
    \       <xsl:text> ]</xsl:text>\n     </xsl:template>\n     <xsl:template match=\"\
    sieve:tag\" mode=\"sieve\">\n       <xsl:text> :</xsl:text>\n       <xsl:value-of\
    \ select=\"text()\"/>\n     </xsl:template>\n     <xsl:template match=\"sieve:comment\"\
    \ mode=\"sieve\">\n       <xsl:param name=\"prefix\"/>\n       <xsl:text xml:space=\"\
    preserve\">\n   </xsl:text>\n       <xsl:value-of select=\"$prefix\"/>\n     \
    \  <xsl:text>/*</xsl:text>\n       <xsl:value-of select=\".\"/>\n       <xsl:value-of\
    \ select=\"$prefix\"/>\n       <xsl:text>*/</xsl:text>\n     </xsl:template>\n\
    \     <!-- Convert display information into structured comments -->\n     <xsl:template\
    \ match=\"sieve:displayblock\" mode=\"sieve\">\n       <xsl:param name=\"prefix\"\
    />\n       <xsl:text xml:space=\"preserve\">\n   </xsl:text>\n       <xsl:value-of\
    \ select=\"$prefix\"/>\n       <xsl:text>/* [*</xsl:text>\n       <xsl:apply-templates\
    \ select=\"@*\" mode=\"copy\"/>\n       <xsl:text> */</xsl:text>\n       <xsl:apply-templates\
    \ select=\"*\" mode=\"sieve\">\n         <xsl:with-param name=\"prefix\" select=\"\
    $prefix\"/>\n       </xsl:apply-templates>\n       <xsl:text xml:space=\"preserve\"\
    >\n   </xsl:text>\n       <xsl:value-of select=\"$prefix\"/>\n       <xsl:text>/*\
    \ *] */</xsl:text>\n     </xsl:template>\n     <xsl:template match=\"sieve:displaydata\"\
    \ mode=\"sieve\">\n       <xsl:param name=\"prefix\"/>\n       <xsl:text xml:space=\"\
    preserve\">\n   </xsl:text>\n       <xsl:value-of select=\"$prefix\"/>\n     \
    \  <xsl:text>/* [|</xsl:text>\n       <xsl:apply-templates mode=\"copy\">\n  \
    \       <xsl:with-param name=\"prefix\"\n                         select=\"concat($prefix,\
    \ '  ')\"/>\n       </xsl:apply-templates>\n       <xsl:text xml:space=\"preserve\"\
    >\n   </xsl:text>\n       <xsl:value-of select=\"$prefix\"/>\n       <xsl:text>\
    \   |] */</xsl:text>\n     </xsl:template>\n     <!-- Copy unrecnognized nodes\
    \ and their descendants -->\n     <xsl:template match=\"*\" mode=\"sieve\">\n\
    \       <xsl:param name=\"prefix\"/>\n       <xsl:text xml:space=\"preserve\"\
    >\n   </xsl:text>\n       <xsl:value-of select=\"$prefix\"/>\n       <xsl:text>/*\
    \ [/</xsl:text>\n       <xsl:apply-templates select=\".\" mode=\"copy\">\n   \
    \      <xsl:with-param name=\"prefix\"\n                         select=\"concat($prefix,\
    \ '  ')\"/>\n       </xsl:apply-templates>\n       <xsl:text xml:space=\"preserve\"\
    >\n   </xsl:text>\n       <xsl:value-of select=\"$prefix\"/>\n       <xsl:text>\
    \   /] */</xsl:text>\n     </xsl:template>\n     <!-- Copy mode processing templates\
    \ -->\n     <xsl:template match=\"*[not(node())]\" mode=\"copy\">\n       <xsl:param\
    \ name=\"prefix\"/>\n       <xsl:text xml:space=\"preserve\">\n   </xsl:text>\n\
    \       <xsl:value-of select=\"$prefix\"/>\n       <xsl:text>&lt;</xsl:text>\n\
    \       <xsl:value-of select=\"name()\"/>\n       <xsl:apply-templates select=\"\
    @*\" mode=\"copy\"/>\n       <xsl:text>/&gt;</xsl:text>\n     </xsl:template>\n\
    \     <xsl:template match=\"*[node()]\" mode=\"copy\">\n       <xsl:param name=\"\
    prefix\"/>\n       <xsl:text xml:space=\"preserve\">\n   </xsl:text>\n       <xsl:value-of\
    \ select=\"$prefix\"/>\n       <xsl:text>&lt;</xsl:text>\n       <xsl:value-of\
    \ select=\"name()\"/>\n       <xsl:apply-templates select=\"@*\" mode=\"copy\"\
    />\n       <xsl:text>&gt;</xsl:text>\n       <xsl:apply-templates mode=\"copy\"\
    >\n         <xsl:with-param name=\"prefix\"\n                         select=\"\
    concat($prefix, '  ')\"/>\n       </xsl:apply-templates>\n       <xsl:if test=\"\
    *[last()][not(text())]\">\n         <xsl:text xml:space=\"preserve\">\n   </xsl:text>\n\
    \         <xsl:value-of select=\"$prefix\"/>\n       </xsl:if>\n       <xsl:text>&lt;/</xsl:text>\n\
    \       <xsl:value-of select=\"name()\"/>\n       <xsl:text>&gt;</xsl:text>\n\
    \     </xsl:template>\n     <xsl:template match=\"@*\" mode=\"copy\">\n      \
    \ <xsl:text> </xsl:text>\n       <xsl:value-of select=\"name()\"/>\n       <xsl:text>=\"\
    </xsl:text>\n       <xsl:value-of select=\".\"/>\n       <xsl:text>\"</xsl:text>\n\
    \     </xsl:template>\n   </xsl:stylesheet>\n"
- title: Appendix E.  Acknowledgements
  contents:
  - "Appendix E.  Acknowledgements\n   The stylesheet copy mode code is loosely based\
    \ on a sample code\n   posted to the xsl-list list by Americo Albuquerque.  Jari\
    \ Arkko,\n   Robert Burrell Donkin, Andrew McKeon, Alexey Melnikov, and Aaron\n\
    \   Stone provided useful comments on the document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Ned Freed\n   Sun Microsystems\n   800 Royal Oaks\n  \
    \ Monrovia, CA  91016-6347\n   USA\n   Phone: +1 909 457 4293\n   EMail: ned.freed@mrochek.com\n\
    \   Srinivas Saisatish Vedam\n   Sun Microsystems\n   Phone: +91 80669 27577\n\
    \   EMail: Srinivas.Sv@Sun.COM\n"
