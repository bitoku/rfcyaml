- title: __initial_text__
  contents:
  - '                Host Identity Protocol Version 2 (HIPv2)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies the details of the Host Identity Protocol\n\
    \   (HIP).  HIP allows consenting hosts to securely establish and\n   maintain\
    \ shared IP-layer state, allowing separation of the identifier\n   and locator\
    \ roles of IP addresses, thereby enabling continuity of\n   communications across\
    \ IP address changes.  HIP is based on a Diffie-\n   Hellman key exchange, using\
    \ public key identifiers from a new Host\n   Identity namespace for mutual peer\
    \ authentication.  The protocol is\n   designed to be resistant to denial-of-service\
    \ (DoS) and man-in-the-\n   middle (MitM) attacks.  When used together with another\
    \ suitable\n   security protocol, such as the Encapsulating Security Payload (ESP),\n\
    \   it provides integrity protection and optional encryption for upper-\n   layer\
    \ protocols, such as TCP and UDP.\n   This document obsoletes RFC 5201 and addresses\
    \ the concerns raised by\n   the IESG, particularly that of crypto agility.  It\
    \ also incorporates\n   lessons learned from the implementations of RFC 5201.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7401.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \      1.1. A New Namespace and Identifiers ............................6\n  \
    \    1.2. The HIP Base Exchange (BEX) ................................6\n    \
    \  1.3. Memo Structure .............................................7\n   2. Terms\
    \ and Definitions ...........................................7\n      2.1. Requirements\
    \ Terminology ...................................7\n      2.2. Notation ...................................................8\n\
    \      2.3. Definitions ................................................8\n  \
    \ 3. Host Identity (HI) and Its Structure ............................9\n    \
    \  3.1. Host Identity Tag (HIT) ...................................10\n      3.2.\
    \ Generating a HIT from an HI ...............................11\n   4. Protocol\
    \ Overview ..............................................12\n      4.1. Creating\
    \ a HIP Association ................................12\n           4.1.1. HIP\
    \ Puzzle Mechanism ...............................14\n           4.1.2. Puzzle\
    \ Exchange ....................................15\n           4.1.3. Authenticated\
    \ Diffie-Hellman Protocol with\n                  DH Group Negotiation ...............................17\n\
    \           4.1.4. HIP Replay Protection ..............................18\n  \
    \         4.1.5. Refusing a HIP Base Exchange .......................19\n    \
    \       4.1.6. Aborting a HIP Base Exchange .......................20\n      \
    \     4.1.7. HIP Downgrade Protection ...........................20\n        \
    \   4.1.8. HIP Opportunistic Mode .............................21\n      4.2.\
    \ Updating a HIP Association ................................24\n      4.3. Error\
    \ Processing ..........................................24\n      4.4. HIP State\
    \ Machine .........................................25\n           4.4.1. State\
    \ Machine Terminology ..........................26\n           4.4.2. HIP States\
    \ .........................................27\n           4.4.3. HIP State Processes\
    \ ................................28\n           4.4.4. Simplified HIP State Diagram\
    \ .......................35\n      4.5. User Data Considerations ..................................37\n\
    \           4.5.1. TCP and UDP Pseudo Header Computation for\n               \
    \   User Data ..........................................37\n           4.5.2.\
    \ Sending Data on HIP Packets ........................37\n           4.5.3. Transport\
    \ Formats ..................................37\n           4.5.4. Reboot, Timeout,\
    \ and Restart of HIP ................37\n      4.6. Certificate Distribution ..................................38\n\
    \   5. Packet Formats .................................................38\n  \
    \    5.1. Payload Format ............................................38\n    \
    \       5.1.1. Checksum ...........................................40\n      \
    \     5.1.2. HIP Controls .......................................40\n        \
    \   5.1.3. HIP Fragmentation Support ..........................40\n      5.2.\
    \ HIP Parameters ............................................41\n           5.2.1.\
    \ TLV Format .........................................44\n           5.2.2. Defining\
    \ New Parameters ............................46\n           5.2.3. R1_COUNTER\
    \ .........................................47\n           5.2.4. PUZZLE .............................................48\n\
    \           5.2.5. SOLUTION ...........................................49\n  \
    \         5.2.6. DH_GROUP_LIST ......................................50\n    \
    \       5.2.7. DIFFIE_HELLMAN .....................................51\n      \
    \     5.2.8. HIP_CIPHER .........................................52\n        \
    \   5.2.9. HOST_ID ............................................54\n          \
    \ 5.2.10. HIT_SUITE_LIST ....................................56\n           5.2.11.\
    \ TRANSPORT_FORMAT_LIST .............................58\n           5.2.12. HIP_MAC\
    \ ...........................................59\n           5.2.13. HIP_MAC_2\
    \ .........................................59\n           5.2.14. HIP_SIGNATURE\
    \ .....................................60\n           5.2.15. HIP_SIGNATURE_2\
    \ ...................................61\n           5.2.16. SEQ ...............................................61\n\
    \           5.2.17. ACK ...............................................62\n  \
    \         5.2.18. ENCRYPTED .........................................62\n    \
    \       5.2.19. NOTIFICATION ......................................64\n      \
    \     5.2.20. ECHO_REQUEST_SIGNED ...............................67\n        \
    \   5.2.21. ECHO_REQUEST_UNSIGNED .............................68\n          \
    \ 5.2.22. ECHO_RESPONSE_SIGNED ..............................69\n           5.2.23.\
    \ ECHO_RESPONSE_UNSIGNED ............................69\n      5.3. HIP Packets\
    \ ...............................................70\n           5.3.1. I1 - the\
    \ HIP Initiator Packet ......................71\n           5.3.2. R1 - the HIP\
    \ Responder Packet ......................72\n           5.3.3. I2 - the Second\
    \ HIP Initiator Packet ...............75\n           5.3.4. R2 - the Second HIP\
    \ Responder Packet ...............76\n           5.3.5. UPDATE - the HIP Update\
    \ Packet .....................77\n           5.3.6. NOTIFY - the HIP Notify Packet\
    \ .....................78\n           5.3.7. CLOSE - the HIP Association Closing\
    \ Packet .........78\n           5.3.8. CLOSE_ACK - the HIP Closing Acknowledgment\
    \ Packet ..79\n      5.4. ICMP Messages .............................................79\n\
    \           5.4.1. Invalid Version ....................................79\n  \
    \         5.4.2. Other Problems with the HIP Header and\n                  Packet\
    \ Structure ...................................80\n           5.4.3. Invalid Puzzle\
    \ Solution ............................80\n           5.4.4. Non-existing HIP\
    \ Association .......................80\n   6. Packet Processing ..............................................80\n\
    \      6.1. Processing Outgoing Application Data ......................81\n  \
    \    6.2. Processing Incoming Application Data ......................82\n    \
    \  6.3. Solving the Puzzle ........................................83\n      6.4.\
    \ HIP_MAC and SIGNATURE Calculation and Verification ........84\n           6.4.1.\
    \ HMAC Calculation ...................................84\n           6.4.2. Signature\
    \ Calculation ..............................87\n      6.5. HIP KEYMAT Generation\
    \ .....................................89\n      6.6. Initiation of a HIP Base\
    \ Exchange .........................90\n           6.6.1. Sending Multiple I1\
    \ Packets in Parallel ............91\n           6.6.2. Processing Incoming ICMP\
    \ Protocol\n                  Unreachable Messages ...............................92\n\
    \      6.7. Processing of Incoming I1 Packets .........................92\n  \
    \         6.7.1. R1 Management ......................................94\n    \
    \       6.7.2. Handling of Malformed Messages .....................94\n      6.8.\
    \ Processing of Incoming R1 Packets .........................94\n           6.8.1.\
    \ Handling of Malformed Messages .....................97\n      6.9. Processing\
    \ of Incoming I2 Packets .........................97\n           6.9.1. Handling\
    \ of Malformed Messages ....................100\n      6.10. Processing of Incoming\
    \ R2 Packets .......................101\n      6.11. Sending UPDATE Packets ..................................101\n\
    \      6.12. Receiving UPDATE Packets ................................102\n  \
    \         6.12.1. Handling a SEQ Parameter in a Received\n                   UPDATE\
    \ Message ...................................103\n           6.12.2. Handling\
    \ an ACK Parameter in a Received\n                   UPDATE Packet ....................................104\n\
    \      6.13. Processing of NOTIFY Packets ............................104\n  \
    \    6.14. Processing of CLOSE Packets .............................105\n    \
    \  6.15. Processing of CLOSE_ACK Packets .........................105\n      6.16.\
    \ Handling State Loss .....................................105\n   7. HIP Policies\
    \ ..................................................106\n   8. Security Considerations\
    \ .......................................106\n   9. IANA Considerations ...........................................109\n\
    \   10. Differences from RFC 5201 ....................................113\n  \
    \ 11. References ...................................................117\n    \
    \  11.1. Normative References ....................................117\n      11.2.\
    \ Informative References ..................................119\n   Appendix A.\
    \ Using Responder Puzzles ..............................122\n   Appendix B. Generating\
    \ a Public Key Encoding from an HI ..........123\n   Appendix C. Example Checksums\
    \ for HIP Packets ....................123\n     C.1. IPv6 HIP Example (I1 Packet)\
    \ ..............................124\n     C.2. IPv4 HIP Packet (I1 Packet) ...............................124\n\
    \     C.3. TCP Segment ...............................................125\n  \
    \ Appendix D. ECDH and ECDSA 160-Bit Groups ........................125\n   Appendix\
    \ E. HIT Suites and HIT Generation ........................125\n   Acknowledgments\
    \ ..................................................127\n   Authors' Addresses\
    \ ...............................................128\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies the details of the Host Identity\
    \ Protocol\n   (HIP).  A high-level description of the protocol and the underlying\n\
    \   architectural thinking is available in the separate HIP architecture\n   description\
    \ [HIP-ARCH].  Briefly, the HIP architecture proposes an\n   alternative to the\
    \ dual use of IP addresses as \"locators\" (routing\n   labels) and \"identifiers\"\
    \ (endpoint, or host, identifiers).  In HIP,\n   public cryptographic keys, of\
    \ a public/private key pair, are used as\n   host identifiers, to which higher-layer\
    \ protocols are bound instead\n   of an IP address.  By using public keys (and\
    \ their representations)\n   as host identifiers, dynamic changes to IP address\
    \ sets can be\n   directly authenticated between hosts, and if desired, strong\n\
    \   authentication between hosts at the TCP/IP stack level can be\n   obtained.\n\
    \   This memo specifies the base HIP protocol (\"base exchange\") used\n   between\
    \ hosts to establish an IP-layer communications context, called\n   a HIP association,\
    \ prior to communications.  It also defines a packet\n   format and procedures\
    \ for updating and terminating an active HIP\n   association.  Other elements\
    \ of the HIP architecture are specified in\n   other documents, such as:\n   o\
    \  \"Using the Encapsulating Security Payload (ESP) Transport Format\n      with\
    \ the Host Identity Protocol (HIP)\" [RFC7402]: how to use the\n      Encapsulating\
    \ Security Payload (ESP) for integrity protection and\n      optional encryption\n\
    \   o  \"Host Mobility with the Host Identity Protocol\" [HIP-HOST-MOB]:\n   \
    \   how to support host mobility in HIP\n   o  \"Host Identity Protocol (HIP)\
    \ Domain Name System (DNS) Extension\"\n      [HIP-DNS-EXT]: how to extend DNS\
    \ to contain Host Identity\n      information\n   o  \"Host Identity Protocol\
    \ (HIP) Rendezvous Extension\"\n      [HIP-REND-EXT]: using a rendezvous mechanism\
    \ to contact mobile HIP\n      hosts\n   Since the HIP base exchange was first\
    \ developed, there have been a\n   few advances in cryptography and attacks against\
    \ cryptographic\n   systems.  As a result, all cryptographic protocols need to\
    \ be agile.\n   That is, the ability to switch from one cryptographic primitive\
    \ to\n   another should be a part of such protocols.  It is important to\n   support\
    \ a reasonable set of mainstream algorithms to cater to\n   different use cases\
    \ and allow moving away from algorithms that are\n   later discovered to be vulnerable.\
    \  This update to the base exchange\n   includes this needed cryptographic agility\
    \ while addressing the\n   downgrade attacks that such flexibility introduces.\
    \  In addition,\n   Elliptic Curve support via Elliptic Curve DSA (ECDSA) and\
    \ Elliptic\n   Curve Diffie-Hellman (ECDH) has been added.\n"
- title: 1.1.  A New Namespace and Identifiers
  contents:
  - "1.1.  A New Namespace and Identifiers\n   The Host Identity Protocol introduces\
    \ a new namespace, the Host\n   Identity namespace.  Some ramifications of this\
    \ new namespace are\n   explained in the HIP architecture description [HIP-ARCH].\n\
    \   There are two main representations of the Host Identity, the full\n   Host\
    \ Identity (HI) and the Host Identity Tag (HIT).  The HI is a\n   public key and\
    \ directly represents the Identity of a host.  Since\n   there are different public\
    \ key algorithms that can be used with\n   different key lengths, the HI, as such,\
    \ is unsuitable for use as a\n   packet identifier, or as an index into the various\
    \ state-related\n   implementation structures needed to support HIP.  Consequently,\
    \ a\n   hash of the HI, the Host Identity Tag (HIT), is used as the\n   operational\
    \ representation.  The HIT is 128 bits long and is used\n   in the HIP headers\
    \ and to index the corresponding state in the\n   end hosts.  The HIT has an important\
    \ security property in that it\n   is self-certifying (see Section 3).\n"
- title: 1.2.  The HIP Base Exchange (BEX)
  contents:
  - "1.2.  The HIP Base Exchange (BEX)\n   The HIP base exchange is a two-party cryptographic\
    \ protocol used to\n   establish communications context between hosts.  The base\
    \ exchange is\n   a SIGMA-compliant [KRA03] four-packet exchange.  The first party\
    \ is\n   called the Initiator and the second party the Responder.  The\n   protocol\
    \ exchanges Diffie-Hellman [DIF76] keys in the 2nd and 3rd\n   packets, and authenticates\
    \ the parties in the 3rd and 4th packets.\n   The four-packet design helps to\
    \ make HIP resistant to DoS attacks.\n   It allows the Responder to stay stateless\
    \ until the IP address and\n   the cryptographic puzzle are verified.  The Responder\
    \ starts the\n   puzzle exchange in the 2nd packet, with the Initiator completing\
    \ it\n   in the 3rd packet before the Responder stores any state from the\n  \
    \ exchange.\n   The exchange can use the Diffie-Hellman output to encrypt the\
    \ Host\n   Identity of the Initiator in the 3rd packet (although Aura, et al.\n\
    \   [AUR05] note that such operation may interfere with packet-inspecting\n  \
    \ middleboxes), or the Host Identity may instead be sent unencrypted.\n   The\
    \ Responder's Host Identity is not protected.  It should be noted,\n   however,\
    \ that both the Initiator's and the Responder's HITs are\n   transported as such\
    \ (in cleartext) in the packets, allowing an\n   eavesdropper with a priori knowledge\
    \ about the parties to identify\n   them by their HITs.  Hence, encrypting the\
    \ HI of any party does not\n   provide privacy against such an attacker.\n   Data\
    \ packets start to flow after the 4th packet.  The 3rd and 4th HIP\n   packets\
    \ may carry a data payload in the future.  However, the details\n   of this may\
    \ be defined later.\n   An existing HIP association can be updated using the update\
    \ mechanism\n   defined in this document, and when the association is no longer\n\
    \   needed, it can be closed using the defined closing mechanism.\n   Finally,\
    \ HIP is designed as an end-to-end authentication and key\n   establishment protocol,\
    \ to be used with Encapsulating Security\n   Payload (ESP) [RFC7402] and other\
    \ end-to-end security protocols.  The\n   base protocol does not cover all the\
    \ fine-grained policy control\n   found in Internet Key Exchange (IKE) [RFC7296]\
    \ that allows IKE to\n   support complex gateway policies.  Thus, HIP is not a\
    \ complete\n   replacement for IKE.\n"
- title: 1.3.  Memo Structure
  contents:
  - "1.3.  Memo Structure\n   The rest of this memo is structured as follows.  Section\
    \ 2 defines\n   the central keywords, notation, and terms used throughout the\
    \ rest of\n   the document.  Section 3 defines the structure of the Host Identity\n\
    \   and its various representations.  Section 4 gives an overview of the\n   HIP\
    \ base exchange protocol.  Sections 5 and 6 define the detailed\n   packet formats\
    \ and rules for packet processing.  Finally, Sections 7,\n   8, and 9 discuss\
    \ policy, security, and IANA considerations,\n   respectively.\n"
- title: 2.  Terms and Definitions
  contents:
  - '2.  Terms and Definitions

    '
- title: 2.1.  Requirements Terminology
  contents:
  - "2.1.  Requirements Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 2.2.  Notation
  contents:
  - "2.2.  Notation\n   [x]    indicates that x is optional.\n   {x}    indicates\
    \ that x is encrypted.\n   X(y)   indicates that y is a parameter of X.\n   <x>i\
    \   indicates that x exists i times.\n   -->    signifies \"Initiator to Responder\"\
    \ communication (requests).\n   <--    signifies \"Responder to Initiator\" communication\
    \ (replies).\n   |      signifies concatenation of information (e.g., X | Y is\
    \ the\n          concatenation of X with Y).\n   Ltrunc (H(x), #K)\n         \
    \ denotes the lowest-order #K bits of the result of the\n          hash function\
    \ H on the input x.\n"
- title: 2.3.  Definitions
  contents:
  - "2.3.  Definitions\n   HIP base exchange (BEX):  The handshake for establishing\
    \ a new HIP\n      association.\n   Host Identity (HI):  The public key of the\
    \ signature algorithm that\n      represents the identity of the host.  In HIP,\
    \ a host proves its\n      identity by creating a signature with the private key\
    \ belonging to\n      its HI (cf. Section 3).\n   Host Identity Tag (HIT):  A\
    \ shorthand for the HI in IPv6 format.  It\n      is generated by hashing the\
    \ HI (cf. Section 3.1).\n   HIT Suite:  A HIT Suite groups all cryptographic algorithms\
    \ that are\n      required to generate and use an HI and its HIT.  In particular,\n\
    \      these algorithms are 1) the public key signature algorithm, 2) the\n  \
    \    hash function, and 3) the truncation (cf. Appendix E).\n   HIP association:\
    \  The shared state between two peers after completion\n      of the BEX.\n  \
    \ HIP packet:  A control packet carrying a HIP packet header relating\n      to\
    \ the establishment, maintenance, or termination of the HIP\n      association.\n\
    \   Initiator:  The host that initiates the BEX.  This role is typically\n   \
    \   forgotten once the BEX is completed.\n   Responder:  The host that responds\
    \ to the Initiator in the BEX.  This\n      role is typically forgotten once the\
    \ BEX is completed.\n   Responder's HIT hash algorithm (RHASH):  The hash algorithm\
    \ used for\n      various hash calculations in this document.  The algorithm is\
    \ the\n      same as is used to generate the Responder's HIT.  The RHASH is the\n\
    \      hash function defined by the HIT Suite of the Responder's HIT\n      (cf.\
    \ Section 5.2.10).\n   Length of the Responder's HIT hash algorithm (RHASH_len):\
    \  The\n      natural output length of RHASH in bits.\n   Signed data:  Data that\
    \ is signed is protected by a digital signature\n      that was created by the\
    \ sender of the data by using the private\n      key of its HI.\n   KDF:  The\
    \ Key Derivation Function (KDF) is used for deriving the\n      symmetric keys\
    \ from the Diffie-Hellman key exchange.\n   KEYMAT:  The keying material derived\
    \ from the Diffie-Hellman key\n      exchange by using the KDF.  Symmetric keys\
    \ for encryption and\n      integrity protection of HIP packets and encrypted\
    \ user data\n      packets are drawn from this keying material.\n"
- title: 3.  Host Identity (HI) and Its Structure
  contents:
  - "3.  Host Identity (HI) and Its Structure\n   In this section, the properties\
    \ of the Host Identity and Host\n   Identity Tag are discussed, and the exact\
    \ format for them is defined.\n   In HIP, the public key of an asymmetric key\
    \ pair is used as the Host\n   Identity (HI).  Correspondingly, the host itself\
    \ is defined as the\n   entity that holds the private key of the key pair.  See\
    \ the HIP\n   architecture specification [HIP-ARCH] for more details on the\n\
    \   difference between an identity and the corresponding identifier.\n   HIP implementations\
    \ MUST support the Rivest Shamir Adleman [RSA]\n   public key algorithm and the\
    \ Elliptic Curve Digital Signature\n   Algorithm (ECDSA) for generating the HI\
    \ as defined in Section 5.2.9.\n   Additional algorithms MAY be supported.\n \
    \  A hashed encoding of the HI, the Host Identity Tag (HIT), is used in\n   protocols\
    \ to represent the Host Identity.  The HIT is 128 bits long\n   and has the following\
    \ three key properties: i) it is the same length\n   as an IPv6 address and can\
    \ be used in fixed address-sized fields in\n   APIs and protocols; ii) it is self-certifying\
    \ (i.e., given a HIT, it\n   is computationally hard to find a Host Identity key\
    \ that matches the\n   HIT); and iii) the probability of a HIT collision between\
    \ two hosts\n   is very low; hence, it is infeasible for an attacker to find a\n\
    \   collision with a HIT that is in use.  For details on the security\n   properties\
    \ of the HIT, see [HIP-ARCH].\n   The structure of the HIT is defined in [RFC7343].\
    \  The HIT is an\n   Overlay Routable Cryptographic Hash Identifier (ORCHID) and\
    \ consists\n   of three parts: first, an IANA-assigned prefix to distinguish it\
    \ from\n   other IPv6 addresses; second, a four-bit encoding of the algorithms\n\
    \   that were used for generating the HI and the hashed representation of\n  \
    \ HI; third, a 96-bit hashed representation of the Host Identity.  The\n   encoding\
    \ of the ORCHID generation algorithm and the exact algorithm\n   for generating\
    \ the hashed representation are specified in Appendix E\n   and [RFC7343].\n \
    \  Carrying HIs and HITs in the header of user data packets would\n   increase\
    \ the overhead of packets.  Thus, it is not expected that they\n   are carried\
    \ in every packet, but other methods are used to map the\n   data packets to the\
    \ corresponding HIs.  In some cases, this makes it\n   possible to use HIP without\
    \ any additional headers in the user data\n   packets.  For example, if ESP is\
    \ used to protect data traffic, the\n   Security Parameter Index (SPI) carried\
    \ in the ESP header can be used\n   to map the encrypted data packet to the correct\
    \ HIP association.\n"
- title: 3.1.  Host Identity Tag (HIT)
  contents:
  - "3.1.  Host Identity Tag (HIT)\n   The Host Identity Tag is a 128-bit value --\
    \ a hashed encoding of the\n   Host Identifier.  There are two advantages of using\
    \ a hashed encoding\n   over the actual variable-sized Host Identity public key\
    \ in protocols.\n   First, the fixed length of the HIT keeps packet sizes manageable\
    \ and\n   eases protocol coding.  Second, it presents a consistent format for\n\
    \   the protocol, independent of the underlying identity technology\n   in use.\n\
    \   RFC 7343 [RFC7343] specifies 128-bit hash-based identifiers, called\n   ORCHIDs.\
    \  Their prefix, allocated from the IPv6 address block, is\n   defined in [RFC7343].\
    \  The Host Identity Tag is one type of ORCHID.\n   This document extends the\
    \ original, experimental HIP specification\n   [RFC5201] with measures to support\
    \ crypto agility.  One of these\n   measures allows different hash functions for\
    \ creating a HIT.  HIT\n   Suites group the sets of algorithms that are required\
    \ to generate and\n   use a particular HIT.  The Suites are encoded in HIT Suite\
    \ IDs.\n   These HIT Suite IDs are transmitted in the ORCHID Generation\n   Algorithm\
    \ (OGA) field in the ORCHID.  With the HIT Suite ID in the\n   OGA ID field, a\
    \ host can tell, from another host's HIT, whether it\n   supports the necessary\
    \ hash and signature algorithms to establish a\n   HIP association with that host.\n"
- title: 3.2.  Generating a HIT from an HI
  contents:
  - "3.2.  Generating a HIT from an HI\n   The HIT MUST be generated according to\
    \ the ORCHID generation method\n   described in [RFC7343] using a context ID value\
    \ of 0xF0EF F02F BFF4\n   3D0F E793 0C3C 6E61 74EA (this tag value has been generated\
    \ randomly\n   by the editor of this specification), and an input that encodes\
    \ the\n   Host Identity field (see Section 5.2.9) present in a HIP payload\n \
    \  packet.  The set of hash function, signature algorithm, and the\n   algorithm\
    \ used for generating the HIT from the HI depends on the HIT\n   Suite (see Section\
    \ 5.2.10) and is indicated by the four bits of the\n   OGA ID field in the ORCHID.\
    \  Currently, truncated SHA-1, truncated\n   SHA-384, and truncated SHA-256 [FIPS.180-4.2012]\
    \ are defined as\n   hashes for generating a HIT.\n   For identities that are\
    \ either RSA, Digital Signature Algorithm (DSA)\n   [FIPS.186-4.2013], or Elliptic\
    \ Curve DSA (ECDSA) public keys, the\n   ORCHID input consists of the public key\
    \ encoding as specified for the\n   Host Identity field of the HOST_ID parameter\
    \ (see Section 5.2.9).\n   This document defines four algorithm profiles: RSA,\
    \ DSA, ECDSA, and\n   ECDSA_LOW.  The ECDSA_LOW profile is meant for devices with\
    \ low\n   computational capabilities.  Hence, one of the following applies:\n\
    \      The RSA public key is encoded as defined in [RFC3110], Section 2,\n   \
    \   taking the exponent length (e_len), exponent (e), and modulus (n)\n      fields\
    \ concatenated.  The length (n_len) of the modulus (n) can be\n      determined\
    \ from the total HI Length and the preceding HI fields\n      including the exponent\
    \ (e).  Thus, the data that serves as input\n      for the HIT generation has\
    \ the same length as the HI.  The fields\n      MUST be encoded in network byte\
    \ order, as defined in [RFC3110].\n      The DSA public key is encoded as defined\
    \ in [RFC2536], Section 2,\n      taking the fields T, Q, P, G, and Y, concatenated\
    \ as input.  Thus,\n      the data to be hashed is 1 + 20 + 3 * 64 + 3 * 8 * T\
    \ octets long,\n      where T is the size parameter as defined in [RFC2536]. \
    \ The size\n      parameter T, affecting the field lengths, MUST be selected as\
    \ the\n      minimum value that is long enough to accommodate P, G, and Y.  The\n\
    \      fields MUST be encoded in network byte order, as defined in\n      [RFC2536].\n\
    \      The ECDSA public keys are encoded as defined in Sections 4.2 and 6\n  \
    \    of [RFC6090].\n   In Appendix B, the public key encoding process is illustrated\
    \ using\n   pseudo-code.\n"
- title: 4.  Protocol Overview
  contents:
  - "4.  Protocol Overview\n   This section is a simplified overview of the HIP protocol\
    \ operation,\n   and does not contain all the details of the packet formats or\
    \ the\n   packet processing steps.  Sections 5 and 6 describe in more detail\n\
    \   the packet formats and packet processing steps, respectively, and are\n  \
    \ normative in case of any conflicts with this section.\n   The protocol number\
    \ 139 has been assigned by IANA to the Host\n   Identity Protocol.\n   The HIP\
    \ payload (Section 5.1) header could be carried in every IP\n   datagram.  However,\
    \ since HIP headers are relatively large\n   (40 bytes), it is desirable to 'compress'\
    \ the HIP header so that the\n   HIP header only occurs in control packets used\
    \ to establish or change\n   HIP association state.  The actual method for header\
    \ 'compression'\n   and for matching data packets with existing HIP associations\
    \ (if any)\n   is defined in separate documents, describing transport formats\
    \ and\n   methods.  All HIP implementations MUST implement, at minimum, the ESP\n\
    \   transport format for HIP [RFC7402].\n"
- title: 4.1.  Creating a HIP Association
  contents:
  - "4.1.  Creating a HIP Association\n   By definition, the system initiating a HIP\
    \ base exchange is the\n   Initiator, and the peer is the Responder.  This distinction\
    \ is\n   typically forgotten once the base exchange completes, and either\n  \
    \ party can become the Initiator in future communications.\n   The HIP base exchange\
    \ serves to manage the establishment of state\n   between an Initiator and a Responder.\
    \  The first packet, I1,\n   initiates the exchange, and the last three packets,\
    \ R1, I2, and R2,\n   constitute an authenticated Diffie-Hellman [DIF76] key exchange\
    \ for\n   session-key generation.  In the first two packets, the hosts agree on\n\
    \   a set of cryptographic identifiers and algorithms that are then used\n   in\
    \ and after the exchange.  During the Diffie-Hellman key exchange, a\n   piece\
    \ of keying material is generated.  The HIP association keys are\n   drawn from\
    \ this keying material by using a Key Derivation Function\n   (KDF).  If other\
    \ cryptographic keys are needed, e.g., to be used with\n   ESP, they are expected\
    \ to be drawn from the same keying material by\n   using the KDF.\n   The Initiator\
    \ first sends a trigger packet, I1, to the Responder.\n   The packet contains\
    \ the HIT of the Initiator and possibly the HIT of\n   the Responder, if it is\
    \ known.  Moreover, the I1 packet initializes\n   the negotiation of the Diffie-Hellman\
    \ group that is used for\n   generating the keying material.  Therefore, the I1\
    \ packet contains a\n   list of Diffie-Hellman Group IDs supported by the Initiator.\
    \  Note\n   that in some cases it may be possible to replace this trigger packet\n\
    \   with some other form of a trigger, in which case the protocol starts\n   with\
    \ the Responder sending the R1 packet.  In such cases, another\n   mechanism to\
    \ convey the Initiator's supported DH groups (e.g., by\n   using a default group)\
    \ must be specified.\n   The second packet, R1, starts the actual authenticated\
    \ Diffie-Hellman\n   exchange.  It contains a puzzle -- a cryptographic challenge\
    \ that the\n   Initiator must solve before continuing the exchange.  The level\
    \ of\n   difficulty of the puzzle can be adjusted based on the level of trust\n\
    \   with the Initiator, the current load, or other factors.  In addition,\n  \
    \ the R1 contains the Responder's Diffie-Hellman parameter and lists of\n   cryptographic\
    \ algorithms supported by the Responder.  Based on these\n   lists, the Initiator\
    \ can continue, abort, or restart the base\n   exchange with a different selection\
    \ of cryptographic algorithms.\n   Also, the R1 packet contains a signature that\
    \ covers selected parts\n   of the message.  Some fields are left outside the\
    \ signature to\n   support pre-created R1s.\n   In the I2 packet, the Initiator\
    \ MUST display the solution to the\n   received puzzle.  Without a correct solution,\
    \ the I2 message is\n   discarded.  The I2 packet also contains a Diffie-Hellman\
    \ parameter\n   that carries needed information for the Responder.  The I2 packet\
    \ is\n   signed by the Initiator.\n   The R2 packet acknowledges the receipt of\
    \ the I2 packet and completes\n   the base exchange.  The packet is signed by\
    \ the Responder.\n   The base exchange is illustrated below in Figure 1.  The\
    \ term \"key\"\n   refers to the Host Identity public key, and \"sig\" represents\
    \ a\n   signature using such a key.  The packets contain other parameters not\n\
    \   shown in this figure.\n      Initiator                              Responder\n\
    \                   I1: DH list\n                 -------------------------->\n\
    \                                             select precomputed R1\n        \
    \           R1: puzzle, DH, key, sig\n                 <-------------------------\n\
    \   check sig                                 remain stateless\n   solve puzzle\n\
    \                 I2: solution, DH, {key}, sig\n                 -------------------------->\n\
    \   compute DH                                check puzzle\n                 \
    \                            check sig\n                           R2: sig\n \
    \                <--------------------------\n   check sig                   \
    \              compute DH\n                                 Figure 1\n"
- title: 4.1.1.  HIP Puzzle Mechanism
  contents:
  - "4.1.1.  HIP Puzzle Mechanism\n   The purpose of the HIP puzzle mechanism is to\
    \ protect the Responder\n   from a number of denial-of-service threats.  It allows\
    \ the Responder\n   to delay state creation until receiving the I2 packet.  Furthermore,\n\
    \   the puzzle allows the Responder to use a fairly cheap calculation to\n   check\
    \ that the Initiator is \"sincere\" in the sense that it has\n   churned enough\
    \ CPU cycles in solving the puzzle.\n   The puzzle allows a Responder implementation\
    \ to completely delay\n   association-specific state creation until a valid I2\
    \ packet is\n   received.  An I2 packet without a valid puzzle solution can be\n\
    \   rejected immediately once the Responder has checked the solution.\n   The\
    \ solution can be checked by computing only one hash function, and\n   invalid\
    \ solutions can be rejected before state is created, and before\n   CPU-intensive\
    \ public-key signature verification and Diffie-Hellman\n   key generation are\
    \ performed.  By varying the difficulty of the\n   puzzle, the Responder can frustrate\
    \ CPU- or memory-targeted DoS\n   attacks.\n   The Responder can remain stateless\
    \ and drop most spoofed I2 packets\n   because puzzle calculation is based on\
    \ the Initiator's Host Identity\n   Tag.  The idea is that the Responder has a\
    \ (perhaps varying) number\n   of pre-calculated R1 packets, and it selects one\
    \ of these based on\n   the information carried in the I1 packet.  When the Responder\
    \ then\n   later receives the I2 packet, it can verify that the puzzle has been\n\
    \   solved using the Initiator's HIT.  This makes it impractical for the\n   attacker\
    \ to first exchange one I1/R1 packet, and then generate a\n   large number of\
    \ spoofed I2 packets that seemingly come from different\n   HITs.  This method\
    \ does not protect the Responder from an attacker\n   that uses fixed HITs, though.\
    \  Against such an attacker, a viable\n   approach may be to create a piece of\
    \ local state, and remember that\n   the puzzle check has previously failed. \
    \ See Appendix A for one\n   possible implementation.  Responder implementations\
    \ SHOULD include\n   sufficient randomness in the puzzle values so that algorithmic\n\
    \   complexity attacks become impossible [CRO03].\n   The Responder can set the\
    \ puzzle difficulty for the Initiator, based\n   on its level of trust of the\
    \ Initiator.  Because the puzzle is not\n   included in the signature calculation,\
    \ the Responder can use\n   pre-calculated R1 packets and include the puzzle just\
    \ before sending\n   the R1 to the Initiator.  The Responder SHOULD use heuristics\
    \ to\n   determine when it is under a denial-of-service attack, and set the\n\
    \   puzzle difficulty value #K appropriately, as explained later.\n"
- title: 4.1.2.  Puzzle Exchange
  contents:
  - "4.1.2.  Puzzle Exchange\n   The Responder starts the puzzle exchange when it\
    \ receives an I1\n   packet.  The Responder supplies a random number #I, and requires\
    \ the\n   Initiator to find a number #J.  To select a proper #J, the Initiator\n\
    \   must create the concatenation of #I, the HITs of the parties, and #J,\n  \
    \ and calculate a hash over this concatenation using the RHASH\n   algorithm.\
    \  The lowest-order #K bits of the result MUST be zeros.\n   The value #K sets\
    \ the difficulty of the puzzle.\n   To generate a proper number #J, the Initiator\
    \ will have to generate a\n   number of #Js until one produces the hash target\
    \ of zeros.  The\n   Initiator SHOULD give up after exceeding the puzzle Lifetime\
    \ in the\n   PUZZLE parameter (as described in Section 5.2.4).  The Responder\n\
    \   needs to re-create the concatenation of #I, the HITs, and the\n   provided\
    \ #J, and compute the hash once to prove that the Initiator\n   completed its\
    \ assigned task.\n   To prevent precomputation attacks, the Responder MUST select\
    \ the\n   number #I in such a way that the Initiator cannot guess it.\n   Furthermore,\
    \ the construction MUST allow the Responder to verify that\n   the value #I was\
    \ indeed selected by it and not by the Initiator.  See\n   Appendix A for an example\
    \ on how to implement this.\n   Using the Opaque data field in the PUZZLE (see\
    \ Section 5.2.4) in an\n   ECHO_REQUEST_SIGNED (see Section 5.2.20) or in an\n\
    \   ECHO_REQUEST_UNSIGNED parameter (see Section 5.2.21), the Responder\n   can\
    \ include some data in R1 that the Initiator MUST copy unmodified\n   in the corresponding\
    \ I2 packet.  The Responder can use the opaque\n   data to transfer a piece of\
    \ local state information to the Initiator\n   and back -- for example, to recognize\
    \ that the I2 is a response to a\n   previously sent R1.  The Responder can generate\
    \ the opaque data in\n   various ways, e.g., using encryption or hashing with\
    \ some secret, the\n   sent #I, and possibly using other related data.  With the\
    \ same\n   secret, the received #I (from the I2 packet), and the other related\n\
    \   data (if any), the Responder can verify that it has itself sent the\n   #I\
    \ to the Initiator.  The Responder MUST periodically change such a\n   secret.\n\
    \   It is RECOMMENDED that the Responder generates new secrets for the\n   puzzle\
    \ and new R1s once every few minutes.  Furthermore, it is\n   RECOMMENDED that\
    \ the Responder is able to verify a valid puzzle\n   solution at least Lifetime\
    \ seconds after the puzzle secret has been\n   deprecated.  This time value guarantees\
    \ that the puzzle is valid for\n   at least Lifetime and at most 2 * Lifetime\
    \ seconds.  This limits the\n   usability that an old, solved puzzle has to an\
    \ attacker.  Moreover,\n   it avoids problems with the validity of puzzles if\
    \ the lifetime is\n   relatively short compared to the network delay and the time\
    \ for\n   solving the puzzle.\n   The puzzle value #I and the solution #J are\
    \ inputs for deriving the\n   keying material from the Diffie-Hellman key exchange\
    \ (see\n   Section 6.5).  Therefore, to ensure that the derived keying material\n\
    \   differs, a Responder SHOULD NOT use the same puzzle #I with the same\n   DH\
    \ keys for the same Initiator twice.  Such uniqueness can be\n   achieved, for\
    \ example, by using a counter as an additional input for\n   generating #I.  This\
    \ counter can be increased for each processed I1\n   packet.  The state of the\
    \ counter can be transmitted in the Opaque\n   data field in the PUZZLE (see Section\
    \ 5.2.4), in an\n   ECHO_REQUEST_SIGNED parameter (see Section 5.2.20), or in\
    \ an\n   ECHO_REQUEST_UNSIGNED parameter (see Section 5.2.21) without the need\n\
    \   to establish state.\n   NOTE: The protocol developers explicitly considered\
    \ whether R1 should\n   include a timestamp in order to protect the Initiator\
    \ from replay\n   attacks.  The decision was to NOT include a timestamp, to avoid\n\
    \   problems with global time synchronization.\n   NOTE: The protocol developers\
    \ explicitly considered whether a memory-\n   bound function should be used for\
    \ the puzzle instead of a CPU-bound\n   function.  The decision was to not use\
    \ memory-bound functions.\n"
- title: 4.1.3.  Authenticated Diffie-Hellman Protocol with DH Group Negotiation
  contents:
  - "4.1.3.  Authenticated Diffie-Hellman Protocol with DH Group Negotiation\n   The\
    \ packets R1, I2, and R2 implement a standard authenticated\n   Diffie-Hellman\
    \ exchange.  The Responder sends one of its public\n   Diffie-Hellman keys and\
    \ its public authentication key, i.e., its Host\n   Identity, in R1.  The signature\
    \ in the R1 packet allows the Initiator\n   to verify that the R1 has been once\
    \ generated by the Responder.\n   However, since the R1 is precomputed and therefore\
    \ does not cover\n   association-specific information in the I1 packet, it does\
    \ not\n   protect against replay attacks.\n   Before the actual authenticated\
    \ Diffie-Hellman exchange, the\n   Initiator expresses its preference regarding\
    \ its choice of the DH\n   groups in the I1 packet.  The preference is expressed\
    \ as a sorted\n   list of DH Group IDs.  The I1 packet is not protected by a signature.\n\
    \   Therefore, this list is sent in an unauthenticated way to avoid\n   costly\
    \ computations for processing the I1 packet at the Responder\n   side.  Based\
    \ on the preferences of the Initiator, the Responder sends\n   an R1 packet containing\
    \ its most suitable public DH value.  The\n   Responder also attaches a list of\
    \ its own preferences to the R1 to\n   convey the basis for the DH group selection\
    \ to the Initiator.  This\n   list is carried in the signed part of the R1 packet.\
    \  If the choice\n   of the DH group value in the R1 does not match the preferences\
    \ of the\n   Initiator and the Responder, the Initiator can detect that the list\n\
    \   of DH Group IDs in the I1 was manipulated (see below for details).\n   If\
    \ none of the DH Group IDs in the I1 packet are supported by the\n   Responder,\
    \ the Responder selects the DH group most suitable for it,\n   regardless of the\
    \ Initiator's preference.  It then sends the R1\n   containing this DH group and\
    \ its list of supported DH Group IDs to\n   the Initiator.\n   When the Initiator\
    \ receives an R1, it receives one of the Responder's\n   public Diffie-Hellman\
    \ values and the list of DH Group IDs supported\n   by the Responder.  This list\
    \ is covered by the signature in the R1\n   packet to avoid forgery.  The Initiator\
    \ compares the Group ID of the\n   public DH value in the R1 packet to the list\
    \ of supported DH Group\n   IDs in the R1 packets and to its own preferences expressed\
    \ in the\n   list of supported DH Group IDs.  The Initiator continues the BEX\
    \ only\n   if the Group ID of the public DH value of the Responder is the most\n\
    \   preferred of the IDs supported by both the Initiator and Responder.\n   Otherwise,\
    \ the communication is subject to a downgrade attack, and\n   the Initiator MUST\
    \ either restart the base exchange with a new I1\n   packet or abort the base\
    \ exchange.  If the Responder's choice of the\n   DH group is not supported by\
    \ the Initiator, the Initiator MAY abort\n   the handshake or send a new I1 packet\
    \ with a different list of\n   supported DH groups.  However, the Initiator MUST\
    \ verify the\n   signature of the R1 packet before restarting or aborting the\n\
    \   handshake.  It MUST silently ignore the R1 packet if the signature is\n  \
    \ not valid.\n   If the preferences regarding the DH Group ID match, the Initiator\n\
    \   computes the Diffie-Hellman session key (Kij).  The Initiator creates\n  \
    \ a HIP association using keying material from the session key (see\n   Section\
    \ 6.5) and may use the HIP association to encrypt its public\n   authentication\
    \ key, i.e., the Host Identity.  The resulting I2 packet\n   contains the Initiator's\
    \ Diffie-Hellman key and its (optionally\n   encrypted) public authentication\
    \ key.  The signature of the I2\n   message covers all parameters of the signed\
    \ parameter ranges (see\n   Section 5.2) in the packet without exceptions, as\
    \ in the R1.\n   The Responder extracts the Initiator's Diffie-Hellman public\
    \ key from\n   the I2 packet, computes the Diffie-Hellman session key, creates\
    \ a\n   corresponding HIP association, and decrypts the Initiator's public\n \
    \  authentication key.  It can then verify the signature using the\n   authentication\
    \ key.\n   The final message, R2, completes the BEX and protects the Initiator\n\
    \   against replay attacks, because the Responder uses the shared key\n   from\
    \ the Diffie-Hellman exchange to create a Hashed Message\n   Authentication Code\
    \ (HMAC) and also uses the private key of its Host\n   Identity to sign the packet\
    \ contents.\n"
- title: 4.1.4.  HIP Replay Protection
  contents:
  - "4.1.4.  HIP Replay Protection\n   HIP includes the following mechanisms to protect\
    \ against malicious\n   packet replays.  Responders are protected against replays\
    \ of I1\n   packets by virtue of the stateless response to I1 packets with\n \
    \  pre-signed R1 messages.  Initiators are protected against R1 replays\n   by\
    \ a monotonically increasing \"R1 generation counter\" included in\n   the R1.\
    \  Responders are protected against replays of forged I2\n   packets by the puzzle\
    \ mechanism (see Section 4.1.1 above), and\n   optional use of opaque data.  Hosts\
    \ are protected against replays of\n   R2 packets and UPDATEs by use of a less\
    \ expensive HMAC verification\n   preceding the HIP signature verification.\n\
    \   The R1 generation counter is a monotonically increasing 64-bit\n   counter\
    \ that may be initialized to any value.  The scope of the\n   counter MAY be system-wide,\
    \ but there SHOULD be a separate counter\n   for each Host Identity, if there\
    \ is more than one local Host\n   Identity.  The value of this counter SHOULD\
    \ be preserved across\n   system reboots and invocations of the HIP base exchange.\
    \  This\n   counter indicates the current generation of puzzles.  Implementations\n\
    \   MUST accept puzzles from the current generation and MAY accept\n   puzzles\
    \ from earlier generations.  A system's local counter MUST be\n   incremented\
    \ at least as often as every time old R1s cease to be\n   valid.  The local counter\
    \ SHOULD never be decremented; otherwise, the\n   host exposes its peers to the\
    \ replay of previously generated, higher-\n   numbered R1s.\n   A host may receive\
    \ more than one R1, either due to sending multiple\n   I1 packets (see Section\
    \ 6.6.1) or due to a replay of an old R1.  When\n   sending multiple I1 packets\
    \ to the same host, an Initiator SHOULD\n   wait for a small amount of time (a\
    \ reasonable time may be\n   2 * expected RTT) after the first R1 reception to\
    \ allow possibly\n   multiple R1s to arrive, and it SHOULD respond to an R1 among\
    \ the set\n   with the largest R1 generation counter.  If an Initiator is\n  \
    \ processing an R1 or has already sent an I2 packet (still waiting for\n   the\
    \ R2 packet) and it receives another R1 with a larger R1 generation\n   counter,\
    \ it MAY elect to restart R1 processing with the fresher R1,\n   as if it were\
    \ the first R1 to arrive.\n   The R1 generation counter may roll over or may become\
    \ reset.  It is\n   important for an Initiator to be robust to the loss of state\
    \ about\n   the R1 generation counter of a peer or to a reset of the peer's\n\
    \   counter.  It is recommended that, when choosing between multiple R1s,\n  \
    \ the Initiator prefer to use the R1 that corresponds to the current R1\n   generation\
    \ counter, but that if it is unable to make progress with\n   that R1, the Initiator\
    \ may try the other R1s, beginning with the R1\n   packet with the highest counter.\n"
- title: 4.1.5.  Refusing a HIP Base Exchange
  contents:
  - "4.1.5.  Refusing a HIP Base Exchange\n   A HIP-aware host may choose not to accept\
    \ a HIP base exchange.  If\n   the host's policy is to only be an Initiator and\
    \ policy allows the\n   establishment of a HIP association with the original Initiator,\
    \ it\n   should begin its own HIP base exchange.  A host MAY choose to have\n\
    \   such a policy since only the privacy of the Initiator's HI is\n   protected\
    \ in the exchange.  It should be noted that such behavior can\n   introduce the\
    \ risk of a race condition if each host's policy is to\n   only be an Initiator,\
    \ at which point the HIP base exchange will fail.\n   If the host's policy does\
    \ not permit it to enter into a HIP exchange\n   with the Initiator, it should\
    \ send an ICMP 'Destination Unreachable,\n   Administratively Prohibited' message.\
    \  A more complex HIP packet is\n   not used here as it actually opens up more\
    \ potential DoS attacks than\n   a simple ICMP message.  A HIP NOTIFY message\
    \ is not used because no\n   HIP association exists between the two hosts at that\
    \ time.\n"
- title: 4.1.6.  Aborting a HIP Base Exchange
  contents:
  - "4.1.6.  Aborting a HIP Base Exchange\n   Two HIP hosts may encounter situations\
    \ in which they cannot complete\n   a HIP base exchange because of insufficient\
    \ support for cryptographic\n   algorithms, in particular the HIT Suites and DH\
    \ groups.  After\n   receiving the R1 packet, the Initiator can determine whether\
    \ the\n   Responder supports the required cryptographic operations to\n   successfully\
    \ establish a HIP association.  The Initiator can abort\n   the BEX silently after\
    \ receiving an R1 packet that indicates an\n   unsupported set of algorithms.\
    \  The specific conditions are described\n   below.\n   The R1 packet contains\
    \ a signed list of HIT Suite IDs as supported by\n   the Responder.  Therefore,\
    \ the Initiator can determine whether its\n   source HIT is supported by the Responder.\
    \  If the HIT Suite ID of the\n   Initiator's HIT is not contained in the list\
    \ of HIT Suites in the R1,\n   the Initiator MAY abort the handshake silently\
    \ or MAY restart the\n   handshake with a new I1 packet that contains a source\
    \ HIT supported\n   by the Responder.\n   During the handshake, the Initiator\
    \ and the Responder agree on a\n   single DH group.  The Responder selects the\
    \ DH group and its DH\n   public value in the R1 based on the list of DH Group\
    \ IDs in the I1\n   packet.  If the Responder supports none of the DH groups requested\
    \ by\n   the Initiator, the Responder selects an arbitrary DH and replies with\n\
    \   an R1 containing its list of supported DH Group IDs.  In such a case,\n  \
    \ the Initiator receives an R1 packet containing the DH public value\n   for an\
    \ unrequested DH group and also the Responder's DH group list in\n   the signed\
    \ part of the R1 packet.  At this point, the Initiator MAY\n   abort the handshake\
    \ or MAY restart the handshake by sending a new I1\n   packet containing a selection\
    \ of DH Group IDs that is supported by\n   the Responder.\n"
- title: 4.1.7.  HIP Downgrade Protection
  contents:
  - "4.1.7.  HIP Downgrade Protection\n   In a downgrade attack, an attacker attempts\
    \ to unnoticeably\n   manipulate the packets of an Initiator and/or a Responder\
    \ to\n   influence the result of the cryptographic negotiations in the BEX in\n\
    \   its favor.  As a result, the victims select weaker cryptographic\n   algorithms\
    \ than they would otherwise have selected without the\n   attacker's interference.\
    \  Downgrade attacks can only be successful if\n   they remain undetected by the\
    \ victims and the victims falsely assume\n   a secure communication channel.\n\
    \   In HIP, almost all packet parameters related to cryptographic\n   negotiations\
    \ are covered by signatures.  These parameters cannot be\n   directly manipulated\
    \ in a downgrade attack without invalidating the\n   signature.  However, signed\
    \ packets can be subject to replay attacks.\n   In such a replay attack, the attacker\
    \ could use an old BEX packet\n   with an outdated and weak selection of cryptographic\
    \ algorithms and\n   replay it instead of a more recent packet with a collection\
    \ of\n   stronger cryptographic algorithms.  Signed packets that could be\n  \
    \ subject to this replay attack are the R1 and I2 packet.  However,\n   replayed\
    \ R1 and I2 packets cannot be used to successfully establish a\n   HIP BEX because\
    \ these packets also contain the public DH values of\n   the Initiator and the\
    \ Responder.  Old DH values from replayed packets\n   lead to invalid keying material\
    \ and mismatching shared secrets\n   because the attacker is unable to derive\
    \ valid keying material from\n   the DH public keys in the R1 and cannot generate\
    \ a valid HMAC and\n   signature for a replayed I2.\n   In contrast to the first\
    \ version of HIP [RFC5201], version 2 of HIP\n   as defined in this document begins\
    \ the negotiation of the DH groups\n   already in the first BEX packet, the I1.\
    \  The I1 packet is, by\n   intention, not protected by a signature, to avoid\
    \ CPU-intensive\n   cryptographic operations processing floods of I1 packets targeted\
    \ at\n   the Responder.  Hence, the list of DH Group IDs in the I1 packet is\n\
    \   vulnerable to forgery and manipulation.  To thwart an unnoticed\n   manipulation\
    \ of the I1 packet, the Responder chooses the DH group\n   deterministically and\
    \ includes its own list of DH Group IDs in the\n   signed part of the R1 packet.\
    \  The Initiator can detect an attempted\n   downgrade attack by comparing the\
    \ list of DH Group IDs in the R1\n   packet to its own preferences in the I1 packet.\
    \  If the choice of the\n   DH group in the R1 packet does not equal the best\
    \ match of the two\n   lists (the highest-priority DH ID of the Responder that\
    \ is present in\n   the Initiator's DH list), the Initiator can conclude that\
    \ its list in\n   the I1 packet was altered by an attacker.  In this case, the\n\
    \   Initiator can restart or abort the BEX.  As mentioned before, the\n   detection\
    \ of the downgrade attack is sufficient to prevent it.\n"
- title: 4.1.8.  HIP Opportunistic Mode
  contents:
  - "4.1.8.  HIP Opportunistic Mode\n   It is possible to initiate a HIP BEX even\
    \ if the Responder's HI (and\n   HIT) is unknown.  In this case, the initial I1\
    \ packet contains all\n   zeros as the destination HIT.  This kind of connection\
    \ setup is\n   called opportunistic mode.\n   The Responder may have multiple\
    \ HITs due to multiple supported HIT\n   Suites.  Since the Responder's HIT Suite\
    \ in the opportunistic mode is\n   not determined by the destination HIT of the\
    \ I1 packet, the Responder\n   can freely select a HIT of any HIT Suite.  The\
    \ complete set of HIT\n   Suites supported by the Initiator is not known to the\
    \ Responder.\n   Therefore, the Responder SHOULD select its HIT from the same\
    \ HIT\n   Suite as the Initiator's HIT (indicated by the HIT Suite information\n\
    \   in the OGA ID field of the Initiator's HIT) because this HIT Suite is\n  \
    \ obviously supported by the Initiator.  If the Responder selects a\n   different\
    \ HIT that is not supported by the Initiator, the Initiator\n   MAY restart the\
    \ BEX with an I1 packet with a source HIT that is\n   contained in the list of\
    \ the Responder's HIT Suites in the R1 packet.\n   Note that the Initiator cannot\
    \ verify the signature of the R1 packet\n   if the Responder's HIT Suite is not\
    \ supported.  Therefore, the\n   Initiator MUST treat R1 packets with unsupported\
    \ Responder HITs as\n   potentially forged and MUST NOT use any parameters from\
    \ the\n   unverified R1 besides the HIT_SUITE_LIST.  Moreover, an Initiator\n\
    \   that uses an unverified HIT_SUITE_LIST from an R1 packet to determine\n  \
    \ a possible source HIT MUST verify that the HIT_SUITE_LIST in the\n   first unverified\
    \ R1 packet matches the HIT_SUITE_LIST in the second\n   R1 packet for which the\
    \ Initiator supports the signature algorithm.\n   The Initiator MUST restart the\
    \ BEX with a new I1 packet for which the\n   algorithm was mentioned in the verifiable\
    \ R1 if the two lists do not\n   match.  This procedure is necessary to mitigate\
    \ downgrade attacks.\n   There are both security and API issues involved with\
    \ the\n   opportunistic mode.  These issues are described in the remainder of\n\
    \   this section.\n   Given that the Responder's HI is not known by the Initiator,\
    \ there\n   must be suitable API calls that allow the Initiator to request,\n\
    \   directly or indirectly, that the underlying system initiates the HIP\n   base\
    \ exchange solely based on locators.  The Responder's HI will be\n   tentatively\
    \ available in the R1 packet, and in an authenticated form\n   once the R2 packet\
    \ has been received and verified.  Hence, the\n   Responder's HIT could be communicated\
    \ to the application via new API\n   mechanisms.  However, with a backwards-compatible\
    \ API the application\n   sees only the locators used for the initial contact.\
    \  Depending on\n   the desired semantics of the API, this can raise the following\n\
    \   issues:\n   o  The actual locators may later change if an UPDATE message is\
    \ used,\n      even if from the API perspective the association still appears\
    \ to\n      be between two specific locators.  However, the locator update is\n\
    \      still secure, and the association is still between the same nodes.\n  \
    \ o  Different associations between the same two locators may result in\n    \
    \  connections to different nodes, if the implementation no longer\n      remembers\
    \ which identifier the peer had in an earlier association.\n      This is possible\
    \ when the peer's locator has changed for\n      legitimate reasons or when an\
    \ attacker pretends to be a node that\n      has the peer's locator.  Therefore,\
    \ when using opportunistic mode,\n      HIP implementations MUST NOT place any\
    \ expectation that the peer's\n      HI returned in the R1 message matches any\
    \ HI previously seen from\n      that address.\n      If the HIP implementation\
    \ and application do not have the same\n      understanding of what constitutes\
    \ an association, this may even\n      happen within the same association.  For\
    \ instance, an\n      implementation may not know when HIP state can be purged\
    \ for\n      UDP-based applications.\n   In addition, the following security considerations\
    \ apply.  The\n   generation counter mechanism will be less efficient in protecting\n\
    \   against replays of the R1 packet, given that the Responder can choose\n  \
    \ a replay that uses an arbitrary HI, not just the one given in the I1\n   packet.\n\
    \   More importantly, the opportunistic exchange is vulnerable to\n   man-in-the-middle\
    \ attacks, because the Initiator does not have any\n   public key information\
    \ about the peer.  To assess the impacts of this\n   vulnerability, we compare\
    \ it to vulnerabilities in current,\n   non-HIP-capable communications.\n   An\
    \ attacker on the path between the two peers can insert itself as a\n   man-in-the-middle\
    \ by providing its own identifier to the Initiator\n   and then initiating another\
    \ HIP association towards the Responder.\n   For this to be possible, the Initiator\
    \ must employ opportunistic\n   mode, and the Responder must be configured to\
    \ accept a connection\n   from any HIP-enabled node.\n   An attacker outside the\
    \ path will be unable to do so, given that it\n   cannot respond to the messages\
    \ in the base exchange.\n   These security properties are characteristic also\
    \ of communications\n   in the current Internet.  A client contacting a server\
    \ without\n   employing end-to-end security may find itself talking to the server\n\
    \   via a man-in-the-middle, assuming again that the server is willing to\n  \
    \ talk to anyone.\n   If end-to-end security is in place, then the worst that\
    \ can happen in\n   both the opportunistic HIP and non-HIP (normal IP) cases is\
    \ denial-\n   of-service; an entity on the path can disrupt communications, but\n\
    \   will be unable to successfully insert itself as a man-in-the-middle.\n   However,\
    \ once the opportunistic exchange has successfully completed,\n   HIP provides\
    \ confidentiality and integrity protection for the\n   communications, and can\
    \ securely change the locators of the\n   endpoints.\n   As a result, opportunistic\
    \ mode in HIP offers a \"better than nothing\"\n   security model.  Initially,\
    \ a base exchange authenticated in the\n   opportunistic mode involves a leap\
    \ of faith subject to man-in-the-\n   middle attacks, but subsequent datagrams\
    \ related to the same HIP\n   association cannot be compromised by a new man-in-the-middle\
    \ attack.\n   Further, if the man-in-the-middle moves away from the path of the\n\
    \   active association, the attack would be exposed after the fact.\n   Thus,\
    \ it can be stated that opportunistic mode in HIP is at least as\n   secure as\
    \ unprotected IP-based communications.\n"
- title: 4.2.  Updating a HIP Association
  contents:
  - "4.2.  Updating a HIP Association\n   A HIP association between two hosts may\
    \ need to be updated over time.\n   Examples include the need to rekey expiring\
    \ security associations,\n   add new security associations, or change IP addresses\
    \ associated with\n   hosts.  The UPDATE packet is used for those and other similar\n\
    \   purposes.  This document only specifies the UPDATE packet format and\n   basic\
    \ processing rules, with mandatory parameters.  The actual usage\n   is defined\
    \ in separate specifications.\n   HIP provides a general-purpose UPDATE packet,\
    \ which can carry\n   multiple HIP parameters, for updating the HIP state between\
    \ two\n   peers.  The UPDATE mechanism has the following properties:\n      UPDATE\
    \ messages carry a monotonically increasing sequence number\n      and are explicitly\
    \ acknowledged by the peer.  Lost UPDATEs or\n      acknowledgments may be recovered\
    \ via retransmission.  Multiple\n      UPDATE messages may be outstanding under\
    \ certain circumstances.\n      UPDATE is protected by both HIP_MAC and HIP_SIGNATURE\
    \ parameters,\n      since processing UPDATE signatures alone is a potential DoS\
    \ attack\n      against intermediate systems.\n      UPDATE packets are explicitly\
    \ acknowledged by the use of an\n      acknowledgment parameter that echoes an\
    \ individual sequence number\n      received from the peer.  A single UPDATE packet\
    \ may contain both a\n      sequence number and one or more acknowledgment numbers\
    \ (i.e.,\n      piggybacked acknowledgment(s) for the peer's UPDATE).\n   The\
    \ UPDATE packet is defined in Section 5.3.5.\n"
- title: 4.3.  Error Processing
  contents:
  - "4.3.  Error Processing\n   HIP error processing behavior depends on whether or\
    \ not there exists\n   an active HIP association.  In general, if a HIP association\
    \ exists\n   between the sender and receiver of a packet causing an error\n  \
    \ condition, the receiver SHOULD respond with a NOTIFY packet.  On the\n   other\
    \ hand, if there are no existing HIP associations between the\n   sender and receiver,\
    \ or the receiver cannot reasonably determine the\n   identity of the sender,\
    \ the receiver MAY respond with a suitable ICMP\n   message; see Section 5.4 for\
    \ more details.\n   The HIP protocol and state machine are designed to recover\
    \ from one\n   of the parties crashing and losing its state.  The following\n\
    \   scenarios describe the main use cases covered by the design.\n      No prior\
    \ state between the two systems.\n         The system with data to send is the\
    \ Initiator.  The process\n         follows the standard four-packet base exchange,\
    \ establishing\n         the HIP association.\n      The system with data to send\
    \ has no state with the receiver, but\n      the receiver has a residual HIP association.\n\
    \         The system with data to send is the Initiator.  The Initiator\n    \
    \     acts as in no prior state, sending an I1 packet and receiving\n        \
    \ an R1 packet.  When the Responder receives a valid I2 packet,\n         the\
    \ old association is 'discovered' and deleted, and the new\n         association\
    \ is established.\n      The system with data to send has a HIP association, but\
    \ the\n      receiver does not.\n         The system sends data on the outbound\
    \ user data security\n         association.  The receiver 'detects' the situation\
    \ when it\n         receives a user data packet that it cannot match to any HIP\n\
    \         association.  The receiving host MUST discard this packet.\n       \
    \  The receiving host SHOULD send an ICMP packet, with the type\n         Parameter\
    \ Problem, to inform the sender that the HIP\n         association does not exist\
    \ (see Section 5.4), and it MAY\n         initiate a new HIP BEX.  However, responding\
    \ with these\n         optional mechanisms is implementation or policy dependent.\
    \  If\n         the sending application doesn't expect a response, the system\n\
    \         could possibly send a large number of packets in this state, so\n  \
    \       for this reason, the sending of one or more ICMP packets is\n        \
    \ RECOMMENDED.  However, any such responses MUST be rate-limited\n         to\
    \ prevent abuse (see Section 5.4).\n"
- title: 4.4.  HIP State Machine
  contents:
  - "4.4.  HIP State Machine\n   HIP itself has little state.  In the HIP base exchange,\
    \ there is an\n   Initiator and a Responder.  Once the security associations (SAs)\
    \ are\n   established, this distinction is lost.  If the HIP state needs to be\n\
    \   re-established, the controlling parameters are which peer still has\n   state\
    \ and which has a datagram to send to its peer.  The following\n   state machine\
    \ attempts to capture these processes.\n   The state machine is symmetric and\
    \ is presented in a single system\n   view, representing either an Initiator or\
    \ a Responder.  The state\n   machine is not a full representation of the processing\
    \ logic.\n   Additional processing rules are presented in the packet definitions.\n\
    \   Hence, both are needed to completely implement HIP.\n   This document extends\
    \ the state machine as defined in [RFC5201] and\n   introduces a restart option\
    \ to allow for the negotiation of\n   cryptographic algorithms.  The extension\
    \ to the previous state\n   machine in [RFC5201] is a transition from state I1-SENT\
    \ back again to\n   I1-SENT; namely, the restart option.  An Initiator is required\
    \ to\n   restart the HIP base exchange if the Responder does not support the\n\
    \   HIT Suite of the Initiator.  In this case, the Initiator restarts the\n  \
    \ HIP base exchange by sending a new I1 packet with a source HIT\n   supported\
    \ by the Responder.\n   Implementors must understand that the state machine, as\
    \ described\n   here, is informational.  Specific implementations are free to\n\
    \   implement the actual processing logic differently.  Section 6\n   describes\
    \ the packet processing rules in more detail.  This state\n   machine focuses\
    \ on the HIP I1, R1, I2, and R2 packets only.  New\n   states and state transitions\
    \ may be introduced by mechanisms in other\n   specifications (such as mobility\
    \ and multihoming).\n"
- title: 4.4.1.  State Machine Terminology
  contents:
  - "4.4.1.  State Machine Terminology\n   Unused Association Lifetime (UAL):  Implementation-specific\
    \ time for\n      which, if no packet is sent or received for this time interval,\
    \ a\n      host MAY begin to tear down an active HIP association.\n   Maximum\
    \ Segment Lifetime (MSL):  Maximum time that a HIP packet is\n      expected to\
    \ spend in the network.  A default value of 2 minutes\n      has been borrowed\
    \ from [RFC0793] because it is a prevailing\n      assumption for packet lifetimes.\n\
    \   Exchange Complete (EC):  Time that the host spends at the R2-SENT\n      state\
    \ before it moves to the ESTABLISHED state.  The time is n *\n      I2 retransmission\
    \ timeout, where n is about I2_RETRIES_MAX.\n   Receive ANYOTHER:  Any received\
    \ packet for which no state transitions\n      or processing rules are defined\
    \ for a given state.\n"
- title: 4.4.2.  HIP States
  contents:
  - "4.4.2.  HIP States\n   +---------------------+---------------------------------------------+\n\
    \   | State               | Explanation                                 |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ UNASSOCIATED        | State machine start                         |\n   |  \
    \                   |                                             |\n   | I1-SENT\
    \             | Initiating base exchange                    |\n   |          \
    \           |                                             |\n   | I2-SENT    \
    \         | Waiting to complete base exchange           |\n   |              \
    \       |                                             |\n   | R2-SENT        \
    \     | Waiting to complete base exchange           |\n   |                  \
    \   |                                             |\n   | ESTABLISHED        \
    \ | HIP association established                 |\n   |                     |\
    \                                             |\n   | CLOSING             | HIP\
    \ association closing, no data can be     |\n   |                     | sent \
    \                                       |\n   |                     |        \
    \                                     |\n   | CLOSED              | HIP association\
    \ closed, no data can be sent |\n   |                     |                  \
    \                           |\n   | E-FAILED            | HIP base exchange failed\
    \                    |\n   +---------------------+---------------------------------------------+\n\
    \                            Table 1: HIP States\n"
- title: 4.4.3.  HIP State Processes
  contents:
  - "4.4.3.  HIP State Processes\n   System behavior in state UNASSOCIATED, Table\
    \ 2.\n   +----------------------------+--------------------------------------+\n\
    \   | Trigger                    | Action                               |\n  \
    \ +----------------------------+--------------------------------------+\n   |\
    \ User data to send,         | Send I1 and go to I1-SENT            |\n   | requiring\
    \ a new HIP        |                                      |\n   | association\
    \                |                                      |\n   |              \
    \              |                                      |\n   | Receive I1     \
    \            | Send R1 and stay at UNASSOCIATED     |\n   |                  \
    \          |                                      |\n   | Receive I2, process\
    \        | If successful, send R2 and go to     |\n   |                      \
    \      | R2-SENT                              |\n   |                        \
    \    |                                      |\n   |                          \
    \  | If fail, stay at UNASSOCIATED        |\n   |                            |\
    \                                      |\n   | Receive user data for an   | Optionally\
    \ send ICMP as defined in   |\n   | unknown HIP association    | Section 5.4 and\
    \ stay at UNASSOCIATED |\n   |                            |                  \
    \                    |\n   | Receive CLOSE              | Optionally send ICMP\
    \ Parameter       |\n   |                            | Problem and stay at UNASSOCIATED\
    \     |\n   |                            |                                   \
    \   |\n   | Receive ANYOTHER           | Drop and stay at UNASSOCIATED       \
    \ |\n   +----------------------------+--------------------------------------+\n\
    \                    Table 2: UNASSOCIATED - Start State\n   System behavior in\
    \ state I1-SENT, Table 3.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ Receive I1 from     | If the local HIT is smaller than the peer   |\n   | Responder\
    \           | HIT, drop I1 and stay at I1-SENT (see       |\n   |            \
    \         | Section 6.5 for HIT comparison)             |\n   |              \
    \       |                                             |\n   |                \
    \     | If the local HIT is greater than the peer   |\n   |                  \
    \   | HIT, send R1 and stay at I1-SENT            |\n   |                    \
    \ |                                             |\n   | Receive I2, process |\
    \ If successful, send R2 and go to R2-SENT    |\n   |                     |  \
    \                                           |\n   |                     | If fail,\
    \ stay at I1-SENT                    |\n   |                     |           \
    \                                  |\n   | Receive R1, process | If the HIT Suite\
    \ of the local HIT is not    |\n   |                     | supported by the peer,\
    \ select supported     |\n   |                     | local HIT, send I1, and stay\
    \ at I1-SENT     |\n   |                     |                               \
    \              |\n   |                     | If successful, send I2 and go to\
    \ I2-SENT    |\n   |                     |                                   \
    \          |\n   |                     | If fail, stay at I1-SENT            \
    \        |\n   |                     |                                       \
    \      |\n   | Receive ANYOTHER    | Drop and stay at I1-SENT                \
    \    |\n   |                     |                                           \
    \  |\n   | Timeout             | Increment trial counter                     |\n\
    \   |                     |                                             |\n  \
    \ |                     | If counter is less than I1_RETRIES_MAX,     |\n   |\
    \                     | send I1 and stay at I1-SENT                 |\n   |  \
    \                   |                                             |\n   |    \
    \                 | If counter is greater than I1_RETRIES_MAX,  |\n   |      \
    \               | go to E-FAILED                              |\n   +---------------------+---------------------------------------------+\n\
    \            Table 3: I1-SENT - Initiating the HIP Base Exchange\n   System behavior\
    \ in state I2-SENT, Table 4.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ Receive I1          | Send R1 and stay at I2-SENT                 |\n   |  \
    \                   |                                             |\n   | Receive\
    \ R1, process | If successful, send I2 and stay at I2-SENT  |\n   |          \
    \           |                                             |\n   |            \
    \         | If fail, stay at I2-SENT                    |\n   |              \
    \       |                                             |\n   | Receive I2, process\
    \ | If successful and local HIT is smaller than |\n   |                     |\
    \ the peer HIT, drop I2 and stay at I2-SENT   |\n   |                     |  \
    \                                           |\n   |                     | If successful\
    \ and local HIT is greater than |\n   |                     | the peer HIT, send\
    \ R2 and go to R2-SENT     |\n   |                     |                     \
    \                        |\n   |                     | If fail, stay at I2-SENT\
    \                    |\n   |                     |                           \
    \                  |\n   | Receive R2, process | If successful, go to ESTABLISHED\
    \            |\n   |                     |                                   \
    \          |\n   |                     | If fail, stay at I2-SENT            \
    \        |\n   |                     |                                       \
    \      |\n   | Receive CLOSE,      | If successful, send CLOSE_ACK and go to \
    \    |\n   | process             | CLOSED                                    \
    \  |\n   |                     |                                             |\n\
    \   |                     | If fail, stay at I2-SENT                    |\n  \
    \ |                     |                                             |\n   |\
    \ Receive ANYOTHER    | Drop and stay at I2-SENT                    |\n   |  \
    \                   |                                             |\n   | Timeout\
    \             | Increment trial counter                     |\n   |          \
    \           |                                             |\n   |            \
    \         | If counter is less than I2_RETRIES_MAX,     |\n   |              \
    \       | send I2 and stay at I2-SENT                 |\n   |                \
    \     |                                             |\n   |                  \
    \   | If counter is greater than I2_RETRIES_MAX,  |\n   |                    \
    \ | go to E-FAILED                              |\n   +---------------------+---------------------------------------------+\n\
    \        Table 4: I2-SENT - Waiting to Finish the HIP Base Exchange\n   System\
    \ behavior in state R2-SENT, Table 5.\n   +------------------------+------------------------------------------+\n\
    \   | Trigger                | Action                                   |\n  \
    \ +------------------------+------------------------------------------+\n   |\
    \ Receive I1             | Send R1 and stay at R2-SENT              |\n   |  \
    \                      |                                          |\n   | Receive\
    \ I2, process    | If successful, send R2 and stay at       |\n   |          \
    \              | R2-SENT                                  |\n   |            \
    \            |                                          |\n   |              \
    \          | If fail, stay at R2-SENT                 |\n   |                \
    \        |                                          |\n   | Receive R1       \
    \      | Drop and stay at R2-SENT                 |\n   |                    \
    \    |                                          |\n   | Receive R2           \
    \  | Drop and stay at R2-SENT                 |\n   |                        |\
    \                                          |\n   | Receive data or UPDATE | Move\
    \ to ESTABLISHED                      |\n   |                        |       \
    \                                   |\n   | Exchange Complete      | Move to ESTABLISHED\
    \                      |\n   | Timeout                |                      \
    \                    |\n   |                        |                        \
    \                  |\n   | Receive CLOSE, process | If successful, send CLOSE_ACK\
    \ and go to  |\n   |                        | CLOSED                         \
    \          |\n   |                        |                                  \
    \        |\n   |                        | If fail, stay at ESTABLISHED       \
    \      |\n   |                        |                                      \
    \    |\n   | Receive CLOSE_ACK      | Drop and stay at R2-SENT               \
    \  |\n   |                        |                                          |\n\
    \   | Receive NOTIFY         | Process and stay at R2-SENT              |\n  \
    \ +------------------------+------------------------------------------+\n    \
    \             Table 5: R2-SENT - Waiting to Finish HIP\n   System behavior in\
    \ state ESTABLISHED, Table 6.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ Receive I1          | Send R1 and stay at ESTABLISHED             |\n   |  \
    \                   |                                             |\n   | Receive\
    \ I2          | Process with puzzle and possible Opaque     |\n   |          \
    \           | data verification                           |\n   |            \
    \         |                                             |\n   |              \
    \       | If successful, send R2, drop old HIP        |\n   |                \
    \     | association, establish a new HIP            |\n   |                  \
    \   | association, and go to R2-SENT              |\n   |                    \
    \ |                                             |\n   |                     |\
    \ If fail, stay at ESTABLISHED                |\n   |                     |  \
    \                                           |\n   | Receive R1          | Drop\
    \ and stay at ESTABLISHED                |\n   |                     |       \
    \                                      |\n   | Receive R2          | Drop and\
    \ stay at ESTABLISHED                |\n   |                     |           \
    \                                  |\n   | Receive user data   | Process and stay\
    \ at ESTABLISHED             |\n   | for HIP association |                   \
    \                          |\n   |                     |                     \
    \                        |\n   | No packet           | Send CLOSE and go to CLOSING\
    \                |\n   | sent/received       |                               \
    \              |\n   | during UAL minutes  |                                 \
    \            |\n   |                     |                                   \
    \          |\n   | Receive UPDATE      | Process and stay at ESTABLISHED     \
    \        |\n   |                     |                                       \
    \      |\n   | Receive CLOSE,      | If successful, send CLOSE_ACK and go to \
    \    |\n   | process             | CLOSED                                    \
    \  |\n   |                     |                                             |\n\
    \   |                     | If fail, stay at ESTABLISHED                |\n  \
    \ |                     |                                             |\n   |\
    \ Receive CLOSE_ACK   | Drop and stay at ESTABLISHED                |\n   |  \
    \                   |                                             |\n   | Receive\
    \ NOTIFY      | Process and stay at ESTABLISHED             |\n   +---------------------+---------------------------------------------+\n\
    \            Table 6: ESTABLISHED - HIP Association Established\n   System behavior\
    \ in state CLOSING, Table 7.\n   +----------------------------+--------------------------------------+\n\
    \   | Trigger                    | Action                               |\n  \
    \ +----------------------------+--------------------------------------+\n   |\
    \ User data to send,         | Send I1 and go to I1-SENT            |\n   | requires\
    \ the creation of   |                                      |\n   | another incarnation\
    \ of the |                                      |\n   | HIP association      \
    \      |                                      |\n   |                        \
    \    |                                      |\n   | Receive I1               \
    \  | Send R1 and stay at CLOSING          |\n   |                            |\
    \                                      |\n   | Receive I2, process        | If\
    \ successful, send R2 and go to     |\n   |                            | R2-SENT\
    \                              |\n   |                            |          \
    \                            |\n   |                            | If fail, stay\
    \ at CLOSING             |\n   |                            |                \
    \                      |\n   | Receive R1, process        | If successful, send\
    \ I2 and go to     |\n   |                            | I2-SENT              \
    \                |\n   |                            |                        \
    \              |\n   |                            | If fail, stay at CLOSING \
    \            |\n   |                            |                            \
    \          |\n   | Receive CLOSE, process     | If successful, send CLOSE_ACK,\
    \       |\n   |                            | discard state, and go to CLOSED \
    \     |\n   |                            |                                   \
    \   |\n   |                            | If fail, stay at CLOSING            \
    \ |\n   |                            |                                      |\n\
    \   | Receive CLOSE_ACK, process | If successful, discard state and go  |\n  \
    \ |                            | to UNASSOCIATED                      |\n   |\
    \                            |                                      |\n   |  \
    \                          | If fail, stay at CLOSING             |\n   |    \
    \                        |                                      |\n   | Receive\
    \ ANYOTHER           | Drop and stay at CLOSING             |\n   |          \
    \                  |                                      |\n   | Timeout    \
    \                | Increment timeout sum and reset      |\n   |              \
    \              | timer.  If timeout sum is less than  |\n   |                \
    \            | UAL+MSL minutes, retransmit CLOSE    |\n   |                  \
    \          | and stay at CLOSING.                 |\n   |                    \
    \        |                                      |\n   |                      \
    \      | If timeout sum is greater than       |\n   |                        \
    \    | UAL+MSL minutes, go to UNASSOCIATED  |\n   +----------------------------+--------------------------------------+\n\
    \   Table 7: CLOSING - HIP Association Has Not Been Used for UAL Minutes\n   System\
    \ behavior in state CLOSED, Table 8.\n   +----------------------------------------+--------------------------+\n\
    \   | Trigger                                | Action                   |\n  \
    \ +----------------------------------------+--------------------------+\n   |\
    \ Datagram to send, requires the         | Send I1 and stay at      |\n   | creation\
    \ of another incarnation of the | CLOSED                   |\n   | HIP association\
    \                        |                          |\n   |                  \
    \                      |                          |\n   | Receive I1         \
    \                    | Send R1 and stay at      |\n   |                      \
    \                  | CLOSED                   |\n   |                        \
    \                |                          |\n   | Receive I2, process      \
    \              | If successful, send R2   |\n   |                            \
    \            | and go to R2-SENT        |\n   |                              \
    \          |                          |\n   |                                \
    \        | If fail, stay at CLOSED  |\n   |                                  \
    \      |                          |\n   | Receive R1, process                \
    \    | If successful, send I2   |\n   |                                      \
    \  | and go to I2-SENT        |\n   |                                        |\
    \                          |\n   |                                        | If\
    \ fail, stay at CLOSED  |\n   |                                        |     \
    \                     |\n   | Receive CLOSE, process                 | If successful,\
    \ send      |\n   |                                        | CLOSE_ACK and stay\
    \ at    |\n   |                                        | CLOSED              \
    \     |\n   |                                        |                       \
    \   |\n   |                                        | If fail, stay at CLOSED \
    \ |\n   |                                        |                          |\n\
    \   | Receive CLOSE_ACK, process             | If successful, discard   |\n  \
    \ |                                        | state and go to          |\n   |\
    \                                        | UNASSOCIATED             |\n   |  \
    \                                      |                          |\n   |    \
    \                                    | If fail, stay at CLOSED  |\n   |      \
    \                                  |                          |\n   | Receive\
    \ ANYOTHER                       | Drop and stay at CLOSED  |\n   |          \
    \                              |                          |\n   | Timeout (UAL+2MSL)\
    \                     | Discard state and go to  |\n   |                     \
    \                   | UNASSOCIATED             |\n   +----------------------------------------+--------------------------+\n\
    \    Table 8: CLOSED - CLOSE_ACK Sent, Resending CLOSE_ACK if Necessary\n   System\
    \ behavior in state E-FAILED, Table 9.\n   +-------------------------+-----------------------------------------+\n\
    \   | Trigger                 | Action                                  |\n  \
    \ +-------------------------+-----------------------------------------+\n   |\
    \ Wait for                | Go to UNASSOCIATED.  Renegotiation is   |\n   | implementation-specific\
    \ | possible after moving to UNASSOCIATED   |\n   | time                    |\
    \ state.                                  |\n   +-------------------------+-----------------------------------------+\n\
    \     Table 9: E-FAILED - HIP Failed to Establish Association with Peer\n"
- title: 4.4.4.  Simplified HIP State Diagram
  contents:
  - "4.4.4.  Simplified HIP State Diagram\n   The following diagram (Figure 2) shows\
    \ the major state transitions.\n   Transitions based on received packets implicitly\
    \ assume that the\n   packets are successfully authenticated or processed.\n \
    \                              +--+       +----------------------------+\n   \
    \           recv I1, send R1 |  |       |                            |\n     \
    \                          |  v       v                            |\n       \
    \                      +--------------+  recv I2, send R2        |\n         \
    \   +----------------| UNASSOCIATED |----------------+         |\n   datagram\
    \ |  +--+          +--------------+                |         |\n   to send, |\
    \  |  | Alg. not supported,                      |         |\n    send I1 |  |\
    \  | send I1                                  |         |\n     .      v  |  v\
    \                                          |         |\n     .   +---------+ \
    \ recv I2, send R2                       |         |\n   +---->| I1-SENT |--------------------------------------+\
    \  |         |\n   |     +---------+            +----------------------+  |  |\
    \         |\n   |          | recv R2,        | recv I2, send R2     |  |  |  \
    \       |\n   |          v send I2         |                      v  v  v    \
    \     |\n   |       +---------+          |                    +---------+    \
    \   |\n   |  +--->| I2-SENT |----------+     +--------------| R2-SENT |<---+ \
    \ |\n   |  |    +---------+                |              +---------+    |  |\n\
    \   |  |          |  |recv R2          |        data or|             |  |\n  \
    \ |  |recv R1,  |  |                 |     EC timeout|             |  |\n   |\
    \  |send I2   +--|-----------------+               |  receive I2,|  |\n   |  |\
    \          |  |       +-------------+           |      send R2|  |\n   |  |  \
    \        |  +------>| ESTABLISHED |<----------+             |  |\n   |  |    \
    \      |          +-------------+                         |  |\n   |  |      \
    \    |            |  |  |      receive I2, send R2      |  |\n   |  |        \
    \  +------------+  |  +-------------------------------+  |\n   |  |          |\
    \               +-----------+                      |  |\n   |  |          |  \
    \  no packet sent/received|    +---+             |  |\n   |  |          |    for\
    \ UAL min, send CLOSE|    |   |timeout      |  |\n   |  |          |         \
    \                  v    v   |(UAL+MSL)    |  |\n   |  |          |           \
    \             +---------+ |retransmit   |  |\n   +--|----------|------------------------|\
    \ CLOSING |-+CLOSE        |  |\n      |          |                        +---------+\
    \               |  |\n      |          |                         | |   | |   \
    \             |  |\n      +----------|-------------------------+ |   | +----------------+\
    \  |\n      |          |               +-----------+   +------------------|--+\n\
    \      |          |               |recv CLOSE,      recv CLOSE_ACK   |  |\n  \
    \    |          +-------------+ |send CLOSE_ACK   or timeout       |  |\n    \
    \  |     recv CLOSE,        | |                 (UAL+MSL)        |  |\n      |\
    \     send CLOSE_ACK     v v                                  |  |\n      |  \
    \                   +--------+  receive I2, send R2         |  |\n      +---------------------|\
    \ CLOSED |------------------------------+  |\n                            +--------+\
    \                                 |\n                             ^ |  |     \
    \                               |\n   recv CLOSE, send CLOSE_ACK| |  |       \
    \       timeout (UAL+2MSL)    |\n                             +-+  +------------------------------------+\n\
    \                                 Figure 2\n"
- title: 4.5.  User Data Considerations
  contents:
  - '4.5.  User Data Considerations

    '
- title: 4.5.1.  TCP and UDP Pseudo Header Computation for User Data
  contents:
  - "4.5.1.  TCP and UDP Pseudo Header Computation for User Data\n   When computing\
    \ TCP and UDP checksums on user data packets that flow\n   through sockets bound\
    \ to HITs, the IPv6 pseudo header format\n   [RFC2460] MUST be used, even if the\
    \ actual addresses in the header of\n   the packet are IPv4 addresses.  Additionally,\
    \ the HITs MUST be used\n   in place of the IPv6 addresses in the IPv6 pseudo\
    \ header.  Note that\n   the pseudo header for actual HIP payloads is computed\
    \ differently;\n   see Section 5.1.1.\n"
- title: 4.5.2.  Sending Data on HIP Packets
  contents:
  - "4.5.2.  Sending Data on HIP Packets\n   Other documents may define how to include\
    \ user data in various HIP\n   packets.  However, currently the HIP header is\
    \ a terminal header, and\n   not followed by any other headers.\n"
- title: 4.5.3.  Transport Formats
  contents:
  - "4.5.3.  Transport Formats\n   The actual data transmission format, used for user\
    \ data after the HIP\n   base exchange, is not defined in this document.  Such\
    \ transport\n   formats and methods are described in separate specifications.\
    \  All\n   HIP implementations MUST implement, at minimum, the ESP transport\n\
    \   format for HIP [RFC7402].  The transport format to be chosen is\n   negotiated\
    \ in the base exchange.  The Responder expresses its\n   preference regarding\
    \ the transport format in the\n   TRANSPORT_FORMAT_LIST in the R1 packet, and\
    \ the Initiator selects one\n   transport format and adds the respective HIP parameter\
    \ to the I2\n   packet.\n"
- title: 4.5.4.  Reboot, Timeout, and Restart of HIP
  contents:
  - "4.5.4.  Reboot, Timeout, and Restart of HIP\n   Simulating a loss of state is\
    \ a potential DoS attack.  The following\n   process has been crafted to manage\
    \ state recovery without presenting\n   a DoS opportunity.\n   If a host reboots\
    \ or the HIP association times out, it has lost its\n   HIP state.  If the host\
    \ that lost state has a datagram to send to the\n   peer, it simply restarts the\
    \ HIP base exchange.  After the base\n   exchange has completed, the Initiator\
    \ can create a new payload\n   association and start sending data.  The peer does\
    \ not reset its\n   state until it receives a valid I2 packet.\n   If a system\
    \ receives a user data packet that cannot be matched to any\n   existing HIP association,\
    \ it is possible that it has lost the state\n   and its peer has not.  It MAY\
    \ send an ICMP packet with the Parameter\n   Problem type, and with the Pointer\
    \ pointing to the referred\n   HIP-related association information.  Reacting\
    \ to such traffic\n   depends on the implementation and the environment where\
    \ the\n   implementation is used.\n   If the host that apparently has lost its\
    \ state decides to restart the\n   HIP base exchange, it sends an I1 packet to\
    \ the peer.  After the base\n   exchange has been completed successfully, the\
    \ Initiator can create a\n   new HIP association, and the peer drops its old payload\
    \ associations\n   and creates a new one.\n"
- title: 4.6.  Certificate Distribution
  contents:
  - "4.6.  Certificate Distribution\n   This document does not define how to use certificates\
    \ or how to\n   transfer them between hosts.  These functions are expected to\
    \ be\n   defined in a future specification, as was done for HIP version 1 (see\n\
    \   [RFC6253]).  A parameter type value, meant to be used for carrying\n   certificates,\
    \ is reserved, though: CERT, Type 768; see Section 5.2.\n"
- title: 5.  Packet Formats
  contents:
  - '5.  Packet Formats

    '
- title: 5.1.  Payload Format
  contents:
  - "5.1.  Payload Format\n   All HIP packets start with a fixed header.\n    0  \
    \                 1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Header   | Header Length |0| Packet Type |Version| RES.|1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Checksum             |           Controls            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Sender's Host Identity Tag (HIT)               |\n   |  \
    \                                                             |\n   |        \
    \                                                       |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Receiver's Host Identity Tag (HIT)              |\n   |  \
    \                                                             |\n   |        \
    \                                                       |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                      HIP Parameters                         /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The HIP header is logically an IPv6 extension header.  However, this\n   document\
    \ does not describe processing for Next Header values other\n   than decimal 59,\
    \ IPPROTO_NONE, the IPv6 'no next header' value.\n   Future documents MAY define\
    \ behavior for other values.  However,\n   current implementations MUST ignore\
    \ trailing data if an unimplemented\n   Next Header value is received.\n   The\
    \ Header Length field contains the combined length of the HIP\n   Header and HIP\
    \ parameters in 8-byte units, excluding the first\n   8 bytes.  Since all HIP\
    \ headers MUST contain the sender's and\n   receiver's HIT fields, the minimum\
    \ value for this field is 4, and\n   conversely, the maximum length of the HIP\
    \ Parameters field is\n   (255 * 8) - 32 = 2008 bytes (see Section 5.1.3 regarding\
    \ HIP\n   fragmentation).  Note: this sets an additional limit for sizes of\n\
    \   parameters included in the Parameters field, independent of the\n   individual\
    \ parameter maximum lengths.\n   The Packet Type indicates the HIP packet type.\
    \  The individual packet\n   types are defined in the relevant sections.  If a\
    \ HIP host receives a\n   HIP packet that contains an unrecognized packet type,\
    \ it MUST drop\n   the packet.\n   The HIP Version field is four bits.  The version\
    \ defined in this\n   document is 2.  The version number is expected to be incremented\
    \ only\n   if there are incompatible changes to the protocol.  Most extensions\n\
    \   can be handled by defining new packet types, new parameter types, or\n   new\
    \ Controls (see Section 5.1.2).\n   The following three bits are reserved for\
    \ future use.  They MUST be\n   zero when sent, and they MUST be ignored when\
    \ handling a received\n   packet.\n   The two fixed bits in the header are reserved\
    \ for SHIM6 compatibility\n   [RFC5533], Section 5.3.  For implementations adhering\
    \ (only) to this\n   specification, they MUST be set as shown when sending and\
    \ MUST be\n   ignored when receiving.  This is to ensure optimal forward\n   compatibility.\
    \  Note that for implementations that implement other\n   compatible specifications\
    \ in addition to this specification, the\n   corresponding rules may well be different.\
    \  For example, an\n   implementation that implements both this specification\
    \ and the SHIM6\n   protocol may need to check these bits in order to determine\
    \ how to\n   handle the packet.\n   The HIT fields are always 128 bits (16 bytes)\
    \ long.\n"
- title: 5.1.1.  Checksum
  contents:
  - "5.1.1.  Checksum\n   Since the checksum covers the source and destination addresses\
    \ in the\n   IP header, it MUST be recomputed on HIP-aware NAT devices.\n   If\
    \ IPv6 is used to carry the HIP packet, the pseudo header [RFC2460]\n   contains\
    \ the source and destination IPv6 addresses, HIP packet length\n   in the pseudo\
    \ header Length field, a zero field, and the HIP protocol\n   number (see Section\
    \ 5.1) in the Next Header field.  The Length field\n   is in bytes and can be\
    \ calculated from the HIP Header Length field:\n   (HIP Header Length + 1) * 8.\n\
    \   In case of using IPv4, the IPv4 UDP pseudo header format [RFC0768] is\n  \
    \ used.  In the pseudo header, the source and destination addresses are\n   those\
    \ used in the IP header, the zero field is obviously zero, the\n   protocol is\
    \ the HIP protocol number (see Section 4), and the length\n   is calculated as\
    \ in the IPv6 case.\n"
- title: 5.1.2.  HIP Controls
  contents:
  - "5.1.2.  HIP Controls\n   The HIP Controls field conveys information about the\
    \ structure of the\n   packet and capabilities of the host.\n   The following\
    \ fields have been defined:\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | |\
    \ | | | | | | | | | | | | | |A|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   A\
    \ - Anonymous:  If this is set, the sender's HI in this packet is\n      anonymous,\
    \ i.e., one not listed in a directory.  Anonymous HIs\n      SHOULD NOT be stored.\
    \  This control is set in packets using\n      anonymous sender HIs.  The peer\
    \ receiving an anonymous HI in an R1\n      or I2 may choose to refuse it.\n \
    \  The rest of the fields are reserved for future use, and MUST be set\n   to\
    \ zero in sent packets and MUST be ignored in received packets.\n"
- title: 5.1.3.  HIP Fragmentation Support
  contents:
  - "5.1.3.  HIP Fragmentation Support\n   A HIP implementation MUST support IP fragmentation/reassembly.\n\
    \   Fragment reassembly MUST be implemented in both IPv4 and IPv6, but\n   fragment\
    \ generation is REQUIRED to be implemented in IPv4 (IPv4\n   stacks and networks\
    \ will usually do this by default) and RECOMMENDED\n   to be implemented in IPv6.\
    \  In IPv6 networks, the minimum MTU is\n   larger, 1280 bytes, than in IPv4 networks.\
    \  The larger MTU size is\n   usually sufficient for most HIP packets, and therefore\
    \ fragment\n   generation may not be needed.  If it is expected that a host will\n\
    \   send HIP packets that are larger than the minimum IPv6 MTU, the\n   implementation\
    \ MUST implement fragment generation even for IPv6.\n   In IPv4 networks, HIP\
    \ packets may encounter low MTUs along their\n   routed path.  Since basic HIP,\
    \ as defined in this document, does not\n   provide a mechanism to use multiple\
    \ IP datagrams for a single HIP\n   packet, support for path MTU discovery does\
    \ not bring any value to\n   HIP in IPv4 networks.  HIP-aware NAT devices SHOULD\
    \ perform IPv4\n   reassembly/fragmentation for HIP packets.\n   All HIP implementations\
    \ have to be careful while employing a\n   reassembly algorithm so that the algorithm\
    \ is sufficiently resistant\n   to DoS attacks.\n   Certificate chains can cause\
    \ the packet to be fragmented, and\n   fragmentation can open implementations\
    \ to denial-of-service attacks\n   [KAU03].  \"Hash and URL\" schemes as defined\
    \ in [RFC6253] for HIP\n   version 1 may be used to avoid fragmentation and mitigate\
    \ resulting\n   DoS attacks.\n"
- title: 5.2.  HIP Parameters
  contents:
  - "5.2.  HIP Parameters\n   The HIP parameters carry information that is necessary\
    \ for\n   establishing and maintaining a HIP association.  For example, the\n\
    \   peer's public keys as well as the signaling for negotiating ciphers\n   and\
    \ payload handling are encapsulated in HIP parameters.  Additional\n   information,\
    \ meaningful for end hosts or middleboxes, may also be\n   included in HIP parameters.\
    \  The specification of the HIP parameters\n   and their mapping to HIP packets\
    \ and packet types is flexible to\n   allow HIP extensions to define new parameters\
    \ and new protocol\n   behavior.\n   In HIP packets, HIP parameters are ordered\
    \ according to their numeric\n   type number and encoded in TLV format.\n   The\
    \ following parameter types are currently defined.\n   +------------------------+-------+-----------+----------------------+\n\
    \   | TLV                    | Type  | Length    | Data                 |\n  \
    \ +------------------------+-------+-----------+----------------------+\n   |\
    \ R1_COUNTER             | 129   | 12        | Puzzle generation    |\n   |  \
    \                      |       |           | counter              |\n   |    \
    \                    |       |           |                      |\n   | PUZZLE\
    \                 | 257   | 12        | #K and Random #I     |\n   |         \
    \               |       |           |                      |\n   | SOLUTION  \
    \             | 321   | 20        | #K, Random #I and    |\n   |             \
    \           |       |           | puzzle solution #J   |\n   |               \
    \         |       |           |                      |\n   | SEQ             \
    \       | 385   | 4         | UPDATE packet ID     |\n   |                   \
    \     |       |           | number               |\n   |                     \
    \   |       |           |                      |\n   | ACK                   \
    \ | 449   | variable  | UPDATE packet ID     |\n   |                        |\
    \       |           | number               |\n   |                        |  \
    \     |           |                      |\n   | DH_GROUP_LIST          | 511\
    \   | variable  | Ordered list of DH   |\n   |                        |      \
    \ |           | Group IDs supported  |\n   |                        |       |\
    \           | by a host            |\n   |                        |       |  \
    \         |                      |\n   | DIFFIE_HELLMAN         | 513   | variable\
    \  | public key           |\n   |                        |       |           |\
    \                      |\n   | HIP_CIPHER             | 579   | variable  | List\
    \ of HIP          |\n   |                        |       |           | encryption\
    \           |\n   |                        |       |           | algorithms  \
    \         |\n   |                        |       |           |               \
    \       |\n   | ENCRYPTED              | 641   | variable  | Encrypted part of\
    \ a  |\n   |                        |       |           | HIP packet         \
    \  |\n   |                        |       |           |                      |\n\
    \   | HOST_ID                | 705   | variable  | Host Identity with   |\n  \
    \ |                        |       |           | Fully Qualified      |\n   |\
    \                        |       |           | Domain Name (FQDN)   |\n   |  \
    \                      |       |           | or Network Access    |\n   |    \
    \                    |       |           | Identifier (NAI)     |\n   |      \
    \                  |       |           |                      |\n   | HIT_SUITE_LIST\
    \         | 715   | variable  | Ordered list of the  |\n   |                 \
    \       |       |           | HIT Suites supported |\n   |                   \
    \     |       |           | by the Responder     |\n   |                     \
    \   |       |           |                      |\n   | CERT                  \
    \ | 768   | variable  | HI Certificate; used |\n   |                        |\
    \       |           | to transfer          |\n   |                        |  \
    \     |           | certificates.        |\n   |                        |    \
    \   |           | Specified in a       |\n   |                        |      \
    \ |           | separate document.   |\n   |                        |       |\
    \           |                      |\n   | NOTIFICATION           | 832   | variable\
    \  | Informational data   |\n   |                        |       |           |\
    \                      |\n   | ECHO_REQUEST_SIGNED    | 897   | variable  | Opaque\
    \ data to be    |\n   |                        |       |           | echoed back;\
    \ signed  |\n   |                        |       |           |               \
    \       |\n   | ECHO_RESPONSE_SIGNED   | 961   | variable  | Opaque data echoed\
    \   |\n   |                        |       |           | back by request;    \
    \ |\n   |                        |       |           | signed               |\n\
    \   |                        |       |           |                      |\n  \
    \ | TRANSPORT_FORMAT_LIST  | 2049  | Ordered   | variable             |\n   |\
    \                        |       | list of   |                      |\n   |  \
    \                      |       | preferred |                      |\n   |    \
    \                    |       | HIP       |                      |\n   |      \
    \                  |       | transport |                      |\n   |        \
    \                |       | type      |                      |\n   |          \
    \              |       | numbers   |                      |\n   |            \
    \            |       |           |                      |\n   | HIP_MAC      \
    \          | 61505 | variable  | HMAC-based message   |\n   |                \
    \        |       |           | authentication code, |\n   |                  \
    \      |       |           | with key material    |\n   |                    \
    \    |       |           | from KEYMAT          |\n   |                      \
    \  |       |           |                      |\n   | HIP_MAC_2              |\
    \ 61569 | variable  | HMAC-based message   |\n   |                        |  \
    \     |           | authentication code, |\n   |                        |    \
    \   |           | with key material    |\n   |                        |      \
    \ |           | from KEYMAT.  Unlike |\n   |                        |       |\
    \           | HIP_MAC, the HOST_ID |\n   |                        |       |  \
    \         | parameter is         |\n   |                        |       |    \
    \       | included in          |\n   |                        |       |      \
    \     | HIP_MAC_2            |\n   |                        |       |        \
    \   | calculation.         |\n   |                        |       |          \
    \ |                      |\n   | HIP_SIGNATURE_2        | 61633 | variable  |\
    \ Signature used in R1 |\n   |                        |       |           | packet\
    \               |\n   |                        |       |           |         \
    \             |\n   | HIP_SIGNATURE          | 61697 | variable  | Signature of\
    \ the     |\n   |                        |       |           | packet        \
    \       |\n   |                        |       |           |                 \
    \     |\n   | ECHO_REQUEST_UNSIGNED  | 63661 | variable  | Opaque data to be \
    \   |\n   |                        |       |           | echoed back; after  \
    \ |\n   |                        |       |           | signature            |\n\
    \   |                        |       |           |                      |\n  \
    \ | ECHO_RESPONSE_UNSIGNED | 63425 | variable  | Opaque data echoed   |\n   |\
    \                        |       |           | back by request;     |\n   |  \
    \                      |       |           | after signature      |\n   +------------------------+-------+-----------+----------------------+\n\
    \   As the ordering (from lowest to highest) of HIP parameters is\n   strictly\
    \ enforced (see Section 5.2.1), the parameter type values for\n   existing parameters\
    \ have been spaced to allow for future protocol\n   extensions.\n   The following\
    \ parameter type number ranges are defined.\n   +---------------+---------------------------------------------------+\n\
    \   | Type Range    | Purpose                                           |\n  \
    \ +---------------+---------------------------------------------------+\n   |\
    \ 0 -  1023     | Handshake                                         |\n   |  \
    \             |                                                   |\n   | 1024\
    \ -   2047 | Reserved                                          |\n   |       \
    \        |                                                   |\n   | 2048 -  \
    \ 4095 | Parameters related to HIP transport formats       |\n   |           \
    \    |                                                   |\n   | 4096 -   8191\
    \ | Signed parameters allocated through specification |\n   |               |\
    \ documents                                         |\n   |               |  \
    \                                                 |\n   | 8192 -  32767 | Reserved\
    \                                          |\n   |               |           \
    \                                        |\n   | 32768 - 49151 | Reserved for\
    \ Private Use.  Signed parameters.     |\n   |               |               \
    \                                    |\n   | 49152 - 61439 | Reserved        \
    \                                  |\n   |               |                   \
    \                                |\n   | 61440 - 62463 | Signatures and (signed)\
    \ MACs                      |\n   |               |                          \
    \                         |\n   | 62464 - 63487 | Parameters that are neither\
    \ signed nor MACed      |\n   |               |                              \
    \                     |\n   | 63488 - 64511 | Rendezvous and relaying        \
    \                   |\n   |               |                                  \
    \                 |\n   | 64512 - 65023 | Parameters that are neither signed nor\
    \ MACed      |\n   |               |                                         \
    \          |\n   | 65024 - 65535 | Reserved                                  \
    \        |\n   +---------------+---------------------------------------------------+\n\
    \   The process for defining new parameters is described in Section 5.2.2\n  \
    \ of this document.\n   The range between 32768 (2^15) and 49151 (2^15 + 2^14)\
    \ is Reserved\n   for Private Use.  Types from this range SHOULD be selected in\
    \ a\n   random fashion to reduce the probability of collisions.\n"
- title: 5.2.1.  TLV Format
  contents:
  - "5.2.1.  TLV Format\n   The TLV-encoded parameters are described in the following\n\
    \   subsections.  The Type field value also describes the order of these\n   fields\
    \ in the packet.  The parameters MUST be included in the packet\n   so that their\
    \ types form an increasing order.  If multiple parameters\n   with the same type\
    \ number are in one packet, the parameters with the\n   same type MUST be consecutive\
    \ in the packet.  If the order does not\n   follow this rule, the packet is considered\
    \ to be malformed and it\n   MUST be discarded.\n   Parameters using type values\
    \ from 2048 up to 4095 are related to\n   transport formats.  Currently, one transport\
    \ format is defined: the\n   ESP transport format [RFC7402].\n   All of the encoded\
    \ TLV parameters have a length (that includes the\n   Type and Length fields),\
    \ which is a multiple of 8 bytes.  When\n   needed, padding MUST be added to the\
    \ end of the parameter so that the\n   total length is a multiple of 8 bytes.\
    \  This rule ensures proper\n   alignment of data.  Any added padding bytes MUST\
    \ be zeroed by the\n   sender, and their values SHOULD NOT be checked by the receiver.\n\
    \   The Length field indicates the length of the Contents field (in\n   bytes).\
    \  Consequently, the total length of the TLV parameter\n   (including Type, Length,\
    \ Contents, and Padding) is related to the\n   Length field according to the following\
    \ formula:\n   Total Length = 11 + Length - (Length + 3) % 8;\n   where % is the\
    \ modulo operator.\n      0                   1                   2          \
    \         3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type            |C|             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     /      \
    \                    Contents                             /\n     /          \
    \                                     +-+-+-+-+-+-+-+-+\n     |              \
    \                                 |    Padding    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type         Type code for the parameter.  16 bits long, C-bit\n       \
    \           being part of the Type code.\n     C            Critical.  One if\
    \ this parameter is critical and\n                  MUST be recognized by the\
    \ recipient, zero otherwise.\n                  The C-bit is considered to be\
    \ a part of the Type\n                  field.  Consequently, critical parameters\
    \ are always\n                  odd, and non-critical ones have an even value.\n\
    \     Length       Length of the Contents, in bytes, excluding Type,\n       \
    \           Length, and Padding\n     Contents     Parameter specific, defined\
    \ by Type\n     Padding      Padding, 0-7 bytes, added if needed\n   Critical\
    \ parameters (indicated by the odd type number value) MUST be\n   recognized by\
    \ the recipient.  If a recipient encounters a critical\n   parameter that it does\
    \ not recognize, it MUST NOT process the packet\n   any further.  It MAY send\
    \ an ICMP or NOTIFY, as defined in\n   Section 4.3.\n   Non-critical parameters\
    \ MAY be safely ignored.  If a recipient\n   encounters a non-critical parameter\
    \ that it does not recognize, it\n   SHOULD proceed as if the parameter was not\
    \ present in the received\n   packet.\n"
- title: 5.2.2.  Defining New Parameters
  contents:
  - "5.2.2.  Defining New Parameters\n   Future specifications may define new parameters\
    \ as needed.  When\n   defining new parameters, care must be taken to ensure that\
    \ the\n   parameter type values are appropriate and leave suitable space for\n\
    \   other future extensions.  One must remember that the parameters MUST\n   always\
    \ be arranged in numerically increasing order by Type code,\n   thereby limiting\
    \ the order of parameters (see Section 5.2.1).\n   The following rules MUST be\
    \ followed when defining new parameters.\n   1.  The low-order bit C of the Type\
    \ code is used to distinguish\n       between critical and non-critical parameters.\
    \  Hence, even\n       parameter type numbers indicate non-critical parameters\
    \ while odd\n       parameter type numbers indicate critical parameters.\n   2.\
    \  A new parameter MAY be critical only if an old implementation\n       that\
    \ ignored it would cause security problems.  In general, new\n       parameters\
    \ SHOULD be defined as non-critical, and expect a reply\n       from the recipient.\n\
    \   3.  If a system implements a new critical parameter, it MUST provide\n   \
    \    the ability to set the associated feature off, such that the\n       critical\
    \ parameter is not sent at all.  The configuration option\n       MUST be well\
    \ documented.  Implementations operating in a mode\n       adhering to this specification\
    \ MUST disable the sending of new\n       critical parameters by default.  In\
    \ other words, the management\n       interface MUST allow vanilla standards-only\
    \ mode as a default\n       configuration setting, and MAY allow new critical\
    \ payloads to be\n       configured on (and off).\n   4.  See Section 9 for allocation\
    \ rules regarding Type codes.\n"
- title: 5.2.3.  R1_COUNTER
  contents:
  - "5.2.3.  R1_COUNTER\n      0                   1                   2         \
    \          3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                     Reserved, 4 bytes                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                R1 generation counter, 8 bytes                 |\n    \
    \ |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type           129\n     Length         12\n     R1 generation\n       counter\
    \      The current generation of valid puzzles\n   The R1_COUNTER parameter contains\
    \ a 64-bit unsigned integer in\n   network byte order, indicating the current\
    \ generation of valid\n   puzzles.  The sender SHOULD increment this counter periodically.\
    \  It\n   is RECOMMENDED that the counter value is incremented at least as\n \
    \  often as old PUZZLE values are deprecated so that SOLUTIONs to them\n   are\
    \ no longer accepted.\n   Support for the R1_COUNTER parameter is mandatory, although\
    \ its\n   inclusion in the R1 packet is optional.  It SHOULD be included in the\n\
    \   R1 (in which case it is covered by the signature), and if present in\n   the\
    \ R1, it MUST be echoed (including the Reserved field verbatim) by\n   the Initiator\
    \ in the I2 packet.\n"
- title: 5.2.4.  PUZZLE
  contents:
  - "5.2.4.  PUZZLE\n      0                   1                   2             \
    \      3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  #K,\
    \ 1 byte   |    Lifetime   |        Opaque, 2 bytes        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                      Random #I, RHASH_len / 8 bytes           |\n    \
    \ /                                                               /\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type           257\n     Length         4 + RHASH_len / 8\n     #K     \
    \        #K is the number of verified bits\n     Lifetime       puzzle lifetime\
    \ 2^(value - 32) seconds\n     Opaque         data set by the Responder, indexing\
    \ the puzzle\n     Random #I      random number of size RHASH_len bits\n   Random\
    \ #I is represented as an n-bit integer (where n is RHASH_len),\n   and #K and\
    \ Lifetime as 8-bit integers, all in network byte order.\n   The PUZZLE parameter\
    \ contains the puzzle difficulty #K and an n-bit\n   random integer #I.  The Puzzle\
    \ Lifetime indicates the time during\n   which the puzzle solution is valid, and\
    \ sets a time limit that should\n   not be exceeded by the Initiator while it\
    \ attempts to solve the\n   puzzle.  The lifetime is indicated as a power of 2\
    \ using the formula\n   2^(Lifetime - 32) seconds.  A puzzle MAY be augmented\
    \ with an\n   ECHO_REQUEST_SIGNED or an ECHO_REQUEST_UNSIGNED parameter included\
    \ in\n   the R1; the contents of the echo request are then echoed back in the\n\
    \   ECHO_RESPONSE_SIGNED or in the ECHO_RESPONSE_UNSIGNED parameter,\n   allowing\
    \ the Responder to use the included information as a part of\n   its puzzle processing.\n\
    \   The Opaque and Random #I fields are not covered by the\n   HIP_SIGNATURE_2\
    \ parameter.\n"
- title: 5.2.5.  SOLUTION
  contents:
  - "5.2.5.  SOLUTION\n      0                   1                   2           \
    \        3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  #K,\
    \ 1 byte   |   Reserved    |        Opaque, 2 bytes        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                      Random #I, n bytes                       |\n    \
    \ /                                                               /\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |            Puzzle solution #J, RHASH_len / 8 bytes            |\n    \
    \ /                                                               /\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type                321\n     Length              4 + RHASH_len / 4\n  \
    \   #K                  #K is the number of verified bits\n     Reserved     \
    \       zero when sent, ignored when received\n     Opaque              copied\
    \ unmodified from the received PUZZLE\n                         parameter\n  \
    \   Random #I           random number of size RHASH_len bits\n     Puzzle solution\
    \ #J  random number of size RHASH_len bits\n   Random #I and Random #J are represented\
    \ as n-bit unsigned integers\n   (where n is RHASH_len), and #K as an 8-bit unsigned\
    \ integer, all in\n   network byte order.\n   The SOLUTION parameter contains\
    \ a solution to a puzzle.  It also\n   echoes back the random difficulty #K, the\
    \ Opaque field, and the\n   puzzle integer #I.\n"
- title: 5.2.6.  DH_GROUP_LIST
  contents:
  - "5.2.6.  DH_GROUP_LIST\n      0                   1                   2      \
    \             3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | DH\
    \ GROUP ID #1| DH GROUP ID #2| DH GROUP ID #3| DH GROUP ID #4|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | DH GROUP ID #n|                Padding                        |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     Type\
    \           511\n     Length         number of DH Group IDs\n     DH GROUP ID\
    \    identifies a DH GROUP ID supported by the host.\n                    The\
    \ list of IDs is ordered by preference of the\n                    host.  The\
    \ possible DH Group IDs are defined\n                    in the DIFFIE_HELLMAN\
    \ parameter.  Each DH\n                    Group ID is one octet long.\n   The\
    \ DH_GROUP_LIST parameter contains the list of supported DH Group\n   IDs of a\
    \ host.  The Initiator sends the DH_GROUP_LIST in the I1\n   packet, and the Responder\
    \ sends its own list in the signed part of\n   the R1 packet.  The DH Group IDs\
    \ in the DH_GROUP_LIST are listed in\n   the order of their preference of the\
    \ host sending the list.  DH Group\n   IDs that are listed first are preferred\
    \ over the DH Group IDs listed\n   later.  The information in the DH_GROUP_LIST\
    \ allows the Responder to\n   select the DH group preferred by itself and supported\
    \ by the\n   Initiator.  Based on the DH_GROUP_LIST in the R1 packet, the\n  \
    \ Initiator can determine if the Responder has selected the best\n   possible\
    \ choice based on the Initiator's and Responder's preferences.\n   If the Responder's\
    \ choice differs from the best choice, the Initiator\n   can conclude that there\
    \ was an attempted downgrade attack (see\n   Section 4.1.7).\n   When selecting\
    \ the DH group for the DIFFIE_HELLMAN parameter in the\n   R1 packet, the Responder\
    \ MUST select the first DH Group ID in its\n   DH_GROUP_LIST in the R1 packet\
    \ that is compatible with one of the\n   Suite IDs in the Initiator's DH_GROUP_LIST\
    \ in the I1 packet.  The\n   Responder MUST NOT select any other DH Group ID that\
    \ is contained in\n   both lists, because then a downgrade attack cannot be detected.\n\
    \   In general, hosts SHOULD prefer stronger groups over weaker ones if\n   the\
    \ computation overhead is not prohibitively high for the intended\n   application.\n"
- title: 5.2.7.  DIFFIE_HELLMAN
  contents:
  - "5.2.7.  DIFFIE_HELLMAN\n      0                   1                   2     \
    \              3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \ Group ID    |      Public Value Length      | Public Value  /\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     /                                                               |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     /  \
    \                             |            Padding            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type           513\n     Length         length in octets, excluding Type,\
    \ Length, and\n                    Padding\n     Group ID       identifies values\
    \ for p and g as well as the KDF\n     Public Value   length of the following\
    \ Public Value in octets\n       Length\n     Public Value   the sender's public\
    \ Diffie-Hellman key\n   A single DIFFIE_HELLMAN parameter may be included in\
    \ selected HIP\n   packets based on the DH Group ID selected (Section 5.2.6).\
    \  The\n   following Group IDs have been defined; values are assigned by this\n\
    \   document:\n    Group                              KDF              Value\n\
    \    Reserved                                            0\n    DEPRECATED   \
    \                                       1\n    DEPRECATED                    \
    \                      2\n    1536-bit MODP group  [RFC3526]     HKDF [RFC5869]\
    \   3\n    3072-bit MODP group  [RFC3526]     HKDF [RFC5869]   4\n    DEPRECATED\
    \                                          5\n    DEPRECATED                 \
    \                         6\n    NIST P-256 [RFC5903]               HKDF [RFC5869]\
    \   7\n    NIST P-384 [RFC5903]               HKDF [RFC5869]   8\n    NIST P-521\
    \ [RFC5903]               HKDF [RFC5869]   9\n    SECP160R1  [SECG]          \
    \        HKDF [RFC5869]  10\n    2048-bit MODP group  [RFC3526]     HKDF [RFC5869]\
    \  11\n   The MODP Diffie-Hellman groups are defined in [RFC3526].  ECDH\n   groups\
    \ 7-9 are defined in [RFC5903] and [RFC6090].  ECDH group 10\n   is covered in\
    \ Appendix D.  Any ECDH used with HIP MUST have a\n   co-factor of 1.\n   The\
    \ Group ID also defines the key derivation function that is to be\n   used for\
    \ deriving the symmetric keys for the HMAC and symmetric\n   encryption from the\
    \ keying material from the Diffie-Hellman key\n   exchange (see Section 6.5).\n\
    \   A HIP implementation MUST implement Group ID 3.  The 160-bit\n   SECP160R1\
    \ group can be used when lower security is enough (e.g., web\n   surfing) and\
    \ when the equipment is not powerful enough (e.g., some\n   PDAs).  Implementations\
    \ SHOULD implement Group IDs 4 and 8.\n   To avoid unnecessary failures during\
    \ the base exchange, the rest of\n   the groups SHOULD be implemented in hosts\
    \ where resources are\n   adequate.\n"
- title: 5.2.8.  HIP_CIPHER
  contents:
  - "5.2.8.  HIP_CIPHER\n      0                   1                   2         \
    \          3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \        Cipher ID #1         |          Cipher ID #2         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          Cipher ID #n         |             Padding           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     Type\
    \           579\n     Length         length in octets, excluding Type, Length,\
    \ and\n                    Padding\n     Cipher ID      identifies the cipher\
    \ algorithm to be used for\n                    encrypting the contents of the\
    \ ENCRYPTED parameter\n   The following Cipher IDs are defined:\n        Suite\
    \ ID           Value\n        RESERVED           0\n        NULL-ENCRYPT     \
    \  1     ([RFC2410])\n        AES-128-CBC        2     ([RFC3602])\n        RESERVED\
    \           3     (unused value)\n        AES-256-CBC        4     ([RFC3602])\n\
    \   The sender of a HIP_CIPHER parameter MUST make sure that there are no\n  \
    \ more than six (6) Cipher IDs in one HIP_CIPHER parameter.\n   Conversely, a\
    \ recipient MUST be prepared to handle received transport\n   parameters that\
    \ contain more than six Cipher IDs by accepting the\n   first six Cipher IDs and\
    \ dropping the rest.  The limited number of\n   Cipher IDs sets the maximum size\
    \ of the HIP_CIPHER parameter.  As the\n   default configuration, the HIP_CIPHER\
    \ parameter MUST contain at least\n   one of the mandatory Cipher IDs.  There\
    \ MAY be a configuration option\n   that allows the administrator to override\
    \ this default.\n   The Responder lists supported and desired Cipher IDs in order\
    \ of\n   preference in the R1, up to the maximum of six Cipher IDs.  The\n   Initiator\
    \ MUST choose only one of the corresponding Cipher IDs.  This\n   Cipher ID will\
    \ be used for generating the ENCRYPTED parameter.\n   Mandatory implementation:\
    \ AES-128-CBC.  Implementors SHOULD support\n   NULL-ENCRYPT for testing/debugging\
    \ purposes but MUST NOT offer or\n   accept this value unless explicitly configured\
    \ for testing/debugging\n   of HIP.\n"
- title: 5.2.9.  HOST_ID
  contents:
  - "5.2.9.  HOST_ID\n      0                   1                   2            \
    \       3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \        HI Length            |DI-Type|      DI Length        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          Algorithm            |         Host Identity         /\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     /  \
    \                             |       Domain Identifier       /\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     /                                               |    Padding    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     Type\
    \               705\n     Length             length in octets, excluding Type,\
    \ Length, and\n                        Padding\n     HI Length          length\
    \ of the Host Identity in octets\n     DI-Type            type of the following\
    \ Domain Identifier field\n     DI Length          length of the Domain Identifier\
    \ field in octets\n     Algorithm          index to the employed algorithm\n \
    \    Host Identity      actual Host Identity\n     Domain Identifier  the identifier\
    \ of the sender\n   The following DI-Types have been defined:\n         Type \
    \                   Value\n         none included           0\n         FQDN \
    \                   1\n         NAI                     2\n         FQDN     \
    \       Fully Qualified Domain Name, in binary format\n         NAI          \
    \   Network Access Identifier\n   The format for the FQDN is defined in RFC 1035\
    \ [RFC1035],\n   Section 3.1.  The format for the NAI is defined in [RFC4282].\n\
    \   A host MAY optionally associate the Host Identity with a single\n   Domain\
    \ Identifier in the HOST_ID parameter.  If there is no Domain\n   Identifier,\
    \ i.e., the DI-Type field is zero, the DI Length field is\n   set to zero as well.\n\
    \   The following HI Algorithms have been defined:\n        Algorithm profiles\
    \   Values\n        RESERVED             0\n        DSA                  3 [FIPS.186-4.2013]\
    \  (RECOMMENDED)\n        RSA                  5 [RFC3447]          (REQUIRED)\n\
    \        ECDSA                7 [RFC4754]          (REQUIRED)\n        ECDSA_LOW\
    \            9 [SECG]             (RECOMMENDED)\n   For DSA, RSA, and ECDSA key\
    \ types, profiles containing at least\n   112 bits of security strength (as defined\
    \ by [NIST.800-131A.2011])\n   should be used.  For RSA signature padding, the\
    \ Probabilistic\n   Signature Scheme (PSS) method of padding [RFC3447] MUST be\
    \ used.\n   The Host Identity is derived from the DNSKEY format for RSA and DSA.\n\
    \   For these, the Public Key field of the RDATA part from RFC 4034\n   [RFC4034]\
    \ is used.  For Elliptic Curve Cryptography (ECC), we\n   distinguish two different\
    \ profiles: ECDSA and ECDSA_LOW.  ECC\n   contains curves approved by NIST and\
    \ defined in RFC 4754 [RFC4754].\n   ECDSA_LOW is defined for devices with low\
    \ computational capabilities\n   and uses shorter curves from the Standards for\
    \ Efficient Cryptography\n   Group [SECG].  Any ECDSA used with HIP MUST have\
    \ a co-factor of 1.\n   For ECDSA and ECDSA_LOW, Host Identities are represented\
    \ by the\n   following fields:\n      0                   1                  \
    \ 2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          ECC Curve            |                               /\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     /  \
    \                       Public Key                            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     ECC Curve     Curve label\n     Public Key    Represented in octet-string\
    \ format [RFC6090]\n   For hosts that implement ECDSA as the algorithm, the following\
    \ ECC\n   curves are required:\n        Algorithm    Curve            Values\n\
    \        ECDSA        RESERVED         0\n        ECDSA        NIST P-256    \
    \   1 [RFC4754]\n        ECDSA        NIST P-384       2 [RFC4754]\n   For hosts\
    \ that implement the ECDSA_LOW algorithm profile, the\n   following curve is required:\n\
    \        Algorithm    Curve            Values\n        ECDSA_LOW    RESERVED \
    \        0\n        ECDSA_LOW    SECP160R1        1 [SECG]\n"
- title: 5.2.10.  HIT_SUITE_LIST
  contents:
  - "5.2.10.  HIT_SUITE_LIST\n   The HIT_SUITE_LIST parameter contains a list of the\
    \ supported HIT\n   Suite IDs of the Responder.  The Responder sends the HIT_SUITE_LIST\n\
    \   in the signed part of the R1 packet.  Based on the HIT_SUITE_LIST,\n   the\
    \ Initiator can determine which source HIT Suite IDs are supported\n   by the\
    \ Responder.\n      0                   1                   2                \
    \   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ |             Type              |             Length            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |     ID #1     |     ID #2     |     ID #3     |     ID #4     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \   ID #n     |                Padding                        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type           715\n     Length         number of HIT Suite IDs\n     ID\
    \             identifies a HIT Suite ID supported by the host.\n             \
    \       The list of IDs is ordered by preference of the\n                    host.\
    \  Each HIT Suite ID is one octet long.  The\n                    four higher-order\
    \ bits of the ID field correspond\n                    to the HIT Suite ID in\
    \ the ORCHID OGA ID field.  The\n                    four lower-order bits are\
    \ reserved and set to 0\n                    by the sender.  The reception of\
    \ an ID with the\n                    four lower-order bits not set to 0 SHOULD\
    \ be\n                    considered as an error that MAY result in a\n      \
    \              NOTIFICATION of type UNSUPPORTED_HIT_SUITE.\n   The HIT Suite ID\
    \ indexes a HIT Suite.  HIT Suites are composed of\n   signature algorithms as\
    \ defined in Section 5.2.9, and hash functions.\n   The ID field in the HIT_SUITE_LIST\
    \ is defined as an eight-bit field,\n   as opposed to the four-bit HIT Suite ID\
    \ and OGA ID field in the\n   ORCHID.  This difference is a measure to accommodate\
    \ larger HIT Suite\n   IDs if the 16 available values prove insufficient.  In\
    \ that case, one\n   of the 16 values, zero, will be used to indicate that four\
    \ additional\n   bits of the ORCHID will be used to encode the HIT Suite ID. \
    \ Hence,\n   the current four-bit HIT Suite IDs only use the four higher-order\n\
    \   bits in the ID field.  Future documents may define the use of the\n   four\
    \ lower-order bits in the ID field.\n   The following HIT Suite IDs are defined,\
    \ and the relationship between\n   the four-bit ID value used in the OGA ID field\
    \ and the eight-bit\n   encoding within the HIT_SUITE_LIST ID field is clarified:\n\
    \        HIT Suite       Four-bit ID    Eight-bit encoding\n        RESERVED \
    \           0             0x00\n        RSA,DSA/SHA-256     1             0x10\
    \           (REQUIRED)\n        ECDSA/SHA-384       2             0x20       \
    \    (RECOMMENDED)\n        ECDSA_LOW/SHA-1     3             0x30           (RECOMMENDED)\n\
    \   The following table provides more detail on the above HIT Suite\n   combinations.\
    \  The input for each generation algorithm is the\n   encoding of the HI as defined\
    \ in Section 3.2.  The output is 96 bits\n   long and is directly used in the\
    \ ORCHID.\n   +-------+----------+--------------+------------+--------------------+\n\
    \   | Index | Hash     | HMAC         | Signature  | Description        |\n  \
    \ |       | function |              | algorithm  |                    |\n   |\
    \       |          |              | family     |                    |\n   +-------+----------+--------------+------------+--------------------+\n\
    \   |     0 |          |              |            | Reserved           |\n  \
    \ |       |          |              |            |                    |\n   |\
    \     1 | SHA-256  | HMAC-SHA-256 | RSA, DSA   | RSA or DSA HI      |\n   |  \
    \     |          |              |            | hashed with        |\n   |    \
    \   |          |              |            | SHA-256, truncated |\n   |      \
    \ |          |              |            | to 96 bits         |\n   |       |\
    \          |              |            |                    |\n   |     2 | SHA-384\
    \  | HMAC-SHA-384 | ECDSA      | ECDSA HI hashed    |\n   |       |          |\
    \              |            | with SHA-384,      |\n   |       |          |  \
    \            |            | truncated to 96    |\n   |       |          |    \
    \          |            | bits               |\n   |       |          |      \
    \        |            |                    |\n   |     3 | SHA-1    | HMAC-SHA-1\
    \   | ECDSA_LOW  | ECDSA_LOW HI       |\n   |       |          |             \
    \ |            | hashed with SHA-1, |\n   |       |          |              |\
    \            | truncated to 96    |\n   |       |          |              |  \
    \          | bits               |\n   +-------+----------+--------------+------------+--------------------+\n\
    \                           Table 10: HIT Suites\n   The hash of the Responder\
    \ as defined in the HIT Suite determines the\n   HMAC to be used for the RHASH\
    \ function.  The HMACs currently defined\n   here are HMAC-SHA-256 [RFC4868],\
    \ HMAC-SHA-384 [RFC4868], and\n   HMAC-SHA-1 [RFC2404].\n"
- title: 5.2.11.  TRANSPORT_FORMAT_LIST
  contents:
  - "5.2.11.  TRANSPORT_FORMAT_LIST\n   The TRANSPORT_FORMAT_LIST parameter contains\
    \ a list of the supported\n   HIP transport formats (TFs) of the Responder.  The\
    \ Responder sends\n   the TRANSPORT_FORMAT_LIST in the signed part of the R1 packet.\
    \  Based\n   on the TRANSPORT_FORMAT_LIST, the Initiator chooses one suitable\n\
    \   transport format and includes the respective HIP transport format\n   parameter\
    \ in its response packet.\n      0                   1                   2   \
    \                3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \        TF type #1           |           TF type #2          /\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     /          TF type #n           |             Padding           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     Type\
    \           2049\n     Length         2x number of TF types\n     TF Type    \
    \    identifies a transport format (TF) type supported\n                    by\
    \ the host.  The TF type numbers correspond to\n                    the HIP parameter\
    \ type numbers of the respective\n                    transport format parameters.\
    \  The list of TF types\n                    is ordered by preference of the sender.\n\
    \   The TF type numbers index the respective HIP parameters for the\n   transport\
    \ formats in the type number range between 2050 and 4095.\n   The parameters and\
    \ their use are defined in separate documents.\n   Currently, the only transport\
    \ format defined is IPsec ESP [RFC7402].\n   For each listed TF type, the sender\
    \ of the TRANSPORT_FORMAT_LIST\n   parameter MUST include the respective transport\
    \ format parameter in\n   the HIP packet.  The receiver MUST ignore the TF type\
    \ in the\n   TRANSPORT_FORMAT_LIST if no matching transport format parameter is\n\
    \   present in the packet.\n"
- title: 5.2.12.  HIP_MAC
  contents:
  - "5.2.12.  HIP_MAC\n      0                   1                   2           \
    \        3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     |      \
    \                       HMAC                              |\n     /          \
    \                                                     /\n     /              \
    \                 +-------------------------------+\n     |                  \
    \             |            Padding            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type           61505\n     Length         length in octets, excluding Type,\
    \ Length, and\n                    Padding\n     HMAC           HMAC computed\
    \ over the HIP packet, excluding the\n                    HIP_MAC parameter and\
    \ any following parameters,\n                    such as HIP_SIGNATURE, HIP_SIGNATURE_2,\n\
    \                    ECHO_REQUEST_UNSIGNED, or ECHO_RESPONSE_UNSIGNED.\n     \
    \               The Checksum field MUST be set to zero, and the\n            \
    \        HIP header length in the HIP common header MUST be\n                \
    \    calculated not to cover any excluded parameters\n                    when\
    \ the HMAC is calculated.  The size of the\n                    HMAC is the natural\
    \ size of the hash computation\n                    output depending on the used\
    \ hash function.\n   The HMAC uses RHASH as the hash algorithm.  The calculation\
    \ and\n   verification process is presented in Section 6.4.1.\n"
- title: 5.2.13.  HIP_MAC_2
  contents:
  - "5.2.13.  HIP_MAC_2\n   HIP_MAC_2 is a MAC of the packet and the HI of the sender\
    \ in the form\n   of a HOST_ID parameter when that parameter is not actually included\n\
    \   in the packet.  The parameter structure is the same as the structure\n   shown\
    \ in Section 5.2.12.  The fields are as follows:\n     Type           61569\n\
    \     Length         length in octets, excluding Type, Length, and\n         \
    \           Padding\n     HMAC           HMAC computed over the HIP packet, excluding\
    \ the\n                    HIP_MAC_2 parameter and any following parameters\n\
    \                    such as HIP_SIGNATURE, HIP_SIGNATURE_2,\n               \
    \     ECHO_REQUEST_UNSIGNED, or ECHO_RESPONSE_UNSIGNED,\n                    and\
    \ including an additional sender's HOST_ID\n                    parameter during\
    \ the HMAC calculation.  The\n                    Checksum field MUST be set to\
    \ zero, and the HIP\n                    header length in the HIP common header\
    \ MUST be\n                    calculated not to cover any excluded parameters\n\
    \                    when the HMAC is calculated.  The size of the\n         \
    \           HMAC is the natural size of the hash computation\n               \
    \     output depending on the used hash function.\n   The HMAC uses RHASH as the\
    \ hash algorithm.  The calculation and\n   verification process is presented in\
    \ Section 6.4.1.\n"
- title: 5.2.14.  HIP_SIGNATURE
  contents:
  - "5.2.14.  HIP_SIGNATURE\n      0                   1                   2     \
    \              3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \  SIG alg                    |            Signature          /\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     /                               |             Padding           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     Type\
    \           61697\n     Length         length in octets, excluding Type, Length,\
    \ and\n                    Padding\n     SIG alg        signature algorithm\n\
    \     Signature      the signature is calculated over the HIP packet,\n      \
    \              excluding the HIP_SIGNATURE parameter and any\n               \
    \     parameters that follow the HIP_SIGNATURE\n                    parameter.\
    \  When the signature is calculated, the\n                    Checksum field MUST\
    \ be set to zero, and the HIP\n                    header length in the HIP common\
    \ header MUST be\n                    calculated only up to the beginning of the\n\
    \                    HIP_SIGNATURE parameter.\n   The signature algorithms are\
    \ defined in Section 5.2.9.  The signature\n   in the Signature field is encoded\
    \ using the method depending on the\n   signature algorithm (e.g., according to\
    \ [RFC3110] in the case of RSA/\n   SHA-1, [RFC5702] in the case of RSA/SHA-256,\
    \ [RFC2536] in the case of\n   DSA, or [RFC6090] in the case of ECDSA).\n   HIP_SIGNATURE\
    \ calculation and verification follow the process defined\n   in Section 6.4.2.\n"
- title: 5.2.15.  HIP_SIGNATURE_2
  contents:
  - "5.2.15.  HIP_SIGNATURE_2\n   HIP_SIGNATURE_2 excludes the variable parameters\
    \ in the R1 packet to\n   allow R1 pre-creation.  The parameter structure is the\
    \ same as the\n   structure shown in Section 5.2.14.  The fields are as follows:\n\
    \     Type           61633\n     Length         length in octets, excluding Type,\
    \ Length, and\n                    Padding\n     SIG alg        signature algorithm\n\
    \     Signature      Within the R1 packet that contains the\n                \
    \    HIP_SIGNATURE_2 parameter, the Initiator's HIT, the\n                   \
    \ Checksum field, and the Opaque and Random #I fields\n                    in\
    \ the PUZZLE parameter MUST be set to zero while\n                    computing\
    \ the HIP_SIGNATURE_2 signature.  Further,\n                    the HIP packet\
    \ length in the HIP header MUST be\n                    adjusted as if the HIP_SIGNATURE_2\
    \ was not in the\n                    packet during the signature calculation,\
    \ i.e., the\n                    HIP packet length points to the beginning of\n\
    \                    the HIP_SIGNATURE_2 parameter during signing and\n      \
    \              verification.\n   Zeroing the Initiator's HIT makes it possible\
    \ to create R1 packets\n   beforehand, to minimize the effects of possible DoS\
    \ attacks.  Zeroing\n   the Random #I and Opaque fields within the PUZZLE parameter\
    \ allows\n   these fields to be populated dynamically on precomputed R1s.\n  \
    \ Signature calculation and verification follow the process defined in\n   Section\
    \ 6.4.2.\n"
- title: 5.2.16.  SEQ
  contents:
  - "5.2.16.  SEQ\n      0                   1                   2               \
    \    3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ |             Type              |             Length            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                            Update ID                          |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     Type\
    \            385\n     Length          4\n     Update ID       32-bit sequence\
    \ number\n   The Update ID is an unsigned number in network byte order,\n   initialized\
    \ by a host to zero upon moving to ESTABLISHED state.  The\n   Update ID has scope\
    \ within a single HIP association, and not across\n   multiple associations or\
    \ multiple hosts.  The Update ID is\n   incremented by one before each new UPDATE\
    \ that is sent by the host;\n   the first UPDATE packet originated by a host has\
    \ an Update ID of 0.\n"
- title: 5.2.17.  ACK
  contents:
  - "5.2.17.  ACK\n      0                   1                   2               \
    \    3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ |             Type              |             Length            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                       peer Update ID 1                        |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     /  \
    \                     peer Update ID n                        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type             449\n     Length           length in octets, excluding\
    \ Type and Length\n     peer Update ID   32-bit sequence number corresponding\
    \ to the\n                      Update ID being ACKed\n   The ACK parameter includes\
    \ one or more Update IDs that have been\n   received from the peer.  The number\
    \ of peer Update IDs can be\n   inferred from the length by dividing it by 4.\n"
- title: 5.2.18.  ENCRYPTED
  contents:
  - "5.2.18.  ENCRYPTED\n      0                   1                   2         \
    \          3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         Reserved                            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                              IV                               /\n    \
    \ /                                                               /\n     /  \
    \                             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               /\n     /                        Encrypted data\
    \                         /\n     /                                          \
    \                     /\n     /                               +-------------------------------+\n\
    \     /                               |            Padding            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     Type\
    \           641\n     Length         length in octets, excluding Type, Length,\
    \ and\n                    Padding\n     Reserved       zero when sent, ignored\
    \ when received\n     IV             Initialization vector, if needed, otherwise\n\
    \                    nonexistent.  The length of the IV is inferred from\n   \
    \                 the HIP_CIPHER.\n     Encrypted      The data is encrypted using\
    \ the encryption algorithm\n       data         defined in the HIP_CIPHER parameter.\n\
    \   The ENCRYPTED parameter encapsulates other parameters, the encrypted\n   data,\
    \ which holds one or more HIP parameters in block encrypted form.\n   Consequently,\
    \ the first fields in the encapsulated parameter(s) are\n   Type and Length of\
    \ the first such parameter, allowing the contents to\n   be easily parsed after\
    \ decryption.\n   The field labeled \"Encrypted data\" consists of the output\
    \ of one or\n   more HIP parameters concatenated together that have been passed\n\
    \   through an encryption algorithm.  Each of these inner parameters is\n   padded\
    \ according to the rules of Section 5.2.1 for padding individual\n   parameters.\
    \  As a result, the concatenated parameters will be a block\n   of data that is\
    \ 8-byte aligned.\n   Some encryption algorithms require that the data to be encrypted\
    \ must\n   be a multiple of the cipher algorithm block size.  In this case, the\n\
    \   above block of data MUST include additional padding, as specified by\n   the\
    \ encryption algorithm.  The size of the extra padding is selected\n   so that\
    \ the length of the unencrypted data block is a multiple of the\n   cipher block\
    \ size.  The encryption algorithm may specify padding\n   bytes other than zero;\
    \ for example, AES [FIPS.197.2001] uses the\n   PKCS5 padding scheme (see Section\
    \ 6.1.1 of [RFC2898]) where the\n   remaining n bytes to fill the block each have\
    \ the value of n.  This\n   yields an \"unencrypted data\" block that is transformed\
    \ to an\n   \"encrypted data\" block by the cipher suite.  This extra padding\
    \ added\n   to the set of parameters to satisfy the cipher block alignment rules\n\
    \   is not counted in HIP TLV Length fields, and this extra padding\n   should\
    \ be removed by the cipher suite upon decryption.\n   Note that the length of\
    \ the cipher suite output may be smaller or\n   larger than the length of the\
    \ set of parameters to be encrypted,\n   since the encryption process may compress\
    \ the data or add additional\n   padding to the data.\n   Once this encryption\
    \ process is completed, the Encrypted data field\n   is ready for inclusion in\
    \ the parameter.  If necessary, additional\n   Padding for 8-byte alignment is\
    \ then added according to the rules of\n   Section 5.2.1.\n"
- title: 5.2.19.  NOTIFICATION
  contents:
  - "5.2.19.  NOTIFICATION\n   The NOTIFICATION parameter is used to transmit informational\
    \ data,\n   such as error conditions and state transitions, to a HIP peer.  A\n\
    \   NOTIFICATION parameter may appear in NOTIFY packets.  The use of the\n   NOTIFICATION\
    \ parameter in other packet types is for further study.\n      0             \
    \      1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \        Reserved             |      Notify Message Type      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               /\n    \
    \ /                   Notification Data                           /\n     /  \
    \                                             +---------------+\n     /      \
    \                                         |     Padding   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type             832\n     Length           length in octets, excluding\
    \ Type, Length, and\n                      Padding\n     Reserved         zero\
    \ when sent, ignored when received\n     Notify Message   specifies the type of\
    \ notification\n       Type\n     Notification     informational or error data\
    \ transmitted in\n       Data           addition to the Notify Message Type. \
    \ Values\n                      for this field are type specific (see below).\n\
    \   Notification information can be error messages specifying why a HIP\n   Security\
    \ Association could not be established.  It can also be status\n   data that a\
    \ HIP implementation wishes to communicate with a peer\n   process.  The table\
    \ below lists the notification messages and their\n   Notify Message Types.  HIP\
    \ packets MAY contain multiple NOTIFICATION\n   parameters if several problems\
    \ exist or several independent pieces of\n   information must be transmitted.\n\
    \   To avoid certain types of attacks, a Responder SHOULD avoid sending a\n  \
    \ NOTIFICATION to any host with which it has not successfully verified\n   a puzzle\
    \ solution.\n   Notify Message Types in the range 0-16383 are intended for reporting\n\
    \   errors, and those in the range 16384-65535 are for other status\n   information.\
    \  An implementation that receives a NOTIFY packet with a\n   Notify Message Type\
    \ that indicates an error in response to a request\n   packet (e.g., I1, I2, UPDATE)\
    \ SHOULD assume that the corresponding\n   request has failed entirely.  Unrecognized\
    \ error types MUST be\n   ignored, except that they SHOULD be logged.\n   As currently\
    \ defined, Notify Message Type values 1-10 are used for\n   informing about errors\
    \ in packet structures, and values 11-20 for\n   informing about problems in parameters.\n\
    \   Notification Data in NOTIFICATION parameters where the Notify Message\n  \
    \ Type is in the status range MUST be ignored if not recognized.\n     Notify\
    \ Message Types - Errors             Value\n     -----------------------------\
    \             -----\n     UNSUPPORTED_CRITICAL_PARAMETER_TYPE        1\n     \
    \  Sent if the parameter type has the \"critical\" bit set and the\n       parameter\
    \ type is not recognized.  Notification Data contains the\n       two-octet parameter\
    \ type.\n     INVALID_SYNTAX                             7\n       Indicates that\
    \ the HIP message received was invalid because some\n       type, length, or value\
    \ was out of range or because the request\n       was otherwise malformed.  To\
    \ avoid a denial-of-service\n       attack using forged messages, this status\
    \ may only be returned\n       for packets whose HIP_MAC (if present) and SIGNATURE\
    \ have been\n       verified.  This status MUST be sent in response to any error\
    \ not\n       covered by one of the other status types and SHOULD NOT contain\n\
    \       details, to avoid leaking information to someone probing a node.\n   \
    \    To aid debugging, more detailed error information SHOULD be\n       written\
    \ to a console or log.\n     NO_DH_PROPOSAL_CHOSEN                     14\n  \
    \     None of the proposed Group IDs were acceptable.\n     INVALID_DH_CHOSEN\
    \                         15\n       The DH Group ID field does not correspond\
    \ to one offered\n       by the Responder.\n     NO_HIP_PROPOSAL_CHOSEN      \
    \              16\n       None of the proposed HIT Suites or HIP Encryption Algorithms\
    \ were\n       acceptable.\n     INVALID_HIP_CIPHER_CHOSEN                 17\n\
    \       The HIP_CIPHER Crypto ID does not correspond to one offered by\n     \
    \  the Responder.\n     UNSUPPORTED_HIT_SUITE                     20\n       Sent\
    \ in response to an I1 or R1 packet for which the HIT Suite\n       is not supported.\n\
    \     AUTHENTICATION_FAILED                     24\n       Sent in response to\
    \ a HIP signature failure, except when\n       the signature verification fails\
    \ in a NOTIFY message.\n     CHECKSUM_FAILED                           26\n  \
    \     Sent in response to a HIP checksum failure.\n     HIP_MAC_FAILED       \
    \                     28\n       Sent in response to a HIP HMAC failure.\n   \
    \  ENCRYPTION_FAILED                         32\n       The Responder could not\
    \ successfully decrypt the\n       ENCRYPTED parameter.\n     INVALID_HIT    \
    \                           40\n       Sent in response to a failure to validate\
    \ the peer's\n       HIT from the corresponding HI.\n     BLOCKED_BY_POLICY  \
    \                       42\n       The Responder is unwilling to set up an association\n\
    \       for some policy reason (e.g., the received HIT is NULL\n       and the\
    \ policy does not allow opportunistic mode).\n     RESPONDER_BUSY_PLEASE_RETRY\
    \               44\n       The Responder is unwilling to set up an association,\
    \ as it is\n       suffering under some kind of overload and has chosen to shed\
    \ load\n       by rejecting the Initiator's request.  The Initiator may retry;\n\
    \       however, the Initiator MUST find another (different) puzzle\n       solution\
    \ for any such retries.  Note that the Initiator may need\n       to obtain a\
    \ new puzzle with a new I1/R1 exchange.\n     Notify Message Types - Status  \
    \          Value\n     -----------------------------            -----\n     I2_ACKNOWLEDGEMENT\
    \                       16384\n       The Responder has an I2 packet from the\
    \ Initiator but had to\n       queue the I2 packet for processing.  The puzzle\
    \ was correctly\n       solved, and the Responder is willing to set up an association\
    \ but\n       currently has a number of I2 packets in the processing queue.\n\
    \       The R2 packet is sent after the I2 packet was processed.\n"
- title: 5.2.20.  ECHO_REQUEST_SIGNED
  contents:
  - "5.2.20.  ECHO_REQUEST_SIGNED\n      0                   1                   2\
    \                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \               Opaque data (variable length)                 |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type          897\n     Length        length of the opaque data in octets\n\
    \     Opaque data   opaque data, supposed to be meaningful only to\n         \
    \          the node that sends ECHO_REQUEST_SIGNED and\n                   receives\
    \ a corresponding ECHO_RESPONSE_SIGNED or\n                   ECHO_RESPONSE_UNSIGNED\n\
    \   The ECHO_REQUEST_SIGNED parameter contains an opaque blob of data\n   that\
    \ the sender wants to get echoed back in the corresponding reply\n   packet.\n\
    \   The ECHO_REQUEST_SIGNED and corresponding echo response parameters\n   MAY\
    \ be used for any purpose where a node wants to carry some state in\n   a request\
    \ packet and get it back in a response packet.  The\n   ECHO_REQUEST_SIGNED is\
    \ covered by the HIP_MAC and SIGNATURE.  A HIP\n   packet can contain only one\
    \ ECHO_REQUEST_SIGNED parameter and MAY\n   contain multiple ECHO_REQUEST_UNSIGNED\
    \ parameters.  The\n   ECHO_REQUEST_SIGNED parameter MUST be responded to with\
    \ an\n   ECHO_RESPONSE_SIGNED.\n"
- title: 5.2.21.  ECHO_REQUEST_UNSIGNED
  contents:
  - "5.2.21.  ECHO_REQUEST_UNSIGNED\n      0                   1                 \
    \  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \               Opaque data (variable length)                 |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type          63661\n     Length        length of the opaque data in octets\n\
    \     Opaque data   opaque data, supposed to be meaningful only to\n         \
    \          the node that sends ECHO_REQUEST_UNSIGNED and\n                   receives\
    \ a corresponding ECHO_RESPONSE_UNSIGNED\n   The ECHO_REQUEST_UNSIGNED parameter\
    \ contains an opaque blob of data\n   that the sender wants to get echoed back\
    \ in the corresponding reply\n   packet.\n   The ECHO_REQUEST_UNSIGNED and corresponding\
    \ echo response parameters\n   MAY be used for any purpose where a node wants\
    \ to carry some state in\n   a request packet and get it back in a response packet.\
    \  The\n   ECHO_REQUEST_UNSIGNED is not covered by the HIP_MAC and SIGNATURE.\
    \  A\n   HIP packet can contain one or more ECHO_REQUEST_UNSIGNED parameters.\n\
    \   It is possible that middleboxes add ECHO_REQUEST_UNSIGNED parameters\n   in\
    \ HIP packets passing by.  The creator of the ECHO_REQUEST_UNSIGNED\n   (end host\
    \ or middlebox) has to create the Opaque field so that it can\n   later identify\
    \ and remove the corresponding ECHO_RESPONSE_UNSIGNED\n   parameter.\n   The ECHO_REQUEST_UNSIGNED\
    \ parameter MUST be responded to with an\n   ECHO_RESPONSE_UNSIGNED parameter.\n"
- title: 5.2.22.  ECHO_RESPONSE_SIGNED
  contents:
  - "5.2.22.  ECHO_RESPONSE_SIGNED\n      0                   1                  \
    \ 2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \               Opaque data (variable length)                 |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type          961\n     Length        length of the opaque data in octets\n\
    \     Opaque data   opaque data, copied unmodified from the\n                \
    \   ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED\n                   parameter\
    \ that triggered this response\n   The ECHO_RESPONSE_SIGNED parameter contains\
    \ an opaque blob of data\n   that the sender of the ECHO_REQUEST_SIGNED wants\
    \ to get echoed back.\n   The opaque data is copied unmodified from the ECHO_REQUEST_SIGNED\n\
    \   parameter.\n   The ECHO_REQUEST_SIGNED and ECHO_RESPONSE_SIGNED parameters\
    \ MAY be\n   used for any purpose where a node wants to carry some state in a\n\
    \   request packet and get it back in a response packet.  The\n   ECHO_RESPONSE_SIGNED\
    \ is covered by the HIP_MAC and SIGNATURE.\n"
- title: 5.2.23.  ECHO_RESPONSE_UNSIGNED
  contents:
  - "5.2.23.  ECHO_RESPONSE_UNSIGNED\n      0                   1                \
    \   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |             Type              |             Length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \               Opaque data (variable length)                 |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Type          63425\n     Length        length of the opaque data in octets\n\
    \     Opaque data   opaque data, copied unmodified from the\n                \
    \   ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED\n                   parameter\
    \ that triggered this response\n   The ECHO_RESPONSE_UNSIGNED parameter contains\
    \ an opaque blob of data\n   that the sender of the ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED\n\
    \   wants to get echoed back.  The opaque data is copied unmodified from\n   the\
    \ corresponding echo request parameter.\n   The echo request and ECHO_RESPONSE_UNSIGNED\
    \ parameters MAY be used\n   for any purpose where a node wants to carry some\
    \ state in a request\n   packet and get it back in a response packet.  The\n \
    \  ECHO_RESPONSE_UNSIGNED is not covered by the HIP_MAC and SIGNATURE.\n"
- title: 5.3.  HIP Packets
  contents:
  - "5.3.  HIP Packets\n   There are eight basic HIP packets (see Table 11).  Four\
    \ are for the\n   HIP base exchange, one is for updating, one is for sending\n\
    \   notifications, and two are for closing a HIP association.  Support\n   for\
    \ the NOTIFY packet type is optional, but support for all other HIP\n   packet\
    \ types listed below is mandatory.\n   +------------------+------------------------------------------------+\n\
    \   |   Packet type    | Packet name                                    |\n  \
    \ +------------------+------------------------------------------------+\n   |\
    \        1         | I1 - the HIP Initiator Packet                  |\n   |  \
    \                |                                                |\n   |    \
    \    2         | R1 - the HIP Responder Packet                  |\n   |      \
    \            |                                                |\n   |        3\
    \         | I2 - the Second HIP Initiator Packet           |\n   |           \
    \       |                                                |\n   |        4    \
    \     | R2 - the Second HIP Responder Packet           |\n   |               \
    \   |                                                |\n   |        16       \
    \ | UPDATE - the HIP Update Packet                 |\n   |                  |\
    \                                                |\n   |        17        | NOTIFY\
    \ - the HIP Notify Packet                 |\n   |                  |         \
    \                                       |\n   |        18        | CLOSE - the\
    \ HIP Association Closing Packet     |\n   |                  |              \
    \                                  |\n   |        19        | CLOSE_ACK - the\
    \ HIP Closing Acknowledgment     |\n   |                  | Packet           \
    \                              |\n   +------------------+------------------------------------------------+\n\
    \               Table 11: HIP Packets and Packet Type Values\n   Packets consist\
    \ of the fixed header as described in Section 5.1,\n   followed by the parameters.\
    \  The parameter part, in turn, consists of\n   zero or more TLV-coded parameters.\n\
    \   In addition to the base packets, other packet types may be defined\n   later\
    \ in separate specifications.  For example, support for mobility\n   and multihoming\
    \ is not included in this specification.\n   See \"Notation\" (Section 2.2) for\
    \ the notation used in the operations.\n   In the future, an optional upper-layer\
    \ payload MAY follow the HIP\n   header.  The Next Header field in the header\
    \ indicates if there is\n   additional data following the HIP header.  The HIP\
    \ packet, however,\n   MUST NOT be fragmented into multiple extension headers\
    \ by setting the\n   Next Header field in a HIP header to the HIP protocol number.\
    \  This\n   limits the size of the possible additional data in the packet.\n"
- title: 5.3.1.  I1 - the HIP Initiator Packet
  contents:
  - "5.3.1.  I1 - the HIP Initiator Packet\n   The HIP header values for the I1 packet:\n\
    \     Header:\n       Packet Type = 1\n       SRC HIT = Initiator's HIT\n    \
    \   DST HIT = Responder's HIT, or NULL\n     IP ( HIP ( DH_GROUP_LIST ) )\n  \
    \ The I1 packet contains the fixed HIP header and the Initiator's\n   DH_GROUP_LIST.\n\
    \   Valid control bits: None\n   The Initiator receives the Responder's HIT from\
    \ either a DNS lookup\n   of the Responder's FQDN (see [HIP-DNS-EXT]), some other\
    \ repository,\n   or a local table.  If the Initiator does not know the Responder's\n\
    \   HIT, it may attempt to use opportunistic mode by using NULL (all\n   zeros)\
    \ as the Responder's HIT.  See also \"HIP Opportunistic Mode\"\n   (Section 4.1.8).\n\
    \   Since the I1 packet is so easy to spoof even if it were signed, no\n   attempt\
    \ is made to add to its generation or processing cost.\n   The Initiator includes\
    \ a DH_GROUP_LIST parameter in the I1 packet to\n   inform the Responder of its\
    \ preferred DH Group IDs.  Note that the\n   DH_GROUP_LIST in the I1 packet is\
    \ not protected by a signature.\n   Implementations MUST be able to handle a storm\
    \ of received I1\n   packets, discarding those with common content that arrive\
    \ within a\n   small time delta.\n"
- title: 5.3.2.  R1 - the HIP Responder Packet
  contents:
  - "5.3.2.  R1 - the HIP Responder Packet\n   The HIP header values for the R1 packet:\n\
    \     Header:\n       Packet Type = 2\n       SRC HIT = Responder's HIT\n    \
    \   DST HIT = Initiator's HIT\n     IP ( HIP ( [ R1_COUNTER, ]\n             \
    \   PUZZLE,\n                DIFFIE_HELLMAN,\n                HIP_CIPHER,\n  \
    \              HOST_ID,\n                HIT_SUITE_LIST,\n                DH_GROUP_LIST,\n\
    \                [ ECHO_REQUEST_SIGNED, ]\n                TRANSPORT_FORMAT_LIST,\n\
    \                HIP_SIGNATURE_2 )\n                <, ECHO_REQUEST_UNSIGNED >i)\n\
    \   Valid control bits: A\n   If the Responder's HI is an anonymous one, the A\
    \ control MUST be set.\n   The Initiator's HIT MUST match the one received in\
    \ the I1 packet if\n   the R1 is a response to an I1.  If the Responder has multiple\
    \ HIs,\n   the Responder's HIT used MUST match the Initiator's request.  If the\n\
    \   Initiator used opportunistic mode, the Responder may select freely\n   among\
    \ its HIs.  See also \"HIP Opportunistic Mode\" (Section 4.1.8).\n   The R1 packet\
    \ generation counter is used to determine the currently\n   valid generation of\
    \ puzzles.  The value is increased periodically,\n   and it is RECOMMENDED that\
    \ it is increased at least as often as\n   solutions to old puzzles are no longer\
    \ accepted.\n   The puzzle contains a Random #I and the difficulty #K.  The\n\
    \   difficulty #K indicates the number of lower-order bits, in the puzzle\n  \
    \ hash result, that must be zeros; see Section 4.1.2.  The Random #I is\n   not\
    \ covered by the signature and must be zeroed during the signature\n   calculation,\
    \ allowing the sender to select and set the #I into a\n   precomputed R1 packet\
    \ just prior to sending it to the peer.\n   The Responder selects the DIFFIE_HELLMAN\
    \ Group ID and Public Value\n   based on the Initiator's preference expressed\
    \ in the DH_GROUP_LIST\n   parameter in the I1 packet.  The Responder sends back\
    \ its own\n   preference based on which it chose the DH public value as\n   DH_GROUP_LIST.\
    \  This allows the Initiator to determine whether its\n   own DH_GROUP_LIST in\
    \ the sent I1 packet was manipulated by an\n   attacker.\n   The Diffie-Hellman\
    \ public value is ephemeral, and values SHOULD NOT\n   be reused across different\
    \ HIP associations.  Once the Responder has\n   received a valid response to an\
    \ R1 packet, that Diffie-Hellman value\n   SHOULD be deprecated.  It is possible\
    \ that the Responder has sent the\n   same Diffie-Hellman value to different hosts\
    \ simultaneously in\n   corresponding R1 packets, and those responses should also\
    \ be\n   accepted.  However, as a defense against I1 packet storms, an\n   implementation\
    \ MAY propose, and reuse unless avoidable, the same\n   Diffie-Hellman value for\
    \ a period of time -- for example, 15 minutes.\n   By using a small number of\
    \ different puzzles for a given\n   Diffie-Hellman value, the R1 packets can be\
    \ precomputed and delivered\n   as quickly as I1 packets arrive.  A scavenger\
    \ process should clean up\n   unused Diffie-Hellman values and puzzles.\n   Reusing\
    \ Diffie-Hellman public values opens up the potential security\n   risk of more\
    \ than one Initiator ending up with the same keying\n   material (due to faulty\
    \ random number generators).  Also, more than\n   one Initiator using the same\
    \ Responder public key half may lead to\n   potentially easier cryptographic attacks\
    \ and to imperfect forward\n   security.\n   However, these risks involved in\
    \ reusing the same public value are\n   statistical; that is, the authors are\
    \ not aware of any mechanism that\n   would allow manipulation of the protocol\
    \ so that the risk of the\n   reuse of any given Responder Diffie-Hellman public\
    \ key would differ\n   from the base probability.  Consequently, it is RECOMMENDED\
    \ that\n   Responders avoid reusing the same DH key with multiple Initiators,\n\
    \   but because the risk is considered statistical and not known to be\n   manipulable,\
    \ the implementations MAY reuse a key in order to ease\n   resource-constrained\
    \ implementations and to increase the probability\n   of successful communication\
    \ with legitimate clients even under an I1\n   packet storm.  In particular, when\
    \ it is too expensive to generate\n   enough precomputed R1 packets to supply\
    \ each potential Initiator with\n   a different DH key, the Responder MAY send\
    \ the same DH key to several\n   Initiators, thereby creating the possibility\
    \ of multiple legitimate\n   Initiators ending up using the same Responder-side\
    \ public key.\n   However, as soon as the Responder knows that it will use a particular\n\
    \   DH key, it SHOULD stop offering it.  This design is aimed to allow\n   resource-constrained\
    \ Responders to offer services under I1 packet\n   storms and to simultaneously\
    \ make the probability of DH key reuse\n   both statistical and as low as possible.\n\
    \   If the Responder uses the same DH key pair for multiple handshakes,\n   it\
    \ must take care to avoid small subgroup attacks [RFC2785].  To\n   avoid these\
    \ attacks, when receiving the I2 message, the Responder\n   SHOULD validate the\
    \ Initiator's DH public key as described in\n   [RFC2785], Section 3.1.  If the\
    \ validation fails, the Responder MUST\n   NOT generate a DH shared key and MUST\
    \ silently abort the HIP BEX.\n   The HIP_CIPHER parameter contains the encryption\
    \ algorithms supported\n   by the Responder to encrypt the contents of the ENCRYPTED\
    \ parameter,\n   in the order of preference.  All implementations MUST support\
    \ AES\n   [RFC3602].\n   The HIT_SUITE_LIST parameter is an ordered list of the\
    \ Responder's\n   preferred and supported HIT Suites.  The list allows the Initiator\
    \ to\n   determine whether its own source HIT matches any suite supported by\n\
    \   the Responder.\n   The ECHO_REQUEST_SIGNED and ECHO_REQUEST_UNSIGNED parameters\
    \ contain\n   data that the sender wants to receive unmodified in the corresponding\n\
    \   response packet in the ECHO_RESPONSE_SIGNED or ECHO_RESPONSE_UNSIGNED\n  \
    \ parameter.  The R1 packet may contain zero or more\n   ECHO_REQUEST_UNSIGNED\
    \ parameters as described in Section 5.2.21.\n   The TRANSPORT_FORMAT_LIST parameter\
    \ is an ordered list of the\n   Responder's preferred and supported transport\
    \ format types.  The list\n   allows the Initiator and the Responder to agree\
    \ on a common type for\n   payload protection.  This parameter is described in\
    \ Section 5.2.11.\n   The signature is calculated over the whole HIP packet as\
    \ described in\n   Section 5.2.15.  This allows the Responder to use precomputed\
    \ R1s.\n   The Initiator SHOULD validate this signature.  It MUST check that the\n\
    \   Responder's HI matches with the one expected, if any.\n"
- title: 5.3.3.  I2 - the Second HIP Initiator Packet
  contents:
  - "5.3.3.  I2 - the Second HIP Initiator Packet\n   The HIP header values for the\
    \ I2 packet:\n     Header:\n       Packet Type = 3\n       SRC HIT = Initiator's\
    \ HIT\n       DST HIT = Responder's HIT\n     IP ( HIP ( [R1_COUNTER,]\n     \
    \           SOLUTION,\n                DIFFIE_HELLMAN,\n                HIP_CIPHER,\n\
    \                ENCRYPTED { HOST_ID } or HOST_ID,\n                [ ECHO_RESPONSE_SIGNED,\
    \ ]\n                TRANSPORT_FORMAT_LIST,\n                HIP_MAC,\n      \
    \          HIP_SIGNATURE\n                <, ECHO_RESPONSE_UNSIGNED>i ) )\n  \
    \ Valid control bits: A\n   The HITs used MUST match the ones used in the R1.\n\
    \   If the Initiator's HI is an anonymous one, the A control bit MUST\n   be set.\n\
    \   If present in the I1 packet, the Initiator MUST include an unmodified\n  \
    \ copy of the R1_COUNTER parameter received in the corresponding R1\n   packet\
    \ into the I2 packet.\n   The Solution contains the Random #I from R1 and the\
    \ computed #J.  The\n   low-order #K bits of the RHASH( #I | ... | #J ) MUST be\
    \ zero.\n   The Diffie-Hellman value is ephemeral.  If precomputed, a scavenger\n\
    \   process should clean up unused Diffie-Hellman values.  The Responder\n   MAY\
    \ reuse Diffie-Hellman values under some conditions as specified in\n   Section\
    \ 5.3.2.\n   The HIP_CIPHER contains the single encryption suite selected by the\n\
    \   Initiator, that it uses to encrypt the ENCRYPTED parameters.  The\n   chosen\
    \ cipher MUST correspond to one of the ciphers offered by the\n   Responder in\
    \ the R1.  All implementations MUST support AES [RFC3602].\n   The Initiator's\
    \ HI MAY be encrypted using the HIP_CIPHER encryption\n   algorithm.  The keying\
    \ material is derived from the Diffie-Hellman\n   exchange as defined in Section\
    \ 6.5.\n   The ECHO_RESPONSE_SIGNED and ECHO_RESPONSE_UNSIGNED contain the\n \
    \  unmodified opaque data copied from the corresponding echo request\n   parameter(s).\n\
    \   The TRANSPORT_FORMAT_LIST contains the single transport format type\n   selected\
    \ by the Initiator.  The chosen type MUST correspond to one of\n   the types offered\
    \ by the Responder in the R1.  Currently, the only\n   transport format defined\
    \ is the ESP transport format ([RFC7402]).\n   The HMAC value in the HIP_MAC parameter\
    \ is calculated over the whole\n   HIP packet, excluding any parameters after\
    \ the HIP_MAC, as described\n   in Section 6.4.1.  The Responder MUST validate\
    \ the HIP_MAC.\n   The signature is calculated over the whole HIP packet, excluding\
    \ any\n   parameters after the HIP_SIGNATURE, as described in Section 5.2.14.\n\
    \   The Responder MUST validate this signature.  The Responder uses the\n   HI\
    \ in the packet or an HI acquired by some other means for verifying\n   the signature.\n"
- title: 5.3.4.  R2 - the Second HIP Responder Packet
  contents:
  - "5.3.4.  R2 - the Second HIP Responder Packet\n   The HIP header values for the\
    \ R2 packet:\n     Header:\n       Packet Type = 4\n       SRC HIT = Responder's\
    \ HIT\n       DST HIT = Initiator's HIT\n     IP ( HIP ( HIP_MAC_2, HIP_SIGNATURE\
    \ ) )\n   Valid control bits: None\n   The HIP_MAC_2 is calculated over the whole\
    \ HIP packet, with the\n   Responder's HOST_ID parameter concatenated with the\
    \ HIP packet.  The\n   HOST_ID parameter is removed after the HMAC calculation.\
    \  The\n   procedure is described in Section 6.4.1.\n   The signature is calculated\
    \ over the whole HIP packet.\n   The Initiator MUST validate both the HIP_MAC\
    \ and the signature.\n"
- title: 5.3.5.  UPDATE - the HIP Update Packet
  contents:
  - "5.3.5.  UPDATE - the HIP Update Packet\n   The HIP header values for the UPDATE\
    \ packet:\n     Header:\n       Packet Type = 16\n       SRC HIT = Sender's HIT\n\
    \       DST HIT = Recipient's HIT\n     IP ( HIP ( [SEQ, ACK, ] HIP_MAC, HIP_SIGNATURE\
    \ ) )\n   Valid control bits: None\n   The UPDATE packet contains mandatory HIP_MAC\
    \ and HIP_SIGNATURE\n   parameters, and other optional parameters.\n   The UPDATE\
    \ packet contains zero or one SEQ parameter.  The presence\n   of a SEQ parameter\
    \ indicates that the receiver MUST acknowledge the\n   UPDATE.  An UPDATE that\
    \ does not contain a SEQ but only an ACK\n   parameter is simply an acknowledgment\
    \ of a previous UPDATE and itself\n   MUST NOT be acknowledged by a separate ACK\
    \ parameter.  Such UPDATE\n   packets containing only an ACK parameter do not\
    \ require processing in\n   relative order to other UPDATE packets.  An UPDATE\
    \ packet without\n   either a SEQ or an ACK parameter is invalid; such unacknowledged\n\
    \   updates MUST instead use a NOTIFY packet.\n   An UPDATE packet contains zero\
    \ or one ACK parameter.  The ACK\n   parameter echoes the SEQ sequence number\
    \ of the UPDATE packet being\n   ACKed.  A host MAY choose to acknowledge more\
    \ than one UPDATE packet\n   at a time; e.g., the ACK parameter may contain the\
    \ last two SEQ\n   values received, for resilience against packet loss.  ACK values\
    \ are\n   not cumulative; each received unique SEQ value requires at least one\n\
    \   corresponding ACK value in reply.  Received ACK parameters that are\n   redundant\
    \ are ignored.  Hosts MUST implement the processing of ACK\n   parameters with\
    \ multiple SEQ sequence numbers even if they do not\n   implement sending ACK\
    \ parameters with multiple SEQ sequence numbers.\n   The UPDATE packet may contain\
    \ both a SEQ and an ACK parameter.  In\n   this case, the ACK parameter is being\
    \ piggybacked on an outgoing\n   UPDATE.  In general, UPDATEs carrying SEQ SHOULD\
    \ be ACKed upon\n   completion of the processing of the UPDATE.  A host MAY choose\
    \ to\n   hold the UPDATE carrying an ACK parameter for a short period of time\n\
    \   to allow for the possibility of piggybacking the ACK parameter, in a\n   manner\
    \ similar to TCP delayed acknowledgments.\n   A sender MAY choose to forego reliable\
    \ transmission of a particular\n   UPDATE (e.g., it becomes overcome by events).\
    \  The semantics are such\n   that the receiver MUST acknowledge the UPDATE, but\
    \ the sender MAY\n   choose to not care about receiving the ACK parameter.\n \
    \  UPDATEs MAY be retransmitted without incrementing SEQ.  If the same\n   subset\
    \ of parameters is included in multiple UPDATEs with different\n   SEQs, the host\
    \ MUST ensure that the receiver's processing of the\n   parameters multiple times\
    \ will not result in a protocol error.\n"
- title: 5.3.6.  NOTIFY - the HIP Notify Packet
  contents:
  - "5.3.6.  NOTIFY - the HIP Notify Packet\n   The NOTIFY packet MAY be used to provide\
    \ information to a peer.\n   Typically, NOTIFY is used to indicate some type of\
    \ protocol error or\n   negotiation failure.  NOTIFY packets are unacknowledged.\
    \  The\n   receiver can handle the packet only as informational, and SHOULD NOT\n\
    \   change its HIP state (see Section 4.4.2) based purely on a received\n   NOTIFY\
    \ packet.\n   The HIP header values for the NOTIFY packet:\n     Header:\n   \
    \    Packet Type = 17\n       SRC HIT = Sender's HIT\n       DST HIT = Recipient's\
    \ HIT, or zero if unknown\n     IP ( HIP (<NOTIFICATION>i, [HOST_ID, ] HIP_SIGNATURE)\
    \ )\n   Valid control bits: None\n   The NOTIFY packet is used to carry one or\
    \ more NOTIFICATION\n   parameters.\n"
- title: 5.3.7.  CLOSE - the HIP Association Closing Packet
  contents:
  - "5.3.7.  CLOSE - the HIP Association Closing Packet\n   The HIP header values\
    \ for the CLOSE packet:\n     Header:\n       Packet Type = 18\n       SRC HIT\
    \ = Sender's HIT\n       DST HIT = Recipient's HIT\n     IP ( HIP ( ECHO_REQUEST_SIGNED,\
    \ HIP_MAC, HIP_SIGNATURE ) )\n   Valid control bits: None\n   The sender MUST\
    \ include an ECHO_REQUEST_SIGNED used to validate\n   CLOSE_ACK received in response,\
    \ and both a HIP_MAC and a signature\n   (calculated over the whole HIP packet).\n\
    \   The receiver peer MUST reply with a CLOSE_ACK containing an\n   ECHO_RESPONSE_SIGNED\
    \ corresponding to the received\n   ECHO_REQUEST_SIGNED.\n"
- title: 5.3.8.  CLOSE_ACK - the HIP Closing Acknowledgment Packet
  contents:
  - "5.3.8.  CLOSE_ACK - the HIP Closing Acknowledgment Packet\n   The HIP header\
    \ values for the CLOSE_ACK packet:\n     Header:\n       Packet Type = 19\n  \
    \     SRC HIT = Sender's HIT\n       DST HIT = Recipient's HIT\n     IP ( HIP\
    \ ( ECHO_RESPONSE_SIGNED, HIP_MAC, HIP_SIGNATURE ) )\n   Valid control bits: None\n\
    \   The sender MUST include both an HMAC and signature (calculated over\n   the\
    \ whole HIP packet).\n   The receiver peer MUST validate the ECHO_RESPONSE_SIGNED\
    \ and validate\n   both the HIP_MAC and the signature if the receiver has state\
    \ for a\n   HIP association.\n"
- title: 5.4.  ICMP Messages
  contents:
  - "5.4.  ICMP Messages\n   When a HIP implementation detects a problem with an incoming\
    \ packet,\n   and it either cannot determine the identity of the sender of the\n\
    \   packet or does not have any existing HIP association with the sender\n   of\
    \ the packet, it MAY respond with an ICMP packet.  Any such replies\n   MUST be\
    \ rate-limited as described in [RFC4443].  In most cases, the\n   ICMP packet\
    \ has the Parameter Problem type (12 for ICMPv4, 4 for\n   ICMPv6), with the Pointer\
    \ pointing to the field that caused the ICMP\n   message to be generated.\n"
- title: 5.4.1.  Invalid Version
  contents:
  - "5.4.1.  Invalid Version\n   If a HIP implementation receives a HIP packet that\
    \ has an\n   unrecognized HIP version number, it SHOULD respond, rate-limited,\n\
    \   with an ICMP packet with type Parameter Problem, with the Pointer\n   pointing\
    \ to the Version/RES. byte in the HIP header.\n"
- title: 5.4.2.  Other Problems with the HIP Header and Packet Structure
  contents:
  - "5.4.2.  Other Problems with the HIP Header and Packet Structure\n   If a HIP\
    \ implementation receives a HIP packet that has other\n   unrecoverable problems\
    \ in the header or packet format, it MAY\n   respond, rate-limited, with an ICMP\
    \ packet with type Parameter\n   Problem, with the Pointer pointing to the field\
    \ that failed to pass\n   the format checks.  However, an implementation MUST\
    \ NOT send an ICMP\n   message if the checksum fails; instead, it MUST silently\
    \ drop the\n   packet.\n"
- title: 5.4.3.  Invalid Puzzle Solution
  contents:
  - "5.4.3.  Invalid Puzzle Solution\n   If a HIP implementation receives an I2 packet\
    \ that has an invalid\n   puzzle solution, the behavior depends on the underlying\
    \ version of\n   IP.  If IPv6 is used, the implementation SHOULD respond with\
    \ an ICMP\n   packet with type Parameter Problem, with the Pointer pointing to\
    \ the\n   beginning of the Puzzle solution #J field in the SOLUTION payload in\n\
    \   the HIP message.\n   If IPv4 is used, the implementation MAY respond with\
    \ an ICMP packet\n   with the type Parameter Problem, copying enough bytes from\
    \ the I2\n   message so that the SOLUTION parameter fits into the ICMP message,\n\
    \   with the Pointer pointing to the beginning of the Puzzle solution #J\n   field,\
    \ as in the IPv6 case.  Note, however, that the resulting ICMPv4\n   message exceeds\
    \ the typical ICMPv4 message size as defined in\n   [RFC0792].\n"
- title: 5.4.4.  Non-existing HIP Association
  contents:
  - "5.4.4.  Non-existing HIP Association\n   If a HIP implementation receives a CLOSE\
    \ or UPDATE packet, or any\n   other packet whose handling requires an existing\
    \ association, that\n   has either a Receiver or Sender HIT that does not match\
    \ with any\n   existing HIP association, the implementation MAY respond, rate-\n\
    \   limited, with an ICMP packet with the type Parameter Problem.  The\n   Pointer\
    \ of the ICMP Parameter Problem packet is set pointing to the\n   beginning of\
    \ the first HIT that does not match.\n   A host MUST NOT reply with such an ICMP\
    \ if it receives any of the\n   following messages: I1, R2, I2, R2, and NOTIFY\
    \ packet.  When\n   introducing new packet types, a specification SHOULD define\
    \ the\n   appropriate rules for sending or not sending this kind of ICMP reply.\n"
- title: 6.  Packet Processing
  contents:
  - "6.  Packet Processing\n   Each host is assumed to have a single HIP implementation\
    \ that manages\n   the host's HIP associations and handles requests for new ones.\
    \  Each\n   HIP association is governed by a conceptual state machine, with\n\
    \   states defined above in Section 4.4.  The HIP implementation can\n   simultaneously\
    \ maintain HIP associations with more than one host.\n   Furthermore, the HIP\
    \ implementation may have more than one active HIP\n   association with another\
    \ host; in this case, HIP associations are\n   distinguished by their respective\
    \ HITs.  It is not possible to have\n   more than one HIP association between\
    \ any given pair of HITs.\n   Consequently, the only way for two hosts to have\
    \ more than one\n   parallel association is to use different HITs, at least at\
    \ one end.\n   The processing of packets depends on the state of the HIP\n   association(s)\
    \ with respect to the authenticated or apparent\n   originator of the packet.\
    \  A HIP implementation determines whether it\n   has an active association with\
    \ the originator of the packet based on\n   the HITs.  In the case of user data\
    \ carried in a specific transport\n   format, the transport format document specifies\
    \ how the incoming\n   packets are matched with the active associations.\n"
- title: 6.1.  Processing Outgoing Application Data
  contents:
  - "6.1.  Processing Outgoing Application Data\n   In a HIP host, an application\
    \ can send application-level data using\n   an identifier specified via the underlying\
    \ API.  The API can be a\n   backwards-compatible API (see [RFC5338]), using identifiers\
    \ that look\n   similar to IP addresses, or a completely new API, providing enhanced\n\
    \   services related to Host Identities.  Depending on the HIP\n   implementation,\
    \ the identifier provided to the application may be\n   different; for example,\
    \ it can be a HIT or an IP address.\n   The exact format and method for transferring\
    \ the user data from the\n   source HIP host to the destination HIP host are defined\
    \ in the\n   corresponding transport format document.  The actual data is\n  \
    \ transferred in the network using the appropriate source and\n   destination\
    \ IP addresses.\n   In this document, conceptual processing rules are defined\
    \ only for\n   the base case where both hosts have only single usable IP addresses;\n\
    \   the multi-address multihoming case is specified separately.\n   The following\
    \ conceptual algorithm describes the steps that are\n   required for handling\
    \ outgoing datagrams destined to a HIT.\n   1.  If the datagram has a specified\
    \ source address, it MUST be a HIT.\n       If it is not, the implementation MAY\
    \ replace the source address\n       with a HIT.  Otherwise, it MUST drop the\
    \ packet.\n   2.  If the datagram has an unspecified source address, the\n   \
    \    implementation MUST choose a suitable source HIT for the\n       datagram.\
    \  Selecting the source HIT is subject to local policy.\n   3.  If there is no\
    \ active HIP association with the given <source,\n       destination> HIT pair,\
    \ one MUST be created by running the base\n       exchange.  While waiting for\
    \ the base exchange to complete, the\n       implementation SHOULD queue at least\
    \ one user data packet per HIP\n       association to be formed, and it MAY queue\
    \ more than one.\n   4.  Once there is an active HIP association for the given\
    \ <source,\n       destination> HIT pair, the outgoing datagram is passed to\n\
    \       transport handling.  The possible transport formats are defined\n    \
    \   in separate documents, of which the ESP transport format for HIP\n       is\
    \ mandatory for all HIP implementations.\n   5.  Before sending the packet, the\
    \ HITs in the datagram are replaced\n       with suitable IP addresses.  For IPv6,\
    \ the rules defined in\n       [RFC6724] SHOULD be followed.  Note that this HIT-to-IP-address\n\
    \       conversion step MAY also be performed at some other point in the\n   \
    \    stack, e.g., before wrapping the packet into the output format.\n"
- title: 6.2.  Processing Incoming Application Data
  contents:
  - "6.2.  Processing Incoming Application Data\n   The following conceptual algorithm\
    \ describes the incoming datagram\n   handling when HITs are used at the receiving\
    \ host as application-\n   level identifiers.  More detailed steps for processing\
    \ packets are\n   defined in corresponding transport format documents.\n   1.\
    \  The incoming datagram is mapped to an existing HIP association,\n       typically\
    \ using some information from the packet.  For example,\n       such mapping may\
    \ be based on the ESP Security Parameter Index\n       (SPI).\n   2.  The specific\
    \ transport format is unwrapped, in a way depending on\n       the transport format,\
    \ yielding a packet that looks like a\n       standard (unencrypted) IP packet.\
    \  If possible, this step SHOULD\n       also verify that the packet was indeed\
    \ (once) sent by the remote\n       HIP host, as identified by the HIP association.\n\
    \       Depending on the used transport mode, the verification method can\n  \
    \     vary.  While the HI (as well as the HIT) is used as the higher-\n      \
    \ layer identifier, the verification method has to verify that the\n       data\
    \ packet was sent by the correct node identity and that the\n       actual identity\
    \ maps to this particular HIT.  When using the ESP\n       transport format [RFC7402],\
    \ the verification is done using the\n       SPI value in the data packet to find\
    \ the corresponding SA with\n       associated HIT and key, and decrypting the\
    \ packet with that\n       associated key.\n   3.  The IP addresses in the datagram\
    \ are replaced with the HITs\n       associated with the HIP association.  Note\
    \ that this IP-address-\n       to-HIT conversion step MAY also be performed at\
    \ some other point\n       in the stack.\n   4.  The datagram is delivered to\
    \ the upper layer (e.g., UDP or TCP).\n       When demultiplexing the datagram,\
    \ the right upper-layer socket is\n       selected based on the HITs.\n"
- title: 6.3.  Solving the Puzzle
  contents:
  - "6.3.  Solving the Puzzle\n   This subsection describes the details for solving\
    \ the puzzle.\n   In the R1 packet, the values #I and #K are sent in network byte\n\
    \   order.  Similarly, in the I2 packet, the values #I and #J are sent in\n  \
    \ network byte order.  The hash is created by concatenating, in network\n   byte\
    \ order, the following data, in the following order and using the\n   RHASH algorithm:\n\
    \      n-bit random value #I (where n is RHASH_len), in network byte\n      order,\
    \ as appearing in the R1 and I2 packets.\n      128-bit Initiator's HIT, in network\
    \ byte order, as appearing in\n      the HIP Payload in the R1 and I2 packets.\n\
    \      128-bit Responder's HIT, in network byte order, as appearing in\n     \
    \ the HIP Payload in the R1 and I2 packets.\n      n-bit random value #J (where\
    \ n is RHASH_len), in network byte\n      order, as appearing in the I2 packet.\n\
    \   In a valid response puzzle, the #K low-order bits of the resulting\n   RHASH\
    \ digest MUST be zero.\n   Notes:\n        i) The length of the data to be hashed\
    \ is variable, depending on\n           the output length of the Responder's hash\
    \ function RHASH.\n       ii) All the data in the hash input MUST be in network\
    \ byte order.\n      iii) The orderings of the Initiator's and Responder's HITs\
    \ are\n           different in the R1 and I2 packets; see Section 5.1.  Care\n\
    \           must be taken to copy the values in the right order to the\n     \
    \      hash input.\n       iv) For a puzzle #I, there may exist multiple valid\
    \ puzzle\n           solutions #J.\n   The following procedure describes the processing\
    \ steps involved,\n   assuming that the Responder chooses to precompute the R1\
    \ packets:\n   Precomputation by the Responder:\n      Sets up the puzzle difficulty\
    \ #K.\n      Creates a signed R1 and caches it.\n   Responder:\n      Selects\
    \ a suitable cached R1.\n      Generates a random number #I.\n      Sends #I and\
    \ #K in an R1.\n      Saves #I and #K for a delta time.\n   Initiator:\n     \
    \ Generates repeated attempts to solve the puzzle until a matching\n      #J is\
    \ found:\n      Ltrunc( RHASH( #I | HIT-I | HIT-R | #J ), #K ) == 0\n      Sends\
    \ #I and #J in an I2.\n   Responder:\n      Verifies that the received #I is a\
    \ saved one.\n      Finds the right #K based on #I.\n      Computes V := Ltrunc(\
    \ RHASH( #I | HIT-I | HIT-R | #J ), #K )\n      Rejects if V != 0\n      Accepts\
    \ if V == 0\n"
- title: 6.4.  HIP_MAC and SIGNATURE Calculation and Verification
  contents:
  - "6.4.  HIP_MAC and SIGNATURE Calculation and Verification\n   The following subsections\
    \ define the actions for processing HIP_MAC,\n   HIP_MAC_2, HIP_SIGNATURE, and\
    \ HIP_SIGNATURE_2 parameters.  The\n   HIP_MAC_2 parameter is contained in the\
    \ R2 packet.  The\n   HIP_SIGNATURE_2 parameter is contained in the R1 packet.\
    \  The\n   HIP_SIGNATURE and HIP_MAC parameters are contained in other HIP\n \
    \  packets.\n"
- title: 6.4.1.  HMAC Calculation
  contents:
  - "6.4.1.  HMAC Calculation\n   The HMAC uses RHASH as the underlying hash function.\
    \  The type of\n   RHASH depends on the HIT Suite of the Responder.  Hence, HMAC-SHA-256\n\
    \   [RFC4868] is used for HIT Suite RSA/DSA/SHA-256, HMAC-SHA-1 [RFC2404]\n  \
    \ is used for HIT Suite ECDSA_LOW/SHA-1, and HMAC-SHA-384 [RFC4868] is\n   used\
    \ for HIT Suite ECDSA/SHA-384.\n   The following process applies both to the HIP_MAC\
    \ and HIP_MAC_2\n   parameters.  When processing HIP_MAC_2, the difference is\
    \ that the\n   HIP_MAC calculation includes a pseudo HOST_ID field containing\
    \ the\n   Responder's information as sent in the R1 packet earlier.\n   Both the\
    \ Initiator and the Responder should take some care when\n   verifying or calculating\
    \ the HIP_MAC_2.  Specifically, the Initiator\n   has to preserve the HOST_ID\
    \ exactly as it was received in the R1\n   packet until it receives the HIP_MAC_2\
    \ in the R2 packet.\n   The scope of the calculation for HIP_MAC is as follows:\n\
    \   HMAC: { HIP header | [ Parameters ] }\n   where Parameters include all of\
    \ the packet's HIP parameters with type\n   values ranging from 1 to (HIP_MAC's\
    \ type value - 1), and excluding\n   those parameters with type values greater\
    \ than or equal to HIP_MAC's\n   type value.\n   During HIP_MAC calculation, the\
    \ following apply:\n   o  In the HIP header, the Checksum field is set to zero.\n\
    \   o  In the HIP header, the Header Length field value is calculated to\n   \
    \   the beginning of the HIP_MAC parameter.\n   Parameter order is described in\
    \ Section 5.2.1.\n   The scope of the calculation for HIP_MAC_2 is as follows:\n\
    \   HIP_MAC_2: { HIP header | [ Parameters ] | HOST_ID }\n   where Parameters\
    \ include all of the packet's HIP parameters with type\n   values from 1 to (HIP_MAC_2's\
    \ type value - 1), and excluding those\n   parameters with type values greater\
    \ than or equal to HIP_MAC_2's type\n   value.\n   During HIP_MAC_2 calculation,\
    \ the following apply:\n   o  In the HIP header, the Checksum field is set to\
    \ zero.\n   o  In the HIP header, the Header Length field value is calculated\
    \ to\n      the beginning of the HIP_MAC_2 parameter and increased by the\n  \
    \    length of the concatenated HOST_ID parameter length (including the\n    \
    \  Type and Length fields).\n   o  The HOST_ID parameter is exactly in the form\
    \ it was received in\n      the R1 packet from the Responder.\n   Parameter order\
    \ is described in Section 5.2.1, except that the\n   HOST_ID parameter in this\
    \ calculation is added to the end.\n   The HIP_MAC parameter is defined in Section\
    \ 5.2.12 and the HIP_MAC_2\n   parameter in Section 5.2.13.  The HMAC calculation\
    \ and verification\n   process (the process applies both to HIP_MAC and HIP_MAC_2,\
    \ except\n   where HIP_MAC_2 is mentioned separately) is as follows:\n   Packet\
    \ sender:\n   1.  Create the HIP packet, without the HIP_MAC, HIP_SIGNATURE,\n\
    \       HIP_SIGNATURE_2, or any other parameter with greater type value\n    \
    \   than the HIP_MAC parameter has.\n   2.  In case of HIP_MAC_2 calculation,\
    \ add a HOST_ID (Responder)\n       parameter to the end of the packet.\n   3.\
    \  Calculate the Header Length field in the HIP header, including\n       the\
    \ added HOST_ID parameter in case of HIP_MAC_2.\n   4.  Compute the HMAC using\
    \ either the HIP-gl or HIP-lg integrity key\n       retrieved from KEYMAT as defined\
    \ in Section 6.5.\n   5.  In case of HIP_MAC_2, remove the HOST_ID parameter from\
    \ the\n       packet.\n   6.  Add the HIP_MAC parameter to the packet and any\
    \ parameter with\n       greater type value than the HIP_MAC's (HIP_MAC_2's) that\
    \ may\n       follow, including possible HIP_SIGNATURE or HIP_SIGNATURE_2\n  \
    \     parameters.\n   7.  Recalculate the Length field in the HIP header.\n  \
    \ Packet receiver:\n   1.  Verify the HIP Header Length field.\n   2.  Remove\
    \ the HIP_MAC or HIP_MAC_2 parameter, as well as all other\n       parameters\
    \ that follow it with greater type value including\n       possible HIP_SIGNATURE\
    \ or HIP_SIGNATURE_2 fields, saving the\n       contents if they are needed later.\n\
    \   3.  In case of HIP_MAC_2, build and add a HOST_ID parameter (with\n      \
    \ Responder information) to the packet.  The HOST_ID parameter\n       should\
    \ be identical to the one previously received from the\n       Responder.\n  \
    \ 4.  Recalculate the HIP packet length in the HIP header and clear the\n    \
    \   Checksum field (set it to all zeros).  In case of HIP_MAC_2, the\n       length\
    \ is calculated with the added HOST_ID parameter.\n   5.  Compute the HMAC using\
    \ either the HIP-gl or HIP-lg integrity key\n       as defined in Section 6.5\
    \ and verify it against the received\n       HMAC.\n   6.  Set the Checksum and\
    \ Header Length fields in the HIP header to\n       original values.  Note that\
    \ the Checksum and Length fields\n       contain incorrect values after this step.\n\
    \   7.  In case of HIP_MAC_2, remove the HOST_ID parameter from the\n       packet\
    \ before further processing.\n"
- title: 6.4.2.  Signature Calculation
  contents:
  - "6.4.2.  Signature Calculation\n   The following process applies both to the HIP_SIGNATURE\
    \ and\n   HIP_SIGNATURE_2 parameters.  When processing the HIP_SIGNATURE_2\n \
    \  parameter, the only difference is that instead of the HIP_SIGNATURE\n   parameter,\
    \ the HIP_SIGNATURE_2 parameter is used, and the Initiator's\n   HIT and PUZZLE\
    \ Opaque and Random #I fields are cleared (set to all\n   zeros) before computing\
    \ the signature.  The HIP_SIGNATURE parameter\n   is defined in Section 5.2.14\
    \ and the HIP_SIGNATURE_2 parameter in\n   Section 5.2.15.\n   The scope of the\
    \ calculation for HIP_SIGNATURE and HIP_SIGNATURE_2 is\n   as follows:\n   HIP_SIGNATURE:\
    \ { HIP header | [ Parameters ] }\n   where Parameters include all of the packet's\
    \ HIP parameters with type\n   values from 1 to (HIP_SIGNATURE's type value -\
    \ 1).\n   During signature calculation, the following apply:\n   o  In the HIP\
    \ header, the Checksum field is set to zero.\n   o  In the HIP header, the Header\
    \ Length field value is calculated to\n      the beginning of the HIP_SIGNATURE\
    \ parameter.\n   Parameter order is described in Section 5.2.1.\n   HIP_SIGNATURE_2:\
    \ { HIP header | [ Parameters ] }\n   where Parameters include all of the packet's\
    \ HIP parameters with type\n   values ranging from 1 to (HIP_SIGNATURE_2's type\
    \ value - 1).\n   During signature calculation, the following apply:\n   o  In\
    \ the HIP header, both the Checksum and the Receiver's HIT fields\n      are set\
    \ to zero.\n   o  In the HIP header, the Header Length field value is calculated\
    \ to\n      the beginning of the HIP_SIGNATURE_2 parameter.\n   o  The PUZZLE\
    \ parameter's Opaque and Random #I fields are set to\n      zero.\n   Parameter\
    \ order is described in Section 5.2.1.\n   The signature calculation and verification\
    \ process (the process\n   applies both to HIP_SIGNATURE and HIP_SIGNATURE_2,\
    \ except in the case\n   where HIP_SIGNATURE_2 is separately mentioned) is as\
    \ follows:\n   Packet sender:\n   1.  Create the HIP packet without the HIP_SIGNATURE\
    \ parameter or any\n       other parameters that follow the HIP_SIGNATURE parameter.\n\
    \   2.  Calculate the Length field and zero the Checksum field in the HIP\n  \
    \     header.  In case of HIP_SIGNATURE_2, set the Initiator's HIT\n       field\
    \ in the HIP header as well as the PUZZLE parameter's Opaque\n       and Random\
    \ #I fields to zero.\n   3.  Compute the signature using the private key corresponding\
    \ to the\n       Host Identifier (public key).\n   4.  Add the HIP_SIGNATURE parameter\
    \ to the packet.\n   5.  Add any parameters that follow the HIP_SIGNATURE parameter.\n\
    \   6.  Recalculate the Length field in the HIP header, and calculate the\n  \
    \     Checksum field.\n   Packet receiver:\n   1.  Verify the HIP Header Length\
    \ field and checksum.\n   2.  Save the contents of the HIP_SIGNATURE parameter\
    \ and any other\n       parameters following the HIP_SIGNATURE parameter, and\
    \ remove them\n       from the packet.\n   3.  Recalculate the HIP packet Length\
    \ in the HIP header and clear the\n       Checksum field (set it to all zeros).\
    \  In case of\n       HIP_SIGNATURE_2, set the Initiator's HIT field in the HIP\
    \ header\n       as well as the PUZZLE parameter's Opaque and Random #I fields\n\
    \       to zero.\n   4.  Compute the signature and verify it against the received\n\
    \       signature using the packet sender's Host Identity (public key).\n   5.\
    \  Restore the original packet by adding removed parameters (in\n       step 2)\
    \ and resetting the values that were set to zero (in\n       step 3).\n   The\
    \ verification can use either the HI received from a HIP packet;\n   the HI retrieved\
    \ from a DNS query, if the FQDN has been received in\n   the HOST_ID parameter;\
    \ or an HI received by some other means.\n"
- title: 6.5.  HIP KEYMAT Generation
  contents:
  - "6.5.  HIP KEYMAT Generation\n   HIP keying material is derived from the Diffie-Hellman\
    \ session key,\n   Kij, produced during the HIP base exchange (see Section 4.1.3).\
    \  The\n   Initiator has Kij during the creation of the I2 packet, and the\n \
    \  Responder has Kij once it receives the I2 packet.  This is why I2 can\n   already\
    \ contain encrypted information.\n   The KEYMAT is derived by feeding Kij into\
    \ the key derivation function\n   defined by the DH Group ID.  Currently, the\
    \ only key derivation\n   function defined in this document is the Hash-based\
    \ Key Derivation\n   Function (HKDF) [RFC5869] using the RHASH hash function.\
    \  Other\n   documents may define new DH Group IDs and corresponding key\n   distribution\
    \ functions.\n   In the following, we provide the details for deriving the keying\n\
    \   material using HKDF.\n   where\n   info    = sort(HIT-I | HIT-R)\n   salt\
    \    =  #I | #J\n   Sort(HIT-I | HIT-R) is defined as the network byte order\n\
    \   concatenation of the two HITs, with the smaller HIT preceding the\n   larger\
    \ HIT, resulting from the numeric comparison of the two HITs\n   interpreted as\
    \ positive (unsigned) 128-bit integers in network byte\n   order.  The #I and\
    \ #J values are from the puzzle and its solution\n   that were exchanged in R1\
    \ and I2 messages when this HIP association\n   was set up.  Both hosts have to\
    \ store #I and #J values for the HIP\n   association for future use.\n   The initial\
    \ keys are drawn sequentially in the order that is\n   determined by the numeric\
    \ comparison of the two HITs, with the\n   comparison method described in the\
    \ previous paragraph.  HOST_g\n   denotes the host with the greater HIT value,\
    \ and HOST_l the host with\n   the lower HIT value.\n   The drawing order for\
    \ the four initial keys is as follows:\n      HIP-gl encryption key for HOST_g's\
    \ ENCRYPTED parameter\n      HIP-gl integrity (HMAC) key for HOST_g's outgoing\
    \ HIP packets\n      HIP-lg encryption key for HOST_l's ENCRYPTED parameter\n\
    \      HIP-lg integrity (HMAC) key for HOST_l's outgoing HIP packets\n   The number\
    \ of bits drawn for a given algorithm is the \"natural\" size\n   of the keys.\
    \  For the mandatory algorithms, the following sizes\n   apply:\n      AES   \
    \    128 or 256 bits\n      SHA-1     160 bits\n      SHA-256   256 bits\n   \
    \   SHA-384   384 bits\n      NULL      0 bits\n   If other key sizes are used,\
    \ they MUST be treated as different\n   encryption algorithms and defined separately.\n"
- title: 6.6.  Initiation of a HIP Base Exchange
  contents:
  - "6.6.  Initiation of a HIP Base Exchange\n   An implementation may originate a\
    \ HIP base exchange to another host\n   based on a local policy decision, usually\
    \ triggered by an application\n   datagram, in much the same way that an IPsec\
    \ IKE key exchange can\n   dynamically create a Security Association.  Alternatively,\
    \ a system\n   may initiate a HIP exchange if it has rebooted or timed out, or\n\
    \   otherwise lost its HIP state, as described in Section 4.5.4.\n   The implementation\
    \ prepares an I1 packet and sends it to the IP\n   address that corresponds to\
    \ the peer host.  The IP address of the\n   peer host may be obtained via conventional\
    \ mechanisms, such as DNS\n   lookup.  The I1 packet contents are specified in\
    \ Section 5.3.1.  The\n   selection of which source or destination Host Identity\
    \ to use, if an\n   Initiator or Responder has more than one to choose from, is\
    \ typically\n   a policy decision.\n   The following steps define the conceptual\
    \ processing rules for\n   initiating a HIP base exchange:\n   1.  The Initiator\
    \ receives one or more of the Responder's HITs and\n       one or more addresses\
    \ from either a DNS lookup of the Responder's\n       FQDN, some other repository,\
    \ or a local database.  If the\n       Initiator does not know the Responder's\
    \ HIT, it may attempt\n       opportunistic mode by using NULL (all zeros) as\
    \ the Responder's\n       HIT (see also \"HIP Opportunistic Mode\" (Section 4.1.8)).\
    \  If the\n       Initiator can choose from multiple Responder HITs, it selects\
    \ a\n       HIT for which the Initiator supports the HIT Suite.\n   2.  The Initiator\
    \ sends an I1 packet to one of the Responder's\n       addresses.  The selection\
    \ of which address to use is a local\n       policy decision.\n   3.  The Initiator\
    \ includes the DH_GROUP_LIST in the I1 packet.  The\n       selection and order\
    \ of DH Group IDs in the DH_GROUP_LIST MUST be\n       stored by the Initiator,\
    \ because this list is needed for later R1\n       processing.  In most cases,\
    \ the preferences regarding the DH\n       groups will be static, so no per-association\
    \ storage is\n       necessary.\n   4.  Upon sending an I1 packet, the sender\
    \ transitions to state\n       I1-SENT and starts a timer for which the timeout\
    \ value SHOULD be\n       larger than the worst-case anticipated RTT.  The sender\
    \ SHOULD\n       also increment the trial counter associated with the I1.\n  \
    \ 5.  Upon timeout, the sender SHOULD retransmit the I1 packet and\n       restart\
    \ the timer, up to a maximum of I1_RETRIES_MAX tries.\n"
- title: 6.6.1.  Sending Multiple I1 Packets in Parallel
  contents:
  - "6.6.1.  Sending Multiple I1 Packets in Parallel\n   For the sake of minimizing\
    \ the association establishment latency, an\n   implementation MAY send the same\
    \ I1 packet to more than one of the\n   Responder's addresses.  However, it MUST\
    \ NOT send to more than three\n   (3) Responder addresses in parallel.  Furthermore,\
    \ upon timeout, the\n   implementation MUST refrain from sending the same I1 packet\
    \ to\n   multiple addresses.  That is, if it retries to initialize the\n   connection\
    \ after a timeout, it MUST NOT send the I1 packet to more\n   than one destination\
    \ address.  These limitations are placed in order\n   to avoid congestion of the\
    \ network, and potential DoS attacks that\n   might occur, e.g., because someone's\
    \ claim to have hundreds or\n   thousands of addresses could generate a huge number\
    \ of I1 packets\n   from the Initiator.\n   As the Responder is not guaranteed\
    \ to distinguish the duplicate I1\n   packets it receives at several of its addresses\
    \ (because it avoids\n   storing states when it answers back an R1 packet), the\
    \ Initiator may\n   receive several duplicate R1 packets.\n   The Initiator SHOULD\
    \ then select the initial preferred destination\n   address using the source address\
    \ of the selected received R1, and use\n   the preferred address as a source address\
    \ for the I2 packet.\n   Processing rules for received R1s are discussed in Section\
    \ 6.8.\n"
- title: 6.6.2.  Processing Incoming ICMP Protocol Unreachable Messages
  contents:
  - "6.6.2.  Processing Incoming ICMP Protocol Unreachable Messages\n   A host may\
    \ receive an ICMP 'Destination Protocol Unreachable' message\n   as a response\
    \ to sending a HIP I1 packet.  Such a packet may be an\n   indication that the\
    \ peer does not support HIP, or it may be an\n   attempt to launch an attack by\
    \ making the Initiator believe that the\n   Responder does not support HIP.\n\
    \   When a system receives an ICMP 'Destination Protocol Unreachable'\n   message\
    \ while it is waiting for an R1 packet, it MUST NOT terminate\n   waiting.  It\
    \ MAY continue as if it had not received the ICMP message,\n   and send a few\
    \ more I1 packets.  Alternatively, it MAY take the ICMP\n   message as a hint\
    \ that the peer most probably does not support HIP,\n   and return to state UNASSOCIATED\
    \ earlier than otherwise.  However, at\n   minimum, it MUST continue waiting for\
    \ an R1 packet for a reasonable\n   time before returning to UNASSOCIATED.\n"
- title: 6.7.  Processing of Incoming I1 Packets
  contents:
  - "6.7.  Processing of Incoming I1 Packets\n   An implementation SHOULD reply to\
    \ an I1 with an R1 packet, unless the\n   implementation is unable or unwilling\
    \ to set up a HIP association.\n   If the implementation is unable to set up a\
    \ HIP association, the host\n   SHOULD send an 'ICMP Destination Protocol Unreachable,\n\
    \   Administratively Prohibited' message to the I1 packet source IP\n   address.\
    \  If the implementation is unwilling to set up a HIP\n   association, the host\
    \ MAY ignore the I1 packet.  This latter case may\n   occur during a DoS attack\
    \ such as an I1 packet flood.\n   The implementation SHOULD be able to handle\
    \ a storm of received I1\n   packets, discarding those with common content that\
    \ arrive within a\n   small time delta.\n   A spoofed I1 packet can result in\
    \ an R1 attack on a system.  An R1\n   packet sender MUST have a mechanism to\
    \ rate-limit R1 packets sent to\n   an address.\n   It is RECOMMENDED that the\
    \ HIP state machine does not transition upon\n   sending an R1 packet.\n   The\
    \ following steps define the conceptual processing rules for\n   responding to\
    \ an I1 packet:\n   1.  The Responder MUST check that the Responder's HIT in the\
    \ received\n       I1 packet is either one of its own HITs or NULL.  Otherwise,\
    \ it\n       must drop the packet.\n   2.  If the Responder is in ESTABLISHED\
    \ state, the Responder MAY\n       respond to this with an R1 packet, prepare\
    \ to drop an existing\n       HIP security association with the peer, and stay\
    \ at ESTABLISHED\n       state.\n   3.  If the Responder is in I1-SENT state,\
    \ it MUST make a comparison\n       between the sender's HIT and its own (i.e.,\
    \ the receiver's) HIT.\n       If the sender's HIT is greater than its own HIT,\
    \ it should drop\n       the I1 packet and stay at I1-SENT.  If the sender's HIT\
    \ is\n       smaller than its own HIT, it SHOULD send the R1 packet and stay\n\
    \       at I1-SENT.  The HIT comparison is performed as defined in\n       Section\
    \ 6.5.\n   4.  If the implementation chooses to respond to the I1 packet with\
    \ an\n       R1 packet, it creates a new R1 or selects a precomputed R1\n    \
    \   according to the format described in Section 5.3.2.  It creates\n       or\
    \ chooses an R1 that contains its most preferred DH public value\n       that\
    \ is also contained in the DH_GROUP_LIST in the I1 packet.  If\n       no suitable\
    \ DH Group ID was contained in the DH_GROUP_LIST in the\n       I1 packet, it\
    \ sends an R1 with any suitable DH public key.\n   5.  If the received Responder's\
    \ HIT in the I1 is NULL, the Responder\n       selects a HIT with the same HIT\
    \ Suite as the Initiator's HIT.  If\n       this HIT Suite is not supported by\
    \ the Responder, it SHOULD\n       select a REQUIRED HIT Suite from Section 5.2.10,\
    \ which is\n       currently RSA/DSA/SHA-256.  Other than that, selecting the\
    \ HIT is\n       a local policy matter.\n   6.  The Responder expresses its supported\
    \ HIP transport formats in\n       the TRANSPORT_FORMAT_LIST as described in Section\
    \ 5.2.11.  The\n       Responder MUST provide at least one payload transport format\n\
    \       type.\n   7.  The Responder sends the R1 packet to the source IP address\
    \ of the\n       I1 packet.\n"
- title: 6.7.1.  R1 Management
  contents:
  - "6.7.1.  R1 Management\n   All compliant implementations MUST be able to produce\
    \ R1 packets;\n   even if a device is configured by policy to only initiate\n\
    \   associations, it must be able to process I1s in cases of recovery\n   from\
    \ loss of state or key exhaustion.  An R1 packet MAY be\n   precomputed.  An R1\
    \ packet MAY be reused for a short time period,\n   denoted here as \"Delta T\"\
    , which is implementation dependent, and\n   SHOULD be deprecated and not used\
    \ once a valid response I2 packet has\n   been received from an Initiator.  During\
    \ an I1 message storm, an R1\n   packet MAY be reused beyond the normal Delta\
    \ T.  R1 information MUST\n   NOT be discarded until a time period \"Delta S\"\
    \ (again, implementation\n   dependent) after the R1 packet is no longer being\
    \ offered.  Delta S\n   is the assumed maximum time needed for the last I2 packet\
    \ in response\n   to the R1 packet to arrive back at the Responder.\n   Implementations\
    \ that support multiple DH groups MAY precompute R1\n   packets for each supported\
    \ group so that incoming I1 packets with\n   different DH Group IDs in the DH_GROUP_LIST\
    \ can be served quickly.\n   An implementation MAY keep state about received I1\
    \ packets and match\n   the received I2 packets against the state, as discussed\
    \ in\n   Section 4.1.1.\n"
- title: 6.7.2.  Handling of Malformed Messages
  contents:
  - "6.7.2.  Handling of Malformed Messages\n   If an implementation receives a malformed\
    \ I1 packet, it SHOULD NOT\n   respond with a NOTIFY message, as such a practice\
    \ could open up a\n   potential denial-of-service threat.  Instead, it MAY respond\
    \ with an\n   ICMP packet, as defined in Section 5.4.\n"
- title: 6.8.  Processing of Incoming R1 Packets
  contents:
  - "6.8.  Processing of Incoming R1 Packets\n   A system receiving an R1 packet MUST\
    \ first check to see if it has\n   sent an I1 packet to the originator of the\
    \ R1 packet (i.e., it is in\n   state I1-SENT).  If so, it SHOULD process the\
    \ R1 as described below,\n   send an I2 packet, and transition to state I2-SENT,\
    \ setting a timer\n   to protect the I2 packet.  If the system is in state I2-SENT,\
    \ it MAY\n   respond to the R1 packet if the R1 packet has a larger R1 generation\n\
    \   counter; if so, it should drop its state due to processing the\n   previous\
    \ R1 packet and start over from state I1-SENT.  If the system\n   is in any other\
    \ state with respect to that host, the system SHOULD\n   silently drop the R1\
    \ packet.\n   When sending multiple I1 packets, an Initiator SHOULD wait for a\n\
    \   small amount of time after the first R1 reception to allow possibly\n   multiple\
    \ R1 packets to arrive, and it SHOULD respond to an R1 packet\n   among the set\
    \ with the largest R1 generation counter.\n   The following steps define the conceptual\
    \ processing rules for\n   responding to an R1 packet:\n   1.   A system receiving\
    \ an R1 MUST first check to see if it has sent\n        an I1 packet to the originator\
    \ of the R1 packet (i.e., it has a\n        HIP association that is in state I1-SENT\
    \ and that is associated\n        with the HITs in the R1).  Unless the I1 packet\
    \ was sent in\n        opportunistic mode (see Section 4.1.8), the IP addresses\
    \ in the\n        received R1 packet SHOULD be ignored by the R1 processing and,\n\
    \        when looking up the right HIP association, the received R1\n        packet\
    \ SHOULD be matched against the associations using only the\n        HITs.  If\
    \ a match exists, the system should process the R1\n        packet as described\
    \ below.\n   2.   Otherwise, if the system is in any state other than I1-SENT\
    \ or\n        I2-SENT with respect to the HITs included in the R1 packet, it\n\
    \        SHOULD silently drop the R1 packet and remain in the current\n      \
    \  state.\n   3.   If the HIP association state is I1-SENT or I2-SENT, the received\n\
    \        Initiator's HIT MUST correspond to the HIT used in the original\n   \
    \     I1.  Also, the Responder's HIT MUST correspond to the one used\n       \
    \ in the I1, unless the I1 packet contained a NULL HIT.\n   4.   The system SHOULD\
    \ validate the R1 signature before applying\n        further packet processing,\
    \ according to Section 5.2.15.\n   5.   If the HIP association state is I1-SENT,\
    \ and multiple valid R1\n        packets are present, the system MUST select from\
    \ among the R1\n        packets with the largest R1 generation counter.\n   6.\
    \   The system MUST check that the Initiator's HIT Suite is\n        contained\
    \ in the HIT_SUITE_LIST parameter in the R1 packet\n        (i.e., the Initiator's\
    \ HIT Suite is supported by the Responder).\n        If the HIT Suite is supported\
    \ by the Responder, the system\n        proceeds normally.  Otherwise, the system\
    \ MAY stay in state\n        I1-SENT and restart the BEX by sending a new I1 packet\
    \ with an\n        Initiator HIT that is supported by the Responder and hence\
    \ is\n        contained in the HIT_SUITE_LIST in the R1 packet.  The system\n\
    \        MAY abort the BEX if no suitable source HIT is available.  The\n    \
    \    system SHOULD wait for an acceptable time span to allow further\n       \
    \ R1 packets with higher R1 generation counters or different HIT\n        and\
    \ HIT Suites to arrive before restarting or aborting the BEX.\n   7.   The system\
    \ MUST check that the DH Group ID in the DIFFIE_HELLMAN\n        parameter in\
    \ the R1 matches the first DH Group ID in the\n        Responder's DH_GROUP_LIST\
    \ in the R1 packet, and also that this\n        Group ID corresponds to a value\
    \ that was included in the\n        Initiator's DH_GROUP_LIST in the I1 packet.\
    \  If the DH Group ID\n        of the DIFFIE_HELLMAN parameter does not express\
    \ the Responder's\n        best choice, the Initiator can conclude that the DH_GROUP_LIST\n\
    \        in the I1 packet was adversely modified.  In such a case, the\n     \
    \   Initiator MAY send a new I1 packet; however, it SHOULD NOT\n        change\
    \ its preference in the DH_GROUP_LIST in the new I1 packet.\n        Alternatively,\
    \ the Initiator MAY abort the HIP base exchange.\n   8.   If the HIP association\
    \ state is I2-SENT, the system MAY re-enter\n        state I1-SENT and process\
    \ the received R1 packet if it has a\n        larger R1 generation counter than\
    \ the R1 packet responded to\n        previously.\n   9.   The R1 packet may have\
    \ the A-bit set -- in this case, the system\n        MAY choose to refuse it by\
    \ dropping the R1 packet and returning\n        to state UNASSOCIATED.  The system\
    \ SHOULD consider dropping the\n        R1 packet only if it used a NULL HIT in\
    \ the I1 packet.  If the\n        A-bit is set, the Responder's HIT is anonymous\
    \ and SHOULD NOT be\n        stored permanently.\n   10.  The system SHOULD attempt\
    \ to validate the HIT against the\n        received Host Identity by using the\
    \ received Host Identity to\n        construct a HIT and verify that it matches\
    \ the Sender's HIT.\n   11.  The system MUST store the received R1 generation\
    \ counter for\n        future reference.\n   12.  The system attempts to solve\
    \ the puzzle in the R1 packet.  The\n        system MUST terminate the search\
    \ after exceeding the remaining\n        lifetime of the puzzle.  If the puzzle\
    \ is not successfully\n        solved, the implementation MAY either resend the\
    \ I1 packet\n        within the retry bounds or abandon the HIP base exchange.\n\
    \   13.  The system computes standard Diffie-Hellman keying material\n       \
    \ according to the public value and Group ID provided in the\n        DIFFIE_HELLMAN\
    \ parameter.  The Diffie-Hellman keying material\n        Kij is used for key\
    \ extraction as specified in Section 6.5.\n   14.  The system selects the HIP_CIPHER\
    \ ID from the choices presented\n        in the R1 packet and uses the selected\
    \ values subsequently when\n        generating and using encryption keys, and\
    \ when sending the I2\n        packet.  If the proposed alternatives are not acceptable\
    \ to the\n        system, it may either resend an I1 within the retry bounds or\n\
    \        abandon the HIP base exchange.\n   15.  The system chooses one suitable\
    \ transport format from the\n        TRANSPORT_FORMAT_LIST and includes the respective\
    \ transport\n        format parameter in the subsequent I2 packet.\n   16.  The\
    \ system initializes the remaining variables in the associated\n        state,\
    \ including Update ID counters.\n   17.  The system prepares and sends an I2 packet,\
    \ as described in\n        Section 5.3.3.\n   18.  The system SHOULD start a timer\
    \ whose timeout value SHOULD be\n        larger than the worst-case anticipated\
    \ RTT, and MUST increment a\n        trial counter associated with the I2 packet.\
    \  The sender SHOULD\n        retransmit the I2 packet upon a timeout and restart\
    \ the timer,\n        up to a maximum of I2_RETRIES_MAX tries.\n   19.  If the\
    \ system is in state I1-SENT, it SHALL transition to state\n        I2-SENT. \
    \ If the system is in any other state, it remains in the\n        current state.\n"
- title: 6.8.1.  Handling of Malformed Messages
  contents:
  - "6.8.1.  Handling of Malformed Messages\n   If an implementation receives a malformed\
    \ R1 message, it MUST\n   silently drop the packet.  Sending a NOTIFY or ICMP\
    \ would not help,\n   as the sender of the R1 packet typically doesn't have any\
    \ state.  An\n   implementation SHOULD wait for some more time for a possibly\
    \ well-\n   formed R1, after which it MAY try again by sending a new I1 packet.\n"
- title: 6.9.  Processing of Incoming I2 Packets
  contents:
  - "6.9.  Processing of Incoming I2 Packets\n   Upon receipt of an I2 packet, the\
    \ system MAY perform initial checks\n   to determine whether the I2 packet corresponds\
    \ to a recent R1 packet\n   that has been sent out, if the Responder keeps such\
    \ state.  For\n   example, the sender could check whether the I2 packet is from\
    \ an\n   address or HIT for which the Responder has recently received an I1.\n\
    \   The R1 packet may have had opaque data included that was echoed back\n   in\
    \ the I2 packet.  If the I2 packet is considered to be suspect, it\n   MAY be\
    \ silently discarded by the system.\n   Otherwise, the HIP implementation SHOULD\
    \ process the I2 packet.  This\n   includes validation of the puzzle solution,\
    \ generating the\n   Diffie-Hellman key, possibly decrypting the Initiator's Host\n\
    \   Identity, verifying the signature, creating state, and finally\n   sending\
    \ an R2 packet.\n   The following steps define the conceptual processing rules\
    \ for\n   responding to an I2 packet:\n   1.   The system MAY perform checks to\
    \ verify that the I2 packet\n        corresponds to a recently sent R1 packet.\
    \  Such checks are\n        implementation dependent.  See Appendix A for a description\
    \ of\n        an example implementation.\n   2.   The system MUST check that the\
    \ Responder's HIT corresponds to\n        one of its own HITs and MUST drop the\
    \ packet otherwise.\n   3.   The system MUST further check that the Initiator's\
    \ HIT Suite is\n        supported.  The Responder SHOULD silently drop I2 packets\
    \ with\n        unsupported Initiator HITs.\n   4.   If the system's state machine\
    \ is in the R2-SENT state, the\n        system MAY check to see if the newly received\
    \ I2 packet is\n        similar to the one that triggered moving to R2-SENT. \
    \ If so, it\n        MAY retransmit a previously sent R2 packet and reset the\
    \ R2-SENT\n        timer, and the state machine stays in R2-SENT.\n   5.   If\
    \ the system's state machine is in the I2-SENT state, the\n        system MUST\
    \ make a comparison between its local and sender's\n        HITs (similar to the\
    \ comparison method described in\n        Section 6.5).  If the local HIT is smaller\
    \ than the sender's\n        HIT, it should drop the I2 packet, use the peer Diffie-Hellman\n\
    \        key and nonce #I from the R1 packet received earlier, and get\n     \
    \   the local Diffie-Hellman key and nonce #J from the I2 packet\n        sent\
    \ to the peer earlier.  Otherwise, the system should process\n        the received\
    \ I2 packet and drop any previously derived\n        Diffie-Hellman keying material\
    \ Kij it might have formed upon\n        sending the I2 packet previously.  The\
    \ peer Diffie-Hellman key\n        and the nonce #J are taken from the I2 packet\
    \ that just arrived.\n        The local Diffie-Hellman key and the nonce #I are\
    \ the ones that\n        were sent earlier in the R1 packet.\n   6.   If the system's\
    \ state machine is in the I1-SENT state, and the\n        HITs in the I2 packet\
    \ match those used in the previously sent I1\n        packet, the system uses\
    \ this received I2 packet as the basis for\n        the HIP association it was\
    \ trying to form, and stops\n        retransmitting I1 packets (provided that\
    \ the I2 packet passes\n        the additional checks below).\n   7.   If the\
    \ system's state machine is in any state other than\n        R2-SENT, the system\
    \ SHOULD check that the echoed R1 generation\n        counter in the I2 packet\
    \ is within the acceptable range if the\n        counter is included.  Implementations\
    \ MUST accept puzzles from\n        the current generation and MAY accept puzzles\
    \ from earlier\n        generations.  If the generation counter in the newly received\
    \ I2\n        packet is outside the accepted range, the I2 packet is stale\n \
    \       (and perhaps replayed) and SHOULD be dropped.\n   8.   The system MUST\
    \ validate the solution to the puzzle by computing\n        the hash described\
    \ in Section 5.3.3 using the same RHASH\n        algorithm.\n   9.   The I2 packet\
    \ MUST have a single value in the HIP_CIPHER\n        parameter, which MUST match\
    \ one of the values offered to the\n        Initiator in the R1 packet.\n   10.\
    \  The system must derive Diffie-Hellman keying material Kij based\n        on\
    \ the public value and Group ID in the DIFFIE_HELLMAN\n        parameter.  This\
    \ key is used to derive the HIP association keys,\n        as described in Section\
    \ 6.5.  If the Diffie-Hellman Group ID is\n        unsupported, the I2 packet\
    \ is silently dropped.\n   11.  The encrypted HOST_ID is decrypted by the Initiator's\
    \ encryption\n        key defined in Section 6.5.  If the decrypted data is not\
    \ a\n        HOST_ID parameter, the I2 packet is silently dropped.\n   12.  The\
    \ implementation SHOULD also verify that the Initiator's HIT\n        in the I2\
    \ packet corresponds to the Host Identity sent in the I2\n        packet.  (Note:\
    \ some middleboxes may not be able to make this\n        verification.)\n   13.\
    \  The system MUST process the TRANSPORT_FORMAT_LIST parameter.\n        Other\
    \ documents specifying transport formats (e.g., [RFC7402])\n        contain specifications\
    \ for handling any specific transport\n        selected.\n   14.  The system MUST\
    \ verify the HIP_MAC according to the procedures\n        in Section 5.2.12.\n\
    \   15.  The system MUST verify the HIP_SIGNATURE according to\n        Sections\
    \ 5.2.14 and 5.3.3.\n   16.  If the checks above are valid, then the system proceeds\
    \ with\n        further I2 processing; otherwise, it discards the I2 and its\n\
    \        state machine remains in the same state.\n   17.  The I2 packet may have\
    \ the A-bit set -- in this case, the system\n        MAY choose to refuse it by\
    \ dropping the I2 and the state machine\n        returns to state UNASSOCIATED.\
    \  If the A-bit is set, the\n        Initiator's HIT is anonymous and should not\
    \ be stored\n        permanently.\n   18.  The system initializes the remaining\
    \ variables in the associated\n        state, including Update ID counters.\n\
    \   19.  Upon successful processing of an I2 message when the system's\n     \
    \   state machine is in state UNASSOCIATED, I1-SENT, I2-SENT, or\n        R2-SENT,\
    \ an R2 packet is sent and the system's state machine\n        transitions to\
    \ state R2-SENT.\n   20.  Upon successful processing of an I2 packet when the\
    \ system's\n        state machine is in state ESTABLISHED, the old HIP association\n\
    \        is dropped and a new one is installed, an R2 packet is sent, and\n  \
    \      the system's state machine transitions to R2-SENT.\n   21.  Upon the system's\
    \ state machine transitioning to R2-SENT, the\n        system starts a timer.\
    \  The state machine transitions to\n        ESTABLISHED if some data has been\
    \ received on the incoming HIP\n        association, or an UPDATE packet has been\
    \ received (or some\n        other packet that indicates that the peer system's\
    \ state machine\n        has moved to ESTABLISHED).  If the timer expires (allowing\
    \ for a\n        maximal amount of retransmissions of I2 packets), the state\n\
    \        machine transitions to ESTABLISHED.\n"
- title: 6.9.1.  Handling of Malformed Messages
  contents:
  - "6.9.1.  Handling of Malformed Messages\n   If an implementation receives a malformed\
    \ I2 message, the behavior\n   SHOULD depend on how many checks the message has\
    \ already passed.  If\n   the puzzle solution in the message has already been\
    \ checked, the\n   implementation SHOULD report the error by responding with a\
    \ NOTIFY\n   packet.  Otherwise, the implementation MAY respond with an ICMP\n\
    \   message as defined in Section 5.4.\n"
- title: 6.10.  Processing of Incoming R2 Packets
  contents:
  - "6.10.  Processing of Incoming R2 Packets\n   An R2 packet received in state UNASSOCIATED,\
    \ I1-SENT, or ESTABLISHED\n   results in the R2 packet being dropped and the state\
    \ machine staying\n   in the same state.  If an R2 packet is received in state\
    \ I2-SENT, it\n   MUST be processed.\n   The following steps define the conceptual\
    \ processing rules for an\n   incoming R2 packet:\n   1.  If the system is in\
    \ any state other than I2-SENT, the R2 packet\n       is silently dropped.\n \
    \  2.  The system MUST verify that the HITs in use correspond to the\n       HITs\
    \ that were received in the R1 packet that caused the\n       transition to the\
    \ I1-SENT state.\n   3.  The system MUST verify the HIP_MAC_2 according to the\
    \ procedures\n       in Section 5.2.13.\n   4.  The system MUST verify the HIP\
    \ signature according to the\n       procedures in Section 5.2.14.\n   5.  If\
    \ any of the checks above fail, there is a high probability of\n       an ongoing\
    \ man-in-the-middle or other security attack.  The\n       system SHOULD act accordingly,\
    \ based on its local policy.\n   6.  Upon successful processing of the R2 packet,\
    \ the state machine\n       transitions to state ESTABLISHED.\n"
- title: 6.11.  Sending UPDATE Packets
  contents:
  - "6.11.  Sending UPDATE Packets\n   A host sends an UPDATE packet when it intends\
    \ to update some\n   information related to a HIP association.  There are a number\
    \ of\n   possible scenarios when this can occur, e.g., mobility management and\n\
    \   rekeying of an existing ESP Security Association.  The following\n   paragraphs\
    \ define the conceptual rules for sending an UPDATE packet\n   to the peer.  Additional\
    \ steps can be defined in other documents\n   where the UPDATE packet is used.\n\
    \   The sequence of UPDATE messages is indicated by their SEQ parameter.\n   Before\
    \ sending an UPDATE message, the system first determines whether\n   there are\
    \ any outstanding UPDATE messages that may conflict with the\n   new UPDATE message\
    \ under consideration.  When multiple UPDATEs are\n   outstanding (not yet acknowledged),\
    \ the sender must assume that such\n   UPDATEs may be processed in an arbitrary\
    \ order by the receiver.\n   Therefore, any new UPDATEs that depend on a previous\
    \ outstanding\n   UPDATE being successfully received and acknowledged MUST be\
    \ postponed\n   until reception of the necessary ACK(s) occurs.  One way to prevent\n\
    \   any conflicts is to only allow one outstanding UPDATE at a time.\n   However,\
    \ allowing multiple UPDATEs may improve the performance of\n   mobility and multihoming\
    \ protocols.\n   The following steps define the conceptual processing rules for\n\
    \   sending UPDATE packets:\n   1.  The first UPDATE packet is sent with an Update\
    \ ID of zero.\n       Otherwise, the system increments its own Update ID value\
    \ by one\n       before continuing the steps below.\n   2.  The system creates\
    \ an UPDATE packet that contains a SEQ parameter\n       with the current value\
    \ of the Update ID.  The UPDATE packet MAY\n       also include zero or more ACKs\
    \ of the peer's Update ID(s) from\n       previously received UPDATE SEQ parameter(s).\n\
    \   3.  The system sends the created UPDATE packet and starts an UPDATE\n    \
    \   timer.  The default value for the timer is 2 * RTT estimate.  If\n       multiple\
    \ UPDATEs are outstanding, multiple timers are in effect.\n   4.  If the UPDATE\
    \ timer expires, the UPDATE is resent.  The UPDATE\n       can be resent UPDATE_RETRY_MAX\
    \ times.  The UPDATE timer SHOULD be\n       exponentially backed off for subsequent\
    \ retransmissions.  If no\n       acknowledgment is received from the peer after\
    \ UPDATE_RETRY_MAX\n       times, the HIP association is considered to be broken\
    \ and the\n       state machine SHOULD move from state ESTABLISHED to state CLOSING\n\
    \       as depicted in Section 4.4.4.  The UPDATE timer is cancelled upon\n  \
    \     receiving an ACK from the peer that acknowledges receipt of the\n      \
    \ UPDATE.\n"
- title: 6.12.  Receiving UPDATE Packets
  contents:
  - "6.12.  Receiving UPDATE Packets\n   When a system receives an UPDATE packet,\
    \ its processing depends on\n   the state of the HIP association and the presence\
    \ and values of the\n   SEQ and ACK parameters.  Typically, an UPDATE message\
    \ also carries\n   optional parameters whose handling is defined in separate documents.\n\
    \   For each association, a host stores the peer's next expected\n   in-sequence\
    \ Update ID (\"peer Update ID\").  Initially, this value is\n   zero.  Update\
    \ ID comparisons of \"less than\" and \"greater than\" are\n   performed with\
    \ respect to a circular sequence number space.  Hence, a\n   wraparound after\
    \ 2^32 updates has to be expected and MUST be handled\n   accordingly.\n   The\
    \ sender MAY send multiple outstanding UPDATE messages.  These\n   messages are\
    \ processed in the order in which they are received at the\n   receiver (i.e.,\
    \ no resequencing is performed).  When processing\n   UPDATEs out of order, the\
    \ receiver MUST keep track of which UPDATEs\n   were previously processed, so\
    \ that duplicates or retransmissions are\n   ACKed and not reprocessed.  A receiver\
    \ MAY choose to define a receive\n   window of Update IDs that it is willing to\
    \ process at any given time,\n   and discard received UPDATEs falling outside\
    \ of that window.\n   The following steps define the conceptual processing rules\
    \ for\n   receiving UPDATE packets:\n   1.  If there is no corresponding HIP association,\
    \ the implementation\n       MAY reply with an ICMP Parameter Problem, as specified\
    \ in\n       Section 5.4.4.\n   2.  If the association is in the ESTABLISHED state\
    \ and the SEQ (but\n       not ACK) parameter is present, the UPDATE is processed\
    \ and\n       replied to as described in Section 6.12.1.\n   3.  If the association\
    \ is in the ESTABLISHED state and the ACK (but\n       not SEQ) parameter is present,\
    \ the UPDATE is processed as\n       described in Section 6.12.2.\n   4.  If the\
    \ association is in the ESTABLISHED state and there are both\n       an ACK and\
    \ SEQ in the UPDATE, the ACK is first processed as\n       described in Section\
    \ 6.12.2, and then the rest of the UPDATE is\n       processed as described in\
    \ Section 6.12.1.\n"
- title: 6.12.1.  Handling a SEQ Parameter in a Received UPDATE Message
  contents:
  - "6.12.1.  Handling a SEQ Parameter in a Received UPDATE Message\n   The following\
    \ steps define the conceptual processing rules for\n   handling a SEQ parameter\
    \ in a received UPDATE packet:\n   1.  If the Update ID in the received SEQ is\
    \ not the next in the\n       sequence of Update IDs and is greater than the receiver's\
    \ window\n       for new UPDATEs, the packet MUST be dropped.\n   2.  If the Update\
    \ ID in the received SEQ corresponds to an UPDATE\n       that has recently been\
    \ processed, the packet is treated as a\n       retransmission.  The HIP_MAC verification\
    \ (next step) MUST NOT be\n       skipped.  (A byte-by-byte comparison of the\
    \ received packet and a\n       stored packet would be acceptable, though.)  It\
    \ is recommended\n       that a host caches UPDATE packets sent with ACKs to avoid\
    \ the\n       cost of generating a new ACK packet to respond to a replayed\n \
    \      UPDATE.  The system MUST acknowledge, again, such (apparent)\n       UPDATE\
    \ message retransmissions but SHOULD also consider rate-\n       limiting such\
    \ retransmission responses to guard against replay\n       attacks.\n   3.  The\
    \ system MUST verify the HIP_MAC in the UPDATE packet.  If the\n       verification\
    \ fails, the packet MUST be dropped.\n   4.  The system MAY verify the SIGNATURE\
    \ in the UPDATE packet.  If the\n       verification fails, the packet SHOULD\
    \ be dropped and an error\n       message logged.\n   5.  If a new SEQ parameter\
    \ is being processed, the parameters in the\n       UPDATE are then processed.\
    \  The system MUST record the Update ID\n       in the received SEQ parameter,\
    \ for replay protection.\n   6.  An UPDATE acknowledgment packet with the ACK\
    \ parameter is\n       prepared and sent to the peer.  This ACK parameter MAY\
    \ be\n       included in a separate UPDATE or piggybacked in an UPDATE with\n\
    \       the SEQ parameter, as described in Section 5.3.5.  The ACK\n       parameter\
    \ MAY acknowledge more than one of the peer's Update IDs.\n"
- title: 6.12.2.  Handling an ACK Parameter in a Received UPDATE Packet
  contents:
  - "6.12.2.  Handling an ACK Parameter in a Received UPDATE Packet\n   The following\
    \ steps define the conceptual processing rules for\n   handling an ACK parameter\
    \ in a received UPDATE packet:\n   1.  The sequence number reported in the ACK\
    \ must match with an UPDATE\n       packet sent earlier that has not already been\
    \ acknowledged.  If\n       no match is found or if the ACK does not acknowledge\
    \ a new\n       UPDATE, then either the packet MUST be dropped if no SEQ\n   \
    \    parameter is present, or the processing steps in Section 6.12.1\n       are\
    \ followed.\n   2.  The system MUST verify the HIP_MAC in the UPDATE packet. \
    \ If the\n       verification fails, the packet MUST be dropped.\n   3.  The system\
    \ MAY verify the SIGNATURE in the UPDATE packet.  If the\n       verification\
    \ fails, the packet SHOULD be dropped and an error\n       message logged.\n \
    \  4.  The corresponding UPDATE timer is stopped (see Section 6.11) so\n     \
    \  that the now-acknowledged UPDATE is no longer retransmitted.  If\n       multiple\
    \ UPDATEs are acknowledged, multiple timers are stopped.\n"
- title: 6.13.  Processing of NOTIFY Packets
  contents:
  - "6.13.  Processing of NOTIFY Packets\n   Processing of NOTIFY packets is OPTIONAL.\
    \  If processed, any errors\n   in a received NOTIFICATION parameter SHOULD be\
    \ logged.  Received\n   errors MUST be considered only as informational, and the\
    \ receiver\n   SHOULD NOT change its HIP state (see Section 4.4.2) purely based\
    \ on\n   the received NOTIFY message.\n"
- title: 6.14.  Processing of CLOSE Packets
  contents:
  - "6.14.  Processing of CLOSE Packets\n   When the host receives a CLOSE message,\
    \ it responds with a CLOSE_ACK\n   message and moves to the CLOSED state.  (The\
    \ authenticity of the\n   CLOSE message is verified using both HIP_MAC and SIGNATURE.)\
    \  This\n   processing applies whether or not the HIP association state is\n \
    \  CLOSING, in order to handle simultaneous CLOSE messages from both\n   ends\
    \ that cross in flight.\n   The HIP association is not discarded before the host\
    \ moves to the\n   UNASSOCIATED state.\n   Once the closing process has started,\
    \ any new need to send data\n   packets triggers the creation and establishment\
    \ of a new HIP\n   association, starting with sending an I1 packet.\n   If there\
    \ is no corresponding HIP association, the CLOSE packet is\n   dropped.\n"
- title: 6.15.  Processing of CLOSE_ACK Packets
  contents:
  - "6.15.  Processing of CLOSE_ACK Packets\n   When a host receives a CLOSE_ACK message,\
    \ it verifies that it is in\n   the CLOSING or CLOSED state and that the CLOSE_ACK\
    \ was in response to\n   the CLOSE.  A host can map CLOSE_ACK messages to CLOSE\
    \ messages by\n   comparing the value of ECHO_REQUEST_SIGNED (in the CLOSE packet)\
    \ to\n   the value of ECHO_RESPONSE_SIGNED (in the CLOSE_ACK packet).\n   The\
    \ CLOSE_ACK contains the HIP_MAC and the SIGNATURE parameters for\n   verification.\
    \  The state is discarded when the state changes to\n   UNASSOCIATED and, after\
    \ that, the host MAY respond with an ICMP\n   Parameter Problem to an incoming\
    \ CLOSE message (see Section 5.4.4).\n"
- title: 6.16.  Handling State Loss
  contents:
  - "6.16.  Handling State Loss\n   In the case of a system crash and unanticipated\
    \ state loss, the\n   system SHOULD delete the corresponding HIP state, including\
    \ the\n   keying material.  That is, the state SHOULD NOT be stored in\n   long-term\
    \ storage.  If the implementation does drop the state\n   (as RECOMMENDED), it\
    \ MUST also drop the peer's R1 generation counter\n   value, unless a local policy\
    \ explicitly defines that the value of\n   that particular host is stored.  An\
    \ implementation MUST NOT store a\n   peer's R1 generation counters by default,\
    \ but storing R1 generation\n   counter values, if done, MUST be configured by\
    \ explicit HITs.\n"
- title: 7.  HIP Policies
  contents:
  - "7.  HIP Policies\n   There are a number of variables that will influence the\
    \ HIP base\n   exchanges that each host must support.  All HIP implementations\
    \ MUST\n   support more than one simultaneous HI, at least one of which SHOULD\n\
    \   be reserved for anonymous usage.  Although anonymous HIs will be\n   rarely\
    \ used as Responders' HIs, they will be common for Initiators.\n   Support for\
    \ more than two HIs is RECOMMENDED.\n   Initiators MAY use a different HI for\
    \ different Responders to provide\n   basic privacy.  Whether such private HIs\
    \ are used repeatedly with the\n   same Responder, and how long these HIs are\
    \ used, are decided by local\n   policy and depend on the privacy requirements\
    \ of the Initiator.\n   The value of #K used in the HIP R1 must be chosen with\
    \ care.  Values\n   of #K that are too high will exclude clients with weak CPUs\
    \ because\n   these devices cannot solve the puzzle within a reasonable amount\
    \ of\n   time.  #K should only be raised if a Responder is under high load,\n\
    \   i.e., it cannot process all incoming HIP handshakes any more.  If a\n   Responder\
    \ is not under high load, #K SHOULD be 0.\n   Responders that only respond to\
    \ selected Initiators require an Access\n   Control List (ACL), representing for\
    \ which hosts they accept HIP base\n   exchanges, and the preferred transport\
    \ format and local lifetimes.\n   Wildcarding SHOULD be supported for such ACLs,\
    \ and also for\n   Responders that offer public or anonymous services.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   HIP is designed to provide secure authentication\
    \ of hosts.  HIP also\n   attempts to limit the exposure of the host to various\
    \ denial-of-\n   service and man-in-the-middle (MitM) attacks.  In doing so, HIP\n\
    \   itself is subject to its own DoS and MitM attacks that potentially\n   could\
    \ be more damaging to a host's ability to conduct business as\n   usual.\n   Denial-of-service\
    \ attacks often take advantage of asymmetries in the\n   cost of starting an association.\
    \  One example of such asymmetry is\n   the need of a Responder to store local\
    \ state while a malicious\n   Initiator can stay stateless.  HIP makes no attempt\
    \ to increase the\n   cost of the start of state at the Initiator, but makes an\
    \ effort to\n   reduce the cost for the Responder.  This is accomplished by having\n\
    \   the Responder start the 3-way exchange instead of the Initiator,\n   making\
    \ the HIP exchange 4 packets long.  In doing this, the first\n   packet from the\
    \ Responder, R1, becomes a 'stock' packet that the\n   Responder MAY use many\
    \ times, until some Initiator has provided a\n   valid response to such an R1\
    \ packet.  During an I1 packet storm, the\n   host may reuse the same DH value\
    \ also, even if some Initiator has\n   provided a valid response using that particular\
    \ DH value.  However,\n   such behavior is discouraged and should be avoided.\
    \  Using the same\n   Diffie-Hellman values and random puzzle #I value has some\
    \ risks.\n   This risk needs to be balanced against a potential storm of HIP I1\n\
    \   packets.\n   This shifting of the start of state cost to the Initiator in\
    \ creating\n   the I2 HIP packet presents another DoS attack.  The attacker can\n\
    \   spoof the I1 packet, and the Responder sends out the R1 HIP packet.\n   This\
    \ could conceivably tie up the 'Initiator' with evaluating the R1\n   HIP packet,\
    \ and creating the I2 packet.  The defense against this\n   attack is to simply\
    \ ignore any R1 packet where a corresponding I1\n   packet was not sent (as defined\
    \ in Section 6.8, step 1).\n   The R1 packet is considerably larger than the I1\
    \ packet.  This\n   asymmetry can be exploited in a reflection attack.  A malicious\n\
    \   attacker could spoof the IP address of a victim and send a flood of\n   I1\
    \ messages to a powerful Responder.  For each small I1 packet, the\n   Responder\
    \ would send a larger R1 packet to the victim.  The\n   difference in packet sizes\
    \ can further amplify a flooding attack\n   against the victim.  To avoid such\
    \ reflection attacks, the Responder\n   SHOULD rate-limit the sending of R1 packets\
    \ in general or SHOULD\n   rate-limit the sending of R1 packets to a specific\
    \ IP address.\n   Floods of forged I2 packets form a second kind of DoS attack.\
    \  Once\n   the attacking Initiator has solved the puzzle, it can send packets\n\
    \   with spoofed IP source addresses with either an invalid HIP signature\n  \
    \ or invalid encrypted HIP payload (in the ENCRYPTED parameter).  This\n   would\
    \ take resources in the Responder's part to reach the point to\n   discover that\
    \ the I2 packet cannot be completely processed.  The\n   defense against this\
    \ attack is that after N bad I2 packets with the\n   same puzzle solution, the\
    \ Responder would discard any I2 packets that\n   contain the given solution.\
    \  This will shut down the attack.  The\n   attacker would have to request another\
    \ R1 packet and use that to\n   launch a new attack.  The Responder could increase\
    \ the value of #K\n   while under attack.  Keeping a list of solutions from malformed\n\
    \   packets requires that the Responder keeps state for these malformed\n   I2\
    \ packets.  This state has to be kept until the R1 counter is\n   increased. \
    \ As malformed packets are generally filtered by their\n   checksum before signature\
    \ verification, only solutions in packets\n   that are forged to pass the checksum\
    \ and puzzle are put into the\n   blacklist.  In addition, a valid puzzle is required\
    \ before a new list\n   entry is created.  Hence, attackers that intend to flood\
    \ the\n   blacklist must solve puzzles first.\n   A third form of DoS attack is\
    \ emulating the restart of state after a\n   reboot of one of the peers.  A restarting\
    \ host would send an I1\n   packet to the peers, which would respond with an R1\
    \ packet even if it\n   were in the ESTABLISHED state.  If the I1 packet were\
    \ spoofed, the\n   resulting R1 packet would be received unexpectedly by the spoofed\n\
    \   host and would be dropped, as in the first case above.\n   A fourth form of\
    \ DoS attack is emulating the closing of the HIP\n   association.  HIP relies\
    \ on timers and a CLOSE/CLOSE_ACK handshake to\n   explicitly signal the end of\
    \ a HIP association.  Because both CLOSE\n   and CLOSE_ACK messages contain a\
    \ HIP_MAC, an outsider cannot close a\n   connection.  The presence of an additional\
    \ SIGNATURE allows\n   middleboxes to inspect these messages and discard the associated\n\
    \   state (e.g., for firewalling, SPI-based NATing, etc.).  However, the\n   optional\
    \ behavior of replying to CLOSE with an ICMP Parameter Problem\n   packet (as\
    \ described in Section 5.4.4) might allow an attacker\n   spoofing the source\
    \ IP address to send CLOSE messages to launch\n   reflection attacks.\n   A fifth\
    \ form of DoS attack is replaying R1s to cause the Initiator to\n   solve stale\
    \ puzzles and become out of synchronization with the\n   Responder.  The R1 generation\
    \ counter is a monotonically increasing\n   counter designed to protect against\
    \ this attack, as described in\n   Section 4.1.4.\n   Man-in-the-middle attacks\
    \ are difficult to defend against, without\n   third-party authentication.  A\
    \ skillful MitM could easily handle all\n   parts of HIP, but HIP indirectly provides\
    \ the following protection\n   from a MitM attack.  If the Responder's HI is retrieved\
    \ from a signed\n   DNS zone, a certificate, or through some other secure means,\
    \ the\n   Initiator can use this to validate the R1 HIP packet.\n   Likewise,\
    \ if the Initiator's HI is in a secure DNS zone, a trusted\n   certificate, or\
    \ otherwise securely available, the Responder can\n   retrieve the HI (after having\
    \ got the I2 HIP packet) and verify that\n   the HI indeed can be trusted.\n \
    \  The HIP \"opportunistic mode\" concept has been introduced in this\n   document,\
    \ but this document does not specify what the semantics of\n   such a connection\
    \ setup are for applications.  There are certain\n   concerns with opportunistic\
    \ mode, as discussed in Section 4.1.8.\n   NOTIFY messages are used only for informational\
    \ purposes, and they\n   are unacknowledged.  A HIP implementation cannot rely\
    \ solely on the\n   information received in a NOTIFY message because the packet\
    \ may have\n   been replayed.  An implementation SHOULD NOT change any state\n\
    \   information purely based on a received NOTIFY message.\n   Since not all hosts\
    \ will ever support HIP, ICMP 'Destination Protocol\n   Unreachable' messages\
    \ are to be expected and may be used for a DoS\n   attack.  Against an Initiator,\
    \ the attack would look like the\n   Responder does not support HIP, but shortly\
    \ after receiving the ICMP\n   message, the Initiator would receive a valid R1\
    \ HIP packet.  Thus, to\n   protect against this attack, an Initiator SHOULD NOT\
    \ react to an ICMP\n   message until a reasonable delta time to get the real Responder's\
    \ R1\n   HIP packet.  A similar attack against the Responder is more involved.\n\
    \   Normally, if an I1 message received by a Responder was a bogus one\n   sent\
    \ by an attacker, the Responder may receive an ICMP message from\n   the IP address\
    \ the R1 message was sent to.  However, a sophisticated\n   attacker can try to\
    \ take advantage of such behavior and try to break\n   up the HIP base exchange\
    \ by sending such an ICMP message to the\n   Responder before the Initiator has\
    \ a chance to send a valid I2\n   message.  Hence, the Responder SHOULD NOT act\
    \ on such an ICMP\n   message.  Especially, it SHOULD NOT remove any minimal state\
    \ created\n   when it sent the R1 HIP packet (if it did create one), but wait\
    \ for\n   either a valid I2 HIP packet or the natural timeout (that is, if R1\n\
    \   packets are tracked at all).  Likewise, the Initiator SHOULD ignore\n   any\
    \ ICMP message while waiting for an R2 HIP packet, and SHOULD\n   delete any pending\
    \ state only after a natural timeout.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   IANA has reserved protocol number 139 for the Host\
    \ Identity Protocol\n   and included it in the \"IPv6 Extension Header Types\"\
    \ registry\n   [RFC7045] and the \"Assigned Internet Protocol Numbers\" registry.\
    \  The\n   reference in both of these registries has been updated from [RFC5201]\n\
    \   to this specification.\n   The reference to the 128-bit value under the CGA\
    \ Message Type\n   namespace [RFC3972] of \"0xF0EF F02F BFF4 3D0F E793 0C3C 6E61\
    \ 74EA\"\n   has been changed from [RFC5201] to this specification.\n   The following\
    \ changes to the \"Host Identity Protocol (HIP)\n   Parameters\" have been made.\
    \  In many cases, the changes involved\n   updating the reference from [RFC5201]\
    \ to this specification, but\n   there are some differences as outlined below.\
    \  Allocation terminology\n   is defined in [RFC5226]; any existing references\
    \ to \"IETF Consensus\"\n   can be replaced with \"IETF Review\" as per [RFC5226].\n\
    \   HIP Version\n      This document adds the value \"2\" to the existing registry.\
    \  The\n      value of \"1\" has been left with a reference to [RFC5201].\n  \
    \ Packet Type\n      The 7-bit Packet Type field in a HIP protocol packet describes\
    \ the\n      type of a HIP protocol message.  It is defined in Section 5.1.\n\
    \      All existing values referring to [RFC5201] have been updated to\n     \
    \ refer to this specification.  Other values have been left\n      unchanged.\n\
    \   HIT Suite ID\n      This specification creates a new registry for \"HIT Suite\
    \ ID\".\n      This is different than the existing registry for \"Suite ID\",\
    \ which\n      can be left unmodified for version 1 of the protocol ([RFC5201]).\n\
    \      The registry has been closed to new registrations.\n      The four-bit\
    \ HIT Suite ID uses the OGA ID field in the ORCHID to\n      express the type\
    \ of the HIT.  This document defines three HIT\n      Suites (see Section 5.2.10).\n\
    \      The HIT Suite ID is also carried in the four higher-order bits of\n   \
    \   the ID field in the HIT_SUITE_LIST parameter.  The four\n      lower-order\
    \ bits are reserved for future extensions of the HIT\n      Suite ID space beyond\
    \ 16 values.\n      For the time being, the HIT Suite uses only four bits because\n\
    \      these bits have to be carried in the HIT.  Using more bits for the\n  \
    \    HIT Suite ID reduces the cryptographic strength of the HIT.  HIT\n      Suite\
    \ IDs must be allocated carefully to avoid namespace\n      exhaustion.  Moreover,\
    \ deprecated IDs should be reused after an\n      appropriate time span.  If 15\
    \ Suite IDs (the zero value is\n      initially reserved) prove to be insufficient\
    \ and more HIT Suite\n      IDs are needed concurrently, more bits can be used\
    \ for the HIT\n      Suite ID by using one HIT Suite ID (0) to indicate that more\
    \ bits\n      should be used.  The HIT_SUITE_LIST parameter already supports\n\
    \      8-bit HIT Suite IDs, should longer IDs be needed.  However,\n      RFC\
    \ 7343 [RFC7343] does not presently support such an extension.\n      We suggest\
    \ trying the rollover approach described in Appendix E\n      first.  Possible\
    \ extensions of the HIT Suite ID space to\n      accommodate eight bits and new\
    \ HIT Suite IDs are defined through\n      IETF Review.\n      Requests to register\
    \ reused values should include a note that the\n      value is being reused after\
    \ a deprecation period, to ensure\n      appropriate IETF review and approval.\n\
    \   Parameter Type\n      The 16-bit Type field in a HIP parameter describes the\
    \ type of the\n      parameter.  It is defined in Section 5.2.1.  The current\
    \ values\n      are defined in Sections 5.2.3 through 5.2.23.  The existing\n\
    \      \"Parameter Types\" registry has been updated as follows.\n      A new\
    \ value (129) for R1_COUNTER has been introduced, with a\n      reference to this\
    \ specification, and the existing value (128) for\n      R1_COUNTER has been left\
    \ in place with a reference to [RFC5201].\n      This documents the change in\
    \ value that has occurred in version 2\n      of this protocol.  For clarity,\
    \ the name for the value 128 has\n      been changed from \"R1_COUNTER\" to \"\
    R1_Counter (v1 only)\".\n      A new value (579) for a new Parameter Type HIP_CIPHER\
    \ has been\n      added, with reference to this specification.  This Parameter\
    \ Type\n      functionally replaces the HIP_TRANSFORM Parameter Type\n      (value\
    \ 577), which has been left in the table with the existing\n      reference to\
    \ [RFC5201].  For clarity, the name for the\n      value 577 has been changed\
    \ from \"HIP_TRANSFORM\" to\n      \"HIP_TRANSFORM (v1 only)\".\n      A new value\
    \ (715) for a new Parameter Type HIT_SUITE_LIST has been\n      added, with reference\
    \ to this specification.\n      A new value (2049) for a new Parameter Type TRANSPORT_FORMAT_LIST\n\
    \      has been added, with reference to this specification.\n      The name of\
    \ the HMAC Parameter Type (value 61505) has been changed\n      to HIP_MAC.  The\
    \ name of the HMAC_2 Parameter Type (value 61569)\n      has been changed to HIP_MAC_2.\
    \  The reference has been changed to\n      this specification.\n      All other\
    \ Parameter Types that reference [RFC5201] have been\n      updated to refer to\
    \ this specification, and Parameter Types that\n      reference other RFCs are\
    \ unchanged.\n      The Type codes 32768 through 49151 (not 49141: a value corrected\n\
    \      from a previous version of this table) have been Reserved for\n      Private\
    \ Use.  Implementors SHOULD select types in a random fashion\n      from this\
    \ range, thereby reducing the probability of collisions.\n      A method employing\
    \ genuine randomness (such as flipping a coin)\n      SHOULD be used.\n      Where\
    \ the existing ranges once stated \"First Come First Served\n      with Specification\
    \ Required\", this has been changed to\n      \"Specification Required\".\n  \
    \ Group ID\n      The eight-bit Group ID values appear in the DIFFIE_HELLMAN\n\
    \      parameter and the DH_GROUP_LIST parameter and are defined in\n      Section\
    \ 5.2.7.  This registry has been updated based on the new\n      values specified\
    \ in Section 5.2.7; values noted as being\n      DEPRECATED can be left in the\
    \ table with reference to [RFC5201].\n      New values are assigned through IETF\
    \ Review.\n   HIP Cipher ID\n      The 16-bit Cipher ID values in a HIP_CIPHER\
    \ parameter are defined\n      in Section 5.2.8.  This is a new registry.  New\
    \ values from either\n      the reserved or unassigned space are assigned through\
    \ IETF Review.\n   DI-Type\n      The four-bit DI-Type values in a HOST_ID parameter\
    \ are defined in\n      Section 5.2.9.  New values are assigned through IETF Review.\
    \  All\n      existing values referring to [RFC5201] have been updated to refer\n\
    \      to this specification.\n   HI Algorithm\n      The 16-bit Algorithm values\
    \ in a HOST_ID parameter are defined in\n      Section 5.2.9.  This is a new registry.\
    \  New values from either\n      the reserved or unassigned space are assigned\
    \ through IETF Review.\n   ECC Curve Label\n      When the HI Algorithm values\
    \ in a HOST_ID parameter are defined to\n      the values of either \"ECDSA\"\
    \ or \"ECDSA_LOW\", a new registry is\n      needed to maintain the values for\
    \ the ECC Curve Label as defined\n      in Section 5.2.9.  This might be handled\
    \ by specifying two\n      algorithm-specific subregistries named \"ECDSA Curve\
    \ Label\" and\n      \"ECDSA_LOW Curve Label\".  New values are to be assigned\
    \ through\n      IETF Review.\n   Notify Message Type\n      The 16-bit Notify\
    \ Message Type values in a NOTIFICATION parameter\n      are defined in Section\
    \ 5.2.19.\n      Notify Message Type values 1-10 are used for informing about\n\
    \      errors in packet structures, values 11-20 for informing about\n      problems\
    \ in parameters containing cryptographic related material,\n      and values 21-30\
    \ for informing about problems in authentication or\n      packet integrity verification.\
    \  Parameter numbers above 30 can be\n      used for informing about other types\
    \ of errors or events.\n      The existing registration procedures have been updated\
    \ as follows.\n      The range from 1-50 can remain as \"IETF Review\".  The range\
    \ from\n      51-8191 has been marked as \"Specification Required\".  Values\n\
    \      8192-16383 remain as \"Reserved for Private Use\".  Values\n      16384-40959\
    \ have been marked as \"Specification Required\".  Values\n      40960-65535 remain\
    \ as \"Reserved for Private Use\".\n      The following updates to the values\
    \ have been made to the existing\n      registry.  All existing values referring\
    \ to [RFC5201] have been\n      updated to refer to this specification.\n    \
    \  INVALID_HIP_TRANSFORM_CHOSEN has been renamed to\n      INVALID_HIP_CIPHER_CHOSEN\
    \ with the same value (17).\n      A new value of 20 for the type UNSUPPORTED_HIT_SUITE\
    \ has been\n      added.\n      HMAC_FAILED has been renamed to HIP_MAC_FAILED\
    \ with the same\n      value (28).\n      SERVER_BUSY_PLEASE_RETRY has been renamed\
    \ to\n      RESPONDER_BUSY_PLEASE_RETRY with the same value (44).\n"
- title: 10.  Differences from RFC 5201
  contents:
  - "10.  Differences from RFC 5201\n   This section summarizes the technical changes\
    \ made from [RFC5201].\n   This section is informational, intended to help implementors\
    \ of the\n   previous protocol version.  If any text in this section contradicts\n\
    \   text in other portions of this specification, the text found outside\n   of\
    \ this section should be considered normative.\n   This document specifies the\
    \ HIP Version 2 protocol, which is not\n   interoperable with the HIP Version\
    \ 1 protocol specified in [RFC5201].\n   The main technical changes are the inclusion\
    \ of additional\n   cryptographic agility features, and an update of the mandatory\
    \ and\n   optional algorithms, including Elliptic Curve support via the\n   Elliptic\
    \ Curve DSA (ECDSA) and Elliptic Curve Diffie-Hellman (ECDH)\n   algorithms. \
    \ The mandatory cryptographic algorithm implementations\n   have been updated,\
    \ such as replacing HMAC-SHA-1 with HMAC-SHA-256 and\n   the RSA/SHA-1 signature\
    \ algorithm with RSASSA-PSS, and adding ECDSA\n   to RSA as mandatory public key\
    \ types.  This version of HIP is also\n   aligned with the ORCHID revision [RFC7343].\n\
    \   The following changes have been made to the protocol operation.\n   o  Section\
    \ 4.1.3 describes the new process for Diffie-Hellman group\n      negotiation,\
    \ an aspect of cryptographic agility.  The Initiator\n      may express a preference\
    \ for the choice of a DH group in the I1\n      packet and may suggest multiple\
    \ possible choices.  The Responder\n      replies with a preference based on local\
    \ policy and the options\n      provided by the Initiator.  The Initiator may\
    \ restart the base\n      exchange if the option chosen by the Responder is unsuitable\n\
    \      (unsupported algorithms).\n   o  Another aspect of cryptographic agility\
    \ that has been added is the\n      ability to use different cryptographic hash\
    \ functions to generate\n      the HIT.  The Responder's HIT hash algorithm (RHASH)\
    \ terminology\n      was introduced to support this.  In addition, HIT Suites\
    \ have been\n      introduced to group the set of cryptographic algorithms used\n\
    \      together for public key signature, hash function, and hash\n      truncation.\
    \  The use of HIT Suites constrains the combinatorial\n      possibilities of\
    \ algorithm selection for different functions.  HIT\n      Suite IDs are related\
    \ to the ORCHID OGA ID field ([RFC7343]).\n   o  The puzzle mechanism has been\
    \ slightly changed, in that the #I\n      parameter depends on the HIT hash function\
    \ (RHASH) selected, and\n      the specification now advises against reusing the\
    \ same #I value to\n      the same Initiator; more details are provided in Sections\
    \ 4.1.2\n      and 5.2.4).\n   o  Section 4.1.4 was extended to cover details\
    \ about R1 generation\n      counter rollover or reset.\n   o  Section 4.1.6 was\
    \ added to describe procedures for aborting a HIP\n      base exchange.\n   o\
    \  Section 4.1.7 provides guidance on avoiding downgrade attacks on\n      the\
    \ cryptographic algorithms.\n   o  Section 4.1.8 on opportunistic mode has been\
    \ updated to account\n      for cryptographic agility by adding HIT selection\
    \ procedures.\n   o  The HIP KEYMAT generation has been updated as described in\n\
    \      Section 6.5 to make the key derivation function a negotiable\n      aspect\
    \ of the protocol.\n   o  Packet processing for the I1, R1, and I2 packets has\
    \ been updated\n      to account for new parameter processing.\n   o  This specification\
    \ adds a requirement that hosts MUST support\n      processing of ACK parameters\
    \ with several SEQ sequence numbers\n      even when they do not support sending\
    \ such parameters.\n   o  This document now clarifies that several ECHO_REQUEST_UNSIGNED\n\
    \      parameters may be present in an R1 and that several ECHO_RESPONSE\n   \
    \   parameters may be present in an I2.\n   o  Procedures for responding to version\
    \ mismatches with an ICMP\n      Parameter Problem have been added.\n   o  The\
    \ security considerations section (Section 8) has been updated\n      to remove\
    \ possible attacks no longer considered applicable.\n   o  The use of the Anonymous\
    \ bit for making the sender's Host Identity\n      anonymous is now supported\
    \ in packets other than the R1 and I2.\n   o  Support for the use of a NULL HIP\
    \ CIPHER is explicitly limited to\n      debugging and testing HIP and is no longer\
    \ a mandatory algorithm\n      to support.\n   The following changes have been\
    \ made to the parameter types and\n   encodings (Section 5.2).\n   o  Four new\
    \ parameter types have been added: DH_GROUP_LIST,\n      HIP_CIPHER, HIT_SUITE_LIST,\
    \ and TRANSPORT_FORMAT_LIST.\n   o  Two parameter types have been renamed: HMAC\
    \ has been renamed to\n      HIP_MAC, and HMAC2 has been renamed to HIP_MAC_2.\n\
    \   o  One parameter type is deprecated: HIP_TRANSFORM.  Functionally, it\n  \
    \    has been replaced by the HIP_CIPHER but with slightly different\n      semantics\
    \ (hashes have been removed and are now determined by\n      RHASH).\n   o  The\
    \ TRANSPORT_FORMAT_LIST parameter allows transports to be\n      negotiated with\
    \ the list instead of by their order in the\n      HIP packet.\n   o  The type\
    \ code for the R1_COUNTER has been changed from 128 to 129\n      to reflect that\
    \ it is now considered a Critical parameter and must\n      be echoed when present\
    \ in R1.\n   o  The PUZZLE and SOLUTION parameter lengths are now variable and\n\
    \      dependent on the RHASH length.\n   o  The Diffie-Hellman Group IDs supported\
    \ have been updated.\n   o  The HOST_ID parameter now requires specification of\
    \ an Algorithm.\n   o  The NOTIFICATION parameter supports new Notify Message\
    \ Type\n      values.\n   o  The HIP_SIGNATURE algorithm field has been changed\
    \ from 8 bits to\n      16 bits to achieve alignment with the HOST_ID parameters.\n\
    \   o  The specification clarifies that the SEQ parameter always contains\n  \
    \    one update ID but that the ACK parameter may acknowledge several\n      update\
    \ IDs.\n   o  The restriction that only one ECHO_RESPONSE_UNSIGNED parameter\n\
    \      must be present in each HIP packet has been removed.\n   o  The document\
    \ creates a new type range allocation for parameters\n      that are only covered\
    \ by a signature if a signature is present and\n      applies it to the newly\
    \ created DH_GROUP_LIST parameter.\n   o  The document clarifies that several\
    \ NOTIFY parameters may be\n      present in a packet.\n   The following changes\
    \ have been made to the packet contents\n   (Section 5.3).\n   o  The I1 packet\
    \ now carries the Initiator's DH_GROUP_LIST.\n   o  The R1 packet now carries\
    \ the HIP_CIPHER, HIT_SUITE_LIST,\n      DH_GROUP_LIST, and TRANSPORT_FORMAT_LIST\
    \ parameters.\n   o  The I2 packet now carries the HIP_CIPHER and TRANSPORT_FORMAT_LIST\n\
    \      parameters.\n   o  This document clarifies that UPDATE packets that do\
    \ not contain\n      either a SEQ or ACK parameter are invalid.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [FIPS.180-4.2012]\n              National Institute\
    \ of Standards and Technology, \"Secure\n              Hash Standard (SHS)\",\
    \ FIPS PUB 180-4, March 2012,\n              <http://csrc.nist.gov/publications/fips/fips180-4/\n\
    \              fips-180-4.pdf>.\n   [NIST.800-131A.2011]\n              National\
    \ Institute of Standards and Technology,\n              \"Transitions: Recommendation\
    \ for Transitioning the Use of\n              Cryptographic Algorithms and Key\
    \ Lengths\", NIST\n              SP 800-131A, January 2011, <http://csrc.nist.gov/\n\
    \              publications/nistpubs/800-131A/sp800-131A.pdf>.\n   [RFC0768] \
    \ Postel, J., \"User Datagram Protocol\", STD 6, RFC 768,\n              August\
    \ 1980, <http://www.rfc-editor.org/info/rfc768>.\n   [RFC0793]  Postel, J., \"\
    Transmission Control Protocol\", STD 7,\n              RFC 793, September 1981,\
    \ <http://www.rfc-editor.org/\n              info/rfc793>.\n   [RFC1035]  Mockapetris,\
    \ P., \"Domain names - implementation and\n              specification\", STD\
    \ 13, RFC 1035, November 1987,\n              <http://www.rfc-editor.org/info/rfc1035>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC2404]  Madson, C. and R. Glenn, \"The Use of HMAC-SHA-1-96 within\n  \
    \            ESP and AH\", RFC 2404, November 1998,\n              <http://www.rfc-editor.org/info/rfc2404>.\n\
    \   [RFC2410]  Glenn, R. and S. Kent, \"The NULL Encryption Algorithm and\n  \
    \            Its Use With IPsec\", RFC 2410, November 1998,\n              <http://www.rfc-editor.org/info/rfc2410>.\n\
    \   [RFC2460]  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n   \
    \           (IPv6) Specification\", RFC 2460, December 1998,\n              <http://www.rfc-editor.org/info/rfc2460>.\n\
    \   [RFC2536]  Eastlake 3rd, D., \"DSA KEYs and SIGs in the Domain Name\n    \
    \          System (DNS)\", RFC 2536, March 1999,\n              <http://www.rfc-editor.org/info/rfc2536>.\n\
    \   [RFC3110]  Eastlake 3rd, D., \"RSA/SHA-1 SIGs and RSA KEYs in the\n      \
    \        Domain Name System (DNS)\", RFC 3110, May 2001,\n              <http://www.rfc-editor.org/info/rfc3110>.\n\
    \   [RFC3526]  Kivinen, T. and M. Kojo, \"More Modular Exponential (MODP)\n  \
    \            Diffie-Hellman groups for Internet Key Exchange (IKE)\",\n      \
    \        RFC 3526, May 2003, <http://www.rfc-editor.org/\n              info/rfc3526>.\n\
    \   [RFC3602]  Frankel, S., Glenn, R., and S. Kelly, \"The AES-CBC Cipher\n  \
    \            Algorithm and Its Use with IPsec\", RFC 3602,\n              September\
    \ 2003, <http://www.rfc-editor.org/info/rfc3602>.\n   [RFC3972]  Aura, T., \"\
    Cryptographically Generated Addresses (CGA)\",\n              RFC 3972, March\
    \ 2005, <http://www.rfc-editor.org/\n              info/rfc3972>.\n   [RFC4034]\
    \  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,\
    \ \"Resource Records for the DNS Security Extensions\",\n              RFC 4034,\
    \ March 2005, <http://www.rfc-editor.org/\n              info/rfc4034>.\n   [RFC4282]\
    \  Aboba, B., Beadles, M., Arkko, J., and P. Eronen, \"The\n              Network\
    \ Access Identifier\", RFC 4282, December 2005,\n              <http://www.rfc-editor.org/info/rfc4282>.\n\
    \   [RFC4443]  Conta, A., Deering, S., and M. Gupta, \"Internet Control\n    \
    \          Message Protocol (ICMPv6) for the Internet Protocol\n             \
    \ Version 6 (IPv6) Specification\", RFC 4443, March 2006,\n              <http://www.rfc-editor.org/info/rfc4443>.\n\
    \   [RFC4754]  Fu, D. and J. Solinas, \"IKE and IKEv2 Authentication Using\n \
    \             the Elliptic Curve Digital Signature Algorithm (ECDSA)\",\n    \
    \          RFC 4754, January 2007, <http://www.rfc-editor.org/\n             \
    \ info/rfc4754>.\n   [RFC4868]  Kelly, S. and S. Frankel, \"Using HMAC-SHA-256,\n\
    \              HMAC-SHA-384, and HMAC-SHA-512 with IPsec\", RFC 4868,\n      \
    \        May 2007, <http://www.rfc-editor.org/info/rfc4868>.\n   [RFC5702]  Jansen,\
    \ J., \"Use of SHA-2 Algorithms with RSA in DNSKEY\n              and RRSIG Resource\
    \ Records for DNSSEC\", RFC 5702,\n              October 2009, <http://www.rfc-editor.org/info/rfc5702>.\n\
    \   [RFC6724]  Thaler, D., Draves, R., Matsumoto, A., and T. Chown,\n        \
    \      \"Default Address Selection for Internet Protocol Version 6\n         \
    \     (IPv6)\", RFC 6724, September 2012,\n              <http://www.rfc-editor.org/info/rfc6724>.\n\
    \   [RFC7343]  Laganier, J. and F. Dupont, \"An IPv6 Prefix for Overlay\n    \
    \          Routable Cryptographic Hash Identifiers Version 2\n              (ORCHIDv2)\"\
    , RFC 7343, September 2014,\n              <http://www.rfc-editor.org/info/rfc7343>.\n\
    \   [RFC7402]  Jokela, P., Moskowitz, R., and J. Melen, \"Using the\n        \
    \      Encapsulating Security Payload (ESP) Transport Format with\n          \
    \    the Host Identity Protocol (HIP)\", RFC 7402, April 2015,\n             \
    \ <http://www.rfc-editor.org/info/rfc7402>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [AUR05]    Aura, T., Nagarajan, A., and A.\
    \ Gurtov, \"Analysis of the\n              HIP Base Exchange Protocol\", in Proceedings\
    \ of the 10th\n              Australasian Conference on Information Security and\n\
    \              Privacy, July 2005.\n   [CRO03]    Crosby, S. and D. Wallach, \"\
    Denial of Service via\n              Algorithmic Complexity Attacks\", in Proceedings\
    \ of the\n              12th USENIX Security Symposium, Washington, D.C.,\n  \
    \            August 2003.\n   [DIF76]    Diffie, W. and M. Hellman, \"New Directions\
    \ in\n              Cryptography\", IEEE Transactions on Information Theory\n\
    \              Volume IT-22, Number 6, pages 644-654, November 1976.\n   [FIPS.186-4.2013]\n\
    \              National Institute of Standards and Technology, \"Digital\n   \
    \           Signature Standard (DSS)\", FIPS PUB 186-4, July 2013,\n         \
    \     <http://nvlpubs.nist.gov/nistpubs/FIPS/\n              NIST.FIPS.186-4.pdf>.\n\
    \   [FIPS.197.2001]\n              National Institute of Standards and Technology,\
    \ \"Advanced\n              Encryption Standard (AES)\", FIPS PUB 197, November\
    \ 2001,\n              <http://csrc.nist.gov/publications/fips/fips197/\n    \
    \          fips-197.pdf>.\n   [HIP-ARCH] Moskowitz, R., Ed., and M. Komu, \"Host\
    \ Identity Protocol\n              Architecture\", Work in Progress,\n       \
    \       draft-ietf-hip-rfc4423-bis-09, October 2014.\n   [HIP-DNS-EXT]\n     \
    \         Laganier, J., \"Host Identity Protocol (HIP) Domain Name\n         \
    \     System (DNS) Extension\", Work in Progress,\n              draft-ietf-hip-rfc5205-bis-06,\
    \ January 2015.\n   [HIP-HOST-MOB]\n              Henderson, T., Ed., Vogt, C.,\
    \ and J. Arkko, \"Host Mobility\n              with the Host Identity Protocol\"\
    , Work in Progress,\n              draft-ietf-hip-rfc5206-bis-08, January 2015.\n\
    \   [HIP-REND-EXT]\n              Laganier, J. and L. Eggert, \"Host Identity\
    \ Protocol (HIP)\n              Rendezvous Extension\", Work in Progress,\n  \
    \            draft-ietf-hip-rfc5204-bis-05, December 2014.\n   [KAU03]    Kaufman,\
    \ C., Perlman, R., and B. Sommerfeld, \"DoS\n              protection for UDP-based\
    \ protocols\", in Proceedings of the\n              10th ACM Conference on Computer\
    \ and Communications\n              Security, October 2003.\n   [KRA03]    Krawczyk,\
    \ H., \"SIGMA: The 'SIGn-and-MAc' Approach to\n              Authenticated Diffie-Hellman\
    \ and Its Use in the IKE\n              Protocols\", in Proceedings of CRYPTO\
    \ 2003, pages 400-425,\n              August 2003.\n   [RFC0792]  Postel, J.,\
    \ \"Internet Control Message Protocol\", STD 5,\n              RFC 792, September\
    \ 1981, <http://www.rfc-editor.org/\n              info/rfc792>.\n   [RFC2785]\
    \  Zuccherato, R., \"Methods for Avoiding the \"Small-Subgroup\"\n           \
    \   Attacks on the Diffie-Hellman Key Agreement Method for\n              S/MIME\"\
    , RFC 2785, March 2000,\n              <http://www.rfc-editor.org/info/rfc2785>.\n\
    \   [RFC2898]  Kaliski, B., \"PKCS #5: Password-Based Cryptography\n         \
    \     Specification Version 2.0\", RFC 2898, September 2000,\n              <http://www.rfc-editor.org/info/rfc2898>.\n\
    \   [RFC3447]  Jonsson, J. and B. Kaliski, \"Public-Key Cryptography\n       \
    \       Standards (PKCS) #1: RSA Cryptography Specifications\n              Version\
    \ 2.1\", RFC 3447, February 2003,\n              <http://www.rfc-editor.org/info/rfc3447>.\n\
    \   [RFC3849]  Huston, G., Lord, A., and P. Smith, \"IPv6 Address Prefix\n   \
    \           Reserved for Documentation\", RFC 3849, July 2004,\n             \
    \ <http://www.rfc-editor.org/info/rfc3849>.\n   [RFC5201]  Moskowitz, R., Nikander,\
    \ P., Jokela, P., and T. Henderson,\n              \"Host Identity Protocol\"\
    , RFC 5201, April 2008,\n              <http://www.rfc-editor.org/info/rfc5201>.\n\
    \   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n   \
    \           IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n       \
    \       May 2008, <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC5338]  Henderson,\
    \ T., Nikander, P., and M. Komu, \"Using the Host\n              Identity Protocol\
    \ with Legacy Applications\", RFC 5338,\n              September 2008, <http://www.rfc-editor.org/info/rfc5338>.\n\
    \   [RFC5533]  Nordmark, E. and M. Bagnulo, \"Shim6: Level 3 Multihoming\n   \
    \           Shim Protocol for IPv6\", RFC 5533, June 2009,\n              <http://www.rfc-editor.org/info/rfc5533>.\n\
    \   [RFC5737]  Arkko, J., Cotton, M., and L. Vegoda, \"IPv4 Address Blocks\n \
    \             Reserved for Documentation\", RFC 5737, January 2010,\n        \
    \      <http://www.rfc-editor.org/info/rfc5737>.\n   [RFC5869]  Krawczyk, H. and\
    \ P. Eronen, \"HMAC-based Extract-and-Expand\n              Key Derivation Function\
    \ (HKDF)\", RFC 5869, May 2010,\n              <http://www.rfc-editor.org/info/rfc5869>.\n\
    \   [RFC5903]  Fu, D. and J. Solinas, \"Elliptic Curve Groups modulo a\n     \
    \         Prime (ECP Groups) for IKE and IKEv2\", RFC 5903,\n              June\
    \ 2010, <http://www.rfc-editor.org/info/rfc5903>.\n   [RFC6090]  McGrew, D., Igoe,\
    \ K., and M. Salter, \"Fundamental Elliptic\n              Curve Cryptography\
    \ Algorithms\", RFC 6090, February 2011,\n              <http://www.rfc-editor.org/info/rfc6090>.\n\
    \   [RFC6253]  Heer, T. and S. Varjonen, \"Host Identity Protocol\n          \
    \    Certificates\", RFC 6253, May 2011,\n              <http://www.rfc-editor.org/info/rfc6253>.\n\
    \   [RFC7045]  Carpenter, B. and S. Jiang, \"Transmission and Processing\n   \
    \           of IPv6 Extension Headers\", RFC 7045, December 2013,\n          \
    \    <http://www.rfc-editor.org/info/rfc7045>.\n   [RFC7296]  Kaufman, C., Hoffman,\
    \ P., Nir, Y., Eronen, P., and T.\n              Kivinen, \"Internet Key Exchange\
    \ Protocol Version 2\n              (IKEv2)\", STD 79, RFC 7296, October 2014,\n\
    \              <http://www.rfc-editor.org/info/rfc7296>.\n   [RSA]      Rivest,\
    \ R., Shamir, A., and L. Adleman, \"A Method for\n              Obtaining Digital\
    \ Signatures and Public-Key\n              Cryptosystems\", Communications of\
    \ the ACM 21 (2),\n              pp. 120-126, February 1978.\n   [SECG]     SECG,\
    \ \"Recommended Elliptic Curve Domain Parameters\",\n              SEC 2 Version\
    \ 2.0, January 2010, <http://www.secg.org/>.\n"
- title: Appendix A.  Using Responder Puzzles
  contents:
  - "Appendix A.  Using Responder Puzzles\n   As mentioned in Section 4.1.1, the Responder\
    \ may delay state creation\n   and still reject most spoofed I2 packets by using\
    \ a number of\n   pre-calculated R1 packets and a local selection function.  This\n\
    \   appendix defines one possible implementation in detail.  The purpose\n   of\
    \ this appendix is to give the implementors an idea of how to\n   implement the\
    \ mechanism.  If the implementation is based on this\n   appendix, it MAY contain\
    \ some local modification that makes an\n   attacker's task harder.\n   The Responder\
    \ creates a secret value S, that it regenerates\n   periodically.  The Responder\
    \ needs to remember the two latest values\n   of S.  Each time the S is regenerated,\
    \ the R1 generation counter\n   value is incremented by one.\n   The Responder\
    \ generates a pre-signed R1 packet.  The signature for\n   pre-generated R1s must\
    \ be recalculated when the Diffie-Hellman key is\n   recomputed or when the R1_COUNTER\
    \ value changes due to S value\n   regeneration.\n   When the Initiator sends\
    \ the I1 packet for initializing a connection,\n   the Responder receives the\
    \ HIT and IP address from the packet, and\n   generates an #I value for the puzzle.\
    \  The #I value is set to the\n   pre-signed R1 packet.\n       #I value calculation:\n\
    \       #I = Ltrunc( RHASH ( S | HIT-I | HIT-R | IP-I | IP-R ), n)\n       where\
    \ n = RHASH_len\n   The RHASH algorithm is the same as is used to generate the\n\
    \   Responder's HIT value.\n   From an incoming I2 packet, the Responder receives\
    \ the required\n   information to validate the puzzle: HITs, IP addresses, and\
    \ the\n   information of the used S value from the R1_COUNTER.  Using these\n\
    \   values, the Responder can regenerate the #I, and verify it against\n   the\
    \ #I received in the I2 packet.  If the #I values match, it can\n   verify the\
    \ solution using #I, #J, and difficulty #K.  If the #I\n   values do not match,\
    \ the I2 is dropped.\n       puzzle_check:\n       V := Ltrunc( RHASH( I2.I |\
    \ I2.hit_i | I2.hit_r | I2.J ), #K )\n       if V != 0, drop the packet\n   If\
    \ the puzzle solution is correct, the #I and #J values are stored\n   for later\
    \ use.  They are used as input material when keying material\n   is generated.\n\
    \   Keeping state about failed puzzle solutions depends on the\n   implementation.\
    \  Although it is possible for the Responder not to\n   keep any state information,\
    \ it still may do so to protect itself\n   against certain attacks (see Section\
    \ 4.1.1).\n"
- title: Appendix B.  Generating a Public Key Encoding from an HI
  contents:
  - "Appendix B.  Generating a Public Key Encoding from an HI\n   The following pseudo-code\
    \ illustrates the process to generate a\n   public key encoding from an HI for\
    \ both RSA and DSA.\n   The symbol \":=\" denotes assignment; the symbol \"+=\"\
    \ denotes\n   appending.  The pseudo-function \"encode_in_network_byte_order\"\
    \ takes\n   two parameters, an integer (bignum) and a length in bytes, and\n \
    \  returns the integer encoded into a byte string of the given length.\n   switch\
    \ ( HI.algorithm )\n   {\n   case RSA:\n      buffer := encode_in_network_byte_order\
    \ ( HI.RSA.e_len,\n                ( HI.RSA.e_len > 255 ) ? 3 : 1 )\n      buffer\
    \ += encode_in_network_byte_order ( HI.RSA.e, HI.RSA.e_len )\n      buffer +=\
    \ encode_in_network_byte_order ( HI.RSA.n, HI.RSA.n_len )\n      break;\n   case\
    \ DSA:\n      buffer := encode_in_network_byte_order ( HI.DSA.T , 1 )\n      buffer\
    \ += encode_in_network_byte_order ( HI.DSA.Q , 20 )\n      buffer += encode_in_network_byte_order\
    \ ( HI.DSA.P , 64 +\n                                               8 * HI.DSA.T\
    \ )\n      buffer += encode_in_network_byte_order ( HI.DSA.G , 64 +\n        \
    \                                       8 * HI.DSA.T )\n      buffer += encode_in_network_byte_order\
    \ ( HI.DSA.Y , 64 +\n                                               8 * HI.DSA.T\
    \ )\n      break;\n   }\n"
- title: Appendix C.  Example Checksums for HIP Packets
  contents:
  - "Appendix C.  Example Checksums for HIP Packets\n   The HIP checksum for HIP packets\
    \ is specified in Section 5.1.1.\n   Checksums for TCP and UDP packets running\
    \ over HIP-enabled security\n   associations are specified in Section 4.5.1. \
    \ The examples below use\n   [RFC3849] and [RFC5737] addresses, and HITs with\
    \ the prefix of\n   2001:20 followed by zeros, followed by a decimal 1 or 2,\n\
    \   respectively.\n   The following example is defined only for testing the checksum\n\
    \   calculation.\n"
- title: C.1.  IPv6 HIP Example (I1 Packet)
  contents:
  - "C.1.  IPv6 HIP Example (I1 Packet)\n     Source Address:                 2001:db8::1\n\
    \     Destination Address:            2001:db8::2\n     Upper-Layer Packet Length:\
    \      48              0x30\n     Next Header:                    139        \
    \     0x8b\n     Payload Protocol:               59              0x3b\n     Header\
    \ Length:                  5               0x5\n     Packet Type:            \
    \        1               0x1\n     Version:                        2         \
    \      0x2\n     Reserved:                       1               0x1\n     Control:\
    \                        0               0x0\n     Checksum:                 \
    \      6750            0x1a5e\n     Sender's HIT:                   2001:20::1\n\
    \     Receiver's HIT:                 2001:20::2\n     DH_GROUP_LIST type:   \
    \          511             0x1ff\n     DH_GROUP_LIST length:           3     \
    \          0x3\n     DH_GROUP_LIST Group IDs:        3,4,8\n"
- title: C.2.  IPv4 HIP Packet (I1 Packet)
  contents:
  - "C.2.  IPv4 HIP Packet (I1 Packet)\n   The IPv4 checksum value for the example\
    \ I1 packet is shown below.\n     Source Address:                 192.0.2.1\n\
    \     Destination Address:            192.0.2.2\n     Upper-Layer Packet Length:\
    \      48              0x30\n     Next Header:                    139        \
    \     0x8b\n     Payload Protocol:               59              0x3b\n     Header\
    \ Length:                  5               0x5\n     Packet Type:            \
    \        1               0x1\n     Version:                        2         \
    \      0x2\n     Reserved:                       1               0x1\n     Control:\
    \                        0               0x0\n     Checksum:                 \
    \      61902           0xf1ce\n     Sender's HIT:                   2001:20::1\n\
    \     Receiver's HIT:                 2001:20::2\n     DH_GROUP_LIST type:   \
    \          511             0x1ff\n     DH_GROUP_LIST length:           3     \
    \          0x3\n     DH_GROUP_LIST Group IDs:        3,4,8\n"
- title: C.3.  TCP Segment
  contents:
  - "C.3.  TCP Segment\n   Regardless of whether IPv6 or IPv4 is used, the TCP and\
    \ UDP sockets\n   use the IPv6 pseudo header format [RFC2460], with the HITs used\
    \ in\n   place of the IPv6 addresses.\n     Sender's HIT:                   2001:20::1\n\
    \     Receiver's HIT:                 2001:20::2\n     Upper-Layer Packet Length:\
    \      20              0x14\n     Next Header:                    6          \
    \     0x06\n     Source port:                    65500           0xffdc\n    \
    \ Destination port:               22              0x0016\n     Sequence number:\
    \                1               0x00000001\n     Acknowledgment number:     \
    \     0               0x00000000\n     Data offset:                    5     \
    \          0x5\n     Flags:                          SYN             0x02\n  \
    \   Window size:                    65535           0xffff\n     Checksum:   \
    \                    28586           0x6faa\n     Urgent pointer:            \
    \     0               0x0000\n"
- title: Appendix D.  ECDH and ECDSA 160-Bit Groups
  contents:
  - "Appendix D.  ECDH and ECDSA 160-Bit Groups\n   The ECDH and ECDSA 160-bit group\
    \ SECP160R1 is rated at 80 bits\n   symmetric strength.  This was once considered\
    \ appropriate for one\n   year of security.  Today, these groups should be used\
    \ only when the\n   host is not powerful enough (e.g., some embedded devices)\
    \ and when\n   security requirements are low (e.g., long-term confidentiality\
    \ is not\n   required).\n"
- title: Appendix E.  HIT Suites and HIT Generation
  contents:
  - "Appendix E.  HIT Suites and HIT Generation\n   The HIT as an ORCHID [RFC7343]\
    \ consists of three parts: A 28-bit\n   prefix, a 4-bit encoding of the ORCHID\
    \ generation algorithm (OGA),\n   and a hash that includes the Host Identity and\
    \ a context ID.  The OGA\n   is an index pointing to the specific algorithm by\
    \ which the public\n   key and the 96-bit hashed encoding are generated.  The\
    \ OGA is\n   protocol specific and is to be interpreted as defined below for all\n\
    \   protocols that use the same context ID as HIP.  HIP groups sets of\n   valid\
    \ combinations of signature and hash algorithms into HIT Suites.\n   These HIT\
    \ Suites are addressed by an index, which is transmitted in\n   the OGA ID field\
    \ of the ORCHID.\n   The set of used HIT Suites will be extended to counter the\
    \ progress\n   in computation capabilities and vulnerabilities in the employed\n\
    \   algorithms.  The intended use of the HIT Suites is to introduce a new\n  \
    \ HIT Suite and phase out an old one before it becomes insecure.  Since\n   the\
    \ 4-bit OGA ID field only permits 15 HIT Suites to be used at the\n   same time\
    \ (the HIT Suite with ID 0 is reserved), phased-out HIT\n   Suites must be reused\
    \ at some point.  In such a case, there will be a\n   rollover of the HIT Suite\
    \ ID and the next newly introduced HIT Suite\n   will start with a lower HIT Suite\
    \ index than the previously\n   introduced one.  The rollover effectively deprecates\
    \ the reused HIT\n   Suite.  For a smooth transition, the HIT Suite should be\
    \ deprecated a\n   considerable time before the HIT Suite index is reused.\n \
    \  Since the number of HIT Suites is tightly limited to 16, the HIT\n   Suites\
    \ must be assigned carefully.  Hence, sets of suitable\n   algorithms are grouped\
    \ in a HIT Suite.\n   The HIT Suite of the Responder's HIT determines the RHASH\
    \ and the\n   hash function to be used for the HMAC in HIP packets as well as\
    \ the\n   signature algorithm family used for generating the HI.  The list of\n\
    \   HIT Suites is defined in Table 10.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The drive to create HIP came to being after attending the\
    \ MALLOC\n   meeting at the 43rd IETF meeting.  Baiju Patel and Hilarie Orman\n\
    \   really gave the original author, Bob Moskowitz, the assist to get HIP\n  \
    \ beyond 5 paragraphs of ideas.  It has matured considerably since the\n   early\
    \ versions thanks to extensive input from IETFers.  Most\n   importantly, its\
    \ design goals are articulated and are different from\n   other efforts in this\
    \ direction.  Particular mention goes to the\n   members of the NameSpace Research\
    \ Group of the IRTF.  Noel Chiappa\n   provided valuable input at early stages\
    \ of discussions about\n   identifier handling and Keith Moore the impetus to\
    \ provide\n   resolvability.  Steve Deering provided encouragement to keep working,\n\
    \   as a solid proposal can act as a proof of ideas for a research group.\n  \
    \ Many others contributed; extensive security tips were provided by\n   Steve\
    \ Bellovin.  Rob Austein kept the DNS parts on track.  Paul\n   Kocher taught\
    \ Bob Moskowitz how to make the puzzle exchange expensive\n   for the Initiator\
    \ to respond, but easy for the Responder to validate.\n   Bill Sommerfeld supplied\
    \ the Birthday concept, which later evolved\n   into the R1 generation counter,\
    \ to simplify reboot management.  Erik\n   Nordmark supplied the CLOSE-mechanism\
    \ for closing connections.\n   Rodney Thayer and Hugh Daniels provided extensive\
    \ feedback.  In the\n   early times of this document, John Gilmore kept Bob Moskowitz\n\
    \   challenged to provide something of value.\n   During the later stages of this\
    \ document, when the editing baton was\n   transferred to Pekka Nikander, the\
    \ input from the early implementors\n   was invaluable.  Without having actual\
    \ implementations, this document\n   would not be on the level it is now.\n  \
    \ In the usual IETF fashion, a large number of people have contributed\n   to\
    \ the actual text or ideas.  The list of these people includes Jeff\n   Ahrenholz,\
    \ Francis Dupont, Derek Fawcus, George Gross, Xin Gu, Rene\n   Hummen, Miika Komu,\
    \ Mika Kousa, Julien Laganier, Andrew McGregor, Jan\n   Melen, Henrik Petander,\
    \ Michael Richardson, Tim Shepard, Jorma Wall,\n   and Jukka Ylitalo.  Our apologies\
    \ to anyone whose name is missing.\n   Once the HIP Working Group was founded\
    \ in early 2004, a number of\n   changes were introduced through the working group\
    \ process.  Most\n   notably, the original document was split in two, one containing\
    \ the\n   base exchange and the other one defining how to use ESP.  Some\n   modifications\
    \ to the protocol proposed by Aura, et al. [AUR05] were\n   added at a later stage.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Robert Moskowitz (editor)\n   HTT Consulting\n   Oak Park,\
    \ MI\n   United States\n   EMail: rgm@labs.htt-consult.com\n   Tobias Heer\n \
    \  Hirschmann Automation and Control\n   Stuttgarter Strasse 45-51\n   Neckartenzlingen\
    \  72654\n   Germany\n   EMail: tobias.heer@belden.com\n   Petri Jokela\n   Ericsson\
    \ Research NomadicLab\n   Jorvas  FIN-02420\n   Finland\n   Phone: +358 9 299\
    \ 1\n   EMail: petri.jokela@nomadiclab.com\n   Thomas R. Henderson\n   University\
    \ of Washington\n   Campus Box 352500\n   Seattle, WA\n   United States\n   EMail:\
    \ tomhend@u.washington.edu\n"
