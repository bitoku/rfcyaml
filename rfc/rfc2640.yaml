- title: __initial_text__
  contents:
  - '           Internationalization of the File Transfer Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The File Transfer Protocol, as defined in RFC 959 [RFC959] and RFC\n\
    \   1123 Section 4 [RFC1123], is one of the oldest and widely used\n   protocols\
    \ on the Internet. The protocol's primary character set, 7\n   bit ASCII, has\
    \ served the protocol well through the early growth\n   years of the Internet.\
    \ However, as the Internet becomes more global,\n   there is a need to support\
    \ character sets beyond 7 bit ASCII.\n   This document addresses the internationalization\
    \ (I18n) of FTP, which\n   includes supporting the multiple character sets and\
    \ languages found\n   throughout the Internet community.  This is achieved by\
    \ extending the\n   FTP specification and giving recommendations for proper\n\
    \   internationalization support.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n    4.1 The LANG command..........................................8\n\
    \    4.2 Syntax of the LANG command................................9\n    4.3\
    \ Feat response for LANG command...........................11\n     4.3.1 Feat\
    \ examples.........................................11\n   5 SECURITY CONSIDERATIONS.....................................12\n\
    \   6 ACKNOWLEDGMENTS.............................................12\n   7 GLOSSARY....................................................13\n\
    \   8 BIBLIOGRAPHY................................................13\n   9 AUTHOR'S\
    \ ADDRESS............................................15\n   ANNEX A - IMPLEMENTATION\
    \ CONSIDERATIONS.......................16\n    A.1 General Considerations...................................16\n\
    \    A.2 Transition Considerations................................18\n   ANNEX\
    \ B - SAMPLE CODE AND EXAMPLES............................19\n    B.1 Valid UTF-8\
    \ check........................................19\n    B.2 Conversions..............................................20\n\
    \     B.2.1 Conversion from Local Character Set to UTF-8..........20\n     B.2.2\
    \ Conversion from UTF-8 to Local Character Set..........23\n     B.2.3 ISO/IEC\
    \ 8859-8 Example................................25\n     B.2.4 Vendor Codepage\
    \ Example...............................25\n    B.3 Pseudo Code for Translating\
    \ Servers......................26\n   Full Copyright Statement......................................27\n"
- title: 1 Introduction
  contents:
  - "1 Introduction\n   As the Internet grows throughout the world the requirement\
    \ to support\n   character sets outside of the ASCII [ASCII] / Latin-1 [ISO-8859]\n\
    \   character set becomes ever more urgent.  For FTP, because of the\n   large\
    \ installed base, it is paramount that this is done without\n   breaking existing\
    \ clients and servers. This document addresses this\n   need. In doing so it defines\
    \ a solution which will still allow the\n   installed base to interoperate with\
    \ new clients and servers.\n   This document enhances the capabilities of the\
    \ File Transfer Protocol\n   by removing the 7-bit restrictions on pathnames used\
    \ in client\n   commands and server responses, RECOMMENDs the use of a Universal\n\
    \   Character Set (UCS) ISO/IEC 10646 [ISO-10646], RECOMMENDs a UCS\n   transformation\
    \ format (UTF) UTF-8 [UTF-8], and defines a new command\n   for language negotiation.\n\
    \   The recommendations made in this document are consistent with the\n   recommendations\
    \ expressed by the IETF policy related to character\n   sets and languages as\
    \ defined in RFC 2277 [RFC2277].\n"
- title: 1.1.  Requirements Terminology
  contents:
  - "1.1.  Requirements Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \
    \ \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in BCP 14 [BCP14].\n"
- title: 2 Internationalization
  contents:
  - "2 Internationalization\n   The File Transfer Protocol was developed when the\
    \ predominate\n   character sets were 7 bit ASCII and 8 bit EBCDIC. Today these\n\
    \   character sets cannot support the wide range of characters needed by\n   multinational\
    \ systems. Given that there are a number of character\n   sets in current use\
    \ that provide more characters than 7-bit ASCII, it\n   makes sense to decide\
    \ on a convenient way to represent the union of\n   those possibilities. To work\
    \ globally either requires support of a\n   number of character sets and to be\
    \ able to convert between them, or\n   the use of a single preferred character\
    \ set. To assure global\n   interoperability this document RECOMMENDS the latter\
    \ approach and\n   defines a single character set, in addition to NVT ASCII and\
    \ EBCDIC,\n   which is understandable by all systems. For FTP this character set\n\
    \   SHALL be ISO/IEC 10646:1993.  For support of global compatibility it\n   is\
    \ STRONGLY RECOMMENDED that clients and servers use UTF-8 encoding\n   when exchanging\
    \ pathnames.  Clients and servers are, however, under\n   no obligation to perform\
    \ any conversion on the contents of a file for\n   operations such as STOR or\
    \ RETR.\n   The character set used to store files SHALL remain a local decision\n\
    \   and MAY depend on the capability of local operating systems. Prior to\n  \
    \ the exchange of pathnames they SHOULD be converted into a ISO/IEC\n   10646\
    \ format and UTF-8 encoded. This approach, while allowing\n   international exchange\
    \ of pathnames, will still allow backward\n   compatibility with older systems\
    \ because the code set positions for\n   ASCII characters are identical to the\
    \ one byte sequence in UTF-8.\n   Sections 2.1 and 2.2 give a brief description\
    \ of the international\n   character set and transfer encoding RECOMMENDED by\
    \ this document. A\n   more thorough description of UTF-8, ISO/IEC 10646, and\
    \ UNICODE\n   [UNICODE], beyond that given in this document, can be found in RFC\n\
    \   2279 [RFC2279].\n"
- title: 2.1 International Character Set
  contents:
  - "2.1 International Character Set\n   The character set defined for international\
    \ support of FTP SHALL be\n   the Universal Character Set as defined in ISO 10646:1993\
    \ as amended.\n   This standard incorporates the character sets of many existing\n\
    \   international, national, and corporate standards. ISO/IEC 10646\n   defines\
    \ two alternate forms of encoding, UCS-4 and UCS-2. UCS-4 is a\n   four byte (31\
    \ bit) encoding containing 2**31 code positions divided\n   into 128 groups of\
    \ 256 planes. Each plane consists of 256 rows of 256\n   cells. UCS-2 is a 2 byte\
    \ (16 bit) character set consisting of plane\n   zero or the Basic Multilingual\
    \ Plane (BMP).  Currently, no codesets\n   have been defined outside of the 2\
    \ byte BMP.\n   The Unicode standard version 2.0 [UNICODE] is consistent with\
    \ the\n   UCS-2 subset of ISO/IEC 10646. The Unicode standard version 2.0\n  \
    \ includes the repertoire of IS 10646 characters, amendments 1-7 of IS\n   10646,\
    \ and editorial and technical corrigenda.\n"
- title: 2.2 Transfer Encoding
  contents:
  - "2.2 Transfer Encoding\n   UCS Transformation Format 8 (UTF-8), in the past referred\
    \ to as UTF-2\n   or UTF-FSS, SHALL be used as a transfer encoding to transmit\
    \ the\n   international character set. UTF-8 is a file safe encoding which\n \
    \  avoids the use of byte values that have special significance during\n   the\
    \ parsing of pathname character strings. UTF-8 is an 8 bit encoding\n   of the\
    \ characters in the UCS. Some of UTF-8's benefits are that it is\n   compatible\
    \ with 7 bit ASCII, so it doesn't affect programs that give\n   special meanings\
    \ to various ASCII characters; it is immune to\n   synchronization errors; its\
    \ encoding rules allow for easy\n   identification; and it has enough space to\
    \ support a large number of\n   character sets.\n   UTF-8 encoding represents\
    \ each UCS character as a sequence of 1 to 6\n   bytes in length. For all sequences\
    \ of one byte the most significant\n   bit is ZERO. For all sequences of more\
    \ than one byte the number of\n   ONE bits in the first byte, starting from the\
    \ most significant bit\n   position, indicates the number of bytes in the UTF-8\
    \ sequence\n   followed by a ZERO bit. For example, the first byte of a 3 byte\
    \ UTF-8\n   sequence would have 1110 as its most significant bits. Each\n   additional\
    \ bytes (continuing bytes) in the UTF-8 sequence, contain a\n   ONE bit followed\
    \ by a ZERO bit as their most significant bits. The\n   remaining free bit positions\
    \ in the continuing bytes are used to\n   identify characters in the UCS. The\
    \ relationship between UCS and\n   UTF-8 is demonstrated in the following table:\n\
    \   UCS-4 range(hex)          UTF-8 byte sequence(binary)\n   00000000 - 0000007F\
    \       0xxxxxxx\n   00000080 - 000007FF       110xxxxx 10xxxxxx\n   00000800\
    \ - 0000FFFF       1110xxxx 10xxxxxx 10xxxxxx\n   00010000 - 001FFFFF       11110xxx\
    \ 10xxxxxx 10xxxxxx 10xxxxxx\n   00200000 - 03FFFFFF       111110xx 10xxxxxx 10xxxxxx\
    \ 10xxxxxx\n                             10xxxxxx\n   04000000 - 7FFFFFFF    \
    \   1111110x 10xxxxxx 10xxxxxx 10xxxxxx\n                             10xxxxxx\
    \ 10xxxxxx\n   A beneficial property of UTF-8 is that its single byte sequence\
    \ is\n   consistent with the ASCII character set. This feature will allow a\n\
    \   transition where old ASCII-only clients can still interoperate with\n   new\
    \ servers that support the UTF-8 encoding.\n   Another feature is that the encoding\
    \ rules make it very unlikely that\n   a character sequence from a different character\
    \ set will be mistaken\n   for a UTF-8 encoded character sequence. Clients and\
    \ servers can use a\n   simple routine to determine if the character set being\
    \ exchanged is\n   valid UTF-8. Section B.1 shows a code example of this check.\n"
- title: 3 Pathnames
  contents:
  - '3 Pathnames

    '
- title: 3.1 General compliance
  contents:
  - "3.1 General compliance\n   - The 7-bit restriction for pathnames exchanged is\
    \ dropped.\n   - Many operating system allow the use of spaces <SP>, carriage\
    \ return\n     <CR>, and line feed <LF> characters as part of the pathname. The\n\
    \     exchange of pathnames with these special command characters will\n     cause\
    \ the pathnames to be parsed improperly. This is because ftp\n     commands associated\
    \ with pathnames have the form:\n      COMMAND <SP> <pathname> <CRLF>.\n   To\
    \ allow the exchange of pathnames containing these characters, the\n   definition\
    \ of pathname is changed from\n     <pathname> ::= <string>   ; in BNF format\n\
    \   to\n     pathname = 1*(%x01..%xFF) ; in ABNF format [ABNF].\n   To avoid mistaking\
    \ these characters within pathnames as special\n   command characters the following\
    \ rules will apply:\n   There MUST be only one <SP> between a ftp command and\
    \ the pathname.\n   Implementations MUST assume <SP> characters following the\
    \ initial\n   <SP> as part of the pathname. For example the pathname in STOR\n\
    \   <SP><SP><SP>foo.bar<CRLF> is <SP><SP>foo.bar.\n   Current implementations,\
    \ which may allow multiple <SP> characters as\n   separators between the command\
    \ and pathname, MUST assure that they\n   comply with this single <SP> convention.\
    \ Note: Implementations which\n   treat 3 character commands (e.g. CWD, MKD, etc.)\
    \ as a fixed 4\n   character command by padding the command with a trailing <SP>\
    \ are in\n   non-compliance to this specification.\n   When a <CR> character is\
    \ encountered as part of a pathname it MUST be\n   padded with a <NUL> character\
    \ prior to sending the command. On\n   receipt of a pathname containing a <CR><NUL>\
    \ sequence the <NUL>\n   character MUST be stripped away. This approach is described\
    \ in the\n   Telnet protocol [RFC854] on pages 11 and 12. For example, to store\
    \ a\n   pathname foo<CR><LF>boo.bar the pathname would become\n   foo<CR><NUL><LF>boo.bar\
    \ prior to sending the command STOR\n   <SP>foo<CR><NUL><LF>boo.bar<CRLF>. Upon\
    \ receipt of the altered\n   pathname the <NUL> character following the <CR> would\
    \ be stripped\n   away to form the original pathname.\n   - Conforming clients\
    \ and servers MUST support UTF-8 for the transfer\n     and receipt of pathnames.\
    \ Clients and servers MAY in addition give\n     users a choice of specifying\
    \ interpretation of pathnames in another\n     encoding. Note that configuring\
    \ clients and servers to use\n     character sets / encoding other than UTF-8\
    \ is outside of the scope\n     of this document. While it is recognized that\
    \ in certain\n     operational scenarios this may be desirable, this is left as\
    \ a\n     quality of implementation and operational issue.\n   - Pathnames are\
    \ sequences of bytes.  The encoding of names that are\n     valid UTF-8 sequences\
    \ is assumed to be UTF-8.  The character set of\n     other names is undefined.\
    \ Clients and servers, unless otherwise\n     configured to support a specific\
    \ native character set, MUST check\n     for a valid UTF-8 byte sequence to determine\
    \ if the pathname being\n     presented is UTF-8.\n   - To avoid data loss, clients\
    \ and servers SHOULD use the UTF-8\n     encoded pathnames when unable to convert\
    \ them to a usable code set.\n   - There may be cases when the code set / encoding\
    \ presented to the\n     server or client cannot be determined. In such cases\
    \ the raw bytes\n     SHOULD be used.\n"
- title: 3.2 Servers compliance
  contents:
  - "3.2 Servers compliance\n   - Servers MUST support the UTF-8 feature in response\
    \ to the FEAT\n     command [RFC2389]. The UTF-8 feature is a line containing\
    \ the exact\n     string \"UTF8\". This string is not case sensitive, but SHOULD\
    \ be\n     transmitted in upper case. The response to a FEAT command SHOULD\n\
    \     be:\n        C> feat\n        S> 211- <any descriptive text>\n        S>\
    \  ...\n        S>  UTF8\n        S>  ...\n        S> 211 end\n   The ellipses\
    \ indicate placeholders where other features may be\n   included, but are NOT\
    \ REQUIRED. The one space indentation of the\n   feature lines is mandatory [RFC2389].\n\
    \   - Mirror servers may want to exactly reflect the site that they are\n    \
    \ mirroring. In such cases servers MAY store and present the exact\n     pathname\
    \ bytes that it received from the main server.\n"
- title: 3.3 Clients compliance
  contents:
  - "3.3 Clients compliance\n   - Clients which do not require display of pathnames\
    \ are under no\n     obligation to do so. Non-display clients do not need to conform\
    \ to\n     requirements associated with display.\n   - Clients, which are presented\
    \ UTF-8 pathnames by the server, SHOULD\n     parse UTF-8 correctly and attempt\
    \ to display the pathname within\n     the limitation of the resources available.\n\
    \   - Clients MUST support the FEAT command and recognize the \"UTF8\"\n     feature\
    \ (defined in 3.2 above) to determine if a server supports\n     UTF-8 encoding.\n\
    \   - Character semantics of other names shall remain undefined. If a\n     client\
    \ detects that a server is non UTF-8, it SHOULD change its\n     display appropriately.\
    \ How a client implementation handles non\n     UTF-8 is a quality of implementation\
    \ issue. It MAY try to assume\n     some other encoding, give the user a chance\
    \ to try to assume\n     something, or save encoding assumptions for a server\
    \ from one FTP\n     session to another.\n   - Glyph rendering is outside the\
    \ scope of this document. How a client\n     presents characters it cannot display\
    \ is a quality of\n     implementation issue. This document RECOMMENDS that octets\n\
    \     corresponding to non-displayable characters SHOULD be presented in\n   \
    \  URL %HH format defined in RFC 1738 [RFC1738]. They MAY, however,\n     display\
    \ them as question marks, with their UCS hexadecimal value,\n     or in any other\
    \ suitable fashion.\n   - Many existing clients interpret 8-bit pathnames as being\
    \ in the\n     local character set. They MAY continue to do so for pathnames that\n\
    \     are not valid UTF-8.\n"
- title: 4. Language Support
  contents:
  - "4. Language Support\n   The Character Set Workshop Report [RFC2130] suggests\
    \ that clients and\n   servers SHOULD negotiate a language for \"greetings\" and\
    \ \"error\n   messages\". This specification interprets the use of the term  \"\
    error\n   message\", by RFC 2130, to mean any explanatory text string returned\n\
    \   by server-PI in response to a user-PI command.\n   Implementers SHOULD note\
    \ that FTP commands and numeric responses are\n   protocol elements. As such,\
    \ their use is not affected by any guidance\n   expressed by this specification.\n\
    \   Language support of greetings and command responses shall be the\n   default\
    \ language supported by the server or the language supported by\n   the server\
    \ and selected by the client.\n   It may be possible to achieve language support\
    \ through a virtual host\n   as described in [MLST]. However, an FTP server might\
    \ not support\n   virtual servers, or virtual servers might be configured to support\
    \ an\n   environment without regard for language. To allow language\n   negotiation\
    \ this specification defines a new LANG command. Clients\n   and servers that\
    \ comply with this specification MUST support the LANG\n   command.\n"
- title: 4.1 The LANG command
  contents:
  - "4.1 The LANG command\n   A new command \"LANG\" is added to the FTP command set\
    \ to allow\n   server-FTP process to determine in which language to present server\n\
    \   greetings and the textual part of command responses. The parameter\n   associated\
    \ with the LANG command SHALL be one of the language tags\n   defined in RFC 1766\
    \ [RFC1766]. If a LANG command without a parameter\n   is issued the server's\
    \ default language will be used.\n   Greetings and responses issued prior to language\
    \ negotiation SHALL be\n   in the server's default language. Paragraph 4.5 of\
    \ [RFC2277] state\n   that this \"default language MUST be understandable by an\
    \ English-\n   speaking person\". This specification RECOMMENDS that the server\n\
    \   default language be English encoded using ASCII. This text may be\n   augmented\
    \ by text from other languages. Once negotiated, server-PI\n   MUST return server\
    \ messages and textual part of command responses in\n   the negotiated language\
    \ and encoded in UTF-8. Server-PI MAY wish to\n   re-send previously issued server\
    \ messages in the newly negotiated\n   language.\n   The LANG command only affects\
    \ presentation of greeting messages and\n   explanatory text associated with command\
    \ responses. No attempt should\n   be made by the server to translate protocol\
    \ elements (FTP commands\n   and numeric responses) or data transmitted over the\
    \ data connection.\n   User-PI MAY issue the LANG command at any time during an\
    \ FTP session.\n   In order to gain the full benefit of this command, it SHOULD\
    \ be\n   presented prior to authentication. In general, it will be issued\n  \
    \ after the HOST command [MLST]. Note that the issuance of a HOST or\n   REIN\
    \ command [RFC959] will negate the affect of the LANG command.\n   User-PI SHOULD\
    \ be capable of supporting UTF-8 encoding for the\n   language negotiated. Guidance\
    \ on interpretation and rendering of\n   UTF-8, defined in section 3, SHALL apply.\n\
    \   Although NOT REQUIRED by this specification, a user-PI SHOULD issue a\n  \
    \ FEAT command [RFC2389] prior to a LANG command. This will allow the\n   user-PI\
    \ to determine if the server supports the LANG command and\n   which language\
    \ options.\n   In order to aid the server in identifying whether a connection\
    \ has\n   been established with a client which conforms to this specification\n\
    \   or an older client, user-PI MUST send a HOST [MLST] and/or LANG\n   command\
    \ prior to issuing any other command (other than FEAT\n   [RFC2389]). If user-PI\
    \ issues a HOST command, and the server's\n   default language is acceptable,\
    \ it need not issue a LANG command.\n   However, if the implementation does not\
    \ support the HOST command, a\n   LANG command MUST be issued. Until server-PI\
    \ is presented with either\n   a HOST or LANG command it SHOULD assume that the\
    \ user-PI does not\n   comply with this specification.\n"
- title: 4.2 Syntax of the LANG command
  contents:
  - "4.2 Syntax of the LANG command\n   The LANG command is defined as follows:\n\
    \   lang-command       = \"Lang\" [(SP lang-tag)] CRLF\n   lang-tag          \
    \ = Primary-tag *( \"-\" Sub-tag)\n   Primary-tag        = 1*8ALPHA\n   Sub-tag\
    \            = 1*8ALPHA\n   lang-response      = lang-ok / error-response\n  \
    \ lang-ok            = \"200\" [SP *(%x00..%xFF) ] CRLF\n   error-response   \
    \  = command-unrecognized / bad-argument /\n                     not-implemented\
    \ / unsupported-parameter\n   command-unrecognized  = \"500\" [SP *(%x01..%xFF)\
    \ ] CRLF\n   bad-argument       = \"501\" [SP *(%x01..%xFF) ] CRLF\n   not-implemented\
    \    = \"502\" [SP *(%x01..%xFF) ] CRLF\n   unsupported-parameter = \"504\" [SP\
    \ *(%x01..%xFF) ] CRLF\n   The \"lang\" command word is case independent and may\
    \ be specified in\n   any character case desired. Therefore \"LANG\", \"lang\"\
    , \"Lang\", and\n   \"lAnG\" are equivalent commands.\n   The OPTIONAL \"Lang-tag\"\
    \ given as a parameter specifies the primary\n   language tags and zero or more\
    \ sub-tags as defined in [RFC1766]. As\n   described in [RFC1766] language tags\
    \ are treated as case insensitive.\n   If omitted server-PI MUST use the server's\
    \ default language.\n   Server-FTP responds to the \"Lang\" command with either\
    \ \"lang-ok\" or\n   \"error-response\". \"lang-ok\" MUST be sent if Server-FTP\
    \ supports the\n   \"Lang\" command and can support some form of the \"lang-tag\"\
    . Support\n   SHOULD be as follows:\n   - If server-FTP receives \"Lang\" with\
    \ no parameters it SHOULD return\n     messages and command responses in the server\
    \ default language.\n   - If server-FTP receives \"Lang\" with only a primary\
    \ tag argument\n     (e.g. en, fr, de, ja, zh, etc.), which it can support, it\
    \ SHOULD\n     return messages and command responses in the language associated\n\
    \     with that primary tag. It is possible that server-FTP will only\n     support\
    \ the primary tag when combined with a sub-tag (e.g. en-US,\n     en-UK, etc.).\
    \ In such cases, server-FTP MAY determine the\n     appropriate variant to use\
    \ during the session. How server-FTP makes\n     that determination is outside\
    \ the scope of this specification. If\n     server-FTP cannot determine if a sub-tag\
    \ variant is appropriate it\n     SHOULD return an \"unsupported-parameter\" (504)\
    \ response.\n   - If server-FTP receives \"Lang\" with a primary tag and sub-tag(s)\n\
    \     argument, which is implemented, it SHOULD return messages and\n     command\
    \ responses in support of the language argument. It is\n     possible that server-FTP\
    \ can support the primary tag of the \"Lang\"\n     argument but not the sub-tag(s).\
    \ In such cases server-FTP MAY\n     return messages and command responses in\
    \ the most appropriate\n     variant of the primary tag that has been implemented.\
    \ How server-\n     FTP makes that determination is outside the scope of this\n\
    \     specification. If server-FTP cannot determine if a sub-tag variant\n   \
    \  is appropriate it SHOULD return an \"unsupported-parameter\" (504)\n     response.\n\
    \   For example if client-FTP sends a \"LANG en-AU\" command and server-FTP\n\
    \   has implemented language tags en-US and en-UK it may decide that the\n   most\
    \ appropriate language tag is en-UK and return \"200 en-AU not\n   supported.\
    \ Language set to en-UK\". The numeric response is a protocol\n   element and\
    \ can not be changed. The associated string is for\n   illustrative purposes only.\n\
    \   Clients and servers that conform to this specification MUST support\n   the\
    \ LANG command. Clients SHOULD, however, anticipate receiving a 500\n   or 502\
    \ command response, in cases where older or non-compliant\n   servers do not recognize\
    \ or have not implemented the \"Lang\". A 501\n   response SHOULD be sent if the\
    \ argument to the \"Lang\" command is not\n   syntactically correct. A 504 response\
    \ SHOULD be sent if the \"Lang\"\n   argument, while syntactically correct, is\
    \ not implemented. As noted\n   above, an argument may be considered a lexicon\
    \ match even though it\n   is not an exact syntax match.\n"
- title: 4.3 Feat response for LANG command
  contents:
  - "4.3 Feat response for LANG command\n   A server-FTP process that supports the\
    \ LANG command, and language\n   support for messages and command responses, MUST\
    \ include in the\n   response to the FEAT command [RFC2389], a feature line indicating\n\
    \   that the LANG command is supported and a fact list of the supported\n   language\
    \ tags. A response to a FEAT command SHALL be in the following\n   format:\n \
    \       Lang-feat  = SP \"LANG\" SP lang-fact CRLF\n        lang-fact  = lang-tag\
    \ [\"*\"] *(\";\" lang-tag [\"*\"])\n        lang-tag   = Primary-tag *( \"-\"\
    \ Sub-tag)\n        Primary-tag= 1*8ALPHA\n        Sub-tag    = 1*8ALPHA\n   The\
    \ lang-feat response contains the string \"LANG\" followed by a\n   language fact.\
    \ This string is not case sensitive, but SHOULD be\n   transmitted in upper case,\
    \ as recommended in [RFC2389]. The initial\n   space shown in the Lang-feat response\
    \ is REQUIRED by the FEAT\n   command. It MUST be a single space character. More\
    \ or less space\n   characters are not permitted. The lang-fact SHALL include\
    \ the lang-\n   tags which server-FTP can support. At least one lang-tag MUST\
    \ be\n   included with the FEAT response. The lang-tag SHALL be in the form\n\
    \   described earlier in this document. The OPTIONAL asterisk, when\n   present,\
    \ SHALL indicate the current lang-tag being used by server-FTP\n   for messages\
    \ and responses.\n"
- title: 4.3.1 Feat examples
  contents:
  - "4.3.1 Feat examples\n        C> feat\n        S> 211- <any descriptive text>\n\
    \        S>  ...\n        S>  LANG EN*\n        S>  ...\n        S> 211 end\n\
    \   In this example server-FTP can only support English, which is the\n   current\
    \ language (as shown by the asterisk) being used by the server\n   for messages\
    \ and command responses.\n        C> feat\n        S> 211- <any descriptive text>\n\
    \        S>  ...\n        S>  LANG EN*;FR\n        S>  ...\n        S> 211 end\n\
    \        C> LANG fr\n        S> 200 Le response sera changez au francais\n   \
    \     C> feat\n        S> 211- <quelconque descriptif texte>\n        S>  ...\n\
    \        S>  LANG EN;FR*\n        S>  ...\n        S> 211 end\n   In this example\
    \ server-FTP supports both English and French as shown\n   by the initial response\
    \ to the FEAT command. The asterisk indicates\n   that English is the current\
    \ language in use by server-FTP. After a\n   LANG command is issued to change\
    \ the language to French, the FEAT\n   response shows French as the current language\
    \ in use.\n   In the above examples ellipses indicate placeholders where other\n\
    \   features may be included, but are NOT REQUIRED.\n"
- title: 5 Security Considerations
  contents:
  - "5 Security Considerations\n   This document addresses the support of character\
    \ sets beyond 1 byte\n   and a new language negotiation command. Conformance to\
    \ this document\n   should not induce a security risk.\n"
- title: 6 Acknowledgments
  contents:
  - "6 Acknowledgments\n   The following people have contributed to this document:\n\
    \   D. J. Bernstein\n   Martin J. Duerst\n   Mark Harris\n   Paul Hethmon\n  \
    \ Alun Jones\n   Gregory Lundberg\n   James Matthews\n   Keith Moore\n   Sandra\
    \ O'Donnell\n   Benjamin Riefenstahl\n   Stephen Tihor\n   (and others from the\
    \ FTPEXT working group)\n"
- title: 7 Glossary
  contents:
  - "7 Glossary\n   BIDI - abbreviation for Bi-directional, a reference to mixed right-\n\
    \   to-left and left-to-right text.\n   Character Set - a collection of characters\
    \ used to represent textual\n   information in which each character has a numeric\
    \ value\n   Code Set -  (see character set).\n   Glyph - a character image represented\
    \ on a display device.\n   I18N - \"I eighteen N\", the first and last letters\
    \ of the word\n   \"internationalization\" and the eighteen letters in between.\n\
    \   UCS-2 - the ISO/IEC 10646 two octet Universal Character Set form.\n   UCS-4\
    \ - the ISO/IEC 10646 four octet Universal Character Set form.\n   UTF-8 - the\
    \ UCS Transformation Format represented in 8 bits.\n   TF-16 - A 16-bit format\
    \ including the BMP (directly encoded) and\n   surrogate pairs to represent characters\
    \ in planes 01-16; equivalent\n   to Unicode.\n"
- title: 8 Bibliography
  contents:
  - "8 Bibliography\n   [ABNF]       Crocker, D. and P. Overell, \"Augmented BNF for\
    \ Syntax\n                Specifications: ABNF\", RFC 2234, November 1997.\n \
    \  [ASCII]      ANSI X3.4:1986 Coded Character Sets - 7 Bit American\n       \
    \         National Standard Code for Information Interchange (7-\n           \
    \     bit ASCII)\n   [ISO-8859]   ISO 8859.  International standard -- Information\n\
    \                processing -- 8-bit single-byte coded graphic character\n   \
    \             sets -- Part 1:Latin alphabet No. 1 (1987) -- Part 2:\n        \
    \        Latin alphabet No. 2 (1987) -- Part 3: Latin alphabet\n             \
    \   No. 3 (1988) -- Part 4: Latin alphabet No. 4 (1988) --\n                Part\
    \ 5: Latin/Cyrillic alphabet (1988) -- Part 6:\n                Latin/Arabic alphabet\
    \ (1987) -- Part : Latin/Greek\n                alphabet (1987) -- Part 8: Latin/Hebrew\
    \ alphabet (1988)\n                -- Part 9: Latin alphabet No. 5 (1989) -- Part10:\
    \ Latin\n                alphabet No. 6 (1992)\n   [BCP14]      Bradner, S., \"\
    Key words for use in RFCs to Indicate\n                Requirement Levels\", BCP\
    \ 14, RFC 2119, March 1997.\n   [ISO-10646]  ISO/IEC 10646-1:1993. International\
    \ standard --\n                Information technology -- Universal multiple-octet\
    \ coded\n                character set (UCS) -- Part 1: Architecture and basic\n\
    \                multilingual plane.\n   [MLST]       Elz, R. and P. Hethmon,\
    \ \"Extensions to FTP\", Work in\n                Progress.\n   [RFC854]     Postel,\
    \ J. and J. Reynolds, \"Telnet Protocol\n                Specification\", STD\
    \ 8, RFC 854, May 1983.\n   [RFC959]     Postel, J. and J. Reynolds, \"File Transfer\
    \ Protocol\n                (FTP)\", STD 9, RFC 959, October 1985.\n   [RFC1123]\
    \    Braden, R., \"Requirements for Internet Hosts --\n                Application\
    \ and Support\", STD 3, RFC 1123, October 1989.\n   [RFC1738]    Berners-Lee,\
    \ T., Masinter, L. and M. McCahill, \"Uniform\n                Resource Locators\
    \ (URL)\", RFC 1738, December 1994.\n   [RFC1766]    Alvestrand, H., \"Tags for\
    \ the Identification of\n                Languages\", RFC 1766, March 1995.\n\
    \   [RFC2130]    Weider, C., Preston, C., Simonsen, K., Alvestrand, H.,\n    \
    \            Atkinson, R., Crispin, M. and P. Svanberg, \"Character\n        \
    \        Set Workshop Report\", RFC 2130, April 1997.\n   [RFC2277]    Alvestrand,\
    \ H., \" IETF Policy on Character Sets and\n                Languages\", RFC 2277,\
    \ January 1998.\n   [RFC2279]    Yergeau, F., \"UTF-8, a transformation format\
    \ of ISO\n                10646\", RFC 2279, January 1998.\n   [RFC2389]    Elz,\
    \ R. and P. Hethmon, \"Feature Negotiation Mechanism\n                for the\
    \ File Transfer Protocol\", RFC 2389, August 1998.\n   [UNICODE]    The Unicode\
    \ Consortium, \"The Unicode Standard - Version\n                2.0\", Addison\
    \ Westley Developers Press, July 1996.\n   [UTF-8]      ISO/IEC 10646-1:1993 AMENDMENT\
    \ 2 (1996). UCS\n                Transformation Format 8 (UTF-8).\n"
- title: 9 Author's Address
  contents:
  - "9 Author's Address\n   Bill Curtin\n   JIEO\n   Attn: JEBBD\n   Ft. Monmouth,\
    \ N.J. 07703-5613\n   EMail: curtinw@ftm.disa.mil\n"
- title: Annex A - Implementation Considerations
  contents:
  - 'Annex A - Implementation Considerations

    '
- title: A.1 General Considerations
  contents:
  - "A.1 General Considerations\n   - Implementers should ensure that their code accounts\
    \ for potential\n     problems, such as using a NULL character to terminate a\
    \ string or\n     no longer being able to steal the high order bit for internal\
    \ use,\n     when supporting the extended character set.\n   - Implementers should\
    \ be aware that there is a chance that pathnames\n     that are non UTF-8 may\
    \ be parsed as valid UTF-8. The probabilities\n     are low for some encoding\
    \ or statistically zero to zero for others.\n     A recent non-scientific analysis\
    \ found that EUC encoded Japanese\n     words had a 2.7% false reading; SJIS had\
    \ a 0.0005% false reading;\n     other encoding such as ASCII or KOI-8 have a\
    \ 0% false reading. This\n     probability is highest for short pathnames and\
    \ decreases as\n     pathname size increases. Implementers may want to look for\
    \ signs\n     that pathnames which parse as UTF-8 are not valid UTF-8, such as\n\
    \     the existence of multiple local character sets in short pathnames.\n   \
    \  Hopefully, as more implementations conform to UTF-8 transfer\n     encoding\
    \ there will be a smaller need to guess at the encoding.\n   - Client developers\
    \ should be aware that it will be possible for\n     pathnames to contain mixed\
    \ characters (e.g.\n     //Latin1DirectoryName/HebrewFileName). They should be\
    \ prepared to\n     handle the Bi-directional (BIDI) display of these character\
    \ sets\n     (i.e. right to left display for the directory and left to right\n\
    \     display for the filename). While bi-directional display is outside\n   \
    \  the scope of this document and more complicated than the above\n     example,\
    \ an algorithm for bi-directional display can be found in\n     the UNICODE 2.0\
    \ [UNICODE] standard. Also note that pathnames can\n     have different byte ordering\
    \ yet be logically and display-wise\n     equivalent due to the insertion of BIDI\
    \ control characters at\n     different points during composition. Also note that\
    \ mixed character\n     sets may also present problems with font swapping.\n \
    \  - A server that copies pathnames transparently from a local\n     filesystem\
    \ may continue to do so. It is then up to the local file\n     creators to use\
    \ UTF-8 pathnames.\n   - Servers can supports charset labeling of files and/or\
    \ directories,\n     such that different pathnames may have different charsets.\
    \ The\n     server should attempt to convert all pathnames to UTF-8, but if it\n\
    \     can't then it should leave that name in its raw form.\n   - Some server's\
    \ OS do not mandate character sets, but allow\n     administrators to configure\
    \ it in the FTP server. These servers\n     should be configured to use a particular\
    \ mapping table (either\n     external or built-in). This will allow the flexibility\
    \ of defining\n     different charsets for different directories.\n   - If the\
    \ server's OS does not mandate the character set and the FTP\n     server cannot\
    \ be configured, the server should simply use the raw\n     bytes in the file\
    \ name.  They might be ASCII or UTF-8.\n   - If the server is a mirror, and wants\
    \ to look just like the site it\n     is mirroring, it should store the exact\
    \ file name bytes that it\n     received from the main server.\n"
- title: A.2 Transition Considerations
  contents:
  - "A.2 Transition Considerations\n   - Servers which support this specification,\
    \ when presented a pathname\n     from an old client (one which does not support\
    \ this specification),\n     can nearly always tell whether the pathname is in\
    \ UTF-8 (see B.1)\n     or in some other code set. In order to support these older\
    \ clients,\n     servers may wish to default to a non UTF-8 code set. However,\
    \ how a\n     server supports non UTF-8 is outside the scope of this\n     specification.\n\
    \   - Clients which support this specification will be able to determine\n   \
    \  if the server can support UTF-8 (i.e. supports this specification)\n     by\
    \ the ability of the server to support the FEAT command and the\n     UTF8 feature\
    \ (defined in 3.2). If the newer clients determine that\n     the server does\
    \ not support UTF-8 it may wish to default to a\n     different code set. Client\
    \ developers should take into\n     consideration that pathnames, associated with\
    \ older servers, might\n     be stored in UTF-8. However, how a client supports\
    \ non UTF-8 is\n     outside the scope of this specification.\n   - Clients and\
    \ servers can transition to UTF-8 by either converting\n     to/from the local\
    \ encoding, or the users can store UTF-8 filenames.\n     The former approach\
    \ is easier on tightly controlled file systems\n     (e.g. PCs and MACs). The\
    \ latter approach is easier on more free\n     form file systems (e.g. Unix).\n\
    \   - For interactive use attention should be focused on user interface\n    \
    \ and ease of use. Non-interactive use requires a consistent and\n     controlled\
    \ behavior.\n   - There may be many applications which reference files under their\n\
    \     old raw pathname (e.g. linked URLs). Changing the pathname to UTF-8\n  \
    \   will cause access to the old URL to fail. A solution may be for the\n    \
    \ server to act as if there was 2 different pathnames associated with\n     the\
    \ file. This might be done internal to the server on controlled\n     file systems\
    \ or by using symbolic links on free form systems. While\n     this approach may\
    \ work for single file transfer non-interactive\n     use, a non-interactive transfer\
    \ of all of the files in a directory\n     will produce duplicates. Interactive\
    \ users may be presented with\n     lists of files which are double the actual\
    \ number files.\n"
- title: Annex B - Sample Code and Examples
  contents:
  - 'Annex B - Sample Code and Examples

    '
- title: B.1 Valid UTF-8 check
  contents:
  - "B.1 Valid UTF-8 check\n   The following routine checks if a byte sequence is\
    \ valid UTF-8. This\n   is done by checking for the proper tagging of the first\
    \ and following\n   bytes to make sure they conform to the UTF-8 format. It then\
    \ checks\n   to assure that the data part of the UTF-8 sequence conforms to the\n\
    \   proper range allowed by the encoding. Note: This routine will not\n   detect\
    \ characters that have not been assigned and therefore do not\n   exist.\n"
- title: int utf8_valid(const unsigned char *buf, unsigned int len)
  contents:
  - 'int utf8_valid(const unsigned char *buf, unsigned int len)

    '
- title: '{'
  contents:
  - "{\n const unsigned char *endbuf = buf + len;\n unsigned char byte2mask=0x00,\
    \ c;\n int trailing = 0;  // trailing (continuation) bytes to follow\n while (buf\
    \ != endbuf)\n {\n   c = *buf++;\n   if (trailing)\n    if ((c&0xC0) == 0x80)\
    \  // Does trailing byte follow UTF-8 format?\n    {if (byte2mask)        // Need\
    \ to check 2nd byte for proper range?\n      if (c&byte2mask)     // Are appropriate\
    \ bits set?\n       byte2mask=0x00;\n      else\n       return 0;\n     trailing--;\
    \ }\n    else\n     return 0;\n   else\n    if ((c&0x80) == 0x00)  continue; \
    \     // valid 1 byte UTF-8\n    else if ((c&0xE0) == 0xC0)            // valid\
    \ 2 byte UTF-8\n          if (c&0x1E)                     // Is UTF-8 byte in\n\
    \                                          // proper range?\n           trailing\
    \ =1;\n          else\n           return 0;\n    else if ((c&0xF0) == 0xE0)  \
    \         // valid 3 byte UTF-8\n          {if (!(c&0x0F))                // Is\
    \ UTF-8 byte in\n                                         // proper range?\n \
    \           byte2mask=0x20;              // If not set mask\n                \
    \                         // to check next byte\n            trailing = 2;}\n\
    \    else if ((c&0xF8) == 0xF0)           // valid 4 byte UTF-8\n          {if\
    \ (!(c&0x07))                // Is UTF-8 byte in\n                           \
    \              // proper range?\n            byte2mask=0x30;              // If\
    \ not set mask\n                                         // to check next byte\n\
    \            trailing = 3;}\n    else if ((c&0xFC) == 0xF8)           // valid\
    \ 5 byte UTF-8\n          {if (!(c&0x03))                // Is UTF-8 byte in\n\
    \                                         // proper range?\n            byte2mask=0x38;\
    \              // If not set mask\n                                         //\
    \ to check next byte\n            trailing = 4;}\n    else if ((c&0xFE) == 0xFC)\
    \           // valid 6 byte UTF-8\n          {if (!(c&0x01))                //\
    \ Is UTF-8 byte in\n                                         // proper range?\n\
    \            byte2mask=0x3C;              // If not set mask\n               \
    \                          // to check next byte\n            trailing = 5;}\n\
    \    else  return 0;\n }\n  return trailing == 0;\n"
- title: '}'
  contents:
  - '}

    '
- title: B.2 Conversions
  contents:
  - "B.2 Conversions\n   The code examples in this section closely reflect the algorithm\
    \ in\n   ISO 10646 and may not present the most efficient solution for\n   converting\
    \ to / from UTF-8 encoding. If efficiency is an issue,\n   implementers should\
    \ use the appropriate bitwise operators.\n   Additional code examples and numerous\
    \ mapping tables can be found at\n   the Unicode site, HTTP://www.unicode.org\
    \ or FTP://unicode.org.\n   Note that the conversion examples below assume that\
    \ the local\n   character set supported in the operating system is something other\n\
    \   than UCS2/UTF-16. There are some operating systems that already\n   support\
    \ UCS2/UTF-16 (notably Plan 9 and Windows NT). In this case no\n   conversion\
    \ will be necessary from the local character set to the UCS.\n"
- title: B.2.1 Conversion from Local Character Set to UTF-8
  contents:
  - "B.2.1 Conversion from Local Character Set to UTF-8\n   Conversion from the local\
    \ filesystem character set to UTF-8 will\n   normally involve a two step process.\
    \ First convert the local\n   character set to the UCS; then convert the UCS to\
    \ UTF-8.\n   The first step in the process can be performed by maintaining a\n\
    \   mapping table that includes the local character set code and the\n   corresponding\
    \ UCS code. For instance the ISO/IEC 8859-8 [ISO-8859]\n   code for the Hebrew\
    \ letter \"VAV\" is 0xE4. The corresponding 4 byte\n   ISO/IEC 10646 code is 0x000005D5.\n\
    \   The next step is to convert the UCS character code to the UTF-8\n   encoding.\
    \ The following routine can be used to determine and encode\n   the correct number\
    \ of bytes based on the UCS-4 character code:\n   unsigned int ucs4_to_utf8 (unsigned\
    \ long *ucs4_buf, unsigned int\n                              ucs4_len, unsigned\
    \ char *utf8_buf)\n   {\n    const unsigned long *ucs4_endbuf = ucs4_buf + ucs4_len;\n\
    \    unsigned int utf8_len = 0;        // return value for UTF8 size\n    unsigned\
    \ char *t_utf8_buf = utf8_buf; // Temporary pointer\n                        \
    \                  // to load UTF8 values\n    while (ucs4_buf != ucs4_endbuf)\n\
    \    {\n     if ( *ucs4_buf <= 0x7F)    // ASCII chars no conversion needed\n\
    \     {\n      *t_utf8_buf++ = (unsigned char) *ucs4_buf;\n      utf8_len++;\n\
    \      ucs4_buf++;\n     }\n     else\n      if ( *ucs4_buf <= 0x07FF ) // In\
    \ the 2 byte utf-8 range\n      {\n        *t_utf8_buf++= (unsigned char) (0xC0\
    \ + (*ucs4_buf/0x40));\n        *t_utf8_buf++= (unsigned char) (0x80 + (*ucs4_buf%0x40));\n\
    \        utf8_len+=2;\n        ucs4_buf++;\n      }\n      else\n        if (\
    \ *ucs4_buf <= 0xFFFF ) /* In the 3 byte utf-8 range. The\n                  \
    \                  values 0x0000FFFE, 0x0000FFFF\n                           \
    \         and 0x0000D800 - 0x0000DFFF do\n                                   \
    \ not occur in UCS-4 */\n        {\n         *t_utf8_buf++= (unsigned char) (0xE0\
    \ +\n                        (*ucs4_buf/0x1000));\n         *t_utf8_buf++= (unsigned\
    \ char) (0x80 +\n                        ((*ucs4_buf/0x40)%0x40));\n         *t_utf8_buf++=\
    \ (unsigned char) (0x80 + (*ucs4_buf%0x40));\n         utf8_len+=3;\n        \
    \ ucs4_buf++;\n         }\n        else\n         if ( *ucs4_buf <= 0x1FFFFF )\
    \ //In the 4 byte utf-8 range\n         {\n          *t_utf8_buf++= (unsigned\
    \ char) (0xF0 +\n                         (*ucs4_buf/0x040000));\n          *t_utf8_buf++=\
    \ (unsigned char) (0x80 +\n                         ((*ucs4_buf/0x10000)%0x40));\n\
    \          *t_utf8_buf++= (unsigned char) (0x80 +\n                         ((*ucs4_buf/0x40)%0x40));\n\
    \          *t_utf8_buf++= (unsigned char) (0x80 + (*ucs4_buf%0x40));\n       \
    \   utf8_len+=4;\n          ucs4_buf++;\n         }\n         else\n         \
    \ if ( *ucs4_buf <= 0x03FFFFFF )//In the 5 byte utf-8 range\n          {\n   \
    \        *t_utf8_buf++= (unsigned char) (0xF8 +\n                          (*ucs4_buf/0x01000000));\n\
    \           *t_utf8_buf++= (unsigned char) (0x80 +\n                         \
    \ ((*ucs4_buf/0x040000)%0x40));\n           *t_utf8_buf++= (unsigned char) (0x80\
    \ +\n                          ((*ucs4_buf/0x1000)%0x40));\n           *t_utf8_buf++=\
    \ (unsigned char) (0x80 +\n                          ((*ucs4_buf/0x40)%0x40));\n\
    \           *t_utf8_buf++= (unsigned char) (0x80 +\n                         \
    \ (*ucs4_buf%0x40));\n           utf8_len+=5;\n           ucs4_buf++;\n      \
    \    }\n          else\n          if ( *ucs4_buf <= 0x7FFFFFFF )//In the 6 byte\
    \ utf-8 range\n           {\n             *t_utf8_buf++= (unsigned char)\n   \
    \                         (0xF8 +(*ucs4_buf/0x40000000));\n             *t_utf8_buf++=\
    \ (unsigned char) (0x80 +\n                            ((*ucs4_buf/0x01000000)%0x40));\n\
    \             *t_utf8_buf++= (unsigned char) (0x80 +\n                       \
    \     ((*ucs4_buf/0x040000)%0x40));\n             *t_utf8_buf++= (unsigned char)\
    \ (0x80 +\n                            ((*ucs4_buf/0x1000)%0x40));\n         \
    \    *t_utf8_buf++= (unsigned char) (0x80 +\n                            ((*ucs4_buf/0x40)%0x40));\n\
    \             *t_utf8_buf++= (unsigned char) (0x80 +\n                       \
    \     (*ucs4_buf%0x40));\n             utf8_len+=6;\n             ucs4_buf++;\n\
    \           }\n    }\n    return (utf8_len);\n   }\n"
- title: B.2.2 Conversion from UTF-8 to Local Character Set
  contents:
  - "B.2.2 Conversion from UTF-8 to Local Character Set\n   When moving from UTF-8\
    \ encoding to the local character set the\n   reverse procedure is used. First\
    \ the UTF-8 encoding is transformed\n   into the UCS-4 character set. The UCS-4\
    \ is then converted to the\n   local character set from a mapping table (i.e.\
    \ the opposite of the\n   table used to form the UCS-4 character code).\n   To\
    \ convert from UTF-8 to UCS-4 the free bits (those that do not\n   define UTF-8\
    \ sequence size or signify continuation bytes) in a UTF-8\n   sequence are concatenated\
    \ as a bit string. The bits are then\n   distributed into a four-byte sequence\
    \ starting from the least\n   significant bits. Those bits not assigned a bit\
    \ in the four-byte\n   sequence are padded with ZERO bits. The following routine\
    \ converts\n   the UTF-8 encoding to UCS-4 character codes:\n   int utf8_to_ucs4\
    \ (unsigned long *ucs4_buf, unsigned int utf8_len,\n                     unsigned\
    \ char *utf8_buf)\n   {\n   const unsigned char *utf8_endbuf = utf8_buf + utf8_len;\n\
    \   unsigned int ucs_len=0;\n    while (utf8_buf != utf8_endbuf)\n    {\n    \
    \ if ((*utf8_buf & 0x80) == 0x00)  /*ASCII chars no conversion\n             \
    \                           needed */\n     {\n      *ucs4_buf++ = (unsigned long)\
    \ *utf8_buf;\n      utf8_buf++;\n      ucs_len++;\n     }\n     else\n      if\
    \ ((*utf8_buf & 0xE0)== 0xC0) //In the 2 byte utf-8 range\n      {\n        *ucs4_buf++\
    \ = (unsigned long) (((*utf8_buf - 0xC0) * 0x40)\n                       + ( *(utf8_buf+1)\
    \ - 0x80));\n        utf8_buf += 2;\n        ucs_len++;\n      }\n      else\n\
    \        if ( (*utf8_buf & 0xF0) == 0xE0 ) /*In the 3 byte utf-8\n           \
    \                                 range */\n        {\n        *ucs4_buf++ = (unsigned\
    \ long) (((*utf8_buf - 0xE0) * 0x1000)\n                      + (( *(utf8_buf+1)\
    \ -  0x80) * 0x40)\n                      + ( *(utf8_buf+2) - 0x80));\n      \
    \   utf8_buf+=3;\n         ucs_len++;\n        }\n        else\n         if ((*utf8_buf\
    \ & 0xF8) == 0xF0) /* In the 4 byte utf-8\n                                  \
    \          range */\n         {\n          *ucs4_buf++ = (unsigned long)\n   \
    \                       (((*utf8_buf - 0xF0) * 0x040000)\n                   \
    \       + (( *(utf8_buf+1) -  0x80) * 0x1000)\n                          + ((\
    \ *(utf8_buf+2) -  0x80) * 0x40)\n                          + ( *(utf8_buf+3)\
    \ - 0x80));\n          utf8_buf+=4;\n          ucs_len++;\n         }\n      \
    \   else\n          if ((*utf8_buf & 0xFC) == 0xF8) /* In the 5 byte utf-8\n \
    \                                            range */\n          {\n         \
    \  *ucs4_buf++ = (unsigned long)\n                          (((*utf8_buf - 0xF8)\
    \ * 0x01000000)\n                          + ((*(utf8_buf+1) - 0x80) * 0x040000)\n\
    \                          + (( *(utf8_buf+2) -  0x80) * 0x1000)\n           \
    \               + (( *(utf8_buf+3) -  0x80) * 0x40)\n                        \
    \  + ( *(utf8_buf+4) - 0x80));\n           utf8_buf+=5;\n           ucs_len++;\n\
    \          }\n          else\n           if ((*utf8_buf & 0xFE) == 0xFC) /* In\
    \ the 6 byte utf-8\n                                              range */\n \
    \          {\n             *ucs4_buf++ = (unsigned long)\n                   \
    \        (((*utf8_buf - 0xFC) * 0x40000000)\n                            + ((*(utf8_buf+1)\
    \ - 0x80) * 0x010000000)\n                            + ((*(utf8_buf+2) - 0x80)\
    \ * 0x040000)\n                            + (( *(utf8_buf+3) -  0x80) * 0x1000)\n\
    \                            + (( *(utf8_buf+4) -  0x80) * 0x40)\n           \
    \                 + ( *(utf8_buf+5) - 0x80));\n             utf8_buf+=6;\n   \
    \          ucs_len++;\n           }\n    }\n   return (ucs_len);\n   }\n"
- title: B.2.3 ISO/IEC 8859-8 Example
  contents:
  - "B.2.3 ISO/IEC 8859-8 Example\n   This example demonstrates mapping ISO/IEC 8859-8\
    \ character set to\n   UTF-8 and back to ISO/IEC 8859-8. As noted earlier, the\
    \ Hebrew letter\n   \"VAV\" is convertd from the ISO/IEC 8859-8 character code\
    \ 0xE4 to the\n   corresponding 4 byte ISO/IEC 10646 code of 0x000005D5 by a simple\n\
    \   lookup of a conversion/mapping file.\n   The UCS-4 character code is transformed\
    \ into UTF-8 using the\n   ucs4_to_utf8 routine described earlier by:\n   1. Because\
    \ the UCS-4 character is between 0x80 and 0x07FF it will map\n      to a 2 byte\
    \ UTF-8 sequence.\n   2. The first byte is defined by (0xC0 + (0x000005D5 / 0x40))\
    \ = 0xD7.\n   3. The second byte is defined by (0x80 + (0x000005D5 % 0x40)) =\
    \ 0x95.\n   The UTF-8 encoding is transferred back to UCS-4 by using the\n   utf8_to_ucs4\
    \ routine described earlier by:\n   1. Because the first byte of the sequence,\
    \ when the '&' operator with\n      a value of 0xE0 is applied, will produce 0xC0\
    \ (0xD7 & 0xE0 = 0xC0)\n      the UTF-8 is a 2 byte sequence.\n   2. The four\
    \ byte UCS-4 character code is produced by (((0xD7 - 0xC0)\n      * 0x40) + (0x95\
    \ -0x80)) = 0x000005D5.\n   Finally, the UCS-4 character code is converted to\
    \ ISO/IEC 8859-8\n   character code (using the mapping table which matches ISO/IEC\
    \ 8859-8\n   to UCS-4 ) to produce the original 0xE4 code for the Hebrew letter\n\
    \   \"VAV\".\n"
- title: B.2.4 Vendor Codepage Example
  contents:
  - "B.2.4 Vendor Codepage Example\n   This example demonstrates the mapping of a\
    \ codepage to UTF-8 and back\n   to a vendor codepage. Mapping between vendor\
    \ codepages can be done in\n   a very similar manner as described above. For instance\
    \ both the PC\n   and Mac codepages reflect the character set from the Thai standard\n\
    \   TIS 620-2533. The character code on both platforms for the Thai\n   letter\
    \ \"SO SO\" is 0xAB. This character can then be mapped into the\n   UCS-4 by way\
    \ of a conversion/mapping file to produce the UCS-4 code\n   of 0x0E0B.\n   The\
    \ UCS-4 character code is transformed into UTF-8 using the\n   ucs4_to_utf8 routine\
    \ described earlier by:\n   1. Because the UCS-4 character is between 0x0800 and\
    \ 0xFFFF it will\n      map to a 3 byte UTF-8 sequence.\n   2. The first byte\
    \ is defined by (0xE0 + (0x00000E0B / 0x1000) = 0xE0.\n   3. The second byte is\
    \ defined by (0x80 + ((0x00000E0B / 0x40) %\n      0x40))) = 0xB8.\n   4. The\
    \ third byte is defined by (0x80 + (0x00000E0B % 0x40)) = 0x8B.\n   The UTF-8\
    \ encoding is transferred back to UCS-4 by using the\n   utf8_to_ucs4 routine\
    \ described earlier by:\n   1. Because the first byte of the sequence, when the\
    \ '&' operator with\n      a value of 0xF0 is applied, will produce 0xE0 (0xE0\
    \ & 0xF0 = 0xE0)\n      the UTF-8 is a 3 byte sequence.\n   2. The four byte UCS-4\
    \ character code is produced by (((0xE0 - 0xE0)\n      * 0x1000) + ((0xB8 - 0x80)\
    \ * 0x40) + (0x8B -0x80) = 0x0000E0B.\n   Finally, the UCS-4 character code is\
    \ converted to either the PC or\n   MAC codepage character code (using the mapping\
    \ table which matches\n   codepage to UCS-4 ) to produce the original 0xAB code\
    \ for the Thai\n   letter \"SO SO\".\n"
- title: B.3 Pseudo Code for a High-Quality Translating Server
  contents:
  - "B.3 Pseudo Code for a High-Quality Translating Server\n   if utf8_valid(fn)\n\
    \     {\n     attempt to convert fn to the local charset, producing localfn\n\
    \     if (conversion fails temporarily) return error\n     if (conversion succeeds)\n\
    \     {\n       attempt to open localfn\n       if (open fails temporarily) return\
    \ error\n       if (open succeeds) return success\n     }\n     }\n   attempt\
    \ to open fn\n   if (open fails temporarily) return error\n   if (open succeeds)\
    \ return success\n   return permanent error\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
