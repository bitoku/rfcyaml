- title: __initial_text__
  contents:
  - "                     Codec Control Messages in the\n             RTP Audio-Visual\
    \ Profile with Feedback (AVPF)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a few extensions to the messages defined\
    \ in\n   the Audio-Visual Profile with Feedback (AVPF).  They are helpful\n  \
    \ primarily in conversational multimedia scenarios where centralized\n   multipoint\
    \ functionalities are in use.  However, some are also usable\n   in smaller multicast\
    \ environments and point-to-point calls.\n   The extensions discussed are messages\
    \ related to the ITU-T Rec. H.271\n   Video Back Channel, Full Intra Request,\
    \ Temporary Maximum Media\n   Stream Bit Rate, and Temporal-Spatial Trade-off.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Definitions .....................................................5\n  \
    \    2.1. Glossary ...................................................5\n    \
    \  2.2. Terminology ................................................5\n      2.3.\
    \ Topologies .................................................8\n   3. Motivation\
    \ ......................................................8\n      3.1. Use Cases\
    \ ..................................................9\n      3.2. Using the Media\
    \ Path ......................................11\n      3.3. Using AVPF ................................................11\n\
    \           3.3.1. Reliability ........................................12\n  \
    \    3.4. Multicast .................................................12\n    \
    \  3.5. Feedback Messages .........................................12\n      \
    \     3.5.1. Full Intra Request Command .........................12\n        \
    \          3.5.1.1. Reliability ...............................13\n          \
    \ 3.5.2. Temporal-Spatial Trade-off Request and\n                  Notification\
    \ .......................................14\n                  3.5.2.1. Point-to-Point\
    \ ............................15\n                  3.5.2.2. Point-to-Multipoint\
    \ Using\n                           Multicast or Translators ..................15\n\
    \                  3.5.2.3. Point-to-Multipoint Using RTP Mixer .......15\n  \
    \                3.5.2.4. Reliability ...............................16\n    \
    \       3.5.3. H.271 Video Back Channel Message ...................16\n      \
    \            3.5.3.1. Reliability ...............................19\n        \
    \   3.5.4. Temporary Maximum Media Stream Bit Rate\n                  Request\
    \ and Notification ...........................19\n                  3.5.4.1. Behavior\
    \ for Media Receivers Using TMMBR ..21\n                  3.5.4.2. Algorithm for\
    \ Establishing Current\n                           Limitations ...............................23\n\
    \                  3.5.4.3. Use of TMMBR in a Mixer-Based\n                  \
    \         Multipoint Operation ......................29\n                  3.5.4.4.\
    \ Use of TMMBR in Point-to-Multipoint Using\n                           Multicast\
    \ or Translators ..................30\n                  3.5.4.5. Use of TMMBR\
    \ in Point-to-Point Operation ..31\n                  3.5.4.6. Reliability ...............................31\n\
    \   4. RTCP Receiver Report Extensions ................................32\n  \
    \    4.1. Design Principles of the Extension Mechanism ..............32\n    \
    \  4.2. Transport Layer Feedback Messages .........................33\n      \
    \     4.2.1. Temporary Maximum Media Stream Bit Rate\n                  Request\
    \ (TMMBR) ....................................34\n                  4.2.1.1. Message\
    \ Format ............................34\n                  4.2.1.2. Semantics\
    \ .................................35\n                  4.2.1.3. Timing Rules\
    \ ..............................39\n                  4.2.1.4. Handling in Translators\
    \ and Mixers ........39\n           4.2.2. Temporary Maximum Media Stream Bit\
    \ Rate\n                  Notification (TMMBN) ...............................39\n\
    \                  4.2.2.1. Message Format ............................39\n  \
    \                4.2.2.2. Semantics .................................40\n    \
    \              4.2.2.3. Timing Rules ..............................41\n      \
    \            4.2.2.4. Handling by Translators and Mixers ........41\n      4.3.\
    \ Payload-Specific Feedback Messages ........................41\n           4.3.1.\
    \ Full Intra Request (FIR) ...........................42\n                  4.3.1.1.\
    \ Message Format ............................42\n                  4.3.1.2. Semantics\
    \ .................................43\n                  4.3.1.3. Timing Rules\
    \ ..............................44\n                  4.3.1.4. Handling of FIR\
    \ Message in Mixers and\n                           Translators ...............................44\n\
    \                  4.3.1.5. Remarks ...................................44\n  \
    \         4.3.2. Temporal-Spatial Trade-off Request (TSTR) ..........45\n    \
    \              4.3.2.1. Message Format ............................46\n      \
    \            4.3.2.2. Semantics .................................46\n        \
    \          4.3.2.3. Timing Rules ..............................47\n          \
    \        4.3.2.4. Handling of Message in Mixers and\n                        \
    \   Translators ...............................47\n                  4.3.2.5.\
    \ Remarks ...................................47\n           4.3.3. Temporal-Spatial\
    \ Trade-off Notification (TSTN) .....48\n                  4.3.3.1. Message Format\
    \ ............................48\n                  4.3.3.2. Semantics .................................49\n\
    \                  4.3.3.3. Timing Rules ..............................49\n  \
    \                4.3.3.4. Handling of TSTN in Mixers and\n                   \
    \        Translators ...............................49\n                  4.3.3.5.\
    \ Remarks ...................................49\n           4.3.4. H.271 Video\
    \ Back Channel Message (VBCM) ............50\n                  4.3.4.1. Message\
    \ Format ............................50\n                  4.3.4.2. Semantics\
    \ .................................51\n                  4.3.4.3. Timing Rules\
    \ ..............................52\n                  4.3.4.4. Handling of Message\
    \ in Mixers or\n                           Translators ...............................52\n\
    \                  4.3.4.5. Remarks ...................................52\n  \
    \ 5. Congestion Control .............................................52\n   6.\
    \ Security Considerations ........................................53\n   7. SDP\
    \ Definitions ................................................54\n      7.1. Extension\
    \ of the rtcp-fb Attribute ........................54\n      7.2. Offer-Answer\
    \ ..............................................55\n      7.3. Examples ..................................................56\n\
    \   8. IANA Considerations ............................................58\n  \
    \ 9. Contributors ...................................................60\n   10.\
    \ Acknowledgements ..............................................60\n   11. References\
    \ ....................................................60\n      11.1. Normative\
    \ References .....................................60\n      11.2. Informative\
    \ References ...................................61\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   When the Audio-Visual Profile with Feedback (AVPF) [RFC4585]\
    \ was\n   developed, the main emphasis lay in the efficient support of point-\n\
    \   to-point and small multipoint scenarios without centralized\n   multipoint\
    \ control.  However, in practice, many small multipoint\n   conferences operate\
    \ utilizing devices known as Multipoint Control\n   Units (MCUs).  Long-standing\
    \ experience of the conversational video\n   conferencing industry suggests that\
    \ there is a need for a few\n   additional feedback messages, to support centralized\
    \ multipoint\n   conferencing efficiently.  Some of the messages have applications\n\
    \   beyond centralized multipoint, and this is indicated in the\n   description\
    \ of the message.  This is especially true for the message\n   intended to carry\
    \ ITU-T Rec. H.271 [H.271] bit strings for Video Back\n   Channel messages.\n\
    \   In Real-time Transport Protocol (RTP) [RFC3550] terminology, MCUs\n   comprise\
    \ mixers and translators.  Most MCUs also include signaling\n   support.  During\
    \ the development of this memo, it was noticed that\n   there is considerable\
    \ confusion in the community related to the use\n   of terms such as mixer, translator,\
    \ and MCU.  In response to these\n   concerns, a number of topologies have been\
    \ identified that are of\n   practical relevance to the industry, but are not\
    \ documented in\n   sufficient detail in [RFC3550].  These topologies are documented\
    \ in\n   [RFC5117], and understanding this memo requires previous or parallel\n\
    \   study of [RFC5117].\n   Some of the messages defined here are forward only,\
    \ in that they do\n   not require an explicit notification to the message emitter\
    \ that they\n   have been received and/or indicating the message receiver's actions.\n\
    \   Other messages require a response, leading to a two-way communication\n  \
    \ model that one could view as useful for control purposes.  However,\n   it is\
    \ not the intention of this memo to open up RTP Control Protocol\n   (RTCP) to\
    \ a generalized control protocol.  All mentioned messages\n   have relatively\
    \ strict real-time constraints, in the sense that their\n   value diminishes with\
    \ increased delay.  This makes the use of more\n   traditional control protocol\
    \ means, such as Session Initiation\n   Protocol (SIP) [RFC3261], undesirable\
    \ when used for the same purpose.\n   That is why this solution is recommended\
    \ instead of \"XML Schema for\n   Media Control\" [XML-MC], which uses SIP Info\
    \ to transfer XML messages\n   with similar semantics to what are defined in this\
    \ memo.\n   Furthermore, all messages are of a very simple format that can be\n\
    \   easily processed by an RTP/RTCP sender/receiver.  Finally, and most\n   importantly,\
    \ all messages relate only to the RTP stream with which\n   they are associated,\
    \ and not to any other property of a communication\n   system.  In particular,\
    \ none of them relate to the properties of the\n   access links traversed by the\
    \ session.\n"
- title: 2.  Definitions
  contents:
  - '2.  Definitions

    '
- title: 2.1.  Glossary
  contents:
  - "2.1.  Glossary\n   AIMD   - Additive Increase Multiplicative Decrease\n   AVPF\
    \   - The extended RTP profile for RTCP-based feedback\n   FCI    - Feedback Control\
    \ Information [RFC4585]\n   FEC    - Forward Error Correction\n   FIR    - Full\
    \ Intra Request\n   MCU    - Multipoint Control Unit\n   MPEG   - Moving Picture\
    \ Experts Group\n   PLI    - Picture Loss Indication\n   PR     - Packet rate\n\
    \   QP     - Quantizer Parameter\n   RTT    - Round trip time\n   SSRC   - Synchronization\
    \ Source\n   TMMBN  - Temporary Maximum Media Stream Bit Rate Notification\n \
    \  TMMBR  - Temporary Maximum Media Stream Bit Rate Request\n   TSTN   - Temporal-Spatial\
    \ Trade-off Notification\n   TSTR   - Temporal-Spatial Trade-off Request\n   VBCM\
    \   - Video Back Channel Message\n"
- title: 2.2.  Terminology
  contents:
  - "2.2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ RFC 2119 [RFC2119].\n      Message:\n          An RTCP feedback message [RFC4585]\
    \ defined by this\n          specification, of one of the following types:\n \
    \         Request:\n              Message that requires acknowledgement\n    \
    \      Command:\n              Message that forces the receiver to an action\n\
    \          Indication:\n              Message that reports a situation\n     \
    \     Notification:\n              Message that provides a notification that an\
    \ event has\n              occurred.  Notifications are commonly generated in\n\
    \              response to a Request.\n   Note that, with the exception of \"\
    Notification\", this terminology is\n   in alignment with ITU-T Rec. H.245 [H245].\n\
    \   Decoder Refresh Point:\n          A bit string, packetized in one or more\
    \ RTP packets, that\n          completely resets the decoder to a known state.\n\
    \          Examples for \"hard\" decoder refresh points are Intra pictures\n \
    \         in H.261, H.263, MPEG-1, MPEG-2, and MPEG-4 part 2, and\n          Instantaneous\
    \ Decoder Refresh (IDR) pictures in H.264.\n          \"Gradual\" decoder refresh\
    \ points may also be used; see for\n          example [AVC].  While both \"hard\"\
    \ and \"gradual\" decoder\n          refresh points are acceptable in the scope\
    \ of this\n          specification, in most cases the user experience will benefit\n\
    \          from using a \"hard\" decoder refresh point.\n          A decoder refresh\
    \ point also contains all header information\n          above the picture layer\
    \ (or equivalent, depending on the video\n          compression standard) that\
    \ is conveyed in-band.  In H.264, for\n          example, a decoder refresh point\
    \ contains parameter set\n          Network Adaptation Layer (NAL) units that\
    \ generate parameter\n          sets necessary for the decoding of the following\
    \ slice/data\n          partition NAL units (and that are not conveyed out of\
    \ band).\n   Decoding:\n          The operation of reconstructing the media stream.\n\
    \   Rendering:\n          The operation of presenting (parts of) the reconstructed\
    \ media\n          stream to the user.\n   Stream thinning:\n          The operation\
    \ of removing some of the packets from a media\n          stream.  Stream thinning,\
    \ preferably, is media-aware, implying\n          that media packets are removed\
    \ in the order of increasing\n          relevance to the reproductive quality.\
    \  However, even when\n          employing media-aware stream thinning, most media\
    \ streams\n          quickly lose quality when subjected to increasing levels\
    \ of\n          thinning.  Media-unaware stream thinning leads to even worse\n\
    \          quality degradation.  In contrast to transcoding, stream\n        \
    \  thinning is typically seen as a computationally lightweight\n          operation.\n\
    \   Media:\n          Often used (sometimes in conjunction with terms like bit\
    \ rate,\n          stream, sender, etc.) to identify the content of the forward\n\
    \          RTP packet stream (carrying the codec data), to which the\n       \
    \   codec control message applies.\n   Media Stream:\n          The stream of\
    \ RTP packets labeled with a single\n          Synchronization Source (SSRC) carrying\
    \ the media (and also in\n          some cases repair information such as retransmission\
    \ or\n          Forward Error Correction (FEC) information).\n   Total media bit\
    \ rate:\n          The total bits per second transferred in a media stream,\n\
    \          measured at an observer-selected protocol layer and averaged\n    \
    \      over a reasonable timescale, the length of which depends on\n         \
    \ the application.  In general, a media sender and a media\n          receiver\
    \ will observe different total media bit rates for the\n          same stream,\
    \ first because they may have selected different\n          reference protocol\
    \ layers, and second, because of changes in\n          per-packet overhead along\
    \ the transmission path.  The goal\n          with bit rate averaging is to be\
    \ able to ignore any burstiness\n          on very short timescales (e.g., below\
    \ 100 ms) introduced by\n          scheduling or link layer packetization effects.\n\
    \   Maximum total media bit rate:\n          The upper limit on total media bit\
    \ rate for a given media\n          stream at a particular receiver and for its\
    \ selected protocol\n          layer.  Note that this value cannot be measured\
    \ on the\n          received media stream.  Instead, it needs to be calculated\
    \ or\n          determined through other means, such as quality of service\n \
    \         (QoS) negotiations or local resource limitations.  Also note\n     \
    \     that this value is an average (on a timescale that is\n          reasonable\
    \ for the application) and that it may be different\n          from the instantaneous\
    \ bit rate seen by packets in the media\n          stream.\n   Overhead:\n   \
    \       All protocol header information required to convey a packet\n        \
    \  with media data from sender to receiver, from the application\n          layer\
    \ down to a pre-defined protocol level (for example, down\n          to, and including,\
    \ the IP header).  Overhead may include, for\n          example, IP, UDP, and\
    \ RTP headers, any layer 2 headers, any\n          Contributing Sources (CSRCs),\
    \ RTP padding, and RTP header\n          extensions.  Overhead excludes any RTP\
    \ payload headers and the\n          payload itself.\n   Net media bit rate:\n\
    \          The bit rate carried by a media stream, net of overhead.  That\n  \
    \        is, the bits per second accounted for by encoded media, any\n       \
    \   applicable payload headers, and any directly associated meta\n          payload\
    \ information placed in the RTP packet.  A typical\n          example of the latter\
    \ is redundancy data provided by the use\n          of RFC 2198 [RFC2198].  Note\
    \ that, unlike the total media bit\n          rate, the net media bit rate will\
    \ have the same value at the\n          media sender and at the media receiver\
    \ unless any mixing or\n          translating of the media has occurred.\n   \
    \       For a given observer, the total media bit rate for a media\n         \
    \ stream is equal to the sum of the net media bit rate and the\n          per-packet\
    \ overhead as defined above multiplied by the packet\n          rate.\n   Feasible\
    \ region:\n          The set of all combinations of packet rate and net media\
    \ bit\n          rate that do not exceed the restrictions in maximum media bit\n\
    \          rate placed on a given media sender by the Temporary Maximum\n    \
    \      Media Stream Bit Rate Request (TMMBR) messages it has\n          received.\
    \  The feasible region will change as new TMMBR\n          messages are received.\n\
    \   Bounding set:\n          The set of TMMBR tuples, selected from all those\
    \ received at a\n          given media sender, that define the feasible region\
    \ for that\n          media sender.  The media sender uses an algorithm such as\
    \ that\n          in section 3.5.4.2 to determine or iteratively approximate the\n\
    \          current bounding set, and reports that set back to the media\n    \
    \      receivers in a Temporary Maximum Media Stream Bit Rate\n          Notification\
    \ (TMMBN) message.\n"
- title: 2.3.  Topologies
  contents:
  - "2.3.  Topologies\n   Please refer to [RFC5117] for an in-depth discussion.  The\
    \ topologies\n   referred to throughout this memo are labeled (consistently with\n\
    \   [RFC5117]) as follows:\n   Topo-Point-to-Point . . . . . Point-to-point communication\n\
    \   Topo-Multicast  . . . . . . . Multicast communication\n   Topo-Translator\
    \ . . . . . . . Translator based\n   Topo-Mixer  . . . . . . . . . Mixer based\n\
    \   Topo-RTP-switch-MCU . . . . . RTP stream switching MCU\n   Topo-RTCP-terminating-MCU\
    \ . . Mixer but terminating RTCP\n"
- title: 3.  Motivation
  contents:
  - "3.  Motivation\n   This section discusses the motivation and usage of the different\n\
    \   video and media control messages.  The video control messages have\n   been\
    \ under discussion for a long time, and a requirement document was\n   drawn up\
    \ [Basso].  That document has expired; however, we quote\n   relevant sections\
    \ of it to provide motivation and requirements.\n"
- title: 3.1.  Use Cases
  contents:
  - "3.1.  Use Cases\n   There are a number of possible usages for the proposed feedback\n\
    \   messages.  Let us begin by looking through the use cases Basso et al.\n  \
    \ [Basso] proposed.  Some of the use cases have been reformulated and\n   comments\
    \ have been added.\n   1. An RTP video mixer composes multiple encoded video sources\
    \ into a\n      single encoded video stream.  Each time a video source is added,\n\
    \      the RTP mixer needs to request a decoder refresh point from the\n     \
    \ video source, so as to start an uncorrupted prediction chain on\n      the spatial\
    \ area of the mixed picture occupied by the data from\n      the new video source.\n\
    \   2. An RTP video mixer receives multiple encoded RTP video streams\n      from\
    \ conference participants, and dynamically selects one of the\n      streams to\
    \ be included in its output RTP stream.  At the time of a\n      bit stream change\
    \ (determined through means such as voice\n      activation or the user interface),\
    \ the mixer requests a decoder\n      refresh point from the remote source, in\
    \ order to avoid using\n      unrelated content as reference data for inter picture\
    \ prediction.\n      After requesting the decoder refresh point, the video mixer\
    \ stops\n      the delivery of the current RTP stream and monitors the RTP stream\n\
    \      from the new source until it detects data belonging to the decoder\n  \
    \    refresh point.  At that time, the RTP mixer starts forwarding the\n     \
    \ newly selected stream to the receiver(s).\n   3. An application needs to signal\
    \ to the remote encoder that the\n      desired trade-off between temporal and\
    \ spatial resolution has\n      changed.  For example, one user may prefer a higher\
    \ frame rate and\n      a lower spatial quality, and another user may prefer the\
    \ opposite.\n      This choice is also highly content dependent.  Many current\
    \ video\n      conferencing systems offer in the user interface a mechanism to\n\
    \      make this selection, usually in the form of a slider.  The\n      mechanism\
    \ is helpful in point-to-point, centralized multipoint and\n      non-centralized\
    \ multipoint uses.\n   4. Use case 4 of the Basso document applies only to Picture\
    \ Loss\n      Indication (PLI) as defined in AVPF [RFC4585] and is not\n     \
    \ reproduced here.\n   5. Use case 5 of the Basso document relates to a mechanism\
    \ known as\n      \"freeze picture request\".  Sending freeze picture requests\
    \ over a\n      non-reliable forward RTCP channel has been identified as\n   \
    \   problematic.  Therefore, no freeze picture request has been\n      included\
    \ in this memo, and the use case discussion is not\n      reproduced here.\n \
    \  6. A video mixer dynamically selects one of the received video\n      streams\
    \ to be sent out to participants and tries to provide the\n      highest bit rate\
    \ possible to all participants, while minimizing\n      stream trans-rating. \
    \ One way of achieving this is to set up\n      sessions with endpoints using\
    \ the maximum bit rate accepted by\n      each endpoint, and accepted by the call\
    \ admission method used by\n      the mixer.  By means of commands that reduce\
    \ the maximum media\n      stream bit rate below what has been negotiated during\
    \ session set\n      up, the mixer can reduce the maximum bit rate sent by endpoints\
    \ to\n      the lowest of all the accepted bit rates.  As the lowest accepted\n\
    \      bit rate changes due to endpoints joining and leaving or due to\n     \
    \ network congestion, the mixer can adjust the limits at which\n      endpoints\
    \ can send their streams to match the new value.  The\n      mixer then requests\
    \ a new maximum bit rate, which is equal to or\n      less than the maximum bit\
    \ rate negotiated at session setup for a\n      specific media stream, and the\
    \ remote endpoint can respond with\n      the actual bit rate that it can support.\n\
    \   The picture Basso, et al., draw up covers most applications we\n   foresee.\
    \  However, we would like to extend the list with two\n   additional use cases:\n\
    \   7. Currently deployed congestion control algorithms (AIMD and TCP\n      Friendly\
    \ Rate Control (TFRC) [RFC3448]) probe for additional\n      available capacity\
    \ as long as there is something to send.  With\n      congestion control algorithms\
    \ using packet loss as the indication\n      for congestion, this probing generally\
    \ results in reduced media\n      quality (often to a point where the distortion\
    \ is large enough to\n      make the media unusable), due to packet loss and increased\
    \ delay.\n      In a number of deployment scenarios, especially cellular ones,\
    \ the\n      bottleneck link is often the last hop link.  That cellular link\n\
    \      also commonly has some type of QoS negotiation enabling the\n      cellular\
    \ device to learn the maximal bit rate available over this\n      last hop.  A\
    \ media receiver behind this link can, in most (if not\n      all) cases, calculate\
    \ at least an upper bound for the bit rate\n      available for each media stream\
    \ it presently receives.  How this\n      is done is an implementation detail\
    \ and not discussed herein.\n      Indicating the maximum available bit rate to\
    \ the transmitting\n      party for the various media streams can be beneficial\
    \ to prevent\n      that party from probing for bandwidth for this stream in excess\
    \ of\n      a known hard limit.  For cellular or other mobile devices, the\n \
    \     known available bit rate for each stream (deduced from the link\n      bit\
    \ rate) can change quickly, due to handover to another\n      transmission technology,\
    \ QoS renegotiation due to congestion, etc.\n      To enable minimal disruption\
    \ of service, quick convergence is\n      necessary, and therefore media path\
    \ signaling is desirable.\n    8. The use of reference picture selection (RPS)\
    \ as an error\n       resilience tool was introduced in 1997 as NEWPRED [NEWPRED],\
    \ and\n       is now widely deployed.  When RPS is in use, simplistically put,\n\
    \       the receiver can send a feedback message to the sender,\n       indicating\
    \ a reference picture that should be used for future\n       prediction.  ([NEWPRED]\
    \ mentions other forms of feedback as\n       well.)  AVPF contains a mechanism\
    \ for conveying such a message,\n       but did not specify for which codec and\
    \ according to which syntax\n       the message should conform.  Recently, the\
    \ ITU-T finalized Rec.\n       H.271, which (among other message types) also includes\
    \ a feedback\n       message.  It is expected that this feedback message will\
    \ fairly\n       quickly enjoy wide support.  Therefore, a mechanism to convey\n\
    \       feedback messages according to H.271 appears to be desirable.\n"
- title: 3.2.  Using the Media Path
  contents:
  - "3.2.  Using the Media Path\n   There are two reasons why we use the media path\
    \ for the codec control\n   messages.\n   First, systems employing MCUs often\
    \ separate the control and media\n   processing parts.  As these messages are\
    \ intended for or generated by\n   the media part rather than the signaling part\
    \ of the MCU, having them\n   on the media path avoids transmission across interfaces\
    \ and\n   unnecessary control traffic between signaling and processing.  If the\n\
    \   MCU is physically decomposed, the use of the media path avoids the\n   need\
    \ for media control protocol extensions (e.g., in media gateway\n   control (MEGACO)\
    \ [RFC3525]).\n   Secondly, the signaling path quite commonly contains several\n\
    \   signaling entities, e.g., SIP proxies and application servers.\n   Avoiding\
    \ going through signaling entities avoids delay for several\n   reasons.  Proxies\
    \ have less stringent delay requirements than media\n   processing, and due to\
    \ their complex and more generic nature may\n   result in significant processing\
    \ delay.  The topological locations of\n   the signaling entities are also commonly\
    \ not optimized for minimal\n   delay, but rather towards other architectural\
    \ goals.  Thus, the\n   signaling path can be significantly longer in both geographical\
    \ and\n   delay sense.\n"
- title: 3.3.  Using AVPF
  contents:
  - "3.3.  Using AVPF\n   The AVPF feedback message framework [RFC4585] provides the\n\
    \   appropriate framework to implement the new messages.  AVPF implements\n  \
    \ rules controlling the timing of feedback messages to avoid congestion\n   through\
    \ network flooding by RTCP traffic.  We re-use these rules by\n   referencing\
    \ AVPF.\n   The signaling setup for AVPF allows each individual type of function\n\
    \   to be configured or negotiated on an RTP session basis.\n"
- title: 3.3.1.  Reliability
  contents:
  - "3.3.1.  Reliability\n   The use of RTCP messages implies that each message transfer\
    \ is\n   unreliable, unless the lower layer transport provides reliability.\n\
    \   The different messages proposed in this specification have different\n   requirements\
    \ in terms of reliability.  However, in all cases, the\n   reaction to an (occasional)\
    \ loss of a feedback message is specified.\n"
- title: 3.4.  Multicast
  contents:
  - "3.4.  Multicast\n   The codec control messages might be used with multicast.\
    \  The RTCP\n   timing rules specified in [RFC3550] and [RFC4585] ensure that\
    \ the\n   messages do not cause overload of the RTCP connection.  The use of\n\
    \   multicast may result in the reception of messages with inconsistent\n   semantics.\
    \  The reaction to inconsistencies depends on the message\n   type, and is discussed\
    \ for each message type separately.\n"
- title: 3.5.  Feedback Messages
  contents:
  - "3.5.  Feedback Messages\n   This section describes the semantics of the different\
    \ feedback\n   messages and how they apply to the different use cases.\n"
- title: 3.5.1.  Full Intra Request Command
  contents:
  - "3.5.1.  Full Intra Request Command\n   A Full Intra Request (FIR) Command, when\
    \ received by the designated\n   media sender, requires that the media sender\
    \ sends a Decoder Refresh\n   Point (see section 2.2) at the earliest opportunity.\
    \  The evaluation\n   of such an opportunity includes the current encoder coding\
    \ strategy\n   and the current available network resources.\n   FIR is also known\
    \ as an \"instantaneous decoder refresh request\",\n   \"fast video update request\"\
    \ or \"video fast update request\".\n   Using a decoder refresh point implies\
    \ refraining from using any\n   picture sent prior to that point as a reference\
    \ for the encoding\n   process of any subsequent picture sent in the stream. \
    \ For predictive\n   media types that are not video, the analogue applies.  For\
    \ example,\n   if in MPEG-4 systems scene updates are used, the decoder refresh\n\
    \   point consists of the full representation of the scene and is not\n   delta-coded\
    \ relative to previous updates.\n   Decoder refresh points, especially Intra or\
    \ IDR pictures, are in\n   general several times larger in size than predicted\
    \ pictures.  Thus,\n   in scenarios in which the available bit rate is small,\
    \ the use of a\n   decoder refresh point implies a delay that is significantly\
    \ longer\n   than the typical picture duration.\n   Usage in multicast is possible;\
    \ however, aggregation of the commands\n   is recommended.  A receiver that receives\
    \ a request closely after\n   sending a decoder refresh point -- within 2 times\
    \ the longest round\n   trip time (RTT) known, plus any AVPF-induced RTCP packet\
    \ sending\n   delays -- should await a second request message to ensure that the\n\
    \   media receiver has not been served by the previously delivered\n   decoder\
    \ refresh point.  The reason for the specified delay is to\n   avoid sending unnecessary\
    \ decoder refresh points.  A session\n   participant may have sent its own request\
    \ while another participant's\n   request was in-flight to them.  Suppressing\
    \ those requests that may\n   have been sent without knowledge about the other\
    \ request avoids this\n   issue.\n   Using the FIR command to recover from errors\
    \ is explicitly\n   disallowed, and instead the PLI message defined in AVPF [RFC4585]\n\
    \   should be used.  The PLI message reports lost pictures and has been\n   included\
    \ in AVPF for precisely that purpose.\n   Full Intra Request is applicable in\
    \ use-cases 1 and 2.\n"
- title: 3.5.1.1.  Reliability
  contents:
  - "3.5.1.1.  Reliability\n   The FIR message results in the delivery of a decoder\
    \ refresh point,\n   unless the message is lost.  Decoder refresh points are easily\n\
    \   identifiable from the bit stream.  Therefore, there is no need for\n   protocol-level\
    \ notification, and a simple command repetition\n   mechanism is sufficient for\
    \ ensuring the level of reliability\n   required.  However, the potential use\
    \ of repetition does require a\n   mechanism to prevent the recipient from responding\
    \ to messages\n   already received and responded to.\n   To ensure the best possible\
    \ reliability, a sender of FIR may repeat\n   the FIR until the desired content\
    \ has been received.  The repetition\n   interval is determined by the RTCP timing\
    \ rules applicable to the\n   session.  Upon reception of a complete decoder refresh\
    \ point or the\n   detection of an attempt to send a decoder refresh point (which\
    \ got\n   damaged due to a packet loss), the repetition of the FIR must stop.\n\
    \   If another FIR is necessary, the request sequence number must be\n   increased.\
    \  A FIR sender shall not have more than one FIR (different\n   request sequence\
    \ number) outstanding at any time per media sender in\n   the session.\n   The\
    \ receiver of FIR (i.e., the media sender) behaves in complementary\n   fashion\
    \ to ensure delivery of a decoder refresh point.  If it\n   receives repetitions\
    \ of the FIR more than 2*RTT after it has sent a\n   decoder refresh point, it\
    \ shall send a new decoder refresh point.\n   Two round trip times allow time\
    \ for the decoder refresh point to\n   arrive back to the requestor and for the\
    \ end of repetitions of FIR to\n   reach and be detected by the media sender.\n\
    \   An RTP mixer or RTP switching MCU that receive a FIR from a media\n   receiver\
    \ is responsible to ensure that a decoder refresh point is\n   delivered to the\
    \ requesting receiver.  It may be necessary for the\n   mixer/MCU to generate\
    \ FIR commands.  From a reliability perspective,\n   the two legs (FIR-requesting\
    \ endpoint to mixer/MCU, and mixer/MCU to\n   decoder refresh point generating\
    \ endpoint) are handled independently\n   from each other.\n"
- title: 3.5.2.  Temporal-Spatial Trade-off Request and Notification
  contents:
  - "3.5.2.  Temporal-Spatial Trade-off Request and Notification\n   The Temporal-Spatial\
    \ Trade-off Request (TSTR) instructs the video\n   encoder to change its trade-off\
    \ between temporal and spatial\n   resolution.  Index values from 0 to 31 indicate\
    \ monotonically a\n   desire for higher frame rate.  That is, a requester asking\
    \ for an\n   index of 0 prefers a high quality and is willing to accept a low\n\
    \   frame rate, whereas a requester asking for 31 wishes a high frame\n   rate,\
    \ potentially at the cost of low spatial quality.\n   In general, the encoder\
    \ reaction time may be significantly longer\n   than the typical picture duration.\
    \  See use case 3 for an example.\n   The encoder decides whether and to what\
    \ extent the request results in\n   a change of the trade-off.  It returns a Temporal-Spatial\
    \ Trade-off\n   Notification (TSTN) message to indicate the trade-off that it\
    \ will\n   use henceforth.\n   TSTR and TSTN have been introduced primarily because\
    \ it is believed\n   that control protocol mechanisms, e.g., a SIP re-invite,\
    \ are too\n   heavyweight and too slow to allow for a reasonable user experience.\n\
    \   Consider, for example, a user interface where the remote user selects\n  \
    \ the temporal/spatial trade-off with a slider.  An immediate feedback\n   to\
    \ any slider movement is required for a reasonable user experience.\n   A SIP\
    \ re-INVITE [RFC3261] would require at least two round-trips more\n   (compared\
    \ to the TSTR/TSTN mechanism) and may involve proxies and\n   other complex mechanisms.\
    \  Even in a well-designed system, it could\n   take a second or so until the\
    \ new trade-off is finally selected.\n   Furthermore, the use of RTCP solves the\
    \ multicast use case very\n   efficiently.\n   The use of TSTR and TSTN in multipoint\
    \ scenarios is a non-trivial\n   subject, and can be achieved in many implementation-specific\
    \ ways.\n   Problems stem from the fact that TSTRs will typically arrive\n   unsynchronized,\
    \ and may request different trade-off values for the\n   same stream and/or endpoint\
    \ encoder.  This memo does not specify a\n   translator's, mixer's, or endpoint's\
    \ reaction to the reception of a\n   suggested trade-off as conveyed in the TSTR.\
    \  We only require the\n   receiver of a TSTR message to reply to it by sending\
    \ a TSTN, carrying\n   the new trade-off chosen by its own criteria (which may\
    \ or may not be\n   based on the trade-off conveyed by the TSTR).  In other words,\
    \ the\n   trade-off sent in a TSTR is a non-binding recommendation, nothing\n\
    \   more.\n   Three TSTR/TSTN scenarios need to be distinguished, based on the\n\
    \   topologies described in [RFC5117].  The scenarios are described in\n   the\
    \ following subsections.\n"
- title: 3.5.2.1.  Point-to-Point
  contents:
  - "3.5.2.1.  Point-to-Point\n   In this most trivial case (Topo-Point-to-Point),\
    \ the media sender\n   typically adjusts its temporal/spatial trade-off based\
    \ on the\n   requested value in TSTR, subject to its own capabilities.  The TSTN\n\
    \   message conveys back the new trade-off value (which may be identical\n   to\
    \ the old one if, for example, the sender is not capable of\n   adjusting its\
    \ trade-off).\n"
- title: 3.5.2.2.  Point-to-Multipoint Using Multicast or Translators
  contents:
  - "3.5.2.2.  Point-to-Multipoint Using Multicast or Translators\n   RTCP Multicast\
    \ is used either with media multicast according to\n   Topo-Multicast, or following\
    \ RFC 3550's translator model according to\n   Topo-Translator.  In these cases,\
    \ unsynchronized TSTR messages from\n   different receivers may be received, possibly\
    \ with different\n   requested trade-offs (because of different user preferences).\
    \  This\n   memo does not specify how the media sender tunes its trade-off.\n\
    \   Possible strategies include selecting the mean or median of all\n   trade-off\
    \ requests received, giving priority to certain participants,\n   or continuing\
    \ to use the previously selected trade-off (e.g., when\n   the sender is not capable\
    \ of adjusting it).  Again, all TSTR messages\n   need to be acknowledged by TSTN,\
    \ and the value conveyed back has to\n   reflect the decision made.\n"
- title: 3.5.2.3.  Point-to-Multipoint Using RTP Mixer
  contents:
  - "3.5.2.3.  Point-to-Multipoint Using RTP Mixer\n   In this scenario (Topo-Mixer),\
    \ the RTP mixer receives all TSTR\n   messages, and has the opportunity to act\
    \ on them based on its own\n   criteria.  In most cases, the mixer should form\
    \ a \"consensus\" of\n   potentially conflicting TSTR messages arriving from different\n\
    \   participants, and initiate its own TSTR message(s) to the media\n   sender(s).\
    \  As in the previous scenario, the strategy for forming\n   this \"consensus\"\
    \ is up to the implementation, and can, for example,\n   encompass averaging the\
    \ participants' request values, giving priority\n   to certain participants, or\
    \ using session default values.\n   Even if a mixer or translator performs transcoding,\
    \ it is very\n   difficult to deliver media with the requested trade-off, unless\
    \ the\n   content the mixer or translator receives is already close to that\n\
    \   trade-off.  Thus, if the mixer changes its trade-off, it needs to\n   request\
    \ the media sender(s) to use the new value, by creating a TSTR\n   of its own.\
    \  Upon reaching a decision on the used trade-off, it\n   includes that value\
    \ in the acknowledgement to the downstream\n   requestors.  Only in cases where\
    \ the original source has\n   substantially higher quality (and bit rate) is it\
    \ likely that\n   transcoding alone can result in the requested trade-off.\n"
- title: 3.5.2.4.  Reliability
  contents:
  - "3.5.2.4.  Reliability\n   A request and reception acknowledgement mechanism is\
    \ specified.  The\n   Temporal-Spatial Trade-off Notification (TSTN) message informs\
    \ the\n   requester that its request has been received, and what trade-off is\n\
    \   used henceforth.  This acknowledgement mechanism is desirable for at\n   least\
    \ the following reasons:\n   o  A change in the trade-off cannot be directly identified\
    \ from the\n      media bit stream.\n   o  User feedback cannot be implemented\
    \ without knowing the chosen\n      trade-off value, according to the media sender's\
    \ constraints.\n   o  Repetitive sending of messages requesting an unimplementable\n\
    \      trade-off can be avoided.\n"
- title: 3.5.3.  H.271 Video Back Channel Message
  contents:
  - "3.5.3.  H.271 Video Back Channel Message\n   ITU-T Rec. H.271 defines syntax,\
    \ semantics, and suggested encoder\n   reaction to a Video Back Channel Message.\
    \  The structure defined in\n   this memo is used to transparently convey such\
    \ a message from media\n   receiver to media sender.  In this memo, we refrain\
    \ from an in-depth\n   discussion of the available code points within H.271 and\
    \ refer to the\n   specification text [H.271] instead.\n   However, we note that\
    \ some H.271 messages bear similarities with\n   native messages of AVPF and this\
    \ memo.  Furthermore, we note that\n   some H.271 message are known to require\
    \ caution in multicast\n   environments -- or are plainly not usable in multicast\
    \ or multipoint\n   scenarios.  Table 1 provides a brief, simplified overview\
    \ of the\n   messages currently defined in H.271, their roughly corresponding\
    \ AVPF\n   or Codec Control Messages (CCMs) (the latter as specified in this\n\
    \   memo), and an indication of our current knowledge of their multicast\n   safety.\n\
    \   H.271 msg type      AVPF/CCM msg type    multicast-safe\n   --------------------------------------------------------------------\n\
    \   0 (when used for\n     reference picture\n      selection)        AVPF RPSI\
    \       No (positive ACK of pictures)\n   1 picture loss       AVPF PLI      \
    \  Yes\n   2 partial loss       AVPF SLI        Yes\n   3 one parameter CRC  N/A\
    \             Yes (no required sender action)\n   4 all parameter CRC  N/A   \
    \          Yes (no required sender action)\n   5 refresh point      CCM FIR  \
    \       Yes\n   Table 1: H.271 messages and their AVPF/CCM equivalents\n     \
    \     Note: H.271 message type 0 is not a strict equivalent to\n          AVPF's\
    \ Reference Picture Selection Indication (RPSI); it is an\n          indication\
    \ of known-as-correct reference picture(s) at the\n          decoder.  It does\
    \ not command an encoder to use a defined\n          reference picture (the form\
    \ of control information envisioned\n          to be carried in RPSI).  However,\
    \ it is believed and intended\n          that H.271 message type 0 will be used\
    \ for the same purpose as\n          AVPF's RPSI -- although other use forms are\
    \ also possible.\n   In response to the opaqueness of the H.271 messages, especially\
    \ with\n   respect to the multicast safety, the following guidelines MUST be\n\
    \   followed when an implementation wishes to employ the H.271 video back\n  \
    \ channel message:\n   1. Implementations utilizing the H.271 feedback message\
    \ MUST stay in\n      compliance with congestion control principles, as outlined\
    \ in\n      section 5.\n   2. An implementation SHOULD utilize the IETF-native\
    \ messages as\n      defined in [RFC4585] and in this memo instead of similar\
    \ messages\n      defined in [H.271].  Our current understanding of similar messages\n\
    \      is documented in Table 1 above.  One good reason to divert from\n     \
    \ the SHOULD statement above would be if it is clearly understood\n      that,\
    \ for a given application and video compression standard, the\n      aforementioned\
    \ \"similarity\" is not given, in contrast to what the\n      table indicates.\n\
    \   3. It has been observed that some of the H.271 code points currently\n   \
    \   in existence are not multicast-safe.  Therefore, the sensible\n      thing\
    \ to do is not to use the H.271 feedback message type in\n      multicast environments.\
    \  It MAY be used only when all the issues\n      mentioned later are fully understood\
    \ by the implementer, and\n      properly taken into account by all endpoints.\
    \  In all other cases,\n      the H.271 message type MUST NOT be used in conjunction\
    \ with\n      multicast.\n   4. It has been observed that even in centralized\
    \ multipoint\n      environments, where the mixer should theoretically be able\
    \ to\n      resolve issues as documented below, the implementation of such a\n\
    \      mixer and cooperative endpoints is a very difficult and tedious\n     \
    \ task.  Therefore, H.271 messages MUST NOT be used in centralized\n      multipoint\
    \ scenarios, unless all the issues mentioned below are\n      fully understood\
    \ by the implementer, and properly taken into\n      account by both mixer and\
    \ endpoints.\n   Issues to be taken into account when considering the use of H.271\
    \ in\n   multipoint environments:\n   1. Different state on different receivers.\
    \  In many environments, it\n      cannot be guaranteed that the decoder state\
    \ of all media receivers\n      is identical at any given point in time.  The\
    \ most obvious reason\n      for such a possible misalignment of state is a loss\
    \ that occurs on\n      the path to only one of many media receivers.  However,\
    \ there are\n      other not so obvious reasons, such as recent joins to the\n\
    \      multipoint conference (be it by joining the multicast group or\n      through\
    \ additional mixer output).  Different states can lead the\n      media receivers\
    \ to issue potentially contradicting H.271 messages\n      (or one media receiver\
    \ issuing an H.271 message that, when\n      observed by the media sender, is\
    \ not helpful for the other media\n      receivers).  A naive reaction of the\
    \ media sender to these\n      contradicting messages can lead to unpredictable\
    \ and annoying\n      results.\n   2. Combining messages from different media\
    \ receivers in a media\n      sender is a non-trivial task.  As reasons, we note\
    \ that these\n      messages may be contradicting each other, and that their transport\n\
    \      is unreliable (there may well be other reasons).  In case of many\n   \
    \   H.271 messages (i.e., types 0, 2, 3, and 4), the algorithm for\n      combining\
    \ must be aware both of the network/protocol environment\n      (i.e., with respect\
    \ to congestion) and of the media codec\n      employed, as H.271 messages of\
    \ a given type can have different\n      semantics for different media codecs.\n\
    \   3. The suppression of requests may need to go beyond the basic\n      mechanisms\
    \ described in AVPF (which are driven exclusively by\n      timing and transport\
    \ considerations on the protocol level).  For\n      example, a receiver is often\
    \ required to refrain from (or delay)\n      generating requests, based on information\
    \ it receives from the\n      media stream.  For instance, it makes no sense for\
    \ a receiver to\n      issue a FIR when a transmission of an Intra/IDR picture\
    \ is\n      ongoing.\n   4. When using the non-multicast-safe messages (e.g.,\
    \ H.271 type 0\n      positive ACK of received pictures/slices) in larger multicast\n\
    \      groups, the media receiver will likely be forced to delay or even\n   \
    \   omit sending these messages.  For the media sender, this looks\n      like\
    \ data has not been properly received (although it was received\n      properly),\
    \ and a naively implemented media sender reacts to these\n      perceived problems\
    \ where it should not.\n"
- title: 3.5.3.1.  Reliability
  contents:
  - "3.5.3.1.  Reliability\n   H.271 Video Back Channel Messages do not require reliable\n\
    \   transmission, and confirmation of the reception of a message can be\n   derived\
    \ from the forward video bit stream.  Therefore, no specific\n   reception acknowledgement\
    \ is specified.\n   With respect to re-sending rules, section 3.5.1.1 applies.\n"
- title: 3.5.4.  Temporary Maximum Media Stream Bit Rate Request and Notification
  contents:
  - "3.5.4.  Temporary Maximum Media Stream Bit Rate Request and Notification\n  \
    \ A receiver, translator, or mixer uses the Temporary Maximum Media\n   Stream\
    \ Bit Rate Request (TMMBR, \"timber\") to request a sender to\n   limit the maximum\
    \ bit rate for a media stream (see section 2.2) to,\n   or below, the provided\
    \ value.  The Temporary Maximum Media Stream Bit\n   Rate Notification (TMMBN)\
    \ contains the media sender's current view of\n   the most limiting subset of\
    \ the TMMBR-defined limits it has received,\n   to help the participants to suppress\
    \ TMMBRs that would not further\n   restrict the media sender.  The primary usage\
    \ for the TMMBR/TMMBN\n   messages is in a scenario with an MCU or mixer (use\
    \ case 6),\n   corresponding to Topo-Translator or Topo-Mixer, but also to Topo-\n\
    \   Point-to-Point.\n   Each temporary limitation on the media stream is expressed\
    \ as a\n   tuple.  The first component of the tuple is the maximum total media\n\
    \   bit rate (as defined in section 2.2) that the media receiver is\n   currently\
    \ prepared to accept for this media stream.  The second\n   component is the per-packet\
    \ overhead that the media receiver has\n   observed for this media stream at its\
    \ chosen reference protocol\n   layer.\n   As indicated in section 2.2, the overhead\
    \ as observed by the sender\n   of the TMMBR (i.e., the media receiver) may differ\
    \ from the overhead\n   observed at the receiver of the TMMBR (i.e., the media\
    \ sender) due to\n   use of a different reference protocol layer at the other\
    \ end or due\n   to the intervention of translators or mixers that affect the\
    \ amount\n   of per packet overhead.  For example, a gateway in between the two\n\
    \   that converts between IPv4 and IPv6 affects the per-packet overhead\n   by\
    \ 20 bytes.  Other mechanisms that change the overhead include\n   tunnels.  The\
    \ problem with varying overhead is also discussed in\n   [RFC3890].  As will be\
    \ seen in the description of the algorithm for\n   use of TMMBR, the difference\
    \ in perceived overhead between the\n   sending and receiving ends presents no\
    \ difficulty because\n   calculations are carried out in terms of variables that\
    \ have the same\n   value at the sender as at the receiver -- for example, packet\
    \ rate\n   and net media rate.\n   Reporting both maximum total media bit rate\
    \ and per-packet overhead\n   allows different receivers to provide bit rate and\
    \ overhead values\n   for different protocol layers, for example, at the IP level,\
    \ at the\n   outer part of a tunnel protocol, or at the link layer.  The protocol\n\
    \   level a peer reports on depends on the level of integration the peer\n   has,\
    \ as it needs to be able to extract the information from that\n   protocol level.\
    \  For example, an application with no knowledge of the\n   IP version it is running\
    \ over cannot meaningfully determine the\n   overhead of the IP header, and hence\
    \ will not want to include IP\n   overhead in the overhead or maximum total media\
    \ bit rate calculation.\n   It is expected that most peers will be able to report\
    \ values at least\n   for the IP layer.  In certain implementations, it may be\
    \ advantageous\n   to also include information pertaining to the link layer, which\
    \ in\n   turn allows for a more precise overhead calculation and a better\n  \
    \ optimization of connectivity resources.\n   The Temporary Maximum Media Stream\
    \ Bit Rate messages are generic\n   messages that can be applied to any RTP packet\
    \ stream.  This\n   separates them from the other codec control messages defined\
    \ in this\n   specification, which apply only to specific media types or payload\n\
    \   formats.  The TMMBR functionality applies to the transport, and the\n   requirements\
    \ the transport places on the media encoding.\n   The reasoning below assumes\
    \ that the participants have negotiated a\n   session maximum bit rate, using\
    \ a signaling protocol.  This value can\n   be global, for example, in case of\
    \ point-to-point, multicast, or\n   translators.  It may also be local between\
    \ the participant and the\n   peer or mixer.  In either case, the bit rate negotiated\
    \ in signaling\n   is the one that the participant guarantees to be able to handle\n\
    \   (depacketize and decode).  In practice, the connectivity of the\n   participant\
    \ also influences the negotiated value -- it does not make\n   much sense to negotiate\
    \ a total media bit rate that one's network\n   interface does not support.\n\
    \   It is also beneficial to have negotiated a maximum packet rate for\n   the\
    \ session or sender.  RFC 3890 provides an SDP [RFC4566] attribute\n   that can\
    \ be used for this purpose; however, that attribute is not\n   usable in RTP sessions\
    \ established using offer/answer [RFC3264].\n   Therefore, an optional maximum\
    \ packet rate signaling parameter is\n   specified in this memo.\n   An already\
    \ established maximum total media bit rate may be changed at\n   any time, subject\
    \ to the timing rules governing the sending of\n   feedback messages.  The limit\
    \ may change to any value between zero\n   and the session maximum, as negotiated\
    \ during session establishment\n   signaling.  However, even if a sender has received\
    \ a TMMBR message\n   allowing an increase in the bit rate, all increases must\
    \ be governed\n   by a congestion control mechanism.  TMMBR indicates known limitations\n\
    \   only, usually in the local environment, and does not provide any\n   guarantees\
    \ about the full path.  Furthermore, any increases in\n   TMMBR-established bit\
    \ rate limits are to be executed only after a\n   certain delay from the sending\
    \ of the TMMBN message that notifies the\n   world about the increase in limit.\
    \  The delay is specified as at\n   least twice the longest RTT as known by the\
    \ media sender, plus the\n   media sender's calculation of the required wait time\
    \ for the sending\n   of another TMMBR message for this session based on AVPF\
    \ timing rules.\n   This delay is introduced to allow other session participants\
    \ to make\n   known their bit rate limit requirements, which may be lower.\n \
    \  If it is likely that the new value indicated by TMMBR will be valid\n   for\
    \ the remainder of the session, the TMMBR sender is expected to\n   perform a\
    \ renegotiation of the session upper limit using the session\n   signaling protocol.\n"
- title: 3.5.4.1.  Behavior for Media Receivers Using TMMBR
  contents:
  - "3.5.4.1.  Behavior for Media Receivers Using TMMBR\n   This section is an informal\
    \ description of behaviour described more\n   precisely in section 4.2.\n   A\
    \ media sender begins the session limited by the maximum media bit\n   rate and\
    \ maximum packet rate negotiated in session signaling, if any.\n   Note that this\
    \ value may be negotiated for another protocol layer\n   than the one the participant\
    \ uses in its TMMBR messages.  Each media\n   receiver selects a reference protocol\
    \ layer, forms an estimate of the\n   overhead it is observing (or estimating\
    \ it if no packets has been\n   seen yet) at that reference level, and determines\
    \ the maximum total\n   media bit rate it can accept, taking into account its\
    \ own limitations\n   and any transport path limitations of which it may be aware.\
    \  In case\n   the current limitations are more restricting than what was agreed\
    \ on\n   in the session signaling, the media receiver reports its initial\n  \
    \ estimate of these two quantities to the media sender using a TMMBR\n   message.\
    \  Overall message traffic is reduced by the possibility of\n   including tuples\
    \ for multiple media senders in the same TMMBR\n   message.\n   The media sender\
    \ applies an algorithm such as that specified in\n   section 3.5.4.2 to select\
    \ which of the tuples it has received are\n   most limiting (i.e., the bounding\
    \ set as defined in section 2.2).  It\n   modifies its operation to stay within\
    \ the feasible region (as defined\n   in section 2.2), and also sends out a TMMBN\
    \ to the media receivers\n   indicating the selected bounding set.  That notification\
    \ also\n   indicates who was responsible for the tuples in the bounding set,\n\
    \   i.e., the \"owner\"(s) of the limitation.  A session participant that\n  \
    \ owns no tuple in the bounding set is called a \"non-owner\".\n   If a media\
    \ receiver does not own one of the tuples in the bounding\n   set reported by\
    \ the TMMBN, it applies the same algorithm as the media\n   sender to determine\
    \ if its current estimated (maximum total media bit\n   rate, overhead) tuple\
    \ would enter the bounding set if known to the\n   media sender.  If so, it issues\
    \ a TMMBR reporting the tuple value to\n   the sender.  Otherwise, it takes no\
    \ action for the moment.\n   Periodically, its estimated tuple values may change\
    \ or it may receive\n   a new TMMBN.  If so, it reapplies the algorithm to decide\
    \ whether it\n   needs to issue a TMMBR.\n   If, alternatively, a media receiver\
    \ owns one of the tuples in the\n   reported bounding set, it takes no action\
    \ until such time as its\n   estimate of its own tuple values changes.  At that\
    \ time, it sends a\n   TMMBR to the media sender to report the changed values.\n\
    \   A media receiver may change status between owner and non-owner of a\n   bounding\
    \ tuple between one TMMBN message and the next.  Thus, it must\n   check the contents\
    \ of each TMMBN to determine its subsequent actions.\n   Implementations may use\
    \ other algorithms of their choosing, as long\n   as the bit rate limitations\
    \ resulting from the exchange of TMMBR and\n   TMMBN messages are at least as\
    \ strict (at least as low, in the bit\n   rate dimension) as the ones resulting\
    \ from the use of the\n   aforementioned algorithm.\n   Obviously, in point-to-point\
    \ cases, when there is only one media\n   receiver, this receiver becomes \"owner\"\
    \ once it receives the first\n   TMMBN in response to its own TMMBR, and stays\
    \ \"owner\" for the rest of\n   the session.  Therefore, when it is known that\
    \ there will always be\n   only a single media receiver, the above algorithm is\
    \ not required.\n   Media receivers that are aware they are the only ones in a\
    \ session\n   can send TMMBR messages with bit rate limits both higher and lower\n\
    \   than the previously notified limit, at any time (subject to the AVPF\n   [RFC4585]\
    \ RTCP RR send timing rules).  However, it may be difficult\n   for a session\
    \ participant to determine if it is the only receiver in\n   the session.  Because\
    \ of this, any implementation of TMMBR is\n   required to include the algorithm\
    \ described in the next section or a\n   stricter equivalent.\n"
- title: 3.5.4.2.  Algorithm for Establishing Current Limitations
  contents:
  - "3.5.4.2.  Algorithm for Establishing Current Limitations\n   This section introduces\
    \ an example algorithm for the calculation of a\n   session limit.  Other algorithms\
    \ can be employed, as long as the\n   result of the calculation is at least as\
    \ restrictive as the result\n   that is obtained by this algorithm.\n   First,\
    \ it is important to consider the implications of using a tuple\n   for limiting\
    \ the media sender's behavior.  The bit rate and the\n   overhead value result\
    \ in a two-dimensional solution space for the\n   calculation of the bit rate\
    \ of media streams.  Fortunately, the two\n   variables are linked.  Specifically,\
    \ the bit rate available for RTP\n   payloads is equal to the TMMBR reported bit\
    \ rate minus the packet\n   rate used, multiplied by the TMMBR reported overhead\
    \ converted to\n   bits.  As a result, when different bit rate/overhead combinations\n\
    \   need to be considered, the packet rate determines the correct\n   limitation.\
    \  This is perhaps best explained by an example:\n   Example:\n   Receiver A:\
    \ TMMBR_max total BR = 35 kbps, TMMBR_OH = 40 bytes\n   Receiver B: TMMBR_max\
    \ total BR = 40 kbps, TMMBR_OH = 60 bytes\n   For a given packet rate (PR), the\
    \ bit rate available for media\n   payloads in RTP will be:\n   Max_net media_BR_A\
    \ =\n       TMMBR_max total BR_A - PR * TMMBR_OH_A * 8 ... (1)\n   Max_net media_BR_B\
    \ =\n       TMMBR_max total BR_B - PR * TMMBR_OH_B * 8 ... (2)\n   For a PR =\
    \ 20, these calculations will yield a Max_net media_BR_A =\n   28600 bps and Max_net\
    \ media_BR_B = 30400 bps, which suggests that\n   receiver A is the limiting one\
    \ for this packet rate.  However, at a\n   certain PR there is a switchover point\
    \ at which receiver B becomes\n   the limiting one.  The switchover point can\
    \ be identified by setting\n   Max_media_BR_A equal to Max_media_BR_B and breaking\
    \ out PR:\n         TMMBR_max total BR_A - TMMBR_max total BR_B\n   PR =  -------------------------------------------\
    \ ... (3)\n                8*(TMMBR_OH_A - TMMBR_OH_B)\n   which, for the numbers\
    \ above, yields 31.25 as the switchover point\n   between the two limits.  That\
    \ is, for packet rates below 31.25 per\n   second, receiver A is the limiting\
    \ receiver, and for higher packet\n   rates, receiver B is more limiting.  The\
    \ implications of this\n   behavior have to be considered by implementations that\
    \ are going to\n   control media encoding and its packetization.  As exemplified\
    \ above,\n   multiple TMMBR limits may apply to the trade-off between net media\n\
    \   bit rate and packet rate.  Which limitation applies depends on the\n   packet\
    \ rate being considered.\n   This also has implications for how the TMMBR mechanism\
    \ needs to work.\n   First, there is the possibility that multiple TMMBR tuples\
    \ are\n   providing limitations on the media sender.  Secondly, there is a need\n\
    \   for any session participant (media sender and receivers) to be able\n   to\
    \ determine if a given tuple will become a limitation upon the media\n   sender,\
    \ or if the set of already given limitations is stricter than\n   the given values.\
    \  In the absence of the ability to make this\n   determination, the suppression\
    \ of TMMBRs would not work.\n   The basic idea of the algorithm is as follows.\
    \  Each TMMBR tuple can\n   be viewed as the equation of a straight line (cf.\
    \ equations (1) and\n   (2)) in a space where packet rate lies along the X-axis\
    \ and net bit\n   rate along the Y-axis.  The lower envelope of the set of lines\n\
    \   corresponding to the complete set of TMMBR tuples, together with the\n   X\
    \ and Y axes, defines a polygon.  Points lying within this polygon\n   are combinations\
    \ of packet rate and bit rate that meet all of the\n   TMMBR constraints.  The\
    \ highest feasible packet rate within this\n   region is the minimum of the rate\
    \ at which the bounding polygon meets\n   the X-axis or the session maximum packet\
    \ rate (SMAXPR, measured in\n   packets per second) provided by signaling, if\
    \ any.  Typically, a\n   media sender will prefer to operate at a lower rate than\
    \ this\n   theoretical maximum, so as to increase the rate at which actual media\n\
    \   content reaches the receivers.  The purpose of the algorithm is to\n   distinguish\
    \ the TMMBR tuples constituting the bounding set and thus\n   delineate the feasible\
    \ region, so that the media sender can select\n   its preferred operating point\
    \ within that region\n   Figure 1 below shows a bounding polygon formed by TMMBR\
    \ tuples A and\n   B.  A third tuple C lies outside the bounding polygon and is\n\
    \   therefore irrelevant in determining feasible trade-offs between media\n  \
    \ rate and packet rate.  The line labeled ss..s represents the limit on\n   packet\
    \ rate imposed by the session maximum packet rate (SMAXPR)\n   obtained by signaling\
    \ during session setup.  In Figure 1, the limit\n   determined by tuple B happens\
    \ to be more restrictive than SMAXPR.\n   The situation could easily be the reverse,\
    \ meaning that the bounding\n   polygon is terminated on the right by the vertical\
    \ line representing\n   the SMAXPR constraint.\n   Net  ^\n   Media|a   c   b\
    \             s\n   Bit  |  a   c  b            s\n   Rate |    a   c b      \
    \     s\n        |      a   cb          s\n        |        a   c         s\n\
    \        |          a  bc       s\n        |            a b c     s\n        |\
    \              ab  c   s\n        |  Feasible      b   c s\n        |   region\
    \        ba   s\n        |                  b a s c\n        |               \
    \    b  s   c\n        |                    b s a\n        |                 \
    \    bs\n        +------------------------------>\n              Packet rate\n\
    \    Figure 1 - Geometric Interpretation of TMMBR Tuples\n   Note that the slopes\
    \ of the lines making up the bounding polygon are\n   increasingly negative as\
    \ one moves in the direction of increasing\n   packet rate.  Note also that with\
    \ slight rearrangement, equations (1)\n   and (2) have the canonical form:\n \
    \         y = mx + b\n   where\n     m is the slope and has value equal to the\
    \ negative of the tuple\n     overhead (in bits),\n   and\n     b is the y-intercept\
    \ and has value equal to the tuple maximum\n     total media bit rate.\n   These\
    \ observations lead to the conclusion that when processing the\n   TMMBR tuples\
    \ to select the initial bounding set, one should sort and\n   process the tuples\
    \ by order of increasing overhead.  Once a\n   particular tuple has been added\
    \ to the bounding set, all tuples not\n   already selected and having lower overhead\
    \ can be eliminated, because\n   the next side of the bounding polygon has to\
    \ be steeper (i.e., the\n   corresponding TMMBR must have higher overhead) than\
    \ the latest added\n   tuple.\n   Line cc..c in Figure 1 illustrates another principle.\
    \  This line is\n   parallel to line aa..a, but has a higher Y-intercept.  That\
    \ is, the\n   corresponding TMMBR tuple contains a higher maximum total media\
    \ bit\n   rate value.  Since line cc..c is outside the bounding polygon, it\n\
    \   illustrates the conclusion that if two TMMBR tuples have the same\n   overhead\
    \ value, the one with higher maximum total media bit rate\n   value cannot be\
    \ part of the bounding set and can be set aside.\n   Two further observations\
    \ complete the algorithm.  Obviously, moving\n   from the left, the successive\
    \ corners of the bounding polygon (i.e.,\n   the intersection points between successive\
    \ pairs of sides) lie at\n   successively higher packet rates.  On the other hand,\
    \ again moving\n   from the left, each successive line making up the bounding\
    \ set\n   crosses the X-axis at a lower packet rate.\n   The complete algorithm\
    \ can now be specified.  The algorithm works\n   with two lists of TMMBR tuples,\
    \ the candidate list X and the selected\n   list Y, both ordered by increasing\
    \ overhead value.  The algorithm\n   terminates when all members of X have been\
    \ discarded or removed for\n   processing.  Membership of the selected list Y\
    \ is probationary until\n   the algorithm is complete.  Each member of the selected\
    \ list is\n   associated with an intersection value, which is the packet rate\
    \ at\n   which the line corresponding to that TMMBR tuple intersects with the\n\
    \   line corresponding to the previous TMMBR tuple in the selected list.\n   Each\
    \ member of the selected list is also associated with a maximum\n   packet rate\
    \ value, which is the lesser of the session maximum packet\n   rate SMAXPR (if\
    \ any) and the packet rate at which the line\n   corresponding to that tuple crosses\
    \ the X-axis.\n   When the algorithm terminates, the selected list is equal to\
    \ the\n   bounding set as defined in section 2.2.\n   Initial Algorithm\n   This\
    \ algorithm is used by the media sender when it has received one\n   or more TMMBRs\
    \ and before it has determined a bounding set for the\n   first time.\n   1. Sort\
    \ the TMMBR tuples by order of increasing overhead.  This is\n      the initial\
    \ candidate list X.\n   2. When multiple tuples in the candidate list have the\
    \ same overhead\n      value, discard all but the one with the lowest maximum\
    \ total media\n      bit rate value.\n   3. Select and remove from the candidate\
    \ list the TMMBR tuple with the\n      lowest maximum total media bit rate value.\
    \  If there is more than\n      one tuple with that value, choose the one with\
    \ the highest\n      overhead value.  This is the first member of the selected\
    \ list Y.\n      Set its intersection value equal to zero.  Calculate its maximum\n\
    \      packet rate as the minimum of SMAXPR (if available) and the value\n   \
    \   obtained from the following formula, which is the packet rate at\n      which\
    \ the corresponding line crosses the X-axis.\n          Max PR = TMMBR max total\
    \ BR / (8 * TMMBR OH) ... (4)\n   4. Discard from the candidate list all tuples\
    \ with a lower overhead\n      value than the selected tuple.\n   5. Remove the\
    \ first remaining tuple from the candidate list for\n      processing.  Call this\
    \ the current candidate.\n   6. Calculate the packet rate PR at the intersection\
    \ of the line\n      generated by the current candidate with the line generated\
    \ by the\n      last tuple in the selected list Y, using equation (3).\n   7.\
    \ If the calculated value PR is equal to or lower than the\n      intersection\
    \ value stored for the last tuple of the selected list,\n      discard the last\
    \ tuple of the selected list and go back to step 6\n      (retaining the same\
    \ current candidate).\n      Note that the choice of the initial member of the\
    \ selected list Y\n      in step 3 guarantees that the selected list will never\
    \ be emptied\n      by this process, meaning that the algorithm must eventually\
    \ (if\n      not immediately) fall through to step 8.\n   8. (This step is reached\
    \ when the calculated PR value of the current\n      candidate is greater than\
    \ the intersection value of the current\n      last member of the selected list\
    \ Y.)  If the calculated value PR\n      of the current candidate is lower than\
    \ the maximum packet rate\n      associated with the last tuple in the selected\
    \ list, add the\n      current candidate tuple to the end of the selected list.\
    \  Store PR\n      as its intersection value.  Calculate its maximum packet rate\
    \ as\n      the lesser of SMAXPR (if available) and the maximum packet rate\n\
    \      calculated using equation (4).\n   9. If any tuples remain in the candidate\
    \ list, go back to step 5.\n   Incremental Algorithm\n   The previous algorithm\
    \ covered the initial case, where no selected\n   list had previously been created.\
    \  It also applied only to the media\n   sender.  When a previously created selected\
    \ list is available at\n   either the media sender or media receiver, two other\
    \ cases can be\n   considered:\n        o when a TMMBR tuple not currently in\
    \ the selected list is a\n          candidate for addition;\n        o when the\
    \ values change in a TMMBR tuple currently in the\n          selected list.\n\
    \   At the media receiver, these cases correspond, respectively, to those\n  \
    \ of the non-owner and owner of a tuple in the TMMBN-reported bounding\n   set.\n\
    \   In either case, the process of updating the selected list to take\n   account\
    \ of the new/changed tuple can use the basic algorithm\n   described above, with\
    \ the modification that the initial candidate set\n   consists only of the existing\
    \ selected list and the new or changed\n   tuple.  Some further optimization is\
    \ possible (beyond starting with a\n   reduced candidate set) by taking advantage\
    \ of the following\n   observations.\n   The first observation is that if the\
    \ new/changed candidate becomes\n   part of the new selected list, the result\
    \ may be to cause zero or\n   more other tuples to be dropped from the list. \
    \ However, if more than\n   one other tuple is dropped, the dropped tuples will\
    \ be consecutive.\n   This can be confirmed geometrically by visualizing a new\
    \ line that\n   cuts off a series of segments from the previously existing bounding\n\
    \   polygon.  The cut-off segments are connected one to the next, the\n   geometric\
    \ equivalent of consecutive tuples in a list ordered by\n   overhead value.  Beyond\
    \ the dropped set in either direction all of\n   the tuples that were in the earlier\
    \ selected list will be in the\n   updated one.  The second observation is that,\
    \ leaving aside the new\n   candidate, the order of tuples remaining in the updated\
    \ selected list\n   is unchanged because their overhead values have not changed.\n\
    \   The consequence of these two observations is that, once the placement\n  \
    \ of the new candidate and the extent of the dropped set of tuples (if\n   any)\
    \ has been determined, the remaining tuples can be copied directly\n   from the\
    \ candidate list into the selected list, preserving their\n   order.  This conclusion\
    \ suggests the following modified algorithm:\n       o Run steps 1-4 of the basic\
    \ algorithm.\n       o If the new candidate has survived steps 2 and 4 and has\
    \ become\n          the new first member of the selected list, run steps 5-9 on\n\
    \          subsequent candidates until another candidate is added to the\n   \
    \       selected list.  Then move all remaining candidates to the\n          selected\
    \ list, preserving their order.\n       o If the new candidate has survived steps\
    \ 2 and 4 and has not\n          become the new first member of the selected list,\
    \ start by\n          moving all tuples in the candidate list with lower overhead\n\
    \          values than that of the new candidate to the selected list,\n     \
    \     preserving their order.  Run steps 5-9 for the new candidate,\n        \
    \  with the modification that the intersection values and maximum\n          packet\
    \ rates for the tuples on the selected list have to be\n          calculated on\
    \ the fly because they were not previously stored.\n          Continue processing\
    \ only until a subsequent tuple has been\n          added to the selected list,\
    \ then move all remaining candidates\n          to the selected list, preserving\
    \ their order.\n          Note that the new candidate could be added to the selected\n\
    \          list only to be dropped again when the next tuple is\n          processed.\
    \  It can easily be seen that in this case the new\n          candidate does not\
    \ displace any of the earlier tuples in the\n          selected list.  The limitations\
    \ of ASCII art make this\n          difficult to show in a figure.  Line cc..c\
    \ in Figure 1 would\n          be an example if it had a steeper slope (tuple\
    \ C had a higher\n          overhead value), but still intersected line aa..a\
    \ beyond where\n          line aa..a intersects line bb..b.\n   The algorithm\
    \ just described is approximate, because it does not take\n   account of tuples\
    \ outside the selected list.  To see how such tuples\n   can become relevant,\
    \ consider Figure 1 and suppose that the maximum\n   total media bit rate in tuple\
    \ A increases to the point that line\n   aa..a moves outside line cc..c.  Tuple\
    \ A will remain in the bounding\n   set calculated by the media sender.  However,\
    \ once it issues a new\n   TMMBN, media receiver C will apply the algorithm and\
    \ discover that\n   its tuple C should now enter the bounding set.  It will issue\
    \ a TMMBR\n   to the media sender, which will repeat its calculation and come\
    \ to\n   the appropriate conclusion.\n   The rules of section 4.2 require that\
    \ the media sender refrain from\n   raising its sending rate until media receivers\
    \ have had a chance to\n   respond to the TMMBN.  In the example just given, this\
    \ delay ensures\n   that the relaxation of tuple A does not actually result in\
    \ an attempt\n   to send media at a rate exceeding the capacity at C.\n"
- title: 3.5.4.3.  Use of TMMBR in a Mixer-Based Multipoint Operation
  contents:
  - "3.5.4.3.  Use of TMMBR in a Mixer-Based Multipoint Operation\n   Assume a small\
    \ mixer-based multiparty conference is ongoing, as\n   depicted in Topo-Mixer\
    \ of [RFC5117].  All participants have\n   negotiated a common maximum bit rate\
    \ that this session can use.  The\n   conference operates over a number of unicast\
    \ paths between the\n   participants and the mixer.  The congestion situation\
    \ on each of\n   these paths can be monitored by the participant in question and\
    \ by\n   the mixer, utilizing, for example, RTCP receiver reports (RRs) or the\n\
    \   transport protocol, e.g., Datagram Congestion Control Protocol (DCCP)\n  \
    \ [RFC4340].  However, any given participant has no knowledge of the\n   congestion\
    \ situation of the connections to the other participants.\n   Worse, without mechanisms\
    \ similar to the ones discussed in this\n   document, the mixer (which is aware\
    \ of the congestion situation on\n   all connections it manages) has no standardized\
    \ means to inform media\n   senders to slow down, short of forging its own receiver\
    \ reports\n   (which is undesirable).  In principle, a mixer confronted with such\
    \ a\n   situation is obliged to thin or transcode streams intended for\n   connections\
    \ that detected congestion.\n   In practice, unfortunately, media-aware streaming\
    \ thinning is a very\n   difficult and cumbersome operation and adds undesirable\
    \ delay.  If\n   media-unaware, it leads very quickly to unacceptable reproduced\
    \ media\n   quality.  Hence, a means to slow down senders even in the absence\
    \ of\n   congestion on their connections to the mixer is desirable.\n   To allow\
    \ the mixer to throttle traffic on the individual links,\n   without performing\
    \ transcoding, there is a need for a mechanism that\n   enables the mixer to ask\
    \ a participant's media encoders to limit the\n   media stream bit rate they are\
    \ currently generating.  TMMBR provides\n   the required mechanism.  When the\
    \ mixer detects congestion between\n   itself and a given participant, it executes\
    \ the following procedure:\n   1. It starts thinning the media traffic to the\
    \ congested participant\n      to the supported bit rate.\n   2. It uses TMMBR\
    \ to request the media sender(s) to reduce the total\n      media bit rate sent\
    \ by them to the mixer, to a value that is in\n      compliance with congestion\
    \ control principles for the slowest\n      link.  Slow refers here to the available\
    \ bandwidth / bit rate /\n      capacity and packet rate after congestion control.\n\
    \   3. As soon as the bit rate has been reduced by the sending part, the\n   \
    \   mixer stops stream thinning implicitly, because there is no need\n      for\
    \ it once the stream is in compliance with congestion control.\n   This use of\
    \ stream thinning as an immediate reaction tool followed up\n   by a quick control\
    \ mechanism appears to be a reasonable compromise\n   between media quality and\
    \ the need to combat congestion.\n"
- title: 3.5.4.4.  Use of TMMBR in Point-to-Multipoint Using Multicast or
  contents:
  - "3.5.4.4.  Use of TMMBR in Point-to-Multipoint Using Multicast or\n          Translators\n\
    \   In these topologies, corresponding to Topo-Multicast or Topo-\n   Translator,\
    \ RTCP RRs are transmitted globally.  This allows all\n   participants to detect\
    \ transmission problems such as congestion, on a\n   medium timescale.  As all\
    \ media senders are aware of the congestion\n   situation of all media receivers,\
    \ the rationale for the use of TMMBR\n   in the previous section does not apply.\
    \  However, even in this case\n   the congestion control response can be improved\
    \ when the unicast\n   links are using congestion controlled transport protocols\
    \ (such as\n   TCP or DCCP).  A peer may also report local limitations to the\
    \ media\n   sender.\n"
- title: 3.5.4.5.  Use of TMMBR in Point-to-Point Operation
  contents:
  - "3.5.4.5.  Use of TMMBR in Point-to-Point Operation\n   In use case 7, it is possible\
    \ to use TMMBR to improve the performance\n   when the known upper limit of the\
    \ bit rate changes.  In this use\n   case, the signaling protocol has established\
    \ an upper limit for the\n   session and total media bit rates.  However, at the\
    \ time of transport\n   link bit rate reduction, a receiver can avoid serious\
    \ congestion by\n   sending a TMMBR to the sending side.  Thus, TMMBR is useful\
    \ for\n   putting restrictions on the application and thus placing the\n   congestion\
    \ control mechanism in the right ballpark.  However, TMMBR\n   is usually unable\
    \ to provide the continuously quick feedback loop\n   required for real congestion\
    \ control.  Nor do its semantics match\n   those of congestion control given its\
    \ different purpose.  For these\n   reasons, TMMBR SHALL NOT be used as a substitute\
    \ for congestion\n   control.\n"
- title: 3.5.4.6.  Reliability
  contents:
  - "3.5.4.6.  Reliability\n   The reaction of a media sender to the reception of\
    \ a TMMBR message is\n   not immediately identifiable through inspection of the\
    \ media stream.\n   Therefore, a more explicit mechanism is needed to avoid unnecessary\n\
    \   re-sending of TMMBR messages.  Using a statistically based\n   retransmission\
    \ scheme would only provide statistical guarantees of\n   the request being received.\
    \  It would also not avoid the\n   retransmission of already received messages.\
    \  In addition, it would\n   not allow for easy suppression of other participants'\
    \ requests.  For\n   these reasons, a mechanism based on explicit notification\
    \ is used.\n   Upon the reception of a TMMBR, a media sender sends a TMMBN\n \
    \  containing the current bounding set, and indicating which session\n   participants\
    \ own that limit.  In multicast scenarios, that allows all\n   other participants\
    \ to suppress any request they may have, if their\n   limitations are less strict\
    \ than the current ones (i.e., define lines\n   lying outside the feasible region\
    \ as defined in section 2.2).\n   Keeping and notifying only the bounding set\
    \ of tuples allows for\n   small message sizes and media sender states.  A media\
    \ sender only\n   keeps state for the SSRCs of the current owners of the bounding\
    \ set\n   of tuples; all other requests and their sources are not saved.  Once\n\
    \   the bounding set has been established, new TMMBR messages should be\n   generated\
    \ only by owners of the bounding tuples and by other entities\n   that determine\
    \ (by applying the algorithm of section 3.5.4.2 or its\n   equivalent) that their\
    \ limitations should now be part of the bounding\n   set.\n"
- title: 4.  RTCP Receiver Report Extensions
  contents:
  - "4.  RTCP Receiver Report Extensions\n   This memo specifies six new feedback\
    \ messages.  The Full Intra\n   Request (FIR), Temporal-Spatial Trade-off Request\
    \ (TSTR), Temporal-\n   Spatial Trade-off Notification (TSTN), and Video Back\
    \ Channel Message\n   (VBCM) are \"Payload Specific Feedback Messages\" as defined\
    \ in section\n   6.3 of AVPF [RFC4585].  The Temporary Maximum Media Stream Bit\
    \ Rate\n   Request (TMMBR) and Temporary Maximum Media Stream Bit Rate\n   Notification\
    \ (TMMBN) are \"Transport Layer Feedback Messages\" as\n   defined in section\
    \ 6.2 of AVPF.\n   The new feedback messages are defined in the following subsections,\n\
    \   following a similar structure to that in sections 6.2 and 6.3 of the\n   AVPF\
    \ specification [RFC4585].\n"
- title: 4.1.  Design Principles of the Extension Mechanism
  contents:
  - "4.1.  Design Principles of the Extension Mechanism\n   RTCP was originally introduced\
    \ as a channel to convey presence,\n   reception quality statistics and hints\
    \ on the desired media coding.\n   A limited set of media control mechanisms was\
    \ introduced in early RTP\n   payload formats for video formats, for example,\
    \ in RFC 2032 [RFC2032]\n   (which was obsoleted by RFC 4587 [RFC4587]).  However,\
    \ this\n   specification, for the first time, suggests a two-way handshake for\n\
    \   some of its messages.  There is danger that this introduction could\n   be\
    \ misunderstood as a precedent for the use of RTCP as an RTP session\n   control\
    \ protocol.  To prevent such a misunderstanding, this\n   subsection attempts\
    \ to clarify the scope of the extensions specified\n   in this memo, and it strongly\
    \ suggests that future extensions follow\n   the rationale spelled out here, or\
    \ compellingly explain why they\n   divert from the rationale.\n   In this memo,\
    \ and in AVPF [RFC4585], only such messages have been\n   included as:\n   a)\
    \ have comparatively strict real-time constraints, which prevent the\n      use\
    \ of mechanisms such as a SIP re-invite in most application\n      scenarios (the\
    \ real-time constraints are explained separately for\n      each message where\
    \ necessary);\n   b) are multicast-safe in that the reaction to potentially\n\
    \      contradicting feedback messages is specified, as necessary for\n      each\
    \ message; and\n   c) are directly related to activities of a certain media codec,\
    \ class\n      of media codecs (e.g., video codecs), or a given RTP packet\n \
    \     stream.\n   In this memo, a two-way handshake is introduced only for messages\
    \ for\n   which:\n   a) a notification or acknowledgement is required due to their\
    \ nature.\n      An analysis to determine whether this requirement exists has\
    \ been\n      performed separately for each message.\n   b) the notification or\
    \ acknowledgement cannot be easily derived from\n      the media bit stream.\n\
    \   All messages in AVPF [RFC4585] and in this memo present their\n   contents\
    \ in a simple, fixed binary format.  This accommodates media\n   receivers that\
    \ have not implemented higher control protocol\n   functionalities (SDP, XML parsers,\
    \ and such) in their media path.\n   Messages that do not conform to the design\
    \ principles just described\n   are not an appropriate use of RTCP or of the Codec\
    \ Control Framework\n   defined in this document.\n"
- title: 4.2.  Transport Layer Feedback Messages
  contents:
  - "4.2.  Transport Layer Feedback Messages\n   As specified in section 6.1 of RFC\
    \ 4585 [RFC4585], transport layer\n   feedback messages are identified by the\
    \ RTCP packet type value RTPFB\n   (205).\n   In AVPF, one message of this category\
    \ had been defined.  This memo\n   specifies two more such messages.  They are\
    \ identified by means of\n   the feedback message type (FMT) parameter as follows:\n\
    \   Assigned in AVPF [RFC4585]:\n      1:    Generic NACK\n      31:   reserved\
    \ for future expansion of the identifier number space\n   Assigned in this memo:\n\
    \      2:    reserved (see note below)\n      3:    Temporary Maximum Media Stream\
    \ Bit Rate Request (TMMBR)\n      4:    Temporary Maximum Media Stream Bit Rate\
    \ Notification (TMMBN)\n          Note: early versions of AVPF [RFC4585] reserved\
    \ FMT=2 for a\n          code point that has later been removed.  It has been\
    \ pointed\n          out that there may be implementations in the field using\
    \ this\n          value in accordance with the expired document.  As there is\n\
    \          sufficient numbering space available, we mark FMT=2 as\n          reserved\
    \ so to avoid possible interoperability problems with\n          any such early\
    \ implementations.\n   Available for assignment:\n      0:    unassigned\n   \
    \   5-30: unassigned\n   The following subsection defines the formats of the Feedback\
    \ Control\n   Information (FCI) entries for the TMMBR and TMMBN messages,\n  \
    \ respectively, and specifies the associated behaviour at the media\n   sender\
    \ and receiver.\n"
- title: 4.2.1.  Temporary Maximum Media Stream Bit Rate Request (TMMBR)
  contents:
  - "4.2.1.  Temporary Maximum Media Stream Bit Rate Request (TMMBR)\n   The Temporary\
    \ Maximum Media Stream Bit Rate Request is identified by\n   RTCP packet type\
    \ value PT=RTPFB and FMT=3.\n   The FCI field of a Temporary Maximum Media Stream\
    \ Bit Rate Request\n   (TMMBR) message SHALL contain one or more FCI entries.\n"
- title: 4.2.1.1.  Message Format
  contents:
  - "4.2.1.1.  Message Format\n   The Feedback Control Information (FCI) consists\
    \ of one or more TMMBR\n   FCI entries with the following syntax:\n    0     \
    \              1                   2                   3\n    0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              SSRC                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | MxTBR Exp |  MxTBR Mantissa                 |Measured Overhead|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        Figure 2 - Syntax of an FCI Entry in the TMMBR Message\n     SSRC (32\
    \ bits): The SSRC value of the media sender that is\n              requested to\
    \ obey the new maximum bit rate.\n     MxTBR Exp (6 bits): The exponential scaling\
    \ of the mantissa for the\n              maximum total media bit rate value. \
    \ The value is an\n              unsigned integer [0..63].\n     MxTBR Mantissa\
    \ (17 bits): The mantissa of the maximum total media\n              bit rate value\
    \ as an unsigned integer.\n     Measured Overhead (9 bits): The measured average\
    \ packet overhead\n              value in bytes.  The measurement SHALL be done\
    \ according\n              to the description in section 4.2.1.2. The value is\
    \ an\n              unsigned integer [0..511].\n   The maximum total media bit\
    \ rate (MxTBR) value in bits per second is\n   calculated from the MxTBR exponent\
    \ (exp) and mantissa in the\n   following way:\n      MxTBR = mantissa * 2^exp\n\
    \   This allows for 17 bits of resolution in the range 0 to 131072*2^63\n   (approximately\
    \ 1.2*10^24).\n   The length of the TMMBR feedback message SHALL be set to 2+2*N\
    \ where\n   N is the number of TMMBR FCI entries.\n"
- title: 4.2.1.2.  Semantics
  contents:
  - "4.2.1.2.  Semantics\n   Behaviour at the Media Receiver (Sender of the TMMBR)\n\
    \   TMMBR is used to indicate a transport-related limitation at the\n   reporting\
    \ entity acting as a media receiver.  TMMBR has the form of a\n   tuple containing\
    \ two components.  The first value is the highest bit\n   rate per sender of a\
    \ media stream, available at a receiver-chosen\n   protocol layer, which the receiver\
    \ currently supports in this RTP\n   session.  The second value is the measured\
    \ header overhead in bytes\n   as defined in section 2.2 and measured at the chosen\
    \ protocol layer\n   in the packets received for the stream.  The measurement\
    \ of the\n   overhead is a running average that is updated for each packet\n \
    \  received for this particular media source (SSRC), using the following\n   formula:\n\
    \       avg_OH (new) = 15/16*avg_OH (old) + 1/16*pckt_OH,\n   where avg_OH is\
    \ the running (exponentially smoothed) average and\n   pckt_OH is the overhead\
    \ observed in the latest packet.\n   If a maximum bit rate has been negotiated\
    \ through signaling, the\n   maximum total media bit rate that the receiver reports\
    \ in a TMMBR\n   message MUST NOT exceed the negotiated value converted to a common\n\
    \   basis (i.e., with overheads adjusted to bring it to the same\n   reference\
    \ protocol layer).\n   Within the common packet header for feedback messages (as\
    \ defined in\n   section 6.1 of [RFC4585]), the \"SSRC of packet sender\" field\n\
    \   indicates the source of the request, and the \"SSRC of media source\"\n  \
    \ is not used and SHALL be set to 0.  Within a particular TMMBR FCI\n   entry,\
    \ the \"SSRC of media source\" in the FCI field denotes the media\n   sender that\
    \ the tuple applies to.  This is useful in the multicast or\n   translator topologies\
    \ where the reporting entity may address all of\n   the media senders in a single\
    \ TMMBR message using multiple FCI\n   entries.\n   The media receiver SHALL save\
    \ the contents of the latest TMMBN\n   message received from each media sender.\n\
    \   The media receiver MAY send a TMMBR FCI entry to a particular media\n   sender\
    \ under the following circumstances:\n     o   before any TMMBN message has been\
    \ received from that media\n         sender;\n     o   when the media receiver\
    \ has been identified as the source of a\n         bounding tuple within the latest\
    \ TMMBN message received from\n         that media sender, and the value of the\
    \ maximum total media bit\n         rate or the overhead relating to that media\
    \ sender has changed;\n     o   when the media receiver has not been identified\
    \ as the source\n         of a bounding tuple within the latest TMMBN message\
    \ received\n         from that media sender, and, after the media receiver applies\n\
    \         the incremental algorithm from section 3.5.4.2 or a stricter\n     \
    \    equivalent, the media receiver's tuple relating to that media\n         sender\
    \ is determined to belong to the bounding set.\n   A TMMBR FCI entry MAY be repeated\
    \ in subsequent TMMBR messages if no\n   Temporary Maximum Media Stream Bit Rate\
    \ Notification (TMMBN) FCI has\n   been received from the media sender at the\
    \ time of transmission of\n   the next RTCP packet.  The bit rate value of a TMMBR\
    \ FCI entry MAY be\n   changed from one TMMBR message to the next.  The overhead\
    \ measurement\n   SHALL be updated to the current value of avg_OH each time the\
    \ entry\n   is sent.\n   If the value set by a TMMBR message is expected to be\
    \ permanent, the\n   TMMBR setting party SHOULD renegotiate the session parameters\
    \ to\n   reflect that using session setup signaling, e.g., a SIP re-invite.\n\
    \   Behaviour at the Media Sender (Receiver of the TMMBR)\n   When it receives\
    \ a TMMBR message containing an FCI entry relating to\n   it, the media sender\
    \ SHALL use an initial or incremental algorithm as\n   applicable to determine\
    \ the bounding set of tuples based on the new\n   information.  The algorithm\
    \ used SHALL be at least as strict as the\n   corresponding algorithm defined\
    \ in section 3.5.4.2.  The media sender\n   MAY accumulate TMMBRs over a small\
    \ interval (relative to the RTCP\n   sending interval) before making this calculation.\n\
    \   Once it has determined the bounding set of tuples, the media sender\n   MAY\
    \ use any combination of packet rate and net media bit rate within\n   the feasible\
    \ region that these tuples describe to produce a lower\n   total media stream\
    \ bit rate, as it may need to address a congestion\n   situation or other limiting\
    \ factors.  See section 5 (congestion\n   control) for more discussion.\n   If\
    \ the media sender concludes that it can increase the maximum total\n   media\
    \ bit rate value, it SHALL wait before actually doing so, for a\n   period long\
    \ enough to allow a media receiver to respond to the TMMBN\n   if it determines\
    \ that its tuple belongs in the bounding set.  This\n   delay period is estimated\
    \ by the formula:\n      2 * RTT + T_Dither_Max,\n   where RTT is the longest\
    \ round trip time known to the media sender\n   and T_Dither_Max is defined in\
    \ section 3.4 of [RFC4585].  Even in\n   point-to-point sessions, a media sender\
    \ MUST obey the aforementioned\n   rule, as it is not guaranteed that a participant\
    \ is able to determine\n   correctly whether all the sources are co-located in\
    \ a single node,\n   and are coordinated.\n   A TMMBN message SHALL be sent by\
    \ the media sender at the earliest\n   possible point in time, in response to\
    \ any TMMBR messages received\n   since the last sending of TMMBN.  The TMMBN\
    \ message indicates the\n   calculated set of bounding tuples and the owners of\
    \ those tuples at\n   the time of the transmission of the message.\n   An SSRC\
    \ may time out according to the default rules for RTP session\n   participants,\
    \ i.e., the media sender has not received any RTP or RTCP\n   packets from the\
    \ owner for the last five regular reporting intervals.\n   An SSRC may also explicitly\
    \ leave the session, with the participant\n   indicating this through the transmission\
    \ of an RTCP BYE packet or\n   using an external signaling channel.  If the media\
    \ sender determines\n   that the owner of a tuple in the bounding set has left\
    \ the session,\n   the media sender SHALL transmit a new TMMBN containing the\
    \ previously\n   determined set of bounding tuples but with the tuple belonging\
    \ to the\n   departed owner removed.\n   A media sender MAY proactively initiate\
    \ the equivalent to a TMMBR\n   message to itself, when it is aware that its transmission\
    \ path is\n   more restrictive than the current limitations.  As a result, a TMMBN\n\
    \   indicating the media source itself as the owner of a tuple is being\n   sent,\
    \ thereby avoiding unnecessary TMMBR messages from other\n   participants.  However,\
    \ like any other participant, when the media\n   sender becomes aware of changed\
    \ limitations, it is required to change\n   the tuple, and to send a corresponding\
    \ TMMBN.\n   Discussion\n   Due to the unreliable nature of transport of TMMBR\
    \ and TMMBN, the\n   above rules may lead to the sending of TMMBR messages that\
    \ appear to\n   disobey those rules.  Furthermore, in multicast scenarios it can\n\
    \   happen that more than one \"non-owning\" session participant may\n   determine,\
    \ rightly or wrongly, that its tuple belongs in the bounding\n   set.  This is\
    \ not critical for a number of reasons:\n   a) If a TMMBR message is lost in transmission,\
    \ either the media\n      sender sends a new TMMBN message in response to some\
    \ other media\n      receiver or it does not send a new TMMBN message at all.\
    \  In the\n      first case, the media receiver applies the incremental algorithm\n\
    \      and, if it determines that its tuple should be part of the\n      bounding\
    \ set, sends out another TMMBR.  In the second case, it\n      repeats the sending\
    \ of a TMMBR unconditionally.  Either way, the\n      media sender eventually\
    \ gets the information it needs.\n   b) Similarly, if a TMMBN message gets lost,\
    \ the media receiver that\n      has sent the corresponding TMMBR does not receive\
    \ the notification\n      and is expected to re-send the request and trigger the\n\
    \      transmission of another TMMBN.\n   c) If multiple competing TMMBR messages\
    \ are sent by different session\n      participants, then the algorithm can be\
    \ applied taking all of\n      these messages into account, and the resulting\
    \ TMMBN provides the\n      participants with an updated view of how their tuples\
    \ compare with\n      the bounded set.\n   d) If more than one session participant\
    \ happens to send TMMBR\n      messages at the same time and with the same tuple\
    \ component\n      values, it does not matter which of those tuples is taken into\
    \ the\n      bounding set.  The losing session participant will determine,\n \
    \     after applying the algorithm, that its tuple does not enter the\n      bounding\
    \ set, and will therefore stop sending its TMMBR.\n   It is important to consider\
    \ the security risks involved with faked\n   TMMBRs.  See the security considerations\
    \ in section 6.\n   As indicated already, the feedback messages may be used in\
    \ both\n   multicast and unicast sessions in any of the specified topologies.\n\
    \   However, for sessions with a large number of participants, using the\n   lowest\
    \ common denominator, as required by this mechanism, may not be\n   the most suitable\
    \ course of action.  Large sessions may need to\n   consider other ways to adapt\
    \ the bit rate to participants'\n   capabilities, such as partitioning the session\
    \ into different quality\n   tiers or using some other method of achieving bit\
    \ rate scalability.\n"
- title: 4.2.1.3.  Timing Rules
  contents:
  - "4.2.1.3.  Timing Rules\n   The first transmission of the TMMBR message MAY use\
    \ early or\n   immediate feedback in cases when timeliness is desirable.  Any\n\
    \   repetition of a request message SHOULD use regular RTCP mode for its\n   transmission\
    \ timing.\n"
- title: 4.2.1.4.  Handling in Translators and Mixers
  contents:
  - "4.2.1.4.  Handling in Translators and Mixers\n   Media translators and mixers\
    \ will need to receive and respond to\n   TMMBR messages as they are part of the\
    \ chain that provides a certain\n   media stream to the receiver.  The mixer or\
    \ translator may act\n   locally on the TMMBR and thus generate a TMMBN to indicate\
    \ that it\n   has done so.  Alternatively, in the case of a media translator it\
    \ can\n   forward the request, or in the case of a mixer generate one of its\n\
    \   own and pass it forward.  In the latter case, the mixer will need to\n   send\
    \ a TMMBN back to the original requestor to indicate that it is\n   handling the\
    \ request.\n"
- title: 4.2.2.  Temporary Maximum Media Stream Bit Rate Notification (TMMBN)
  contents:
  - "4.2.2.  Temporary Maximum Media Stream Bit Rate Notification (TMMBN)\n   The\
    \ Temporary Maximum Media Stream Bit Rate Notification is\n   identified by RTCP\
    \ packet type value PT=RTPFB and FMT=4.\n   The FCI field of the TMMBN feedback\
    \ message may contain zero, one, or\n   more TMMBN FCI entries.\n"
- title: 4.2.2.1.  Message Format
  contents:
  - "4.2.2.1.  Message Format\n   The Feedback Control Information (FCI) consists\
    \ of zero, one, or more\n   TMMBN FCI entries with the following syntax:\n   \
    \ 0                   1                   2                   3\n    0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              SSRC                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | MxTBR Exp |  MxTBR Mantissa                 |Measured Overhead|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        Figure 3 - Syntax of an FCI Entry in the TMMBN Message\n     SSRC (32\
    \ bits): The SSRC value of the \"owner\" of this tuple.\n     MxTBR Exp (6 bits):\
    \ The exponential scaling of the mantissa for the\n              maximum total\
    \ media bit rate value.  The value is an\n              unsigned integer [0..63].\n\
    \     MxTBR Mantissa (17 bits): The mantissa of the maximum total media\n    \
    \          bit rate value as an unsigned integer.\n     Measured Overhead (9 bits):\
    \ The measured average packet overhead\n              value in bytes represented\
    \ as an unsigned integer\n              [0..511].\n   Thus, the FCI within the\
    \ TMMBN message contains entries indicating\n   the bounding tuples.  For each\
    \ tuple, the entry gives the owner by\n   the SSRC, followed by the applicable\
    \ maximum total media bit rate and\n   overhead value.\n   The length of the TMMBN\
    \ message SHALL be set to 2+2*N where N is the\n   number of TMMBN FCI entries.\n"
- title: 4.2.2.2.  Semantics
  contents:
  - "4.2.2.2.  Semantics\n   This feedback message is used to notify the senders of\
    \ any TMMBR\n   message that one or more TMMBR messages have been received or\
    \ that an\n   owner has left the session.  It indicates to all participants the\n\
    \   current set of bounding tuples and the \"owners\" of those tuples.\n   Within\
    \ the common packet header for feedback messages (as defined in\n   section 6.1\
    \ of [RFC4585]), the \"SSRC of packet sender\" field\n   indicates the source\
    \ of the notification.  The \"SSRC of media source\"\n   is not used and SHALL\
    \ be set to 0.\n   A TMMBN message SHALL be scheduled for transmission after the\n\
    \   reception of a TMMBR message with an FCI entry identifying this media\n  \
    \ sender.  Only a single TMMBN SHALL be sent, even if more than one\n   TMMBR\
    \ message is received between the scheduling of the transmission\n   and the actual\
    \ transmission of the TMMBN message.  The TMMBN message\n   indicates the bounding\
    \ tuples and their owners at the time of\n   transmitting the message.  The bounding\
    \ tuples included SHALL be the\n   set arrived at through application of the applicable\
    \ algorithm of\n   section 3.5.4.2 or an equivalent, applied to the previous bounding\n\
    \   set, if any, and tuples received in TMMBR messages since the last\n   TMMBN\
    \ was transmitted.\n   The reception of a TMMBR message SHALL still result in\
    \ the\n   transmission of a TMMBN message even if, after application of the\n\
    \   algorithm, the newly reported TMMBR tuple is not accepted into the\n   bounding\
    \ set.  In such a case, the bounding tuples and their owners\n   are not changed,\
    \ unless the TMMBR was from an owner of a tuple within\n   the previously calculated\
    \ bounding set.  This procedure allows\n   session participants that did not see\
    \ the last TMMBN message to get a\n   correct view of this media sender's state.\n\
    \   As indicated in section 4.2.1.2, when a media sender determines that\n   an\
    \ \"owner\" of a bounding tuple has left the session, then that tuple\n   is removed\
    \ from the bounding set, and the media sender SHALL send a\n   TMMBN message indicating\
    \ the remaining bounding tuples.  If there are\n   no remaining bounding tuples,\
    \ a TMMBN without any FCI SHALL be sent\n   to indicate this.  Without a remaining\
    \ bounding tuple, the maximum\n   media bit rate and maximum packet rate negotiated\
    \ in session\n   signaling, if any, apply.\n     Note: if any media receivers\
    \ remain in the session, this last will\n     be a temporary situation.  The empty\
    \ TMMBN will cause every\n     remaining media receiver to determine that its\
    \ limitation belongs\n     in the bounding set and send a TMMBR in consequence.\n\
    \   In unicast scenarios (i.e., where a single sender talks to a single\n   receiver),\
    \ the aforementioned algorithm to determine ownership\n   degenerates to the media\
    \ receiver becoming the \"owner\" of the one\n   bounding tuple as soon as the\
    \ media receiver has issued the first\n   TMMBR message.\n"
- title: 4.2.2.3.  Timing Rules
  contents:
  - "4.2.2.3.  Timing Rules\n   The TMMBN acknowledgement SHOULD be sent as soon as\
    \ allowed by the\n   applied timing rules for the session.  Immediate or early\
    \ feedback\n   mode SHOULD be used for these messages.\n"
- title: 4.2.2.4.  Handling by Translators and Mixers
  contents:
  - "4.2.2.4.  Handling by Translators and Mixers\n   As discussed in section 4.2.1.4,\
    \ mixers or translators may need to\n   issue TMMBN messages as responses to TMMBR\
    \ messages for SSRCs handled\n   by them.\n"
- title: 4.3.  Payload-Specific Feedback Messages
  contents:
  - "4.3.  Payload-Specific Feedback Messages\n   As specified by section 6.1 of RFC\
    \ 4585 [RFC4585], Payload-Specific\n   FB messages are identified by the RTCP\
    \ packet type value PSFB (206).\n   AVPF [RFC4585] defines three payload-specific\
    \ feedback messages and\n   one application layer feedback message.  This memo\
    \ specifies four\n   additional payload-specific feedback messages.  All are identified\
    \ by\n   means of the FMT parameter as follows:\n   Assigned in [RFC4585]:\n \
    \    1:     Picture Loss Indication (PLI)\n     2:     Slice Lost Indication (SLI)\n\
    \     3:     Reference Picture Selection Indication (RPSI)\n     15:    Application\
    \ layer FB message\n     31:    reserved for future expansion of the number space\n\
    \   Assigned in this memo:\n     4:     Full Intra Request (FIR) Command\n   \
    \  5:     Temporal-Spatial Trade-off Request (TSTR)\n     6:     Temporal-Spatial\
    \ Trade-off Notification (TSTN)\n     7:     Video Back Channel Message (VBCM)\n\
    \   Unassigned:\n         0: unassigned\n      8-14: unassigned\n     16-30: unassigned\n\
    \   The following subsections define the new FCI formats for the\n   payload-specific\
    \ feedback messages.\n"
- title: 4.3.1.  Full Intra Request (FIR)
  contents:
  - "4.3.1.  Full Intra Request (FIR)\n   The FIR message is identified by RTCP packet\
    \ type value PT=PSFB and\n   FMT=4.\n   The FCI field MUST contain one or more\
    \ FIR entries.  Each entry\n   applies to a different media sender, identified\
    \ by its SSRC.\n"
- title: 4.3.1.1.  Message Format
  contents:
  - "4.3.1.1.  Message Format\n   The Feedback Control Information (FCI) for the Full\
    \ Intra Request\n   consists of one or more FCI entries, the content of which\
    \ is depicted\n   in Figure 4.  The length of the FIR feedback message MUST be\
    \ set to\n   2+2*N, where N is the number of FCI entries.\n    0             \
    \      1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              SSRC                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Seq nr.       |    Reserved                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Figure 4 - Syntax of an FCI Entry in the FIR Message\n     SSRC (32\
    \ bits): The SSRC value of the media sender that is\n              requested to\
    \ send a decoder refresh point.\n     Seq nr. (8 bits): Command sequence number.\
    \  The sequence number\n              space is unique for each pairing of the\
    \ SSRC of command\n              source and the SSRC of the command target.  The\
    \ sequence\n              number SHALL be increased by 1 modulo 256 for each new\n\
    \              command.  A repetition SHALL NOT increase the sequence\n      \
    \        number.  The initial value is arbitrary.\n     Reserved (24 bits): All\
    \ bits SHALL be set to 0 by the sender and\n              SHALL be ignored on\
    \ reception.\n   The semantics of this feedback message is independent of the\
    \ RTP\n   payload type.\n"
- title: 4.3.1.2.  Semantics
  contents:
  - "4.3.1.2.  Semantics\n   Within the common packet header for feedback messages\
    \ (as defined in\n   section 6.1 of [RFC4585]), the \"SSRC of packet sender\"\
    \ field\n   indicates the source of the request, and the \"SSRC of media source\"\
    \n   is not used and SHALL be set to 0.  The SSRCs of the media senders to\n \
    \  which the FIR command applies are in the corresponding FCI entries.\n   A FIR\
    \ message MAY contain requests to multiple media senders, using\n   one FCI entry\
    \ per target media sender.\n   Upon reception of FIR, the encoder MUST send a\
    \ decoder refresh point\n   (see section 2.2) as soon as possible.\n   The sender\
    \ MUST consider congestion control as outlined in section 5,\n   which MAY restrict\
    \ its ability to send a decoder refresh point\n   quickly.\n   FIR SHALL NOT be\
    \ sent as a reaction to picture losses -- it is\n   RECOMMENDED to use PLI [RFC4585]\
    \ instead.  FIR SHOULD be used only in\n   situations where not sending a decoder\
    \ refresh point would render the\n   video unusable for the users.\n   A typical\
    \ example where sending FIR is appropriate is when, in a\n   multipoint conference,\
    \ a new user joins the session and no regular\n   decoder refresh point interval\
    \ is established.  Another example would\n   be a video switching MCU that changes\
    \ streams.  Here, normally, the\n   MCU issues a FIR to the new sender so to force\
    \ it to emit a decoder\n   refresh point.  The decoder refresh point normally\
    \ includes a Freeze\n   Picture Release (defined outside this specification),\
    \ which re-starts\n   the rendering process of the receivers.  Both techniques\
    \ mentioned\n   are commonly used in MCU-based multipoint conferences.\n   Other\
    \ RTP payload specifications such as RFC 2032 [RFC2032] already\n   define a feedback\
    \ mechanism for certain codecs.  An application\n   supporting both schemes MUST\
    \ use the feedback mechanism defined in\n   this specification when sending feedback.\
    \  For backward-compatibility\n   reasons, such an application SHOULD also be\
    \ capable of receiving and\n   reacting to the feedback scheme defined in the\
    \ respective RTP payload\n   format, if this is required by that payload format.\n"
- title: 4.3.1.3.  Timing Rules
  contents:
  - "4.3.1.3.  Timing Rules\n   The timing follows the rules outlined in section 3\
    \ of [RFC4585].  FIR\n   commands MAY be used with early or immediate feedback.\
    \  The FIR\n   feedback message MAY be repeated.  If using immediate feedback\
    \ mode,\n   the repetition SHOULD wait at least one RTT before being sent.  In\n\
    \   early or regular RTCP mode, the repetition is sent in the next\n   regular\
    \ RTCP packet.\n"
- title: 4.3.1.4.  Handling of FIR Message in Mixers and Translators
  contents:
  - "4.3.1.4.  Handling of FIR Message in Mixers and Translators\n   A media translator\
    \ or a mixer performing media encoding of the\n   content for which the session\
    \ participant has issued a FIR is\n   responsible for acting upon it.  A mixer\
    \ acting upon a FIR SHOULD NOT\n   forward the message unaltered; instead, it\
    \ SHOULD issue a FIR itself.\n"
- title: 4.3.1.5. Remarks
  contents:
  - "4.3.1.5. Remarks\n   Currently, video appears to be the only useful application\
    \ for FIR,\n   as it appears to be the only RTP payload widely deployed that relies\n\
    \   heavily on media prediction across RTP packet boundaries.  However,\n   use\
    \ of FIR could also reasonably be envisioned for other media types\n   that share\
    \ essential properties with compressed video, namely,\n   cross-frame prediction\
    \ (whatever a frame may be for that media type).\n   One possible example may\
    \ be the dynamic updates of MPEG-4 scene\n   descriptions.  It is suggested that\
    \ payload formats for such media\n   types refer to FIR and other message types\
    \ defined in this\n   specification and in AVPF [RFC4585], instead of creating\
    \ similar\n   mechanisms in the payload specifications.  The payload specifications\n\
    \   may have to explain how the payload-specific terminologies map to the\n  \
    \ video-centric terminology used herein.\n   In conjunction with video codecs,\
    \ FIR messages typically trigger the\n   sending of full intra or IDR pictures.\
    \  Both are several times larger\n   than predicted (inter) pictures.  Their size\
    \ is independent of the\n   time they are generated.  In most environments, especially\
    \ when\n   employing bandwidth-limited links, the use of an intra picture\n  \
    \ implies an allowed delay that is a significant multiple of the\n   typical frame\
    \ duration.  An example: if the sending frame rate is 10\n   fps, and an intra\
    \ picture is assumed to be 10 times as big as an\n   inter picture, then a full\
    \ second of latency has to be accepted.  In\n   such an environment, there is\
    \ no need for a particularly short delay\n   in sending the FIR message.  Hence,\
    \ waiting for the next possible\n   time slot allowed by RTCP timing rules as\
    \ per [RFC4585] should not\n   have an overly negative impact on the system performance.\n\
    \   Mandating a maximum delay for completing the sending of a decoder\n   refresh\
    \ point would be desirable from an application viewpoint, but\n   is problematic\
    \ from a congestion control point of view.  \"As soon as\n   possible\" as mentioned\
    \ above appears to be a reasonable compromise.\n   In environments where the sender\
    \ has no control over the codec (e.g.,\n   when streaming pre-recorded and pre-coded\
    \ content), the reaction to\n   this command cannot be specified.  One suitable\
    \ reaction of a sender\n   would be to skip forward in the video bit stream to\
    \ the next decoder\n   refresh point.  In other scenarios, it may be preferable\
    \ not to react\n   to the command at all, e.g., when streaming to a large multicast\n\
    \   group.  Other reactions may also be possible.  When deciding on a\n   strategy,\
    \ a sender could take into account factors such as the size\n   of the receiving\
    \ group, the \"importance\" of the sender of the FIR\n   message (however \"importance\"\
    \ may be defined in this specific\n   application), the frequency of decoder refresh\
    \ points in the content,\n   and so on.  However, a session that predominantly\
    \ handles pre-coded\n   content is not expected to use FIR at all.\n   The relationship\
    \ between the Picture Loss Indication and FIR is as\n   follows.  As discussed\
    \ in section 6.3.1 of AVPF [RFC4585], a Picture\n   Loss Indication informs the\
    \ decoder about the loss of a picture and\n   hence the likelihood of misalignment\
    \ of the reference pictures\n   between the encoder and decoder.  Such a scenario\
    \ is normally related\n   to losses in an ongoing connection.  In point-to-point\
    \ scenarios, and\n   without the presence of advanced error resilience tools,\
    \ one possible\n   option for an encoder consists in sending a decoder refresh\
    \ point.\n   However, there are other options.  One example is that the media\n\
    \   sender ignores the PLI, because the embedded stream redundancy is\n   likely\
    \ to clean up the reproduced picture within a reasonable amount\n   of time. \
    \ The FIR, in contrast, leaves a (real-time) encoder no\n   choice but to send\
    \ a decoder refresh point.  It does not allow the\n   encoder to take into account\
    \ any considerations such as the ones\n   mentioned above.\n"
- title: 4.3.2.  Temporal-Spatial Trade-off Request (TSTR)
  contents:
  - "4.3.2.  Temporal-Spatial Trade-off Request (TSTR)\n   The TSTR feedback message\
    \ is identified by RTCP packet type value\n   PT=PSFB and FMT=5.\n   The FCI field\
    \ MUST contain one or more TSTR FCI entries.\n"
- title: 4.3.2.1.  Message Format
  contents:
  - "4.3.2.1.  Message Format\n   The content of the FCI entry for the Temporal-Spatial\
    \ Trade-off\n   Request is depicted in Figure 5.  The length of the feedback message\n\
    \   MUST be set to 2+2*N, where N is the number of FCI entries included.\n   \
    \ 0                   1                   2                   3\n    0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              SSRC                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Seq nr.      |  Reserved                           | Index   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Figure 5 - Syntax of an FCI Entry in the TSTR Message\n     SSRC (32\
    \ bits): The SSRC of the media sender that is requested to\n              apply\
    \ the trade-off value given in Index.\n     Seq nr. (8 bits): Request sequence\
    \ number.  The sequence number\n              space is unique for pairing of the\
    \ SSRC of request source\n              and the SSRC of the request target.  The\
    \ sequence number\n              SHALL be increased by 1 modulo 256 for each new\
    \ command.\n              A repetition SHALL NOT increase the sequence number.\
    \  The\n              initial value is arbitrary.\n     Reserved (19 bits): All\
    \ bits SHALL be set to 0 by the sender and\n              SHALL be ignored on\
    \ reception.\n     Index (5 bits): An integer value between 0 and 31 that indicates\n\
    \              the relative trade-off that is requested.  An index value\n   \
    \           of 0 indicates the highest possible spatial quality, while\n     \
    \         31 indicates the highest possible temporal resolution.\n"
- title: 4.3.2.2.  Semantics
  contents:
  - "4.3.2.2.  Semantics\n   A decoder can suggest a temporal-spatial trade-off level\
    \ by sending a\n   TSTR message to an encoder.  If the encoder is capable of adjusting\n\
    \   its temporal-spatial trade-off, it SHOULD take into account the\n   received\
    \ TSTR message for future coding of pictures.  A value of 0\n   suggests a high\
    \ spatial quality and a value of 31 suggests a high\n   frame rate.  The progression\
    \ of values from 0 to 31 indicates\n   monotonically a desire for higher frame\
    \ rate.  The index values do\n   not correspond to precise values of spatial quality\
    \ or frame rate.\n   The reaction to the reception of more than one TSTR message\
    \ by a\n   media sender from different media receivers is left open to the\n \
    \  implementation.  The selected trade-off SHALL be communicated to the\n   media\
    \ receivers by means of the TSTN message.\n   Within the common packet header\
    \ for feedback messages (as defined in\n   section 6.1 of [RFC4585]), the \"SSRC\
    \ of packet sender\" field\n   indicates the source of the request, and the \"\
    SSRC of media source\"\n   is not used and SHALL be set to 0.  The SSRCs of the\
    \ media senders to\n   which the TSTR applies are in the corresponding FCI entries.\n\
    \   A TSTR message MAY contain requests to multiple media senders, using\n   one\
    \ FCI entry per target media sender.\n"
- title: 4.3.2.3.  Timing Rules
  contents:
  - "4.3.2.3.  Timing Rules\n   The timing follows the rules outlined in section 3\
    \ of [RFC4585].\n   This request message is not time critical and SHOULD be sent\
    \ using\n   regular RTCP timing.  Only if it is known that the user interface\n\
    \   requires quick feedback, the message MAY be sent with early or\n   immediate\
    \ feedback timing.\n"
- title: 4.3.2.4.  Handling of Message in Mixers and Translators
  contents:
  - "4.3.2.4.  Handling of Message in Mixers and Translators\n   A mixer or media\
    \ translator that encodes content sent to the session\n   participant issuing\
    \ the TSTR SHALL consider the request to determine\n   if it can fulfill it by\
    \ changing its own encoding parameters.  A\n   media translator unable to fulfill\
    \ the request MAY forward the\n   request unaltered towards the media sender.\
    \  A mixer encoding for\n   multiple session participants will need to consider\
    \ the joint needs\n   of these participants before generating a TSTR on its own\
    \ behalf\n   towards the media sender.  See also the discussion in section 3.5.2.\n"
- title: 4.3.2.5.  Remarks
  contents:
  - "4.3.2.5.  Remarks\n   The term \"spatial quality\" does not necessarily refer\
    \ to the\n   resolution as measured by the number of pixels the reconstructed\n\
    \   video is using.  In fact, in most scenarios the video resolution\n   stays\
    \ constant during the lifetime of a session.  However, all video\n   compression\
    \ standards have means to adjust the spatial quality at a\n   given resolution,\
    \ often influenced by the Quantizer Parameter or QP.\n   A numerically low QP\
    \ results in a good reconstructed picture quality,\n   whereas a numerically high\
    \ QP yields a coarse picture.  The typical\n   reaction of an encoder to this\
    \ request is to change its rate control\n   parameters to use a lower frame rate\
    \ and a numerically lower (on\n   average) QP, or vice versa.  The precise mapping\
    \ of Index value to\n   frame rate and QP is intentionally left open here, as\
    \ it depends on\n   factors such as the compression standard employed, spatial\n\
    \   resolution, content, bit rate, and so on.\n"
- title: 4.3.3.  Temporal-Spatial Trade-off Notification (TSTN)
  contents:
  - "4.3.3.  Temporal-Spatial Trade-off Notification (TSTN)\n   The TSTN message is\
    \ identified by RTCP packet type value PT=PSFB and\n   FMT=6.\n   The FCI field\
    \ SHALL contain one or more TSTN FCI entries.\n"
- title: 4.3.3.1.  Message Format
  contents:
  - "4.3.3.1.  Message Format\n   The content of an FCI entry for the Temporal-Spatial\
    \ Trade-off\n   Notification is depicted in Figure 6.  The length of the TSTN\
    \ message\n   MUST be set to 2+2*N, where N is the number of FCI entries.\n  \
    \  0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              SSRC                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Seq nr.      |  Reserved                           | Index   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 6 - Syntax of the TSTN\n     SSRC (32 bits): The SSRC\
    \ of the source of the TSTR that resulted in\n              this Notification.\n\
    \     Seq nr. (8 bits): The sequence number value from the TSTR that is\n    \
    \          being acknowledged.\n     Reserved (19 bits): All bits SHALL be set\
    \ to 0 by the sender and\n              SHALL be ignored on reception.\n     Index\
    \ (5 bits): The trade-off value the media sender is using\n              henceforth.\n\
    \      Informative note: The returned trade-off value (Index) may differ\n   \
    \   from the requested one, for example, in cases where a media\n      encoder\
    \ cannot tune its trade-off, or when pre-recorded content is\n      used.\n"
- title: 4.3.3.2.  Semantics
  contents:
  - "4.3.3.2.  Semantics\n   This feedback message is used to acknowledge the reception\
    \ of a TSTR.\n   For each TSTR received targeted at the session participant, a\
    \ TSTN\n   FCI entry SHALL be sent in a TSTN feedback message.  A single TSTN\n\
    \   message MAY acknowledge multiple requests using multiple FCI entries.\n  \
    \ The index value included SHALL be the same in all FCI entries of the\n   TSTN\
    \ message.  Including a FCI for each requestor allows each\n   requesting entity\
    \ to determine that the media sender received the\n   request.  The Notification\
    \ SHALL also be sent in response to TSTR\n   repetitions received.  If the request\
    \ receiver has received TSTR with\n   several different sequence numbers from\
    \ a single requestor, it SHALL\n   only respond to the request with the highest\
    \ (modulo 256) sequence\n   number.  Note that the highest sequence number may\
    \ be a smaller\n   integer value due to the wrapping of the field.  Appendix A.1\
    \ of\n   [RFC3550] has an algorithm for keeping track of the highest received\n\
    \   sequence number for RTP packets; it could be adapted for this usage.\n   The\
    \ TSTN SHALL include the Temporal-Spatial Trade-off index that will\n   be used\
    \ as a result of the request.  This is not necessarily the same\n   index as requested,\
    \ as the media sender may need to aggregate\n   requests from several requesting\
    \ session participants.  It may also\n   have some other policies or rules that\
    \ limit the selection.\n   Within the common packet header for feedback messages\
    \ (as defined in\n   section 6.1 of [RFC4585]), the \"SSRC of packet sender\"\
    \ field\n   indicates the source of the Notification, and the \"SSRC of media\n\
    \   source\" is not used and SHALL be set to 0.  The SSRCs of the\n   requesting\
    \ entities to which the Notification applies are in the\n   corresponding FCI\
    \ entries.\n"
- title: 4.3.3.3.  Timing Rules
  contents:
  - "4.3.3.3.  Timing Rules\n   The timing follows the rules outlined in section 3\
    \ of [RFC4585].\n   This acknowledgement message is not extremely time critical\
    \ and\n   SHOULD be sent using regular RTCP timing.\n"
- title: 4.3.3.4.  Handling of TSTN in Mixers and Translators
  contents:
  - "4.3.3.4.  Handling of TSTN in Mixers and Translators\n   A mixer or translator\
    \ that acts upon a TSTR SHALL also send the\n   corresponding TSTN.  In cases\
    \ where it needs to forward a TSTR\n   itself, the notification message MAY need\
    \ to be delayed until the\n   TSTR has been responded to.\n"
- title: 4.3.3.5.  Remarks
  contents:
  - "4.3.3.5.  Remarks\n   None.\n"
- title: 4.3.4.  H.271 Video Back Channel Message (VBCM)
  contents:
  - "4.3.4.  H.271 Video Back Channel Message (VBCM)\n   The VBCM is identified by\
    \ RTCP packet type value PT=PSFB and FMT=7.\n   The FCI field MUST contain one\
    \ or more VBCM FCI entries.\n"
- title: 4.3.4.1.  Message Format
  contents:
  - "4.3.4.1.  Message Format\n   The syntax of an FCI entry within the VBCM indication\
    \ is depicted in\n   Figure 7.\n   0                   1                   2 \
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              SSRC                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Seq nr.       |0| Payload Type| Length                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    VBCM Octet String....      |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 7 - Syntax of an FCI Entry in the VBCM\n   SSRC (32 bits):\
    \ The SSRC value of the media sender that is requested\n          to instruct\
    \ its encoder to react to the VBCM.\n   Seq nr. (8 bits): Command sequence number.\
    \  The sequence number space\n          is unique for pairing of the SSRC of the\
    \ command source and\n          the SSRC of the command target.  The sequence\
    \ number SHALL be\n          increased by 1 modulo 256 for each new command. \
    \ A repetition\n          SHALL NOT increase the sequence number.  The initial\
    \ value is\n          arbitrary.\n   0: Must be set to 0 by the sender and should\
    \ not be acted upon by the\n          message receiver.\n   Payload Type (7 bits):\
    \ The RTP payload type for which the VBCM bit\n          stream must be interpreted.\n\
    \   Length (16 bits): The length of the VBCM octet string in octets\n        \
    \  exclusive of any padding octets.\n   VBCM Octet String (variable length): This\
    \ is the octet string\n          generated by the decoder carrying a specific\
    \ feedback sub-\n          message.\n   Padding (variable length): Bits set to\
    \ 0 to make up a 32-bit\n          boundary.\n"
- title: 4.3.4.2.  Semantics
  contents:
  - "4.3.4.2.  Semantics\n   The \"payload\" of the VBCM indication carries different\
    \ types of\n   codec-specific, feedback information.  The type of feedback\n \
    \  information can be classified as a 'status report' (such as an\n   indication\
    \ that a bit stream was received without errors, or that a\n   partial or complete\
    \ picture or block was lost) or 'update requests'\n   (such as complete refresh\
    \ of the bit stream).\n          Note: There are possible overlaps between the\
    \ VBCM sub-\n          messages and CCM/AVPF feedback messages, such as FIR. \
    \ Please\n          see section 3.5.3 for further discussion.\n   The different\
    \ types of feedback sub-messages carried in the VBCM are\n   indicated by the\
    \ \"payloadType\" as defined in [H.271].  These sub-\n   message types are reproduced\
    \ below for convenience.  \"payloadType\",\n   in ITU-T Rec. H.271 terminology,\
    \ refers to the sub-type of the H.271\n   message and should not be confused with\
    \ an RTP payload type.\n   Payload          Message Content\n   Type\n   ---------------------------------------------------------------------\n\
    \   0      One or more pictures without detected bit stream error\n          mismatch\n\
    \   1      One or more pictures that are entirely or partially lost\n   2    \
    \  A set of blocks of one picture that is entirely or partially\n          lost\n\
    \   3      CRC for one parameter set\n   4      CRC for all parameter sets of\
    \ a certain type\n   5      A \"reset\" request indicating that the sender should\
    \ completely\n          refresh the video bit stream as if no prior bit stream\
    \ data\n          had been received\n   > 5    Reserved for future use by ITU-T\n\
    \   Table 2: H.271 message types (\"payloadTypes\")\n   The bit string or the\
    \ \"payload\" of a VBCM is of variable length and\n   is self-contained and coded\
    \ in a variable-length, binary format.  The\n   media sender necessarily has to\
    \ be able to parse this optimized\n   binary format to make use of VBCMs.\n  \
    \ Each of the different types of sub-messages (indicated by\n   payloadType) may\
    \ have different semantics depending on the codec\n   used.\n   Within the common\
    \ packet header for feedback messages (as defined in\n   section 6.1 of [RFC4585]),\
    \ the \"SSRC of packet sender\" field\n   indicates the source of the request,\
    \ and the \"SSRC of media source\"\n   is not used and SHALL be set to 0.  The\
    \ SSRCs of the media senders to\n   which the VBCM applies are in the corresponding\
    \ FCI entries.  The\n   sender of the VBCM MAY send H.271 messages to multiple\
    \ media senders\n   and MAY send more than one H.271 message to the same media\
    \ sender\n   within the same VBCM.\n"
- title: 4.3.4.3.  Timing Rules
  contents:
  - "4.3.4.3.  Timing Rules\n   The timing follows the rules outlined in section 3\
    \ of [RFC4585].  The\n   different sub-message types may have different properties\
    \ in regards\n   to the timing of messages that should be used.  If several different\n\
    \   types are included in the same feedback packet, then the requirements\n  \
    \ for the sub-message type with the most stringent requirements should\n   be\
    \ followed.\n"
- title: 4.3.4.4.  Handling of Message in Mixers or Translators
  contents:
  - "4.3.4.4.  Handling of Message in Mixers or Translators\n   The handling of a\
    \ VBCM in a mixer or translator is sub-message type\n   dependent.\n"
- title: 4.3.4.5.  Remarks
  contents:
  - "4.3.4.5.  Remarks\n   Please see section 3.5.3 for a discussion of the usage\
    \ of H.271\n   messages and messages defined in AVPF [RFC4585] and this memo with\n\
    \   similar functionality.\n     Note: There has been some discussion whether\
    \ the RTP payload type\n     field in this message is needed.  It will be needed\
    \ if there is\n     potentially more than one VBCM-capable RTP payload type in\
    \ the same\n     session, and the semantics of a given VBCM changes between payload\n\
    \     types.  For example, the picture identification mechanism in\n     messages\
    \ of H.271 type 0 is fundamentally different between H.263\n     and H.264 (although\
    \ both use the same syntax).  Therefore, the\n     payload field is justified\
    \ here.  There was a further comment that\n     for TSTR and FIR such a need does\
    \ not exist, because the semantics\n     of TSTR and FIR are either loosely enough\
    \ defined, or generic\n     enough, to apply to all video payloads currently in\n\
    \     existence/envisioned.\n"
- title: 5.  Congestion Control
  contents:
  - "5.  Congestion Control\n   The correct application of the AVPF [RFC4585] timing\
    \ rules prevents\n   the network from being flooded by feedback messages.  Hence,\
    \ assuming\n   a correct implementation and configuration, the RTCP channel cannot\n\
    \   break its bit rate commitment and introduce congestion.\n   The reception\
    \ of some of the feedback messages modifies the behaviour\n   of the media senders\
    \ or, more specifically, the media encoders.\n   Thus, modified behaviour MUST\
    \ respect the bandwidth limits that the\n   application of congestion control\
    \ provides.  For example, when a\n   media sender is reacting to a FIR, the unusually\
    \ high number of\n   packets that form the decoder refresh point have to be paced\
    \ in\n   compliance with the congestion control algorithm, even if the user\n\
    \   experience suffers from a slowly transmitted decoder refresh point.\n   A\
    \ change of the Temporary Maximum Media Stream Bit Rate value can\n   only mitigate\
    \ congestion, but not cause congestion as long as\n   congestion control is also\
    \ employed.  An increase of the value by a\n   request REQUIRES the media sender\
    \ to use congestion control when\n   increasing its transmission rate to that\
    \ value.  A reduction of the\n   value results in a reduced transmission bit rate,\
    \ thus reducing the\n   risk for congestion.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   The defined messages have certain properties\
    \ that have security\n   implications.  These must be addressed and taken into\
    \ account by\n   users of this protocol.\n   The defined setup signaling mechanism\
    \ is sensitive to modification\n   attacks that can result in session creation\
    \ with sub-optimal\n   configuration, and, in the worst case, session rejection.\
    \  To prevent\n   this type of attack, authentication and integrity protection\
    \ of the\n   setup signaling is required.\n   Spoofed or maliciously created feedback\
    \ messages of the type defined\n   in this specification can have the following\
    \ implications:\n        a. severely reduced media bit rate due to false TMMBR\
    \ messages\n           that sets the maximum to a very low value;\n        b.\
    \ assignment of the ownership of a bounding tuple to the wrong\n           participant\
    \ within a TMMBN message, potentially causing\n           unnecessary oscillation\
    \ in the bounding set as the mistakenly\n           identified owner reports a\
    \ change in its tuple and the true\n           owner possibly holds back on changes\
    \ until a correct TMMBN\n           message reaches the participants;\n      \
    \  c. sending TSTRs that result in a video quality different from\n          \
    \ the user's desire, rendering the session less useful;\n        d. sending multiple\
    \ FIR commands to reduce the frame rate, and\n           make the video jerky,\
    \ due to the frequent usage of decoder\n           refresh points.\n   To prevent\
    \ these attacks, there is a need to apply authentication and\n   integrity protection\
    \ of the feedback messages.  This can be\n   accomplished against threats external\
    \ to the current RTP session\n   using the RTP profile that combines Secure RTP\
    \ [SRTP] and AVPF into\n   SAVPF [SAVPF].  In the mixer cases, separate security\
    \ contexts and\n   filtering can be applied between the mixer and the participants,\
    \ thus\n   protecting other users on the mixer from a misbehaving participant.\n"
- title: 7.  SDP Definitions
  contents:
  - "7.  SDP Definitions\n   Section 4 of [RFC4585] defines a new SDP [RFC4566] attribute,\
    \ rtcp-\n   fb, that may be used to negotiate the capability to handle specific\n\
    \   AVPF commands and indications, such as Reference Picture Selection,\n   Picture\
    \ Loss Indication, etc.  The ABNF for rtcp-fb is described in\n   section 4.2\
    \ of [RFC4585].  In this section, we extend the rtcp-fb\n   attribute to include\
    \ the commands and indications that are described\n   for codec control in the\
    \ present document.  We also discuss the\n   Offer/Answer implications for the\
    \ codec control commands and\n   indications.\n"
- title: 7.1.  Extension of the rtcp-fb Attribute
  contents:
  - "7.1.  Extension of the rtcp-fb Attribute\n   As described in AVPF [RFC4585],\
    \ the rtcp-fb attribute indicates the\n   capability of using RTCP feedback. \
    \ AVPF specifies that the rtcp-fb\n   attribute must only be used as a media level\
    \ attribute and must not\n   be provided at session level.  All the rules described\
    \ in [RFC4585]\n   for rtcp-fb attribute relating to payload type and to multiple\
    \ rtcp-\n   fb attributes in a session description also apply to the new feedback\n\
    \   messages defined in this memo.\n   The ABNF [RFC4234] for rtcp-fb as defined\
    \ in [RFC4585] is\n     \"a=rtcp-fb: \" rtcp-fb-pt SP rtcp-fb-val CRLF\n   where\
    \ rtcp-fb-pt is the payload type and rtcp-fb-val defines the type\n   of the feedback\
    \ message such as ack, nack, trr-int, and rtcp-fb-id.\n   For example, to indicate\
    \ the support of feedback of Picture Loss\n   Indication, the sender declares\
    \ the following in SDP\n         v=0\n         o=alice 3203093520 3203093520 IN\
    \ IP4 host.example.com\n         s=Media with feedback\n         t=0 0\n     \
    \    c=IN IP4 host.example.com\n         m=audio 49170 RTP/AVPF 98\n         a=rtpmap:98\
    \ H263-1998/90000\n         a=rtcp-fb:98 nack pli\n   In this document, we define\
    \ a new feedback value \"ccm\", which\n   indicates the support of codec control\
    \ using RTCP feedback messages.\n   The \"ccm\" feedback value SHOULD be used\
    \ with parameters that indicate\n   the specific codec control commands supported.\
    \  In this document, we\n   define four such parameters, namely:\n      o  \"\
    fir\" indicates support of the Full Intra Request (FIR).\n      o  \"tmmbr\" indicates\
    \ support of the Temporary Maximum Media Stream\n         Bit Rate Request/Notification\
    \ (TMMBR/TMMBN).  It has an\n         optional sub-parameter to indicate the session\
    \ maximum packet\n         rate (measured in packets per second) to be used. \
    \ If not\n         included, this defaults to infinity.\n      o  \"tstr\" indicates\
    \ support of the Temporal-Spatial Trade-off\n         Request/Notification (TSTR/TSTN).\n\
    \      o  \"vbcm\" indicates support of H.271 Video Back Channel Messages\n  \
    \       (VBCMs).  It has zero or more subparameters identifying the\n        \
    \ supported H.271 \"payloadType\" values.\n   In the ABNF for rtcp-fb-val defined\
    \ in [RFC4585], there is a\n   placeholder called rtcp-fb-id to define new feedback\
    \ types.  \"ccm\" is\n   defined as a new feedback type in this document, and\
    \ the ABNF for the\n   parameters for ccm is defined here (please refer to section\
    \ 4.2 of\n   [RFC4585] for complete ABNF syntax).\n   rtcp-fb-val        =/ \"\
    ccm\" rtcp-fb-ccm-param\n   rtcp-fb-ccm-param  = SP \"fir\"   ; Full Intra Request\n\
    \                      / SP \"tmmbr\" [SP \"smaxpr=\" MaxPacketRateValue]\n  \
    \                                 ; Temporary max media bit rate\n           \
    \           / SP \"tstr\"  ; Temporal-Spatial Trade-Off\n                    \
    \  / SP \"vbcm\" *(SP subMessageType) ; H.271 VBCMs\n                      / SP\
    \ token [SP byte-string]\n                              ; for future commands/indications\n\
    \   subMessageType = 1*8DIGIT\n   byte-string = <as defined in section 4.2 of\
    \ [RFC4585] >\n   MaxPacketRateValue = 1*15DIGIT\n"
- title: 7.2.  Offer-Answer
  contents:
  - "7.2.  Offer-Answer\n   The Offer/Answer [RFC3264] implications for codec control\
    \ protocol\n   feedback messages are similar to those described in [RFC4585].\
    \  The\n   offerer MAY indicate the capability to support selected codec\n   commands\
    \ and indications.  The answerer MUST remove all CCM\n   parameters corresponding\
    \ to the CCMs that it does not wish to support\n   in this particular media session\
    \ (for example, because it does not\n   implement the message in question, or\
    \ because its application logic\n   suggests that support of the message adds\
    \ no value).  The answerer\n   MUST NOT add new ccm parameters in addition to\
    \ what has been offered.\n   The answer is binding for the media session and both\
    \ offerer and\n   answerer MUST NOT use any feedback messages other than what\
    \ both\n   sides have explicitly indicated as being supported.  In other words,\n\
    \   only the joint subset of CCM parameters from the offer and answer may\n  \
    \ be used.\n   Note that including a CCM parameter in an offer or answer indicates\n\
    \   that the party (offerer or answerer) is at least capable of receiving\n  \
    \ the corresponding CCM(s) and act upon them.  In cases when the\n   reception\
    \ of a negotiated CCM mandates the party to respond with\n   another CCM, it must\
    \ also have that capability.  Although it is not\n   mandated to initiate CCMs\
    \ of any negotiated type, it is generally\n   expected that a party will initiate\
    \ CCMs when appropriate.\n   The session maximum packet rate parameter part of\
    \ the TMMBR\n   indication is declarative, and the highest value from offer and\n\
    \   answer SHALL be used.  If the session maximum packet rate parameter\n   is\
    \ not present in an offer, it SHALL NOT be included by the answerer.\n"
- title: 7.3.  Examples
  contents:
  - "7.3.  Examples\n   Example 1: The following SDP describes a point-to-point video\
    \ call\n   with H.263, with the originator of the call declaring its capability\n\
    \   to support the FIR and TSTR/TSTN codec control messages.  The SDP is\n   carried\
    \ in a high-level signaling protocol like SIP.\n         v=0\n         o=alice\
    \ 3203093520 3203093520 IN IP4 host.example.com\n         s=Point-to-Point call\n\
    \         c=IN IP4 192.0.2.124\n         m=audio 49170 RTP/AVP 0\n         a=rtpmap:0\
    \ PCMU/8000\n         m=video 51372 RTP/AVPF 98\n         a=rtpmap:98 H263-1998/90000\n\
    \         a=rtcp-fb:98 ccm tstr\n         a=rtcp-fb:98 ccm fir\n   In the above\
    \ example, when the sender receives a TSTR message from\n   the remote party it\
    \ is capable of adjusting the trade-off as\n   indicated in the RTCP TSTN feedback\
    \ message.\n   Example 2: The following SDP describes a SIP end point joining\
    \ a\n   video mixer that is hosting a multiparty video conferencing session.\n\
    \   The participant supports only the FIR (Full Intra Request) codec\n   control\
    \ command and it declares it in its session description.\n         v=0\n     \
    \    o=alice 3203093520 3203093520 IN IP4 host.example.com\n         s=Multiparty\
    \ Video Call\n         c=IN IP4 192.0.2.124\n         m=audio 49170 RTP/AVP 0\n\
    \         a=rtpmap:0 PCMU/8000\n         m=video 51372 RTP/AVPF 98\n         a=rtpmap:98\
    \ H263-1998/90000\n         a=rtcp-fb:98 ccm fir\n   When the video MCU decides\
    \ to route the video of this participant, it\n   sends an RTCP FIR feedback message.\
    \  Upon receiving this feedback\n   message, the end point is required to generate\
    \ a full intra request.\n   Example 3: The following example describes the Offer/Answer\n\
    \   implications for the codec control messages.  The offerer wishes to\n   support\
    \ \"tstr\", \"fir\" and \"tmmbr\".  The offered SDP is\n   -------------> Offer\n\
    \         v=0\n         o=alice 3203093520 3203093520 IN IP4 host.example.com\n\
    \         s=Offer/Answer\n         c=IN IP4 192.0.2.124\n         m=audio 49170\
    \ RTP/AVP 0\n         a=rtpmap:0 PCMU/8000\n         m=video 51372 RTP/AVPF 98\n\
    \         a=rtpmap:98 H263-1998/90000\n         a=rtcp-fb:98 ccm tstr\n      \
    \   a=rtcp-fb:98 ccm fir\n         a=rtcp-fb:* ccm tmmbr smaxpr=120\n   The answerer\
    \ wishes to support only the FIR and TSTR/TSTN messages\n   and the answerer SDP\
    \ is\n   <---------------- Answer\n         v=0\n         o=alice 3203093520 3203093524\
    \ IN IP4 otherhost.example.com\n         s=Offer/Answer\n         c=IN IP4 192.0.2.37\n\
    \         m=audio 47190 RTP/AVP 0\n         a=rtpmap:0 PCMU/8000\n         m=video\
    \ 53273 RTP/AVPF 98\n         a=rtpmap:98 H263-1998/90000\n         a=rtcp-fb:98\
    \ ccm tstr\n         a=rtcp-fb:98 ccm fir\n   Example 4: The following example\
    \ describes the Offer/Answer\n   implications for H.271 Video Back Channel Messages\
    \ (VBCMs).  The\n   offerer wishes to support VBCM and the sub-messages of payloadType\
    \ 1\n   (one or more pictures that are entirely or partially lost) and 2 (a\n\
    \   set of blocks of one picture that are entirely or partially lost).\n   ------------->\
    \ Offer\n         v=0\n         o=alice 3203093520 3203093520 IN IP4 host.example.com\n\
    \         s=Offer/Answer\n         c=IN IP4 192.0.2.124\n         m=audio 49170\
    \ RTP/AVP 0\n         a=rtpmap:0 PCMU/8000\n         m=video 51372 RTP/AVPF 98\n\
    \         a=rtpmap:98 H263-1998/90000\n         a=rtcp-fb:98 ccm vbcm 1 2\n  \
    \ The answerer only wishes to support sub-messages of type 1 only\n   <----------------\
    \ Answer\n         v=0\n         o=alice 3203093520 3203093524 IN IP4 otherhost.example.com\n\
    \         s=Offer/Answer\n         c=IN IP4 192.0.2.37\n         m=audio 47190\
    \ RTP/AVP 0\n         a=rtpmap:0 PCMU/8000\n         m=video 53273 RTP/AVPF 98\n\
    \         a=rtpmap:98 H263-1998/90000\n         a=rtcp-fb:98 ccm vbcm 1\n   So,\
    \ in the above example, only VBCM indications comprised of\n   \"payloadType\"\
    \ 1 will be supported.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   The new value \"ccm\" has been registered with IANA\
    \ in the \"rtcp-fb\"\n   Attribute Values registry located at the time of publication\
    \ at:\n   http://www.iana.org/assignments/sdp-parameters\n      Value name:  \
    \     ccm\n      Long Name:        Codec Control Commands and Indications\n  \
    \    Reference:        RFC 5104\n   A new registry \"Codec Control Messages\"\
    \ has been created to hold\n   \"ccm\" parameters located at time of publication\
    \ at:\n   http://www.iana.org/assignments/sdp-parameters\n   New registration\
    \ in this registry follows the \"Specification\n   required\" policy as defined\
    \ by [RFC2434].  In addition, they are\n   required to indicate any additional\
    \ RTCP feedback types, such as\n   \"nack\" and \"ack\".\n   The initial content\
    \ of the registry is the following values:\n      Value name:       fir\n    \
    \  Long name:        Full Intra Request Command\n      Usable with:      ccm\n\
    \      Reference:        RFC 5104\n      Value name:       tmmbr\n      Long name:\
    \        Temporary Maximum Media Stream Bit Rate\n      Usable with:      ccm\n\
    \      Reference:        RFC 5104\n      Value name:       tstr\n      Long name:\
    \        Temporal Spatial Trade Off\n      Usable with:      ccm\n      Reference:\
    \        RFC 5104\n      Value name:       vbcm\n      Long name:        H.271\
    \ video back channel messages\n      Usable with:      ccm\n      Reference: \
    \       RFC 5104\n   The following values have been registered as FMT values in\
    \ the \"FMT\n   Values for RTPFB Payload Types\" registry located at the time\
    \ of\n   publication at: http://www.iana.org/assignments/rtp-parameters\n   RTPFB\
    \ range\n   Name           Long Name                         Value  Reference\n\
    \   -------------- --------------------------------- -----  ---------\n      \
    \            Reserved                             2   [RFC5104]\n   TMMBR    \
    \      Temporary Maximum Media Stream Bit   3   [RFC5104]\n                  Rate\
    \ Request\n   TMMBN          Temporary Maximum Media Stream Bit   4   [RFC5104]\n\
    \                  Rate Notification\n   The following values have been registered\
    \ as FMT values in the \"FMT\n   Values for PSFB Payload Types\" registry located\
    \ at the time of\n   publication at: http://www.iana.org/assignments/rtp-parameters\n\
    \   PSFB range\n   Name           Long Name                             Value\
    \ Reference\n   -------------- ---------------------------------     ----- ---------\n\
    \   FIR            Full Intra Request Command              4   [RFC5104]\n   TSTR\
    \           Temporal-Spatial Trade-off Request      5   [RFC5104]\n   TSTN   \
    \        Temporal-Spatial Trade-off Notification 6   [RFC5104]\n   VBCM      \
    \     Video Back Channel Message              7   [RFC5104]\n"
- title: 9.  Contributors
  contents:
  - "9.  Contributors\n   Tom Taylor has made a very significant contribution to this\n\
    \   specification, for which the authors are very grateful, by helping\n   rewrite\
    \ the specification.  Especially the parts regarding the\n   algorithm for determining\
    \ bounding sets for TMMBR have benefited.\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   The authors would like to thank Andrea Basso, Orit\
    \ Levin, and Nermeen\n   Ismail for their work on the requirement and discussion\
    \ document\n   [Basso].\n   Versions of this memo were reviewed and extensively\
    \ commented on by\n   Roni Even, Colin Perkins, Randell Jesup, Keith Lantz, Harikishan\n\
    \   Desineni, Guido Franceschini, and others.  The authors appreciate\n   these\
    \ reviews.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC4585]   Ott, J., Wenger, S., Sato, N., Burmeister,\
    \ C., and J.\n               Rey, \"Extended RTP Profile for Real-Time Transport\n\
    \               Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\", RFC\n   \
    \            4585, July 2006.\n   [RFC2119]   Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC3550]   Schulzrinne, H.,  Casner, S., Frederick, R., and\
    \ V.\n               Jacobson, \"RTP: A Transport Protocol for Real-Time\n   \
    \            Applications\", STD 64, RFC 3550, July 2003.\n   [RFC4566]   Handley,\
    \ M., Jacobson, V., and C. Perkins, \"SDP: Session\n               Description\
    \ Protocol\", RFC 4566, July 2006.\n   [RFC3264]   Rosenberg, J. and H. Schulzrinne,\
    \ \"An Offer/Answer Model\n               with Session Description Protocol (SDP)\"\
    , RFC 3264, June\n               2002.\n   [RFC2434]   Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing an\n               IANA Considerations Section in RFCs\"\
    , BCP 26, RFC 2434,\n               October 1998.\n   [RFC4234]   Crocker, D.\
    \ and P. Overell, \"Augmented BNF for Syntax\n               Specifications: ABNF\"\
    , RFC 4234, October 2005.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [Basso]     Basso, A., Levin, O., and N. Ismail,\
    \ \"Requirements for\n               transport of video control commands\", Work\
    \ in Progress,\n               October 2004.\n   [AVC]       Joint Video Team\
    \ of ITU-T and ISO/IEC JTC 1, Draft ITU-T\n               Recommendation and Final\
    \ Draft International Standard of\n               Joint Video Specification (ITU-T\
    \ Rec. H.264 | ISO/IEC\n               14496-10 AVC), Joint Video Team (JVT) of\
    \ ISO/IEC MPEG and\n               ITU-T VCEG, JVT-G050, March 2003.\n   [H245]\
    \      ITU-T Rec. H.245, \"Control protocol for multimedia\n               communication\"\
    , May 2006.\n   [NEWPRED]   S. Fukunaga, T. Nakai, and H. Inoue, \"Error Resilient\n\
    \               Video Coding by Dynamic Replacing of Reference Pictures\",\n \
    \              in Proc. Globcom'96, vol. 3, pp. 1503 - 1508, 1996.\n   [SRTP]\
    \      Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.\n           \
    \    Norrman, \"The Secure Real-time Transport Protocol\n               (SRTP)\"\
    , RFC 3711, March 2004.\n   [RFC2032]   Turletti, T. and C. Huitema, \"RTP Payload\
    \ Format for\n               H.261 Video Streams\", RFC 2032, October 1996.\n\
    \   [SAVPF]     Ott, J. and E. Carrara, \"Extended Secure RTP Profile for\n  \
    \             RTCP-based Feedback (RTP/SAVPF)\", Work in Progress,\n         \
    \      November 2007.\n   [RFC3525]   Groves, C., Pantaleo, M., Anderson, T.,\
    \ and T. Taylor,\n               \"Gateway Control Protocol Version 1\", RFC 3525,\
    \ June\n               2003.\n   [RFC3448]   Handley, M., Floyd, S., Padhye, J.,\
    \ and J. Widmer, \"TCP\n               Friendly Rate Control (TFRC): Protocol\
    \ Specification\",\n               RFC 3448, January 2003.\n   [H.271]     ITU-T\
    \ Rec. H.271, \"Video Back Channel Messages\", June\n               2006.\n  \
    \ [RFC3890]   Westerlund, M., \"A Transport Independent Bandwidth\n          \
    \     Modifier for the Session Description Protocol (SDP)\", RFC\n           \
    \    3890, September 2004.\n   [RFC4340]   Kohler, E., Handley, M., and S. Floyd,\
    \ \"Datagram\n               Congestion Control Protocol (DCCP)\", RFC 4340, March\n\
    \               2006.\n   [RFC3261]   Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G., Johnston,\n               A., Peterson, J., Sparks, R., Handley, M., and\
    \ E.\n               Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n\
    \               June 2002.\n   [RFC2198]   Perkins, C., Kouvelas, I., Hodson,\
    \ O., Hardman, V.,\n               Handley, M., Bolot, J., Vega-Garcia, A., and\
    \ S. Fosse-\n               Parisis, \"RTP Payload for Redundant Audio Data\"\
    , RFC\n               2198, September 1997.\n   [RFC4587]   Even, R., \"RTP Payload\
    \ Format for H.261 Video Streams\",\n               RFC 4587, August 2006.\n \
    \  [RFC5117]   Westerlund, M. and S. Wenger, \"RTP Topologies\", RFC 5117,\n \
    \              January 2008.\n   [XML-MC]    Levin, O., Even, R., and P. Hagendorf,\
    \ \"XML Schema for\n               Media Control\", Work in Progress, November\
    \ 2007.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Stephan Wenger\n   Nokia Corporation\n   975, Page Mill\
    \ Road,\n   Palo Alto,CA 94304\n   USA\n   Phone: +1-650-862-7368\n   EMail: stewe@stewe.org\n\
    \   Umesh Chandra\n   Nokia Research Center\n   975, Page Mill Road,\n   Palo\
    \ Alto,CA 94304\n   USA\n   Phone: +1-650-796-7502\n   Email: Umesh.1.Chandra@nokia.com\n\
    \   Magnus Westerlund\n   Ericsson Research\n   Ericsson AB\n   SE-164 80 Stockholm,\
    \ SWEDEN\n   Phone: +46 8 7190000\n   EMail: magnus.westerlund@ericsson.com\n\
    \   Bo Burman\n   Ericsson Research\n   Ericsson AB\n   SE-164 80 Stockholm, SWEDEN\n\
    \   Phone: +46 8 7190000\n   EMail: bo.burman@ericsson.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
