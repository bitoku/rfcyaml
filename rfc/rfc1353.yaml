- title: __initial_text__
  contents:
  - "                     Definitions of Managed Objects\n                   for Administration\
    \ of SNMP Parties\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an IAB standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements. Please refer to the current edition of the \"IAB\n   Official\
    \ Protocol Standards\" for the standardization state and status\n   of this protocol.\
    \ Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo defines a portion of the Management Information Base (MIB)\n\
    \   for use with network management protocols in TCP/IP-based internets.\n   In\
    \ particular, it describes a representation of the SNMP parties\n   defined in\
    \ [8] as objects defined according to the Internet Standard\n   SMI [1]. These\
    \ definitions are consistent with the SNMP Security\n   protocols set forth in\
    \ [9].\n"
- title: Table of Contents
  contents:
  - 'Table of Contents

    '
- title: 1.  The Network Management Framework
  contents:
  - "1.  The Network Management Framework\n   the Internet-standard Network Management\
    \ Framework consists of three\n   components.  They are:\n      RFC 1155 which\
    \ defines the SMI, the mechanisms used for describing\n      and naming objects\
    \ for the purpose of management.  RFC 1212\n      defines a more concise description\
    \ mechanism, which is wholly\n      consistent with the SMI.\n      RFC 1156 which\
    \ defines MIB-I, the core set of managed objects for\n      the Internet suite\
    \ of protocols.  RFC 1213, defines MIB-II, an\n      evolution of MIB-I based\
    \ on implementation experience and new\n      operational requirements.\n    \
    \  RFC 1157 which defines the SNMP, the protocol used for network\n      access\
    \ to managed objects.\n   The Framework permits new objects to be defined for\
    \ the purpose of\n   experimentation and evaluation.\n"
- title: 2.  Objects
  contents:
  - "2.  Objects\n   Managed objects are accessed via a virtual information store,\
    \ termed\n   the Management Information Base or MIB.  Objects in the MIB are\n\
    \   defined using the subset of Abstract Syntax Notation One (ASN.1) [5]\n   defined\
    \ in the SMI.  In particular, each object has a name, a syntax,\n   and an encoding.\
    \  The name is an object identifier, an\n   administratively assigned name, which\
    \ specifies an object type.  The\n   object type together with an object instance\
    \ serves to uniquely\n   identify a specific instantiation of the object.  For\
    \ human\n   convenience, we often use a textual string, termed the OBJECT\n  \
    \ DESCRIPTOR, to also refer to the object type.\n   The syntax of an object type\
    \ defines the abstract data structure\n   corresponding to that object type. \
    \ The ASN.1 language is used for\n   this purpose.  However, the SMI [1] purposely\
    \ restricts the ASN.1\n   constructs which may be used.  These restrictions are\
    \ explicitly made\n   for simplicity.\n   The encoding of an object type is simply\
    \ how that object type is\n   represented using the object type's syntax.  Implicitly\
    \ tied to the\n   notion of an object type's syntax and encoding is how the object\
    \ type\n   is represented when being transmitted on the network.\n   The SMI specifies\
    \ the use of the basic encoding rules of ASN.1 [6],\n   subject to the additional\
    \ requirements imposed by the SNMP.\n"
- title: 2.1.  Format of Definitions
  contents:
  - "2.1.  Format of Definitions\n   Section 4 contains the specification of all object\
    \ types contained in\n   this MIB module.  The object types are defined using\
    \ the conventions\n   defined in the SMI, as amended by the extensions specified\
    \ in [7].\n"
- title: 3.  Overview
  contents:
  - '3.  Overview

    '
- title: 3.1.  Structure
  contents:
  - "3.1.  Structure\n   This MIB contains the definitions for four tables, a number\
    \ of OBJECT\n   IDENTIFIER assignments, and some conventions for initial use with\n\
    \   some of the assignments.  The four tables are the SNMP Party Public\n   database,\
    \ the SNMP Party Secrets database, the SNMP Access Control\n   database, and the\
    \ SNMP Views database.\n   The SNMP Party Public database and the SNMP Party Secrets\
    \ database\n   are defined as separate tables specifically for the purpose of\n\
    \   positioning them in different parts of the MIB tree namespace.  In\n   particular,\
    \ the SNMP Party Secrets database contains secret\n   information, for which security\
    \ demands that access to it be limited\n   to parties which use both authentication\
    \ and privacy.  It is\n   therefore positioned in a separate branch of the MIB\
    \ tree so as to\n   provide for the easiest means of accommodating the required\n\
    \   limitation.\n   In contrast, the SNMP Party Public database contains public\n\
    \   information about SNMP parties.  In particular, it contains the\n   parties'\
    \ clocks which need to be read-able (but not write-able) by\n   unauthenticated\
    \ queries, since an unauthenticated query of a party's\n   clock is the first\
    \ step of the procedure to re-establish clock\n   synchronization (see [9]).\n\
    \   The objects in this MIB are organized into four groups.  All four of\n   the\
    \ groups are mandatory for those SNMP implementations that realize\n   the security\
    \ framework and mechanisms defined in [8] and [9].\n"
- title: 3.2.  Instance Identifiers
  contents:
  - "3.2.  Instance Identifiers\n   In all four of the tables in this MIB, the object\
    \ instances are\n   identified by values which have an underlying syntax of OBJECT\n\
    \   IDENTIFIER.  For the Party Public database and the Party Secrets\n   database,\
    \ the index variable is the party identifier.  For the Access\n   Control database\
    \ and the Views database, two index variables are\n   defined, both of which have\
    \ a syntax of OBJECT IDENTIFIER.  (See the\n   INDEX clauses in the MIB definitions\
    \ below for the specific\n   variables.)\n   According to RFC 1212 [7], section\
    \ 4.1.6, the syntax of the object(s)\n   specified in an INDEX clause indicates\
    \ how to form the instance-\n   identifier.  In particular, for each index object\
    \ which is object\n   identifier-valued, its contribution to the instance identifier\
    \ is:\n      `n+1' sub-identifiers, where `n' is the number of sub-identifiers\n\
    \      in the value (the first sub-identifier is `n' itself, following\n     \
    \ this, each sub-identifier in the value is copied).\n"
- title: 3.3.  Textual Conventions
  contents:
  - "3.3.  Textual Conventions\n   The datatypes, Party, Clock, and TAddress, are\
    \ used as textual\n   conventions in this document.  These textual conventions\
    \ have NO\n   effect on either the syntax nor the semantics of any managed object.\n\
    \   Objects defined using these conventions are always encoded by means\n   of\
    \ the rules that define their primitive type.  Hence, no changes to\n   the SMI\
    \ or the SNMP are necessary to accommodate these textual\n   conventions which\
    \ are adopted merely for the convenience of readers.\n"
- title: 4.  Definitions
  contents:
  - "4.  Definitions\n          RFC1353-MIB DEFINITIONS ::= BEGIN\n          IMPORTS\n\
    \                  system, mib, private, internet    FROM RFC1155-SMI\n      \
    \            OBJECT-TYPE                       FROM RFC-1212;\n          snmpParties\
    \     OBJECT IDENTIFIER ::= { mib-2 20 }\n          partyAdmin      OBJECT IDENTIFIER\
    \ ::= { snmpParties 1 }\n          partyPublic     OBJECT IDENTIFIER ::= { snmpParties\
    \ 2 }\n          snmpSecrets     OBJECT IDENTIFIER ::= { mib-2 21 }\n        \
    \  partyPrivate    OBJECT IDENTIFIER ::= { snmpSecrets 1 }\n          partyAccess\
    \     OBJECT IDENTIFIER ::= { snmpSecrets 2 }\n          partyViews      OBJECT\
    \ IDENTIFIER ::= { snmpSecrets 3 }\n          --                  Textual Conventions\n\
    \          --    A textual convention denoting a SNMP party identifier:\n    \
    \      Party ::= OBJECT IDENTIFIER\n          --    A party's authentication clock\
    \ - a non-negative integer\n          -- which is incremented as specified/allowed\
    \ by the party's\n          -- Authentication Protocol.\n          --    For noAuth,\
    \ a party's authentication clock is unused and\n          -- its value is undefined.\n\
    \          --    For md5AuthProtocol, a party's authentication clock is a\n  \
    \        -- relative clock with 1-second granularity.\n          Clock ::= INTEGER\
    \ (0..2147483647)\n          --    A textual convention denoting a transport service\n\
    \          -- address.\n          --    For rfc1351Domain, a TAddress is 6 octets\
    \ long,\n          -- the initial 4 octets containing the IP-address in\n    \
    \      -- network-byte order and the last 2 containing the\n          -- UDP port\
    \ in network-byte order.\n          TAddress ::= OCTET STRING\n          --- Definitions\
    \ of Security Protocols\n          partyProtocols\n              OBJECT IDENTIFIER\
    \ ::= { partyAdmin 1 }\n          noAuth                  -- The protocol without\
    \ authentication\n              OBJECT IDENTIFIER ::= { partyProtocols 1 }\n \
    \         noPriv                  -- The protocol without privacy\n          \
    \    OBJECT IDENTIFIER ::= { partyProtocols 3 }\n          desPrivProtocol   \
    \      -- The DES Privacy Protocol\n              OBJECT IDENTIFIER ::= { partyProtocols\
    \ 4 }\n          md5AuthProtocol         -- The MD5 Authentication Protocol\n\
    \              OBJECT IDENTIFIER ::= { partyProtocols 5 }\n          --- definitions\
    \ of Transport Domains\n          transportDomains\n              OBJECT IDENTIFIER\
    \ ::= { partyAdmin 2 }\n          rfc1351Domain --- RFC-1351 (SNMP over UDP, using\
    \ SNMP Parties)\n              OBJECT IDENTIFIER ::= { transportDomains 1 }\n\
    \          --- definitions of Proxy Domains\n          proxyDomains\n        \
    \      OBJECT IDENTIFIER ::= { partyAdmin 3 }\n          noProxy             \
    \   --- Local operation\n              OBJECT IDENTIFIER ::= { proxyDomains 1\
    \ }\n          ---    Definition of Initial Party Identifiers\n          --  When\
    \ devices are installed, they need to be configured\n          --  with an initial\
    \ set of SNMP parties.  The configuration\n          --  of SNMP parties requires\
    \ (among other things) the\n          --  assignment of several OBJECT IDENTIFIERs.\
    \  Any local\n          --  network administration can obtain the delegated\n\
    \          --  authority necessary to assign its own OBJECT\n          --  IDENTIFIERs.\
    \  However, to provide for those\n          --  administrations who have not obtained\
    \ the necessary\n          --  authority, this document allocates a branch of\
    \ the\n          --  naming tree for use with the following conventions.\n   \
    \       initialPartyId\n              OBJECT IDENTIFIER ::= { partyAdmin 4 }\n\
    \          --  Note these are identified as \"initial\" party identifiers\n  \
    \        --  since these allow secure SNMP communication to proceed,\n       \
    \   --  thereby allowing further SNMP parties to be configured\n          -- \
    \ through use of the SNMP itself.\n          --  The following definitions identify\
    \ a party identifier,\n          --  and specify the initial values of various\
    \ object\n          --  instances indexed by that identifier.  In addition,\n\
    \          --  the initial MIB view and access control parameters\n          --\
    \  assigned, by convention, to these parties are identified.\n          --   \
    \ Party Identifiers for use as initial SNMP parties\n          --       at IP\
    \ address  a.b.c.d\n          -- partyIdentity            = { initialPartyId a\
    \ b c d 1 }\n          -- partyTDomain             = { rfc1351Domain }\n     \
    \     -- partyTAddress            = a.b.c.d, 161\n          -- partyProxyFor \
    \           = { noProxy }\n          -- partyAuthProtocol        = { noAuth }\n\
    \          -- partyAuthClock           = 0\n          -- partySecretsAuthPrivate\
    \  = ''h    (the empty string)\n          -- partyAuthPublic          = ''h  \
    \  (the empty string)\n          -- partyAuthLifetime        = 0\n          --\
    \ partyPrivProtocol        = { noPriv }\n          -- partySecretsPrivPrivate\
    \  = ''h    (the empty string)\n          -- partyPrivPublic          = ''h  \
    \  (the empty string)\n          -- partyIdentity            = { initialPartyId\
    \ a b c d 2 }\n          -- partyTDomain             = { rfc1351Domain }\n   \
    \       -- partyTAddress            = assigned by local administration\n     \
    \     -- partyProxyFor            = { noProxy }\n          -- partyAuthProtocol\
    \        = { noAuth }\n          -- partyAuthClock           = 0\n          --\
    \ partySecretsAuthPrivate  = ''h    (the empty string)\n          -- partyAuthPublic\
    \          = ''h    (the empty string)\n          -- partyAuthLifetime       \
    \ = 0\n          -- partyPrivProtocol        = { noPriv }\n          -- partySecretsPrivPrivate\
    \  = ''h    (the empty string)\n          -- partyPrivPublic          = ''h  \
    \  (the empty string)\n          -- partyIdentity            = { initialPartyId\
    \ a b c d 3 }\n          -- partyTDomain             = { rfc1351Domain }\n   \
    \       -- partyTAddress            = a.b.c.d, 161\n          -- partyProxyFor\
    \            = { noProxy }\n          -- partyAuthProtocol        = { md5AuthProtocol\
    \ }\n          -- partyAuthClock           = 0\n          -- partySecretsAuthPrivate\
    \  = assigned by local administration\n          -- partyAuthPublic          =\
    \ ''h    (the empty string)\n          -- partyAuthLifetime        = 300\n   \
    \       -- partyPrivProtocol        = { noPriv }\n          -- partySecretsPrivPrivate\
    \  = ''h    (the empty string)\n          -- partyPrivPublic          = ''h  \
    \  (the empty string)\n          -- partyIdentity            = { initialPartyId\
    \ a b c d 4 }\n          -- partyTDomain             = { rfc1351Domain }\n   \
    \       -- partyTAddress            = assigned by local administration\n     \
    \     -- partyProxyFor            = { noProxy }\n          -- partyAuthProtocol\
    \        = { md5AuthProtocol }\n          -- partyAuthClock           = 0\n  \
    \        -- partySecretsAuthPrivate  = assigned by local administration\n    \
    \      -- partyAuthPublic          = ''h    (the empty string)\n          -- partyAuthLifetime\
    \        = 300\n          -- partyPrivProtocol        = { noPriv }\n         \
    \ -- partySecretsPrivPrivate  = ''h    (the empty string)\n          -- partyPrivPublic\
    \          = ''h    (the empty string)\n          -- partyIdentity           \
    \ = { initialPartyId a b c d 5 }\n          -- partyTDomain             = { rfc1351Domain\
    \ }\n          -- partyTAddress            = a.b.c.d, 161\n          -- partyProxyFor\
    \            = { noProxy }\n          -- partyAuthProtocol        = { md5AuthProtocol\
    \ }\n          -- partyAuthClock           = 0\n          -- partySecretsAuthPrivate\
    \  = assigned by local administration\n          -- partyAuthPublic          =\
    \ ''h    (the empty string)\n          -- partyAuthLifetime        = 300\n   \
    \       -- partyPrivProtocol        = { desPrivProtocol }\n          -- partySecretsPrivPrivate\
    \  = assigned by local administration\n          -- partyPrivPublic          =\
    \ ''h    (the empty string)\n          -- partyIdentity            = { initialPartyId\
    \ a b c d 6 }\n          -- partyTDomain             = { rfc1351Domain }\n   \
    \       -- partyTAddress            = assigned by local administration\n     \
    \     -- partyProxyFor            = { noProxy }\n          -- partyAuthProtocol\
    \        = { md5AuthProtocol }\n          -- partyAuthClock           = 0\n  \
    \        -- partySecretsAuthPrivate  = assigned by local administration\n    \
    \      -- partyAuthPublic          = ''h    (the empty string)\n          -- partyAuthLifetime\
    \        = 300\n          -- partyPrivProtocol        = { desPrivProtocol }\n\
    \          -- partySecretsPrivPrivate  = assigned by local administration\n  \
    \        -- partyPrivPublic          = ''h   (the empty string)\n          --\
    \  The initial access control parameters assigned, by\n          --  convention,\
    \ to these parties are:\n          -- aclTarget     = { initialPartyId a b c d\
    \ 1 }\n          -- aclSubject    = { initialPartyId a b c d 2 }\n          --\
    \ aclPrivileges = 3 (Get & Get-Next)\n          -- aclTarget     = { initialPartyId\
    \ a b c d 2 }\n          -- aclSubject    = { initialPartyId a b c d 1 }\n   \
    \       -- aclPrivileges = 20 (GetResponse & Trap)\n          -- aclTarget   \
    \  = { initialPartyId a b c d 3 }\n          -- aclSubject    = { initialPartyId\
    \ a b c d 4 }\n          -- aclPrivileges = 11 (Get, Get-Next & Set)\n       \
    \   -- aclTarget     = { initialPartyId a b c d 4 }\n          -- aclSubject \
    \   = { initialPartyId a b c d 3 }\n          -- aclPrivileges = 20 (GetResponse\
    \ & Trap)\n          -- aclTarget     = { initialPartyId a b c d 5 }\n       \
    \   -- aclSubject    = { initialPartyId a b c d 6 }\n          -- aclPrivileges\
    \ = 11 (Get, Get-Next & Set)\n          -- aclTarget     = { initialPartyId a\
    \ b c d 6 }\n          -- aclSubject    = { initialPartyId a b c d 5 }\n     \
    \     -- aclPrivileges = 20 (GetResponse & Trap)\n          --  The initial MIB\
    \ views assigned, by convention, to\n          --  these parties are:\n      \
    \    -- viewParty    = { initialPartyId a b c d 1 }\n          -- viewSubtree\
    \  = { system }\n          -- viewStatus   = { included }\n          -- viewMask\
    \     = { ''h }\n          -- viewParty    = { initialPartyId a b c d 1 }\n  \
    \        -- viewSubtree  = { snmpParties }\n          -- viewStatus   = { included\
    \ }\n          -- viewMask     = { ''h }\n          -- viewParty    = { initialPartyId\
    \ a b c d 3 }\n          -- viewSubtree  = { internet }\n          -- viewStatus\
    \   = { included }\n          -- viewMask     = { ''h }\n          -- viewParty\
    \    = { initialPartyId a b c d 3 }\n          -- viewSubtree  = { partyPrivate\
    \ }\n          -- viewStatus   = { excluded }\n          -- viewMask     = { ''h\
    \ }\n          -- viewParty    = { initialPartyId a b c d 5 }\n          -- viewSubtree\
    \  = { internet }\n          -- viewStatus   = { included }\n          -- viewMask\
    \     = { ''h }\n          --   The SNMP Party Public Database Group\n       \
    \   --\n          -- The non-secret party information.\n          --\n       \
    \   -- Implementation of the objects in this group is mandatory.\n          partyTable\
    \ OBJECT-TYPE\n              SYNTAX  SEQUENCE OF PartyEntry\n              ACCESS\
    \  not-accessible\n              STATUS  mandatory\n              DESCRIPTION\n\
    \                      \"The SNMP Party Public database.\n                   \
    \   An agent must ensure that there is, at all times,\n                      a\
    \ one-to-one correspondence between entries in\n                      this table\
    \ and entries in the partySecretsTable.\n                      The creation/deletion\
    \ of instances in this table\n                      via SNMP Set-Requests is not\
    \ allowed.  Instead,\n                      entries in this table are created/deleted\
    \ as a\n                      side-effect of the creation/deletion of\n      \
    \                corresponding entries in the partySecretsTable.\n           \
    \           Thus, a SNMP Set-Request whose varbinds contain a\n              \
    \        reference to a non-existent instance of a\n                      partyTable\
    \ object, but no reference to the\n                      corresponding instance\
    \ of a partySecretsTable\n                      object, will be rejected.\"\n\
    \          ::= { partyPublic 1 }\n          partyEntry OBJECT-TYPE\n         \
    \     SYNTAX  PartyEntry\n              ACCESS  not-accessible\n             \
    \ STATUS  mandatory\n              DESCRIPTION\n                      \"Locally\
    \ held non-secret information about a\n                      particular SNMP party,\
    \ which is available for\n                      access by network management.\
    \  Note that this does\n                      not include all locally held information\
    \ about a\n                      party.  In particular, it does not include the\n\
    \                      'last-timestamp' (i.e., the timestamp of the last\n   \
    \                   authentic message received) or the 'nonce'\n             \
    \         values.\"\n              INDEX  { partyIdentity }\n              ::=\
    \ { partyTable 1 }\n          PartyEntry ::=\n              SEQUENCE {\n     \
    \             partyIdentity\n                      Party,\n                  partyTDomain\n\
    \                      OBJECT IDENTIFIER,\n                  partyTAddress\n \
    \                     TAddress,\n                  partyProxyFor\n           \
    \           Party,\n                  partyAuthProtocol\n                    \
    \  OBJECT IDENTIFIER,\n                  partyAuthClock\n                    \
    \  Clock,\n                  partyAuthPublic\n                      OCTET STRING,\n\
    \                  partyAuthLifetime\n                      INTEGER,\n       \
    \           partyPrivProtocol\n                      OBJECT IDENTIFIER,\n    \
    \              partyPrivPublic\n                      OCTET STRING,\n        \
    \          partyMaxMessageSize\n                      INTEGER,\n             \
    \     partyStatus\n                      INTEGER\n              }\n          partyIdentity\
    \  OBJECT-TYPE\n              SYNTAX  Party\n              ACCESS  read-write\n\
    \              STATUS  mandatory\n              DESCRIPTION\n                \
    \      \"A party identifier uniquely identifying a\n                      particular\
    \ SNMP party.\"\n              ::= { partyEntry 1 }\n          partyTDomain  OBJECT-TYPE\n\
    \              SYNTAX  OBJECT IDENTIFIER\n              ACCESS  read-write\n \
    \             STATUS  mandatory\n              DESCRIPTION\n                 \
    \     \"Indicates the kind of transport service by which\n                   \
    \   the party receives network management traffic. An\n                      example\
    \ of a transport domain is 'rfc1351Domain'\n                      (SNMP over UDP).\"\
    \n              DEFVAL  { rfc1351Domain }\n              ::= { partyEntry 2 }\n\
    \          partyTAddress  OBJECT-TYPE\n              SYNTAX  TAddress\n      \
    \        ACCESS  read-write\n              STATUS  mandatory\n              DESCRIPTION\n\
    \                      \"The transport service address by which the party\n  \
    \                    receives network management traffic, formatted\n        \
    \              according to the corresponding value of\n                     \
    \ partyTDomain.  For rfc1351Domain, partyTAddress is\n                      formatted\
    \ as a 4-octet IP Address concatenated\n                      with a 2-octet UDP\
    \ port number.\"\n              DEFVAL  { '000000000000'h }\n              ::=\
    \ { partyEntry 3 }\n          partyProxyFor OBJECT-TYPE\n              SYNTAX\
    \  Party\n              ACCESS  read-write\n              STATUS  mandatory\n\
    \              DESCRIPTION\n                      \"The identity of a second SNMP\
    \ party or other\n                      management entity with which interaction\
    \ may be\n                      necessary to satisfy received management requests.\n\
    \                      In this context, the distinguished value { noProxy\n  \
    \                    } signifies that the party responds to received\n       \
    \               management requests by entirely local mechanisms.\"\n        \
    \      DEFVAL  { noProxy }\n              ::= { partyEntry 4 }\n          partyAuthProtocol\
    \ OBJECT-TYPE\n              SYNTAX  OBJECT IDENTIFIER\n              ACCESS \
    \ read-write\n              STATUS  mandatory\n              DESCRIPTION\n   \
    \                   \"The authentication protocol by which all messages\n    \
    \                  generated by the party are authenticated as to\n          \
    \            origin and integrity.  In this context, the value\n             \
    \         { noAuth } signifies that messages generated by\n                  \
    \    the party are not authenticated.\"\n              DEFVAL  { md5AuthProtocol\
    \ }\n              ::= { partyEntry 5 }\n          partyAuthClock OBJECT-TYPE\n\
    \              SYNTAX  Clock\n              ACCESS  read-write\n             \
    \ STATUS  mandatory\n              DESCRIPTION\n                      \"The authentication\
    \ clock which represents the\n                      local notion of the current\
    \ time specific to the\n                      party.  This value must not be decremented\
    \ unless\n                      the party's secret information is changed\n  \
    \                    simultaneously, at which time the party's nonce\n       \
    \               and last-timestamp values must also be reset to\n            \
    \          zero, and the new value of the clock,\n                      respectively.\"\
    \n              DEFVAL  { 0 }\n              ::= { partyEntry 6 }\n          partyAuthPublic\
    \ OBJECT-TYPE\n              SYNTAX  OCTET STRING -- for md5AuthProtocol: (SIZE\
    \ (0..16))\n              ACCESS  read-write\n              STATUS  mandatory\n\
    \              DESCRIPTION\n                      \"A publically-readable value\
    \ for the party.\n                      Depending on the party's authentication\
    \ protocol,\n                      this value may be needed to support the party's\n\
    \                      authentication protocol.  Alternatively, it may be\n  \
    \                    used by a manager during the procedure for\n            \
    \          altering secret information about a party.  (For\n                \
    \      example, by altering the value of an instance of\n                    \
    \  this object in the same SNMP Set-Request used to\n                      update\
    \ an instance of partyAuthPrivate, a\n                      subsequent Get-Request\
    \ can determine if the Set-\n                      Request was successful in the\
    \ event that no\n                      response to the Set-Request is received,\
    \ see RFC\n                      1352.)\n                      The length of the\
    \ value is dependent on the\n                      party's authentication protocol.\
    \  If not used by\n                      the authentication protocol, it is recommended\n\
    \                      that agents support values of any length up to and\n  \
    \                    including the length of the corresponding\n             \
    \         partyAuthPrivate object.\"\n              DEFVAL  { ''h }      -- the\
    \ empty string\n              ::= { partyEntry 7 }\n          partyAuthLifetime\
    \ OBJECT-TYPE\n              SYNTAX  INTEGER (0..2147483647)\n              ACCESS\
    \  read-write\n              STATUS  mandatory\n              DESCRIPTION\n  \
    \                    \"The lifetime (in units of seconds) which\n            \
    \          represents an administrative upper bound on\n                     \
    \ acceptable delivery delay for protocol messages\n                      generated\
    \ by the party.\"\n              DEFVAL  { 300 }\n              ::= { partyEntry\
    \ 8 }\n          partyPrivProtocol OBJECT-TYPE\n              SYNTAX  OBJECT IDENTIFIER\n\
    \              ACCESS  read-write\n              STATUS  mandatory\n         \
    \     DESCRIPTION\n                      \"The privacy protocol by which all protocol\n\
    \                      messages received by the party are protected from\n   \
    \                   disclosure.  In this context, the value { noPriv }\n     \
    \                 signifies that messages received by the party are\n        \
    \              not protected.\"\n              DEFVAL  { noPriv }\n          \
    \    ::= { partyEntry 9 }\n          partyPrivPublic OBJECT-TYPE\n           \
    \   SYNTAX  OCTET STRING -- for desPrivProtocol: (SIZE (0..16))\n            \
    \  ACCESS  read-write\n              STATUS  mandatory\n              DESCRIPTION\n\
    \                      \"A publically-readable value for the party.\n        \
    \              Depending on the party's privacy protocol, this\n             \
    \         value may be needed to support the party's privacy\n               \
    \       protocol.  Alternatively, it may be used by a\n                      manager\
    \ as a part of its procedure for altering\n                      secret information\
    \ about a party.  (For example,\n                      by altering the value of\
    \ an instance of this\n                      object in the same SNMP Set-Request\
    \ used to update\n                      an instance of partyPrivPrivate, a subsequent\n\
    \                      Get-Request can determine if the Set-Request was\n    \
    \                  successful in the event that no response to the\n         \
    \             Set-Request is received, see RFC 1352.)\n                      The\
    \ length of the value is dependent on the\n                      party's privacy\
    \ protocol.  If not used by the\n                      privacy protocol, it is\
    \ recommended that agents\n                      support values of any length\
    \ up to and including\n                      the length of the corresponding partyPrivPrivate\n\
    \                      object.\"\n              DEFVAL  { ''h }     -- the empty\
    \ string\n              ::= { partyEntry 10 }\n          partyMaxMessageSize OBJECT-TYPE\n\
    \              SYNTAX  INTEGER (484..65507)\n              ACCESS  read-write\n\
    \              STATUS  mandatory\n              DESCRIPTION\n                \
    \      \"The maximum length in octets of a SNMP message\n                    \
    \  which this party will accept.  For parties which\n                      execute\
    \ at an agent, the agent initializes this\n                      object to the\
    \ maximum length supported by the\n                      agent, and does not let\
    \ the object be set to any\n                      larger value.  For parties which\
    \ do not execute at\n                      the agent, the agent must allow the\
    \ manager to set\n                      this object to any legal value, even if\
    \ it is\n                      larger than the agent can generate.\"\n       \
    \       DEFVAL  { 484 }\n              ::= { partyEntry 11 }\n          partyStatus\
    \ OBJECT-TYPE\n              SYNTAX  INTEGER  { valid(1), invalid(2) }\n     \
    \         ACCESS  read-only\n              STATUS  mandatory\n              DESCRIPTION\n\
    \                      \"The status of the locally-held information on a\n   \
    \                   particular SNMP party.\n                      The instance\
    \ of this object for a particular party\n                      and the instance\
    \ of partySecretsStatus for the\n                      same party always have\
    \ the same value.\n                      This object will typically provide unrestricted\n\
    \                      read-only access to the status of parties.  In\n      \
    \                contrast, partySecretsStatus will typically\n               \
    \       provide restricted read-write access to the status\n                 \
    \     of parties.\"\n              ::= { partyEntry 12 }\n          --   The SNMP\
    \ Party Secrets Database Group\n          -- The secret party information\n  \
    \        --\n          -- Implementation of the objects in this group is mandatory.\n\
    \          partySecretsTable OBJECT-TYPE\n              SYNTAX  SEQUENCE OF PartySecretsEntry\n\
    \              ACCESS  not-accessible\n              STATUS  mandatory\n     \
    \         DESCRIPTION\n                      \"The SNMP Party Secrets database.\"\
    \n          ::= { partyPrivate 1 }\n          partySecretsEntry OBJECT-TYPE\n\
    \              SYNTAX  PartySecretsEntry\n              ACCESS  not-accessible\n\
    \              STATUS  mandatory\n              DESCRIPTION\n                \
    \      \"Locally held secret information about a\n                      particular\
    \ SNMP party, which is available for\n                      access by network\
    \ management.\n                      When a SNMP Set-Request is used to update\
    \ the\n                      values of instances of objects in this table, it\n\
    \                      is recommended that the same SNMP Set-Request also\n  \
    \                    alter the value of a non-secret object instance\n       \
    \               (e.g., an instance of partyAuthPublic or\n                   \
    \   partyPrivPublic).  This allows a Get-Request of\n                      that\
    \ non-secret object instance to determine if\n                      the Set-Request\
    \ was successful in the event that\n                      no response which matches\
    \ the Set-Request is\n                      received, see RFC 1352.\"\n      \
    \        INDEX  { partySecretsIdentity }\n              ::= { partySecretsTable\
    \ 1 }\n          PartySecretsEntry ::=\n              SEQUENCE {\n           \
    \       partySecretsIdentity\n                      Party,\n                 \
    \ partySecretsAuthPrivate\n                      OCTET STRING,\n             \
    \     partySecretsPrivPrivate\n                      OCTET STRING,\n         \
    \         partySecretsStatus\n                      INTEGER\n              }\n\
    \          partySecretsIdentity  OBJECT-TYPE\n              SYNTAX  Party\n  \
    \            ACCESS  read-write\n              STATUS  mandatory\n           \
    \   DESCRIPTION\n                      \"A party identifier uniquely identifying\
    \ a\n                      particular SNMP party.\"\n              ::= { partySecretsEntry\
    \ 1 }\n          partySecretsAuthPrivate OBJECT-TYPE\n              SYNTAX  OCTET\
    \ STRING   -- for md5AuthProtocol: (SIZE (16))\n              ACCESS  read-write\n\
    \              STATUS  mandatory\n              DESCRIPTION\n                \
    \      \"An encoding of the party's private authentication\n                 \
    \     key which may be needed to support the\n                      authentication\
    \ protocol.  Although the value of\n                      this variable may be\
    \ altered by a management\n                      operation (e.g., a SNMP Set-Request),\
    \ its value\n                      can never be retrieved by a management operation:\n\
    \                      when read, the value of this variable is the zero\n   \
    \                   length OCTET STRING.\n                      The private authentication\
    \ key is NOT directly\n                      represented by the value of this\
    \ variable, but\n                      rather it is represented according to an\
    \ encoding.\n                      This encoding is the bitwise exclusive-OR of\
    \ the\n                      old key with the new key, i.e., of the old private\n\
    \                      authentication key (prior to the alteration) with\n   \
    \                   the new private authentication key (after the\n          \
    \            alteration).  Thus, when processing a received\n                \
    \      protocol Set operation, the new private\n                      authentication\
    \ key is obtained from the value of\n                      this variable as the\
    \ result of a bitwise\n                      exclusive-OR of the variable's value\
    \ and the old\n                      private authentication key.  In calculating\
    \ the\n                      exclusive-OR, if the old key is shorter than the\n\
    \                      new key, zero-valued padding is appended to the\n     \
    \                 old key.  If no value for the old key exists, a\n          \
    \            zero-length OCTET STRING is used in the\n                      calculation.\"\
    \n              DEFVAL  { ''h }     -- the empty string\n              ::= { partySecretsEntry\
    \ 2 }\n          partySecretsPrivPrivate OBJECT-TYPE\n              SYNTAX  OCTET\
    \ STRING   -- for desPrivProtocol: (SIZE (16))\n              ACCESS  read-write\n\
    \              STATUS  mandatory\n              DESCRIPTION\n                \
    \      \"An encoding of the party's private encryption key\n                 \
    \     which may be needed to support the privacy\n                      protocol.\
    \  Although the value of this variable may\n                      be altered by\
    \ a management operation (e.g., a SNMP\n                      Set-Request), its\
    \ value can never be retrieved by\n                      a management operation:\
    \ when read, the value of\n                      this variable is the zero length\
    \ OCTET STRING.\n                      The private encryption key is NOT directly\n\
    \                      represented by the value of this variable, but\n      \
    \                rather it is represented according to an encoding.\n        \
    \              This encoding is the bitwise exclusive-OR of the\n            \
    \          old key with the new key, i.e., of the old private\n              \
    \        encryption key (prior to the alteration) with the\n                 \
    \     new private encryption key (after the alteration).\n                   \
    \   Thus, when processing a received protocol Set\n                      operation,\
    \ the new private encryption key is\n                      obtained from the value\
    \ of this variable as the\n                      result of a bitwise exclusive-OR\
    \ of the variable's\n                      value and the old private encryption\
    \ key.  In\n                      calculating the exclusive-OR, if the old key\
    \ is\n                      shorter than the new key, zero-valued padding is\n\
    \                      appended to the old key.  If no value for the old\n   \
    \                   key exists, a zero-length OCTET STRING is used in\n      \
    \                the calculation.\"\n              DEFVAL  { ''h }     -- the\
    \ empty string\n              ::= { partySecretsEntry 3 }\n          partySecretsStatus\
    \ OBJECT-TYPE\n              SYNTAX  INTEGER  { valid(1), invalid(2) }\n     \
    \         ACCESS  read-write\n              STATUS  mandatory\n              DESCRIPTION\n\
    \                      \"The status of the locally-held information on a\n   \
    \                   particular SNMP party.\n                      Setting an instance\
    \ of this object to the value\n                      'valid(1)' has the effect\
    \ of ensuring that valid\n                      local knowledge exists for the\
    \ corresponding\n                      party.  For valid local knowledge to exist,\
    \ there\n                      must be corresponding instances of each object\
    \ in\n                      this table and in the partyTable.  Thus, the\n   \
    \                   creation of instances in the partyTable (but not\n       \
    \               in the aclTable or viewTable) occurs as a direct\n           \
    \           result of the creation of instances in this table.\n             \
    \         Setting an instance of this object to the value\n                  \
    \    'invalid(2)' has the effect of invalidating all\n                      local\
    \ knowledge of the corresponding party,\n                      including the invalidating\
    \ of any/all entries in\n                      the partyTable, the partySecretsTable,\
    \ the\n                      aclTable, and the viewTable which reference said\n\
    \                      party.\n                      It is an implementation-specific\
    \ matter as to\n                      whether the agent removes an invalidated\
    \ entry\n                      from the table.  Accordingly, management stations\n\
    \                      must be prepared to receive from agents tabular\n     \
    \                 information corresponding to entries not currently\n       \
    \               in use.  Proper interpretation of such entries\n             \
    \         requires examination of the relevant\n                      partySecretsStatus\
    \ object.\"\n              DEFVAL  { valid }\n              ::= { partySecretsEntry\
    \ 4 }\n          --  The SNMP Access Privileges Database Group\n          -- \
    \ This group of objects allows the SNMP itself to be used to\n          --  configure\
    \ new SNMP parties, or to manipulate the access\n          --  privileges of existing\
    \ parties.\n          --\n          --  Implementation of the objects in this\
    \ group is mandatory.\n          aclTable OBJECT-TYPE\n              SYNTAX  SEQUENCE\
    \ OF AclEntry\n              ACCESS  not-accessible\n              STATUS  mandatory\n\
    \              DESCRIPTION\n                      \"The access privileges database.\"\
    \n          ::= { partyAccess 1 }\n          aclEntry OBJECT-TYPE\n          \
    \    SYNTAX  AclEntry\n              ACCESS  not-accessible\n              STATUS\
    \  mandatory\n              DESCRIPTION\n                      \"The access privileges\
    \ for a particular requesting\n                      SNMP party in accessing a\
    \ particular target SNMP\n                      party.\"\n              INDEX\
    \  { aclTarget, aclSubject }\n              ::= { aclTable 1 }\n          AclEntry\
    \ ::=\n              SEQUENCE {\n                  aclTarget\n               \
    \       Party,\n                  aclSubject\n                      Party,\n \
    \                 aclPrivileges\n                      INTEGER,\n            \
    \      aclStatus\n                      INTEGER\n              }\n          aclTarget\
    \ OBJECT-TYPE\n              SYNTAX  Party\n              ACCESS  read-write\n\
    \              STATUS  mandatory\n              DESCRIPTION\n                \
    \      \"The target SNMP party whose performance of\n                      management\
    \ operations is constrained by this set\n                      of access privileges.\"\
    \n              ::= { aclEntry 1 }\n          aclSubject OBJECT-TYPE\n       \
    \       SYNTAX  Party\n              ACCESS  read-write\n              STATUS\
    \  mandatory\n              DESCRIPTION\n                      \"The subject SNMP\
    \ party whose requests for\n                      management operations to be\
    \ performed is\n                      constrained by this set of access privileges.\"\
    \n              ::= { aclEntry 2 }\n          aclPrivileges OBJECT-TYPE\n    \
    \          SYNTAX  INTEGER (0..31)\n              ACCESS  read-write\n       \
    \       STATUS  mandatory\n              DESCRIPTION\n                      \"\
    The access privileges which govern what\n                      management operations\
    \ a particular target party\n                      may perform when requested\
    \ by a particular subject\n                      party.  These privileges are\
    \ specified as a sum of\n                      values, where each value specifies\
    \ a SNMP PDU type\n                      by which the subject party may request\
    \ a permitted\n                      operation.  The value for a particular PDU\
    \ type is\n                      computed as 2 raised to the value of the ASN.1\n\
    \                      context-specific tag for the appropriate SNMP PDU\n   \
    \                   type.  The values (for the tags defined in RFC\n         \
    \             1157) are defined in RFC 1351 as:\n                       Get  \
    \       :   1\n                       GetNext     :   2\n                    \
    \   GetResponse :   4\n                       Set         :   8\n            \
    \           Trap        :  16\n                      The null set is represented\
    \ by the value zero.\"\n              DEFVAL  { 3 }      -- Get & Get-Next\n \
    \             ::= { aclEntry 3 }\n          aclStatus OBJECT-TYPE\n          \
    \    SYNTAX  INTEGER  { valid(1), invalid(2) }\n              ACCESS  read-write\n\
    \              STATUS  mandatory\n              DESCRIPTION\n                \
    \      \"The status of the access privileges for a\n                      particular\
    \ requesting SNMP party in accessing a\n                      particular target\
    \ SNMP party.  Setting an instance\n                      of this object to the\
    \ value 'invalid(2)' has the\n                      effect of invalidating the\
    \ corresponding access\n                      privileges.\n                  \
    \    It is an implementation-specific matter as to\n                      whether\
    \ the agent removes an invalidated entry\n                      from the table.\
    \  Accordingly, management stations\n                      must be prepared to\
    \ receive from agents tabular\n                      information corresponding\
    \ to entries not currently\n                      in use.  Proper interpretation\
    \ of such entries\n                      requires examination of the relevant\
    \ aclStatus\n                      object.\"\n              DEFVAL  { valid }\n\
    \              ::= { aclEntry 4 }\n          --   The MIB View Database Group\n\
    \          --  This group of objects allows the SNMP itself to be used to\n  \
    \        --  configure new SNMP parties, or to manipulate the MIB\n          --\
    \  MIB views of existing parties.\n          --\n          --  Implementation\
    \ of the objects in this group is mandatory.\n          viewTable OBJECT-TYPE\n\
    \              SYNTAX  SEQUENCE OF ViewEntry\n              ACCESS  not-accessible\n\
    \              STATUS  mandatory\n              DESCRIPTION\n                \
    \      \"The table contained in the local database which\n                   \
    \   defines local MIB views.  Each SNMP party has a\n                      single\
    \ MIB view which is defined by two\n                      collections of view\
    \ subtrees: the included view\n                      subtrees, and the excluded\
    \ view subtrees.  Every\n                      such subtree, both included and\
    \ excluded, is\n                      defined in this table.\n               \
    \       To determine if a particular object instance is in\n                 \
    \     a particular SNMP party's MIB view, compare the\n                      object\
    \ instance's Object Identifier with each\n                      entry (for this\
    \ party) in this table.  If none\n                      match, then the object\
    \ instance is not in the MIB\n                      view.  If one or more match,\
    \ then the object\n                      instance is included in, or excluded\
    \ from, the MIB\n                      view according to the value of viewStatus\
    \ in the\n                      entry whose value of viewSubtree has the most\n\
    \                      sub-identifiers.  If multiple entries match and\n     \
    \                 have the same number of sub-identifiers, then the\n        \
    \              lexicographically greatest instance of viewStatus\n           \
    \           determines the inclusion or exclusion.\n                      An object\
    \ instance's Object Identifier X matches\n                      an entry in this\
    \ table when the number of sub-\n                      identifiers in X is at\
    \ least as many as in the\n                      value of viewSubtree for the\
    \ entry, and each sub-\n                      identifier in the value of viewSubtree\
    \ matches its\n                      corresponding sub-identifier in X.  Two sub-\n\
    \                      identifiers match either if the corresponding bit\n   \
    \                   of viewMask is zero (the 'wild card' value), or if\n     \
    \                 they are equal.\n                      Due to this 'wild card'\
    \ capability, we introduce\n                      the term, a 'family' of view\
    \ subtrees, to refer to\n                      the set of subtrees defined by\
    \ a particular\n                      combination of values of viewSubtree and\
    \ viewMask.\n                      In the case where no 'wild card' is defined\
    \ in\n                      viewMask, the family of view subtrees reduces to a\n\
    \                      single view subtree.\"\n          ::= { partyViews 1 }\n\
    \          viewEntry OBJECT-TYPE\n              SYNTAX  ViewEntry\n          \
    \    ACCESS  not-accessible\n              STATUS  mandatory\n              DESCRIPTION\n\
    \                      \"Information on a particular family of view\n        \
    \              subtrees included in or excluded from a particular\n          \
    \            SNMP party's MIB view.\"\n              INDEX  { viewParty, viewSubtree\
    \ }\n              ::= { viewTable 1 }\n          ViewEntry ::=\n            \
    \  SEQUENCE {\n                  viewParty\n                      Party,\n   \
    \               viewSubtree\n                      OBJECT IDENTIFIER,\n      \
    \            viewStatus\n                      INTEGER,\n                  viewMask\n\
    \                      OCTET STRING\n              }\n          viewParty  OBJECT-TYPE\n\
    \              SYNTAX  Party\n              ACCESS  read-write\n             \
    \ STATUS  mandatory\n              DESCRIPTION\n                      \"The SNMP\
    \ party whose single MIB view includes or\n                      excludes a particular\
    \ family of view subtrees.\"\n              ::= { viewEntry 1 }\n          viewSubtree\
    \ OBJECT-TYPE\n              SYNTAX  OBJECT IDENTIFIER\n              ACCESS \
    \ read-write\n              STATUS  mandatory\n              DESCRIPTION\n   \
    \                   \"The view subtree which, in combination with the\n      \
    \                corresponding instance of viewMask, defines a\n             \
    \         family of view subtrees.  This family is included\n                \
    \      in, or excluded from the particular SNMP party's\n                    \
    \  MIB view, according to the value of the\n                      corresponding\
    \ instance of viewStatus.\"\n              ::= { viewEntry 2 }\n          viewStatus\
    \ OBJECT-TYPE\n              SYNTAX  INTEGER  {\n                          included(1),\n\
    \                          excluded(2),\n                          invalid(3)\n\
    \                      }\n              ACCESS  read-write\n              STATUS\
    \  mandatory\n              DESCRIPTION\n                      \"The status of\
    \ a particular family of view\n                      subtrees within the particular\
    \ SNMP party's MIB\n                      view.  The value 'included(1)' indicates\
    \ that the\n                      corresponding instances of viewSubtree and\n\
    \                      viewMask define a family of view subtrees included\n  \
    \                    in the MIB view.  The  value 'excluded(2)'\n            \
    \          indicates that the corresponding instances of\n                   \
    \   viewSubtree and viewMask define a family of view\n                      subtrees\
    \ excluded from the MIB view.\n                      Setting an instance of this\
    \ object to the value\n                      'invalid(3)' has the effect of invalidating\
    \ the\n                      presence or absence of the corresponding family of\n\
    \                      view subtrees in the corresponding SNMP party's\n     \
    \                 MIB view.\n                      It is an implementation-specific\
    \ matter as to\n                      whether the agent removes an invalidated\
    \ entry\n                      from the table.  Accordingly, management stations\n\
    \                      must be prepared to receive from agents tabular\n     \
    \                 information corresponding to entries not currently\n       \
    \               in use.  Proper interpretation of such entries\n             \
    \         requires examination of the relevant viewStatus\n                  \
    \    object.\"\n              DEFVAL  { included }\n              ::= { viewEntry\
    \ 3 }\n          viewMask  OBJECT-TYPE\n              SYNTAX  OCTET STRING (SIZE\
    \ (0..16))\n              ACCESS  read-write\n              STATUS  mandatory\n\
    \              DESCRIPTION\n                      \"The bit mask which, in combination\
    \ with the\n                      corresponding instance of viewSubtree, defines\
    \ a\n                      family of view subtrees.\n                      Each\
    \ bit of this bit mask corresponds to a sub-\n                      identifier\
    \ of viewSubtree, with the most\n                      significant bit of the\
    \ i-th octet of this octet\n                      string value (extended if necessary,\
    \ see below)\n                      corresponding to the (8*i - 7)-th sub-identifier,\n\
    \                      and the least significant bit of the i-th octet of\n  \
    \                    this octet string corresponding to the (8*i)-th\n       \
    \               sub-identifier, where i is in the range 1 through\n          \
    \            16.\n                      Each bit of this bit mask specifies whether\
    \ or not\n                      the corresponding sub-identifiers must match when\n\
    \                      determining if an Object Identifier is in this\n      \
    \                family of view subtrees; a '1' indicates that an\n          \
    \            exact match must occur; a '0' indicates 'wild\n                 \
    \     card', i.e., any sub-identifier value matches.\n                      Thus,\
    \ the Object Identifier X of an object\n                      instance is contained\
    \ in a family of view subtrees\n                      if the following criteria\
    \ are met:\n                           for each sub-identifier of the value of\n\
    \                           viewSubtree, either:\n                           \
    \     the i-th bit of viewMask is 0, or\n                                the i-th\
    \ sub-identifier of X is equal to\n                                the i-th sub-identifier\
    \ of the value of\n                                viewSubtree.\n            \
    \          If the value of this bit mask is M bits long and\n                \
    \      there are more than M sub-identifiers in the\n                      corresponding\
    \ instance of viewSubtree, then the\n                      bit mask is extended\
    \ with 1's to be the required\n                      length.\n               \
    \       Note that when the value of this object is the\n                     \
    \ zero-length string, this extension rule results in\n                      a\
    \ mask of all-1's being used (i.e., no 'wild\n                      card'), and\
    \ the family of view subtrees is the one\n                      view subtree uniquely\
    \ identified by the\n                      corresponding instance of viewSubtree.\"\
    \n              DEFVAL  { ''h }\n              ::= { viewEntry 4 }\n         \
    \ END\n"
- title: 5.  Acknowledgments
  contents:
  - "5.  Acknowledgments\n   This document was produced on behalf of the SNMP Security\
    \ Working\n   Group of the Internet Engineering Task Force.  The authors wish\
    \ to\n   thank the members of the working group, and others who contributed to\n\
    \   this effort.\n"
- title: 6.  References
  contents:
  - "6.  References\n   [1] Rose, M., and K. McCloghrie, \"Structure and Identification\
    \ of\n       Management Information for TCP/IP based internets\", RFC 1155,\n\
    \       Performance Systems International, Hughes LAN Systems, May 1990.\n   [2]\
    \ McCloghrie, K., and M. Rose, \"Management Information Base for\n       Network\
    \ Management of TCP/IP-based Internets\", RFC 1156, Hughes\n       LAN Systems\
    \ and Performance Systems International, May 1990.\n   [3] Case, J., M. Fedor,\
    \ M. Schoffstall, and J. Davin, The Simple\n       Network Management Protocol\"\
    , RFC 1157, University of Tennessee\n       at Knoxville, Performance Systems\
    \ International, Performance\n       Systems International, and the MIT Laboratory\
    \ for Computer\n       Science, May 1990.\n   [4] McCloghrie K., and M. Rose,\
    \ Editors, \"Management Information Base\n       for Network Management of TCP/IP-based\
    \ internets\", RFC 1213,\n       Performance Systems International, March 1991.\n\
    \   [5] Information processing systems - Open Systems Interconnection -\n    \
    \   Specification of Abstract Syntax Notation One (ASN.1),\n       International\
    \ Organization for Standardization, International\n       Standard 8824, December\
    \ 1987.\n   [6] Information processing systems - Open Systems Interconnection\
    \ -\n       Specification of Basic Encoding Rules for Abstract Notation One\n\
    \       (ASN.1), International Organization for Standardization,\n       International\
    \ Standard 8825, December 1987.\n   [7] Rose, M., and K. McCloghrie, Editors,\
    \ \"Concise MIB Definitions\",\n       RFC 1212, Performance Systems International,\
    \ Hughes LAN Systems,\n       March 1991.\n   [8] Davin, J., Galvin, J., and K.\
    \ McCloghrie, \"SNMP Administrative\n       Model\", RFC 1351, MIT Laboratory\
    \ for Computer Science, Trusted\n       Information Systems, Inc., Hughes LAN\
    \ Systems, Inc., July 1992.\n   [9] Galvin, J., McCloghrie, K., and J. Davin,\
    \ \"SNMP Security\n       Protocols\", RFC 1352, Trusted Information Systems,\
    \ Inc., Hughes\n       LAN Systems, Inc., MIT Laboratory for Computer Science,\
    \ July\n       1992.\n"
- title: Security Considerstions
  contents:
  - "Security Considerstions\n   Security issues are discussed in section 3.1. and\
    \ in RFCs 1351 and\n   1352.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Keith McCloghrie\n   Hughes LAN Systems, Inc.\n   Mountain\
    \ View, CA 94043\n   Phone:  (415) 966-7934\n   EMail:  kzm@hls.com\n   James\
    \ R. Davin\n   MIT Laboratory for Computer Science\n   545 Technology Square\n\
    \   Cambridge, MA 02139\n   Phone:  (617) 253-6020\n   EMail:  jrd@ptt.lcs.mit.edu\n\
    \   James M. Galvin\n   Trusted Information Systems, Inc.\n   3060 Washington\
    \ Road, Route 97\n   Glenwood, MD 21738\n   Phone:  (301) 854-6889\n   EMail:\
    \  galvin@tis.com\n"
