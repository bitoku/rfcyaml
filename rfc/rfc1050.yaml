- title: __initial_text__
  contents:
  - "                       RPC: Remote Procedure Call\n                         Protocol\
    \ Specification\n"
- title: STATUS OF THIS MEMO
  contents:
  - "STATUS OF THIS MEMO\n   This RFC describes a standard that Sun Microsystems and\
    \ others are\n   using and is one we wish to propose for the Internet's consideration.\n\
    \   This memo is not an Internet standard at this time.  Distribution of\n   this\
    \ memo is unlimited.\n"
- title: 1. INTRODUCTION
  contents:
  - "1. INTRODUCTION\n   This document specifies a message protocol used in implementing\
    \ Sun's\n   Remote Procedure Call (RPC) package.  The message protocol is\n  \
    \ specified with the eXternal Data Representation (XDR) language [9].\n   This\
    \ document assumes that the reader is familiar with XDR.  It does\n   not attempt\
    \ to justify RPC or its uses.  The paper by Birrell and\n   Nelson [1] is recommended\
    \ as an excellent background to and\n   justification of RPC.\n"
- title: 2. TERMINOLOGY
  contents:
  - "2. TERMINOLOGY\n   This document discusses servers, services, programs, procedures,\n\
    \   clients, and versions.  A server is a piece of software where network\n  \
    \ services are implemented.  A network service is a collection of one\n   or more\
    \ remote programs.  A remote program implements one or more\n   remote procedures;\
    \ the procedures, their parameters, and results are\n   documented in the specific\
    \ program's protocol specification (see\n   Appendix A for an example).  Network\
    \ clients are pieces of software\n   that initiate remote procedure calls to services.\
    \  A server may\n   support more than one version of a remote program in order\
    \ to be\n   forward compatible with changing protocols.\n   For example, a network\
    \ file service may be composed of two programs.\n   One program may deal with\
    \ high-level applications such as file system\n   access control and locking.\
    \  The other may deal with low-level file\n   IO and have procedures like \"read\"\
    \ and \"write\".  A client machine of\n   the network file service would call\
    \ the procedures associated with\n   the two programs of the service on behalf\
    \ of some user on the client\n   machine.\n"
- title: 3. THE RPC MODEL
  contents:
  - "3. THE RPC MODEL\n   The remote procedure call model is similar to the local\
    \ procedure\n   call model.  In the local case, the caller places arguments to\
    \ a\n   procedure in some well-specified location (such as a result\n   register).\
    \  It then transfers control to the procedure, and\n   eventually gains back control.\
    \  At that point, the results of the\n   procedure are extracted from the well-specified\
    \ location, and the\n   caller continues execution.\n   The remote procedure call\
    \ is similar, in that one thread of control\n   logically winds through two processes\
    \ -- one is the caller's process,\n   the other is a server's process.  That is,\
    \ the caller process sends a\n   call message to the server process and waits\
    \ (blocks) for a reply\n   message.  The call message contains the procedure's\
    \ parameters, among\n   other things.  The reply message contains the procedure's\
    \ results,\n   among other things.  Once the reply message is received, the results\n\
    \   of the procedure are extracted, and caller's execution is resumed.\n   On\
    \ the server side, a process is dormant awaiting the arrival of a\n   call message.\
    \  When one arrives, the server process extracts the\n   procedure's parameters,\
    \ computes the results, sends a reply message,\n   and then awaits the next call\
    \ message.\n   Note that in this model, only one of the two processes is active\
    \ at\n   any given time.  However, this model is only given as an example.\n \
    \  The RPC protocol makes no restrictions on the concurrency model\n   implemented,\
    \ and others are possible.  For example, an implementation\n   may choose to have\
    \ RPC calls be asynchronous, so that the client may\n   do useful work while waiting\
    \ for the reply from the server.  Another\n   possibility is to have the server\
    \ create a task to process an\n   incoming request, so that the server can be\
    \ free to receive other\n   requests.\n"
- title: 4. TRANSPORTS AND SEMANTICS
  contents:
  - "4. TRANSPORTS AND SEMANTICS\n   The RPC protocol is independent of transport\
    \ protocols.  That is, RPC\n   does not care how a message is passed from one\
    \ process to another.\n   The protocol deals only with specification and interpretation\
    \ of\n   messages.\n   It is important to point out that RPC does not try to implement\
    \ any\n   kind of reliability and that the application must be aware of the\n\
    \   type of transport protocol underneath RPC.  If it knows it is running\n  \
    \ on top of a reliable transport such as TCP/IP [6], then most of the\n   work\
    \ is already done for it.  On the other hand, if it is running on\n   top of an\
    \ unreliable transport such as UDP/IP [7], it must implement\n   its own retransmission\
    \ and time-out policy as the RPC layer does not\n   provide this service.\n  \
    \ Because of transport independence, the RPC protocol does not attach\n   specific\
    \ semantics to the remote procedures or their execution.\n   Semantics can be\
    \ inferred from (but should be explicitly specified\n   by) the underlying transport\
    \ protocol.  For example, consider RPC\n   running on top of an unreliable transport\
    \ such as UDP/IP.  If an\n   application retransmits RPC messages after short\
    \ time-outs, the only\n   thing it can infer if it receives no reply is that the\
    \ procedure was\n   executed zero or more times.  If it does receive a reply,\
    \ then it can\n   infer that the procedure was executed at least once.\n   A server\
    \ may wish to remember previously granted requests from a\n   client and not regrant\
    \ them in order to insure some degree of\n   execute-at-most-once semantics. \
    \ A server can do this by taking\n   advantage of the transaction ID that is packaged\
    \ with every RPC\n   request.  The main use of this transaction is by the client\
    \ RPC layer\n   in matching replies to requests.  However, a client application\
    \ may\n   choose to reuse its previous transaction ID when retransmitting a\n\
    \   request.  The server application, knowing this fact, may choose to\n   remember\
    \ this ID after granting a request and not regrant requests\n   with the same\
    \ ID in order to achieve some degree of execute-at-most-\n   once semantics. \
    \ The server is not allowed to examine this ID in any\n   other way except as\
    \ a test for equality.\n   On the other hand, if using a reliable transport such\
    \ as TCP/IP, the\n   application can infer from a reply message that the procedure\
    \ was\n   executed exactly once, but if it receives no reply message, it cannot\n\
    \   assume the remote procedure was not executed.  Note that even if a\n   connection-oriented\
    \ protocol like TCP is used, an application still\n   needs time-outs and reconnection\
    \ to handle server crashes.\n   There are other possibilities for transports besides\
    \ datagram- or\n   connection-oriented protocols.  For example, a request-reply\
    \ protocol\n   such as VMTP [2] is perhaps the most natural transport for RPC.\n\
    \   Note:  At Sun, RPC is currently implemented on top of both TCP/IP and\n  \
    \ UDP/IP transports.\n"
- title: 5. BINDING AND RENDEZVOUS INDEPENDENCE
  contents:
  - "5. BINDING AND RENDEZVOUS INDEPENDENCE\n   The act of binding a client to a service\
    \ is NOT part of the remote\n   procedure call specification.  This important\
    \ and necessary function\n   is left up to some higher-level software.  (The software\
    \ may use RPC\n   itself; see Appendix A.)\n   Implementors should think of the\
    \ RPC protocol as the jump-subroutine\n   instruction (\"JSR\") of a network;\
    \ the loader (binder) makes JSR\n   useful, and the loader itself uses JSR to\
    \ accomplish its task.\n   Likewise, the network makes RPC useful, using RPC to\
    \ accomplish this\n   task.\n"
- title: 6. AUTHENTICATION
  contents:
  - "6. AUTHENTICATION\n   The RPC protocol provides the fields necessary for a client\
    \ to\n   identify itself to a service and vice-versa.  Security and access\n \
    \  control mechanisms can be built on top of the message authentication.\n   Several\
    \ different authentication protocols can be supported.  A field\n   in the RPC\
    \ header indicates which protocol is being used.  More\n   information on specific\
    \ authentication protocols is in section 9:\n   \"Authentication Protocols\".\n"
- title: 7. RPC PROTOCOL REQUIREMENTS
  contents:
  - "7. RPC PROTOCOL REQUIREMENTS\n   The RPC protocol must provide for the following:\n\
    \      (1) Unique specification of a procedure to be called.\n      (2) Provisions\
    \ for matching response messages to request messages.\n      (3) Provisions for\
    \ authenticating the caller to service and\n          vice-versa.\n   Besides\
    \ these requirements, features that detect the following are\n   worth supporting\
    \ because of protocol roll-over errors, implementation\n   bugs, user error, and\
    \ network administration:\n      (1) RPC protocol mismatches.\n      (2) Remote\
    \ program protocol version mismatches.\n      (3) Protocol errors (such as misspecification\
    \ of a procedure's\n          parameters).\n      (4) Reasons why remote authentication\
    \ failed.\n      (5) Any other reasons why the desired procedure was not called.\n"
- title: 7.1 RPC Programs and Procedures
  contents:
  - "7.1 RPC Programs and Procedures\n   The RPC call message has three unsigned fields:\
    \  remote program\n   number, remote program version number, and remote procedure\
    \ number.\n   The three fields uniquely identify the procedure to be called.\n\
    \   Program numbers are administered by some central authority (like\n   Sun).\
    \  Once an implementor has a program number, he can implement his\n   remote program;\
    \ the first implementation would most likely have the\n   version number of 1.\
    \  Because most new protocols evolve into better,\n   stable, and mature protocols,\
    \ a version field of the call message\n   identifies which version of the protocol\
    \ the caller is using.\n   Version numbers make speaking old and new protocols\
    \ through the same\n   server process possible.\n   The procedure number identifies\
    \ the procedure to be called.  These\n   numbers are documented in the specific\
    \ program's protocol\n   specification.  For example, a file service's protocol\
    \ specification\n   may state that its procedure number 5 is \"read\" and procedure\
    \ number\n   12 is \"write\".\n   Just as remote program protocols may change\
    \ over several versions,\n   the actual RPC message protocol could also change.\
    \  Therefore, the\n   call message also has in it the RPC version number, which\
    \ is always\n   equal to two for the version of RPC described here.\n   The reply\
    \ message to a request message has enough information to\n   distinguish the following\
    \ error conditions:\n      (1) The remote implementation of RPC does speak protocol\
    \ version 2.\n          The lowest and highest supported RPC version numbers are\n\
    \          returned.\n      (2) The remote program is not available on the remote\
    \ system.\n      (3) The remote program does not support the requested version\
    \ number.\n          The lowest and highest supported remote program version numbers\n\
    \          are returned.\n      (4) The requested procedure number does not exist.\
    \  (This is usually\n          a caller side protocol or programming error.)\n\
    \      (5) The parameters to the remote procedure appear to be garbage\n     \
    \     from the server's point of view.  (Again, this is usually\n          caused\
    \ by a disagreement about the protocol between client\n          and service.)\n"
- title: 7.2 Authentication
  contents:
  - "7.2 Authentication\n   Provisions for authentication of caller to service and\
    \ vice-versa are\n   provided as a part of the RPC protocol.  The call message\
    \ has two\n   authentication fields, the credentials and verifier.  The reply\n\
    \   message has one authentication field, the response verifier.  The RPC\n  \
    \ protocol specification defines all three fields to be the following\n   opaque\
    \ type:\n         enum auth_flavor {\n            AUTH_NULL       = 0,\n     \
    \       AUTH_UNIX       = 1,\n            AUTH_SHORT      = 2,\n            AUTH_DES\
    \        = 3\n            /* and more to be defined */\n         };\n        \
    \ struct opaque_auth {\n            auth_flavor flavor;\n            opaque body<400>;\n\
    \         };\n   In simple English, any \"opaque_auth\" structure is an \"auth_flavor\"\
    \n   enumeration followed by bytes which are opaque to the RPC protocol\n   implementation.\n\
    \   The interpretation and semantics of the data contained within the\n   authentication\
    \ fields is specified by individual, independent\n   authentication protocol specifications.\
    \  (Section 9 defines the\n   various authentication protocols.)\n   If authentication\
    \ parameters were rejected, the response message\n   contains information stating\
    \ why they were rejected.\n"
- title: 7.3 Program Number Assignment
  contents:
  - "7.3 Program Number Assignment\n   Program numbers are given out in groups of\
    \ hexadecimal 20000000\n   (decimal 536870912) according to the following chart:\n\
    \                 0 - 1fffffff   defined by Sun\n          20000000 - 3fffffff\
    \   defined by user\n          40000000 - 5fffffff   transient\n          60000000\
    \ - 7fffffff   reserved\n          80000000 - 9fffffff   reserved\n          a0000000\
    \ - bfffffff   reserved\n          c0000000 - dfffffff   reserved\n          e0000000\
    \ - ffffffff   reserved\n   The first group is a range of numbers administered\
    \ by Sun\n   Microsystems and should be identical for all sites.  The second range\n\
    \   is for applications peculiar to a particular site.  This range is\n   intended\
    \ primarily for debugging new programs.  When a site develops\n   an application\
    \ that might be of general interest, that application\n   should be given an assigned\
    \ number in the first range.  The third\n   group is for applications that generate\
    \ program numbers dynamically.\n   The final groups are reserved for future use,\
    \ and should not be used.\n"
- title: 7.4 Other Uses of the RPC Protocol
  contents:
  - "7.4 Other Uses of the RPC Protocol\n   The intended use of this protocol is for\
    \ calling remote procedures.\n   That is, each call message is matched with a\
    \ response message.\n   However, the protocol itself is a message-passing protocol\
    \ with which\n   other (non-RPC) protocols can be implemented.  Sun currently\
    \ uses, or\n   perhaps abuses, the RPC message protocol for the following two\
    \ (non-\n   RPC) protocols:  batching (or pipelining) and broadcast RPC.  These\n\
    \   two protocols are discussed but not defined below.\n"
- title: 7.4.1 Batching
  contents:
  - "7.4.1 Batching\n   Batching allows a client to send an arbitrarily large sequence\
    \ of\n   call messages to a server; batching typically uses reliable byte\n  \
    \ stream protocols (like TCP/IP) for its transport.  In the case of\n   batching,\
    \ the client never waits for a reply from the server, and the\n   server does\
    \ not send replies to batch requests.  A sequence of batch\n   calls is usually\
    \ terminated by a legitimate RPC in order to flush the\n   pipeline (with positive\
    \ acknowledgement).\n"
- title: 7.4.2 Broadcast RPC
  contents:
  - "7.4.2 Broadcast RPC\n   In broadcast RPC-based protocols, the client sends a\
    \ broadcast packet\n   to the network and waits for numerous replies.  Broadcast\
    \ RPC uses\n   unreliable, packet-based protocols (like UDP/IP) as its transports.\n\
    \   Servers that support broadcast protocols only respond when the\n   request\
    \ is successfully processed, and are silent in the face of\n   errors.  Broadcast\
    \ RPC uses the Port Mapper RPC service to achieve\n   its semantics.  (See Appendix\
    \ A for more information.)\n"
- title: 8. THE RPC MESSAGE PROTOCOL
  contents:
  - "8. THE RPC MESSAGE PROTOCOL\n   This section defines the RPC message protocol\
    \ in the XDR data\n   description language.  The message is defined in a top-down\
    \ style.\n       enum msg_type {\n          CALL  = 0,\n          REPLY = 1\n\
    \       };\n       /*\n        * A reply to a call message can take on two forms:\n\
    \        * The message was either accepted or rejected.\n        */\n       enum\
    \ reply_stat {\n          MSG_ACCEPTED = 0,\n          MSG_DENIED   = 1\n    \
    \   };\n       /*\n        * Given that a call message was accepted, the following\
    \ is the\n        * status of an attempt to call a remote procedure.\n       \
    \ */\n       enum accept_stat {\n          SUCCESS       = 0, /* RPC executed\
    \ successfully       */\n          PROG_UNAVAIL  = 1, /* remote hasn't exported\
    \ program  */\n          PROG_MISMATCH = 2, /* remote can't support version #\
    \  */\n          PROC_UNAVAIL  = 3, /* program can't support procedure */\n  \
    \        GARBAGE_ARGS  = 4  /* procedure can't decode params   */\n       };\n\
    \       /*\n        * Reasons why a call message was rejected:\n        */\n \
    \      enum reject_stat {\n          RPC_MISMATCH = 0, /* RPC version number !=\
    \ 2          */\n          AUTH_ERROR = 1    /* remote can't authenticate caller\
    \ */\n       };\n       /*\n        * Why authentication failed:\n        */\n\
    \       enum auth_stat {\n          AUTH_BADCRED      = 1,  /* bad credentials\
    \ (seal broken) */\n          AUTH_REJECTEDCRED = 2,  /* client must begin new\
    \ session */\n          AUTH_BADVERF      = 3,  /* bad verifier (seal broken)\
    \    */\n          AUTH_REJECTEDVERF = 4,  /* verifier expired or replayed  */\n\
    \          AUTH_TOOWEAK      = 5   /* rejected for security reasons */\n     \
    \  };\n       /*\n        * The  RPC  message:\n        * All messages start with\
    \ a transaction identifier, xid,\n        * followed by a two-armed discriminated\
    \ union.  The union's\n        * discriminant is a msg_type which switches to\
    \ one of the two\n        * types of the message.  The xid of a REPLY message\
    \ always\n        * matches that of the initiating CALL message.  NB: The xid\n\
    \        * field is only used for clients  matching reply messages with\n    \
    \    * call messages or for servers detecting retransmissions; the\n        *\
    \ service side cannot treat this id as any type of sequence\n        * number.\n\
    \        */\n       struct rpc_msg {\n          unsigned int xid;\n          union\
    \ switch (msg_type mtype) {\n          case CALL:\n             call_body cbody;\n\
    \          case REPLY:\n             reply_body rbody;\n          } body;\n  \
    \     };\n       /*\n        * Body of an RPC request call:\n        * In version\
    \ 2 of the RPC protocol specification, rpcvers must\n        * be equal to 2.\
    \  The fields prog, vers, and proc specify the\n        * remote program, its\
    \ version number, and the procedure within\n        * the remote program to be\
    \ called.  After these fields are two\n        * authentication parameters: cred\
    \ (authentication credentials)\n        * and verf (authentication verifier).\
    \  The two authentication\n        * parameters are followed by the parameters\
    \ to the remote\n        * procedure, which are specified by the specific program\n\
    \        * protocol.\n        */\n       struct call_body {\n          unsigned\
    \ int rpcvers;          /* must be equal to two (2) */\n          unsigned int\
    \ prog;\n          unsigned int vers;\n          unsigned int proc;\n        \
    \  opaque_auth cred;\n          opaque_auth verf;\n          /* procedure specific\
    \ parameters start here */\n       };\n       /*\n        * Body of a reply to\
    \ an RPC request:\n        * The call message was either accepted or rejected.\n\
    \        */\n       union reply_body switch (reply_stat stat) {\n       case MSG_ACCEPTED:\n\
    \          accepted_reply areply;\n       case MSG_DENIED:\n          rejected_reply\
    \ rreply;\n       } reply;\n       /*\n        * Reply to an RPC request that\
    \ was accepted by the server:\n        * there could be an error even though the\
    \ request was accepted.\n        * The first field is an authentication verifier\
    \ that the server\n        * generates in order to validate itself to the caller.\
    \  It is\n        * followed by a union whose discriminant is an enum\n      \
    \  * accept_stat.  The SUCCESS arm of the union is protocol\n        * specific.\
    \  The PROG_UNAVAIL, PROC_UNAVAIL, and GARBAGE_ARGS\n        * arms of the union\
    \ are void.  The PROG_MISMATCH arm specifies\n        * the lowest and highest\
    \ version numbers of the remote program\n        * supported by the server.\n\
    \        */\n       struct accepted_reply {\n          opaque_auth verf;\n   \
    \       union switch (accept_stat stat) {\n          case SUCCESS:\n         \
    \    opaque results[0];\n             /*\n              * procedure-specific results\
    \ start here\n              */\n           case PROG_MISMATCH:\n             \
    \ struct {\n                 unsigned int low;\n                 unsigned int\
    \ high;\n              } mismatch_info;\n           default:\n              /*\n\
    \               * Void.  Cases include PROG_UNAVAIL, PROC_UNAVAIL,\n         \
    \      * and GARBAGE_ARGS.\n               */\n              void;\n         \
    \  } reply_data;\n       };\n       /*\n        * Reply to an RPC request that\
    \ was rejected by the server:\n        * The request can be rejected for two reasons:\
    \  either the\n        * server is not running a compatible version of the RPC\n\
    \        * protocol (RPC_MISMATCH), or the server refuses to\n        * authenticate\
    \ the caller (AUTH_ERROR).  In case of an RPC\n        * version mismatch, the\
    \ server returns the lowest and highest\n        * supported RPC version numbers.\
    \  In case of refused\n        * authentication, failure status is returned.\n\
    \        */\n       union rejected_reply switch (reject_stat stat) {\n       case\
    \ RPC_MISMATCH:\n          struct {\n             unsigned int low;\n        \
    \     unsigned int high;\n          } mismatch_info;\n       case AUTH_ERROR:\n\
    \          auth_stat stat;\n       };\n"
- title: 9. AUTHENTICATION PROTOCOLS
  contents:
  - "9. AUTHENTICATION PROTOCOLS\n   As previously stated, authentication parameters\
    \ are opaque, but\n   open-ended to the rest of the RPC protocol.  This section\
    \ defines\n   some \"flavors\" of authentication implemented at (and supported\
    \ by)\n   Sun.  Other sites are free to invent new authentication types, with\n\
    \   the same rules of flavor number assignment as there is for program\n   number\
    \ assignment.\n"
- title: 9.1 Null Authentication
  contents:
  - "9.1 Null Authentication\n   Often calls must be made where the caller does not\
    \ know who he is or\n   the server does not care who the caller is.  In this case,\
    \ the flavor\n   value (the discriminant of the opaque_auth's union) of the RPC\n\
    \   message's credentials, verifier, and response verifier is\n   \"AUTH_NULL\"\
    .  The bytes of the opaque_auth's body are undefined.  It\n   is recommended that\
    \ the opaque length be zero.\n"
- title: 9.2 UNIX Authentication
  contents:
  - "9.2 UNIX Authentication\n   The caller of a remote procedure may wish to identify\
    \ himself as he\n   is identified on a UNIX(tm) system.  The value of the credential's\n\
    \   discriminant of an RPC call message is \"AUTH_UNIX\".  The bytes of the\n\
    \   credential's opaque body encode the the following structure:\n         struct\
    \ auth_unix {\n            unsigned int stamp;\n            string machinename<255>;\n\
    \            unsigned int uid;\n            unsigned int gid;\n            unsigned\
    \ int gids<10>;\n         };\n   The \"stamp\" is an arbitrary ID which the caller\
    \ machine may generate.\n   The \"machinename\" is the name of the caller's machine\
    \ (like\n   \"krypton\").  The \"uid\" is the caller's effective user ID.  The\
    \ \"gid\"\n   is the caller's effective group ID.  The \"gids\" is a counted array\
    \ of\n   groups which contain the caller as a member.  The verifier\n   accompanying\
    \ the credentials should be of \"AUTH_NULL\" (defined\n   above).\n   The value\
    \ of the discriminant of the response verifier received in\n   the reply message\
    \ from the server may be \"AUTH_NULL\" or \"AUTH_SHORT\".\n   In the case of \"\
    AUTH_SHORT\", the bytes of the response verifier's\n   string encode an opaque\
    \ structure.  This new opaque structure may now\n   be passed to the server instead\
    \ of the original \"AUTH_UNIX\" flavor\n   credentials.  The server keeps a cache\
    \ which maps shorthand opaque\n   structures (passed back by way of an \"AUTH_SHORT\"\
    \ style response\n   verifier) to the original credentials of the caller.  The\
    \ caller can\n   save network bandwidth and server cpu cycles by using the new\n\
    \   credentials.\n   The server may flush the shorthand opaque structure at any\
    \ time.  If\n   this happens, the remote procedure call message will be rejected\
    \ due\n   to an authentication error.  The reason for the failure will be\n  \
    \ \"AUTH_REJECTEDCRED\".  At this point, the caller may wish to try the\n   original\
    \ \"AUTH_UNIX\" style of credentials.\n"
- title: 9.3 DES Authentication
  contents:
  - "9.3 DES Authentication\n   UNIX authentication suffers from two major problems:\n\
    \         (1) The naming is too UNIX oriented.\n         (2) There is no verifier,\
    \ so credentials can easily be faked.\n   DES authentication attempts to fix these\
    \ two problems.\n"
- title: 9.3.1 Naming
  contents:
  - "9.3.1 Naming\n   The first problem is handled by addressing the caller by a simple\n\
    \   string of characters instead of by an operating system specific\n   integer.\
    \  This string of characters is known as the \"netname\" or\n   network name of\
    \ the caller.  The server is not allowed to interpret\n   the contents of the\
    \ caller's name in any other way except to identify\n   the caller.  Thus, netnames\
    \ should be unique for every caller in the\n   Internet.\n   It is up to each\
    \ operating system's implementation of DES\n   authentication to generate netnames\
    \ for its users that insure this\n   uniqueness when they call upon remote servers.\
    \  Operating systems\n   already know how to distinguish users local to their\
    \ systems.  It is\n   usually a simple matter to extend this mechanism to the\
    \ network.  For\n   example, a UNIX user at Sun with a user ID of 515 might be\
    \ assigned\n   the following netname: \"unix.515@sun.com\".  This netname contains\n\
    \   three items that serve to insure it is unique.  Going backwards,\n   there\
    \ is only one naming domain called \"sun.com\" in the Internet.\n   Within this\
    \ domain, there is only one UNIX user with user ID 515.\n   However, there may\
    \ be another user on another operating system, for\n   example VMS, within the\
    \ same naming domain that, by coincidence,\n   happens to have the same user ID.\
    \  To insure that these two users can\n   be distinguished, we add the operating\
    \ system name.  So, one user is\n   \"unix.515@sun.com\" and the other is \"vms.515@sun.com\"\
    .\n   The first field is actually a naming method rather than an operating\n \
    \  system name.  It just happens that today, there is almost a one-to-\n   one\
    \ correspondence between naming methods and operating systems.  If\n   the world\
    \ could agree on a naming standard, the first field could be\n   the name of that\
    \ standard, instead of an operating system name.\n"
- title: 9.3.2 DES Authentication Verifiers
  contents:
  - "9.3.2 DES Authentication Verifiers\n   Unlike UNIX authentication, DES authentication\
    \ does have a verifier\n   so the server can validate the client's credential\
    \ (and vice-versa).\n   The contents of this verifier is primarily an encrypted\
    \ timestamp.\n   The server can decrypt this timestamp, and if it is close to\
    \ what the\n   real time is, then the client must have encrypted it correctly.\
    \  The\n   only way the client could encrypt it correctly is to know the\n   \"\
    conversation key\" of the RPC session.  And, if the client knows the\n   conversation\
    \ key, then it must be the real client.\n   The conversation key is a DES [5]\
    \ key which the client generates and\n   notifies the server of in its first RPC\
    \ call.  The conversation key\n   is encrypted using a public key scheme in this\
    \ first transaction.\n   The particular public key scheme used in DES authentication\
    \ is\n   Diffie-Hellman [3], with 128-bit keys.  The details of this\n   encryption\
    \ method are described later.\n   The client and the server need the same notion\
    \ of the current time in\n   order for all of this to work.  If network time synchronization\n\
    \   cannot be guaranteed, then client can synchronize with the server\n   before\
    \ beginning the conversation, perhaps by consulting the Internet\n   Time Server\
    \ (TIME [4]).\n   The way a server determines if a client timestamp is valid is\n\
    \   somewhat complicated.  For any other transaction but the first, the\n   server\
    \ just checks for two things:\n         (1) the timestamp is greater than the\
    \ one previously seen from\n             the same client.\n         (2) the timestamp\
    \ has not expired.\n   A timestamp is expired if the server's time is later than\
    \ the sum of\n   the client's timestamp, plus what is known as the client's \"\
    window\".\n   The \"window\" is a number the client passes (encrypted) to the\
    \ server\n   in its first transaction.  You can think of it as a lifetime for\
    \ the\n   credential.\n   This explains everything but the first transaction.\
    \  In the first\n   transaction, the server checks only that the timestamp has\
    \ not\n   expired.  If this was all that was done though, then it would be\n \
    \  quite easy for the client to send random data in place of the\n   timestamp\
    \ with a fairly good chance of succeeding.  As an added\n   check, the client\
    \ sends an encrypted item in the first transaction\n   known as the \"window verifier\"\
    \ which must be equal to the window\n   minus 1, or the server will reject the\
    \ credential.\n   The client too, must check the verifier returned from the server\
    \ to\n   be sure it is legitimate.  The server sends back to the client the\n\
    \   encrypted timestamp it received from the client, minus one second.\n   If\
    \ the client gets anything different than this, it will reject it.\n"
- title: 9.3.3 Nicknames and Clock Synchronization
  contents:
  - "9.3.3 Nicknames and Clock Synchronization\n   After the first transaction, the\
    \ server's DES authentication\n   subsystem returns in its verifier to the client\
    \ an integer \"nickname\"\n   which the client may use in its further transactions\
    \ instead of\n   passing its netname, encrypted DES key, and window every time.\
    \ The\n   nickname is most likely an index into a table on the server which\n\
    \   stores for each client its netname, decrypted DES key, and window.\n   Though\
    \ they originally were synchronized, the client's and server's\n   clocks can\
    \ get out of sync again.  When this happens, the client RPC\n   subsystem most\
    \ likely will get back \"RPC_AUTHERROR\" at which point it\n   should resynchronize.\n\
    \   A client may still get the \"RPC_AUTHERROR\" error even though it is\n   synchronized\
    \ with the server.  The reason is that the server's\n   nickname table is a limited\
    \ size, and it may flush entries whenever\n   it wants.  A client should resend\
    \ its original credential in this\n   case and the server will give it a new nickname.\
    \  If a server\n   crashes, the entire nickname table gets flushed, and all clients\
    \ will\n   have to resend their original credentials.\n"
- title: 9.3.4 DES Authentication Protocol Specification (in XDR language)
  contents:
  - "9.3.4 DES Authentication Protocol Specification (in XDR language)\n    /*\n \
    \    * There are two kinds of credentials: one in which the client uses\n    \
    \ * its full network name, and one in which it uses its \"nickname\"\n     * (just\
    \ an unsigned integer) given to it by the server.  The\n     * client must use\
    \ its fullname in its first transaction with the\n     * server, in which the\
    \ server will return to the client its\n     * nickname.  The client may use its\
    \ nickname in all further\n     * transactions with the server.  There is no requirement\
    \ to use the\n     * nickname, but it is wise to use it for performance reasons.\n\
    \     */\n    enum authdes_namekind {\n       ADN_FULLNAME = 0,\n       ADN_NICKNAME\
    \ = 1\n    };\n    /*\n     * A 64-bit block of encrypted DES data\n     */\n\
    \    typedef opaque des_block[8];\n    /*\n     * Maximum length of a network\
    \ user's name\n     */\n    const MAXNETNAMELEN = 255;\n    /*\n     * A fullname\
    \ contains the network name of the client, an encrypted\n     * conversation key,\
    \ and the window.  The window is actually a\n     * lifetime for the credential.\
    \  If the time indicated in the\n     * verifier timestamp plus the window has\
    \ past, then the server\n     * should expire the request and not grant it.  To\
    \ insure that\n     * requests are not replayed, the server should insist that\n\
    \     * timestamps are greater than the previous one seen, unless it is\n    \
    \ * the  first transaction.  In the first transaction, the server\n     * checks\
    \ instead that the window verifier is one less than the\n     * window.\n    \
    \ */\n    struct authdes_fullname {\n       string name<MAXNETNAMELEN>;  /* name\
    \ of client                */\n       des_block key;               /* PK encrypted\
    \ conversation key */\n       unsigned int window;         /* encrypted window\
    \              */\n    };\n    /*\n     * A credential is either a fullname or\
    \ a nickname\n     */\n    union authdes_cred switch (authdes_namekind adc_namekind)\
    \ {\n    case ADN_FULLNAME:\n       authdes_fullname adc_fullname;\n    case ADN_NICKNAME:\n\
    \       unsigned int adc_nickname;\n    };\n    /*\n     * A timestamp encodes\
    \ the time since midnight, January 1, 1970.\n     */\n    struct timestamp {\n\
    \         unsigned int seconds;    /* seconds          */\n         unsigned int\
    \ useconds;   /* and microseconds */\n    };\n    /*\n     * Verifier: client\
    \ variety\n     * The window verifier is only used in the first transaction. \
    \ In\n     * conjunction with a fullname credential, these items are packed\n\
    \     * into the following structure before being encrypted:\n     *\n     * struct\
    \ {\n     *     adv_timestamp;        -- one DES block\n     *     adc_fullname.window;\
    \  -- one half DES block\n     *     adv_winverf;          -- one half DES block\n\
    \     * }\n     * This structure is encrypted using CBC mode encryption with an\n\
    \     * input vector of zero.  All other encryptions of timestamps use\n     *\
    \ ECB mode encryption.\n     */\n    struct authdes_verf_clnt {\n       timestamp\
    \ adv_timestamp;    /* encrypted timestamp       */\n       unsigned int adv_winverf;\
    \   /* encrypted window verifier */\n    };\n    /*\n     * Verifier: server variety\n\
    \     * The server returns (encrypted) the same timestamp the client\n     * gave\
    \ it minus one second.  It also tells the client its nickname\n     * to be used\
    \ in future transactions (unencrypted).\n     */\n    struct authdes_verf_svr\
    \ {\n       timestamp adv_timeverf;     /* encrypted verifier      */\n      \
    \ unsigned int adv_nickname;  /* new nickname for client */\n    };\n"
- title: 9.3.5 Diffie-Hellman Encryption
  contents:
  - "9.3.5 Diffie-Hellman Encryption\n   In this scheme, there are two constants \"\
    PROOT\" and \"MODULUS\".  The\n   particular values Sun has chosen for these for\
    \ the DES authentication\n   protocol are:\n        const PROOT = 2;\n       \
    \ const MODULUS = \"b520985fb31fcaf75036701e37d8b857\"; /* in hex */\n   The way\
    \ this scheme works is best explained by an example.  Suppose\n   there are two\
    \ people \"A\" and \"B\" who want to send encrypted messages\n   to each other.\
    \  So, A and B both generate \"secret\" keys at random\n   which they do not reveal\
    \ to anyone.  Let these keys be represented as\n   SK(A) and SK(B).  They also\
    \ publish in a public directory their\n   \"public\" keys.  These keys are computed\
    \ as follows:\n            PK(A) = ( PROOT ** SK(A) ) mod MODULUS\n          \
    \  PK(B) = ( PROOT ** SK(B) ) mod MODULUS\n   The \"**\" notation is used here\
    \ to represent exponentiation.  Now,\n   both A and B can arrive at the \"common\"\
    \ key between them, represented\n   here as CK(A, B), without revealing their\
    \ secret keys.\n         A computes:\n            CK(A, B) = ( PK(B) ** SK(A))\
    \ mod MODULUS\n         while B computes:\n            CK(A, B) = ( PK(A) ** SK(B))\
    \ mod MODULUS\n         These two can be shown to be equivalent:\n           \
    \ (PK(B) ** SK(A)) mod MODULUS = (PK(A) ** SK(B)) mod MODULUS\n         We drop\
    \ the \"mod MODULUS\" parts and assume modulo arithmetic to\n         simplify\
    \ things:\n            PK(B) ** SK(A) = PK(A) ** SK(B)\n         Then, replace\
    \ PK(B) by what B computed earlier and likewise for\n         PK(A).\n       \
    \     ((PROOT ** SK(B)) ** SK(A) = (PROOT ** SK(A)) ** SK(B)\n         which leads\
    \ to:\n            PROOT ** (SK(A) * SK(B)) = PROOT ** (SK(A) * SK(B))\n   This\
    \ common key CK(A, B) is not used to encrypt the timestamps used\n   in the protocol.\
    \  Rather, it is used only to encrypt a conversation\n   key which is then used\
    \ to encrypt the timestamps.  The reason for\n   doing this is to use the common\
    \ key as little as possible, for fear\n   that it could be broken.  Breaking the\
    \ conversation key is a far less\n   serious offense, since conversations are\
    \ relatively short-lived.\n   The conversation key is encrypted using 56-bit DES\
    \ keys, yet the\n   common key is 128 bits.  To reduce the number of bits, 56\
    \ bits are\n   selected from the common key as follows.  The middle-most 8-bytes\
    \ are\n   selected from the common key, and then parity is added to the lower\n\
    \   order bit of each byte, producing a 56-bit key with 8 bits of parity.\n"
- title: 10. RECORD MARKING STANDARD
  contents:
  - "10. RECORD MARKING STANDARD\n   When RPC messages are passed on top of a byte\
    \ stream protocol (like\n   TCP/IP), it is necessary, or at least desirable, to\
    \ delimit one\n   message from another in order to detect and possibly recover\
    \ from\n   user protocol errors.  This is called record marking (RM).  Sun uses\n\
    \   this RM/TCP/IP transport for passing RPC messages on TCP streams.\n   One\
    \ RPC message fits into one RM record.\n   A record is composed of one or more\
    \ record fragments.  A record\n   fragment is a four-byte header followed by 0\
    \ to (2**31)-1 bytes of\n   fragment data.  The bytes encode an unsigned binary\
    \ number; as with\n   XDR integers, the byte order is from highest to lowest.\
    \  The number\n   encodes two values -- a boolean which indicates whether the\
    \ fragment\n   is the last fragment of the record (bit value 1 implies the fragment\n\
    \   is the last fragment) and a 31-bit unsigned binary value which is the\n  \
    \ length in bytes of the fragment's data.  The boolean value is the\n   highest-order\
    \ bit of the header; the length is the 31 low-order bits.\n   (Note that this\
    \ record specification is NOT in XDR standard form!)\n"
- title: 11. THE RPC LANGUAGE
  contents:
  - "11. THE RPC LANGUAGE\n   Just as there was a need to describe the XDR data-types\
    \ in a formal\n   language, there is also need to describe the procedures that\
    \ operate\n   on these XDR data-types in a formal language as well.  We use the\
    \ RPC\n   Language for this purpose.  It is an extension to the XDR language.\n\
    \   The following example is used to describe the essence of the\n   language.\n"
- title: 11.1 An Example Service Described in the RPC Language
  contents:
  - "11.1 An Example Service Described in the RPC Language\n   Here is an example\
    \ of the specification of a simple ping program:\n         /*\n          * Simple\
    \ ping program\n          */\n         program PING_PROG {\n            /*\n \
    \            * Latest and greatest version\n             */\n            version\
    \ PING_VERS_PINGBACK {\n               void\n               PINGPROC_NULL(void)\
    \ = 0;\n               /*\n                * Ping the caller, return the round-trip\
    \ time\n                * (in microseconds).  Returns -1 if the operation\n  \
    \              * timed out.\n                */\n               int\n        \
    \       PINGPROC_PINGBACK(void) = 1;\n            } = 2;\n            /*\n   \
    \          * Original version\n             */\n            version PING_VERS_ORIG\
    \ {\n               void\n               PINGPROC_NULL(void) = 0;\n          \
    \  } = 1;\n         } = 1;\n         const PING_VERS = 2;      /* latest version\
    \ */\n   The first version described is PING_VERS_PINGBACK with two\n   procedures,\
    \ PINGPROC_NULL and PINGPROC_PINGBACK.  PINGPROC_NULL takes\n   no arguments and\
    \ returns no results, but it is useful for computing\n   round-trip times from\
    \ the client to the server and back again.  By\n   convention, procedure 0 of\
    \ any RPC protocol should have the same\n   semantics, and never require any kind\
    \ of authentication.  The second\n   procedure is used for the client to have\
    \ the server do a reverse ping\n   operation back to the client, and it returns\
    \ the amount of time (in\n   microseconds) that the operation used.  The next\
    \ version,\n   PING_VERS_ORIG, is the original version of the protocol and it\
    \ does\n   not contain PINGPROC_PINGBACK procedure.  It is useful for\n   compatibility\
    \ with old client programs, and as this program matures\n   it may be dropped\
    \ from the protocol entirely.\n"
- title: 11.1 The RPC Language Specification
  contents:
  - "11.1 The RPC Language Specification\n   The RPC language is identical to the\
    \ XDR language, except for the\n   added definition of a \"program-def\" described\
    \ below.\n      program-def:\n         \"program\" identifier \"{\"\n        \
    \     version-def\n             version-def *\n         \"}\" \"=\" constant \"\
    ;\"\n      version-def:\n         \"version\" identifier \"{\"\n             procedure-def\n\
    \             procedure-def *\n         \"}\" \"=\" constant \";\"\n      procedure-def:\n\
    \         type-specifier identifier \"(\" type-specifier \")\"\n         \"=\"\
    \ constant \";\"\n"
- title: 11.2 Syntax Notes
  contents:
  - "11.2 Syntax Notes\n   (1) The following keywords are added and cannot be used\
    \ as\n       identifiers:  \"program\" and \"version\";\n   (2) A version name\
    \ cannot occur more than once within the scope\n       of a program definition.\
    \  Nor can a version number occur more\n       than once within the scope of a\
    \ program definition.\n   (3) A procedure name cannot occur more than once within\
    \ the scope\n       of a version definition.  Nor can a procedure number occur\n\
    \       more than once within the scope of version definition.\n   (4) Program\
    \ identifiers are in the same name space as constant\n       and type identifiers.\n\
    \   (5) Only unsigned constants can be assigned to programs, versions,\n     \
    \  and procedures.\n"
- title: 'APPENDIX A: PORT MAPPER PROGRAM PROTOCOL'
  contents:
  - "APPENDIX A: PORT MAPPER PROGRAM PROTOCOL\n   The port mapper program maps RPC\
    \ program and version numbers to\n   transport-specific port numbers.  This program\
    \ makes dynamic binding\n   of remote programs possible.\n   This is desirable\
    \ because the range of reserved port numbers is very\n   small, and the number\
    \ of potential remote programs is very large.  By\n   running only the port mapper\
    \ on a reserved port, the port numbers of\n   other remote programs can be ascertained\
    \ by querying the port mapper.\n   The port mapper also aids in broadcast RPC.\
    \  A given RPC program will\n   usually have different port number bindings on\
    \ different machines, so\n   there is no way to directly broadcast to all of these\
    \ programs.  The\n   port mapper, however, does have a fixed port number.  So,\
    \ to\n   broadcast to a given program, the client actually sends its message\n\
    \   to the port mapper located at the broadcast address.  Each port\n   mapper\
    \ that picks up the broadcast then calls the local service\n   specified by the\
    \ client.  When the port mapper gets the reply from\n   the local service, it\
    \ sends the reply on back to the client.\n"
- title: A.1 Port Mapper Protocol Specification (in RPC Language)
  contents:
  - "A.1 Port Mapper Protocol Specification (in RPC Language)\n      const PMAP_PORT\
    \ = 111;      /* portmapper port number */\n      /*\n       * A mapping of (program,\
    \ version, protocol) to port number\n       */\n      struct mapping {\n     \
    \    unsigned int prog;\n         unsigned int vers;\n         unsigned int prot;\n\
    \         unsigned int port;\n      };\n      /*\n       * Supported values for\
    \ the \"prot\" field\n       */\n      const IPPROTO_TCP = 6;      /* protocol\
    \ number for TCP/IP */\n      const IPPROTO_UDP = 17;     /* protocol number for\
    \ UDP/IP */\n      /*\n       * A list of mappings\n       */\n      struct *pmaplist\
    \ {\n         mapping map;\n         pmaplist next;\n      };\n      /*\n    \
    \   * Arguments to callit\n       */\n      struct call_args {\n         unsigned\
    \ int prog;\n         unsigned int vers;\n         unsigned int proc;\n      \
    \   opaque args<>;\n      };\n      /*\n       * Results of callit\n       */\n\
    \      struct call_result {\n         unsigned int port;\n         opaque res<>;\n\
    \      };\n     /*\n      * Port mapper procedures\n      */\n      program PMAP_PROG\
    \ {\n         version PMAP_VERS {\n            void\n            PMAPPROC_NULL(void)\
    \         = 0;\n            bool\n            PMAPPROC_SET(mapping)       = 1;\n\
    \            bool\n            PMAPPROC_UNSET(mapping)     = 2;\n            unsigned\
    \ int\n            PMAPPROC_GETPORT(mapping)   = 3;\n            pmaplist\n  \
    \          PMAPPROC_DUMP(void)         = 4;\n            call_result\n       \
    \     PMAPPROC_CALLIT(call_args)  = 5;\n         } = 2;\n      } = 100000;\n"
- title: A.2 Port Mapper Operation
  contents:
  - "A.2 Port Mapper Operation\n   The portmapper program currently supports two protocols\
    \ (UDP/IP and\n   TCP/IP).  The portmapper is contacted by talking to it on assigned\n\
    \   port number 111 (SUNRPC [8]) on either of these protocols.  The\n   following\
    \ is a description of each of the portmapper procedures:\n      PMAPPROC_NULL:\n\
    \         This procedure does no work.  By convention, procedure zero of\n   \
    \      any protocol takes no parameters and returns no results.\n      PMAPPROC_SET:\n\
    \         When a program first becomes available on a machine, it\n         registers\
    \ itself with the port mapper program on the same\n         machine.  The program\
    \ passes its program number \"prog\", version\n         number \"vers\", transport\
    \ protocol number \"prot\", and the port\n         \"port\" on which it awaits\
    \ service request.  The procedure\n         returns a boolean response whose value\
    \ is \"TRUE\" if the\n         procedure successfully established the mapping\
    \ and \"FALSE\"\n         otherwise.  The procedure refuses to establish a mapping\
    \ if one\n         already exists for the tuple \"(prog, vers, prot)\".\n    \
    \  PMAPPROC_UNSET:\n         When a program becomes unavailable, it should unregister\
    \ itself\n         with the port mapper program on the same machine.  The\n  \
    \       parameters and results have meanings identical to those of\n         \"\
    PMAPPROC_SET\".  The protocol and port number fields of the\n         argument\
    \ are ignored.\n      PMAPPROC_GETPORT:\n         Given a program number \"prog\"\
    , version number \"vers\", and\n         transport protocol number \"prot\", this\
    \ procedure returns the\n         port number on which the program is awaiting\
    \ call requests.  A\n         port value of zeros means the program has not been\
    \ registered.\n         The \"port\" field of the argument is ignored.\n     \
    \ PMAPPROC_DUMP:\n         This procedure enumerates all entries in the port mapper's\n\
    \         database.  The procedure takes no parameters and returns a list\n  \
    \       of program, version, protocol, and port values.\n      PMAPPROC_CALLIT:\n\
    \         This procedure allows a caller to call another remote procedure\n  \
    \       on the same machine without knowing the remote procedure's port\n    \
    \     number.  It is intended for supporting broadcasts to arbitrary\n       \
    \  remote programs via the well-known port mapper's port.  The\n         parameters\
    \ \"prog\", \"vers\", \"proc\", and the bytes of \"args\" are\n         the program\
    \ number, version number, procedure number, and\n         parameters of the remote\
    \ procedure.  Note:\n            (1) This procedure only sends a response if the\
    \ procedure\n                 was successfully executed and is silent (no response)\n\
    \                 otherwise.\n            (2) The port mapper communicates with\
    \ the remote program\n                using UDP/IP only.\n         The procedure\
    \ returns the remote program's port number, and the\n         bytes of results\
    \ are the results of the remote procedure.\n"
- title: REFERENCES
  contents:
  - "REFERENCES\n   [1]  Birrel, A. D., and Nelson, B. J., \"Implementing Remote\n\
    \        Procedure Calls\", XEROX CSL-83-7, October 1983.\n   [2]  Cheriton, D.,\
    \ \"VMTP: Versatile Message Transaction Protocol\",\n        Version 0.7, RFC-1045,\
    \ Stanford University, February 1988.\n   [3]  Diffie & Hellman, \"Net Directions\
    \ in Cryptography\", IEEE\n        Transactions on Information Theory IT-22, November\
    \ 1976.\n   [4]  Postel, J., and Harrenstien, K., \"Time Protocol\", RFC-868,\n\
    \        Network Information Center, SRI, May 1983.\n   [5]  National Bureau of\
    \ Standards, \"Data Encryption Standard\",\n        Federal Information Processing\
    \ Standards Publication 46,\n        January 1977.\n   [6]  Postel, J., \"Transmission\
    \ Control Protocol - DARPA Internet\n        Program Protocol Specification\"\
    , RFC-793; Network Information\n        Center, SRI, September 1981.\n   [7] \
    \ Postel, J., \"User Datagram Protocol\", RFC-768, Network\n        Information\
    \ Center, SRI, August 1980.\n   [8]  Reynolds, J. and Postel, J.; \"Assigned Numbers\"\
    , RFC-1010,\n        Network Information Center, SRI, May 1987.\n   [9]  Sun Microsystems;\
    \ \"XDR:  External Data Representation\n        Standard\", RFC-1014; Sun Microsystems,\
    \ June 1987.\n"
