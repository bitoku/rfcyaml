- title: __initial_text__
  contents:
  - '   Privacy Extensions for Stateless Address Autoconfiguration in IPv6

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Nodes use IPv6 stateless address autoconfiguration to generate\n\
    \   addresses without the necessity of a Dynamic Host Configuration\n   Protocol\
    \ (DHCP) server.  Addresses are formed by combining network\n   prefixes with\
    \ an interface identifier.  On interfaces that contain\n   embedded IEEE Identifiers,\
    \ the interface identifier is typically\n   derived from it.  On other interface\
    \ types, the interface identifier\n   is generated through other means, for example,\
    \ via random number\n   generation.  This document describes an extension to IPv6\
    \ stateless\n   address autoconfiguration for interfaces whose interface identifier\n\
    \   is derived from an IEEE identifier.  Use of the extension causes\n   nodes\
    \ to generate global-scope addresses from interface identifiers\n   that change\
    \ over time, even in cases where the interface contains an\n   embedded IEEE identifier.\
    \  Changing the interface identifier (and the\n   global-scope addresses generated\
    \ from it) over time makes it more\n   difficult for eavesdroppers and other information\
    \ collectors to\n   identify when different addresses used in different transactions\n\
    \   actually correspond to the same node.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction.............................................\
    \    2\n   2.  Background...............................................    3\n\
    \      2.1.  Extended Use of the Same Identifier.................    3\n     \
    \ 2.2.  Address Usage in IPv4 Today.........................    4\n      2.3.\
    \  The Concern With IPv6 Addresses.....................    5\n      2.4.  Possible\
    \ Approaches.................................    6\n   3.  Protocol Description.....................................\
    \    7\n      3.1.  Assumptions.........................................    8\n\
    \      3.2.  Generation Of Randomized Interface Identifiers......    9\n     \
    \ 3.3.  Generating Temporary Addresses......................   10\n      3.4.\
    \  Expiration of Temporary Addresses...................   11\n      3.5.  Regeneration\
    \ of Randomized Interface Identifiers....   12\n   4.  Implications of Changing\
    \ Interface Identifiers...........   13\n   5.  Defined Constants........................................\
    \   14\n   6.  Future Work..............................................   14\n\
    \   7.  Security Considerations..................................   15\n   8.\
    \  Acknowledgments..........................................   15\n   9.  References...............................................\
    \   15\n   10. Authors' Addresses.......................................   16\n\
    \   11. Full Copyright Statement.................................   17\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Stateless address autoconfiguration [ADDRCONF] defines how\
    \ an IPv6\n   node generates addresses without the need for a DHCP server.  Some\n\
    \   types of network interfaces come with an embedded IEEE Identifier\n   (i.e.,\
    \ a link-layer MAC address), and in those cases stateless\n   address autoconfiguration\
    \ uses the IEEE identifier to generate a 64-\n   bit interface identifier [ADDRARCH].\
    \  By design, the interface\n   identifier is likely to be globally unique when\
    \ generated in this\n   fashion.  The interface identifier is in turn appended\
    \ to a prefix to\n   form a 128-bit IPv6 address.\n   All nodes combine interface\
    \ identifiers (whether derived from an IEEE\n   identifier or generated through\
    \ some other technique) with the\n   reserved link-local prefix to generate link-local\
    \ addresses for their\n   attached interfaces.  Additional addresses, including\
    \ site-local and\n   global-scope addresses, are then created by combining prefixes\n\
    \   advertised in Router Advertisements via Neighbor Discovery\n   [DISCOVERY]\
    \ with the interface identifier.\n   Not all nodes and interfaces contain IEEE\
    \ identifiers.  In such\n   cases, an interface identifier is generated through\
    \ some other means\n   (e.g., at random), and the resultant interface identifier\
    \ is not\n   globally unique and may also change over time.  The focus of this\n\
    \   document is on addresses derived from IEEE identifiers, as the\n   concern\
    \ being addressed exists only in those cases where the\n   interface identifier\
    \ is globally unique and non-changing.  The rest\n   of this document assumes\
    \ that IEEE identifiers are being used, but\n   the techniques described may also\
    \ apply to interfaces with other\n   types of globally unique and/or persistent\
    \ identifiers.\n   This document discusses concerns associated with the embedding\
    \ of\n   non-changing interface identifiers within IPv6 addresses and\n   describes\
    \ extensions to stateless address autoconfiguration that can\n   help mitigate\
    \ those concerns for individual users and in environments\n   where such concerns\
    \ are significant.  Section 2 provides background\n   information on the issue.\
    \  Section 3 describes a procedure for\n   generating alternate interface identifiers\
    \ and global-scope\n   addresses.  Section 4 discusses implications of changing\
    \ interface\n   identifiers.\n"
- title: 2.  Background
  contents:
  - "2.  Background\n   This section discusses the problem in more detail, provides\
    \ context\n   for evaluating the significance of the concerns in specific\n  \
    \ environments and makes comparisons with existing practices.\n"
- title: 2.1.  Extended Use of the Same Identifier
  contents:
  - "2.1.  Extended Use of the Same Identifier\n   The use of a non-changing interface\
    \ identifier to form addresses is a\n   specific instance of the more general\
    \ case where a constant\n   identifier is reused over an extended period of time\
    \ and in multiple\n   independent activities.  Anytime the same identifier is\
    \ used in\n   multiple contexts, it becomes possible for that identifier to be\
    \ used\n   to correlate seemingly unrelated activity.  For example, a network\n\
    \   sniffer placed strategically on a link across which all traffic\n   to/from\
    \ a particular host crosses could keep track of which\n   destinations a node\
    \ communicated with and at what times.  Such\n   information can in some cases\
    \ be used to infer things, such as what\n   hours an employee was active, when\
    \ someone is at home, etc.\n   One of the requirements for correlating seemingly\
    \ unrelated\n   activities is the use (and reuse) of an identifier that is\n \
    \  recognizable over time within different contexts.  IP addresses\n   provide\
    \ one obvious example, but there are more.  Many nodes also\n   have DNS names\
    \ associated with their addresses, in which case the DNS\n   name serves as a\
    \ similar identifier.  Although the DNS name\n   associated with an address is\
    \ more work to obtain (it may require a\n   DNS query) the information is often\
    \ readily available.  In such\n   cases, changing the address on a machine over\
    \ time would do little to\n   address the concerns raised in this document, unless\
    \ the DNS name is\n   changed as well (see Section 4).\n   Web browsers and servers\
    \ typically exchange \"cookies\" with each other\n   [COOKIES].  Cookies allow\
    \ web servers to correlate a current activity\n   with a previous activity.  One\
    \ common usage is to send back targeted\n   advertising to a user by using the\
    \ cookie supplied by the browser to\n   identify what earlier queries had been\
    \ made (e.g., for what type of\n   information).  Based on the earlier queries,\
    \ advertisements can be\n   targeted to match the (assumed) interests of the end-user.\n\
    \   The use of a constant identifier within an address is of special\n   concern\
    \ because addresses are a fundamental requirement of\n   communication and cannot\
    \ easily be hidden from eavesdroppers and\n   other parties.  Even when higher\
    \ layers encrypt their payloads,\n   addresses in packet headers appear in the\
    \ clear.  Consequently, if a\n   mobile host (e.g., laptop) accessed the network\
    \ from several\n   different locations, an eavesdropper might be able to track\
    \ the\n   movement of that mobile host from place to place, even if the upper\n\
    \   layer payloads were encrypted [SERIALNUM].\n"
- title: 2.2.  Address Usage in IPv4 Today
  contents:
  - "2.2.  Address Usage in IPv4 Today\n   Addresses used in today's Internet are\
    \ often non-changing in practice\n   for extended periods of time, especially\
    \ in non-home environments\n   (e.g., corporations, campuses, etc.).  In such\
    \ sites, addresses are\n   assigned statically and typically change infrequently.\
    \  Over the last\n   few years, sites have begun moving away from static allocation\
    \ to\n   dynamic allocation via DHCP [DHCP].  In theory, the address a client\n\
    \   gets via DHCP can change over time, but in practice servers often\n   return\
    \ the same address to the same client (unless addresses are in\n   such short\
    \ supply that they are reused immediately by a different\n   node when they become\
    \ free).  Thus, even within sites using DHCP,\n   clients frequently end up using\
    \ the same address for weeks to months\n   at a time.\n   For home users accessing\
    \ the Internet over dialup lines, the\n   situation is generally different.  Such\
    \ users do not have permanent\n   connections and are often assigned temporary\
    \ addresses each time they\n   connect to their ISP (e.g., AOL).  Consequently,\
    \ the addresses they\n   use change frequently over time and are shared among\
    \ a number of\n   different users.  Thus, an address does not reliably identify\
    \ a\n   particular device over time spans of more than a few minutes.\n   A more\
    \ interesting case concerns always-on connections (e.g., cable\n   modems, ISDN,\
    \ DSL, etc.) that result in a home site using the same\n   address for extended\
    \ periods of time.  This is a scenario that is\n   just starting to become common\
    \ in IPv4 and promises to become more of\n   a concern as always-on internet connectivity\
    \ becomes widely\n   available.  Although it might appear that changing an address\n\
    \   regularly in such environments would be desirable to lessen privacy\n   concerns,\
    \ it should be noted that the network prefix portion of an\n   address also serves\
    \ as a constant identifier.  All nodes at (say) a\n   home, would have the same\
    \ network prefix, which identifies the\n   topological location of those nodes.\
    \  This has implications for\n   privacy, though not at the same granularity as\
    \ the concern that this\n   document addresses.  Specifically, all nodes within\
    \ a home would be\n   grouped together for the purposes of collecting information.\
    \  This\n   issue is difficult to address, because the routing prefix part of\
    \ an\n   address contains topology information and cannot contain arbitrary\n\
    \   values.\n   Finally, it should be noted that nodes that need a (non-changing)\
    \ DNS\n   name generally have static addresses assigned to them to simplify the\n\
    \   configuration of DNS servers.  Although Dynamic DNS [DDNS] can be\n   used\
    \ to update the DNS dynamically, it is not yet widely deployed.\n   In addition,\
    \ changing an address but keeping the same DNS name does\n   not really address\
    \ the underlying concern, since the DNS name becomes\n   a non-changing identifier.\
    \  Servers generally require a DNS name (so\n   clients can connect to them),\
    \ and clients often do as well (e.g.,\n   some servers refuse to speak to a client\
    \ whose address cannot be\n   mapped into a DNS name that also maps back into\
    \ the same address).\n   Section 4 describes one approach to this issue.\n"
- title: 2.3.  The Concern With IPv6 Addresses
  contents:
  - "2.3.  The Concern With IPv6 Addresses\n   The division of IPv6 addresses into\
    \ distinct topology and interface\n   identifier portions raises an issue new\
    \ to IPv6 in that a fixed\n   portion of an IPv6 address (i.e., the interface\
    \ identifier) can\n   contain an identifier that remains constant even when the\
    \ topology\n   portion of an address changes (e.g., as the result of connecting\
    \ to a\n   different part of the Internet).  In IPv4, when an address changes,\n\
    \   the entire address (including the local part of the address) usually\n   changes.\
    \  It is this new issue that this document addresses.\n   If addresses are generated\
    \ from an interface identifier, a home\n   user's address could contain an interface\
    \ identifier that remains the\n   same from one dialup session to the next, even\
    \ if the rest of the\n   address changes.  The way PPP is used today, however,\
    \ PPP servers\n   typically unilaterally inform the client what address they are\
    \ to use\n   (i.e., the client doesn't generate one on its own).  This practice,\n\
    \   if continued in IPv6, would avoid the concerns that are the focus of\n   this\
    \ document.\n   A more troubling case concerns mobile devices (e.g., laptops,\
    \ PDAs,\n   etc.) that move topologically within the Internet.  Whenever they\n\
    \   move (in the absence of technology such as mobile IP [MOBILEIP]),\n   they\
    \ form new addresses for their current topological point of\n   attachment.  This\
    \ is typified today by the \"road warrior\" who has\n   Internet connectivity\
    \ both at home and at the office.  While the\n   node's address changes as it\
    \ moves, however, the interface identifier\n   contained within the address remains\
    \ the same (when derived from an\n   IEEE Identifier).  In such cases, the interface\
    \ identifier can be\n   used to track the movement and usage of a particular machine\n\
    \   [SERIALNUM].  For example, a server that logs usage information\n   together\
    \ with a source addresses, is also recording the interface\n   identifier since\
    \ it is embedded within an address.  Consequently, any\n   data-mining technique\
    \ that correlates activity based on addresses\n   could easily be extended to\
    \ do the same using the interface\n   identifier.  This is of particular concern\
    \ with the expected\n   proliferation of next-generation network-connected devices\
    \ (e.g.,\n   PDAs, cell phones, etc.) in which large numbers of devices are in\n\
    \   practice associated with individual users (i.e., not shared).  Thus,\n   the\
    \ interface identifier embedded within an address could be used to\n   track activities\
    \ of an individual, even as they move topologically\n   within the internet.\n\
    \   In summary, IPv6 addresses on a given interface generated via\n   Stateless\
    \ Autoconfiguration contain the same interface identifier,\n   regardless of where\
    \ within the Internet the device connects.  This\n   facilitates the tracking\
    \ of individual devices (and thus potentially\n   users).  The purpose of this\
    \ document is to define mechanisms that\n   eliminate this issue, in those situations\
    \ where it is a concern.\n"
- title: 2.4.  Possible Approaches
  contents:
  - "2.4.  Possible Approaches\n   One way to avoid some of the problems discussed\
    \ above is to use DHCP\n   for obtaining addresses.  With DHCP, the DHCP server\
    \ could arrange to\n   hand out addresses that change over time.\n   Another approach,\
    \ compatible with the stateless address\n   autoconfiguration architecture, would\
    \ be to change the interface id\n   portion of an address over time and generate\
    \ new addresses from the\n   interface identifier for some address scopes.  Changing\
    \ the interface\n   identifier can make it more difficult to look at the IP addresses\
    \ in\n   independent transactions and identify which ones actually correspond\n\
    \   to the same node, both in the case where the routing prefix portion\n   of\
    \ an address changes and when it does not.\n   Many machines function as both\
    \ clients and servers.  In such cases,\n   the machine would need a DNS name for\
    \ its use as a server.  Whether\n   the address stays fixed or changes has little\
    \ privacy implication\n   since the DNS name remains constant and serves as a\
    \ constant\n   identifier.  When acting as a client (e.g., initiating\n   communication),\
    \ however, such a machine may want to vary the\n   addresses it uses.  In such\
    \ environments, one may need multiple\n   addresses: a \"public\" (i.e., non-secret)\
    \ server address, registered\n   in the DNS, that is used to accept incoming connection\
    \ requests from\n   other machines, and a \"temporary\" address used to shield\
    \ the identity\n   of the client when it initiates communication.  These two cases\
    \ are\n   roughly analogous to telephone numbers and caller ID, where a user\n\
    \   may list their telephone number in the public phone book, but disable\n  \
    \ the display of its number via caller ID when initiating calls.\n   To make it\
    \ difficult to make educated guesses as to whether two\n   different interface\
    \ identifiers belong to the same node, the\n   algorithm for generating alternate\
    \ identifiers must include input\n   that has an unpredictable component from\
    \ the perspective of the\n   outside entities that are collecting information.\
    \  Picking\n   identifiers from a pseudo-random sequence suffices, so long as\
    \ the\n   specific sequence cannot be determined by an outsider examining\n  \
    \ information that is readily available or easily determinable (e.g.,\n   by examining\
    \ packet contents).  This document proposes the generation\n   of a pseudo-random\
    \ sequence of interface identifiers via an MD5 hash.\n   Periodically, the next\
    \ interface identifier in the sequence is\n   generated, a new set of temporary\
    \ addresses is created, and the\n   previous temporary addresses are deprecated\
    \ to discourage their\n   further use.  The precise pseudo-random sequence depends\
    \ on both a\n   random component and the globally unique interface identifier\
    \ (when\n   available), to increase the likelihood that different nodes generate\n\
    \   different sequences.\n"
- title: 3.  Protocol Description
  contents:
  - "3.  Protocol Description\n   The goal of this section is to define procedures\
    \ that:\n   1) Do not result in any changes to the basic behavior of addresses\n\
    \      generated via stateless address autoconfiguration [ADDRCONF].\n   2) Create\
    \ additional global-scope addresses based on a random\n      interface identifier\
    \ for use with global scope addresses.  Such\n      addresses would be used to\
    \ initiate outgoing sessions.  These\n      \"random\" or temporary addresses\
    \ would be used for a short period\n      of time (hours to days) and would then\
    \ be deprecated.  Deprecated\n      address can continue to be used for already\
    \ established\n      connections, but are not used to initiate new connections.\
    \  New\n      temporary addresses are generated periodically to replace\n    \
    \  temporary addresses that expire, with the exact time between\n      address\
    \ generation a matter of local policy.\n   3) Produce a sequence of temporary\
    \ global-scope addresses from a\n      sequence of interface identifiers that\
    \ appear to be random in the\n      sense that it is difficult for an outside\
    \ observer to predict a\n      future address (or identifier) based on a current\
    \ one and it is\n      difficult to determine previous addresses (or identifiers)\
    \ knowing\n      only the present one.\n   4) Generate a set of addresses from\
    \ the same (randomized) interface\n      identifier, one address for each prefix\
    \ for which a global address\n      has been generated via stateless address autoconfiguration.\
    \  Using\n      the same interface identifier to generate a set of temporary\n\
    \      addresses reduces the number of IP multicast groups a host must\n     \
    \ join.  Nodes join the solicited-node multicast address for each\n      unicast\
    \ address they support, and solicited-node addresses are\n      dependent only\
    \ on the low-order bits of the corresponding address.\n      This decision was\
    \ made to address the concern that a node that\n      joins a large number of\
    \ multicast groups may be required to put\n      its interface into promiscuous\
    \ mode, resulting in possible reduced\n      performance.\n"
- title: 3.1.  Assumptions
  contents:
  - "3.1.  Assumptions\n   The following algorithm assumes that each interface maintains\
    \ an\n   associated randomized interface identifier.  When temporary addresses\n\
    \   are generated, the current value of the associated randomized\n   interface\
    \ identifier is used.  The actual value of the identifier\n   changes over time\
    \ as described below, but the same identifier can be\n   used to generate more\
    \ than one temporary address.\n   The algorithm also assumes that for a given\
    \ temporary address, an\n   implementation can determine the corresponding public\
    \ address from\n   which it was generated.  When a temporary address is deprecated,\
    \ a\n   new temporary address is generated.  The specific valid and preferred\n\
    \   lifetimes for the new address are dependent on the corresponding\n   lifetime\
    \ values in the public address.\n   Finally, this document assumes that when a\
    \ node initiates outgoing\n   communication, temporary addresses can be given\
    \ preference over\n   public addresses.  This can mean that all connections initiated\
    \ by\n   the node use temporary addresses by default, or that applications\n \
    \  individually indicate whether they prefer to use temporary or public\n   addresses.\
    \  Giving preference to temporary address is consistent with\n   on-going work\
    \ that addresses the topic of source-address selection in\n   the more general\
    \ case [ADDR_SELECT].  An implementation may make it a\n   policy that it does\
    \ not select a public address in the event that no\n   temporary address is available\
    \ (e.g., if generation of a useable\n   temporary address fails).\n"
- title: 3.2.  Generation Of Randomized Interface Identifiers.
  contents:
  - "3.2.  Generation Of Randomized Interface Identifiers.\n   We describe two approaches\
    \ for the maintenance of the randomized\n   interface identifier.  The first assumes\
    \ the presence of stable\n   storage that can be used to record state history\
    \ for use as input\n   into the next iteration of the algorithm across system\
    \ restarts.  A\n   second approach addresses the case where stable storage is\n\
    \   unavailable and there is a need to generate randomized interface\n   identifiers\
    \ without previous state.\n"
- title: 3.2.1.  When Stable Storage Is Present
  contents:
  - "3.2.1.  When Stable Storage Is Present\n   The following algorithm assumes the\
    \ presence of a 64-bit \"history\n   value\" that is used as input in generating\
    \ a randomized interface\n   identifier.  The very first time the system boots\
    \ (i.e., out-of-the-\n   box), a random value should be generated using techniques\
    \ that help\n   ensure the initial value is hard to guess [RANDOM].  Whenever\
    \ a new\n   interface identifier is generated, a value generated by the\n   computation\
    \ is saved in the history value for the next iteration of\n   the algorithm.\n\
    \   A randomized interface identifier is created as follows:\n   1) Take the history\
    \ value from the previous iteration of this\n      algorithm (or a random value\
    \ if there is no previous value) and\n      append to it the interface identifier\
    \ generated as described in\n      [ADDRARCH].\n   2) Compute the MD5 message\
    \ digest [MD5] over the quantity created in\n      the previous step.\n   3) Take\
    \ the left-most 64-bits of the MD5 digest and set bit 6 (the\n      left-most\
    \ bit is numbered 0) to zero.  This creates an interface\n      identifier with\
    \ the universal/local bit indicating local\n      significance only.  Save the\
    \ generated identifier as the\n      associated randomized interface identifier.\n\
    \   4) Take the rightmost 64-bits of the MD5 digest computed in step 2)\n    \
    \  and save them in stable storage as the history value to be used in\n      the\
    \ next iteration of the algorithm.\n   MD5 was chosen for convenience, and because\
    \ its particular properties\n   were adequate to produce the desired level of\
    \ randomization.  IPv6\n   nodes are already required to implement MD5 as part\
    \ of IPsec [IPSEC],\n   thus the code will already be present on IPv6 machines.\n\
    \   In theory, generating successive randomized interface identifiers\n   using\
    \ a history scheme as above has no advantages over generating\n   them at random.\
    \  In practice, however, generating truly random\n   numbers can be tricky.  Use\
    \ of a history value is intended to avoid\n   the particular scenario where two\
    \ nodes generate the same randomized\n   interface identifier, both detect the\
    \ situation via DAD, but then\n   proceed to generate identical randomized interface\
    \ identifiers via\n   the same (flawed) random number generation algorithm.  The\
    \ above\n   algorithm avoids this problem by having the interface identifier\n\
    \   (which will often be globally unique) used in the calculation that\n   generates\
    \ subsequent randomized interface identifiers.  Thus, if two\n   nodes happen\
    \ to generate the same randomized interface identifier,\n   they should generate\
    \ different ones on the followup attempt.\n"
- title: 3.2.2.  In The Absence of Stable Storage
  contents:
  - "3.2.2.  In The Absence of Stable Storage\n   In the absence of stable storage,\
    \ no history value will be available\n   across system restarts to generate a\
    \ pseudo-random sequence of\n   interface identifiers.  Consequently, the initial\
    \ history value used\n   above will need to be generated at random.  A number\
    \ of techniques\n   might be appropriate.  Consult [RANDOM] for suggestions on\
    \ good\n   sources for obtaining random numbers.  Note that even though machines\n\
    \   may not have stable storage for storing a history value, they will in\n  \
    \ many cases have configuration information that differs from one\n   machine\
    \ to another (e.g., user identity, security keys, serial\n   numbers, etc.). \
    \ One approach to generating a random initial history\n   value in such cases\
    \ is to use the configuration information to\n   generate some data bits (which\
    \ may remain constant for the life of\n   the machine, but will vary from one\
    \ machine to another), append some\n   random data and compute the MD5 digest\
    \ as before.\n"
- title: 3.3.  Generating Temporary Addresses
  contents:
  - "3.3.  Generating Temporary Addresses\n   [ADDRCONF] describes the steps for generating\
    \ a link-local address\n   when an interface becomes enabled as well as the steps\
    \ for generating\n   addresses for other scopes.  This document extends [ADDRCONF]\
    \ as\n   follows.  When processing a Router Advertisement with a Prefix\n   Information\
    \ option carrying a global-scope prefix for the purposes of\n   address autoconfiguration\
    \ (i.e., the A bit is set), perform the\n   following steps:\n   1) Process the\
    \ Prefix Information Option as defined in [ADDRCONF],\n      either creating a\
    \ public address or adjusting the lifetimes of\n      existing addresses, both\
    \ public and temporary.  When adjusting the\n      lifetimes of an existing temporary\
    \ address, only lower the\n      lifetimes.  Implementations must not increase\
    \ the lifetimes of an\n      existing temporary address when processing a Prefix\
    \ Information\n      Option.\n   2) When a new public address is created as described\
    \ in [ADDRCONF]\n      (because the prefix advertised does not match the prefix\
    \ of any\n      address already assigned to the interface, and the Valid Lifetime\n\
    \      in the option is not zero), also create a new temporary address.\n   3)\
    \ When creating a temporary address, the lifetime values are derived\n      from\
    \ the corresponding public address as follows:\n      -  Its Valid Lifetime is\
    \ the lower of the Valid Lifetime of the\n         public address or TEMP_VALID_LIFETIME.\n\
    \      -  Its Preferred Lifetime is the lower of the Preferred Lifetime\n    \
    \     of the public address or TEMP_PREFERRED_LIFETIME -\n         DESYNC_FACTOR.\n\
    \      A temporary address is created only if this calculated Preferred\n    \
    \  Lifetime is greater than REGEN_ADVANCE time units.  In particular,\n      an\
    \ implementation must not create a temporary address with a zero\n      Preferred\
    \ Lifetime.\n   4) New temporary addresses are created by appending the interface's\n\
    \      current randomized interface identifier to the prefix that was\n      used\
    \ to generate the corresponding public address.  If by chance\n      the new temporary\
    \ address is the same as an address already\n      assigned to the interface,\
    \ generate a new randomized interface\n      identifier and repeat this step.\n\
    \   5) Perform duplicate address detection (DAD) on the generated\n      temporary\
    \ address.  If DAD indicates the address is already in\n      use, generate a\
    \ new randomized interface identifier as described\n      in Section 3.2 above,\
    \ and repeat the previous steps as appropriate\n      up to 5 times.  If after\
    \ 5 consecutive attempts no non-unique\n      address was generated, log a system\
    \ error and give up attempting\n      to generate temporary addresses for that\
    \ interface.\n      Note: because multiple temporary addresses are generated from\
    \ the\n      same associated randomized interface identifier, there is little\n\
    \      benefit in running DAD on every temporary address.  This document\n   \
    \   recommends that DAD be run on the first address generated from a\n      given\
    \ randomized identifier, but that DAD be skipped on all\n      subsequent addresses\
    \ generated from the same randomized interface\n      identifier.\n"
- title: 3.4.  Expiration of Temporary Addresses
  contents:
  - "3.4.  Expiration of Temporary Addresses\n   When a temporary address becomes\
    \ deprecated, a new one should be\n   generated.  This is done by repeating the\
    \ actions described in\n   Section 3.3, starting at step 3).  Note that, except\
    \ for the\n   transient period when a temporary address is being regenerated,\
    \ in\n   normal operation at most one temporary address corresponding to a\n \
    \  public address should be in a non-deprecated state at any given time.\n   Note\
    \ that if a temporary address becomes deprecated as result of\n   processing a\
    \ Prefix Information Option with a zero Preferred\n   Lifetime, then a new temporary\
    \ address must not be generated.  The\n   Prefix Information Option will also\
    \ deprecate the corresponding\n   public address.\n   To insure that a preferred\
    \ temporary address is always available, a\n   new temporary address should be\
    \ regenerated slightly before its\n   predecessor is deprecated.  This is to allow\
    \ sufficient time to avoid\n   race conditions in the case where generating a\
    \ new temporary address\n   is not instantaneous, such as when duplicate address\
    \ detection must\n   be run.  It is recommended that an implementation start the\
    \ address\n   regeneration process REGEN_ADVANCE time units before a temporary\n\
    \   address would actually be deprecated.\n   As an optional optimization, an\
    \ implementation may wish to remove a\n   deprecated temporary address that is\
    \ not in use by applications or\n   upper-layers.  For TCP connections, such information\
    \ is available in\n   control blocks.  For UDP-based applications, it may be the\
    \ case that\n   only the applications have knowledge about what addresses are\n\
    \   actually in use.  Consequently, one may need to use heuristics in\n   deciding\
    \ when an address is no longer in use (e.g., the default\n   TEMP_VALID_LIFETIME\
    \ suggested above).\n"
- title: 3.5.  Regeneration of Randomized Interface Identifiers
  contents:
  - "3.5.  Regeneration of Randomized Interface Identifiers\n   The frequency at which\
    \ temporary addresses should change depends on\n   how a device is being used\
    \ (e.g., how frequently it initiates new\n   communication) and the concerns of\
    \ the end user.  The most egregious\n   privacy concerns appear to involve addresses\
    \ used for long periods of\n   time (weeks to months to years).  The more frequently\
    \ an address\n   changes, the less feasible collecting or coordinating information\n\
    \   keyed on interface identifiers becomes.  Moreover, the cost of\n   collecting\
    \ information and attempting to correlate it based on\n   interface identifiers\
    \ will only be justified if enough addresses\n   contain non-changing identifiers\
    \ to make it worthwhile.  Thus, having\n   large numbers of clients change their\
    \ address on a daily or weekly\n   basis is likely to be sufficient to alleviate\
    \ most privacy concerns.\n   There are also client costs associated with having\
    \ a large number of\n   addresses associated with a node (e.g., in doing address\
    \ lookups, the\n   need to join many multicast groups, etc.).  Thus, changing\
    \ addresses\n   frequently (e.g., every few minutes) may have performance\n  \
    \ implications.\n   This document recommends that implementations generate new\
    \ temporary\n   addresses on a periodic basis.  This can be achieved automatically\
    \ by\n   generating a new randomized interface identifier at least once every\n\
    \   (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE - DESYNC_FACTOR) time units.\n  \
    \ As described above, generating a new temporary address REGEN_ADVANCE\n   time\
    \ units before a temporary address becomes deprecated produces\n   addresses with\
    \ a preferred lifetime no larger than\n   TEMP_PREFERRED_LIFETIME.  The value\
    \ DESYNC_FACTOR is a random value\n   (different for each client) that ensures\
    \ that clients don't\n   synchronize with each other and generate new addresses\
    \ at exactly the\n   same time.  When the preferred lifetime expires, a new temporary\n\
    \   address is generated using the new randomized interface identifier.\n   Because\
    \ the precise frequency at which it is appropriate to generate\n   new addresses\
    \ varies from one environment to another, implementations\n   should provide end\
    \ users with the ability to change the frequency at\n   which addresses are regenerated.\
    \  The default value is given in\n   TEMP_PREFERRED_LIFETIME and is one day. \
    \ In addition, the exact time\n   at which to invalidate a temporary address depends\
    \ on how\n   applications are used by end users.  Thus the default value given\
    \ of\n   one week (TEMP_VALID_LIFETIME) may not be appropriate in all\n   environments.\
    \  Implementations should provide end users with the\n   ability to override both\
    \ of these default values.\n   Finally, when an interface connects to a new link,\
    \ a new randomized\n   interface identifier should be generated immediately together\
    \ with a\n   new set of temporary addresses.  If a device moves from one ethernet\n\
    \   to another, generating a new set of temporary addresses from a\n   different\
    \ randomized interface identifier ensures that the device\n   uses different randomized\
    \ interface identifiers for the temporary\n   addresses associated with the two\
    \ links, making it more difficult to\n   correlate addresses from the two different\
    \ links as being from the\n   same node.\n"
- title: 4.  Implications of Changing Interface Identifiers
  contents:
  - "4.  Implications of Changing Interface Identifiers\n   The IPv6 addressing architecture\
    \ goes to some lengths to ensure that\n   interface identifiers are likely to\
    \ be globally unique where easy to\n   do so.  During the IPng discussions of\
    \ the GSE proposal [GSE], it was\n   felt that keeping interface identifiers globally\
    \ unique in practice\n   might prove useful to future transport protocols.  Usage\
    \ of the\n   algorithms in this document may complicate providing such a future\n\
    \   flexibility.\n   The desires of protecting individual privacy vs. the desire\
    \ to\n   effectively maintain and debug a network can conflict with each\n   other.\
    \  Having clients use addresses that change over time will make\n   it more difficult\
    \ to track down and isolate operational problems.\n   For example, when looking\
    \ at packet traces, it could become more\n   difficult to determine whether one\
    \ is seeing behavior caused by a\n   single errant machine, or by a number of\
    \ them.\n   Some servers refuse to grant access to clients for which no DNS name\n\
    \   exists.  That is, they perform a DNS PTR query to determine the DNS\n   name,\
    \ and may then also perform an A query on the returned name to\n   verify that\
    \ the returned DNS name maps back into the address being\n   used.  Consequently,\
    \ clients not properly registered in the DNS may\n   be unable to access some\
    \ services.  As noted earlier, however, a\n   node's DNS name (if non-changing)\
    \ serves as a constant identifier.\n   The wide deployment of the extension described\
    \ in this document could\n   challenge the practice of inverse-DNS-based \"authentication,\"\
    \ which\n   has little validity, though it is widely implemented.  In order to\n\
    \   meet server challenges, nodes could register temporary addresses in\n   the\
    \ DNS using random names (for example a string version of the\n   random address\
    \ itself).\n   Use of the extensions defined in this document may complicate\n\
    \   debugging and other operational troubleshooting activities.\n   Consequently,\
    \ it may be site policy that temporary addresses should\n   not be used.  Implementations\
    \ may provide a method for a trusted\n   administrator to override the use of\
    \ temporary addresses.\n"
- title: 5.  Defined Constants
  contents:
  - "5.  Defined Constants\n   Constants defined in this document include:\n"
- title: 'TEMP_VALID_LIFETIME -- Default value: 1 week.  Users should be able'
  contents:
  - "TEMP_VALID_LIFETIME -- Default value: 1 week.  Users should be able\n       \
    \   to override the default value.\n"
- title: 'TEMP_PREFERRED_LIFETIME -- Default value: 1 day.  Users should be'
  contents:
  - "TEMP_PREFERRED_LIFETIME -- Default value: 1 day.  Users should be\n         \
    \ able to override the default value.\n"
- title: REGEN_ADVANCE -- 5 seconds
  contents:
  - 'REGEN_ADVANCE -- 5 seconds

    '
- title: MAX_DESYNC_FACTOR -- 10 minutes.  Upper bound on DESYNC_FACTOR.
  contents:
  - 'MAX_DESYNC_FACTOR -- 10 minutes.  Upper bound on DESYNC_FACTOR.

    '
- title: DESYNC_FACTOR -- A random value within the range 0 - MAX_DESYNC_FACTOR.
  contents:
  - "DESYNC_FACTOR -- A random value within the range 0 - MAX_DESYNC_FACTOR.\n   \
    \       It is computed once at system start (rather than each time\n         \
    \ it is used) and must never be greater than\n          (TEMP_VALID_LIFETIME -\
    \ REGEN_ADVANCE).\n"
- title: 6.  Future Work
  contents:
  - "6.  Future Work\n   An implementation might want to keep track of which addresses\
    \ are\n   being used by upper layers so as to be able to remove a deprecated\n\
    \   temporary address from internal data structures once no upper layer\n   protocols\
    \ are using it (but not before).  This is in contrast to\n   current approaches\
    \ where addresses are removed from an interface when\n   they become invalid [ADDRCONF],\
    \ independent of whether or not upper\n   layer protocols are still using them.\
    \  For TCP connections, such\n   information is available in control blocks. \
    \ For UDP-based\n   applications, it may be the case that only the applications\
    \ have\n   knowledge about what addresses are actually in use.  Consequently,\
    \ an\n   implementation generally will need to use heuristics in deciding when\n\
    \   an address is no longer in use (e.g., as is suggested in Section\n   3.4).\n\
    \   The determination as to whether to use public vs. temporary addresses\n  \
    \ can in some cases only be made by an application.  For example, some\n   applications\
    \ may always want to use temporary addresses, while others\n   may want to use\
    \ them only in some circumstances or not at all.\n   Suitable API extensions will\
    \ likely need to be developed to enable\n   individual applications to indicate\
    \ with sufficient granularity their\n   needs with regards to the use of temporary\
    \ addresses.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The motivation for this document stems from privacy\
    \ concerns for\n   individuals.  This document does not appear to add any security\n\
    \   issues beyond those already associated with stateless address\n   autoconfiguration\
    \ [ADDRCONF].\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   The authors would like to acknowledge the contributions\
    \ of the IPNGWG\n   working group and, in particular, Matt Crawford, Steve Deering\
    \ and\n   Allison Mankin for their detailed comments.\n"
- title: 9.  References
  contents:
  - "9.  References\n   [ADDRARCH]    Hinden, R. and S. Deering, \"IP Version 6 Addressing\n\
    \                 Architecture\", RFC 2373, July 1998.\n   [ADDRCONF]    Thomson,\
    \ S. and T. Narten, \"IPv6 Address\n                 Autoconfiguration\", RFC\
    \ 2462, December 1998.\n   [ADDR_SELECT] Draves, R. \"Default Address Selection\
    \ for IPv6\", Work\n                 in Progress.\n   [COOKIES]     Kristol, D.\
    \ and L. Montulli, \"HTTP State Management\n                 Mechanism\", RFC\
    \ 2965, October 2000.\n   [DHCP]        Droms, R., \"Dynamic Host Configuration\
    \ Protocol\", RFC\n                 2131, March 1997.\n   [DDNS]        Vixie,\
    \ R., Thomson, S., Rekhter, Y. and J. Bound,\n                 \"Dynamic Updates\
    \ in the Domain Name System (DNS\n                 UPDATE)\", RFC 2136, April\
    \ 1997.\n   [DISCOVERY]   Narten, T., Nordmark, E. and W. Simpson, \"Neighbor\n\
    \                 Discovery for IP Version 6 (IPv6)\", RFC 2461, December\n  \
    \               1998.\n   [GSE]         Crawford, et al., \"Separating Identifiers\
    \ and Locators\n                 in Addresses: An Analysis of the GSE Proposal\
    \ for\n                 IPv6\", Work in Progress.\n   [IPSEC]       Kent, S.,\
    \ Atkinson, R., \"Security Architecture for the\n                 Internet Protocol\"\
    , RFC 2401, November 1998.\n   [MD5]         Rivest, R., \"The MD5 Message-Digest\
    \ Algorithm\", RFC\n                 1321, April 1992.\n   [MOBILEIP]    Perkins,\
    \ C., \"IP Mobility Support\", RFC 2002, October\n                 1996.\n   [RANDOM]\
    \      Eastlake 3rd, D., Crocker S. and J. Schiller,\n                 \"Randomness\
    \ Recommendations for Security\", RFC 1750,\n                 December 1994.\n\
    \   [SERIALNUM]   Moore, K., \"Privacy Considerations for the Use of\n       \
    \          Hardware Serial Numbers in End-to-End Network\n                 Protocols\"\
    , Work in Progress.\n"
- title: 10. Authors' Addresses
  contents:
  - "10. Authors' Addresses\n   Thomas Narten\n   IBM Corporation\n   P.O. Box 12195\n\
    \   Research Triangle Park, NC 27709-2195\n   USA\n   Phone: +1 919 254 7798\n\
    \   EMail: narten@raleigh.ibm.com\n   Richard Draves\n   Microsoft Research\n\
    \   One Microsoft Way\n   Redmond, WA 98052\n   Phone: +1 425 936 2268\n   EMail:\
    \ richdr@microsoft.com\n"
- title: 11.  Full Copyright Statement
  contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2001).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
