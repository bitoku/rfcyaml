- contents:
  - "              Punycode: A Bootstring encoding of Unicode\n       for Internationalized
    Domain Names in Applications (IDNA)\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   Punycode is a simple and efficient transfer encoding syntax designed\n
    \  for use with Internationalized Domain Names in Applications (IDNA).\n   It
    uniquely and reversibly transforms a Unicode string into an ASCII\n   string.
    \ ASCII characters in the Unicode string are represented\n   literally, and non-ASCII
    characters are represented by ASCII\n   characters that are allowed in host name
    labels (letters, digits, and\n   hyphens).  This document defines a general algorithm
    called\n   Bootstring that allows a string of basic code points to uniquely\n
    \  represent any string of code points drawn from a larger set.\n   Punycode is
    an instance of Bootstring that uses particular parameter\n   values specified
    by this document, appropriate for IDNA.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction...............................................2\n
    \      1.1 Features..............................................2\n       1.2
    Interaction of protocol parts.........................3\n   2. Terminology................................................3\n
    \  3. Bootstring description.....................................4\n       3.1
    Basic code point segregation..........................4\n       3.2 Insertion
    unsort coding...............................4\n       3.3 Generalized variable-length
    integers..................5\n       3.4 Bias adaptation.......................................7\n
    \  4. Bootstring parameters......................................8\n   5. Parameter
    values for Punycode..............................8\n   6. Bootstring algorithms......................................9\n
    \      6.1 Bias adaptation function.............................10\n       6.2
    Decoding procedure...................................11\n       6.3 Encoding procedure...................................12\n
    \      6.4 Overflow handling....................................13\n   7. Punycode
    examples.........................................14\n       7.1 Sample strings.......................................14\n
    \      7.2 Decoding traces......................................17\n       7.3
    Encoding traces......................................19\n   8. Security Considerations...................................20\n
    \  9. References................................................21\n       9.1
    Normative References.................................21\n       9.2 Informative
    References...............................21\n   A. Mixed-case annotation.....................................22\n
    \  B. Disclaimer and license....................................22\n   C. Punycode
    sample implementation............................23\n   Author's Address.............................................34\n
    \  Full Copyright Statement.....................................35\n"
  title: Table of Contents
- contents:
  - "1. Introduction\n   [IDNA] describes an architecture for supporting internationalized\n
    \  domain names.  Labels containing non-ASCII characters can be\n   represented
    by ACE labels, which begin with a special ACE prefix and\n   contain only ASCII
    characters.  The remainder of the label after the\n   prefix is a Punycode encoding
    of a Unicode string satisfying certain\n   constraints.  For the details of the
    prefix and constraints, see\n   [IDNA] and [NAMEPREP].\n   Punycode is an instance
    of a more general algorithm called\n   Bootstring, which allows strings composed
    from a small set of \"basic\"\n   code points to uniquely represent any string
    of code points drawn\n   from a larger set.  Punycode is Bootstring with particular
    parameter\n   values appropriate for IDNA.\n"
  title: 1. Introduction
- contents:
  - "1.1 Features\n   Bootstring has been designed to have the following features:\n
    \  *  Completeness:  Every extended string (sequence of arbitrary code\n      points)
    can be represented by a basic string (sequence of basic\n      code points).  Restrictions
    on what strings are allowed, and on\n      length, can be imposed by higher layers.\n
    \  *  Uniqueness:  There is at most one basic string that represents a\n      given
    extended string.\n   *  Reversibility:  Any extended string mapped to a basic
    string can\n      be recovered from that basic string.\n   *  Efficient encoding:
    \ The ratio of basic string length to extended\n      string length is small.
    \ This is important in the context of\n      domain names because RFC 1034 [RFC1034]
    restricts the length of a\n      domain label to 63 characters.\n   *  Simplicity:
    \ The encoding and decoding algorithms are reasonably\n      simple to implement.
    \ The goals of efficiency and simplicity are\n      at odds; Bootstring aims at
    a good balance between them.\n   *  Readability:  Basic code points appearing
    in the extended string\n      are represented as themselves in the basic string
    (although the\n      main purpose is to improve efficiency, not readability).\n
    \  Punycode can also support an additional feature that is not used by\n   the
    ToASCII and ToUnicode operations of [IDNA].  When extended\n   strings are case-folded
    prior to encoding, the basic string can use\n   mixed case to tell how to convert
    the folded string into a mixed-case\n   string.  See appendix A \"Mixed-case annotation\".\n"
  title: 1.1 Features
- contents:
  - "1.2 Interaction of protocol parts\n   Punycode is used by the IDNA protocol [IDNA]
    for converting domain\n   labels into ASCII; it is not designed for any other
    purpose.  It is\n   explicitly not designed for processing arbitrary free text.\n"
  title: 1.2 Interaction of protocol parts
- contents:
  - "2. Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in BCP 14, RFC 2119\n
    \  [RFC2119].\n   A code point is an integral value associated with a character
    in a\n   coded character set.\n   As in the Unicode Standard [UNICODE], Unicode
    code points are denoted\n   by \"U+\" followed by four to six hexadecimal digits,
    while a range of\n   code points is denoted by two hexadecimal numbers separated
    by \"..\",\n   with no prefixes.\n   The operators div and mod perform integer
    division; (x div y) is the\n   quotient of x divided by y, discarding the remainder,
    and (x mod y)\n   is the remainder, so (x div y) * y + (x mod y) == x.  Bootstring
    uses\n   these operators only with nonnegative operands, so the quotient and\n
    \  remainder are always nonnegative.\n   The break statement jumps out of the
    innermost loop (as in C).\n   An overflow is an attempt to compute a value that
    exceeds the maximum\n   value of an integer variable.\n"
  title: 2. Terminology
- contents:
  - "3. Bootstring description\n   Bootstring represents an arbitrary sequence of
    code points (the\n   \"extended string\") as a sequence of basic code points (the
    \"basic\n   string\").  This section describes the representation.  Section 6\n
    \  \"Bootstring algorithms\" presents the algorithms as pseudocode.\n   Sections
    7.1 \"Decoding traces\" and 7.2 \"Encoding traces\" trace the\n   algorithms for
    sample inputs.\n   The following sections describe the four techniques used in\n
    \  Bootstring.  \"Basic code point segregation\" is a very simple and\n   efficient
    encoding for basic code points occurring in the extended\n   string: they are
    simply copied all at once.  \"Insertion unsort\n   coding\" encodes the non-basic
    code points as deltas, and processes\n   the code points in numerical order rather
    than in order of\n   appearance, which typically results in smaller deltas.  The
    deltas\n   are represented as \"generalized variable-length integers\", which
    use\n   basic code points to represent nonnegative integers.  The parameters\n
    \  of this integer representation are dynamically adjusted using \"bias\n   adaptation\",
    to improve efficiency when consecutive deltas have\n   similar magnitudes.\n"
  title: 3. Bootstring description
- contents:
  - "3.1 Basic code point segregation\n   All basic code points appearing in the extended
    string are\n   represented literally at the beginning of the basic string, in
    their\n   original order, followed by a delimiter if (and only if) the number\n
    \  of basic code points is nonzero.  The delimiter is a particular basic\n   code
    point, which never appears in the remainder of the basic string.\n   The decoder
    can therefore find the end of the literal portion (if\n   there is one) by scanning
    for the last delimiter.\n"
  title: 3.1 Basic code point segregation
- contents:
  - "3.2 Insertion unsort coding\n   The remainder of the basic string (after the
    last delimiter if there\n   is one) represents a sequence of nonnegative integral
    deltas as\n   generalized variable-length integers, described in section 3.3.
    \ The\n   meaning of the deltas is best understood in terms of the decoder.\n
    \  The decoder builds the extended string incrementally.  Initially, the\n   extended
    string is a copy of the literal portion of the basic string\n   (excluding the
    last delimiter).  The decoder inserts non-basic code\n   points, one for each
    delta, into the extended string, ultimately\n   arriving at the final decoded
    string.\n   At the heart of this process is a state machine with two state\n   variables:
    an index i and a counter n.  The index i refers to a\n   position in the extended
    string; it ranges from 0 (the first\n   position) to the current length of the
    extended string (which refers\n   to a potential position beyond the current end).
    \ If the current\n   state is <n,i>, the next state is <n,i+1> if i is less than
    the\n   length of the extended string, or <n+1,0> if i equals the length of\n
    \  the extended string.  In other words, each state change causes i to\n   increment,
    wrapping around to zero if necessary, and n counts the\n   number of wrap-arounds.\n
    \  Notice that the state always advances monotonically (there is no way\n   for
    the decoder to return to an earlier state).  At each state, an\n   insertion is
    either performed or not performed.  At most one\n   insertion is performed in
    a given state.  An insertion inserts the\n   value of n at position i in the extended
    string.  The deltas are a\n   run-length encoding of this sequence of events:
    they are the lengths\n   of the runs of non-insertion states preceeding the insertion
    states.\n   Hence, for each delta, the decoder performs delta state changes, then\n
    \  an insertion, and then one more state change.  (An implementation\n   need
    not perform each state change individually, but can instead use\n   division and
    remainder calculations to compute the next insertion\n   state directly.)  It
    is an error if the inserted code point is a\n   basic code point (because basic
    code points were supposed to be\n   segregated as described in section 3.1).\n
    \  The encoder's main task is to derive the sequence of deltas that will\n   cause
    the decoder to construct the desired string.  It can do this by\n   repeatedly
    scanning the extended string for the next code point that\n   the decoder would
    need to insert, and counting the number of state\n   changes the decoder would
    need to perform, mindful of the fact that\n   the decoder's extended string will
    include only those code points\n   that have already been inserted.  Section 6.3
    \"Encoding procedure\"\n   gives a precise algorithm.\n"
  title: 3.2 Insertion unsort coding
- contents:
  - "3.3 Generalized variable-length integers\n   In a conventional integer representation
    the base is the number of\n   distinct symbols for digits, whose values are 0
    through base-1.  Let\n   digit_0 denote the least significant digit, digit_1 the
    next least\n   significant, and so on.  The value represented is the sum over
    j of\n   digit_j * w(j), where w(j) = base^j is the weight (scale factor) for\n
    \  position j.  For example, in the base 8 integer 437, the digits are\n   7,
    3, and 4, and the weights are 1, 8, and 64, so the value is 7 +\n   3*8 + 4*64
    = 287.  This representation has two disadvantages:  First,\n   there are multiple
    encodings of each value (because there can be\n   extra zeros in the most significant
    positions), which is inconvenient\n   when unique encodings are needed.  Second,
    the integer is not self-\n   delimiting, so if multiple integers are concatenated
    the boundaries\n   between them are lost.\n   The generalized variable-length
    representation solves these two\n   problems.  The digit values are still 0 through
    base-1, but now the\n   integer is self-delimiting by means of thresholds t(j),
    each of which\n   is in the range 0 through base-1.  Exactly one digit, the most\n
    \  significant, satisfies digit_j < t(j).  Therefore, if several\n   integers
    are concatenated, it is easy to separate them, starting with\n   the first if
    they are little-endian (least significant digit first),\n   or starting with the
    last if they are big-endian (most significant\n   digit first).  As before, the
    value is the sum over j of digit_j *\n   w(j), but the weights are different:\n
    \     w(0) = 1\n      w(j) = w(j-1) * (base - t(j-1)) for j > 0\n   For example,
    consider the little-endian sequence of base 8 digits\n   734251...  Suppose the
    thresholds are 2, 3, 5, 5, 5, 5...  This\n   implies that the weights are 1, 1*(8-2)
    = 6, 6*(8-3) = 30, 30*(8-5) =\n   90, 90*(8-5) = 270, and so on.  7 is not less
    than 2, and 3 is not\n   less than 3, but 4 is less than 5, so 4 is the last digit.
    \ The value\n   of 734 is 7*1 + 3*6 + 4*30 = 145.  The next integer is 251, with\n
    \  value 2*1 + 5*6 + 1*30 = 62.  Decoding this representation is very\n   similar
    to decoding a conventional integer:  Start with a current\n   value of N = 0 and
    a weight w = 1.  Fetch the next digit d and\n   increase N by d * w.  If d is
    less than the current threshold (t)\n   then stop, otherwise increase w by a factor
    of (base - t), update t\n   for the next position, and repeat.\n   Encoding this
    representation is similar to encoding a conventional\n   integer:  If N < t then
    output one digit for N and stop, otherwise\n   output the digit for t + ((N -
    t) mod (base - t)), then replace N\n   with (N - t) div (base - t), update t for
    the next position, and\n   repeat.\n   For any particular set of values of t(j),
    there is exactly one\n   generalized variable-length representation of each nonnegative\n
    \  integral value.\n   Bootstring uses little-endian ordering so that the deltas
    can be\n   separated starting with the first.  The t(j) values are defined in\n
    \  terms of the constants base, tmin, and tmax, and a state variable\n   called
    bias:\n      t(j) = base * (j + 1) - bias,\n      clamped to the range tmin through
    tmax\n   The clamping means that if the formula yields a value less than tmin\n
    \  or greater than tmax, then t(j) = tmin or tmax, respectively.  (In\n   the
    pseudocode in section 6 \"Bootstring algorithms\", the expression\n   base * (j
    + 1) is denoted by k for performance reasons.)  These t(j)\n   values cause the
    representation to favor integers within a particular\n   range determined by the
    bias.\n"
  title: 3.3 Generalized variable-length integers
- contents:
  - "3.4 Bias adaptation\n   After each delta is encoded or decoded, bias is set for
    the next\n   delta as follows:\n   1. Delta is scaled in order to avoid overflow
    in the next step:\n         let delta = delta div 2\n      But when this is the
    very first delta, the divisor is not 2, but\n      instead a constant called damp.
    \ This compensates for the fact\n      that the second delta is usually much smaller
    than the first.\n   2. Delta is increased to compensate for the fact that the
    next delta\n      will be inserting into a longer string:\n         let delta
    = delta + (delta div numpoints)\n      numpoints is the total number of code points
    encoded/decoded so\n      far (including the one corresponding to this delta itself,
    and\n      including the basic code points).\n   3. Delta is repeatedly divided
    until it falls within a threshold, to\n      predict the minimum number of digits
    needed to represent the next\n      delta:\n         while delta > ((base - tmin)
    * tmax) div 2\n         do let delta = delta div (base - tmin)\n   4. The bias
    is set:\n         let bias =\n           (base * the number of divisions performed
    in step 3) +\n           (((base - tmin + 1) * delta) div (delta + skew))\n      The
    motivation for this procedure is that the current delta\n      provides a hint
    about the likely size of the next delta, and so\n      t(j) is set to tmax for
    the more significant digits starting with\n      the one expected to be last,
    tmin for the less significant digits\n      up through the one expected to be
    third-last, and somewhere\n      between tmin and tmax for the digit expected
    to be second-last\n      (balancing the hope of the expected-last digit being
    unnecessary\n      against the danger of it being insufficient).\n"
  title: 3.4 Bias adaptation
- contents:
  - "4. Bootstring parameters\n   Given a set of basic code points, one needs to be
    designated as the\n   delimiter.  The base cannot be greater than the number of\n
    \  distinguishable basic code points remaining.  The digit-values in the\n   range
    0 through base-1 need to be associated with distinct non-\n   delimiter basic
    code points.  In some cases multiple code points need\n   to have the same digit-value;
    for example, uppercase and lowercase\n   versions of the same letter need to be
    equivalent if basic strings\n   are case-insensitive.\n   The initial value of
    n cannot be greater than the minimum non-basic\n   code point that could appear
    in extended strings.\n   The remaining five parameters (tmin, tmax, skew, damp,
    and the\n   initial value of bias) need to satisfy the following constraints:\n
    \     0 <= tmin <= tmax <= base-1\n      skew >= 1\n      damp >= 2\n      initial_bias
    mod base <= base - tmin\n   Provided the constraints are satisfied, these five
    parameters affect\n   efficiency but not correctness.  They are best chosen empirically.\n
    \  If support for mixed-case annotation is desired (see appendix A),\n   make
    sure that the code points corresponding to 0 through tmax-1 all\n   have both
    uppercase and lowercase forms.\n"
  title: 4. Bootstring parameters
- contents:
  - "5. Parameter values for Punycode\n   Punycode uses the following Bootstring parameter
    values:\n      base         = 36\n      tmin         = 1\n      tmax         =
    26\n      skew         = 38\n      damp         = 700\n      initial_bias = 72\n
    \     initial_n    = 128 = 0x80\n   Although the only restriction Punycode imposes
    on the input integers\n   is that they be nonnegative, these parameters are especially
    designed\n   to work well with Unicode [UNICODE] code points, which are integers\n
    \  in the range 0..10FFFF (but not D800..DFFF, which are reserved for\n   use
    by the UTF-16 encoding of Unicode).  The basic code points are\n   the ASCII [ASCII]
    code points (0..7F), of which U+002D (-) is the\n   delimiter, and some of the
    others have digit-values as follows:\n      code points    digit-values\n      ------------
    \  ----------------------\n      41..5A (A-Z) =  0 to 25, respectively\n      61..7A
    (a-z) =  0 to 25, respectively\n      30..39 (0-9) = 26 to 35, respectively\n
    \  Using hyphen-minus as the delimiter implies that the encoded string\n   can
    end with a hyphen-minus only if the Unicode string consists\n   entirely of basic
    code points, but IDNA forbids such strings from\n   being encoded.  The encoded
    string can begin with a hyphen-minus, but\n   IDNA prepends a prefix.  Therefore
    IDNA using Punycode conforms to\n   the RFC 952 rule that host name labels neither
    begin nor end with a\n   hyphen-minus [RFC952].\n   A decoder MUST recognize the
    letters in both uppercase and lowercase\n   forms (including mixtures of both
    forms).  An encoder SHOULD output\n   only uppercase forms or only lowercase forms,
    unless it uses mixed-\n   case annotation (see appendix A).\n   Presumably most
    users will not manually write or type encoded strings\n   (as opposed to cutting
    and pasting them), but those who do will need\n   to be alert to the potential
    visual ambiguity between the following\n   sets of characters:\n      G 6\n      I
    l 1\n      O 0\n      S 5\n      U V\n      Z 2\n   Such ambiguities are usually
    resolved by context, but in a Punycode\n   encoded string there is no context
    apparent to humans.\n"
  title: 5. Parameter values for Punycode
- contents:
  - "6. Bootstring algorithms\n   Some parts of the pseudocode can be omitted if the
    parameters satisfy\n   certain conditions (for which Punycode qualifies).  These
    parts are\n   enclosed in {braces}, and notes immediately following the pseudocode\n
    \  explain the conditions under which they can be omitted.\n   Formally, code
    points are integers, and hence the pseudocode assumes\n   that arithmetic operations
    can be performed directly on code points.\n   In some programming languages, explicit
    conversion between code\n   points and integers might be necessary.\n"
  title: 6. Bootstring algorithms
- contents:
  - "6.1 Bias adaptation function\n   function adapt(delta,numpoints,firsttime):\n
    \    if firsttime then let delta = delta div damp\n     else let delta = delta
    div 2\n     let delta = delta + (delta div numpoints)\n     let k = 0\n     while
    delta > ((base - tmin) * tmax) div 2 do begin\n       let delta = delta div (base
    - tmin)\n       let k = k + base\n     end\n     return k + (((base - tmin + 1)
    * delta) div (delta + skew))\n   It does not matter whether the modifications
    to delta and k inside\n   adapt() affect variables of the same name inside the\n
    \  encoding/decoding procedures, because after calling adapt() the\n   caller
    does not read those variables before overwriting them.\n"
  title: 6.1 Bias adaptation function
- contents:
  - "6.2 Decoding procedure\n   let n = initial_n\n   let i = 0\n   let bias = initial_bias\n
    \  let output = an empty string indexed from 0\n   consume all code points before
    the last delimiter (if there is one)\n     and copy them to output, fail on any
    non-basic code point\n   if more than zero code points were consumed then consume
    one more\n     (which will be the last delimiter)\n   while the input is not exhausted
    do begin\n     let oldi = i\n     let w = 1\n     for k = base to infinity in
    steps of base do begin\n       consume a code point, or fail if there was none
    to consume\n       let digit = the code point's digit-value, fail if it has none\n
    \      let i = i + digit * w, fail on overflow\n       let t = tmin if k <= bias
    {+ tmin}, or\n               tmax if k >= bias + tmax, or k - bias otherwise\n
    \      if digit < t then break\n       let w = w * (base - t), fail on overflow\n
    \    end\n     let bias = adapt(i - oldi, length(output) + 1, test oldi is 0?)\n
    \    let n = n + i div (length(output) + 1), fail on overflow\n     let i = i
    mod (length(output) + 1)\n     {if n is a basic code point then fail}\n     insert
    n into output at position i\n     increment i\n   end\n   The full statement enclosed
    in braces (checking whether n is a basic\n   code point) can be omitted if initial_n
    exceeds all basic code points\n   (which is true for Punycode), because n is never
    less than initial_n.\n   In the assignment of t, where t is clamped to the range
    tmin through\n   tmax, \"+ tmin\" can always be omitted.  This makes the clamping\n
    \  calculation incorrect when bias < k < bias + tmin, but that cannot\n   happen
    because of the way bias is computed and because of the\n   constraints on the
    parameters.\n   Because the decoder state can only advance monotonically, and
    there\n   is only one representation of any delta, there is therefore only one\n
    \  encoded string that can represent a given sequence of integers.  The\n   only
    error conditions are invalid code points, unexpected end-of-\n   input, overflow,
    and basic code points encoded using deltas instead\n   of appearing literally.
    \ If the decoder fails on these errors as\n   shown above, then it cannot produce
    the same output for two distinct\n   inputs.  Without this property it would have
    been necessary to re-\n   encode the output and verify that it matches the input
    in order to\n   guarantee the uniqueness of the encoding.\n"
  title: 6.2 Decoding procedure
- contents:
  - "6.3 Encoding procedure\n   let n = initial_n\n   let delta = 0\n   let bias =
    initial_bias\n   let h = b = the number of basic code points in the input\n   copy
    them to the output in order, followed by a delimiter if b > 0\n   {if the input
    contains a non-basic code point < n then fail}\n   while h < length(input) do
    begin\n     let m = the minimum {non-basic} code point >= n in the input\n     let
    delta = delta + (m - n) * (h + 1), fail on overflow\n     let n = m\n     for
    each code point c in the input (in order) do begin\n       if c < n {or c is basic}
    then increment delta, fail on overflow\n       if c == n then begin\n         let
    q = delta\n         for k = base to infinity in steps of base do begin\n           let
    t = tmin if k <= bias {+ tmin}, or\n                   tmax if k >= bias + tmax,
    or k - bias otherwise\n           if q < t then break\n           output the code
    point for digit t + ((q - t) mod (base - t))\n           let q = (q - t) div (base
    - t)\n         end\n         output the code point for digit q\n         let bias
    = adapt(delta, h + 1, test h equals b?)\n         let delta = 0\n         increment
    h\n       end\n     end\n     increment delta and n\n   end\n   The full statement
    enclosed in braces (checking whether the input\n   contains a non-basic code point
    less than n) can be omitted if all\n   code points less than initial_n are basic
    code points (which is true\n   for Punycode if code points are unsigned).\n   The
    brace-enclosed conditions \"non-basic\" and \"or c is basic\" can be\n   omitted
    if initial_n exceeds all basic code points (which is true for\n   Punycode), because
    the code point being tested is never less than\n   initial_n.\n   In the assignment
    of t, where t is clamped to the range tmin through\n   tmax, \"+ tmin\" can always
    be omitted.  This makes the clamping\n   calculation incorrect when bias < k <
    bias + tmin, but that cannot\n   happen because of the way bias is computed and
    because of the\n   constraints on the parameters.\n   The checks for overflow
    are necessary to avoid producing invalid\n   output when the input contains very
    large values or is very long.\n   The increment of delta at the bottom of the
    outer loop cannot\n   overflow because delta < length(input) before the increment,
    and\n   length(input) is already assumed to be representable.  The increment\n
    \  of n could overflow, but only if h == length(input), in which case\n   the
    procedure is finished anyway.\n"
  title: 6.3 Encoding procedure
- contents:
  - "6.4 Overflow handling\n   For IDNA, 26-bit unsigned integers are sufficient to
    handle all valid\n   IDNA labels without overflow, because any string that needed
    a 27-bit\n   delta would have to exceed either the code point limit (0..10FFFF)
    or\n   the label length limit (63 characters).  However, overflow handling\n   is
    necessary because the inputs are not necessarily valid IDNA\n   labels.\n   If
    the programming language does not provide overflow detection, the\n   following
    technique can be used.  Suppose A, B, and C are\n   representable nonnegative
    integers and C is nonzero.  Then A + B\n   overflows if and only if B > maxint
    - A, and A + (B * C) overflows if\n   and only if B > (maxint - A) div C, where
    maxint is the greatest\n   integer for which maxint + 1 cannot be represented.
    \ Refer to\n   appendix C \"Punycode sample implementation\" for demonstrations
    of\n   this technique in the C language.\n   The decoding and encoding algorithms
    shown in sections 6.2 and 6.3\n   handle overflow by detecting it whenever it
    happens.  Another\n   approach is to enforce limits on the inputs that prevent
    overflow\n   from happening.  For example, if the encoder were to verify that
    no\n   input code points exceed M and that the input length does not exceed\n
    \  L, then no delta could ever exceed (M - initial_n) * (L + 1), and\n   hence
    no overflow could occur if integer variables were capable of\n   representing
    values that large.  This prevention approach would\n   impose more restrictions
    on the input than the detection approach\n   does, but might be considered simpler
    in some programming languages.\n   In theory, the decoder could use an analogous
    approach, limiting the\n   number of digits in a variable-length integer (that
    is, limiting the\n   number of iterations in the innermost loop).  However, the
    number of\n   digits that suffice to represent a given delta can sometimes\n   represent
    much larger deltas (because of the adaptation), and hence\n   this approach would
    probably need integers wider than 32 bits.\n   Yet another approach for the decoder
    is to allow overflow to occur,\n   but to check the final output string by re-encoding
    it and comparing\n   to the decoder input.  If and only if they do not match (using
    a\n   case-insensitive ASCII comparison) overflow has occurred.  This\n   delayed-detection
    approach would not impose any more restrictions on\n   the input than the immediate-detection
    approach does, and might be\n   considered simpler in some programming languages.\n
    \  In fact, if the decoder is used only inside the IDNA ToUnicode\n   operation
    [IDNA], then it need not check for overflow at all, because\n   ToUnicode performs
    a higher level re-encoding and comparison, and a\n   mismatch has the same consequence
    as if the Punycode decoder had\n   failed.\n"
  title: 6.4 Overflow handling
- contents:
  - '7. Punycode examples

    '
  title: 7. Punycode examples
- contents:
  - "7.1 Sample strings\n   In the Punycode encodings below, the ACE prefix is not
    shown.\n   Backslashes show where line breaks have been inserted in strings too\n
    \  long for one line.\n   The first several examples are all translations of the
    sentence \"Why\n   can't they just speak in <language>?\" (courtesy of Michael
    Kaplan's\n   \"provincial\" page [PROVINCIAL]).  Word breaks and punctuation have\n
    \  been removed, as is often done in domain names.\n   (A) Arabic (Egyptian):\n
    \      u+0644 u+064A u+0647 u+0645 u+0627 u+0628 u+062A u+0643 u+0644\n       u+0645
    u+0648 u+0634 u+0639 u+0631 u+0628 u+064A u+061F\n       Punycode: egbpdaj6bu4bxfgehfvwxn\n
    \  (B) Chinese (simplified):\n       u+4ED6 u+4EEC u+4E3A u+4EC0 u+4E48 u+4E0D
    u+8BF4 u+4E2D u+6587\n       Punycode: ihqwcrb4cv8a8dqg056pqjye\n   (C) Chinese
    (traditional):\n       u+4ED6 u+5011 u+7232 u+4EC0 u+9EBD u+4E0D u+8AAA u+4E2D
    u+6587\n       Punycode: ihqwctvzc91f659drss3x8bo0yb\n   (D) Czech: Pro<ccaron>prost<ecaron>nemluv<iacute><ccaron>esky\n
    \      U+0050 u+0072 u+006F u+010D u+0070 u+0072 u+006F u+0073 u+0074\n       u+011B
    u+006E u+0065 u+006D u+006C u+0075 u+0076 u+00ED u+010D\n       u+0065 u+0073
    u+006B u+0079\n       Punycode: Proprostnemluvesky-uyb24dma41a\n   (E) Hebrew:\n
    \      u+05DC u+05DE u+05D4 u+05D4 u+05DD u+05E4 u+05E9 u+05D5 u+05D8\n       u+05DC
    u+05D0 u+05DE u+05D3 u+05D1 u+05E8 u+05D9 u+05DD u+05E2\n       u+05D1 u+05E8
    u+05D9 u+05EA\n       Punycode: 4dbcagdahymbxekheh6e0a7fei0b\n   (F) Hindi (Devanagari):\n
    \      u+092F u+0939 u+0932 u+094B u+0917 u+0939 u+093F u+0928 u+094D\n       u+0926
    u+0940 u+0915 u+094D u+092F u+094B u+0902 u+0928 u+0939\n       u+0940 u+0902
    u+092C u+094B u+0932 u+0938 u+0915 u+0924 u+0947\n       u+0939 u+0948 u+0902\n
    \      Punycode: i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd\n   (G) Japanese
    (kanji and hiragana):\n       u+306A u+305C u+307F u+3093 u+306A u+65E5 u+672C
    u+8A9E u+3092\n       u+8A71 u+3057 u+3066 u+304F u+308C u+306A u+3044 u+306E
    u+304B\n       Punycode: n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa\n   (H) Korean
    (Hangul syllables):\n       u+C138 u+ACC4 u+C758 u+BAA8 u+B4E0 u+C0AC u+B78C u+B4E4
    u+C774\n       u+D55C u+AD6D u+C5B4 u+B97C u+C774 u+D574 u+D55C u+B2E4 u+BA74\n
    \      u+C5BC u+B9C8 u+B098 u+C88B u+C744 u+AE4C\n       Punycode: 989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j\\\n
    \                psd879ccm6fea98c\n   (I) Russian (Cyrillic):\n       U+043F u+043E
    u+0447 u+0435 u+043C u+0443 u+0436 u+0435 u+043E\n       u+043D u+0438 u+043D
    u+0435 u+0433 u+043E u+0432 u+043E u+0440\n       u+044F u+0442 u+043F u+043E
    u+0440 u+0443 u+0441 u+0441 u+043A\n       u+0438\n       Punycode: b1abfaaepdrnnbgefbaDotcwatmq2g4l\n
    \  (J) Spanish: Porqu<eacute>nopuedensimplementehablarenEspa<ntilde>ol\n       U+0050
    u+006F u+0072 u+0071 u+0075 u+00E9 u+006E u+006F u+0070\n       u+0075 u+0065
    u+0064 u+0065 u+006E u+0073 u+0069 u+006D u+0070\n       u+006C u+0065 u+006D
    u+0065 u+006E u+0074 u+0065 u+0068 u+0061\n       u+0062 u+006C u+0061 u+0072
    u+0065 u+006E U+0045 u+0073 u+0070\n       u+0061 u+00F1 u+006F u+006C\n       Punycode:
    PorqunopuedensimplementehablarenEspaol-fmd56a\n   (K) Vietnamese:\n       T<adotbelow>isaoh<odotbelow>kh<ocirc>ngth<ecirchookabove>ch\\\n
    \      <ihookabove>n<oacute>iti<ecircacute>ngVi<ecircdotbelow>t\n       U+0054
    u+1EA1 u+0069 u+0073 u+0061 u+006F u+0068 u+1ECD u+006B\n       u+0068 u+00F4
    u+006E u+0067 u+0074 u+0068 u+1EC3 u+0063 u+0068\n       u+1EC9 u+006E u+00F3
    u+0069 u+0074 u+0069 u+1EBF u+006E u+0067\n       U+0056 u+0069 u+1EC7 u+0074\n
    \      Punycode: TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g\n   The next several
    examples are all names of Japanese music artists,\n   song titles, and TV programs,
    just because the author happens to have\n   them handy (but Japanese is useful
    for providing examples of single-\n   row text, two-row text, ideographic text,
    and various mixtures\n   thereof).\n   (L) 3<nen>B<gumi><kinpachi><sensei>\n       u+0033
    u+5E74 U+0042 u+7D44 u+91D1 u+516B u+5148 u+751F\n       Punycode: 3B-ww4c5e180e575a65lsy2b\n
    \  (M) <amuro><namie>-with-SUPER-MONKEYS\n       u+5B89 u+5BA4 u+5948 u+7F8E u+6075
    u+002D u+0077 u+0069 u+0074\n       u+0068 u+002D U+0053 U+0055 U+0050 U+0045
    U+0052 u+002D U+004D\n       U+004F U+004E U+004B U+0045 U+0059 U+0053\n       Punycode:
    -with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n\n   (N) Hello-Another-Way-<sorezore><no><basho>\n
    \      U+0048 u+0065 u+006C u+006C u+006F u+002D U+0041 u+006E u+006F\n       u+0074
    u+0068 u+0065 u+0072 u+002D U+0057 u+0061 u+0079 u+002D\n       u+305D u+308C
    u+305E u+308C u+306E u+5834 u+6240\n       Punycode: Hello-Another-Way--fc4qua05auwb3674vfr0b\n
    \  (O) <hitotsu><yane><no><shita>2\n       u+3072 u+3068 u+3064 u+5C4B u+6839
    u+306E u+4E0B u+0032\n       Punycode: 2-u9tlzr9756bt3uc0v\n   (P) Maji<de>Koi<suru>5<byou><mae>\n
    \      U+004D u+0061 u+006A u+0069 u+3067 U+004B u+006F u+0069 u+3059\n       u+308B
    u+0035 u+79D2 u+524D\n       Punycode: MajiKoi5-783gue6qz075azm5e\n   (Q) <pafii>de<runba>\n
    \      u+30D1 u+30D5 u+30A3 u+30FC u+0064 u+0065 u+30EB u+30F3 u+30D0\n       Punycode:
    de-jg4avhby1noc0d\n   (R) <sono><supiido><de>\n       u+305D u+306E u+30B9 u+30D4
    u+30FC u+30C9 u+3067\n       Punycode: d9juau41awczczp\n   The last example is
    an ASCII string that breaks the existing rules\n   for host name labels.  (It
    is not a realistic example for IDNA,\n   because IDNA never encodes pure ASCII
    labels.)\n   (S) -> $1.00 <-\n       u+002D u+003E u+0020 u+0024 u+0031 u+002E
    u+0030 u+0030 u+0020\n       u+003C u+002D\n       Punycode: -> $1.00 <--\n"
  title: 7.1 Sample strings
- contents:
  - "7.2 Decoding traces\n   In the following traces, the evolving state of the decoder
    is shown\n   as a sequence of hexadecimal values, representing the code points
    in\n   the extended string.  An asterisk appears just after the most\n   recently
    inserted code point, indicating both n (the value preceeding\n   the asterisk)
    and i (the position of the value just after the\n   asterisk).  Other numerical
    values are decimal.\n   Decoding trace of example B from section 7.1:\n   n is
    128, i is 0, bias is 72\n   input is \"ihqwcrb4cv8a8dqg056pqjye\"\n   there is
    no delimiter, so extended string starts empty\n   delta \"ihq\" decodes to 19853\n
    \  bias becomes 21\n   4E0D *\n   delta \"wc\" decodes to 64\n   bias becomes
    20\n   4E0D 4E2D *\n   delta \"rb\" decodes to 37\n   bias becomes 13\n   4E3A
    * 4E0D 4E2D\n   delta \"4c\" decodes to 56\n   bias becomes 17\n   4E3A 4E48 *
    4E0D 4E2D\n   delta \"v8a\" decodes to 599\n   bias becomes 32\n   4E3A 4EC0 *
    4E48 4E0D 4E2D\n   delta \"8d\" decodes to 130\n   bias becomes 23\n   4ED6 *
    4E3A 4EC0 4E48 4E0D 4E2D\n   delta \"qg\" decodes to 154\n   bias becomes 25\n
    \  4ED6 4EEC * 4E3A 4EC0 4E48 4E0D 4E2D\n   delta \"056p\" decodes to 46301\n
    \  bias becomes 84\n   4ED6 4EEC 4E3A 4EC0 4E48 4E0D 4E2D 6587 *\n   delta \"qjye\"
    decodes to 88531\n   bias becomes 90\n   4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 *
    4E2D 6587\n   Decoding trace of example L from section 7.1:\n   n is 128, i is
    0, bias is 72\n   input is \"3B-ww4c5e180e575a65lsy2b\"\n   literal portion is
    \"3B-\", so extended string starts as:\n   0033 0042\n   delta \"ww4c\" decodes
    to 62042\n   bias becomes 27\n   0033 0042 5148 *\n   delta \"5e\" decodes to
    139\n   bias becomes 24\n   0033 0042 516B * 5148\n   delta \"180e\" decodes to
    16683\n   bias becomes 67\n   0033 5E74 * 0042 516B 5148\n   delta \"575a\" decodes
    to 34821\n   bias becomes 82\n   0033 5E74 0042 516B 5148 751F *\n   delta \"65l\"
    decodes to 14592\n   bias becomes 67\n   0033 5E74 0042 7D44 * 516B 5148 751F\n
    \  delta \"sy2b\" decodes to 42088\n   bias becomes 84\n   0033 5E74 0042 7D44
    91D1 * 516B 5148 751F\n"
  title: 7.2 Decoding traces
- contents:
  - "7.3 Encoding traces\n   In the following traces, code point values are hexadecimal,
    while\n   other numerical values are decimal.\n   Encoding trace of example B
    from section 7.1:\n   bias is 72\n   input is:\n   4ED6 4EEC 4E3A 4EC0 4E48 4E0D
    8BF4 4E2D 6587\n   there are no basic code points, so no literal portion\n   next
    code point to insert is 4E0D\n   needed delta is 19853, encodes as \"ihq\"\n   bias
    becomes 21\n   next code point to insert is 4E2D\n   needed delta is 64, encodes
    as \"wc\"\n   bias becomes 20\n   next code point to insert is 4E3A\n   needed
    delta is 37, encodes as \"rb\"\n   bias becomes 13\n   next code point to insert
    is 4E48\n   needed delta is 56, encodes as \"4c\"\n   bias becomes 17\n   next
    code point to insert is 4EC0\n   needed delta is 599, encodes as \"v8a\"\n   bias
    becomes 32\n   next code point to insert is 4ED6\n   needed delta is 130, encodes
    as \"8d\"\n   bias becomes 23\n   next code point to insert is 4EEC\n   needed
    delta is 154, encodes as \"qg\"\n   bias becomes 25\n   next code point to insert
    is 6587\n   needed delta is 46301, encodes as \"056p\"\n   bias becomes 84\n   next
    code point to insert is 8BF4\n   needed delta is 88531, encodes as \"qjye\"\n
    \  bias becomes 90\n   output is \"ihqwcrb4cv8a8dqg056pqjye\"\n   Encoding trace
    of example L from section 7.1:\n   bias is 72\n   input is:\n   0033 5E74 0042
    7D44 91D1 516B 5148 751F\n   basic code points (0033, 0042) are copied to literal
    portion: \"3B-\"\n   next code point to insert is 5148\n   needed delta is 62042,
    encodes as \"ww4c\"\n   bias becomes 27\n   next code point to insert is 516B\n
    \  needed delta is 139, encodes as \"5e\"\n   bias becomes 24\n   next code point
    to insert is 5E74\n   needed delta is 16683, encodes as \"180e\"\n   bias becomes
    67\n   next code point to insert is 751F\n   needed delta is 34821, encodes as
    \"575a\"\n   bias becomes 82\n   next code point to insert is 7D44\n   needed
    delta is 14592, encodes as \"65l\"\n   bias becomes 67\n   next code point to
    insert is 91D1\n   needed delta is 42088, encodes as \"sy2b\"\n   bias becomes
    84\n   output is \"3B-ww4c5e180e575a65lsy2b\"\n"
  title: 7.3 Encoding traces
- contents:
  - "8. Security Considerations\n   Users expect each domain name in DNS to be controlled
    by a single\n   authority.  If a Unicode string intended for use as a domain label\n
    \  could map to multiple ACE labels, then an internationalized domain\n   name
    could map to multiple ASCII domain names, each controlled by a\n   different authority,
    some of which could be spoofs that hijack\n   service requests intended for another.
    \ Therefore Punycode is\n   designed so that each Unicode string has a unique
    encoding.\n   However, there can still be multiple Unicode representations of
    the\n   \"same\" text, for various definitions of \"same\".  This problem is\n
    \  addressed to some extent by the Unicode standard under the topic of\n   canonicalization,
    and this work is leveraged for domain names by\n   Nameprep [NAMEPREP].\n"
  title: 8. Security Considerations
- contents:
  - '9. References

    '
  title: 9. References
- contents:
  - "9.1 Normative References\n   [RFC2119]    Bradner, S., \"Key words for use in
    RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119, March
    1997.\n"
  title: 9.1 Normative References
- contents:
  - "9.2 Informative References\n   [RFC952]     Harrenstien, K., Stahl, M. and E.
    Feinler, \"DOD Internet\n                Host Table Specification\", RFC 952,
    October 1985.\n   [RFC1034]    Mockapetris, P., \"Domain Names - Concepts and\n
    \               Facilities\", STD 13, RFC 1034, November 1987.\n   [IDNA]       Faltstrom,
    P., Hoffman, P. and A. Costello,\n                \"Internationalizing Domain
    Names in Applications\n                (IDNA)\", RFC 3490, March 2003.\n   [NAMEPREP]
    \  Hoffman, P. and  M. Blanchet, \"Nameprep: A Stringprep\n                Profile
    for Internationalized Domain Names (IDN)\", RFC\n                3491, March 2003.\n
    \  [ASCII]      Cerf, V., \"ASCII format for Network Interchange\", RFC\n                20,
    October 1969.\n   [PROVINCIAL] Kaplan, M., \"The 'anyone can be provincial!' page\",\n
    \               http://www.trigeminal.com/samples/provincial.html.\n   [UNICODE]
    \   The Unicode Consortium, \"The Unicode Standard\",\n                http://www.unicode.org/unicode/standard/standard.html.\n"
  title: 9.2 Informative References
- contents:
  - "A. Mixed-case annotation\n   In order to use Punycode to represent case-insensitive
    strings,\n   higher layers need to case-fold the strings prior to Punycode\n   encoding.
    \ The encoded string can use mixed case as an annotation\n   telling how to convert
    the folded string into a mixed-case string for\n   display purposes.  Note, however,
    that mixed-case annotation is not\n   used by the ToASCII and ToUnicode operations
    specified in [IDNA], and\n   therefore implementors of IDNA can disregard this
    appendix.\n   Basic code points can use mixed case directly, because the decoder\n
    \  copies them verbatim, leaving lowercase code points lowercase, and\n   leaving
    uppercase code points uppercase.  Each non-basic code point\n   is represented
    by a delta, which is represented by a sequence of\n   basic code points, the last
    of which provides the annotation.  If it\n   is uppercase, it is a suggestion
    to map the non-basic code point to\n   uppercase (if possible); if it is lowercase,
    it is a suggestion to\n   map the non-basic code point to lowercase (if possible).\n
    \  These annotations do not alter the code points returned by decoders;\n   the
    annotations are returned separately, for the caller to use or\n   ignore.  Encoders
    can accept annotations in addition to code points,\n   but the annotations do
    not alter the output, except to influence the\n   uppercase/lowercase form of
    ASCII letters.\n   Punycode encoders and decoders need not support these annotations,\n
    \  and higher layers need not use them.\n"
  title: A. Mixed-case annotation
- contents:
  - "B. Disclaimer and license\n   Regarding this entire document or any portion of
    it (including the\n   pseudocode and C code), the author makes no guarantees and
    is not\n   responsible for any damage resulting from its use.  The author grants\n
    \  irrevocable permission to anyone to use, modify, and distribute it in\n   any
    way that does not diminish the rights of anyone else to use,\n   modify, and distribute
    it, provided that redistributed derivative\n   works do not contain misleading
    author or version information.\n   Derivative works need not be licensed under
    similar terms.\n"
  title: B. Disclaimer and license
- contents:
  - 'C. Punycode sample implementation

    '
  - '/*

    '
  - 'punycode.c from RFC 3492

    '
  - 'http://www.nicemice.net/idn/

    '
  - 'Adam M. Costello

    '
  - 'http://www.nicemice.net/amc/

    '
  - 'This is ANSI C code (C89) implementing Punycode (RFC 3492).

    '
  - '*/

    '
  - '/************************************************************/

    '
  - '/* Public interface (would normally go in its own .h file): */

    '
  - '#include <limits.h>

    '
  - "enum punycode_status {\n  punycode_success,\n  punycode_bad_input,   /* Input
    is invalid.                       */\n  punycode_big_output,  /* Output would
    exceed the space provided. */\n  punycode_overflow     /* Input needs wider integers
    to process.  */\n"
  - '};

    '
  - '#if UINT_MAX >= (1 << 26) - 1

    '
  - 'typedef unsigned int punycode_uint;

    '
  - '#else

    '
  - 'typedef unsigned long punycode_uint;

    '
  - '#endif

    '
  - "enum punycode_status punycode_encode(\n  punycode_uint input_length,\n  const
    punycode_uint input[],\n  const unsigned char case_flags[],\n  punycode_uint *output_length,\n
    \ char output[] );\n    /* punycode_encode() converts Unicode to Punycode.  The
    input     */\n    /* is represented as an array of Unicode code points (not code
    \   */\n    /* units; surrogate pairs are not allowed), and the output        */\n
    \   /* will be represented as an array of ASCII code points.  The     */\n    /*
    output string is *not* null-terminated; it will contain        */\n    /* zeros
    if and only if the input contains zeros.  (Of course     */\n    /* the caller
    can leave room for a terminator and add one if      */\n    /* needed.)  The input_length
    is the number of code points in     */\n    /* the input.  The output_length is
    an in/out argument: the       */\n    /* caller passes in the maximum number of
    code points that it     */\n    /* can receive, and on successful return it will
    contain the      */\n    /* number of code points actually output.  The case_flags
    array   */\n    /* holds input_length boolean values, where nonzero suggests that
    */\n    /* the corresponding Unicode character be forced to uppercase     */\n
    \   /* after being decoded (if possible), and zero suggests that      */\n    /*
    it be forced to lowercase (if possible).  ASCII code points    */\n    /* are
    encoded literally, except that ASCII letters are forced    */\n    /* to uppercase
    or lowercase according to the corresponding       */\n    /* uppercase flags.
    \ If case_flags is a null pointer then ASCII   */\n    /* letters are left as
    they are, and other code points are        */\n    /* treated as if their uppercase
    flags were zero.  The return     */\n    /* value can be any of the punycode_status
    values defined above   */\n    /* except punycode_bad_input; if not punycode_success,
    then       */\n    /* output_size and output might contain garbage.                  */\n"
  - "enum punycode_status punycode_decode(\n  punycode_uint input_length,\n  const
    char input[],\n  punycode_uint *output_length,\n  punycode_uint output[],\n  unsigned
    char case_flags[] );\n    /* punycode_decode() converts Punycode to Unicode.  The
    input is  */\n    /* represented as an array of ASCII code points, and the output
    \  */\n    /* will be represented as an array of Unicode code points.  The   */\n
    \   /* input_length is the number of code points in the input.  The   */\n    /*
    output_length is an in/out argument: the caller passes in      */\n    /* the
    maximum number of code points that it can receive, and     */\n    /* on successful
    return it will contain the actual number of      */\n    /* code points output.
    \ The case_flags array needs room for at    */\n    /* least output_length values,
    or it can be a null pointer if the */\n    /* case information is not needed.
    \ A nonzero flag suggests that  */\n    /* the corresponding Unicode character
    be forced to uppercase     */\n    /* by the caller (if possible), while zero
    suggests that it be    */\n    /* forced to lowercase (if possible).  ASCII code
    points are      */\n    /* output already in the proper case, but their flags
    will be set */\n    /* appropriately so that applying the flags would be harmless.
    \   */\n    /* The return value can be any of the punycode_status values      */\n
    \   /* defined above; if not punycode_success, then output_length,    */\n    /*
    output, and case_flags might contain garbage.  On success, the */\n    /* decoder
    will never need to write an output_length greater than */\n    /* input_length,
    because of how the encoding is defined.          */\n"
  - '/**********************************************************/

    '
  - '/* Implementation (would normally go in its own .c file): */

    '
  - '#include <string.h>

    '
  - '/*** Bootstring parameters for Punycode ***/

    '
  - "enum { base = 36, tmin = 1, tmax = 26, skew = 38, damp = 700,\n       initial_bias
    = 72, initial_n = 0x80, delimiter = 0x2D };\n"
  - '/* basic(cp) tests whether cp is a basic code point: */

    '
  - '#define basic(cp) ((punycode_uint)(cp) < 0x80)

    '
  - '/* delim(cp) tests whether cp is a delimiter: */

    '
  - '#define delim(cp) ((cp) == delimiter)

    '
  - '/* decode_digit(cp) returns the numeric value of a basic code */

    '
  - '/* point (for use in representing integers) in the range 0 to */

    '
  - '/* base-1, or base if cp is does not represent a value.       */

    '
  - 'static punycode_uint decode_digit(punycode_uint cp)

    '
  - "{\n  return  cp - 48 < 10 ? cp - 22 :  cp - 65 < 26 ? cp - 65 :\n          cp
    - 97 < 26 ? cp - 97 :  base;\n"
  - '}

    '
  - '/* encode_digit(d,flag) returns the basic code point whose value      */

    '
  - '/* (when used for representing integers) is d, which needs to be in   */

    '
  - '/* the range 0 to base-1.  The lowercase form is used unless flag is  */

    '
  - '/* nonzero, in which case the uppercase form is used.  The behavior   */

    '
  - '/* is undefined if flag is nonzero and digit d has no uppercase form. */

    '
  - 'static char encode_digit(punycode_uint d, int flag)

    '
  - "{\n  return d + 22 + 75 * (d < 26) - ((flag != 0) << 5);\n  /*  0..25 map to
    ASCII a..z or A..Z */\n  /* 26..35 map to ASCII 0..9         */\n"
  - '}

    '
  - '/* flagged(bcp) tests whether a basic code point is flagged */

    '
  - '/* (uppercase).  The behavior is undefined if bcp is not a  */

    '
  - '/* basic code point.                                        */

    '
  - '#define flagged(bcp) ((punycode_uint)(bcp) - 65 < 26)

    '
  - '/* encode_basic(bcp,flag) forces a basic code point to lowercase */

    '
  - '/* if flag is zero, uppercase if flag is nonzero, and returns    */

    '
  - '/* the resulting code point.  The code point is unchanged if it  */

    '
  - '/* is caseless.  The behavior is undefined if bcp is not a basic */

    '
  - '/* code point.                                                   */

    '
  - 'static char encode_basic(punycode_uint bcp, int flag)

    '
  - "{\n  bcp -= (bcp - 97 < 26) << 5;\n  return bcp + ((!flag && (bcp - 65 < 26))
    << 5);\n"
  - '}

    '
  - '/*** Platform-specific constants ***/

    '
  - '/* maxint is the maximum value of a punycode_uint variable: */

    '
  - 'static const punycode_uint maxint = -1;

    '
  - '/* Because maxint is unsigned, -1 becomes the maximum value. */

    '
  - '/*** Bias adaptation function ***/

    '
  - "static punycode_uint adapt(\n  punycode_uint delta, punycode_uint numpoints,
    int firsttime )\n"
  - "{\n  punycode_uint k;\n  delta = firsttime ? delta / damp : delta >> 1;\n  /*
    delta >> 1 is a faster way of doing delta / 2 */\n  delta += delta / numpoints;\n
    \ for (k = 0;  delta > ((base - tmin) * tmax) / 2;  k += base) {\n    delta /=
    base - tmin;\n  }\n  return k + (base - tmin + 1) * delta / (delta + skew);\n"
  - '}

    '
  - '/*** Main encode function ***/

    '
  - "enum punycode_status punycode_encode(\n  punycode_uint input_length,\n  const
    punycode_uint input[],\n  const unsigned char case_flags[],\n  punycode_uint *output_length,\n
    \ char output[] )\n"
  - "{\n  punycode_uint n, delta, h, b, out, max_out, bias, j, m, q, k, t;\n  /* Initialize
    the state: */\n  n = initial_n;\n  delta = out = 0;\n  max_out = *output_length;\n
    \ bias = initial_bias;\n  /* Handle the basic code points: */\n  for (j = 0;  j
    < input_length;  ++j) {\n    if (basic(input[j])) {\n      if (max_out - out <
    2) return punycode_big_output;\n      output[out++] =\n        case_flags ?  encode_basic(input[j],
    case_flags[j]) : input[j];\n    }\n    /* else if (input[j] < n) return punycode_bad_input;
    */\n    /* (not needed for Punycode with unsigned code points) */\n  }\n  h =
    b = out;\n  /* h is the number of code points that have been handled, b is the
    \ */\n  /* number of basic code points, and out is the number of characters */\n
    \ /* that have been output.                                           */\n  if
    (b > 0) output[out++] = delimiter;\n  /* Main encoding loop: */\n  while (h <
    input_length) {\n    /* All non-basic code points < n have been     */\n    /*
    handled already.  Find the next larger one: */\n    for (m = maxint, j = 0;  j
    < input_length;  ++j) {\n      /* if (basic(input[j])) continue; */\n      /*
    (not needed for Punycode) */\n      if (input[j] >= n && input[j] < m) m = input[j];\n
    \   }\n    /* Increase delta enough to advance the decoder's    */\n    /* <n,i>
    state to <m,0>, but guard against overflow: */\n    if (m - n > (maxint - delta)
    / (h + 1)) return punycode_overflow;\n    delta += (m - n) * (h + 1);\n    n =
    m;\n    for (j = 0;  j < input_length;  ++j) {\n      /* Punycode does not need
    to check whether input[j] is basic: */\n      if (input[j] < n /* || basic(input[j])
    */ ) {\n        if (++delta == 0) return punycode_overflow;\n      }\n      if
    (input[j] == n) {\n        /* Represent delta as a generalized variable-length
    integer: */\n        for (q = delta, k = base;  ;  k += base) {\n          if
    (out >= max_out) return punycode_big_output;\n          t = k <= bias /* + tmin
    */ ? tmin :     /* +tmin not needed */\n              k >= bias + tmax ? tmax
    : k - bias;\n          if (q < t) break;\n          output[out++] = encode_digit(t
    + (q - t) % (base - t), 0);\n          q = (q - t) / (base - t);\n        }\n
    \       output[out++] = encode_digit(q, case_flags && case_flags[j]);\n        bias
    = adapt(delta, h + 1, h == b);\n        delta = 0;\n        ++h;\n      }\n    }\n
    \   ++delta, ++n;\n  }\n  *output_length = out;\n  return punycode_success;\n"
  - '}

    '
  - '/*** Main decode function ***/

    '
  - "enum punycode_status punycode_decode(\n  punycode_uint input_length,\n  const
    char input[],\n  punycode_uint *output_length,\n  punycode_uint output[],\n  unsigned
    char case_flags[] )\n"
  - "{\n  punycode_uint n, out, i, max_out, bias,\n                 b, j, in, oldi,
    w, k, digit, t;\n  /* Initialize the state: */\n  n = initial_n;\n  out = i =
    0;\n  max_out = *output_length;\n  bias = initial_bias;\n  /* Handle the basic
    code points:  Let b be the number of input code */\n  /* points before the last
    delimiter, or 0 if there is none, then    */\n  /* copy the first b code points
    to the output.                      */\n  for (b = j = 0;  j < input_length;  ++j)
    if (delim(input[j])) b = j;\n  if (b > max_out) return punycode_big_output;\n
    \ for (j = 0;  j < b;  ++j) {\n    if (case_flags) case_flags[out] = flagged(input[j]);\n
    \   if (!basic(input[j])) return punycode_bad_input;\n    output[out++] = input[j];\n
    \ }\n  /* Main decoding loop:  Start just after the last delimiter if any  */\n
    \ /* basic code points were copied; start at the beginning otherwise. */\n  for
    (in = b > 0 ? b + 1 : 0;  in < input_length;  ++out) {\n    /* in is the index
    of the next character to be consumed, and */\n    /* out is the number of code
    points in the output array.     */\n    /* Decode a generalized variable-length
    integer into delta,  */\n    /* which gets added to i.  The overflow checking
    is easier   */\n    /* if we increase i as we go, then subtract off its starting
    */\n    /* value at the end to obtain delta.                         */\n    for
    (oldi = i, w = 1, k = base;  ;  k += base) {\n      if (in >= input_length) return
    punycode_bad_input;\n      digit = decode_digit(input[in++]);\n      if (digit
    >= base) return punycode_bad_input;\n      if (digit > (maxint - i) / w) return
    punycode_overflow;\n      i += digit * w;\n      t = k <= bias /* + tmin */ ?
    tmin :     /* +tmin not needed */\n          k >= bias + tmax ? tmax : k - bias;\n
    \     if (digit < t) break;\n      if (w > maxint / (base - t)) return punycode_overflow;\n
    \     w *= (base - t);\n    }\n    bias = adapt(i - oldi, out + 1, oldi == 0);\n
    \   /* i was supposed to wrap around from out+1 to 0,   */\n    /* incrementing
    n each time, so we'll fix that now: */\n    if (i / (out + 1) > maxint - n) return
    punycode_overflow;\n    n += i / (out + 1);\n    i %= (out + 1);\n    /* Insert
    n at position i of the output: */\n    /* not needed for Punycode: */\n    /*
    if (decode_digit(n) <= base) return punycode_invalid_input; */\n    if (out >=
    max_out) return punycode_big_output;\n    if (case_flags) {\n      memmove(case_flags
    + i + 1, case_flags + i, out - i);\n      /* Case of last character determines
    uppercase flag: */\n      case_flags[i] = flagged(input[in - 1]);\n    }\n    memmove(output
    + i + 1, output + i, (out - i) * sizeof *output);\n    output[i++] = n;\n  }\n
    \ *output_length = out;\n  return punycode_success;\n"
  - '}

    '
  - '/******************************************************************/

    '
  - '/* Wrapper for testing (would normally go in a separate .c file): */

    '
  - '#include <assert.h>

    '
  - '#include <stdio.h>

    '
  - '#include <stdlib.h>

    '
  - '#include <string.h>

    '
  - '/* For testing, we''ll just set some compile-time limits rather than */

    '
  - '/* use malloc(), and set a compile-time option rather than using a  */

    '
  - '/* command-line option.                                             */

    '
  - "enum {\n  unicode_max_length = 256,\n  ace_max_length = 256\n"
  - '};

    '
  - 'static void usage(char **argv)

    '
  - "{\n  fprintf(stderr,\n    \"\\n\"\n    \"%s -e reads code points and writes a
    Punycode string.\\n\"\n    \"%s -d reads a Punycode string and writes code points.\\n\"\n
    \   \"\\n\"\n    \"Input and output are plain text in the native character set.\\n\"\n
    \   \"Code points are in the form u+hex separated by whitespace.\\n\"\n    \"Although
    the specification allows Punycode strings to contain\\n\"\n    \"any characters
    from the ASCII repertoire, this test code\\n\"\n    \"supports only the printable
    characters, and needs the Punycode\\n\"\n    \"string to be followed by a newline.\\n\"\n
    \   \"The case of the u in u+hex is the force-to-uppercase flag.\\n\"\n    , argv[0],
    argv[0]);\n  exit(EXIT_FAILURE);\n"
  - '}

    '
  - 'static void fail(const char *msg)

    '
  - "{\n  fputs(msg,stderr);\n  exit(EXIT_FAILURE);\n"
  - '}

    '
  - "static const char too_big[] =\n  \"input or output is too large, recompile with
    larger limits\\n\";\n"
  - 'static const char invalid_input[] = "invalid input\n";

    '
  - 'static const char overflow[] = "arithmetic overflow\n";

    '
  - 'static const char io_error[] = "I/O error\n";

    '
  - '/* The following string is used to convert printable */

    '
  - '/* characters between ASCII and the native charset:  */

    '
  - "static const char print_ascii[] =\n  \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"\n
    \ \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"\n  \" !\\\"#$%&'()*+,-./\"\n
    \ \"0123456789:;<=>?\"\n  \"@ABCDEFGHIJKLMNO\"\n  \"PQRSTUVWXYZ[\\\\]^_\"\n  \"`abcdefghijklmno\"\n
    \ \"pqrstuvwxyz{|}~\\n\";\n"
  - 'int main(int argc, char **argv)

    '
  - "{\n  enum punycode_status status;\n  int r;\n  unsigned int input_length, output_length,
    j;\n  unsigned char case_flags[unicode_max_length];\n  if (argc != 2) usage(argv);\n
    \ if (argv[1][0] != '-') usage(argv);\n  if (argv[1][2] != 0) usage(argv);\n  if
    (argv[1][1] == 'e') {\n    punycode_uint input[unicode_max_length];\n    unsigned
    long codept;\n    char output[ace_max_length+1], uplus[3];\n    int c;\n    /*
    Read the input code points: */\n    input_length = 0;\n    for (;;) {\n      r
    = scanf(\"%2s%lx\", uplus, &codept);\n      if (ferror(stdin)) fail(io_error);\n
    \     if (r == EOF || r == 0) break;\n      if (r != 2 || uplus[1] != '+' || codept
    > (punycode_uint)-1) {\n        fail(invalid_input);\n      }\n      if (input_length
    == unicode_max_length) fail(too_big);\n      if (uplus[0] == 'u') case_flags[input_length]
    = 0;\n      else if (uplus[0] == 'U') case_flags[input_length] = 1;\n      else
    fail(invalid_input);\n      input[input_length++] = codept;\n    }\n    /* Encode:
    */\n    output_length = ace_max_length;\n    status = punycode_encode(input_length,
    input, case_flags,\n                             &output_length, output);\n    if
    (status == punycode_bad_input) fail(invalid_input);\n    if (status == punycode_big_output)
    fail(too_big);\n    if (status == punycode_overflow) fail(overflow);\n    assert(status
    == punycode_success);\n    /* Convert to native charset and output: */\n    for
    (j = 0;  j < output_length;  ++j) {\n      c = output[j];\n      assert(c >= 0
    && c <= 127);\n      if (print_ascii[c] == 0) fail(invalid_input);\n      output[j]
    = print_ascii[c];\n    }\n    output[j] = 0;\n    r = puts(output);\n    if (r
    == EOF) fail(io_error);\n    return EXIT_SUCCESS;\n  }\n  if (argv[1][1] == 'd')
    {\n    char input[ace_max_length+2], *p, *pp;\n    punycode_uint output[unicode_max_length];\n
    \   /* Read the Punycode input string and convert to ASCII: */\n    fgets(input,
    ace_max_length+2, stdin);\n    if (ferror(stdin)) fail(io_error);\n    if (feof(stdin))
    fail(invalid_input);\n    input_length = strlen(input) - 1;\n    if (input[input_length]
    != '\\n') fail(too_big);\n    input[input_length] = 0;\n    for (p = input;  *p
    != 0;  ++p) {\n      pp = strchr(print_ascii, *p);\n      if (pp == 0) fail(invalid_input);\n
    \     *p = pp - print_ascii;\n    }\n    /* Decode: */\n    output_length = unicode_max_length;\n
    \   status = punycode_decode(input_length, input, &output_length,\n                             output,
    case_flags);\n    if (status == punycode_bad_input) fail(invalid_input);\n    if
    (status == punycode_big_output) fail(too_big);\n    if (status == punycode_overflow)
    fail(overflow);\n    assert(status == punycode_success);\n    /* Output the result:
    */\n    for (j = 0;  j < output_length;  ++j) {\n      r = printf(\"%s+%04lX\\n\",\n
    \                case_flags[j] ? \"U\" : \"u\",\n                 (unsigned long)
    output[j] );\n      if (r < 0) fail(io_error);\n    }\n    return EXIT_SUCCESS;\n
    \ }\n  usage(argv);\n  return EXIT_SUCCESS;  /* not reached, but quiets compiler
    warning */\n"
  - '}

    '
  title: C. Punycode sample implementation
- contents:
  - "Author's Address\n   Adam M. Costello\n   University of California, Berkeley\n
    \  http://www.nicemice.net/amc/\n"
  title: Author's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2003).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
