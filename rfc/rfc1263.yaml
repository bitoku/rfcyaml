- title: __initial_text__
  contents:
  - '                   TCP EXTENSIONS CONSIDERED HARMFUL

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard.  Distribution of this document\
    \ is\n   unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This RFC comments on recent proposals to extend TCP.  It argues\
    \ that\n   the backward compatible extensions proposed in RFC's 1072 and 1185\n\
    \   should not be pursued, and proposes an alternative way to evolve the\n   Internet\
    \ protocol suite.  Its purpose is to stimulate discussion in\n   the Internet\
    \ community.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The rapid growth of the size, capacity, and complexity of\
    \ the\n   Internet has led to the need to change the existing protocol suite.\n\
    \   For example, the maximum TCP window size is no longer sufficient to\n   efficiently\
    \ support the high capacity links currently being planned\n   and constructed.\
    \ One is then faced with the choice of either leaving\n   the protocol alone and\
    \ accepting the fact that TCP will run no faster\n   on high capacity links than\
    \ on low capacity links, or changing TCP.\n   This is not an isolated incident.\
    \ We have counted at least eight\n   other proposed changes to TCP (some to be\
    \ taken more seriously than\n   others), and the question is not whether to change\
    \ the protocol\n   suite, but what is the most cost effective way to change it.\n\
    \   This RFC compares the costs and benefits of three approaches to\n   making\
    \ these changes: the creation of new protocols, backward\n   compatible protocol\
    \ extensions, and protocol evolution. The next\n   section introduces these three\
    \ approaches and enumerates the\n   strengths and weaknesses of each.  The following\
    \ section describes\n   how we believe these three approaches are best applied\
    \ to the many\n   proposed changes to TCP. Note that we have not written this\
    \ RFC as an\n   academic exercise.  It is our intent to argue against acceptance\
    \ of\n   the various TCP extensions, most notably RFC's 1072 and 1185 [4,5],\n\
    \   by describing a more palatable alternative.\n"
- title: 2.  Creation vs. Extension vs. Evolution
  contents:
  - '2.  Creation vs. Extension vs. Evolution

    '
- title: 2.1.  Protocol Creation
  contents:
  - "2.1.  Protocol Creation\n   Protocol creation involves the design, implementation,\n\
    \   standardization, and distribution of an entirely new protocol. In\n   this\
    \ context, there are two basic reasons for creating a new\n   protocol. The first\
    \ is to replace an old protocol that is so outdated\n   that it can no longer\
    \ be effectively extended to perform its original\n   function.  The second is\
    \ to add a new protocol because users are\n   making demands upon the original\
    \ protocol that were not envisioned by\n   the designer and cannot be efficiently\
    \ handled in terms of the\n   original protocol.  For example, TCP was designed\
    \ as a reliable\n   byte-stream protocol but is commonly used as both a reliable\
    \ record-\n   stream protocol and a reliable request-reply protocol due to the\
    \ lack\n   of such protocols in the Internet protocol suite.  The performance\n\
    \   demands placed upon a byte-stream protocol in the new Internet\n   environment\
    \ makes it difficult to extend TCP to meet these new\n   application demands.\n\
    \   The advantage of creating a new protocol is the ability to start with\n  \
    \ a clean sheet of paper when attempting to solve a complex network\n   problem.\
    \  The designer, free from the constraints of an existing\n   protocol, can take\
    \ maximum advantage of modern network research in\n   the basic algorithms needed\
    \ to solve the problem. Even more\n   importantly, the implementor is free to\
    \ steal from a large number of\n   existing academic protocols that have been\
    \ developed over the years.\n   In some cases, if truly new functionality is desired,\
    \ creating a new\n   protocol is the only viable approach.\n   The most obvious\
    \ disadvantage of this approach is the high cost of\n   standardizing and distributing\
    \ an entirely new protocol.  Second,\n   there is the issue of making the new\
    \ protocol reliable. Since new\n   protocols have not undergone years of network\
    \ stress testing, they\n   often contain bugs which require backward compatible\
    \ fixes, and\n   hence, the designer is back where he or she started.  A third\n\
    \   disadvantage of introducing new protocols is that they generally have\n  \
    \ new interfaces which require significant effort on the part of the\n   Internet\
    \ community to use. This alone is often enough to kill a new\n   protocol.\n \
    \  Finally, there is a subtle problem introduced by the very freedom\n   provided\
    \ by this approach. Specifically, being able to introduce a\n   new protocol often\
    \ results in protocols that go far beyond the basic\n   needs of the situation.\
    \  New protocols resemble Senate appropriations\n   bills; they tend to accumulate\
    \ many amendments that have nothing to\n   do with the original problem. A good\
    \ example of this phenomena is the\n   attempt to standardize VMTP [1] as the\
    \ Internet RPC protocol. While\n   VMTP was a large protocol to begin with, the\
    \ closer it got to\n   standardization the more features were added until it essentially\n\
    \   collapsed under its own weight. As we argue below, new protocols\n   should\
    \ initially be minimal, and then evolve as the situation\n   dictates.\n"
- title: 2.2.  Backward Compatible Extensions
  contents:
  - "2.2.  Backward Compatible Extensions\n   In a backward compatible extension,\
    \ the protocol is modified in such\n   a fashion that the new version of the protocol\
    \ can transparently\n   inter-operate with existing versions of the protocol.\
    \ This generally\n   implies no changes to the protocol's header. TCP slow start\
    \ [3] is an\n   example of such a change. In a slightly more relaxed version of\n\
    \   backward compatibility, no changes are made to the fixed part of a\n   protocol's\
    \ header. Instead, either some fields are added to the\n   variable length options\
    \ field found at the end of the header, or\n   existing header fields are overloaded\
    \ (i.e., used for multiple\n   purposes). However, we can find no real advantage\
    \ to this technique\n   over simply changing the protocol.\n   Backward compatible\
    \ extensions are widely used to modify protocols\n   because there is no need\
    \ to synchronize the distribution of the new\n   version of the protocol. The\
    \ new version is essentially allowed to\n   diffuse through the Internet at its\
    \ own pace, and at least in theory,\n   the Internet will continue to function\
    \ as before. Thus, the explicit\n   distribution costs are limited. Backward compatible\
    \ extensions also\n   avoid the bureaucratic costs of standardizing a new protocol.\
    \ TCP is\n   still TCP and the approval cost of a modification to an existing\n\
    \   protocol is much less than that of a new protocol. Finally, the very\n   difficulty\
    \ of making such changes tends to restrict the changes to\n   the minimal set\
    \ needed to solve the current problem. Thus, it is rare\n   to see unneeded changes\
    \ made when using this technique.\n   Unfortunately, this approach has several\
    \ drawbacks. First, the time\n   to distribute the new version of the protocol\
    \ to all hosts can be\n   quite long (forever in fact). This leaves the network\
    \ in a\n   heterogeneous state for long periods of time. If there is the\n   slightest\
    \ incompatibly between old and new versions, chaos can\n   result. Thus, the implicit\
    \ cost of this type of distribution can be\n   quite high. Second, designing a\
    \ backward compatible change to a new\n   protocol is extremely difficult, and\
    \ the implementations \"tend toward\n   complexity and ugliness\" [5]. The need\
    \ for backward compatibility\n   ensures that no code can every really be eliminated\
    \ from the\n   protocol, and since such vestigial code is rarely executed, it\
    \ is\n   often wrong. Finally, most protocols have limits, based upon the\n  \
    \ design decisions of it inventors, that simply cannot be side-stepped\n   in\
    \ this fashion.\n"
- title: 2.3.  Protocol Evolution
  contents:
  - "2.3.  Protocol Evolution\n   Protocol evolution is an approach to protocol change\
    \ that attempts to\n   escape the limits of backward compatibility without incurring\
    \ all of\n   the costs of creating new protocols. The basic idea is for the\n\
    \   protocol designer to take an existing protocol that requires\n   modification\
    \ and make the desired changes without maintaining\n   backward compatibility.\
    \  This drastically simplifies the job of the\n   protocol designer. For example,\
    \ the limited TCP window size could be\n   fixed by changing the definition of\
    \ the window size in the header\n   from 16-bits to 32-bits, and re-compiling\
    \ the protocol. The effect of\n   backward compatibility would be ensured by simply\
    \ keeping both the\n   new and old version of the protocol running until most\
    \ machines use\n   the new version. Since the change is small and invisible to\
    \ the user\n   interface, it is a trivial problem to dynamically select the correct\n\
    \   TCP version at runtime. How this is done is discussed in the next\n   section.\n\
    \   Protocol evolution has several advantages. First, it is by far the\n   simplest\
    \ type of modification to make to a protocol, and hence, the\n   modifications\
    \ can be made faster and are less likely to contain bugs.\n   There is no need\
    \ to worry about the effects of the change on all\n   previous versions of the\
    \ protocol. Also, most of the protocol is\n   carried over into the new version\
    \ unchanged, thus avoiding the design\n   and debugging cost of creating an entirely\
    \ new protocol. Second,\n   there is no artificial limit to the amount of change\
    \ that can be made\n   to a protocol, and as a consequence, its useful lifetime\
    \ can be\n   extended indefinitely. In a series of evolutionary steps, it is\n\
    \   possible to make fairly radical changes to a protocol without\n   upsetting\
    \ the Internet community greatly. Specifically, it is\n   possible to both add\
    \ new features and remove features that are no\n   longer required for the current\
    \ environment.  Thus, the protocol is\n   not condemned to grow without bound.\
    \ Finally, by keeping the old\n   version of the protocol around, backward compatibility\
    \ is guaranteed.\n   The old code will work as well as it ever did.\n   Assuming\
    \ the infrastructure described in the following subsection,\n   the only real\
    \ disadvantage of protocol evolution is the amount of\n   memory required to run\
    \ several versions of the same protocol.\n   Fortunately, memory is not the scarcest\
    \ resource in modern\n   workstations (it may, however, be at a premium in the\
    \ BSD kernel and\n   its derivatives). Since old versions may rarely if ever be\
    \ executed,\n   the old versions can be swapped out to disk with little performance\n\
    \   loss. Finally, since this cost is explicit, there is a huge incentive\n  \
    \ to eliminate old protocol versions from the network.\n"
- title: 2.4.  Infrastructure Support for Protocol Evolution
  contents:
  - "2.4.  Infrastructure Support for Protocol Evolution\n   The effective use of\
    \ protocol evolution implies that each protocol is\n   considered a vector of\
    \ implementations which share the same top level\n   interface, and perhaps not\
    \ much else.  TCP[0] is the current\n   implementation of TCP and exists to provide\
    \ backward compatibility\n   with all existing machines. TCP[1] is a version of\
    \ TCP that is\n   optimized for high-speed networks.  TCP[0] is always present;\
    \ TCP[1]\n   may or may not be. Treating TCP as a vector of protocols requires\n\
    \   only three changes to the way protocols are designed and implemented.\n  \
    \ First, each version of TCP is assigned a unique id, but this id is\n   not given\
    \ as an IP protocol number. (This is because IP's protocol\n   number field is\
    \ only 8 bits long and could easily be exhausted.)  The\n   \"obvious\" solution\
    \ to this limitation is to increase IP's protocol\n   number field to 32 bits.\
    \ In this case, however, the obvious solution\n   is wrong, not because of the\
    \ difficultly of changing IP, but simply\n   because there is a better approach.\
    \ The best way to deal with this\n   problem is to increase the IP protocol number\
    \ field to 32 bits and\n   move it to the very end of the IP header (i.e., the\
    \ first four bytes\n   of the TCP header).  A backward compatible modification\
    \ would be made\n   to IP such that for all packets with a special protocol number,\
    \ say\n   77, IP would look into the four bytes following its header for its\n\
    \   de-multiplexing information. On systems which do not support a\n   modified\
    \ IP, an actual protocol 77 would be used to perform the de-\n   multiplexing\
    \ to the correct TCP version.\n   Second, a version control protocol, called VTCP,\
    \ is used to select\n   the appropriate version of TCP for a particular connection.\
    \ VTCP is\n   an example of a virtual protocol as introduced in [2]. Application\n\
    \   programs access the various versions of TCP through VTCP. When a TCP\n   connection\
    \ is opened to a specific machine, VTCP checks its local\n   cache to determine\
    \ the highest common version shared by the two\n   machines. If the target machine\
    \ is in the cache, it opens that\n   version of TCP and returns the connection\
    \ to the protocol above and\n   does not effect performance. If the target machine\
    \ is not found in\n   the cache, VTCP sends a UDP packet to the other machine\
    \ asking what\n   versions of TCP that machine supports. If it receives a response,\
    \ it\n   uses that information to select a version and puts the information in\n\
    \   the cache.  If no reply is forthcoming, it assumes that the other\n   machine\
    \ does not support VTCP and attempts to open a TCP[0]\n   connection. VTCP's cache\
    \ is flushed occasionally to ensure that its\n   information is current.\n   Note\
    \ that this is only one possible way for VTCP to decide the right\n   version\
    \ of TCP to use. Another possibility is for VTCP to learn the\n   right version\
    \ for a particular host when it resolves the host's name.\n   That is, version\
    \ information could be stored in the Domain Name\n   System. It is also possible\
    \ that VTCP might take the performance\n   characteristics of the network into\
    \ consideration when selecting a\n   version; TCP[0] may in fact turn out to be\
    \ the correct choice for a\n   low-bandwidth network.\n   Third, because our proposal\
    \ would lead to a more dynamically changing\n   network architecture, a mechanism\
    \ for distributing new versions will\n   need to be developed. This is clearly\
    \ the hardest requirement of the\n   infrastructure, but we believe that it can\
    \ be addressed in stages.\n   More importantly, we believe this problem can be\
    \ addressed after the\n   decision has been made to go the protocol evolution\
    \ route.  In the\n   short term, we are considering only a single new version\
    \ of TCP---\n   TCP[1]. This version can be distributed in the same ad hoc way,\
    \ and\n   at exactly the same cost, as the backward compatible changes\n   suggested\
    \ in RFC's 1072 and 1185.\n   In the medium term, we envision the IAB approving\
    \ new versions of TCP\n   every year or so. Given this scenario, a simple distribution\n\
    \   mechanism can be designed based on software distribution mechanisms\n   that\
    \ have be developed for other environments; e.g., Unix RDIST and\n   Mach SUP.\
    \  Such a mechanism need not be available on all hosts.\n   Instead, hosts will\
    \ be divided into two sets, those that can quickly\n   be updated with new protocols\
    \ and those that cannot.  High\n   performance machines that can use high performance\
    \ networks will need\n   the most current version of TCP as soon as it is available,\
    \ thus they\n   have incentive to change.  Old machines which are too slow to\
    \ drive a\n   high capacity lines can be ignored, and probably should be ignored.\n\
    \   In the long term, we envision protocols being designed on an\n   application\
    \ by application basis, without the need for central\n   approval. In such a world,\
    \ a common protocol implementation\n   environment---a protocol backplane---is\
    \ the right way to go.  Given\n   such a backplane, protocols can be automatically\
    \ installed over the\n   network. While we claim to know how to build such an\
    \ environment,\n   such a discussion is beyond the scope of this paper.\n"
- title: 2.5.  Remarks
  contents:
  - "2.5.  Remarks\n   Each of these three methods has its advantages.  When used\
    \ in\n   combination, the result is better protocols at a lower overall cost.\n\
    \   Backward compatible changes are best reserved for changes that do not\n  \
    \ affect the protocol's header, and do not require that the instance\n   running\
    \ on the other end of the connection also be changed.  Protocol\n   evolution\
    \ should be the primary way of dealing with header fields\n   that are no longer\
    \ large enough, or when one algorithm is substituted\n   directly for another.\
    \  New protocols should be written to off load\n   unexpected user demands on\
    \ existing protocols, or better yet, to\n   catch them before they start.\n  \
    \ There are also synergistic effects. First, since we know it is\n   possible\
    \ to evolve a newly created protocol once it has been put in\n   place, the pressure\
    \ to add unnecessary features should be reduced.\n   Second, the ability to create\
    \ new protocols removes the pressure to\n   overextend a given protocol. Finally,\
    \ the ability to evolve a\n   protocol removes the pressure to maintain backward\
    \ compatibility\n   where it is really not possible.\n"
- title: '3.  TCP Extensions: A Case Study'
  contents:
  - "3.  TCP Extensions: A Case Study\n   This section examines the effects of using\
    \ our proposed methodology\n   to implement changes to TCP. We will begin by analyzing\
    \ the backward\n   compatible extensions defined in RFC's 1072 and 1185, and proposing\
    \ a\n   set of much simpler evolutionary modifications. We also analyze\n   several\
    \ more problematical extensions to TCP, such as Transactional\n   TCP. Finally,\
    \ we point our some areas of TCP which may require\n   changes in the future.\n\
    \   The evolutionary modification to TCP that we propose includes all of\n   the\
    \ functionality described in RFC's 1072 and 1185, but does not\n   preserve the\
    \ header format.  At the risk of being misunderstood as\n   believing backward\
    \ compatibility is a good idea, we also show how our\n   proposed changes to TCP\
    \ can be folded into a backward compatible\n   implementation of TCP.  We do this\
    \ as a courtesy for those readers\n   that cannot accept the possibility of multiple\
    \ versions of TCP.\n"
- title: 3.1.  RFC's 1072 and 1185
  contents:
  - "3.1.  RFC's 1072 and 1185\n   3.1.1.  Round Trip Timing\n   In RFC 1072, a new\
    \ ECHO option is proposed that allows each TCP\n   packet to carry a timestamp\
    \ in its header.  This timestamp is used to\n   keep a more accurate estimate\
    \ of the RTT (round trip time) used to\n   decide when to re-transmit segments.\
    \ In the original TCP algorithm,\n   the sender manually times a small number\
    \ of sends. The resulting\n   algorithm was quite complex and does not produce\
    \ an accurate enough\n   RTT for high capacity networks. The inclusion of a timestamp\
    \ in every\n   header both simplifies the code needed to calculate the RTT and\n\
    \   improves the accuracy and robustness of the algorithm.\n   The new algorithm\
    \ as proposed in RFC 1072 does not appear to have any\n   serious problems. However,\
    \ the authors of RFC 1072 go to great\n   lengths in an attempt to keep this modification\
    \ backward compatible\n   with the previous version of TCP. They place an ECHO\
    \ option in the\n   SYN segment and state, \"It is likely that most implementations\
    \ will\n   properly ignore any options in the SYN segment that they do not\n \
    \  understand, so new initial options should not cause problems\" [4].\n   This\
    \ statement does not exactly inspire confidence, and we consider\n   the addition\
    \ of an optional field to any protocol to be a de-facto,\n   if not a de-jure,\
    \ example of an evolutionary change. Optional fields\n   simply attempt to hide\
    \ the basic incompatibility inside the protocol,\n   it does not eliminate it.\
    \  Therefore, since we are making an\n   evolutionary change anyway, the only\
    \ modification to the proposed\n   algorithm is to move the fields into the header\
    \ proper.  Thus, each\n   header will contain 32-bit echo and echo reply fields.\
    \ Two fields are\n   needed to handle bi-directional data streams.\n   3.1.2.\
    \  Window Size and Sequence Number Space\n   Long Fat Networks (LFN's), networks\
    \ which contain very high capacity\n   lines with very high latency, introduce\
    \ the possibility that the\n   number of bits in transit (the bandwidth-delay\
    \ product) could exceed\n   the TCP window size, thus making TCP the limiting\
    \ factor in network\n   performance.  Worse yet, the time it takes the sequence\
    \ numbers to\n   wrap around could be reduced to a point below the MSL (maximum\n\
    \   segment lifetime), introducing the possibility of old packets being\n   mistakenly\
    \ accepted as new.\n   RFC 1072 extends the window size through the use of an\
    \ implicit\n   constant scaling factor. The window size in the TCP header is\n\
    \   multiplied by this factor to get the true window size.  This\n   algorithm\
    \ has three problems. First, one must prove that at all times\n   the implicit\
    \ scaling factor used by the sender is the same as the\n   receiver.  The proposed\
    \ algorithm appears to do so, but the\n   complexity of the algorithm creates\
    \ the opportunity for poor\n   implementations to affect the correctness of TCP.\
    \  Second, the use of\n   a scaling factor complicates the TCP implementation\
    \ in general, and\n   can have serious effects on other parts of the protocol.\n\
    \   A final problem is what we characterize as the \"quantum window\n   sizing\"\
    \ problem. Assuming that the scaling factors will be powers of\n   two, the algorithm\
    \ right shifts the receiver's window before sending\n   it.  This effectively\
    \ rounds the window size down to the nearest\n   multiple of the scaling factor.\
    \ For large scaling factors, say 64k,\n   this implies that window values are\
    \ all multiples of 64k and the\n   minimum window size is 64k; advertising a smaller\
    \ window is\n   impossible. While this is not necessarily a problem (and it seems\
    \ to\n   be an extreme solution to the silly window syndrome) what effect this\n\
    \   will have on the performance of high-speed network links is anyone's\n   guess.\
    \ We can imagine this extension leading to future papers\n   entitled \"A Quantum\
    \ Mechanical Approach to Network Performance\".\n   RFC 1185 is an attempt to\
    \ get around the problem of the window\n   wrapping too quickly without explicitly\
    \ increasing the sequence\n   number space.  Instead, the RFC proposes to use\
    \ the timestamp used in\n   the ECHO option to weed out old duplicate messages.\
    \ The algorithm\n   presented in RFC 1185 is complex and has been shown to be\
    \ seriously\n   flawed at a recent End-to-End Research Group meeting.  Attempts\
    \ are\n   currently underway to fix the algorithm presented in the RFC. We\n \
    \  believe that this is a serious mistake.\n   We see two problems with this approach\
    \ on a very fundamental level.\n   First, we believe that making TCP depend on\
    \ accurate clocks for\n   correctness to be a mistake. The Internet community\
    \ has NO experience\n   with transport protocols that depend on clocks for correctness.\n\
    \   Second, the proposal uses two distinct schemes to deal with old\n   duplicate\
    \ packets: the sliding window algorithm takes care of \"new\"\n   old packets\
    \ (packets from the current sequence number epoch) and the\n   timestamp algorithm\
    \ deals with \"old\" old packets (packets from\n   previous sequence number epochs).\
    \ It is hard enough getting one of\n   these schemes to work much less to get\
    \ two to work and ensure that\n   they do not interfere with one another.\n  \
    \ In RFC 1185, the statement is made that \"An obvious fix for the\n   problem\
    \ of cycling the sequence number space is to increase the size\n   of the TCP\
    \ sequence number field.\" Using protocol evolution, the\n   obvious fix is also\
    \ the correct one. The window size can be increased\n   to 32 bits by simply changing\
    \ a short to a long in the definition of\n   the TCP header. At the same time,\
    \ the sequence number and\n   acknowledgment fields can be increased to 64 bits.\
    \  This change is\n   the minimum complexity modification to get the job done\
    \ and requires\n   little or no analysis to be shown to work correctly.\n   On\
    \ machines that do not support 64-bit integers, increasing the\n   sequence number\
    \ size is not as trivial as increasing the window size.\n   However, it is identical\
    \ in cost to the modification proposed in RFC\n   1185; the high order bits can\
    \ be thought of as an optimal clock that\n   ticks only when it has to.  Also,\
    \ because we are not dealing with\n   real time, the problems with unreliable\
    \ system clocks is avoided.  On\n   machines that support 64-bit integers, the\
    \ original TCP code may be\n   reused.  Since only very high performance machines\
    \ can hope to drive\n   a communications network at the rates this modification\
    \ is designed\n   to support, and the new generation of RISC microprocessors (e.g.,\n\
    \   MIPS R4000 and PA-RISC) do support 64-bit integers, the assumption of\n  \
    \ 64-bit arithmetic may be more of an advantage than a liability.\n   3.1.3. \
    \ Selective Retransmission\n   Another problem with TCP's support for LFN's is\
    \ that the sliding\n   window algorithm used by TCP does not support any form\
    \ of selective\n   acknowledgment. Thus, if a segment is lost, the total amount\
    \ of data\n   that must be re-transmitted is some constant times the bandwidth-\n\
    \   delay product, despite the fact that most of the segments have in\n   fact\
    \ arrived at the receiver.  RFC 1072 proposes to extend TCP to\n   allow the receiver\
    \ to return partial acknowledgments to the sender in\n   the hope that the sender\
    \ will use that information to avoid\n   unnecessary re-transmissions.\n   It\
    \ has been our experience on predictable local area networks that\n   the performance\
    \ of partial re-transmission strategies is highly non-\n   obvious, and it generally\
    \ requires more than one iteration to find a\n   decent algorithm. It is therefore\
    \ not surprising that the algorithm\n   proposed in RFC 1072 has some problems.\
    \  The proposed TCP extension\n   allows the receiver to include a short list\
    \ of received fragments\n   with every ACK.  The idea being that when the receiver\
    \ sends back a\n   normal ACK, it checks its queue of segments that have been\
    \ received\n   out of order and sends the relative sequence numbers of contiguous\n\
    \   blocks of segments back to the sender. The sender then uses this\n   information\
    \ to re-transmit the segments transmitted but not listed in\n   the ACK.\n   As\
    \ specified, this algorithm has two related problems: (1) it ignores\n   the relative\
    \ frequencies of delivered and dropped packets, and (2)\n   the list provided\
    \ in the option field is probably too short to do\n   much good on networks with\
    \ large bandwidth-delay products.  In every\n   model of high bandwidth networks\
    \ that we have seen, the packet loss\n   rate is very low, and thus, the ratio\
    \ of dropped packets to delivered\n   packets is very low. An algorithm that returns\
    \ ACKs as proposed is\n   simply going to have to send more information than one\
    \ in which the\n   receiver returns NAKs.\n   This problem is compounded by the\
    \ short size of the TCP option field\n   (44 bytes). In theory, since we are only\
    \ worried about high bandwidth\n   networks, returning ACKs instead of NAKs is\
    \ not really a problem; the\n   bandwidth is available to send any information\
    \ that's needed. The\n   problem comes when trying to compress the ACK information\
    \ into the 44\n   bytes allowed.  The proposed extensions effectively compresses\
    \ the\n   ACK information by allowing the receiver to ACK byte ranges rather\n\
    \   than segments, and scaling the relative sequence numbers of the re-\n   transmitted\
    \ segments. This makes it much more difficult for the\n   sender to tell which\
    \ segments should be re-transmitted, and\n   complicates the re-transmission code.\
    \  More importantly, one should\n   never compress small amounts of data being\
    \ sent over a high bandwidth\n   network; it trades a scarce resource for an abundant\
    \ resource.  On\n   low bandwidth networks, selective retransmission is not needed\
    \ and\n   the SACK option should be disabled.\n   We propose two solutions to\
    \ this problem. First, the receiver can\n   examine its list of out-of-order packets\
    \ and guess which segments\n   have been dropped, and NAK those segments back\
    \ to the sender. The\n   number of NAKs should be low enough that one per TCP\
    \ packet should be\n   sufficient. Note that the receiver has just as much information\
    \ as\n   the sender about what packets should be retransmitted, and in any\n \
    \  case, the NAKs are simply suggestions which have no effect on\n   correctness.\n\
    \   Our second proposed modification is to increase the offset field in\n   the\
    \ TCP header from 4 bits to 16 bits.  This allows 64k-bytes of TCP\n   header,\
    \ which allows us to radically simplify the selective re-\n   transmission algorithm\
    \ proposed in RFC 1072.  The receiver can now\n   simply send a list of 64-bit\
    \ sequence numbers for the out-of-order\n   segments to the sender. The sender\
    \ can then use this information to\n   do a partial retransmission without needing\
    \ an ouji board to\n   translate ACKs into segments.  With the new header size,\
    \ it may be\n   faster for the receiver to send a large list than to attempt to\n\
    \   aggregate segments into larger blocks.\n   3.1.4.  Header Modifications\n\
    \   The modifications proposed above drastically change the size and\n   structure\
    \ of the TCP header. This makes it a good time to re-think\n   the structure of\
    \ the proposed TCP header. The primary goal of the\n   current TCP header is to\
    \ save bits in the output stream. When TCP was\n   developed, a high bandwidth\
    \ network was 56kbps, and the key use for\n   TCP was terminal I/O.  In both situations,\
    \ minimal header size was\n   important.  Unfortunately, while the network has\
    \ drastically\n   increased in performance and the usage pattern of the network\
    \ is now\n   vastly different, most protocol designers still consider saving a\
    \ few\n   bits in the header to be worth almost any price. Our basic goal is\n\
    \   different: to improve performance by eliminating the need to extract\n   information\
    \ packed into odd length bit fields in the header.  Below\n   is our first cut\
    \ at such a modification.\n   The protocol id field is there to make further evolutionary\n\
    \   modifications to TCP easier. This field basically subsumes the\n   protocol\
    \ number field contained in the IP header with a version\n   number.  Each distinct\
    \ TCP version has a different protocol id and\n   this field ensures that the\
    \ right code is looking at the right\n   header.  The offset field has been increased\
    \ to 16 bits to support\n   the larger header size required, and to simplify header\
    \ processing.\n   The code field has been extended to 16 bits to support more\
    \ options.\n   The source port and destination port are unchanged. The size of\
    \ both\n   the sequence number and ACK fields have been increased to 64 bits.\n\
    \   The open window field has been increased to 32 bits. The checksum and\n  \
    \ urgent data pointer fields are unchanged. The echo and echo reply\n   fields\
    \ are added.  The option field remains but can be much larger\n   than in the\
    \ old TCP.  All headers are padded out to 32 bit\n   boundaries.  Note that these\
    \ changes increase the minimum header size\n   from 24 bytes (actually 36 bytes\
    \ if the ECHO and ECHO reply options\n   defined in RFC 1072 are included on every\
    \ packet) to 48 bytes. The\n   maximum header size has been increased to the maximum\
    \ segment size.\n   We do not believe that the the increased header size will\
    \ have a\n   measurable effect on protocol performance.\n       0            \
    \       1                   2                   3\n       0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        Protocol ID                            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Offset           |              Code             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |              Source           |              Dest             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                              Seq                              |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                              Ack                              |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                            Window                             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \             Checksum          |             Urgent            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                             Echo                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                          Echo Reply                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  Options                                      |     Pad       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   3.1.5.\
    \  Backward Compatibility\n   The most likely objection to the proposed TCP extension\
    \ is that it is\n   not backward compatible with the current version of TCP, and\
    \ most\n   importantly, TCP's header. In this section we will present three\n\
    \   versions of the proposed extension with increasing degrees of\n   backward\
    \ compatibility. The final version will combine the same\n   degree of backward\
    \ compatibility found in the protocol described in\n   RFC's 1072/1185, with the\
    \ much simpler semantics described in this\n   RFC.\n   We believe that the best\
    \ way to preserve backward compatibility is to\n   leave all of TCP alone and\
    \ support the transparent use of a new\n   protocol when and where it is needed.\
    \ The basic scheme is the one\n   described in section 2.4. Those machines and\
    \ operating systems that\n   need to support high speed connections should implement\
    \ some general\n   protocol infrastructure that allows them to rapidly evolve\
    \ protocols.\n   Machines that do not require such service simply keep using the\n\
    \   existing version of TCP. A virtual protocol is used to manage the use\n  \
    \ of multiple TCP versions.\n   This approach has several advantages. First, it\
    \ guarantees backward\n   compatibility with ALL existing TCP versions because\
    \ such\n   implementations will never see strange packets with new options.\n\
    \   Second, it supports further modification of TCP with little\n   additional\
    \ costs. Finally, since our version of TCP will more closely\n   resemble the\
    \ existing TCP protocol than that proposed in RFC's\n   1072/1185, the cost of\
    \ maintaining two simple protocols will probably\n   be lower than maintaining\
    \ one complex protocol.  (Note that with high\n   probability you still have to\
    \ maintain two versions of TCP in any\n   case.)  The only additional cost is\
    \ the memory required for keeping\n   around two copies of TCP.\n   For those\
    \ that insist that the only efficient way to implement TCP\n   modifications is\
    \ in a single monolithic protocol, or those that\n   believe that the space requirements\
    \ of two protocols would be too\n   great, we simply migrate the virtual protocol\
    \ into TCP. TCP is\n   modified so that when opening a connection, the sender\
    \ uses the TCP\n   VERSION option attached to the SYN packet to request using\
    \ the new\n   version.  The receiver responds with a TCP VERSION ACK in the SYN\
    \ ACK\n   packet, after which point, the new header format described in Section\n\
    \   3.1.4 is used. Thus, there is only one version of TCP, but that\n   version\
    \ supports multiple header formats. The complexity of such a\n   protocol would\
    \ be no worse than the protocol described in RFC\n   1072/1185. It does, however,\
    \ make it more difficult to make\n   additional changes to TCP.\n   Finally, for\
    \ those that believe that the preservation of the TCP's\n   header format has\
    \ any intrinsic value (e.g., for those that don't\n   want to re-program their\
    \ ethernet monitors), a header compatible\n   version of our proposal is possible.\
    \  One simply takes all of the\n   additional information contained in the header\
    \ given in Section 3.1.4\n   and places it into a single optional field. Thus,\
    \ one could define a\n   new TCP option which consists of the top 32 bits of the\
    \ sequence and\n   ack fields, the echo and echo_reply fields, and the top 16\
    \ bits of\n   the window field. This modification makes it more difficult to take\n\
    \   advantage of machines with 64-bit address spaces, but at a minimum\n   will\
    \ be just as easy to process as the protocol described in RFC\n   1072/1185. \
    \ The only restriction is that the size of the header\n   option field is still\
    \ limited to 44 bytes, and thus, selective\n   retransmission using NAKs rather\
    \ than ACKs will probably be required.\n   The key observation is that one should\
    \ make a protocol extension\n   correct and simple before trying to make it backward\
    \ compatible.  As\n   far as we can tell, the only advantages possessed by the\
    \ protocol\n   described in RFC 1072/1185 is that its typical header, size including\n\
    \   options, is 8 to 10 bytes shorter. The price for this \"advantage\" is\n \
    \  a protocol of such complexity that it may prove impossible for normal\n   humans\
    \ to implement. Trying to maintain backward compatibility at\n   every stage of\
    \ the protocol design process is a serious mistake.\n"
- title: 3.2.  TCP Over Extension
  contents:
  - "3.2.  TCP Over Extension\n   Another potential problem with TCP that has been\
    \ discussed recently,\n   but has not yet resulted in the generation of an RFC,\
    \ is the\n   potential for TCP to grab and hold all 2**16 port numbers on a given\n\
    \   machine.  This problem is caused by short port numbers, long MSLs,\n   and\
    \ the misuse of TCP as a request-reply protocol. TCP must hold onto\n   each port\
    \ after a close until all possible messages to that port have\n   died, about\
    \ 240 seconds. Even worse, this time is not decreasing with\n   increase network\
    \ performance.  With new fast hardware, it is possible\n   for an application\
    \ to open a TCP connection, send data, get a reply,\n   and close the connection\
    \ at a rate fast enough to use up all the\n   ports in less than 240 seconds.\
    \ This usage pattern is generated by\n   people using TCP for something it was\
    \ never intended to do---\n   guaranteeing at-most-once semantics for remote procedure\
    \ calls.\n   The proposed solution is to embed an RPC protocol into TCP while\n\
    \   preserving backward compatibility. This is done by piggybacking the\n   request\
    \ message on the SYN packet and the reply message on the SYN-\n   ACK packet.\
    \ This approach suffers from one key problem: it reduces\n   the probability of\
    \ a correct TCP implementation to near 0. The basic\n   problem has nothing to\
    \ do with TCP, rather it is the lack of an\n   Internet request-reply protocol\
    \ that guarantees at-most-once\n   semantics.\n   We propose to solve this problem\
    \ by the creation of a new protocol.\n   This has already been attempted with\
    \ VMTP, but the size and\n   complexity of VMTP, coupled with the process currently\
    \ required to\n   standardize a new protocol doomed it from the start.  Instead\
    \ of\n   solving the general problem, we propose to use Sprite RPC [7], a much\n\
    \   simpler protocol, as a means of off-loading inappropriate users from\n   TCP.\n\
    \   The basic design would attempt to preserve as much of the TCP\n   interface\
    \ as possible in order that current TCP (mis)users could be\n   switched to Sprite\
    \ RPC without requiring code modification on their\n   part. A virtual protocol\
    \ could be used to select the correct protocol\n   TCP or Sprite RPC if it exists\
    \ on the other machine. A backward\n   compatible modification to TCP could be\
    \ made which would simply\n   prevent it from grabbing all of the ports by refusing\
    \ connections.\n   This would encourage TCP abusers to use the new protocol.\n\
    \   Sprite RPC, which is designed for a local area network, has two\n   problems\
    \ when extended into the Internet. First, it does not have a\n   usefully flow\
    \ control algorithm. Second, it lacks the necessary\n   semantics to reliably\
    \ tear down connections. The lack of a tear down\n   mechanism needs to be solved,\
    \ but the flow control problem could be\n   dealt with in later iterations of\
    \ the protocol as Internet blast\n   protocols are not yet well understood; for\
    \ now, we could simple limit\n   the size of each message to 16k or 32k bytes.\
    \ This might also be a\n   good place to use a decomposed version of Sprite RPC\
    \ [2], which\n   exposes each of these features as separate protocols. This would\n\
    \   permit the quick change of algorithms, and once the protocol had\n   stabilized,\
    \ a monolithic version could be constructed and distributed\n   to replace the\
    \ decomposed version.\n   In other words, the basic strategy is to introduce as\
    \ simple of RPC\n   protocol as possible today, and later evolve this protocol\
    \ to address\n   the known limitations.\n"
- title: 3.3.  Future Modifications
  contents:
  - "3.3.  Future Modifications\n   The header prediction algorithm should be generalized\
    \ so as to be\n   less sensitive to changes in the protocols header and algorithm.\n\
    \   There almost seems to be as much effort to make all modifications to\n   TCP\
    \ backward compatible with header prediction as there is to make\n   them backward\
    \ compatible with TCP.  The question that needs to be\n   answered is: are there\
    \ any changes we can made to TCP to make header\n   prediction easier, including\
    \ the addition of information into the\n   header.  In [6], the authors showed\
    \ how one might generalize\n   optimistic blast from VMTP to almost any protocol\
    \ that performs\n   fragmentation and reassembly.  Generalizing header prediction\
    \ so that\n   it scales with TCP modification would be step in the right direction.\n\
    \   It is clear that an evolutionary change to increase the size of the\n   source\
    \ and destination ports in the TCP header will eventually be\n   necessary.  We\
    \ also believe that TCP could be made significantly\n   simpler and more flexible\
    \ through the elimination of the pseudo-\n   header. The solution to this problem\
    \ is to simply add a length field\n   and the IP address of the destination to\
    \ the TCP header. It has also\n   been mentioned that better and simpler TCP connection\
    \ establishment\n   algorithms would be useful.  Some form of reliable record\
    \ stream\n   protocol should be developed.  Performing sliding window and flow\n\
    \   control over records rather than bytes would provide numerous\n   opportunities\
    \ for optimizations and allow TCP to return to its\n   original purpose as a byte-stream\
    \ protocol. Finally, it has become\n   clear to us that the current Internet congestion\
    \ control strategy is\n   to use TCP for everything since it is the only protocol\
    \ that supports\n   congestion control. One of the primary reasons many \"new\
    \ protocols\"\n   are proposed as TCP options is that it is the only way to get\
    \ at\n   TCP's congestion control. At some point, a TCP-independent congestion\n\
    \   control scheme must be implemented and one might then be able to\n   remove\
    \ the existing congestion control from TCP and radically\n   simplify the protocol.\n"
- title: 4.  Discussion
  contents:
  - "4.  Discussion\n   One obvious side effect of the changes we propose is to increase\
    \ the\n   size of the TCP header. In some sense, this is inevitable; just about\n\
    \   every field in the header has been pushed to its limit by the radical\n  \
    \ growth of the network. However, we have made very little effort to\n   make\
    \ the minimal changes to solve the current problem. In fact, we\n   have tended\
    \ to sacrifice header size in order to defer future changes\n   as long as possible.\
    \ The problem with this is that one of TCP's\n   claims to fame is its efficiency\
    \ at sending small one byte packets\n   over slow networks. Increasing the size\
    \ of the TCP header will\n   inevitably result in some increase in overhead on\
    \ small packets on\n   slow networks. Clark among others have stated that they\
    \ see no\n   fundamental performance limitations that would prevent TCP from\n\
    \   supporting very high speed networks. This is true as far as it goes;\n   there\
    \ seems to be a direct trade-off between TCP performance on high\n   speed networks\
    \ and TCP performance on slow speed networks. The\n   dynamic range is simply\
    \ too great to be optimally supported by one\n   protocol. Hence, in keeping around\
    \ the old version of TCP we have\n   effectively split TCP into two protocols,\
    \ one for high bandwidth\n   lines and the other for low bandwidth lines.\n  \
    \ Another potential argument is that all of the changes mentioned above\n   should\
    \ be packaged together as a new version of TCP. This version\n   could be standardized\
    \ and we could all go back to the status quo of\n   stable unchanging protocols.\
    \  While to a certain extent this is\n   inevitable---there is a backlog of necessary\
    \ TCP changes because of\n   the current logistical problems in modifying protocols---it\
    \ is only\n   begs the question. The status quo is simply unacceptably static;\n\
    \   there will always be future changes to TCP.  Evolutionary change will\n  \
    \ also result in a better and more reliable TCP.  Making small changes\n   and\
    \ distributing them at regular intervals ensures that one change\n   has actually\
    \ been stabilized before the next has been made.  It also\n   presents a more\
    \ balanced workload to the protocol designer; rather\n   than designing one new\
    \ protocol every 10 years he makes annual\n   protocol extensions. It will also\
    \ eventually make protocol\n   distribution easier: the basic problem with protocol\
    \ distribution now\n   is that it is done so rarely that no one knows how to do\
    \ it and there\n   is no incentive to develop the infrastructure needed to perform\
    \ the\n   task efficiently.  While the first protocol distribution is almost\n\
    \   guaranteed to be a disaster, the problem will get easier with each\n   additional\
    \ one. Finally, such a new TCP would have the same problems\n   as VMTP did; a\
    \ radically new protocol presents a bigger target.\n   The violation of backward\
    \ compatibility in systems as complex as the\n   Internet is always a serious\
    \ step. However, backward compatibility is\n   a technique, not a religion. Two\
    \ facts are often overlooked when\n   backward compatibility gets out of hand.\
    \ First, violating backward\n   compatibility is always a big win when you can\
    \ get away with it.  One\n   of the key advantages of RISC chips over CISC chips\
    \ is simply that\n   they were not backward compatible with anything. Thus, they\
    \ were not\n   bound by design decisions made when compilers were stupid and real\n\
    \   men programmed in assembler. Second, one is going to have to break\n   backward\
    \ compatibility at some point anyway. Every system has some\n   headroom limitations\
    \ which result in either stagnation (IBM mainframe\n   software) or even worse,\
    \ accidental violations of backward\n   compatibility.\n   Of course, the biggest\
    \ problem with our approach is that it is not\n   compatible with the existing\
    \ standardization process. We hope to be\n   able to design and distribute protocols\
    \ in less time than it takes a\n   standards committee to agree on an acceptable\
    \ meeting time.  This is\n   inevitable because the basic problem with networking\
    \ is the\n   standardization process. Over the last several years, there has been\n\
    \   a push in the research community for lightweight protocols, when in\n   fact\
    \ what is needed are lightweight standards.  Also note that we\n   have not proposed\
    \ to implement some entirely new set of \"superior\"\n   communications protocols,\
    \ we have simply proposed a system for making\n   necessary changes to the existing\
    \ protocol suites fast enough to keep\n   up with the underlying change in the\
    \ network.  In fact, the first\n   standards organization that realizes that the\
    \ primary impediment to\n   standardization is poor logistical support will probably\
    \ win.\n"
- title: 5.  Conclusions
  contents:
  - "5.  Conclusions\n   The most important conclusion of this RFC is that protocol\
    \ change\n   happens and is currently happening at a very respectable clip.  While\n\
    \   all of the changes given as example in this document are from TCP,\n   there\
    \ are many other protocols that require modification.  In a more\n   prosaic domain,\
    \ the telephone company is running out of phone\n   numbers; they are being overrun\
    \ by fax machines, modems, and cars.\n   The underlying cause of these problems\
    \ seems to be an consistent\n   exponential increase almost all network metrics:\
    \ number of hosts,\n   bandwidth, host performance, applications, and so on, combined\
    \ with\n   an attempt to run the network with a static set of unchanging network\n\
    \   protocols.  This has been shown to be impossible and one can almost\n   feel\
    \ the pressure for protocol change building. We simply propose to\n   explicitly\
    \ deal with the changes rather keep trying to hold back the\n   flood.\n   Of\
    \ almost equal importance is the observation that TCP is a protocol\n   and not\
    \ a platform for implementing other protocols. Because of a\n   lack of any alternatives,\
    \ TCP has become a de-facto platform for\n   implementing other protocols. It\
    \ provides a vague standard interface\n   with the kernel, it runs on many machines,\
    \ and has a well defined\n   distribution path. Otherwise sane people have proposed\
    \ Bounded Time\n   TCP (an unreliable byte stream protocol), Simplex TCP (which\
    \ supports\n   data in only one direction) and Multi-cast TCP (too horrible to\
    \ even\n   consider).  All of these protocols probably have their uses, but not\n\
    \   as TCP options. The fact that a large number of people are willing to\n  \
    \ use TCP as a protocol implementation platform points to the desperate\n   need\
    \ for a protocol independent platform.\n   Finally, we point out that in our research\
    \ we have found very little\n   difference in the actual technical work involved\
    \ with the three\n   proposed methods of protocol modification. The amount of\
    \ work\n   involved in a backward compatible change is often more than that\n\
    \   required for an evolutionary change or the creation of a new\n   protocol.\
    \  Even the distribution costs seem to be identical.  The\n   primary cost difference\
    \ between the three approaches is the cost of\n   getting the modification approved.\
    \ A protocol modification, no matter\n   how extensive or bizarre, seems to incur\
    \ much less cost and risk. It\n   is time to stop changing the protocols to fit\
    \ our current way of\n   thinking, and start changing our way of thinking to fit\
    \ the\n   protocols.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: '[1]  Cheriton D., "VMTP: Versatile Message Transaction Protocol", RFC'
  contents:
  - "[1]  Cheriton D., \"VMTP: Versatile Message Transaction Protocol\", RFC\n   \
    \  1045, Stanford University, February 1988.\n"
- title: '[2]  Hutchinson, N., Peterson, L., Abbott, M., and S. O''Malley, "RPC in'
  contents:
  - "[2]  Hutchinson, N., Peterson, L., Abbott, M., and S. O'Malley, \"RPC in\n  \
    \   the x-Kernel: Evaluating New Design Techniques\", Proceedings of the\n   \
    \  12th Symposium on Operating System Principles, Pgs. 91-101,\n     December\
    \ 1989.\n"
- title: '[3]  Jacobson, V., "Congestion Avoidance and Control", SIGCOMM ''88,'
  contents:
  - "[3]  Jacobson, V., \"Congestion Avoidance and Control\", SIGCOMM '88,\n     August\
    \ 1988.\n"
- title: '[4]  Jacobson, V., and R. Braden, "TCP Extensions for Long-Delay Paths",'
  contents:
  - "[4]  Jacobson, V., and R. Braden, \"TCP Extensions for Long-Delay Paths\",\n\
    \     RFC 1072, LBL, ISI, October 1988.\n"
- title: '[5]  Jacobson, V., Braden, R., and L. Zhang, "TCP Extensions for High-'
  contents:
  - "[5]  Jacobson, V., Braden, R., and L. Zhang, \"TCP Extensions for High-\n   \
    \  Speed Paths\", RFC 1185, LBL, ISI, PARC, October 1990.\n"
- title: '[6]  O''Malley, S., Abbott, M., Hutchinson, N., and L. Peterson, "A Tran-'
  contents:
  - "[6]  O'Malley, S., Abbott, M., Hutchinson, N., and L. Peterson, \"A Tran-\n \
    \    sparent Blast Facility\", Journal of Internetworking, Vol. 1, No.\n     2,\
    \ Pgs. 57-75, December 1990.\n"
- title: '[7]  Welch, B., "The Sprite Remote Procedure Call System", UCB/CSD'
  contents:
  - "[7]  Welch, B., \"The Sprite Remote Procedure Call System\", UCB/CSD\n     86/302,\
    \ University of California at Berkeley, June 1988.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 8.  Authors' Addresses
  contents:
  - "8.  Authors' Addresses\n   Larry L. Peterson\n   University of Arizona\n   Department\
    \ of Computer Sciences\n   Tucson, AZ 85721\n   Phone: (602) 621-4231\n   EMail:\
    \ llp@cs.arizona.edu\n   Sean O'Malley\n   University of Arizona\n   Department\
    \ of Computer Sciences\n   Tucson, AZ 85721\n   Phone: 602-621-8373\n   EMail:\
    \ sean@cs.arizona.edu\n"
