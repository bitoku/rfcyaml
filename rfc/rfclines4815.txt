Abstract RFC 3095 defines the RObust Header Compression (ROHC) framework and profiles for IP (Internet Protocol), UDP (User Datagram Protocol), RTP (Real Time Transport Protocol), and ESP (Encapsulating Security Payload).
Some parts of the specification are unclear or contain errors that may lead to misinterpretations that may impair interoperability between different implementations.
This document provides corrections, additions, and clarifications to RFC 3095; this document thus updates RFC 3095.
In addition, other clarifications related to RFC 3241 (ROHC over PPP), RFC 3843 (ROHC IP profile) and RFC 4109 (ROHC UDP Lite profiles) are also provided.
Introduction and Terminology RFC 3095
[1] defines the RObust Header Compression (ROHC) framework and profiles for IP (Internet Protocol)
[8][9], UDP (User Datagram Protocol)
[10], RTP (Real Time Transport Protocol) [11], and ESP (Encapsulating Security Payload)
During implementation and interoperability testing of RFC 3095, some ambiguities and common misinterpretations have been identified, as well as a few errors.
This document summarizes identified issues and provides corrections needed for implementations of RFC 3095 to interoperate, i.e., it constitutes an update to RFC 3095.
This document also provides other clarifications related to common misinterpretations of the specification.
References to RFC 3095 should, therefore, also include this document.
In addition, some clarifications and corrections are also provided for RFC 3241 (ROHC over PPP) [2], RFC 3843 (ROHC IP only profile) [4], and RFC 4019 (ROHC UDP Lite profiles) [5], which are thus also updated by this document.
Furthermore, RFC 4362 (ROHC Link Layer Assisted Profile)
[7] is implicitly updated by this document, since RFC 4362 is also based on RFC 3095.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 [6].
When a section of this document makes formal corrections, additions or invalidations to text in RFC 3095, this is clearly summarized.
The text from RFC 3095 that is being addressed is given and labeled "INCOMPLETE", "INCORRECT", or "INCORRECT AND INVALIDATED", followed by the correct text labeled "CORRECTED", where applicable.
When text is added that does not simply correct text in previous specifications, it is given with the label "FORMAL ADDITION".
In this document, a reference to a section in RFC 3095 [1] is written as RFC 3095 Section <number>. 2.
CRC Calculation and Coverage 2.1.
CRC Calculation RFC 3095 Section 5.9 defines polynomials for 3 , 7 , and 8 bit Cyclic Redundancy Checks (CRCs), but it does not specify what algorithm is used.
The 3 , 7  and 8 bit CRCs are calculated using the CRC algorithm defined in [3].
A Perl implementation of the algorithm can be found in Appendix A of this document.
Padding Octet and CRC Calculations RFC 3095 Section 5.9.1 is incomplete, as it does not mention how to handle the padding octet in CRC calculations for IR and IR DYN packets.
Padding isn't meant to be a meaningful part of a packet and is not included in the CRC calculation.
As a result, the CRC does not cover the Add CID octet for CID 0, either.
INCOMPLETE RFC 3095 TEXT (RFC 3095 Section 5.9.1): "
The CRC in the IR and IR DYN packet is calculated over the entire IR or IR DYN packet, excluding Payload and including CID or any Add CID octet."
The CRC in the IR and IR DYN packet is calculated over the entire IR or IR DYN packet, excluding Payload, Padding and including CID or any Add CID octet, except for the add CID octet for CID 0.
CRC Coverage in CRC Feedback Options RFC 3095 Section 5.7.6.3 is incomplete, as it does not mention how the "size" field is handled when calculating the 8 bit CRC used in the CRC feedback option.
Since the "size" field is an extension of the "code" field, it must be treated in the same way.
INCOMPLETE RFC 3095 TEXT (RFC 3095 Section 5.7.6.3): "The CRC option contains an 8 bit CRC computed over the entire feedback payload, without the packet type and code octet, but including any CID fields, using the polynomial of section 5.9.1."
The CRC option contains an 8 bit CRC computed over the entire feedback payload including any CID fields but excluding the packet type, the 'Size' field and the 'Code' octet, using the polynomial of Section 5.9.1.
CRC Coverage of the ESP NULL Header RFC 3095 Section 5.8.7 gives the CRC coverage of the ESP NULL [13] header as "Entire ESP header".
This must be interpreted as including only the initial part of the header (i.e., Security Parameter Index (SPI) and sequence number), and not the trailer part at the end of the payload.
Therefore, the ESP NULL header has the same CRC coverage as the ESP header used in the ESP profile (RFC 3095 Section 5.7.7.7).
During Mode Transition to U  and O Mode RFC 3095 Section 5.6.1
states that during mode transitions, while the D TRANS parameter is I, the decompressor sends feedback for each received packet.
This restrictive behavior prevents the decompressor from using a sparse feedback algorithm during mode transitions.
To reduce transmission overhead and computational complexity (including CRC calculation) associated with feedback packets sent for each decompressed packet during mode transition, a decompressor MAY be implemented with slightly modified mode transition procedures compared to those defined in [1], as described in this section.
These enhanced procedures should be considered only as a possible improvement to a decompressor implementation, since interoperability is not affected in any way.
A decompressor implemented according to the optimized procedures will interoperate with an RFC 3095 compressor, as well as a decompressor implemented according to the procedures described in RFC 3095.
Mode Transition Procedures Allowing Sparse Feedback
The purpose of these enhanced transition procedures is to allow the decompressor to sparsely send feedback for packets decompressed during the second half of the transition procedure, i.e., after an appropriate IR/IR DYN/UOR 2 packet has been received from the compressor.
This is achieved by allowing the decompressor transition parameter (D TRANS) to be set to P (Pending) at that stage, as shown in the transition diagrams of Sections 3.1.2 and 3.1.3 below.
This enhanced transition, where feedback need not be sent for every decompressed packet, does however introduce some considerations in case feedback messages would be lost.
Specifically, there is a risk for a deadlock situation when a transition from R mode is performed; if no feedback message successfully reaches the compressor, the transition is never completed.
For transition between U mode and O mode, there is also a small risk for reduced compression efficiency.
To avoid this, the decompressor MUST continue to send feedback at least periodically, as well as when in a Pending transition state.
This is equivalent to enhancing the definition of the D TRANS parameter in RFC 3095 Section 5.6.1, to include the definition of a Pending state:  D TRANS:
Possible values for the D TRANS parameter are (I)NITIATED, (P)ENDING, and (D)ONE.
D TRANS MUST be initialized to D, and a mode transition can be initiated only when D TRANS is D.
While D TRANS is I, the decompressor sends a NACK or ACK carrying a CRC option for each packet received.
When D TRANS is set to P, the decompressor does not have to send a NACK or ACK for each packet received, but it MUST continue to send feedback with some periodicity, and all feedback packets sent MUST include the CRC option.
This ensures that all mode transitions will be completed also in case of feedback losses.
The modifications affect transitions to Optimistic and Unidirectional modes of operation (i.e., the transitions described in RFC 3095  Section 5.6.5 and RFC 3095 Section 5.6.6) and make those transition diagrams more consistent with the diagram describing the transition to R mode.
Transition from Reliable to Optimistic Mode
During Mode Transition RFC 3095 Section 5.6.1 states that feedback is always used during mode transitions.
However, the text then continues by making concrete applications of the rule in an inconsistent way, making it unclear when CRCs are used.
Further, the text does not define how the compressor should act during mode transitions based on feedback not protected by CRCs, i.e., whether or not to carry out mode transition actions.
The proper behavior from the compressor is to perform any action related to mode transitions only when the feedback is protected by the CRC option.
INCOMPLETE RFC 3095 TEXT (RFC 3095 Section 5.6.1): "As a safeguard against residual errors, all feedback sent during a mode transition MUST be protected by a CRC, i.e., the CRC option MUST be used."
As a safeguard against residual errors, all feedback sent by the decompressor during a mode transition MUST be protected by a CRC, i.e., the CRC option MUST be used.
The compressor MUST ignore feedback information related to mode transition if the feedback is not protected by the CRC option.
" One more related issue that requires clarifications comes from the following text at the end of RFC 3095 Section 5.6.1: "While D TRANS is I, the decompressor sends a NACK or ACK carrying a CRC option for each received packet."
However, RFC 3095 Section 5.5.2.2 already stated that for R mode, feedback is never sent for packets that do not update the context, i.e., for packets that do not carry a CRC, such as R 0 and R 1 .
This means that when D TRANS I during mode transition, a decompressor operating in R mode sends an acknowledgement for each packet it receives and MUST use the sequence number that corresponds to the packet that last updated the context, i.e., the decompressor MUST NOT use the sequence number of the R 0 or the R 1  packet.
3.3.  Packet Decoding During Mode Transition
The purpose of a mode transition is to ensure that the compressor and the decompressor coherently move from one mode of operation to another using a three way handshake.
At one point during the mode transition, the decompressor acknowledges the reception of one (or more) IR, IR DYN or UOR 2 packet(s) that have mode bits set to the new mode.
Packets of type 0 or type 1 that are received up to this point are decompressed using the old mode, while afterwards they are decompressed using the new mode.
If the enhanced transition procedures described in Section 3.1 are used, the setting of the D TRANS parameter to P represents this breakpoint.
The successful decompression of a packet of type 0 or type 1 completes the mode transition.
Encoding Used for Compressed TS Bits RTP Timestamp (TS) values are always encoded using W LSB encoding, both when sent scaled and unscaled.
When no TS bits are transmitted in a compressed packet, TS is always scaled.
If a compressed packet carries an Extension 3 and field(Tsc) 0, the compressed packet must thus always carry unscaled TS bits.
For TS values sent in Extension 3, W LSB encoded
values are sent using the self describing variable  length format (RFC 3095 Section 4.5.6), and this applies to both scaled and unscaled values.
(De)compression of TS without Transmitted TS Bits
When ROHC RTP operates using its most efficient packet types, apart from packet type identification and the error detection CRC, only RTP sequence number (SN) bits are transmitted in RTP compressed headers.
All other fields are then omitted either because they are unchanged or because they can be reconstructed through a function from the SN (i.e., by combining the transmitted SN bits with state information from the context).
Fields that can be inferred from the SN are the IP Identification (IP ID) and the RTP Timestamp (TS).
IP ID compression and decompression, both with and without transmitted IP ID bits in the compressed header, are well defined in RFC 3095 Section 4.5.5 (see Section 8.2).
For the TS field, however, RFC 3095 only defines how to decompress based on actual TS bits in the compressed header, either scaled or unscaled, but not how to infer the TS from the SN when there are no TS bits present in the compressed header.
When no TS bits are received in the compressed header, the scaled TS value is reconstructed assuming a linear extrapolation from the SN, i.e., delta TS
delta SN   default slope, where delta SN and delta TS are both signed integers.
RFC 3095 Section 5.7 defines the potential values for default slope.
INCOMPLETE RFC 3095 TEXT (RFC 3095 Section 5.7): "If value(Tsc)   1, Scaled RTP Timestamp encoding is used before compression (see section 4.5.3), and default slope(TS)   1.
, the Timestamp value is compressed as is, and default slope(TS)
When a compressed header with no TS bits is received, the scaled TS value is reconstructed assuming a linear extrapolation from the SN, i.e., delta TS
1, Scaled RTP Timestamp encoding is used before compression (see Section 4.5.3), and default slope(TS)
, the Timestamp value is compressed as is, and default slope(TS)
If a packet with no TS bits is received with Tsc   0, the decompressor MUST discard the packet."
RFC 3095 TEXT (Section RFC 3095 5.5.1.2): "For example, in a typical case where the string pattern has the form of non SN field
slope   offset, one ACK is enough if the slope has been previously established by the decompressor (i.e., only the new offset needs to be synchronized).
Otherwise, two ACKs are required since the decompressor needs two headers to learn both the new slope and the new offset.
Consequently, there is no other slope value than the default slope, as defined in RFC 3095 Section 5.7.
Interpretation Intervals for TS Encoding RFC 3095 Section 4.5.4 defines the interpretation interval, p, for timer based compression of the RTP timestamp.
However, RFC 3095  Section 5.7 defines a different interpretation interval, which is defined as the interpretation interval to use for all TS values.
It is thus unclear which p value to use, at least for timer based compression.
The way this should be interpreted is that the p value differs depending on whether or not timer based compression is enabled.
For timer based compression (TIME STRIDE set to a non zero value), the interpretation interval is: p   2^(k 1) 1
(as per RFC 3095 Section 4.5.4)
Otherwise, the interpretation interval is: p   2^(k 2)
1 (as per RFC 3095 Section 5.7) 4.4.
This section redefines the algorithm for scaled RTP timestamp encoding, defined as a 5 step procedure in RFC 3095 Section 4.5.3.
Two formal errors have been corrected, as described in sub sections 4.4.1 and 4.4.2 below, and the whole algorithm has been reworked to be more concise and to use well defined terminology.
The resulting text can be found in 4.4.3 below.
TS STRIDE for Scaled Timestamp Encoding RFC 3095 defines the timestamp stride (TS STRIDE) as the expected increase in the timestamp value between two RTP packets with consecutive sequence numbers.
TS STRIDE is set by the compressor and explicitly communicated to the decompressor, and it is used as the scaling factor for scaled TS encoding.
The relation between TS and TS SCALED, given by the following equality in RFC 3095 Section 4.5.3, defines the mathematical meaning of TS STRIDE:
TS OFFSET TS SCALED is incompletely written as TS / TS STRIDE in the compression step following the above core equality.
This formula is incorrect both because it excludes TS OFFSET and because it would prevent a TS STRIDE value of 0, which is an alternative not excluded by the definition or by the core equality above.
(TS is never sent scaled when TS STRIDE 0)
TS Wraparound with Scaled Timestamp Encoding RFC 3095 Section 4.5.3 states in points 4 and 5 that the compressor is not required to initialize TS OFFSET at wraparound, but that it is required to increase the number of bits sent for the scaled TS value when there is a TS wraparound.
The decompressor is also required to detect and cope with TS wraparound, including updating TS OFFSET.
This method is not interoperable and not robust.
The gain is also insignificant, as TS wraparound happens very seldomly.
Therefore, the compressor should reinitialize TS OFFSET upon TS wraparound, by sending an unscaled TS.
Algorithm for Scaled Timestamp Encoding INCORRECT
RFC 3095 TEXT (RFC 3095 Section 4.5.3): "1.
The compressor sends to the decompressor the value of TS STRIDE and the absolute value of one or several TS fields.
The latter are used by the decompressor to initialize TS OFFSET to (absolute value) modulo TS STRIDE.
Note that TS OFFSET is the same regardless of which absolute value is used, as long as the unscaled TS value does not wrap around
After initialization, the compressor no longer compresses the original TS values.
Instead, it compresses the downscaled values:
The compression method could be either W LSB encoding or the timer based encoding described in the next section.
When receiving the compressed value of TS SCALED, the decompressor first derives the value of the original TS SCALED.
The original RTP TS is then calculated as TS   TS SCALED
Wraparound of the unscaled 32 bit TS will invalidate the current value of TS OFFSET used in the equation above.
For example, let us assume TS STRIDE
0xA0 and the current TS
TS OFFSET is then 0x50   80.
Then if the next RTP TS   0x00000130
(i.e., the increment is 160
320), the new TS OFFSET should be 0x00000130
The compressor is not required to re  initialize TS OFFSET at wraparound.
Instead, the decompressor MUST detect wraparound of the unscaled TS (which is trivial) and update TS OFFSET to TS OFFSET
Initialization and updating of RTP TS scaling function:  The compressor sends to the decompressor the value of TS STRIDE along with an unscaled TS.
These are both needed by the decompressor to initialize TS OFFSET as hdr(TS) modulo field(TS STRIDE).
Note that TS OFFSET is the same for any TS as long as TS STRIDE does not change and as long as the unscaled TS value does not wrap around
After initialization, the compressor no longer compresses the unscaled TS values.
Instead, it compresses the scaled values.
The compression method can be either W LSB encoding or timer based encoding.
When receiving a (compressed) TS SCALED, the field is first decompressed, and the unscaled RTP TS is then calculated as TS   TS SCALED
Offset at wraparound: If the value of TS STRIDE is not equal to a power of two, wraparound of the unscaled 32 bit TS will change the value of TS OFFSET.
When this happens, the compressor SHOULD reinitialize TS OFFSET by sending unscaled TS, as in 1 above."
RFC 3095 TEXT (RFC 3095 Section 4.5.3):
The entire point 5, i.e. the entire text starting from "5.
OFFSET TS can be sent unscaled if the TS value change does not match the established TS STRIDE, but the TS STRIDE might still stay unchanged.
To ensure correct decompression of subsequent packets, the decompressor MUST therefore always recalculate TS OFFSET (RTP TS modulo TS STRIDE) when a packet with an unscaled TS value is received.
TS STRIDE and the Tsc Flag in Extension 3
The Tsc flag in Extension 3 indicates whether or not TS is scaled.
The value of the Tsc flag thus applies to all TS bits, as well as if there are no TS bits in the extension itself.
When TS is scaled, it is always scaled using context(TS STRIDE).
The legend for Extension 3 in RFC 3095 Section 5.7.5 incorrectly states that value(TS STRIDE) is used for scaled TS.
If TS STRIDE is present in Extension 3, as indicated by the Tss flag being set, the compressed header SHOULD carry unscaled TS bits; i.e., the Tsc flag SHOULD NOT be set when Tss is set since an unscaled TS is needed together with TS STRIDE to recalculate the TS OFFSET.
If TS STRIDE is included in a compressed header with scaled TS, the decompressor must ignore and discard field(TS STRIDE).
RFC 3095 TEXT (RFC 3095 Section 5.7.5): "Tsc:
Tsc   0 indicates that TS is not scaled; Tsc   1 indicates that TS is scaled according to section 4.5.3, using value(TS STRIDE).
If scaling is not desired, the compressor will establish TS STRIDE   1."
Tsc   0 indicates that TS is not scaled; Tsc   1 indicates that TS is scaled according to Section 4.5.3, using context(TS STRIDE).
If scaling is not desired, the compressor will establish TS STRIDE   1.
If field(Tsc)   1, and if TSS   1 (meaning that TS STRIDE is present in the extension), field(TS STRIDE) MUST be ignored and discarded.
" When the compressor re establishes a new value for TS STRIDE using Extension 3, it should send unscaled TS bits together with TS STRIDE.
Using Timer Based Compression Timer
based compression of the RTP timestamp, as described in RFC 3095 Section 4.5.4, may be used to reduce the number of transmitted timestamp bits (bytes) needed when the timestamp cannot be inferred from the SN.
Timer based compression is only used for decompression of compressed headers that contains a TS field; otherwise, when no timestamp bits are present, the timestamp is linearly inferred from the SN (see Section 4.2 of this document).
Whether or not to use timer based compression is controlled by the TIME STRIDE control field, which can be set by either an IR, an IR  DYN, or a compressed packet with Extension 3.
Before timer based compression can be used, the decompressor has to inform the compressor (on a per channel basis) about its clock resolution by sending a CLOCK feedback option for any CID on the channel.
The compressor can then initiate timer based compression by sending (on a per context basis) a non zero TIME STRIDE to the decompressor.
When the compressor is confident that the decompressor has received the TIME STRIDE value, it can switch to timer based compression.
CSRC List Items in RTP Dynamic Chain RFC 3095 Section 5.7.7.6 defines the static and dynamic parts of the RTP header.
This section indicates a 'Generic CSRC list' field in the dynamic chain, which has a variable length (see RFC 3095 Section 5.8.6).
This field is always at least one octet in size, even if the list is empty (as opposed to the CSRC list in the uncompressed RTP header, which is not present when the RTP CC field is set to 0).
Multiple Occurrences of the CC Field
The static and the dynamic parts of the RTP header are defined in RFC 3095 Section 5.7.7.6.
In the dynamic part, a CC field indicates the number of CSRC items present in the 'Generic CSRC list'.
Another CC field also appears within the 'Generic CSRC list' (RFC 3095 Section 5.8.6.1), because Encoding Type 0 is always used in the dynamic chain.
Both CC fields have the same meaning: the value of the CC field determines the number of XI items in the CSRC list for Encoding Type 0, and it is not used otherwise.
FORMAL ADDITION TO RFC 3095:
"The first octet in the dynamic part of the RTP header contains a CC field, as defined in Section 5.7.7.6.
A second occurrence appears in the 'Generic CSRC list', which is also in the dynamic part of the RTP header, where Encoding Type 0 is used according to the format defined in RFC 3095 5.8.6.1.
The compressor MUST set both occurrences of the CC field to the same value.
The decompressor MUST use the value of the CC field from the Encoding Type 0 within the Generic CRSC list, and it MUST thus ignore the first occurrence of the CC field.
Bit Masks in List Compression
The insertion and/or removal schemes, described in RFC 3095 Sections 5.8.6.2 5.8.6.4, use bit masks to indicates insertion or removal positions within the reference list.
The size of the bit mask can be 7 bits or 15 bits.
The compressor MAY use a 7 bit mask, even if the reference list has more than seven items, provided that changes to the list are only applied to items within the first seven items of the reference list, leaving items with an index not covered by the 7 bit mask unchanged.
The decompressor MUST NOT modify items with an index not covered by the 7 bit mask, when a 7 bit mask is received for a reference list that contains more than seven items.
Headers Compressed with List Compression
In RFC 3095 Section 5.8, it states that headers that can be part of extension header chains "include" AH [14], ESP NULL [13], minimal encapsulation (MINE) [15], GRE [16][17], and IPv6 [9] extensions.
This list of headers that can be compressed is correct, but the word "include" should not be there, since only the header types listed can actually be handled.
It should further be noted that for the Minimal Encapsulation (MINE) header, there is no explicit discussion of how to compress it, as the header is sent either uncompressed or fully compressed away.
ESP NULL Header List Compression
Due to the offset of the fields in the trailer part of the ESP header, a compressor MUST NOT compress packets containing
more than one NULL ESP [13] header, unless the second outermost header is treated as a regular ESP [12] header and the packets are compressed using profile 0x0003.
Translation Tables and Indexes for IP Extension Headers RFC 3095 Section 5.8.4 describes how list indexes are associated to list items and how table lists are built for IP extension headers.
The text incorrectly states that one index per type is used, since the same type can appear several times with different content in one single chain.
In IP extension header list compression, an index is associated with each individual extension header of an extension header chain.
When there are multiple non identical occurrences of the same extension type (Protocol Number) within a header chain, each MUST be given its own index.
In the case where there are multiple identical occurrences of the same extension type, the compressor can associate them to the same index.
When the value of an item whose index occurs more than once in the list is updated, the compressor MUST send the value for each occurrence of that index in the list.
When content of extension headers changes, an implementation can choose to either use a different index or update the existing one.
Some extensions can be compressed away even when some fields change, as those changes can be conveyed to the decompressor implicitly (e.g. sequence numbers in extension headers that can be inferred from the RTP SN) or explicitly (e.g., as part of the 'IP extension header(s)' field in Extension 3).
When there is more than one IP header, there is more than one list of extension headers, and a translation table is maintained for each list independently of one another.
A list compressed using encoding type 1 (insertion), type 2 (removal), or type 3 (removal/insertion) uses a coding scheme that is based on the use of a reference list in the context (identified as ref id).
While it could seem to be a fair choice to send a type 1 list when ref id is an empty list, there is nothing gained in doing so with respect to using a type 0 list.
Sending a type 2 list when ref id is an empty list would lead to a failure, while sending a type 3 list has very little meaning.
All these alternatives could be seen as possible, based on how list compression is specified in RFC 3095.
If these alternatives were allowed, a decompressor would become required to maintain a sliding window of ref id lists in R mode, even for the case where no items are sent in the compressed list, and this is not a desirable requirement.
Using list encoding type 1, type 2, and type 3 is therefore only allowed for non empty reference lists.
FORMAL ADDITION TO RFC 3095
: "Regardless of the operating mode, for list encoding of type 1, type 2, and type 3 lists, ref id MUST refer to a non empty list."
Compression of AH and GRE Sequence Numbers RFC 3095 Section 5.8.4.2 and RFC 3095 Section
5.8.4.4 describe how to compress the Authentication Header (AH) [14] and the Generic Routing Encapsulation (GRE) [16][17] header.
Both these sections present a possibility to omit the AH/GRE sequence number in the compressed header, under certain circumstances.
However, the specific conditions for omitting the AH/GRE sequence number, as well as the concrete compression and decompression procedures to apply, are not clearly defined to guarantee robustness and facilitate interoperable implementation.
When the offset is not constant, the sequence number may be compressed by sending LSBs" The same logic applies to the AH/GRE sequence numbers.
RFC 3095 TEXT (RFC 3095 Section 5.8.4.2): "If the sequence number in the AH linearly increases as the RTP Sequence Number increases, and the compressor is confident that the decompressor has obtained the pattern, the sequence number in AH need not be sent.
The decompressor applies linear extrapolation to reconstruct the sequence number in the AH."
The AH sequence number can be omitted from the compressed header when the offset from the sequence number (SN) of the compressed header is constant, when the compressor has confidence that the decompressor has established the correct offset."
RFC 3095 TEXT (RFC 3095 Section 5.8.4.4): "If the sequence number in the GRE header linearly increases as the RTP Sequence Number increases and the compressor is confident that the decompressor has received the pattern, the sequence number in GRE need not be sent.
The decompressor applies linear extrapolation to reconstruct the sequence number in the GRE header."
The GRE sequence number can be omitted from the compressed header when the offset from the sequence number (SN) of the compressed header is constant, when the compressor has confidence that the decompressor has established the correct offset.
A context updating packet that contains compressed sequence number information may also carry information about other fields; in such cases, these fields are updated according to the content of the packet.
The updating packet also implicitly updates inferred fields (e.g., RTP Timestamp) according to the current mode and the appropriate mapping function of the updated and inferred fields.
An updating packet thus updates the reference values of all header fields, either explicitly or implicitly, except for the UO 1 ID packet (see Section 6.2 of this document).
In UO mode, all packets are updating packets, while in R mode, all packets with a CRC are updating packets.
For example, a UO 0 packet contains the compressed RTP sequence number (SN).
Such a packet also implicitly updates RTP timestamp, IPv4 ID, and sequence numbers of IP extension headers.
Updating Properties of UO 1  RFC 3095 Section 5.7.3 states that the values provided in extensions carried by a UO 1 ID packet do not update the context, except for SN, TS, or IP ID fields.
However, RFC 3095 Section 5.8.1 correctly states that the translation table in the context is updated whenever an (Index, item) pair is received, something that is contradicted by the statement in RFC 3095 5.7.3 because the UO 1 ID packet can carry Extension 3 with (Index, item) pair items within the 'Compressed CSRC list' field.
In addition to this contradiction, the text does not mention what to do with the other sequence numbers inferred from the SN, which are also to be implicitly updated.
The updating properties of UO 1  as stated by RFC 3095 Section 5.7.3 are thus incomplete.
INCOMPLETE RFC 3095 TEXT (RFC 3095 Section 5.7.3): "
Values provided in extensions, except those in other SN, TS, or IP ID fields, do not update the context."
UO 1 ID packets only updates TS, SN, IP ID, and sequence numbers of IP extension headers.
Other values provided in extensions do not update the context.
The decompressor MUST update its translation table whenever an (Index, item) pair is received, as per RFC 3095 Section 5.8.1, and this rule applies also to UO 1 ID packets.
Context Updating Properties for IR Packets IR packets do not clear the whole context, but update all fields carried in the IR header.
Similarly, an IR without a dynamic chain simply updates the static part of the context, while the rest of the context is left unchanged.
A consequence of this is that fields that are not updated by the IR packet, e.g., the translation tables for list compression, MUST NOT be invalidated by the decompressor when it assumes context damage.
RTP Padding Field (R P) in Extension 3 RFC 3095 Section 5.7.5 defines the properties of RTP header flags and fields in Extension 3.
These get updated when the rtp flag of the Extension 3 is set, i.e., when rtp   1; otherwise, they are not updated.
However, it is unclear how Extension 3 updates the R P bit in the context.
INCOMPLETE RFC 3095 TEXT (RFC 3095 Section 5.7.5):
RTP Padding bit, absolute value
"R P: RTP Padding bit.
If R PT   1, R P is the absolute value of the RTP padding bit and this value updates context(R P).
If R PT   0, context(R P) is updated to zero.
RTP eXtension bit (X) in dynamic part RFC 3095 Section 5.7.7.6 defines the properties of the RTP header flags and fields in the RTP part of the dynamic chain of IR and IR  DYN packets.
However, it is unclear how the X bit is updated in the context.
INCOMPLETE RFC 3095 TEXT (RFC 3095 Section 5.7.7.6): "
X: Copy of X bit from RTP header (presumed 0 if RX   0)"
X bit from RTP header.
If RX   1, X is the X bit from the RTP header and this value updates context(X).
If RX   0, context(X) is updated to zero.
Context management and CID/context Reuse 7.1.
As part of the negotiated channel parameters, compressor and decompressor have, through the MAX CID parameter, agreed on the highest context identification (CID) number to be used.
By agreeing on MAX CID, the decompressor also agrees to provide memory resources to host at least MAX CID 1 contexts, and an established context with a CID within this negotiated space MUST be kept by the decompressor until either the CID gets reused, or the channel is taken down or renegotiated.
As part of the channel negotiation, the maximal number of active contexts supported is negotiated between the compressor and the decompressor through the MAX CID parameter.
The value of MAX CID can differ significantly from one link application to another, as well as the load in terms of the number of packet streams to compress.
The lifetime of a ROHC channel can also vary, from almost permanent to rather short lived.
However, in general, it is not expected that resources will be allocated for more contexts than what can reasonably be expected to be active concurrently over the link.
As a consequence hereof, context identifiers (CIDs) and context memory are resources that will have to be reused by the compressor as part of what can be considered normal operation.
How context resources are reused is left unspecified in RFC 3095 [1] and subsequent 3095 based ROHC specifications.
This document does not intend to change that, i.e., ROHC resource management is still considered an implementation detail.
However, reusing a CID and its allocated memory is not always as simple as initiating a context with a previously unused CID.
Because some profiles can be operating in various modes where packet formats vary depending on current mode, care has to be taken to ensure that the old context data will be completely and safely overwritten, eliminating the risk of undesired side effects from interactions between old and new context data.
This document therefore points out some important core aspects to consider when implementing resource management in ROHC compressors and decompressors.
On a high level, CID/context reuse can be of two kinds, either reuse for a new context based on the same profile as the old context, or for a new context based on a different profile.
These cases are discussed separately in the following two sub sections.
Reusing a CID/Context with the Same Profile
For multi mode profiles, such as those defined in RFC 3095 [1], mode transitions are performed using a decompressor initiated handshake procedure, as defined in RFC 3095 Section 5.6.
When a CID/context is reused for a new context based on the same profile as the old context, the current mode of operation SHOULD be inherited from the old to the new context.
Specifically, the compressor SHOULD continue to operate using the mode of operation of the old context also with the new context.
The reason for this is that there is no reliable way for the compressor to inform the decompressor that a CID/context reuse is happening.
The decompressor can thus not be expected to clear the context memory for the CID (see Section 6.3), and there is no way to trigger a safe mode switching (which requires the decompressor initiated handshake procedure).
The rule of mode inheritance applies also when the CONTEXT REINITIALIZATION signal (RFC 3095 Section 6.3.1) is used to reinitiate an entire context.
Reusing a CID/Context with a Different Profile
When a CID is reused for a new context based on a different profile than the old context, both the compressor and the decompressor MUST start operation with that context in the initial mode of the profile (if it is a multi mode profile).
This applies both to IR
initiated new contexts and profile downgrades with IR DYN (e.g., the profile 0x0001
profile 0x0002 downgrade in RFC 3095 Section 5.11.1).
Type 0 and type 1 packets have different formats in U/
O  and R mode, and
these R mode packets have no CRC.
When initiating a new context on a reused R mode CID, there is a risk that the decompressor will misinterpret compressed packets if the initiating IR packets are lost.
A CID for a context currently operating in R mode SHOULD therefore not be reused for a new context based on a different profile than the old context.
A compressor doing otherwise should minimize the risk for misinterpretation of R 0/R 1 by, e.g., not using packets of types beginning with 00 or 10 before it is highly confident that the new context has successfully been initiated at the decompressor.
In IPv4 dynamic part (RFC 3095 Section 5.7.7.4), if the 'NBO' bit is set, it means that network byte order is used.
According to RFC 3095 Section 5.7, IP ID means the compressed value of the IPv4 header's 'Identification' field.
Compressed packets contain this compressed value (IP ID), while IR packets with dynamic chain and IR DYN packets transmit the original, uncompressed Identification field value.
The IP ID field always represents the Identification value of the innermost IPv4 header whose corresponding RND flag is not 1.
If RND or RND2 is set to 1, the corresponding IP ID(s) is (are) sent as 16 bit uncompressed Identification value(s) at the end of the compressed base header, according to the IP ID description (see the beginning of RFC 3095 Section 5.7).
When there is no compressed IP  ID, i.e., for IPv6 or when all IP Identification information is sent as is (as indicated by RND/RND2 being set to 1), the decompressor ignores IP ID bits sent within compressed base headers.
When RND RND2 0, IP ID is compressed, i.e., expressed as an SN offset and byte swapped if NBO 0.
This is the case also when 16 bits of IP ID is sent in Extension 3.
When RND 0 but no IP ID bits are sent in the compressed header, the SN offset for IP ID stays unchanged, meaning that Offset m equals Offset ref, as described in Section 4.5.5.
This is further expressed in a slightly different way (with the same meaning) in Section 5.7, where it is said that "default slope(IP ID offset)   0", meaning, if no bits are sent for IP ID, its SN offset slope defaults to 0.
Extension 3 in UOR 2  Packets
Some flags of the IP header in the extension (e.g., NBO or RND) may change the interpretation of fields in UOR 2  packets.
In such cases, when a flag changes in Extension 3, a decompressor MUST re  parse the UOR 2  packet.
Multiple Occurrences of the M Bit The RTP header part of Extension 3, as defined by RFC 3095 Section 5.7.5, includes a one bit field for the RTP Marker bit.
This field is also present in all compressed base header formats except for UO  1 ID; meaning, there may be two occurrences of the field within one single compressed header.
In such cases, the two M fields must have the same value.
FORMAL ADDITION TO RFC 3095: "When there are two occurrences of the M field in a compressed header (both in the compressed base header and in the RTP part of Extension 3), the compressor MUST set both these occurrences of the M field to the same value.
At the decompressor, if the two M field values of such a packet are not identical, the packet MUST be discarded.
Multiple SN options in one feedback packet
The length of the sequence number field in the original ESP [12] header is 32 bits.
The format of the SN feedback option (RFC 3095  Section 5.7.6.6) allows for 8 additional SN bits to the 12 SN bits of the FEEDBACK 2 format (RFC 3095 Section 5.7.6.1).
One single SN feedback option is thus not enough for the decompressor to send back all the 32 bits of the ESP sequence number in a feedback packet, unless it uses multiple SN options in one feedback packet.
RFC 3095 Section 5.7.6.1 declares that a FEEDBACK 2 packet can contain a variable number of feedback options, and the options can appear in any order.
When processing multiple SN options in one feedback packet, the SN would be given by concatenating the fields.
Multiple CRC Options in One Feedback Packet
Although it is not useful to have more than one single CRC option in a feedback packet, having multiple CRC options is still allowed.
If multiple CRC options are included, all such CRC options MUST be identical, as they will be calculated over the same header; the compressor MUST otherwise discard the feedback packet.
Responding to Lost Feedback Links
Although this is neither desirable or expected, it may happen that a link used to carry feedback between two associated instances becomes unavailable.
If the compressor can be notified of such an event, the compressor SHOULD restart compression for each flow that is operating in R mode.
When restarting compression, the compressor SHOULD use a different CID for each flow being restarted; this is useful to avoid the possibility of misinterpreting the type of the compressed header for the packet type identifiers that are common to both
U/O mode and R mode, when the flow is restarted in U mode (see also Section 7.2).
Generally, feedback links are not expected to disappear once present, but it should be noted that this might be the case for certain link technologies.
UOR 2 in Profile 0x0002
One single new format is defined for UOR 2 in profile 0x0002 and profile 0x0003, which replaces all three (UOR 2, UOR 2 ID, UOR 2 TS) formats from profile 0x0001.
The same UOR 2 format is thus used independent of whether or not there are IP headers with a corresponding RND 1.
This also applies to the IP profile [4] and the IP/UDP Lite profile [5].
Sequence Number LSB's in IP Extension Headers In RFC 3095 Section 5.8.5, formats are defined for compression of IP extension header fields.
These include compressed sequence number fields, and these fields contain the "LSB of sequence number".
These sequence numbers are not "LSB encoded" as, e.g., the RTP sequence number, but are the LSB's of the uncompressed fields.
Expecting UOR 2 ACKs in O Mode Usage of UOR 2 ACKs in O mode, as discussed in RFC 3095 Section 5.4.1.1.2, is optional.
A decompressor can also send ACKs for purposes other than to acknowledge the UOR 2, without having to continue sending ACKs for all UOR 2.
Similarly, a compressor implementation can ignore UOR 2s ACKs for the purpose of adapting the optimistic approach strategies.
It is thus NOT RECOMMENDED to use the optional ACK mechanism in O  mode, either in compressor or in decompressor implementations.
Using an incorrect expectation on UOR 2 ACKs as a basis for compressor behavior will significantly degrade the compression performance.
This is because UOR 2 ACKs can be sent from a decompressor for other purposes than to acknowledge the UOR 2 packet, e.g., to send feedback such as clock resolution, or to initiate a mode transition.
If an implementation does use the optional acknowledgment algorithm described in Section 5.4.1.1.2, it must make sure to set the k 3 and n 3 parameters to much larger values than 1 to ensure that the compressor performance is not degraded due to the problem described above.
Context Repairs, TS STRIDE and TIME STRIDE
The 7 bit CRC used to verify the outcome of the decompression attempt
covers the original uncompressed header.
The CRC verification thus excludes TS STRIDE and TIME STRIDE, as these fields are not part of the original uncompressed header.
The UOR 2 packet type can be used to update the value of the TS STRIDE and/or the TIME STRIDE, with the Extension 3.
However, these fields are not used for decompression of the RTP TS field for this packet type and their respective value is thus not verified, either implicitly or explicitly.
When the compressor receives a negative acknowledgement, it thus cannot determine whether the failure may be caused by an unsuccessful update to the TS STRIDE and/or the TIME STRIDE field(s), for which a previous header that last attempted to update their value had previously been acknowledged.
FORMAL ADDITION TO RFC 3095: "When the compressor receives a NACK and uses the UOR 2 header type to repair the decompressor context, it SHOULD include fields that update the value of both the TS STRIDE and the TIME STRIDE whose value it has updated at least once since the establishment of that context, i.e., since the CID was first associated with its current profile.
When the compressor receives a static NACK, it MUST include in the IR header fields for both the TS STRIDE and the TIME STRIDE whose value it has updated at least once since the establishment of that context, i.e., since the CID was first associated with its current profile.
ROHC Negotiation RFC 3095 Section 4.1 states that the link layer must provide means to negotiate, e.g., the channel parameters listed in RFC 3095 Section 5.1.1.
One of these parameters is the PROFILES parameter, which is a set of non negative integers where each integer indicates a profile supported by the decompressor.
Each profile is identified by a 16 bit value, where the 8 LSB bits indicate the actual profile, and the 8 MSB bits indicate the variant of that profile (see RFC 3095 Section 8).
In the ROHC headers sent over the link, the profile used is identified only with the 8 LSB bits, which means that the compressor and decompressor must have agreed on which variant to use for each profile.
The negotiation protocol must thus be able to communicate to the compressor the set of profiles supported by the decompressor.
When multiple variants of the same profile are available, the negotiation protocol must provide the means for the decompressor to know which variant will be used by the compressor.
This basically means that the PROFILES set after negotiation MUST NOT include more than one variant of a profile.
PROFILES Sub option in ROHC over PPP
The logical union of sub options for IPCP and IPV6CP negotiations, as specified by ROHC over PPP [2], cannot be used for the PROFILES suboption, as the whole union would then have to be considered within each of the two IPCP negotiations to avoid getting an ambiguous profile set.
An implementation of RFC 3241 MUST therefore ensure that the same profile set is negotiated for both IPv4 and IPv6 (IPCP/IPV6CP).
Constant IP ID Encoding in IP only and UPD Lite Profiles
In the ROHC IP only profile, Section 3.3 of RFC 3843 [4], a mechanism for encoding of a constant Identification value in IPv4 (constant IP ID) is defined.
This mechanism is also used by the ROHC UDP Lite profiles, RFC 4019 [5].
The "Constant IP ID" mechanism applies to both the inner and outer IP header, when present, meaning that there will be both a SID and a SID2 context value.
This document provides a number of corrections and clarifications to [1], but it does not make any changes with regard to the security aspects of the protocol.
As a consequence, the security considerations of [1] apply without additions.
This little demo shows the four types of CRCs in use in RFC 3095, # the specification for robust header compression.
if ( $i % 16   0)
# # The CRC calculation algorithm.
# Note that the text implies that this is complemented like for PPP # (this differs from 8 , 7 , and 3 bit CRCs)
x^3 # do crc(3, 0x6, $string);
