- title: __initial_text__
  contents:
  - '                        PPP in HDLC-like Framing

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Point-to-Point Protocol (PPP) [1] provides a standard method\
    \ for\n   transporting multi-protocol datagrams over point-to-point links.\n \
    \  This document describes the use of HDLC-like framing for PPP\n   encapsulated\
    \ packets.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n     5.     Bit-stuffed framing ...................................\
    \   11\n        5.1       Flag Sequence ...................................  \
    \ 11\n        5.2       Transparency ....................................   11\n\
    \        5.3       Invalid Frames ..................................   11\n  \
    \      5.4       Time Fill .......................................   11\n    \
    \    5.5       Transmission Considerations .....................   12\n     6.\
    \     Asynchronous to Synchronous Conversion ................   13\n     7.  \
    \   Additional LCP Configuration Options ..................   14\n        7.1\
    \       Async-Control-Character-Map (ACCM) ..............   14\n     APPENDICES\
    \ ...................................................   17\n     A.     Recommended\
    \ LCP Options ...............................   17\n     B.     Automatic Recognition\
    \ of PPP Frames ...................   17\n     C.     Fast Frame Check Sequence\
    \ (FCS) Implementation ........   18\n        C.1       FCS table generator .............................\
    \   18\n        C.2       16-bit FCS Computation Method ...................  \
    \ 19\n        C.3       32-bit FCS Computation Method ...................   21\n\
    \     SECURITY CONSIDERATIONS ......................................   24\n  \
    \   REFERENCES ...................................................   24\n    \
    \ ACKNOWLEDGEMENTS .............................................   25\n     CHAIR'S\
    \ ADDRESS ..............................................   25\n     EDITOR'S ADDRESS\
    \ .............................................   25\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This specification provides for framing over both bit-oriented\
    \ and\n   octet-oriented synchronous links, and asynchronous links with 8 bits\n\
    \   of data and no parity.  These links MUST be full-duplex, but MAY be\n   either\
    \ dedicated or circuit-switched.\n   An escape mechanism is specified to allow\
    \ control data such as\n   XON/XOFF to be transmitted transparently over the link,\
    \ and to remove\n   spurious control data which may be injected into the link\
    \ by\n   intervening hardware and software.\n   Some protocols expect error free\
    \ transmission, and either provide\n   error detection only on a conditional basis,\
    \ or do not provide it at\n   all.  PPP uses the HDLC Frame Check Sequence for\
    \ error detection.\n   This is commonly available in hardware implementations,\
    \ and a\n   software implementation is provided.\n"
- title: 1.1.  Specification of Requirements
  contents:
  - "1.1.  Specification of Requirements\n   In this document, several words are used\
    \ to signify the requirements\n   of the specification.  These words are often\
    \ capitalized.\n   MUST      This word, or the adjective \"required\", means that\
    \ the\n             definition is an absolute requirement of the specification.\n\
    \   MUST NOT  This phrase means that the definition is an absolute\n         \
    \    prohibition of the specification.\n   SHOULD    This word, or the adjective\
    \ \"recommended\", means that there\n             may exist valid reasons in particular\
    \ circumstances to\n             ignore this item, but the full implications must\
    \ be\n             understood and carefully weighed before choosing a\n      \
    \       different course.\n   MAY       This word, or the adjective \"optional\"\
    , means that this\n             item is one of an allowed set of alternatives.\
    \  An\n             implementation which does not include this option MUST be\n\
    \             prepared to interoperate with another implementation which\n   \
    \          does include the option.\n"
- title: 1.2.  Terminology
  contents:
  - "1.2.  Terminology\n   This document frequently uses the following terms:\n  \
    \ datagram  The unit of transmission in the network layer (such as IP).\n    \
    \         A datagram may be encapsulated in one or more packets\n            \
    \ passed to the data link layer.\n   frame     The unit of transmission at the\
    \ data link layer.  A frame\n             may include a header and/or a trailer,\
    \ along with some\n             number of units of data.\n   packet    The basic\
    \ unit of encapsulation, which is passed across the\n             interface between\
    \ the network layer and the data link\n             layer.  A packet is usually\
    \ mapped to a frame; the\n             exceptions are when data link layer fragmentation\
    \ is being\n             performed, or when multiple packets are incorporated\
    \ into a\n             single frame.\n   peer      The other end of the point-to-point\
    \ link.\n   silently discard\n             The implementation discards the packet\
    \ without further\n             processing.  The implementation SHOULD provide\
    \ the\n             capability of logging the error, including the contents of\n\
    \             the silently discarded packet, and SHOULD record the event\n   \
    \          in a statistics counter.\n"
- title: 2.  Physical Layer Requirements
  contents:
  - "2.  Physical Layer Requirements\n   PPP is capable of operating across most DTE/DCE\
    \ interfaces (such as,\n   EIA RS-232-E, EIA RS-422, and CCITT V.35).  The only\
    \ absolute\n   requirement imposed by PPP is the provision of a full-duplex circuit,\n\
    \   either dedicated or circuit-switched, which can operate in either an\n   asynchronous\
    \ (start/stop), bit-synchronous, or octet-synchronous\n   mode, transparent to\
    \ PPP Data Link Layer frames.\n   Interface Format\n      PPP presents an octet\
    \ interface to the physical layer.  There is\n      no provision for sub-octets\
    \ to be supplied or accepted.\n   Transmission Rate\n      PPP does not impose\
    \ any restrictions regarding transmission rate,\n      other than that of the\
    \ particular DTE/DCE interface.\n   Control Signals\n      PPP does not require\
    \ the use of control signals, such as Request\n      To Send (RTS), Clear To Send\
    \ (CTS), Data Carrier Detect (DCD), and\n      Data Terminal Ready (DTR).\n  \
    \    When available, using such signals can allow greater functionality\n    \
    \  and performance.  In particular, such signals SHOULD be used to\n      signal\
    \ the Up and Down events in the LCP Option Negotiation\n      Automaton [1]. \
    \ When such signals are not available, the\n      implementation MUST signal the\
    \ Up event to LCP upon\n      initialization, and SHOULD NOT signal the Down event.\n\
    \      Because signalling is not required, the physical layer MAY be\n      decoupled\
    \ from the data link layer, hiding the transient details\n      of the physical\
    \ transport.  This has implications for mobility in\n      cellular radio networks,\
    \ and other rapidly switching links.\n      When moving from cell to cell within\
    \ the same zone, an\n      implementation MAY choose to treat the entire zone\
    \ as a single\n      link, even though transmission is switched among several\n\
    \      frequencies.  The link is considered to be with the central\n      control\
    \ unit for the zone, rather than the individual cell\n      transceivers.  However,\
    \ the link SHOULD re-establish its\n      configuration whenever the link is switched\
    \ to a different\n      administration.\n      Due to the bursty nature of data\
    \ traffic, some implementations\n      have choosen to disconnect the physical\
    \ layer during periods of\n      inactivity, and reconnect when traffic resumes,\
    \ without informing\n      the data link layer.  Robust implementations should\
    \ avoid using\n      this trick over-zealously, since the price for decreased\
    \ setup\n      latency is decreased security.  Implementations SHOULD signal the\n\
    \      Down event whenever \"significant time\" has elapsed since the link\n \
    \     was disconnected.  The value for \"significant time\" is a matter of\n \
    \     considerable debate, and is based on the tariffs, call setup\n      times,\
    \ and security concerns of the installation.\n"
- title: 3.  The Data Link Layer
  contents:
  - "3.  The Data Link Layer\n   PPP uses the principles described in ISO 3309-1979\
    \ HDLC frame\n   structure, most recently the fourth edition 3309:1991 [2], which\n\
    \   specifies modifications to allow HDLC use in asynchronous\n   environments.\n\
    \   The PPP control procedures use the Control field encodings described\n   in\
    \ ISO 4335-1979 HDLC elements of procedures, most recently the\n   fourth edition\
    \ 4335:1991 [4].\n      This should not be construed to indicate that every feature\
    \ of the\n      above recommendations are included in PPP.  Each feature included\n\
    \      is explicitly described in the following sections.\n   To remain consistent\
    \ with standard Internet practice, and avoid\n   confusion for people used to\
    \ reading RFCs, all binary numbers in the\n   following descriptions are in Most\
    \ Significant Bit to Least\n   Significant Bit order, reading from left to right,\
    \ unless otherwise\n   indicated.  Note that this is contrary to standard ISO\
    \ and CCITT\n   practice which orders bits as transmitted (network bit order).\
    \  Keep\n   this in mind when comparing this document with the international\n\
    \   standards documents.\n"
- title: 3.1.  Frame Format
  contents:
  - "3.1.  Frame Format\n   A summary of the PPP HDLC-like frame structure is shown\
    \ below.  This\n   figure does not include bits inserted for synchronization (such\
    \ as\n   start and stop bits for asynchronous links), nor any bits or octets\n\
    \   inserted for transparency.  The fields are transmitted from left to\n   right.\n\
    \           +----------+----------+----------+\n           |   Flag   | Address\
    \  | Control  |\n           | 01111110 | 11111111 | 00000011 |\n           +----------+----------+----------+\n\
    \           +----------+-------------+---------+\n           | Protocol | Information\
    \ | Padding |\n           | 8/16 bits|      *      |    *    |\n           +----------+-------------+---------+\n\
    \           +----------+----------+-----------------\n           |   FCS    |\
    \   Flag   | Inter-frame Fill\n           |16/32 bits| 01111110 | or next Address\n\
    \           +----------+----------+-----------------\n   The Protocol, Information\
    \ and Padding fields are described in the\n   Point-to-Point Protocol Encapsulation\
    \ [1].\n   Flag Sequence\n      Each frame begins and ends with a Flag Sequence,\
    \ which is the\n      binary sequence 01111110 (hexadecimal 0x7e).  All implementations\n\
    \      continuously check for this flag, which is used for frame\n      synchronization.\n\
    \      Only one Flag Sequence is required between two frames.  Two\n      consecutive\
    \ Flag Sequences constitute an empty frame, which is\n      silently discarded,\
    \ and not counted as a FCS error.\n   Address Field\n      The Address field is\
    \ a single octet, which contains the binary\n      sequence 11111111 (hexadecimal\
    \ 0xff), the All-Stations address.\n      Individual station addresses are not\
    \ assigned.  The All-Stations\n      address MUST always be recognized and received.\n\
    \      The use of other address lengths and values may be defined at a\n     \
    \ later time, or by prior agreement.  Frames with unrecognized\n      Addresses\
    \ SHOULD be silently discarded.\n   Control Field\n      The Control field is\
    \ a single octet, which contains the binary\n      sequence 00000011 (hexadecimal\
    \ 0x03), the Unnumbered Information\n      (UI) command with the Poll/Final (P/F)\
    \ bit set to zero.\n      The use of other Control field values may be defined\
    \ at a later\n      time, or by prior agreement.  Frames with unrecognized Control\n\
    \      field values SHOULD be silently discarded.\n   Frame Check Sequence (FCS)\
    \ Field\n      The Frame Check Sequence field defaults to 16 bits (two octets).\n\
    \      The FCS is transmitted least significant octet first, which\n      contains\
    \ the coefficient of the highest term.\n      A 32-bit (four octet) FCS is also\
    \ defined.  Its use may be\n      negotiated as described in \"PPP LCP Extensions\"\
    \ [5].\n      The use of other FCS lengths may be defined at a later time, or\
    \ by\n      prior agreement.\n      The FCS field is calculated over all bits\
    \ of the Address, Control,\n      Protocol, Information and Padding fields, not\
    \ including any start\n      and stop bits (asynchronous) nor any bits (synchronous)\
    \ or octets\n      (asynchronous or synchronous) inserted for transparency.  This\n\
    \      also does not include the Flag Sequences nor the FCS field itself.\n  \
    \       When octets are received which are flagged in the Async-\n         Control-Character-Map,\
    \ they are discarded before calculating\n         the FCS.\n      For more information\
    \ on the specification of the FCS, see the\n      Appendices.\n   The end of the\
    \ Information and Padding fields is found by locating\n   the closing Flag Sequence\
    \ and removing the Frame Check Sequence\n   field.\n"
- title: 3.2.  Modification of the Basic Frame
  contents:
  - "3.2.  Modification of the Basic Frame\n   The Link Control Protocol can negotiate\
    \ modifications to the standard\n   HDLC-like frame structure.  However, modified\
    \ frames will always be\n   clearly distinguishable from standard frames.\n  \
    \ Address-and-Control-Field-Compression\n      When using the standard HDLC-like\
    \ framing, the Address and Control\n      fields contain the hexadecimal values\
    \ 0xff and 0x03 respectively.\n      When other Address or Control field values\
    \ are in use, Address-\n      and-Control-Field-Compression MUST NOT be negotiated.\n\
    \      On transmission, compressed Address and Control fields are simply\n   \
    \   omitted.\n      On reception, the Address and Control fields are decompressed\
    \ by\n      examining the first two octets.  If they contain the values 0xff\n\
    \      and 0x03, they are assumed to be the Address and Control fields.\n    \
    \  If not, it is assumed that the fields were compressed and were not\n      transmitted.\n\
    \         By definition, the first octet of a two octet Protocol field\n     \
    \    will never be 0xff (since it is not even).  The Protocol field\n        \
    \ value 0x00ff is not allowed (reserved) to avoid ambiguity when\n         Protocol-Field-Compression\
    \ is enabled and the first Information\n         field octet is 0x03.\n"
- title: 4.  Octet-stuffed framing
  contents:
  - "4.  Octet-stuffed framing\n   This chapter summarizes the use of HDLC-like framing\
    \ with 8-bit\n   asynchronous and octet-synchronous links.\n"
- title: 4.1.  Flag Sequence
  contents:
  - "4.1.  Flag Sequence\n   The Flag Sequence indicates the beginning or end of a\
    \ frame.  The\n   octet stream is examined on an octet-by-octet basis for the\
    \ value\n   01111110 (hexadecimal 0x7e).\n"
- title: 4.2.  Transparency
  contents:
  - "4.2.  Transparency\n   An octet stuffing procedure is used.  The Control Escape\
    \ octet is\n   defined as binary 01111101 (hexadecimal 0x7d), most significant\
    \ bit\n   first.\n   As a minimum, sending implementations MUST escape the Flag\
    \ Sequence\n   and Control Escape octets.\n   After FCS computation, the transmitter\
    \ examines the entire frame\n   between the two Flag Sequences.  Each Flag Sequence,\
    \ Control Escape\n   octet, and any octet which is flagged in the sending Async-Control-\n\
    \   Character-Map (ACCM), is replaced by a two octet sequence consisting\n   of\
    \ the Control Escape octet followed by the original octet\n   exclusive-or'd with\
    \ hexadecimal 0x20.\n      This is bit 5 complemented, where the bit positions\
    \ are numbered\n      76543210 (the 6th bit as used in ISO numbered 87654321 --\
    \ BEWARE\n      when comparing documents).\n   Receiving implementations MUST\
    \ correctly process all Control Escape\n   sequences.\n   On reception, prior\
    \ to FCS computation, each octet with value less\n   than hexadecimal 0x20 is\
    \ checked.  If it is flagged in the receiving\n   ACCM, it is simply removed (it\
    \ may have been inserted by intervening\n   data communications equipment).  Each\
    \ Control Escape octet is also\n   removed, and the following octet is exclusive-or'd\
    \ with hexadecimal\n   0x20, unless it is the Flag Sequence (which aborts a frame).\n\
    \   A few examples may make this more clear.  Escaped data is transmitted\n  \
    \ on the link as follows:\n      0x7e is encoded as 0x7d, 0x5e.    (Flag Sequence)\n\
    \      0x7d is encoded as 0x7d, 0x5d.    (Control Escape)\n      0x03 is encoded\
    \ as 0x7d, 0x23.    (ETX)\n   Some modems with software flow control may intercept\
    \ outgoing DC1 and\n   DC3 ignoring the 8th (parity) bit.  This data would be\
    \ transmitted on\n   the link as follows:\n      0x11 is encoded as 0x7d, 0x31.\
    \    (XON)\n      0x13 is encoded as 0x7d, 0x33.    (XOFF)\n      0x91 is encoded\
    \ as 0x7d, 0xb1.    (XON with parity set)\n      0x93 is encoded as 0x7d, 0xb3.\
    \    (XOFF with parity set)\n"
- title: 4.3.  Invalid Frames
  contents:
  - "4.3.  Invalid Frames\n   Frames which are too short (less than 4 octets when\
    \ using the 16-bit\n   FCS), or which end with a Control Escape octet followed\
    \ immediately\n   by a closing Flag Sequence, or in which octet-framing is violated\
    \ (by\n   transmitting a \"0\" stop bit where a \"1\" bit is expected), are\n\
    \   silently discarded, and not counted as a FCS error.\n"
- title: 4.4.  Time Fill
  contents:
  - '4.4.  Time Fill

    '
- title: 4.4.1.  Octet-synchronous
  contents:
  - "4.4.1.  Octet-synchronous\n   There is no provision for inter-octet time fill.\n\
    \   The Flag Sequence MUST be transmitted during inter-frame time fill.\n"
- title: 4.4.2.  Asynchronous
  contents:
  - "4.4.2.  Asynchronous\n   Inter-octet time fill MUST be accomplished by transmitting\
    \ continuous\n   \"1\" bits (mark-hold state).\n   Inter-frame time fill can be\
    \ viewed as extended inter-octet time\n   fill.  Doing so can save one octet for\
    \ every frame, decreasing delay\n   and increasing bandwidth.  This is possible\
    \ since a Flag Sequence may\n   serve as both a frame end and a frame begin. \
    \ After having received\n   any frame, an idle receiver will always be in a frame\
    \ begin state.\n   Robust transmitters should avoid using this trick over-zealously,\n\
    \   since the price for decreased delay is decreased reliability.  Noisy\n   links\
    \ may cause the receiver to receive garbage characters and\n   interpret them\
    \ as part of an incoming frame.  If the transmitter does\n   not send a new opening\
    \ Flag Sequence before sending the next frame,\n   then that frame will be appended\
    \ to the noise characters causing an\n   invalid frame (with high reliability).\n\
    \   It is suggested that implementations will achieve the best results by\n  \
    \ always sending an opening Flag Sequence if the new frame is not\n   back-to-back\
    \ with the last.  Transmitters SHOULD send an open Flag\n   Sequence whenever\
    \ \"appreciable time\" has elapsed after the prior\n   closing Flag Sequence.\
    \  The maximum value for \"appreciable time\" is\n   likely to be no greater than\
    \ the typing rate of a slow typist, about\n   1 second.\n"
- title: 4.5.  Transmission Considerations
  contents:
  - '4.5.  Transmission Considerations

    '
- title: 4.5.1.  Octet-synchronous
  contents:
  - "4.5.1.  Octet-synchronous\n   The definition of various encodings and scrambling\
    \ is the\n   responsibility of the DTE/DCE equipment in use, and is outside the\n\
    \   scope of this specification.\n"
- title: 4.5.2.  Asynchronous
  contents:
  - "4.5.2.  Asynchronous\n   All octets are transmitted least significant bit first,\
    \ with one\n   start bit, eight bits of data, and one stop bit.  There is no\n\
    \   provision for seven bit asynchronous links.\n"
- title: 5.  Bit-stuffed framing
  contents:
  - "5.  Bit-stuffed framing\n   This chapter summarizes the use of HDLC-like framing\
    \ with bit-\n   synchronous links.\n"
- title: 5.1.  Flag Sequence
  contents:
  - "5.1.  Flag Sequence\n   The Flag Sequence indicates the beginning or end of a\
    \ frame, and is\n   used for frame synchronization.  The bit stream is examined\
    \ on a\n   bit-by-bit basis for the binary sequence 01111110 (hexadecimal 0x7e).\n\
    \   The \"shared zero mode\" Flag Sequence \"011111101111110\" SHOULD NOT be\n\
    \   used.  When not avoidable, such an implementation MUST ensure that\n   the\
    \ first Flag Sequence detected (the end of the frame) is promptly\n   communicated\
    \ to the link layer.  Use of the shared zero mode hinders\n   interoperability\
    \ with bit-synchronous to asynchronous and bit-\n   synchronous to octet-synchronous\
    \ converters.\n"
- title: 5.2.  Transparency
  contents:
  - "5.2.  Transparency\n   After FCS computation, the transmitter examines the entire\
    \ frame\n   between the two Flag Sequences.  A \"0\" bit is inserted after all\n\
    \   sequences of five contiguous \"1\" bits (including the last 5 bits of\n  \
    \ the FCS) to ensure that a Flag Sequence is not simulated.\n   On reception,\
    \ prior to FCS computation, any \"0\" bit that directly\n   follows five contiguous\
    \ \"1\" bits is discarded.\n"
- title: 5.3.  Invalid Frames
  contents:
  - "5.3.  Invalid Frames\n   Frames which are too short (less than 4 octets when\
    \ using the 16-bit\n   FCS), or which end with a sequence of more than six \"\
    1\" bits, are\n   silently discarded, and not counted as a FCS error.\n"
- title: 5.4.  Time Fill
  contents:
  - "5.4.  Time Fill\n   There is no provision for inter-octet time fill.\n   The\
    \ Flag Sequence SHOULD be transmitted during inter-frame time fill.\n   However,\
    \ certain types of circuit-switched links require the use of\n   mark idle (continuous\
    \ ones), particularly those that calculate\n   accounting based on periods of\
    \ bit activity.  When mark idle is used\n   on a bit-synchronous link, the implementation\
    \ MUST ensure at least 15\n   consecutive \"1\" bits between Flags during the\
    \ idle period, and that\n   the Flag Sequence is always generated at the beginning\
    \ of a frame\n   after an idle period.\n      This differs from practice in ISO\
    \ 3309, which allows 7 to 14 bit\n      mark idle.\n"
- title: 5.5.  Transmission Considerations
  contents:
  - "5.5.  Transmission Considerations\n   All octets are transmitted least significant\
    \ bit first.\n   The definition of various encodings and scrambling is the\n \
    \  responsibility of the DTE/DCE equipment in use, and is outside the\n   scope\
    \ of this specification.\n   While PPP will operate without regard to the underlying\n\
    \   representation of the bit stream, lack of standards for transmission\n   will\
    \ hinder interoperability as surely as lack of data link\n   standards.  At speeds\
    \ of 56 Kbps through 2.0 Mbps, NRZ is currently\n   most widely available, and\
    \ on that basis is recommended as a default.\n   When configuration of the encoding\
    \ is allowed, NRZI is recommended as\n   an alternative, because of its relative\
    \ immunity to signal inversion\n   configuration errors, and instances when it\
    \ MAY allow connection\n   without an expensive DSU/CSU.  Unfortunately, NRZI\
    \ encoding\n   exacerbates the missing x1 factor of the 16-bit FCS, so that one\n\
    \   error in 2**15 goes undetected (instead of one in 2**16), and triple\n   errors\
    \ are not detected.  Therefore, when NRZI is in use, it is\n   recommended that\
    \ the 32-bit FCS be negotiated, which includes the x1\n   factor.\n   At higher\
    \ speeds of up to 45 Mbps, some implementors have chosen the\n   ANSI High Speed\
    \ Synchronous Interface [HSSI].  While this experience\n   is currently limited,\
    \ implementors are encouraged to cooperate in\n   choosing transmission encoding.\n"
- title: 6.  Asynchronous to Synchronous Conversion
  contents:
  - "6.  Asynchronous to Synchronous Conversion\n   There may be some use of asynchronous-to-synchronous\
    \ converters (some\n   built into modems and cellular interfaces), resulting in\
    \ an\n   asynchronous PPP implementation on one end of a link and a\n   synchronous\
    \ implementation on the other.  It is the responsibility of\n   the converter\
    \ to do all stuffing conversions during operation.\n   To enable this functionality,\
    \ synchronous PPP implementations MUST\n   always respond to the Async-Control-Character-Map\
    \ Configuration\n   Option with the LCP Configure-Ack.  However, acceptance of\
    \ the\n   Configuration Option does not imply that the synchronous\n   implementation\
    \ will do any ACCM mapping.  Instead, all such octet\n   mapping will be performed\
    \ by the asynchronous-to-synchronous\n   converter.\n"
- title: 7.  Additional LCP Configuration Options
  contents:
  - "7.  Additional LCP Configuration Options\n   The Configuration Option format\
    \ and basic options are already defined\n   for LCP [1].\n   Up-to-date values\
    \ of the LCP Option Type field are specified in the\n   most recent \"Assigned\
    \ Numbers\" RFC [10].  This document concerns the\n   following values:\n    \
    \  2       Async-Control-Character-Map\n"
- title: 7.1.  Async-Control-Character-Map (ACCM)
  contents:
  - "7.1.  Async-Control-Character-Map (ACCM)\n   Description\n      This Configuration\
    \ Option provides a method to negotiate the use\n      of control character transparency\
    \ on asynchronous links.\n      Each end of the asynchronous link maintains two\
    \ Async-Control-\n      Character-Maps.  The receiving ACCM is 32 bits, but the\
    \ sending\n      ACCM may be up to 256 bits.  This results in four distinct ACCMs,\n\
    \      two in each direction of the link.\n      For asynchronous links, the default\
    \ receiving ACCM is 0xffffffff.\n      The default sending ACCM is 0xffffffff,\
    \ plus the Control Escape\n      and Flag Sequence characters themselves, plus\
    \ whatever other\n      outgoing characters are flagged (by prior configuration)\
    \ as likely\n      to be intercepted.\n      For other types of links, the default\
    \ value is 0, since there is\n      no need for mapping.\n         The default\
    \ inclusion of all octets less than hexadecimal 0x20\n         allows all ASCII\
    \ control characters [6] excluding DEL (Delete)\n         to be transparently\
    \ communicated through all known data\n         communications equipment.\n  \
    \    The transmitter MAY also send octets with values in the range 0x40\n    \
    \  through 0xff (except 0x5e) in Control Escape format.  Since these\n      octet\
    \ values are not negotiable, this does not solve the problem\n      of receivers\
    \ which cannot handle all non-control characters.\n      Also, since the technique\
    \ does not affect the 8th bit, this does\n      not solve problems for communications\
    \ links that can send only 7-\n      bit characters.\n         Note that this\
    \ specification differs in detail from later\n         amendments, such as 3309:1991/Amendment\
    \ 2 [3].  However, such\n         \"extended transparency\" is applied only by\
    \ \"prior agreement\".\n         Use of the transparency methods in this specification\n\
    \         constitute a prior agreement with respect to PPP.\n         For compatibility\
    \ with 3309:1991/Amendment 2, the transmitter\n         MAY escape DEL and ACCM\
    \ equivalents with the 8th (most\n         significant) bit set.  No change is\
    \ required in the receiving\n         algorithm.\n         Following ACCM negotiation,\
    \ the transmitter SHOULD cease\n         escaping DEL.\n      However, it is rarely\
    \ necessary to map all control characters, and\n      often it is unnecessary\
    \ to map any control characters.  The\n      Configuration Option is used to inform\
    \ the peer which control\n      characters MUST remain mapped when the peer sends\
    \ them.\n      The peer MAY still send any other octets in mapped format, if it\n\
    \      is necessary because of constraints known to the peer.  The peer\n    \
    \  SHOULD Configure-Nak with the logical union of the sets of mapped\n      octets,\
    \ so that when such octets are spuriously introduced they\n      can be ignored\
    \ on receipt.\n   A summary of the Async-Control-Character-Map Configuration Option\n\
    \   format is shown below.  The fields are transmitted from left to\n   right.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Type      |    Length     |               ACCM\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             ACCM (cont)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Type\n      2\n   Length\n      6\n   ACCM\n      The ACCM field is four octets,\
    \ and indicates the set of control\n      characters to be mapped.  The map is\
    \ sent most significant octet\n      first.\n      Each numbered bit corresponds\
    \ to the octet of the same value.  If\n      the bit is cleared to zero, then\
    \ that octet need not be mapped.\n      If the bit is set to one, then that octet\
    \ MUST remain mapped.  For\n      example, if bit 19 is set to zero, then the\
    \ ASCII control\n      character 19 (DC3, Control-S) MAY be sent in the clear.\n\
    \         Note: The least significant bit of the least significant octet\n   \
    \      (the final octet transmitted) is numbered bit 0, and would map\n      \
    \   to the ASCII control character NUL.\n"
- title: A.  Recommended LCP Options
  contents:
  - "A.  Recommended LCP Options\n   The following Configurations Options are recommended:\n\
    \   High Speed links\n      Magic Number\n      Link Quality Monitoring\n    \
    \  No Address and Control Field Compression\n      No Protocol Field Compression\n\
    \   Low Speed or Asynchronous links\n      Async Control Character Map\n     \
    \ Magic Number\n      Address and Control Field Compression\n      Protocol Field\
    \ Compression\n"
- title: B.  Automatic Recognition of PPP Frames
  contents:
  - "B.  Automatic Recognition of PPP Frames\n   It is sometimes desirable to detect\
    \ PPP frames, for example during a\n   login sequence.  The following octet sequences\
    \ all begin valid PPP\n   LCP frames:\n      7e ff 03 c0 21\n      7e ff 7d 23\
    \ c0 21\n      7e 7d df 7d 23 c0 21\n   Note that the first two forms are not\
    \ a valid username for Unix.\n   However, only the third form generates a correctly\
    \ checksummed PPP\n   frame, whenever 03 and ff are taken as the control characters\
    \ ETX and\n   DEL without regard to parity (they are correct for an even parity\n\
    \   link) and discarded.\n   Many implementations deal with this by putting the\
    \ interface into\n   packet mode when one of the above username patterns are detected\n\
    \   during login, without examining the initial PPP checksum.  The\n   initial\
    \ incoming PPP frame is discarded, but a Configure-Request is\n   sent immediately.\n"
- title: C.  Fast Frame Check Sequence (FCS) Implementation
  contents:
  - "C.  Fast Frame Check Sequence (FCS) Implementation\n   The FCS was originally\
    \ designed with hardware implementations in\n   mind.  A serial bit stream is\
    \ transmitted on the wire, the FCS is\n   calculated over the serial data as it\
    \ goes out, and the complement of\n   the resulting FCS is appended to the serial\
    \ stream, followed by the\n   Flag Sequence.\n   The receiver has no way of determining\
    \ that it has finished\n   calculating the received FCS until it detects the Flag\
    \ Sequence.\n   Therefore, the FCS was designed so that a particular pattern results\n\
    \   when the FCS operation passes over the complemented FCS.  A good\n   frame\
    \ is indicated by this \"good FCS\" value.\n"
- title: C.1.  FCS table generator
  contents:
  - "C.1.  FCS table generator\n   The following code creates the lookup table used\
    \ to calculate the\n   FCS-16.\n   /*\n    * Generate a FCS-16 table.\n    *\n\
    \    * Drew D. Perkins at Carnegie Mellon University.\n    *\n    * Code liberally\
    \ borrowed from Mohsen Banan and D. Hugh Redelmeier.\n    */\n   /*\n    * The\
    \ FCS-16 generator polynomial: x**0 + x**5 + x**12 + x**16.\n    */\n   #define\
    \ P       0x8408\n   main()\n   {\n       register unsigned int b, v;\n      \
    \ register int i;\n       printf(\"typedef unsigned short u16;\\n\");\n      \
    \ printf(\"static u16 fcstab[256] = {\");\n       for (b = 0; ; ) {\n        \
    \   if (b % 8 == 0)\n               printf(\"\\n\");\n           v = b;\n    \
    \       for (i = 8; i--; )\n               v = v & 1 ? (v >> 1) ^ P : v >> 1;\n\
    \           printf(\"\\t0x%04x\", v & 0xFFFF);\n           if (++b == 256)\n \
    \              break;\n           printf(\",\");\n       }\n       printf(\"\\\
    n};\\n\");\n   }\n"
- title: C.2.  16-bit FCS Computation Method
  contents:
  - "C.2.  16-bit FCS Computation Method\n   The following code provides a table lookup\
    \ computation for\n   calculating the Frame Check Sequence as data arrives at\
    \ the\n   interface.  This implementation is based on [7], [8], and [9].\n   /*\n\
    \    * u16 represents an unsigned 16-bit number.  Adjust the typedef for\n   \
    \ * your hardware.\n    */\n   typedef unsigned short u16;\n   /*\n    * FCS lookup\
    \ table as calculated by the table generator.\n    */\n   static u16 fcstab[256]\
    \ = {\n      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,\n\
    \      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,\n     \
    \ 0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,\n      0x9cc9,\
    \ 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,\n      0x2102, 0x308b,\
    \ 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,\n      0xad4a, 0xbcc3, 0x8e58,\
    \ 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,\n      0x3183, 0x200a, 0x1291, 0x0318,\
    \ 0x77a7, 0x662e, 0x54b5, 0x453c,\n      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef,\
    \ 0xea66, 0xd8fd, 0xc974,\n      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9,\
    \ 0x2732, 0x36bb,\n      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a,\
    \ 0xbaf3,\n      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,\n\
    \      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,\n     \
    \ 0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,\n      0xef4e,\
    \ 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,\n      0x7387, 0x620e,\
    \ 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,\n      0xffcf, 0xee46, 0xdcdd,\
    \ 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,\n      0x8408, 0x9581, 0xa71a, 0xb693,\
    \ 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,\n      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64,\
    \ 0x5fed, 0x6d76, 0x7cff,\n      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324,\
    \ 0xf1bf, 0xe036,\n      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7,\
    \ 0x6c7e,\n      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,\n\
    \      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,\n     \
    \ 0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,\n      0x39c3,\
    \ 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,\n      0xc60c, 0xd785,\
    \ 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,\n      0x4a44, 0x5bcd, 0x6956,\
    \ 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,\n      0xd68d, 0xc704, 0xf59f, 0xe416,\
    \ 0x90a9, 0x8120, 0xb3bb, 0xa232,\n      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1,\
    \ 0x0d68, 0x3ff3, 0x2e7a,\n      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3,\
    \ 0x8238, 0x93b1,\n      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70,\
    \ 0x1ff9,\n      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,\n\
    \      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78\n   };\n\
    \   #define PPPINITFCS16    0xffff  /* Initial FCS value */\n   #define PPPGOODFCS16\
    \    0xf0b8  /* Good final FCS value */\n   /*\n    * Calculate a new fcs given\
    \ the current fcs and the new data.\n    */\n   u16 pppfcs16(fcs, cp, len)\n \
    \      register u16 fcs;\n       register unsigned char *cp;\n       register\
    \ int len;\n   {\n       ASSERT(sizeof (u16) == 2);\n       ASSERT(((u16) -1)\
    \ > 0);\n       while (len--)\n           fcs = (fcs >> 8) ^ fcstab[(fcs ^ *cp++)\
    \ & 0xff];\n       return (fcs);\n   }\n   /*\n    * How to use the fcs\n    */\n\
    \   tryfcs16(cp, len)\n       register unsigned char *cp;\n       register int\
    \ len;\n   {\n       u16 trialfcs;\n       /* add on output */\n       trialfcs\
    \ = pppfcs16( PPPINITFCS16, cp, len );\n       trialfcs ^= 0xffff;           \
    \      /* complement */\n       cp[len] = (trialfcs & 0x00ff);      /* least significant\
    \ byte first */\n       cp[len+1] = ((trialfcs >> 8) & 0x00ff);\n       /* check\
    \ on input */\n       trialfcs = pppfcs16( PPPINITFCS16, cp, len + 2 );\n    \
    \   if ( trialfcs == PPPGOODFCS16 )\n           printf(\"Good FCS\\n\");\n   }\n"
- title: C.3.  32-bit FCS Computation Method
  contents:
  - "C.3.  32-bit FCS Computation Method\n   The following code provides a table lookup\
    \ computation for\n   calculating the 32-bit Frame Check Sequence as data arrives\
    \ at the\n   interface.\n   /*\n    * The FCS-32 generator polynomial: x**0 +\
    \ x**1 + x**2 + x**4 + x**5\n    *                      + x**7 + x**8 + x**10\
    \ + x**11 + x**12 + x**16\n    *                      + x**22 + x**23 + x**26\
    \ + x**32.\n    */\n   /*\n    * u32 represents an unsigned 32-bit number.  Adjust\
    \ the typedef for\n    * your hardware.\n    */\n   typedef unsigned long u32;\n\
    \   static u32 fcstab_32[256] =\n      {\n      0x00000000, 0x77073096, 0xee0e612c,\
    \ 0x990951ba,\n      0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n      0x0edb8832,\
    \ 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n      0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\
    \ 0x90bf1d91,\n      0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n      0x1adad47d,\
    \ 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n      0x136c9856, 0x646ba8c0, 0xfd62f97a,\
    \ 0x8a65c9ec,\n      0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n      0x3b6e20c8,\
    \ 0x4c69105e, 0xd56041e4, 0xa2677172,\n      0x3c03e4d1, 0x4b04d447, 0xd20d85fd,\
    \ 0xa50ab56b,\n      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,\n      0x32d86ce3,\
    \ 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n      0x26d930ac, 0x51de003a, 0xc8d75180,\
    \ 0xbfd06116,\n      0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n      0x2802b89e,\
    \ 0x5f058808, 0xc60cd9b2, 0xb10be924,\n      0x2f6f7c87, 0x58684c11, 0xc1611dab,\
    \ 0xb6662d3d,\n      0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,\n      0x71b18589,\
    \ 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n      0x7807c9a2, 0x0f00f934, 0x9609a88e,\
    \ 0xe10e9818,\n      0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n      0x6b6b51f4,\
    \ 0x1c6c6162, 0x856530d8, 0xf262004e,\n      0x6c0695ed, 0x1b01a57b, 0x8208f4c1,\
    \ 0xf50fc457,\n      0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,\n      0x62dd1ddf,\
    \ 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n      0x4db26158, 0x3ab551ce, 0xa3bc0074,\
    \ 0xd4bb30e2,\n      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n      0x4369e96a,\
    \ 0x346ed9fc, 0xad678846, 0xda60b8d0,\n      0x44042d73, 0x33031de5, 0xaa0a4c5f,\
    \ 0xdd0d7cc9,\n      0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,\n      0x5768b525,\
    \ 0x206f85b3, 0xb966d409, 0xce61e49f,\n      0x5edef90e, 0x29d9c998, 0xb0d09822,\
    \ 0xc7d7a8b4,\n      0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n      0xedb88320,\
    \ 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n      0xead54739, 0x9dd277af, 0x04db2615,\
    \ 0x73dc1683,\n      0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n      0xe40ecf0b,\
    \ 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n      0xf00f9344, 0x8708a3d2, 0x1e01f268,\
    \ 0x6906c2fe,\n      0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n      0xfed41b76,\
    \ 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n      0xf9b9df6f, 0x8ebeeff9, 0x17b7be43,\
    \ 0x60b08ed5,\n      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,\n      0xd1bb67f1,\
    \ 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n      0xd80d2bda, 0xaf0a1b4c, 0x36034af6,\
    \ 0x41047a60,\n      0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n      0xcb61b38c,\
    \ 0xbc66831a, 0x256fd2a0, 0x5268e236,\n      0xcc0c7795, 0xbb0b4703, 0x220216b9,\
    \ 0x5505262f,\n      0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,\n      0xc2d7ffa7,\
    \ 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n      0x9b64c2b0, 0xec63f226, 0x756aa39c,\
    \ 0x026d930a,\n      0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n      0x95bf4a82,\
    \ 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n      0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7,\
    \ 0x0bdbdf21,\n      0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,\n      0x81be16cd,\
    \ 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n      0x88085ae6, 0xff0f6a70, 0x66063bca,\
    \ 0x11010b5c,\n      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n      0xa00ae278,\
    \ 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n      0xa7672661, 0xd06016f7, 0x4969474d,\
    \ 0x3e6e77db,\n      0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,\n      0xa9bcae53,\
    \ 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n      0xbdbdf21c, 0xcabac28a, 0x53b39330,\
    \ 0x24b4a3a6,\n      0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n      0xb3667a2e,\
    \ 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n      0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\
    \ 0x2d02ef8d\n      };\n   #define PPPINITFCS32  0xffffffff   /* Initial FCS value\
    \ */\n   #define PPPGOODFCS32  0xdebb20e3   /* Good final FCS value */\n   /*\n\
    \    * Calculate a new FCS given the current FCS and the new data.\n    */\n \
    \  u32 pppfcs32(fcs, cp, len)\n       register u32 fcs;\n       register unsigned\
    \ char *cp;\n       register int len;\n       {\n       ASSERT(sizeof (u32) ==\
    \ 4);\n       ASSERT(((u32) -1) > 0);\n       while (len--)\n           fcs =\
    \ (((fcs) >> 8) ^ fcstab_32[((fcs) ^ (*cp++)) & 0xff]);\n       return (fcs);\n\
    \       }\n   /*\n    * How to use the fcs\n    */\n   tryfcs32(cp, len)\n   \
    \    register unsigned char *cp;\n       register int len;\n   {\n       u32 trialfcs;\n\
    \       /* add on output */\n       trialfcs = pppfcs32( PPPINITFCS32, cp, len\
    \ );\n       trialfcs ^= 0xffffffff;             /* complement */\n       cp[len]\
    \ = (trialfcs & 0x00ff);      /* least significant byte first */\n       cp[len+1]\
    \ = ((trialfcs >>= 8) & 0x00ff);\n       cp[len+2] = ((trialfcs >>= 8) & 0x00ff);\n\
    \       cp[len+3] = ((trialfcs >> 8) & 0x00ff);\n       /* check on input */\n\
    \       trialfcs = pppfcs32( PPPINITFCS32, cp, len + 4 );\n       if ( trialfcs\
    \ == PPPGOODFCS32 )\n           printf(\"Good FCS\\n\");\n   }\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   As noted in the Physical Layer Requirements section,\
    \ the link layer\n   might not be informed when the connected state of the physical\
    \ layer\n   has changed.  This results in possible security lapses due to over-\n\
    \   reliance on the integrity and security of switching systems and\n   administrations.\
    \  An insertion attack might be undetected.  An\n   attacker which is able to\
    \ spoof the same calling identity might be\n   able to avoid link authentication.\n"
- title: References
  contents:
  - "References\n   [1]   Simpson, W., Editor, \"The Point-to-Point Protocol (PPP)\"\
    , \n         STD 50, RFC 1661, Daydreamer, July 1994.\n   [2]   ISO/IEC 3309:1991(E),\
    \ \"Information Technology -\n         Telecommunications and information exchange\
    \ between systems -\n         High-level data link control (HDLC) procedures -\
    \ Frame\n         structure\", International Organization For Standardization,\n\
    \         Fourth edition 1991-06-01.\n   [3]   ISO/IEC 3309:1991/Amd.2:1992(E),\
    \ \"Information Technology -\n         Telecommunications and information exchange\
    \ between systems -\n         High-level data link control (HDLC) procedures -\
    \ Frame\n         structure - Amendment 2: Extended transparency options for\n\
    \         start/stop transmission\", International Organization For\n        \
    \ Standardization, 1992-01-15.\n   [4]   ISO/IEC 4335:1991(E), \"Information Technology\
    \ -\n         Telecommunications and information exchange between systems -\n\
    \         High-level data link control (HDLC) procedures - Elements of\n     \
    \    procedures\", International Organization For Standardization,\n         Fourth\
    \ edition 1991-09-15.\n   [5]   Simpson, W., Editor, \"PPP LCP Extensions\", RFC\
    \ 1570, \n         Daydreamer, January 1994.\n   [6]   ANSI X3.4-1977, \"American\
    \ National Standard Code for\n         Information Interchange\", American National\
    \ Standards\n         Institute, 1977.\n   [7]   Perez, \"Byte-wise CRC Calculations\"\
    , IEEE Micro, June 1983.\n   [8]   Morse, G., \"Calculating CRC's by Bits and\
    \ Bytes\", Byte,\n         September 1986.\n   [9]   LeVan, J., \"A Fast CRC\"\
    , Byte, November 1987.\n   [10]  Reynolds, J., and J. Postel, \"Assigned Numbers\"\
    , STD 2, RFC\n         1340, USC/Information Sciences Institute, July 1992.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This document is the product of the Point-to-Point Protocol\
    \ Working\n   Group of the Internet Engineering Task Force (IETF).  Comments should\n\
    \   be submitted to the ietf-ppp@merit.edu mailing list.\n   This specification\
    \ is based on previous RFCs, where many\n   contributions have been acknowleged.\n\
    \   The 32-bit FCS example code was provided by Karl Fox (Morning Star\n   Technologies).\n\
    \   Special thanks to Morning Star Technologies for providing computing\n   resources\
    \ and network access support for writing this specification.\n"
- title: Chair's Address
  contents:
  - "Chair's Address\n   The working group can be contacted via the current chair:\n\
    \      Fred Baker\n      Advanced Computer Communications\n      315 Bollay Drive\n\
    \      Santa Barbara, California  93117\n      fbaker@acc.com\n"
- title: Editor's Address
  contents:
  - "Editor's Address\n   Questions about this memo can also be directed to:\n   \
    \   William Allen Simpson\n      Daydreamer\n      Computer Systems Consulting\
    \ Services\n      1384 Fontaine\n      Madison Heights, Michigan  48071\n    \
    \  Bill.Simpson@um.cc.umich.edu\n          bsimpson@MorningStar.com\n"
