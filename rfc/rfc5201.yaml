- title: __initial_text__
  contents:
  - '                         Host Identity Protocol

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   The following issues describe IESG concerns about this document.\
    \  The\n   IESG expects that these issues will be addressed when future versions\n\
    \   of HIP are designed.\n   This document doesn't currently define support for\
    \ parameterized\n   (randomized) hashing in signatures, support for negotiation\
    \ of a key\n   derivation function, or support for combined encryption modes.\n\
    \   HIP defines the usage of RSA in signing and encrypting data.  Current\n  \
    \ recommendations propose usage of, for example, RSA OAEP/PSS for these\n   operations\
    \ in new protocols.  Changing the algorithms to more current\n   best practice\
    \ should be considered.\n   The current specification is currently using HMAC\
    \ for message\n   authentication.  This is considered to be acceptable for an\n\
    \   experimental RFC, but future versions must define a more generic\n   method\
    \ for message authentication, including the ability for other\n   MAC algorithms\
    \ to be used.\n   SHA-1 is no longer a preferred hashing algorithm.  This is noted\
    \ also\n   by the authors, and it is understood that future, non-experimental\n\
    \   versions must consider more secure hashing algorithms.\n   HIP requires that\
    \ an incoming packet's IP address be ignored.  In\n   simple cases this can be\
    \ done, but when there are security policies\n   based on incoming interface or\
    \ IP address rules, the situation\n   changes.  The handling of data needs to\
    \ be enhanced to cover\n   different types of network and security configurations,\
    \ as well as to\n   meet local security policies.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo specifies the details of the Host Identity Protocol (HIP).\n\
    \   HIP allows consenting hosts to securely establish and maintain shared\n  \
    \ IP-layer state, allowing separation of the identifier and locator\n   roles\
    \ of IP addresses, thereby enabling continuity of communications\n   across IP\
    \ address changes.  HIP is based on a Sigma-compliant Diffie-\n   Hellman key\
    \ exchange, using public key identifiers from a new Host\n   Identity namespace\
    \ for mutual peer authentication.  The protocol is\n   designed to be resistant\
    \ to denial-of-service (DoS) and man-in-the-\n   middle (MitM) attacks.  When\
    \ used together with another suitable\n   security protocol, such as the Encapsulated\
    \ Security Payload (ESP),\n   it provides integrity protection and optional encryption\
    \ for upper-\n   layer protocols, such as TCP and UDP.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   5\n     1.1.  A New Namespace and Identifiers . . . . . . . . .\
    \ . . . .   5\n     1.2.  The HIP Base Exchange . . . . . . . . . . . . . . .\
    \ . . .   6\n     1.3.  Memo Structure  . . . . . . . . . . . . . . . . . . .\
    \ . .   7\n   2.  Terms and Definitions . . . . . . . . . . . . . . . . . . .\
    \ .   7\n     2.1.  Requirements Terminology  . . . . . . . . . . . . . . . .\
    \   7\n     2.2.  Notation  . . . . . . . . . . . . . . . . . . . . . . . .  \
    \ 7\n     2.3.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   7\n\
    \   3.  Host Identifier (HI) and Its Representations  . . . . . . . .   8\n  \
    \   3.1.  Host Identity Tag (HIT) . . . . . . . . . . . . . . . . .   9\n    \
    \ 3.2.  Generating a HIT from an HI . . . . . . . . . . . . . . .   9\n   4. \
    \ Protocol Overview . . . . . . . . . . . . . . . . . . . . . .  10\n     4.1.\
    \  Creating a HIP Association  . . . . . . . . . . . . . . .  10\n       4.1.1.\
    \  HIP Puzzle Mechanism  . . . . . . . . . . . . . . . .  12\n       4.1.2.  Puzzle\
    \ Exchange . . . . . . . . . . . . . . . . . . .  13\n       4.1.3.  Authenticated\
    \ Diffie-Hellman Protocol . . . . . . . .  14\n       4.1.4.  HIP Replay Protection\
    \ . . . . . . . . . . . . . . . .  14\n       4.1.5.  Refusing a HIP Exchange\
    \ . . . . . . . . . . . . . . .  15\n       4.1.6.  HIP Opportunistic Mode  .\
    \ . . . . . . . . . . . . . .  16\n     4.2.  Updating a HIP Association  . .\
    \ . . . . . . . . . . . . .  18\n     4.3.  Error Processing  . . . . . . . .\
    \ . . . . . . . . . . . .  18\n     4.4.  HIP State Machine . . . . . . . . .\
    \ . . . . . . . . . . .  19\n       4.4.1.  HIP States  . . . . . . . . . . .\
    \ . . . . . . . . . .  20\n       4.4.2.  HIP State Processes . . . . . . . .\
    \ . . . . . . . . .  21\n       4.4.3.  Simplified HIP State Diagram  . . . .\
    \ . . . . . . . .  28\n     4.5.  User Data Considerations  . . . . . . . . .\
    \ . . . . . . .  30\n       4.5.1.  TCP and UDP Pseudo-Header Computation for\
    \ User Data .  30\n       4.5.2.  Sending Data on HIP Packets . . . . . . . .\
    \ . . . . .  30\n       4.5.3.  Transport Formats . . . . . . . . . . . . . .\
    \ . . . .  30\n       4.5.4.  Reboot and SA Timeout Restart of HIP  . . . . .\
    \ . . .  30\n     4.6.  Certificate Distribution  . . . . . . . . . . . . . .\
    \ . .  31\n   5.  Packet Formats  . . . . . . . . . . . . . . . . . . . . . .\
    \ .  31\n     5.1.  Payload Format  . . . . . . . . . . . . . . . . . . . . .\
    \  31\n       5.1.1.  Checksum  . . . . . . . . . . . . . . . . . . . . . .  33\n\
    \       5.1.2.  HIP Controls  . . . . . . . . . . . . . . . . . . . .  33\n  \
    \     5.1.3.  HIP Fragmentation Support . . . . . . . . . . . . . .  33\n    \
    \ 5.2.  HIP Parameters  . . . . . . . . . . . . . . . . . . . . .  34\n      \
    \ 5.2.1.  TLV Format  . . . . . . . . . . . . . . . . . . . . .  37\n       5.2.2.\
    \  Defining New Parameters . . . . . . . . . . . . . . .  38\n       5.2.3.  R1_COUNTER\
    \  . . . . . . . . . . . . . . . . . . . . .  39\n       5.2.4.  PUZZLE  . . .\
    \ . . . . . . . . . . . . . . . . . . . .  40\n       5.2.5.  SOLUTION  . . .\
    \ . . . . . . . . . . . . . . . . . . .  41\n       5.2.6.  DIFFIE_HELLMAN  .\
    \ . . . . . . . . . . . . . . . . . .  42\n       5.2.7.  HIP_TRANSFORM . . .\
    \ . . . . . . . . . . . . . . . . .  43\n       5.2.8.  HOST_ID . . . . . . .\
    \ . . . . . . . . . . . . . . . .  44\n       5.2.9.  HMAC  . . . . . . . . .\
    \ . . . . . . . . . . . . . . .  45\n       5.2.10. HMAC_2  . . . . . . . . .\
    \ . . . . . . . . . . . . . .  46\n       5.2.11. HIP_SIGNATURE . . . . . . .\
    \ . . . . . . . . . . . . .  46\n       5.2.12. HIP_SIGNATURE_2 . . . . . . .\
    \ . . . . . . . . . . . .  47\n       5.2.13. SEQ . . . . . . . . . . . . . .\
    \ . . . . . . . . . . .  48\n       5.2.14. ACK . . . . . . . . . . . . . . .\
    \ . . . . . . . . . .  48\n       5.2.15. ENCRYPTED . . . . . . . . . . . . .\
    \ . . . . . . . . .  49\n       5.2.16. NOTIFICATION  . . . . . . . . . . . .\
    \ . . . . . . . .  50\n       5.2.17. ECHO_REQUEST_SIGNED . . . . . . . . . .\
    \ . . . . . . .  54\n       5.2.18. ECHO_REQUEST_UNSIGNED . . . . . . . . . .\
    \ . . . . . .  54\n       5.2.19. ECHO_RESPONSE_SIGNED  . . . . . . . . . . .\
    \ . . . . .  55\n       5.2.20. ECHO_RESPONSE_UNSIGNED  . . . . . . . . . . .\
    \ . . . .  56\n     5.3.  HIP Packets . . . . . . . . . . . . . . . . . . . .\
    \ . . .  56\n       5.3.1.  I1 - the HIP Initiator Packet . . . . . . . . . .\
    \ . .  58\n       5.3.2.  R1 - the HIP Responder Packet . . . . . . . . . . .\
    \ .  58\n       5.3.3.  I2 - the Second HIP Initiator Packet  . . . . . . . .\
    \  61\n       5.3.4.  R2 - the Second HIP Responder Packet  . . . . . . . .  62\n\
    \       5.3.5.  UPDATE - the HIP Update Packet  . . . . . . . . . . .  62\n  \
    \     5.3.6.  NOTIFY - the HIP Notify Packet  . . . . . . . . . . .  63\n    \
    \   5.3.7.  CLOSE - the HIP Association Closing Packet  . . . . .  64\n      \
    \ 5.3.8.  CLOSE_ACK - the HIP Closing Acknowledgment Packet . .  64\n     5.4.\
    \  ICMP Messages . . . . . . . . . . . . . . . . . . . . . .  65\n       5.4.1.\
    \  Invalid Version . . . . . . . . . . . . . . . . . . .  65\n       5.4.2.  Other\
    \ Problems with the HIP Header and Packet\n               Structure . . . . .\
    \ . . . . . . . . . . . . . . . . .  65\n       5.4.3.  Invalid Puzzle Solution\
    \ . . . . . . . . . . . . . . .  65\n       5.4.4.  Non-Existing HIP Association\
    \  . . . . . . . . . . . .  66\n   6.  Packet Processing . . . . . . . . . . .\
    \ . . . . . . . . . . .  66\n     6.1.  Processing Outgoing Application Data \
    \ . . . . . . . . . .  66\n     6.2.  Processing Incoming Application Data  .\
    \ . . . . . . . . .  67\n     6.3.  Solving the Puzzle  . . . . . . . . . . .\
    \ . . . . . . . .  68\n     6.4.  HMAC and SIGNATURE Calculation and Verification\
    \ . . . . .  70\n       6.4.1.  HMAC Calculation  . . . . . . . . . . . . . .\
    \ . . . .  70\n       6.4.2.  Signature Calculation . . . . . . . . . . . . .\
    \ . . .  72\n     6.5.  HIP KEYMAT Generation . . . . . . . . . . . . . . . .\
    \ . .  74\n     6.6.  Initiation of a HIP Exchange  . . . . . . . . . . . . .\
    \ .  75\n       6.6.1.  Sending Multiple I1s in Parallel  . . . . . . . . . .\
    \  76\n       6.6.2.  Processing Incoming ICMP Protocol Unreachable\n        \
    \       Messages  . . . . . . . . . . . . . . . . . . . . . .  77\n     6.7. \
    \ Processing Incoming I1 Packets  . . . . . . . . . . . . .  77\n       6.7.1.\
    \  R1 Management . . . . . . . . . . . . . . . . . . . .  78\n       6.7.2.  Handling\
    \ Malformed Messages . . . . . . . . . . . . .  79\n     6.8.  Processing Incoming\
    \ R1 Packets  . . . . . . . . . . . . .  79\n       6.8.1.  Handling Malformed\
    \ Messages . . . . . . . . . . . . .  81\n     6.9.  Processing Incoming I2 Packets\
    \  . . . . . . . . . . . . .  81\n       6.9.1.  Handling Malformed Messages .\
    \ . . . . . . . . . . . .  84\n     6.10. Processing Incoming R2 Packets  . .\
    \ . . . . . . . . . . .  84\n     6.11. Sending UPDATE Packets  . . . . . . .\
    \ . . . . . . . . . .  84\n     6.12. Receiving UPDATE Packets  . . . . . . .\
    \ . . . . . . . . .  85\n       6.12.1. Handling a SEQ Parameter in a Received\
    \ UPDATE\n               Message . . . . . . . . . . . . . . . . . . . . . . .\
    \  86\n       6.12.2. Handling an ACK Parameter in a Received UPDATE\n       \
    \        Packet  . . . . . . . . . . . . . . . . . . . . . . .  87\n     6.13.\
    \ Processing NOTIFY Packets . . . . . . . . . . . . . . . .  87\n     6.14. Processing\
    \ CLOSE Packets  . . . . . . . . . . . . . . . .  88\n     6.15. Processing CLOSE_ACK\
    \ Packets  . . . . . . . . . . . . . .  88\n     6.16. Handling State Loss . .\
    \ . . . . . . . . . . . . . . . . .  88\n   7.  HIP Policies  . . . . . . . .\
    \ . . . . . . . . . . . . . . . .  89\n   8.  Security Considerations . . . .\
    \ . . . . . . . . . . . . . . .  89\n   9.  IANA Considerations . . . . . . .\
    \ . . . . . . . . . . . . . .  92\n   10. Acknowledgments . . . . . . . . . .\
    \ . . . . . . . . . . . . .  93\n   11. References  . . . . . . . . . . . . .\
    \ . . . . . . . . . . . .  95\n     11.1. Normative References  . . . . . . .\
    \ . . . . . . . . . . .  95\n     11.2. Informative References  . . . . . . .\
    \ . . . . . . . . . .  96\n   Appendix A.  Using Responder Puzzles  . . . . .\
    \ . . . . . . . . .  98\n   Appendix B.  Generating a Public Key Encoding from\
    \ an HI  . . . .  99\n   Appendix C.  Example Checksums for HIP Packets  . . .\
    \ . . . . . . 100\n     C.1.  IPv6 HIP Example (I1) . . . . . . . . . . . . .\
    \ . . . . . 100\n     C.2.  IPv4 HIP Packet (I1)  . . . . . . . . . . . . . .\
    \ . . . . 100\n     C.3.  TCP Segment . . . . . . . . . . . . . . . . . . . .\
    \ . . . 101\n   Appendix D.  384-Bit Group  . . . . . . . . . . . . . . . . .\
    \ . . 101\n   Appendix E.  OAKLEY Well-Known Group 1  . . . . . . . . . . . .\
    \ . 102\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memo specifies the details of the Host Identity Protocol\
    \ (HIP).\n   A high-level description of the protocol and the underlying\n   architectural\
    \ thinking is available in the separate HIP architecture\n   description [RFC4423].\
    \  Briefly, the HIP architecture proposes an\n   alternative to the dual use of\
    \ IP addresses as \"locators\" (routing\n   labels) and \"identifiers\" (endpoint,\
    \ or host, identifiers).  In HIP,\n   public cryptographic keys, of a public/private\
    \ key pair, are used as\n   Host Identifiers, to which higher layer protocols\
    \ are bound instead\n   of an IP address.  By using public keys (and their representations)\n\
    \   as host identifiers, dynamic changes to IP address sets can be\n   directly\
    \ authenticated between hosts, and if desired, strong\n   authentication between\
    \ hosts at the TCP/IP stack level can be\n   obtained.\n   This memo specifies\
    \ the base HIP protocol (\"base exchange\") used\n   between hosts to establish\
    \ an IP-layer communications context, called\n   HIP association, prior to communications.\
    \  It also defines a packet\n   format and procedures for updating an active HIP\
    \ association.  Other\n   elements of the HIP architecture are specified in other\
    \ documents,\n   such as.\n   o  \"Using the Encapsulating Security Payload (ESP)\
    \ Transport Format\n      with the Host Identity Protocol (HIP)\" [RFC5202]: how\
    \ to use the\n      Encapsulating Security Payload (ESP) for integrity protection\
    \ and\n      optional encryption\n   o  \"End-Host Mobility and Multihoming with\
    \ the Host Identity\n      Protocol\" [RFC5206]: how to support mobility and multihoming\
    \ in\n      HIP\n   o  \"Host Identity Protocol (HIP) Domain Name System (DNS)\
    \ Extensions\"\n      [RFC5205]: how to extend DNS to contain Host Identity information\n\
    \   o  \"Host Identity Protocol (HIP) Rendezvous Extension\" [RFC5204]:\n    \
    \  using a rendezvous mechanism to contact mobile HIP hosts\n"
- title: 1.1.  A New Namespace and Identifiers
  contents:
  - "1.1.  A New Namespace and Identifiers\n   The Host Identity Protocol introduces\
    \ a new namespace, the Host\n   Identity namespace.  Some ramifications of this\
    \ new namespace are\n   explained in the HIP architecture description [RFC4423].\n\
    \   There are two main representations of the Host Identity, the full\n   Host\
    \ Identifier (HI) and the Host Identity Tag (HIT).  The HI is a\n   public key\
    \ and directly represents the Identity.  Since there are\n   different public\
    \ key algorithms that can be used with different key\n   lengths, the HI is not\
    \ good for use as a packet identifier, or as an\n   index into the various operational\
    \ tables needed to support HIP.\n   Consequently, a hash of the HI, the Host Identity\
    \ Tag (HIT), becomes\n   the operational representation.  It is 128 bits long\
    \ and is used in\n   the HIP payloads and to index the corresponding state in\
    \ the end\n   hosts.  The HIT has an important security property in that it is\n\
    \   self-certifying (see Section 3).\n"
- title: 1.2.  The HIP Base Exchange
  contents:
  - "1.2.  The HIP Base Exchange\n   The HIP base exchange is a two-party cryptographic\
    \ protocol used to\n   establish communications context between hosts.  The base\
    \ exchange is\n   a Sigma-compliant [KRA03] four-packet exchange.  The first party\
    \ is\n   called the Initiator and the second party the Responder.  The four-\n\
    \   packet design helps to make HIP DoS resilient.  The protocol\n   exchanges\
    \ Diffie-Hellman keys in the 2nd and 3rd packets, and\n   authenticates the parties\
    \ in the 3rd and 4th packets.  Additionally,\n   the Responder starts a puzzle\
    \ exchange in the 2nd packet, with the\n   Initiator completing it in the 3rd\
    \ packet before the Responder stores\n   any state from the exchange.\n   The\
    \ exchange can use the Diffie-Hellman output to encrypt the Host\n   Identity\
    \ of the Initiator in the 3rd packet (although Aura, et al.,\n   [AUR03] notes\
    \ that such operation may interfere with packet-\n   inspecting middleboxes),\
    \ or the Host Identity may instead be sent\n   unencrypted.  The Responder's Host\
    \ Identity is not protected.  It\n   should be noted, however, that both the Initiator's\
    \ and the\n   Responder's HITs are transported as such (in cleartext) in the\n\
    \   packets, allowing an eavesdropper with a priori knowledge about the\n   parties\
    \ to verify their identities.\n   Data packets start to flow after the 4th packet.\
    \  The 3rd and 4th HIP\n   packets may carry a data payload in the future.  However,\
    \ the details\n   of this are to be defined later as more implementation experience\
    \ is\n   gained.\n   An existing HIP association can be updated using the update\
    \ mechanism\n   defined in this document, and when the association is no longer\n\
    \   needed, it can be closed using the defined closing mechanism.\n   Finally,\
    \ HIP is designed as an end-to-end authentication and key\n   establishment protocol,\
    \ to be used with Encapsulated Security Payload\n   (ESP) [RFC5202] and other\
    \ end-to-end security protocols.  The base\n   protocol does not cover all the\
    \ fine-grained policy control found in\n   Internet Key Exchange (IKE) [RFC4306]\
    \ that allows IKE to support\n   complex gateway policies.  Thus, HIP is not a\
    \ replacement for IKE.\n"
- title: 1.3.  Memo Structure
  contents:
  - "1.3.  Memo Structure\n   The rest of this memo is structured as follows.  Section\
    \ 2 defines\n   the central keywords, notation, and terms used throughout the\
    \ rest of\n   the document.  Section 3 defines the structure of the Host Identity\n\
    \   and its various representations.  Section 4 gives an overview of the\n   HIP\
    \ base exchange protocol.  Sections 5 and 6 define the detail\n   packet formats\
    \ and rules for packet processing.  Finally, Sections 7,\n   8, and 9 discuss\
    \ policy, security, and IANA considerations,\n   respectively.\n"
- title: 2.  Terms and Definitions
  contents:
  - '2.  Terms and Definitions

    '
- title: 2.1.  Requirements Terminology
  contents:
  - "2.1.  Requirements Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 2.2.  Notation
  contents:
  - "2.2.  Notation\n   [x]   indicates that x is optional.\n   {x}   indicates that\
    \ x is encrypted.\n   X(y)   indicates that y is a parameter of X.\n   <x>i  \
    \ indicates that x exists i times.\n   -->   signifies \"Initiator to Responder\"\
    \ communication (requests).\n   <--   signifies \"Responder to Initiator\" communication\
    \ (replies).\n   |  signifies concatenation of information-- e.g., X | Y is the\n\
    \      concatenation of X with Y.\n   Ltrunc (SHA-1(), K)   denotes the lowest\
    \ order K bits of the SHA-1\n      result.\n"
- title: 2.3.  Definitions
  contents:
  - "2.3.  Definitions\n   Unused Association Lifetime (UAL):   Implementation-specific\
    \ time for\n      which, if no packet is sent or received for this time interval,\
    \ a\n      host MAY begin to tear down an active association.\n   Maximum Segment\
    \ Lifetime (MSL):   Maximum time that a TCP segment is\n      expected to spend\
    \ in the network.\n   Exchange Complete (EC):   Time that the host spends at the\
    \ R2-SENT\n      before it moves to ESTABLISHED state.  The time is n * I2\n \
    \     retransmission timeout, where n is about I2_RETRIES_MAX.\n   HIT Hash Algorithm:\
    \   Hash algorithm used to generate a Host Identity\n      Tag (HIT) from the\
    \ Host Identity public key.  Currently SHA-1\n      [FIPS95] is used.\n   Responder's\
    \ HIT Hash Algorithm (RHASH):   Hash algorithm used for\n      various hash calculations\
    \ in this document.  The algorithm is the\n      same as is used to generate the\
    \ Responder's HIT.  RHASH is defined\n      by the Orchid Context ID.  For HIP,\
    \ the present RHASH algorithm is\n      defined in Section 3.2.  A future version\
    \ of HIP may define a new\n      RHASH algorithm by defining a new Context ID.\n\
    \   Opportunistic mode:   HIP base exchange where the Responder's HIT is\n   \
    \   not known a priori to the Initiator.\n"
- title: 3.  Host Identifier (HI) and Its Representations
  contents:
  - "3.  Host Identifier (HI) and Its Representations\n   In this section, the properties\
    \ of the Host Identifier and Host\n   Identifier Tag are discussed, and the exact\
    \ format for them is\n   defined.  In HIP, the public key of an asymmetric key\
    \ pair is used as\n   the Host Identifier (HI).  Correspondingly, the host itself\
    \ is\n   defined as the entity that holds the private key from the key pair.\n\
    \   See the HIP architecture specification [RFC4423] for more details\n   about\
    \ the difference between an identity and the corresponding\n   identifier.\n \
    \  HIP implementations MUST support the Rivest Shamir Adelman (RSA/SHA1)\n   [RFC3110]\
    \ public key algorithm, and SHOULD support the Digital\n   Signature Algorithm\
    \ (DSA) [RFC2536] algorithm; other algorithms MAY\n   be supported.\n   A hashed\
    \ encoding of the HI, the Host Identity Tag (HIT), is used in\n   protocols to\
    \ represent the Host Identity.  The HIT is 128 bits long\n   and has the following\
    \ three key properties: i) it is the same length\n   as an IPv6 address and can\
    \ be used in address-sized fields in APIs\n   and protocols, ii) it is self-certifying\
    \ (i.e., given a HIT, it is\n   computationally hard to find a Host Identity key\
    \ that matches the\n   HIT), and iii) the probability of HIT collision between\
    \ two hosts is\n   very low.\n   Carrying HIs and HITs in the header of user data\
    \ packets would\n   increase the overhead of packets.  Thus, it is not expected\
    \ that they\n   are carried in every packet, but other methods are used to map\
    \ the\n   data packets to the corresponding HIs.  In some cases, this makes it\n\
    \   possible to use HIP without any additional headers in the user data\n   packets.\
    \  For example, if ESP is used to protect data traffic, the\n   Security Parameter\
    \ Index (SPI) carried in the ESP header can be used\n   to map the encrypted data\
    \ packet to the correct HIP association.\n"
- title: 3.1.  Host Identity Tag (HIT)
  contents:
  - "3.1.  Host Identity Tag (HIT)\n   The Host Identity Tag is a 128-bit value --\
    \ a hashed encoding of the\n   Host Identifier.  There are two advantages of using\
    \ a hashed encoding\n   over the actual Host Identity public key in protocols.\
    \  Firstly, its\n   fixed length makes for easier protocol coding and also better\
    \ manages\n   the packet size cost of this technology.  Secondly, it presents\
    \ a\n   consistent format to the protocol whatever underlying identity\n   technology\
    \ is used.\n   RFC 4843 [RFC4843] specifies 128-bit hash-based identifiers, called\n\
    \   Overlay Routable Cryptographic Hash Identifiers (ORCHIDs).  Their\n   prefix,\
    \ allocated from the IPv6 address block, is defined in\n   [RFC4843].  The Host\
    \ Identity Tag is a type of ORCHID, based on a\n   SHA-1 hash of the Host Identity,\
    \ as defined in Section 2 of\n   [RFC4843].\n"
- title: 3.2.  Generating a HIT from an HI
  contents:
  - "3.2.  Generating a HIT from an HI\n   The HIT MUST be generated according to\
    \ the ORCHID generation method\n   described in [RFC4843] using a context ID value\
    \ of 0xF0EF F02F BFF4\n   3D0F E793 0C3C 6E61 74EA (this tag value has been generated\
    \ randomly\n   by the editor of this specification), and an input that encodes\
    \ the\n   Host Identity field (see Section 5.2.8) present in a HIP payload\n \
    \  packet.  The hash algorithm SHA-1 has to be used when generating HITs\n   with\
    \ this context ID.  If a new ORCHID hash algorithm is needed in\n   the future\
    \ for HIT generation, a new version of HIP has to be\n   specified with a new\
    \ ORCHID context ID associated with the new hash\n   algorithm.\n   For Identities\
    \ that are either RSA or Digital Signature Algorithm\n   (DSA) public keys, this\
    \ input consists of the public key encoding as\n   specified in the corresponding\
    \ DNSSEC document, taking the algorithm-\n   specific portion of the RDATA part\
    \ of the KEY RR.  There are\n   currently only two defined public key algorithms:\
    \ RSA/SHA1 and DSA.\n   Hence, either of the following applies:\n      The RSA\
    \ public key is encoded as defined in [RFC3110] Section 2,\n      taking the exponent\
    \ length (e_len), exponent (e), and modulus (n)\n      fields concatenated.  The\
    \ length (n_len) of the modulus (n) can be\n      determined from the total HI\
    \ Length and the preceding HI fields\n      including the exponent (e).  Thus,\
    \ the data to be hashed has the\n      same length as the HI.  The fields MUST\
    \ be encoded in network byte\n      order, as defined in [RFC3110].\n      The\
    \ DSA public key is encoded as defined in [RFC2536] Section 2,\n      taking the\
    \ fields T, Q, P, G, and Y, concatenated.  Thus, the data\n      to be hashed\
    \ is 1 + 20 + 3 * 64 + 3 * 8 * T octets long, where T\n      is the size parameter\
    \ as defined in [RFC2536].  The size parameter\n      T, affecting the field lengths,\
    \ MUST be selected as the minimum\n      value that is long enough to accommodate\
    \ P, G, and Y.  The fields\n      MUST be encoded in network byte order, as defined\
    \ in [RFC2536].\n   In Appendix B, the public key encoding process is illustrated\
    \ using\n   pseudo-code.\n"
- title: 4.  Protocol Overview
  contents:
  - "4.  Protocol Overview\n   The following material is an overview of the HIP protocol\
    \ operation,\n   and does not contain all details of the packet formats or the\
    \ packet\n   processing steps.  Sections 5 and 6 describe in more detail the\n\
    \   packet formats and packet processing steps, respectively, and are\n   normative\
    \ in case of any conflicts with this section.\n   The protocol number 139 has\
    \ been assigned by IANA to the Host\n   Identity Protocol.\n   The HIP payload\
    \ (Section 5.1) header could be carried in every IP\n   datagram.  However, since\
    \ HIP headers are relatively large (40\n   bytes), it is desirable to 'compress'\
    \ the HIP header so that the HIP\n   header only occurs in control packets used\
    \ to establish or change HIP\n   association state.  The actual method for header\
    \ 'compression' and\n   for matching data packets with existing HIP associations\
    \ (if any) is\n   defined in separate documents, describing transport formats\
    \ and\n   methods.  All HIP implementations MUST implement, at minimum, the ESP\n\
    \   transport format for HIP [RFC5202].\n"
- title: 4.1.  Creating a HIP Association
  contents:
  - "4.1.  Creating a HIP Association\n   By definition, the system initiating a HIP\
    \ exchange is the Initiator,\n   and the peer is the Responder.  This distinction\
    \ is forgotten once\n   the base exchange completes, and either party can become\
    \ the\n   Initiator in future communications.\n   The HIP base exchange serves\
    \ to manage the establishment of state\n   between an Initiator and a Responder.\
    \  The first packet, I1,\n   initiates the exchange, and the last three packets,\
    \ R1, I2, and R2,\n   constitute an authenticated Diffie-Hellman [DIF76] key exchange\
    \ for\n   session key generation.  During the Diffie-Hellman key exchange, a\n\
    \   piece of keying material is generated.  The HIP association keys are\n   drawn\
    \ from this keying material.  If other cryptographic keys are\n   needed, e.g.,\
    \ to be used with ESP, they are expected to be drawn from\n   the same keying\
    \ material.\n   The Initiator first sends a trigger packet, I1, to the Responder.\n\
    \   The packet contains only the HIT of the Initiator and possibly the\n   HIT\
    \ of the Responder, if it is known.  Note that in some cases it may\n   be possible\
    \ to replace this trigger packet by some other form of a\n   trigger, in which\
    \ case the protocol starts with the Responder sending\n   the R1 packet.\n   The\
    \ second packet, R1, starts the actual exchange.  It contains a\n   puzzle --\
    \ a cryptographic challenge that the Initiator must solve\n   before continuing\
    \ the exchange.  The level of difficulty of the\n   puzzle can be adjusted based\
    \ on level of trust with the Initiator,\n   current load, or other factors.  In\
    \ addition, the R1 contains the\n   initial Diffie-Hellman parameters and a signature,\
    \ covering part of\n   the message.  Some fields are left outside the signature\
    \ to support\n   pre-created R1s.\n   In the I2 packet, the Initiator must display\
    \ the solution to the\n   received puzzle.  Without a correct solution, the I2\
    \ message is\n   discarded.  The I2 also contains a Diffie-Hellman parameter that\n\
    \   carries needed information for the Responder.  The packet is signed\n   by\
    \ the sender.\n   The R2 packet finalizes the base exchange.  The packet is signed.\n\
    \   The base exchange is illustrated below.  The term \"key\" refers to the\n\
    \   Host Identity public key, and \"sig\" represents a signature using such\n\
    \   a key.  The packets contain other parameters not shown in this\n   figure.\n\
    \       Initiator                              Responder\n                   \
    \ I1: trigger exchange\n                  -------------------------->\n      \
    \                                        select precomputed R1\n             \
    \       R1: puzzle, D-H, key, sig\n                  <-------------------------\n\
    \    check sig                                 remain stateless\n    solve puzzle\n\
    \                  I2: solution, D-H, {key}, sig\n                  -------------------------->\n\
    \    compute D-H                               check puzzle\n                \
    \                              check sig\n                            R2: sig\n\
    \                  <--------------------------\n    check sig                \
    \                 compute D-H\n"
- title: 4.1.1.  HIP Puzzle Mechanism
  contents:
  - "4.1.1.  HIP Puzzle Mechanism\n   The purpose of the HIP puzzle mechanism is to\
    \ protect the Responder\n   from a number of denial-of-service threats.  It allows\
    \ the Responder\n   to delay state creation until receiving I2.  Furthermore,\
    \ the puzzle\n   allows the Responder to use a fairly cheap calculation to check\
    \ that\n   the Initiator is \"sincere\" in the sense that it has churned CPU\n\
    \   cycles in solving the puzzle.\n   The puzzle mechanism has been explicitly\
    \ designed to give space for\n   various implementation options.  It allows a\
    \ Responder implementation\n   to completely delay session-specific state creation\
    \ until a valid I2\n   is received.  In such a case, a correctly formatted I2\
    \ can be\n   rejected only once the Responder has checked its validity by\n  \
    \ computing one hash function.  On the other hand, the design also\n   allows\
    \ a Responder implementation to keep state about received I1s,\n   and match the\
    \ received I2s against the state, thereby allowing the\n   implementation to avoid\
    \ the computational cost of the hash function.\n   The drawback of this latter\
    \ approach is the requirement of creating\n   state.  Finally, it also allows\
    \ an implementation to use other\n   combinations of the space-saving and computation-saving\
    \ mechanisms.\n   The Responder can remain stateless and drop most spoofed I2s\
    \ because\n   puzzle calculation is based on the Initiator's Host Identity Tag.\n\
    \   The idea is that the Responder has a (perhaps varying) number of pre-\n  \
    \ calculated R1 packets, and it selects one of these based on the\n   information\
    \ carried in I1.  When the Responder then later receives\n   I2, it can verify\
    \ that the puzzle has been solved using the\n   Initiator's HIT.  This makes it\
    \ impractical for the attacker to first\n   exchange one I1/R1, and then generate\
    \ a large number of spoofed I2s\n   that seemingly come from different HITs. \
    \ The method does not protect\n   from an attacker that uses fixed HITs, though.\
    \  Against such an\n   attacker a viable approach may be to create a piece of\
    \ local state,\n   and remember that the puzzle check has previously failed. \
    \ See\n   Appendix A for one possible implementation.  Implementations SHOULD\n\
    \   include sufficient randomness to the algorithm so that algorithmic\n   complexity\
    \ attacks become impossible [CRO03].\n   The Responder can set the puzzle difficulty\
    \ for Initiator, based on\n   its level of trust of the Initiator.  Because the\
    \ puzzle is not\n   included in the signature calculation, the Responder can use\
    \ pre-\n   calculated R1 packets and include the puzzle just before sending the\n\
    \   R1 to the Initiator.  The Responder SHOULD use heuristics to\n   determine\
    \ when it is under a denial-of-service attack, and set the\n   puzzle difficulty\
    \ value K appropriately; see below.\n"
- title: 4.1.2.  Puzzle Exchange
  contents:
  - "4.1.2.  Puzzle Exchange\n   The Responder starts the puzzle exchange when it\
    \ receives an I1.  The\n   Responder supplies a random number I, and requires\
    \ the Initiator to\n   find a number J.  To select a proper J, the Initiator must\
    \ create the\n   concatenation of I, the HITs of the parties, and J, and take\
    \ a hash\n   over this concatenation using the RHASH algorithm.  The lowest order\n\
    \   K bits of the result MUST be zeros.  The value K sets the difficulty\n   of\
    \ the puzzle.\n   To generate a proper number J, the Initiator will have to generate\
    \ a\n   number of Js until one produces the hash target of zeros.  The\n   Initiator\
    \ SHOULD give up after exceeding the puzzle lifetime in the\n   PUZZLE parameter\
    \ (Section 5.2.4).  The Responder needs to re-create\n   the concatenation of\
    \ I, the HITs, and the provided J, and compute the\n   hash once to prove that\
    \ the Initiator did its assigned task.\n   To prevent precomputation attacks,\
    \ the Responder MUST select the\n   number I in such a way that the Initiator\
    \ cannot guess it.\n   Furthermore, the construction MUST allow the Responder\
    \ to verify that\n   the value was indeed selected by it and not by the Initiator.\
    \  See\n   Appendix A for an example on how to implement this.\n   Using the Opaque\
    \ data field in an ECHO_REQUEST_SIGNED\n   (Section 5.2.17) or in an ECHO_REQUEST_UNSIGNED\
    \ parameter\n   (Section 5.2.18), the Responder can include some data in R1 that\
    \ the\n   Initiator must copy unmodified in the corresponding I2 packet.  The\n\
    \   Responder can generate the Opaque data in various ways; e.g., using\n   some\
    \ secret, the sent I, and possibly other related data.  Using the\n   same secret,\
    \ the received I (from the I2), and the other related data\n   (if any), the Receiver\
    \ can verify that it has itself sent the I to\n   the Initiator.  The Responder\
    \ MUST periodically change such a used\n   secret.\n   It is RECOMMENDED that\
    \ the Responder generates a new puzzle and a new\n   R1 once every few minutes.\
    \  Furthermore, it is RECOMMENDED that the\n   Responder remembers an old puzzle\
    \ at least 2*Lifetime seconds after\n   the puzzle has been deprecated.  These\
    \ time values allow a slower\n   Initiator to solve the puzzle while limiting\
    \ the usability that an\n   old, solved puzzle has to an attacker.\n   NOTE: The\
    \ protocol developers explicitly considered whether R1 should\n   include a timestamp\
    \ in order to protect the Initiator from replay\n   attacks.  The decision was\
    \ to NOT include a timestamp.\n   NOTE: The protocol developers explicitly considered\
    \ whether a memory\n   bound function should be used for the puzzle instead of\
    \ a CPU-bound\n   function.  The decision was not to use memory-bound functions.\
    \  At\n   the time of the decision, the idea of memory-bound functions was\n \
    \  relatively new and their IPR status were unknown.  Once there is more\n   experience\
    \ about memory-bound functions and once their IPR status is\n   better known,\
    \ it may be reasonable to reconsider this decision.\n"
- title: 4.1.3.  Authenticated Diffie-Hellman Protocol
  contents:
  - "4.1.3.  Authenticated Diffie-Hellman Protocol\n   The packets R1, I2, and R2\
    \ implement a standard authenticated Diffie-\n   Hellman exchange.  The Responder\
    \ sends one or two public Diffie-\n   Hellman keys and its public authentication\
    \ key, i.e., its Host\n   Identity, in R1.  The signature in R1 allows the Initiator\
    \ to verify\n   that the R1 has been once generated by the Responder.  However,\
    \ since\n   it is precomputed and therefore does not cover all of the packet,\
    \ it\n   does not protect from replay attacks.\n   When the Initiator receives\
    \ an R1, it gets one or two public Diffie-\n   Hellman values from the Responder.\
    \  If there are two values, it\n   selects the value corresponding to the strongest\
    \ supported Group ID\n   and computes the Diffie-Hellman session key (Kij).  It\
    \ creates a HIP\n   association using keying material from the session key (see\n\
    \   Section 6.5), and may use the association to encrypt its public\n   authentication\
    \ key, i.e., Host Identity.  The resulting I2 contains\n   the Initiator's Diffie-Hellman\
    \ key and its (optionally encrypted)\n   public authentication key.  The signature\
    \ in I2 covers all of the\n   packet.\n   The Responder extracts the Initiator\
    \ Diffie-Hellman public key from\n   the I2, computes the Diffie-Hellman session\
    \ key, creates a\n   corresponding HIP association, and decrypts the Initiator's\
    \ public\n   authentication key.  It can then verify the signature using the\n\
    \   authentication key.\n   The final message, R2, is needed to protect the Initiator\
    \ from replay\n   attacks.\n"
- title: 4.1.4.  HIP Replay Protection
  contents:
  - "4.1.4.  HIP Replay Protection\n   The HIP protocol includes the following mechanisms\
    \ to protect against\n   malicious replays.  Responders are protected against\
    \ replays of I1\n   packets by virtue of the stateless response to I1s with presigned\
    \ R1\n   messages.  Initiators are protected against R1 replays by a\n   monotonically\
    \ increasing \"R1 generation counter\" included in the R1.\n   Responders are\
    \ protected against replays or false I2s by the puzzle\n   mechanism (Section\
    \ 4.1.1 above), and optional use of opaque data.\n   Hosts are protected against\
    \ replays to R2s and UPDATEs by use of a\n   less expensive HMAC verification\
    \ preceding HIP signature\n   verification.\n   The R1 generation counter is a\
    \ monotonically increasing 64-bit\n   counter that may be initialized to any value.\
    \  The scope of the\n   counter MAY be system-wide but SHOULD be per Host Identity,\
    \ if there\n   is more than one local host identity.  The value of this counter\n\
    \   SHOULD be kept across system reboots and invocations of the HIP base\n   exchange.\
    \  This counter indicates the current generation of puzzles.\n   Implementations\
    \ MUST accept puzzles from the current generation and\n   MAY accept puzzles from\
    \ earlier generations.  A system's local\n   counter MUST be incremented at least\
    \ as often as every time old R1s\n   cease to be valid, and SHOULD never be decremented,\
    \ lest the host\n   expose its peers to the replay of previously generated, higher\n\
    \   numbered R1s.  The R1 counter SHOULD NOT roll over.\n   A host may receive\
    \ more than one R1, either due to sending multiple\n   I1s (Section 6.6.1) or\
    \ due to a replay of an old R1.  When sending\n   multiple I1s, an Initiator SHOULD\
    \ wait for a small amount of time (a\n   reasonable time may be 2 * expected RTT)\
    \ after the first R1 reception\n   to allow possibly multiple R1s to arrive, and\
    \ it SHOULD respond to an\n   R1 among the set with the largest R1 generation\
    \ counter.  If an\n   Initiator is processing an R1 or has already sent an I2\
    \ (still\n   waiting for R2) and it receives another R1 with a larger R1\n   generation\
    \ counter, it MAY elect to restart R1 processing with the\n   fresher R1, as if\
    \ it were the first R1 to arrive.\n   Upon conclusion of an active HIP association\
    \ with another host, the\n   R1 generation counter associated with the peer host\
    \ SHOULD be\n   flushed.  A local policy MAY override the default flushing of\
    \ R1\n   counters on a per-HIT basis.  The reason for recommending the\n   flushing\
    \ of this counter is that there may be hosts where the R1\n   generation counter\
    \ (occasionally) decreases; e.g., due to hardware\n   failure.\n"
- title: 4.1.5.  Refusing a HIP Exchange
  contents:
  - "4.1.5.  Refusing a HIP Exchange\n   A HIP-aware host may choose not to accept\
    \ a HIP exchange.  If the\n   host's policy is to only be an Initiator, it should\
    \ begin its own HIP\n   exchange.  A host MAY choose to have such a policy since\
    \ only the\n   Initiator's HI is protected in the exchange.  There is a risk of\
    \ a\n   race condition if each host's policy is to only be an Initiator, at\n\
    \   which point the HIP exchange will fail.\n   If the host's policy does not\
    \ permit it to enter into a HIP exchange\n   with the Initiator, it should send\
    \ an ICMP 'Destination Unreachable,\n   Administratively Prohibited' message.\
    \  A more complex HIP packet is\n   not used here as it actually opens up more\
    \ potential DoS attacks than\n   a simple ICMP message.\n"
- title: 4.1.6.  HIP Opportunistic Mode
  contents:
  - "4.1.6.  HIP Opportunistic Mode\n   It is possible to initiate a HIP negotiation\
    \ even if the Responder's\n   HI (and HIT) is unknown.  In this case, the connection\
    \ initializing\n   I1 packet contains NULL (all zeros) as the destination HIT.\
    \  This\n   kind of connection setup is called opportunistic mode.\n   There are\
    \ both security and API issues involved with the\n   opportunistic mode.\n   Given\
    \ that the Responder's HI is not known by the Initiator, there\n   must be suitable\
    \ API calls that allow the Initiator to request,\n   directly or indirectly, that\
    \ the underlying kernel initiate the HIP\n   base exchange solely based on locators.\
    \  The Responder's HI will be\n   tentatively available in the R1 packet, and\
    \ in an authenticated form\n   once the R2 packet has been received and verified.\
    \  Hence, it could\n   be communicated to the application via new API mechanisms.\
    \  However,\n   with a backwards-compatible API the application sees only the\n\
    \   locators used for the initial contact.  Depending on the desired\n   semantics\
    \ of the API, this can raise the following issues:\n   o  The actual locators\
    \ may later change if an UPDATE message is used,\n      even if from the API perspective\
    \ the session still appears to be\n      between specific locators.  The locator\
    \ update is still secure,\n      however, and the session is still between the\
    \ same nodes.\n   o  Different sessions between the same locators may result in\n\
    \      connections to different nodes, if the implementation no longer\n     \
    \ remembers which identifier the peer had in another session.  This\n      is\
    \ possible when the peer's locator has changed for legitimate\n      reasons or\
    \ when an attacker pretends to be a node that has the\n      peer's locator. \
    \ Therefore, when using opportunistic mode, HIP\n      MUST NOT place any expectation\
    \ that the peer's HI returned in the\n      R1 message matches any HI previously\
    \ seen from that address.\n      If the HIP implementation and application do\
    \ not have the same\n      understanding of what constitutes a session, this may\
    \ even happen\n      within the same session.  For instance, an implementation\
    \ may not\n      know when HIP state can be purged for UDP-based applications.\n\
    \   o  As with all HIP exchanges, the handling of locator-based or\n      interface-based\
    \ policy is unclear for opportunistic mode HIP.  An\n      application may make\
    \ a connection to a specific locator because\n      the application has knowledge\
    \ of the security properties along the\n      network to that locator.  If one\
    \ of the nodes moves and the\n      locators are updated, these security properties\
    \ may not be\n      maintained.  Depending on the security policy of the application,\n\
    \      this may be a problem.  This is an area of ongoing study.  As an\n    \
    \  example, there is work to create an API that applications can use\n      to\
    \ specify their security requirements in a similar context\n      [IPsec-APIs].\n\
    \   In addition, the following security considerations apply.  The\n   generation\
    \ counter mechanism will be less efficient in protecting\n   against replays of\
    \ the R1 packet, given that the Responder can choose\n   a replay that uses any\
    \ HI, not just the one given in the I1 packet.\n   More importantly, the opportunistic\
    \ exchange is vulnerable to man-in-\n   the-middle attacks, because the Initiator\
    \ does not have any public\n   key information about the peer.  To assess the\
    \ impacts of this\n   vulnerability, we compare it to vulnerabilities in current,\
    \ non-HIP-\n   capable communications.\n   An attacker on the path between the\
    \ two peers can insert itself as a\n   man-in-the-middle by providing its own\
    \ identifier to the Initiator\n   and then initiating another HIP session towards\
    \ the Responder.  For\n   this to be possible, the Initiator must employ opportunistic\
    \ mode,\n   and the Responder must be configured to accept a connection from any\n\
    \   HIP-enabled node.\n   An attacker outside the path will be unable to do so,\
    \ given that it\n   cannot respond to the messages in the base exchange.\n   These\
    \ properties are characteristic also of communications in the\n   current Internet.\
    \  A client contacting a server without employing\n   end-to-end security may\
    \ find itself talking to the server via a man-\n   in-the-middle, assuming again\
    \ that the server is willing to talk to\n   anyone.\n   If end-to-end security\
    \ is in place, then the worst that can happen in\n   both the opportunistic HIP\
    \ and normal IP cases is denial-of-service;\n   an entity on the path can disrupt\
    \ communications, but will be unable\n   to insert itself as a man-in-the-middle.\n\
    \   However, once the opportunistic exchange has successfully completed,\n   HIP\
    \ provides integrity protection and confidentiality for the\n   communications,\
    \ and can securely change the locators of the\n   endpoints.\n   As a result,\
    \ it is believed that the HIP opportunistic mode is at\n   least as secure as\
    \ current IP.\n"
- title: 4.2.  Updating a HIP Association
  contents:
  - "4.2.  Updating a HIP Association\n   A HIP association between two hosts may\
    \ need to be updated over time.\n   Examples include the need to rekey expiring\
    \ user data security\n   associations, add new security associations, or change\
    \ IP addresses\n   associated with hosts.  The UPDATE packet is used for those\
    \ and other\n   similar purposes.  This document only specifies the UPDATE packet\n\
    \   format and basic processing rules, with mandatory parameters.  The\n   actual\
    \ usage is defined in separate specifications.\n   HIP provides a general purpose\
    \ UPDATE packet, which can carry\n   multiple HIP parameters, for updating the\
    \ HIP state between two\n   peers.  The UPDATE mechanism has the following properties:\n\
    \      UPDATE messages carry a monotonically increasing sequence number\n    \
    \  and are explicitly acknowledged by the peer.  Lost UPDATEs or\n      acknowledgments\
    \ may be recovered via retransmission.  Multiple\n      UPDATE messages may be\
    \ outstanding under certain circumstances.\n      UPDATE is protected by both\
    \ HMAC and HIP_SIGNATURE parameters,\n      since processing UPDATE signatures\
    \ alone is a potential DoS attack\n      against intermediate systems.\n     \
    \ UPDATE packets are explicitly acknowledged by the use of an\n      acknowledgment\
    \ parameter that echoes an individual sequence number\n      received from the\
    \ peer.  A single UPDATE packet may contain both a\n      sequence number and\
    \ one or more acknowledgment numbers (i.e.,\n      piggybacked acknowledgment(s)\
    \ for the peer's UPDATE).\n   The UPDATE packet is defined in Section 5.3.5.\n"
- title: 4.3.  Error Processing
  contents:
  - "4.3.  Error Processing\n   HIP error processing behavior depends on whether or\
    \ not there exists\n   an active HIP association.  In general, if a HIP association\
    \ exists\n   between the sender and receiver of a packet causing an error\n  \
    \ condition, the receiver SHOULD respond with a NOTIFY packet.  On the\n   other\
    \ hand, if there are no existing HIP associations between the\n   sender and receiver,\
    \ or the receiver cannot reasonably determine the\n   identity of the sender,\
    \ the receiver MAY respond with a suitable ICMP\n   message; see Section 5.4 for\
    \ more details.\n   The HIP protocol and state machine is designed to recover\
    \ from one of\n   the parties crashing and losing its state.  The following scenarios\n\
    \   describe the main use cases covered by the design.\n      No prior state between\
    \ the two systems.\n         The system with data to send is the Initiator.  The\
    \ process\n         follows the standard four-packet base exchange, establishing\n\
    \         the HIP association.\n      The system with data to send has no state\
    \ with the receiver, but\n      the receiver has a residual HIP association.\n\
    \         The system with data to send is the Initiator.  The Initiator\n    \
    \     acts as in no prior state, sending I1 and getting R1.  When the\n      \
    \   Responder receives a valid I2, the old association is\n         'discovered'\
    \ and deleted, and the new association is\n         established.\n      The system\
    \ with data to send has a HIP association, but the\n      receiver does not.\n\
    \         The system sends data on the outbound user data security\n         association.\
    \  The receiver 'detects' the situation when it\n         receives a user data\
    \ packet that it cannot match to any HIP\n         association.  The receiving\
    \ host MUST discard this packet.\n         Optionally, the receiving host MAY\
    \ send an ICMP packet, with\n         the type Parameter Problem, to inform the\
    \ sender that the HIP\n         association does not exist (see Section 5.4),\
    \ and it MAY\n         initiate a new HIP negotiation.  However, responding with\
    \ these\n         optional mechanisms is implementation or policy dependent.\n"
- title: 4.4.  HIP State Machine
  contents:
  - "4.4.  HIP State Machine\n   The HIP protocol itself has little state.  In the\
    \ HIP base exchange,\n   there is an Initiator and a Responder.  Once the security\n\
    \   associations (SAs) are established, this distinction is lost.  If the\n  \
    \ HIP state needs to be re-established, the controlling parameters are\n   which\
    \ peer still has state and which has a datagram to send to its\n   peer.  The\
    \ following state machine attempts to capture these\n   processes.\n   The state\
    \ machine is presented in a single system view, representing\n   either an Initiator\
    \ or a Responder.  There is not a complete overlap\n   of processing logic here\
    \ and in the packet definitions.  Both are\n   needed to completely implement\
    \ HIP.\n   Implementors must understand that the state machine, as described\n\
    \   here, is informational.  Specific implementations are free to\n   implement\
    \ the actual functions differently.  Section 6 describes the\n   packet processing\
    \ rules in more detail.  This state machine focuses\n   on the HIP I1, R1, I2,\
    \ and R2 packets only.  Other states may be\n   introduced by mechanisms in other\
    \ specifications (such as mobility\n   and multihoming).\n"
- title: 4.4.1.  HIP States
  contents:
  - "4.4.1.  HIP States\n   +---------------------+---------------------------------------------+\n\
    \   | State               | Explanation                                 |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ UNASSOCIATED        | State machine start                         |\n   |  \
    \                   |                                             |\n   | I1-SENT\
    \             | Initiating base exchange                    |\n   |          \
    \           |                                             |\n   | I2-SENT    \
    \         | Waiting to complete base exchange           |\n   |              \
    \       |                                             |\n   | R2-SENT        \
    \     | Waiting to complete base exchange           |\n   |                  \
    \   |                                             |\n   | ESTABLISHED        \
    \ | HIP association established                 |\n   |                     |\
    \                                             |\n   | CLOSING             | HIP\
    \ association closing, no data can be     |\n   |                     | sent \
    \                                       |\n   |                     |        \
    \                                     |\n   | CLOSED              | HIP association\
    \ closed, no data can be sent |\n   |                     |                  \
    \                           |\n   | E-FAILED            | HIP exchange failed\
    \                         |\n   +---------------------+---------------------------------------------+\n\
    \                            Table 1: HIP States\n"
- title: 4.4.2.  HIP State Processes
  contents:
  - "4.4.2.  HIP State Processes\n   System behavior in state UNASSOCIATED, Table\
    \ 2.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ User data to send,  | Send I1 and go to I1-SENT                   |\n   | requiring\
    \ a new HIP |                                             |\n   | association\
    \         |                                             |\n   |              \
    \       |                                             |\n   | Receive I1     \
    \     | Send R1 and stay at UNASSOCIATED            |\n   |                  \
    \   |                                             |\n   | Receive I2, process\
    \ | If successful, send R2 and go to R2-SENT    |\n   |                     |\
    \                                             |\n   |                     | If\
    \ fail, stay at UNASSOCIATED               |\n   |                     |     \
    \                                        |\n   | Receive user data   | Optionally\
    \ send ICMP as defined in          |\n   | for unknown HIP     | Section 5.4 and\
    \ stay at UNASSOCIATED        |\n   | association         |                  \
    \                           |\n   |                     |                    \
    \                         |\n   | Receive CLOSE       | Optionally send ICMP Parameter\
    \ Problem and  |\n   |                     | stay at UNASSOCIATED            \
    \            |\n   |                     |                                   \
    \          |\n   | Receive ANYOTHER    | Drop and stay at UNASSOCIATED       \
    \        |\n   +---------------------+---------------------------------------------+\n\
    \                    Table 2: UNASSOCIATED - Start state\n   System behavior in\
    \ state I1-SENT, Table 3.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ Receive I1          | If the local HIT is smaller than the peer   |\n   |  \
    \                   | HIT, drop I1 and stay at I1-SENT            |\n   |    \
    \                 |                                             |\n   |      \
    \               | If the local HIT is greater than the peer   |\n   |        \
    \             | HIT, send R1 and stay at I1_SENT            |\n   |          \
    \           |                                             |\n   | Receive I2,\
    \ process | If successful, send R2 and go to R2-SENT    |\n   |              \
    \       |                                             |\n   |                \
    \     | If fail, stay at I1-SENT                    |\n   |                  \
    \   |                                             |\n   | Receive R1, process\
    \ | If successful, send I2 and go to I2-SENT    |\n   |                     |\
    \                                             |\n   |                     | If\
    \ fail, stay at I1-SENT                    |\n   |                     |     \
    \                                        |\n   | Receive ANYOTHER    | Drop and\
    \ stay at I1-SENT                    |\n   |                     |           \
    \                                  |\n   | Timeout, increment  | If counter is\
    \ less than I1_RETRIES_MAX,     |\n   | timeout counter     | send I1 and stay\
    \ at I1-SENT                 |\n   |                     |                   \
    \                          |\n   |                     | If counter is greater\
    \ than I1_RETRIES_MAX,  |\n   |                     | go to E-FAILED         \
    \                     |\n   +---------------------+---------------------------------------------+\n\
    \                     Table 3: I1-SENT - Initiating HIP\n   System behavior in\
    \ state I2-SENT, Table 4.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ Receive I1          | Send R1 and stay at I2-SENT                 |\n   |  \
    \                   |                                             |\n   | Receive\
    \ R1, process | If successful, send I2 and cycle at I2-SENT |\n   |          \
    \           |                                             |\n   |            \
    \         | If fail, stay at I2-SENT                    |\n   |              \
    \       |                                             |\n   | Receive I2, process\
    \ | If successful and local HIT is smaller than |\n   |                     |\
    \ the peer HIT, drop I2 and stay at I2-SENT   |\n   |                     |  \
    \                                           |\n   |                     | If successful\
    \ and local HIT is greater than |\n   |                     | the peer HIT, send\
    \ R2 and go to R2-SENT     |\n   |                     |                     \
    \                        |\n   |                     | If fail, stay at I2-SENT\
    \                    |\n   |                     |                           \
    \                  |\n   | Receive R2, process | If successful, go to ESTABLISHED\
    \            |\n   |                     |                                   \
    \          |\n   |                     | If fail, stay at I2-SENT            \
    \        |\n   |                     |                                       \
    \      |\n   | Receive ANYOTHER    | Drop and stay at I2-SENT                \
    \    |\n   |                     |                                           \
    \  |\n   | Timeout, increment  | If counter is less than I2_RETRIES_MAX,     |\n\
    \   | timeout counter     | send I2 and stay at I2-SENT                 |\n  \
    \ |                     |                                             |\n   |\
    \                     | If counter is greater than I2_RETRIES_MAX,  |\n   |  \
    \                   | go to E-FAILED                              |\n   +---------------------+---------------------------------------------+\n\
    \                 Table 4: I2-SENT - Waiting to finish HIP\n   System behavior\
    \ in state R2-SENT, Table 5.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ Receive I1          | Send R1 and stay at R2-SENT                 |\n   |  \
    \                   |                                             |\n   | Receive\
    \ I2, process | If successful, send R2 and cycle at R2-SENT |\n   |          \
    \           |                                             |\n   |            \
    \         | If fail, stay at R2-SENT                    |\n   |              \
    \       |                                             |\n   | Receive R1     \
    \     | Drop and stay at R2-SENT                    |\n   |                  \
    \   |                                             |\n   | Receive R2         \
    \ | Drop and stay at R2-SENT                    |\n   |                     |\
    \                                             |\n   | Receive data or     | Move\
    \ to ESTABLISHED                         |\n   | UPDATE              |       \
    \                                      |\n   |                     |         \
    \                                    |\n   | Exchange Complete   | Move to ESTABLISHED\
    \                         |\n   | Timeout             |                      \
    \                       |\n   +---------------------+---------------------------------------------+\n\
    \                 Table 5: R2-SENT - Waiting to finish HIP\n   System behavior\
    \ in state ESTABLISHED, Table 6.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ Receive I1          | Send R1 and stay at ESTABLISHED             |\n   |  \
    \                   |                                             |\n   | Receive\
    \ I2, process | If successful, send R2, drop old HIP        |\n   | with puzzle\
    \ and     | association, establish a new HIP            |\n   | possible Opaque\
    \     | association, go to R2-SENT                  |\n   | data verification\
    \   |                                             |\n   |                    \
    \ |                                             |\n   |                     |\
    \ If fail, stay at ESTABLISHED                |\n   |                     |  \
    \                                           |\n   | Receive R1          | Drop\
    \ and stay at ESTABLISHED                |\n   |                     |       \
    \                                      |\n   | Receive R2          | Drop and\
    \ stay at ESTABLISHED                |\n   |                     |           \
    \                                  |\n   | Receive user data   | Process and stay\
    \ at ESTABLISHED             |\n   | for HIP association |                   \
    \                          |\n   |                     |                     \
    \                        |\n   | No packet           | Send CLOSE and go to CLOSING\
    \                |\n   | sent/received       |                               \
    \              |\n   | during UAL minutes  |                                 \
    \            |\n   |                     |                                   \
    \          |\n   | Receive CLOSE,      | If successful, send CLOSE_ACK and go\
    \ to     |\n   | process             | CLOSED                                \
    \      |\n   |                     |                                         \
    \    |\n   |                     | If fail, stay at ESTABLISHED              \
    \  |\n   +---------------------+---------------------------------------------+\n\
    \            Table 6: ESTABLISHED - HIP association established\n   System behavior\
    \ in state CLOSING, Table 7.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ User data to send,  | Send I1 and stay at CLOSING                 |\n   | requires\
    \ the        |                                             |\n   | creation of\
    \ another |                                             |\n   | incarnation of\
    \ the  |                                             |\n   | HIP association \
    \    |                                             |\n   |                   \
    \  |                                             |\n   | Receive I1          |\
    \ Send R1 and stay at CLOSING                 |\n   |                     |  \
    \                                           |\n   | Receive I2, process | If successful,\
    \ send R2 and go to R2-SENT    |\n   |                     |                 \
    \                            |\n   |                     | If fail, stay at CLOSING\
    \                    |\n   |                     |                           \
    \                  |\n   | Receive R1, process | If successful, send I2 and go\
    \ to I2-SENT    |\n   |                     |                                \
    \             |\n   |                     | If fail, stay at CLOSING         \
    \           |\n   |                     |                                    \
    \         |\n   | Receive CLOSE,      | If successful, send CLOSE_ACK, discard\
    \      |\n   | process             | state and go to CLOSED                  \
    \    |\n   |                     |                                           \
    \  |\n   |                     | If fail, stay at CLOSING                    |\n\
    \   |                     |                                             |\n  \
    \ | Receive CLOSE_ACK,  | If successful, discard state and go to      |\n   |\
    \ process             | UNASSOCIATED                                |\n   |  \
    \                   |                                             |\n   |    \
    \                 | If fail, stay at CLOSING                    |\n   |      \
    \               |                                             |\n   | Receive\
    \ ANYOTHER    | Drop and stay at CLOSING                    |\n   |          \
    \           |                                             |\n   | Timeout, increment\
    \  | If timeout sum is less than UAL+MSL         |\n   | timeout sum, reset  |\
    \ minutes, retransmit CLOSE and stay at       |\n   | timer               | CLOSING\
    \                                     |\n   |                     |          \
    \                                   |\n   |                     | If timeout sum\
    \ is greater than UAL+MSL      |\n   |                     | minutes, go to UNASSOCIATED\
    \                 |\n   +---------------------+---------------------------------------------+\n\
    \   Table 7: CLOSING - HIP association has not been used for UAL minutes\n   System\
    \ behavior in state CLOSED, Table 8.\n   +---------------------+---------------------------------------------+\n\
    \   | Trigger             | Action                                      |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ Datagram to send,   | Send I1, and stay at CLOSED                 |\n   | requires\
    \ the        |                                             |\n   | creation of\
    \ another |                                             |\n   | incarnation of\
    \ the  |                                             |\n   | HIP association \
    \    |                                             |\n   |                   \
    \  |                                             |\n   | Receive I1          |\
    \ Send R1 and stay at CLOSED                  |\n   |                     |  \
    \                                           |\n   | Receive I2, process | If successful,\
    \ send R2 and go to R2-SENT    |\n   |                     |                 \
    \                            |\n   |                     | If fail, stay at CLOSED\
    \                     |\n   |                     |                          \
    \                   |\n   | Receive R1, process | If successful, send I2 and go\
    \ to I2-SENT    |\n   |                     |                                \
    \             |\n   |                     | If fail, stay at CLOSED          \
    \           |\n   |                     |                                    \
    \         |\n   | Receive CLOSE,      | If successful, send CLOSE_ACK, stay at\
    \      |\n   | process             | CLOSED                                  \
    \    |\n   |                     |                                           \
    \  |\n   |                     | If fail, stay at CLOSED                     |\n\
    \   |                     |                                             |\n  \
    \ | Receive CLOSE_ACK,  | If successful, discard state and go to      |\n   |\
    \ process             | UNASSOCIATED                                |\n   |  \
    \                   |                                             |\n   |    \
    \                 | If fail, stay at CLOSED                     |\n   |      \
    \               |                                             |\n   | Receive\
    \ ANYOTHER    | Drop and stay at CLOSED                     |\n   |          \
    \           |                                             |\n   | Timeout (UAL+2MSL)\
    \  | Discard state, and go to UNASSOCIATED       |\n   +---------------------+---------------------------------------------+\n\
    \    Table 8: CLOSED - CLOSE_ACK sent, resending CLOSE_ACK if necessary\n   System\
    \ behavior in state E-FAILED, Table 9.\n   +-------------------------+-----------------------------------------+\n\
    \   | Trigger                 | Action                                  |\n  \
    \ +-------------------------+-----------------------------------------+\n   |\
    \ Wait for                | Go to UNASSOCIATED.  Re-negotiation is  |\n   | implementation-specific\
    \ | possible after moving to UNASSOCIATED   |\n   | time                    |\
    \ state.                                  |\n   +-------------------------+-----------------------------------------+\n\
    \     Table 9: E-FAILED - HIP failed to establish association with peer\n"
- title: 4.4.3.  Simplified HIP State Diagram
  contents:
  - "4.4.3.  Simplified HIP State Diagram\n   The following diagram shows the major\
    \ state transitions.  Transitions\n   based on received packets implicitly assume\
    \ that the packets are\n   successfully authenticated or processed.\n        \
    \                        +-+        +---------------------------+\n          \
    \ I1 received, send R1 | |        |                           |\n            \
    \                    | v        v                           |\n            Datagram\
    \ to send  +--------------+  I2 received, send R2   |\n              +---------------|\
    \ UNASSOCIATED |---------------+         |\n      Send I1 |               +--------------+\
    \               |         |\n              v                                 \
    \             |         |\n         +---------+  I2 received, send R2        \
    \           |         |\n   +---->| I1-SENT |---------------------------------------+\
    \ |         |\n   |     +---------+                                       | |\
    \         |\n   |          |                 +------------------------+ | |  \
    \       |\n   |          | R1 received,    | I2 received, send R2   | | |    \
    \     |\n   |          v send I2         |                        v v v      \
    \   |\n   |     +---------+            |                   +---------+       \
    \ |\n   |  +->| I2-SENT |------------+                   | R2-SENT |<----+  |\n\
    \   |  |  +---------+                                +---------+     |  |\n  \
    \ |  |          |                                     |            |  |\n   |\
    \  |          |                                 data|            |  |\n   |  |receive\
    \   |                                   or|            |  |\n   |  |R1, send \
    \ |                           EC timeout| receive I2,|  |\n   |  |I2        |R2\
    \ received +--------------+         |     send R2|  |\n   |  |          +----------->|\
    \ ESTABLISHED  |<-------+|            |  |\n   |  |                       +--------------+\
    \                      |  |\n   |  |                         |    |     |  receive\
    \ I2, send R2   |  |\n   |  |        recv+------------+    |     +------------------------+\
    \  |\n   |  |      CLOSE,|                 |                              |  |\n\
    \   |  |        send|   No packet sent|                              |  |\n  \
    \ |  |   CLOSE_ACK|   /received for |                   timeout    |  |\n   |\
    \  |            |   UAL min, send |    +---------+<-+ (UAL+MSL)  |  |\n   |  |\
    \            |           CLOSE +--->| CLOSING |--+ retransmit |  |\n   |  |  \
    \          |                      +---------+    CLOSE      |  |\n   +--|------------|----------------------+\
    \ | |  | |                |  |\n      +------------|------------------------+\
    \ |  | +----------------+  |\n      |            |              +-----------+\
    \  +------------------|--+\n      |            +------------+ | receive CLOSE,\
    \   CLOSE_ACK      |  |\n      |                         | | send CLOSE_ACK  \
    \ received or    |  |\n      |                         | |                  timeout\
    \        |  |\n      |                         | |                  (UAL+MSL)\
    \      |  |\n      |                         v v                             \
    \    |  |\n      |                        +--------+  receive I2, send R2    \
    \  |  |\n      +------------------------| CLOSED |---------------------------+\
    \  |\n                               +--------+       /----------------------+\n\
    \                                 ^ |   \\-------/  timeout (UAL+2MSL),\n    \
    \                             +-+              move to UNASSOCIATED\n        \
    \          CLOSE received, send CLOSE_ACK\n"
- title: 4.5.  User Data Considerations
  contents:
  - '4.5.  User Data Considerations

    '
- title: 4.5.1.  TCP and UDP Pseudo-Header Computation for User Data
  contents:
  - "4.5.1.  TCP and UDP Pseudo-Header Computation for User Data\n   When computing\
    \ TCP and UDP checksums on user data packets that flow\n   through sockets bound\
    \ to HITs, the IPv6 pseudo-header format\n   [RFC2460] MUST be used, even if the\
    \ actual addresses on the packet\n   are IPv4 addresses.  Additionally, the HITs\
    \ MUST be used in the place\n   of the IPv6 addresses in the IPv6 pseudo-header.\
    \  Note that the\n   pseudo-header for actual HIP payloads is computed differently;\
    \ see\n   Section 5.1.1.\n"
- title: 4.5.2.  Sending Data on HIP Packets
  contents:
  - "4.5.2.  Sending Data on HIP Packets\n   A future version of this document may\
    \ define how to include user data\n   on various HIP packets.  However, currently\
    \ the HIP header is a\n   terminal header, and not followed by any other headers.\n"
- title: 4.5.3.  Transport Formats
  contents:
  - "4.5.3.  Transport Formats\n   The actual data transmission format, used for user\
    \ data after the HIP\n   base exchange, is not defined in this document.  Such\
    \ transport\n   formats and methods are described in separate specifications.\
    \  All\n   HIP implementations MUST implement, at minimum, the ESP transport\n\
    \   format for HIP [RFC5202].\n   When new transport formats are defined, they\
    \ get the type value from\n   the HIP Transform type value space 2048-4095.  The\
    \ order in which the\n   transport formats are presented in the R1 packet, is\
    \ the preferred\n   order.  The last of the transport formats MUST be ESP transport\n\
    \   format, represented by the ESP_TRANSFORM parameter.\n"
- title: 4.5.4.  Reboot and SA Timeout Restart of HIP
  contents:
  - "4.5.4.  Reboot and SA Timeout Restart of HIP\n   Simulating a loss of state is\
    \ a potential DoS attack.  The following\n   process has been crafted to manage\
    \ state recovery without presenting\n   a DoS opportunity.\n   If a host reboots\
    \ or the HIP association times out, it has lost its\n   HIP state.  If the host\
    \ that lost state has a datagram to send to the\n   peer, it simply restarts the\
    \ HIP base exchange.  After the base\n   exchange has completed, the Initiator\
    \ can create a new SA and start\n   sending data.  The peer does not reset its\
    \ state until it receives a\n   valid I2 HIP packet.\n   If a system receives\
    \ a user data packet that cannot be matched to any\n   existing HIP association,\
    \ it is possible that it has lost the state\n   and its peer has not.  It MAY\
    \ send an ICMP packet with the Parameter\n   Problem type, and with the pointer\
    \ pointing to the referred HIP-\n   related association information.  Reacting\
    \ to such traffic depends on\n   the implementation and the environment where\
    \ the implementation is\n   used.\n   If the host, that apparently has lost its\
    \ state, decides to restart\n   the HIP base exchange, it sends an I1 packet to\
    \ the peer.  After the\n   base exchange has been completed successfully, the\
    \ Initiator can\n   create a new HIP association and the peer drops its old SA\
    \ and\n   creates a new one.\n"
- title: 4.6.  Certificate Distribution
  contents:
  - "4.6.  Certificate Distribution\n   This document does not define how to use certificates\
    \ or how to\n   transfer them between hosts.  These functions are expected to\
    \ be\n   defined in a future specification.  A parameter type value, meant to\n\
    \   be used for carrying certificates, is reserved, though: CERT, Type\n   768;\
    \ see Section 5.2.\n"
- title: 5.  Packet Formats
  contents:
  - '5.  Packet Formats

    '
- title: 5.1.  Payload Format
  contents:
  - "5.1.  Payload Format\n   All HIP packets start with a fixed header.\n    0  \
    \                 1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Header   | Header Length |0| Packet Type |  VER. | RES.|1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Checksum             |           Controls            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Sender's Host Identity Tag (HIT)               |\n   |  \
    \                                                             |\n   |        \
    \                                                       |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Receiver's Host Identity Tag (HIT)              |\n   |  \
    \                                                             |\n   |        \
    \                                                       |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                      HIP Parameters                         /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The HIP header is logically an IPv6 extension header.  However, this\n   document\
    \ does not describe processing for Next Header values other\n   than decimal 59,\
    \ IPPROTO_NONE, the IPv6 'no next header' value.\n   Future documents MAY do so.\
    \  However, current implementations MUST\n   ignore trailing data if an unimplemented\
    \ Next Header value is\n   received.\n   The Header Length field contains the\
    \ length of the HIP Header and HIP\n   parameters in 8-byte units, excluding the\
    \ first 8 bytes.  Since all\n   HIP headers MUST contain the sender's and receiver's\
    \ HIT fields, the\n   minimum value for this field is 4, and conversely, the maximum\
    \ length\n   of the HIP Parameters field is (255*8)-32 = 2008 bytes.  Note: this\n\
    \   sets an additional limit for sizes of parameters included in the\n   Parameters\
    \ field, independent of the individual parameter maximum\n   lengths.\n   The\
    \ Packet Type indicates the HIP packet type.  The individual packet\n   types\
    \ are defined in the relevant sections.  If a HIP host receives a\n   HIP packet\
    \ that contains an unknown packet type, it MUST drop the\n   packet.\n   The HIP\
    \ Version is four bits.  The current version is 1.  The version\n   number is\
    \ expected to be incremented only if there are incompatible\n   changes to the\
    \ protocol.  Most extensions can be handled by defining\n   new packet types,\
    \ new parameter types, or new controls.\n   The following three bits are reserved\
    \ for future use.  They MUST be\n   zero when sent, and they SHOULD be ignored\
    \ when handling a received\n   packet.\n   The two fixed bits in the header are\
    \ reserved for potential SHIM6\n   compatibility [SHIM6-PROTO].  For implementations\
    \ adhering (only) to\n   this specification, they MUST be set as shown when sending\
    \ and MUST\n   be ignored when receiving.  This is to ensure optimal forward\n\
    \   compatibility.  Note that for implementations that implement other\n   compatible\
    \ specifications in addition to this specification, the\n   corresponding rules\
    \ may well be different.  For example, in the case\n   that the forthcoming SHIM6\
    \ protocol happens to be compatible with\n   this specification, an implementation\
    \ that implements both this\n   specification and the SHIM6 protocol may need\
    \ to check these bits in\n   order to determine how to handle the packet.\n  \
    \ The HIT fields are always 128 bits (16 bytes) long.\n"
- title: 5.1.1.  Checksum
  contents:
  - "5.1.1.  Checksum\n   Since the checksum covers the source and destination addresses\
    \ in the\n   IP header, it must be recomputed on HIP-aware NAT devices.\n   If\
    \ IPv6 is used to carry the HIP packet, the pseudo-header [RFC2460]\n   contains\
    \ the source and destination IPv6 addresses, HIP packet length\n   in the pseudo-header\
    \ length field, a zero field, and the HIP protocol\n   number (see Section 4)\
    \ in the Next Header field.  The length field is\n   in bytes and can be calculated\
    \ from the HIP header length field: (HIP\n   Header Length + 1) * 8.\n   In case\
    \ of using IPv4, the IPv4 UDP pseudo-header format [RFC0768] is\n   used.  In\
    \ the pseudo-header, the source and destination addresses are\n   those used in\
    \ the IP header, the zero field is obviously zero, the\n   protocol is the HIP\
    \ protocol number (see Section 4), and the length\n   is calculated as in the\
    \ IPv6 case.\n"
- title: 5.1.2.  HIP Controls
  contents:
  - "5.1.2.  HIP Controls\n   The HIP Controls section conveys information about the\
    \ structure of\n   the packet and capabilities of the host.\n   The following\
    \ fields have been defined:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \ | | | | | | | | | | | | | | |A|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n \
    \  A - Anonymous:   If this is set, the sender's HI in this packet is\n      anonymous,\
    \ i.e., one not listed in a directory.  Anonymous HIs\n      SHOULD NOT be stored.\
    \  This control is set in packets R1 and/or\n      I2.  The peer receiving an\
    \ anonymous HI may choose to refuse it.\n   The rest of the fields are reserved\
    \ for future use and MUST be set to\n   zero on sent packets and ignored on received\
    \ packets.\n"
- title: 5.1.3.  HIP Fragmentation Support
  contents:
  - "5.1.3.  HIP Fragmentation Support\n   A HIP implementation must support IP fragmentation/reassembly.\n\
    \   Fragment reassembly MUST be implemented in both IPv4 and IPv6, but\n   fragment\
    \ generation is REQUIRED to be implemented in IPv4 (IPv4\n   stacks and networks\
    \ will usually do this by default) and RECOMMENDED\n   to be implemented in IPv6.\
    \  In IPv6 networks, the minimum MTU is\n   larger, 1280 bytes, than in IPv4 networks.\
    \  The larger MTU size is\n   usually sufficient for most HIP packets, and therefore\
    \ fragment\n   generation may not be needed.  If a host expects to send HIP packets\n\
    \   that are larger than the minimum IPv6 MTU, it MUST implement fragment\n  \
    \ generation even for IPv6.\n   In IPv4 networks, HIP packets may encounter low\
    \ MTUs along their\n   routed path.  Since HIP does not provide a mechanism to\
    \ use multiple\n   IP datagrams for a single HIP packet, support for path MTU\
    \ discovery\n   does not bring any value to HIP in IPv4 networks.  HIP-aware NAT\n\
    \   devices MUST perform any IPv4 reassembly/fragmentation.\n   All HIP implementations\
    \ have to be careful while employing a\n   reassembly algorithm so that the algorithm\
    \ is sufficiently resistant\n   to DoS attacks.\n   Because certificate chains\
    \ can cause the packet to be fragmented and\n   fragmentation can open implementation\
    \ to denial-of-service attacks\n   [KAU03], it is strongly recommended that the\
    \ separate document\n   specifying the certificate usage in the HIP Base Exchange\
    \ defines the\n   usage of \"Hash and URL\" formats rather than including certificates\
    \ in\n   exchanges.  With this, most problems related to DoS attacks with\n  \
    \ fragmentation can be avoided.\n"
- title: 5.2.  HIP Parameters
  contents:
  - "5.2.  HIP Parameters\n   The HIP Parameters are used to carry the public key\
    \ associated with\n   the sender's HIT, together with related security and other\n\
    \   information.  They consist of ordered parameters, encoded in TLV\n   format.\n\
    \   The following parameter types are currently defined.\n   +------------------------+-------+----------+-----------------------+\n\
    \   | TLV                    | Type  | Length   | Data                  |\n  \
    \ +------------------------+-------+----------+-----------------------+\n   |\
    \ R1_COUNTER             | 128   | 12       | System Boot Counter   |\n   |  \
    \                      |       |          |                       |\n   | PUZZLE\
    \                 | 257   | 12       | K and Random #I       |\n   |         \
    \               |       |          |                       |\n   | SOLUTION  \
    \             | 321   | 20       | K, Random #I and      |\n   |             \
    \           |       |          | puzzle solution J     |\n   |               \
    \         |       |          |                       |\n   | SEQ             \
    \       | 385   | 4        | Update packet ID      |\n   |                   \
    \     |       |          | number                |\n   |                     \
    \   |       |          |                       |\n   | ACK                   \
    \ | 449   | variable | Update packet ID      |\n   |                        |\
    \       |          | number                |\n   |                        |  \
    \     |          |                       |\n   | DIFFIE_HELLMAN         | 513\
    \   | variable | public key            |\n   |                        |      \
    \ |          |                       |\n   | HIP_TRANSFORM          | 577   |\
    \ variable | HIP Encryption and    |\n   |                        |       |  \
    \        | Integrity Transform   |\n   |                        |       |    \
    \      |                       |\n   | ENCRYPTED              | 641   | variable\
    \ | Encrypted part of I2  |\n   |                        |       |          |\
    \ packet                |\n   |                        |       |          |  \
    \                     |\n   | HOST_ID                | 705   | variable | Host\
    \ Identity with    |\n   |                        |       |          | Fully-Qualified\
    \       |\n   |                        |       |          | Domain FQDN (Name)\
    \ or |\n   |                        |       |          | Network Access      \
    \  |\n   |                        |       |          | Identifier (NAI)      |\n\
    \   |                        |       |          |                       |\n  \
    \ | CERT                   | 768   | variable | HI Certificate; used  |\n   |\
    \                        |       |          | to transfer           |\n   |  \
    \                      |       |          | certificates.  Usage  |\n   |    \
    \                    |       |          | is not currently      |\n   |      \
    \                  |       |          | defined, but it will  |\n   |        \
    \                |       |          | be specified in a     |\n   |          \
    \              |       |          | separate document     |\n   |            \
    \            |       |          | once needed.          |\n   |              \
    \          |       |          |                       |\n   | NOTIFICATION   \
    \        | 832   | variable | Informational data    |\n   |                  \
    \      |       |          |                       |\n   | ECHO_REQUEST_SIGNED\
    \    | 897   | variable | Opaque data to be     |\n   |                      \
    \  |       |          | echoed back; under    |\n   |                        |\
    \       |          | signature             |\n   |                        |  \
    \     |          |                       |\n   | ECHO_RESPONSE_SIGNED   | 961\
    \   | variable | Opaque data echoed    |\n   |                        |      \
    \ |          | back; under signature |\n   |                        |       |\
    \          |                       |\n   | HMAC                   | 61505 | variable\
    \ | HMAC-based message    |\n   |                        |       |          |\
    \ authentication code,  |\n   |                        |       |          | with\
    \ key material     |\n   |                        |       |          | from HIP_TRANSFORM\
    \    |\n   |                        |       |          |                     \
    \  |\n   | HMAC_2                 | 61569 | variable | HMAC based message    |\n\
    \   |                        |       |          | authentication code,  |\n  \
    \ |                        |       |          | with key material     |\n   |\
    \                        |       |          | from HIP_TRANSFORM.   |\n   |  \
    \                      |       |          | Compared to HMAC, the |\n   |    \
    \                    |       |          | HOST_ID parameter is  |\n   |      \
    \                  |       |          | included in HMAC_2    |\n   |        \
    \                |       |          | calculation.          |\n   |          \
    \              |       |          |                       |\n   | HIP_SIGNATURE_2\
    \        | 61633 | variable | Signature of the R1   |\n   |                  \
    \      |       |          | packet                |\n   |                    \
    \    |       |          |                       |\n   | HIP_SIGNATURE        \
    \  | 61697 | variable | Signature of the      |\n   |                        |\
    \       |          | packet                |\n   |                        |  \
    \     |          |                       |\n   | ECHO_REQUEST_UNSIGNED  | 63661\
    \ | variable | Opaque data to be     |\n   |                        |       |\
    \          | echoed back; after    |\n   |                        |       |  \
    \        | signature             |\n   |                        |       |    \
    \      |                       |\n   | ECHO_RESPONSE_UNSIGNED | 63425 | variable\
    \ | Opaque data echoed    |\n   |                        |       |          |\
    \ back; after signature |\n   +------------------------+-------+----------+-----------------------+\n\
    \   Because the ordering (from lowest to highest) of HIP parameters is\n   strictly\
    \ enforced (see Section 5.2.1), the parameter type values for\n   existing parameters\
    \ have been spaced to allow for future protocol\n   extensions.  Parameters numbered\
    \ between 0-1023 are used in HIP\n   handshake and update procedures and are covered\
    \ by signatures.\n   Parameters numbered between 1024-2047 are reserved.  Parameters\n\
    \   numbered between 2048-4095 are used for parameters related to HIP\n   transform\
    \ types.  Parameters numbered between 4096 and (2^16 - 2^12)\n   61439 are reserved.\
    \  Parameters numbered between 61440-62463 are used\n   for signatures and signed\
    \ MACs.  Parameters numbered between 62464-\n   63487 are used for parameters\
    \ that fall outside of the signed area of\n   the packet.  Parameters numbered\
    \ between 63488-64511 are used for\n   rendezvous and other relaying services.\
    \  Parameters numbered between\n   64512-65535 are reserved.\n"
- title: 5.2.1.  TLV Format
  contents:
  - "5.2.1.  TLV Format\n   The TLV-encoded parameters are described in the following\n\
    \   subsections.  The type-field value also describes the order of these\n   fields\
    \ in the packet, except for type values from 2048 to 4095 which\n   are reserved\
    \ for new transport forms.  The parameters MUST be\n   included in the packet\
    \ such that their types form an increasing\n   order.  If the parameter can exist\
    \ multiple times in the packet, the\n   type value may be the same in consecutive\
    \ parameters.  If the order\n   does not follow this rule, the packet is considered\
    \ to be malformed\n   and it MUST be discarded.\n   Parameters using type values\
    \ from 2048 up to 4095 are transport\n   formats.  Currently, one transport format\
    \ is defined: the ESP\n   transport format [RFC5202].  The order of these parameters\
    \ does not\n   follow the order of their type value, but they are put in the packet\n\
    \   in order of preference.  The first of the transport formats it the\n   most\
    \ preferred, and so on.\n   All of the TLV parameters have a length (including\
    \ Type and Length\n   fields), which is a multiple of 8 bytes.  When needed, padding\
    \ MUST\n   be added to the end of the parameter so that the total length becomes\n\
    \   a multiple of 8 bytes.  This rule ensures proper alignment of data.\n   Any\
    \ added padding bytes MUST be zeroed by the sender, and their\n   values SHOULD\
    \ NOT be checked by the receiver.\n   Consequently, the Length field indicates\
    \ the length of the Contents\n   field (in bytes).  The total length of the TLV\
    \ parameter (including\n   Type, Length, Contents, and Padding) is related to\
    \ the Length field\n   according to the following formula:\n   Total Length =\
    \ 11 + Length - (Length + 3) % 8;\n   where % is the modulo operator\n       0\
    \                   1                   2                   3\n       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type            |C|             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      /   \
    \                       Contents                             /\n      /      \
    \                                         +-+-+-+-+-+-+-+-+\n      |         \
    \                                      |    Padding    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type         Type code for the parameter.  16 bits long, C-bit\n      \
    \             being part of the Type code.\n        C          Critical.  One\
    \ if this parameter is critical, and\n                   MUST be recognized by\
    \ the recipient, zero otherwise.\n                   The C bit is considered to\
    \ be a part of the Type\n                   field.  Consequently, critical parameters\
    \ are always\n                   odd and non-critical ones have an even value.\n\
    \      Length       Length of the Contents, in bytes.\n      Contents     Parameter\
    \ specific, defined by Type\n      Padding      Padding, 0-7 bytes, added if needed\n\
    \   Critical parameters MUST be recognized by the recipient.  If a\n   recipient\
    \ encounters a critical parameter that it does not recognize,\n   it MUST NOT\
    \ process the packet any further.  It MAY send an ICMP or\n   NOTIFY, as defined\
    \ in Section 4.3.\n   Non-critical parameters MAY be safely ignored.  If a recipient\n\
    \   encounters a non-critical parameter that it does not recognize, it\n   SHOULD\
    \ proceed as if the parameter was not present in the received\n   packet.\n"
- title: 5.2.2.  Defining New Parameters
  contents:
  - "5.2.2.  Defining New Parameters\n   Future specifications may define new parameters\
    \ as needed.  When\n   defining new parameters, care must be taken to ensure that\
    \ the\n   parameter type values are appropriate and leave suitable space for\n\
    \   other future extensions.  One must remember that the parameters MUST\n   always\
    \ be arranged in increasing order by Type code, thereby limiting\n   the order\
    \ of parameters (see Section 5.2.1).\n   The following rules must be followed\
    \ when defining new parameters.\n   1.  The low-order bit C of the Type code is\
    \ used to distinguish\n       between critical and non-critical parameters.\n\
    \   2.  A new parameter may be critical only if an old recipient ignoring\n  \
    \     it would cause security problems.  In general, new parameters\n       SHOULD\
    \ be defined as non-critical, and expect a reply from the\n       recipient.\n\
    \   3.  If a system implements a new critical parameter, it MUST provide\n   \
    \    the ability to set the associated feature off, such that the\n       critical\
    \ parameter is not sent at all.  The configuration option\n       must be well\
    \ documented.  Implementations operating in a mode\n       adhering to this specification\
    \ MUST disable the sending of new\n       critical parameters.  In other words,\
    \ the management interface\n       MUST allow vanilla standards-only mode as a\
    \ default configuration\n       setting, and MAY allow new critical payloads to\
    \ be configured on\n       (and off).\n   4.  See Section 9 for allocation rules\
    \ regarding Type codes.\n"
- title: 5.2.3.  R1_COUNTER
  contents:
  - "5.2.3.  R1_COUNTER\n      0                   1                   2         \
    \          3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       Reserved, 4 bytes                       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                R1 generation counter, 8 bytes                 |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type           128\n      Length         12\n      R1 generation\n    \
    \    counter      The current generation of valid puzzles\n   The R1_COUNTER parameter\
    \ contains a 64-bit unsigned integer in\n   network-byte order, indicating the\
    \ current generation of valid\n   puzzles.  The sender is supposed to increment\
    \ this counter\n   periodically.  It is RECOMMENDED that the counter value is\n\
    \   incremented at least as often as old PUZZLE values are deprecated so\n   that\
    \ SOLUTIONs to them are no longer accepted.\n   The R1_COUNTER parameter is optional.\
    \  It SHOULD be included in the\n   R1 (in which case, it is covered by the signature),\
    \ and if present in\n   the R1, it MAY be echoed (including the Reserved field\
    \ verbatim) by\n   the Initiator in the I2.\n"
- title: 5.2.4.  PUZZLE
  contents:
  - "5.2.4.  PUZZLE\n       0                   1                   2            \
    \       3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  K, 1 byte    |    Lifetime   |        Opaque, 2 bytes        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                      Random #I, 8 bytes                       |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type           257\n      Length         12\n      K              K is\
    \ the number of verified bits\n      Lifetime       puzzle lifetime 2^(value-32)\
    \ seconds\n      Opaque         data set by the Responder, indexing the puzzle\n\
    \      Random #I      random number\n   Random #I is represented as a 64-bit integer,\
    \ K and Lifetime as 8-bit\n   integers, all in network byte order.\n   The PUZZLE\
    \ parameter contains the puzzle difficulty K and a 64-bit\n   puzzle random integer\
    \ #I.  The Puzzle Lifetime indicates the time\n   during which the puzzle solution\
    \ is valid, and sets a time limit that\n   should not be exceeded by the Initiator\
    \ while it attempts to solve\n   the puzzle.  The lifetime is indicated as a power\
    \ of 2 using the\n   formula 2^(Lifetime-32) seconds.  A puzzle MAY be augmented\
    \ with an\n   ECHO_REQUEST_SIGNED or an ECHO_REQUEST_UNSIGNED parameter included\
    \ in\n   the R1; the contents of the echo request are then echoed back in the\n\
    \   ECHO_RESPONSE_SIGNED or in the ECHO_RESPONSE_UNSIGNED, allowing the\n   Responder\
    \ to use the included information as a part of its puzzle\n   processing.\n  \
    \ The Opaque and Random #I field are not covered by the HIP_SIGNATURE_2\n   parameter.\n"
- title: 5.2.5.  SOLUTION
  contents:
  - "5.2.5.  SOLUTION\n       0                   1                   2          \
    \         3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \ K, 1 byte     |   Reserved    |        Opaque, 2 bytes        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                      Random #I, 8 bytes                       |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                 Puzzle solution #J, 8 bytes                   |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type               321\n      Length             20\n      K          \
    \        K is the number of verified bits\n      Reserved           zero when\
    \ sent, ignored when received\n      Opaque             copied unmodified from\
    \ the received PUZZLE\n                         parameter\n      Random #I   \
    \       random number\n      Puzzle solution #J random number\n   Random #I and\
    \ Random #J are represented as 64-bit integers, K as an\n   8-bit integer, all\
    \ in network byte order.\n   The SOLUTION parameter contains a solution to a puzzle.\
    \  It also\n   echoes back the random difficulty K, the Opaque field, and the\
    \ puzzle\n   integer #I.\n"
- title: 5.2.6.  DIFFIE_HELLMAN
  contents:
  - "5.2.6.  DIFFIE_HELLMAN\n       0                   1                   2    \
    \               3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \   Group ID    |      Public Value Length      | Public Value  /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /                                                               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \   Group ID    |      Public Value Length      | Public Value  /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /                               |            padding            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Type\
    \           513\n      Length         length in octets, excluding Type, Length,\
    \ and\n                     padding\n      Group ID       defines values for p\
    \ and g\n      Public Value   length of the following Public Value in octets\n\
    \        Length\n      Public Value   the sender's public Diffie-Hellman key\n\
    \   The following Group IDs have been defined:\n      Group                  \
    \          Value\n      Reserved                         0\n      384-bit group\
    \                    1\n      OAKLEY well-known group 1        2\n      1536-bit\
    \ MODP group              3\n      3072-bit MODP group              4\n      6144-bit\
    \ MODP group              5\n      8192-bit MODP group              6\n   The\
    \ MODP Diffie-Hellman groups are defined in [RFC3526].  The OAKLEY\n   well-known\
    \ group 1 is defined in Appendix E.\n   The sender can include at most two different\
    \ Diffie-Hellman public\n   values in the DIFFIE_HELLMAN parameter.  This gives\
    \ the possibility,\n   e.g., for a server to provide a weaker encryption possibility\
    \ for a\n   PDA host that is not powerful enough.  It is RECOMMENDED that the\n\
    \   Initiator, receiving more than one public value, selects the stronger\n  \
    \ one, if it supports it.\n   A HIP implementation MUST implement Group IDs 1\
    \ and 3.  The 384-bit\n   group can be used when lower security is enough (e.g.,\
    \ web surfing)\n   and when the equipment is not powerful enough (e.g., some PDAs).\
    \  It\n   is REQUIRED that the default configuration allows Group ID 1 usage,\n\
    \   but it is RECOMMENDED that applications that need stronger security\n   turn\
    \ Group ID 1 support off.  Equipment powerful enough SHOULD\n   implement also\
    \ Group ID 5.  The 384-bit group is defined in\n   Appendix D.\n   To avoid unnecessary\
    \ failures during the base exchange, the rest of\n   the groups SHOULD be implemented\
    \ in hosts where resources are\n   adequate.\n"
- title: 5.2.7.  HIP_TRANSFORM
  contents:
  - "5.2.7.  HIP_TRANSFORM\n       0                   1                   2     \
    \              3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \            Suite ID #1        |          Suite ID #2          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |            Suite ID #n        |             Padding           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Type\
    \           577\n      Length         length in octets, excluding Type, Length,\
    \ and\n                     padding\n      Suite ID       defines the HIP Suite\
    \ to be used\n   The following Suite IDs are defined ([RFC4307],[RFC2451]):\n\
    \         Suite ID                          Value\n         RESERVED         \
    \                 0\n         AES-CBC with HMAC-SHA1            1\n         3DES-CBC\
    \ with HMAC-SHA1           2\n         3DES-CBC with HMAC-MD5            3\n \
    \        BLOWFISH-CBC with HMAC-SHA1       4\n         NULL-ENCRYPT with HMAC-SHA1\
    \       5\n         NULL-ENCRYPT with HMAC-MD5        6\n   The sender of a HIP_TRANSFORM\
    \ parameter MUST make sure that there are\n   no more than six (6) HIP Suite IDs\
    \ in one HIP_TRANSFORM parameter.\n   Conversely, a recipient MUST be prepared\
    \ to handle received transport\n   parameters that contain more than six Suite\
    \ IDs by accepting the\n   first six Suite IDs and dropping the rest.  The limited\
    \ number of\n   transforms sets the maximum size of HIP_TRANSFORM parameter. \
    \ As the\n   default configuration, the HIP_TRANSFORM parameter MUST contain at\n\
    \   least one of the mandatory Suite IDs.  There MAY be a configuration\n   option\
    \ that allows the administrator to override this default.\n   The Responder lists\
    \ supported and desired Suite IDs in order of\n   preference in the R1, up to\
    \ the maximum of six Suite IDs.  The\n   Initiator MUST choose only one of the\
    \ corresponding Suite IDs.  That\n   Suite ID will be used for generating the\
    \ I2.\n   Mandatory implementations: AES-CBC with HMAC-SHA1 and NULL-ENCRYPTION\n\
    \   with HMAC-SHA1.\n"
- title: 5.2.8.  HOST_ID
  contents:
  - "5.2.8.  HOST_ID\n       0                   1                   2           \
    \        3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \          HI Length            |DI-type|      DI Length        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         Host Identity                         /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                               |         Domain Identifier     /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /                                               |    Padding    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Type\
    \              705\n      Length            length in octets, excluding Type,\
    \ Length, and\n                        Padding\n      HI Length         length\
    \ of the Host Identity in octets\n      DI-type           type of the following\
    \ Domain Identifier field\n      DI Length         length of the FQDN or NAI in\
    \ octets\n      Host Identity     actual Host Identity\n      Domain Identifier\
    \ the identifier of the sender\n   The Host Identity is represented in RFC 4034\
    \ [RFC4034] format.  The\n   algorithms used in RDATA format are the following:\n\
    \         Algorithms       Values\n         RESERVED         0\n         DSA \
    \             3 [RFC2536] (RECOMMENDED)\n         RSA/SHA1         5 [RFC3110]\
    \ (REQUIRED)\n   The following DI-types have been defined:\n          Type   \
    \                 Value\n          none included           0\n          FQDN \
    \                   1\n          NAI                     2\n          FQDN   \
    \         Fully Qualified Domain Name, in binary format.\n          NAI      \
    \       Network Access Identifier\n   The format for the FQDN is defined in RFC\
    \ 1035 [RFC1035] Section 3.1.\n   The format for NAI is defined in [RFC4282]\n\
    \   If there is no Domain Identifier, i.e., the DI-type field is zero,\n   the\
    \ DI Length field is set to zero as well.\n"
- title: 5.2.9.  HMAC
  contents:
  - "5.2.9.  HMAC\n       0                   1                   2              \
    \     3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \                          HMAC                              |\n      /      \
    \                                                         /\n      /         \
    \                      +-------------------------------+\n      |            \
    \                   |            Padding            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type           61505\n      Length         length in octets, excluding\
    \ Type, Length, and\n                     Padding\n      HMAC           HMAC computed\
    \ over the HIP packet, excluding the\n                     HMAC parameter and\
    \ any following parameters, such\n                     as HIP_SIGNATURE, HIP_SIGNATURE_2,\n\
    \                     ECHO_REQUEST_UNSIGNED, or ECHO_RESPONSE_UNSIGNED.\n    \
    \                 The checksum field MUST be set to zero and the HIP\n       \
    \              header length in the HIP common header MUST be\n              \
    \       calculated not to cover any excluded parameters\n                    \
    \ when the HMAC is calculated.  The size of the\n                     HMAC is\
    \ the natural size of the hash computation\n                     output depending\
    \ on the used hash function.\n   The HMAC calculation and verification process\
    \ is presented in\n   Section 6.4.1.\n"
- title: 5.2.10.  HMAC_2
  contents:
  - "5.2.10.  HMAC_2\n   The parameter structure is the same as in Section 5.2.9.\
    \  The fields\n   are:\n      Type           61569\n      Length         length\
    \ in octets, excluding Type, Length, and\n                     Padding\n     \
    \ HMAC           HMAC computed over the HIP packet, excluding the\n          \
    \           HMAC parameter and any following parameters such\n               \
    \      as HIP_SIGNATURE, HIP_SIGNATURE_2,\n                     ECHO_REQUEST_UNSIGNED,\
    \ or ECHO_RESPONSE_UNSIGNED,\n                     and including an additional\
    \ sender's HOST_ID\n                     parameter during the HMAC calculation.\
    \  The\n                     checksum field MUST be set to zero and the HIP\n\
    \                     header length in the HIP common header MUST be\n       \
    \              calculated not to cover any excluded parameters\n             \
    \        when the HMAC is calculated.  The size of the\n                     HMAC\
    \ is the natural size of the hash computation\n                     output depending\
    \ on the used hash function.\n   The HMAC calculation and verification process\
    \ is presented in\n   Section 6.4.1.\n"
- title: 5.2.11.  HIP_SIGNATURE
  contents:
  - "5.2.11.  HIP_SIGNATURE\n       0                   1                   2    \
    \               3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \    SIG alg    |                  Signature                    /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /                               |             Padding           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Type\
    \           61697\n      Length         length in octets, excluding Type, Length,\
    \ and\n                     Padding\n      SIG alg        signature algorithm\n\
    \      Signature      the signature is calculated over the HIP packet,\n     \
    \                excluding the HIP_SIGNATURE parameter and any\n             \
    \        parameters that follow the HIP_SIGNATURE parameter.\n               \
    \      The checksum field MUST be set to zero, and the HIP\n                 \
    \    header length in the HIP common header MUST be\n                     calculated\
    \ only to the beginning of the\n                     HIP_SIGNATURE parameter when\
    \ the signature is\n                     calculated.\n   The signature algorithms\
    \ are defined in Section 5.2.8.  The signature\n   in the Signature field is encoded\
    \ using the proper method depending\n   on the signature algorithm (e.g., according\
    \ to [RFC3110] in case of\n   RSA/SHA1, or according to [RFC2536] in case of DSA).\n\
    \   The HIP_SIGNATURE calculation and verification process is presented\n   in\
    \ Section 6.4.2.\n"
- title: 5.2.12.  HIP_SIGNATURE_2
  contents:
  - "5.2.12.  HIP_SIGNATURE_2\n   The parameter structure is the same as in Section\
    \ 5.2.11.  The fields\n   are:\n   Type           61633\n   Length         length\
    \ in octets, excluding Type, Length, and\n                  Padding\n   SIG alg\
    \        signature algorithm\n   Signature      Within the R1 packet that contains\
    \ the HIP_SIGNATURE_2\n                  parameter, the Initiator's HIT, the checksum\n\
    \                  field, and the Opaque and Random #I fields in the\n       \
    \           PUZZLE parameter MUST be set to zero while\n                  computing\
    \ the HIP_SIGNATURE_2 signature.  Further,\n                  the HIP packet length\
    \ in the HIP header MUST be\n                  adjusted as if the HIP_SIGNATURE_2\
    \ was not in the\n                  packet during the signature calculation, i.e.,\
    \ the\n                  HIP packet length points to the beginning of\n      \
    \            the HIP_SIGNATURE_2 parameter during signing and\n              \
    \    verification.\n   Zeroing the Initiator's HIT makes it possible to create\
    \ R1 packets\n   beforehand, to minimize the effects of possible DoS attacks.\
    \  Zeroing\n   the Random #I and Opaque fields within the PUZZLE parameter allows\n\
    \   these fields to be populated dynamically on precomputed R1s.\n   Signature\
    \ calculation and verification follows the process in\n   Section 6.4.2.\n"
- title: 5.2.13.  SEQ
  contents:
  - "5.2.13.  SEQ\n       0                   1                   2              \
    \     3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                            Update ID                          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type           385\n      Length         4\n      Update ID      32-bit\
    \ sequence number\n   The Update ID is an unsigned quantity, initialized by a\
    \ host to zero\n   upon moving to ESTABLISHED state.  The Update ID has scope\
    \ within a\n   single HIP association, and not across multiple associations or\n\
    \   multiple hosts.  The Update ID is incremented by one before each new\n   UPDATE\
    \ that is sent by the host; the first UPDATE packet originated\n   by a host has\
    \ an Update ID of 0.\n"
- title: 5.2.14.  ACK
  contents:
  - "5.2.14.  ACK\n       0                   1                   2              \
    \     3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       peer Update ID                          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type            449\n      Length          variable (multiple of 4)\n \
    \     peer Update ID  32-bit sequence number corresponding to the\n          \
    \            Update ID being ACKed.\n   The ACK parameter includes one or more\
    \ Update IDs that have been\n   received from the peer.  The Length field identifies\
    \ the number of\n   peer Update IDs that are present in the parameter.\n"
- title: 5.2.15.  ENCRYPTED
  contents:
  - "5.2.15.  ENCRYPTED\n       0                   1                   2        \
    \           3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                           Reserved                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                              IV                               /\n   \
    \   /                                                               /\n      /\
    \                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               /\n      /                        Encrypted data\
    \                         /\n      /                                         \
    \                      /\n      /                               +-------------------------------+\n\
    \      /                               |            Padding            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Type\
    \           641\n      Length         length in octets, excluding Type, Length,\
    \ and\n                     Padding\n      Reserved       zero when sent, ignored\
    \ when received\n      IV             Initialization vector, if needed, otherwise\n\
    \                     nonexistent.  The length of the IV is inferred from\n  \
    \                   the HIP transform.\n      Encrypted      The data is encrypted\
    \ using an encryption algorithm\n        data         as defined in HIP transform.\n\
    \   The ENCRYPTED parameter encapsulates another parameter, the encrypted\n  \
    \ data, which holds one or more HIP parameters in block encrypted form.\n   Consequently,\
    \ the first fields in the encapsulated parameter(s) are\n   Type and Length of\
    \ the first such parameter, allowing the contents to\n   be easily parsed after\
    \ decryption.\n   The field labelled \"Encrypted data\" consists of the output\
    \ of one or\n   more HIP parameters concatenated together that have been passed\n\
    \   through an encryption algorithm.  Each of these inner parameters is\n   padded\
    \ according to the rules of Section 5.2.1 for padding individual\n   parameters.\
    \  As a result, the concatenated parameters will be a block\n   of data that is\
    \ 8-byte aligned.\n   Some encryption algorithms require that the data to be encrypted\
    \ must\n   be a multiple of the cipher algorithm block size.  In this case, the\n\
    \   above block of data MUST include additional padding, as specified by\n   the\
    \ encryption algorithm.  The size of the extra padding is selected\n   so that\
    \ the length of the unencrypted data block is a multiple of the\n   cipher block\
    \ size.  The encryption algorithm may specify padding\n   bytes other than zero;\
    \ for example, AES [FIPS01] uses the PKCS5\n   padding scheme (see section 6.1.1\
    \ of [RFC2898]) where the remaining n\n   bytes to fill the block each have the\
    \ value n.  This yields an\n   \"unencrypted data\" block that is transformed\
    \ to an \"encrypted data\"\n   block by the cipher suite.  This extra padding\
    \ added to the set of\n   parameters to satisfy the cipher block alignment rules\
    \ is not counted\n   in HIP TLV length fields, and this extra padding should be\
    \ removed by\n   the cipher suite upon decryption.\n   Note that the length of\
    \ the cipher suite output may be smaller or\n   larger than the length of the\
    \ set of parameters to be encrypted,\n   since the encryption process may compress\
    \ the data or add additional\n   padding to the data.\n   Once this encryption\
    \ process is completed, the Encrypted data field\n   is ready for inclusion in\
    \ the Parameter.  If necessary, additional\n   Padding for 8-byte alignment is\
    \ then added according to the rules of\n   Section 5.2.1.\n"
- title: 5.2.16.  NOTIFICATION
  contents:
  - "5.2.16.  NOTIFICATION\n   The NOTIFICATION parameter is used to transmit informational\
    \ data,\n   such as error conditions and state transitions, to a HIP peer.  A\n\
    \   NOTIFICATION parameter may appear in the NOTIFY packet type.  The use\n  \
    \ of the NOTIFICATION parameter in other packet types is for further\n   study.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \          Reserved             |      Notify Message Type      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               /\n   \
    \   /                   Notification Data                           /\n      /\
    \                                               +---------------+\n      /   \
    \                                            |     Padding   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type           832\n      Length         length in octets, excluding Type,\
    \ Length, and\n                     Padding\n      Reserved       zero when sent,\
    \ ignored when received\n      Notify Message specifies the type of notification\n\
    \        Type\n      Notification   informational or error data transmitted in\
    \ addition\n        Data         to the Notify Message Type.  Values for this\
    \ field\n                     are type specific (see below).\n      Padding  \
    \      any Padding, if necessary, to make the parameter a\n                  \
    \   multiple of 8 bytes.\n   Notification information can be error messages specifying\
    \ why an SA\n   could not be established.  It can also be status data that a process\n\
    \   managing an SA database wishes to communicate with a peer process.\n   The\
    \ table below lists the Notification messages and their\n   corresponding values.\n\
    \   To avoid certain types of attacks, a Responder SHOULD avoid sending a\n  \
    \ NOTIFICATION to any host with which it has not successfully verified\n   a puzzle\
    \ solution.\n   Types in the range 0-16383 are intended for reporting errors and\
    \ in\n   the range 16384-65535 for other status information.  An\n   implementation\
    \ that receives a NOTIFY packet with a NOTIFICATION\n   error parameter in response\
    \ to a request packet (e.g., I1, I2,\n   UPDATE) SHOULD assume that the corresponding\
    \ request has failed\n   entirely.  Unrecognized error types MUST be ignored except\
    \ that they\n   SHOULD be logged.\n   Notify payloads with status types MUST be\
    \ ignored if not recognized.\n   NOTIFICATION PARAMETER - ERROR TYPES     Value\n\
    \   ------------------------------------     -----\n   UNSUPPORTED_CRITICAL_PARAMETER_TYPE\
    \        1\n      Sent if the parameter type has the \"critical\" bit set and\
    \ the\n      parameter type is not recognized.  Notification Data contains\n \
    \     the two-octet parameter type.\n   INVALID_SYNTAX                       \
    \      7\n      Indicates that the HIP message received was invalid because\n\
    \      some type, length, or value was out of range or because the\n      request\
    \ was rejected for policy reasons.  To avoid a denial-\n      of-service attack\
    \ using forged messages, this status may only be\n      returned for packets whose\
    \ HMAC (if present) and SIGNATURE have\n      been verified.  This status MUST\
    \ be sent in response to any\n      error not covered by one of the other status\
    \ types, and should\n      not contain details to avoid leaking information to\
    \ someone\n      probing a node.  To aid debugging, more detailed error\n    \
    \  information SHOULD be written to a console or log.\n   NO_DH_PROPOSAL_CHOSEN\
    \                     14\n      None of the proposed group IDs was acceptable.\n\
    \   INVALID_DH_CHOSEN                         15\n      The D-H Group ID field\
    \ does not correspond to one offered\n      by the Responder.\n   NO_HIP_PROPOSAL_CHOSEN\
    \                    16\n      None of the proposed HIP Transform crypto suites\
    \ was\n      acceptable.\n   INVALID_HIP_TRANSFORM_CHOSEN              17\n  \
    \    The HIP Transform crypto suite does not correspond to\n      one offered\
    \ by the Responder.\n   AUTHENTICATION_FAILED                     24\n      Sent\
    \ in response to a HIP signature failure, except when\n      the signature verification\
    \ fails in a NOTIFY message.\n   CHECKSUM_FAILED                           26\n\
    \      Sent in response to a HIP checksum failure.\n   HMAC_FAILED           \
    \                    28\n      Sent in response to a HIP HMAC failure.\n   ENCRYPTION_FAILED\
    \                         32\n      The Responder could not successfully decrypt\
    \ the\n      ENCRYPTED parameter.\n   INVALID_HIT                            \
    \   40\n      Sent in response to a failure to validate the peer's\n      HIT\
    \ from the corresponding HI.\n   BLOCKED_BY_POLICY                         42\n\
    \      The Responder is unwilling to set up an association\n      for some policy\
    \ reason (e.g., received HIT is NULL\n      and policy does not allow opportunistic\
    \ mode).\n   SERVER_BUSY_PLEASE_RETRY                  44\n      The Responder\
    \ is unwilling to set up an association as it is\n      suffering under some kind\
    \ of overload and has chosen to shed load\n      by rejecting the Initiator's\
    \ request.  The Initiator may retry;\n      however, the Initiator MUST find another\
    \ (different) puzzle\n      solution for any such retries.  Note that the Initiator\
    \ may need\n      to obtain a new puzzle with a new I1/R1 exchange.\n   NOTIFY\
    \ MESSAGES - STATUS TYPES           Value\n   ------------------------------ \
    \          -----\n   I2_ACKNOWLEDGEMENT                        16384\n      The\
    \ Responder has an I2 from the Initiator but had to queue the I2\n      for processing.\
    \  The puzzle was correctly solved and the Responder\n      is willing to set\
    \ up an association but currently has a number of\n      I2s in the processing\
    \ queue.  R2 will be sent after the I2 has\n      been processed.\n"
- title: 5.2.17.  ECHO_REQUEST_SIGNED
  contents:
  - "5.2.17.  ECHO_REQUEST_SIGNED\n       0                   1                  \
    \ 2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                 Opaque data (variable length)                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type         897\n      Length       variable\n      Opaque data  opaque\
    \ data, supposed to be meaningful only to the\n                   node that sends\
    \ ECHO_REQUEST_SIGNED and receives a\n                   corresponding ECHO_RESPONSE_SIGNED\
    \ or\n                   ECHO_RESPONSE_UNSIGNED.\n   The ECHO_REQUEST_SIGNED parameter\
    \ contains an opaque blob of data\n   that the sender wants to get echoed back\
    \ in the corresponding reply\n   packet.\n   The ECHO_REQUEST_SIGNED and corresponding\
    \ echo response parameters\n   MAY be used for any purpose where a node wants\
    \ to carry some state in\n   a request packet and get it back in a response packet.\
    \  The\n   ECHO_REQUEST_SIGNED is covered by the HMAC and SIGNATURE.  A HIP\n\
    \   packet can contain only one ECHO_REQUEST_SIGNED or\n   ECHO_REQUEST_UNSIGNED\
    \ parameter.  The ECHO_REQUEST_SIGNED parameter\n   MUST be responded to with\
    \ a corresponding echo response.\n   ECHO_RESPONSE_SIGNED SHOULD be used, but\
    \ if it is not possible, e.g.,\n   due to a middlebox-provided response, it MAY\
    \ be responded to with an\n   ECHO_RESPONSE_UNSIGNED.\n"
- title: 5.2.18.  ECHO_REQUEST_UNSIGNED
  contents:
  - "5.2.18.  ECHO_REQUEST_UNSIGNED\n       0                   1                \
    \   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                 Opaque data (variable length)                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type         63661\n      Length       variable\n      Opaque data  opaque\
    \ data, supposed to be meaningful only to the\n                   node that sends\
    \ ECHO_REQUEST_UNSIGNED and receives a\n                   corresponding ECHO_RESPONSE_UNSIGNED.\n\
    \   The ECHO_REQUEST_UNSIGNED parameter contains an opaque blob of data\n   that\
    \ the sender wants to get echoed back in the corresponding reply\n   packet.\n\
    \   The ECHO_REQUEST_UNSIGNED and corresponding echo response parameters\n   MAY\
    \ be used for any purpose where a node wants to carry some state in\n   a request\
    \ packet and get it back in a response packet.  The\n   ECHO_REQUEST_UNSIGNED\
    \ is not covered by the HMAC and SIGNATURE.  A\n   HIP packet can contain one\
    \ or more ECHO_REQUEST_UNSIGNED parameters.\n   It is possible that middleboxes\
    \ add ECHO_REQUEST_UNSIGNED parameters\n   in HIP packets passing by.  The sender\
    \ has to create the Opaque field\n   so that it can later identify and remove\
    \ the corresponding\n   ECHO_RESPONSE_UNSIGNED parameter.\n   The ECHO_REQUEST_UNSIGNED\
    \ parameter MUST be responded to with an\n   ECHO_RESPONSE_UNSIGNED parameter.\n"
- title: 5.2.19.  ECHO_RESPONSE_SIGNED
  contents:
  - "5.2.19.  ECHO_RESPONSE_SIGNED\n       0                   1                 \
    \  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                 Opaque data (variable length)                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type         961\n      Length       variable\n      Opaque data  opaque\
    \ data, copied unmodified from the\n                   ECHO_REQUEST_SIGNED or\
    \ ECHO_REQUEST_UNSIGNED\n                   parameter that triggered this response.\n\
    \   The ECHO_RESPONSE_SIGNED parameter contains an opaque blob of data\n   that\
    \ the sender of the ECHO_REQUEST_SIGNED wants to get echoed back.\n   The opaque\
    \ data is copied unmodified from the ECHO_REQUEST_SIGNED\n   parameter.\n   The\
    \ ECHO_REQUEST_SIGNED and ECHO_RESPONSE_SIGNED parameters MAY be\n   used for\
    \ any purpose where a node wants to carry some state in a\n   request packet and\
    \ get it back in a response packet.  The\n   ECHO_RESPONSE_SIGNED is covered by\
    \ the HMAC and SIGNATURE.\n"
- title: 5.2.20.  ECHO_RESPONSE_UNSIGNED
  contents:
  - "5.2.20.  ECHO_RESPONSE_UNSIGNED\n       0                   1               \
    \    2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                 Opaque data (variable length)                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type         63425\n      Length       variable\n      Opaque data  opaque\
    \ data, copied unmodified from the\n                   ECHO_REQUEST_SIGNED or\
    \ ECHO_REQUEST_UNSIGNED\n                   parameter that triggered this response.\n\
    \   The ECHO_RESPONSE_UNSIGNED parameter contains an opaque blob of data\n   that\
    \ the sender of the ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED\n   wants to\
    \ get echoed back.  The opaque data is copied unmodified from\n   the corresponding\
    \ echo request parameter.\n   The echo request and ECHO_RESPONSE_UNSIGNED parameters\
    \ MAY be used\n   for any purpose where a node wants to carry some state in a\
    \ request\n   packet and get it back in a response packet.  The\n   ECHO_RESPONSE_UNSIGNED\
    \ is not covered by the HMAC and SIGNATURE.\n"
- title: 5.3.  HIP Packets
  contents:
  - "5.3.  HIP Packets\n   There are eight basic HIP packets (see Table 10).  Four\
    \ are for the\n   HIP base exchange, one is for updating, one is for sending\n\
    \   notifications, and two are for closing a HIP association.\n   +------------------+------------------------------------------------+\n\
    \   |    Packet type   | Packet name                                    |\n  \
    \ +------------------+------------------------------------------------+\n   |\
    \         1        | I1 - the HIP Initiator Packet                  |\n   |  \
    \                |                                                |\n   |    \
    \     2        | R1 - the HIP Responder Packet                  |\n   |      \
    \            |                                                |\n   |        \
    \ 3        | I2 - the Second HIP Initiator Packet           |\n   |          \
    \        |                                                |\n   |         4  \
    \      | R2 - the Second HIP Responder Packet           |\n   |              \
    \    |                                                |\n   |        16      \
    \  | UPDATE - the HIP Update Packet                 |\n   |                  |\
    \                                                |\n   |        17        | NOTIFY\
    \ - the HIP Notify Packet                 |\n   |                  |         \
    \                                       |\n   |        18        | CLOSE - the\
    \ HIP Association Closing Packet     |\n   |                  |              \
    \                                  |\n   |        19        | CLOSE_ACK - the\
    \ HIP Closing Acknowledgment     |\n   |                  | Packet           \
    \                              |\n   +------------------+------------------------------------------------+\n\
    \               Table 10: HIP packets and packet type numbers\n   Packets consist\
    \ of the fixed header as described in Section 5.1,\n   followed by the parameters.\
    \  The parameter part, in turn, consists of\n   zero or more TLV-coded parameters.\n\
    \   In addition to the base packets, other packet types will be defined\n   later\
    \ in separate specifications.  For example, support for mobility\n   and multi-homing\
    \ is not included in this specification.\n   See Notation (Section 2.2) for used\
    \ operations.\n   In the future, an OPTIONAL upper-layer payload MAY follow the\
    \ HIP\n   header.  The Next Header field in the header indicates if there is\n\
    \   additional data following the HIP header.  The HIP packet, however,\n   MUST\
    \ NOT be fragmented.  This limits the size of the possible\n   additional data\
    \ in the packet.\n"
- title: 5.3.1.  I1 - the HIP Initiator Packet
  contents:
  - "5.3.1.  I1 - the HIP Initiator Packet\n   The HIP header values for the I1 packet:\n\
    \      Header:\n        Packet Type = 1\n        SRC HIT = Initiator's HIT\n \
    \       DST HIT = Responder's HIT, or NULL\n      IP ( HIP () )\n   The I1 packet\
    \ contains only the fixed HIP header.\n   Valid control bits: none\n   The Initiator\
    \ gets the Responder's HIT either from a DNS lookup of\n   the Responder's FQDN,\
    \ from some other repository, or from a local\n   table.  If the Initiator does\
    \ not know the Responder's HIT, it may\n   attempt to use opportunistic mode by\
    \ using NULL (all zeros) as the\n   Responder's HIT.  See also \"HIP Opportunistic\
    \ Mode\" (Section 4.1.6).\n   Since this packet is so easy to spoof even if it\
    \ were signed, no\n   attempt is made to add to its generation or processing cost.\n\
    \   Implementations MUST be able to handle a storm of received I1\n   packets,\
    \ discarding those with common content that arrive within a\n   small time delta.\n"
- title: 5.3.2.  R1 - the HIP Responder Packet
  contents:
  - "5.3.2.  R1 - the HIP Responder Packet\n   The HIP header values for the R1 packet:\n\
    \      Header:\n        Packet Type = 2\n        SRC HIT = Responder's HIT\n \
    \       DST HIT = Initiator's HIT\n      IP ( HIP ( [ R1_COUNTER, ]\n        \
    \         PUZZLE,\n                 DIFFIE_HELLMAN,\n                 HIP_TRANSFORM,\n\
    \                 HOST_ID,\n                 [ ECHO_REQUEST_SIGNED, ]\n      \
    \           HIP_SIGNATURE_2 )\n                 <, ECHO_REQUEST_UNSIGNED >i)\n\
    \   Valid control bits: A\n   If the Responder's HI is an anonymous one, the A\
    \ control MUST be set.\n   The Initiator's HIT MUST match the one received in\
    \ I1.  If the\n   Responder has multiple HIs, the Responder's HIT used MUST match\n\
    \   Initiator's request.  If the Initiator used opportunistic mode, the\n   Responder\
    \ may select freely among its HIs.  See also \"HIP\n   Opportunistic Mode\" (Section\
    \ 4.1.6).\n   The R1 generation counter is used to determine the currently valid\n\
    \   generation of puzzles.  The value is increased periodically, and it\n   is\
    \ RECOMMENDED that it is increased at least as often as solutions to\n   old puzzles\
    \ are no longer accepted.\n   The Puzzle contains a Random #I and the difficulty\
    \ K.  The difficulty\n   K indicates the number of lower-order bits, in the puzzle\
    \ hash\n   result, that must be zeros; see Section 4.1.2.  The Random #I is not\n\
    \   covered by the signature and must be zeroed during the signature\n   calculation,\
    \ allowing the sender to select and set the #I into a\n   precomputed R1 just\
    \ prior sending it to the peer.\n   The Diffie-Hellman value is ephemeral, and\
    \ one value SHOULD be used\n   only for one connection.  Once the Responder has\
    \ received a valid\n   response to an R1 packet, that Diffie-Hellman value SHOULD\
    \ be\n   deprecated.  Because it is possible that the Responder has sent the\n\
    \   same Diffie-Hellman value to different hosts simultaneously in\n   corresponding\
    \ R1 packets, those responses should also be accepted.\n   However, as a defense\
    \ against I1 storms, an implementation MAY\n   propose, and re-use if not avoidable,\
    \ the same Diffie-Hellman value\n   for a period of time, for example, 15 minutes.\
    \  By using a small\n   number of different puzzles for a given Diffie-Hellman\
    \ value, the R1\n   packets can be precomputed and delivered as quickly as I1\
    \ packets\n   arrive.  A scavenger process should clean up unused Diffie-Hellman\n\
    \   values and puzzles.\n   Re-using Diffie-Hellman public keys opens up the potential\
    \ security\n   risk of more than one Initiator ending up with the same keying\n\
    \   material (due to faulty random number generators).  Also, more than\n   one\
    \ Initiator using the same Responder public key half may lead to\n   potentially\
    \ easier cryptographic attacks and to imperfect forward\n   security.\n   However,\
    \ these risks involved in re-using the same key are\n   statistical; that is,\
    \ the authors are not aware of any mechanism that\n   would allow manipulation\
    \ of the protocol so that the risk of the re-\n   use of any given Responder Diffie-Hellman\
    \ public key would differ\n   from the base probability.  Consequently, it is\
    \ RECOMMENDED that\n   implementations avoid re-using the same D-H key with multiple\n\
    \   Initiators, but because the risk is considered statistical and not\n   known\
    \ to be manipulable, the implementations MAY re-use a key in\n   order to ease\
    \ resource-constrained implementations and to increase\n   the probability of\
    \ successful communication with legitimate clients\n   even under an I1 storm.\
    \  In particular, when it is too expensive to\n   generate enough precomputed\
    \ R1 packets to supply each potential\n   Initiator with a different D-H key,\
    \ the Responder MAY send the same\n   D-H key to several Initiators, thereby creating\
    \ the possibility of\n   multiple legitimate Initiators ending up using the same\
    \ Responder-\n   side public key.  However, as soon as the Responder knows that\
    \ it\n   will use a particular D-H key, it SHOULD stop offering it.  This\n  \
    \ design is aimed to allow resource-constrained Responders to offer\n   services\
    \ under I1 storms and to simultaneously make the probability\n   of D-H key re-use\
    \ both statistical and as low as possible.\n   If a future version of this protocol\
    \ is considered, we strongly\n   recommend that these issues be studied again.\
    \  Especially, the\n   current design allows hosts to become potentially more\
    \ vulnerable to\n   a statistical, low-probability problem during I1 storm attacks\
    \ than\n   what they are if no attack is taking place; whether this is\n   acceptable\
    \ or not should be reconsidered in the light of any new\n   experience gained.\n\
    \   The HIP_TRANSFORM contains the encryption and integrity algorithms\n   supported\
    \ by the Responder to protect the HI exchange, in the order\n   of preference.\
    \  All implementations MUST support the AES [RFC3602]\n   with HMAC-SHA-1-96 [RFC2404].\n\
    \   The ECHO_REQUEST_SIGNED and ECHO_REQUEST_UNSIGNED contains data that\n   the\
    \ sender wants to receive unmodified in the corresponding response\n   packet\
    \ in the ECHO_RESPONSE_SIGNED or ECHO_RESPONSE_UNSIGNED\n   parameter.\n   The\
    \ signature is calculated over the whole HIP envelope, after\n   setting the Initiator's\
    \ HIT, header checksum, as well as the Opaque\n   field and the Random #I in the\
    \ PUZZLE parameter temporarily to zero,\n   and excluding any parameters that\
    \ follow the signature, as described\n   in Section 5.2.12.  This allows the Responder\
    \ to use precomputed R1s.\n   The Initiator SHOULD validate this signature.  It\
    \ SHOULD check that\n   the Responder's HI received matches with the one expected,\
    \ if any.\n"
- title: 5.3.3.  I2 - the Second HIP Initiator Packet
  contents:
  - "5.3.3.  I2 - the Second HIP Initiator Packet\n   The HIP header values for the\
    \ I2 packet:\n      Header:\n        Type = 3\n        SRC HIT = Initiator's HIT\n\
    \        DST HIT = Responder's HIT\n      IP ( HIP ( [R1_COUNTER,]\n         \
    \        SOLUTION,\n                 DIFFIE_HELLMAN,\n                 HIP_TRANSFORM,\n\
    \                 ENCRYPTED { HOST_ID } or HOST_ID,\n                 [ ECHO_RESPONSE_SIGNED\
    \ ,]\n                 HMAC,\n                 HIP_SIGNATURE\n               \
    \  <, ECHO_RESPONSE_UNSIGNED>i ) )\n   Valid control bits: A\n   The HITs used\
    \ MUST match the ones used previously.\n   If the Initiator's HI is an anonymous\
    \ one, the A control MUST be set.\n   The Initiator MAY include an unmodified\
    \ copy of the R1_COUNTER\n   parameter received in the corresponding R1 packet\
    \ into the I2 packet.\n   The Solution contains the Random #I from R1 and the\
    \ computed #J.  The\n   low-order K bits of the RHASH(I | ... | J) MUST be zero.\n\
    \   The Diffie-Hellman value is ephemeral.  If precomputed, a scavenger\n   process\
    \ should clean up unused Diffie-Hellman values.  The Responder\n   may re-use\
    \ Diffie-Hellman values under some conditions as specified\n   in Section 5.3.2.\n\
    \   The HIP_TRANSFORM contains the single encryption and integrity\n   transform\
    \ selected by the Initiator, that will be used to protect the\n   HI exchange.\
    \  The chosen transform MUST correspond to one offered by\n   the Responder in\
    \ the R1.  All implementations MUST support the AES\n   transform [RFC3602].\n\
    \   The Initiator's HI MAY be encrypted using the HIP_TRANSFORM\n   encryption\
    \ algorithm.  The keying material is derived from the\n   Diffie-Hellman exchanged\
    \ as defined in Section 6.5.\n   The ECHO_RESPONSE_SIGNED and ECHO_RESPONSE_UNSIGNED\
    \ contain the\n   unmodified Opaque data copied from the corresponding echo request\n\
    \   parameter.\n   The HMAC is calculated over the whole HIP envelope, excluding\
    \ any\n   parameters after the HMAC, as described in Section 6.4.1.  The\n   Responder\
    \ MUST validate the HMAC.\n   The signature is calculated over the whole HIP envelope,\
    \ excluding\n   any parameters after the HIP_SIGNATURE, as described in\n   Section\
    \ 5.2.11.  The Responder MUST validate this signature.  It MAY\n   use either\
    \ the HI in the packet or the HI acquired by some other\n   means.\n"
- title: 5.3.4.  R2 - the Second HIP Responder Packet
  contents:
  - "5.3.4.  R2 - the Second HIP Responder Packet\n   The HIP header values for the\
    \ R2 packet:\n      Header:\n        Packet Type = 4\n        SRC HIT = Responder's\
    \ HIT\n        DST HIT = Initiator's HIT\n      IP ( HIP ( HMAC_2, HIP_SIGNATURE\
    \ ) )\n   Valid control bits: none\n   The HMAC_2 is calculated over the whole\
    \ HIP envelope, with\n   Responder's HOST_ID parameter concatenated with the HIP\
    \ envelope.\n   The HOST_ID parameter is removed after the HMAC calculation. \
    \ The\n   procedure is described in Section 6.4.1.\n   The signature is calculated\
    \ over the whole HIP envelope.\n   The Initiator MUST validate both the HMAC and\
    \ the signature.\n"
- title: 5.3.5.  UPDATE - the HIP Update Packet
  contents:
  - "5.3.5.  UPDATE - the HIP Update Packet\n   Support for the UPDATE packet is MANDATORY.\n\
    \   The HIP header values for the UPDATE packet:\n      Header:\n        Packet\
    \ Type = 16\n        SRC HIT = Sender's HIT\n        DST HIT = Recipient's HIT\n\
    \      IP ( HIP ( [SEQ, ACK, ] HMAC, HIP_SIGNATURE ) )\n   Valid control bits:\
    \ None\n   The UPDATE packet contains mandatory HMAC and HIP_SIGNATURE\n   parameters,\
    \ and other optional parameters.\n   The UPDATE packet contains zero or one SEQ\
    \ parameter.  The presence\n   of a SEQ parameter indicates that the receiver\
    \ MUST ACK the UPDATE.\n   An UPDATE that does not contain a SEQ parameter is\
    \ simply an ACK of a\n   previous UPDATE and itself MUST NOT be ACKed.\n   An\
    \ UPDATE packet contains zero or one ACK parameters.  The ACK\n   parameter echoes\
    \ the SEQ sequence number of the UPDATE packet being\n   ACKed.  A host MAY choose\
    \ to ACK more than one UPDATE packet at a\n   time; e.g., the ACK may contain\
    \ the last two SEQ values received, for\n   robustness to ACK loss.  ACK values\
    \ are not cumulative; each received\n   unique SEQ value requires at least one\
    \ corresponding ACK value in\n   reply.  Received ACKs that are redundant are\
    \ ignored.\n   The UPDATE packet may contain both a SEQ and an ACK parameter.\
    \  In\n   this case, the ACK is being piggybacked on an outgoing UPDATE.  In\n\
    \   general, UPDATEs carrying SEQ SHOULD be ACKed upon completion of the\n   processing\
    \ of the UPDATE.  A host MAY choose to hold the UPDATE\n   carrying ACK for a\
    \ short period of time to allow for the possibility\n   of piggybacking the ACK\
    \ parameter, in a manner similar to TCP delayed\n   acknowledgments.\n   A sender\
    \ MAY choose to forgo reliable transmission of a particular\n   UPDATE (e.g.,\
    \ it becomes overcome by events).  The semantics are such\n   that the receiver\
    \ MUST acknowledge the UPDATE, but the sender MAY\n   choose to not care about\
    \ receiving the ACK.\n   UPDATEs MAY be retransmitted without incrementing SEQ.\
    \  If the same\n   subset of parameters is included in multiple UPDATEs with different\n\
    \   SEQs, the host MUST ensure that the receiver's processing of the\n   parameters\
    \ multiple times will not result in a protocol error.\n"
- title: 5.3.6.  NOTIFY - the HIP Notify Packet
  contents:
  - "5.3.6.  NOTIFY - the HIP Notify Packet\n   The NOTIFY packet is OPTIONAL.  The\
    \ NOTIFY packet MAY be used to\n   provide information to a peer.  Typically,\
    \ NOTIFY is used to indicate\n   some type of protocol error or negotiation failure.\
    \  NOTIFY packets\n   are unacknowledged.  The receiver can handle the packet\
    \ only as\n   informational, and SHOULD NOT change its HIP state (Section 4.4.1)\n\
    \   based purely on a received NOTIFY packet.\n   The HIP header values for the\
    \ NOTIFY packet:\n      Header:\n        Packet Type = 17\n        SRC HIT = Sender's\
    \ HIT\n        DST HIT = Recipient's HIT, or zero if unknown\n      IP ( HIP (<NOTIFICATION>i,\
    \ [HOST_ID, ] HIP_SIGNATURE) )\n   Valid control bits: None\n   The NOTIFY packet\
    \ is used to carry one or more NOTIFICATION\n   parameters.\n"
- title: 5.3.7.  CLOSE - the HIP Association Closing Packet
  contents:
  - "5.3.7.  CLOSE - the HIP Association Closing Packet\n   The HIP header values\
    \ for the CLOSE packet:\n      Header:\n        Packet Type = 18\n        SRC\
    \ HIT = Sender's HIT\n        DST HIT = Recipient's HIT\n      IP ( HIP ( ECHO_REQUEST_SIGNED,\
    \ HMAC, HIP_SIGNATURE ) )\n   Valid control bits: none\n   The sender MUST include\
    \ an ECHO_REQUEST_SIGNED used to validate\n   CLOSE_ACK received in response,\
    \ and both an HMAC and a signature\n   (calculated over the whole HIP envelope).\n\
    \   The receiver peer MUST validate both the HMAC and the signature if it\n  \
    \ has a HIP association state, and MUST reply with a CLOSE_ACK\n   containing\
    \ an ECHO_RESPONSE_SIGNED corresponding to the received\n   ECHO_REQUEST_SIGNED.\n"
- title: 5.3.8.  CLOSE_ACK - the HIP Closing Acknowledgment Packet
  contents:
  - "5.3.8.  CLOSE_ACK - the HIP Closing Acknowledgment Packet\n   The HIP header\
    \ values for the CLOSE_ACK packet:\n      Header:\n        Packet Type = 19\n\
    \        SRC HIT = Sender's HIT\n        DST HIT = Recipient's HIT\n      IP (\
    \ HIP ( ECHO_RESPONSE_SIGNED, HMAC, HIP_SIGNATURE ) )\n   Valid control bits:\
    \ none\n   The sender MUST include both an HMAC and signature (calculated over\n\
    \   the whole HIP envelope).\n   The receiver peer MUST validate both the HMAC\
    \ and the signature.\n"
- title: 5.4.  ICMP Messages
  contents:
  - "5.4.  ICMP Messages\n   When a HIP implementation detects a problem with an incoming\
    \ packet,\n   and it either cannot determine the identity of the sender of the\n\
    \   packet or does not have any existing HIP association with the sender\n   of\
    \ the packet, it MAY respond with an ICMP packet.  Any such replies\n   MUST be\
    \ rate-limited as described in [RFC2463].  In most cases, the\n   ICMP packet\
    \ will have the Parameter Problem type (12 for ICMPv4, 4\n   for ICMPv6), with\
    \ the Pointer field pointing to the field that caused\n   the ICMP message to\
    \ be generated.\n"
- title: 5.4.1.  Invalid Version
  contents:
  - "5.4.1.  Invalid Version\n   If a HIP implementation receives a HIP packet that\
    \ has an\n   unrecognized HIP version number, it SHOULD respond, rate-limited,\n\
    \   with an ICMP packet with type Parameter Problem, the Pointer pointing\n  \
    \ to the VER./RES. byte in the HIP header.\n"
- title: 5.4.2.  Other Problems with the HIP Header and Packet Structure
  contents:
  - "5.4.2.  Other Problems with the HIP Header and Packet Structure\n   If a HIP\
    \ implementation receives a HIP packet that has other\n   unrecoverable problems\
    \ in the header or packet format, it MAY\n   respond, rate-limited, with an ICMP\
    \ packet with type Parameter\n   Problem, the Pointer pointing to the field that\
    \ failed to pass the\n   format checks.  However, an implementation MUST NOT send\
    \ an ICMP\n   message if the checksum fails; instead, it MUST silently drop the\n\
    \   packet.\n"
- title: 5.4.3.  Invalid Puzzle Solution
  contents:
  - "5.4.3.  Invalid Puzzle Solution\n   If a HIP implementation receives an I2 packet\
    \ that has an invalid\n   puzzle solution, the behavior depends on the underlying\
    \ version of\n   IP.  If IPv6 is used, the implementation SHOULD respond with\
    \ an ICMP\n   packet with type Parameter Problem, the Pointer pointing to the\n\
    \   beginning of the Puzzle solution #J field in the SOLUTION payload in\n   the\
    \ HIP message.\n   If IPv4 is used, the implementation MAY respond with an ICMP\
    \ packet\n   with the type Parameter Problem, copying enough of bytes from the\
    \ I2\n   message so that the SOLUTION parameter fits into the ICMP message,\n\
    \   the Pointer pointing to the beginning of the Puzzle solution #J\n   field,\
    \ as in the IPv6 case.  Note, however, that the resulting ICMPv4\n   message exceeds\
    \ the typical ICMPv4 message size as defined in\n   [RFC0792].\n"
- title: 5.4.4.  Non-Existing HIP Association
  contents:
  - "5.4.4.  Non-Existing HIP Association\n   If a HIP implementation receives a CLOSE\
    \ or UPDATE packet, or any\n   other packet whose handling requires an existing\
    \ association, that\n   has either a Receiver or Sender HIT that does not match\
    \ with any\n   existing HIP association, the implementation MAY respond, rate-\n\
    \   limited, with an ICMP packet with the type Parameter Problem, and\n   with\
    \ the Pointer pointing to the beginning of the first HIT that does\n   not match.\n\
    \   A host MUST NOT reply with such an ICMP if it receives any of the\n   following\
    \ messages: I1, R2, I2, R2, and NOTIFY.  When introducing new\n   packet types,\
    \ a specification SHOULD define the appropriate rules for\n   sending or not sending\
    \ this kind of ICMP reply.\n"
- title: 6.  Packet Processing
  contents:
  - "6.  Packet Processing\n   Each host is assumed to have a single HIP protocol\
    \ implementation\n   that manages the host's HIP associations and handles requests\
    \ for new\n   ones.  Each HIP association is governed by a conceptual state\n\
    \   machine, with states defined above in Section 4.4.  The HIP\n   implementation\
    \ can simultaneously maintain HIP associations with more\n   than one host.  Furthermore,\
    \ the HIP implementation may have more\n   than one active HIP association with\
    \ another host; in this case, HIP\n   associations are distinguished by their\
    \ respective HITs.  It is not\n   possible to have more than one HIP association\
    \ between any given pair\n   of HITs.  Consequently, the only way for two hosts\
    \ to have more than\n   one parallel association is to use different HITs, at\
    \ least at one\n   end.\n   The processing of packets depends on the state of\
    \ the HIP\n   association(s) with respect to the authenticated or apparent\n \
    \  originator of the packet.  A HIP implementation determines whether it\n   has\
    \ an active association with the originator of the packet based on\n   the HITs.\
    \  In the case of user data carried in a specific transport\n   format, the transport\
    \ format document specifies how the incoming\n   packets are matched with the\
    \ active associations.\n"
- title: 6.1.  Processing Outgoing Application Data
  contents:
  - "6.1.  Processing Outgoing Application Data\n   In a HIP host, an application\
    \ can send application-level data using\n   an identifier specified via the underlying\
    \ API.  The API can be a\n   backwards-compatible API (see [HIP-APP]), using identifiers\
    \ that look\n   similar to IP addresses, or a completely new API, providing enhanced\n\
    \   services related to Host Identities.  Depending on the HIP\n   implementation,\
    \ the identifier provided to the application may be\n   different; for example,\
    \ it can be a HIT or an IP address.\n   The exact format and method for transferring\
    \ the data from the source\n   HIP host to the destination HIP host is defined\
    \ in the corresponding\n   transport format document.  The actual data is transferred\
    \ in the\n   network using the appropriate source and destination IP addresses.\n\
    \   In this document, conceptual processing rules are defined only for\n   the\
    \ base case where both hosts have only single usable IP addresses;\n   the multi-address\
    \ multi-homing case will be specified separately.\n   The following conceptual\
    \ algorithm describes the steps that are\n   required for handling outgoing datagrams\
    \ destined to a HIT.\n   1.  If the datagram has a specified source address, it\
    \ MUST be a HIT.\n       If it is not, the implementation MAY replace the source\
    \ address\n       with a HIT.  Otherwise, it MUST drop the packet.\n   2.  If\
    \ the datagram has an unspecified source address, the\n       implementation must\
    \ choose a suitable source HIT for the\n       datagram.\n   3.  If there is no\
    \ active HIP association with the given <source,\n       destination> HIT pair,\
    \ one must be created by running the base\n       exchange.  While waiting for\
    \ the base exchange to complete, the\n       implementation SHOULD queue at least\
    \ one packet per HIP\n       association to be formed, and it MAY queue more than\
    \ one.\n   4.  Once there is an active HIP association for the given <source,\n\
    \       destination> HIT pair, the outgoing datagram is passed to\n       transport\
    \ handling.  The possible transport formats are defined\n       in separate documents,\
    \ of which the ESP transport format for HIP\n       is mandatory for all HIP implementations.\n\
    \   5.  Before sending the packet, the HITs in the datagram are replaced\n   \
    \    with suitable IP addresses.  For IPv6, the rules defined in\n       [RFC3484]\
    \ SHOULD be followed.  Note that this HIT-to-IP-address\n       conversion step\
    \ MAY also be performed at some other point in the\n       stack, e.g., before\
    \ wrapping the packet into the output format.\n"
- title: 6.2.  Processing Incoming Application Data
  contents:
  - "6.2.  Processing Incoming Application Data\n   The following conceptual algorithm\
    \ describes the incoming datagram\n   handling when HITs are used at the receiving\
    \ host as application-\n   level identifiers.  More detailed steps for processing\
    \ packets are\n   defined in corresponding transport format documents.\n   1.\
    \  The incoming datagram is mapped to an existing HIP association,\n       typically\
    \ using some information from the packet.  For example,\n       such mapping may\
    \ be based on the ESP Security Parameter Index\n       (SPI).\n   2.  The specific\
    \ transport format is unwrapped, in a way depending on\n       the transport format,\
    \ yielding a packet that looks like a\n       standard (unencrypted) IP packet.\
    \  If possible, this step SHOULD\n       also verify that the packet was indeed\
    \ (once) sent by the remote\n       HIP host, as identified by the HIP association.\n\
    \       Depending on the used transport mode, the verification method can\n  \
    \     vary.  While the HI (as well as HIT) is used as the higher-layer\n     \
    \  identifier, the verification method has to verify that the data\n       packet\
    \ was sent by a node identity and that the actual identity\n       maps to this\
    \ particular HIT.  When using ESP transport format\n       [RFC5202], the verification\
    \ is done using the SPI value in the\n       data packet to find the corresponding\
    \ SA with associated HIT and\n       key, and decrypting the packet with that\
    \ associated key.\n   3.  The IP addresses in the datagram are replaced with the\
    \ HITs\n       associated with the HIP association.  Note that this IP-address-\n\
    \       to-HIT conversion step MAY also be performed at some other point\n   \
    \    in the stack.\n   4.  The datagram is delivered to the upper layer.  When\n\
    \       demultiplexing the datagram, the right upper-layer socket is\n       based\
    \ on the HITs.\n"
- title: 6.3.  Solving the Puzzle
  contents:
  - "6.3.  Solving the Puzzle\n   This subsection describes the puzzle-solving details.\n\
    \   In R1, the values I and K are sent in network byte order.  Similarly,\n  \
    \ in I2, the values I and J are sent in network byte order.  The hash\n   is created\
    \ by concatenating, in network byte order, the following\n   data, in the following\
    \ order and using the RHASH algorithm:\n      64-bit random value I, in network\
    \ byte order, as appearing in R1\n      and I2.\n      128-bit Initiator's HIT,\
    \ in network byte order, as appearing in\n      the HIP Payload in R1 and I2.\n\
    \      128-bit Responder's HIT, in network byte order, as appearing in\n     \
    \ the HIP Payload in R1 and I2.\n      64-bit random value J, in network byte\
    \ order, as appearing in I2.\n   In order to be a valid response puzzle, the K\
    \ low-order bits of the\n   resulting RHASH digest must be zero.\n   Notes:\n\
    \      i) The length of the data to be hashed is 48 bytes.\n      ii) All the\
    \ data in the hash input MUST be in network byte order.\n      iii) The order\
    \ of the Initiator's and Responder's HITs are\n      different in the R1 and I2\
    \ packets; see Section 5.1.  Care must be\n      taken to copy the values in the\
    \ right order to the hash input.\n   The following procedure describes the processing\
    \ steps involved,\n   assuming that the Responder chooses to precompute the R1\
    \ packets:\n   Precomputation by the Responder:\n      Sets up the puzzle difficulty\
    \ K.\n      Creates a signed R1 and caches it.\n   Responder:\n      Selects a\
    \ suitable cached R1.\n      Generates a random number I.\n      Sends I and K\
    \ in an R1.\n      Saves I and K for a Delta time.\n   Initiator:\n      Generates\
    \ repeated attempts to solve the puzzle until a matching J\n      is found:\n\
    \      Ltrunc( RHASH( I | HIT-I | HIT-R | J ), K ) == 0\n      Sends I and J in\
    \ an I2.\n   Responder:\n      Verifies that the received I is a saved one.\n\
    \      Finds the right K based on I.\n      Computes V := Ltrunc( RHASH( I | HIT-I\
    \ | HIT-R | J ), K )\n      Rejects if V != 0\n      Accept if V == 0\n"
- title: 6.4.  HMAC and SIGNATURE Calculation and Verification
  contents:
  - "6.4.  HMAC and SIGNATURE Calculation and Verification\n   The following subsections\
    \ define the actions for processing HMAC,\n   HIP_SIGNATURE and HIP_SIGNATURE_2\
    \ parameters.\n"
- title: 6.4.1.  HMAC Calculation
  contents:
  - "6.4.1.  HMAC Calculation\n   The following process applies both to the HMAC and\
    \ HMAC_2 parameters.\n   When processing HMAC_2, the difference is that the HMAC\
    \ calculation\n   includes a pseudo HOST_ID field containing the Responder's\n\
    \   information as sent in the R1 packet earlier.\n   Both the Initiator and the\
    \ Responder should take some care when\n   verifying or calculating the HMAC_2.\
    \  Specifically, the Responder\n   should preserve other parameters than the HOST_ID\
    \ when sending the\n   R2.  Also, the Initiator has to preserve the HOST_ID exactly\
    \ as it\n   was received in the R1 packet.\n   The scope of the calculation for\
    \ HMAC and HMAC_2 is:\n   HMAC: { HIP header | [ Parameters ] }\n   where Parameters\
    \ include all HIP parameters of the packet that is\n   being calculated with Type\
    \ values from 1 to (HMAC's Type value - 1)\n   and exclude parameters with Type\
    \ values greater or equal to HMAC's\n   Type value.\n   During HMAC calculation,\
    \ the following applies:\n   o  In the HIP header, the Checksum field is set to\
    \ zero.\n   o  In the HIP header, the Header Length field value is calculated\
    \ to\n      the beginning of the HMAC parameter.\n   Parameter order is described\
    \ in Section 5.2.1.\n   HMAC_2: { HIP header | [ Parameters ] | HOST_ID }\n  \
    \ where Parameters include all HIP parameters for the packet that is\n   being\
    \ calculated with Type values from 1 to (HMAC_2's Type value - 1)\n   and exclude\
    \ parameters with Type values greater or equal to HMAC_2's\n   Type value.\n \
    \  During HMAC_2 calculation, the following applies:\n   o  In the HIP header,\
    \ the Checksum field is set to zero.\n   o  In the HIP header, the Header Length\
    \ field value is calculated to\n      the beginning of the HMAC_2 parameter and\
    \ added to the length of\n      the concatenated HOST_ID parameter length.\n \
    \  o  HOST_ID parameter is exactly in the form it was received in the R1\n   \
    \   packet from the Responder.\n   Parameter order is described in Section 5.2.1,\
    \ except that the\n   HOST_ID parameter in this calculation is added to the end.\n\
    \   The HMAC parameter is defined in Section 5.2.9 and the HMAC_2\n   parameter\
    \ in Section 5.2.10.  The HMAC calculation and verification\n   process (the process\
    \ applies both to HMAC and HMAC_2 except where\n   HMAC_2 is mentioned separately)\
    \ is as follows:\n   Packet sender:\n   1.  Create the HIP packet, without the\
    \ HMAC, HIP_SIGNATURE,\n       HIP_SIGNATURE_2, or any other parameter with greater\
    \ Type value\n       than the HMAC parameter has.\n   2.  In case of HMAC_2 calculation,\
    \ add a HOST_ID (Responder)\n       parameter to the end of the packet.\n   3.\
    \  Calculate the Header Length field in the HIP header including the\n       added\
    \ HOST_ID parameter in case of HMAC_2.\n   4.  Compute the HMAC using either HIP-gl\
    \ or HIP-lg integrity key\n       retrieved from KEYMAT as defined in Section\
    \ 6.5.\n   5.  In case of HMAC_2, remove the HOST_ID parameter from the packet.\n\
    \   6.  Add the HMAC parameter to the packet and any parameter with\n       greater\
    \ Type value than the HMAC's (HMAC_2's) that may follow,\n       including possible\
    \ HIP_SIGNATURE or HIP_SIGNATURE_2 parameters\n   7.  Recalculate the Length field\
    \ in the HIP header.\n   Packet receiver:\n   1.  Verify the HIP header Length\
    \ field.\n   2.  Remove the HMAC or HMAC_2 parameter, as well as all other\n \
    \      parameters that follow it with greater Type value including\n       possible\
    \ HIP_SIGNATURE or HIP_SIGNATURE_2 fields, saving the\n       contents if they\
    \ will be needed later.\n   3.  In case of HMAC_2, build and add a HOST_ID parameter\
    \ (with\n       Responder information) to the packet.  The HOST_ID parameter\n\
    \       should be identical to the one previously received from the\n       Responder.\n\
    \   4.  Recalculate the HIP packet length in the HIP header and clear the\n  \
    \     Checksum field (set it to all zeros).  In case of HMAC_2, the\n       length\
    \ is calculated with the added HOST_ID parameter.\n   5.  Compute the HMAC using\
    \ either HIP-gl or HIP-lg integrity key as\n       defined in Section 6.5 and\
    \ verify it against the received HMAC.\n   6.  Set Checksum and Header Length\
    \ field in the HIP header to\n       original values.\n   7.  In case of HMAC_2,\
    \ remove the HOST_ID parameter from the packet\n       before further processing.\n"
- title: 6.4.2.  Signature Calculation
  contents:
  - "6.4.2.  Signature Calculation\n   The following process applies both to the HIP_SIGNATURE\
    \ and\n   HIP_SIGNATURE_2 parameters.  When processing HIP_SIGNATURE_2, the\n\
    \   only difference is that instead of HIP_SIGNATURE parameter, the\n   HIP_SIGNATURE_2\
    \ parameter is used, and the Initiator's HIT and PUZZLE\n   Opaque and Random\
    \ #I fields are cleared (set to all zeros) before\n   computing the signature.\
    \  The HIP_SIGNATURE parameter is defined in\n   Section 5.2.11 and the HIP_SIGNATURE_2\
    \ parameter in Section 5.2.12.\n   The scope of the calculation for HIP_SIGNATURE\
    \ and HIP_SIGNATURE_2\n   is:\n   HIP_SIGNATURE: { HIP header | [ Parameters ]\
    \ }\n   where Parameters include all HIP parameters for the packet that is\n \
    \  being calculated with Type values from 1 to (HIP_SIGNATURE's Type\n   value\
    \ - 1).\n   During signature calculation, the following apply:\n   o  In the HIP\
    \ header, the Checksum field is set to zero.\n   o  In the HIP header, the Header\
    \ Length field value is calculated to\n      the beginning of the HIP_SIGNATURE\
    \ parameter.\n   Parameter order is described in Section 5.2.1.\n   HIP_SIGNATURE_2:\
    \ { HIP header | [ Parameters ] }\n   where Parameters include all HIP parameters\
    \ for the packet that is\n   being calculated with Type values from 1 to (HIP_SIGNATURE_2's\
    \ Type\n   value - 1).\n   During signature calculation, the following apply:\n\
    \   o  In the HIP header, the Initiator's HIT field and Checksum fields\n    \
    \  are set to zero.\n   o  In the HIP header, the Header Length field value is\
    \ calculated to\n      the beginning of the HIP_SIGNATURE_2 parameter.\n   o \
    \ PUZZLE parameter's Opaque and Random #I fields are set to zero.\n   Parameter\
    \ order is described in Section 5.2.1.\n   Signature calculation and verification\
    \ process (the process applies\n   both to HIP_SIGNATURE and HIP_SIGNATURE_2 except\
    \ in the case where\n   HIP_SIGNATURE_2 is separately mentioned):\n   Packet sender:\n\
    \   1.  Create the HIP packet without the HIP_SIGNATURE parameter or any\n   \
    \    parameters that follow the HIP_SIGNATURE parameter.\n   2.  Calculate the\
    \ Length field and zero the Checksum field in the HIP\n       header.  In case\
    \ of HIP_SIGNATURE_2, set Initiator's HIT field in\n       the HIP header as well\
    \ as PUZZLE parameter's Opaque and Random #I\n       fields to zero.\n   3.  Compute\
    \ the signature using the private key corresponding to the\n       Host Identifier\
    \ (public key).\n   4.  Add the HIP_SIGNATURE parameter to the packet.\n   5.\
    \  Add any parameters that follow the HIP_SIGNATURE parameter.\n   6.  Recalculate\
    \ the Length field in the HIP header, and calculate the\n       Checksum field.\n\
    \   Packet receiver:\n   1.  Verify the HIP header Length field.\n   2.  Save\
    \ the contents of the HIP_SIGNATURE parameter and any\n       parameters following\
    \ the HIP_SIGNATURE parameter and remove them\n       from the packet.\n   3.\
    \  Recalculate the HIP packet Length in the HIP header and clear the\n       Checksum\
    \ field (set it to all zeros).  In case of\n       HIP_SIGNATURE_2, set Initiator's\
    \ HIT field in HIP header as well\n       as PUZZLE parameter's Opaque and Random\
    \ #I fields to zero.\n   4.  Compute the signature and verify it against the received\n\
    \       signature using the packet sender's Host Identifier (public key).\n  \
    \ 5.  Restore the original packet by adding removed parameters (in step\n    \
    \   2) and resetting the values that were set to zero (in step 3).\n   The verification\
    \ can use either the HI received from a HIP packet,\n   the HI from a DNS query,\
    \ if the FQDN has been received in the HOST_ID\n   packet, or one received by\
    \ some other means.\n"
- title: 6.5.  HIP KEYMAT Generation
  contents:
  - "6.5.  HIP KEYMAT Generation\n   HIP keying material is derived from the Diffie-Hellman\
    \ session key,\n   Kij, produced during the HIP base exchange (Section 4.1.3).\
    \  The\n   Initiator has Kij during the creation of the I2 packet, and the\n \
    \  Responder has Kij once it receives the I2 packet.  This is why I2 can\n   already\
    \ contain encrypted information.\n   The KEYMAT is derived by feeding Kij and\
    \ the HITs into the following\n   operation; the | operation denotes concatenation.\n\
    \    KEYMAT = K1 | K2 | K3 | ...\n          where\n    K1   = RHASH( Kij | sort(HIT-I\
    \ | HIT-R) | I | J | 0x01 )\n    K2   = RHASH( Kij | K1 | 0x02 )\n    K3   = RHASH(\
    \ Kij | K2 | 0x03 )\n    ...\n    K255 = RHASH( Kij | K254 | 0xff )\n    K256\
    \ = RHASH( Kij | K255 | 0x00 )\n    etc.\n   Sort(HIT-I | HIT-R) is defined as\
    \ the network byte order\n   concatenation of the two HITs, with the smaller HIT\
    \ preceding the\n   larger HIT, resulting from the numeric comparison of the two\
    \ HITs\n   interpreted as positive (unsigned) 128-bit integers in network byte\n\
    \   order.\n   I and J values are from the puzzle and its solution that were\n\
    \   exchanged in R1 and I2 messages when this HIP association was set up.\n  \
    \ Both hosts have to store I and J values for the HIP association for\n   future\
    \ use.\n   The initial keys are drawn sequentially in the order that is\n   determined\
    \ by the numeric comparison of the two HITs, with comparison\n   method described\
    \ in the previous paragraph.  HOST_g denotes the host\n   with the greater HIT\
    \ value, and HOST_l the host with the lower HIT\n   value.\n   The drawing order\
    \ for initial keys:\n      HIP-gl encryption key for HOST_g's outgoing HIP packets\n\
    \      HIP-gl integrity (HMAC) key for HOST_g's outgoing HIP packets\n      HIP-lg\
    \ encryption key (currently unused) for HOST_l's outgoing HIP\n      packets\n\
    \      HIP-lg integrity (HMAC) key for HOST_l's outgoing HIP packets\n   The number\
    \ of bits drawn for a given algorithm is the \"natural\" size\n   of the keys.\
    \  For the mandatory algorithms, the following sizes\n   apply:\n   AES  128 bits\n\
    \   SHA-1  160 bits\n   NULL  0 bits\n   If other key sizes are used, they must\
    \ be treated as different\n   encryption algorithms and defined separately.\n"
- title: 6.6.  Initiation of a HIP Exchange
  contents:
  - "6.6.  Initiation of a HIP Exchange\n   An implementation may originate a HIP\
    \ exchange to another host based\n   on a local policy decision, usually triggered\
    \ by an application\n   datagram, in much the same way that an IPsec IKE key exchange\
    \ can\n   dynamically create a Security Association.  Alternatively, a system\n\
    \   may initiate a HIP exchange if it has rebooted or timed out, or\n   otherwise\
    \ lost its HIP state, as described in Section 4.5.4.\n   The implementation prepares\
    \ an I1 packet and sends it to the IP\n   address that corresponds to the peer\
    \ host.  The IP address of the\n   peer host may be obtained via conventional\
    \ mechanisms, such as DNS\n   lookup.  The I1 contents are specified in Section\
    \ 5.3.1.  The\n   selection of which Host Identity to use, if a host has more\
    \ than one\n   to choose from, is typically a policy decision.\n   The following\
    \ steps define the conceptual processing rules for\n   initiating a HIP exchange:\n\
    \   1.  The Initiator gets the Responder's HIT and one or more addresses\n   \
    \    either from a DNS lookup of the Responder's FQDN, from some other\n     \
    \  repository, or from a local table.  If the Initiator does not\n       know\
    \ the Responder's HIT, it may attempt opportunistic mode by\n       using NULL\
    \ (all zeros) as the Responder's HIT.  See also \"HIP\n       Opportunistic Mode\"\
    \ (Section 4.1.6).\n   2.  The Initiator sends an I1 to one of the Responder's\
    \ addresses.\n       The selection of which address to use is a local policy decision.\n\
    \   3.  Upon sending an I1, the sender shall transition to state I1-SENT,\n  \
    \     start a timer whose timeout value should be larger than the\n       worst-case\
    \ anticipated RTT, and shall increment a timeout counter\n       associated with\
    \ the I1.\n   4.  Upon timeout, the sender SHOULD retransmit the I1 and restart\
    \ the\n       timer, up to a maximum of I1_RETRIES_MAX tries.\n"
- title: 6.6.1.  Sending Multiple I1s in Parallel
  contents:
  - "6.6.1.  Sending Multiple I1s in Parallel\n   For the sake of minimizing the session\
    \ establishment latency, an\n   implementation MAY send the same I1 to more than\
    \ one of the\n   Responder's addresses.  However, it MUST NOT send to more than\
    \ three\n   (3) addresses in parallel.  Furthermore, upon timeout, the\n   implementation\
    \ MUST refrain from sending the same I1 packet to\n   multiple addresses.  That\
    \ is, if it retries to initialize the\n   connection after timeout, it MUST NOT\
    \ send the I1 packet to more than\n   one destination address.  These limitations\
    \ are placed in order to\n   avoid congestion of the network, and potential DoS\
    \ attacks that might\n   happen, e.g., because someone's claim to have hundreds\
    \ or thousands\n   of addresses could generate a huge number of I1 messages from\
    \ the\n   Initiator.\n   As the Responder is not guaranteed to distinguish the\
    \ duplicate I1s\n   it receives at several of its addresses (because it avoids\
    \ storing\n   states when it answers back an R1), the Initiator may receive several\n\
    \   duplicate R1s.\n   The Initiator SHOULD then select the initial preferred\
    \ destination\n   address using the source address of the selected received R1,\
    \ and use\n   the preferred address as a source address for the I2.  Processing\n\
    \   rules for received R1s are discussed in Section 6.8.\n"
- title: 6.6.2.  Processing Incoming ICMP Protocol Unreachable Messages
  contents:
  - "6.6.2.  Processing Incoming ICMP Protocol Unreachable Messages\n   A host may\
    \ receive an ICMP 'Destination Protocol Unreachable' message\n   as a response\
    \ to sending a HIP I1 packet.  Such a packet may be an\n   indication that the\
    \ peer does not support HIP, or it may be an\n   attempt to launch an attack by\
    \ making the Initiator believe that the\n   Responder does not support HIP.\n\
    \   When a system receives an ICMP 'Destination Protocol Unreachable'\n   message\
    \ while it is waiting for an R1, it MUST NOT terminate the\n   wait.  It MAY continue\
    \ as if it had not received the ICMP message,\n   and send a few more I1s.  Alternatively,\
    \ it MAY take the ICMP message\n   as a hint that the peer most probably does\
    \ not support HIP, and\n   return to state UNASSOCIATED earlier than otherwise.\
    \  However, at\n   minimum, it MUST continue waiting for an R1 for a reasonable\
    \ time\n   before returning to UNASSOCIATED.\n"
- title: 6.7.  Processing Incoming I1 Packets
  contents:
  - "6.7.  Processing Incoming I1 Packets\n   An implementation SHOULD reply to an\
    \ I1 with an R1 packet, unless the\n   implementation is unable or unwilling to\
    \ set up a HIP association.\n   If the implementation is unable to set up a HIP\
    \ association, the host\n   SHOULD send an ICMP Destination Protocol Unreachable,\n\
    \   Administratively Prohibited, message to the I1 source address.  If\n   the\
    \ implementation is unwilling to set up a HIP association, the host\n   MAY ignore\
    \ the I1.  This latter case may occur during a DoS attack\n   such as an I1 flood.\n\
    \   The implementation MUST be able to handle a storm of received I1\n   packets,\
    \ discarding those with common content that arrive within a\n   small time delta.\n\
    \   A spoofed I1 can result in an R1 attack on a system.  An R1 sender\n   MUST\
    \ have a mechanism to rate-limit R1s to an address.\n   It is RECOMMENDED that\
    \ the HIP state machine does not transition upon\n   sending an R1.\n   The following\
    \ steps define the conceptual processing rules for\n   responding to an I1 packet:\n\
    \   1.  The Responder MUST check that the Responder's HIT in the received\n  \
    \     I1 is either one of its own HITs or NULL.\n   2.  If the Responder is in\
    \ ESTABLISHED state, the Responder MAY\n       respond to this with an R1 packet,\
    \ prepare to drop existing SAs,\n       and stay at ESTABLISHED state.\n   3.\
    \  If the Responder is in I1-SENT state, it must make a comparison\n       between\
    \ the sender's HIT and its own (i.e., the receiver's) HIT.\n       If the sender's\
    \ HIT is greater than its own HIT, it should drop\n       the I1 and stay at I1-SENT.\
    \  If the sender's HIT is smaller than\n       its own HIT, it should send R1\
    \ and stay at I1-SENT.  The HIT\n       comparison goes similarly as in Section\
    \ 6.5.\n   4.  If the implementation chooses to respond to the I1 with an R1\n\
    \       packet, it creates a new R1 or selects a precomputed R1 according\n  \
    \     to the format described in Section 5.3.2.\n   5.  The R1 MUST contain the\
    \ received Responder's HIT, unless the\n       received HIT is NULL, in which\
    \ case the Responder SHOULD select a\n       HIT that is constructed with the\
    \ MUST algorithm in Section 3,\n       which is currently RSA.  Other than that,\
    \ selecting the HIT is a\n       local policy matter.\n   6.  The Responder sends\
    \ the R1 to the source IP address of the I1\n       packet.\n"
- title: 6.7.1.  R1 Management
  contents:
  - "6.7.1.  R1 Management\n   All compliant implementations MUST produce R1 packets.\
    \  An R1 packet\n   MAY be precomputed.  An R1 packet MAY be reused for time Delta\
    \ T,\n   which is implementation dependent, and SHOULD be deprecated and not\n\
    \   used once a valid response I2 packet has been received from an\n   Initiator.\
    \  During an I1 message storm, an R1 packet may be re-used\n   beyond this limit.\
    \  R1 information MUST NOT be discarded until Delta\n   S after T.  Time S is\
    \ the delay needed for the last I2 to arrive back\n   to the Responder.\n   An\
    \ implementation MAY keep state about received I1s and match the\n   received\
    \ I2s against the state, as discussed in Section 4.1.1.\n"
- title: 6.7.2.  Handling Malformed Messages
  contents:
  - "6.7.2.  Handling Malformed Messages\n   If an implementation receives a malformed\
    \ I1 message, it SHOULD NOT\n   respond with a NOTIFY message, as such practice\
    \ could open up a\n   potential denial-of-service danger.  Instead, it MAY respond\
    \ with an\n   ICMP packet, as defined in Section 5.4.\n"
- title: 6.8.  Processing Incoming R1 Packets
  contents:
  - "6.8.  Processing Incoming R1 Packets\n   A system receiving an R1 MUST first\
    \ check to see if it has sent an I1\n   to the originator of the R1 (i.e., it\
    \ is in state I1-SENT).  If so,\n   it SHOULD process the R1 as described below,\
    \ send an I2, and go to\n   state I2-SENT, setting a timer to protect the I2.\
    \  If the system is\n   in state I2-SENT, it MAY respond to an R1 if the R1 has\
    \ a larger R1\n   generation counter; if so, it should drop its state due to processing\n\
    \   the previous R1 and start over from state I1-SENT.  If the system is\n   in\
    \ any other state with respect to that host, it SHOULD silently drop\n   the R1.\n\
    \   When sending multiple I1s, an Initiator SHOULD wait for a small\n   amount\
    \ of time after the first R1 reception to allow possibly\n   multiple R1s to arrive,\
    \ and it SHOULD respond to an R1 among the set\n   with the largest R1 generation\
    \ counter.\n   The following steps define the conceptual processing rules for\n\
    \   responding to an R1 packet:\n   1.   A system receiving an R1 MUST first check\
    \ to see if it has sent\n        an I1 to the originator of the R1 (i.e., it has\
    \ a HIP\n        association that is in state I1-SENT and that is associated with\n\
    \        the HITs in the R1).  Unless the I1 was sent in opportunistic\n     \
    \   mode (see Section 4.1.6), the IP addresses in the received R1\n        packet\
    \ SHOULD be ignored and, when looking up the right HIP\n        association, the\
    \ received R1 SHOULD be matched against the\n        associations using only the\
    \ HITs.  If a match exists, the system\n        should process the R1 as described\
    \ below.\n   2.   Otherwise, if the system is in any other state than I1-SENT\
    \ or\n        I2-SENT with respect to the HITs included in the R1, it SHOULD\n\
    \        silently drop the R1 and remain in the current state.\n   3.   If the\
    \ HIP association state is I1-SENT or I2-SENT, the received\n        Initiator's\
    \ HIT MUST correspond to the HIT used in the original,\n        and the I1 and\
    \ the Responder's HIT MUST correspond to the one\n        used, unless the I1\
    \ contained a NULL HIT.\n   4.   The system SHOULD validate the R1 signature before\
    \ applying\n        further packet processing, according to Section 5.2.12.\n\
    \   5.   If the HIP association state is I1-SENT, and multiple valid R1s\n   \
    \     are present, the system SHOULD select from among the R1s with\n        the\
    \ largest R1 generation counter.\n   6.   If the HIP association state is I2-SENT,\
    \ the system MAY reenter\n        state I1-SENT and process the received R1 if\
    \ it has a larger R1\n        generation counter than the R1 responded to previously.\n\
    \   7.   The R1 packet may have the A bit set -- in this case, the system\n  \
    \      MAY choose to refuse it by dropping the R1 and returning to\n        state\
    \ UNASSOCIATED.  The system SHOULD consider dropping the R1\n        only if it\
    \ used a NULL HIT in I1.  If the A bit is set, the\n        Responder's HIT is\
    \ anonymous and should not be stored.\n   8.   The system SHOULD attempt to validate\
    \ the HIT against the\n        received Host Identity by using the received Host\
    \ Identity to\n        construct a HIT and verify that it matches the Sender's\
    \ HIT.\n   9.   The system MUST store the received R1 generation counter for\n\
    \        future reference.\n   10.  The system attempts to solve the puzzle in\
    \ R1.  The system MUST\n        terminate the search after exceeding the remaining\
    \ lifetime of\n        the puzzle.  If the puzzle is not successfully solved,\
    \ the\n        implementation may either resend I1 within the retry bounds or\n\
    \        abandon the HIP exchange.\n   11.  The system computes standard Diffie-Hellman\
    \ keying material\n        according to the public value and Group ID provided\
    \ in the\n        DIFFIE_HELLMAN parameter.  The Diffie-Hellman keying material\n\
    \        Kij is used for key extraction as specified in Section 6.5.  If\n   \
    \     the received Diffie-Hellman Group ID is not supported, the\n        implementation\
    \ may either resend I1 within the retry bounds or\n        abandon the HIP exchange.\n\
    \   12.  The system selects the HIP transform from the choices presented\n   \
    \     in the R1 packet and uses the selected values subsequently when\n      \
    \  generating and using encryption keys, and when sending the I2.\n        If\
    \ the proposed alternatives are not acceptable to the system,\n        it may\
    \ either resend I1 within the retry bounds or abandon the\n        HIP exchange.\n\
    \   13.  The system initializes the remaining variables in the associated\n  \
    \      state, including Update ID counters.\n   14.  The system prepares and sends\
    \ an I2, as described in\n        Section 5.3.3.\n   15.  The system SHOULD start\
    \ a timer whose timeout value should be\n        larger than the worst-case anticipated\
    \ RTT, and MUST increment a\n        timeout counter associated with the I2. \
    \ The sender SHOULD\n        retransmit the I2 upon a timeout and restart the\
    \ timer, up to a\n        maximum of I2_RETRIES_MAX tries.\n   16.  If the system\
    \ is in state I1-SENT, it shall transition to state\n        I2-SENT.  If the\
    \ system is in any other state, it remains in the\n        current state.\n"
- title: 6.8.1.  Handling Malformed Messages
  contents:
  - "6.8.1.  Handling Malformed Messages\n   If an implementation receives a malformed\
    \ R1 message, it MUST\n   silently drop the packet.  Sending a NOTIFY or ICMP\
    \ would not help,\n   as the sender of the R1 typically doesn't have any state.\
    \  An\n   implementation SHOULD wait for some more time for a possibly good R1,\n\
    \   after which it MAY try again by sending a new I1 packet.\n"
- title: 6.9.  Processing Incoming I2 Packets
  contents:
  - "6.9.  Processing Incoming I2 Packets\n   Upon receipt of an I2, the system MAY\
    \ perform initial checks to\n   determine whether the I2 corresponds to a recent\
    \ R1 that has been\n   sent out, if the Responder keeps such state.  For example,\
    \ the sender\n   could check whether the I2 is from an address or HIT that has\n\
    \   recently received an R1 from it.  The R1 may have had Opaque data\n   included\
    \ that was echoed back in the I2.  If the I2 is considered to\n   be suspect,\
    \ it MAY be silently discarded by the system.\n   Otherwise, the HIP implementation\
    \ SHOULD process the I2.  This\n   includes validation of the puzzle solution,\
    \ generating the Diffie-\n   Hellman key, decrypting the Initiator's Host Identity,\
    \ verifying the\n   signature, creating state, and finally sending an R2.\n  \
    \ The following steps define the conceptual processing rules for\n   responding\
    \ to an I2 packet:\n   1.   The system MAY perform checks to verify that the I2\
    \ corresponds\n        to a recently sent R1.  Such checks are implementation\n\
    \        dependent.  See Appendix A for a description of an example\n        implementation.\n\
    \   2.   The system MUST check that the Responder's HIT corresponds to\n     \
    \   one of its own HITs.\n   3.   If the system's state machine is in the R2-SENT\
    \ state, the\n        system MAY check if the newly received I2 is similar to\
    \ the one\n        that triggered moving to R2-SENT.  If so, it MAY retransmit\
    \ a\n        previously sent R2, reset the R2-SENT timer, and the state\n    \
    \    machine stays in R2-SENT.\n   4.   If the system's state machine is in the\
    \ I2-SENT state, the\n        system makes a comparison between its local and\
    \ sender's HITs\n        (similarly as in Section 6.5).  If the local HIT is smaller\
    \ than\n        the sender's HIT, it should drop the I2 packet, use the peer\n\
    \        Diffie-Hellman key and nonce I from the R1 packet received\n        earlier,\
    \ and get the local Diffie-Hellman key and nonce J from\n        the I2 packet\
    \ sent to the peer earlier.  Otherwise, the system\n        should process the\
    \ received I2 packet and drop any previously\n        derived Diffie-Hellman keying\
    \ material Kij it might have formed\n        upon sending the I2 previously. \
    \ The peer Diffie-Hellman key and\n        the nonce J are taken from the just\
    \ arrived I2 packet.  The\n        local Diffie-Hellman key and the nonce I are\
    \ the ones that were\n        earlier sent in the R1 packet.\n   5.   If the system's\
    \ state machine is in the I1-SENT state, and the\n        HITs in the I2 match\
    \ those used in the previously sent I1, the\n        system uses this received\
    \ I2 as the basis for the HIP\n        association it was trying to form, and\
    \ stops retransmitting I1\n        (provided that the I2 passes the below additional\
    \ checks).\n   6.   If the system's state machine is in any other state than R2-\n\
    \        SENT, the system SHOULD check that the echoed R1 generation\n       \
    \ counter in I2 is within the acceptable range.  Implementations\n        MUST\
    \ accept puzzles from the current generation and MAY accept\n        puzzles from\
    \ earlier generations.  If the newly received I2 is\n        outside the accepted\
    \ range, the I2 is stale (perhaps replayed)\n        and SHOULD be dropped.\n\
    \   7.   The system MUST validate the solution to the puzzle by computing\n  \
    \      the hash described in Section 5.3.3 using the same RHASH\n        algorithm.\n\
    \   8.   The I2 MUST have a single value in the HIP_TRANSFORM parameter,\n   \
    \     which MUST match one of the values offered to the Initiator in\n       \
    \ the R1 packet.\n   9.   The system must derive Diffie-Hellman keying material\
    \ Kij based\n        on the public value and Group ID in the DIFFIE_HELLMAN\n\
    \        parameter.  This key is used to derive the HIP association keys,\n  \
    \      as described in Section 6.5.  If the Diffie-Hellman Group ID is\n     \
    \   unsupported, the I2 packet is silently dropped.\n   10.  The encrypted HOST_ID\
    \ is decrypted by the Initiator encryption\n        key defined in Section 6.5.\
    \  If the decrypted data is not a\n        HOST_ID parameter, the I2 packet is\
    \ silently dropped.\n   11.  The implementation SHOULD also verify that the Initiator's\
    \ HIT\n        in the I2 corresponds to the Host Identity sent in the I2.\n  \
    \      (Note: some middleboxes may not able to make this verification.)\n   12.\
    \  The system MUST verify the HMAC according to the procedures in\n        Section\
    \ 5.2.9.\n   13.  The system MUST verify the HIP_SIGNATURE according to\n    \
    \    Section 5.2.11 and Section 5.3.3.\n   14.  If the checks above are valid,\
    \ then the system proceeds with\n        further I2 processing; otherwise, it\
    \ discards the I2 and its\n        state machine remains in the same state.\n\
    \   15.  The I2 packet may have the A bit set -- in this case, the system\n  \
    \      MAY choose to refuse it by dropping the I2 and the state machine\n    \
    \    returns to state UNASSOCIATED.  If the A bit is set, the\n        Initiator's\
    \ HIT is anonymous and should not be stored.\n   16.  The system initializes the\
    \ remaining variables in the associated\n        state, including Update ID counters.\n\
    \   17.  Upon successful processing of an I2 when the system's state\n       \
    \ machine is in state UNASSOCIATED, I1-SENT, I2-SENT, or R2-SENT,\n        an\
    \ R2 is sent and the system's state machine transitions to\n        state R2-SENT.\n\
    \   18.  Upon successful processing of an I2 when the system's state\n       \
    \ machine is in state ESTABLISHED, the old HIP association is\n        dropped\
    \ and a new one is installed, an R2 is sent, and the\n        system's state machine\
    \ transitions to R2-SENT.\n   19.  Upon the system's state machine transitioning\
    \ to R2-SENT, the\n        system starts a timer.  The state machine transitions\
    \ to\n        ESTABLISHED if some data has been received on the incoming HIP\n\
    \        association, or an UPDATE packet has been received (or some\n       \
    \ other packet that indicates that the peer system's state machine\n        has\
    \ moved to ESTABLISHED).  If the timer expires (allowing for\n        maximal\
    \ retransmissions of I2s), the state machine transitions\n        to ESTABLISHED.\n"
- title: 6.9.1.  Handling Malformed Messages
  contents:
  - "6.9.1.  Handling Malformed Messages\n   If an implementation receives a malformed\
    \ I2 message, the behavior\n   SHOULD depend on how many checks the message has\
    \ already passed.  If\n   the puzzle solution in the message has already been\
    \ checked, the\n   implementation SHOULD report the error by responding with a\
    \ NOTIFY\n   packet.  Otherwise, the implementation MAY respond with an ICMP\n\
    \   message as defined in Section 5.4.\n"
- title: 6.10.  Processing Incoming R2 Packets
  contents:
  - "6.10.  Processing Incoming R2 Packets\n   An R2 received in states UNASSOCIATED,\
    \ I1-SENT, or ESTABLISHED\n   results in the R2 being dropped and the state machine\
    \ staying in the\n   same state.  If an R2 is received in state I2-SENT, it SHOULD\
    \ be\n   processed.\n   The following steps define the conceptual processing rules\
    \ for an\n   incoming R2 packet:\n   1.  The system MUST verify that the HITs\
    \ in use correspond to the\n       HITs that were received in the R1.\n   2. \
    \ The system MUST verify the HMAC_2 according to the procedures in\n       Section\
    \ 5.2.10.\n   3.  The system MUST verify the HIP signature according to the\n\
    \       procedures in Section 5.2.11.\n   4.  If any of the checks above fail,\
    \ there is a high probability of\n       an ongoing man-in-the-middle or other\
    \ security attack.  The\n       system SHOULD act accordingly, based on its local\
    \ policy.\n   5.  If the system is in any other state than I2-SENT, the R2 is\n\
    \       silently dropped.\n   6.  Upon successful processing of the R2, the state\
    \ machine moves to\n       state ESTABLISHED.\n"
- title: 6.11.  Sending UPDATE Packets
  contents:
  - "6.11.  Sending UPDATE Packets\n   A host sends an UPDATE packet when it wants\
    \ to update some\n   information related to a HIP association.  There are a number\
    \ of\n   likely situations, e.g., mobility management and rekeying of an\n   existing\
    \ ESP Security Association.  The following paragraphs define\n   the conceptual\
    \ rules for sending an UPDATE packet to the peer.\n   Additional steps can be\
    \ defined in other documents where the UPDATE\n   packet is used.\n   The system\
    \ first determines whether there are any outstanding UPDATE\n   messages that\
    \ may conflict with the new UPDATE message under\n   consideration.  When multiple\
    \ UPDATEs are outstanding (not yet\n   acknowledged), the sender must assume that\
    \ such UPDATEs may be\n   processed in an arbitrary order.  Therefore, any new\
    \ UPDATEs that\n   depend on a previous outstanding UPDATE being successfully\
    \ received\n   and acknowledged MUST be postponed until reception of the necessary\n\
    \   ACK(s) occurs.  One way to prevent any conflicts is to only allow one\n  \
    \ outstanding UPDATE at a time.  However, allowing multiple UPDATEs may\n   improve\
    \ the performance of mobility and multihoming protocols.\n   The following steps\
    \ define the conceptual processing rules for\n   sending UPDATE packets.\n   1.\
    \  The first UPDATE packet is sent with Update ID of zero.\n       Otherwise,\
    \ the system increments its own Update ID value by one\n       before continuing\
    \ the below steps.\n   2.  The system creates an UPDATE packet that contains a\
    \ SEQ parameter\n       with the current value of Update ID.  The UPDATE packet\
    \ may also\n       include an ACK of the peer's Update ID found in a received\
    \ UPDATE\n       SEQ parameter, if any.\n   3.  The system sends the created UPDATE\
    \ packet and starts an UPDATE\n       timer.  The default value for the timer\
    \ is 2 * RTT estimate.  If\n       multiple UPDATEs are outstanding, multiple\
    \ timers are in effect.\n   4.  If the UPDATE timer expires, the UPDATE is resent.\
    \  The UPDATE\n       can be resent UPDATE_RETRY_MAX times.  The UPDATE timer\
    \ SHOULD be\n       exponentially backed off for subsequent retransmissions. \
    \ If no\n       acknowledgment is received from the peer after UPDATE_RETRY_MAX\n\
    \       times, the HIP association is considered to be broken and the\n      \
    \ state machine should move from state ESTABLISHED to state CLOSING\n       as\
    \ depicted in Section 4.4.3.  The UPDATE timer is cancelled upon\n       receiving\
    \ an ACK from the peer that acknowledges receipt of the\n       UPDATE.\n"
- title: 6.12.  Receiving UPDATE Packets
  contents:
  - "6.12.  Receiving UPDATE Packets\n   When a system receives an UPDATE packet,\
    \ its processing depends on\n   the state of the HIP association and the presence\
    \ and values of the\n   SEQ and ACK parameters.  Typically, an UPDATE message\
    \ also carries\n   optional parameters whose handling is defined in separate documents.\n\
    \   For each association, the peer's next expected in-sequence Update ID\n   (\"\
    peer Update ID\") is stored.  Initially, this value is zero.  Update\n   ID comparisons\
    \ of \"less than\" and \"greater than\" are performed with\n   respect to a circular\
    \ sequence number space.\n   The sender may send multiple outstanding UPDATE messages.\
    \  These\n   messages are processed in the order in which they are received at\
    \ the\n   receiver (i.e., no resequencing is performed).  When processing\n  \
    \ UPDATEs out-of-order, the receiver MUST keep track of which UPDATEs\n   were\
    \ previously processed, so that duplicates or retransmissions are\n   ACKed and\
    \ not reprocessed.  A receiver MAY choose to define a receive\n   window of Update\
    \ IDs that it is willing to process at any given time,\n   and discard received\
    \ UPDATEs falling outside of that window.\n   The following steps define the conceptual\
    \ processing rules for\n   receiving UPDATE packets.\n   1.  If there is no corresponding\
    \ HIP association, the implementation\n       MAY reply with an ICMP Parameter\
    \ Problem, as specified in\n       Section 5.4.4.\n   2.  If the association is\
    \ in the ESTABLISHED state and the SEQ (but\n       not ACK) parameter is present,\
    \ the UPDATE is processed and\n       replied to as described in Section 6.12.1.\n\
    \   3.  If the association is in the ESTABLISHED state and the ACK (but\n    \
    \   not SEQ) parameter is present, the UPDATE is processed as\n       described\
    \ in Section 6.12.2.\n   4.  If the association is in the ESTABLISHED state and\
    \ there is both\n       an ACK and SEQ in the UPDATE, the ACK is first processed\
    \ as\n       described in Section 6.12.2, and then the rest of the UPDATE is\n\
    \       processed as described in Section 6.12.1.\n"
- title: 6.12.1.  Handling a SEQ Parameter in a Received UPDATE Message
  contents:
  - "6.12.1.  Handling a SEQ Parameter in a Received UPDATE Message\n   The following\
    \ steps define the conceptual processing rules for\n   handling a SEQ parameter\
    \ in a received UPDATE packet.\n   1.  If the Update ID in the received SEQ is\
    \ not the next in the\n       sequence of Update IDs and is greater than the receiver's\
    \ window\n       for new UPDATEs, the packet MUST be dropped.\n   2.  If the Update\
    \ ID in the received SEQ corresponds to an UPDATE\n       that has recently been\
    \ processed, the packet is treated as a\n       retransmission.  The HMAC verification\
    \ (next step) MUST NOT be\n       skipped.  (A byte-by-byte comparison of the\
    \ received and a stored\n       packet would be OK, though.)  It is recommended\
    \ that a host cache\n       UPDATE packets sent with ACKs to avoid the cost of\
    \ generating a\n       new ACK packet to respond to a replayed UPDATE.  The system\
    \ MUST\n       acknowledge, again, such (apparent) UPDATE message\n       retransmissions\
    \ but SHOULD also consider rate-limiting such\n       retransmission responses\
    \ to guard against replay attacks.\n   3.  The system MUST verify the HMAC in\
    \ the UPDATE packet.  If the\n       verification fails, the packet MUST be dropped.\n\
    \   4.  The system MAY verify the SIGNATURE in the UPDATE packet.  If the\n  \
    \     verification fails, the packet SHOULD be dropped and an error\n       message\
    \ logged.\n   5.  If a new SEQ parameter is being processed, the parameters in\
    \ the\n       UPDATE are then processed.  The system MUST record the Update ID\n\
    \       in the received SEQ parameter, for replay protection.\n   6.  An UPDATE\
    \ acknowledgment packet with ACK parameter is prepared\n       and sent to the\
    \ peer.  This ACK parameter may be included in a\n       separate UPDATE or piggybacked\
    \ in an UPDATE with SEQ parameter,\n       as described in Section 5.3.5.  The\
    \ ACK parameter MAY acknowledge\n       more than one of the peer's Update IDs.\n"
- title: 6.12.2.  Handling an ACK Parameter in a Received UPDATE Packet
  contents:
  - "6.12.2.  Handling an ACK Parameter in a Received UPDATE Packet\n   The following\
    \ steps define the conceptual processing rules for\n   handling an ACK parameter\
    \ in a received UPDATE packet.\n   1.  The sequence number reported in the ACK\
    \ must match with an\n       earlier sent UPDATE packet that has not already been\n\
    \       acknowledged.  If no match is found or if the ACK does not\n       acknowledge\
    \ a new UPDATE, the packet MUST either be dropped if no\n       SEQ parameter\
    \ is present, or the processing steps in\n       Section 6.12.1 are followed.\n\
    \   2.  The system MUST verify the HMAC in the UPDATE packet.  If the\n      \
    \ verification fails, the packet MUST be dropped.\n   3.  The system MAY verify\
    \ the SIGNATURE in the UPDATE packet.  If the\n       verification fails, the\
    \ packet SHOULD be dropped and an error\n       message logged.\n   4.  The corresponding\
    \ UPDATE timer is stopped (see Section 6.11) so\n       that the now acknowledged\
    \ UPDATE is no longer retransmitted.  If\n       multiple UPDATEs are newly acknowledged,\
    \ multiple timers are\n       stopped.\n"
- title: 6.13.  Processing NOTIFY Packets
  contents:
  - "6.13.  Processing NOTIFY Packets\n   Processing NOTIFY packets is OPTIONAL. \
    \ If processed, any errors in a\n   received NOTIFICATION parameter SHOULD be\
    \ logged.  Received errors\n   MUST be considered only as informational, and the\
    \ receiver SHOULD NOT\n   change its HIP state (Section 4.4.1) purely based on\
    \ the received\n   NOTIFY message.\n"
- title: 6.14.  Processing CLOSE Packets
  contents:
  - "6.14.  Processing CLOSE Packets\n   When the host receives a CLOSE message, it\
    \ responds with a CLOSE_ACK\n   message and moves to CLOSED state.  (The authenticity\
    \ of the CLOSE\n   message is verified using both HMAC and SIGNATURE).  This processing\n\
    \   applies whether or not the HIP association state is CLOSING in order\n   to\
    \ handle CLOSE messages from both ends that cross in flight.\n   The HIP association\
    \ is not discarded before the host moves from the\n   UNASSOCIATED state.\n  \
    \ Once the closing process has started, any need to send data packets\n   will\
    \ trigger creating and establishing of a new HIP association,\n   starting with\
    \ sending an I1.\n   If there is no corresponding HIP association, the CLOSE packet\
    \ is\n   dropped.\n"
- title: 6.15.  Processing CLOSE_ACK Packets
  contents:
  - "6.15.  Processing CLOSE_ACK Packets\n   When a host receives a CLOSE_ACK message,\
    \ it verifies that it is in\n   CLOSING or CLOSED state and that the CLOSE_ACK\
    \ was in response to the\n   CLOSE (using the included ECHO_RESPONSE_SIGNED in\
    \ response to the\n   sent ECHO_REQUEST_SIGNED).\n   The CLOSE_ACK uses HMAC and\
    \ SIGNATURE for verification.  The state is\n   discarded when the state changes\
    \ to UNASSOCIATED and, after that, the\n   host MAY respond with an ICMP Parameter\
    \ Problem to an incoming CLOSE\n   message (see Section 5.4.4).\n"
- title: 6.16.  Handling State Loss
  contents:
  - "6.16.  Handling State Loss\n   In the case of system crash and unanticipated\
    \ state loss, the system\n   SHOULD delete the corresponding HIP state, including\
    \ the keying\n   material.  That is, the state SHOULD NOT be stored on stable\
    \ storage.\n   If the implementation does drop the state (as RECOMMENDED), it\
    \ MUST\n   also drop the peer's R1 generation counter value, unless a local\n\
    \   policy explicitly defines that the value of that particular host is\n   stored.\
    \  An implementation MUST NOT store R1 generation counters by\n   default, but\
    \ storing R1 generation counter values, if done, MUST be\n   configured by explicit\
    \ HITs.\n"
- title: 7.  HIP Policies
  contents:
  - "7.  HIP Policies\n   There are a number of variables that will influence the\
    \ HIP exchanges\n   that each host must support.  All HIP implementations MUST\
    \ support\n   more than one simultaneous HI, at least one of which SHOULD be\n\
    \   reserved for anonymous usage.  Although anonymous HIs will be rarely\n   used\
    \ as Responders' HIs, they will be common for Initiators.  Support\n   for more\
    \ than two HIs is RECOMMENDED.\n   Many Initiators would want to use a different\
    \ HI for different\n   Responders.  The implementations SHOULD provide for an\
    \ ACL of\n   Initiator's HIT to Responder's HIT.  This ACL SHOULD also include\n\
    \   preferred transform and local lifetimes.\n   The value of K used in the HIP\
    \ R1 packet can also vary by policy.  K\n   should never be greater than 20, but\
    \ for trusted partners it could be\n   as low as 0.\n   Responders would need\
    \ a similar ACL, representing which hosts they\n   accept HIP exchanges, and the\
    \ preferred transform and local\n   lifetimes.  Wildcarding SHOULD be supported\
    \ for this ACL also.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   HIP is designed to provide secure authentication\
    \ of hosts.  HIP also\n   attempts to limit the exposure of the host to various\
    \ denial-of-\n   service and man-in-the-middle (MitM) attacks.  In so doing, HIP\n\
    \   itself is subject to its own DoS and MitM attacks that potentially\n   could\
    \ be more damaging to a host's ability to conduct business as\n   usual.\n   The\
    \ 384-bit Diffie-Hellman Group is targeted to be used in hosts that\n   either\
    \ do not require or are not powerful enough for handling strong\n   cryptography.\
    \  Although there is a risk that with suitable equipment\n   the encryption can\
    \ be broken in real time, the 384-bit group can\n   provide some protection for\
    \ end-hosts that are not able to handle any\n   stronger cryptography.  When the\
    \ security provided by the 384-bit\n   group is not enough for applications on\
    \ a host, the support for this\n   group should be turned off in the configuration.\n\
    \   Denial-of-service attacks often take advantage of the cost of start\n   of\
    \ state for a protocol on the Responder compared to the 'cheapness'\n   on the\
    \ Initiator.  HIP makes no attempt to increase the cost of the\n   start of state\
    \ on the Initiator, but makes an effort to reduce the\n   cost to the Responder.\
    \  This is done by having the Responder start\n   the 3-way exchange instead of\
    \ the Initiator, making the HIP protocol\n   4 packets long.  In doing this, packet\
    \ 2 becomes a 'stock' packet\n   that the Responder MAY use many times, until\
    \ some Initiator has\n   provided a valid response to such an R1 packet.  During\
    \ an I1 storm,\n   the host may reuse the same D-H value also even if some Initiator\
    \ has\n   provided a valid response using that particular D-H value.  However,\n\
    \   such behavior is discouraged and should be avoided.  Using the same\n   Diffie-Hellman\
    \ values and random puzzle #I value has some risks.\n   This risk needs to be\
    \ balanced against a potential storm of HIP I1\n   packets.\n   This shifting\
    \ of the start of state cost to the Initiator in creating\n   the I2 HIP packet,\
    \ presents another DoS attack.  The attacker spoofs\n   the I1 HIP packet and\
    \ the Responder sends out the R1 HIP packet.\n   This could conceivably tie up\
    \ the 'Initiator' with evaluating the R1\n   HIP packet, and creating the I2 HIP\
    \ packet.  The defense against this\n   attack is to simply ignore any R1 packet\
    \ where a corresponding I1 was\n   not sent.\n   A second form of DoS attack arrives\
    \ in the I2 HIP packet.  Once the\n   attacking Initiator has solved the puzzle,\
    \ it can send packets with\n   spoofed IP source addresses with either an invalid\
    \ encrypted HIP\n   payload component or a bad HIP signature.  This would take\
    \ resources\n   in the Responder's part to reach the point to discover that the\
    \ I2\n   packet cannot be completely processed.  The defense against this\n  \
    \ attack is after N bad I2 packets, the Responder would discard any I2s\n   that\
    \ contain the given Initiator HIT.  This will shut down the\n   attack.  The attacker\
    \ would have to request another R1 and use that\n   to launch a new attack.  The\
    \ Responder could up the value of K while\n   under attack.  On the downside,\
    \ valid I2s might get dropped too.\n   A third form of DoS attack is emulating\
    \ the restart of state after a\n   reboot of one of the partners.  A restarting\
    \ host would send an I1 to\n   a peer, which would respond with an R1 even if\
    \ it were in the\n   ESTABLISHED state.  If the I1 were spoofed, the resulting\
    \ R1 would be\n   received unexpectedly by the spoofed host and would be dropped,\
    \ as in\n   the first case above.\n   A fourth form of DoS attack is emulating\
    \ the end of state.  HIP\n   relies on timers plus a CLOSE/CLOSE_ACK handshake\
    \ to explicitly\n   signal the end of a HIP association.  Because both CLOSE and\n\
    \   CLOSE_ACK messages contain an HMAC, an outsider cannot close a\n   connection.\
    \  The presence of an additional SIGNATURE allows\n   middleboxes to inspect these\
    \ messages and discard the associated\n   state (for e.g., firewalling, SPI-based\
    \ NATing, etc.).  However, the\n   optional behavior of replying to CLOSE with\
    \ an ICMP Parameter Problem\n   packet (as described in Section 5.4.4) might allow\
    \ an IP spoofer\n   sending CLOSE messages to launch reflection attacks.\n   A\
    \ fifth form of DoS attack is replaying R1s to cause the Initiator to\n   solve\
    \ stale puzzles and become out of synchronization with the\n   Responder.  The\
    \ R1 generation counter is a monotonically increasing\n   counter designed to\
    \ protect against this attack, as described in\n   Section 4.1.4.\n   Man-in-the-middle\
    \ attacks are difficult to defend against, without\n   third-party authentication.\
    \  A skillful MitM could easily handle all\n   parts of HIP, but HIP indirectly\
    \ provides the following protection\n   from a MitM attack.  If the Responder's\
    \ HI is retrieved from a signed\n   DNS zone, a certificate, or through some other\
    \ secure means, the\n   Initiator can use this to validate the R1 HIP packet.\n\
    \   Likewise, if the Initiator's HI is in a secure DNS zone, a trusted\n   certificate,\
    \ or otherwise securely available, the Responder can\n   retrieve the HI (after\
    \ having got the I2 HIP packet) and verify that\n   the HI indeed can be trusted.\
    \  However, since an Initiator may choose\n   to use an anonymous HI, it knowingly\
    \ risks a MitM attack.  The\n   Responder may choose not to accept a HIP exchange\
    \ with an anonymous\n   Initiator.\n   The HIP Opportunistic Mode concept has\
    \ been introduced in this\n   document, but this document does not specify what\
    \ the semantics of\n   such a connection setup are for applications.  There are\
    \ certain\n   concerns with opportunistic mode, as discussed in Section 4.1.6.\n\
    \   NOTIFY messages are used only for informational purposes and they are\n  \
    \ unacknowledged.  A HIP implementation cannot rely solely on the\n   information\
    \ received in a NOTIFY message because the packet may have\n   been replayed.\
    \  It SHOULD NOT change any state information based\n   purely on a received NOTIFY\
    \ message.\n   Since not all hosts will ever support HIP, ICMP 'Destination Protocol\n\
    \   Unreachable' messages are to be expected and present a DoS attack.\n   Against\
    \ an Initiator, the attack would look like the Responder does\n   not support\
    \ HIP, but shortly after receiving the ICMP message, the\n   Initiator would receive\
    \ a valid R1 HIP packet.  Thus, to protect from\n   this attack, an Initiator\
    \ should not react to an ICMP message until a\n   reasonable delta time to get\
    \ the real Responder's R1 HIP packet.  A\n   similar attack against the Responder\
    \ is more involved.  Normally, if\n   an I1 message received by a Responder was\
    \ a bogus one sent by an\n   attacker, the Responder may receive an ICMP message\
    \ from the IP\n   address the R1 message was sent to.  However, a sophisticated\n\
    \   attacker can try to take advantage of such a behavior and try to\n   break\
    \ up the HIP exchange by sending such an ICMP message to the\n   Responder before\
    \ the Initiator has a chance to send a valid I2\n   message.  Hence, the Responder\
    \ SHOULD NOT act on such an ICMP\n   message.  Especially, it SHOULD NOT remove\
    \ any minimal state created\n   when it sent the R1 HIP packet (if it did create\
    \ one), but wait for\n   either a valid I2 HIP packet or the natural timeout (that\
    \ is, if R1\n   packets are tracked at all).  Likewise, the Initiator should ignore\n\
    \   any ICMP message while waiting for an R2 HIP packet, and should\n   delete\
    \ any pending state only after a natural timeout.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   IANA has reserved protocol number 139 for the Host\
    \ Identity Protocol.\n   This document defines a new 128-bit value under the CGA\
    \ Message Type\n   namespace [RFC3972], 0xF0EF F02F BFF4 3D0F E793 0C3C 6E61 74EA,\
    \ to be\n   used for HIT generation as specified in ORCHID [RFC4843].\n   This\
    \ document also creates a set of new namespaces.  These are\n   described below.\n\
    \   Packet Type\n      The 7-bit Packet Type field in a HIP protocol packet describes\
    \ the\n      type of a HIP protocol message.  It is defined in Section 5.1.\n\
    \      The current values are defined in Sections 5.3.1 through 5.3.8.\n     \
    \ New values are assigned through IETF Consensus [RFC2434].\n   HIP Version\n\
    \      The four-bit Version field in a HIP protocol packet describes the\n   \
    \   version of the HIP protocol.  It is defined in Section 5.1.  The\n      only\
    \ currently defined value is 1.  New values are assigned\n      through IETF Consensus.\n\
    \   Parameter Type\n      The 16-bit Type field in a HIP parameter describes the\
    \ type of the\n      parameter.  It is defined in Section 5.2.1.  The current\
    \ values\n      are defined in Sections 5.2.3 through 5.2.20.\n      With the\
    \ exception of the assigned Type codes, the Type codes 0\n      through 1023 and\
    \ 61440 through 65535 are reserved for future base\n      protocol extensions,\
    \ and are assigned through IETF Consensus.\n      The Type codes 32768 through\
    \ 49141 are reserved for\n      experimentation.  Types SHOULD be selected in\
    \ a random fashion\n      from this range, thereby reducing the probability of\
    \ collisions.\n      A method employing genuine randomness (such as flipping a\
    \ coin)\n      SHOULD be used.\n      All other Type codes are assigned through\
    \ First Come First Served,\n      with Specification Required [RFC2434].\n   Group\
    \ ID\n      The eight-bit Group ID values appear in the DIFFIE_HELLMAN\n     \
    \ parameter and are defined in Section 5.2.6.  New values either\n      from the\
    \ reserved or unassigned space are assigned through IETF\n      Consensus.\n \
    \  Suite ID\n      The 16-bit Suite ID values in a HIP_TRANSFORM parameter are\n\
    \      defined in Section 5.2.7.  New values either from the reserved or\n   \
    \   unassigned space are assigned through IETF Consensus.\n   DI-Type\n      The\
    \ four-bit DI-Type values in a HOST_ID parameter are defined in\n      Section\
    \ 5.2.8.  New values are assigned through IETF Consensus.\n   Notify Message Type\n\
    \      The 16-bit Notify Message Type values in a NOTIFICATION parameter\n   \
    \   are defined in Section 5.2.16.\n      Notify Message Type values 1-10 are\
    \ used for informing about\n      errors in packet structures, values 11-20 for\
    \ informing about\n      problems in parameters containing cryptographic related\
    \ material,\n      values 21-30 for informing about problems in authentication\
    \ or\n      packet integrity verification.  Parameter numbers above 30 can be\n\
    \      used for informing about other types of errors or events.  Values\n   \
    \   51-8191 are error types reserved to be allocated by IANA.  Values\n      8192-16383\
    \ are error types for experimentation.  Values 16385-\n      40959 are status\
    \ types to be allocated by IANA, and values 40960-\n      65535 are status types\
    \ for experimentation.  New values in ranges\n      51-8191 and 16385-40959 are\
    \ assigned through First Come First\n      Served, with Specification Required.\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   The drive to create HIP came to being after attending\
    \ the MALLOC\n   meeting at the 43rd IETF meeting.  Baiju Patel and Hilarie Orman\n\
    \   really gave the original author, Bob Moskowitz, the assist to get HIP\n  \
    \ beyond 5 paragraphs of ideas.  It has matured considerably since the\n   early\
    \ versions thanks to extensive input from IETFers.  Most\n   importantly, its\
    \ design goals are articulated and are different from\n   other efforts in this\
    \ direction.  Particular mention goes to the\n   members of the NameSpace Research\
    \ Group of the IRTF.  Noel Chiappa\n   provided valuable input at early stages\
    \ of discussions about\n   identifier handling and Keith Moore the impetus to\
    \ provide\n   resolvability.  Steve Deering provided encouragement to keep working,\n\
    \   as a solid proposal can act as a proof of ideas for a research group.\n  \
    \ Many others contributed; extensive security tips were provided by\n   Steve\
    \ Bellovin.  Rob Austein kept the DNS parts on track.  Paul\n   Kocher taught\
    \ Bob Moskowitz how to make the puzzle exchange expensive\n   for the Initiator\
    \ to respond, but easy for the Responder to validate.\n   Bill Sommerfeld supplied\
    \ the Birthday concept, which later evolved\n   into the R1 generation counter,\
    \ to simplify reboot management.  Erik\n   Nordmark supplied the CLOSE-mechanism\
    \ for closing connections.\n   Rodney Thayer and Hugh Daniels provided extensive\
    \ feedback.  In the\n   early times of this document, John Gilmore kept Bob Moskowitz\n\
    \   challenged to provide something of value.\n   During the later stages of this\
    \ document, when the editing baton was\n   transferred to Pekka Nikander, the\
    \ input from the early implementors\n   was invaluable.  Without having actual\
    \ implementations, this document\n   would not be on the level it is now.\n  \
    \ In the usual IETF fashion, a large number of people have contributed\n   to\
    \ the actual text or ideas.  The list of these people include Jeff\n   Ahrenholz,\
    \ Francis Dupont, Derek Fawcus, George Gross, Andrew\n   McGregor, Julien Laganier,\
    \ Miika Komu, Mika Kousa, Jan Melen, Henrik\n   Petander, Michael Richardson,\
    \ Tim Shepard, Jorma Wall, and Jukka\n   Ylitalo.  Our apologies to anyone whose\
    \ name is missing.\n   Once the HIP Working Group was founded in early 2004, a\
    \ number of\n   changes were introduced through the working group process.  Most\n\
    \   notably, the original document was split in two, one containing the\n   base\
    \ exchange and the other one defining how to use ESP.  Some\n   modifications\
    \ to the protocol proposed by Aura, et al., [AUR03] were\n   added at a later\
    \ stage.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [FIPS95]       NIST, \"FIPS PUB 180-1: Secure\
    \ Hash Standard\",\n                  April 1995.\n   [RFC0768]      Postel, J.,\
    \ \"User Datagram Protocol\", STD 6, RFC 768,\n                  August 1980.\n\
    \   [RFC1035]      Mockapetris, P., \"Domain names - implementation and\n    \
    \              specification\", STD 13, RFC 1035, November 1987.\n   [RFC2119]\
    \      Bradner, S., \"Key words for use in RFCs to Indicate\n                \
    \  Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2404]      Madson,\
    \ C. and R. Glenn, \"The Use of HMAC-SHA-1-96\n                  within ESP and\
    \ AH\", RFC 2404, November 1998.\n   [RFC2451]      Pereira, R. and R. Adams,\
    \ \"The ESP CBC-Mode Cipher\n                  Algorithms\", RFC 2451, November\
    \ 1998.\n   [RFC2460]      Deering, S. and R. Hinden, \"Internet Protocol, Version\n\
    \                  6 (IPv6) Specification\", RFC 2460, December 1998.\n   [RFC2463]\
    \      Conta, A. and S. Deering, \"Internet Control Message\n                \
    \  Protocol (ICMPv6) for the Internet Protocol Version 6\n                  (IPv6)\
    \ Specification\", RFC 2463, December 1998.\n   [RFC2536]      Eastlake, D., \"\
    DSA KEYs and SIGs in the Domain Name\n                  System (DNS)\", RFC 2536,\
    \ March 1999.\n   [RFC2898]      Kaliski, B., \"PKCS #5: Password-Based Cryptography\n\
    \                  Specification Version 2.0\", RFC 2898, September 2000.\n  \
    \ [RFC3110]      Eastlake, D., \"RSA/SHA-1 SIGs and RSA KEYs in the\n        \
    \          Domain Name System (DNS)\", RFC 3110, May 2001.\n   [RFC3484]     \
    \ Draves, R., \"Default Address Selection for Internet\n                  Protocol\
    \ version 6 (IPv6)\", RFC 3484, February 2003.\n   [RFC3526]      Kivinen, T.\
    \ and M. Kojo, \"More Modular Exponential\n                  (MODP) Diffie-Hellman\
    \ groups for Internet Key Exchange\n                  (IKE)\", RFC 3526, May 2003.\n\
    \   [RFC3602]      Frankel, S., Glenn, R., and S. Kelly, \"The AES-CBC\n     \
    \             Cipher Algorithm and Its Use with IPsec\", RFC 3602,\n         \
    \         September 2003.\n   [RFC3972]      Aura, T., \"Cryptographically Generated\
    \ Addresses\n                  (CGA)\", RFC 3972, March 2005.\n   [RFC4034]  \
    \    Arends, R., Austein, R., Larson, M., Massey, D., and\n                  S.\
    \ Rose, \"Resource Records for the DNS Security\n                  Extensions\"\
    , RFC 4034, March 2005.\n   [RFC4282]      Aboba, B., Beadles, M., Arkko, J.,\
    \ and P. Eronen, \"The\n                  Network Access Identifier\", RFC 4282,\
    \ December 2005.\n   [RFC4307]      Schiller, J., \"Cryptographic Algorithms for\
    \ Use in the\n                  Internet Key Exchange Version 2 (IKEv2)\", RFC\
    \ 4307,\n                  December 2005.\n   [RFC4843]      Nikander, P., Laganier,\
    \ J., and F. Dupont, \"An IPv6\n                  Prefix for Overlay Routable\
    \ Cryptographic Hash\n                  Identifiers (ORCHID)\", RFC 4843, April\
    \ 2007.\n   [RFC5202]      Jokela, P., Moskowitz, R., and P. Nikander, \"Using\
    \ the\n                  Encapsulating Security Payload (ESP) Transport Format\n\
    \                  with the Host Identity Protocol (HIP)\", RFC 5202,\n      \
    \            April 2008.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [AUR03]        Aura, T., Nagarajan, A., and\
    \ A. Gurtov, \"Analysis of\n                  the HIP Base Exchange Protocol\"\
    , in Proceedings\n                  of 10th Australasian Conference on Information\n\
    \                  Security and  Privacy, July 2003.\n   [CRO03]        Crosby,\
    \ SA. and DS. Wallach, \"Denial of Service via\n                  Algorithmic\
    \ Complexity Attacks\", in Proceedings\n                  of Usenix Security Symposium\
    \ 2003,  Washington, DC.,\n                  August 2003.\n   [DIF76]        Diffie,\
    \ W. and M. Hellman, \"New Directions in\n                  Cryptography\", IEEE\
    \ Transactions on Information\n                  Theory vol. IT-22, number 6,\
    \ pages 644-654, Nov 1976.\n   [FIPS01]       NIST, \"FIPS PUB 197: Advanced Encryption\
    \ Standard\",\n                  Nov 2001.\n   [HIP-APP]      Henderson, T., Nikander,\
    \ P., and M. Komu, \"Using the\n                  Host Identity Protocol with\
    \ Legacy Applications\", Work\n                  in Progress, November 2007.\n\
    \   [IPsec-APIs]   Richardson, M., Williams, N., Komu, M., and S.\n          \
    \        Tarkoma, \"IPsec Application Programming Interfaces\",\n            \
    \      Work in Progress, February 2008.\n   [KAU03]        Kaufman, C., Perlman,\
    \ R., and B. Sommerfeld, \"DoS\n                  protection for UDP-based protocols\"\
    , ACM Conference on\n                  Computer and Communications Security ,\
    \ Oct 2003.\n   [KRA03]        Krawczyk, H., \"SIGMA: The 'SIGn-and-MAc' Approach\
    \ to\n                  Authenticated Diffie-Hellman and Its Use in the IKE-\n\
    \                  Protocols\", in Proceedings of CRYPTO 2003, pages 400-\n  \
    \                425, August 2003.\n   [RFC0792]      Postel, J., \"Internet Control\
    \ Message Protocol\",\n                  STD 5, RFC 792, September 1981.\n   [RFC2412]\
    \      Orman, H., \"The OAKLEY Key Determination Protocol\",\n               \
    \   RFC 2412, November 1998.\n   [RFC2434]      Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing\n                  an IANA Considerations Section in\
    \ RFCs\", BCP 26,\n                  RFC 2434, October 1998.\n   [RFC4306]   \
    \   Kaufman, C., \"Internet Key Exchange (IKEv2) Protocol\",\n               \
    \   RFC 4306, December 2005.\n   [RFC4423]      Moskowitz, R. and P. Nikander,\
    \ \"Host Identity Protocol\n                  (HIP) Architecture\", RFC 4423,\
    \ May 2006.\n   [RFC5204]      Laganier, J. and L. Eggert, \"Host Identity Protocol\n\
    \                  (HIP) Rendezvous Extension\", RFC 5204, April 2008.\n   [RFC5205]\
    \      Nikander, P. and J. Laganier, \"Host Identity Protocol\n              \
    \    (HIP) Domain Name System (DNS) Extensions\", RFC 5205,\n                \
    \  April 2008.\n   [RFC5206]      Henderson, T., Ed., \"End-Host Mobility and\
    \ Multihoming\n                  with the Host Identity Protocol\", RFC 5206,\n\
    \                  April 2008.\n   [SHIM6-PROTO]  Nordmark, E. and M. Bagnulo,\
    \ \"Shim6: Level 3\n                  Multihoming Shim Protocol for IPv6\", Work\
    \ in Progress,\n                  February 2008.\n"
- title: Appendix A.  Using Responder Puzzles
  contents:
  - "Appendix A.  Using Responder Puzzles\n   As mentioned in Section 4.1.1, the Responder\
    \ may delay state creation\n   and still reject most spoofed I2s by using a number\
    \ of pre-calculated\n   R1s and a local selection function.  This appendix defines\
    \ one\n   possible implementation in detail.  The purpose of this appendix is\n\
    \   to give the implementors an idea on how to implement the mechanism.\n   If\
    \ the implementation is based on this appendix, it MAY contain some\n   local\
    \ modification that makes an attacker's task harder.\n   The Responder creates\
    \ a secret value S, that it regenerates\n   periodically.  The Responder needs\
    \ to remember the two latest values\n   of S.  Each time the S is regenerated,\
    \ the R1 generation counter\n   value is incremented by one.\n   The Responder\
    \ generates a pre-signed R1 packet.  The signature for\n   pre-generated R1s must\
    \ be recalculated when the Diffie-Hellman key is\n   recomputed or when the R1_COUNTER\
    \ value changes due to S value\n   regeneration.\n   When the Initiator sends\
    \ the I1 packet for initializing a connection,\n   the Responder gets the HIT\
    \ and IP address from the packet, and\n   generates an I value for the puzzle.\
    \  The I value is set to the pre-\n   signed R1 packet.\n        I value calculation:\n\
    \        I = Ltrunc( RHASH ( S | HIT-I | HIT-R | IP-I | IP-R ), 64)\n   The RHASH\
    \ algorithm is the same that is used to generate the\n   Responder's HIT value.\n\
    \   From an incoming I2 packet, the Responder gets the required\n   information\
    \ to validate the puzzle: HITs, IP addresses, and the\n   information of the used\
    \ S value from the R1_COUNTER.  Using these\n   values, the Responder can regenerate\
    \ the I, and verify it against the\n   I received in the I2 packet.  If the I\
    \ values match, it can verify\n   the solution using I, J, and difficulty K. \
    \ If the I values do not\n   match, the I2 is dropped.\n        puzzle_check:\n\
    \        V := Ltrunc( RHASH( I2.I | I2.hit_i | I2.hit_r | I2.J ), K )\n      \
    \  if V != 0, drop the packet\n   If the puzzle solution is correct, the I and\
    \ J values are stored for\n   later use.  They are used as input material when\
    \ keying material is\n   generated.\n   Keeping state about failed puzzle solutions\
    \ depends on the\n   implementation.  Although it is possible for the Responder\
    \ not to\n   keep any state information, it still may do so to protect itself\n\
    \   against certain attacks (see Section 4.1.1).\n"
- title: Appendix B.  Generating a Public Key Encoding from an HI
  contents:
  - "Appendix B.  Generating a Public Key Encoding from an HI\n   The following pseudo-code\
    \ illustrates the process to generate a\n   public key encoding from an HI for\
    \ both RSA and DSA.\n   The symbol := denotes assignment; the symbol += denotes\
    \ appending.\n   The pseudo-function encode_in_network_byte_order takes two\n\
    \   parameters, an integer (bignum) and a length in bytes, and returns\n   the\
    \ integer encoded into a byte string of the given length.\n   switch ( HI.algorithm\
    \ )\n   {\n   case RSA:\n    buffer := encode_in_network_byte_order ( HI.RSA.e_len,\n\
    \              ( HI.RSA.e_len > 255 ) ? 3 : 1 )\n    buffer += encode_in_network_byte_order\
    \ ( HI.RSA.e, HI.RSA.e_len )\n    buffer += encode_in_network_byte_order ( HI.RSA.n,\
    \ HI.RSA.n_len )\n    break;\n   case DSA:\n    buffer := encode_in_network_byte_order\
    \ ( HI.DSA.T , 1 )\n    buffer += encode_in_network_byte_order ( HI.DSA.Q , 20\
    \ )\n    buffer += encode_in_network_byte_order ( HI.DSA.P , 64 +\n          \
    \                                   8 * HI.DSA.T )\n    buffer += encode_in_network_byte_order\
    \ ( HI.DSA.G , 64 +\n                                             8 * HI.DSA.T\
    \ )\n    buffer += encode_in_network_byte_order ( HI.DSA.Y , 64 +\n          \
    \                                   8 * HI.DSA.T )\n    break;\n   }\n"
- title: Appendix C.  Example Checksums for HIP Packets
  contents:
  - "Appendix C.  Example Checksums for HIP Packets\n   The HIP checksum for HIP packets\
    \ is specified in Section 5.1.1.\n   Checksums for TCP and UDP packets running\
    \ over HIP-enabled security\n   associations are specified in Section 3.5.  The\
    \ examples below use IP\n   addresses of 192.168.0.1 and 192.168.0.2 (and their\
    \ respective IPv4-\n   compatible IPv6 formats), and HITs with the prefix of 2001:10\n\
    \   followed by zeros, followed by a decimal 1 or 2, respectively.\n   The following\
    \ example is defined only for testing a checksum\n   calculation.  The address\
    \ format for the IPv4-compatible IPv6 address\n   is not a valid one, but using\
    \ these IPv6 addresses when testing an\n   IPv6 implementation gives the same\
    \ checksum output as an IPv4\n   implementation with the corresponding IPv4 addresses.\n"
- title: C.1.  IPv6 HIP Example (I1)
  contents:
  - "C.1.  IPv6 HIP Example (I1)\n      Source Address:                 ::192.168.0.1\n\
    \      Destination Address:            ::192.168.0.2\n      Upper-Layer Packet\
    \ Length:      40              0x28\n      Next Header:                    139\
    \             0x8b\n      Payload Protocol:               59              0x3b\n\
    \      Header Length:                  4               0x4\n      Packet Type:\
    \                    1               0x1\n      Version:                     \
    \   1               0x1\n      Reserved:                       1             \
    \  0x1\n      Control:                        0               0x0\n      Checksum:\
    \                       446             0x1be\n      Sender's HIT  :         \
    \        2001:10::1\n      Receiver's HIT:                 2001:10::2\n"
- title: C.2.  IPv4 HIP Packet (I1)
  contents:
  - "C.2.  IPv4 HIP Packet (I1)\n   The IPv4 checksum value for the same example I1\
    \ packet is the same as\n   the IPv6 checksum (since the checksums due to the\
    \ IPv4 and IPv6\n   pseudo-header components are the same).\n"
- title: C.3.  TCP Segment
  contents:
  - "C.3.  TCP Segment\n   Regardless of whether IPv6 or IPv4 is used, the TCP and\
    \ UDP sockets\n   use the IPv6 pseudo-header format [RFC2460], with the HITs used\
    \ in\n   place of the IPv6 addresses.\n      Sender's HIT:                   2001:10::1\n\
    \      Receiver's HIT:                 2001:10::2\n      Upper-Layer Packet Length:\
    \      20              0x14\n      Next Header:                    6         \
    \      0x06\n      Source port:                    65500           0xffdc\n  \
    \    Destination port:               22              0x0016\n      Sequence number:\
    \                1               0x00000001\n      Acknowledgment number:    \
    \      0               0x00000000\n      Header length:                  20  \
    \            0x14\n      Flags:                          SYN             0x02\n\
    \      Window size:                    65535           0xffff\n      Checksum:\
    \                       28618           0x6fca\n      Urgent pointer:        \
    \         0               0x0000\n        0x0000:  6000 0000 0014 0640 2001 0010\
    \ 0000 0000\n        0x0010:  0000 0000 0000 0001 2001 0010 0000 0000\n      \
    \  0x0020:  0000 0000 0000 0002 ffdc 0016 0000 0001\n        0x0030:  0000 0000\
    \ 5002 ffff 6fca 0000\n"
- title: Appendix D.  384-Bit Group
  contents:
  - "Appendix D.  384-Bit Group\n   This 384-bit group is defined only to be used\
    \ with HIP.  NOTE: The\n   security level of this group is very low!  The encryption\
    \ may be\n   broken in a very short time, even real-time.  It should be used only\n\
    \   when the host is not powerful enough (e.g., some PDAs) and when\n   security\
    \ requirements are low (e.g., during normal web surfing).\n   This prime is: 2^384\
    \ - 2^320 - 1 + 2^64 * { [ 2^254 pi] + 5857 }\n   Its hexadecimal value is:\n\
    \       FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n       29024E08\
    \ 8A67CC74 020BBEA6 3B13B202 FFFFFFFF FFFFFFFF\n   The generator is: 2.\n"
- title: Appendix E.  OAKLEY Well-Known Group 1
  contents:
  - "Appendix E.  OAKLEY Well-Known Group 1\n   See also [RFC2412] for definition\
    \ of OAKLEY well-known group 1.\n   OAKLEY Well-Known Group 1: A 768-bit prime\n\
    \   The prime is 2^768 - 2^704 - 1 + 2^64 * { [2^638 pi] + 149686 }.\n   The hexadecimal\
    \ value is:\n       FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n  \
    \     29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\n       EF9519B3 CD3A431B\
    \ 302B0A6D F25F1437 4FE1356D 6D51C245\n       E485B576 625E7EC6 F44C42E9 A63A3620\
    \ FFFFFFFF FFFFFFFF\n   This has been rigorously verified as a prime.\n   The\
    \ generator is: 22 (decimal)\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Robert Moskowitz\n   ICSAlabs, An Independent Division\
    \ of Verizon Business Systems\n   1000 Bent Creek Blvd, Suite 200\n   Mechanicsburg,\
    \ PA\n   USA\n   EMail: rgm@icsalabs.com\n   Pekka Nikander\n   Ericsson Research\
    \ NomadicLab\n   JORVAS  FIN-02420\n   FINLAND\n   Phone: +358 9 299 1\n   EMail:\
    \ pekka.nikander@nomadiclab.com\n   Petri Jokela (editor)\n   Ericsson Research\
    \ NomadicLab\n   JORVAS  FIN-02420\n   FINLAND\n   Phone: +358 9 299 1\n   EMail:\
    \ petri.jokela@nomadiclab.com\n   Thomas R. Henderson\n   The Boeing Company\n\
    \   P.O. Box 3707\n   Seattle, WA\n   USA\n   EMail: thomas.r.henderson@boeing.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
