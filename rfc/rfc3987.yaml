- contents:
  - '             Internationalized Resource Identifiers (IRIs)

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document defines a new protocol element, the Internationalized\n
    \  Resource Identifier (IRI), as a complement to the Uniform Resource\n   Identifier
    (URI).  An IRI is a sequence of characters from the\n   Universal Character Set
    (Unicode/ISO 10646).  A mapping from IRIs to\n   URIs is defined, which means
    that IRIs can be used instead of URIs,\n   where appropriate, to identify resources.\n
    \  The approach of defining a new protocol element was chosen instead of\n   extending
    or changing the definition of URIs.  This was done in order\n   to allow a clear
    distinction and to avoid incompatibilities with\n   existing software.  Guidelines
    are provided for the use and\n   deployment of IRIs in various protocols, formats,
    and software\n   components that currently deal with URIs.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n       1.1.  Overview and Motivation  . . . . . . . . . . . .
    . . . .  3\n       1.2.  Applicability  . . . . . . . . . . . . . . . . . . .
    . .  3\n       1.3.  Definitions  . . . . . . . . . . . . . . . . . . . . . .
    \ 4\n       1.4.  Notation . . . . . . . . . . . . . . . . . . . . . . . .  5\n
    \  2.  IRI Syntax . . . . . . . . . . . . . . . . . . . . . . . . . .  6\n       2.1.
    \ Summary of IRI Syntax  . . . . . . . . . . . . . . . . .  6\n       2.2.  ABNF
    for IRI References and IRIs . . . . . . . . . . . .  7\n   3.  Relationship between
    IRIs and URIs . . . . . . . . . . . . . . 10\n       3.1.  Mapping of IRIs to
    URIs  . . . . . . . . . . . . . . . . 10\n       3.2.  Converting URIs to IRIs
    \ . . . . . . . . . . . . . . . . 14\n             3.2.1.  Examples . . . . .
    . . . . . . . . . . . . . . . 15\n   4.  Bidirectional IRIs for Right-to-Left
    Languages.  . . . . . . . 16\n       4.1.  Logical Storage and Visual Presentation
    \ . . . . . . . . 17\n       4.2.  Bidi IRI Structure . . . . . . . . . . . .
    . . . . . . . 18\n       4.3.  Input of Bidi IRIs . . . . . . . . . . . . . .
    . . . . . 19\n       4.4.  Examples . . . . . . . . . . . . . . . . . . . . .
    . . . 19\n   5.  Normalization and Comparison . . . . . . . . . . . . . . . .
    . 21\n       5.1.  Equivalence  . . . . . . . . . . . . . . . . . . . . . . 22\n
    \      5.2.  Preparation for Comparison . . . . . . . . . . . . . . . 22\n       5.3.
    \ Comparison Ladder  . . . . . . . . . . . . . . . . . . . 23\n             5.3.1.
    \ Simple String Comparison . . . . . . . . . . . . 23\n             5.3.2.  Syntax-Based
    Normalization . . . . . . . . . . . 24\n             5.3.3.  Scheme-Based Normalization
    . . . . . . . . . . . 27\n             5.3.4.  Protocol-Based Normalization .
    . . . . . . . . . 28\n   6.  Use of IRIs  . . . . . . . . . . . . . . . . . .
    . . . . . . . 29\n       6.1.  Limitations on UCS Characters Allowed in IRIs  .
    . . . . 29\n       6.2.  Software Interfaces and Protocols  . . . . . . . . .
    . . 29\n       6.3.  Format of URIs and IRIs in Documents and Protocols . . .
    30\n       6.4.  Use of UTF-8 for Encoding Original Characters .. . . . . 30\n
    \      6.5.  Relative IRI References  . . . . . . . . . . . . . . . . 32\n   7.
    \ URI/IRI Processing Guidelines (informative)  . . . . . . . . . 32\n       7.1.
    \ URI/IRI Software Interfaces  . . . . . . . . . . . . . . 32\n       7.2.  URI/IRI
    Entry  . . . . . . . . . . . . . . . . . . . . . 33\n       7.3.  URI/IRI Transfer
    between Applications  . . . . . . . . . 33\n       7.4.  URI/IRI Generation .
    . . . . . . . . . . . . . . . . . . 34\n       7.5.  URI/IRI Selection  . . .
    . . . . . . . . . . . . . . . . 34\n       7.6.  Display of URIs/IRIs . . . .
    . . . . . . . . . . . . . . 35\n       7.7.  Interpretation of URIs and IRIs  .
    . . . . . . . . . . . 36\n       7.8.  Upgrading Strategy . . . . . . . . . .
    . . . . . . . . . 36\n   8.  Security Considerations  . . . . . . . . . . . .
    . . . . . . . 37\n   9.  Acknowledgements . . . . . . . . . . . . . . . . . .
    . . . . . 39\n   10. References . . . . . . . . . . . . . . . . . . . . . . .
    . . . 40\n       10.1. Normative References . . . . . . . . . . . . . . . . .
    . 40\n       10.2. Informative References . . . . . . . . . . . . . . . . . 41\n
    \  A.  Design Alternatives  . . . . . . . . . . . . . . . . . . . . . 44\n       A.1.
    \ New Scheme(s)  . . . . . . . . . . . . . . . . . . . . . 44\n       A.2.  Character
    Encodings Other Than UTF-8 . . . . . . . . . . 44\n       A.3.  New Encoding Convention
    \ . . . . . . . . . . . . . . . . 44\n       A.4.  Indicating Character Encodings
    in the URI/IRI  . . . . . 45\n   Authors' Addresses . . . . . . . . . . . . .
    . . . . . . . . . . . 45\n   Full Copyright Statement . . . . . . . . . . . .
    . . . . . . . . . 46\n"
  title: Table of Contents
- contents:
  - '1.  Introduction

    '
  - contents:
    - "1.1.  Overview and Motivation\n   A Uniform Resource Identifier (URI) is defined
      in [RFC3986] as a\n   sequence of characters chosen from a limited subset of
      the repertoire\n   of US-ASCII [ASCII] characters.\n   The characters in URIs
      are frequently used for representing words of\n   natural languages.  This usage
      has many advantages: Such URIs are\n   easier to memorize, easier to interpret,
      easier to transcribe, easier\n   to create, and easier to guess.  For most languages
      other than\n   English, however, the natural script uses characters other than
      A -\n   Z. For many people, handling Latin characters is as difficult as\n   handling
      the characters of other scripts is for those who use only\n   the Latin alphabet.
      \ Many languages with non-Latin scripts are\n   transcribed with Latin letters.
      \ These transcriptions are now often\n   used in URIs, but they introduce additional
      ambiguities.\n   The infrastructure for the appropriate handling of characters
      from\n   local scripts is now widely deployed in local versions of operating\n
      \  system and application software.  Software that can handle a wide\n   variety
      of scripts and languages at the same time is increasingly\n   common.  Also,
      increasing numbers of protocols and formats can carry\n   a wide range of characters.\n
      \  This document defines a new protocol element called Internationalized\n   Resource
      Identifier (IRI) by extending the syntax of URIs to a much\n   wider repertoire
      of characters.  It also defines \"internationalized\"\n   versions corresponding
      to other constructs from [RFC3986], such as\n   URI references.  The syntax
      of IRIs is defined in section 2, and the\n   relationship between IRIs and URIs
      in section 3.\n   Using characters outside of A - Z in IRIs brings some difficulties.\n
      \  Section 4 discusses the special case of bidirectional IRIs, section 5\n   various
      forms of equivalence between IRIs, and section 6 the use of\n   IRIs in different
      situations.  Section 7 gives additional informative\n   guidelines, and section
      8 security considerations.\n"
    title: 1.1.  Overview and Motivation
  - contents:
    - "1.2.  Applicability\n   IRIs are designed to be compatible with recommendations
      for new URI\n   schemes [RFC2718].  The compatibility is provided by specifying
      a\n   well-defined and deterministic mapping from the IRI character\n   sequence
      to the functionally equivalent URI character sequence.\n   Practical use of
      IRIs (or IRI references) in place of URIs (or URI\n   references) depends on
      the following conditions being met:\n   a.  A protocol or format element should
      be explicitly designated to\n       be able to carry IRIs.  The intent is not
      to introduce IRIs into\n       contexts that are not defined to accept them.
      \ For example, XML\n       schema [XMLSchema] has an explicit type \"anyURI\"
      that includes\n       IRIs and IRI references. Therefore, IRIs and IRI references
      can\n       be in attributes and elements of type \"anyURI\".  On the other\n
      \      hand, in the HTTP protocol [RFC2616], the Request URI is defined\n       as
      a URI, which means that direct use of IRIs is not allowed in\n       HTTP requests.\n
      \  b.  The protocol or format carrying the IRIs should have a mechanism\n       to
      represent the wide range of characters used in IRIs, either\n       natively
      or by some protocol- or format-specific escaping\n       mechanism (for example,
      numeric character references in [XML1]).\n   c.  The URI corresponding to the
      IRI in question has to encode\n       original characters into octets using
      UTF-8.  For new URI\n       schemes, this is recommended in [RFC2718].  It can
      apply to a\n       whole scheme (e.g., IMAP URLs [RFC2192] and POP URLs [RFC2384],\n
      \      or the URN syntax [RFC2141]).  It can apply to a specific part of\n       a
      URI, such as the fragment identifier (e.g., [XPointer]).  It\n       can apply
      to a specific URI or part(s) thereof.  For details,\n       please see section
      6.4.\n"
    title: 1.2.  Applicability
  - contents:
    - "1.3.  Definitions\n   The following definitions are used in this document;
      they follow the\n   terms in [RFC2130], [RFC2277], and [ISO10646].\n   character:
      A member of a set of elements used for the organization,\n      control, or
      representation of data.  For example, \"LATIN CAPITAL\n      LETTER A\" names
      a character.\n   octet: An ordered sequence of eight bits considered as a unit.\n
      \  character repertoire: A set of characters (in the mathematical\n      sense).\n
      \  sequence of characters: A sequence of characters (one after another).\n   sequence
      of octets: A sequence of octets (one after another).\n   character encoding:
      A method of representing a sequence of characters\n      as a sequence of octets
      (maybe with variants).  Also, a method of\n      (unambiguously) converting
      a sequence of octets into a sequence of\n      characters.\n   charset: The
      name of a parameter or attribute used to identify a\n      character encoding.\n
      \  UCS: Universal Character Set. The coded character set defined by\n      ISO/IEC
      10646 [ISO10646] and the Unicode Standard [UNIV4].\n   IRI reference: Denotes
      the common usage of an Internationalized\n      Resource Identifier.  An IRI
      reference may be absolute or\n      relative.  However, the \"IRI\" that results
      from such a reference\n      only includes absolute IRIs; any relative IRI references
      are\n      resolved to their absolute form.  Note that in [RFC2396] URIs did\n
      \     not include fragment identifiers, but in [RFC3986] fragment\n      identifiers
      are part of URIs.\n   running text: Human text (paragraphs, sentences, phrases)
      with syntax\n      according to orthographic conventions of a natural language,
      as\n      opposed to syntax defined for ease of processing by machines\n      (e.g.,
      markup, programming languages).\n   protocol element: Any portion of a message
      that affects processing of\n      that message by the protocol in question.\n
      \  presentation element: A presentation form corresponding to a protocol\n      element;
      for example, using a wider range of characters.\n   create (a URI or IRI): With
      respect to URIs and IRIs, the term is\n      used for the initial creation.
      \ This may be the initial creation\n      of a resource with a certain identifier,
      or the initial exposition\n      of a resource under a particular identifier.\n
      \  generate (a URI or IRI): With respect to URIs and IRIs, the term is\n      used
      when the IRI is generated by derivation from other\n      information.\n"
    title: 1.3.  Definitions
  - contents:
    - "1.4.  Notation\n   RFCs and Internet Drafts currently do not allow any characters\n
      \  outside the US-ASCII repertoire.  Therefore, this document uses\n   various
      special notations to denote such characters in examples.\n   In text, characters
      outside US-ASCII are sometimes referenced by\n   using a prefix of 'U+', followed
      by four to six hexadecimal digits.\n   To represent characters outside US-ASCII
      in examples, this document\n   uses two notations: 'XML Notation' and 'Bidi
      Notation'.\n   XML Notation uses a leading '&#x', a trailing ';', and the\n
      \  hexadecimal number of the character in the UCS in between.  For\n   example,
      &#x44F; stands for CYRILLIC CAPITAL LETTER YA.  In this\n   notation, an actual
      '&' is denoted by '&amp;'.\n   Bidi Notation is used for bidirectional examples:
      Lowercase letters\n   stand for Latin letters or other letters that are written
      left to\n   right, whereas uppercase letters represent Arabic or Hebrew letters\n
      \  that are written right to left.\n   To denote actual octets in examples (as
      opposed to percent-encoded\n   octets), the two hex digits denoting the octet
      are enclosed in \"<\"\n   and \">\".  For example, the octet often denoted as
      0xc9 is denoted\n   here as <c9>.\n   In this document, the key words \"MUST\",
      \"MUST NOT\", \"REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD
      NOT\", \"RECOMMENDED\",  \"MAY\",\n   and \"OPTIONAL\" are to be interpreted
      as described in [RFC2119].\n"
    title: 1.4.  Notation
  title: 1.  Introduction
- contents:
  - "2.  IRI Syntax\n   This section defines the syntax of Internationalized Resource\n
    \  Identifiers (IRIs).\n   As with URIs, an IRI is defined as a sequence of characters,
    not as a\n   sequence of octets.  This definition accommodates the fact that IRIs\n
    \  may be written on paper or read over the radio as well as stored or\n   transmitted
    digitally.  The same IRI may be represented as different\n   sequences of octets
    in different protocols or documents if these\n   protocols or documents use different
    character encodings (and/or\n   transfer encodings).  Using the same character
    encoding as the\n   containing protocol or document ensures that the characters
    in the\n   IRI can be handled (e.g., searched, converted, displayed) in the same\n
    \  way as the rest of the protocol or document.\n"
  - contents:
    - "2.1.  Summary of IRI Syntax\n   IRIs are defined similarly to URIs in [RFC3986],
      but the class of\n   unreserved characters is extended by adding the characters
      of the UCS\n   (Universal Character Set, [ISO10646]) beyond U+007F, subject
      to the\n   limitations given in the syntax rules below and in section 6.1.\n
      \  Otherwise, the syntax and use of components and reserved characters\n   is
      the same as that in [RFC3986].  All the operations defined in\n   [RFC3986],
      such as the resolution of relative references, can be\n   applied to IRIs by
      IRI-processing software in exactly the same way as\n   they are for URIs by
      URI-processing software.\n   Characters outside the US-ASCII repertoire are
      not reserved and\n   therefore MUST NOT be used for syntactical purposes, such
      as to\n   delimit components in newly defined schemes.  For example, U+00A2,\n
      \  CENT SIGN, is not allowed as a delimiter in IRIs, because it is in\n   the
      'iunreserved' category. This is similar to the fact that it is\n   not possible
      to use '-' as a delimiter in URIs, because it is in the\n   'unreserved' category.\n"
    title: 2.1.  Summary of IRI Syntax
  - contents:
    - "2.2.  ABNF for IRI References and IRIs\n   Although it might be possible to
      define IRI references and IRIs\n   merely by their transformation to URI references
      and URIs, they can\n   also be accepted and processed directly.  Therefore,
      an ABNF\n   definition for IRI references (which are the most general concept
      and\n   the start of the grammar) and IRIs is given here.  The syntax of this\n
      \  ABNF is described in [RFC2234].  Character numbers are taken from the\n   UCS,
      without implying any actual binary encoding.  Terminals in the\n   ABNF are
      characters, not bytes.\n   The following grammar closely follows the URI grammar
      in [RFC3986],\n   except that the range of unreserved characters is expanded
      to include\n   UCS characters, with the restriction that private UCS characters
      can\n   occur only in query parts.  The grammar is split into two parts:\n   Rules
      that differ from [RFC3986] because of the above-mentioned\n   expansion, and
      rules that are the same as those in [RFC3986].  For\n   rules that are different
      than those in [RFC3986], the names of the\n   non-terminals have been changed
      as follows.  If the non-terminal\n   contains 'URI', this has been changed to
      'IRI'.  Otherwise, an 'i'\n   has been prefixed.\n   The following rules are
      different from those in [RFC3986]:\n   IRI            = scheme \":\" ihier-part
      [ \"?\" iquery ]\n                         [ \"#\" ifragment ]\n   ihier-part
      \    = \"//\" iauthority ipath-abempty\n                  / ipath-absolute\n
      \                 / ipath-rootless\n                  / ipath-empty\n   IRI-reference
      \ = IRI / irelative-ref\n   absolute-IRI   = scheme \":\" ihier-part [ \"?\"
      iquery ]\n   irelative-ref  = irelative-part [ \"?\" iquery ] [ \"#\" ifragment
      ]\n   irelative-part = \"//\" iauthority ipath-abempty\n                       /
      ipath-absolute\n                  / ipath-noscheme\n                  / ipath-empty\n
      \  iauthority     = [ iuserinfo \"@\" ] ihost [ \":\" port ]\n   iuserinfo      =
      *( iunreserved / pct-encoded / sub-delims / \":\" )\n   ihost          = IP-literal
      / IPv4address / ireg-name\n   ireg-name      = *( iunreserved / pct-encoded
      / sub-delims )\n   ipath          = ipath-abempty   ; begins with \"/\" or is
      empty\n                  / ipath-absolute  ; begins with \"/\" but not \"//\"\n
      \                 / ipath-noscheme  ; begins with a non-colon segment\n                  /
      ipath-rootless  ; begins with a segment\n                  / ipath-empty     ;
      zero characters\n   ipath-abempty  = *( \"/\" isegment )\n   ipath-absolute
      = \"/\" [ isegment-nz *( \"/\" isegment ) ]\n   ipath-noscheme = isegment-nz-nc
      *( \"/\" isegment )\n   ipath-rootless = isegment-nz *( \"/\" isegment )\n   ipath-empty
      \   = 0<ipchar>\n   isegment       = *ipchar\n   isegment-nz    = 1*ipchar\n
      \  isegment-nz-nc = 1*( iunreserved / pct-encoded / sub-delims\n                        /
      \"@\" )\n                  ; non-zero-length segment without any colon \":\"\n
      \  ipchar         = iunreserved / pct-encoded / sub-delims / \":\"\n                  /
      \"@\"\n   iquery         = *( ipchar / iprivate / \"/\" / \"?\" )\n   ifragment
      \     = *( ipchar / \"/\" / \"?\" )\n   iunreserved    = ALPHA / DIGIT / \"-\"
      / \".\" / \"_\" / \"~\" / ucschar\n   ucschar        = %xA0-D7FF / %xF900-FDCF
      / %xFDF0-FFEF\n                  / %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD\n
      \                 / %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD\n                  /
      %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD\n                  / %xA0000-AFFFD
      / %xB0000-BFFFD / %xC0000-CFFFD\n                  / %xD0000-DFFFD / %xE1000-EFFFD\n
      \  iprivate       = %xE000-F8FF / %xF0000-FFFFD / %x100000-10FFFD\n   Some productions
      are ambiguous.  The \"first-match-wins\" (a.k.a.\n   \"greedy\") algorithm applies.
      \ For details, see [RFC3986].\n   The following rules are the same as those
      in [RFC3986]:\n   scheme         = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" /
      \".\" )\n   port           = *DIGIT\n   IP-literal     = \"[\" ( IPv6address
      / IPvFuture  ) \"]\"\n   IPvFuture      = \"v\" 1*HEXDIG \".\" 1*( unreserved
      / sub-delims / \":\" )\n   IPv6address    =                            6( h16
      \":\" ) ls32\n                  /                       \"::\" 5( h16 \":\"
      ) ls32\n                  / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n
      \                 / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n                  /
      [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n                  / [ *3(
      h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n                  / [ *4( h16
      \":\" ) h16 ] \"::\"              ls32\n                  / [ *5( h16 \":\"
      ) h16 ] \"::\"              h16\n                  / [ *6( h16 \":\" ) h16 ]
      \"::\"\n   h16            = 1*4HEXDIG\n   ls32           = ( h16 \":\" h16 )
      / IPv4address\n   IPv4address    = dec-octet \".\" dec-octet \".\" dec-octet
      \".\" dec-octet\n   dec-octet      = DIGIT                 ; 0-9\n                  /
      %x31-39 DIGIT         ; 10-99\n                  / \"1\" 2DIGIT            ;
      100-199\n                  / \"2\" %x30-34 DIGIT     ; 200-249\n                  /
      \"25\" %x30-35          ; 250-255\n   pct-encoded    = \"%\" HEXDIG HEXDIG\n
      \  unreserved     = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   reserved
      \      = gen-delims / sub-delims\n   gen-delims     = \":\" / \"/\" / \"?\"
      / \"#\" / \"[\" / \"]\" / \"@\"\n   sub-delims     = \"!\" / \"$\" / \"&\" /
      \"'\" / \"(\" / \")\"\n                  / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n
      \  This syntax does not support IPv6 scoped addressing zone identifiers.\n"
    title: 2.2.  ABNF for IRI References and IRIs
  title: 2.  IRI Syntax
- contents:
  - "3.  Relationship between IRIs and URIs\n   IRIs are meant to replace URIs in
    identifying resources for\n   protocols, formats, and software components that
    use a UCS-based\n   character repertoire.  These protocols and components may
    never need\n   to use URIs directly, especially when the resource identifier is
    used\n   simply for identification purposes.  However, when the resource\n   identifier
    is used for resource retrieval, it is in many cases\n   necessary to determine
    the associated URI, because currently most\n   retrieval mechanisms are only defined
    for URIs.  In this case, IRIs\n   can serve as presentation elements for URI protocol
    elements.  An\n   example would be an address bar in a Web user agent.  (Additional\n
    \  rationale is given in section 3.1.)\n"
  - contents:
    - "3.1.  Mapping of IRIs to URIs\n   This section defines how to map an IRI to
      a URI.  Everything in this\n   section also applies to IRI references and URI
      references, as well as\n   to components thereof (for example, fragment identifiers).\n
      \  This mapping has two purposes:\n   Syntaxical. Many URI schemes and components
      define additional\n      syntactical restrictions not captured in section 2.2.\n
      \     Scheme-specific restrictions are applied to IRIs by converting\n      IRIs
      to URIs and checking the URIs against the scheme-specific\n      restrictions.\n
      \  Interpretational. URIs identify resources in various ways.  IRIs also\n      identify
      resources.  When the IRI is used solely for\n      identification purposes,
      it is not necessary to map the IRI to a\n      URI (see section 5).  However,
      when an IRI is used for resource\n      retrieval, the resource that the IRI
      locates is the same as the\n      one located by the URI obtained after converting
      the IRI according\n      to the procedure defined here.  This means that there
      is no need\n      to define resolution separately on the IRI level.\n   Applications
      MUST map IRIs to URIs by using the following two steps.\n   Step 1.  Generate
      a UCS character sequence from the original IRI\n            format.  This step
      has the following three variants,\n            depending on the form of the
      input:\n            a. If the IRI is written on paper, read aloud, or otherwise\n
      \              represented as a sequence of characters independent of\n               any
      character encoding, represent the IRI as a sequence\n               of characters
      from the UCS normalized according to\n               Normalization Form C (NFC,
      [UTR15]).\n            b. If the IRI is in some digital representation (e.g.,
      an\n               octet stream) in some known non-Unicode character\n               encoding,
      convert the IRI to a sequence of characters\n               from the UCS normalized
      according to NFC.\n            c. If the IRI is in a Unicode-based character
      encoding (for\n               example, UTF-8 or UTF-16), do not normalize (see
      section\n               5.3.2.2 for details).  Apply step 2 directly to the\n
      \              encoded Unicode character sequence.\n   Step 2.  For each character
      in 'ucschar' or 'iprivate', apply steps\n            2.1 through 2.3 below.\n
      \      2.1.  Convert the character to a sequence of one or more octets\n             using
      UTF-8 [RFC3629].\n       2.2.  Convert each octet to %HH, where HH is the hexadecimal\n
      \            notation of the octet value.  Note that this is identical\n             to
      the percent-encoding mechanism in section 2.1 of\n             [RFC3986].  To
      reduce variability, the hexadecimal notation\n             SHOULD use uppercase
      letters.\n       2.3.  Replace the original character with the resulting character\n
      \            sequence (i.e., a sequence of %HH triplets).\n   The above mapping
      from IRIs to URIs produces URIs fully conforming to\n   [RFC3986].  The mapping
      is also an identity transformation for URIs\n   and is idempotent;  applying
      the mapping a second time will not\n   change anything.  Every URI is by definition
      an IRI.\n   Systems accepting IRIs MAY convert the ireg-name component of an
      IRI\n   as follows (before step 2 above) for schemes known to use domain\n   names
      in ireg-name, if the scheme definition does not allow\n   percent-encoding for
      ireg-name:\n   Replace the ireg-name part of the IRI by the part converted using
      the\n   ToASCII operation specified in section 4.1 of [RFC3490] on each\n   dot-separated
      label, and by using U+002E (FULL STOP) as a label\n   separator, with the flag
      UseSTD3ASCIIRules set to TRUE, and with the\n   flag AllowUnassigned set to
      FALSE for creating IRIs and set to TRUE\n   otherwise.\n   The ToASCII operation
      may fail, but this would mean that the IRI\n   cannot be resolved.  This conversion
      SHOULD be used when the goal is\n   to maximize interoperability with legacy
      URI resolvers.  For example,\n   the IRI\n   \"http://r&#xE9;sum&#xE9;.example.org\"\n
      \  may be converted to\n   \"http://xn--rsum-bpad.example.org\"\n   instead
      of\n   \"http://r%C3%A9sum%C3%A9.example.org\".\n   An IRI with a scheme that
      is known to use domain names in ireg-name,\n   but where the scheme definition
      does not allow percent-encoding for\n   ireg-name, meets scheme-specific restrictions
      if either the\n   straightforward conversion or the conversion using the ToASCII\n
      \  operation on ireg-name result in an URI that meets the scheme-\n   specific
      restrictions.\n   Such an IRI resolves to the URI obtained after converting
      the IRI and\n   uses the ToASCII operation on ireg-name.  Implementations do
      not have\n   to do this conversion as long as they produce the same result.\n
      \  Note: The difference between variants b and c in step 1 (using\n      normalization
      with NFC, versus not using any normalization)\n      accounts for the fact that
      in many non-Unicode character\n      encodings, some text cannot be represented
      directly. For example,\n      the word \"Vietnam\" is natively written \"Vi&#x1EC7;t
      Nam\"\n      (containing a LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW)\n
      \     in NFC, but a direct transcoding from the windows-1258 character\n      encoding
      leads to \"Vi&#xEA;&#x323;t Nam\" (containing a LATIN SMALL\n      LETTER E
      WITH CIRCUMFLEX followed by a COMBINING DOT BELOW).\n      Direct transcoding
      of other 8-bit encodings of Vietnamese may lead\n      to other representations.\n
      \  Note: The uniform treatment of the whole IRI in step 2 is important\n      to
      make processing independent of URI scheme.  See [Gettys] for an\n      in-depth
      discussion.\n   Note: In practice, whether the general mapping (steps 1 and
      2) or the\n      ToASCII operation of [RFC3490] is used for ireg-name will not
      be\n      noticed if mapping from IRI to URI and resolution is tightly\n      integrated
      (e.g., carried out in the same user agent).  But\n      conversion using [RFC3490]
      may be able to better deal with\n      backwards compatibility issues in case
      mapping and resolution are\n      separated, as in the case of using an HTTP
      proxy.\n   Note: Internationalized Domain Names may be contained in parts of
      an\n      IRI other than the ireg-name part.  It is the responsibility of\n
      \     scheme-specific implementations (if the Internationalized Domain\n      Name
      is part of the scheme syntax) or of server-side\n      implementations (if the
      Internationalized Domain Name is part of\n      'iquery') to apply the necessary
      conversions at the appropriate\n      point.  Example: Trying to validate the
      Web page at\n      http://r&#xE9;sum&#xE9;.example.org would lead to an IRI
      of\n      http://validator.w3.org/check?uri=http%3A%2F%2Fr&#xE9;sum&#xE9;.\n
      \     example.org, which would convert to a URI of\n      http://validator.w3.org/check?uri=http%3A%2F%2Fr%C3%A9sum%C3%A9.\n
      \     example.org.  The server side implementation would be responsible\n      for
      making the necessary conversions to be able to retrieve the\n      Web page.\n
      \  Systems accepting IRIs MAY also deal with the printable characters in\n   US-ASCII
      that are not allowed in URIs, namely \"<\", \">\", '\"', space,\n   \"{\", \"}\",
      \"|\", \"\\\", \"^\", and \"`\", in step 2 above.  If these\n   characters are
      found but are not converted, then the conversion\n   SHOULD fail.  Please note
      that the number sign (\"#\"), the percent\n   sign (\"%\"), and the square bracket
      characters (\"[\", \"]\") are not part\n   of the above list and MUST NOT be
      converted.  Protocols and formats\n   that have used earlier definitions of
      IRIs including these characters\n   MAY require percent-encoding of these characters
      as a preprocessing\n   step to extract the actual IRI from a given field.  This\n
      \  preprocessing MAY also be used by applications allowing the user to\n   enter
      an IRI.\n   Note: In this process (in step 2.3), characters allowed in URI\n
      \     references and existing percent-encoded sequences are not encoded\n      further.
      \ (This mapping is similar to, but different from, the\n      encoding applied
      when arbitrary content is included in some part\n      of a URI.)  For example,
      an IRI of\n      \"http://www.example.org/red%09ros&#xE9;#red\" (in XML notation)
      is\n      converted to\n      \"http://www.example.org/red%09ros%C3%A9#red\",
      not to something\n      like\n      \"http%3A%2F%2Fwww.example.org%2Fred%2509ros%C3%A9%23red\".\n
      \  Note: Some older software transcoding to UTF-8 may produce illegal\n      output
      for some input, in particular for characters outside the\n      BMP (Basic Multilingual
      Plane).  As an example, for the IRI with\n      non-BMP characters (in XML Notation):\n
      \     \"http://example.com/&#x10300;&#x10301;&#x10302\";\n      which contains
      the first three letters of the Old Italic alphabet,\n      the correct conversion
      to a URI is\n      \"http://example.com/%F0%90%8C%80%F0%90%8C%81%F0%90%8C%82\"\n"
    title: 3.1.  Mapping of IRIs to URIs
  - contents:
    - "3.2.  Converting URIs to IRIs\n   In some situations, converting a URI into
      an equivalent IRI may be\n   desirable.  This section gives a procedure for
      this conversion.  The\n   conversion described in this section will always result
      in an IRI\n   that maps back to the URI used as an input for the conversion
      (except\n   for potential case differences in percent-encoding and for potential\n
      \  percent-encoded unreserved characters).  However, the IRI resulting\n   from
      this conversion may not be exactly the same as the original IRI\n   (if there
      ever was one).\n   URI-to-IRI conversion removes percent-encodings, but not
      all\n   percent-encodings can be eliminated.  There are several reasons for\n
      \  this:\n   1.  Some percent-encodings are necessary to distinguish percent-\n
      \      encoded and unencoded uses of reserved characters.\n   2.  Some percent-encodings
      cannot be interpreted as sequences of\n       UTF-8 octets.\n       (Note: The
      octet patterns of UTF-8 are highly regular.\n       Therefore, there is a very
      high probability, but no guarantee,\n       that percent-encodings that can
      be interpreted as sequences of\n       UTF-8 octets actually originated from
      UTF-8.  For a detailed\n       discussion, see [Duerst97].)\n   3.  The conversion
      may result in a character that is not appropriate\n       in an IRI.  See sections
      2.2, 4.1, and 6.1 for further details.\n   Conversion from a URI to an IRI is
      done by using the following steps\n   (or any other algorithm that produces
      the same result):\n   1.  Represent the URI as a sequence of octets in US-ASCII.\n
      \  2.  Convert all percent-encodings (\"%\" followed by two hexadecimal\n       digits)
      to the corresponding octets, except those corresponding\n       to \"%\", characters
      in \"reserved\", and characters in US-ASCII not\n       allowed in URIs.\n   3.
      \ Re-percent-encode any octet produced in step 2 that is not part\n       of
      a strictly legal UTF-8 octet sequence.\n   4. Re-percent-encode all octets produced
      in step 3 that in UTF-8\n      represent characters that are not appropriate
      according to\n      sections 2.2, 4.1, and 6.1.\n   5. Interpret the resulting
      octet sequence as a sequence of characters\n      encoded in UTF-8.\n   This
      procedure will convert as many percent-encoded characters as\n   possible to
      characters in an IRI.  Because there are some choices\n   when step 4 is applied
      (see section 6.1), results may vary.\n   Conversions from URIs to IRIs MUST
      NOT use any character encoding\n   other than UTF-8 in steps 3 and 4, even if
      it might be possible to\n   guess from the context that another character encoding
      than UTF-8 was\n   used in the URI.  For example, the URI\n   \"http://www.example.org/r%E9sum%E9.html\"
      might with some guessing be\n   interpreted to contain two e-acute characters
      encoded as iso-8859-1.\n   It must not be converted to an IRI containing these
      e-acute\n   characters.  Otherwise, in the future the IRI will be mapped to\n
      \  \"http://www.example.org/r%C3%A9sum%C3%A9.html\", which is a different\n
      \  URI from \"http://www.example.org/r%E9sum%E9.html\".\n"
    - contents:
      - "3.2.1.  Examples\n   This section shows various examples of converting URIs
        to IRIs.  Each\n   example shows the result after each of the steps 1 through
        5 is\n   applied.  XML Notation is used for the final result.  Octets are\n
        \  denoted by \"<\" followed by two hexadecimal digits followed by \">\".\n
        \  The following example contains the sequence \"%C3%BC\", which is a\n   strictly
        legal UTF-8 sequence, and which is converted into the actual\n   character
        U+00FC, LATIN SMALL LETTER U WITH DIAERESIS (also known as\n   u-umlaut).\n
        \  1.  http://www.example.org/D%C3%BCrst\n   2.  http://www.example.org/D<c3><bc>rst\n
        \  3.  http://www.example.org/D<c3><bc>rst\n   4.  http://www.example.org/D<c3><bc>rst\n
        \  5.  http://www.example.org/D&#xFC;rst\n   The following example contains
        the sequence \"%FC\", which might\n   represent U+00FC, LATIN SMALL LETTER
        U WITH DIAERESIS, in the\n   iso-8859-1 character encoding.  (It might represent
        other characters\n   in other character encodings.  For example, the octet
        <fc> in\n   iso-8859-5 represents U+045C, CYRILLIC SMALL LETTER KJE.)  Because\n
        \  <fc> is not part of a strictly legal UTF-8 sequence, it is\n   re-percent-encoded
        in step 3.\n   1.  http://www.example.org/D%FCrst\n   2.  http://www.example.org/D<fc>rst\n
        \  3.  http://www.example.org/D%FCrst\n   4.  http://www.example.org/D%FCrst\n
        \  5.  http://www.example.org/D%FCrst\n   The following example contains \"%e2%80%ae\",
        which is the percent-\n   encoded UTF-8 character encoding of U+202E, RIGHT-TO-LEFT
        OVERRIDE.\n   Section 4.1 forbids the direct use of this character in an IRI.\n
        \  Therefore, the corresponding octets are re-percent-encoded in step 4.\n
        \  This example shows that the case (upper- or lowercase) of letters\n   used
        in percent-encodings may not be preserved.  The example also\n   contains
        a punycode-encoded domain name label (xn--99zt52a), which is\n   not converted.\n
        \  1.  http://xn--99zt52a.example.org/%e2%80%ae\n   2.  http://xn--99zt52a.example.org/<e2><80><ae>\n
        \  3.  http://xn--99zt52a.example.org/<e2><80><ae>\n   4.  http://xn--99zt52a.example.org/%E2%80%AE\n
        \  5.  http://xn--99zt52a.example.org/%E2%80%AE\n   Implementations with scheme-specific
        knowledge MAY convert\n   punycode-encoded domain name labels to the corresponding
        characters\n   by using the ToUnicode procedure.  Thus, for the example above,
        the\n   label \"xn--99zt52a\" may be converted to U+7D0D U+8C46 (Japanese\n
        \  Natto), leading to the overall IRI of\n   \"http://&#x7D0D;&#x8C46;.example.org/%E2%80%AE\".\n"
      title: 3.2.1.  Examples
    title: 3.2.  Converting URIs to IRIs
  title: 3.  Relationship between IRIs and URIs
- contents:
  - "4.  Bidirectional IRIs for Right-to-Left Languages\n   Some UCS characters, such
    as those used in the Arabic and Hebrew\n   scripts, have an inherent right-to-left
    (rtl) writing direction.\n   IRIs containing these characters (called bidirectional
    IRIs or Bidi\n   IRIs) require additional attention because of the non-trivial\n
    \  relation between logical representation (used for digital\n   representation
    and for reading/spelling) and visual representation\n   (used for display/printing).\n
    \  Because of the complex interaction between the logical\n   representation,
    the visual representation, and the syntax of a Bidi\n   IRI, a balance is needed
    between various requirements.  The main\n   requirements are\n   1.  user-predictable
    conversion between visual and logical\n       representation;\n   2.  the ability
    to include a wide range of characters in various\n       parts of the IRI; and\n
    \  3.  minor or no changes or restrictions for implementations.\n"
  - contents:
    - "4.1.  Logical Storage and Visual Presentation\n   When stored or transmitted
      in digital representation, bidirectional\n   IRIs MUST be in full logical order
      and MUST conform to the IRI syntax\n   rules (which includes the rules relevant
      to their scheme). This\n   ensures that bidirectional IRIs can be processed
      in the same way as\n   other IRIs.\n   Bidirectional IRIs MUST be rendered by
      using the Unicode\n   Bidirectional Algorithm [UNIV4], [UNI9].  Bidirectional
      IRIs MUST be\n   rendered in the same way as they would be if they were in a\n
      \  left-to-right embedding; i.e., as if they were preceded by U+202A,\n   LEFT-TO-RIGHT
      EMBEDDING (LRE), and followed by U+202C, POP\n   DIRECTIONAL FORMATTING (PDF).
      \ Setting the embedding direction can\n   also be done in a higher-level protocol
      (e.g., the dir='ltr'\n   attribute in HTML).\n   There is no requirement to
      use the above embedding if the display is\n   still the same without the embedding.
      \ For example, a bidirectional\n   IRI in a text with left-to-right base directionality
      (such as used\n   for English or Cyrillic) that is preceded and followed by
      whitespace\n   and  strong left-to-right characters does not need an embedding.\n
      \  Also, a bidirectional relative IRI reference that only contains\n   strong
      right-to-left characters and weak characters and that starts\n   and ends with
      a strong right-to-left character and appears in a text\n   with right-to-left
      base directionality (such as used for Arabic or\n   Hebrew) and is preceded
      and followed by whitespace and strong\n   characters does not need an embedding.\n
      \  In some other cases, using U+200E, LEFT-TO-RIGHT MARK (LRM), may be\n   sufficient
      to force the correct display behavior.  However, the\n   details of the Unicode
      Bidirectional algorithm are not always easy to\n   understand.  Implementers
      are strongly advised to err on the side of\n   caution and to use embedding
      in all cases where they are not\n   completely sure that the display behavior
      is unaffected without the\n   embedding.\n   The Unicode Bidirectional Algorithm
      ([UNI9], section 4.3) permits\n   higher-level protocols to influence bidirectional
      rendering.  Such\n   changes by higher-level protocols MUST NOT be used if they
      change the\n   rendering of IRIs.\n   The bidirectional formatting characters
      that may be used before or\n   after the IRI to ensure correct display are not
      themselves part of\n   the IRI.  IRIs MUST NOT contain bidirectional formatting
      characters\n   (LRM, RLM, LRE, RLE, LRO, RLO, and PDF).  They affect the visual\n
      \  rendering of the IRI but do not appear themselves.  It would\n   therefore
      not be possible to input an IRI with such characters\n   correctly.\n"
    title: 4.1.  Logical Storage and Visual Presentation
  - contents:
    - "4.2.  Bidi IRI Structure\n   The Unicode Bidirectional Algorithm is designed
      mainly for running\n   text.  To make sure that it does not affect the rendering
      of\n   bidirectional IRIs too much, some restrictions on bidirectional IRIs\n
      \  are necessary.  These restrictions are given in terms of delimiters\n   (structural
      characters, mostly punctuation such as \"@\", \".\", \":\", and\n   \"/\") and
      components (usually consisting mostly of letters and\n   digits).\n   The following
      syntax rules from section 2.2 correspond to components\n   for the purpose of
      Bidi behavior: iuserinfo, ireg-name, isegment,\n   isegment-nz, isegment-nz-nc,
      ireg-name, iquery, and ifragment.\n   Specifications that define the syntax
      of any of the above components\n   MAY divide them further and define smaller
      parts to be components\n   according to this document.  As an example, the restrictions
      of\n   [RFC3490] on bidirectional domain names correspond to treating each\n
      \  label of a domain name as a component for schemes with ireg-name as a\n   domain
      name.  Even where the components are not defined formally, it\n   may be helpful
      to think about some syntax in terms of components and\n   to apply the relevant
      restrictions.  For example, for the usual\n   name/value syntax in query parts,
      it is convenient to treat each name\n   and each value as a component.  As another
      example, the extensions in\n   a resource name can be treated as separate components.\n
      \  For each component, the following restrictions apply:\n   1.  A component
      SHOULD NOT use both right-to-left and left-to-right\n       characters.\n   2.
      \ A component using right-to-left characters SHOULD start and end\n       with
      right-to-left characters.\n   The above restrictions are given as shoulds, rather
      than as musts.\n   For IRIs that are never presented visually, they are not
      relevant.\n   However, for IRIs in general, they are very important to ensure\n
      \  consistent conversion between visual presentation and logical\n   representation,
      in both directions.\n   Note: In some components, the above restrictions may
      actually be\n      strictly enforced.  For example, [RFC3490] requires that
      these\n      restrictions apply to the labels of a host name for those schemes\n
      \     where ireg-name is a host name.  In some other components (for\n      example,
      path components) following these restrictions may not be\n      too difficult.
      \ For other components, such as parts of the query\n      part, it may be very
      difficult to enforce the restrictions because\n      the values of query parameters
      may be arbitrary character\n      sequences.\n   If the above restrictions cannot
      be satisfied otherwise, the affected\n   component can always be mapped to URI
      notation as described in\n   section 3.1.  Please note that the whole component
      has to be mapped\n   (see also Example 9 below).\n"
    title: 4.2.  Bidi IRI Structure
  - contents:
    - "4.3.  Input of Bidi IRIs\n   Bidi input methods MUST generate Bidi IRIs in
      logical order while\n   rendering them according to section 4.1.  During input,
      rendering\n   SHOULD be updated after every new character is input to avoid
      end-\n   user confusion.\n"
    title: 4.3.  Input of Bidi IRIs
  - contents:
    - "4.4.  Examples\n   This section gives examples of bidirectional IRIs, in Bidi
      Notation.\n   It shows legal IRIs with the relationship between logical and
      visual\n   representation and explains how certain phenomena in this\n   relationship
      may look strange to somebody not familiar with\n   bidirectional behavior, but
      familiar to users of Arabic and Hebrew.\n   It also shows what happens if the
      restrictions given in section 4.2\n   are not followed.  The examples below
      can be seen at [BidiEx], in\n   Arabic, Hebrew, and Bidi Notation variants.\n
      \  To read the bidi text in the examples, read the visual representation\n   from
      left to right until you encounter a block of rtl text.  Read the\n   rtl block
      (including slashes and other special characters) from right\n   to left, then
      continue at the next unread ltr character.\n   Example 1: A single component
      with rtl characters is inverted:\n   Logical representation: \"http://ab.CDEFGH.ij/kl/mn/op.html\"\n
      \  Visual representation: \"http://ab.HGFEDC.ij/kl/mn/op.html\"\n   Components
      can be read one by one, and each component can be read in\n   its natural direction.\n
      \  Example 2: More than one consecutive component with rtl characters is\n   inverted
      as a whole:\n   Logical representation: \"http://ab.CDE.FGH/ij/kl/mn/op.html\"\n
      \  Visual representation: \"http://ab.HGF.EDC/ij/kl/mn/op.html\"\n   A sequence
      of rtl components is read rtl, in the same way as a\n   sequence of rtl words
      is read rtl in a bidi text.\n   Example 3: All components of an IRI (except
      for the scheme) are rtl.\n   All rtl components are inverted overall:\n   Logical
      representation: \"http://AB.CD.EF/GH/IJ/KL?MN=OP;QR=ST#UV\"\n   Visual representation:
      \"http://VU#TS=RQ;PO=NM?LK/JI/HG/FE.DC.BA\"\n   The whole IRI (except the scheme)
      is read rtl.  Delimiters between\n   rtl components stay between the respective
      components; delimiters\n   between ltr and rtl components don't move.\n   Example
      4: Each of several sequences of rtl components is inverted on\n   its own:\n
      \  Logical representation: \"http://AB.CD.ef/gh/IJ/KL.html\"\n   Visual representation:
      \"http://DC.BA.ef/gh/LK/JI.html\"\n   Each sequence of rtl components is read
      rtl, in the same way as each\n   sequence of rtl words in an ltr text is read
      rtl.\n   Example 5: Example 2, applied to components of different kinds:\n   Logical
      representation: \"http://ab.cd.EF/GH/ij/kl.html\"\n   Visual representation:
      \"http://ab.cd.HG/FE/ij/kl.html\"\n   The inversion of the domain name label
      and the path component may be\n   unexpected, but it is consistent with other
      bidi behavior.  For\n   reassurance that the domain component really is \"ab.cd.EF\",
      it may be\n   helpful to read aloud the visual representation following the
      bidi\n   algorithm.  After \"http://ab.cd.\" one reads the RTL block\n   \"E-F-slash-G-H\",
      which corresponds to the logical representation.\n   Example 6: Same as Example
      5, with more rtl components:\n   Logical representation: \"http://ab.CD.EF/GH/IJ/kl.html\"\n
      \  Visual representation: \"http://ab.JI/HG/FE.DC/kl.html\"\n   The inversion
      of the domain name labels and the path components may\n   be easier to identify
      because the delimiters also move.\n   Example 7: A single rtl component includes
      digits:\n   Logical representation: \"http://ab.CDE123FGH.ij/kl/mn/op.html\"\n
      \  Visual representation: \"http://ab.HGF123EDC.ij/kl/mn/op.html\"\n   Numbers
      are written ltr in all cases but are treated as an additional\n   embedding
      inside a run of rtl characters.  This is completely\n   consistent with usual
      bidirectional text.\n   Example 8 (not allowed): Numbers are at the start or
      end of an rtl\n   component:\n   Logical representation: \"http://ab.cd.ef/GH1/2IJ/KL.html\"\n
      \  Visual representation: \"http://ab.cd.ef/LK/JI1/2HG.html\"\n   The sequence
      \"1/2\" is interpreted by the bidi algorithm as a\n   fraction, fragmenting
      the components and leading to confusion.  There\n   are other characters that
      are interpreted in a special way close to\n   numbers; in particular, \"+\",
      \"-\", \"#\", \"$\", \"%\", \",\", \".\", and \":\".\n   Example 9 (not allowed):
      The numbers in the previous example are\n   percent-encoded:\n   Logical representation:
      \"http://ab.cd.ef/GH%31/%32IJ/KL.html\",\n   Visual representation (Hebrew):
      \"http://ab.cd.ef/%31HG/LK/JI%32.html\"\n   Visual representation (Arabic):
      \"http://ab.cd.ef/31%HG/%LK/JI32.html\"\n   Depending on whether the uppercase
      letters represent Arabic or\n   Hebrew, the visual representation is different.\n
      \  Example 10 (allowed but not recommended):\n   Logical representation: \"http://ab.CDEFGH.123/kl/mn/op.html\"\n
      \  Visual representation: \"http://ab.123.HGFEDC/kl/mn/op.html\"\n   Components
      consisting of only numbers are allowed (it would be rather\n   difficult to
      prohibit them), but these may interact with adjacent RTL\n   components in ways
      that are not easy to predict.\n"
    title: 4.4.  Examples
  title: 4.  Bidirectional IRIs for Right-to-Left Languages
- contents:
  - "5.  Normalization and Comparison\n      Note: The structure and much of the material
    for this section is\n      taken from section 6 of [RFC3986]; the differences
    are due to the\n      specifics of IRIs.\n   One of the most common operations
    on IRIs is simple comparison:\n   Determining whether two IRIs are equivalent
    without using the IRIs or\n   the mapped URIs to access their respective resource(s).
    \ A comparison\n   is performed whenever a response cache is accessed, a browser
    checks\n   its history to color a link, or an XML parser processes tags within
    a\n   namespace.  Extensive normalization prior to comparison of IRIs may\n   be
    used by spiders and indexing engines to prune a search space or\n   reduce duplication
    of request actions and response storage.\n   IRI comparison is performed for some
    particular purpose.  Protocols\n   or implementations that compare IRIs for different
    purposes will\n   often be subject to differing design trade-offs in regards to
    how\n   much effort should be spent in reducing aliased identifiers.  This\n   section
    describes various methods that may be used to compare IRIs,\n   the trade-offs
    between them, and the types of applications that might\n   use them.\n"
  - contents:
    - "5.1.  Equivalence\n   Because IRIs exist to identify resources, presumably
      they should be\n   considered equivalent when they identify the same resource.
      \ However,\n   this definition of equivalence is not of much practical use,
      as there\n   is no way for an implementation to compare two resources unless
      it\n   has full knowledge or control of them. For this reason, determination\n
      \  of equivalence or difference of IRIs is based on string comparison,\n   perhaps
      augmented by reference to additional rules provided by URI\n   scheme definitions.
      \ We use the terms \"different\" and \"equivalent\" to\n   describe the possible
      outcomes of such comparisons, but there are\n   many application-dependent versions
      of equivalence.\n   Even though it is possible to determine that two IRIs are
      equivalent,\n   IRI comparison is not sufficient to determine whether two IRIs\n
      \  identify different resources.  For example, an owner of two different\n   domain
      names could decide to serve the same resource from both,\n   resulting in two
      different IRIs.  Therefore, comparison methods are\n   designed to minimize
      false negatives while strictly avoiding false\n   positives.\n   In testing
      for equivalence, applications should not directly compare\n   relative references;
      the references should be converted to their\n   respective target IRIs before
      comparison.  When IRIs are compared to\n   select (or avoid) a network action,
      such as retrieval of a\n   representation, fragment components (if any) should
      be excluded from\n   the comparison.\n   Applications using IRIs as identity
      tokens with no relationship to a\n   protocol MUST use the Simple String Comparison
      (see section 5.3.1).\n   All other applications MUST select one of the comparison
      practices\n   from the Comparison Ladder (see section 5.3 or, after IRI-to-URI\n
      \  conversion, select one of the comparison practices from the URI\n   comparison
      ladder in [RFC3986], section 6.2)\n"
    title: 5.1.  Equivalence
  - contents:
    - "5.2.  Preparation for Comparison\n   Any kind of IRI comparison REQUIRES that
      all escapings or encodings\n   in the protocol or format that carries an IRI
      are resolved.  This is\n   usually done when the protocol or format is parsed.
      \ Examples of such\n   escapings or encodings are entities and numeric character
      references\n   in [HTML4] and [XML1].  As an example,\n   \"http://example.org/ros&eacute;\"
      (in HTML),\n   \"http://example.org/ros&#233\"; (in HTML or XML), and\n   \"http://example.org/ros&#xE9\";
      (in HTML or XML) are all resolved into\n   what is denoted in this document
      (see section 1.4) as\n   \"http://example.org/ros&#xE9\"; (the \"&#xE9;\" here
      standing for the\n   actual e-acute character, to compensate for the fact that
      this\n   document cannot contain non-ASCII characters).\n   Similar considerations
      apply to encodings such as Transfer Codings in\n   HTTP (see [RFC2616]) and
      Content Transfer Encodings in MIME\n   ([RFC2045]), although in these cases,
      the encoding is based not on\n   characters but on octets, and additional care
      is required to make\n   sure that characters, and not just arbitrary octets,
      are compared\n   (see section 5.3.1).\n"
    title: 5.2.  Preparation for Comparison
  - contents:
    - "5.3.  Comparison Ladder\n   In practice, a variety of methods are used, to
      test IRI equivalence.\n   These methods fall into a range distinguished by the
      amount of\n   processing required and the degree to which the probability of
      false\n   negatives is reduced.  As noted above, false negatives cannot be\n
      \  eliminated.  In practice, their probability can be reduced, but this\n   reduction
      requires more processing and is not cost-effective for all\n   applications.\n
      \  If this range of comparison practices is considered as a ladder, the\n   following
      discussion will climb the ladder, starting with practices\n   that are cheap
      but have a relatively higher chance of producing false\n   negatives, and proceeding
      to those that have higher computational\n   cost and lower risk of false negatives.\n"
    - contents:
      - "5.3.1.  Simple String Comparison\n   If two IRIs, when considered as character
        strings, are identical,\n   then it is safe to conclude that they are equivalent.
        \ This type of\n   equivalence test has very low computational cost and is
        in wide use\n   in a variety of applications, particularly in the domain of
        parsing.\n   It is also used when a definitive answer to the question of IRI\n
        \  equivalence is needed that is independent of the scheme used and that\n
        \  can be calculated quickly and without accessing a network.  An\n   example
        of such a case is XML Namespaces ([XMLNamespace]).\n   Testing strings for
        equivalence requires some basic precautions. This\n   procedure is often referred
        to as \"bit-for-bit\" or \"byte-for-byte\"\n   comparison, which is potentially
        misleading.  Testing strings for\n   equality is normally based on pair comparison
        of the characters that\n   make up the strings, starting from the first and
        proceeding until\n   both strings are exhausted and all characters are found
        to be equal,\n   until a pair of characters compares unequal, or until one
        of the\n   strings is exhausted before the other.\n   This character comparison
        requires that each pair of characters be\n   put in comparable encoding form.
        \ For example, should one IRI be\n   stored in a byte array in UTF-8 encoding
        form and the second in a\n   UTF-16 encoding form, bit-for-bit comparisons
        applied naively will\n   produce errors.  It is better to speak of equality
        on a\n   character-for-character rather than on a byte-for-byte or bit-for-bit\n
        \  basis.  In practical terms, character-by-character comparisons should\n
        \  be done codepoint by codepoint after conversion to a common character\n
        \  encoding form.  When comparing character by character, the comparison\n
        \  function MUST NOT map IRIs to URIs, because such a mapping would\n   create
        additional spurious equivalences.  It follows that an IRI\n   SHOULD NOT be
        modified when being transported if there is any chance\n   that this IRI might
        be used as an identifier.\n   False negatives are caused by the production
        and use of IRI aliases.\n   Unnecessary aliases can be reduced, regardless
        of the comparison\n   method, by consistently providing IRI references in
        an already\n   normalized form (i.e., a form identical to what would be produced\n
        \  after normalization is applied, as described below). Protocols and\n   data
        formats often limit some IRI comparisons to simple string\n   comparison,
        based on the theory that people and implementations will,\n   in their own
        best interest, be consistent in providing IRI\n   references, or at least
        be consistent enough to negate any efficiency\n   that might be obtained from
        further normalization.\n"
      title: 5.3.1.  Simple String Comparison
    - contents:
      - "5.3.2.  Syntax-Based Normalization\n   Implementations may use logic based
        on the definitions provided by\n   this specification to reduce the probability
        of false negatives. This\n   processing is moderately higher in cost than
        character-for-character\n   string comparison.  For example, an application
        using this approach\n   could reasonably consider the following two IRIs equivalent:\n
        \     example://a/b/c/%7Bfoo%7D/ros&#xE9;\n      eXAMPLE://a/./b/../b/%63/%7bfoo%7d/ros%C3%A9\n
        \  Web user agents, such as browsers, typically apply this type of IRI\n   normalization
        when determining whether a cached response is\n   available.  Syntax-based
        normalization includes such techniques as\n   case normalization, character
        normalization, percent-encoding\n   normalization, and removal of dot-segments.\n"
      - contents:
        - "5.3.2.1.  Case Normalization\n   For all IRIs, the hexadecimal digits within
          a percent-encoding\n   triplet (e.g., \"%3a\" versus \"%3A\") are case-insensitive
          and therefore\n   should be normalized to use uppercase letters for the
          digits A - F.\n   When an IRI uses components of the generic syntax, the
          component\n   syntax equivalence rules always apply; namely, that the scheme
          and\n   US-ASCII only host are case insensitive and therefore should be\n
          \  normalized to lowercase.  For example, the URI\n   \"HTTP://www.EXAMPLE.com/\"
          is equivalent to \"http://www.example.com/\".\n   Case equivalence for non-ASCII
          characters in IRI components that are\n   IDNs are discussed in section
          5.3.3.  The other generic syntax\n   components are assumed to be case sensitive
          unless specifically\n   defined otherwise by the scheme.\n   Creating schemes
          that allow case-insensitive syntax components\n   containing non-ASCII characters
          should be avoided. Case normalization\n   of non-ASCII characters can be
          culturally dependent and is always a\n   complex operation.  The only exception
          concerns non-ASCII host names\n   for which the character normalization
          includes a mapping step derived\n   from case folding.\n"
        title: 5.3.2.1.  Case Normalization
      - contents:
        - "5.3.2.2.  Character Normalization\n   The Unicode Standard [UNIV4] defines
          various equivalences between\n   sequences of characters for various purposes.
          \ Unicode Standard Annex\n   #15 [UTR15] defines various Normalization Forms
          for these\n   equivalences, in particular Normalization Form C (NFC, Canonical\n
          \  Decomposition, followed by Canonical Composition) and Normalization\n
          \  Form KC (NFKC, Compatibility Decomposition, followed by Canonical\n   Composition).\n
          \  Equivalence of IRIs MUST rely on the assumption that IRIs are\n   appropriately
          pre-character-normalized rather than apply character\n   normalization when
          comparing two IRIs.  The exceptions are conversion\n   from a non-digital
          form, and conversion from a non-UCS-based\n   character encoding to a UCS-based
          character encoding. In these cases,\n   NFC or a normalizing transcoder
          using NFC MUST be used for\n   interoperability.  To avoid false negatives
          and problems with\n   transcoding, IRIs SHOULD be created by using NFC.
          \ Using NFKC may\n   avoid even more problems; for example, by choosing
          half-width Latin\n   letters instead of full-width ones, and full-width
          instead of\n   half-width Katakana.\n   As an example, \"http://www.example.org/r&#xE9;sum&#xE9;.html\"
          (in XML\n   Notation) is in NFC.  On the other hand,\n   \"http://www.example.org/re&#x301;sume&#x301;.html\"
          is not in NFC.\n   The former uses precombined e-acute characters, and the
          latter uses\n   \"e\" characters followed by combining acute accents.  Both
          usages are\n   defined as canonically equivalent in [UNIV4].\n   Note: Because
          it is unknown how a particular sequence of characters\n      is being treated
          with respect to character normalization, it would\n      be inappropriate
          to allow third parties to normalize an IRI\n      arbitrarily.  This does
          not contradict the recommendation that\n      when a resource is created,
          its IRI should be as character\n      normalized as possible (i.e., NFC
          or even NFKC).  This is similar\n      to the uppercase/lowercase problems.
          \ Some parts of a URI are case\n      insensitive (domain name).  For others,
          it is unclear whether they\n      are case sensitive, case insensitive,
          or something in between\n      (e.g., case sensitive, but with a multiple
          choice selection if the\n      wrong case is used, instead of a direct negative
          result).  The\n      best recipe is that the creator use a reasonable capitalization\n
          \     and, when transferring the URI, capitalization never be changed.\n
          \  Various IRI schemes may allow the usage of Internationalized Domain\n
          \  Names (IDN) [RFC3490] either in the ireg-name part or elsewhere.\n   Character
          Normalization also applies to IDNs, as discussed in section\n   5.3.3.\n"
        title: 5.3.2.2.  Character Normalization
      - contents:
        - "5.3.2.3.  Percent-Encoding Normalization\n   The percent-encoding mechanism
          (section 2.1 of [RFC3986]) is a\n   frequent source of variance among otherwise
          identical IRIs.  In\n   addition to the case normalization issue noted above,
          some IRI\n   producers percent-encode octets that do not require percent-encoding,\n
          \  resulting in IRIs that are equivalent to their non encoded\n   counterparts.
          \ These IRIs should be normalized by decoding any\n   percent-encoded octet
          sequence that corresponds to an unreserved\n   character, as described in
          section 2.3 of [RFC3986].\n   For actual resolution, differences in percent-encoding
          (except for\n   the percent-encoding of reserved characters) MUST always
          result in\n   the same resource.  For example, \"http://example.org/~user\",\n
          \  \"http://example.org/%7euser\", and \"http://example.org/%7Euser\", must\n
          \  resolve to the same resource.\n   If this kind of equivalence is to be
          tested, the percent-encoding of\n   both IRIs to be compared has to be aligned;
          for example, by\n   converting both IRIs to URIs (see section 3.1), eliminating
          escape\n   differences in the resulting URIs, and making sure that the case
          of\n   the hexadecimal characters in the percent-encoding is always the
          same\n   (preferably uppercase).  If the IRI is to be passed to another\n
          \  application or used further in some other way, its original form MUST\n
          \  be preserved.  The conversion described here should be performed only\n
          \  for local comparison.\n"
        title: 5.3.2.3.  Percent-Encoding Normalization
      - contents:
        - "5.3.2.4.  Path Segment Normalization\n   The complete path segments \".\"
          and \"..\" are intended only for use\n   within relative references (section
          4.1 of [RFC3986]) and are removed\n   as part of the reference resolution
          process (section 5.2 of\n   [RFC3986]).  However, some implementations may
          incorrectly assume\n   that reference resolution is not necessary when the
          reference is\n   already an IRI, and thus fail to remove dot-segments when
          they occur\n   in non-relative paths.  IRI normalizers should remove dot-segments
          by\n   applying the remove_dot_segments algorithm to the path, as described\n
          \  in section 5.2.4 of [RFC3986].\n"
        title: 5.3.2.4.  Path Segment Normalization
      title: 5.3.2.  Syntax-Based Normalization
    - contents:
      - "5.3.3.  Scheme-Based Normalization\n   The syntax and semantics of IRIs vary
        from scheme to scheme, as\n   described by the defining specification for
        each scheme.\n   Implementations may use scheme-specific rules, at further
        processing\n   cost, to reduce the probability of false negatives.  For example,\n
        \  because the \"http\" scheme makes use of an authority component, has a\n
        \  default port of \"80\", and defines an empty path to be equivalent to\n
        \  \"/\", the following four IRIs are equivalent:\n      http://example.com\n
        \     http://example.com/\n      http://example.com:/\n      http://example.com:80/\n
        \  In general, an IRI that uses the generic syntax for authority with an\n
        \  empty path should be normalized to a path of \"/\".  Likewise, an\n   explicit
        \":port\", for which the port is empty or the default for the\n   scheme,
        is equivalent to one where the port and its \":\" delimiter are\n   elided
        and thus should be removed by scheme-based normalization.  For\n   example,
        the second IRI above is the normal form for the \"http\"\n   scheme.\n   Another
        case where normalization varies by scheme is in the handling\n   of an empty
        authority component or empty host subcomponent.  For many\n   scheme specifications,
        an empty authority or host is considered an\n   error; for others, it is considered
        equivalent to \"localhost\" or the\n   end-user's host.  When a scheme defines
        a default for authority and\n   an IRI reference to that default is desired,
        the reference should be\n   normalized to an empty authority for the sake
        of uniformity, brevity,\n   and internationalization.  If, however, either
        the userinfo or port\n   subcomponents are non-empty, then the host should
        be given explicitly\n   even if it matches the default.\n   Normalization
        should not remove delimiters when their associated\n   component is empty
        unless it is licensed to do so by the scheme\n   specification.  For example,
        the IRI \"http://example.com/?\" cannot be\n   assumed to be equivalent to
        any of the examples above.  Likewise, the\n   presence or absence of delimiters
        within a userinfo subcomponent is\n   usually significant to its interpretation.
        \ The fragment component is\n   not subject to any scheme-based normalization;
        thus, two IRIs that\n   differ only by the suffix \"#\" are considered different
        regardless of\n   the scheme.\n   Some IRI schemes may allow the usage of
        Internationalized Domain\n   Names (IDN) [RFC3490] either in their ireg-name
        part or elsewhere.\n   When in use in IRIs, those names SHOULD be validated
        by using the\n   ToASCII operation defined in [RFC3490], with the flags\n
        \  \"UseSTD3ASCIIRules\" and \"AllowUnassigned\".  An IRI containing an\n
        \  invalid IDN cannot successfully be resolved.  Validated IDN\n   components
        of IRIs SHOULD be character normalized by using the\n   Nameprep process [RFC3491];
        however, for legibility purposes, they\n   SHOULD NOT be converted into ASCII
        Compatible Encoding (ACE).\n   Scheme-based normalization may also consider
        IDN components and their\n   conversions to punycode as equivalent.  As an
        example,\n   \"http://r&#xE9;sum&#xE9;.example.org\" may be considered equivalent
        to\n   \"http://xn--rsum-bpad.example.org\".\n   Other scheme-specific normalizations
        are possible.\n"
      title: 5.3.3.  Scheme-Based Normalization
    - contents:
      - "5.3.4.  Protocol-Based Normalization\n   Substantial effort to reduce the
        incidence of false negatives is\n   often cost-effective for web spiders.
        Consequently, they implement\n   even more aggressive techniques in IRI comparison.
        \ For example, if\n   they observe that an IRI such as\n      http://example.com/data\n
        \  redirects to an IRI differing only in the trailing slash\n      http://example.com/data/\n
        \  they will likely regard the two as equivalent in the future.  This\n   kind
        of technique is only appropriate when equivalence is clearly\n   indicated
        by both the result of accessing the resources and the\n   common conventions
        of their scheme's dereference algorithm (in this\n   case, use of redirection
        by HTTP origin servers to avoid problems\n   with relative references).\n"
      title: 5.3.4.  Protocol-Based Normalization
    title: 5.3.  Comparison Ladder
  title: 5.  Normalization and Comparison
- contents:
  - '6.  Use of IRIs

    '
  - contents:
    - "6.1.  Limitations on UCS Characters Allowed in IRIs\n   This section discusses
      limitations on characters and character\n   sequences usable for IRIs beyond
      those given in section 2.2 and\n   section 4.1.  The considerations in this
      section are relevant when\n   IRIs are created and when URIs are converted to
      IRIs.\n   a.  The repertoire of characters allowed in each IRI component is\n
      \      limited by the definition of that component.  For example, the\n       definition
      of the scheme component does not allow characters\n       beyond US-ASCII.\n
      \      (Note: In accordance with URI practice, generic IRI software\n       cannot
      and should not check for such limitations.)\n   b.  The UCS contains many areas
      of characters for which there are\n       strong visual look-alikes.  Because
      of the likelihood of\n       transcription errors, these also should be avoided.
      \ This\n       includes the full-width equivalents of Latin characters,\n       half-width
      Katakana characters for Japanese, and many others.  It\n       also includes
      many look-alikes of \"space\", \"delims\", and\n       \"unwise\", characters
      excluded in [RFC3491].\n   Additional information is available from [UNIXML].
      \ [UNIXML] is\n   written in the context of running text rather than in that
      of\n   identifiers.  Nevertheless, it discusses many of the categories of\n
      \  characters not appropriate for IRIs.\n"
    title: 6.1.  Limitations on UCS Characters Allowed in IRIs
  - contents:
    - "6.2.  Software Interfaces and Protocols\n   Although an IRI is defined as a
      sequence of characters, software\n   interfaces for URIs typically function
      on sequences of octets or\n   other kinds of code units.  Thus, software interfaces
      and protocols\n   MUST define which character encoding is used.\n   Intermediate
      software interfaces between IRI-capable components and\n   URI-only components
      MUST map the IRIs per section 3.1, when\n   transferring from IRI-capable to
      URI-only components.  This mapping\n   SHOULD be applied as late as possible.
      \ It SHOULD NOT be applied\n   between components that are known to be able
      to handle IRIs.\n"
    title: 6.2.  Software Interfaces and Protocols
  - contents:
    - "6.3.  Format of URIs and IRIs in Documents and Protocols\n   Document formats
      that transport URIs may have to be upgraded to allow\n   the transport of IRIs.
      \ In cases where the document as a whole has a\n   native character encoding,
      IRIs MUST also be encoded in this\n   character encoding and converted accordingly
      by a parser or\n   interpreter.  IRI characters not expressible in the native
      character\n   encoding SHOULD be escaped by using the escaping conventions of
      the\n   document format if such conventions are available. Alternatively,\n
      \  they MAY be percent-encoded according to section 3.1. For example, in\n   HTML
      or XML, numeric character references SHOULD be used.  If a\n   document as a
      whole has a native character encoding and that\n   character encoding is not
      UTF-8, then IRIs MUST NOT be placed into\n   the document in the UTF-8 character
      encoding.\n   Note: Some formats already accommodate IRIs, although they use\n
      \  different terminology.  HTML 4.0 [HTML4] defines the conversion from\n   IRIs
      to URIs as error-avoiding behavior.  XML 1.0 [XML1], XLink\n   [XLink], XML
      Schema [XMLSchema], and specifications based upon them\n   allow IRIs.  Also,
      it is expected that all relevant new W3C formats\n   and protocols will be required
      to handle IRIs [CharMod].\n"
    title: 6.3.  Format of URIs and IRIs in Documents and Protocols
  - contents:
    - "6.4.  Use of UTF-8 for Encoding Original Characters\n   This section discusses
      details and gives examples for point c) in\n   section 1.2.  To be able to use
      IRIs, the URI corresponding to the\n   IRI in question has to encode original
      characters into octets by\n   using UTF-8.  This can be specified for all URIs
      of a URI scheme or\n   can apply to individual URIs for schemes that do not
      specify how to\n   encode original characters.  It can apply to the whole URI,
      or only\n   to some part.  For background information on encoding characters
      into\n   URIs, see also section 2.5 of [RFC3986].\n   For new URI schemes, using
      UTF-8 is recommended in [RFC2718].\n   Examples where UTF-8 is already used
      are the URN syntax [RFC2141],\n   IMAP URLs [RFC2192], and POP URLs [RFC2384].
      \ On the other hand,\n   because the HTTP URL scheme does not specify how to
      encode original\n   characters, only some HTTP URLs can have corresponding but
      different\n   IRIs.\n   For example, for a document with a URI of\n   \"http://www.example.org/r%C3%A9sum%C3%A9.html\",
      it is possible to\n   construct a corresponding IRI (in XML notation, see, section
      1.4):\n   \"http://www.example.org/r&#xE9;sum&#xE9;.html\" (\"&#xE9\"; stands
      for\n   the e-acute character, and \"%C3%A9\" is the UTF-8 encoded and\n   percent-encoded
      representation of that character).  On the other\n   hand, for a document with
      a URI of\n   \"http://www.example.org/r%E9sum%E9.html\", the percent-encoding
      octets\n   cannot be converted to actual characters in an IRI, as the\n   percent-encoding
      is not based on UTF-8.\n   This means that for most URI schemes, there is no
      need to upgrade\n   their scheme definition in order for them to work with IRIs.
      \ The\n   main case where upgrading makes sense is when a scheme definition,
      or\n   a particular component of a scheme, is strictly limited to the use of\n
      \  US-ASCII characters with no provision to include non-ASCII\n   characters/octets
      via percent-encoding, or if a scheme definition\n   currently uses highly scheme-specific
      provisions for the encoding of\n   non-ASCII characters.  An example of this
      is the mailto: scheme\n   [RFC2368].\n   This specification does not upgrade
      any scheme specifications in any\n   way; this has to be done separately.  Also,
      note that there is no\n   such thing as an \"IRI scheme\"; all IRIs use URI
      schemes, and all URI\n   schemes can be used with IRIs, even though in some
      cases only by\n   using URIs directly as IRIs, without any conversion.\n   URI
      schemes can impose restrictions on the syntax of scheme-specific\n   URIs; i.e.,
      URIs that are admissible under the generic URI syntax\n   [RFC3986] may not
      be admissible due to narrower syntactic constraints\n   imposed by a URI scheme
      specification.  URI scheme definitions cannot\n   broaden the syntactic restrictions
      of the generic URI syntax;\n   otherwise, it would be possible to generate URIs
      that satisfied the\n   scheme-specific syntactic constraints without satisfying
      the\n   syntactic constraints of the generic URI syntax.  However, additional\n
      \  syntactic constraints imposed by URI scheme specifications are\n   applicable
      to IRI, as the corresponding URI resulting from the\n   mapping defined in section
      3.1 MUST be a valid URI under the\n   syntactic restrictions of generic URI
      syntax and any narrower\n   restrictions imposed by the corresponding URI scheme
      specification.\n   The requirement for the use of UTF-8 applies to all parts
      of a URI\n   (with the potential exception of the ireg-name part; see section\n
      \  3.1).  However, it is possible that the capability of IRIs to\n   represent
      a wide range of characters directly is used just in some\n   parts of the IRI
      (or IRI reference).  The other parts of the IRI may\n   only contain US-ASCII
      characters, or they may not be based on UTF-8.\n   They may be based on another
      character encoding, or they may directly\n   encode raw binary data (see also
      [RFC2397]).\n   For example, it is possible to have a URI reference of\n   \"http://www.example.org/r%E9sum%E9.xml#r%C3%A9sum%C3%A9\",
      where the\n   document name is encoded in iso-8859-1 based on server settings,
      but\n   where the fragment identifier is encoded in UTF-8 according to\n   [XPointer].
      The IRI corresponding to the above URI would be (in XML\n   notation)\n   \"http://www.example.org/r%E9sum%E9.xml#r&#xE9;sum&#xE9\";.\n
      \  Similar considerations apply to query parts.  The functionality of\n   IRIs
      (namely, to be able to include non-ASCII characters) can only be\n   used if
      the query part is encoded in UTF-8.\n"
    title: 6.4.  Use of UTF-8 for Encoding Original Characters
  - contents:
    - "6.5.  Relative IRI References\n   Processing of relative IRI references against
      a base is handled\n   straightforwardly; the algorithms of [RFC3986] can be
      applied\n   directly, treating the characters additionally allowed in IRI\n
      \  references in the same way that unreserved characters are in URI\n   references.\n"
    title: 6.5.  Relative IRI References
  title: 6.  Use of IRIs
- contents:
  - "7.  URI/IRI Processing Guidelines (Informative)\n   This informative section
    provides guidelines for supporting IRIs in\n   the same software components and
    operations that currently process\n   URIs: Software interfaces that handle URIs,
    software that allows\n   users to enter URIs, software that creates or generates
    URIs,\n   software that displays URIs, formats and protocols that transport\n
    \  URIs, and software that interprets URIs.  These may all require\n   modification
    before functioning properly with IRIs.  The\n   considerations in this section
    also apply to URI references and IRI\n   references.\n"
  - contents:
    - "7.1.  URI/IRI Software Interfaces\n   Software interfaces that handle URIs,
      such as URI-handling APIs and\n   protocols transferring URIs, need interfaces
      and protocol elements\n   that are designed to carry IRIs.\n   In case the current
      handling in an API or protocol is based on\n   US-ASCII, UTF-8 is recommended
      as the character encoding for IRIs, as\n   it is compatible with US-ASCII, is
      in accordance with the\n   recommendations of [RFC2277], and makes converting
      to URIs easy.  In\n   any case, the API or protocol definition must clearly
      define the\n   character encoding to be used.\n   The transfer from URI-only
      to IRI-capable components requires no\n   mapping, although the conversion described
      in section 3.2 above may\n   be performed.  It is preferable not to perform
      this inverse\n   conversion when there is a chance that this cannot be done
      correctly.\n"
    title: 7.1.  URI/IRI Software Interfaces
  - contents:
    - "7.2.  URI/IRI Entry\n   Some components allow users to enter URIs into the
      system by typing\n   or dictation, for example.  This software must be updated
      to allow\n   for IRI entry.\n   A person viewing a visual representation of
      an IRI (as a sequence of\n   glyphs, in some order, in some visual display)
      or hearing an IRI will\n   use an entry method for characters in the user's
      language to input\n   the IRI.  Depending on the script and the input method
      used, this may\n   be a more or less complicated process.\n   The process of
      IRI entry must ensure, as much as possible, that the\n   restrictions defined
      in section 2.2 are met.  This may be done by\n   choosing appropriate input
      methods or variants/settings thereof, by\n   appropriately converting the characters
      being input, by eliminating\n   characters that cannot be converted, and/or
      by issuing a warning or\n   error message to the user.\n   As an example of
      variant settings, input method editors for East\n   Asian Languages usually
      allow the input of Latin letters and related\n   characters in full-width or
      half-width versions.  For IRI input, the\n   input method editor should be set
      so that it produces half-width\n   Latin letters and punctuation and full-width
      Katakana.\n   An input field primarily or solely used for the input of URIs/IRIs\n
      \  may allow the user to view an IRI as it is mapped to a URI.  Places\n   where
      the input of IRIs is frequent may provide the possibility for\n   viewing an
      IRI as mapped to a URI.  This will help users when some of\n   the software
      they use does not yet accept IRIs.\n   An IRI input component interfacing to
      components that handle URIs,\n   but not IRIs, must map the IRI to a URI before
      passing it to these\n   components.\n   For the input of IRIs with right-to-left
      characters, please see\n   section 4.3.\n"
    title: 7.2.  URI/IRI Entry
  - contents:
    - "7.3.  URI/IRI Transfer between Applications\n   Many applications, particularly
      mail user agents, try to detect URIs\n   appearing in plain text.  For this,
      they use some heuristics based on\n   URI syntax.  They then allow the user
      to click on such URIs and\n   retrieve the corresponding resource in an appropriate
      (usually\n   scheme-dependent) application.\n   Such applications have to be
      upgraded to use the IRI syntax as a base\n   for heuristics.  In particular,
      a non-ASCII character should not be\n   taken as the indication of the end of
      an IRI.  Such applications also\n   have to make sure that they correctly convert
      the detected IRI from\n   the character encoding of the document or application
      where the IRI\n   appears to the character encoding used by the system-wide
      IRI\n   invocation mechanism, or to a URI (according to section 3.1) if the\n
      \  system-wide invocation mechanism only accepts URIs.\n   The clipboard is
      another frequently used way to transfer URIs and\n   IRIs from one application
      to another.  On most platforms, the\n   clipboard is able to store and transfer
      text in many languages and\n   scripts.  Correctly used, the clipboard transfers
      characters, not\n   bytes, which will do the right thing with IRIs.\n"
    title: 7.3.  URI/IRI Transfer between Applications
  - contents:
    - "7.4.  URI/IRI Generation\n   Systems that offer resources through the Internet,
      where those\n   resources have logical names, sometimes automatically generate
      URIs\n   for the resources they offer.  For example, some HTTP servers can\n
      \  generate a directory listing for a file directory and then respond to\n   the
      generated URIs with the files.\n   Many legacy character encodings are in use
      in various file systems.\n   Many currently deployed systems do not transform
      the local character\n   representation of the underlying system before generating
      URIs.\n   For maximum interoperability, systems that generate resource\n   identifiers
      should make the appropriate transformations.  For\n   example, if a file system
      contains a file named\n   \"r&#xE9;sum&#xE9;.html\", a server should expose
      this as\n   \"r%C3%A9sum%C3%A9.html\" in a URI, which allows use of\n   \"r&#xE9;sum&#xE9;.html\"
      in an IRI, even if locally the file name is\n   kept in a character encoding
      other than UTF-8.\n   This recommendation particularly applies to HTTP servers.
      \ For FTP\n   servers, similar considerations apply; see [RFC2640].\n"
    title: 7.4.  URI/IRI Generation
  - contents:
    - "7.5.  URI/IRI Selection\n   In some cases, resource owners and publishers have
      control over the\n   IRIs used to identify their resources.  This control is
      mostly\n   executed by controlling the resource names, such as file names,\n
      \  directly.\n   In these cases, it is recommended to avoid choosing IRIs that
      are\n   easily confused.  For example, for US-ASCII, the lower-case ell (\"l\")\n
      \  is easily confused with the digit one (\"1\"), and the upper-case oh\n   (\"O\")
      is easily confused with the digit zero (\"0\").  Publishers\n   should avoid
      confusing users with \"br0ken\" or \"1ame\" identifiers.\n   Outside the US-ASCII
      repertoire, there are many more opportunities\n   for confusion; a complete
      set of guidelines is too lengthy to include\n   here.  As long as names are
      limited to characters from a single\n   script, native writers of a given script
      or language will know best\n   when ambiguities can appear, and how they can
      be avoided.  What may\n   look ambiguous to a stranger may be completely obvious
      to the average\n   native user.  On the other hand, in some cases, the UCS contains\n
      \  variants for compatibility reasons; for example, for typographic\n   purposes.
      \ These should be avoided wherever possible.  Although there\n   may be exceptions,
      newly created resource names should generally be\n   in NFKC [UTR15] (which
      means that they are also in NFC).\n   As an example, the UCS contains the \"fi\"
      ligature at U+FB01 for\n   compatibility reasons.  Wherever possible, IRIs should
      use the two\n   letters \"f\" and \"i\" rather than the \"fi\" ligature.  An
      example where\n   the latter may be used is in the query part of an IRI for
      an explicit\n   search for a word written containing the \"fi\" ligature.\n
      \  In certain cases, there is a chance that characters from different\n   scripts
      look the same.  The best known example is the similarity of\n   the Latin \"A\",
      the Greek \"Alpha\", and the Cyrillic \"A\".  To avoid\n   such cases, only
      IRIs should be created where all the characters in a\n   single component are
      used together in a given language.  This usually\n   means that all of these
      characters will be from the same script, but\n   there are languages that mix
      characters from different scripts (such\n   as Japanese).  This is similar to
      the heuristics used to distinguish\n   between letters and numbers in the examples
      above.  Also, for Latin,\n   Greek, and Cyrillic, using lowercase letters results
      in fewer\n   ambiguities than using uppercase letters would.\n"
    title: 7.5.  URI/IRI Selection
  - contents:
    - "7.6.  Display of URIs/IRIs\n   In situations where the rendering software is
      not expected to display\n   non-ASCII parts of the IRI correctly using the available
      layout and\n   font resources, these parts should be percent-encoded before
      being\n   displayed.\n   For display of Bidi IRIs, please see section 4.1.\n"
    title: 7.6.  Display of URIs/IRIs
  - contents:
    - "7.7.  Interpretation of URIs and IRIs\n   Software that interprets IRIs as
      the names of local resources should\n   accept IRIs in multiple forms and convert
      and match them with the\n   appropriate local resource names.\n   First, multiple
      representations include both IRIs in the native\n   character encoding of the
      protocol and also their URI counterparts.\n   Second, it may include URIs constructed
      based on character encodings\n   other than UTF-8.  These URIs may be produced
      by user agents that do\n   not conform to this specification and that use legacy
      character\n   encodings to convert non-ASCII characters to URIs.  Whether this
      is\n   necessary, and what character encodings to cover, depends on a number\n
      \  of factors, such as the legacy character encodings used locally and\n   the
      distribution of various versions of user agents.  For example,\n   software
      for Japanese may accept URIs in Shift_JIS and/or EUC-JP in\n   addition to UTF-8.\n
      \  Third, it may include additional mappings to be more user-friendly\n   and
      robust against transmission errors.  These would be similar to\n   how some
      servers currently treat URIs as case insensitive or perform\n   additional matching
      to account for spelling errors.  For characters\n   beyond the US-ASCII repertoire,
      this may, for example, include\n   ignoring the accents on received IRIs or
      resource names.  Please note\n   that such mappings, including case mappings,
      are language dependent.\n   It can be difficult to identify a resource unambiguously
      if too many\n   mappings are taken into consideration.  However, percent-encoded
      and\n   not percent-encoded parts of IRIs can always be clearly\n   distinguished.
      \ Also, the regularity of UTF-8 (see [Duerst97]) makes\n   the potential for
      collisions lower than it may seem at first.\n"
    title: 7.7.  Interpretation of URIs and IRIs
  - contents:
    - "7.8.  Upgrading Strategy\n   Where this recommendation places further constraints
      on software for\n   which many instances are already deployed, it is important
      to\n   introduce upgrades carefully and to be aware of the various\n   interdependencies.\n
      \  If IRIs cannot be interpreted correctly, they should not be created,\n   generated,
      or transported.  This suggests that upgrading URI\n   interpreting software
      to accept IRIs should have highest priority.\n   On the other hand, a single
      IRI is interpreted only by a single or\n   very few interpreters that are known
      in advance, although it may be\n   entered and transported very widely.\n   Therefore,
      IRIs benefit most from a broad upgrade of software to be\n   able to enter and
      transport IRIs.  However, before an individual IRI\n   is published, care should
      be taken to upgrade the corresponding\n   interpreting software in order to
      cover the forms expected to be\n   received by various versions of entry and
      transport software.\n   The upgrade of generating software to generate IRIs
      instead of using\n   a local character encoding should happen only after the
      service is\n   upgraded to accept IRIs.  Similarly, IRIs should only be generated\n
      \  when the service accepts IRIs and the intervening infrastructure and\n   protocol
      is known to transport them safely.\n   Software converting from URIs to IRIs
      for display should be upgraded\n   only after upgraded entry software has been
      widely deployed to the\n   population that will see the displayed result.\n
      \  Where there is a free choice of character encodings, it is often\n   possible
      to reduce the effort and dependencies for upgrading to IRIs\n   by using UTF-8
      rather than another encoding.  For example, when a new\n   file-based Web server
      is set up, using UTF-8 as the character\n   encoding for file names will make
      the transition to IRIs easier.\n   Likewise, when a new Web form is set up using
      UTF-8 as the character\n   encoding of the form page, the returned query URIs
      will use UTF-8 as\n   the character encoding (unless the user, for whatever
      reason, changes\n   the character encoding) and will therefore be compatible
      with IRIs.\n   These recommendations, when taken together, will allow for the\n
      \  extension from URIs to IRIs in order to handle characters other than\n   US-ASCII
      while minimizing interoperability problems.  For\n   considerations regarding
      the upgrade of URI scheme definitions, see\n   section 6.4.\n"
    title: 7.8.  Upgrading Strategy
  title: 7.  URI/IRI Processing Guidelines (Informative)
- contents:
  - "8.  Security Considerations\n   The security considerations discussed in [RFC3986]
    also apply to\n   IRIs.  In addition, the following issues require particular
    care for\n   IRIs.\n   Incorrect encoding or decoding can lead to security problems.
    \ In\n   particular, some UTF-8 decoders do not check against overlong byte\n
    \  sequences.  As an example, a \"/\" is encoded with the byte 0x2F both\n   in
    UTF-8 and in US-ASCII, but some UTF-8 decoders also wrongly\n   interpret the
    sequence 0xC0 0xAF as a \"/\".  A sequence such as\n   \"%C0%AF..\" may pass some
    security tests and then be interpreted as\n   \"/..\" in a path if UTF-8 decoders
    are fault-tolerant, if conversion\n   and checking are not done in the right order,
    and/or if reserved\n   characters and unreserved characters are not clearly distinguished.\n
    \  There are various ways in which \"spoofing\" can occur with IRIs.\n   \"Spoofing\"
    means that somebody may add a resource name that looks the\n   same or similar
    to the user, but that points to a different resource.\n   The added resource may
    pretend to be the real resource by looking\n   very similar but may contain all
    kinds of changes that may be\n   difficult to spot and that can cause all kinds
    of problems.  Most\n   spoofing possibilities for IRIs are extensions of those
    for URIs.\n   Spoofing can occur for various reasons.  First, a user's\n   normalization
    expectations or actual normalization when entering an\n   IRI or transcoding an
    IRI from a legacy character encoding do not\n   match the normalization used on
    the server side.  Conceptually, this\n   is no different from the problems surrounding
    the use of\n   case-insensitive web servers.  For example, a popular web page
    with a\n   mixed-case name (\"http://big.example.com/PopularPage.html\") might
    be\n   \"spoofed\" by someone who is able to create\n   \"http://big.example.com/popularpage.html\".
    \ However, the use of\n   unnormalized character sequences, and of additional
    mappings for user\n   convenience, may increase the chance for spoofing.  Protocols
    and\n   servers that allow the creation of resources with names that are not\n
    \  normalized are particularly vulnerable to such attacks.  This is an\n   inherent
    security problem of the relevant protocol, server, or\n   resource and is not
    specific to IRIs, but it is mentioned here for\n   completeness.\n   Spoofing
    can occur in various IRI components, such as the domain name\n   part or a path
    part.  For considerations specific to the domain name\n   part, see [RFC3491].
    \ For the path part, administrators of sites that\n   allow independent users
    to create resources in the same sub area may\n   have to be careful to check for
    spoofing.\n   Spoofing can occur because in the UCS many characters look very\n
    \  similar.  Details are discussed in Section 7.5.  Again, this is very\n   similar
    to spoofing possibilities on US-ASCII, e.g., using \"br0ken\"\n   or \"1ame\"
    URIs.\n   Spoofing can occur when URIs with percent-encodings based on various\n
    \  character encodings are accepted to deal with older user agents.  In\n   some
    cases, particularly for Latin-based resource names, this is\n   usually easy to
    detect because UTF-8-encoded names, when interpreted\n   and viewed as legacy
    character encodings, produce mostly garbage.\n   When concurrently used character
    encodings have a similar structure\n   but there are no characters that have exactly
    the same encoding,\n   detection is more difficult.\n   Spoofing can occur with
    bidirectional IRIs, if the restrictions in\n   section 4.2 are not followed.  The
    same visual representation may be\n   interpreted as different logical representations,
    and vice versa.  It\n   is also very important that a correct Unicode bidirectional\n
    \  implementation be used.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  Acknowledgements\n   We would like to thank Larry Masinter for his work as
    coauthor of\n   many earlier versions of this document (draft-masinter-url-i18n-xx).\n
    \  The discussion on the issue addressed here started a long time ago.\n   There
    was a thread in the HTML working group in August 1995 (under\n   the topic of
    \"Globalizing URIs\") and in the www-international mailing\n   list in July 1996
    (under the topic of \"Internationalization and\n   URLs\"), and there were ad-hoc
    meetings at the Unicode conferences in\n   September 1995 and September 1997.\n
    \  Many thanks go to Francois Yergeau, Matitiahu Allouche, Roy Fielding,\n   Tim
    Berners-Lee, Mark Davis, M.T. Carrasco Benitez, James Clark, Tim\n   Bray, Chris
    Wendt, Yaron Goland, Andrea Vine, Misha Wolf, Leslie\n   Daigle, Ted Hardie, Bill
    Fenner, Margaret Wasserman, Russ Housley,\n   Makoto MURATA, Steven Atkin, Ryan
    Stansifer, Tex Texin, Graham Klyne,\n   Bjoern Hoehrmann, Chris Lilley, Ian Jacobs,
    Adam Costello, Dan\n   Oscarson, Elliotte Rusty Harold, Mike J. Brown, Roy Badami,
    Jonathan\n   Rosenne, Asmus Freytag, Simon Josefsson, Carlos Viegas Damasio, Chris\n
    \  Haynes, Walter Underwood, and many others for help with understanding\n   the
    issues and possible solutions, and with getting the details\n   right.\n   This
    document is a product of the Internationalization Working Group\n   (I18N WG)
    of the World Wide Web Consortium (W3C).  Thanks to the\n   members of the W3C
    I18N Working Group and Interest Group for their\n   contributions and their work
    on [CharMod].  Thanks also go to the\n   members of many other W3C Working Groups
    for adopting IRIs, and to\n   the members of the Montreal IAB Workshop on Internationalization
    and\n   Localization for their review.\n"
  title: 9.  Acknowledgements
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [ASCII]        American National Standards
      Institute, \"Coded\n                  Character Set -- 7-bit American Standard
      Code for\n                  Information Interchange\", ANSI X3.4, 1986.\n   [ISO10646]
      \    International Organization for Standardization,\n                  \"ISO/IEC
      10646:2003: Information Technology -\n                  Universal Multiple-Octet
      Coded Character Set (UCS)\",\n                  ISO Standard 10646, December
      2003.\n   [RFC2119]      Bradner, S., \"Key words for use in RFCs to Indicate\n
      \                 Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2234]
      \     Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n                  Specifications:
      ABNF\", RFC 2234, November 1997.\n   [RFC3490]      Faltstrom, P., Hoffman,
      P., and A. Costello,\n                  \"Internationalizing Domain Names in
      Applications\n                  (IDNA)\", RFC 3490, March 2003.\n   [RFC3491]
      \     Hoffman, P. and M. Blanchet, \"Nameprep: A Stringprep\n                  Profile
      for Internationalized Domain Names (IDN)\", RFC\n                  3491, March
      2003.\n   [RFC3629]      Yergeau, F., \"UTF-8, a transformation format of ISO\n
      \                 10646\", STD 63, RFC 3629, November 2003.\n   [RFC3986]      Berners-Lee,
      T., Fielding, R., and L. Masinter,\n                  \"Uniform Resource Identifier
      (URI): Generic Syntax\",\n                  STD 66, RFC 3986, January 2005.\n
      \  [UNI9]         Davis, M., \"The Bidirectional Algorithm\", Unicode\n                  Standard
      Annex #9, March 2004,\n                  <http://www.unicode.org/reports/tr9/tr9-13.html>.\n
      \  [UNIV4]        The Unicode Consortium, \"The Unicode Standard, Version\n
      \                 4.0.1, defined by: The Unicode Standard, Version 4.0\n                  (Reading,
      MA, Addison-Wesley, 2003. ISBN\n                  0-321-18578-1), as amended
      by Unicode 4.0.1\n                  (http://www.unicode.org/versions/Unicode4.0.1/)\",\n
      \                 March 2004.\n   [UTR15]        Davis, M. and M. Duerst, \"Unicode
      Normalization\n                  Forms\", Unicode Standard Annex #15, April
      2003,\n                  <http://www.unicode.org/unicode/reports/\n                  tr15/tr15-23.html>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [BidiEx]       \"Examples of bidirectional
      IRIs\",\n                  <http://www.w3.org/International/iri-edit/\n                  BidiExamples>.\n
      \  [CharMod]      Duerst, M., Yergeau, F., Ishida, R., Wolf, M., and T.\n                  Texin,
      \"Character Model for the World Wide Web:\n                  Resource Identifiers\",
      World Wide Web Consortium\n                  Candidate Recommendation, November
      2004,\n                  <http://www.w3.org/TR/charmod-resid>.\n   [Duerst97]
      \    Duerst, M., \"The Properties and Promises of UTF-8\",\n                  Proc.
      \ 11th International Unicode Conference, San Jose\n                  , September
      1997,\n                  <http://www.ifi.unizh.ch/mml/mduerst/papers/\n                  PDF/IUC11-UTF-8.pdf>.\n
      \  [Gettys]       Gettys, J., \"URI Model Consequences\",\n                  <http://www.w3.org/DesignIssues/ModelConsequences>.\n
      \  [HTML4]        Raggett, D., Le Hors, A., and I. Jacobs, \"HTML 4.01\n                  Specification\",
      World Wide Web Consortium\n                  Recommendation, December 1999,\n
      \                 <http://www.w3.org/TR/html401/appendix/\n                  notes.html#h-B.2>.\n
      \  [RFC2045]      Freed, N. and N. Borenstein, \"Multipurpose Internet\n                  Mail
      Extensions (MIME) Part One: Format of Internet\n                  Message Bodies\",
      RFC 2045, November 1996.\n   [RFC2130]      Weider, C., Preston, C., Simonsen,
      K., Alvestrand, H.,\n                  Atkinson, R., Crispin, M., and P. Svanberg,
      \"The\n                  Report of the IAB Character Set Workshop held 29\n
      \                 February - 1 March, 1996\", RFC 2130, April 1997.\n   [RFC2141]
      \     Moats, R., \"URN Syntax\", RFC 2141, May 1997.\n   [RFC2192]      Newman,
      C., \"IMAP URL Scheme\", RFC 2192, September\n                  1997.\n   [RFC2277]
      \     Alvestrand, H., \"IETF Policy on Character Sets and\n                  Languages\",
      BCP 18, RFC 2277, January 1998.\n   [RFC2368]      Hoffman, P., Masinter, L.,
      and J. Zawinski, \"The\n                  mailto URL scheme\", RFC 2368, July
      1998.\n   [RFC2384]      Gellens, R., \"POP URL Scheme\", RFC 2384, August 1998.\n
      \  [RFC2396]      Berners-Lee, T., Fielding, R., and L. Masinter,\n                  \"Uniform
      Resource Identifiers (URI): Generic Syntax\",\n                  RFC 2396, August
      1998.\n   [RFC2397]      Masinter, L., \"The \"data\" URL scheme\", RFC 2397,\n
      \                 August 1998.\n   [RFC2616]      Fielding,  R., Gettys, J.,
      Mogul, J., Frystyk, H.,\n                  Masinter, L., Leach, P., and T. Berners-Lee,\n
      \                 \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616,\n                  June
      1999.\n   [RFC2640]      Curtin, B., \"Internationalization of the File Transfer\n
      \                 Protocol\", RFC 2640, July 1999.\n   [RFC2718]      Masinter,
      L., Alvestrand, H., Zigmond, D., and R.\n                  Petke, \"Guidelines
      for new URL Schemes\", RFC 2718,\n                  November 1999.\n   [UNIXML]
      \      Duerst, M. and A. Freytag, \"Unicode in XML and other\n                  Markup
      Languages\", Unicode Technical Report #20, World\n                  Wide Web
      Consortium Note, June 2003,\n                  <http://www.w3.org/TR/unicode-xml/>.\n
      \  [XLink]        DeRose, S., Maler, E., and D. Orchard, \"XML Linking\n                  Language
      (XLink) Version 1.0\", World Wide Web\n                  Consortium Recommendation,
      June 2001,\n                  <http://www.w3.org/TR/xlink/#link-locators>.\n
      \  [XML1]         Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,\n                  and
      F. Yergeau, \"Extensible Markup Language (XML) 1.0\n                  (Third
      Edition)\", World Wide Web Consortium\n                  Recommendation, February
      2004,\n                  <http://www.w3.org/TR/REC-xml#sec-external-ent>.\n
      \  [XMLNamespace] Bray, T., Hollander, D., and A. Layman, \"Namespaces in\n
      \                 XML\", World Wide Web Consortium Recommendation,\n                  January
      1999, <http://www.w3.org/TR/REC-xml-names>.\n   [XMLSchema]    Biron, P. and
      A. Malhotra, \"XML Schema Part 2:\n                  Datatypes\", World Wide
      Web Consortium Recommendation,\n                  May 2001, <http://www.w3.org/TR/xmlschema-2/#anyURI>.\n
      \  [XPointer]     Grosso, P., Maler, E., Marsh, J. and N. Walsh,\n                  \"XPointer
      Framework\", World Wide Web Consortium\n                  Recommendation, March
      2003,\n                  <http://www.w3.org/TR/xptr-framework/#escaping>.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Design Alternatives\n   This section shortly summarizes major design
    alternatives and the\n   reasons for why they were not chosen.\n"
  title: Appendix A.  Design Alternatives
- contents:
  - "Appendix A.1.  New Scheme(s)\n   Introducing new schemes (for example, httpi:,
    ftpi:,...) or a new\n   metascheme (e.g., i:, leading to URI/IRI prefixes such
    as i:http:,\n   i:ftp:,...) was proposed to make IRI-to-URI conversion scheme\n
    \  dependent or to distinguish between percent-encodings resulting from\n   IRI-to-URI
    conversion and percent-encodings from legacy character\n   encodings.\n   New
    schemes are not needed to distinguish URIs from true IRIs (i.e.,\n   IRIs that
    contain non-ASCII characters).  The benefit of being able\n   to detect the origin
    of percent-encodings is marginal, as UTF-8 can\n   be detected with very high
    reliability.  Deploying new schemes is\n   extremely hard, so not requiring new
    schemes for IRIs makes\n   deployment of IRIs vastly easier.  Making conversion
    scheme dependent\n   is highly inadvisable and would be encouraged by separate
    schemes for\n   IRIs.  Using a uniform convention for conversion from IRIs to
    URIs\n   makes IRI implementation orthogonal to the introduction of actual new\n
    \  schemes.\n"
  title: Appendix A.1.  New Scheme(s)
- contents:
  - "Appendix A.2.  Character Encodings Other Than UTF-8\n   At an early stage, UTF-7
    was considered as an alternative to UTF-8\n   when IRIs are converted to URIs.
    \ UTF-7 would not have needed\n   percent-encoding and in most cases would have
    been shorter than\n   percent-encoded UTF-8.\n   Using UTF-8 avoids a double layering
    and overloading of the use of\n   the \"+\" character.  UTF-8 is fully compatible
    with US-ASCII and has\n   therefore been recommended by the IETF, and is being
    used widely.\n   UTF-7 has never been used much and is now clearly being discouraged.\n
    \  Requiring implementations to convert from UTF-8 to UTF-7 and back\n   would
    be an additional implementation burden.\n"
  title: Appendix A.2.  Character Encodings Other Than UTF-8
- contents:
  - "Appendix A.3.  New Encoding Convention\n   Instead of using the existing percent-encoding
    convention of URIs,\n   which is based on octets, the idea was to create a new
    encoding\n   convention; for example, to use \"%u\" to introduce UCS code points.\n
    \  Using the existing octet-based percent-encoding mechanism does not\n   need
    an upgrade of the URI syntax and does not need corresponding\n   server upgrades.\n"
  title: Appendix A.3.  New Encoding Convention
- contents:
  - "Appendix A.4.  Indicating Character Encodings in the URI/IRI\n   Some proposals
    suggested indicating the character encodings used in\n   an URI or IRI with some
    new syntactic convention in the URI itself,\n   similar to the \"charset\" parameter
    for e-mails and Web pages.  As an\n   example, the label in square brackets in\n
    \  \"http://www.example.org/ros[iso-8859-1]&#xE9\"; indicated that the\n   following
    \"&#xE9\"; had to be interpreted as iso-8859-1.\n   If UTF-8 is used exclusively,
    an upgrade to the URI syntax is not\n   needed.  It avoids potentially multiple
    labels that have to be copied\n   correctly in all cases, even on the side of
    a bus or on a napkin,\n   leading to usability problems (and being prohibitively
    annoying).\n   Exclusively using UTF-8 also reduces transcoding errors and\n   confusion.\n"
  title: Appendix A.4.  Indicating Character Encodings in the URI/IRI
- contents:
  - "Authors' Addresses\n   Martin Duerst  (Note: Please write \"Duerst\" with u-umlaut
    wherever\n                  possible, for example as \"D&#252;rst\" in XML and\n
    \                 HTML.)\n   World Wide Web Consortium\n   5322 Endo\n   Fujisawa,
    Kanagawa  252-8520\n   Japan\n   Phone: +81 466 49 1170\n   Fax:   +81 466 49
    1171\n   EMail: duerst@w3.org\n   URI:   http://www.w3.org/People/D%C3%BCrst/\n
    \  (Note: This is the percent-encoded form of an IRI.)\n   Michel Suignard\n   Microsoft
    Corporation\n   One Microsoft Way\n   Redmond, WA  98052\n   U.S.A.\n   Phone:
    +1 425 882-8080\n   EMail: michelsu@microsoft.com\n   URI:   http://www.suignard.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the IETF's procedures with respect
    to rights in IETF Documents can\n   be found in BCP 78 and BCP 79.\n   Copies
    of IPR disclosures made to the IETF Secretariat and any\n   assurances of licenses
    to be made available, or the result of an\n   attempt made to obtain a general
    license or permission for the use of\n   such proprietary rights by implementers
    or users of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
