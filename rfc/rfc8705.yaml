- title: __initial_text__
  contents:
  - "    OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound\n      \
    \                       Access Tokens\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes OAuth client authentication and certificate-\n\
    \   bound access and refresh tokens using mutual Transport Layer Security\n  \
    \ (TLS) authentication with X.509 certificates.  OAuth clients are\n   provided\
    \ a mechanism for authentication to the authorization server\n   using mutual\
    \ TLS, based on either self-signed certificates or public\n   key infrastructure\
    \ (PKI).  OAuth authorization servers are provided a\n   mechanism for binding\
    \ access tokens to a client's mutual-TLS\n   certificate, and OAuth protected\
    \ resources are provided a method for\n   ensuring that such an access token presented\
    \ to it was issued to the\n   client presenting the token.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8705.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n     1.1.  Requirements Notation and\
    \ Conventions\n     1.2.  Terminology\n   2.  Mutual TLS for OAuth Client Authentication\n\
    \     2.1.  PKI Mutual-TLS Method\n       2.1.1.  PKI Method Metadata Value\n\
    \       2.1.2.  Client Registration Metadata\n     2.2.  Self-Signed Certificate\
    \ Mutual-TLS Method\n       2.2.1.  Self-Signed Method Metadata Value\n      \
    \ 2.2.2.  Client Registration Metadata\n   3.  Mutual-TLS Client Certificate-Bound\
    \ Access Tokens\n     3.1.  JWT Certificate Thumbprint Confirmation Method\n \
    \    3.2.  Confirmation Method for Token Introspection\n     3.3.  Authorization\
    \ Server Metadata\n     3.4.  Client Registration Metadata\n   4.  Public Clients\
    \ and Certificate-Bound Tokens\n   5.  Metadata for Mutual-TLS Endpoint Aliases\n\
    \   6.  Implementation Considerations\n     6.1.  Authorization Server\n     6.2.\
    \  Resource Server\n     6.3.  Certificate Expiration and Bound Access Tokens\n\
    \     6.4.  Implicit Grant Unsupported\n     6.5.  TLS Termination\n   7.  Security\
    \ Considerations\n     7.1.  Certificate-Bound Refresh Tokens\n     7.2.  Certificate\
    \ Thumbprint Binding\n     7.3.  TLS Versions and Best Practices\n     7.4.  X.509\
    \ Certificate Spoofing\n     7.5.  X.509 Certificate Parsing and Validation Complexity\n\
    \   8.  Privacy Considerations\n   9.  IANA Considerations\n     9.1.  JWT Confirmation\
    \ Methods Registration\n     9.2.  Authorization Server Metadata Registration\n\
    \     9.3.  Token Endpoint Authentication Method Registration\n     9.4.  Token\
    \ Introspection Response Registration\n     9.5.  Dynamic Client Registration\
    \ Metadata Registration\n   10. References\n     10.1.  Normative References\n\
    \     10.2.  Informative References\n   Appendix A.  Example \"cnf\" Claim, Certificate,\
    \ and JWK\n   Appendix B.  Relationship to Token Binding\n   Acknowledgements\n\
    \   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The OAuth 2.0 Authorization Framework [RFC6749] enables\
    \ third-party\n   client applications to obtain delegated access to protected\n\
    \   resources.  In the prototypical abstract OAuth flow, illustrated in\n   Figure\
    \ 1, the client obtains an access token from an entity known as\n   an authorization\
    \ server and then uses that token when accessing\n   protected resources, such\
    \ as HTTPS APIs.\n     |        |<--(A)-- Get an access token --->| Authorization\
    \ |\n     |        |\n     | Client |                           Validate the\n\
    \     |        |\n     |        |<--(B)-- Use the access token -->|   Protected\
    \   |\n                 Figure 1: Abstract OAuth 2.0 Protocol Flow\n   The flow\
    \ illustrated in Figure 1 includes the following steps:\n   (A)  The client makes\
    \ an HTTPS \"POST\" request to the authorization\n        server and presents\
    \ a credential representing the authorization\n        grant.  For certain types\
    \ of clients (those that have been\n        issued or otherwise established a\
    \ set of client credentials) the\n        request must be authenticated.  In the\
    \ response, the\n        authorization server issues an access token to the client.\n\
    \   (B)  The client includes the access token when making a request to\n     \
    \   access a protected resource.\n   (C)  The protected resource validates the\
    \ access token in order to\n        authorize the request.  In some cases, such\
    \ as when the token is\n        self-contained and cryptographically secured,\
    \ the validation can\n        be done locally by the protected resource.  Other\
    \ cases require\n        that the protected resource call out to the authorization\
    \ server\n        to determine the state of the token and obtain metainformation\n\
    \        about it.\n   Layering on the abstract flow above, this document standardizes\n\
    \   enhanced security options for OAuth 2.0 utilizing client-certificate-\n  \
    \ based mutual TLS.  Section 2 provides options for authenticating the\n   request\
    \ in Step (A).  Step (C) is supported with semantics to express\n   the binding\
    \ of the token to the client certificate for both local and\n   remote processing\
    \ in Sections 3.1 and 3.2, respectively.  This\n   ensures that, as described\
    \ in Section 3, protected resource access in\n   Step (B) is only possible by\
    \ the legitimate client using a\n   certificate-bound token and holding the private\
    \ key corresponding to\n   the certificate.\n   OAuth 2.0 defines a shared-secret\
    \ method of client authentication but\n   also allows for defining and using additional\
    \ client authentication\n   mechanisms when interacting directly with the authorization\
    \ server.\n   This document describes an additional mechanism of client\n   authentication\
    \ utilizing mutual-TLS certificate-based authentication\n   that provides better\
    \ security characteristics than shared secrets.\n   While [RFC6749] documents\
    \ client authentication for requests to the\n   token endpoint, extensions to\
    \ OAuth 2.0 (such as Introspection\n   [RFC7662], Revocation [RFC7009], and the\
    \ Backchannel Authentication\n   Endpoint in [OpenID.CIBA]) define endpoints that\
    \ also utilize client\n   authentication, and the mutual-TLS methods defined herein\
    \ are\n   applicable to those endpoints as well.\n   Mutual-TLS certificate-bound\
    \ access tokens ensure that only the party\n   in possession of the private key\
    \ corresponding to the certificate can\n   utilize the token to access the associated\
    \ resources.  Such a\n   constraint is sometimes referred to as key confirmation,\
    \ proof-of-\n   possession, or holder-of-key and is unlike the case of the bearer\n\
    \   token described in [RFC6750], where any party in possession of the\n   access\
    \ token can use it to access the associated resources.  Binding\n   an access\
    \ token to the client's certificate prevents the use of\n   stolen access tokens\
    \ or replay of access tokens by unauthorized\n   parties.\n   Mutual-TLS certificate-bound\
    \ access tokens and mutual-TLS client\n   authentication are distinct mechanisms\
    \ that are complementary but\n   don't necessarily need to be deployed or used\
    \ together.\n   Additional client metadata parameters are introduced by this document\n\
    \   in support of certificate-bound access tokens and mutual-TLS client\n   authentication.\
    \  The authorization server can obtain client metadata\n   via the Dynamic Client\
    \ Registration Protocol [RFC7591], which defines\n   mechanisms for dynamically\
    \ registering OAuth 2.0 client metadata with\n   authorization servers.  Also\
    \ the metadata defined by [RFC7591], and\n   registered extensions to it, imply\
    \ a general data model for clients\n   that is useful for authorization server\
    \ implementations, even when\n   the Dynamic Client Registration Protocol isn't\
    \ in play.  Such\n   implementations will typically have some sort of user interface\n\
    \   available for managing client configuration.\n"
- title: 1.1.  Requirements Notation and Conventions
  contents:
  - "1.1.  Requirements Notation and Conventions\n   The key words \"MUST\", \"MUST\
    \ NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\"\
    , \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this\
    \ document are to be interpreted as described in\n   BCP 14 [RFC2119] [RFC8174]\
    \ when, and only when, they appear in all\n   capitals, as shown here.\n"
- title: 1.2.  Terminology
  contents:
  - "1.2.  Terminology\n   Throughout this document the term \"mutual TLS\" refers\
    \ to the process\n   whereby, in addition to the normal TLS server authentication\
    \ with a\n   certificate, a client presents its X.509 certificate and proves\n\
    \   possession of the corresponding private key to a server when\n   negotiating\
    \ a TLS session.  In contemporary versions of TLS [RFC5246]\n   [RFC8446], this\
    \ requires that the client send the Certificate and\n   CertificateVerify messages\
    \ during the handshake and for the server to\n   verify the CertificateVerify\
    \ and Finished messages.\n"
- title: 2.  Mutual TLS for OAuth Client Authentication
  contents:
  - "2.  Mutual TLS for OAuth Client Authentication\n   This section defines, as an\
    \ extension of Section 2.3 of OAuth 2.0\n   [RFC6749], two distinct methods of\
    \ using mutual-TLS X.509 client\n   certificates as client credentials.  The requirement\
    \ of mutual TLS\n   for client authentication is determined by the authorization\
    \ server,\n   based on policy or configuration for the given client (regardless\
    \ of\n   whether the client was dynamically registered, statically configured,\n\
    \   or otherwise established).\n   In order to utilize TLS for OAuth client authentication,\
    \ the TLS\n   connection between the client and the authorization server MUST\
    \ have\n   been established or re-established with mutual-TLS X.509 certificate\n\
    \   authentication (i.e., the client Certificate and CertificateVerify\n   messages\
    \ are sent during the TLS handshake).\n   For all requests to the authorization\
    \ server utilizing mutual-TLS\n   client authentication, the client MUST include\
    \ the \"client_id\"\n   parameter described in Section 2.2 of OAuth 2.0 [RFC6749].\
    \  The\n   presence of the \"client_id\" parameter enables the authorization\n\
    \   server to easily identify the client independently from the content\n   of\
    \ the certificate.  The authorization server can locate the client\n   configuration\
    \ using the client identifier and check the certificate\n   presented in the TLS\
    \ handshake against the expected credentials for\n   that client.  The authorization\
    \ server MUST enforce the binding\n   between client and certificate, as described\
    \ in either Section 2.1 or\n   2.2 below.  If no certificate is presented, or\
    \ that which is\n   presented doesn't match that which is expected for the given\n\
    \   \"client_id\", the authorization server returns a normal OAuth 2.0\n   error\
    \ response per Section 5.2 of [RFC6749] with the \"invalid_client\"\n   error\
    \ code to indicate failed client authentication.\n"
- title: 2.1.  PKI Mutual-TLS Method
  contents:
  - "2.1.  PKI Mutual-TLS Method\n   The PKI (public key infrastructure) method of\
    \ mutual-TLS OAuth client\n   authentication adheres to the way in which X.509\
    \ certificates are\n   traditionally used for authentication.  It relies on a\
    \ validated\n   certificate chain [RFC5280] and a single subject distinguished\
    \ name\n   (DN) or a single subject alternative name (SAN) to authenticate the\n\
    \   client.  Only one subject name value of any type is used for each\n   client.\
    \  The TLS handshake is utilized to validate the client's\n   possession of the\
    \ private key corresponding to the public key in the\n   certificate and to validate\
    \ the corresponding certificate chain.  The\n   client is successfully authenticated\
    \ if the subject information in\n   the certificate matches the single expected\
    \ subject configured or\n   registered for that particular client (note that a\
    \ predictable\n   treatment of DN values, such as the distinguishedNameMatch rule\
    \ from\n   [RFC4517], is needed in comparing the certificate's subject DN to the\n\
    \   client's registered DN).  Revocation checking is possible with the\n   PKI\
    \ method but if and how to check a certificate's revocation status\n   is a deployment\
    \ decision at the discretion of the authorization\n   server.  Clients can rotate\
    \ their X.509 certificates without the need\n   to modify the respective authentication\
    \ data at the authorization\n   server by obtaining a new certificate with the\
    \ same subject from a\n   trusted certificate authority (CA).\n"
- title: 2.1.1.  PKI Method Metadata Value
  contents:
  - "2.1.1.  PKI Method Metadata Value\n   For the PKI method of mutual-TLS client\
    \ authentication, this\n   specification defines and registers the following authentication\n\
    \   method metadata value into the \"OAuth Token Endpoint Authentication\n   Methods\"\
    \ registry [IANA.OAuth.Parameters].\n   tls_client_auth\n      Indicates that\
    \ client authentication to the authorization server\n      will occur with mutual\
    \ TLS utilizing the PKI method of associating\n      a certificate to a client.\n"
- title: 2.1.2.  Client Registration Metadata
  contents:
  - "2.1.2.  Client Registration Metadata\n   In order to convey the expected subject\
    \ of the certificate, the\n   following metadata parameters are introduced for\
    \ the OAuth 2.0\n   Dynamic Client Registration Protocol [RFC7591] in support\
    \ of the PKI\n   method of mutual-TLS client authentication.  A client using the\n\
    \   \"tls_client_auth\" authentication method MUST use exactly one of the\n  \
    \ below metadata parameters to indicate the certificate subject value\n   that\
    \ the authorization server is to expect when authenticating the\n   respective\
    \ client.\n   tls_client_auth_subject_dn\n      A string representation -- as\
    \ defined in [RFC4514] -- of the\n      expected subject distinguished name of\
    \ the certificate that the\n      OAuth client will use in mutual-TLS authentication.\n\
    \   tls_client_auth_san_dns\n      A string containing the value of an expected\
    \ dNSName SAN entry in\n      the certificate that the OAuth client will use in\
    \ mutual-TLS\n      authentication.\n   tls_client_auth_san_uri\n      A string\
    \ containing the value of an expected\n      uniformResourceIdentifier SAN entry\
    \ in the certificate that the\n      OAuth client will use in mutual-TLS authentication.\n\
    \   tls_client_auth_san_ip\n      A string representation of an IP address in\
    \ either dotted decimal\n      notation (for IPv4) or colon-delimited hexadecimal\
    \ (for IPv6, as\n      defined in [RFC5952]) that is expected to be present as\
    \ an\n      iPAddress SAN entry in the certificate that the OAuth client will\n\
    \      use in mutual-TLS authentication.  Per Section 8 of [RFC5952], the\n  \
    \    IP address comparison of the value in this parameter and the SAN\n      entry\
    \ in the certificate is to be done in binary format.\n   tls_client_auth_san_email\n\
    \      A string containing the value of an expected rfc822Name SAN entry\n   \
    \   in the certificate that the OAuth client will use in mutual-TLS\n      authentication.\n"
- title: 2.2.  Self-Signed Certificate Mutual-TLS Method
  contents:
  - "2.2.  Self-Signed Certificate Mutual-TLS Method\n   This method of mutual-TLS\
    \ OAuth client authentication is intended to\n   support client authentication\
    \ using self-signed certificates.  As a\n   prerequisite, the client registers\
    \ its X.509 certificates (using\n   \"jwks\" defined in [RFC7591]) or a reference\
    \ to a trusted source for\n   its X.509 certificates (using \"jwks_uri\" from\
    \ [RFC7591]) with the\n   authorization server.  During authentication, TLS is\
    \ utilized to\n   validate the client's possession of the private key corresponding\
    \ to\n   the public key presented within the certificate in the respective TLS\n\
    \   handshake.  In contrast to the PKI method, the client's certificate\n   chain\
    \ is not validated by the server in this case.  The client is\n   successfully\
    \ authenticated if the certificate that it presented\n   during the handshake\
    \ matches one of the certificates configured or\n   registered for that particular\
    \ client.  The Self-Signed Certificate\n   method allows the use of mutual TLS\
    \ to authenticate clients without\n   the need to maintain a PKI.  When used in\
    \ conjunction with a\n   \"jwks_uri\" for the client, it also allows the client\
    \ to rotate its\n   X.509 certificates without the need to change its respective\n\
    \   authentication data directly with the authorization server.\n"
- title: 2.2.1.  Self-Signed Method Metadata Value
  contents:
  - "2.2.1.  Self-Signed Method Metadata Value\n   For the Self-Signed Certificate\
    \ method of mutual-TLS client\n   authentication, this specification defines and\
    \ registers the\n   following authentication method metadata value into the \"\
    OAuth Token\n   Endpoint Authentication Methods\" registry [IANA.OAuth.Parameters].\n\
    \   self_signed_tls_client_auth\n      Indicates that client authentication to\
    \ the authorization server\n      will occur using mutual TLS with the client\
    \ utilizing a self-\n      signed certificate.\n"
- title: 2.2.2.  Client Registration Metadata
  contents:
  - "2.2.2.  Client Registration Metadata\n   For the Self-Signed Certificate method\
    \ of binding a certificate with\n   a client using mutual-TLS client authentication,\
    \ the existing\n   \"jwks_uri\" or \"jwks\" metadata parameters from [RFC7591]\
    \ are used to\n   convey the client's certificates via JSON Web Key (JWK) in a\
    \ JWK Set\n   [RFC7517].  The \"jwks\" metadata parameter is a JWK Set containing\
    \ the\n   client's public keys as an array of JWKs, while the \"jwks_uri\"\n \
    \  parameter is a URL that references a client's JWK Set. A certificate\n   is\
    \ represented with the \"x5c\" parameter of an individual JWK within\n   the set.\
    \  Note that the members of the JWK representing the public\n   key (e.g., \"\
    n\" and \"e\" for RSA, \"x\" and \"y\" for Elliptic Curve (EC))\n   are required\
    \ parameters per [RFC7518] so will be present even though\n   they are not utilized\
    \ in this context.  Also note that Section 4.7 of\n   [RFC7517] requires that\
    \ the key in the first certificate of the \"x5c\"\n   parameter match the public\
    \ key represented by those other members of\n   the JWK.\n"
- title: 3.  Mutual-TLS Client Certificate-Bound Access Tokens
  contents:
  - "3.  Mutual-TLS Client Certificate-Bound Access Tokens\n   When mutual TLS is\
    \ used by the client on the connection to the token\n   endpoint, the authorization\
    \ server is able to bind the issued access\n   token to the client certificate.\
    \  Such a binding is accomplished by\n   associating the certificate with the\
    \ token in a way that can be\n   accessed by the protected resource, such as embedding\
    \ the certificate\n   hash in the issued access token directly, using the syntax\
    \ described\n   in Section 3.1, or through token introspection as described in\n\
    \   Section 3.2.  Binding the access token to the client certificate in\n   that\
    \ fashion has the benefit of decoupling that binding from the\n   client's authentication\
    \ with the authorization server, which enables\n   mutual TLS during protected\
    \ resource access to serve purely as a\n   proof-of-possession mechanism.  Other\
    \ methods of associating a\n   certificate with an access token are possible,\
    \ per agreement by the\n   authorization server and the protected resource, but\
    \ are beyond the\n   scope of this specification.\n   In order for a resource\
    \ server to use certificate-bound access\n   tokens, it must have advance knowledge\
    \ that mutual TLS is to be used\n   for some or all resource accesses.  In particular,\
    \ the access token\n   itself cannot be used as input to the decision of whether\
    \ or not to\n   request mutual TLS because (from the TLS perspective) it is\n\
    \   \"Application Data\", only exchanged after the TLS handshake has been\n  \
    \ completed, and the initial CertificateRequest occurs during the\n   handshake,\
    \ before the Application Data is available.  Although\n   subsequent opportunities\
    \ for a TLS client to present a certificate\n   may be available, e.g., via TLS\
    \ 1.2 renegotiation [RFC5246] or TLS\n   1.3 post-handshake authentication [RFC8446],\
    \ this document makes no\n   provision for their usage.  It is expected to be\
    \ common that a\n   mutual-TLS-using resource server will require mutual TLS for\
    \ all\n   resources hosted thereupon or will serve mutual-TLS-protected and\n\
    \   regular resources on separate hostname and port combinations, though\n   other\
    \ workflows are possible.  How resource server policy is\n   synchronized with\
    \ the authorization server (AS) is out of scope for\n   this document.\n   Within\
    \ the scope of a mutual-TLS-protected resource-access flow, the\n   client makes\
    \ protected resource requests, as described in [RFC6750],\n   however, those requests\
    \ MUST be made over a mutually authenticated\n   TLS connection using the same\
    \ certificate that was used for mutual\n   TLS at the token endpoint.\n   The\
    \ protected resource MUST obtain, from its TLS implementation\n   layer, the client\
    \ certificate used for mutual TLS and MUST verify\n   that the certificate matches\
    \ the certificate associated with the\n   access token.  If they do not match,\
    \ the resource access attempt MUST\n   be rejected with an error, per [RFC6750],\
    \ using an HTTP 401 status\n   code and the \"invalid_token\" error code.\n  \
    \ Metadata to convey server and client capabilities for mutual-TLS\n   client\
    \ certificate-bound access tokens is defined in Sections 3.3 and\n   3.4, respectively.\n"
- title: 3.1.  JWT Certificate Thumbprint Confirmation Method
  contents:
  - "3.1.  JWT Certificate Thumbprint Confirmation Method\n   When access tokens are\
    \ represented as JSON Web Tokens (JWT)\n   [RFC7519], the certificate hash information\
    \ SHOULD be represented\n   using the \"x5t#S256\" confirmation method member\
    \ defined herein.\n   To represent the hash of a certificate in a JWT, this specification\n\
    \   defines the new JWT Confirmation Method [RFC7800] member \"x5t#S256\"\n  \
    \ for the X.509 Certificate SHA-256 Thumbprint.  The value of the\n   \"x5t#S256\"\
    \ member is a base64url-encoded [RFC4648] SHA-256 [SHS] hash\n   (a.k.a., thumbprint,\
    \ fingerprint, or digest) of the DER encoding\n   [X690] of the X.509 certificate\
    \ [RFC5280].  The base64url-encoded\n   value MUST omit all trailing pad '=' characters\
    \ and MUST NOT include\n   any line breaks, whitespace, or other additional characters.\n\
    \   The following is an example of a JWT payload containing an \"x5t#S256\"\n\
    \   certificate thumbprint confirmation method.  The new JWT content\n   introduced\
    \ by this specification is the \"cnf\" confirmation method\n   claim at the bottom\
    \ of the example that has the \"x5t#S256\"\n   confirmation method member containing\
    \ the value that is the hash of\n   the client certificate to which the access\
    \ token is bound.\n     {\n       \"iss\": \"https://server.example.com\",\n \
    \      \"sub\": \"ty.webb@example.com\",\n       \"exp\": 1493726400,\n      \
    \ \"nbf\": 1493722800,\n       \"cnf\":{\n         \"x5t#S256\": \"bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\"\
    \n       }\n     }\n   Figure 2: Example JWT Claims Set with an X.509 Certificate\
    \ Thumbprint\n                            Confirmation Method\n"
- title: 3.2.  Confirmation Method for Token Introspection
  contents:
  - "3.2.  Confirmation Method for Token Introspection\n   OAuth 2.0 Token Introspection\
    \ [RFC7662] defines a method for a\n   protected resource to query an authorization\
    \ server about the active\n   state of an access token as well as to determine\
    \ metainformation\n   about the token.\n   For a mutual-TLS client certificate-bound\
    \ access token, the hash of\n   the certificate to which the token is bound is\
    \ conveyed to the\n   protected resource as metainformation in a token introspection\n\
    \   response.  The hash is conveyed using the same \"cnf\" with \"x5t#S256\"\n\
    \   member structure as the certificate SHA-256 thumbprint confirmation\n   method,\
    \ described in Section 3.1, as a top-level member of the\n   introspection response\
    \ JSON.  The protected resource compares that\n   certificate hash to a hash of\
    \ the client certificate used for mutual-\n   TLS authentication and rejects the\
    \ request if they do not match.\n   The following is an example of an introspection\
    \ response for an\n   active token with an \"x5t#S256\" certificate thumbprint\
    \ confirmation\n   method.  The new introspection response content introduced\
    \ by this\n   specification is the \"cnf\" confirmation method at the bottom of\
    \ the\n   example that has the \"x5t#S256\" confirmation method member containing\n\
    \   the value that is the hash of the client certificate to which the\n   access\
    \ token is bound.\n     HTTP/1.1 200 OK\n     Content-Type: application/json\n\
    \     {\n       \"active\": true,\n       \"iss\": \"https://server.example.com\"\
    ,\n       \"sub\": \"ty.webb@example.com\",\n       \"exp\": 1493726400,\n   \
    \    \"nbf\": 1493722800,\n       \"cnf\":{\n         \"x5t#S256\": \"bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\"\
    \n       }\n     }\n      Figure 3: Example Introspection Response for a Certificate-Bound\n"
- title: 3.3.  Authorization Server Metadata
  contents:
  - "3.3.  Authorization Server Metadata\n   This document introduces the following\
    \ new authorization server\n   metadata [RFC8414] parameter to signal the server's\
    \ capability to\n   issue certificate-bound access tokens:\n   tls_client_certificate_bound_access_tokens\n\
    \      OPTIONAL.  Boolean value indicating server support for mutual-TLS\n   \
    \   client certificate-bound access tokens.  If omitted, the default\n      value\
    \ is \"false\".\n"
- title: 3.4.  Client Registration Metadata
  contents:
  - "3.4.  Client Registration Metadata\n   The following new client metadata parameter\
    \ is introduced to convey\n   the client's intention to use certificate-bound\
    \ access tokens:\n   tls_client_certificate_bound_access_tokens\n      OPTIONAL.\
    \  Boolean value used to indicate the client's intention\n      to use mutual-TLS\
    \ client certificate-bound access tokens.  If\n      omitted, the default value\
    \ is \"false\".\n   Note that if a client that has indicated the intention to\
    \ use mutual-\n   TLS client certificate-bound tokens makes a request to the token\n\
    \   endpoint over a non-mutual-TLS connection, it is at the authorization\n  \
    \ server's discretion as to whether to return an error or issue an\n   unbound\
    \ token.\n"
- title: 4.  Public Clients and Certificate-Bound Tokens
  contents:
  - "4.  Public Clients and Certificate-Bound Tokens\n   Mutual-TLS OAuth client authentication\
    \ and certificate-bound access\n   tokens can be used independently of each other.\
    \  Use of certificate-\n   bound access tokens without mutual-TLS OAuth client\
    \ authentication,\n   for example, is possible in support of binding access tokens\
    \ to a TLS\n   client certificate for public clients (those without authentication\n\
    \   credentials associated with the \"client_id\").  The authorization\n   server\
    \ would configure the TLS stack in the same manner as for the\n   Self-Signed\
    \ Certificate method such that it does not verify that the\n   certificate presented\
    \ by the client during the handshake is signed by\n   a trusted CA.  Individual\
    \ instances of a client would create a self-\n   signed certificate for mutual\
    \ TLS with both the authorization server\n   and resource server.  The authorization\
    \ server would not use the\n   mutual-TLS certificate to authenticate the client\
    \ at the OAuth layer\n   but would bind the issued access token to the certificate\
    \ for which\n   the client has proven possession of the corresponding private\
    \ key.\n   The access token is then bound to the certificate and can only be\n\
    \   used by the client possessing the certificate and corresponding\n   private\
    \ key and utilizing them to negotiate mutual TLS on connections\n   to the resource\
    \ server.  When the authorization server issues a\n   refresh token to such a\
    \ client, it SHOULD also bind the refresh token\n   to the respective certificate\
    \ and check the binding when the refresh\n   token is presented to get new access\
    \ tokens.  The implementation\n   details of the binding of the refresh token\
    \ are at the discretion of\n   the authorization server.\n"
- title: 5.  Metadata for Mutual-TLS Endpoint Aliases
  contents:
  - "5.  Metadata for Mutual-TLS Endpoint Aliases\n   The process of negotiating client\
    \ certificate-based mutual TLS\n   involves a TLS server requesting a certificate\
    \ from the TLS client\n   (the client does not provide one unsolicited).  Although\
    \ a server can\n   be configured such that client certificates are optional, meaning\n\
    \   that the connection is allowed to continue when the client does not\n   provide\
    \ a certificate, the act of a server requesting a certificate\n   can result in\
    \ undesirable behavior from some clients.  This is\n   particularly true of web\
    \ browsers as TLS clients, which will\n   typically present the end user with\
    \ an intrusive certificate\n   selection interface when the server requests a\
    \ certificate.\n   Authorization servers supporting both clients using mutual\
    \ TLS and\n   conventional clients MAY chose to isolate the server side mutual-TLS\n\
    \   behavior to only clients intending to do mutual TLS, thus avoiding\n   any\
    \ undesirable effects it might have on conventional clients.  The\n   following\
    \ authorization server metadata parameter is introduced to\n   facilitate such\
    \ separation:\n   mtls_endpoint_aliases\n      OPTIONAL.  A JSON object containing\
    \ alternative authorization\n      server endpoints that, when present, an OAuth\
    \ client intending to\n      do mutual TLS uses in preference to the conventional\
    \ endpoints.\n      The parameter value itself consists of one or more endpoint\n\
    \      parameters, such as \"token_endpoint\", \"revocation_endpoint\",\n    \
    \  \"introspection_endpoint\", etc., conventionally defined for the top\n    \
    \  level of authorization server metadata.  An OAuth client intending\n      to\
    \ do mutual TLS (for OAuth client authentication and/or to\n      acquire or use\
    \ certificate-bound tokens) when making a request\n      directly to the authorization\
    \ server MUST use the alias URL of the\n      endpoint within the \"mtls_endpoint_aliases\"\
    , when present, in\n      preference to the endpoint URL of the same name at the\
    \ top level\n      of metadata.  When an endpoint is not present in\n      \"\
    mtls_endpoint_aliases\", then the client uses the conventional\n      endpoint\
    \ URL defined at the top level of the authorization server\n      metadata.  Metadata\
    \ parameters within \"mtls_endpoint_aliases\" that\n      do not define endpoints\
    \ to which an OAuth client makes a direct\n      request have no meaning and SHOULD\
    \ be ignored.\n   Below is an example of an authorization server metadata document\
    \ with\n   the \"mtls_endpoint_aliases\" parameter, which indicates aliases for\n\
    \   the token, revocation, and introspection endpoints that an OAuth\n   client\
    \ intending to do mutual TLS would use in preference to the\n   conventional token,\
    \ revocation, and introspection endpoints.  Note\n   that the endpoints in \"\
    mtls_endpoint_aliases\" use a different host\n   than their conventional counterparts,\
    \ which allows the authorization\n   server (via TLS \"server_name\" extension\
    \ [RFC6066] or actual distinct\n   hosts) to differentiate its TLS behavior as\
    \ appropriate.\n   {\n     \"issuer\": \"https://server.example.com\",\n     \"\
    authorization_endpoint\": \"https://server.example.com/authz\",\n     \"token_endpoint\"\
    : \"https://server.example.com/token\",\n     \"introspection_endpoint\": \"https://server.example.com/introspect\"\
    ,\n     \"revocation_endpoint\": \"https://server.example.com/revo\",\n     \"\
    jwks_uri\": \"https://server.example.com/jwks\",\n     \"response_types_supported\"\
    : [\"code\"],\n     \"response_modes_supported\": [\"fragment\",\"query\",\"form_post\"\
    ],\n     \"grant_types_supported\": [\"authorization_code\", \"refresh_token\"\
    ],\n     \"token_endpoint_auth_methods_supported\":\n                     [\"\
    tls_client_auth\",\"client_secret_basic\",\"none\"],\n     \"tls_client_certificate_bound_access_tokens\"\
    : true,\n     \"mtls_endpoint_aliases\": {\n       \"token_endpoint\": \"https://mtls.example.com/token\"\
    ,\n       \"revocation_endpoint\": \"https://mtls.example.com/revo\",\n      \
    \ \"introspection_endpoint\": \"https://mtls.example.com/introspect\"\n     }\n\
    \   }\n      Figure 4: Example Authorization Server Metadata with Mutual-TLS\n\
    \                              Endpoint Aliases\n"
- title: 6.  Implementation Considerations
  contents:
  - '6.  Implementation Considerations

    '
- title: 6.1.  Authorization Server
  contents:
  - "6.1.  Authorization Server\n   The authorization server needs to set up its TLS\
    \ configuration\n   appropriately for the OAuth client authentication methods\
    \ it\n   supports.\n   An authorization server that supports mutual-TLS client\n\
    \   authentication and other client authentication methods or public\n   clients\
    \ in parallel would make mutual TLS optional (i.e., allowing a\n   handshake to\
    \ continue after the server requests a client certificate\n   but the client does\
    \ not send one).\n   In order to support the Self-Signed Certificate method alone,\
    \ the\n   authorization server would configure the TLS stack in such a way that\n\
    \   it does not verify whether the certificate presented by the client\n   during\
    \ the handshake is signed by a trusted CA certificate.\n   As described in Section\
    \ 3, the authorization server binds the issued\n   access token to the TLS client\
    \ certificate, which means that it will\n   only issue certificate-bound tokens\
    \ for a certificate that the client\n   has proven possession of the corresponding\
    \ private key.\n   The authorization server may also consider hosting the token\
    \ endpoint\n   and other endpoints requiring client authentication on a separate\n\
    \   host name or port in order to prevent unintended impact on the TLS\n   behavior\
    \ of its other endpoints, e.g., the authorization endpoint.\n   As described in\
    \ Section 5, it may further isolate any potential\n   impact of the server requesting\
    \ client certificates by offering a\n   distinct set of endpoints on a separate\
    \ host or port, which are\n   aliases for the originals that a client intending\
    \ to do mutual TLS\n   will use in preference to the conventional endpoints.\n"
- title: 6.2.  Resource Server
  contents:
  - "6.2.  Resource Server\n   OAuth divides the roles and responsibilities such that\
    \ the resource\n   server relies on the authorization server to perform client\n\
    \   authentication and obtain resource-owner (end-user) authorization.\n   The\
    \ resource server makes authorization decisions based on the access\n   token\
    \ presented by the client but does not directly authenticate the\n   client per\
    \ se.  The manner in which an access token is bound to the\n   client certificate\
    \ and how a protected resource verifies the proof-\n   of-possession decouples\
    \ that from the specific method that the client\n   used to authenticate with\
    \ the authorization server.  Mutual TLS\n   during protected resource access can,\
    \ therefore, serve purely as a\n   proof-of-possession mechanism.  As such, it\
    \ is not necessary for the\n   resource server to validate the trust chain of\
    \ the client's\n   certificate in any of the methods defined in this document.\
    \  The\n   resource server would, therefore, configure the TLS stack in a way\n\
    \   that it does not verify whether the certificate presented by the\n   client\
    \ during the handshake is signed by a trusted CA certificate.\n"
- title: 6.3.  Certificate Expiration and Bound Access Tokens
  contents:
  - "6.3.  Certificate Expiration and Bound Access Tokens\n   As described in Section\
    \ 3, an access token is bound to a specific\n   client certificate, which means\
    \ that the same certificate must be\n   used for mutual TLS on protected resource\
    \ access.  It also implies\n   that access tokens are invalidated when a client\
    \ updates the\n   certificate, which can be handled similarly to expired access\
    \ tokens\n   where the client requests a new access token (typically with a\n\
    \   refresh token) and retries the protected resource request.\n"
- title: 6.4.  Implicit Grant Unsupported
  contents:
  - "6.4.  Implicit Grant Unsupported\n   This document describes binding an access\
    \ token to the client\n   certificate presented on the TLS connection from the\
    \ client to the\n   authorization server's token endpoint, however, such binding\
    \ of\n   access tokens issued directly from the authorization endpoint via the\n\
    \   implicit grant flow is explicitly out of scope.  End users interact\n   directly\
    \ with the authorization endpoint using a web browser, and the\n   use of client\
    \ certificates in user's browsers bring operational and\n   usability issues that\
    \ make it undesirable to support certificate-\n   bound access tokens issued in\
    \ the implicit grant flow.\n   Implementations wanting to employ certificate-bound\
    \ access tokens\n   should utilize grant types that involve the client making\
    \ an access\n   token request directly to the token endpoint (e.g., the authorization\n\
    \   code and refresh token grant types).\n"
- title: 6.5.  TLS Termination
  contents:
  - "6.5.  TLS Termination\n   An authorization server or resource server MAY choose\
    \ to terminate\n   TLS connections at a load balancer, reverse proxy, or other\
    \ network\n   intermediary.  How the client certificate metadata is securely\n\
    \   communicated between the intermediary and the application server, in\n   this\
    \ case, is out of scope of this specification.\n"
- title: 7.  Security Considerations
  contents:
  - '7.  Security Considerations

    '
- title: 7.1.  Certificate-Bound Refresh Tokens
  contents:
  - "7.1.  Certificate-Bound Refresh Tokens\n   The OAuth 2.0 Authorization Framework\
    \ [RFC6749] requires that an\n   authorization server (AS) bind refresh tokens\
    \ to the client to which\n   they were issued and that confidential clients (those\
    \ having\n   established authentication credentials with the AS) authenticate\
    \ to\n   the AS when presenting a refresh token.  As a result, refresh tokens\n\
    \   are indirectly certificate-bound by way of the client ID and the\n   associated\
    \ requirement for (certificate-based) authentication to the\n   AS when issued\
    \ to clients utilizing the \"tls_client_auth\" or\n   \"self_signed_tls_client_auth\"\
    \ methods of client authentication.\n   Section 4 describes certificate-bound\
    \ refresh tokens issued to public\n   clients (those without authentication credentials\
    \ associated with the\n   \"client_id\").\n"
- title: 7.2.  Certificate Thumbprint Binding
  contents:
  - "7.2.  Certificate Thumbprint Binding\n   The binding between the certificate\
    \ and access token specified in\n   Section 3.1 uses a cryptographic hash of the\
    \ certificate.  It relies\n   on the hash function having sufficient second-preimage\
    \ resistance so\n   as to make it computationally infeasible to find or create\
    \ another\n   certificate that produces to the same hash output value.  The SHA-256\n\
    \   hash function was used because it meets the aforementioned\n   requirement\
    \ while being widely available.  If, in the future,\n   certificate thumbprints\
    \ need to be computed using hash function(s)\n   other than SHA-256, it is suggested\
    \ that, for additional related JWT\n   confirmation methods, members be defined\
    \ for that purpose and\n   registered in the IANA \"JWT Confirmation Methods\"\
    \ registry\n   [IANA.JWT.Claims] for JWT \"cnf\" member values.\n   Community\
    \ knowledge about the strength of various algorithms and\n   feasible attacks\
    \ can change suddenly, and experience shows that a\n   document about security\
    \ is a point-in-time statement.  Readers are\n   advised to seek out any errata\
    \ or updates that apply to this\n   document.\n"
- title: 7.3.  TLS Versions and Best Practices
  contents:
  - "7.3.  TLS Versions and Best Practices\n   This document is applicable with any\
    \ TLS version supporting\n   certificate-based client authentication.  Both TLS\
    \ 1.3 [RFC8446] and\n   TLS 1.2 [RFC5246] are cited herein, because, at the time\
    \ of writing,\n   1.3 is the newest version, while 1.2 is the most widely deployed.\n\
    \   General implementation and security considerations for TLS, including\n  \
    \ version recommendations, can be found in [BCP195].\n   TLS certificate validation\
    \ (for both client and server certificates)\n   requires a local database of trusted\
    \ certificate authorities (CAs).\n   Decisions about what CAs to trust and how\
    \ to make such a\n   determination of trust are out of scope for this document.\n"
- title: 7.4.  X.509 Certificate Spoofing
  contents:
  - "7.4.  X.509 Certificate Spoofing\n   If the PKI method of client authentication\
    \ is used, an attacker could\n   try to impersonate a client using a certificate\
    \ with the same subject\n   (DN or SAN) but issued by a different CA that the\
    \ authorization\n   server trusts.  To cope with that threat, the authorization\
    \ server\n   SHOULD only accept, as trust anchors, a limited number of CAs whose\n\
    \   certificate issuance policy meets its security requirements.  There\n   is\
    \ an assumption then that the client and server agree out of band on\n   the set\
    \ of trust anchors that the server uses to create and validate\n   the certificate\
    \ chain.  Without this assumption the use of a subject\n   to identify the client\
    \ certificate would open the server up to\n   certificate spoofing attacks.\n"
- title: 7.5.  X.509 Certificate Parsing and Validation Complexity
  contents:
  - "7.5.  X.509 Certificate Parsing and Validation Complexity\n   Parsing and validation\
    \ of X.509 certificates and certificate chains\n   is complex, and implementation\
    \ mistakes have previously exposed\n   security vulnerabilities.  Complexities\
    \ of validation include (but\n   are not limited to) [CX5P] [DCW] [RFC5280]:\n\
    \   *  checking of basic constraints, basic and extended key usage\n      constraints,\
    \ validity periods, and critical extensions;\n   *  handling of embedded NUL bytes\
    \ in ASN.1 counted-length strings and\n      non-canonical or non-normalized string\
    \ representations in subject\n      names;\n   *  handling of wildcard patterns\
    \ in subject names;\n   *  recursive verification of certificate chains and checking\n\
    \      certificate revocation.\n   For these reasons, implementors SHOULD use\
    \ an established and well-\n   tested X.509 library (such as one used by an established\
    \ TLS library)\n   for validation of X.509 certificate chains and SHOULD NOT attempt\
    \ to\n   write their own X.509 certificate validation procedures.\n"
- title: 8.  Privacy Considerations
  contents:
  - "8.  Privacy Considerations\n   In TLS versions prior to 1.3, the client's certificate\
    \ is sent\n   unencrypted in the initial handshake and can potentially be used\
    \ by\n   third parties to monitor, track, and correlate client activity.  This\n\
    \   is likely of little concern for clients that act on behalf of a\n   significant\
    \ number of end users because individual user activity will\n   not be discernible\
    \ amidst the client activity as a whole.  However,\n   clients that act on behalf\
    \ of a single end user, such as a native\n   application on a mobile device, should\
    \ use TLS version 1.3 whenever\n   possible or consider the potential privacy\
    \ implications of using\n   mutual TLS on earlier versions.\n"
- title: 9.  IANA Considerations
  contents:
  - '9.  IANA Considerations

    '
- title: 9.1.  JWT Confirmation Methods Registration
  contents:
  - "9.1.  JWT Confirmation Methods Registration\n   Per this specification, the following\
    \ value has been registered in\n   the IANA \"JWT Confirmation Methods\" registry\
    \ [IANA.JWT.Claims] for\n   JWT \"cnf\" member values established by [RFC7800].\n\
    \   Confirmation Method Value:  \"x5t#S256\"\n   Confirmation Method Description:\
    \  X.509 Certificate SHA-256\n      Thumbprint\n   Change Controller:  IESG\n\
    \   Specification Document(s):  Section 3.1 of RFC 8705\n"
- title: 9.2.  Authorization Server Metadata Registration
  contents:
  - "9.2.  Authorization Server Metadata Registration\n   Per this specification,\
    \ the following values have been registered in\n   the IANA \"OAuth Authorization\
    \ Server Metadata\" registry\n   [IANA.OAuth.Parameters] established by [RFC8414].\n\
    \   Metadata Name:  \"tls_client_certificate_bound_access_tokens\"\n   Metadata\
    \ Description:  Indicates authorization server support for\n      mutual-TLS client\
    \ certificate-bound access tokens.\n   Change Controller:  IESG\n   Specification\
    \ Document(s):  Section 3.3 of RFC 8705\n   Metadata Name:  \"mtls_endpoint_aliases\"\
    \n   Metadata Description:  JSON object containing alternative\n      authorization\
    \ server endpoints, which a client intending to do\n      mutual TLS will use\
    \ in preference to the conventional endpoints.\n   Change Controller:  IESG\n\
    \   Specification Document(s):  Section 5 of RFC 8705\n"
- title: 9.3.  Token Endpoint Authentication Method Registration
  contents:
  - "9.3.  Token Endpoint Authentication Method Registration\n   Per this specification,\
    \ the following values have been registered in\n   the IANA \"OAuth Token Endpoint\
    \ Authentication Methods\" registry\n   [IANA.OAuth.Parameters] established by\
    \ [RFC7591].\n   Token Endpoint Authentication Method Name:  \"tls_client_auth\"\
    \n   Change Controller:  IESG\n   Specification Document(s):  Section 2.1.1 of\
    \ RFC 8705\n   Token Endpoint Authentication Method Name:  \"self_signed_tls_client_\n\
    \      auth\"\n   Change Controller:  IESG\n   Specification Document(s):  Section\
    \ 2.2.1 of RFC 8705\n"
- title: 9.4.  Token Introspection Response Registration
  contents:
  - "9.4.  Token Introspection Response Registration\n   \"Proof-of-Possession Key\
    \ Semantics for JSON Web Tokens (JWTs)\"\n   [RFC7800] defined the \"cnf\" (confirmation)\
    \ claim that enables\n   confirmation key information to be carried in a JWT.\
    \  However, the\n   same proof-of-possession semantics are also useful for introspected\n\
    \   access tokens whereby the protected resource obtains the confirmation\n  \
    \ key data as metainformation of a token introspection response and\n   uses that\
    \ information in verifying proof-of-possession.  Therefore,\n   this specification\
    \ defines and registers proof-of-possession\n   semantics for OAuth 2.0 Token\
    \ Introspection [RFC7662] using the \"cnf\"\n   structure.  When included as a\
    \ top-level member of an OAuth token\n   introspection response, \"cnf\" has the\
    \ same semantics and format as\n   the claim of the same name defined in [RFC7800].\
    \  While this\n   specification only explicitly uses the \"x5t#S256\" confirmation\
    \ method\n   member (see Section 3.2), it needs to define and register the higher-\n\
    \   level \"cnf\" structure as an introspection response member in order to\n\
    \   define and use the more specific certificate thumbprint confirmation\n   method.\n\
    \   As such, the following values have been registered in the IANA \"OAuth\n \
    \  Token Introspection Response\" registry [IANA.OAuth.Parameters]\n   established\
    \ by [RFC7662].\n   Claim Name:  \"cnf\"\n   Claim Description:  Confirmation\n\
    \   Change Controller:  IESG\n   Specification Document(s):  [RFC7800] and RFC\
    \ 8705\n"
- title: 9.5.  Dynamic Client Registration Metadata Registration
  contents:
  - "9.5.  Dynamic Client Registration Metadata Registration\n   Per this specification,\
    \ the following client metadata definitions\n   have been registered in the IANA\
    \ \"OAuth Dynamic Client Registration\n   Metadata\" registry [IANA.OAuth.Parameters]\
    \ established by [RFC7591]:\n   Client Metadata Name:  \"tls_client_certificate_bound_access_tokens\"\
    \n   Client Metadata Description:  Indicates the client's intention to use\n \
    \     mutual-TLS client certificate-bound access tokens.\n   Change Controller:\
    \  IESG\n   Specification Document(s):  Section 3.4 of RFC 8705\n   Client Metadata\
    \ Name:  \"tls_client_auth_subject_dn\"\n   Client Metadata Description:  String\
    \ value specifying the expected\n      subject DN of the client certificate.\n\
    \   Change Controller:  IESG\n   Specification Document(s):  Section 2.1.2 of\
    \ RFC 8705\n   Client Metadata Name:  \"tls_client_auth_san_dns\"\n   Client Metadata\
    \ Description:  String value specifying the expected\n      dNSName SAN entry\
    \ in the client certificate.\n   Change Controller:  IESG\n   Specification Document(s):\
    \  Section 2.1.2 of RFC 8705\n   Client Metadata Name:  \"tls_client_auth_san_uri\"\
    \n   Client Metadata Description:  String value specifying the expected\n    \
    \  uniformResourceIdentifier SAN entry in the client certificate.\n   Change Controller:\
    \  IESG\n   Specification Document(s):  Section 2.1.2 of RFC 8705\n   Client Metadata\
    \ Name:  \"tls_client_auth_san_ip\"\n   Client Metadata Description:  String value\
    \ specifying the expected\n      iPAddress SAN entry in the client certificate.\n\
    \   Change Controller:  IESG\n   Specification Document(s):  Section 2.1.2 of\
    \ RFC 8705\n   Client Metadata Name:  \"tls_client_auth_san_email\"\n   Client\
    \ Metadata Description:  String value specifying the expected\n      rfc822Name\
    \ SAN entry in the client certificate.\n   Change Controller:  IESG\n   Specification\
    \ Document(s):  Section 2.1.2 of RFC 8705\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [BCP195]   Sheffer, Y., Holz, R., and P. Saint-Andre,\n\
    \              \"Recommendations for Secure Use of Transport Layer\n         \
    \     Security (TLS) and Datagram Transport Layer Security\n              (DTLS)\"\
    , BCP 195, RFC 7525, May 2015,\n              <https://www.rfc-editor.org/info/bcp195>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC4514]\
    \  Zeilenga, K., Ed., \"Lightweight Directory Access Protocol\n              (LDAP):\
    \ String Representation of Distinguished Names\",\n              RFC 4514, DOI\
    \ 10.17487/RFC4514, June 2006,\n              <https://www.rfc-editor.org/info/rfc4514>.\n\
    \   [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n        \
    \      Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006,\n          \
    \    <https://www.rfc-editor.org/info/rfc4648>.\n   [RFC5246]  Dierks, T. and\
    \ E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol Version\
    \ 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August 2008,\n       \
    \       <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5280]  Cooper, D.,\
    \ Santesson, S., Farrell, S., Boeyen, S.,\n              Housley, R., and W. Polk,\
    \ \"Internet X.509 Public Key\n              Infrastructure Certificate and Certificate\
    \ Revocation List\n              (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280,\
    \ May 2008,\n              <https://www.rfc-editor.org/info/rfc5280>.\n   [RFC6749]\
    \  Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\",\n              RFC\
    \ 6749, DOI 10.17487/RFC6749, October 2012,\n              <https://www.rfc-editor.org/info/rfc6749>.\n\
    \   [RFC6750]  Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization\n       \
    \       Framework: Bearer Token Usage\", RFC 6750,\n              DOI 10.17487/RFC6750,\
    \ October 2012,\n              <https://www.rfc-editor.org/info/rfc6750>.\n  \
    \ [RFC7517]  Jones, M., \"JSON Web Key (JWK)\", RFC 7517,\n              DOI 10.17487/RFC7517,\
    \ May 2015,\n              <https://www.rfc-editor.org/info/rfc7517>.\n   [RFC7519]\
    \  Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token\n              (JWT)\"\
    , RFC 7519, DOI 10.17487/RFC7519, May 2015,\n              <https://www.rfc-editor.org/info/rfc7519>.\n\
    \   [RFC7591]  Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and\n  \
    \            P. Hunt, \"OAuth 2.0 Dynamic Client Registration Protocol\",\n  \
    \            RFC 7591, DOI 10.17487/RFC7591, July 2015,\n              <https://www.rfc-editor.org/info/rfc7591>.\n\
    \   [RFC7662]  Richer, J., Ed., \"OAuth 2.0 Token Introspection\",\n         \
    \     RFC 7662, DOI 10.17487/RFC7662, October 2015,\n              <https://www.rfc-editor.org/info/rfc7662>.\n\
    \   [RFC7800]  Jones, M., Bradley, J., and H. Tschofenig, \"Proof-of-\n      \
    \        Possession Key Semantics for JSON Web Tokens (JWTs)\",\n            \
    \  RFC 7800, DOI 10.17487/RFC7800, April 2016,\n              <https://www.rfc-editor.org/info/rfc7800>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8414]  Jones,\
    \ M., Sakimura, N., and J. Bradley, \"OAuth 2.0\n              Authorization Server\
    \ Metadata\", RFC 8414,\n              DOI 10.17487/RFC8414, June 2018,\n    \
    \          <https://www.rfc-editor.org/info/rfc8414>.\n   [RFC8446]  Rescorla,\
    \ E., \"The Transport Layer Security (TLS) Protocol\n              Version 1.3\"\
    , RFC 8446, DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n\
    \   [SHS]      National Institute of Standards and Technology (NIST),\n      \
    \        \"Secure Hash Standard (SHS)\", FIPS PUB 180-4,\n              DOI 10.6028/NIST.FIPS.180-4,\
    \ August 2015,\n              <https://nvlpubs.nist.gov/nistpubs/FIPS/\n     \
    \         NIST.FIPS.180-4.pdf>.\n   [X690]     ITU-T, \"Information Technology\
    \ - ASN.1 encoding rules:\n              Specification of Basic Encoding Rules\
    \ (BER), Canonical\n              Encoding Rules (CER) and Distinguished Encoding\
    \ Rules\n              (DER)\", ITU-T Recommendation X.690, August 2015.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [CX5P]     Wong, D., \"Common x509 certificate\
    \ validation/creation\n              pitfalls\", September 2016,\n           \
    \   <https://www.cryptologie.net/article/374/common-x509-\n              certificate-validationcreation-pitfalls>.\n\
    \   [DCW]      Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh,\n    \
    \          D., and V. Shmatikov, \"The Most Dangerous Code in the\n          \
    \    World: Validating SSL Certificates in Non-Browser\n              Software\"\
    , DOI 10.1145/2382196.2382204, October 2012,\n              <http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf>.\n\
    \   [IANA.JWT.Claims]\n              IANA, \"JSON Web Token Claims\",\n      \
    \        <https://www.iana.org/assignments/jwt>.\n   [IANA.OAuth.Parameters]\n\
    \              IANA, \"OAuth Parameters\",\n              <https://www.iana.org/assignments/oauth-parameters>.\n\
    \   [OpenID.CIBA]\n              Fernandez, G., Walter, F., Nennker, A., Tonge,\
    \ D., and B.\n              Campbell, \"OpenID Connect Client Initiated Backchannel\n\
    \              Authentication Flow - Core 1.0\", 16 January 2019,\n          \
    \    <https://openid.net/specs/openid-client-initiated-\n              backchannel-authentication-core-1_0.html>.\n\
    \   [RFC4517]  Legg, S., Ed., \"Lightweight Directory Access Protocol\n      \
    \        (LDAP): Syntaxes and Matching Rules\", RFC 4517,\n              DOI 10.17487/RFC4517,\
    \ June 2006,\n              <https://www.rfc-editor.org/info/rfc4517>.\n   [RFC5952]\
    \  Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6\n              Address\
    \ Text Representation\", RFC 5952,\n              DOI 10.17487/RFC5952, August\
    \ 2010,\n              <https://www.rfc-editor.org/info/rfc5952>.\n   [RFC6066]\
    \  Eastlake 3rd, D., \"Transport Layer Security (TLS)\n              Extensions:\
    \ Extension Definitions\", RFC 6066,\n              DOI 10.17487/RFC6066, January\
    \ 2011,\n              <https://www.rfc-editor.org/info/rfc6066>.\n   [RFC7009]\
    \  Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, \"OAuth\n             \
    \ 2.0 Token Revocation\", RFC 7009, DOI 10.17487/RFC7009,\n              August\
    \ 2013, <https://www.rfc-editor.org/info/rfc7009>.\n   [RFC7518]  Jones, M., \"\
    JSON Web Algorithms (JWA)\", RFC 7518,\n              DOI 10.17487/RFC7518, May\
    \ 2015,\n              <https://www.rfc-editor.org/info/rfc7518>.\n   [TOKEN]\
    \    Jones, M., Campbell, B., Bradley, J., and W. Denniss,\n              \"OAuth\
    \ 2.0 Token Binding\", Work in Progress, Internet-\n              Draft, draft-ietf-oauth-token-binding-08,\
    \ 19 October 2018,\n              <https://tools.ietf.org/html/draft-ietf-oauth-token-\n\
    \              binding-08>.\n"
- title: Appendix A.  Example "cnf" Claim, Certificate, and JWK
  contents:
  - "Appendix A.  Example \"cnf\" Claim, Certificate, and JWK\n   For reference, an\
    \ \"x5t#S256\" value and the X.509 certificate from\n   which it was calculated\
    \ are provided in the following examples,\n   Figures 5 and 6, respectively. \
    \ A JWK representation of the\n   certificate's public key along with the \"x5c\"\
    \ member is also provided\n   in Figure 7.\n   \"cnf\":{\"x5t#S256\":\"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0\"\
    }\n                   Figure 5: x5t#S256 Confirmation Claim\n   -----BEGIN CERTIFICATE-----\n\
    \   MIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTAx\n   ODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGByqG\n\
    \   SM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZjjJ\n   /Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0EAwID\n\
    \   SQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2eXZOV\n   bUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY=\n\
    \   -----END CERTIFICATE-----\n               Figure 6: PEM Encoded Self-Signed\
    \ Certificate\n   {\n    \"kty\":\"EC\",\n    \"x\":\"1yfLHCpXqFjxCeHHHMVDTcLscpb07KUxudBmOMn8C7Q\"\
    ,\n    \"y\":\"8_coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8\",\n    \"crv\":\"\
    P-256\",\n    \"x5c\":[\n     \"MIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTA\n\
    \      xODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGBy\n     \
    \ qGSM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZ\n      jjJ/Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0E\n\
    \      AwIDSQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2\n     \
    \ eXZOVbUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY=\"\n      ]\n    }\n              \
    \             Figure 7: JSON Web Key\n"
- title: Appendix B.  Relationship to Token Binding
  contents:
  - "Appendix B.  Relationship to Token Binding\n   OAuth 2.0 Token Binding [TOKEN]\
    \ enables the application of Token\n   Binding to the various artifacts and tokens\
    \ employed throughout\n   OAuth.  That includes binding of an access token to\
    \ a Token Binding\n   key, which bears some similarities in motivation and design\
    \ to the\n   mutual-TLS client certificate-bound access tokens defined in this\n\
    \   document.  Both documents define what is often called a proof-of-\n   possession\
    \ security mechanism for access tokens, whereby a client\n   must demonstrate\
    \ possession of cryptographic keying material when\n   accessing a protected resource.\
    \  The details differ somewhat between\n   the two documents but both have the\
    \ authorization server bind the\n   access token that it issues to an asymmetric\
    \ key pair held by the\n   client.  The client then proves possession of the private\
    \ key from\n   that pair with respect to the TLS connection over which the protected\n\
    \   resource is accessed.\n   Token Binding uses bare keys that are generated\
    \ on the client, which\n   avoids many of the difficulties of creating, distributing,\
    \ and\n   managing certificates used in this specification.  However, at the\n\
    \   time of writing, Token Binding is fairly new, and there is relatively\n  \
    \ little support for it in available application development platforms\n   and\
    \ tooling.  Until better support for the underlying core Token\n   Binding specifications\
    \ exists, practical implementations of OAuth 2.0\n   Token Binding are infeasible.\
    \  Mutual TLS, on the other hand, has\n   been around for some time and enjoys\
    \ widespread support in web\n   servers and development platforms.  As a consequence,\
    \ OAuth 2.0\n   Mutual-TLS Client Authentication and Certificate-Bound Access\
    \ Tokens\n   can be built and deployed now using existing platforms and tools.\
    \  In\n   the future, the two specifications are likely to be deployed in\n  \
    \ parallel for solving similar problems in different environments.\n   Authorization\
    \ servers may even support both specifications\n   simultaneously using different\
    \ proof-of-possession mechanisms for\n   tokens issued to different clients.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Scott \"not Tomlinson\" Tomilson and Matt Peterson were\
    \ involved in\n   design and development work on a mutual-TLS OAuth client\n \
    \  authentication implementation that predates this document.\n   Experience and\
    \ learning from that work informed some of the content\n   of this document.\n\
    \   This specification was developed within the OAuth Working Group under\n  \
    \ the chairmanship of Hannes Tschofenig and Rifaat Shekh-Yusef with\n   Eric Rescorla,\
    \ Benjamin Kaduk, and Roman Danyliw serving as Security\n   Area Directors.  Additionally,\
    \ the following individuals contributed\n   ideas, feedback, and wording that\
    \ helped shape this specification:\n   Vittorio Bertocci, Sergey Beryozkin, Ralph\
    \ Bragg, Sophie Bremer,\n   Roman Danyliw, Vladimir Dzhuvinov, Samuel Erdtman,\
    \ Evan Gilman, Leif\n   Johansson, Michael Jones, Phil Hunt, Benjamin Kaduk, Takahiko\n\
    \   Kawasaki, Sean Leonard, Kepeng Li, Neil Madden, James Manger, Jim\n   Manico,\
    \ Nov Matake, Sascha Preibisch, Eric Rescorla, Justin Richer,\n   Vincent Roca,\
    \ Filip Skokan, Dave Tonge, and Hannes Tschofenig.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Brian Campbell\n   Ping Identity\n   Email: brian.d.campbell@gmail.com\n\
    \   John Bradley\n   Yubico\n   Email: ve7jtb@ve7jtb.com\n   URI:   http://www.thread-safe.com/\n\
    \   Nat Sakimura\n   Nomura Research Institute\n   Email: n-sakimura@nri.co.jp\n\
    \   URI:   https://nat.sakimura.org/\n   Torsten Lodderstedt\n"
