- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                M-J. Saarinen, Ed.
  contents:
  - "Independent Submission                                M-J. Saarinen, Ed.\n  The\
    \ BLAKE2 Cryptographic Hash and Message Authentication Code (MAC)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the cryptographic hash function BLAKE2 and\n\
    \   makes the algorithm specification and C source code conveniently\n   available\
    \ to the Internet community.  BLAKE2 comes in two main\n   flavors: BLAKE2b is\
    \ optimized for 64-bit platforms and BLAKE2s for\n   smaller architectures.  BLAKE2\
    \ can be directly keyed, making it\n   functionally equivalent to a Message Authentication\
    \ Code (MAC).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7693.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and Terminology  . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Conventions, Variables, and Constants . . . . . . . .\
    \ . . . .   4\n     2.1.  Parameters  . . . . . . . . . . . . . . . . . . . .\
    \ . . .   4\n     2.2.  Other Constants and Variables . . . . . . . . . . . .\
    \ . .   4\n     2.3.  Arithmetic Notation . . . . . . . . . . . . . . . . . .\
    \ .   4\n     2.4.  Little-Endian Interpretation of Words as Bytes  . . . . .\
    \   5\n     2.5.  Parameter Block . . . . . . . . . . . . . . . . . . . . .  \
    \ 5\n     2.6.  Initialization Vector . . . . . . . . . . . . . . . . . .   6\n\
    \     2.7.  Message Schedule SIGMA  . . . . . . . . . . . . . . . . .   6\n  \
    \ 3.  BLAKE2 Processing . . . . . . . . . . . . . . . . . . . . . .   7\n    \
    \ 3.1.  Mixing Function G . . . . . . . . . . . . . . . . . . . .   7\n     3.2.\
    \  Compression Function F  . . . . . . . . . . . . . . . . .   8\n     3.3.  Padding\
    \ Data and Computing a BLAKE2 Digest  . . . . . . .   9\n   4.  Standard Parameter\
    \ Sets and Algorithm Identifiers . . . . . .  10\n   5.  Security Considerations\
    \ . . . . . . . . . . . . . . . . . . .  11\n   6.  References  . . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  11\n     6.1.  Normative References  .\
    \ . . . . . . . . . . . . . . . . .  11\n     6.2.  Informative References  .\
    \ . . . . . . . . . . . . . . . .  11\n   Appendix A.  Example of BLAKE2b Computation\
    \ . . . . . . . . . . .  13\n   Appendix B.  Example of BLAKE2s Computation .\
    \ . . . . . . . . . .  15\n   Appendix C.  BLAKE2b Implementation C Source  .\
    \ . . . . . . . . .  16\n     C.1.  blake2b.h . . . . . . . . . . . . . . . .\
    \ . . . . . . . .  16\n     C.2.  blake2b.c . . . . . . . . . . . . . . . . .\
    \ . . . . . . .  17\n   Appendix D.  BLAKE2s Implementation C Source  . . . .\
    \ . . . . . .  21\n     D.1.  blake2s.h . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  21\n     D.2.  blake2s.c . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  22\n   Appendix E.  BLAKE2b and BLAKE2s Self-Test Module C Source \
    \ . . .  26\n   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  29\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . .\
    \ .  30\n"
- title: 1.  Introduction and Terminology
  contents:
  - "1.  Introduction and Terminology\n   The BLAKE2 cryptographic hash function [BLAKE2]\
    \ was designed by Jean-\n   Philippe Aumasson, Samuel Neves, Zooko Wilcox-O'Hearn,\
    \ and Christian\n   Winnerlein.\n   BLAKE2 comes in two basic flavors:\n   o \
    \ BLAKE2b (or just BLAKE2) is optimized for 64-bit platforms and\n      produces\
    \ digests of any size between 1 and 64 bytes.\n   o  BLAKE2s is optimized for\
    \ 8- to 32-bit platforms and produces\n      digests of any size between 1 and\
    \ 32 bytes.\n   Both BLAKE2b and BLAKE2s are believed to be highly secure and\
    \ perform\n   well on any platform, software, or hardware.  BLAKE2 does not require\n\
    \   a special \"HMAC\" (Hashed Message Authentication Code) construction\n   for\
    \ keyed message authentication as it has a built-in keying\n   mechanism.\n  \
    \ The BLAKE2 hash function may be used by digital signature algorithms\n   and\
    \ message authentication and integrity protection mechanisms in\n   applications\
    \ such as Public Key Infrastructure (PKI), secure\n   communication protocols,\
    \ cloud storage, intrusion detection, forensic\n   suites, and version control\
    \ systems.\n   The BLAKE2 suite provides a more efficient alternative to US Secure\n\
    \   Hash Algorithms SHA and HMAC-SHA [RFC6234].  BLAKE2s-128 is\n   especially\
    \ suited as a fast and more secure drop-in replacement to\n   MD5 and HMAC-MD5\
    \ in legacy applications [RFC6151].\n   To aid implementation, we provide a trace\
    \ of BLAKE2b-512 hash\n   computation in Appendix A and a trace of BLAKE2s-256\
    \ hash computation\n   in Appendix B.  Due to space constraints, this document\
    \ does not\n   contain a full set of test vectors for BLAKE2.\n   A reference\
    \ implementation in C programming language for BLAKE2b can\n   be found in Appendix\
    \ C and for BLAKE2s in Appendix D of this\n   document.  These implementations\
    \ MAY be validated with the more\n   exhaustive Test Module contained in Appendix\
    \ E.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL\
    \ NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"\
    \ in this\n   document are to be interpreted as described in [RFC2119].\n"
- title: 2.  Conventions, Variables, and Constants
  contents:
  - '2.  Conventions, Variables, and Constants

    '
- title: 2.1.  Parameters
  contents:
  - "2.1.  Parameters\n   The following table summarizes various parameters and their\
    \ ranges:\n                            | BLAKE2b          | BLAKE2s          |\n\
    \              --------------+------------------+------------------+\n       \
    \        Bits in word | w = 64           | w = 32           |\n              \
    \ Rounds in F  | r = 12           | r = 10           |\n               Block bytes\
    \  | bb = 128         | bb = 64          |\n               Hash bytes   | 1 <=\
    \ nn <= 64    | 1 <= nn <= 32    |\n               Key bytes    | 0 <= kk <= 64\
    \    | 0 <= kk <= 32    |\n               Input bytes  | 0 <= ll < 2**128 | 0\
    \ <= ll < 2**64  |\n              --------------+------------------+------------------+\n\
    \               G Rotation   | (R1, R2, R3, R4) | (R1, R2, R3, R4) |\n       \
    \         constants = | (32, 24, 16, 63) | (16, 12,  8,  7) |\n              --------------+------------------+------------------+\n"
- title: 2.2.  Other Constants and Variables
  contents:
  - "2.2.  Other Constants and Variables\n   These variables are used in the algorithm\
    \ description:\n   IV[0..7]  Initialization Vector (constant).\n   SIGMA[0..9]\
    \  Message word permutations (constant).\n   p[0..7]  Parameter block (defines\
    \ hash and key sizes).\n   m[0..15]  Sixteen words of a single message block.\n\
    \   h[0..7]  Internal state of the hash.\n   d[0..dd-1]  Padded input blocks.\
    \  Each has \"bb\" bytes.\n   t  Message byte offset at the end of the current\
    \ block.\n   f  Flag indicating the last block.\n"
- title: 2.3.  Arithmetic Notation
  contents:
  - "2.3.  Arithmetic Notation\n   For real-valued x, we define the following functions:\n\
    \   floor(x)  Floor, the largest integer <= x.\n   ceil(x)  Ceiling, the smallest\
    \ integer >= x.\n   frac(x)  Positive fractional part of x, frac(x) = x - floor(x).\n\
    \   Operator notation in pseudocode:\n   2**n =  2 to the power \"n\". 2**0=1,\
    \ 2**1=2, 2**2=4, 2**3=8, etc.\n   a ^ b =  Bitwise exclusive-or operation between\
    \ \"a\" and \"b\".\n   a mod b =  Remainder \"a\" modulo \"b\", always in range\
    \ [0, b-1].\n   x >> n =  floor(x / 2**n).  Logical shift \"x\" right by \"n\"\
    \ bits.\n   x << n =  (x * 2**n) mod (2**w).  Logical shift \"x\" left by \"n\"\
    .\n   x >>> n =  (x >> n) ^ (x << (w - n)).  Rotate \"x\" right by \"n\".\n"
- title: 2.4.  Little-Endian Interpretation of Words as Bytes
  contents:
  - "2.4.  Little-Endian Interpretation of Words as Bytes\n   All mathematical operations\
    \ are on 64-bit words in BLAKE2b and on\n   32-bit words in BLAKE2s.\n   We may\
    \ also perform operations on vectors of words.  Vector indexing\n   is zero based;\
    \ the first element of an n-element vector \"v\" is v[0]\n   and the last one\
    \ is v[n - 1].  All elements are denoted by v[0..n-1].\n   Byte (octet) streams\
    \ are interpreted as words in little-endian order,\n   with the least-significant\
    \ byte first.  Consider this sequence of\n   eight hexadecimal bytes:\n      \
    \  x[0..7] = 0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF\n   When interpreted as a\
    \ 32-bit word from the beginning memory address,\n   x[0..3] has a numerical value\
    \ of 0x67452301 or 1732584193.\n   When interpreted as a 64-bit word, bytes x[0..7]\
    \ have a numerical\n   value of 0xEFCDAB8967452301 or 17279655951921914625.\n"
- title: 2.5.  Parameter Block
  contents:
  - "2.5.  Parameter Block\n   We specify the parameter block words p[0..7] as follows:\n\
    \        byte offset:    3 2 1 0     (otherwise zero)\n              p[0] = 0x0101kknn\
    \     p[1..7] = 0\n   Here the \"nn\" byte specifies the hash size in bytes. \
    \ The second\n   (little-endian) byte of the parameter block, \"kk\", specifies\
    \ the key\n   size in bytes.  Set kk = 00 for unkeyed hashing.  Bytes 2 and 3\
    \ are\n   set as 01.  All other bytes in the parameter block are set as zero.\n\
    \   Note: [BLAKE2] defines additional variants of BLAKE2 with features\n   such\
    \ as salting, personalized hashes, and tree hashing.  These\n   OPTIONAL features\
    \ use fields in the parameter block that are not\n   defined in this document.\n"
- title: 2.6.  Initialization Vector
  contents:
  - "2.6.  Initialization Vector\n   We define the Initialization Vector constant\
    \ IV mathematically as:\n          IV[i] = floor(2**w * frac(sqrt(prime(i+1)))),\
    \ where prime(i)\n          is the i:th prime number ( 2, 3, 5, 7, 11, 13, 17,\
    \ 19 )\n          and sqrt(x) is the square root of x.\n   The numerical values\
    \ of IV can also be found in implementations in\n   Appendices C and D for BLAKE2b\
    \ and BLAKE2s, respectively.\n   Note: BLAKE2b IV is the same as SHA-512 IV, and\
    \ BLAKE2s IV is the\n   same as SHA-256 IV; see [RFC6234].\n"
- title: 2.7.  Message Schedule SIGMA
  contents:
  - "2.7.  Message Schedule SIGMA\n   Message word schedule permutations for each\
    \ round of both BLAKE2b and\n   BLAKE2s are defined by SIGMA.  For BLAKE2b, the\
    \ two extra\n   permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n\
    \          Round   |  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 |\n     \
    \   ----------+-------------------------------------------------+\n         SIGMA[0]\
    \ |  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 |\n         SIGMA[1] | 14\
    \ 10  4  8  9 15 13  6  1 12  0  2 11  7  5  3 |\n         SIGMA[2] | 11  8 12\
    \  0  5  2 15 13 10 14  3  6  7  1  9  4 |\n         SIGMA[3] |  7  9  3  1 13\
    \ 12 11 14  2  6  5 10  4  0 15  8 |\n         SIGMA[4] |  9  0  5  7  2  4 10\
    \ 15 14  1 11 12  6  8  3 13 |\n         SIGMA[5] |  2 12  6 10  0 11  8  3  4\
    \ 13  7  5 15 14  1  9 |\n         SIGMA[6] | 12  5  1 15 14 13  4 10  0  7  6\
    \  3  9  2  8 11 |\n         SIGMA[7] | 13 11  7 14 12  1  3  9  5  0 15  4  8\
    \  6  2 10 |\n         SIGMA[8] |  6 15 14  9 11  3  0  8 12  2 13  7  1  4 10\
    \  5 |\n         SIGMA[9] | 10  2  8  4  7  6  1  5 15 11  9 14  3 12 13  0 |\n\
    \        ----------+-------------------------------------------------+\n"
- title: 3.  BLAKE2 Processing
  contents:
  - '3.  BLAKE2 Processing

    '
- title: 3.1.  Mixing Function G
  contents:
  - "3.1.  Mixing Function G\n   The G primitive function mixes two input words, \"\
    x\" and \"y\", into\n   four words indexed by \"a\", \"b\", \"c\", and \"d\" in\
    \ the working vector\n   v[0..15].  The full modified vector is returned.  The\
    \ rotation\n   constants (R1, R2, R3, R4) are given in Section 2.1.\n       FUNCTION\
    \ G( v[0..15], a, b, c, d, x, y )\n       |\n       |   v[a] := (v[a] + v[b] +\
    \ x) mod 2**w\n       |   v[d] := (v[d] ^ v[a]) >>> R1\n       |   v[c] := (v[c]\
    \ + v[d])     mod 2**w\n       |   v[b] := (v[b] ^ v[c]) >>> R2\n       |   v[a]\
    \ := (v[a] + v[b] + y) mod 2**w\n       |   v[d] := (v[d] ^ v[a]) >>> R3\n   \
    \    |   v[c] := (v[c] + v[d])     mod 2**w\n       |   v[b] := (v[b] ^ v[c])\
    \ >>> R4\n       |\n       |   RETURN v[0..15]\n       |\n       END FUNCTION.\n"
- title: 3.2.  Compression Function F
  contents:
  - "3.2.  Compression Function F\n   Compression function F takes as an argument\
    \ the state vector \"h\",\n   message block vector \"m\" (last block is padded\
    \ with zeros to full\n   block size, if required), 2w-bit offset counter \"t\"\
    , and final block\n   indicator flag \"f\".  Local vector v[0..15] is used in\
    \ processing.  F\n   returns a new state vector.  The number of rounds, \"r\"\
    , is 12 for\n   BLAKE2b and 10 for BLAKE2s.  Rounds are numbered from 0 to r -\
    \ 1.\n       FUNCTION F( h[0..7], m[0..15], t, f )\n       |\n       |      //\
    \ Initialize local work vector v[0..15]\n       |      v[0..7] := h[0..7]    \
    \          // First half from state.\n       |      v[8..15] := IV[0..7]     \
    \       // Second half from IV.\n       |\n       |      v[12] := v[12] ^ (t mod\
    \ 2**w)   // Low word of the offset.\n       |      v[13] := v[13] ^ (t >> w)\
    \       // High word.\n       |\n       |      IF f = TRUE THEN              \
    \  // last block flag?\n       |      |   v[14] := v[14] ^ 0xFF..FF   // Invert\
    \ all bits.\n       |      END IF.\n       |\n       |      // Cryptographic mixing\n\
    \       |      FOR i = 0 TO r - 1 DO           // Ten or twelve rounds.\n    \
    \   |      |\n       |      |   // Message word selection permutation for this\
    \ round.\n       |      |   s[0..15] := SIGMA[i mod 10][0..15]\n       |     \
    \ |\n       |      |   v := G( v, 0, 4,  8, 12, m[s[ 0]], m[s[ 1]] )\n       |\
    \      |   v := G( v, 1, 5,  9, 13, m[s[ 2]], m[s[ 3]] )\n       |      |   v\
    \ := G( v, 2, 6, 10, 14, m[s[ 4]], m[s[ 5]] )\n       |      |   v := G( v, 3,\
    \ 7, 11, 15, m[s[ 6]], m[s[ 7]] )\n       |      |\n       |      |   v := G(\
    \ v, 0, 5, 10, 15, m[s[ 8]], m[s[ 9]] )\n       |      |   v := G( v, 1, 6, 11,\
    \ 12, m[s[10]], m[s[11]] )\n       |      |   v := G( v, 2, 7,  8, 13, m[s[12]],\
    \ m[s[13]] )\n       |      |   v := G( v, 3, 4,  9, 14, m[s[14]], m[s[15]] )\n\
    \       |      |\n       |      END FOR\n       |\n       |      FOR i = 0 TO\
    \ 7 DO               // XOR the two halves.\n       |      |   h[i] := h[i] ^\
    \ v[i] ^ v[i + 8]\n       |      END FOR.\n       |\n       |      RETURN h[0..7]\
    \                  // New state.\n       |\n       END FUNCTION.\n"
- title: 3.3.  Padding Data and Computing a BLAKE2 Digest
  contents:
  - "3.3.  Padding Data and Computing a BLAKE2 Digest\n   We refer the reader to Appendices\
    \ C and D for reference C language\n   implementations of BLAKE2b and BLAKE2s,\
    \ respectively.\n   Key and data input are split and padded into \"dd\" message\
    \ blocks\n   d[0..dd-1], each consisting of 16 words (or \"bb\" bytes).\n   If\
    \ a secret key is used (kk > 0), it is padded with zero bytes and\n   set as d[0].\
    \  Otherwise, d[0] is the first data block.  The final\n   data block d[dd-1]\
    \ is also padded with zero to \"bb\" bytes (16 words).\n   The number of blocks\
    \ is therefore dd = ceil(kk / bb) + ceil(ll / bb).\n   However, in the special\
    \ case of an unkeyed empty message (kk = 0 and\n   ll = 0), we still set dd =\
    \ 1 and d[0] consists of all zeros.\n   The following procedure processes the\
    \ padded data blocks into an\n   \"nn\"-byte final hash value.  See Section 2\
    \ for a description of\n   various variables and constants used.\n        FUNCTION\
    \ BLAKE2( d[0..dd-1], ll, kk, nn )\n        |\n        |     h[0..7] := IV[0..7]\
    \          // Initialization Vector.\n        |\n        |     // Parameter block\
    \ p[0]\n        |     h[0] := h[0] ^ 0x01010000 ^ (kk << 8) ^ nn\n        |\n\
    \        |     // Process padded key and data blocks\n        |     IF dd > 1\
    \ THEN\n        |     |       FOR i = 0 TO dd - 2 DO\n        |     |       |\
    \       h := F( h, d[i], (i + 1) * bb, FALSE )\n        |     |       END FOR.\n\
    \        |     END IF.\n        |\n        |     // Final block.\n        |  \
    \   IF kk = 0 THEN\n        |     |       h := F( h, d[dd - 1], ll, TRUE )\n \
    \       |     ELSE\n        |     |       h := F( h, d[dd - 1], ll + bb, TRUE\
    \ )\n        |     END IF.\n        |\n        |     RETURN first \"nn\" bytes\
    \ from little-endian word array h[].\n        |\n        END FUNCTION.\n"
- title: 4.  Standard Parameter Sets and Algorithm Identifiers
  contents:
  - "4.  Standard Parameter Sets and Algorithm Identifiers\n   An implementation of\
    \ BLAKE2b and/or BLAKE2s MAY support the following\n   digest size parameters\
    \ for interoperability (e.g., digital\n   signatures), as long as a sufficient\
    \ level of security is attained by\n   the parameter selections.  These parameters\
    \ and identifiers are\n   intended to be suitable as drop-in replacements to MD5\
    \ and\n   corresponding SHA algorithms.\n   Developers adapting BLAKE2 to ASN.1-based\
    \ message formats SHOULD use\n   the OID tree at x = 1.3.6.1.4.1.1722.12.2.  The\
    \ same OID can be used\n   for both keyed and unkeyed hashing since in the latter\
    \ case the key\n   simply has zero length.\n            Algorithm     | Target\
    \ | Collision | Hash | Hash ASN.1 |\n               Identifier |  Arch  |  Security\
    \ |  nn  | OID Suffix |\n           ---------------+--------+-----------+------+------------+\n\
    \            id-blake2b160 | 64-bit |   2**80   |  20  |   x.1.5    |\n      \
    \      id-blake2b256 | 64-bit |   2**128  |  32  |   x.1.8    |\n            id-blake2b384\
    \ | 64-bit |   2**192  |  48  |   x.1.12   |\n            id-blake2b512 | 64-bit\
    \ |   2**256  |  64  |   x.1.16   |\n           ---------------+--------+-----------+------+------------+\n\
    \            id-blake2s128 | 32-bit |   2**64   |  16  |   x.2.4    |\n      \
    \      id-blake2s160 | 32-bit |   2**80   |  20  |   x.2.5    |\n            id-blake2s224\
    \ | 32-bit |   2**112  |  28  |   x.2.7    |\n            id-blake2s256 | 32-bit\
    \ |   2**128  |  32  |   x.2.8    |\n           ---------------+--------+-----------+------+------------+\n\
    \          hashAlgs OBJECT IDENTIFIER ::= {\n              iso(1) identified-organization(3)\
    \ dod(6) internet(1)\n              private(4) enterprise(1) kudelski(1722) cryptography(12)\
    \ 2\n          }\n          macAlgs OBJECT IDENTIFIER ::= {\n              iso(1)\
    \ identified-organization(3) dod(6) internet(1)\n              private(4) enterprise(1)\
    \ kudelski(1722) cryptography(12) 3\n          }\n          -- the two BLAKE2\
    \ variants --\n          blake2b OBJECT IDENTIFIER ::= { hashAlgs 1 }\n      \
    \    blake2s OBJECT IDENTIFIER ::= { hashAlgs 2 }\n          -- BLAKE2b Identifiers\
    \ --\n          id-blake2b160 OBJECT IDENTIFIER ::= { blake2b 5 }\n          id-blake2b256\
    \ OBJECT IDENTIFIER ::= { blake2b 8 }\n          id-blake2b384 OBJECT IDENTIFIER\
    \ ::= { blake2b 12 }\n          id-blake2b512 OBJECT IDENTIFIER ::= { blake2b\
    \ 16 }\n          -- BLAKE2s Identifiers --\n          id-blake2s128 OBJECT IDENTIFIER\
    \ ::= { blake2s 4 }\n          id-blake2s160 OBJECT IDENTIFIER ::= { blake2s 5\
    \ }\n          id-blake2s224 OBJECT IDENTIFIER ::= { blake2s 7 }\n          id-blake2s256\
    \ OBJECT IDENTIFIER ::= { blake2s 8 }\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This document is intended to provide convenient\
    \ open-source access by\n   the Internet community to the BLAKE2 cryptographic\
    \ hash algorithm.\n   We wish to make no independent assertion to its security\
    \ in this\n   document.  We refer the reader to [BLAKE] and [BLAKE2] for detailed\n\
    \   cryptanalytic rationale behind its design.\n   In order to avoid bloat, the\
    \ reference implementations in Appendices\n   C and D may not erase all sensitive\
    \ data (such as secret keys)\n   immediately from process memory after use.  Such\
    \ cleanup can be added\n   if needed.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [BLAKE]    Aumasson, J-P., Meier, W., Phan,\
    \ R., and L. Henzen, \"The\n              Hash Function BLAKE\", January 2015,\n\
    \              <https://131002.net/blake/book>.\n   [BLAKE2]   Aumasson, J-P.,\
    \ Neves, S., Wilcox-O'Hearn, Z., and C.\n              Winnerlein, \"BLAKE2: simpler,\
    \ smaller, fast as MD5\",\n              January 2013, <https://blake2.net/blake2.pdf>.\n\
    \   [FIPS140-2IG]\n              NIST, \"Implementation Guidance for FIPS PUB\
    \ 140-2 and the\n              Cryptographic Module Validation Program\", September\
    \ 2015,\n              <http://csrc.nist.gov/groups/STM/cmvp/documents/fips140-2/\n\
    \              FIPS1402IG.pdf/>.\n   [RFC6151]  Turner, S. and L. Chen, \"Updated\
    \ Security Considerations\n              for the MD5 Message-Digest and the HMAC-MD5\
    \ Algorithms\",\n              RFC 6151, DOI 10.17487/RFC6151, March 2011,\n \
    \             <http://www.rfc-editor.org/info/rfc6151>.\n   [RFC6234]  Eastlake\
    \ 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n              (SHA and SHA-based\
    \ HMAC and HKDF)\", RFC 6234,\n              DOI 10.17487/RFC6234, May 2011,\n\
    \              <http://www.rfc-editor.org/info/rfc6234>.\n"
- title: Appendix A.  Example of BLAKE2b Computation
  contents:
  - "Appendix A.  Example of BLAKE2b Computation\n   We compute the unkeyed hash of\
    \ three ASCII bytes \"abc\" with\n   BLAKE2b-512 and show internal values during\
    \ computation.\n          m[16] = 0000000000636261 0000000000000000 0000000000000000\n\
    \                  0000000000000000 0000000000000000 0000000000000000\n      \
    \            0000000000000000 0000000000000000 0000000000000000\n            \
    \      0000000000000000 0000000000000000 0000000000000000\n                  0000000000000000\
    \ 0000000000000000 0000000000000000\n                  0000000000000000\n   (i=\
    \ 0) v[16] = 6A09E667F2BDC948 BB67AE8584CAA73B 3C6EF372FE94F82B\n            \
    \      A54FF53A5F1D36F1 510E527FADE682D1 9B05688C2B3E6C1F\n                  1F83D9ABFB41BD6B\
    \ 5BE0CD19137E2179 6A09E667F3BCC908\n                  BB67AE8584CAA73B 3C6EF372FE94F82B\
    \ A54FF53A5F1D36F1\n                  510E527FADE682D2 9B05688C2B3E6C1F E07C265404BE4294\n\
    \                  5BE0CD19137E2179\n   (i= 1) v[16] = 86B7C1568029BB79 C12CBCC809FF59F3\
    \ C6A5214CC0EACA8E\n                  0C87CD524C14CC5D 44EE6039BD86A9F7 A447C850AA694A7E\n\
    \                  DE080F1BB1C0F84B 595CB8A9A1ACA66C BEC3AE837EAC4887\n      \
    \            6267FC79DF9D6AD1 FA87B01273FA6DBE 521A715C63E08D8A\n            \
    \      E02D0975B8D37A83 1C7B754F08B7D193 8F885A76B6E578FE\n                  2318A24E2140FC64\n\
    \   (i= 2) v[16] = 53281E83806010F2 3594B403F81B4393 8CD63C7462DE0DFF\n      \
    \            85F693F3DA53F974 BAABDBB2F386D9AE CA5425AEC65A10A8\n            \
    \      C6A22E2FF0F7AA48 C6A56A51CB89C595 224E6A3369224F96\n                  500E125E58A92923\
    \ E9E4AD0D0E1A0D48 85DF9DC143C59A74\n                  92A3AAAA6D952B7F C5FDF71090FAE853\
    \ 2A8A40F15A462DD0\n                  572D17EFFDD37358\n   (i= 3) v[16] = 60ED96AA7AD41725\
    \ E46A743C71800B9D 1A04B543A01F156B\n                  A2F8716E775C4877 DA0A61BCDE4267EA\
    \ B1DD230754D7BDEE\n                  25A1422779E06D14 E6823AE4C3FF58A5 A1677E19F37FD5DA\n\
    \                  22BDCE6976B08C51 F1DE8696BEC11BF1 A0EBD586A4A1D2C8\n      \
    \            C804EBAB11C99FA9 8E0CEC959C715793 7C45557FAE0D4D89\n            \
    \      716343F52FDD265E\n   (i= 4) v[16] = BB2A77D3A8382351 45EB47971F23B103 98BE297F6E45C684\n\
    \                  A36077DEE3370B89 8A03C4CB7E97590A 24192E49EBF54EA0\n      \
    \            4F82C9401CB32D7A 8CCD013726420DC4 A9C9A8F17B1FC614\n            \
    \      55908187977514A0 5B44273E66B19D27 B6D5C9FCA2579327\n                  086092CFB858437E\
    \ 5C4BE2156DBEECF9 2EFEDE99ED4EFF16\n                  3E7B5F234CD1F804\n   (i=\
    \ 5) v[16] = C79C15B3D423B099 2DA2224E8DA97556 77D2B26DF1C45C55\n            \
    \      8934EB09A3456052 0F6D9EEED157DA2A 6FE66467AF88C0A9\n                  4EB0B76284C7AAFB\
    \ 299C8E725D954697 B2240B59E6D567D3\n                  2643C2370E49EBFD 79E02EEF20CDB1AE\
    \ 64B3EED7BB602F39\n                  B97D2D439E4DF63D C718E755294C9111 1F0893F2772BB373\n\
    \                  1205EA4A7859807D\n   (i= 6) v[16] = E58F97D6385BAEE4 7640AA9764DA137A\
    \ DEB4C7C23EFE287E\n                  70F6F41C8783C9F6 7127CD48C76A7708 9E472AF0BE3DB3F6\n\
    \                  0F244C62DDF71788 219828AA83880842 41CCA9073C8C4D0D\n      \
    \            5C7912BC10DF3B4B A2C3ABBD37510EE2 CB5668CC2A9F7859\n            \
    \      8733794F07AC1500 C67A6BE42335AA6F ACB22B28681E4C82\n                  DB2161604CBC9828\n\
    \   (i= 7) v[16] = 6E2D286EEADEDC81 BCF02C0787E86358 57D56A56DD015EDF\n      \
    \            55D899D40A5D0D0A 819415B56220C459 B63C479A6A769F02\n            \
    \      258E55E0EC1F362A 3A3B4EC60E19DFDC 04D769B3FCB048DB\n                  B78A9A33E9BFF4DD\
    \ 5777272AE1E930C0 5A387849E578DBF6\n                  92AAC307CF2C0AFC 30AACCC4F06DAFAA\
    \ 483893CC094F8863\n                  E03C6CC89C26BF92\n   (i= 8) v[16] = FFC83ECE76024D01\
    \ 1BE7BFFB8C5CC5F9 A35A18CBAC4C65B7\n                  B7C2C7E6D88C285F 81937DA314A50838\
    \ E1179523A2541963\n                  3A1FAD7106232B8F 1C7EDE92AB8B9C46 A3C2D35E4F685C10\n\
    \                  A53D3F73AA619624 30BBCC0285A22F65 BCEFBB6A81539E5D\n      \
    \            3841DEF6F4C9848A 98662C85FBA726D4 7762439BD5A851BD\n            \
    \      B0B9F0D443D1A889\n   (i= 9) v[16] = 753A70A1E8FAEADD 6B0D43CA2C25D629 F8343BA8B94F8C0B\n\
    \                  BC7D062B0DB5CF35 58540EE1B1AEBC47 63C5B9B80D294CB9\n      \
    \            490870ECAD27DEBD B2A90DDF667287FE 316CC9EBEEFAD8FC\n            \
    \      4A466BCD021526A4 5DA7F7638CEC5669 D9C8826727D306FC\n                  88ED6C4F3BD7A537\
    \ 19AE688DDF67F026 4D8707AAB40F7E6D\n                  FD3F572687FEA4F1\n   (i=10)\
    \ v[16] = E630C747CCD59C4F BC713D41127571CA 46DB183025025078\n               \
    \   6727E81260610140 2D04185EAC2A8CBA 5F311B88904056EC\n                  40BD313009201AAB\
    \ 0099D4F82A2A1EAB 6DD4FBC1DE60165D\n                  B3B0B51DE3C86270 900AEE2F233B08E5\
    \ A07199D87AD058D8\n                  2C6B25593D717852 37E8CA471BEAA5F8 2CFC1BAC10EF4457\n\
    \                  01369EC18746E775\n   (i=11) v[16] = E801F73B9768C760 35C6D22320BE511D\
    \ 306F27584F65495E\n                  B51776ADF569A77B F4F1BE86690B3C34 3CC88735D1475E4B\n\
    \                  5DAC67921FF76949 1CDB9D31AD70CC4E 35BA354A9C7DF448\n      \
    \            4929CBE45679D73E 733D1A17248F39DB 92D57B736F5F170A\n            \
    \      61B5C0A41D491399 B5C333457E12844A BD696BE010D0D889\n                  02231E1A917FE0BD\n\
    \   (i=12) v[16] = 12EF8A641EC4F6D6 BCED5DE977C9FAF5 733CA476C5148639\n      \
    \            97DF596B0610F6FC F42C16519AD5AFA7 AA5AC1888E10467E\n            \
    \      217D930AA51787F3 906A6FF19E573942 75AB709BD3DCBF24\n                  EE7CE1F345947AA4\
    \ F8960D6C2FAF5F5E E332538A36B6D246\n                  885BEF040EF6AA0B A4939A417BFB78A3\
    \ 646CBB7AF6DCE980\n                  E813A23C60AF3B82\n           h[8] = 0D4D1C983FA580BA\
    \ E9F6129FB697276A B7C45A68142F214C\n                  D1A2FFDB6FBB124B 2D79AB2A39C5877D\
    \ 95CC3345DED552C2\n                  5A92F1DBA88AD318 239900D4ED8623B9\n   BLAKE2b-512(\"\
    abc\") = BA 80 A5 3F 98 1C 4D 0D 6A 27 97 B6 9F 12 F6 E9\n                   \
    \     4C 21 2F 14 68 5A C4 B7 4B 12 BB 6F DB FF A2 D1\n                      \
    \  7D 87 C5 39 2A AB 79 2D C2 52 D5 DE 45 33 CC 95\n                        18\
    \ D3 8A A8 DB F1 92 5A B9 23 86 ED D4 00 99 23\n"
- title: Appendix B.  Example of BLAKE2s Computation
  contents:
  - "Appendix B.  Example of BLAKE2s Computation\n   We compute the unkeyed hash of\
    \ three ASCII bytes \"abc\" with\n   BLAKE2s-256 and show internal values during\
    \ computation.\n          m[16] = 00636261 00000000 00000000 00000000 00000000\
    \ 00000000\n                  00000000 00000000 00000000 00000000 00000000 00000000\n\
    \                  00000000 00000000 00000000 00000000\n   (i=0)  v[16] = 6B08E647\
    \ BB67AE85 3C6EF372 A54FF53A 510E527F 9B05688C\n                  1F83D9AB 5BE0CD19\
    \ 6A09E667 BB67AE85 3C6EF372 A54FF53A\n                  510E527C 9B05688C E07C2654\
    \ 5BE0CD19\n   (i=1)  v[16] = 16A3242E D7B5E238 CE8CE24B 927AEDE1 A7B430D9 93A4A14E\n\
    \                  A44E7C31 41D4759B 95BF33D3 9A99C181 608A3A6B B666383E\n   \
    \               7A8DD50F BE378ED7 353D1EE6 3BB44C6B\n   (i=2)  v[16] = 3AE30FE3\
    \ 0982A96B E88185B4 3E339B16 F24338CD 0E66D326\n                  E005ED0C D591A277\
    \ 180B1F3A FCF43914 30DB62D6 4847831C\n                  7F00C58E FB847886 C544E836\
    \ 524AB0E2\n   (i=3)  v[16] = 7A3BE783 997546C1 D45246DF EDB5F821 7F98A742 10E864E2\n\
    \                  D4AB70D0 C63CB1AB 6038DA9E 414594B0 F2C218B5 8DA0DCB7\n   \
    \               D7CD7AF5 AB4909DF 85031A52 C4EDFC98\n   (i=4)  v[16] = 2A8B8CB7\
    \ 1ACA82B2 14045D7F CC7258ED 383CF67C E090E7F9\n                  3025D276 57D04DE4\
    \ 994BACF0 F0982759 F17EE300 D48FC2D5\n                  DC854C10 523898A9 C03A0F89\
    \ 47D6CD88\n   (i=5)  v[16] = C4AA2DDB 111343A3 D54A700A 574A00A9 857D5A48 B1E11989\n\
    \                  6F5C52DF DD2C53A3 678E5F8E 9718D4E9 622CB684 92976076\n   \
    \               0E41A517 359DC2BE 87A87DDD 643F9CEC\n   (i=6)  v[16] = 3453921C\
    \ D7595EE1 592E776D 3ED6A974 4D997CB3 DE9212C3\n                  35ADF5C9 9916FD65\
    \ 96562E89 4EAD0792 EBFC2712 2385F5B2\n                  F34600FB D7BC20FB EB452A7B\
    \ ECE1AA40\n   (i=7)  v[16] = BE851B2D A85F6358 81E6FC3B 0BB28000 FA55A33A 87BE1FAD\n\
    \                  4119370F 1E2261AA A1318FD3 F4329816 071783C2 6E536A8D\n   \
    \               9A81A601 E7EC80F1 ACC09948 F849A584\n   (i=8)  v[16] = 07E5B85A\
    \ 069CC164 F9DE3141 A56F4680 9E440AD2 9AB659EA\n                  3C84B971 21DBD9CF\
    \ 46699F8C 765257EC AF1D998C 75E4C3B6\n                  523878DC 30715015 397FEE81\
    \ 4F1FA799\n   (i=9)  v[16] = 435148C4 A5AA2D11 4B354173 D543BC9E BDA2591C BF1D2569\n\
    \                  4FCB3120 707ADA48 565B3FDE 32C9C916 EAF4A1AB B1018F28\n   \
    \               8078D978 68ADE4B5 9778FDA3 2863B92E\n   (i=10) v[16] = D9C994AA\
    \ CFEC3AA6 700D0AB2 2C38670E AF6A1F66 1D023EF3\n                  1D9EC27D 945357A5\
    \ 3E9FFEBD 969FE811 EF485E21 A632797A\n                  DEEF082E AF3D80E1 4E86829B\
    \ 4DEAFD3A\n           h[8] = 8C5E8C50 E2147C32 A32BA7E1 2F45EB4E 208B4537 293AD69E\n\
    \                  4C9B994D 82596786\n   BLAKE2s-256(\"abc\") = 50 8C 5E 8C 32\
    \ 7C 14 E2 E1 A7 2B A3 4E EB 45 2F\n                        37 45 8B 20 9E D6\
    \ 3A 29 4D 99 9B 4C 86 67 59 82\n"
- title: Appendix C.  BLAKE2b Implementation C Source
  contents:
  - 'Appendix C.  BLAKE2b Implementation C Source

    '
- title: C.1.  blake2b.h
  contents:
  - "C.1.  blake2b.h\n   <CODE BEGINS>\n   // blake2b.h\n   // BLAKE2b Hashing Context\
    \ and API Prototypes\n   #ifndef BLAKE2B_H\n   #define BLAKE2B_H\n   #include\
    \ <stdint.h>\n   #include <stddef.h>\n   // state context\n   typedef struct {\n\
    \       uint8_t b[128];                     // input buffer\n       uint64_t h[8];\
    \                      // chained state\n       uint64_t t[2];               \
    \       // total number of bytes\n       size_t c;                           //\
    \ pointer for b[]\n       size_t outlen;                      // digest size\n\
    \   } blake2b_ctx;\n   // Initialize the hashing context \"ctx\" with optional\
    \ key \"key\".\n   //      1 <= outlen <= 64 gives the digest size in bytes.\n\
    \   //      Secret key (also <= 64 bytes) is optional (keylen = 0).\n   int blake2b_init(blake2b_ctx\
    \ *ctx, size_t outlen,\n       const void *key, size_t keylen);    // secret key\n\
    \   // Add \"inlen\" bytes from \"in\" into the hash.\n   void blake2b_update(blake2b_ctx\
    \ *ctx,   // context\n       const void *in, size_t inlen);      // data to be\
    \ hashed\n   // Generate the message digest (size given in init).\n   //     \
    \ Result placed in \"out\".\n   void blake2b_final(blake2b_ctx *ctx, void *out);\n\
    \   // All-in-one convenience function.\n   int blake2b(void *out, size_t outlen,\
    \   // return buffer for digest\n       const void *key, size_t keylen,     //\
    \ optional secret key\n       const void *in, size_t inlen);      // data to be\
    \ hashed\n   #endif\n   <CODE ENDS>\n"
- title: C.2.  blake2b.c
  contents:
  - "C.2.  blake2b.c\n   <CODE BEGINS>\n   // blake2b.c\n   // A simple BLAKE2b Reference\
    \ Implementation.\n   #include \"blake2b.h\"\n   // Cyclic right rotation.\n \
    \  #ifndef ROTR64\n   #define ROTR64(x, y)  (((x) >> (y)) ^ ((x) << (64 - (y))))\n\
    \   #endif\n   // Little-endian byte access.\n   #define B2B_GET64(p)        \
    \                    \\\n       (((uint64_t) ((uint8_t *) (p))[0]) ^        \\\
    \n       (((uint64_t) ((uint8_t *) (p))[1]) << 8) ^  \\\n       (((uint64_t) ((uint8_t\
    \ *) (p))[2]) << 16) ^ \\\n       (((uint64_t) ((uint8_t *) (p))[3]) << 24) ^\
    \ \\\n       (((uint64_t) ((uint8_t *) (p))[4]) << 32) ^ \\\n       (((uint64_t)\
    \ ((uint8_t *) (p))[5]) << 40) ^ \\\n       (((uint64_t) ((uint8_t *) (p))[6])\
    \ << 48) ^ \\\n       (((uint64_t) ((uint8_t *) (p))[7]) << 56))\n   // G Mixing\
    \ function.\n   #define B2B_G(a, b, c, d, x, y) {   \\\n       v[a] = v[a] + v[b]\
    \ + x;         \\\n       v[d] = ROTR64(v[d] ^ v[a], 32); \\\n       v[c] = v[c]\
    \ + v[d];             \\\n       v[b] = ROTR64(v[b] ^ v[c], 24); \\\n       v[a]\
    \ = v[a] + v[b] + y;         \\\n       v[d] = ROTR64(v[d] ^ v[a], 16); \\\n \
    \      v[c] = v[c] + v[d];             \\\n       v[b] = ROTR64(v[b] ^ v[c], 63);\
    \ }\n   // Initialization Vector.\n   static const uint64_t blake2b_iv[8] = {\n\
    \       0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,\n       0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,\n\
    \       0x510E527FADE682D1, 0x9B05688C2B3E6C1F,\n       0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179\n\
    \   };\n   // Compression function. \"last\" flag indicates last block.\n   static\
    \ void blake2b_compress(blake2b_ctx *ctx, int last)\n   {\n       const uint8_t\
    \ sigma[12][16] = {\n           { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15 },\n           { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3\
    \ },\n           { 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },\n \
    \          { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },\n       \
    \    { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },\n           { 2,\
    \ 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },\n           { 12, 5, 1,\
    \ 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },\n           { 13, 11, 7, 14, 12,\
    \ 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },\n           { 6, 15, 14, 9, 11, 3, 0, 8,\
    \ 12, 2, 13, 7, 1, 4, 10, 5 },\n           { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11,\
    \ 9, 14, 3, 12, 13, 0 },\n           { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14, 15 },\n           { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7,\
    \ 5, 3 }\n       };\n       int i;\n       uint64_t v[16], m[16];\n       for\
    \ (i = 0; i < 8; i++) {           // init work variables\n           v[i] = ctx->h[i];\n\
    \           v[i + 8] = blake2b_iv[i];\n       }\n       v[12] ^= ctx->t[0];  \
    \               // low 64 bits of offset\n       v[13] ^= ctx->t[1];         \
    \        // high 64 bits\n       if (last)                           // last block\
    \ flag set ?\n           v[14] = ~v[14];\n       for (i = 0; i < 16; i++)    \
    \        // get little-endian words\n           m[i] = B2B_GET64(&ctx->b[8 * i]);\n\
    \       for (i = 0; i < 12; i++) {          // twelve rounds\n           B2B_G(\
    \ 0, 4,  8, 12, m[sigma[i][ 0]], m[sigma[i][ 1]]);\n           B2B_G( 1, 5,  9,\
    \ 13, m[sigma[i][ 2]], m[sigma[i][ 3]]);\n           B2B_G( 2, 6, 10, 14, m[sigma[i][\
    \ 4]], m[sigma[i][ 5]]);\n           B2B_G( 3, 7, 11, 15, m[sigma[i][ 6]], m[sigma[i][\
    \ 7]]);\n           B2B_G( 0, 5, 10, 15, m[sigma[i][ 8]], m[sigma[i][ 9]]);\n\
    \           B2B_G( 1, 6, 11, 12, m[sigma[i][10]], m[sigma[i][11]]);\n        \
    \   B2B_G( 2, 7,  8, 13, m[sigma[i][12]], m[sigma[i][13]]);\n           B2B_G(\
    \ 3, 4,  9, 14, m[sigma[i][14]], m[sigma[i][15]]);\n       }\n       for( i =\
    \ 0; i < 8; ++i )\n           ctx->h[i] ^= v[i] ^ v[i + 8];\n   }\n   // Initialize\
    \ the hashing context \"ctx\" with optional key \"key\".\n   //      1 <= outlen\
    \ <= 64 gives the digest size in bytes.\n   //      Secret key (also <= 64 bytes)\
    \ is optional (keylen = 0).\n   int blake2b_init(blake2b_ctx *ctx, size_t outlen,\n\
    \       const void *key, size_t keylen)        // (keylen=0: no key)\n   {\n \
    \      size_t i;\n       if (outlen == 0 || outlen > 64 || keylen > 64)\n    \
    \       return -1;                      // illegal parameters\n       for (i =\
    \ 0; i < 8; i++)             // state, \"param block\"\n           ctx->h[i] =\
    \ blake2b_iv[i];\n       ctx->h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;\n \
    \      ctx->t[0] = 0;                      // input count low word\n       ctx->t[1]\
    \ = 0;                      // input count high word\n       ctx->c = 0;     \
    \                    // pointer within buffer\n       ctx->outlen = outlen;\n\
    \       for (i = keylen; i < 128; i++)      // zero input block\n           ctx->b[i]\
    \ = 0;\n       if (keylen > 0) {\n           blake2b_update(ctx, key, keylen);\n\
    \           ctx->c = 128;                   // at the end\n       }\n       return\
    \ 0;\n   }\n   // Add \"inlen\" bytes from \"in\" into the hash.\n   void blake2b_update(blake2b_ctx\
    \ *ctx,\n       const void *in, size_t inlen)       // data bytes\n   {\n    \
    \   size_t i;\n       for (i = 0; i < inlen; i++) {\n           if (ctx->c ==\
    \ 128) {            // buffer full ?\n               ctx->t[0] += ctx->c;    \
    \    // add counters\n               if (ctx->t[0] < ctx->c)     // carry overflow\
    \ ?\n                   ctx->t[1]++;            // high word\n               blake2b_compress(ctx,\
    \ 0);   // compress (not last)\n               ctx->c = 0;                 //\
    \ counter to zero\n           }\n           ctx->b[ctx->c++] = ((const uint8_t\
    \ *) in)[i];\n       }\n   }\n   // Generate the message digest (size given in\
    \ init).\n   //      Result placed in \"out\".\n   void blake2b_final(blake2b_ctx\
    \ *ctx, void *out)\n   {\n       size_t i;\n       ctx->t[0] += ctx->c;      \
    \          // mark last block offset\n       if (ctx->t[0] < ctx->c)         \
    \    // carry overflow\n           ctx->t[1]++;                    // high word\n\
    \       while (ctx->c < 128)                // fill up with zeros\n          \
    \ ctx->b[ctx->c++] = 0;\n       blake2b_compress(ctx, 1);           // final block\
    \ flag = 1\n       // little endian convert and store\n       for (i = 0; i <\
    \ ctx->outlen; i++) {\n           ((uint8_t *) out)[i] =\n               (ctx->h[i\
    \ >> 3] >> (8 * (i & 7))) & 0xFF;\n       }\n   }\n   // Convenience function\
    \ for all-in-one computation.\n   int blake2b(void *out, size_t outlen,\n    \
    \   const void *key, size_t keylen,\n       const void *in, size_t inlen)\n  \
    \ {\n       blake2b_ctx ctx;\n       if (blake2b_init(&ctx, outlen, key, keylen))\n\
    \           return -1;\n       blake2b_update(&ctx, in, inlen);\n       blake2b_final(&ctx,\
    \ out);\n       return 0;\n   }\n   <CODE ENDS>\n"
- title: Appendix D.  BLAKE2s Implementation C Source
  contents:
  - 'Appendix D.  BLAKE2s Implementation C Source

    '
- title: D.1.  blake2s.h
  contents:
  - "D.1.  blake2s.h\n   <CODE BEGINS>\n   // blake2s.h\n   // BLAKE2s Hashing Context\
    \ and API Prototypes\n   #ifndef BLAKE2S_H\n   #define BLAKE2S_H\n   #include\
    \ <stdint.h>\n   #include <stddef.h>\n   // state context\n   typedef struct {\n\
    \       uint8_t b[64];                      // input buffer\n       uint32_t h[8];\
    \                      // chained state\n       uint32_t t[2];               \
    \       // total number of bytes\n       size_t c;                           //\
    \ pointer for b[]\n       size_t outlen;                      // digest size\n\
    \   } blake2s_ctx;\n   // Initialize the hashing context \"ctx\" with optional\
    \ key \"key\".\n   //      1 <= outlen <= 32 gives the digest size in bytes.\n\
    \   //      Secret key (also <= 32 bytes) is optional (keylen = 0).\n   int blake2s_init(blake2s_ctx\
    \ *ctx, size_t outlen,\n       const void *key, size_t keylen);    // secret key\n\
    \   // Add \"inlen\" bytes from \"in\" into the hash.\n   void blake2s_update(blake2s_ctx\
    \ *ctx,   // context\n       const void *in, size_t inlen);      // data to be\
    \ hashed\n   // Generate the message digest (size given in init).\n   //     \
    \ Result placed in \"out\".\n   void blake2s_final(blake2s_ctx *ctx, void *out);\n\
    \   // All-in-one convenience function.\n   int blake2s(void *out, size_t outlen,\
    \   // return buffer for digest\n       const void *key, size_t keylen,     //\
    \ optional secret key\n       const void *in, size_t inlen);      // data to be\
    \ hashed\n   #endif\n   <CODE ENDS>\n"
- title: D.2.  blake2s.c
  contents:
  - "D.2.  blake2s.c\n   <CODE BEGINS>\n   // blake2s.c\n   // A simple blake2s Reference\
    \ Implementation.\n   #include \"blake2s.h\"\n   // Cyclic right rotation.\n \
    \  #ifndef ROTR32\n   #define ROTR32(x, y)  (((x) >> (y)) ^ ((x) << (32 - (y))))\n\
    \   #endif\n   // Little-endian byte access.\n   #define B2S_GET32(p)        \
    \                    \\\n       (((uint32_t) ((uint8_t *) (p))[0]) ^        \\\
    \n       (((uint32_t) ((uint8_t *) (p))[1]) << 8) ^  \\\n       (((uint32_t) ((uint8_t\
    \ *) (p))[2]) << 16) ^ \\\n       (((uint32_t) ((uint8_t *) (p))[3]) << 24))\n\
    \   // Mixing function G.\n   #define B2S_G(a, b, c, d, x, y) {   \\\n       v[a]\
    \ = v[a] + v[b] + x;         \\\n       v[d] = ROTR32(v[d] ^ v[a], 16); \\\n \
    \      v[c] = v[c] + v[d];             \\\n       v[b] = ROTR32(v[b] ^ v[c], 12);\
    \ \\\n       v[a] = v[a] + v[b] + y;         \\\n       v[d] = ROTR32(v[d] ^ v[a],\
    \ 8);  \\\n       v[c] = v[c] + v[d];             \\\n       v[b] = ROTR32(v[b]\
    \ ^ v[c], 7); }\n   // Initialization Vector.\n   static const uint32_t blake2s_iv[8]\
    \ =\n   {\n       0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n       0x510E527F,\
    \ 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n   };\n   // Compression function. \"last\"\
    \ flag indicates last block.\n   static void blake2s_compress(blake2s_ctx *ctx,\
    \ int last)\n   {\n       const uint8_t sigma[10][16] = {\n           { 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },\n           { 14, 10, 4, 8,\
    \ 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },\n           { 11, 8, 12, 0, 5, 2,\
    \ 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },\n           { 7, 9, 3, 1, 13, 12, 11, 14,\
    \ 2, 6, 5, 10, 4, 0, 15, 8 },\n           { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11,\
    \ 12, 6, 8, 3, 13 },\n           { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15,\
    \ 14, 1, 9 },\n           { 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8,\
    \ 11 },\n           { 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },\n\
    \           { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },\n      \
    \     { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 }\n       };\n  \
    \     int i;\n       uint32_t v[16], m[16];\n       for (i = 0; i < 8; i++) {\
    \           // init work variables\n           v[i] = ctx->h[i];\n           v[i\
    \ + 8] = blake2s_iv[i];\n       }\n       v[12] ^= ctx->t[0];                \
    \ // low 32 bits of offset\n       v[13] ^= ctx->t[1];                 // high\
    \ 32 bits\n       if (last)                           // last block flag set ?\n\
    \           v[14] = ~v[14];\n       for (i = 0; i < 16; i++)            // get\
    \ little-endian words\n           m[i] = B2S_GET32(&ctx->b[4 * i]);\n       for\
    \ (i = 0; i < 10; i++) {          // ten rounds\n           B2S_G( 0, 4,  8, 12,\
    \ m[sigma[i][ 0]], m[sigma[i][ 1]]);\n           B2S_G( 1, 5,  9, 13, m[sigma[i][\
    \ 2]], m[sigma[i][ 3]]);\n           B2S_G( 2, 6, 10, 14, m[sigma[i][ 4]], m[sigma[i][\
    \ 5]]);\n           B2S_G( 3, 7, 11, 15, m[sigma[i][ 6]], m[sigma[i][ 7]]);\n\
    \           B2S_G( 0, 5, 10, 15, m[sigma[i][ 8]], m[sigma[i][ 9]]);\n        \
    \   B2S_G( 1, 6, 11, 12, m[sigma[i][10]], m[sigma[i][11]]);\n           B2S_G(\
    \ 2, 7,  8, 13, m[sigma[i][12]], m[sigma[i][13]]);\n           B2S_G( 3, 4,  9,\
    \ 14, m[sigma[i][14]], m[sigma[i][15]]);\n       }\n       for( i = 0; i < 8;\
    \ ++i )\n           ctx->h[i] ^= v[i] ^ v[i + 8];\n   }\n   // Initialize the\
    \ hashing context \"ctx\" with optional key \"key\".\n   //      1 <= outlen <=\
    \ 32 gives the digest size in bytes.\n   //      Secret key (also <= 32 bytes)\
    \ is optional (keylen = 0).\n   int blake2s_init(blake2s_ctx *ctx, size_t outlen,\n\
    \       const void *key, size_t keylen)     // (keylen=0: no key)\n   {\n    \
    \   size_t i;\n       if (outlen == 0 || outlen > 32 || keylen > 32)\n       \
    \    return -1;                      // illegal parameters\n       for (i = 0;\
    \ i < 8; i++)             // state, \"param block\"\n           ctx->h[i] = blake2s_iv[i];\n\
    \       ctx->h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;\n       ctx->t[0] =\
    \ 0;                      // input count low word\n       ctx->t[1] = 0;     \
    \                 // input count high word\n       ctx->c = 0;               \
    \          // pointer within buffer\n       ctx->outlen = outlen;\n       for\
    \ (i = keylen; i < 64; i++)       // zero input block\n           ctx->b[i] =\
    \ 0;\n       if (keylen > 0) {\n           blake2s_update(ctx, key, keylen);\n\
    \           ctx->c = 64;                    // at the end\n       }\n       return\
    \ 0;\n   }\n   // Add \"inlen\" bytes from \"in\" into the hash.\n   void blake2s_update(blake2s_ctx\
    \ *ctx,\n       const void *in, size_t inlen)       // data bytes\n   {\n    \
    \   size_t i;\n       for (i = 0; i < inlen; i++) {\n           if (ctx->c ==\
    \ 64) {             // buffer full ?\n               ctx->t[0] += ctx->c;    \
    \    // add counters\n               if (ctx->t[0] < ctx->c)     // carry overflow\
    \ ?\n                   ctx->t[1]++;            // high word\n               blake2s_compress(ctx,\
    \ 0);   // compress (not last)\n               ctx->c = 0;                 //\
    \ counter to zero\n           }\n           ctx->b[ctx->c++] = ((const uint8_t\
    \ *) in)[i];\n       }\n   }\n   // Generate the message digest (size given in\
    \ init).\n   //      Result placed in \"out\".\n   void blake2s_final(blake2s_ctx\
    \ *ctx, void *out)\n   {\n       size_t i;\n       ctx->t[0] += ctx->c;      \
    \          // mark last block offset\n       if (ctx->t[0] < ctx->c)         \
    \    // carry overflow\n           ctx->t[1]++;                    // high word\n\
    \       while (ctx->c < 64)                 // fill up with zeros\n          \
    \ ctx->b[ctx->c++] = 0;\n       blake2s_compress(ctx, 1);           // final block\
    \ flag = 1\n       // little endian convert and store\n       for (i = 0; i <\
    \ ctx->outlen; i++) {\n           ((uint8_t *) out)[i] =\n               (ctx->h[i\
    \ >> 2] >> (8 * (i & 3))) & 0xFF;\n       }\n   }\n   // Convenience function\
    \ for all-in-one computation.\n   int blake2s(void *out, size_t outlen,\n    \
    \   const void *key, size_t keylen,\n       const void *in, size_t inlen)\n  \
    \ {\n       blake2s_ctx ctx;\n       if (blake2s_init(&ctx, outlen, key, keylen))\n\
    \           return -1;\n       blake2s_update(&ctx, in, inlen);\n       blake2s_final(&ctx,\
    \ out);\n       return 0;\n   }\n   <CODE ENDS>\n"
- title: Appendix E.  BLAKE2b and BLAKE2s Self-Test Module C Source
  contents:
  - "Appendix E.  BLAKE2b and BLAKE2s Self-Test Module C Source\n   This module computes\
    \ a series of keyed and unkeyed hashes from\n   deterministically generated pseudorandom\
    \ data and computes a hash\n   over those results.  This is a fairly exhaustive,\
    \ yet compact and\n   fast method for verifying that the hashing module is functioning\n\
    \   correctly.\n   Such testing is RECOMMENDED, especially when compiling the\n\
    \   implementation for a new a target platform configuration.\n   Furthermore,\
    \ some security standards, such as FIPS-140, may require a\n   Power-On Self Test\
    \ (POST) to be performed every time the\n   cryptographic module is loaded [FIPS140-2IG].\n\
    \   <CODE BEGINS>\n   // test_main.c\n   // Self test Modules for BLAKE2b and\
    \ BLAKE2s -- and a stub main().\n   #include <stdio.h>\n   #include \"blake2b.h\"\
    \n   #include \"blake2s.h\"\n   // Deterministic sequences (Fibonacci generator).\n\
    \   static void selftest_seq(uint8_t *out, size_t len, uint32_t seed)\n   {\n\
    \       size_t i;\n       uint32_t t, a , b;\n       a = 0xDEAD4BAD * seed;  \
    \            // prime\n       b = 1;\n       for (i = 0; i < len; i++) {     \
    \    // fill the buf\n           t = a + b;\n           a = b;\n           b =\
    \ t;\n           out[i] = (t >> 24) & 0xFF;\n       }\n   }\n   // BLAKE2b self-test\
    \ validation. Return 0 when OK.\n   int blake2b_selftest()\n   {\n       // grand\
    \ hash of hash results\n       const uint8_t blake2b_res[32] = {\n           0xC2,\
    \ 0x3A, 0x78, 0x00, 0xD9, 0x81, 0x23, 0xBD,\n           0x10, 0xF5, 0x06, 0xC6,\
    \ 0x1E, 0x29, 0xDA, 0x56,\n           0x03, 0xD7, 0x63, 0xB8, 0xBB, 0xAD, 0x2E,\
    \ 0x73,\n           0x7F, 0x5E, 0x76, 0x5A, 0x7B, 0xCC, 0xD4, 0x75\n       };\n\
    \       // parameter sets\n       const size_t b2b_md_len[4] = { 20, 32, 48, 64\
    \ };\n       const size_t b2b_in_len[6] = { 0, 3, 128, 129, 255, 1024 };\n   \
    \    size_t i, j, outlen, inlen;\n       uint8_t in[1024], md[64], key[64];\n\
    \       blake2b_ctx ctx;\n       // 256-bit hash for testing\n       if (blake2b_init(&ctx,\
    \ 32, NULL, 0))\n           return -1;\n       for (i = 0; i < 4; i++) {\n   \
    \        outlen = b2b_md_len[i];\n           for (j = 0; j < 6; j++) {\n     \
    \          inlen = b2b_in_len[j];\n               selftest_seq(in, inlen, inlen);\
    \     // unkeyed hash\n               blake2b(md, outlen, NULL, 0, in, inlen);\n\
    \               blake2b_update(&ctx, md, outlen);   // hash the hash\n       \
    \        selftest_seq(key, outlen, outlen);  // keyed hash\n               blake2b(md,\
    \ outlen, key, outlen, in, inlen);\n               blake2b_update(&ctx, md, outlen);\
    \   // hash the hash\n           }\n       }\n       // compute and compare the\
    \ hash of hashes\n       blake2b_final(&ctx, md);\n       for (i = 0; i < 32;\
    \ i++) {\n           if (md[i] != blake2b_res[i])\n               return -1;\n\
    \       }\n       return 0;\n   }\n   // BLAKE2s self-test validation. Return\
    \ 0 when OK.\n   int blake2s_selftest()\n   {\n       // Grand hash of hash results.\n\
    \       const uint8_t blake2s_res[32] = {\n           0x6A, 0x41, 0x1F, 0x08,\
    \ 0xCE, 0x25, 0xAD, 0xCD,\n           0xFB, 0x02, 0xAB, 0xA6, 0x41, 0x45, 0x1C,\
    \ 0xEC,\n           0x53, 0xC5, 0x98, 0xB2, 0x4F, 0x4F, 0xC7, 0x87,\n        \
    \   0xFB, 0xDC, 0x88, 0x79, 0x7F, 0x4C, 0x1D, 0xFE\n       };\n       // Parameter\
    \ sets.\n       const size_t b2s_md_len[4] = { 16, 20, 28, 32 };\n       const\
    \ size_t b2s_in_len[6] = { 0,  3,  64, 65, 255, 1024 };\n       size_t i, j, outlen,\
    \ inlen;\n       uint8_t in[1024], md[32], key[32];\n       blake2s_ctx ctx;\n\
    \       // 256-bit hash for testing.\n       if (blake2s_init(&ctx, 32, NULL,\
    \ 0))\n           return -1;\n       for (i = 0; i < 4; i++) {\n           outlen\
    \ = b2s_md_len[i];\n           for (j = 0; j < 6; j++) {\n               inlen\
    \ = b2s_in_len[j];\n               selftest_seq(in, inlen, inlen);     // unkeyed\
    \ hash\n               blake2s(md, outlen, NULL, 0, in, inlen);\n            \
    \   blake2s_update(&ctx, md, outlen);   // hash the hash\n               selftest_seq(key,\
    \ outlen, outlen);  // keyed hash\n               blake2s(md, outlen, key, outlen,\
    \ in, inlen);\n               blake2s_update(&ctx, md, outlen);   // hash the\
    \ hash\n           }\n       }\n       // Compute and compare the hash of hashes.\n\
    \       blake2s_final(&ctx, md);\n       for (i = 0; i < 32; i++) {\n        \
    \   if (md[i] != blake2s_res[i])\n               return -1;\n       }\n      \
    \ return 0;\n   }\n   // Test driver.\n   int main(int argc, char **argv)\n  \
    \ {\n       printf(\"blake2b_selftest() = %s\\n\",\n            blake2b_selftest()\
    \ ? \"FAIL\" : \"OK\");\n       printf(\"blake2s_selftest() = %s\\n\",\n     \
    \       blake2s_selftest() ? \"FAIL\" : \"OK\");\n       return 0;\n   }\n   <CODE\
    \ ENDS>\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The editor wishes to thank the [BLAKE2] team for their encouragement:\n\
    \   Jean-Philippe Aumasson, Samuel Neves, Zooko Wilcox-O'Hearn, and\n   Christian\
    \ Winnerlein.  We have borrowed passages from [BLAKE] and\n   [BLAKE2] with permission.\n\
    \   [BLAKE2] is based on the SHA-3 proposal [BLAKE], designed by Jean-\n   Philippe\
    \ Aumasson, Luca Henzen, Willi Meier, and Raphael C.-W. Phan.\n   BLAKE2, like\
    \ BLAKE, relies on a core algorithm borrowed from the\n   ChaCha stream cipher,\
    \ designed by Daniel J. Bernstein.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Markku-Juhani O. Saarinen (editor)\n   Queen's University\
    \ Belfast\n   Centre for Secure Information Technologies, ECIT\n   Northern Ireland\
    \ Science Park\n   Queen's Road, Queen's Island\n   Belfast  BT3 9DT\n   United\
    \ Kingdom\n   Email: m.saarinen@qub.ac.uk\n   URI:   http://www.csit.qub.ac.uk\n\
    \   Jean-Philippe Aumasson\n   Kudelski Security\n   22-24, Route de Geneve\n\
    \   Case Postale 134\n   Cheseaux  1033\n   Switzerland\n   Email: jean-philippe.aumasson@nagra.com\n\
    \   URI:   https://www.kudelskisecurity.com\n"
