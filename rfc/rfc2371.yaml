- contents:
  - "                     Transaction Internet Protocol\n                              Version
    3.0\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   In many applications where different nodes cooperate on some work,\n
    \  there is a need to guarantee that the work happens atomically. That\n   is,
    each node must reach the same conclusion as to whether the work\n   is to be completed,
    even in the face of failures.  This document\n   proposes a simple, easily-implemented
    protocol for achieving this\n   end.\n"
  title: Abstract
- contents:
  - "Table of Contents\n 1. Introduction                                                       2\n
    2. Example Usage                                                      3\n 3. Transactions
    \                                                      4\n 4. Connections                                                        4\n
    5. Transaction Identifiers                                            5\n 6. Pushing
    vs. Pulling Transactions                                   5\n 7. TIP Transaction
    Manager Identification & Connection Establishment  6\n 8. TIP Uniform Resource
    Locators                                      8\n 9. States of a Connection                                            10\n
    10. Protocol Versioning                                              12\n 11.
    Commands and Responses                                           12\n 12. Command
    Pipelining                                               13\n 13. TIP Commands
    \                                                    13\n 14. Error Handling                                                   20\n
    15. Connection Failure and Recovery                                  20\n 16.
    Security Considerations                                          22\n 17. References
    \                                                      25\n 18. Authors' Addresses
    \                                              26\n 19. Comments                                                         26\n
    Appendix A. The TIP Multiplexing Protocol Version 2.0.               27\n Fully
    Copyright Statement                                            31\n"
  title: Table of Contents
- contents:
  - "1. Introduction\n   The standard method for achieving atomic commitment is the
    two-phase\n   commit protocol; see [1] for an introduction to atomic commitment
    and\n   two-phase commit protocols.\n   Numerous two-phase commit protocols have
    been implemented over the\n   years.  However, none of them has become widely
    used in the Internet,\n   due mainly to their complexity.  Most of that complexity
    comes from\n   the fact that the two-phase commit protocol is bundled together
    with\n   a specific program-to-program communication protocol, and that\n   protocol
    lives on top of a very large infrastructure.\n   This memo proposes a very simple
    two-phase commit protocol.  It\n   achieves its simplicity by specifying only
    how different nodes agree\n   on the outcome of a transaction; it allows (even
    requires) that the\n   subject matter on which the nodes are agreeing be communicated
    via\n   other protocols. By doing so, we avoid all of the issues related to\n
    \  application communication semantics and data representation (to name\n   just
    a few). Independent of the application communication protocol a\n   transaction
    manager may use the Transport Layer Security protocol [3]\n   to authenticate
    other transaction managers and encrypt messages.\n   It is envisioned that this
    protocol will be used mainly for a\n   transaction manager on one Internet node
    to communicate with a\n   transaction manager on another node. While it is possible
    to use this\n   protocol for application programs and/or resource managers to
    speak\n   to transaction managers, this communication is usually intra-node,\n
    \  and most transaction managers already have more-than-adequate\n   interfaces
    for the task.\n   While we do not expect this protocol to replace existing ones,
    we do\n   expect that it will be relatively easy for many existing\n   heterogeneous
    transaction managers to implement this protocol for\n   communication with each
    other.\n   Further supplemental information regarding the TIP protocol can be\n
    \  found in [5].\n"
  title: 1. Introduction
- contents:
  - "2. Example Usage\n   Today the electronic shopping basket is a common metaphor
    at many\n   electronic store-fronts. Customers browse through an electronic\n
    \  catalog, select goods and place them into an electronic shopping\n   basket.
    HTTP servers [2] provide various means ranging from URL\n   encoding to context
    cookies to keep track of client context (e.g.\n   the shopping basket of a customer)
    and resume it on subsequent\n   customer requests.\n   Once a customer has finished
    shopping they may decide to commit their\n   selection and place the associated
    orders. Most orders may have no\n   relationship with each other except being
    executed as part of the\n   same shopping transaction; others may be dependent
    on each other (for\n   example, if made as part of a special offering).  Irrespective
    of\n   these details a customer will expect that all orders have been\n   successfully
    placed upon receipt of a positive acknowledgment.\n   Today's electronic store-fronts
    must implement their own special\n   protocols to coordinate such placement of
    all orders. This\n   programming is especially complex when orders are placed
    through\n   multiple electronic store-fronts. This complexity limits the\n   potential
    utility of internet applications, and constrains growth.\n   The protocol described
    in this document intends to provide a standard\n   for Internet servers to achieve
    agreement on a unit of shared work\n   (e.g. placement of orders in an electronic
    shopping basket).  The\n   server (e.g. a CGI program) placing the orders may
    want to start a\n   transaction calling its local transaction manager, and ask
    other\n   servers participating in the work to join the transaction.  The\n   server
    placing the orders passes a reference to the transaction as\n   user data on HTTP
    requests to the other servers.  The other servers\n   call their transaction managers
    to start a local transaction and ask\n   them to join the remote transaction using
    the protocol defined in\n   this document. Once all orders have been placed, execution
    of the\n   two-phase-commit protocol is delegated to the involved transaction\n
    \  managers. If the transaction commits, all orders have been\n   successfully
    placed and the customer gets a positive acknowledgment.\n   If the transaction
    aborts no orders will be placed and the customer\n   will be informed of the problem.\n
    \  Transaction support greatly simplifies programming of these\n   applications
    as exception handling and failure recovery are delegated\n   to a special component.
    End users are also not left having to deal\n   with the consequences of only partial
    success.  While this example\n   shows how the protocol can be used by HTTP servers,
    applications may\n   use the protocol when accessing a remote database (e.g. via
    ODBC), or\n   invoking remote services using other already existing protocols
    (e.g.\n   RPC). The protocol makes it easy for applications in a heterogeneous\n
    \  network to participate in the same transaction, even if using\n   different
    communication protocols.\n"
  title: 2. Example Usage
- contents:
  - "3. Transactions\n   \"Transaction\" is the term given to the programming model
    whereby\n   computational work performed has atomic semantics. That is, either\n
    \  all work completes successfully and changes are made permanent (the\n   transaction
    commits), or if any work is unsuccessful, changes are\n   undone (the transaction
    aborts). The work comprising a transaction\n   (unit of work), is defined by the
    application.\n"
  title: 3. Transactions
- contents:
  - "4. Connections\n   The Transaction Internet Protocol (TIP) requires a reliable
    ordered\n   stream transport with low connection setup costs. In an Internet (IP)\n
    \  environment, TIP operates over TCP, optionally using TLS to provide a\n   secured
    and authenticated connection, and optionally using a protocol\n   to multiplex
    light-weight connections over the same TCP or TLS\n   connection.\n   Transaction
    managers that share transactions establish a TCP (and\n   optionally a TLS) connection.
    The protocol uses a different\n   connection for each simultaneous transaction
    shared betwween two\n   transaction managers. After a transaction has ended, the
    connection\n   can be reused for a different transaction.\n   Optionally, instead
    of associating a TCP or TLS connection with only\n   a single transaction, two
    transaction managers may agree on a\n   protocol to multiplex light-weight connections
    over the same TCP or\n   TLS connection, and associate each simultaneous transaction
    with a\n   separate light-weight connection. Using light-weight connections\n
    \  reduces latency and resource consumption associated with executing\n   simultaneous
    transactions. Similar techniques as described here are\n   widely used by existing
    transaction processing systems.  See Appendix\n   A for an example of one such
    protocol.\n   Note that although the TIP protocol itself is described only in
    terms\n   of TCP and TLS, there is nothing to preclude the use of TIP with\n   other
    transport protocols. However, it is up to the implementor to\n   ensure the chosen
    transport provides equivalent semantics to TCP, and\n   to map the TIP protocol
    appropriately.\n   In this document the terms \"connection\" or \"TCP connection\"
    can refer\n   to a TIP TCP connection, a TIP TLS connection, or a TIP multiplexing\n
    \  connection (over either TCP or TLS). It makes no difference which,\n   the
    behavior is the same in each case. Where there are differences in\n   behavior
    between the connection types, these are stated explicitly.\n"
  title: 4. Connections
- contents:
  - "5. Transaction Identifiers\n   Unfortunately, there is no single globally-accepted
    standard for the\n   format of a transaction identifier; there are various standard
    and\n   proprietary formats.  Allowed formats for a TIP transaction\n   identifier
    are described below in the section \"TIP Uniform Resource\n   Locators\". A transaction
    manager may map its internal transaction\n   identifiers into this TIP format
    in any manner it sees fit.\n   Furthermore, each party in a superior/subordinate
    relationship gets\n   to assign its own identifier to the transaction; these identifiers\n
    \  are exchanged when the relationship is first established.  Thus, a\n   transaction
    manager gets to use its own format of transaction\n   identifier internally, but
    it must remember a foreign transaction\n   identifier for each superior/subordinate
    relationship in which it is\n   involved.\n"
  title: 5. Transaction Identifiers
- contents:
  - "6. Pushing vs. Pulling Transactions\n   Suppose that some program on node \"A\"
    has created a transaction, and\n   wants some program on node \"B\" to do some
    work as part of the\n   transaction.  There are two classical ways that he does
    this,\n   referred to as the \"push\" model and the \"pull\" model.\n   In the
    \"push\" model, the program on A first asks his transaction\n   manager to export
    the transaction to node B.  A's transaction manager\n   sends a message to B's
    TM asking it to instantiate the transaction as\n   a subordinate of A, and return
    its name for the transaction.  The\n   program on A then sends a message to its
    counterpart on B on the\n   order of \"Do some work, and make it part of the transaction
    that your\n   transaction manager already knows of by the name ...\".  Because
    A's\n   TM knows that it sent the transaction to B's TM, A's TM knows to\n   involve
    B's TM in the two-phase commit process.\n   In the \"pull\" model, the program
    on A merely sends a message to B on\n   the order of \"Do some work, and make
    it part of the transaction that\n   my TM knows by the name ...\".  The program
    on B asks its TM to enlist\n   in the transaction.  At that time, B's TM will
    \"pull\" the transaction\n   over from A.  As a result of this pull, A's TM knows
    to involve B's\n   TM in the two-phase commit process.\n   The protocol described
    here supports both the \"push\" and \"pull\"\n   models.\n"
  title: 6. Pushing vs. Pulling Transactions
- contents:
  - "7. TIP Transaction Manager Identification and Connection Establishment\n   In
    order for TIP transaction managers to connect they must be able to\n   identify
    and locate each other. The information necessary to do this\n   is described by
    the TIP transaction manager address.\n   [This specification does not prescribe
    how TIP transaction managers\n   initially obtain the transaction manager address
    (which will probably\n   be via some implementation-specific configuration mechanism).]\n
    \  TIP transaction manager addresses take the form:\n     <hostport><path>\n   The
    <hostport> component comprises:\n     <host>[:<port>]\n   where <host> is either
    a <dns name> or an <ip address>; and <port> is\n   a decimal number specifying
    the port at which the transaction manager\n   (or proxy) is listening for requests
    to establish TIP connections. If\n   the port number is omitted, the standard
    TIP port number (3372) is\n   used.\n   A <dns name> is a standard name, acceptable
    to the domain name\n   service. It must be sufficiently qualified to be useful
    to the\n   receiver of the command.\n   An <ip address> is an IP address, in the
    usual form: four decimal\n   numbers separated by period characters.\n   The <hostport>
    component defines the scope (locale) of the <path>\n   component.\n   The <path>
    component of the transaction manager address contains data\n   identifying the
    specific TIP transaction manager, at the location\n   defined by <hostport>.\n
    \  The <path> component takes the form:\n     \"/\" [path_segments]\n     path_segments
    = segment *( \"/\" segment )\n     segment = *pchar *( \";\" param )\n     param
    = *pchar\n     pchar = unreserved | escaped | \":\" | \"@\" | \"&\" | \"=\" |
    \"+\"\n     unreserved = ASCII character octets with values in the range\n                  (inclusive):
    48-57, 65-90, 97-122 | \"$\" | \"-\" | \"_\" |\n                  \".\" | \"!\"
    | \"~\" | \"*\" | \"'\" | \"(\" | \")\" | \",\"\n     escaped = \"%\" hex hex\n
    \    hex = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\"
    | \"9\" |\n           \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"a\" |
    \"b\" | \"c\" | \"d\" |\n           \"e\" | \"f\"\n   The <path> component may
    consist of a sequence of path segments\n   separated by a single slash \"/\" character.
    Within a path segment, the\n   characters \"/\", \";\", \"=\", and \"?\" are reserved.
    Each path segment may\n   include a sequence of parameters, indicated by the semicolon
    \";\"\n   character. The parameters are not significant to the parsing of\n   relative
    references.\n   [It is intended that the form of the transaction manager address\n
    \  follow the proposed scheme for Uniform Resource Identifiers (URI)\n   [8].]\n
    \  The TIP transaction manager address therefore provides to the\n   connection
    initiator (the primary) the endpoint identifier to be used\n   for the TCP connection
    (<hostport>), and to the connection receiver\n   (the secondary) the path to be
    used to locate the specific TIP\n   transaction manager (<path>). This is all
    the information required\n   for the connection between the primary and secondary
    TIP transaction\n   managers to be established.\n   After a connection has been
    established, the primary party issues an\n   IDENTIFY command. This command includes
    as parameters two transaction\n   manager addresses: the primary transaction manager
    address, and the\n   secondary transaction manager address.\n   The primary transaction
    manager address identifies the TIP\n   transaction manager that initiated the
    connection. This information\n   is required in certain cases after connection
    failures, when one of\n   the parties of the connection must re-establish a new
    connection to\n   the other party in order to complete the two-phase-commit protocol.\n
    \  If the primary party needs to re-establish the connection, the job is\n   easy:
    a connection is established in the same way as was the original\n   connection.
    However, if the secondary party needs to re-establish the\n   connection, it must
    be known how to contact the initiator of the\n   original connection. This information
    is supplied to the secondary\n   via the primary transaction manager address on
    the IDENTIFY command.\n   If a primary transaction manager address is not supplied,
    the primary\n   party must not perform any action which would require a connection
    to\n   be re-established (e.g. to perform recovery actions).\n   The secondary
    transaction manager address identifies the receiving\n   TIP transaction manager.
    In the case of TIP communication via\n   intermediate proxy servers, this URL
    may be used by the proxy servers\n   to correctly identify and connect to the
    required TIP transaction\n   manager.\n"
  title: 7. TIP Transaction Manager Identification and Connection Establishment
- contents:
  - "8. TIP Uniform Resource Locators\n   Transactions and transaction managers are
    resources associated with\n   the TIP protocol. Transaction managers and transactions
    are located\n   using the transaction manager address scheme. Once a connection
    has\n   been established, TIP commands may be sent to operate on transactions\n
    \  associated with the respective transaction managers.\n   Applications which
    want to pull a transaction from a remote node must\n   supply a reference to the
    remote transaction which allows the local\n   transaction manager (i.e. the transaction
    manager pulling the\n   transaction) to connect to the remote transaction manager
    and\n   identify the particular transaction. Applications which want to push\n
    \  a transaction to a remote node must supply a reference to the remote\n   transaction
    manager (i.e. the transaction manager to which the\n   transaction is to be pushed),
    which allows the local transaction\n   manager to locate the remote transaction
    manager. The TIP protocol\n   defines a URL scheme [4] which allows applications
    and transaction\n   managers to exchange references to transaction managers and\n
    \  transactions.\n   A TIP URL takes the form:\n     tip://<transaction manager
    address>?<transaction string>\n   where <transaction manager address> identifies
    the TIP transaction\n   manager (as defined in Section 7 above); and <transaction
    string>\n   specifies a transaction identifier, which may take one of two forms\n
    \  (standard or non-standard):\n   i. \"urn:\" <NID> \":\" <NSS>\n     A standard
    transaction identifier, conforming to the proposed\n     Internet Standard for
    Uniform Resource Names (URNs), as specified\n     by RFC2141; where <NID> is the
    Namespace Identifier, and <NSS> is\n     the Namespace Specific String. The Namespace
    ID determines the\n     syntactic interpretation of the Namespace Specific String.
    The\n     Namespace Specific String is a sequence of characters representing\n
    \    a transaction identifier (as defined by <NID>). The rules for the\n     contents
    of these fields are specified by [6] (valid characters,\n     encoding, etc.).\n
    \    This format of <transaction string> may be used to express global\n     transaction
    identifiers in terms of standard representations.\n     Examples for <NID> might
    be <iso> or <xopen>. e.g.\n       tip://123.123.123.123/?urn:xopen:xid\n     Note
    that Namespace Ids require registration. See [7] for details\n     on how to do
    this.\n   ii. <transaction identifier>\n     A sequence of printable ASCII characters
    (octets with values in the\n     range 32 through 126 inclusive (excluding \":\")
    representing a\n     transaction identifier. In this non-standard case, it is
    the\n     combination of <transaction manager address> and <transaction\n     identifier>
    which ensures global uniqueness. e.g.\n       tip://123.123.123.123/?transid1\n
    \    To create a non-standard TIP URL from a transaction identifier,\n     first
    replace any reserved characters in the transaction identifier\n     with their
    equivalent escape sequences, then insert the appropriate\n     transaction manager
    address. If the transaction identifier is one\n     that you created, insert your
    own transaction manager address. If\n     the transaction identifier is one that
    you received on a TIP\n     connection that you initiated, use the secondary transaction\n
    \    manager address that was sent in the IDENTIFY command. If the\n     transaction
    identifier is one that you received on a TIP connection\n     that you did not
    initiate, use the primary transaction manager\n     address that was received
    in the IDENTIFY command.\n   TIP URLs must be guaranteed globally unique for all
    time. This\n   uniqueness constraint ensures TIP URLs are never duplicated, thereby\n
    \  preventing possible non-deterministic behaviour. How uniqueness is\n   achieved
    is implementation specific. For example, the Universally\n   Unique Identifier
    (UUID, also known as a Globally Unique Identifier,\n   or GUID (see [9])) could
    be used as part of the <transaction string>.\n   Note also that some standard
    transaction identifiers may define their\n   own rules for ensuring global uniqueness
    (e.g. OSI CCR atomic action\n   identifiers).\n   Except as otherwise described
    above, the TIP URL scheme follows the\n   rules for reserved characters as defined
    in [4], and uses escape\n   sequences as defined in [4] Section 5.\n   Note that
    the TIP protocol itself does not use the TIP URL scheme (it\n   does use the transaction
    manager address scheme). The TIP URL scheme\n   is proposed as a standard way
    to pass transaction identification\n   information through other protocols. e.g.
    between cooperating\n   application processes. The TIP URL may then be used to
    communicate to\n   the local transaction manager the information necessary to
    associate\n   the application with a particular TIP transaction. e.g. to PULL
    the\n   transaction from a remote transaction manager. It is anticipated that\n
    \  each TIP implementation will provide some set of APIs for this\n   purpose
    ([5] includes examples of such APIs).\n"
  title: 8. TIP Uniform Resource Locators
- contents:
  - "9. States of a Connection\n   At any instant, only one party on a connection
    is allowed to send\n   commands, while the other party is only allowed to respond
    to\n   commands that he receives. Throughout this document, the party that\n   is
    allowed to send commands is called \"primary\"; the other party is\n   called
    \"secondary\". Initially, the party that initiated the\n   connection is primary;
    however, a few commands cause the roles to\n   switch. A connection returns to
    its original polarity whenever the\n   Idle state is reached.\n   When multiplexing
    is being used, these rules apply independently to\n   each \"virtual\" connection,
    regardless of the polarity of the\n   underlying connection (which will be in
    the Multiplexing state).\n   Note that commands may be sent \"out of band\" by
    the secondary via the\n   use of pipelining. This does not affect the polarity
    of the\n   connection (i.e. the roles of primary and secondary do not switch).\n
    \  See section 12 for details.\n   In the normal case, TIP connections should
    only be closed by the\n   primary, when in Initial state. It is generally undesirable
    for a\n   connection to be closed by the secondary, although this may be\n   necessary
    in certain error cases.\n   At any instant, a connection is in one of the following
    states. From\n   the point of view of the secondary party, the state changes when
    he\n   sends a reply; from the point of view of the primary party, the state\n
    \  changes when he receives a reply.\n   Initial: The initial connection starts
    out in the Initial state.\n     Upon entry into this state, the party that initiated
    the connection\n     becomes primary, and the other party becomes secondary. There
    is no\n     transaction associated with the connection in this state. From this\n
    \    state, the primary can send an IDENTIFY or a TLS command.\n   Idle: In this
    state, the primary and the secondary have agreed on a\n     protocol version,
    and the primary supplied an identifier to the\n     secondary party to reconnect
    after a failure. There is no\n     transaction associated with the connection
    in this state.  Upon\n     entry to this state, the party that initiated the connection\n
    \    becomes primary, and the other party becomes secondary. From this\n     state,
    the primary can send any of the following commands: BEGIN,\n     MULTIPLEX, PUSH,
    PULL, QUERY and RECONNECT.\n   Begun: In this state, a connection is associated
    with an active\n     transaction, which can only be completed by a one-phase protocol.\n
    \    A BEGUN response to a BEGIN command places a connection into this\n     state.
    Failure of a connection in Begun state implies that the\n     transaction will
    be aborted. From this state, the primary can send\n     an ABORT, or COMMIT command.\n
    \  Enlisted: In this state, the connection is associated with an active\n     transaction,
    which can be completed by a one-phase or, two-phase\n     protocol. A PUSHED response
    to a PUSH command, or a PULLED response\n     to a PULL command, places the connection
    into this state. Failure\n     of the connection in Enlisted state implies that
    the transaction\n     will be aborted. From this state, the primary can send an
    ABORT,\n     COMMIT, or PREPARE command.\n   Prepared: In this state, a connection
    is associated with a\n     transaction that has been prepared. A PREPARED response
    to a\n     PREPARE command, or a RECONNECTED response to a RECONNECT command\n
    \    places a connection into this state.  Unlike other states, failure\n     of
    a connection in this state does not cause the transaction to\n     automatically
    abort. From this state, the primary can send an\n     ABORT, or COMMIT command.\n
    \  Multiplexing: In this state, the connection is being used by a\n     multiplexing
    protocol, which provides its own set of connections.\n     In this state, no TIP
    commands are possible on the connection.  (Of\n     course, TIP commands are possible
    on the connections supplied by\n     the multiplexing protocol.) The connection
    can never leave this\n     state.\n   Tls: In this state, the connection is being
    used by the TLS\n     protocol, which provides its own secured connection. In
    this state,\n     no TIP commands are possible on the connection. (Of course,
    TIP\n     commands are possible on the connection supplied by the TLS\n     protocol.)
    The connection can never leave this state.\n   Error: In this state, a protocol
    error has occurred, and the\n     connection is no longer useful. The connection
    can never leave this\n     state.\n"
  title: 9. States of a Connection
- contents:
  - "10. Protocol Versioning\n   This document describes version 3 of the protocol.
    In order to\n   accommodate future versions, the primary party sends a message\n
    \  indicating the lowest and the highest version number it understands.\n   The
    secondary responds with the highest version number it\n   understands.\n   After
    such an exchange, communication can occur using the smaller of\n   the highest
    version numbers (i.e., the highest version number that\n   both understand). This
    exchange is mandatory and occurs using the\n   IDENTIFY command (and IDENTIFIED
    response).\n   If the highest version supported by one party is considered obsolete\n
    \  and no longer supported by the other party, no useful communication\n   can
    occur.  In this case, the newer party should merely drop the\n   connection.\n"
  title: 10. Protocol Versioning
- contents:
  - "11. Commands and Responses\n   All commands and responses consist of one line
    of ASCII text, using\n   only octets with values in the range 32 through 126 inclusive,\n
    \  followed by either a CR (an octet with value 13) or an LR (an octet\n   with
    value 10).  Each line can be split up into one or more \"words\",\n   where successive
    words are separated by one or more space octets\n   (value 32).\n   Arbitrary
    numbers of spaces at the beginning and/or end of each line\n   are allowed, and
    ignored.\n   Lines that are empty, or consist entirely of spaces are ignored.\n
    \  (One implication of this is that you can terminate lines with both a\n   CR
    and an LF if desired; the LF will be treated as terminating an\n   empty line,
    and ignored.)\n   In all cases, the first word of each line indicates the type
    of\n   command or response; all defined commands and responses consist of\n   upper-case
    letters only.\n   For some commands and responses, subsequent words convey parameters\n
    \  for the command or response; each command and response takes a fixed\n   number
    of parameters.\n   All words on a command or response line after (and including)
    the\n   first undefined word are totally ignored. These can be used to pass\n
    \  human-readable information for debugging or other purposes.\n"
  title: 11. Commands and Responses
- contents:
  - "12. Command Pipelining\n   In order to reduce communication latency and improve
    efficiency, it\n   is possible for multiple TIP \"lines\" (commands or responses)
    to be\n   pipelined (concatenated) together and sent as a single message.\n   Lines
    may also be sent \"ahead\" (by the secondary, for later procesing\n   by the primary).
    Examples are an ABORT command immediately followed\n   by a BEGIN command, or
    a COMMITTED response immediately followed by a\n   PULL command.\n   The sending
    of pipelined lines is an implementation option. Likewise\n   which lines are pipelined
    together. Generally, it must be certain\n   that the pipelined line will be valid
    for the state of the connection\n   at the time it is processed by the receiver.
    It is the responsibility\n   of the sender to determine this.\n   All implementations
    must support the receipt of pipelined lines - the\n   rules for processing of
    which are described by the following\n   paragraph:\n     When the connection
    state is such that a line should be read\n     (either command or response), then
    that line (when received) is\n     processed. No more lines are read from the
    connection until\n     processing again reaches such a state. If a line is received
    on a\n     connection when it is not the turn of the other party to send, that\n
    \    line is _not_ rejected. Instead, the line is held and processed\n     when
    the connection state again requires it. The receiving party\n     must process
    lines and issue responses in the order of lines\n     received. If a line causes
    an error the connection enters the Error\n     state, and all subsequent lines
    on the connection are discarded.\n"
  title: 12. Command Pipelining
- contents:
  - "13. TIP Commands\n   Commands pertain either to connections or transactions.
    Commands\n   which pertain to connections are: IDENTIFY, MULTIPLEX and TLS.\n
    \  Commands which pertain to transactions are: ABORT, BEGIN, COMMIT,\n   PREPARE,
    PULL, PUSH, QUERY, and RECONNECT.\n   Following is a list of all valid commands,
    and all possible responses\n   to each:\n   ABORT\n     This command is valid
    in the Begun, Enlisted, and Prepared states.\n     It informs the secondary that
    the current transaction of the\n     connection will abort. Possible responses
    are:\n     ABORTED\n       The transaction has aborted; the connection enters
    Idle state.\n     ERROR\n       The command was issued in the wrong state, or
    was malformed.  The\n       connection enters the Error state.\n   BEGIN\n     This
    command is valid only in the Idle state. It asks the secondary\n     to create
    a new transaction and associate it with the connection.\n     The newly created
    transaction will be completed with a one-phase\n     protocol. Possible responses
    are:\n     BEGUN <transaction identifier>\n       A new transaction has been successfully
    begun, and that\n       transaction is now the current transaction of the connection.\n
    \      The connection enters Begun state.\n     NOTBEGUN\n       A new transaction
    could not be begun; the connection remains in\n       Idle state.\n     ERROR\n
    \      The command was issued in the wrong state, or was malformed.  The\n       connection
    enters the Error state.\n   COMMIT\n     This command is valid in the Begun, Enlisted
    or Prepared states.\n     In the Begun or Enlisted state, it asks the secondary
    to attempt to\n     commit the transaction; in the Prepared state, it informs
    the\n     secondary that the transaction has committed. Note that in the\n     Enlisted
    state this command represents a one-phase protocol, and\n     should only be done
    when the sender has 1) no local recoverable\n     resources involved in the transaction,
    and 2) only one subordinate\n     (the sender will not be involved in any transaction
    recovery\n     process). Possible responses are:\n     ABORTED\n       This response
    is possible only from the Begun and Enlisted\n       states. It indicates that
    some party has vetoed the commitment of\n       the transaction, so it has been
    aborted instead of committing.\n       The connection enters the Idle state.\n
    \    COMMITTED\n       This response indicates that the transaction has been committed,\n
    \      and that the primary no longer has any responsibilities to the\n       secondary
    with respect to the transaction. The connection enters\n       the Idle state.\n
    \    ERROR\n       The command was issued in the wrong state, or was malformed.
    \ The\n       connection enters the Error state.\n   ERROR\n     This command
    is valid in any state; it informs the secondary that a\n     previous response
    was not recognized or was badly formed.  A\n     secondary should not respond
    to this command. The connection enters\n     Error state.\n   IDENTIFY  <lowest
    protocol version>\n             <highest protocol version>\n             <primary
    transaction manager address> | \"-\"\n             <secondary transaction manager
    address>\n     This command is valid only in the Initial state. The primary party\n
    \    informs the secondary party of: 1) the lowest and highest protocol\n     version
    supported (all versions between the lowest and highest must\n     be supported;
    2) optionally, an identifier for the primary party at\n     which the secondary
    party can re-establish a connection if ever\n     needed (the primary transaction
    manager address); and 3) an\n     identifier which may be used by intermediate
    proxy servers to\n     connect to the required TIP transaction manager (the secondary\n
    \    transaction manager address). If a primary transaction manager\n     address
    is not supplied, the secondary party will respond with\n     ABORTED or READONLY
    to any PREPARE commands.  Possible responses\n     are:\n     IDENTIFIED <protocol
    version>\n       The secondary party has been successfully contacted and has saved\n
    \      the primary transaction manager address. The response contains\n       the
    highest protocol version supported by the secondary party.\n       All future
    communication is assumed to take place using the\n       smaller of the protocol
    versions in the IDENTIFY command and the\n       IDENTIFIED response. The connection
    enters the Idle state.\n     NEEDTLS\n       The secondary party is only willing
    to communicate over TLS\n       secured connections. The connection enters the
    Tls state, and all\n       subsequent communication is as defined by the TLS protocol.
    This\n       protocol will begin with the first octet after the line\n       terminator
    of the IDENTIFY command (for data sent by the primary\n       party), and the
    first byte after the line terminator of the\n       NEEDTLS response (for data
    sent by the secondary party). This\n       implies that an implementation must
    not send both a CR and a LF\n       octet after either the IDENTIFY command or
    the NEEDTLS response,\n       lest the LF octet be mistaken for the first byte
    of the TLS\n       protocol. The connection provided by the TLS protocol starts
    out\n       in the Initial state.  After TLS has been negotiated, the primary\n
    \      party must resend the IDENTIFY command. If the primary party\n       cannot
    support (or refuses to use) the TLS protocol, it closes\n       the connection.\n
    \    ERROR\n       The command was issued in the wrong state, or was malformed.\n
    \      This response also occurs if the secondary party does not support\n       any
    version of the protocol in the range supported by the primary\n       party. The
    connection enters the Error state. The primary party\n       should close the
    connection.\n   MULTIPLEX  <protocol-identifier>\n     This command is only valid
    in the Idle state. The command seeks\n     agreement to use the connection for
    a multiplexing protocol that\n     will supply a large number of connections on
    the existing\n     connection. The primary suggests a particular multiplexing\n
    \    protocol. The secondary party can either accept or reject use of\n     this
    protocol.\n     At the present, the only defined protocol identifier is \"TMP2.0\",\n
    \    which refers to the TIP Multiplexing Protocol, version 2.0. See\n     Appendix
    A for details of this protocol. Other protocol identifiers\n     may be defined
    in the future.\n     If the MULTIPLEX command is accepted, the specified multiplexing\n
    \    protocol will totally control the underlying connection. This\n     protocol
    will begin with the first octet after the line terminator\n     of the MULTIPLEX
    command (for data sent by the initiator), and the\n     first byte after the line
    terminator of the MULTIPLEXING response\n     (for data received by the initiator).
    This implies that an\n     implementation must not send both a CR and a LF octet
    after either\n     the MULTIPLEX command or the MULTIPLEXING response, lest the
    LF\n     octet be mistaken for the first byte of the multiplexing protocol.\n
    \    Note that when using TMP V2.0, a single TIP command (TMP\n     application
    message) must be wholly contained within a single TMP\n     packet (the TMP PUSH
    flag is not used by TIP). Possible responses\n     to the MULTIPLEX command are:\n
    \    MULTIPLEXING\n       The secondary party agrees to use the specified multiplexing\n
    \      protocol. The connection enters the Multiplexing state, and all\n       subsequent
    communication is as defined by that protocol.  All\n       connections created
    by the multiplexing protocol start out in the\n       Idle state.\n     CANTMULTIPLEX\n
    \      The secondary party cannot support (or refuses to use) the\n       specified
    multiplexing protocol. The connection remains in the\n       Idle state.\n     ERROR\n
    \      The command was issued in the wrong state, or was malformed.  The\n       connection
    enters the Error state.\n   PREPARE\n     This command is valid only in the Enlisted
    state; it requests the\n     secondary to prepare the transaction for commitment
    (phase one of\n     two-phase commit). Possible responses are:\n     PREPARED\n
    \      The subordinate has prepared the transaction; the connection\n       enters
    PREPARED state.\n     ABORTED\n       The subordinate has vetoed committing the
    transaction. The\n       connection enters the Idle state.  After this response,
    the\n       superior has no responsibilities to the subordinate with respect\n
    \      to the transaction.\n     READONLY\n       The subordinate no longer cares
    whether the transaction commits\n       or aborts. The connection enters the Idle
    state. After this\n       response, the superior has no responsibilities to the
    subordinate\n       with respect to the transaction.\n     ERROR\n       The command
    was issued in the wrong state, or was malformed.  The\n       connection enters
    the Error state.\n   PULL  <superior's transaction identifier>\n         <subordinate's
    transaction identifier>\n     This command is only valid in Idle state. This command
    seeks to\n     establish a superior/subordinate relationship in a transaction,\n
    \    with the primary party of the connection as the subordinate (i.e.,\n     he
    is pulling a transaction from the secondary party).  Note that\n     the entire
    value of <transaction string> (as defined in the section\n     \"TIP Uniform Resource
    Locators\") must be specified as the\n     transaction identifier. Possible responses
    are:\n     PULLED\n       The relationship has been established.  Upon receipt
    of this\n       response, the specified transaction becomes the current\n       transaction
    of the connection, and the connection enters Enlisted\n       state. Additionally,
    the roles of primary and secondary become\n       reversed.  (That is, the superior
    becomes the primary for the\n       connection.)\n     NOTPULLED\n       The relationship
    has not been established (possibly, because the\n       secondary party no longer
    has the requested transaction).  The\n       connection remains in Idle state.\n
    \    ERROR\n       The command was issued in the wrong state, or was malformed.
    \ The\n       connection enters the Error state.\n   PUSH <superior's transaction
    identifier>\n     This command is valid only in the Idle state. It seeks to establish\n
    \    a superior/subordinate relationship in a transaction with the\n     primary
    as the superior. Note that the entire value of <transaction\n     string> (as
    defined in the section \"TIP Uniform Resource Locators\")\n     must be specified
    as the transaction identifier. Possible responses\n     are:\n     PUSHED <subordinate's
    transaction identifier>\n       The relationship has been established, and the
    identifier by\n       which the subordinate knows the transaction is returned.
    The\n       transaction becomes the current transaction for the connection,\n
    \      and the connection enters Enlisted state.\n     ALREADYPUSHED <subordinate's
    transaction identifier>\n       The relationship has been established, and the
    identifier by\n       which the subordinate knows the transaction is returned.\n
    \      However, the subordinate already knows about the transaction, and\n       is
    expecting the two-phase commit protocol to arrive via a\n       different connection.
    In this case, the connection remains in the\n       Idle state.\n     NOTPUSHED\n
    \      The relationship could not be established. The connection remains\n       in
    the Idle state.\n     ERROR\n       The command was issued in the wrong state,
    or was malformed.  The\n       connection enters Error state.\n   QUERY <superior's
    transaction identifier>\n     This command is valid only in the Idle state. A
    subordinate uses\n     this command to determine whether a specific transaction
    still\n     exists at the superior. Possible responses are:\n     QUERIEDEXISTS\n
    \      The transaction still exists.  The connection remains in the Idle\n       state.\n
    \    QUERIEDNOTFOUND\n       The transaction no longer exists.  The connection
    remains in the\n       Idle state.\n     ERROR\n       The command was issued
    in the wrong state, or was malformed.  The\n       connection enters Error state.\n
    \  RECONNECT <subordinate's transaction identifier>\n     This command is valid
    only in the Idle state. A superior uses the\n     command to re-establish a connection
    for a transaction, when the\n     previous connection was lost during Prepared
    state. Possible\n     responses are:\n     RECONNECTED\n       The subordinate
    accepts the reconnection. The connection enters\n       Prepared state.\n     NOTRECONNECTED\n
    \      The subordinate no longer knows about the transaction. The\n       connection
    remains in Idle state.\n     ERROR\n       The command was issued in the wrong
    state, or was malformed.  The\n       connection enters Error state.\n   TLS\n
    \    This command is valid only in the Initial state. A primary uses\n     this
    command to attempt to establish a secured connection using\n     TLS.\n     If
    the TLS command is accepted, the TLS protocol will totally\n     control the underlying
    connection. This protocol will begin with\n     the first octet after the line
    terminator of the TLS command (for\n     data sent by the primary), and the first
    byte after the line\n     terminator of the TLSING response (for data received
    by the\n     primary). This implies that an implementation must not send both
    a\n     CR and a LF octet after either the TLS command or the TLSING\n     response,
    lest the LF octet be mistaken for the first byte of the\n     TLS protocol.\n
    \    Possible responses to the TLS command are:\n     TLSING\n       The secondary
    party agrees to use the TLS protocol [3]. The\n       connection enters the Tls
    state, and all subsequent communication\n       is as defined by the TLS protocol.
    The connection provided by the\n       TLS protocol starts out in the Initial
    state.\n     CANTTLS\n       The secondary party cannot support (or refuses to
    use) the TLS\n       protocol. The connection remains in the Initial state.\n
    \    ERROR\n       The command was issued in the wrong state, or was malformed.
    \ The\n       connection enters the Error state.\n"
  title: 13. TIP Commands
- contents:
  - "14. Error Handling\n   If either party receives a line that it cannot understand
    it closes\n   the connection. If either party (either a command or a response),\n
    \  receives an ERROR indication or an ERROR response on a connection the\n   connection
    enters the Error state and no further communication is\n   possible on that connection.
    An implementation may decide to close\n   the connection. Closing of the connection
    is treated by the other\n   party as a communication failure.\n   Receipt of an
    ERROR indication or an ERROR response indicates that\n   the other party believes
    that you have not properly implemented the\n   protocol.\n"
  title: 14. Error Handling
- contents:
  - "15. Connection Failure and Recovery\n   A connection failure may be caused by
    a communication failure, or by\n   any party closing the connection. It is assumed
    TIP implementations\n   will use some private mechanism to detect TIP connection
    failure\n   (e.g. socket keepalive, or a timeout scheme).\n   Depending on the
    state of a connection, transaction managers will\n   need to take various actions
    when a connection fails.\n   If the connection fails in Initial or Idle state,
    the connection does\n   not refer to a transaction. No action is necessary.\n
    \  If the connection fails in the Multiplexing state, all connections\n   provided
    by the multiplexing protocol are assumed to have failed.\n   Each of them will
    be treated independently.\n   If the connection fails in Begun or Enlisted state
    and COMMIT has\n   been sent, then transaction completion has been delegated to
    the\n   subordinate (the superior is not involved); the outcome of the\n   transaction
    is unknown by the superior (it is known at the\n   subordinate). The superior
    uses application-specific means to\n   determine the outcome of the transaction
    (note that transaction\n   integrity is not compromised in this case since the
    superior has no\n   recoverable resources involved in the transaction). If the
    connection\n   fails in Begun or Enlisted state and COMMIT has not been sent,
    the\n   transaction will be aborted.\n   If the connection fails in Prepared state,
    then the appropriate\n   action is different for the superior and subordinate
    in the\n   transaction.\n   If the superior determines that the transaction commits,
    then it must\n   eventually establish a new connection to the subordinate, and
    send a\n   RECONNECT command for the transaction. If it receives a\n   NOTRECONNECTED
    response, it need do nothing else. However, if it\n   receives a RECONNECTED response,
    it must send a COMMIT request and\n   receive a COMMITTED response.\n   If the
    superior determines that the transaction aborts, it is allowed\n   to (but not
    required to) establish a new connection and send a\n   RECONNECT command for the
    transaction. If it receives a RECONNECTED\n   response, it should send an ABORT
    command.\n   The above definition allows the superior to reestablish the\n   connection
    before it knows the outcome of the transaction, if it\n   finds that  convenient.
    Having succeeded in a RECONNECT command, the\n   connection is back in Prepared
    state, and the superior can send a\n   COMMIT or ABORT command as appropriate
    when it knows the transaction\n   outcome.\n   Note that it is possible for a
    RECONNECT command to be received by\n   the subordinate before it is aware that
    the previous connection has\n   failed. In this case the subordinate treats the
    RECONNECT command as\n   a failure indication and cleans-up any resources associated
    with the\n   connection, and associates the transaction state with the new\n   connection.\n
    \  If a subordinate notices a connection failure in Prepared state, then\n   it
    should periodically attempt to create a new connection to the\n   superior and
    send a QUERY command for the transaction. It should\n   continue doing this until
    one of the following two events occurs:\n   1. It receives a QUERIEDNOTFOUND response
    from the superior. In this\n      case, the subordinate should abort the transaction.\n
    \  2. The superior, on some connection that it initiated, sends a\n      RECONNECT
    command for the transaction to the subordinate. In this\n      case, the subordinate
    can expect to learn the outcome of the\n      transaction on this new connection.
    If this new connection should\n      fail before the subordinate learns the outcome
    of the transaction,\n      it should again start sending QUERY commands.\n   Note
    that if a TIP system receives either a QUERY or a RECONNECT\n   command, and for
    some reason is unable to satisfy the request (e.g.\n   the necessary recovery
    information is not currently available), then\n   the connection should be dropped.\n"
  title: 15. Connection Failure and Recovery
- contents:
  - "16. Security Considerations\n   This section is meant to inform application developers,
    transaction\n   manager developers, and users of the security implications of
    TIP as\n   described by this document. The discussion does not include\n   definitive
    solutions to the issues described, though it does make\n   some suggestions for
    reducing security risks.\n   As with all two phase-commit protocols, any security
    mechanisms\n   applied to the application communication protocol are liable to
    be\n   subverted unless corresponding mechanisms are applied to the\n   commitment
    protocol. For example, any authentication between the\n   parties using the application
    protocol must be supported by security\n   of the TIP exchanges to at least the
    same level of certainty.\n"
  - contents:
    - "16.1. TLS, Mutual Authentication and Authorization\n   TLS provides optional
      client-side authentication, optional server-\n   side authentication, and optional
      packet encryption.\n   A TIP implementation may refuse to provide service unless
      TLS is\n   being used. It may refuse to provide service if packet encryption
      is\n   not being used. It may refuse to provide service unless the remote\n
      \  party has been authenticated (via TLS).\n   A TIP implementation should be
      willing to be authenticated itself\n   (via TLS). This is true regardless of
      whether the implementation is\n   acting as a client or a server.\n   Once a
      remote party has been authenticated, a TIP transaction manager\n   may use that
      remote party's identity to decide what operations to\n   allow.\n   Whether
      TLS is to be used on a connection, and if so, how TLS is to\n   be used, and
      what operations are to subsequently be allowed, is\n   determined by the security
      policies of the connecting TIP transaction\n   managers towards each other.
      How these security policies are defined,\n   and how a TIP transaction manager
      learns of them is totally private\n   to the implementation and beyond the scope
      of this document.\n"
    title: 16.1. TLS, Mutual Authentication and Authorization
  - contents:
    - "16.2. PULL-Based Denial-of-Service Attack\n   Assume that a malicious user
      knows the identity of a transaction that\n   is currently active in some transaction
      manager. If the malefactor\n   opens a TIP connection to the transaction manager,
      sends a PULL\n   command, then closes the connection, he can cause that transaction
      to\n   be aborted. This results in a denial of service to the legitimate\n   owner
      of the transaction.\n   An implementation may avoid this attack by refusing
      PULL commands\n   unless TLS is being used, the remote party has been authenticated,\n
      \  and the remote party is trusted.\n"
    title: 16.2. PULL-Based Denial-of-Service Attack
  - contents:
    - "16.3. PUSH-Based Denial-of-Service Attack\n   When the connection between two
      transaction managers is closed while\n   a transaction is in the Prepared state,
      each transaction manager\n   needs to remember information about the transaction
      until a\n   connection can be re-established.\n   If a malicious user exploits
      this fact to repeatedly create\n   transactions, get them into Prepared state
      and drop the connection,\n   he may cause a transaction manager to suffer resource
      exhaustion,\n   thus denying service to all legitimate users of that transaction\n
      \  manager.\n   An implementation may avoid this attack by refusing PUSH commands\n
      \  unless TLS is being used, the remote party has been authenticated,\n   and
      the remote party is trusted.\n"
    title: 16.3. PUSH-Based Denial-of-Service Attack
  - contents:
    - "16.4. Transaction Corruption Attack\n   If a subordinate transaction manager
      has lost its connection for a\n   particular prepared transaction, a malicious
      user can initiate a TIP\n   connection to the transaction manager, and send
      it a RECONNECT\n   command followed by either a COMMIT or an ABORT command for
      the\n   transaction. The malicious user could thus cause part of a\n   transaction
      to be committed when it should have been aborted, or vice\n   versa.\n   An
      implementation may avoid this attack by recording the\n   authenticated identity
      of its superior in a transaction, and by\n   refusing RECONNECT commands unless
      TLS is being used and the\n   authenticated identity of the remote party is
      the same as the\n   identity of the original superior.\n"
    title: 16.4. Transaction Corruption Attack
  - contents:
    - "16.5. Packet-Sniffing Attacks\n   If a malicious user can intercept traffic
      on a TIP connection, he may\n   be able to deduce information useful in planning
      other attacks.  For\n   example, if comment fields include the product name
      and version\n   number of a transaction manager, a malicious user might be able
      to\n   use this information to determine what security bugs exist in the\n   implementation.\n
      \  An implementation may avoid this attack by always using TLS to\n   provide
      session encryption, and by not putting any personalizing\n   information on
      the TLS/TLSING command/response pair.\n"
    title: 16.5. Packet-Sniffing Attacks
  - contents:
    - "16.6. Man-in-the-Middle Attack\n   If a malicious user can intercept and alter
      traffic on a TIP\n   connection, he can wreak havoc in a number of ways. For
      example, he\n   could replace a COMMIT command with an ABORT command.\n   An
      implementation may avoid this attack by always using TLS to\n   provide session
      encryption and authentication of the remote party.\n"
    title: 16.6. Man-in-the-Middle Attack
  title: 16. Security Considerations
- contents:
  - "17. References\n   [1]  Gray, J. and A. Reuter (1993), Transaction Processing:
    Concepts\n        and Techniques.  San Francisco, CA: Morgan Kaufmann Publishers.\n
    \       (ISBN 1-55860-190-2).\n   [2]  Fielding, R., Gettys, J., Mogul, J., Frystyk,
    H., and T.\n        Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\",
    RFC\n        2068, January 1997.\n   [3]  Dierks, T., et. al., \"The TLS Protocol
    Version 1.0\", Work in\n        Progress.\n   [4]  Berners-Lee, T., Masinter,
    L., and M. McCahill, \"Uniform\n        Resource Locators (URL)\", RFC 1738, December
    1994.\n   [5]  Evans, K., Klein, J., and J. Lyon, \"Transaction Internet\n        Protocol
    - Requirements and Supplemental Information\", RFC 2372,\n        July 1998.\n
    \  [6]  Moats, R., \"URN Syntax\", RFC 2141, May 1997.\n   [7]  Faltstrom, P.,
    et. al., \"Namespace Identifier Requirements for\n        URN Services\", Work
    in Progress.\n   [8]  Berners-Lee, T., et. at., \"Uniform Resource Identifiers
    (URI):\n        Generic Syntax and Semantics\", Work in Progress.\n   [9]  Leach,
    P., and R. Salz, \"UUIDs and GUIDs\", Work in Progress.\n"
  title: 17. References
- contents:
  - "18. Authors' Addresses\n   Jim Lyon\n   Microsoft Corporation\n   One Microsoft
    Way\n   Redmond, WA  98052-6399, USA\n   Phone: +1 (206) 936 0867\n   Fax:   +1
    (206) 936 7329\n   EMail: JimLyon@Microsoft.Com\n   Keith Evans\n   Tandem Computers,
    Inc.\n   5425 Stevens Creek Blvd\n   Santa Clara, CA 95051-7200, USA\n   Phone:
    +1 (408) 285 5314\n   Fax:   +1 (408) 285 5245\n   EMail: Keith.Evans@Tandem.Com\n
    \  Johannes Klein\n   Tandem Computers Inc.\n   10555 Ridgeview Court\n   Cupertino,
    CA 95014-0789, USA\n   Phone: +1 (408) 285 0453\n   Fax:   +1 (408) 285 9818\n
    \  EMail: Johannes.Klein@Tandem.Com\n"
  title: 18. Authors' Addresses
- contents:
  - "19. Comments\n   Please send comments on this document to the authors at\n   <JimLyon@Microsoft.Com>,
    <Keith.Evans@Tandem.Com>,\n   <Johannes.Klein@Tandem.Com>, or to the TIP mailing
    list at\n   <Tip@Lists.Tandem.Com>. You can subscribe to the TIP mailing list
    by\n   sending  mail to <Listserv@Lists.Tandem.Com> with the line \"subscribe\n
    \  tip <full name>\" somewhere in the body of the message.\n"
  title: 19. Comments
- contents:
  - "Appendix A. The TIP Multiplexing Protocol Version 2.0.\n   This appendix describes
    version 2.0 of the TIP Multiplexing Protocol\n   (TMP). TMP is intended solely
    for use with the TIP protocol, and\n   forms part of the TIP protocol specification
    (although its\n   implementation is optional). TMP V2.0 is the only multiplexing\n
    \  protocol supported by TIP V3.0.\n"
  - "Abstract\n   TMP provides a simple mechanism for creating multiple lightweight\n
    \  connections over a single TCP connection. Several such lightweight\n   connections
    can be active simultaneously. TMP provides a byte\n   oriented service, but allows
    message boundaries to be marked.\n"
  - contents:
    - "A.1. Introduction\n   There are several protocols in widespread use on the
      Internet which\n   create a single TCP connection for each transaction. Unfortunately,\n
      \  because these transactions are short lived, the cost of setting up\n   and
      tearing down these TCP connections becomes significant, both in\n   terms of
      resources used and in the delays associated with TCP's\n   congestion control
      mechanisms.\n   The TIP Multiplexing Protocol (TMP) is a simple protocol running
      on\n   top of TCP that can be used to create multiple lightweight\n   connections
      over a single transport connection. TMP therefore\n   provides for more efficient
      use of TCP connections. Data from several\n   different TMP connections can
      be interleaved, and both message\n   boundaries and end of stream markers can
      be provided.\n   Because TMP runs on top of a reliable byte ordered transport
      service\n   it can avoid most of the extra work TCP must go through in order
      to\n   ensure reliability. For example, TMP connections do not need to be\n
      \  confirmed, so there is no need to wait for handshaking to complete\n   before
      data can be sent.\n   Note: TMP is not intended as a generalized multiplexing
      protocol. If\n   you are designing a different protocol that needs multiplexing,
      TMP\n   may or may not be appropriate. Protocols with large messages can\n   exceed
      the buffering capabilities of the receiver, and under certain\n   conditions
      this can cause deadlock. TMP when used with TIP does not\n   suffer from this
      problem since TIP is a request-response protocol,\n   and all messages are short.\n"
    title: A.1. Introduction
  - contents:
    - "A.2. Protocol Model\n   The basic protocol model is that of multiple lightweight
      connections\n   operating over a reliable stream of bytes. The party which initiated\n
      \  the connection is referred to as the primary, and the party which\n   accepted
      the connection is referred to as the secondary.\n   Connections may be unidirectional
      or bi-directional; each end of a\n   bi-directional connection may be closed
      separately. Connections may\n   be closed normally, or reset to indicate an
      abortive release.\n   Aborting a connection closes both data streams.\n   Once
      a connection has been opened, applications can send messages\n   over it, and
      signal the end of application level messages.\n   Application messages are encapsulated
      in TMP packets and transferred\n   over the byte stream. A single TIP command
      (TMP application message)\n   must be wholly contained within a single TMP packet.\n"
    title: A.2. Protocol Model
  - contents:
    - "A.3. TMP Packet Format\n   A TMP packet consists of a 64 bit header followed
      by zero or more\n   octets of data. The header contains three fields; a flag
      byte, the\n   connection identifier, and the packet length. Both integers, the\n
      \  connection identifier and the packet length must be sent in network\n   byte
      order.\n    FLAGS\n   +--------+--------+--------+--------+\n   |SFPR0000| Connection
      ID            |\n   +--------+--------+--------+--------+\n   |        | Length
      \                  |\n   +--------+--------+--------+--------+\n"
    - contents:
      - "A.3.1. Flag Details\n   +-------+-----------+-----------------------------------------+\n
        \  | Name  | Mask      | Description                             |\n   +-------+-----------+
        ----------------------------------------+\n   | SYN   | 1xxx|0000 | Open a
        new connection                   |\n   | FIN   | x1xx|0000 | Close an existing
        connection            |\n   | PUSH  | xx1x|0000 | Mark application level message
        boundary |\n   | RESET | xxx1|0000 | Abort the connection                    |\n
        \  +-------+-----------+-----------------------------------------+\n"
      title: A.3.1. Flag Details
    title: A.3. TMP Packet Format
  - contents:
    - "A.4. Connection Identifiers\n   Each TMP connection is identified by a 24 bit
      integer. TMP\n   connections created by the party which initiated the underlying
      TCP\n   connection must have even identifiers; those created by the other\n
      \  party must have odd identifiers.\n"
    title: A.4. Connection Identifiers
  - contents:
    - "A.5. TMP Connection States\n   TMP connections can exist in several different
      states; Closed,\n   OpenWrite, OpenSynRead, OpenSynReset, OpenReadWrite, CloseWrite,
      and\n   CloseRead. A connection can change its state in response to receiving\n
      \  a packet with the SYN, FIN, or RESET bits set, or in response to an\n   API
      call by the application. The available API calls are open, close,\n   and abort.\n
      \  The meaning of most states is obvious (e.g. OpenWrite means that a\n   connection
      has been opened for writing). The meaning of the states\n   OpenSynRead and
      OpenResetRead need more explanation.\n   In the OpenSynRead state a primary
      opened and immediately closed the\n   output data stream of a connection, and
      is now waiting for a SYN\n   response from the secondary to open the input data
      stream for\n   reading.\n   In the OpenResetRead state a primary opened and
      immediately aborted a\n   connection, and is now waiting for a SYN response
      from the secondary\n   to finally close the connection.\n"
    title: A.5. TMP Connection States
  - contents:
    - "A.6. Event Priorities and State Transitions\n   The state table shown below
      describes the actions and state\n   transitions that occur in response to a
      given event. The events\n   accepted by each state are listed in priority order
      with highest\n   priority first. If multiple events are present in a message,
      those\n   events matching the list are processed. If multiple events match,
      the\n   event with the highest priority is accepted and processed first.  Any\n
      \  remaining events are processed in the resultant successor state.\n   For
      example, if a TMP connection at the secondary is in the Closed\n   state, and
      the secondary receives a packet containing a SYN event, a\n   FIN event and
      an input data event (i.e. DATA-IN), the secondary first\n   accepts the SYN
      event (because it is the only match in Closed state).\n   The secondary accepts
      the connection, sends a SYN event and enters\n   the ReadWrite state. The SYN
      event is removed from the list of\n   pending events. The remaining events are
      FIN and DATA-IN. In the\n   ReadWrite state the secondary reads the input data
      (i.e. the DATA-IN\n   event is processed first because it has higher priority
      than the FIN\n   event). Once the data has been read and the DATA-IN event has
      been\n   removed from the list of pending events, the FIN event is processed\n
      \  and the secondary enters the CloseWrite state.\n   If the secondary receives
      a packet containing a SYN event, and is for\n   some reason unable to accept
      the connection (e.g. insufficient\n   resources), it should reject the request
      by sending a SYN event\n   followed by a RESET event. Note that both events
      can be sent as part\n   of the same TMP packet.\n   If either party receives
      a TMP packet that it does not understand, or\n   an event in an incorrect state,
      it closes the TCP connection.\n   +==============+=========+==========+==============+\n
      \  | Entry State  | Event   | Action   | Exit State   |\n   +==============+=========+==========+==============+\n
      \  | Closed       | SYN     | SYN      | ReadWrite    |\n   |              |
      OPEN    | SYN      | OpenWrite    |\n   +--------------+---------+----------+--------------+\n
      \  | OpenWrite    | SYN     | Accept   | ReadWrite    |\n   |              |
      WRITE   | DATA-OUT | OpenWrite    |\n   |              | CLOSE   | FIN      |
      OpenSynRead  |\n   |              | ABORT   | RESET    | OpenSynReset |\n   +--------------+---------+----------+--------------+\n
      \  | OpenSynRead  | SYN     | Accept   | CloseRead    |\n   +--------------+---------+----------+--------------+\n
      \  | OpenSynReset | SYN     | Accept   | Closed       |\n   +--------------+---------+----------+--------------+\n
      \  | ReadWrite    | DATA-IN | Accept   | ReadWrite    |\n   |              |
      FIN     | Accept   | CloseWrite   |\n   |              | RESET   | Accept   |
      Closed       |\n   |              | WRITE   | DATA-OUT | ReadWrite    |\n   |
      \             | CLOSE   | FIN      | CloseRead    |\n   |              | ABORT
      \  | RESET    | Closed       |\n   +--------------+---------+----------+--------------+\n
      \  | CloseWrite   | RESET   | Accept   | Closed       |\n   |              |
      WRITE   | DATA-OUT | CloseWrite   |\n   |              | CLOSE   | FIN      |
      Closed       |\n   |              | ABORT   | RESET    | Closed       |\n   +--------------+---------+----------+--------------+\n
      \  | CloseRead    | DATA-IN | Accept   | CloseRead    |\n   |              |
      FIN     | Accept   | Closed       |\n   |              | RESET   | Accept   |
      Closed       |\n   |              | ABORT   | RESET    | Closed       |\n   +--------------+---------+----------+--------------+\n
      \       TMP Event Priorities and State Transitions\n"
    title: A.6. Event Priorities and State Transitions
  title: Appendix A. The TIP Multiplexing Protocol Version 2.0.
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
