- title: __initial_text__
  contents:
  - "                          Description of the\n     Resource Reservation Protocol\
    \ - Traffic-Engineered (RSVP-TE)\n                      Graceful Restart Procedures\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\
    \ in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n\
    \   Please review these documents carefully, as they describe your rights\n  \
    \ and restrictions with respect to this document.\n   This document may contain\
    \ material from IETF Documents or IETF\n   Contributions published or made publicly\
    \ available before November\n   10, 2008.  The person(s) controlling the copyright\
    \ in some of this\n   material may not have granted the IETF Trust the right to\
    \ allow\n   modifications of such material outside the IETF Standards Process.\n\
    \   Without obtaining an adequate license from the person(s) controlling\n   the\
    \ copyright in such materials, this document may not be modified\n   outside the\
    \ IETF Standards Process, and derivative works of it may\n   not be created outside\
    \ the IETF Standards Process, except to format\n   it for publication as an RFC\
    \ or to translate it into languages other\n   than English.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Hello message for the Resource Reservation Protocol (RSVP) has\n\
    \   been defined to establish and maintain basic signaling node\n   adjacencies\
    \ for Label Switching Routers (LSRs) participating in a\n   Multiprotocol Label\
    \ Switching (MPLS) traffic-engineered (TE) network.\n   The Hello message has\
    \ been extended for use in Generalized MPLS\n   (GMPLS) networks for state recovery\
    \ of control channel or nodal\n   faults.\n   The GMPLS protocol definitions for\
    \ RSVP also allow a restarting node\n   to learn which label it previously allocated\
    \ for use on a Label\n   Switched Path (LSP).\n   Further RSVP protocol extensions\
    \ have been defined to enable a\n   restarting node to recover full control plane\
    \ state by exchanging\n   RSVP messages with its upstream and downstream neighbors.\n\
    \   This document provides an informational clarification of the control\n   plane\
    \ procedures for a GMPLS network when there are multiple node\n   failures, and\
    \ describes how full control plane state can be recovered\n   in different scenarios\
    \ where the order in which the nodes restart is\n   different.\n   This document\
    \ does not define any new processes or procedures.  All\n   protocol mechanisms\
    \ are already defined in the referenced documents.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Existing Procedures for Single Node Restart .....................4\n  \
    \    2.1. Procedures Defined in RFC 3473 .............................4\n    \
    \  2.2. Procedures Defined in RFC 5063 .............................5\n   3. Multiple\
    \ Node Restart Scenarios .................................6\n   4. RSVP State\
    \ ......................................................7\n   5. Procedures for\
    \ Multiple Node Restart ............................7\n      5.1. Procedures for\
    \ the Normal Node .............................8\n      5.2. Procedures for the\
    \ Restarting Node .........................8\n           5.2.1. Procedures for\
    \ Scenario 1 ...........................8\n           5.2.2. Procedures for Scenario\
    \ 2 ...........................9\n           5.2.3. Procedures for Scenario 3\
    \ ..........................11\n           5.2.4. Procedures for Scenario 4 ..........................12\n\
    \           5.2.5. Procedures for Scenario 5 ..........................12\n  \
    \    5.3. Consideration of the Reuse of Data Plane Resources ........12\n    \
    \  5.4. Consideration of Management Plane Intervention ............13\n   6. Clarification\
    \ of Restarting Node Procedure .....................13\n   7. Security Considerations\
    \ ........................................15\n   8. Acknowledgments ................................................16\n\
    \   9. References .....................................................17\n  \
    \    9.1. Normative References ......................................17\n    \
    \  9.2. Informative References ....................................17\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Hello message for the Resource Reservation Protocol\
    \ (RSVP) has\n   been defined to establish and maintain basic signaling node\n\
    \   adjacencies for Label Switching Routers (LSRs) participating in a\n   Multiprotocol\
    \ Label Switching (MPLS) traffic-engineered (TE) network\n   [RFC3209].  The Hello\
    \ message has been extended for use in\n   Generalized MPLS (GMPLS) networks for\
    \ state recovery of control\n   channel or nodal faults through the exchange of\
    \ the Restart_Cap\n   Object [RFC3473].\n   The GMPLS protocol definitions for\
    \ RSVP [RFC3473] also allow a\n   restarting node to learn which label it previously\
    \ allocated for use\n   on a Label Switched Path (LSP) through the Recovery_Label\
    \ Object\n   carried on a Path message sent to a restarting node from its upstream\n\
    \   neighbor.\n   Further RSVP protocol extensions have been defined [RFC5063]\
    \ to\n   perform graceful restart and to enable a restarting node to recover\n\
    \   full control plane state by exchanging RSVP messages with its\n   upstream\
    \ and downstream neighbors.  State previously transmitted to\n   the upstream\
    \ neighbor (principally, the downstream label) is\n   recovered from the upstream\
    \ neighbor on a Path message (using the\n   Recovery_Label Object as described\
    \ in [RFC3473]).  State previously\n   transmitted to the downstream neighbor\
    \ (including the upstream label,\n   interface identifiers, and the explicit route)\
    \ is recovered from the\n   downstream neighbor using a RecoveryPath message.\n\
    \   [RFC5063] also extends the Hello message to exchange information\n   about\
    \ the ability to support the RecoveryPath message.\n   The examples and procedures\
    \ in [RFC3473] and [RFC5063] focus on the\n   description of a single node restart\
    \ when adjacent network nodes are\n   operative.  Although the procedures are\
    \ equally applicable to multi-\n   node restarts, no detailed explanation is provided\
    \ for such a case.\n   This document provides an informational clarification of\
    \ the control\n   plane procedures for a GMPLS network when there are multiple\
    \ node\n   failures, and describes how full control plane state can be recovered\n\
    \   in different scenarios where the order in which the nodes restart is\n   different.\n\
    \   This document does not define any new processes or procedures.  All\n   protocol\
    \ mechanisms already defined in [RFC3473] and [RFC5063] are\n   definitive.\n"
- title: 2.  Existing Procedures for Single Node Restart
  contents:
  - "2.  Existing Procedures for Single Node Restart\n   This section documents for\
    \ information the existing procedures\n   defined in [RFC3473] and [RFC5063].\
    \  Those documents are definitive,\n   and the description here is non-normative.\
    \  It is provided for\n   informational clarification only.\n"
- title: 2.1.  Procedures Defined in RFC 3473
  contents:
  - "2.1.  Procedures Defined in RFC 3473\n   In the case of nodal faults, the procedures\
    \ for the restarting node\n   and the procedures for the neighbor of a restarting\
    \ node are applied\n   to the corresponding nodes.  These procedures, described\
    \ in\n   [RFC3473], are summarized as follows:\n   For the Restarting Node:\n\
    \   1) Tells its neighbors that state recovery is supported using the\n      Hello\
    \ message.\n   2) Recovers its RSVP state with the help of a Path message, received\n\
    \      from its upstream neighbor, that carries the Recovery_Label\n      Object.\n\
    \   3) For bidirectional LSPs, uses the Upstream_Label Object on the\n      received\
    \ Path message to recover the corresponding RSVP state.\n   4) If the corresponding\
    \ forwarding state in the data plane does not\n      exist, the node treats this\
    \ as a setup for a new LSP.  If the\n      forwarding state in the data plane\
    \ does exist, the forwarding\n      state is bound to the LSP associated with\
    \ the message, and the\n      related forwarding state should be considered as\
    \ valid and\n      refreshed.  In addition, if the node is not the tail-end of\
    \ the\n      LSP, the incoming label on the downstream interface is retrieved\n\
    \      from the forwarding state on the restarting node and set in the\n     \
    \ Upstream_Label Object in the Path message sent to the downstream\n      neighbor.\n\
    \   For the Neighbor of a Restarting Node:\n   1) Sends a Path message with the\
    \ Recovery_Label Object containing a\n      label value corresponding to the label\
    \ value received in the most\n      recently received corresponding Resv message.\n\
    \   2) Resumes refreshing Path state with the restarting node.\n   3) Resumes\
    \ refreshing Resv state with the restarting node.\n"
- title: 2.2.  Procedures Defined in RFC 5063
  contents:
  - "2.2.  Procedures Defined in RFC 5063\n   A new message is introduced in [RFC5063]\
    \ called the RecoveryPath\n   message.  This message is sent by the downstream\
    \ neighbor of a\n   restarting node to convey the contents of the last received\
    \ Path\n   message back to the restarting node.\n   The restarting node will receive\
    \ the Path message with the\n   Recovery_Label Object from its upstream neighbor\
    \ and/or the\n   RecoveryPath message from its downstream neighbor.  The full\
    \ RSVP\n   state of the restarting node can be recovered from these two\n   messages.\n\
    \   The following state can be recovered from the received Path message:\n   o\
    \ Upstream data interface (from RSVP_Hop Object)\n   o Label on the upstream data\
    \ interface (from Recovery_Label Object)\n   o Upstream label for bidirectional\
    \ LSP (from Upstream_Label Object)\n   The following state can be recovered from\
    \ the received RecoveryPath\n   message:\n   o Downstream data interface (from\
    \ RSVP_Hop Object)\n   o Label on the downstream data interface (from Recovery_Label\
    \ Object)\n   o Upstream direction label for bidirectional LSP (from Upstream_Label\n\
    \     Object)\n   The other objects originally exchanged on Path and Resv messages\
    \ can\n   be recovered from the regular Path and Resv refresh messages, or from\n\
    \   the RecoveryPath.\n"
- title: 3.  Multiple Node Restart Scenarios
  contents:
  - "3.  Multiple Node Restart Scenarios\n   We define the following terms for the\
    \ different node types:\n   Restarting - The node has restarted.  Communication\
    \ with its neighbor\n      nodes is restored, and its RSVP state is under recovery.\n\
    \   Delayed Restarting - The node has restarted, but the communication\n     \
    \ with a neighbor node is interrupted (for example, the neighbor\n      node needs\
    \ to restart).\n   Normal - The normal node is the fully operational neighbor\
    \ of a\n      restarting or delayed restarting node.\n   There are five scenarios\
    \ for multi-node restart.  We will focus on\n   the different positions of a restarting\
    \ node.  As shown in Figure 1,\n   an LSP starts from Node A, traverses Nodes\
    \ B and C, and ends at Node\n   D.\n          +-----+  Path  +-----+  Path  +-----+\
    \  Path  +-----+\n          | PSB |------->| PSB |------->| PSB |------->| PSB\
    \ |\n          |     |        |     |        |     |        |     |\n        \
    \  | RSB |<-------| RSB |<-------| RSB |<-------| RSB |\n          +-----+  Resv\
    \  +-----+  Resv  +-----+  Resv  +-----+\n          Node A         Node B    \
    \     Node C         Node D\n                   Figure 1: Two Neighbor Nodes Restart\n\
    \   1) A restarting node with downstream delayed restarting node.  For\n     \
    \ example, in Figure 1, Nodes A and D are normal nodes, Node B is a\n      restarting\
    \ node, and Node C is a delayed restarting node.\n   2) A restarting node with\
    \ upstream delayed restarting node.  For\n      example, in Figure 1, Nodes A\
    \ and D are normal nodes, Node B is a\n      delayed restarting node, and Node\
    \ C is a restarting node.\n   3) A restarting node with downstream and upstream\
    \ delayed restarting\n      nodes.  For example, in Figure 1, Node A is a normal\
    \ node, Nodes B\n      and D are delayed restarting nodes, and Node C is a restarting\n\
    \      node.\n   4) A restarting ingress node with downstream delayed restarting\
    \ node.\n      For example, in Figure 1, Node A is a restarting node and Node\
    \ B\n      is a delayed restarting node.  Nodes C and D are normal nodes.\n  \
    \ 5) A restarting egress node with upstream delayed restarting node.\n      For\
    \ example, in Figure 1, Nodes A and B are normal nodes, Node C\n      is a delayed\
    \ restarting node, and Node D is a restarting node.\n   If the communication between\
    \ two nodes is interrupted, the upstream\n   node may think the downstream node\
    \ is a delayed restarting node, or\n   vice versa.\n   Note that if multiple nodes\
    \ that are not neighbors are restarted, the\n   restart procedures could be applied\
    \ as multiple separated restart\n   procedures that are exactly the same as the\
    \ procedures described in\n   [RFC3473] and [RFC5063].  Therefore, these scenarios\
    \ are not\n   described in this document.  For example, in Figure 1, Node A and\n\
    \   Node C are normal nodes, and Node B and Node D are restarting nodes;\n   therefore,\
    \ Node B could be restarted through Node A and Node C, while\n   Node D could\
    \ be restarted through Node C separately.\n"
- title: 4.  RSVP State
  contents:
  - "4.  RSVP State\n   For each scenario, the RSVP state that needs to be recovered\
    \ at the\n   restarting nodes are the Path State Block (PSB) and Resv State Block\n\
    \   (RSB), which are created when the node receives the corresponding\n   Path\
    \ message and Resv message.\n   According to [RFC2209], how to construct the PSB\
    \ and RSB is really an\n   implementation issue.  In fact, there is no requirement\
    \ to maintain\n   separate PSB and RSB data structures.  In GMPLS, there is a\
    \ much\n   closer tie between Path and Resv state so it is possible to combine\n\
    \   the information into a single state block (the LSP state block).  On\n   the\
    \ other hand, if point-to-multipoint is supported, it may be\n   convenient to\
    \ maintain separate upstream and downstream state.  Note\n   that the PSB and\
    \ RSB are not upstream and downstream state since the\n   PSB is responsible for\
    \ receiving a Path from upstream and sending a\n   Path to downstream.\n   Regardless\
    \ of how the RSVP state is implemented, on recovery there\n   are two logical\
    \ pieces of state to be recovered and these correspond\n   to the PSB and RSB.\n"
- title: 5.  Procedures for Multiple Node Restart
  contents:
  - "5.  Procedures for Multiple Node Restart\n   In this document, all the nodes\
    \ are assumed to have the graceful\n   restart capabilities that are described\
    \ in [RFC3473] and [RFC5063].\n"
- title: 5.1.  Procedures for the Normal Node
  contents:
  - "5.1.  Procedures for the Normal Node\n   When the downstream normal node detects\
    \ its neighbor restarting, it\n   must send a RecoveryPath message for each LSP\
    \ associated with the\n   restarting node for which it has previously sent a Resv\
    \ message and\n   which has not been torn down.\n   When the upstream normal node\
    \ detects its neighbor restarting, it\n   must send a Path message with a Recovery_Label\
    \ Object containing a\n   label value corresponding to the label value received\
    \ in the most\n   recently received corresponding Resv message.\n   This document\
    \ does not modify the procedures for the normal node,\n   which are described\
    \ in [RFC3473] and [RFC5063].\n"
- title: 5.2.  Procedures for the Restarting Node
  contents:
  - "5.2.  Procedures for the Restarting Node\n   This document does not modify the\
    \ procedures for the restarting node,\n   which are described in [RFC3473] and\
    \ [RFC5063].\n"
- title: 5.2.1.  Procedures for Scenario 1
  contents:
  - "5.2.1.  Procedures for Scenario 1\n   After the restarting node restarts, it\
    \ starts a Recovery Timer.  Any\n   RSVP state that has not been resynchronized\
    \ when the Recovery Timer\n   expires should be cleared.\n   At the restarting\
    \ node (Node B in the example), full\n   resynchronization with the upstream neighbor\
    \ (Node A) is possible\n   because Node A is a normal node.  The upstream Path\
    \ information is\n   recovered from the Path message received from Node A.  Node\
    \ B also\n   recovers the upstream Resv information (that it had previously sent\n\
    \   to Node A) from the Recovery_Label Object carried in the Path message\n  \
    \ received from Node A, but, obviously, some information (like the\n   Recorded_Route\
    \ Object) will be missing from the new Resv message\n   generated by Node B and\
    \ cannot be supplied until the downstream\n   delayed restarting node (Node C)\
    \ restarts and sends a Resv.\n   After the upstream Path information and upstream\
    \ Resv information\n   have been recovered by Node B, the normal refresh procedure\
    \ with\n   upstream Node A should be started.\n   As per [RFC5063], the restarting\
    \ node (Node B) would normally expect\n   to receive a RecoveryPath message from\
    \ its downstream neighbor (Node\n   C).  It would use this to recover the downstream\
    \ Path information,\n   and would subsequently send a Path message to its downstream\
    \ neighbor\n   and receive a Resv message.  But in this scenario, because the\n\
    \   downstream neighbor has not restarted yet, Node B detects the\n   communication\
    \ with\n   Node C is interrupted and must wait before resynchronizing with its\n\
    \   downstream neighbor.\n   In this case, the restarting node (Node B) follows\
    \ the procedures in\n   Section 9.3 of [RFC3473] and may run a Restart Timer to\
    \ wait for the\n   downstream neighbor (Node C) to restart.  If its downstream\
    \ neighbor\n   (Node C) has not restarted before the timer expires, the\n   corresponding\
    \ LSPs may be torn down according to local policy\n   [RFC3473].  Note, however,\
    \ that the Restart Time value suggested in\n   [RFC3473] is based on the previous\
    \ Hello message exchanged with the\n   node that has not restarted yet (Node C).\
    \  Since this time value is\n   unlikely to be available to the restarting node\
    \ (Node B), a\n   configured time value must be used if the timer is operated.\n\
    \   The RSVP state must be reconciled with the retained data plane state\n   if\
    \ the cross-connect information can be retrieved from the data\n   plane.  In\
    \ the event of any mismatches, local policy will dictate the\n   action that must\
    \ be taken, which could include:\n   - reprogramming the data plane\n   - sending\
    \ an alert to the management plane\n   - tearing down the control plane state\
    \ for the LSP\n   In the case that the delayed restarting node never comes back\
    \ and a\n   Restart Timer is not used to automatically tear down LSPs, the LSPs\n\
    \   can be tidied up through the control plane using a PathTear from the\n   upstream\
    \ node (Node A).  Note that if Node C restarts after this\n   operation, the RecoveryPath\
    \ message that it sends to Node B will not\n   be matched with any state on Node\
    \ B and will receive a PathTear as\n   its response, resulting in the teardown\
    \ of the LSP at all downstream\n   nodes.\n"
- title: 5.2.2.  Procedures for Scenario 2
  contents:
  - "5.2.2.  Procedures for Scenario 2\n   In this case, the restarting node (Node\
    \ C) can recover full\n   downstream state from its downstream neighbor (Node\
    \ D), which is a\n   normal node.  The downstream Path state can be recovered\
    \ from the\n   RecoveryPath message, which is sent by Node D.  This allows Node\
    \ C to\n   send a Path refresh message to Node D, and Node D will respond with\
    \ a\n   Resv message from which Node C can reconstruct the downstream Resv\n \
    \  state.\n   After the downstream Path information and downstream Resv information\n\
    \   have been recovered in Node C, the normal refresh procedure with\n   downstream\
    \ Node D should be started.\n   The restarting node would normally expect to resynchronize\
    \ with its\n   upstream neighbor to re-learn the upstream Path and Resv state,\
    \ but\n   in this scenario, because the upstream neighbor (Node B) has not\n \
    \  restarted yet, the restarting node (Node C) detects that the\n   communication\
    \ with upstream neighbor (Node B) is interrupted.  The\n   restarting node (Node\
    \ C) follows the procedures in Section 9.3 of\n   [RFC3473] and may run a Restart\
    \ Timer to wait for the upstream\n   neighbor (Node B) to restart.  If its upstream\
    \ neighbor (Node B) has\n   not restarted before the Restart Timer expires, the\
    \ corresponding\n   LSPs may be torn down according to local policy [RFC3473].\
    \  Note,\n   however, that the Restart Time value suggested in [RFC3473] is based\n\
    \   on the previous Hello message exchanged with the node that has not\n   restarted\
    \ yet (Node B).  Since this time value is unlikely to be\n   available to the\
    \ restarting node (Node C), a configured time value\n   must be used if the timer\
    \ is operated.\n   Note that no Resv message is sent to the upstream neighbor\
    \ (Node B),\n   because it has not restarted.\n   The RSVP state must be reconciled\
    \ with the retained data plane state\n   if the cross-connect information can\
    \ be retrieved from the data\n   plane.\n   In the event of any mismatches, local\
    \ policy will dictate the action\n   that must be taken, which could include:\n\
    \   - reprogramming the data plane\n   - sending an alert to the management plane\n\
    \   - tearing down the control plane state for the LSP\n   In the case that the\
    \ delayed restarting node never comes back and a\n   Restart Timer is not used\
    \ to automatically tear down LSPs, the LSPs\n   cannot be tidied up through the\
    \ control plane using a PathTear from\n   the upstream node (Node A), because\
    \ there is no control plane\n   connectivity to Node C from the upstream direction.\
    \  There are two\n   possibilities in [RFC3473]:\n   - Management action may be\
    \ taken at the restarting node to tear the\n     LSP.  This will result in the\
    \ LSP being removed from Node C and a\n     PathTear being sent downstream to\
    \ Node D.\n   - Management action may be taken at any downstream node (for example,\n\
    \     Node D), resulting in a PathErr message with the Path_State_Removed\n  \
    \   flag set being sent to Node C to tear the LSP state.\n   Note that if Node\
    \ B restarts after this operation, the Path message\n   that it sends to Node\
    \ C will not be matched with any state on Node C\n   and will be treated as a\
    \ new Path message, resulting in LSP setup.\n   Node C should use the labels carried\
    \ in the Path message (in the\n   Upstream_Label Object and in the Recovery_Label\
    \ Object) to drive its\n   label allocation, but may use other labels according\
    \ to normal LSP\n   setup rules.\n"
- title: 5.2.3.  Procedures for Scenario 3
  contents:
  - "5.2.3.  Procedures for Scenario 3\n   In this example, the restarting node (Node\
    \ C) is isolated.  Its\n   upstream and downstream neighbors have not restarted.\n\
    \   The restarting node (Node C) follows the procedures in Section 9.3 of\n  \
    \ [RFC3473] and may run a Restart Timer for each of its neighbors\n   (Nodes B\
    \ and D).  If a neighbor has not restarted before its Restart\n   Timer expires,\
    \ the corresponding LSPs may be torn down according to\n   local policy [RFC3473].\
    \  Note, however, that the Restart Time values\n   suggested in [RFC3473] are\
    \ based on the previous Hello message\n   exchanged with the nodes that have not\
    \ restarted yet.  Since these\n   time values are unlikely to be available to\
    \ the restarting node (Node\n   C), a configured time value must be used if the\
    \ timer is operated.\n   During the Recovery Time, if the upstream delayed restarting\
    \ node has\n   restarted, the procedure for scenario 1 can be applied.\n   During\
    \ the Recovery Time, if the downstream delayed restarting node\n   has restarted,\
    \ the procedure for scenario 2 can be applied.\n   In the case that neither delayed\
    \ restarting node ever comes back and\n   a Restart Timer is not used to automatically\
    \ tear down LSPs,\n   management intervention is required to tidy up the control\
    \ plane and\n   the data plane on the node that is waiting for the failed device\
    \ to\n   restart.\n   If the downstream delayed restarting node restarts after\
    \ the cleanup\n   of LSPs at Node C, the RecoveryPath message from Node D will\
    \ be\n   responded to with a PathTear message.  If the upstream delayed\n   restarting\
    \ node restarts after the cleanup of LSPs at Node C, the\n   Path message from\
    \ Node B will be treated as a new LSP setup request,\n   but the setup will fail\
    \ because Node D cannot be reached; Node C will\n   respond with a PathErr message.\
    \  Since this happens to Node B during\n   its restart processing, it should follow\
    \ the rules of [RFC5063] and\n   tear down the LSP.\n"
- title: 5.2.4.  Procedures for Scenario 4
  contents:
  - "5.2.4.  Procedures for Scenario 4\n   When the ingress node (Node A) restarts,\
    \ it does not know which LSPs\n   it caused to be created.  Usually, however,\
    \ this information is\n   retrieved from the management plane or from the configuration\n\
    \   requests stored in non-volatile form in the node in order to recover\n   the\
    \ LSP state.\n   Furthermore, if the downstream node (Node B) is a normal node,\n\
    \   according to the procedures in [RFC5063], the ingress will receive a\n   RecoveryPath\
    \ message and will understand that it was the ingress of\n   the LSP.\n   However,\
    \ in this scenario, the downstream node is a delayed\n   restarting node, so Node\
    \ A must either rely on the information from\n   the management plane or stored\
    \ configuration, or it must wait for\n   Node B to restart.\n   In the event that\
    \ Node B never restarts, management plane\n   intervention is needed at Node A\
    \ to clean up any LSP control plane\n   state restored from the management plane\
    \ or from local configuration,\n   and to release any data plane resources.\n"
- title: 5.2.5.  Procedures for Scenario 5
  contents:
  - "5.2.5.  Procedures for Scenario 5\n   In this scenario, the egress node (Node\
    \ D) restarts, and its upstream\n   neighbor (Node C) has not restarted.  In this\
    \ case, the egress node\n   may have no control plane state relating to the LSPs.\
    \  It has no\n   downstream neighbor to help it and no management plane or\n \
    \  configuration information, although there will be data plane state\n   for\
    \ the LSP.  The egress node must simply wait until its upstream\n   neighbor restarts\
    \ and gives it the information in Path messages\n   carrying Recovery_Label Objects.\n"
- title: 5.3.  Consideration of the Reuse of Data Plane Resources
  contents:
  - "5.3.  Consideration of the Reuse of Data Plane Resources\n   Fundamental to the\
    \ processes described above is an understanding that\n   data plane resources\
    \ may remain in use (allocated and cross-\n   connected) when control plane state\
    \ has not been fully resynchronized\n   because some control plane nodes have\
    \ not restarted.\n   It is assumed that these data plane resources might be carrying\n\
    \   traffic and should not be reconfigured except through application of\n   operator-configured\
    \ policy, or as a direct result of operator action.\n   In particular, new LSP\
    \ setup requests from the control plane or the\n   management plane should not\
    \ be allowed to use data plane resources\n   that are still in use.  Specific\
    \ action must first be taken to\n   release the resources.\n"
- title: 5.4.  Consideration of Management Plane Intervention
  contents:
  - "5.4.  Consideration of Management Plane Intervention\n   The management plane\
    \ must always retain the ability to control data\n   plane resources and to override\
    \ the control plane.  In this context,\n   the management plane must always be\
    \ able to release data plane\n   resources that were previously in place for use\
    \ by control-plane-\n   established LSPs.  Further, the management plane must\
    \ always be able\n   to instruct any control plane node to tear down any LSP.\n\
    \   Operators should be aware of the risks of misconnection that could be\n  \
    \ caused by careless manipulation from the management plane of in-use\n   data\
    \ plane resources.\n"
- title: 6.  Clarification of Restarting Node Procedure
  contents:
  - "6.  Clarification of Restarting Node Procedure\n   According to the current graceful\
    \ restart procedure [RFC3473], after\n   a node restarts its control plane, it\
    \ needs its upstream node to send\n   a PATH message with a recovery label in\
    \ order to synchronize its RSVP\n   state.  If the restarted control plane becomes\
    \ operational quickly,\n   the upstream node may not detect the restarting of\
    \ the downstream\n   node and, therefore, may send a PATH message without a recovery\n\
    \   label, causing errors and unwanted connection deletion.\n     N1         \
    \      N2\n     |                |\n     |                X (Restart start)\n\
    \     | HELLO          |\n     |--------------->|\n     |                |\n \
    \    | SRefresh       |\n     |--------------->|\n     |                |\n  \
    \   | HELLO          |\n     |--------------->|\n     |                |\n   \
    \  |                X (Restart complete)\n     | SRefresh       |\n     |--------------->|\n\
    \     | NACK           |\n     |<---------------|\n     | Path without   |\n \
    \    | recovery label |\n     |--------------->|\n     |                X (resource\
    \ allocation failed because the\n     |                | resources are in use)\n\
    \     |  PathErr       |\n     |<---------------|\n     |  PathTear      |\n \
    \    |--------------->|\n     X(LSP deletion)  X (LSP deletion)\n     |      \
    \          |\n            Figure 2: Message Flow for Accidental LSP Deletion\n\
    \   The sequence diagram above depicts one scenario where the LSP may get\n  \
    \ deleted.\n   In this sequence, N1 does not detect Hello failure and continues\n\
    \   sending SRefreshes, which may get NACK'ed by N2 once restart\n   completes\
    \ because there is no Path state corresponding to the\n   SRefresh message.  This\
    \ NACK causes a Path refresh message to be\n   generated, but there is no Recovery_Label\
    \ because N1 does not yet\n   detect that N2 has restarted, as Hello exchanges\
    \ have not yet\n   started.  The Path message is treated as \"new\" and fails\
    \ to allocate\n   the resources because they are still in use.  This causes a\
    \ PathErr\n   message to be generated, which may lead to the teardown of the LSP.\n\
    \   To resolve the aforementioned problem, the following procedures,\n   which\
    \ are implicit in [RFC3473] and [RFC5063], should be followed.\n   These procedures\
    \ work together with the recovery procedures\n   documented in [RFC3473].  Here,\
    \ it is assumed that the restarting\n   node and the neighboring node(s) support\
    \ the Hello extension as\n   documented in [RFC3209] as well as the recovery procedures\
    \ documented\n   in [RFC3473].\n   After a node restarts its control plane, it\
    \ should ignore and\n   silently drop all RSVP-TE messages (except Hello messages)\
    \ it\n   receives from any neighbor to which no HELLO session has been\n   established.\n\
    \   The restarting node should follow [RFC3209] to establish Hello\n   sessions\
    \ with its neighbors, after its control plane becomes\n   operational.\n   The\
    \ restarting node resumes processing of RSVP-TE messages sent from\n   each neighbor\
    \ to which the Hello session has been established.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This document clarifies the procedures defined\
    \ in [RFC3473] and\n   [RFC5063] to be performed on RSVP agents that neighbor\
    \ one or more\n   restarting RSVP agents.  It does not introduce any new procedures\n\
    \   and, therefore, does not introduce any new security risks or issues.\n   In\
    \ the case of the control plane in general, and the RSVP agent in\n   particular,\
    \ where one or more nodes carrying one or more LSPs are\n   restarted due to external\
    \ attacks, the procedures defined in\n   [RFC5063] and described in this document\
    \ provide the ability for the\n   restarting RSVP agents to recover the RSVP state\
    \ in each restarting\n   node corresponding to the LSPs, with the least possible\
    \ perturbation\n   to the rest of the network.  These procedures can be considered\
    \ to\n   provide mechanisms by which the GMPLS network can recover from\n   physical\
    \ attacks or from attacks on remotely controlled power\n   supplies.\n   The procedures\
    \ described are such that only the neighboring RSVP\n   agents should notice the\
    \ restart of a node, and hence only they need\n   to perform additional processing.\
    \  This allows for a network with\n   active LSPs to recover LSP state gracefully\
    \ from an external attack,\n   without perturbing the data/forwarding plane state\
    \ and without\n   propagating the error condition in the control or data plane.\
    \  In\n   other words, the effect of the restart (which might be the result of\n\
    \   an attack) does not spread into the network.\n   Note that concern has been\
    \ expressed about the vulnerability of a\n   restarting node to false messages\
    \ received from its neighbors.  For\n   example, a restarting node might receive\
    \ a false Path message with a\n   Recovery_Label Object from an upstream neighbor,\
    \ or a false\n   RecoveryPath message from its downstream neighbor.  This situation\n\
    \   might arise in one of four cases:\n   - The message is spoofed and does not\
    \ come from the neighbor at all.\n   - The message has been modified as it was\
    \ traveling from the\n     neighbor.\n   - The neighbor is defective and has generated\
    \ a message in error.\n   - The neighbor has been subverted and has a \"rogue\"\
    \ RSVP agent.\n   The first two cases may be handled using standard RSVP authentication\n\
    \   and integrity procedures [RFC3209], [RFC3473].  If the operator is\n   particularly\
    \ worried, the control plane may be operated using IPsec\n   [RFC4301], [RFC4302],\
    \ [RFC4835], [RFC4306], and [RFC2411].\n   Protection against defective or rogue\
    \ RSVP implementations is\n   generally hard-to-impossible.  Neighbor-to-neighbor\
    \ authentication\n   and integrity validation is, by definition, ineffective in\
    \ these\n   situations.  For example, if a neighbor node sends a Resv during\n\
    \   normal LSP setup, and if that message carries a Generalized_Label\n   Object\
    \ carrying an incorrect label value, then the receiving LSR will\n   use the supplied\
    \ value and the LSP will be set up incorrectly.\n   Alternatively, if a Path message\
    \ is modified by an upstream LSR to\n   change the destination and explicit route,\
    \ there is no way for the\n   downstream LSR to detect this, and the LSP may be\
    \ set up to the wrong\n   destination.  Furthermore, the upstream LSR could disguise\
    \ this fact\n   by modifying the recorded route reported in the Resv message.\
    \  Thus,\n   these issues are in no way specific to the restart case, do not cause\n\
    \   any greater or different problems from the normal case, and do not\n   warrant\
    \ specific security measures applicable to restart scenarios.\n   Note that the\
    \ RSVP Policy_Data Object [RFC2205] provides a scope by\n   which secure end-to-end\
    \ checks could be applied.  However, very\n   little definition of the use of\
    \ this object has been made to date.\n   See [MPLS-SEC] for a wider discussion\
    \ of security in MPLS and GMPLS\n   networks.\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   We would like to thank Adrian Farrel, Dimitri Papadimitriou,\
    \ and Lou\n   Berger for their useful comments.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2209]  Braden, R. and L. Zhang, \"Resource\
    \ ReSerVation Protocol\n              (RSVP) -- Version 1 Message Processing Rules\"\
    , RFC 2209,\n              September 1997.\n   [RFC3209]  Awduche, D., Berger,\
    \ L., Gan, D., Li, T., Srinivasan, V.,\n              and G. Swallow, \"RSVP-TE:\
    \ Extensions to RSVP for LSP\n              Tunnels\", RFC 3209, December 2001.\n\
    \   [RFC3473]  Berger, L., Ed., \"Generalized Multi-Protocol Label\n         \
    \     Switching (GMPLS) Signaling Resource ReserVation\n              Protocol-Traffic\
    \ Engineering (RSVP-TE) Extensions\", RFC\n              3473, January 2003.\n\
    \   [RFC5063]  Satyanarayana, A., Ed., and R. Rahman, Ed., \"Extensions to\n \
    \             GMPLS Resource Reservation Protocol (RSVP) Graceful\n          \
    \    Restart\", RFC 5063, October 2007.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [MPLS-SEC] Fang, L., \"Security Framework for\
    \ MPLS and GMPLS\n              Networks\", Work in Progress, November 2008.\n\
    \   [RFC2205]  Braden, R., Ed., Zhang, L., Berson, S., Herzog, S., and S.\n  \
    \            Jamin, \"Resource ReSerVation Protocol (RSVP) -- Version 1\n    \
    \          Functional Specification\", RFC 2205, September 1997.\n   [RFC2411]\
    \  Thayer, R., Doraswamy, N., and R. Glenn, \"IP Security\n              Document\
    \ Roadmap\", RFC 2411, November 1998.\n   [RFC4301]  Kent, S. and K. Seo, \"Security\
    \ Architecture for the\n              Internet Protocol\", RFC 4301, December\
    \ 2005.\n   [RFC4302]  Kent, S., \"IP Authentication Header\", RFC 4302, December\n\
    \              2005.\n   [RFC4306]  Kaufman, C., Ed., \"Internet Key Exchange\
    \ (IKEv2)\n              Protocol\", RFC 4306, December 2005.\n   [RFC4835]  Manral,\
    \ V., \"Cryptographic Algorithm Implementation\n              Requirements for\
    \ Encapsulating Security Payload (ESP) and\n              Authentication Header\
    \ (AH)\", RFC 4835, April 2007.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Dan Li\n   Huawei Technologies\n   F3-5-B R&D Center,\
    \ Huawei Base,\n   Shenzhen 518129, China\n   Phone: +86 755 28970230\n   EMail:\
    \ danli@huawei.com\n   Jianhua Gao\n   Huawei Technologies\n   F3-5-B R&D Center,\
    \ Huawei Base,\n   Shenzhen 518129, China\n   Phone: +86 755 28972902\n   EMail:\
    \ gjhhit@huawei.com\n   Arun Satyanarayana\n   Cisco Systems\n   170 West Tasman\
    \ Dr\n   San Jose, CA 95134, USA\n   Phone: +1 408 853-3206\n   EMail: asatyana@cisco.com\n\
    \   Snigdho C. Bardalai\n   Fujitsu Network Communications\n   2801 Telecom Parkway\n\
    \   Richardson, Texas 75082, USA\n   Phone: +1 972 479 2951\n   EMail: snigdho.bardalai@us.fujitsu.com\n"
