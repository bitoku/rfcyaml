- title: __initial_text__
  contents:
  - '      Wave and Equation Based Rate Control (WEBRC) Building Block

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies Wave and Equation Based Rate Control (WEBRC),\n\
    \   which provides rate and congestion control for data delivery.  WEBRC\n   is\
    \ specifically designed to support protocols using IP multicast.  It\n   provides\
    \ multiple-rate, congestion-controlled delivery to receivers,\n   i.e., different\
    \ receivers joined to the same session may be receiving\n   packets at different\
    \ rates depending on the bandwidths of their\n   individual connections to the\
    \ sender and on competing traffic along\n   these connections.  WEBRC requires\
    \ no feedback from receivers to the\n   sender, i.e., it is a completely receiver-driven\
    \ congestion control\n   protocol.  Thus, it is designed to scale to potentially\
    \ massive\n   numbers of receivers attached to a session from a single sender.\n\
    \   Furthermore, because each individual receiver adjusts to the\n   available\
    \ bandwidth between the sender and that receiver, there is\n   the potential to\
    \ deliver data to each individual receiver at the\n   fastest possible rate for\
    \ that receiver, even in a highly\n   heterogeneous network architecture, using\
    \ a single sender.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction. . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Rationale . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   5\n   3.  Functionality . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   6\n       3.1. Sender Operation . . . . . . . . . . . . . . . . . .\
    \ . .   9\n            3.1.1. Sender inputs and initialization. . . . . . . .\
    \ .   9\n            3.1.2. Sending packets to the session. . . . . . . . . .\
    \  10\n       3.2. Receiver Operation . . . . . . . . . . . . . . . . . . .  12\n\
    \            3.2.1. Receiver inputs and initialization. . . . . . . .  12\n  \
    \          3.2.2. Receiver measurements and calculations. . . . . .  13\n    \
    \               3.2.2.1. Average loss probability . . . . . . . .  13\n      \
    \             3.2.2.2. Average round-trip time. . . . . . . . .  16\n        \
    \           3.2.2.3. Rate Equation. . . . . . . . . . . . . .  16\n          \
    \         3.2.2.4. Epochs . . . . . . . . . . . . . . . . .  17\n            \
    \       3.2.2.5. Average reception rate . . . . . . . . .  17\n              \
    \     3.2.2.6. Slow start . . . . . . . . . . . . . . .  19\n                \
    \   3.2.2.7. Target rate. . . . . . . . . . . . . . .  20\n            3.2.3.\
    \ Receiver events . . . . . . . . . . . . . . . . .  20\n                   3.2.3.1.\
    \ Packet reception . . . . . . . . . . . .  20\n                   3.2.3.2. First\
    \ packet after join. . . . . . . . .  20\n                   3.2.3.3. Time slot\
    \ change . . . . . . . . . . . .  20\n                   3.2.3.4. Loss event .\
    \ . . . . . . . . . . . . . .  21\n                   3.2.3.5. Epoch change .\
    \ . . . . . . . . . . . . .  21\n                   3.2.3.6. Join the next higher\
    \ layer . . . . . . .  21\n                   3.2.3.7. Join timeout . . . . .\
    \ . . . . . . . . .  23\n                   3.2.3.8. Exceptional timeouts . .\
    \ . . . . . . . .  23\n   4.  Applicability Statement . . . . . . . . . . . .\
    \ . . . . . . .  23\n       4.1. Environmental Requirements and Considerations.\
    \ . . . . .  23\n   5.  Packet Header Fields. . . . . . . . . . . . . . . . .\
    \ . . . .  25\n       5.1. Short Format Congestion Control Information. . . .\
    \ . . .  26\n       5.2. Long Format Congestion Control Information . . . . .\
    \ . .  27\n   6.  Requirements From Other Building Blocks . . . . . . . . . .\
    \ .  28\n   7.  Security Considerations . . . . . . . . . . . . . . . . . . .\
    \  28\n   8.  References. . . . . . . . . . . . . . . . . . . . . . . . . .  29\n\
    \       8.1. Normative References . . . . . . . . . . . . . . . . . .  29\n  \
    \     8.2. Informative References . . . . . . . . . . . . . . . . .  30\n   9.\
    \  Authors' Addresses. . . . . . . . . . . . . . . . . . . . . .  31\n   10. Full\
    \ Copyright Statement. . . . . . . . . . . . . . . . . . .  32\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies Wave and Equation Based Rate Control\
    \ (WEBRC).\n   WEBRC is a congestion control building block that is designed to\
    \ be\n   massively scalable when used with the IP multicast network service.\n\
    \   WEBRC is also suitable as the basis for unicast congestion control,\n   but\
    \ this is outside the scope of this document.  WEBRC is designed to\n   compete\
    \ fairly with TCP and similar congestion-controlled sessions.\n   WEBRC can be\
    \ used as a congestion control protocol for any type of\n   data delivery, including\
    \ reliable content delivery and streaming\n   delivery.\n   WEBRC is a receiver-driven\
    \ congestion control protocol in the spirit\n   of [5] and [18].  This means that\
    \ all measurements and decisions to\n   raise or lower the reception rate are\
    \ made by each individual\n   receiver, and these decisions are acted upon by\
    \ sending join and\n   leave messages for channels to the network.  A receiver\
    \ using WEBRC\n   adjusts its reception rate without regard for other concerns\
    \ such as\n   reliability.  This is different from TCP, where the congestion\n\
    \   control protocol and the reliability protocol are intricately\n   interwoven.\n\
    \   WEBRC takes the same basic equation-based approach as TFRC [9].  In\n   particular,\
    \ each WEBRC receiver measures parameters that are plugged\n   into a TCP-like\
    \ equation to compute the receiver target reception\n   rate and adjusts its reception\
    \ rate up and down to closely\n   approximate the target reception rate.  The\
    \ sender sends packets to\n   multiple channels; one channel is called the base\
    \ channel and the\n   remaining channels are called wave channels.  Each wave\
    \ channel\n   follows the same pattern of packet rate transmission spread out\
    \ over\n   equally-spaced intervals of time.  The pattern of each wave is that\n\
    \   it starts at a high rate and the rate decreases gradually and\n   continually\
    \ over a long period of time.  (Picture an infinite\n   sequence of waves.)  The\
    \ receiver increases its reception rate by\n   joining the next wave channel earlier\
    \ in the descent of the wave than\n   it joined the previous wave channel, and\
    \ the receiver decreases its\n   reception rate by joining the next wave channel\
    \ later in the descent\n   of the wave than it joined the previous wave channel.\n\
    \   The wave channels are ordered at each point in time from a lowest\n   layer\
    \ to a highest layer.  At each point in time, the lowest layer is\n   the wave\
    \ channel that among all active wave channels is nearest to\n   the end of its\
    \ active period; the highest layer is the wave channel\n   that is furthest from\
    \ the end of its active period.  Because waves\n   are dynamically becoming active\
    \ and quiescent over time, the\n   designation of which wave channel is at which\
    \ layer changes\n   dynamically over time.  In addition to being joined to the\
    \ base\n   channel, at each point in time a receiver is joined to a consecutive\n\
    \   set of layers starting at the lowest layer and proceeding towards the\n  \
    \ highest.\n   WEBRC introduces a natural notion of a multicast round-trip time\n\
    \   (MRTT).  An MRTT is measured individually by each receiver and\n   averaged\
    \ as a substitute for conventional unicast round-trip time\n   (RTT).  Because\
    \ the throughput of a TCP session depends strongly on\n   RTT, having some measure\
    \ of RTT is essential in making the WEBRC\n   equation-based rate control protocol\
    \ \"TCP-friendly\".  The use of the\n   MRTT also helps to coordinate and equalize\
    \ the reception rates of\n   proximate receivers joined to a session behind a\
    \ bottleneck link.\n   This implies that packets for the session that flow through\
    \ the\n   bottleneck link are on average sent to almost all downstream\n   receivers,\
    \ and thus the efficiencies of multicast are realized.\n   Furthermore, WEBRC\
    \ is designed to be massively scalable in the sense\n   that the sender is insensitive\
    \ to the number of receivers joined to a\n   multicast session.\n   WEBRC is designed\
    \ for applications that use a fixed packet size and\n   vary their packet reception\
    \ rates in response to congestion.  WEBRC\n   is designed to be reasonably fair\
    \ when competing for bandwidth with\n   TCP flows, where a flow is \"reasonably\
    \ fair\" if its reception rate is\n   generally within a factor of two of the\
    \ reception rate of a TCP flow\n   under the same conditions.  However WEBRC has\
    \ a much lower variation\n   of throughput over time compared to TCP, which makes\
    \ it more suitable\n   for applications such as telephony or streaming media where\
    \ a\n   relatively smooth rate is of importance.  The penalty of having\n   smoother\
    \ throughput than TCP while competing fairly for bandwidth is\n   that WEBRC responds\
    \ more slowly than TCP to changes in available\n   bandwidth.\n   The receiver\
    \ measures and performs the calculation of congestion\n   control parameters (e.g.,\
    \ the average loss probability, the average\n   MRTT) and makes decisions on how\
    \ to increase or decrease its rate\n   based on these parameters.  The receiver-based\
    \ approach is well\n   suited to an application where the sender is handling many\
    \ concurrent\n   connections and therefore WEBRC is suitable as a building block\
    \ for\n   multicast congestion control.\n   The paper [16] and technical report\
    \ [15] provide much of the\n   rationale and intuition for the WEBRC design and\
    \ describe some\n   preliminary simulations.\n   This document describes a building\
    \ block as defined in RFC 3048 [4].\n   This document describes a congestion control\
    \ building block that\n   conforms to RFC 2357 [3].  This document is a product\
    \ of the IETF RMT\n   WG and follows the general guidelines provided in RFC 3269\
    \ [2].  The\n   key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"\
    SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"\
    OPTIONAL\" in this\n   document are to be interpreted as described in BCP 14,\
    \ RFC 2119 [1].\n"
- title: Statement of Intent
  contents:
  - "Statement of Intent\n   This memo contains part of the definitions necessary\
    \ to fully specify\n   a Reliable Multicast Transport protocol in accordance with\
    \ RFC 2357.\n   As per RFC 2357, the use of any reliable multicast protocol in\
    \ the\n   Internet requires an adequate congestion control scheme.  This\n   document\
    \ specifies an experimental congestion control scheme.  While\n   waiting for\
    \ initial deployment and experience to show this scheme to\n   be effective and\
    \ scalable, the IETF publishes this scheme in the\n   \"Experimental\" category.\n\
    \   It is the intent of the Reliable Multicast Transport (RMT) Working\n   Group\
    \ to re-submit the specification as an IETF Proposed Standard as\n   soon as the\
    \ scheme is deemed adequate.\n"
- title: 2.  Rationale
  contents:
  - "2.  Rationale\n   WEBRC provides congestion control for massively scalable protocols\n\
    \   using the IP multicast network service.  The congestion control that\n   WEBRC\
    \ provides is common to a variety of applications, including\n   reliable content\
    \ delivery and streaming applications.\n   WEBRC is designed to provide congestion\
    \ control for all packets that\n   are sent to a session.  A session comprises\
    \ multiple channels\n   originating at a single sender that are used for some\
    \ period of time\n   to carry packets pertaining to the transmission of one or\
    \ more\n   objects that can be of interest to receivers.  The logic behind\n \
    \  defining a session as originating from a single sender is that this\n   is\
    \ the right granularity to regulate packet traffic via congestion\n   control.\
    \  The rationale for providing congestion control that uses\n   multiple channels\
    \ within the same session is that this allows the\n   data on the channels to\
    \ be layered, which in turn allows each\n   receiver to control its reception\
    \ rate by joining and leaving\n   channels during its participation in the session.\
    \  There are\n   advantages to layered data for streaming, where the most important\n\
    \   data can be sent to the lower layers and incrementally valuable data\n   to\
    \ the higher layers.  For reliable content delivery, as described in\n   [13],\
    \ an application can send in packets encoded data generated from\n   an object\
    \ in such a way that the arrival of enough packets by a\n   receiver is sufficient\
    \ to reliably reconstruct the original object.\n   A primary advantage of WEBRC\
    \ is that each receiver controls it\n   reception rate independent of other receivers.\
    \  Thus, for example, a\n   receiver with a slow connection to the sender does\
    \ not slow down the\n   receivers with faster connections.\n   There are coding\
    \ techniques that provide massively scalable\n   reliability and asynchronous\
    \ delivery which are compatible with\n   WEBRC, e.g., as described in [11].  When\
    \ combined the result is a\n   massively scalable, reliable, asynchronous content\
    \ delivery protocol\n   that is network friendly.  WEBRC also provides congestion\
    \ control\n   that is suitable for streaming applications.\n   WEBRC avoids using\
    \ techniques that are not massively scalable.  For\n   example, WEBRC does not\
    \ provide any mechanisms for sending\n   information from receivers to senders,\
    \ although this does not rule\n   out protocols that both use WEBRC and that send\
    \ information from\n   receivers to senders.\n   WEBRC provides congestion control\
    \ that can be tuned for different\n   applications that may have differing application\
    \ requirements.  For\n   example, a content delivery protocol may aggressively\
    \ strive to use\n   all available bandwidth between receivers and the sender,\
    \ and thus to\n   maintain fairness it must drastically reduce its rate when there\
    \ is\n   competing traffic.  On the other hand, a streaming delivery protocol\n\
    \   may strive to maintain a constant rate instead of trying to use all\n   available\
    \ bandwidth, and thus it may not reduce its rate as fast when\n   there is competing\
    \ traffic.\n   WEBRC does not provide any support beyond congestion control, and\n\
    \   thus WEBRC is to be combined with other building blocks to provide a\n   complete\
    \ protocol instantiation.  For example, WEBRC does not provide\n   any means that\
    \ can be used to identify which session each received\n   packet belongs to. \
    \ As another example, WEBRC does not provide\n   support for identifying which\
    \ object each packet is carrying\n   information about.\n"
- title: 3.  Functionality
  contents:
  - "3.  Functionality\n   A WEBRC session comprises a logically related set of channels\n\
    \   originating from a single sender that are used for some period of\n   time\
    \ to carry data packets with a header carrying WEBRC Congestion\n   Control Information.\
    \  When packets are received, they are first\n   checked to see that they belong\
    \ to the appropriate session before\n   WEBRC is applied.  A session label defined\
    \ by a protocol\n   instantiation may be carried in each packet to identify to\
    \ which\n   session the packet belongs.  For example, if LCT [12] is being used\n\
    \   with the session, then the sender IP address together with the\n   Transport\
    \ Session Identifier supported by LCT would be used to\n   determine which session\
    \ a received packet belongs to.  The particular\n   details of how this filtering\
    \ is performed is outside the scope of\n   this document.  In the remainder of\
    \ this document, references to\n   channels are always within the scope of a single\
    \ session.\n   A channel can be uniquely identified at the network layer by a\n\
    \   (sender IP address, multicast group address) pair, and this is the\n   address\
    \ to which the receiver sends messages to join and leave the\n   channel.  The\
    \ channels used by a WEBRC session are mapped uniquely to\n   consecutive channel\
    \ numbers.  In each packet sent to a channel, the\n   channel number that corresponds\
    \ to the channel is carried in the\n   WEBRC Congestion Control Information. \
    \ A WEBRC receiver uses the\n   channel number to determine which channel within\
    \ a session a packet\n   is received from.\n   At the sender, time is partitioned\
    \ into time slots, each of duration\n   TSD seconds.  There is a fixed number\
    \ T of time slot indices\n   associated with a session.  As time progresses, the\
    \ current time slot\n   index increases by one modulo T each TSD seconds.  The\
    \ current time\n   slot index CTSI is carried in the WEBRC Congestion Control\n\
    \   Information.  This allows receivers to perform very coarse-grained\n   synchronization\
    \ within a session.\n   WEBRC congestion control is achieved by having the sender\
    \ send\n   packets associated with a given session to several different\n   channels.\
    \  Individual receivers dynamically join and leave these\n   channels according\
    \ to the network congestion they experience.  These\n   congestion control adjustments\
    \ are performed at each receiver\n   independently of all other receivers, without\
    \ any impact on the\n   sender.  A packet sequence number is carried in the WEBRC\
    \ Congestion\n   Control Information.  The packet sequence numbers are consecutively\n\
    \   numbered per channel and are used by receivers to measure packet\n   loss.\n\
    \   The channels associated with a session consist of one base channel\n   and\
    \ T wave channels.  The packet rate for each channel varies over\n   time.  For\
    \ the base channel, packets are sent to the channel at a low\n   rate BCR_P at\
    \ the beginning of a time slot and this rate gradually\n   decreases to P*BCR_P\
    \ at the end of the time slot, where P < 1 is a\n   constant defined later.  This\
    \ pattern for the base channel repeats\n   over each time slot.  For each wave\
    \ channel i, packets are sent to\n   channel i at a rate that first increases\
    \ very quickly to a high rate\n   and then decreases over time by a fixed fraction\
    \ P per time slot\n   until a rate of BCR_P is reached at the end of time slot\
    \ i.  Then,\n   for a period of time called the quiescent period, no packets are\
    \ sent\n   to wave channel i, and thereafter the whole cycle repeats itself,\n\
    \   where the duration of the cycle is T*TSD seconds.  Thus, the wave\n   channels\
    \ are going through the same cyclic pattern of packet rate\n   transmission spaced\
    \ out evenly by TSD seconds.\n   Before joining a session, the receivers MUST\
    \ obtain enough of the\n   session description to start the session.  This MUST\
    \ include the\n   relevant session parameters needed by a receiver to participate\
    \ in\n   the session and perform WEBRC congestion control.  The session\n   description\
    \ is determined by the sender and is typically communicated\n   to the receivers\
    \ out of band.  How receivers obtain the session\n   description is outside the\
    \ scope of this document.\n   When a receiver initiates a session, it first joins\
    \ the base channel.\n   The packets in the base channel help the receiver orient\
    \ itself in\n   terms of what the current time slot index is, which in turn allows\n\
    \   the receiver to know the relative rates on the wave channels.  The\n   receiver\
    \ remains joined to the base channel for the duration of its\n   participation\
    \ in the session.\n   At each point in time the active (non-quiescent) wave channels\
    \ are\n   ordered into layers, where the lowest layer is the active wave\n   channel\
    \ whose wave is nearest to completion and the highest layer is\n   the active\
    \ wave channel whose wave is furthest from completion.\n   (This is almost the\
    \ same as saying that the lowest layer has the\n   lowest rate and the highest\
    \ layer has the highest rate.  The possible\n   deviation from this is due to\
    \ the optional non-exponential beginnings\n   of the waves as described in [8].)\
    \  Each time a wave channel becomes\n   active, it is the highest layer.  At the\
    \ end of each time slot the\n   lowest-layer wave channel becomes quiescent, and\
    \ thus all active wave\n   channels move down a layer at this point in time. \
    \ At each point in\n   time a receiver is joined to the base channel and a consecutive\
    \ set\n   of layers starting with the lowest.  Each time a receiver joins a\n\
    \   wave channel it joins the lowest layer not yet joined.  A receiver\n   always\
    \ leaves the lowest layer when it becomes quiescent.\n   After joining a session\
    \ the receiver adjusts its rate upwards by\n   joining wave channels in sequence,\
    \ starting with the lowest layer and\n   moving towards the highest.  The rates\
    \ on the active wave channels\n   are decreasing with time, so the receiver adjusts\
    \ its rate downwards\n   simply by refraining from joining additional wave channels.\
    \  Since\n   the layer ordering among the channels changes dynamically over time\n\
    \   depending on the current time slot index, it is important that the\n   receiver\
    \ continually monitor the current time slot index contained in\n   received packets.\
    \  The reception rate at the receiver is determined\n   by how early each wave\
    \ channel is joined by the receiver: the earlier\n   the receiver joins a channel\
    \ with respect to when its wave started,\n   the higher the reception rate.\n\
    \   Once the receiver is joined to a wave channel, the receiver remains\n   joined\
    \ to the wave channel until the channel goes quiescent, at which\n   point the\
    \ receiver MUST leave the channel.\n   The way the receiver adjusts its reception\
    \ rate is inspired by TFRC\n   [9].  The receiver at all points in time maintains\
    \ a target reception\n   rate, and the receiver is allowed to join the next wave\
    \ channel if\n   after joining its anticipated reception rate from all the layers\
    \ it\n   is joined to would be at most its target reception rate.  The target\n\
    \   rate is continually updated based on a set of measured parameters.\n   The\
    \ primary parameters are an estimate LOSSP of the average loss\n   probability\
    \ and an estimate ARTT of the average multicast round-trip\n   time.\n   In the\
    \ remainder of this document, log(X) denotes the natural\n   logarithm of X, i.e.,\
    \ the logarithm base 2.71828459... of X.\n"
- title: 3.1.  Sender Operation
  contents:
  - "3.1.  Sender Operation\n   The sender operation is by design much simpler than\
    \ the receiver\n   operation.\n"
- title: 3.1.1.  Sender inputs and initialization
  contents:
  - "3.1.1.  Sender inputs and initialization\n   The primary input to the sender\
    \ for the session is SR_b.  SR_b is an\n   upper bound to the sender transmission\
    \ rate in bits per second at any\n   point in time (with some reasonable granularity)\
    \ in aggregate to all\n   channels.  Naturally, this is then also the maximum\
    \ rate in bits per\n   second that any receiver could receive data from the session\
    \ at any\n   point in time.  It is RECOMMENDED that the sender transmission rate\n\
    \   in aggregate to all channels be made constant as described in [8].\n   It\
    \ is also RECOMMENDED that the session description indicate whether\n   the aggregate\
    \ transmission rate is constant, unless there is no\n   ambiguity.\n   The secondary\
    \ inputs to the sender are listed below.  These inputs\n   are secondary because\
    \ their values will generally be fixed to default\n   values that will not change,\
    \ because they will be derived from SR_b,\n   or because they are chosen based\
    \ on non-WEBRC considerations.\n   o  LENP_B is the length of packets in bytes\
    \ sent to the session.  The\n      value of LENP_B depends on the complete protocol,\
    \ but in general\n      this SHOULD be set to as high a value as possible without\n\
    \      exceeding the MTU size for the network that would cause\n      fragmentation.\n\
    \   o  BCR_P is the transmission rate on the base channel at the\n      beginning\
    \ of a time slot in packets per second.  The default value\n      for BCR_P is\
    \ 1.\n   o  TSD is the time slot duration measured in seconds.  The\n      RECOMMENDED\
    \ value for TSD is 10.\n   o  QD is the minimum quiescent period duration measured\
    \ in seconds.\n      The RECOMMENDED value for QD is 300.\n   o  P is the multiplicative\
    \ drop in every channel rate over each time\n      slot.  The default value for\
    \ P is 0.75.\n   o  N is the duration in time slots for each wave.  N is also\
    \ the\n      number of wave channels active at any time.  (A wave channel is\n\
    \      called active when it is not quiescent.)  A sender may choose any\n   \
    \   value that allows it to produce waves that substantially follow\n      the\
    \ required exponential shape described in Section 3.1.2.  A\n      RECOMMENDED\
    \ mechanism for relating N to SR_b, BCR_P and P is\n      described in [8].\n\
    \   From these inputs the following fixed sender parameters can be\n   derived\
    \ as follows.\n   o  SR_P = SR_b/(8*LENP_B) is the sender transmission rate in\
    \ packets\n      per second.\n   o  BCR_b = 8*LENP_B*BCR_P is the rate of the\
    \ base channel at the\n      beginning of a time slot in bits per second.\n  \
    \ o  L = ceil(BCR_P*TSD*(P-1)/log(P)) is the number of base channel\n      packets\
    \ sent in each time slot.\n   o  Q = ceil(QD/TSD) is the number of quiescent time\
    \ slots per cycle\n      for a wave channel.\n   o  T = N + Q is the total number\
    \ of time slots in a cycle.  T is also\n      the total number of wave channels.\n\
    \   o  For the base channel CN = T and for the wave channels CN =\n      0,1,...,T-1.\
    \  The sender has the description of the channels\n      assigned to the session\
    \ and the mapping between the channels and\n      the CNs.\n   o  C = TSD*T is\
    \ the total duration of a cycle in seconds.\n"
- title: 3.1.2.  Sending packets to the session
  contents:
  - "3.1.2.  Sending packets to the session\n   The sender keeps track of the current\
    \ time slot index CTSI.  The\n   value of CTSI is incremented by 1 modulo T each\
    \ TSD seconds.  The\n   value of CTSI is placed into each packet in the format\
    \ described in\n   Section 5.  For each packet sent to the session, the sender\
    \ also\n   places the channel number CN of the channel into the packets in the\n\
    \   format described in Section 5.  Recall that CN = T for the base\n   channel\
    \ and CN = 0,1,...,T-1 for the wave channels.\n   For each packet sent to the\
    \ session, the sender calculates a packet\n   sequence number PSN and places it\
    \ into the packet.  The value of PSN\n   is scoped by CN, and the value of PSN\
    \ is consecutively increasing\n   within each channel.  Furthermore, for each\
    \ wave channel, the last\n   packet sent before the channel becomes quiescent\
    \ must have the\n   maximum possible PSN value.  When the short format for Congestion\n\
    \   Control Information is used (see Section 5.1), this implies that for\n   any\
    \ wave channel the last PSN value sent to the channel just before\n   the channel\
    \ becomes quiescent is 2^16-1 = 65,535.  Similarly, when\n   the long format for\
    \ Congestion Control Information is used (see\n   Section 5.2), the PSN for the\
    \ final packet of any wave is 2^32-1 =\n   4,294,967,295.  The PSN of the initial\
    \ packet of a wave thus depends\n   on TSD, P, BCR_P and SR_P.  For the base channel,\
    \ the first packet of\n   each time slot has a PSN congruent to zero modulo L.\
    \  Hence, instead\n   of 2^16 - 1 or 2^32 - 1 being the highest PSN used (depending\
    \ on the\n   choice of short format or long format Congestion Control\n   Information),\
    \ the highest PSN is one less than the largest multiple\n   of L that does not\
    \ exceed 2^16 (short format) or 2^32 (long format).\n   The format for the PSN\
    \ within packets is described in Section 5.\n   The rate at which packets are\
    \ sent to the base channel starts at\n   BCR_P packets per second at the beginning\
    \ of each time slot and\n   decreases exponentially to P*BCR_P at the end of that\
    \ time slot.\n   The packet rate for the wave channels is more complicated.  Each\
    \ wave\n   channel carries a sequence of waves separated by quiescent periods.\n\
    \   On each wave channel each wave is active during N time slots followed\n  \
    \ by a quiescent period of Q time slots.  The waves on wave channel i\n   end\
    \ at the ends of time slots with CTSI i.  Therefore wave channel i\n   is active\
    \ during time slots i-N+1 modulo T, i-N+2 modulo T, ..., i\n   and is quiescent\
    \ for time slots i+1 modulo T, i+2 modulo T, ..., i+Q\n   modulo T.  Wave channel\
    \ i first becomes active within time slot i-N+1\n   modulo T at a point in time\
    \ that may depend on the value of SR_b.\n   Except for at most the first two time\
    \ slots after a wave becomes\n   active, the packet rate of the wave MUST decrease\
    \ exponentially by a\n   factor of P per TSD seconds, down to a rate of BCR_P\
    \ at the end of\n   the last active time slot.  At the beginning of each wave,\
    \ i.e., for\n   at most the first two time slots when the wave becomes active,\
    \ the\n   rate MAY deviate from this exponential form so that the total sending\n\
    \   rate in aggregate to all of the channels is constant.  A RECOMMENDED\n   design\
    \ for the beginnings of waves to achieve this goal is described\n   in [8].\n"
- title: 3.2.  Receiver Operation
  contents:
  - "3.2.  Receiver Operation\n   The bulk of the complexity in WEBRC is in the receiver\
    \ operation.\n   For ease of explanation, suppose for the moment that during the\n\
    \   reception there is no packet loss and packets are arriving at exactly\n  \
    \ the rate at which they were sent.  The sender transmission rate to\n   the channels\
    \ is designed so that the receiver reception rate behaves\n   as follows.\n  \
    \ Upon entering a session, the receiver immediately joins the base\n   channel.\
    \  When the receiver wants to increase its rate, it joins\n   consecutive layers\
    \ starting with the lowest and moving towards the\n   highest.  (Recall that the\
    \ designations of lowest to highest change\n   as waves become active and quiescent.)\
    \  When the receiver wants to\n   maintain its current reception rate and it is\
    \ already joined to the\n   lowest NWC layers, if the receiver joins channel i-1+NWC\
    \ modulo T\n   sometime during time slot i then the receiver joins channel i+NWC\n\
    \   modulo T TSD seconds later in time slot i+1.  When the lowest layer\n   becomes\
    \ quiescent the receiver leaves the channel.\n   Suppose the receiver wants to\
    \ decrease its rate till it is joined to\n   just the base channel.  Assume that\
    \ a receiver is joined to the\n   lowest NWC < N-2 layers at the beginning of\
    \ time slot i, i.e., wave\n   channels i, i+1 modulo T,..., i+NWC-1 modulo T.\
    \  Then, the aggregate\n   packet reception rate of the receiver over the next\
    \ NWC time slots\n   will behave as follows if the receiver does not join any\
    \ wave\n   channels during this time.  At the beginning of time slot i the\n \
    \  receiver reception rate is BCR_P*(1 + (1/P) + (1/P)^2 + ... +\n   (1/P)^NWC).\
    \  Then the receiver reception rate decreases by a factor\n   of P over the duration\
    \ of each time slot, and at the end of each time\n   slot the reception rate decreases\
    \ by an additive amount of P*BCR_P.\n   At the end of time slot i+NWC-1 mod T,\
    \ the receiver reception rate is\n   BCR_P*(1+P), and at the beginning of time\
    \ slot i+NWC mod T the\n   receiver is joined only to the base channel and its\
    \ reception rate is\n   BCR_P.\n"
- title: 3.2.1.  Receiver inputs and initialization
  contents:
  - "3.2.1.  Receiver inputs and initialization\n   Before joining a session the receiver\
    \ MUST know the mapping between\n   the CNs and the channels.  Upon joining the\
    \ session or shortly\n   thereafter, it SHOULD have the values of LENP_B, BCR_P,\
    \ TSD, P, N, L,\n   Q and T.  Some of these values may be computed or measured\
    \ once the\n   receiver has joined the session.  For example, the receiver MAY\n\
    \   obtain LENP_B and T from the first packet received from the base\n   channel,\
    \ and the receiver MAY measure BCR_P once it is joined to the\n   base channel.\
    \  The values of P, Q and TSD MAY be fixed to default\n   values built into the\
    \ receiver that do not change from session to\n   session, and the value of N\
    \ MAY be computed as T-Q.  The receiver\n   SHOULD know whether the sender is\
    \ employing a technique to produce\n   constant aggregate rate as described in\
    \ [8].\n   When a receiver first joins a session, it MUST first join just the\n\
    \   base channel and start receiving packets to determine the current\n   time\
    \ slot index.  If during the course of the session the receiver\n   continually\
    \ loses a high fraction of the packets from the base\n   channel even when the\
    \ receiver is only joined to the base channel,\n   the receiver SHOULD leave the\
    \ session.\n   The receiver MAY also have other individually set parameters that\
    \ may\n   be used to determine its behavior.  One such parameter is MRR_b:\n \
    \  o  MRR_b is the maximum receiver reception rate in bits per second.\n     \
    \ This may be used to determine the maximum reception rate this\n      receiver\
    \ is willing to reach.  Thus, the maximum reception rate\n      that the receiver\
    \ can possibly achieve in the session is the\n      minimum of SR_b and MRR_b.\
    \  A recommended value of MRR_b for a\n      receiver is the bandwidth capacity\
    \ of the last link to the\n      receiver.  MRR_P is the maximum receiver reception\
    \ rate in packets\n      per second, i.e., MRR_P = MRR_b/(8*LENP_B).\n"
- title: 3.2.2.  Receiver measurements and calculations
  contents:
  - "3.2.2.  Receiver measurements and calculations\n   As outlined in the introduction,\
    \ the way a receiver adjusts its\n   reception rate is inspired by TFRC [9]. The\
    \ receiver at all points in\n   time maintains a target reception rate, and the\
    \ receiver is allowed\n   to join the next wave channel if joining would increase\
    \ its reception\n   rate to at most its target reception rate.  The target rate\
    \ is\n   continually updated based on a set of measured parameters.\n   Two primary\
    \ parameters are the estimate LOSSP of the average loss\n   probability and the\
    \ estimate ARTT of the average MRTT.  Both LOSSP\n   and ARTT are moving averages\
    \ of measurements based on discrete\n   events.  For many of the other estimates\
    \ calculated by WEBRC, using\n   an exponentially weighted moving average (EWMA)\
    \ with a fixed\n   averaging fraction is sufficient.  However, the calculations\
    \ of LOSSP\n   and ARTT require a more general and sophisticated filtering approach.\n"
- title: 3.2.2.1.  Average loss probability
  contents:
  - "3.2.2.1.  Average loss probability\n   The design of TFRC [9] reflects that,\
    \ because the average packet loss\n   probability can vary by orders of magnitude,\
    \ any estimate of the\n   average loss probability based on either a fixed number\
    \ of packets or\n   on a fixed period of time with a fixed averaging fraction\
    \ will be\n   poor.  In TFRC the average is estimated from the numbers of packets\n\
    \   between beginnings of loss events, and the number of loss events used\n  \
    \ is fixed.\n   The estimate LOSSP of the average loss probability of the receiver\
    \ is\n   maintained in a manner somewhat similar to that described in TFRC\n \
    \  [9].  The WEBRC receiver estimates the inverse of the average loss\n   probability\
    \ by applying two EWMA filters to the packet reception\n   measurements, a time-based\
    \ filter with smoothing constant 0 < Nu < 1\n   and a loss-based filter with smoothing\
    \ constant 0 < Delta < 1.  The\n   recommended values for the smoothing constants\
    \ are Nu = 0.3 and Delta\n   = 0.3.  The reason for the time-based filter is that\
    \ the loss events\n   in WEBRC are bursty; they typically occur just after a new\
    \ wave has\n   been joined.  To smooth out this burstiness, the time-based filter\
    \ is\n   applied to the packet reception measurements at the end of each epoch\n\
    \   to smooth out the bursty loss events over a few time slot durations.\n   Intuitively,\
    \ the time-based filter averages packet reception events\n   such that the events\
    \ are smoothed out over an interval of time\n   proportional to TSD/Nu seconds.\
    \  The loss-based filter, similar to\n   what is suggested in TFRC, is applied\
    \ to the output of the time-based\n   filter to produce the estimate of the inverse\
    \ of the average loss\n   probability.  Intuitively, the loss-based filter averages\
    \ loss events\n   such that each loss event is averaged in with weight Delta.\n\
    \   As described later, LOSSP is initialized at the end of slow start and\n  \
    \ occasionally reset due to other events.  Let W and X be counts of\n   packets,\
    \ let Y be a count of loss events and let Z be the long-term\n   estimate of the\
    \ inverse of the average loss probability.  Whenever\n   the value of LOSSP is\
    \ initialized or reset, the values of W, X, Y and\n   Z are also initialized or\
    \ reset.\n   Recall that TSD is the duration of a time slot.  The epoch length\
    \ EL\n   is the duration of time between decisions to adjust the reception\n \
    \  rate.  Generally EL is much smaller than TSD, and the RECOMMENDED\n   values\
    \ are EL = 0.5 seconds and TSD = 10 seconds.\n   Define G = Nu*EL/TSD as the amount\
    \ of time-based smoothing to perform\n   at the end of each epoch.  The update\
    \ rules for W, X, Y, Z, and LOSSP\n   are the following:\n   o  At the end of\
    \ each epoch, adjust X, Y and Z and compute LOSSP as\n      follows:\n       \
    \  Z = Z*(1-Delta)^(G*Y) + G*X/(G*Y+1)*(1-(1-Delta)^(G*Y+1))\n         X = X*(1-G)\n\
    \         Y = Y*(1-G)\n         Z1 = Z*(1-Delta)^Y + X/(Y+1)*(1-(1-Delta)^(Y+1))\n\
    \         Z2 = Z*(1-Delta)^(Y+1) + (X+W+1)/(Y+2)*(1-(1-Delta)^(Y+2))\n       \
    \  LOSSP = 1/max{Z1,Z2,1}\n   o  For each packet event (whether it is a received\
    \ packet or a lost\n      packet), W = W + 1\n   o  At the beginning of each loss\
    \ event, update W, X, and Y as\n      follows:\n         X = X + W\n         W\
    \ = 0\n         Y = Y + 1\n   The intuition behind these update rules is the following.\
    \  If just\n   loss-filtering were used to update Z, then Z would be decreased\
    \ by a\n   multiplicative amount 1 - Delta for each loss event and Z would be\n\
    \   increased by an additive amount Delta for each packet.  To smooth out\n  \
    \ loss events over more than one time slot, these adjustments are\n   filtered\
    \ into Z over time, at the rate of a fraction G at the end of\n   each epoch.\
    \  Thus, the variables X and Y are counts of the portions\n   of the packets and\
    \ loss events, respectively, that have not yet been\n   filtered into the long-term\
    \ memory Z.  W is the count of packets\n   since the last loss event started.\
    \  This explains why W is increased\n   by one for each packet and Y is increased\
    \ by one for each loss event.\n   At the end of each epoch a fraction G of both\
    \ X and Y are filtered\n   into Z according to the loss-filter rule described\
    \ above, and then\n   the same fraction G is removed from both X and Y to account\
    \ for the\n   fact that this portion has been filtered into Z.  The LOSSP\n  \
    \ calculation combines the short-term history (X,Y) with the long-term\n   history\
    \ Z and also allows the arrivals since the last loss W to have\n   some influence.\
    \  The value of Z2 is what Z1 would become were the\n   next packet to be lost.\n\
    \   To reset the loss calculation to a value LOSSP = a, the state\n   variables\
    \ are set as follows:\n         W = 0\n         X = 0\n         Y = 0\n      \
    \   Z = 1/a\n"
- title: 3.2.2.2.  Average round-trip time
  contents:
  - "3.2.2.2.  Average round-trip time\n   The receiver maintains an average round-trip\
    \ time, ARTT, as a\n   measurement-based filter of MRTT measurements using a smoothing\n\
    \   constant 0 < Alpha < 1.  The RECOMMENDED value for Alpha is 0.25.\n   Each\
    \ time the receiver joins a channel (either the base channel upon\n   entering\
    \ a session or wave channels continually), it makes a\n   measurement of the multicast\
    \ round-trip time MRTT as follows.  Let V\n   be an auxiliary variable that is\
    \ used that keep track of the average\n   of the square of the MRTT measurements.\
    \  When the receiver sends the\n   join for the channel it records the current\
    \ time JoinTime and sets a\n   Boolean variable JOINING to true.  When the first\
    \ packet is received\n   from the channel the receiver records the current time\
    \ FirstTime and\n   resets the value of JOINING to false.  If it is the base channel\
    \ that\n   has been joined, ARTT is set to FirstTime-JoinTime and V is set to\n\
    \   ARTT*ARTT.  Otherwise, the value of MRTT is set to (FirstTime -\n   JoinTime)\
    \ - log(1/P)/2/(1-P)/BCR_P * P^NWC.  (Note that this value\n   can be negative.)\
    \  Then, ARTT is updated as follows.  Let Omega =\n   Alpha*ARTT*ARTT/V, and at\
    \ the Kth MRTT measurement let Rho =\n   Omega/(1-(1-Omega)^(K+1)).  (Note that\
    \ as K grows Rho approaches\n   Omega.)  Then, V is updated to (1-Rho)*V+Rho*MRTT*MRTT\
    \ and ARTT is\n   updated to max{P*ARTT,(1-Rho)*ARTT+Rho*MRTT}.\n   Usually ARTT\
    \ is updated to the second term in the max, and in this\n   case ARTT is the EWMA\
    \ of the previous value of ARTT and the new MRTT,\n   with a weighting on the\
    \ new MRTT that as K grows is proportional to\n   the square of the previous ARTT\
    \ divided by the previous average V of\n   the square of the MRTT.  Thus, if there\
    \ is not much variance in the\n   previous MRTTs relative to the square of their\
    \ average then the new\n   MRTT will be filtered into ARTT with a high weight,\
    \ whereas  if there\n   is a lot of variance in the previous MRTTs relative to\
    \ the square of\n   their average then the new MRTT will be filtered into ARTT\
    \ with a low\n   weight.  The intuitive rationale for this is that in general\
    \ the\n   number of measurements needed to compute a meaningful average for a\n\
    \   random variable is proportional to its variance divided by the square\n  \
    \ of its average; see, e.g., [6]. By making the weight factor depend on\n   previous\
    \ measurements in this way, the appropriate weight to use to\n   average the new\
    \ MRTT into the ARTT self-adjusts automatically to the\n   variability in the\
    \ measurements.\n"
- title: 3.2.2.3.  Rate Equation
  contents:
  - "3.2.2.3.  Rate Equation\n   The receiver calculates the reception rate REQN based\
    \ on the TCP\n   equation as follows: REQN = 1/(ARTT*sqrt{LOSSP}(0.816 +\n   7.35*LOSSP*(1+32*LOSSP^2))).\
    \  This equation comes from TFRC [9].\n"
- title: 3.2.2.4.  Epochs
  contents:
  - "3.2.2.4.  Epochs\n   The receiver makes decisions on whether or not to join another\
    \ wave\n   channel at equally-spaced units of time called epochs.  The duration\n\
    \   of an epoch in seconds, EL, is set to be a small fraction of TSD, so\n   that\
    \ decisions to join a channel can be made at a much finer\n   granularity than\
    \ TSD.  A standard setting is EL = TSD/20.  Thus, with\n   the recommended setting\
    \ of TSD = 10, it is RECOMMENDED that EL = 0.5.\n"
- title: 3.2.2.5.  Average reception rate
  contents:
  - "3.2.2.5.  Average reception rate\n   There are two averaged reception rates maintained\
    \ by the receiver:\n   TRR_P, the true reception rate, and ARR_P, the anticipated\
    \ reception\n   rate.  These are used for different purposes and thus are calculated\n\
    \   quite differently.  Recommended values for the filtering weights Beta\n  \
    \ and Zeta are provided at the end of this subsection.\n   In start-up mode, the\
    \ true reception rate TRR_P is used to ensure\n   that the receiver does not increase\
    \ its reception rate too quickly\n   above its current reception rate.  In the\
    \ transition from start-up\n   mode to normal operation and in normal operation,\
    \ TRR_P is used in\n   setting the slow start rate.  TRR_P is calculated based\
    \ on the\n   measurement of RR_P, where RR_P is the receiver reception rate in\n\
    \   packets per second measured at the beginning of an epoch averaged\n   over\
    \ the epoch that just ended.  TRR_P is initialized to BCR_P +\n   k*log(P)/TSD\
    \ when the first base channel packet of the session\n   arrives, where k is the\
    \ PSN of the packet reduced modulo L.  TRR_P is\n   updated to (1-Zeta)*TRR_P\
    \ + Zeta*RR_P at the beginning of each epoch\n   after RR_P is measured for the\
    \ previous epoch.\n   The anticipated reception rate ARR_P is the receiver's estimate\
    \ of\n   the total instantaneous rate of the currently joined channels.  It is\n\
    \   used to compare against the target rate to decide whether or not the\n   receiver\
    \ should increase its reception rate by joining the next\n   higher unjoined layer.\
    \  ARR_P is calculated based on a measurement\n   IRR_P and on the number of joined\
    \ wave channels NWC.  The ideal\n   reception rate IRR_P is the reception rate\
    \ in packets per second\n   including both received and lost packets; like RR_P,\
    \ it is measured\n   at the beginning of the epoch and averaged over the previous\
    \ epoch.\n   ARR_P, IRR_P and NWC are updated as follows:\n   o  NWC is initialized\
    \ to 0.\n   o  When the first base channel packet arrives, ARR_P is set to BCR_P\n\
    \      + k*log(P)/TSD, where k is the PSN of the packet reduced modulo L.\n  \
    \ o  At the beginning of each epoch, IRR_P is measured over the\n      previous\
    \ epoch and then ARR_P is updated to\n      P^(EL/TSD)*(1-Beta)*ARR_P + Beta*IRR_P.\
    \  Then if ARR_P exceeds\n      ARR_P_max = ((1/P)^(NWC+1)-1)/((1/P)-1)*BCR_P,\
    \ ARR_P is updated to\n      ARR_P_max.\n   o  When a join is made to the next\
    \ higher unjoined layer, NWC is\n      updated to NWC+1 and then ARR_P is multiplicatively\
    \ increased by\n      the factor ((1/P)^(NWC+1)-1)/((1/P)^NWC-1).  (Joins happen\
    \ at\n      epoch boundaries; this adjustment is in addition to the adjustment\n\
    \      above.)\n   o  Each time a next time slot index is detected, ARR_P is additively\n\
    \      increased by (1-P)*BCR_P to account for the change in rate on the\n   \
    \   base channel.  In addition, the bottom layer in the previous time\n      slot\
    \ has just gone quiescent and thus a message to leave this\n      layer has been\
    \ sent, ARR_P is additively decreased by BCR_P and\n      NWC is decremented by\
    \ 1.  Thus, the combination of these effects\n      on ARR_P is that it is additively\
    \ decreased by P*BCR_P.\n   Consider for the moment what happens if Beta = 0 and\
    \ ARR_P is an\n   accurate estimate of the total rate of the joined channels.\
    \  The\n   adjustments to ARR_P upon joining and leaving wave channels, with the\n\
    \   passage of epochs, and with the detection of time slot changes will\n   then\
    \ cause ARR_P to remain an accurate estimate.  In practice, Beta\n   MUST be positive;\
    \ allowing an influence of IRR_P prevents ARR_P from\n   drifting away from being\
    \ an accurate estimate of the total joined\n   rate.\n   The motivation for separate\
    \ estimates TRR_P and ARR_P is as follows.\n   ARR_P is needed for comparison\
    \ with the TFRC-inspired target rate\n   because there is no lag before it reflects\
    \ the potential rate\n   increase resulting from joining the next higher layer\
    \ and because it\n   measures the total possible impact on the network since it\
    \ also\n   includes lost packets.  TRR_P is needed because it reflects the rate\n\
    \   of data arriving at the receiver and this is used to ensure that\n   there\
    \ is not a large gap between the joined rate and the receiving\n   rate.\n   The\
    \ recommended values for Beta and Zeta depend on whether the\n   receiver is in\
    \ start-up mode (SSR_P = infinity).  In start-up mode,\n   it is RECOMMENDED that\
    \ Beta = (1 - P^(0.25))/2 and Zeta = sqrt(P)/(1\n   + sqrt(P)).  In normal operation,\
    \ it is RECOMMENDED that Beta = 1 -\n   (P/(1+P))^(EL/TSD) and Zeta = 2*EL/(4+TSD).\n"
- title: 3.2.2.6.  Slow start
  contents:
  - "3.2.2.6.  Slow start\n   WEBRC uses a slow start mechanism to quickly ramp up\
    \ its rate at both\n   the beginning of the session and in the middle of a session\
    \ when the\n   rate drops precipitously.  To enact this, the receiver maintains\
    \ the\n   following parameters:\n   o  SSMINR_P is the minimum allowed slow start\
    \ threshold rate in\n      packets per second.  The recommended value for SSMINR_P\
    \ is\n      BCR_P*(1+1/P+1/P^2).\n   o  SSR_P is the slow start threshold rate\
    \ in packets per second.  It\n      is adjusted at the beginning of loss events\
    \ as described in\n      Section 3.2.3.4. SSR_P is initialized to infinity and\
    \ is first set\n      to a finite value when the receiver leaves the initial start-up\n\
    \      period as described below.\n   At the beginning of a session, the receiver\
    \ cannot compute a\n   meaningful target rate from its measurements.  Thus, it\
    \ uses SSR_P =\n   infinity until one of the following events causes an end to\
    \ this\n   start-up mode:\n   o  A packet loss is detected.  In this case the\
    \ value of SSR_P is\n      updated to max{SSMINR_P, P*TRR_P} as with the beginning\
    \ of any\n      other loss event.\n   o  A sharp increase in MRTT is detected.\
    \  While SSR_P = infinity the\n      receiver MUST compute, in the notation of\
    \ Section 3.2.2.2,\n      differences in successive measurements of (FirstTime-JoinTime)\n\
    \      from successive waves and MUST set SSR_P to max{SSMINR_P, P*TRR_P}\n  \
    \    when a large increase in (FirstTime-JoinTime) is observed.  It is\n     \
    \ RECOMMENDED that an increase in (FirstTime-JoinTime) be considered\n      large\
    \ if it exceeds (P^(NWC+1)-1)/(P*log(P)) / ARR_P.\n   o  The maximum reception\
    \ rate is reached.  When SSR_P = infinity, if\n      (P^(-NWC-2)-1)/(P^(-NWC-1)-1)*ARR_P\
    \ exceeds MRR_P or SR_P, the\n      receiver MUST set SSR_P to max{SSMINR_P, TRR_P}.\n\
    \   o  TRR_P is not increasing consistent with the last join of a wave\n     \
    \ channel.  While SSR_P = infinity, it is RECOMMENDED that the\n      receiver\
    \ wait at least one full epoch after the first packet of a\n      wave is received\
    \ before joining the next wave.  If the TRR_P after\n      that full epoch is\
    \ greatly below ARR_P the receiver SHOULD NOT\n      join and SHOULD then set\
    \ SSR_P to max{SSMINR_P, TRR_P}.  It is\n      RECOMMENDED that TRR_P be considered\
    \ greatly below ARR_P if TRR_P\n      < c * ARR_P - 2/EL, where c = Zeta + (1-Zeta)*(P^(-EL/TSD))*(Zeta\n\
    \      + (1-Zeta)*sqrt(P)*(P^(-EL/TSD)))/g with g = (P^(-NWC-1)-1)/(P^(-\n   \
    \   NWC)-1).\n   In any of these four cases, the variables associated with LOSSP\
    \ are\n   reset to make REQN, calculated as in Section 3.2.2.3 with the current\n\
    \   value of ARTT, equal TRR_P.\n"
- title: 3.2.2.7.  Target rate
  contents:
  - "3.2.2.7.  Target rate\n   In typical operation, SSR_P has a finite value and\
    \ the target rate\n   TRATE is computed as TRATE = min{max{SSR_P, REQN}, MRR_P}.\
    \  When\n   SSR_P = infinity, TRATE is computed as TRATE = min{4*TRR_P, MRR_P}.\n"
- title: 3.2.3.  Receiver events
  contents:
  - "3.2.3.  Receiver events\n   There are various receiver events, some of which\
    \ are triggered by the\n   passing of time on the receiver, and others by events\
    \ such as packet\n   reception, detection of packet loss, reception of a first\
    \ packet from\n   a channel, and exceptional time-outs.\n"
- title: 3.2.3.1.  Packet reception
  contents:
  - "3.2.3.1.  Packet reception\n   Most packet reception events require the receiver\
    \ to merely register\n   the reception for later calculation of RR_P and IRR_P\
    \ (see Section\n   3.2.2.5) and increment W for later calculation of LOSSP (see\
    \ Section\n   3.2.2.1).\n   Additional actions, described in the following three\
    \ subsections, are\n   required if the packet is the first packet received in\
    \ response to a\n   join operation, the CTSI of the packet indicates a time slot\
    \ change,\n   or the CN and PSN of the packet indicate a packet loss.\n"
- title: 3.2.3.2.  First packet after join
  contents:
  - "3.2.3.2.  First packet after join\n   When channel i is the most recently joined\
    \ channel and the Boolean\n   variable JOINING is true, the reception of a packet\
    \ with PSN = i is a\n   special event because it is the first packet received\
    \ in response to\n   the most recent join.  MRTT is calculated and ARTT and V\
    \ are updated\n   as described in Section 3.2.2.2, and JOINING is set to false.\
    \  The\n   first received packet of the session furthermore necessitates\n   initialization\
    \ of ARR_P and TRR_P as described in Section 3.2.2.5.\n"
- title: 3.2.3.3.  Time slot change
  contents:
  - "3.2.3.3.  Time slot change\n   This is an event that is triggered by the reception\
    \ of a packet with\n   a CTSI value that is one larger modulo T than the previous\
    \ CTSI\n   value.  When a packet with a new CTSI = i is received, a leave is\n\
    \   sent for the lowest layer in the previous time slot, i.e., wave\n   channel\
    \ i-1 modulo T, NWC is updated to NWC-1, and ARR_P is updated\n   to ARR_P - P*BCR_P\
    \ as described in Section 3.2.2.5. If the channel\n   for which the leave is sent\
    \ is also the most recently joined wave\n   channel and JOINING is true, then\
    \ JOINING is set to false.\n   It is possible due to packet reordering for some\
    \ packets from the\n   previous time slot to be received after packets from the\
    \ current time\n   slot.  It is RECOMMENDED that measures be put into place to\
    \ handle\n   this situation appropriately, i.e., to not trigger a time slot change\n\
    \   in this situation.  One simple mechanism for this is as follows:\n   Compute\
    \ the difference i-j modulo T, where i is the CTSI of the\n   received packet\
    \ and j is the current CTSI of the receiver.  A\n   difference of zero is, of\
    \ course, not a time slot change.  In\n   addition, a very large difference, for\
    \ example a difference larger\n   than T-Q/2, should also not trigger a time slot\
    \ change.\n"
- title: 3.2.3.4.  Loss event
  contents:
  - "3.2.3.4.  Loss event\n   Each time the receiver detects a lost packet (based\
    \ on the sequence\n   numbers in the packets scoped by the channel number), the\
    \ receiver\n   records the start of a new loss event and sets a Boolean variable\n\
    \   LOSS_EVENT to true that will automatically reset to false after ARTT\n   seconds.\
    \  All subsequent packet loss for a period of ARTT seconds is\n   considered as\
    \ part of the same loss event.  When a start of a loss\n   event is detected,\
    \ the value of SSR_P is updated to max{SSMINR_P,\n   P*TRR_P}.\n   It is RECOMMENDED\
    \ that the receiver account for simple misordering of\n   packets without inferring\
    \ a loss.\n"
- title: 3.2.3.5.  Epoch change
  contents:
  - "3.2.3.5.  Epoch change\n   This is an event that is triggered by the passage\
    \ of time at the\n   receiver, which occurs each EL seconds.  When this happens,\
    \ TRR_P and\n   ARR_P are computed as described in Section 3.2.2.5. Immediately\
    \ after\n   these updates, a decision is made about whether to join the next\n\
    \   higher layer as described in Section 3.2.3.6.\n"
- title: 3.2.3.6.  Join the next higher layer
  contents:
  - "3.2.3.6.  Join the next higher layer\n   At the beginning of each epoch, after\
    \ updating the values of ARR_P\n   and TRR_P as described in Section 3.2.2.5,\
    \ the receiver decides\n   whether or not to join the next higher layer as follows:\n\
    \   o  If the first base channel packet has not yet arrived the receiver\n   \
    \   MUST not join.\n   o  If there is a loss event in progress (LOSS_EVENT = true)\
    \ the\n      receiver MUST not join.\n   o  If a join of a channel is in progress\
    \ (JOINING = true) the\n      receiver MUST not join.\n   o  If NWC = N the receiver\
    \ MUST not join.\n   o  If the receiver is employing the OPTIONAL rule described\
    \ in\n      Section 3.2.2.6, SSR_P = infinity, and a full epoch has not passed\n\
    \      since the first packet arrival on the most recently joined wave\n     \
    \ channel then the receiver MUST not join.\n   o  If the receiver is employing\
    \ the OPTIONAL rule described in\n      Section 3.2.2.6, SSR_P = infinity, and\
    \ a full epoch has passed\n      since the first packet arrival on the most recently\
    \ joined wave\n      channel, then the receiver checks if TRR_P is greatly below\
    \ ARR_P\n      as described in Section 3.2.2.6. If TRR_P is greatly below ARR_P\n\
    \      the receiver MUST not join.\n   o  The receiver calculates REQN as described\
    \ in Section 3.2.2.3.\n   o  The receiver calculates TRATE as described in Section\
    \ 3.2.2.7.\n   o  If the sender is not sending at constant aggregate rate and\
    \ TRATE\n      < ARR_P*((1/P)^{NWC+2}-1)/((1/P)^{NWC+1}-1), the receiver MUST\
    \ not\n      join. If the sender is sending at constant aggregate rate and\n \
    \     TRATE < ARR_P*((1/P)^{NWC+2}-1)/((1/P)^{NWC+1}-1) and TRATE <\n      SR_P,\
    \ the receiver MUST not join.\n   o  If SSR_P is finite and the sender is not\
    \ sending at constant\n      aggregate rate or SSR_P is finite and the sender\
    \ is sending at\n      constant aggregate rate and TRATE < SR_P then the receiver\
    \ MAY\n      apply one additional OPTIONAL check before deciding to join.\n  \
    \    It is RECOMMENDED that the receiver not join if the value of RR_P\n     \
    \ is not sufficiently lower than the maximum value of RR_P observed\n      since\
    \ the last join.  It is RECOMMENDED that RR_P is sufficiently\n      low to allow\
    \ a join if RR_P <= max{RRmax-2/EL,P*RRmax}, where\n      RRmax is the maximum\
    \ measured RR_P since the last join.\n      If the receiver does not join because\
    \ RR_P is not sufficiently\n      small then a value of LOSSP is calculated so\
    \ as to make the value\n      of the REQN equation given in Section 3.2.2.3 evaluate\
    \ to\n      ARR_P*((1/P)^(NWC+2)-1)/((1/P)^(NWC+1)-1) with respect to the\n  \
    \    current value of ARR_P.  Then, the variables associated with LOSSP\n    \
    \  are reset based on this calculated value of LOSSP as described at\n      the\
    \ end of Section 3.2.2.1.\n   o Otherwise, the receiver MAY join the next higher\
    \ layer.\n   Suppose the receiver has decided to join and CTSI = i.  The receiver\n\
    \   joins the next higher wave channel, i.e., the wave channel with CN =\n   i+NWC\
    \ modulo T, increments NWC by 1, and then updates ARR_P to\n   ARR_P*((1/P)^{NWC+1}-1)/((1/P)^NWC-1)\
    \ as described in Section\n   3.2.2.5.  The time of the join is recorded for use\
    \ in updating ARTT\n   as described in Section 3.2.2.2.\n"
- title: 3.2.3.7.  Join timeout
  contents:
  - "3.2.3.7.  Join timeout\n   When no packet arrives in response to the join of\
    \ channel for a long\n   period of time, the join times out.  The receiver sets\
    \ JOINING to\n   false, updates ARR_P to ARR_P*((1/P)^NWC-1)/((1/P)^{NWC+1}-1),\
    \ and\n   then decrements NWC by 1.\n   The RECOMMENDED threshold for a join timeout\
    \ is max{2*V/ARTT,10*ARTT}\n   seconds.\n"
- title: 3.2.3.8.  Exceptional timeouts
  contents:
  - "3.2.3.8.  Exceptional timeouts\n   These are timeouts when the packet reception\
    \ behavior is far from\n   what it should be and these MUST trigger the receiver\
    \ to leave the\n   session.  Exceptional timeouts include\n   o  No packets are\
    \ received for a long period.  A RECOMMENDED\n      threshold is max{10,TSD} seconds.\n\
    \   o  There is no change in time slot index for a long period.  A\n      RECOMMENDED\
    \ threshold is max{20,2*TSD} seconds.\n"
- title: 4.  Applicability Statement
  contents:
  - "4.  Applicability Statement\n   WEBRC is intended to be a congestion control\
    \ scheme that can be used\n   in a complete protocol instantiation that delivers\
    \ objects and\n   streams (both reliable content delivery and streaming of multimedia\n\
    \   information).  WEBRC is most applicable for delivery of objects or\n   streams\
    \ of substantial length, i.e., objects or streams that range in\n   length from\
    \ hundreds of kilobytes to many gigabytes, and whose\n   transfer time is on the\
    \ order of tens of seconds or more.\n"
- title: 4.1.  Environmental Requirements and Considerations
  contents:
  - "4.1.  Environmental Requirements and Considerations\n   WEBRC can be used with\
    \ both multicast and unicast networks.  However,\n   the scope of this document\
    \ is limited to multicast.  WEBRC requires\n   connectivity between a sender and\
    \ receivers, but does not require\n   connectivity from receivers to the sender.\n\
    \   WEBRC inherently works with all types of networks, including LANs,\n   WANs,\
    \ Intranets, the Internet, asymmetric networks, wireless\n   networks, and satellite\
    \ networks.  Thus, the inherent raw scalability\n   of WEBRC is unlimited.  However,\
    \ in some network environments varying\n   reception rates to receivers may not\
    \ be advantageous.  For example,\n   the network may have dedicated a fixed amount\
    \ of bandwidth to the\n   session or there may be no effective way for receivers\
    \ to dynamically\n   vary the set of channels they are joined to, as in a satellite\n\
    \   network.\n   Receivers join and leave channels using the appropriate multicast\n\
    \   join and leave messages.  For IPv4 multicast, IGMP messages are used\n   by\
    \ receivers to join and leave channels.  For IPv6, MLDv2 messages\n   are used\
    \ by receivers to join and leave channels.  This is the only\n   dependency of\
    \ WEBRC on the IP version.\n   WEBRC requires receivers to be able to uniquely\
    \ identify and\n   demultiplex packets associated with a session in order to effectively\n\
    \   perform congestion control over all packets associated with the\n   session.\
    \  How receivers achieve this is outside the scope of this\n   document.\n   WEBRC\
    \ is presumed to be used with an underlying network or transport\n   service that\
    \ is a \"best effort\" service that does not guarantee\n   packet reception, packet\
    \ reception order, and which does not have any\n   support for flow or congestion\
    \ control.  For example, the Any-Source\n   Multicast (ASM) model of IP multicast\
    \ as defined in RFC 1112 [7] is\n   such a best effort network service.  While\
    \ the basic service provided\n   by RFC 1112 is largely scalable, providing congestion\
    \ control or\n   reliability should be done carefully to avoid severe scalability\n\
    \   limitations, especially in the presence of heterogeneous sets of\n   receivers.\n\
    \   There are currently two models of multicast delivery, the Any-Source\n   Multicast\
    \ (ASM) model as defined in RFC 1112 [7] and the Source-\n   Specific Multicast\
    \ (SSM) model as defined in [10].  WEBRC works with\n   both multicast models,\
    \ but in a slightly different way with somewhat\n   different environmental concerns.\
    \  When using ASM, a sender S sends\n   packets to a multicast group G, and the\
    \ WEBRC channel address\n   consists of the pair (S,G), where S is the IP address\
    \ of the sender\n   and G is a multicast group address.  When using SSM, a sender\
    \ S sends\n   packets to an SSM channel (S,G), and the WEBRC channel address\n\
    \   coincides with the SSM channel address.\n   A sender can locally allocate\
    \ unique SSM channel addresses, and this\n   makes allocation of channel addresses\
    \ easy with SSM.  To allocate\n   channel addresses using ASM, the sender must\
    \ uniquely chose the ASM\n   multicast group address across the scope of the group,\
    \ and this makes\n   allocation of WEBRC channel addresses more difficult with\
    \ ASM.  This\n   is an issue for WEBRC because several channels are used per session.\n\
    \   WEBRC channels and SSM channels coincide, and thus the receiver will\n   only\
    \ receive packets sent to the requested WEBRC channel.  With ASM,\n   the receiver\
    \ joins a channel by joining a multicast group G, and all\n   packets sent to\
    \ G, regardless of the sender, may be received by the\n   receiver.  Thus, SSM\
    \ has compelling security advantages over ASM for\n   prevention of denial of\
    \ service attacks.  In either case, receivers\n   SHOULD use mechanisms to filter\
    \ out packets from unwanted sources.\n   WEBRC assumes that the packet route between\
    \ the sender and a\n   particular receiver is the same for all channels associated\
    \ with a\n   session.  For SSM this assumption is true because the multicast tree\n\
    \   is a shortest path tree from each receiver to the sender and\n   generally\
    \ this path changes infrequently.  For ASM there are some\n   issues that if not\
    \ properly considered may invalidate this\n   assumption.  With ASM, the packet\
    \ route between the sender and\n   receivers may initially be through the Rendezvous\
    \ Point (RP) and then\n   switch over to the shortest path to the sender as packets\
    \ start\n   flowing in a channel.  The first issue is that the RP may not be the\n\
    \   same for all channels associated with a session, and thus the first\n   packets\
    \ sent to the channels may follow a route that depends on the\n   RP of the channel.\
    \  This depends on the RP configuration for the\n   sender.  If the sender registers\
    \ all channels associated with the\n   session with the same RP then the assumption\
    \ is true, but if the\n   sender registers different channels with different RPs\
    \ then the\n   assumption may not be true.  Thus, it is RECOMMENDED that the sender\n\
    \   register all channels associated with a session with the same RP.\n   Another\
    \ issue is that when the channel switches over from the RP to\n   the sender-based\
    \ tree then the route to the receivers may vary within\n   a channel.  Furthermore,\
    \ this may cause either the receipt of\n   duplicate packets at receivers or loss\
    \ of packets depending on the\n   smoothness of the switchover.  Thus, it is RECOMMENDED\
    \ that the RP be\n   placed as close as possible to the sender.  The best location\
    \ for the\n   RP is that it be the first-hop router closest to the sender, in\
    \ which\n   case the path to the sender and the path to the RP is the same for\n\
    \   each receiver and the problems mentioned above are eliminated.  The\n   consequences\
    \ of this assumption not being true are that the receiver\n   reaction to congestion\
    \ may not be appropriate.  Generally, the WEBRC\n   receiver will act conservatively\
    \ and reduce its reception rate too\n   much if this assumption is not true, but\
    \ there can be cases where the\n   receivers will act inappropriately.\n"
- title: 5.  Packet Header Fields
  contents:
  - "5.  Packet Header Fields\n   Packets sent to a session using WEBRC MUST include\
    \ Congestion Control\n   Information fields as specified in this section. This\
    \ document\n   specifies short and long formats for the Congestion Control\n \
    \  Information, and it is RECOMMENDED that protocol instantiations use\n   one\
    \ of these two formats.  Other formats for the Congestion Control\n   Information\
    \ fields MAY be used by protocol instantiations, but all\n   protocol instantiations\
    \ are REQUIRED to use these fields in a format\n   that is compatible with the\
    \ interpretations of these fields.  Thus,\n   if a protocol does use a different\
    \ format for the fields in the\n   Congestion Control Information then it MUST\
    \ specify the lengths and\n   positions of these fields within the packet header.\n\
    \   All integer fields are carried in \"big-endian\" or \"network order\"\n  \
    \ format, that is, most significant byte (octet) first.  All constants,\n   unless\
    \ otherwise specified, are expressed in base ten.\n"
- title: 5.1.  Short Format Congestion Control Information
  contents:
  - "5.1.  Short Format Congestion Control Information\n   The short format for the\
    \ Congestion Control Information is shown in\n   Fig. 1.  The total length of\
    \ the short format is 32-bits.\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      CTSI     | Channel Number|    Packet Sequence Number     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Fig. 1 - Short format for Congestion Control Information\n   The function\
    \ of each field in the Congestion Control Information is\n   the following.\n\
    \      Current Time Slot Index (CTSI): 8 bits\n         CTSI indicates the index\
    \ of the current time slot.  This must\n         be sent in each packet within\
    \ the session.  The Current Time\n         Slot Index increases by one modulo\
    \ T each TSD seconds at the\n         sender, where T is the number of time slots\
    \ associated with the\n         session and TSD is the time slot duration.  Note\
    \ that T is also\n         the number of wave channels associated with the session,\
    \ and\n         thus T MUST be at most 255.\n      Channel Number (CN): 8 bits\n\
    \         CN is the channel number that this packet belongs to.  CN for\n    \
    \     the base channel is T, and the CNs for the wave channels are 0\n       \
    \  through T-1.  Thus, T+1 channels in total are used, and thus T\n         MUST\
    \ be at most 255.\n      Packet Sequence Number (PSN): 16 bits\n         The PSN\
    \ of each packet is scoped by its CN value.  The sequence\n         numbers of\
    \ consecutive packets sent to the base channel are\n         numbered consecutively\
    \ modulo 2^16.  The same sequence of PSNs\n         are used for each wave channel\
    \ in each cycle.  The sequence\n         numbers of consecutive packets sent to\
    \ a wave channel are\n         numbered consecutively modulo 2^16 within each\
    \ cycle, ending\n         with the last packet sent to the channel before the\
    \ channel\n         goes quiescent with PSN = 2^16-1.\n"
- title: 5.2.  Long Format Congestion Control Information
  contents:
  - "5.2.  Long Format Congestion Control Information\n   The long format for the\
    \ Congestion Control Information is shown in\n   Fig.  2.  The total length of\
    \ the long format is 64-bits.\n    0                   1                   2 \
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             CTSI              |        Channel Number         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Packet Sequence Number                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Fig. 2 - Long format for Congestion Control Information\n   The meaning of\
    \ each field for the long format is the same as for the\n   short format, the\
    \ only difference is that each field is twice as\n   long.\n      Current Time\
    \ Slot Index (CTSI): 16 bits\n         CTSI indicates the index of the current\
    \ time slot.  This must\n         be sent in each packet within the session. \
    \ The Current Time\n         Slot Index increases by one modulo T each TSD seconds\
    \ at the\n         sender, where T is the number of time slots associated with\
    \ the\n         session and TSD is the time slot duration.  Note that T is also\n\
    \         the number of wave channels associated with the session, and\n     \
    \    thus T MUST be at most 65,535.\n      Channel Number (CN): 16 bits\n    \
    \     CN is the channel number that this packet belongs to.  CN for\n        \
    \ the base channel is T, and the CNs for the wave channels are 0\n         through\
    \ T-1.  Thus, T+1 channels in total are used, and thus T\n         MUST be at\
    \ most 65,535.\n      Packet Sequence Number (PSN): 32 bits\n         The PSN\
    \ of each packet is scoped by its CN value.  The sequence\n         numbers of\
    \ consecutive packets sent to the base channel are\n         numbered consecutively\
    \ modulo 2^32.  The same sequence of PSNs\n         are used for each wave channel\
    \ in each cycle.  The sequence\n         numbers of consecutive packets sent to\
    \ a wave channel are\n         numbered consecutively modulo 2^32 within each\
    \ cycle, ending\n         with the last packet sent to the channel before the\
    \ channel\n         goes quiescent with PSN = 2^32-1.\n"
- title: 6.  Requirements From Other Building Blocks
  contents:
  - "6.  Requirements From Other Building Blocks\n   As described in RFC 3048 [4],\
    \ WEBRC is a building block that is\n   intended to be used, in conjunction with\
    \ other building blocks, to\n   help specify a protocol instantiation.\n   WEBRC\
    \ does not provide higher level session support, e.g., how\n   receivers obtain\
    \ the necessary session description and how the\n   receivers demultiplex received\
    \ packets based on their session.  There\n   is support provided by other building\
    \ blocks that can be used in\n   conjunction with WEBRC to provide some of this\
    \ support.  For example,\n   LCT [12] can provide some of the higher level in-band\
    \ session support\n   that may be needed by receivers, and the WEBRC Congestion\
    \ Control\n   Information (CCI) required in each packet can be carried in the\
    \ CCI\n   field of the LCT header [12].\n   WEBRC does not provide any type of\
    \ reliability, and in particular\n   does not provide support for retransmission\
    \ of loss packets.\n   Reliability can be added by independent means, such as\
    \ by the use of\n   FEC codes as described in [13] and specified in the FEC building\n\
    \   block [14].\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   WEBRC can be subject to denial-of-service attacks\
    \ by attackers that\n   try to confuse the congestion control mechanism for receivers\
    \ by\n   injecting forged packets into the multicast stream.  This attack most\n\
    \   adversely affects network elements and receivers downstream of the\n   attack,\
    \ and much less significantly the rest of the network and other\n   receivers.\
    \  Because of this and because of the potential attacks due\n   to the use of\
    \ FEC described above, it is RECOMMENDED that Reverse\n   Path Forwarding checks\
    \ be enabled in all network routers and switches\n   along the path from the sender\
    \ to receivers to limit the possibility\n   of a bad agent injecting forged packets\
    \ into the multicast tree data\n   path.\n   It is also RECOMMENDED that packet\
    \ authentication be used to\n   authenticate each packet immediately upon receipt\
    \ before the receiver\n   performs any WEBRC actions based upon its receipt. \
    \ Unfortunately,\n   there are currently no practical multicast packet authentication\n\
    \   schemes that offer instant packet authentication upon receipt.\n   However,\
    \ TESLA [17] can be used to authenticate each packet a few\n   seconds after receipt.\
    \  Thus, TESLA could be used in conjunction with\n   WEBRC to authenticate packets\
    \ and for example terminate the session\n   upon detection of a forged packet.\
    \  However, it is RECOMMENDED that\n   the normal WEBRC receiver responses to\
    \ received packets occur\n   immediately -- not delayed by the TESLA authentication\
    \ process.  This\n   is because the overall WEBRC performance would be greatly\
    \ degraded if\n   the receiver delayed its WEBRC response to packet receipt for\
    \ several\n   seconds.\n   A receiver with an incorrect or corrupted implementation\
    \ of WEBRC may\n   affect health of the network in the path between the sender\
    \ and the\n   receiver, and may also affect the reception rates of other receivers\n\
    \   joined to the session.  It is therefore RECOMMENDED that receivers be\n  \
    \ required to identify themselves as legitimate before they receive the\n   session\
    \ description needed to join the session.\n   Another vulnerability of WEBRC is\
    \ the potential of receivers\n   obtaining an incorrect session description for\
    \ the session.  The\n   consequences of this could be that legitimate receivers\
    \ with the\n   wrong session description are unable to correctly receive the session\n\
    \   content, or that receivers inadvertently try to receive at a much\n   higher\
    \ rate than they are capable of, thereby disrupting traffic in\n   portions of\
    \ the network.  To avoid these problems, it is RECOMMENDED\n   that measures be\
    \ taken to prevent receivers from accepting incorrect\n   session descriptions,\
    \ e.g., by using source authentication to ensure\n   that receivers only accept\
    \ legitimate session descriptions from\n   authorized senders.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n \
    \  [2]  Kermode, R. and L. Vicisano, \"Author Guidelines for Reliable\n      \
    \  Multicast Transport (RMT) Building Blocks and Protocol\n        Instantiation\
    \ documents\", RFC 3269, April 2002.\n   [3]  Mankin, A., Romanow, A., Bradner,\
    \ S. and V. Paxson, \"IETF\n        Criteria for Evaluating Reliable Multicast\
    \ Transport and\n        Application Protocols\", RFC 2357, June 1998.\n   [4]\
    \  Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S.\n        and\
    \ M. Luby, \"Reliable Multicast Transport Building Blocks for\n        One-to-Many\
    \ Bulk-Data Transfer\", RFC 3048, January 2001.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [5]  Byers, J., Horn, G., Luby, M., Mitzenmacher,\
    \ M. and W. Shaver.\n        \"FLID-DL: Congestion control for layered multicast,\"\
    \ IEEE J. on\n        Selected Areas in Communications, Special Issue on Network\n\
    \        Support for Multicast Communication, Vol. 20, No. 8, October\n      \
    \  2002, pp. 1558-1570.\n   [6]  Dagum, P., Karp, R., Luby, M. and S. Ross, \"\
    An optimal algorithm\n        for Monte Carlo estimation,\" SIAM J. Comput., 29(5):1484-1496,\n\
    \        April 2000.\n   [7]  Deering, S., \"Host Extensions for IP Multicasting\"\
    , STD 5, RFC\n        1112, August 1989.\n   [8]  Goyal, V., \"On WEBRC Wave Design\
    \ and Server Implementation\",\n        Digital Fountain Technical Report no.\
    \ DF2002-09-001, September\n        2002, available at http://www.digitalfountain.com/technology/.\n\
    \   [9]  Handley, M., Floyd, S., Padhye, J. and J. Widmer, \"TCP Friendly\n  \
    \      Rate Control (TFRC): Protocol Specification\", RFC 3448, January\n    \
    \    2003.\n   [10] Holbrook, H., \"A Channel Model for Multicast\", Ph.D.\n \
    \       Dissertation, Stanford University, Department of Computer\n        Science,\
    \ Stanford, California, August 2001.\n   [11] Luby, M., Gemmell, J., Vicisano,\
    \ L., Rizzo, L. and J. Crowcroft,\n        \"Asynchronous Layered Coding (ALC)\
    \ Protocol Instantiation\", RFC\n        3450, December 2002.\n   [12] Luby, M.,\
    \ Gemmell, J., Vicisano, L., Rizzo, L., Handley, M. and\n        J.  Crowcroft,\
    \ \"Layered Coding Transport (LCT) Building Block\",\n        RFC 3451, December\
    \ 2002.\n   [13] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M. and\n\
    \        J. Crowcroft, \"The Use of Forward Error Correction (FEC) in\n      \
    \  Reliable Multicast\", RFC 3453, December 2002.\n   [14] Luby, M., Vicisano,\
    \ L., Gemmell, J., Rizzo, L., Handley, M. and\n        J.  Crowcroft, \"Forward\
    \ Error Correction (FEC) Building Block\",\n        RFC 3452, December 2002.\n\
    \   [15] Luby, M. and V. Goyal, \"Wave and Equation Based Rate Control\n     \
    \   Using Multicast Round Trip Time: Extended Report\", Digital\n        Fountain\
    \ Technical Report no. DF2002-07-001, September 2002,\n        available at http://www.digitalfountain.com/technology/.\n\
    \   [16] Luby, M., Goyal, V., Skaria, S. and G. Horn, \"Wave and Equation\n  \
    \      Based Rate Control Using Multicast Round Trip Time\", Proc. ACM\n     \
    \   SIGCOMM 2002, Pittsburgh, PA,  August 2002, pp. 191-214.\n   [17] Perrig,\
    \ A., Canetti, R., Song, D. and J. Tygar, \"Efficient and\n        Secure Source\
    \ Authentication for Multicast\", Network and\n        Distributed System Security\
    \ Symposium, NDSS 2001, pp. 35-46,\n        February 2001.\n   [18] Vicisano,\
    \ L., Rizzo, L. and J. Crowcroft, \"TCP-like Congestion\n        Control for Layered\
    \ Multicast Data Transfer\", Proc. IEEE Infocom\n        '98, San Francisco, CA,\
    \ March-April 1998, pp. 996-1003.\n"
- title: 9.  Authors' Addresses
  contents:
  - "9.  Authors' Addresses\n   Michael Luby\n   Digital Fountain\n   39141 Civic\
    \ Center Drive, Suite 300\n   Fremont, CA, USA, 94538\n   EMail: luby@digitalfountain.com\n\
    \   Vivek K Goyal\n   Massachusetts Institute of Technology\n   Room 36-690\n\
    \   77 Massachusetts Avenue\n   Cambridge, MA, USA, 02139\n   EMail: v.goyal@ieee.org\n"
- title: 10.  Full Copyright Statement
  contents:
  - "10.  Full Copyright Statement\n   Copyright (C) The Internet Society (2004).\
    \  This document is subject\n   to the rights, licenses and restrictions contained\
    \ in BCP 78 and\n   except as set forth therein, the authors retain all their\
    \ rights.\n   This document and the information contained herein are provided\
    \ on an\n   \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n\
    \   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
