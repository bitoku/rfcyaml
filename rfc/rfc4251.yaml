- title: __initial_text__
  contents:
  - '              The Secure Shell (SSH) Protocol Architecture

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   The Secure Shell (SSH) Protocol is a protocol for secure remote\
    \ login\n   and other secure network services over an insecure network.  This\n\
    \   document describes the architecture of the SSH protocol, as well as\n   the\
    \ notation and terminology used in SSH protocol documents.  It also\n   discusses\
    \ the SSH algorithm naming system that allows local\n   extensions.  The SSH protocol\
    \ consists of three major components: The\n   Transport Layer Protocol provides\
    \ server authentication,\n   confidentiality, and integrity with perfect forward\
    \ secrecy.  The\n   User Authentication Protocol authenticates the client to the\
    \ server.\n   The Connection Protocol multiplexes the encrypted tunnel into several\n\
    \   logical channels.  Details of these protocols are described in\n   separate\
    \ documents.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Contributors ....................................................3\n  \
    \ 3. Conventions Used in This Document ...............................4\n   4.\
    \ Architecture ....................................................4\n      4.1.\
    \ Host Keys ..................................................4\n      4.2. Extensibility\
    \ ..............................................6\n      4.3. Policy Issues ..............................................6\n\
    \      4.4. Security Properties ........................................7\n  \
    \    4.5. Localization and Character Set Support .....................7\n   5.\
    \ Data Type Representations Used in the SSH Protocols .............8\n   6. Algorithm\
    \ and Method Naming ....................................10\n   7. Message Numbers\
    \ ................................................11\n   8. IANA Considerations\
    \ ............................................12\n   9. Security Considerations\
    \ ........................................13\n      9.1. Pseudo-Random Number\
    \ Generation ...........................13\n      9.2. Control Character Filtering\
    \ ...............................14\n      9.3. Transport .................................................14\n\
    \           9.3.1. Confidentiality ....................................14\n  \
    \         9.3.2. Data Integrity .....................................16\n    \
    \       9.3.3. Replay .............................................16\n      \
    \     9.3.4. Man-in-the-middle ..................................17\n        \
    \   9.3.5. Denial of Service ..................................19\n          \
    \ 9.3.6. Covert Channels ....................................20\n           9.3.7.\
    \ Forward Secrecy ....................................20\n           9.3.8. Ordering\
    \ of Key Exchange Methods ...................20\n           9.3.9. Traffic Analysis\
    \ ...................................21\n      9.4. Authentication Protocol ...................................21\n\
    \           9.4.1. Weak Transport .....................................21\n  \
    \         9.4.2. Debug Messages .....................................22\n    \
    \       9.4.3. Local Security Policy ..............................22\n      \
    \     9.4.4. Public Key Authentication ..........................23\n        \
    \   9.4.5. Password Authentication ............................23\n          \
    \ 9.4.6. Host-Based Authentication ..........................23\n      9.5. Connection\
    \ Protocol .......................................24\n           9.5.1. End Point\
    \ Security .................................24\n           9.5.2. Proxy Forwarding\
    \ ...................................24\n           9.5.3. X11 Forwarding .....................................24\n\
    \   10. References ....................................................26\n  \
    \    10.1. Normative References .....................................26\n    \
    \  10.2. Informative References ...................................26\n   Authors'\
    \ Addresses ................................................29\n   Trademark Notice\
    \ ..................................................29\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Secure Shell (SSH) is a protocol for secure remote login\
    \ and other\n   secure network services over an insecure network.  It consists\
    \ of\n   three major components:\n   o  The Transport Layer Protocol [SSH-TRANS]\
    \ provides server\n      authentication, confidentiality, and integrity.  It may\
    \ optionally\n      also provide compression.  The transport layer will typically\
    \ be\n      run over a TCP/IP connection, but might also be used on top of any\n\
    \      other reliable data stream.\n   o  The User Authentication Protocol [SSH-USERAUTH]\
    \ authenticates the\n      client-side user to the server.  It runs over the transport\
    \ layer\n      protocol.\n   o  The Connection Protocol [SSH-CONNECT] multiplexes\
    \ the encrypted\n      tunnel into several logical channels.  It runs over the\
    \ user\n      authentication protocol.\n   The client sends a service request\
    \ once a secure transport layer\n   connection has been established.  A second\
    \ service request is sent\n   after user authentication is complete.  This allows\
    \ new protocols to\n   be defined and coexist with the protocols listed above.\n\
    \   The connection protocol provides channels that can be used for a wide\n  \
    \ range of purposes.  Standard methods are provided for setting up\n   secure\
    \ interactive shell sessions and for forwarding (\"tunneling\")\n   arbitrary\
    \ TCP/IP ports and X11 connections.\n"
- title: 2.  Contributors
  contents:
  - "2.  Contributors\n   The major original contributors of this set of documents\
    \ have been:\n   Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen (all\
    \ of SSH\n   Communications Security Corp), and Markku-Juhani O. Saarinen\n  \
    \ (University of Jyvaskyla).  Darren Moffat was the original editor of\n   this\
    \ set of documents and also made very substantial contributions.\n   Many people\
    \ contributed to the development of this document over the\n   years.  People\
    \ who should be acknowledged include Mats Andersson, Ben\n   Harris, Bill Sommerfeld,\
    \ Brent McClure, Niels Moller, Damien Miller,\n   Derek Fawcus, Frank Cusack,\
    \ Heikki Nousiainen, Jakob Schlyter, Jeff\n   Van Dyke, Jeffrey Altman, Jeffrey\
    \ Hutzelman, Jon Bright, Joseph\n   Galbraith, Ken Hornstein, Markus Friedl, Martin\
    \ Forssen, Nicolas\n   Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon\n\
    \   Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse, and\n   Tadayoshi\
    \ Kohno.  Listing their names here does not mean that they\n   endorse this document,\
    \ but that they have contributed to it.\n"
- title: 3.  Conventions Used in This Document
  contents:
  - "3.  Conventions Used in This Document\n   All documents related to the SSH protocols\
    \ shall use the keywords\n   \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",\
    \ \"SHALL NOT\", \"SHOULD\",\n   \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" to describe\n   requirements.  These keywords are to be interpreted\
    \ as described in\n   [RFC2119].\n   The keywords \"PRIVATE USE\", \"HIERARCHICAL\
    \ ALLOCATION\", \"FIRST COME\n   FIRST SERVED\", \"EXPERT REVIEW\", \"SPECIFICATION\
    \ REQUIRED\", \"IESG\n   APPROVAL\", \"IETF CONSENSUS\", and \"STANDARDS ACTION\"\
    \ that appear in\n   this document when used to describe namespace allocation\
    \ are to be\n   interpreted as described in [RFC2434].\n   Protocol fields and\
    \ possible values to fill them are defined in this\n   set of documents.  Protocol\
    \ fields will be defined in the message\n   definitions.  As an example, SSH_MSG_CHANNEL_DATA\
    \ is defined as\n   follows.\n      byte      SSH_MSG_CHANNEL_DATA\n      uint32\
    \    recipient channel\n      string    data\n   Throughout these documents, when\
    \ the fields are referenced, they will\n   appear within single quotes.  When\
    \ values to fill those fields are\n   referenced, they will appear within double\
    \ quotes.  Using the above\n   example, possible values for 'data' are \"foo\"\
    \ and \"bar\".\n"
- title: 4.  Architecture
  contents:
  - '4.  Architecture

    '
- title: 4.1.  Host Keys
  contents:
  - "4.1.  Host Keys\n   Each server host SHOULD have a host key.  Hosts MAY have\
    \ multiple\n   host keys using multiple different algorithms.  Multiple hosts\
    \ MAY\n   share the same host key.  If a host has keys at all, it MUST have at\n\
    \   least one key that uses each REQUIRED public key algorithm (DSS\n   [FIPS-186-2]).\n\
    \   The server host key is used during key exchange to verify that the\n   client\
    \ is really talking to the correct server.  For this to be\n   possible, the client\
    \ must have a priori knowledge of the server's\n   public host key.\n   Two different\
    \ trust models can be used:\n   o  The client has a local database that associates\
    \ each host name (as\n      typed by the user) with the corresponding public host\
    \ key.  This\n      method requires no centrally administered infrastructure,\
    \ and no\n      third-party coordination.  The downside is that the database of\n\
    \      name-to-key associations may become burdensome to maintain.\n   o  The\
    \ host name-to-key association is certified by a trusted\n      certification\
    \ authority (CA).  The client only knows the CA root\n      key, and can verify\
    \ the validity of all host keys certified by\n      accepted CAs.\n   The second\
    \ alternative eases the maintenance problem, since ideally\n   only a single CA\
    \ key needs to be securely stored on the client.  On\n   the other hand, each\
    \ host key must be appropriately certified by a\n   central authority before authorization\
    \ is possible.  Also, a lot of\n   trust is placed on the central infrastructure.\n\
    \   The protocol provides the option that the server name - host key\n   association\
    \ is not checked when connecting to the host for the first\n   time.  This allows\
    \ communication without prior communication of host\n   keys or certification.\
    \  The connection still provides protection\n   against passive listening; however,\
    \ it becomes vulnerable to active\n   man-in-the-middle attacks.  Implementations\
    \ SHOULD NOT normally allow\n   such connections by default, as they pose a potential\
    \ security\n   problem.  However, as there is no widely deployed key infrastructure\n\
    \   available on the Internet at the time of this writing, this option\n   makes\
    \ the protocol much more usable during the transition time until\n   such an infrastructure\
    \ emerges, while still providing a much higher\n   level of security than that\
    \ offered by older solutions (e.g., telnet\n   [RFC0854] and rlogin [RFC1282]).\n\
    \   Implementations SHOULD try to make the best effort to check host\n   keys.\
    \  An example of a possible strategy is to only accept a host key\n   without\
    \ checking the first time a host is connected, save the key in\n   a local database,\
    \ and compare against that key on all future\n   connections to that host.\n \
    \  Implementations MAY provide additional methods for verifying the\n   correctness\
    \ of host keys, e.g., a hexadecimal fingerprint derived\n   from the SHA-1 hash\
    \ [FIPS-180-2] of the public key.  Such\n   fingerprints can easily be verified\
    \ by using telephone or other\n   external communication channels.\n   All implementations\
    \ SHOULD provide an option not to accept host keys\n   that cannot be verified.\n\
    \   The members of this Working Group believe that 'ease of use' is\n   critical\
    \ to end-user acceptance of security solutions, and no\n   improvement in security\
    \ is gained if the new solutions are not used.\n   Thus, providing the option\
    \ not to check the server host key is\n   believed to improve the overall security\
    \ of the Internet, even though\n   it reduces the security of the protocol in\
    \ configurations where it is\n   allowed.\n"
- title: 4.2.  Extensibility
  contents:
  - "4.2.  Extensibility\n   We believe that the protocol will evolve over time, and\
    \ some\n   organizations will want to use their own encryption, authentication,\n\
    \   and/or key exchange methods.  Central registration of all extensions\n   is\
    \ cumbersome, especially for experimental or classified features.\n   On the other\
    \ hand, having no central registration leads to conflicts\n   in method identifiers,\
    \ making interoperability difficult.\n   We have chosen to identify algorithms,\
    \ methods, formats, and\n   extension protocols with textual names that are of\
    \ a specific format.\n   DNS names are used to create local namespaces where experimental\
    \ or\n   classified extensions can be defined without fear of conflicts with\n\
    \   other implementations.\n   One design goal has been to keep the base protocol\
    \ as simple as\n   possible, and to require as few algorithms as possible.  However,\
    \ all\n   implementations MUST support a minimal set of algorithms to ensure\n\
    \   interoperability (this does not imply that the local policy on all\n   hosts\
    \ would necessarily allow these algorithms).  The mandatory\n   algorithms are\
    \ specified in the relevant protocol documents.\n   Additional algorithms, methods,\
    \ formats, and extension protocols can\n   be defined in separate documents. \
    \ See Section 6, Algorithm Naming,\n   for more information.\n"
- title: 4.3.  Policy Issues
  contents:
  - "4.3.  Policy Issues\n   The protocol allows full negotiation of encryption, integrity,\
    \ key\n   exchange, compression, and public key algorithms and formats.\n   Encryption,\
    \ integrity, public key, and compression algorithms can be\n   different for each\
    \ direction.\n   The following policy issues SHOULD be addressed in the configuration\n\
    \   mechanisms of each implementation:\n   o  Encryption, integrity, and compression\
    \ algorithms, separately for\n      each direction.  The policy MUST specify which\
    \ is the preferred\n      algorithm (e.g., the first algorithm listed in each\
    \ category).\n   o  Public key algorithms and key exchange method to be used for\
    \ host\n      authentication.  The existence of trusted host keys for different\n\
    \      public key algorithms also affects this choice.\n   o  The authentication\
    \ methods that are to be required by the server\n      for each user.  The server's\
    \ policy MAY require multiple\n      authentication for some or all users.  The\
    \ required algorithms MAY\n      depend on the location from where the user is\
    \ trying to gain\n      access.\n   o  The operations that the user is allowed\
    \ to perform using the\n      connection protocol.  Some issues are related to\
    \ security; for\n      example, the policy SHOULD NOT allow the server to start\
    \ sessions\n      or run commands on the client machine, and MUST NOT allow\n\
    \      connections to the authentication agent unless forwarding such\n      connections\
    \ has been requested.  Other issues, such as which\n      TCP/IP ports can be\
    \ forwarded and by whom, are clearly issues of\n      local policy.  Many of these\
    \ issues may involve traversing or\n      bypassing firewalls, and are interrelated\
    \ with the local security\n      policy.\n"
- title: 4.4.  Security Properties
  contents:
  - "4.4.  Security Properties\n   The primary goal of the SSH protocol is to improve\
    \ security on the\n   Internet.  It attempts to do this in a way that is easy\
    \ to deploy,\n   even at the cost of absolute security.\n   o  All encryption,\
    \ integrity, and public key algorithms used are\n      well-known, well-established\
    \ algorithms.\n   o  All algorithms are used with cryptographically sound key\
    \ sizes\n      that are believed to provide protection against even the strongest\n\
    \      cryptanalytic attacks for decades.\n   o  All algorithms are negotiated,\
    \ and in case some algorithm is\n      broken, it is easy to switch to some other\
    \ algorithm without\n      modifying the base protocol.\n   Specific concessions\
    \ were made to make widespread, fast deployment\n   easier.  The particular case\
    \ where this comes up is verifying that\n   the server host key really belongs\
    \ to the desired host; the protocol\n   allows the verification to be left out,\
    \ but this is NOT RECOMMENDED.\n   This is believed to significantly improve usability\
    \ in the short\n   term, until widespread Internet public key infrastructures\
    \ emerge.\n"
- title: 4.5.  Localization and Character Set Support
  contents:
  - "4.5.  Localization and Character Set Support\n   For the most part, the SSH protocols\
    \ do not directly pass text that\n   would be displayed to the user.  However,\
    \ there are some places where\n   such data might be passed.  When applicable,\
    \ the character set for\n   the data MUST be explicitly specified.  In most places,\
    \ ISO-10646\n   UTF-8 encoding is used [RFC3629].  When applicable, a field is\
    \ also\n   provided for a language tag [RFC3066].\n   One big issue is the character\
    \ set of the interactive session.  There\n   is no clear solution, as different\
    \ applications may display data in\n   different formats.  Different types of\
    \ terminal emulation may also be\n   employed in the client, and the character\
    \ set to be used is\n   effectively determined by the terminal emulation.  Thus,\
    \ no place is\n   provided for directly specifying the character set or encoding\
    \ for\n   terminal session data.  However, the terminal emulation type (e.g.,\n\
    \   \"vt100\") is transmitted to the remote site, and it implicitly\n   specifies\
    \ the character set and encoding.  Applications typically use\n   the terminal\
    \ type to determine what character set they use, or the\n   character set is determined\
    \ using some external means.  The terminal\n   emulation may also allow configuring\
    \ the default character set.  In\n   any case, the character set for the terminal\
    \ session is considered\n   primarily a client local issue.\n   Internal names\
    \ used to identify algorithms or protocols are normally\n   never displayed to\
    \ users, and must be in US-ASCII.\n   The client and server user names are inherently\
    \ constrained by what\n   the server is prepared to accept.  They might, however,\
    \ occasionally\n   be displayed in logs, reports, etc.  They MUST be encoded using\
    \ ISO\n   10646 UTF-8, but other encodings may be required in some cases.  It\n\
    \   is up to the server to decide how to map user names to accepted user\n   names.\
    \  Straight bit-wise, binary comparison is RECOMMENDED.\n   For localization purposes,\
    \ the protocol attempts to minimize the\n   number of textual messages transmitted.\
    \  When present, such messages\n   typically relate to errors, debugging information,\
    \ or some externally\n   configured data.  For data that is normally displayed,\
    \ it SHOULD be\n   possible to fetch a localized message instead of the transmitted\n\
    \   message by using a numerical code.  The remaining messages SHOULD be\n   configurable.\n"
- title: 5.  Data Type Representations Used in the SSH Protocols
  contents:
  - "5.  Data Type Representations Used in the SSH Protocols\n   byte\n      A byte\
    \ represents an arbitrary 8-bit value (octet).  Fixed length\n      data is sometimes\
    \ represented as an array of bytes, written\n      byte[n], where n is the number\
    \ of bytes in the array.\n   boolean\n      A boolean value is stored as a single\
    \ byte.  The value 0\n      represents FALSE, and the value 1 represents TRUE.\
    \  All non-zero\n      values MUST be interpreted as TRUE; however, applications\
    \ MUST NOT\n      store values other than 0 and 1.\n   uint32\n      Represents\
    \ a 32-bit unsigned integer.  Stored as four bytes in the\n      order of decreasing\
    \ significance (network byte order).  For\n      example: the value 699921578\
    \ (0x29b7f4aa) is stored as 29 b7 f4\n      aa.\n   uint64\n      Represents a\
    \ 64-bit unsigned integer.  Stored as eight bytes in\n      the order of decreasing\
    \ significance (network byte order).\n   string\n      Arbitrary length binary\
    \ string.  Strings are allowed to contain\n      arbitrary binary data, including\
    \ null characters and 8-bit\n      characters.  They are stored as a uint32 containing\
    \ its length\n      (number of bytes that follow) and zero (= empty string) or\
    \ more\n      bytes that are the value of the string.  Terminating null\n    \
    \  characters are not used.\n      Strings are also used to store text.  In that\
    \ case, US-ASCII is\n      used for internal names, and ISO-10646 UTF-8 for text\
    \ that might\n      be displayed to the user.  The terminating null character\
    \ SHOULD\n      NOT normally be stored in the string.  For example: the US-ASCII\n\
    \      string \"testing\" is represented as 00 00 00 07 t e s t i n g.  The\n\
    \      UTF-8 mapping does not alter the encoding of US-ASCII characters.\n   mpint\n\
    \      Represents multiple precision integers in two's complement format,\n  \
    \    stored as a string, 8 bits per byte, MSB first.  Negative numbers\n     \
    \ have the value 1 as the most significant bit of the first byte of\n      the\
    \ data partition.  If the most significant bit would be set for\n      a positive\
    \ number, the number MUST be preceded by a zero byte.\n      Unnecessary leading\
    \ bytes with the value 0 or 255 MUST NOT be\n      included.  The value zero MUST\
    \ be stored as a string with zero\n      bytes of data.\n      By convention,\
    \ a number that is used in modular computations in\n      Z_n SHOULD be represented\
    \ in the range 0 <= x < n.\n         Examples:\n         value (hex)        representation\
    \ (hex)\n         -----------        --------------------\n         0        \
    \          00 00 00 00\n         9a378f9b2e332a7    00 00 00 08 09 a3 78 f9 b2\
    \ e3 32 a7\n         80                 00 00 00 02 00 80\n         -1234    \
    \          00 00 00 02 ed cc\n         -deadbeef          00 00 00 05 ff 21 52\
    \ 41 11\n   name-list\n      A string containing a comma-separated list of names.\
    \  A name-list\n      is represented as a uint32 containing its length (number\
    \ of bytes\n      that follow) followed by a comma-separated list of zero or more\n\
    \      names.  A name MUST have a non-zero length, and it MUST NOT\n      contain\
    \ a comma (\",\").  As this is a list of names, all of the\n      elements contained\
    \ are names and MUST be in US-ASCII.  Context may\n      impose additional restrictions\
    \ on the names.  For example, the\n      names in a name-list may have to be a\
    \ list of valid algorithm\n      identifiers (see Section 6 below), or a list\
    \ of [RFC3066] language\n      tags.  The order of the names in a name-list may\
    \ or may not be\n      significant.  Again, this depends on the context in which\
    \ the list\n      is used.  Terminating null characters MUST NOT be used, neither\n\
    \      for the individual names, nor for the list as a whole.\n       Examples:\n\
    \       value                      representation (hex)\n       -----        \
    \              --------------------\n       (), the empty name-list    00 00 00\
    \ 00\n       (\"zlib\")                   00 00 00 04 7a 6c 69 62\n       (\"\
    zlib,none\")              00 00 00 09 7a 6c 69 62 2c 6e 6f 6e 65\n"
- title: 6.  Algorithm and Method Naming
  contents:
  - "6.  Algorithm and Method Naming\n   The SSH protocols refer to particular hash,\
    \ encryption, integrity,\n   compression, and key exchange algorithms or methods\
    \ by name.  There\n   are some standard algorithms and methods that all implementations\n\
    \   MUST support.  There are also algorithms and methods that are defined\n  \
    \ in the protocol specification, but are OPTIONAL.  Furthermore, it is\n   expected\
    \ that some organizations will want to use their own\n   algorithms or methods.\n\
    \   In this protocol, all algorithm and method identifiers MUST be\n   printable\
    \ US-ASCII, non-empty strings no longer than 64 characters.\n   Names MUST be\
    \ case-sensitive.\n   There are two formats for algorithm and method names:\n\
    \   o  Names that do not contain an at-sign (\"@\") are reserved to be\n     \
    \ assigned by IETF CONSENSUS.  Examples include \"3des-cbc\", \"sha-1\",\n   \
    \   \"hmac-sha1\", and \"zlib\" (the doublequotes are not part of the\n      name).\
    \  Names of this format are only valid if they are first\n      registered with\
    \ the IANA.  Registered names MUST NOT contain an\n      at-sign (\"@\"), comma\
    \ (\",\"), whitespace, control characters (ASCII\n      codes 32 or less), or\
    \ the ASCII code 127 (DEL).  Names are case-\n      sensitive, and MUST NOT be\
    \ longer than 64 characters.\n   o  Anyone can define additional algorithms or\
    \ methods by using names\n      in the format name@domainname, e.g., \"ourcipher-cbc@example.com\"\
    .\n      The format of the part preceding the at-sign is not specified;\n    \
    \  however, these names MUST be printable US-ASCII strings, and MUST\n      NOT\
    \ contain the comma character (\",\"), whitespace, control\n      characters (ASCII\
    \ codes 32 or less), or the ASCII code 127 (DEL).\n      They MUST have only a\
    \ single at-sign in them.  The part following\n      the at-sign MUST be a valid,\
    \ fully qualified domain name [RFC1034]\n      controlled by the person or organization\
    \ defining the name.  Names\n      are case-sensitive, and MUST NOT be longer\
    \ than 64 characters.  It\n      is up to each domain how it manages its local\
    \ namespace.  It\n      should be noted that these names resemble STD 11 [RFC0822]\
    \ email\n      addresses.  This is purely coincidental and has nothing to do with\n\
    \      STD 11 [RFC0822].\n"
- title: 7.  Message Numbers
  contents:
  - "7.  Message Numbers\n   SSH packets have message numbers in the range 1 to 255.\
    \  These\n   numbers have been allocated as follows:\n   Transport layer protocol:\n\
    \      1 to 19    Transport layer generic (e.g., disconnect, ignore,\n       \
    \          debug, etc.)\n      20 to 29   Algorithm negotiation\n      30 to 49\
    \   Key exchange method specific (numbers can be reused\n                 for\
    \ different authentication methods)\n   User authentication protocol:\n      50\
    \ to 59   User authentication generic\n      60 to 79   User authentication method\
    \ specific (numbers can be\n                 reused for different authentication\
    \ methods)\n   Connection protocol:\n      80 to 89   Connection protocol generic\n\
    \      90 to 127  Channel related messages\n   Reserved for client protocols:\n\
    \      128 to 191 Reserved\n   Local extensions:\n      192 to 255 Local extensions\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document is part of a set.  The instructions\
    \ for the IANA for\n   the SSH protocol, as defined in this document, [SSH-USERAUTH],\n\
    \   [SSH-TRANS], and [SSH-CONNECT], are detailed in [SSH-NUMBERS].  The\n   following\
    \ is a brief summary for convenience, but note well that\n   [SSH-NUMBERS] contains\
    \ the actual instructions to the IANA, which may\n   be superseded in the future.\n\
    \   Allocation of the following types of names in the SSH protocols is\n   assigned\
    \ by IETF consensus:\n   o  Service Names\n      *  Authentication Methods\n \
    \     *  Connection Protocol Channel Names\n      *  Connection Protocol Global\
    \ Request Names\n      *  Connection Protocol Channel Request Names\n   o  Key\
    \ Exchange Method Names\n   o  Assigned Algorithm Names\n      *  Encryption Algorithm\
    \ Names\n      *  MAC Algorithm Names\n      *  Public Key Algorithm Names\n \
    \     *  Compression Algorithm Names\n   These names MUST be printable US-ASCII\
    \ strings, and MUST NOT contain\n   the characters at-sign (\"@\"), comma (\"\
    ,\"), whitespace, control\n   characters (ASCII codes 32 or less), or the ASCII\
    \ code 127 (DEL).\n   Names are case-sensitive, and MUST NOT be longer than 64\
    \ characters.\n   Names with the at-sign (\"@\") are locally defined extensions\
    \ and are\n   not controlled by the IANA.\n   Each category of names listed above\
    \ has a separate namespace.\n   However, using the same name in multiple categories\
    \ SHOULD be avoided\n   to minimize confusion.\n   Message numbers (see Section\
    \ 7) in the range of 0 to 191 are\n   allocated via IETF CONSENSUS, as described\
    \ in [RFC2434].  Message\n   numbers in the 192 to 255 range (local extensions)\
    \ are reserved for\n   PRIVATE USE, also as described in [RFC2434].\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   In order to make the entire body of Security\
    \ Considerations more\n   accessible, Security Considerations for the transport,\n\
    \   authentication, and connection documents have been gathered here.\n   The\
    \ transport protocol [SSH-TRANS] provides a confidential channel\n   over an insecure\
    \ network.  It performs server host authentication,\n   key exchange, encryption,\
    \ and integrity protection.  It also derives\n   a unique session id that may\
    \ be used by higher-level protocols.\n   The authentication protocol [SSH-USERAUTH]\
    \ provides a suite of\n   mechanisms that can be used to authenticate the client\
    \ user to the\n   server.  Individual mechanisms specified in the authentication\n\
    \   protocol use the session id provided by the transport protocol and/or\n  \
    \ depend on the security and integrity guarantees of the transport\n   protocol.\n\
    \   The connection protocol [SSH-CONNECT] specifies a mechanism to\n   multiplex\
    \ multiple streams (channels) of data over the confidential\n   and authenticated\
    \ transport.  It also specifies channels for\n   accessing an interactive shell,\
    \ for proxy-forwarding various external\n   protocols over the secure transport\
    \ (including arbitrary TCP/IP\n   protocols), and for accessing secure subsystems\
    \ on the server host.\n"
- title: 9.1.  Pseudo-Random Number Generation
  contents:
  - "9.1.  Pseudo-Random Number Generation\n   This protocol binds each session key\
    \ to the session by including\n   random, session specific data in the hash used\
    \ to produce session\n   keys.  Special care should be taken to ensure that all\
    \ of the random\n   numbers are of good quality.  If the random data here (e.g.,\
    \ Diffie-\n   Hellman (DH) parameters) are pseudo-random, then the pseudo-random\n\
    \   number generator should be cryptographically secure (i.e., its next\n   output\
    \ not easily guessed even when knowing all previous outputs)\n   and, furthermore,\
    \ proper entropy needs to be added to the pseudo-\n   random number generator.\
    \  [RFC4086] offers suggestions for sources of\n   random numbers and entropy.\
    \  Implementers should note the importance\n   of entropy and the well-meant,\
    \ anecdotal warning about the difficulty\n   in properly implementing pseudo-random\
    \ number generating functions.\n   The amount of entropy available to a given\
    \ client or server may\n   sometimes be less than what is required.  In this case,\
    \ one must\n   either resort to pseudo-random number generation regardless of\n\
    \   insufficient entropy or refuse to run the protocol.  The latter is\n   preferable.\n"
- title: 9.2.  Control Character Filtering
  contents:
  - "9.2.  Control Character Filtering\n   When displaying text to a user, such as\
    \ error or debug messages, the\n   client software SHOULD replace any control\
    \ characters (except tab,\n   carriage return, and newline) with safe sequences\
    \ to avoid attacks by\n   sending terminal control characters.\n"
- title: 9.3.  Transport
  contents:
  - '9.3.  Transport

    '
- title: 9.3.1.  Confidentiality
  contents:
  - "9.3.1.  Confidentiality\n   It is beyond the scope of this document and the Secure\
    \ Shell Working\n   Group to analyze or recommend specific ciphers other than\
    \ the ones\n   that have been established and accepted within the industry.  At\
    \ the\n   time of this writing, commonly used ciphers include 3DES, ARCFOUR,\n\
    \   twofish, serpent, and blowfish.  AES has been published by The US\n   Federal\
    \ Information Processing Standards as [FIPS-197], and the\n   cryptographic community\
    \ has accepted AES as well.  As always,\n   implementers and users should check\
    \ current literature to ensure that\n   no recent vulnerabilities have been found\
    \ in ciphers used within\n   products.  Implementers should also check to see\
    \ which ciphers are\n   considered to be relatively stronger than others and should\
    \ recommend\n   their use to users over relatively weaker ciphers.  It would be\n\
    \   considered good form for an implementation to politely and\n   unobtrusively\
    \ notify a user that a stronger cipher is available and\n   should be used when\
    \ a weaker one is actively chosen.\n   The \"none\" cipher is provided for debugging\
    \ and SHOULD NOT be used\n   except for that purpose.  Its cryptographic properties\
    \ are\n   sufficiently described in [RFC2410], which will show that its use\n\
    \   does not meet the intent of this protocol.\n   The relative merits of these\
    \ and other ciphers may also be found in\n   current literature.  Two references\
    \ that may provide information on\n   the subject are [SCHNEIER] and [KAUFMAN].\
    \  Both of these describe the\n   CBC mode of operation of certain ciphers and\
    \ the weakness of this\n   scheme.  Essentially, this mode is theoretically vulnerable\
    \ to chosen\n   cipher-text attacks because of the high predictability of the\
    \ start\n   of packet sequence.  However, this attack is deemed difficult and\
    \ not\n   considered fully practicable, especially if relatively long block\n\
    \   sizes are used.\n   Additionally, another CBC mode attack may be mitigated\
    \ through the\n   insertion of packets containing SSH_MSG_IGNORE.  Without this\n\
    \   technique, a specific attack may be successful.  For this attack\n   (commonly\
    \ known as the Rogaway attack [ROGAWAY], [DAI], [BELLARE]) to\n   work, the attacker\
    \ would need to know the Initialization Vector (IV)\n   of the next block that\
    \ is going to be encrypted.  In CBC mode that is\n   the output of the encryption\
    \ of the previous block.  If the attacker\n   does not have any way to see the\
    \ packet yet (i.e., it is in the\n   internal buffers of the SSH implementation\
    \ or even in the kernel),\n   then this attack will not work.  If the last packet\
    \ has been sent out\n   to the network (i.e., the attacker has access to it),\
    \ then he can use\n   the attack.\n   In the optimal case, an implementer would\
    \ need to add an extra packet\n   only if the packet has been sent out onto the\
    \ network and there are\n   no other packets waiting for transmission.  Implementers\
    \ may wish to\n   check if there are any unsent packets awaiting transmission;\n\
    \   unfortunately, it is not normally easy to obtain this information\n   from\
    \ the kernel or buffers.  If there are no unsent packets, then a\n   packet containing\
    \ SSH_MSG_IGNORE SHOULD be sent.  If a new packet is\n   added to the stream every\
    \ time the attacker knows the IV that is\n   supposed to be used for the next\
    \ packet, then the attacker will not\n   be able to guess the correct IV, thus\
    \ the attack will never be\n   successful.\n   As an example, consider the following\
    \ case:\n      Client                                                  Server\n\
    \      ------                                                  ------\n      TCP(seq=x,\
    \ len=500)             ---->\n       contains Record 1\n                     \
    \     [500 ms passes, no ACK]\n      TCP(seq=x, len=1000)            ---->\n \
    \      contains Records 1,2\n                                                \
    \                ACK\n   1. The Nagle algorithm + TCP retransmits mean that the\
    \ two records\n      get coalesced into a single TCP segment.\n   2. Record 2\
    \ is not at the beginning of the TCP segment and never will\n      be because\
    \ it gets ACKed.\n   3. Yet, the attack is possible because Record 1 has already\
    \ been\n      seen.\n   As this example indicates, it is unsafe to use the existence\
    \ of\n   unflushed data in the TCP buffers proper as a guide to whether an\n \
    \  empty packet is needed, since when the second write() is performed\n   the\
    \ buffers will contain the un-ACKed Record 1.\n   On the other hand, it is perfectly\
    \ safe to have the following\n   situation:\n      Client                    \
    \                              Server\n      ------                          \
    \                        ------\n      TCP(seq=x, len=500)             ---->\n\
    \         contains SSH_MSG_IGNORE\n      TCP(seq=y, len=500)             ---->\n\
    \         contains Data\n      Provided that the IV for the second SSH Record\
    \ is fixed after the\n      data for the Data packet is determined, then the following\
    \ should\n      be performed:\n         read from user\n         encrypt null\
    \ packet\n         encrypt data packet\n"
- title: 9.3.2.  Data Integrity
  contents:
  - "9.3.2.  Data Integrity\n   This protocol does allow the Data Integrity mechanism\
    \ to be disabled.\n   Implementers SHOULD be wary of exposing this feature for\
    \ any purpose\n   other than debugging.  Users and administrators SHOULD be explicitly\n\
    \   warned anytime the \"none\" MAC is enabled.\n   So long as the \"none\" MAC\
    \ is not used, this protocol provides data\n   integrity.\n   Because MACs use\
    \ a 32-bit sequence number, they might start to leak\n   information after 2**32\
    \ packets have been sent.  However, following\n   the rekeying recommendations\
    \ should prevent this attack.  The\n   transport protocol [SSH-TRANS] recommends\
    \ rekeying after one gigabyte\n   of data, and the smallest possible packet is\
    \ 16 bytes.  Therefore,\n   rekeying SHOULD happen after 2**28 packets at the\
    \ very most.\n"
- title: 9.3.3.  Replay
  contents:
  - "9.3.3.  Replay\n   The use of a MAC other than \"none\" provides integrity and\n\
    \   authentication.  In addition, the transport protocol provides a\n   unique\
    \ session identifier (bound in part to pseudo-random data that\n   is part of\
    \ the algorithm and key exchange process) that can be used\n   by higher level\
    \ protocols to bind data to a given session and prevent\n   replay of data from\
    \ prior sessions.  For example, the authentication\n   protocol ([SSH-USERAUTH])\
    \ uses this to prevent replay of signatures\n   from previous sessions.  Because\
    \ public key authentication exchanges\n   are cryptographically bound to the session\
    \ (i.e., to the initial key\n   exchange), they cannot be successfully replayed\
    \ in other sessions.\n   Note that the session id can be made public without harming\
    \ the\n   security of the protocol.\n   If two sessions have the same session\
    \ id (hash of key exchanges),\n   then packets from one can be replayed against\
    \ the other.  It must be\n   stressed that the chances of such an occurrence are,\
    \ needless to say,\n   minimal when using modern cryptographic methods.  This\
    \ is all the\n   more true when specifying larger hash function outputs and DH\n\
    \   parameters.\n   Replay detection using monotonically increasing sequence numbers\
    \ as\n   input to the MAC, or HMAC in some cases, is described in [RFC2085],\n\
    \   [RFC2246], [RFC2743], [RFC1964], [RFC2025], and [RFC4120].  The\n   underlying\
    \ construct is discussed in [RFC2104].  Essentially, a\n   different sequence\
    \ number in each packet ensures that at least this\n   one input to the MAC function\
    \ will be unique and will provide a\n   nonrecurring MAC output that is not predictable\
    \ to an attacker.  If\n   the session stays active long enough, however, this\
    \ sequence number\n   will wrap.  This event may provide an attacker an opportunity\
    \ to\n   replay a previously recorded packet with an identical sequence number\n\
    \   but only if the peers have not rekeyed since the transmission of the\n   first\
    \ packet with that sequence number.  If the peers have rekeyed,\n   then the replay\
    \ will be detected since the MAC check will fail.  For\n   this reason, it must\
    \ be emphasized that peers MUST rekey before a\n   wrap of the sequence numbers.\
    \  Naturally, if an attacker does attempt\n   to replay a captured packet before\
    \ the peers have rekeyed, then the\n   receiver of the duplicate packet will not\
    \ be able to validate the MAC\n   and it will be discarded.  The reason that the\
    \ MAC will fail is\n   because the receiver will formulate a MAC based upon the\
    \ packet\n   contents, the shared secret, and the expected sequence number.  Since\n\
    \   the replayed packet will not be using that expected sequence number\n   (the\
    \ sequence number of the replayed packet will have already been\n   passed by\
    \ the receiver), the calculated MAC will not match the MAC\n   received with the\
    \ packet.\n"
- title: 9.3.4.  Man-in-the-middle
  contents:
  - "9.3.4.  Man-in-the-middle\n   This protocol makes no assumptions or provisions\
    \ for an\n   infrastructure or means for distributing the public keys of hosts.\n\
    \   It is expected that this protocol will sometimes be used without\n   first\
    \ verifying the association between the server host key and the\n   server host\
    \ name.  Such usage is vulnerable to man-in-the-middle\n   attacks.  This section\
    \ describes this and encourages administrators\n   and users to understand the\
    \ importance of verifying this association\n   before any session is initiated.\n\
    \   There are three cases of man-in-the-middle attacks to consider.  The\n   first\
    \ is where an attacker places a device between the client and the\n   server before\
    \ the session is initiated.  In this case, the attack\n   device is trying to\
    \ mimic the legitimate server and will offer its\n   public key to the client\
    \ when the client initiates a session.  If it\n   were to offer the public key\
    \ of the server, then it would not be able\n   to decrypt or sign the transmissions\
    \ between the legitimate server\n   and the client unless it also had access to\
    \ the private key of the\n   host.  The attack device will also, simultaneously\
    \ to this, initiate\n   a session to the legitimate server, masquerading itself\
    \ as the\n   client.  If the public key of the server had been securely\n   distributed\
    \ to the client prior to that session initiation, the key\n   offered to the client\
    \ by the attack device will not match the key\n   stored on the client.  In that\
    \ case, the user SHOULD be given a\n   warning that the offered host key does\
    \ not match the host key cached\n   on the client.  As described in Section 4.1,\
    \ the user may be free to\n   accept the new key and continue the session.  It\
    \ is RECOMMENDED that\n   the warning provide sufficient information to the user\
    \ of the client\n   device so the user may make an informed decision.  If the\
    \ user\n   chooses to continue the session with the stored public key of the\n\
    \   server (not the public key offered at the start of the session), then\n  \
    \ the session-specific data between the attacker and server will be\n   different\
    \ between the client-to-attacker session and the attacker-\n   to-server sessions\
    \ due to the randomness discussed above.  From this,\n   the attacker will not\
    \ be able to make this attack work since the\n   attacker will not be able to\
    \ correctly sign packets containing this\n   session-specific data from the server,\
    \ since he does not have the\n   private key of that server.\n   The second case\
    \ that should be considered is similar to the first\n   case in that it also happens\
    \ at the time of connection, but this case\n   points out the need for the secure\
    \ distribution of server public\n   keys.  If the server public keys are not securely\
    \ distributed, then\n   the client cannot know if it is talking to the intended\
    \ server.  An\n   attacker may use social engineering techniques to pass off server\n\
    \   keys to unsuspecting users and may then place a man-in-the-middle\n   attack\
    \ device between the legitimate server and the clients.  If this\n   is allowed\
    \ to happen, then the clients will form client-to-attacker\n   sessions, and the\
    \ attacker will form attacker-to-server sessions and\n   will be able to monitor\
    \ and manipulate all of the traffic between the\n   clients and the legitimate\
    \ servers.  Server administrators are\n   encouraged to make host key fingerprints\
    \ available for checking by\n   some means whose security does not rely on the\
    \ integrity of the\n   actual host keys.  Possible mechanisms are discussed in\
    \ Section 4.1\n   and may also include secured Web pages, physical pieces of paper,\n\
    \   etc.  Implementers SHOULD provide recommendations on how best to do\n   this\
    \ with their implementation.  Because the protocol is extensible,\n   future extensions\
    \ to the protocol may provide better mechanisms for\n   dealing with the need\
    \ to know the server's host key before\n   connecting.  For example, making the\
    \ host key fingerprint available\n   through a secure DNS lookup, or using Kerberos\
    \ ([RFC4120]) over\n   GSS-API ([RFC1964]) during key exchange to authenticate\
    \ the server\n   are possibilities.\n   In the third man-in-the-middle case, attackers\
    \ may attempt to\n   manipulate packets in transit between peers after the session\
    \ has\n   been established.  As described in Section 9.3.3, a successful attack\n\
    \   of this nature is very improbable.  As in Section 9.3.3, this\n   reasoning\
    \ does assume that the MAC is secure and that it is\n   infeasible to construct\
    \ inputs to a MAC algorithm to give a known\n   output.  This is discussed in\
    \ much greater detail in Section 6 of\n   [RFC2104].  If the MAC algorithm has\
    \ a vulnerability or is weak\n   enough, then the attacker may be able to specify\
    \ certain inputs to\n   yield a known MAC.  With that, they may be able to alter\
    \ the contents\n   of a packet in transit.  Alternatively, the attacker may be\
    \ able to\n   exploit the algorithm vulnerability or weakness to find the shared\n\
    \   secret by reviewing the MACs from captured packets.  In either of\n   those\
    \ cases, an attacker could construct a packet or packets that\n   could be inserted\
    \ into an SSH stream.  To prevent this, implementers\n   are encouraged to utilize\
    \ commonly accepted MAC algorithms, and\n   administrators are encouraged to watch\
    \ current literature and\n   discussions of cryptography to ensure that they are\
    \ not using a MAC\n   algorithm that has a recently found vulnerability or weakness.\n\
    \   In summary, the use of this protocol without a reliable association\n   of\
    \ the binding between a host and its host keys is inherently\n   insecure and\
    \ is NOT RECOMMENDED.  However, it may be necessary in\n   non-security-critical\
    \ environments, and will still provide protection\n   against passive attacks.\
    \  Implementers of protocols and applications\n   running on top of this protocol\
    \ should keep this possibility in mind.\n"
- title: 9.3.5.  Denial of Service
  contents:
  - "9.3.5.  Denial of Service\n   This protocol is designed to be used over a reliable\
    \ transport.  If\n   transmission errors or message manipulation occur, the connection\
    \ is\n   closed.  The connection SHOULD be re-established if this occurs.\n  \
    \ Denial of service attacks of this type (wire cutter) are almost\n   impossible\
    \ to avoid.\n   In addition, this protocol is vulnerable to denial of service\
    \ attacks\n   because an attacker can force the server to go through the CPU and\n\
    \   memory intensive tasks of connection setup and key exchange without\n   authenticating.\
    \  Implementers SHOULD provide features that make this\n   more difficult, for\
    \ example, only allowing connections from a subset\n   of clients known to have\
    \ valid users.\n"
- title: 9.3.6.  Covert Channels
  contents:
  - "9.3.6.  Covert Channels\n   The protocol was not designed to eliminate covert\
    \ channels.  For\n   example, the padding, SSH_MSG_IGNORE messages, and several\
    \ other\n   places in the protocol can be used to pass covert information, and\n\
    \   the recipient has no reliable way of verifying whether such\n   information\
    \ is being sent.\n"
- title: 9.3.7.  Forward Secrecy
  contents:
  - "9.3.7.  Forward Secrecy\n   It should be noted that the Diffie-Hellman key exchanges\
    \ may provide\n   perfect forward secrecy (PFS).  PFS is essentially defined as\
    \ the\n   cryptographic property of a key-establishment protocol in which the\n\
    \   compromise of a session key or long-term private key after a given\n   session\
    \ does not cause the compromise of any earlier session\n   [ANSI-T1.523-2001].\
    \  SSH sessions resulting from a key exchange using\n   the diffie-hellman methods\
    \ described in the section Diffie-Hellman\n   Key Exchange of [SSH-TRANS] (including\
    \ \"diffie-hellman-group1-sha1\"\n   and \"diffie-hellman-group14-sha1\") are\
    \ secure even if private\n   keying/authentication material is later revealed,\
    \ but not if the\n   session keys are revealed.  So, given this definition of\
    \ PFS, SSH\n   does have PFS.  However, this property is not commuted to any of\
    \ the\n   applications or protocols using SSH as a transport.  The transport\n\
    \   layer of SSH provides confidentiality for password authentication and\n  \
    \ other methods that rely on secret data.\n   Of course, if the DH private parameters\
    \ for the client and server are\n   revealed, then the session key is revealed,\
    \ but these items can be\n   thrown away after the key exchange completes.  It's\
    \ worth pointing\n   out that these items should not be allowed to end up on swap\
    \ space\n   and that they should be erased from memory as soon as the key\n  \
    \ exchange completes.\n"
- title: 9.3.8.  Ordering of Key Exchange Methods
  contents:
  - "9.3.8.  Ordering of Key Exchange Methods\n   As stated in the section on Algorithm\
    \ Negotiation of [SSH-TRANS],\n   each device will send a list of preferred methods\
    \ for key exchange.\n   The most-preferred method is the first in the list.  It\
    \ is\n   RECOMMENDED that the algorithms be sorted by cryptographic strength,\n\
    \   strongest first.  Some additional guidance for this is given in\n   [RFC3766].\n"
- title: 9.3.9.  Traffic Analysis
  contents:
  - "9.3.9.  Traffic Analysis\n   Passive monitoring of any protocol may give an attacker\
    \ some\n   information about the session, the user, or protocol specific\n   information\
    \ that they would otherwise not be able to garner.  For\n   example, it has been\
    \ shown that traffic analysis of an SSH session\n   can yield information about\
    \ the length of the password - [Openwall]\n   and [USENIX].  Implementers should\
    \ use the SSH_MSG_IGNORE packet,\n   along with the inclusion of random lengths\
    \ of padding, to thwart\n   attempts at traffic analysis.  Other methods may also\
    \ be found and\n   implemented.\n"
- title: 9.4.  Authentication Protocol
  contents:
  - "9.4.  Authentication Protocol\n   The purpose of this protocol is to perform\
    \ client user\n   authentication.  It assumes that this runs over a secure transport\n\
    \   layer protocol, which has already authenticated the server machine,\n   established\
    \ an encrypted communications channel, and computed a\n   unique session identifier\
    \ for this session.\n   Several authentication methods with different security\n\
    \   characteristics are allowed.  It is up to the server's local policy\n   to\
    \ decide which methods (or combinations of methods) it is willing to\n   accept\
    \ for each user.  Authentication is no stronger than the weakest\n   combination\
    \ allowed.\n   The server may go into a sleep period after repeated unsuccessful\n\
    \   authentication attempts to make key search more difficult for\n   attackers.\
    \  Care should be taken so that this doesn't become a self-\n   denial of service\
    \ vector.\n"
- title: 9.4.1.  Weak Transport
  contents:
  - "9.4.1.  Weak Transport\n   If the transport layer does not provide confidentiality,\n\
    \   authentication methods that rely on secret data SHOULD be disabled.\n   If\
    \ it does not provide strong integrity protection, requests to\n   change authentication\
    \ data (e.g., a password change) SHOULD be\n   disabled to prevent an attacker\
    \ from modifying the ciphertext without\n   being noticed, or rendering the new\
    \ authentication data unusable\n   (denial of service).\n   The assumption stated\
    \ above, that the Authentication Protocol only\n   runs over a secure transport\
    \ that has previously authenticated the\n   server, is very important to note.\
    \  People deploying SSH are reminded\n   of the consequences of man-in-the-middle\
    \ attacks if the client does\n   not have a very strong a priori association of\
    \ the server with the\n   host key of that server.  Specifically, for the case\
    \ of the\n   Authentication Protocol, the client may form a session to a man-in-\n\
    \   the-middle attack device and divulge user credentials such as their\n   username\
    \ and password.  Even in the cases of authentication where no\n   user credentials\
    \ are divulged, an attacker may still gain information\n   they shouldn't have\
    \ by capturing key-strokes in much the same way\n   that a honeypot works.\n"
- title: 9.4.2.  Debug Messages
  contents:
  - "9.4.2.  Debug Messages\n   Special care should be taken when designing debug\
    \ messages.  These\n   messages may reveal surprising amounts of information about\
    \ the host\n   if not properly designed.  Debug messages can be disabled (during\n\
    \   user authentication phase) if high security is required.\n   Administrators\
    \ of host machines should make all attempts to\n   compartmentalize all event\
    \ notification messages and protect them\n   from unwarranted observation.  Developers\
    \ should be aware of the\n   sensitive nature of some of the normal event and\
    \ debug messages, and\n   may want to provide guidance to administrators on ways\
    \ to keep this\n   information away from unauthorized people.  Developers should\n\
    \   consider minimizing the amount of sensitive information obtainable by\n  \
    \ users during the authentication phase, in accordance with the local\n   policies.\
    \  For this reason, it is RECOMMENDED that debug messages be\n   initially disabled\
    \ at the time of deployment and require an active\n   decision by an administrator\
    \ to allow them to be enabled.  It is also\n   RECOMMENDED that a message expressing\
    \ this concern be presented to\n   the administrator of a system when the action\
    \ is taken to enable\n   debugging messages.\n"
- title: 9.4.3.  Local Security Policy
  contents:
  - "9.4.3.  Local Security Policy\n   The implementer MUST ensure that the credentials\
    \ provided validate\n   the professed user and also MUST ensure that the local\
    \ policy of the\n   server permits the user the access requested.  In particular,\
    \ because\n   of the flexible nature of the SSH connection protocol, it may not\
    \ be\n   possible to determine the local security policy, if any, that should\n\
    \   apply at the time of authentication because the kind of service being\n  \
    \ requested is not clear at that instant.  For example, local policy\n   might\
    \ allow a user to access files on the server, but not start an\n   interactive\
    \ shell.  However, during the authentication protocol, it\n   is not known whether\
    \ the user will be accessing files, attempting to\n   use an interactive shell,\
    \ or even both.  In any event, where local\n   security policy for the server\
    \ host exists, it MUST be applied and\n   enforced correctly.\n   Implementers\
    \ are encouraged to provide a default local policy and\n   make its parameters\
    \ known to administrators and users.  At the\n   discretion of the implementers,\
    \ this default policy may be along the\n   lines of anything-goes where there\
    \ are no restrictions placed upon\n   users, or it may be along the lines of excessively-restrictive,\
    \ in\n   which case, the administrators will have to actively make changes to\n\
    \   the initial default parameters to meet their needs.  Alternatively,\n   it\
    \ may be some attempt at providing something practical and\n   immediately useful\
    \ to the administrators of the system so they don't\n   have to put in much effort\
    \ to get SSH working.  Whatever choice is\n   made must be applied and enforced\
    \ as required above.\n"
- title: 9.4.4  Public Key Authentication
  contents:
  - "9.4.4  Public Key Authentication\n   The use of public key authentication assumes\
    \ that the client host has\n   not been compromised.  It also assumes that the\
    \ private key of the\n   server host has not been compromised.\n   This risk can\
    \ be mitigated by the use of passphrases on private keys;\n   however, this is\
    \ not an enforceable policy.  The use of smartcards,\n   or other technology to\
    \ make passphrases an enforceable policy is\n   suggested.\n   The server could\
    \ require both password and public key authentication;\n   however, this requires\
    \ the client to expose its password to the\n   server (see the section on Password\
    \ Authentication below.)\n"
- title: 9.4.5.  Password Authentication
  contents:
  - "9.4.5.  Password Authentication\n   The password mechanism, as specified in the\
    \ authentication protocol,\n   assumes that the server has not been compromised.\
    \  If the server has\n   been compromised, using password authentication will\
    \ reveal a valid\n   username/password combination to the attacker, which may\
    \ lead to\n   further compromises.\n   This vulnerability can be mitigated by\
    \ using an alternative form of\n   authentication.  For example, public key authentication\
    \ makes no\n   assumptions about security on the server.\n"
- title: 9.4.6.  Host-Based Authentication
  contents:
  - "9.4.6.  Host-Based Authentication\n   Host-based authentication assumes that\
    \ the client has not been\n   compromised.  There are no mitigating strategies,\
    \ other than to use\n   host-based authentication in combination with another\
    \ authentication\n   method.\n"
- title: 9.5.  Connection Protocol
  contents:
  - '9.5.  Connection Protocol

    '
- title: 9.5.1.  End Point Security
  contents:
  - "9.5.1.  End Point Security\n   End point security is assumed by the connection\
    \ protocol.  If the\n   server has been compromised, any terminal sessions, port\
    \ forwarding,\n   or systems accessed on the host are compromised.  There are\
    \ no\n   mitigating factors for this.\n   If the client has been compromised,\
    \ and the server fails to stop the\n   attacker at the authentication protocol,\
    \ all services exposed (either\n   as subsystems or through forwarding) will be\
    \ vulnerable to attack.\n   Implementers SHOULD provide mechanisms for administrators\
    \ to control\n   which services are exposed to limit the vulnerability of other\n\
    \   services.  These controls might include controlling which machines\n   and\
    \ ports can be targeted in port-forwarding operations, which users\n   are allowed\
    \ to use interactive shell facilities, or which users are\n   allowed to use exposed\
    \ subsystems.\n"
- title: 9.5.2.  Proxy Forwarding
  contents:
  - "9.5.2.  Proxy Forwarding\n   The SSH connection protocol allows for proxy forwarding\
    \ of other\n   protocols such as SMTP, POP3, and HTTP.  This may be a concern\
    \ for\n   network administrators who wish to control the access of certain\n \
    \  applications by users located outside of their physical location.\n   Essentially,\
    \ the forwarding of these protocols may violate site-\n   specific security policies,\
    \ as they may be undetectably tunneled\n   through a firewall.  Implementers SHOULD\
    \ provide an administrative\n   mechanism to control the proxy forwarding functionality\
    \ so that\n   site-specific security policies may be upheld.\n   In addition,\
    \ a reverse proxy forwarding functionality is available,\n   which, again, can\
    \ be used to bypass firewall controls.\n   As indicated above, end-point security\
    \ is assumed during proxy\n   forwarding operations.  Failure of end-point security\
    \ will compromise\n   all data passed over proxy forwarding.\n"
- title: 9.5.3.  X11 Forwarding
  contents:
  - "9.5.3.  X11 Forwarding\n   Another form of proxy forwarding provided by the SSH\
    \ connection\n   protocol is the forwarding of the X11 protocol.  If end-point\n\
    \   security has been compromised, X11 forwarding may allow attacks\n   against\
    \ the X11 server.  Users and administrators should, as a matter\n   of course,\
    \ use appropriate X11 security mechanisms to prevent\n   unauthorized use of the\
    \ X11 server.  Implementers, administrators,\n   and users who wish to further\
    \ explore the security mechanisms of X11\n   are invited to read [SCHEIFLER] and\
    \ analyze previously reported\n   problems with the interactions between SSH forwarding\
    \ and X11 in CERT\n   vulnerabilities VU#363181 and VU#118892 [CERT].\n   X11\
    \ display forwarding with SSH, by itself, is not sufficient to\n   correct well\
    \ known problems with X11 security [VENEMA].  However, X11\n   display forwarding\
    \ in SSH (or other secure protocols), combined with\n   actual and pseudo-displays\
    \ that accept connections only over local\n   IPC mechanisms authorized by permissions\
    \ or access control lists\n   (ACLs), does correct many X11 security problems,\
    \ as long as the\n   \"none\" MAC is not used.  It is RECOMMENDED that X11 display\n\
    \   implementations default to allow the display to open only over local\n   IPC.\
    \  It is RECOMMENDED that SSH server implementations that support\n   X11 forwarding\
    \ default to allow the display to open only over local\n   IPC.  On single-user\
    \ systems, it might be reasonable to default to\n   allow the local display to\
    \ open over TCP/IP.\n   Implementers of the X11 forwarding protocol SHOULD implement\
    \ the\n   magic cookie access-checking spoofing mechanism, as described in\n \
    \  [SSH-CONNECT], as an additional mechanism to prevent unauthorized use\n   of\
    \ the proxy.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [SSH-TRANS]        Ylonen, T. and C. Lonvick,\
    \ Ed., \"The Secure Shell\n                      (SSH) Transport Layer Protocol\"\
    , RFC 4253, January\n                      2006.\n   [SSH-USERAUTH]     Ylonen,\
    \ T. and C. Lonvick, Ed., \"The Secure Shell\n                      (SSH) Authentication\
    \ Protocol\", RFC 4252, January\n                      2006.\n   [SSH-CONNECT]\
    \      Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell\n                  \
    \    (SSH) Connection Protocol\", RFC 4254, January\n                      2006.\n\
    \   [SSH-NUMBERS]      Lehtinen, S. and C. Lonvick, Ed., \"The Secure\n      \
    \                Shell (SSH) Protocol Assigned Numbers\", RFC 4250,\n        \
    \              January 2006.\n   [RFC2119]          Bradner, S., \"Key words for\
    \ use in RFCs to\n                      Indicate Requirement Levels\", BCP 14,\
    \ RFC 2119,\n                      March 1997.\n   [RFC2434]          Narten,\
    \ T. and H. Alvestrand, \"Guidelines for\n                      Writing an IANA\
    \ Considerations Section in RFCs\",\n                      BCP 26, RFC 2434, October\
    \ 1998.\n   [RFC3066]          Alvestrand, H., \"Tags for the Identification of\n\
    \                      Languages\", BCP 47, RFC 3066, January 2001.\n   [RFC3629]\
    \          Yergeau, F., \"UTF-8, a transformation format of\n                \
    \      ISO 10646\", STD 63, RFC 3629, November 2003.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [RFC0822]          Crocker, D., \"Standard\
    \ for the format of ARPA\n                      Internet text messages\", STD\
    \ 11, RFC 822, August\n                      1982.\n   [RFC0854]          Postel,\
    \ J. and J. Reynolds, \"Telnet Protocol\n                      Specification\"\
    , STD 8, RFC 854, May 1983.\n   [RFC1034]          Mockapetris, P., \"Domain names\
    \ - concepts and\n                      facilities\", STD 13, RFC 1034, November\
    \ 1987.\n   [RFC1282]          Kantor, B., \"BSD Rlogin\", RFC 1282, December\
    \ 1991.\n   [RFC4120]          Neuman, C., Yu, T., Hartman, S., and K. Raeburn,\n\
    \                      \"The Kerberos Network Authentication Service\n       \
    \               (V5)\", RFC 4120, July 2005.\n   [RFC1964]          Linn, J.,\
    \ \"The Kerberos Version 5 GSS-API\n                      Mechanism\", RFC 1964,\
    \ June 1996.\n   [RFC2025]          Adams, C., \"The Simple Public-Key GSS-API\n\
    \                      Mechanism (SPKM)\", RFC 2025, October 1996.\n   [RFC2085]\
    \          Oehler, M. and R. Glenn, \"HMAC-MD5 IP\n                      Authentication\
    \ with Replay Prevention\", RFC 2085,\n                      February 1997.\n\
    \   [RFC2104]          Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC:\n  \
    \                    Keyed-Hashing for Message Authentication\", RFC\n       \
    \               2104, February 1997.\n   [RFC2246]          Dierks, T. and C.\
    \ Allen, \"The TLS Protocol Version\n                      1.0\", RFC 2246, January\
    \ 1999.\n   [RFC2410]          Glenn, R. and S. Kent, \"The NULL Encryption\n\
    \                      Algorithm and Its Use With IPsec\", RFC 2410,\n       \
    \               November 1998.\n   [RFC2743]          Linn, J., \"Generic Security\
    \ Service Application\n                      Program Interface Version 2, Update\
    \ 1\", RFC 2743,\n                      January 2000.\n   [RFC3766]          Orman,\
    \ H. and P. Hoffman, \"Determining Strengths\n                      For Public\
    \ Keys Used For Exchanging Symmetric\n                      Keys\", BCP 86, RFC\
    \ 3766, April 2004.\n   [RFC4086]          Eastlake, D., 3rd, Schiller, J., and\
    \ S. Crocker,\n                      \"Randomness Requirements for Security\"\
    , BCP 106,\n                      RFC 4086, June 2005.\n   [FIPS-180-2]      \
    \ US National Institute of Standards and Technology,\n                      \"\
    Secure Hash Standard (SHS)\", Federal Information\n                      Processing\
    \ Standards Publication 180-2, August\n                      2002.\n   [FIPS-186-2]\
    \       US National Institute of Standards and Technology,\n                 \
    \     \"Digital Signature Standard (DSS)\", Federal\n                      Information\
    \ Processing Standards Publication 186-\n                      2, January 2000.\n\
    \   [FIPS-197]         US National Institute of Standards and Technology,\n  \
    \                    \"Advanced Encryption Standard (AES)\", Federal\n       \
    \               Information Processing Standards Publication 197,\n          \
    \            November 2001.\n   [ANSI-T1.523-2001] American National Standards\
    \ Institute, Inc.,\n                      \"Telecom Glossary 2000\", ANSI T1.523-2001,\n\
    \                      February 2001.\n   [SCHNEIER]         Schneier, B., \"\
    Applied Cryptography Second\n                      Edition:  protocols algorithms\
    \ and source in code\n                      in C\", John Wiley and Sons, New York,\
    \ NY, 1996.\n   [SCHEIFLER]        Scheifler, R., \"X Window System : The Complete\n\
    \                      Reference to Xlib, X Protocol, Icccm, Xlfd, 3rd\n     \
    \                 edition.\", Digital Press, ISBN 1555580882,\n              \
    \        February 1992.\n   [KAUFMAN]          Kaufman, C., Perlman, R., and M.\
    \ Speciner,\n                      \"Network Security: PRIVATE Communication in\
    \ a\n                      PUBLIC World\", Prentice Hall Publisher, 1995.\n  \
    \ [CERT]             CERT Coordination Center, The.,\n                      \"\
    http://www.cert.org/nav/index_red.html\".\n   [VENEMA]           Venema, W., \"\
    Murphy's Law and Computer Security\",\n                      Proceedings of 6th\
    \ USENIX Security Symposium, San\n                      Jose CA\n            \
    \          http://www.usenix.org/publications/library/\n                     \
    \ proceedings/sec96/venema.html, July 1996.\n   [ROGAWAY]          Rogaway, P.,\
    \ \"Problems with Proposed IP\n                      Cryptography\", Unpublished\
    \ paper\n                      http://www.cs.ucdavis.edu/~rogaway/ papers/draft-\n\
    \                      rogaway-ipsec-comments-00.txt, 1996.\n   [DAI]        \
    \      Dai, W., \"An attack against SSH2 protocol\", Email\n                 \
    \     to the SECSH Working Group ietf-ssh@netbsd.org\n                      ftp://\
    \ ftp.ietf.org/ietf-mail-archive/secsh/2002-\n                      02.mail, Feb\
    \ 2002.\n   [BELLARE]          Bellaire, M., Kohno, T., and C. Namprempre,\n \
    \                     \"Authenticated Encryption in SSH: Fixing the SSH\n    \
    \                  Binary Packet Protocol\", Proceedings of the 9th\n        \
    \              ACM Conference on Computer and Communications\n               \
    \       Security, Sept 2002.\n   [Openwall]         Solar Designer and D. Song,\
    \ \"SSH Traffic Analysis\n                      Attacks\", Presentation given\
    \ at HAL2001 and\n                      NordU2002 Conferences, Sept 2001.\n  \
    \ [USENIX]           Song, X.D., Wagner, D., and X. Tian, \"Timing\n         \
    \             Analysis of Keystrokes and SSH Timing Attacks\",\n             \
    \         Paper given at 10th USENIX Security Symposium,\n                   \
    \   2001.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Tatu Ylonen\n   SSH Communications Security Corp\n   Valimotie\
    \ 17\n   00380 Helsinki\n   Finland\n   EMail: ylo@ssh.com\n   Chris Lonvick (editor)\n\
    \   Cisco Systems, Inc.\n   12515 Research Blvd.\n   Austin  78759\n   USA\n \
    \  EMail: clonvick@cisco.com\n"
- title: Trademark Notice
  contents:
  - "Trademark Notice\n   \"ssh\" is a registered trademark in the United States and/or\
    \ other\n   countries.\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
