- contents:
  - '                    SBM (Subnet Bandwidth Manager):

    '
  title: __initial_text__
- contents:
  - 'A Protocol for RSVP-based Admission Control over IEEE 802-style networks

    '
  title: A Protocol for RSVP-based Admission Control over IEEE 802-style networks
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes a signaling method and protocol for RSVP-\n
    \  based admission control over IEEE 802-style LANs.  The protocol is\n   designed
    to work both with the current generation of IEEE 802 LANs as\n   well as with
    the recent work completed by the IEEE 802.1 committee.\n"
  title: Abstract
- contents:
  - "1. Introduction\n   New extensions to the Internet architecture and service models
    have\n   been defined for an integrated services Internet [RFC-1633, RFC-2205,\n
    \  RFC-2210] so that applications can request specific qualities or\n   levels
    of service from an internetwork in addition to the current IP\n   best-effort
    service.  These extensions include RSVP, a resource\n   reservation setup protocol,
    and definition of new service classes to\n   be supported by Integrated Services
    routers.  RSVP and service class\n   definitions are largely independent of the
    underlying networking\n   technologies and it is necessary to define the mapping
    of RSVP and\n   Integrated Services specifications onto specific subnetwork\n
    \  technologies.  For example, a definition of service mappings and\n   reservation
    setup protocols is needed for specific link-layer\n   technologies such as shared
    and switched IEEE-802-style LAN\n   technologies.\n   This document defines SBM,
    a signaling protocol for RSVP-based\n   admission control over IEEE 802-style
    networks.  SBM provides a\n   method for mapping an internet-level setup protocol
    such as RSVP onto\n   IEEE 802 style networks.  In particular, it describes the
    operation\n   of RSVP-enabled hosts/routers and link layer devices (switches,\n
    \  bridges) to support reservation of LAN resources for RSVP-enabled\n   data
    flows.  A framework for providing Integrated Services over\n   shared and switched
    IEEE-802-style LAN technologies and a definition\n   of service mappings have
    been described in separate documents [RFC-\n   FRAME, RFC-MAP].\n"
  title: 1. Introduction
- contents:
  - "2. Goals and Assumptions\n   The SBM (Subnet Bandwidth Manager) protocol and
    its use for admission\n   control and bandwidth management in IEEE 802 level-2
    networks is\n   based on the following architectural goals and assumptions:\n
    \     I. Even though the current trend is towards increased use of\n      switched
    LAN topologies consisting of newer switches that support\n      the priority queuing
    mechanisms specified by IEEE 802.1p, we\n      assume that the LAN technologies
    will continue to be a mix of\n      legacy shared/ switched LAN segments and newer
    switched segments\n      based on IEEE 802.1p specification.  Therefore, we specify
    a\n      signaling protocol for managing bandwidth over both legacy and\n      newer
    LAN topologies and that takes advantage of the additional\n      functionality
    (such as an explicit support for different traffic\n      classes or integrated
    service classes) as it becomes available in\n      the new generation of switches,
    hubs, or bridges.  As a result,\n      the SBM protocol would allow for a range
    of LAN bandwidth\n      management solutions that vary from one that exercises
    purely\n      administrative control (over the amount of bandwidth consumed by\n
    \     RSVP-enabled traffic flows) to one that requires cooperation (and\n      enforcement)
    from all the end-systems or switches in a IEEE 802\n      LAN.\n      II. This
    document specifies only a signaling method and protocol\n      for LAN-based admission
    control over RSVP flows.  We do not define\n      here any traffic control mechanisms
    for the link layer; the\n      protocol is designed to use any such mechanisms
    defined by IEEE\n      802.  In addition, we assume that the Layer 3 end-systems
    (e.g., a\n      host or a router) will exercise traffic control by policing\n
    \     Integrated Services traffic flows to ensure that each flow stays\n      within
    its traffic specifications stipulated in an earlier\n      reservation request
    submitted for admission control.  This then\n      allows a system using SBM admission
    control combined with per flow\n      shaping at end systems and IEEE-defined
    traffic control at link\n      layer to realize some approximation of Controlled
    Load (and even\n      Guaranteed) services over IEEE 802-style LANs.\n      III.
    In the absence of any link-layer traffic control or priority\n      queuing mechanisms
    in the underlying LAN (such as a shared LAN\n      segment), the SBM-based admission
    control mechanism only limits\n      the total amount of traffic load imposed
    by RSVP-enabled flows on\n      a shared LAN. In such an environment, no traffic
    flow separation\n      mechanism exists to protect the RSVP-enabled flows from
    the best-\n      effort traffic on the same shared media and that raises the\n
    \     question of the utility of such a mechanism outside a topology\n      consisting
    only of 802.1p-compliant switches.  However, we assume\n      that the SBM-based
    admission control mechanism will still serve a\n      useful purpose in a legacy,
    shared LAN topology for two reasons.\n      First, assuming that all the nodes
    that generate Integrated\n      Services traffic flows utilize the SBM-based admission
    control\n      procedure to request reservation of resources before sending any\n
    \     traffic, the mechanism will restrict the total amount of traffic\n      generated
    by Integrated Services flows within the bounds desired\n      by a LAN administrator
    (see discussion of the NonResvSendLimit\n      parameter in Appendix C).  Second,
    the best-effort traffic\n      generated by the TCP/IP-based traffic sources is
    generally rate\n      adaptive (using a TCP-style \"slow start\" congestion avoidance\n
    \     mechanism or a feedback-based rate adaptation mechanism used by\n      audio/video
    streams based on RTP/RTCP protocols) and adapts to\n      stay within the available
    network bandwidth.  Thus, the\n      combination of admission control and rate
    adaptation should avoid\n      persistent traffic congestion.  This does not,
    however, guarantee\n      that non-Integrated-Services traffic will not interfere
    with the\n      Integrated Services traffic in the absence of traffic control\n
    \     support in the underlying LAN infrastructure.\n"
  title: 2. Goals and Assumptions
- contents:
  - "3. Organization of the rest of this document\n   The rest of this document provides
    a detailed description of the\n   SBM-based admission control procedure(s) for
    IEEE 802 LAN\n   technologies. The document is organized as follows:\n   *  Section
    4 first defines the various terms used in the document and\n      then provides
    an overview of the admission control procedure with\n      an example of its application
    to a sample network.\n   *  Section 5 describes the rules for processing and forwarding
    PATH\n      (and PATH_TEAR) messages at DSBMs (Designated Subnet Bandwidth\n      Managers),
    SBMs, and DSBM clients.\n   *  Section 6 addresses the inter-operability issues
    when a DSBM may\n      operate in the absence of RSVP signaling at Layer 3 or
    when\n      another signaling protocol (such as SNMP) is used to reserve\n      resources
    on a LAN segment.\n   *  Appendix A describes the details of the DSBM election
    algorithm\n      used for electing a designated SBM on a LAN segment when more
    than\n      one SBM is present.  It also describes how DSBM clients discover\n
    \     the presence of a DSBM on a managed segment.\n   *  Appendix B specifies
    the formats of SBM-specific messages used and\n      the formats of new RSVP objects
    needed for the SBM operation.\n   *  Appendix C describes usage of the DSBM to
    distribute configuration\n      information to senders on a managed segment.\n"
  title: 3. Organization of the rest of this document
- contents:
  - '4. Overview

    '
  title: 4. Overview
- contents:
  - "4.1. Definitions\n   -  Link Layer or Layer 2 or L2: We refer to data-link layer\n
    \     technologies such as IEEE 802.3/Ethernet as L2 or layer 2.\n   -  Link Layer
    Domain or Layer 2 domain or L2 domain: a set of nodes\n      and links interconnected
    without passing through a L3 forwarding\n      function. One or more IP subnets
    can be overlaid on a L2 domain.\n   -  Layer 2 or L2 devices: We refer to devices
    that only implement\n      Layer 2 functionality as Layer 2 or L2 devices. These
    include\n      802.1D bridges or switches.\n   -  Internetwork Layer or Layer
    3 or L3: Layer 3 of the ISO 7 layer\n      model. This document is primarily concerned
    with networks that use\n      the Internet Protocol (IP) at this layer.\n   -
    \ Layer 3 Device or L3 Device or End-Station: these include hosts\n      and routers
    that use L3 and higher layer protocols or application\n      programs that need
    to make resource reservations.\n   -  Segment: A L2 physical segment that is shared
    by one or more\n      senders. Examples of segments include (a) a shared Ethernet
    or\n      Token-Ring wire resolving contention for media access using CSMA\n      or
    token passing (\"shared L2 segment\"), (b) a half duplex link\n      between two
    stations or switches, (c) one direction of a switched\n      full-duplex link.\n
    \  -  Managed segment: A managed segment is a segment with a DSBM\n      present
    and responsible for exercising admission control over\n      requests for resource
    reservation. A managed segment includes\n      those interconnected parts of a
    shared LAN that are not separated\n      by DSBMs.\n   -  Traffic Class: An aggregation
    of data flows which are given\n      similar service within a switched network.\n
    \  -  User_priority: User_priority is a value associated with the\n      transmission
    and reception of all frames in the IEEE 802 service\n      model: it is supplied
    by the sender that is using the MAC service.\n      It is provided along with
    the data to a receiver using the MAC\n      service. It may or may not be actually
    carried over the network:\n      Token-Ring/802.5 carries this value (encoded
    in its FC octet),\n      basic Ethernet/802.3 does not, 802.12 may or may not
    depending on\n      the frame format in use. 802.1p defines a consistent way to
    carry\n      this value over the bridged network on Ethernet, Token Ring,\n      Demand-Priority,
    FDDI or other MAC-layer media using an extended\n      frame format. The usage
    of user_priority is fully described in\n      section 2.5 of 802.1D [IEEE8021D]
    and 802.1p [IEEE8021P] \"Support\n      of the Internal Layer Service by Specific
    MAC Procedures\".\n   -  Subnet: used in this memo to indicate a group of L3 devices\n
    \     sharing a common L3 network address prefix along with the set of\n      segments
    making up the L2 domain in which they are located.\n   -  Bridge/Switch: a layer
    2 forwarding device as defined by IEEE\n      802.1D. The terms bridge and switch
    are used synonymously in this\n      document.\n   -  DSBM: Designated SBM (DSBM)
    is a protocol entity that resides in a\n      L2 or L3 device and manages resources
    on a L2 segment. At most one\n      DSBM exists for each L2 segment.\n   -  SBM:
    the SBM is a protocol entity that resides in a L2 or L3\n      device and is capable
    of managing resources on a segment. However,\n      only a DSBM manages the resources
    for a managed segment. When more\n      than one SBM exists on a segment, one
    of the SBMs is elected to be\n      the DSBM.\n   -  Extended segment: An extended
    segment includes those parts of a\n      network which are members of the same
    IP subnet and therefore are\n      not separated by any layer 3 devices. Several
    managed segments,\n      interconnected by layer 2 devices, constitute an extended
    segment.\n   -  Managed L2 domain: An L2 domain consisting of managed segments
    is\n      referred to as a managed L2 domain to distinguish it from a L2\n      domain
    with no DSBMs present for exercising admission control over\n      resources at
    segments in the L2 domain.\n   -  DSBM clients: These are entities that transmit
    traffic onto a\n      managed segment and use the services of a DSBM for the managed\n
    \     segment for admission control over a LAN segment. Only the layer 3\n      or
    higher layer entities on L3 devices such as hosts and routers\n      are expected
    to send traffic that requires resource reservations,\n      and, therefore, DSBM
    clients are L3 entities.\n   -  SBM transparent devices: A \"SBM transparent\"
    device is unaware of\n      SBMs or DSBMs (though it may or may not be RSVP aware)
    and,\n      therefore, does not participate in the SBM-based admission control\n
    \     procedure over a managed segment. Such a device uses standard\n      forwarding
    rules appropriate for the device and is transparent\n      with respect to SBM.
    \ An example of such a L2 device is a legacy\n      switch that does not participate
    in resource reservation.\n   -  Layer 3 and layer 2 addresses: We refer to layer
    3 addresses of\n      L3/L2 devices as \"L3 addresses\" and layer 2 addresses
    as \"L2\n      addresses\". This convention will be used in the rest of the\n
    \     document to distinguish between Layer 3 and layer 2 addresses used\n      to
    refer to RSVP next hop (NHOP) and previous hop (PHOP) devices.\n      For example,
    in conventional RSVP message processing, RSVP_HOP\n      object in a PATH message
    carries the L3 address of the previous\n      hop device. We will refer to the
    address contained in the RSVP_HOP\n      object as the RSVP_HOP_L3 address and
    the corresponding MAC\n      address of the previous hop device will be referred
    to as the\n      RSVP_HOP_L2 address.\n"
  title: 4.1. Definitions
- contents:
  - "4.2. Overview of the SBM-based Admission Control Procedure\n   A protocol entity
    called \"Designated SBM\" (DSBM) exists for each\n   managed segment and is responsible
    for admission control over the\n   resource reservation requests originating from
    the DSBM clients in\n   that segment.  Given a segment, one or more SBMs may exist
    on the\n   segment.  For example, many SBM-capable devices may be attached to
    a\n   shared L2 segment whereas two SBM-capable switches may share a half-\n   duplex
    switched segment. In that case, a single DSBM is elected for\n   the segment.
    The procedure for dynamically electing the DSBM is\n   described in Appendix A.
    The only other approved method for\n   specifying a DSBM for a managed segment
    is static configuration at\n   SBM-capable devices.\n   The presence of a DSBM
    makes the segment a \"managed segment\".\n   Sometimes, two or more L2 segments
    may be interconnected by SBM\n   transparent devices. In that case, a single DSBM
    will manage the\n   resources for those segments treating the collection of such
    segments\n   as a single managed segment for the purpose of admission control.\n"
  title: 4.2. Overview of the SBM-based Admission Control Procedure
- contents:
  - "4.2.1. Basic Algorithm\n   Figure 1 - An Example of a Managed Segment.\n       +-------+
    \     +-----+     +------+    +-----+   +--------+\n       |Router |      | Host|
    \    | DSBM |    | Host|   | Router |\n       | R2    |      | C   |     +------+
    \   |  B  |   |  R3    |\n       +-------+      +-----+     /           +-----+
    \  +--------+\n          |             |        /               |          |\n
    \         |             |       /                |          |\n   ==============================================================LAN\n
    \                   |                                   |\n                    |
    \                                  |\n                  +------+                          +-------+\n
    \                 | Host |                          | Router|\n                  |
    \ A   |                          |   R1  |\n                  +------+                          +-------+\n
    \  Figure 1 shows an example of a managed segment in a L2 domain that\n   interconnects
    a set of hosts and routers. For the purpose of this\n   discussion, we ignore
    the actual physical topology of the L2 domain\n   (assume it is a shared L2 segment
    and a single managed segment\n   represents the entire L2 domain). A single SBM
    device is designated\n   to be the DSBM for the managed segment. We will provide
    examples of\n   operation of the DSBM over switched and shared segments later
    in the\n   document.\n   The basic DSBM-based admission control procedure works
    as follows:\n   1.  DSBM Initialization:  As part of its initial configuration,
    DSBM\n       obtains information such as the limits on fraction of available\n
    \      resources that can be reserved on each managed segment under its\n       control.
    For instance, bandwidth is one such resource. Even\n       though methods such
    as auto-negotiation of link speeds and\n       knowledge of link topology allow
    discovery of link capacity, the\n       configuration may be necessary to limit
    the fraction of link\n       capacity that can be reserved on a link.  Configuration
    is likely\n       to be static with the current L2/L3 devices. Future work may\n
    \      allow for dynamic discovery of this information. This document\n       does
    not specify the configuration mechanism.\n   2.  DSBM Client Initialization:  For
    each interface attached, a DSBM\n       client determines whether a DSBM exists
    on the interface. The\n       procedure for discovering and verifying the existence
    of the DSBM\n       for an attached segment is described in Appendix A. If the
    client\n       itself is capable of serving as the DSBM on the segment, it may\n
    \      choose to participate in the election to become the DSBM. At the\n       start,
    a DSBM client first verifies that a DSBM exists in its L2\n       domain so that
    it can communicate with the DSBM for admission\n       control purposes.\n       In
    the case of a full-duplex segment, an election may not be\n       necessary as
    the SBM at each end will typically act as the DSBM\n       for outgoing traffic
    in each direction.\n   3.  DSBM-based Admission Control: To request reservation
    of resources\n       (e.g., LAN bandwidth in a L2 domain), DSBM clients (RSVP-capable\n
    \      L3 devices such as hosts and routers) follow the following steps:\n      a)
    When a DSBM client sends or forwards a RSVP PATH message over\n         an interface
    attached to a managed segment, it sends the PATH\n         message to the segment's
    DSBM instead of sending it to the RSVP\n         session destination address (as
    is done in conventional RSVP\n         processing). After processing (and possibly
    updating an\n         ADSPEC), the DSBM will forward the PATH message toward its\n
    \        destination address. As part of its processing, the DSBM builds\n         and
    maintains a PATH state for the session and notes the\n         previous L2/L3
    hop that sent it the PATH message.\n         Let us consider the managed segment
    in Figure 1. Assume that a\n         sender to a RSVP session (session address
    specifies the IP\n         address of host A on the managed segment in Figure
    1) resides\n         outside the L2 domain of the managed segment and sends a
    PATH\n         message that arrives at router R1 which is on the path towards\n
    \        host A.\n         DSBM client on Router R1 forwards the PATH message
    from the\n         sender to the DSBM. The DSBM processes the PATH message and\n
    \        forwards the PATH message towards the RSVP receiver (Detailed\n         message
    processing and forwarding rules are described in\n         Section 5).  In the
    process, the DSBM builds the PATH state,\n         remembers the router R1 (its
    L2 and l3 addresses) as the\n         previous hop for the session, puts its own
    L2 and L3 addresses\n         in the PHOP objects (see explanation later), and
    effectively\n         inserts itself as an intermediate node between the sender
    (or\n         R1 in Figure 1) and the receiver (host A) on the managed\n         segment.\n
    \     b) When an application on host A wishes to make a reservation for\n         the
    RSVP session, host A follows the standard RSVP message\n         processing rules
    and sends a RSVP RESV message to the previous\n         hop L2/L3 address (the
    DSBMs address) obtained from the PHOP\n         object(s) in the previously received
    PATH message.\n      c) The DSBM processes the RSVP RESV message based on the
    bandwidth\n         available and returns an RESV_ERR message to the requester\n
    \        (host A) if the request cannot be granted. If sufficient\n         resources
    are available and the reservation request is granted,\n         the DSBM forwards
    the RESV message towards the PHOP(s) based on\n         its local PATH state for
    the session. The DSBM merges\n         reservation requests for the same session
    as and when possible\n         using the rules similar to those used in the conventional
    RSVP\n         processing (except for an additional criterion described in\n         Section
    5.8).\n      d) If the L2 domain contains more than one managed segment, the\n
    \        requester (host A) and the forwarder (router R1) may be\n         separated
    by more than one managed segment. In that case, the\n         original PATH message
    would propagate through many DSBMs (one\n         for each managed segment on
    the path from R1 to A) setting up\n         PATH state at each DSBM. Therefore,
    the RESV message would\n         propagate hop-by-hop in reverse through the intermediate
    DSBMs\n         and eventually reach the original forwarder (router R1) on the\n
    \        L2 domain if admission control at all DSBMs succeeds.\n"
  title: 4.2.1. Basic Algorithm
- contents:
  - "4.2.2. Enhancements to the conventional RSVP operation\n   (D)SBMs and DSBM clients
    implement minor additions to the standard\n   RSVP protocol. These are summarized
    in this section. A detailed\n   description of the message processing and forwarding
    rules follows in\n   section 5.\n"
  title: 4.2.2. Enhancements to the conventional RSVP operation
- contents:
  - "4.2.2.1 Sending PATH Messages to the DSBM on a Managed Segment\n   Normal RSVP
    forwarding rules apply at a DSBM client when it is not\n   forwarding an outgoing
    PATH message over a managed segment. However,\n   outgoing PATH messages on a
    managed segment are sent to the DSBM for\n   the corresponding managed segment
    (Section 5.2 describes how the PATH\n   messages are sent to the DSBM on a managed
    segment).\n"
  title: 4.2.2.1 Sending PATH Messages to the DSBM on a Managed Segment
- contents:
  - "4.2.2.2 The LAN_NHOP Objects\n   In conventional RSVP processing over point-to-point
    links, RSVP nodes\n   (hosts/routers) use RSVP_HOP object (NHOP and PHOP info)
    to keep\n   track of the next hop (downstream node in the path of data packets
    in\n   a traffic flow) and the previous hop (upstream nodes with respect to\n
    \  the data flow) nodes on the path between a sender and a receiver.\n   Routers
    along the path of a PATH message forward the message towards\n   the destination
    address based on the L3 routing (packet forwarding)\n   tables.\n   For example,
    consider the L2 domain in Figure 1. Assume that both the\n   sender (some host
    X) and the receiver (some host Y) in a RSVP session\n   reside outside the L2
    domain shown in the Figure, but PATH messages\n   from the sender to its receiver
    pass through the routers in the L2\n   domain using it as a transit subnet. Assume
    that the PATH message\n   from the sender X arrives at the router R1. R1 uses
    its local routing\n   information to decide which next hop router (either router
    R2 or\n   router R3) to use to forward the PATH message towards host Y.\n   However,
    when the path traverses a managed L2 domain, we require the\n   PATH and RESV
    messages to go through a DSBM for each managed segment.\n   Such a L2 domain may
    span many managed segments (and DSBMs) and,\n   typically, SBM protocol entities
    on L2 devices (such as a switch)\n   will serve as the DSBMs for the managed segments
    in a switched\n   topology. When R1 forwards the PATH message to the DSBM (an
    L2\n   device), the DSBM may not have the L3 routing information necessary\n   to
    select the egress router (between R2 and R3) before forwarding the\n   PATH message.
    To ensure correct operation and routing of RSVP\n   messages, we must provide
    additional forwarding information to DSBMs.\n   For this purpose, we introduce
    new RSVP objects called LAN_NHOP\n   address objects that keep track of the next
    L3 hop as the PATH\n   message traverses an L2 domain between two L3 entities
    (RSVP PHOP and\n   NHOP nodes).\n"
  title: 4.2.2.2 The LAN_NHOP Objects
- contents:
  - "4.2.2.3 Including Both Layer-2 and Layer-3 Addresses in the LAN_NHOP\n   When
    a DSBM client (a host or a router acting as the originator of a\n   PATH message)
    sends out a PATH message to the DSBM, it must include\n   LAN_NHOP information
    in the message. In the case of a unicast\n   destination, the LAN_NHOP address
    specifies the destination address\n   (if the destination is local to its L2 domain)
    or the address of the\n   next hop router towards the destination. In our example
    of an RSVP\n   session involving the sender X and receiver Y with L2 domain in\n
    \  Figure 1 acting as the transit subnet, R1 is the ingress node that\n   receives
    the PATH message.  R1 first determines that R2 is the next\n   hop router (or
    the egress node in the L2 domain for the session\n   address) and then inserts
    a LAN_NHOP object that specifies R2's IP\n   address. When a DSBM receives a PATH
    message, it can now look at the\n   address in the LAN_NHOP object and forward
    the PATH message towards\n   the egress node after processing the PATH message.
    \ However, we\n   expect the L2 devices (such as switches) to act as DSBMs on
    the path\n   within the L2 domain and it may not be reasonable to expect these\n
    \  devices to have an ARP capability to determine the MAC address (we\n   call
    it L2ADDR for Layer 2 address) corresponding to the IP address\n   in the LAN_NHOP
    object.\n   Therefore, we require that the LAN_NHOP information (generated by
    the\n   L3 device) include both the IP address (LAN_NHOP_L3 address) and the\n
    \  corresponding MAC address (LAN_NHOP_L2 address ) for the next L3 hop\n   over
    the L2 domain.  The LAN_NHOP_L3 address is used by SBM protocol\n   entities on
    L3 devices to forward the PATH message towards its\n   destination whereas the
    L2 address is used by the SBM protocol\n   entities on L2 devices to determine
    how to forward the PATH message\n   towards the L3 NHOP (egress point from the
    L2 domain).  The exact\n   format of the LAN_NHOP information and relevant objects
    is described\n   later in Appendix B.\n"
  title: 4.2.2.3 Including Both Layer-2 and Layer-3 Addresses in the LAN_NHOP
- contents:
  - "4.2.2.4 Similarities to Standard RSVP Message Processing\n   -  When a DSBM receives
    a RSVP PATH message, it processes the PATH\n      message according to the PATH
    processing rules described in the\n      RSVP specification. In particular, the
    DSBM retrieves the IP\n      address of the previous hop from the RSVP_HOP object
    in the PATH\n      message and stores the PHOP address in its PATH state.  It
    then\n      forwards the PATH message with the PHOP (RSVP_HOP) object modified\n
    \     to reflect its own IP address (RSVP_HOP_L3 address). Thus, the\n      DSBM
    inserts itself as an intermediate hop in the chain of nodes\n      in the path
    between two L3 nodes across the L2 domain.\n   -  The PATH state in a DSBM is
    used for forwarding subsequent RESV\n      messages as per the standard RSVP message
    processing rules.  When\n      the DSBM receives a RESV message, it processes
    the message and\n      forwards it to appropriate PHOP(s) based on its PATH state.\n
    \  -  Because a DSBM inserts itself as a hop between two RSVP nodes in\n      the
    path of a RSVP flow, all RSVP related messages (such as PATH,\n      PATH_TEAR,
    RESV, RESV_CONF, RESV_TEAR, and RESV_ERR) now flow\n      through the DSBM.  In
    particular, a PATH_TEAR message is routed\n      exactly through the intermediate
    DSBM(s) as its corresponding PATH\n      message and the local PATH state is first
    cleaned up at each\n      intermediate hop before the PATH_TEAR message gets forwarded.\n
    \  -  So far, we have described how the PATH message propagates through\n      the
    L2 domain establishing PATH state at each DSBM along the\n      managed segments
    in the path. The layer 2 address (LAN_NHOP_L2\n      address) in the LAN_NHOP
    object should be used by the L2 devices\n      along the path to decide how to
    forward the PATH message toward\n      the next L3 hop.  Such devices will apply
    the standard IEEE 802.1D\n      forwarding rules (e.g., send it on a single port
    based on its\n      filtering database, or flood it on all ports active in the\n
    \     spanning tree if the L2 address does not appear in the filtering\n      database)
    to the LAN_NHOP_L2 address as are applied normally to\n      data packets destined
    to the address.\n"
  title: 4.2.2.4 Similarities to Standard RSVP Message Processing
- contents:
  - "4.2.2.5 Including Both Layer-2 and Layer-3 Addresses in the RSVP_HOP\n        Objects\n
    \  In the conventional RSVP message processing, the PATH state\n   established
    along the nodes on a path is used to route the RESV\n   message from a receiver
    to a sender in an RSVP session. As each\n   intermediate node builds the path
    state, it remembers the previous\n   hop (stores the PHOP IP address available
    in the RSVP_HOP object of\n   an incoming message) that sent it the PATH message
    and, when the RESV\n   message arrives, the intermediate node simply uses the
    stored PHOP\n   address to forward the RESV after processing it successfully.\n
    \  In our case, we expect the SBM entities residing at L2 devices to act\n   as
    DSBMs (and, therefore, intermediate RSVP hops in an L2 domain)\n   along the path
    between a sender (PHOP) and receiver (NHOP). Thus,\n   when a RESV message arrives
    at a DSBM, it must use the stored PHOP IP\n   address to forward the RESV message
    to its previous hop. However, it\n   may not be reasonable to expect the L2 devices
    to have an ARP cache\n   or the ARP capability to map the PHOP IP address to its
    corresponding\n   L2 address before forwarding the RESV message.\n   To obviate
    the need for such address mapping at L2 devices, we use a\n   RSVP_HOP_L2 object
    in the PATH message. The RSVP_HOP_L2 object\n   includes the Layer 2 address (L2ADDR)
    of the previous hop and\n   complements the L3 address information included in
    the RSVP_HOP\n   object (RSVP_HOP_L3 address).\n   When a L3 device constructs
    and forwards a PATH message over a\n   managed segment, it includes its IP address
    (IP address of the\n   interface over which PATH is sent) in the RSVP_HOP object
    and adds a\n   RSVP_HOP_L2 object that includes the corresponding L2 address for
    the\n   interface.  When a device in the L2 domain receives such a PATH\n   message,
    it remembers the addresses in the RSVP_HOP and RSVP_HOP_L2\n   objects in its
    PATH state and then overwrites the RSVP_HOP and\n   RSVP_HOP_L2 objects with its
    own addresses before forwarding the PATH\n   message over a managed segment.\n
    \  The exact format of RSVP_HOP_L2 object is specified in Appendix B.\n"
  title: 4.2.2.5 Including Both Layer-2 and Layer-3 Addresses in the RSVP_HOP
- contents:
  - "4.2.2.6 Loop Detection\n   When an RSVP session address is a multicast address
    and a SBM, DSBM,\n   and DSBM clients share the same L2 segment (a shared segment),
    it is\n   possible for a SBM or a DSBM client to receive one or more copies of\n
    \  a PATH message that it forwarded earlier when a DSBM on the same wire\n   forwards
    it (See Section 5.7 for an example of such a case). To\n   facilitate detection
    of such loops, we use a new RSVP object called\n   the LAN_LOOPBACK object. DSBM
    clients or SBMs (but not the DSBMs\n   reflecting a PATH message onto the interface
    over which it arrived\n   earlier) must overwrite (or add if the PATH message
    does NOT already\n   include a LAN_LOOPBACK object) the LAN_LOOPBACK object in
    the PATH\n   message with their own unicast IP address.\n   Now, a SBM or a DSBM
    client can easily detect and discard the\n   duplicates by checking the contents
    of the LAN_LOOPBACK object (a\n   duplicate PATH message will list a device's
    own interface address in\n   the LAN_LOOPBACK object). Appendix B specifies the
    exact format of\n   the LAN_LOOPBACK object.\n"
  title: 4.2.2.6 Loop Detection
- contents:
  - "4.2.2.7 802.1p, User Priority and TCLASS\n   The model proposed by the Integrated
    Services working group requires\n   isolation of traffic flows from each other
    during their transit\n   across a network. The motivation for traffic flow separation
    is to\n   provide Integrated Services flows protection from misbehaving flows\n
    \  and other best-effort traffic that share the same path. The basic\n   IEEE
    802.3/Ethernet networks do not provide any notion of traffic\n   classes to discriminate
    among different flows that request different\n   services.  However, IEEE 802.1p
    defines a way for switches to\n   differentiate among several \"user_priority\"
    values encoded in packets\n   representing different traffic classes (see [IEEE802Q,
    IEEE8021p] for\n   further details). The user_priority values can be encoded either
    in\n   native LAN packets (e.g., in IEEE 802.5's FC octet) or by using an\n   encapsulation
    above the MAC layer (e.g., in the case of Ethernet, the\n   user_priority value
    assigned to each packet will be carried in the\n   frame header using the new,
    extended frame format defined by IEEE\n   802.1Q [IEEE8021Q]. IEEE, however, makes
    no recommendations about how\n   a sender or network should use the user_priority
    values. An\n   accompanying document makes recommendations on the usage of the\n
    \  user_priority values (see [RFC-MAP] for details).\n   Under the Integrated
    Services model, L3 (or higher) entities that\n   transmit traffic flows onto a
    L2 segment should perform per-flow\n   policing to ensure that the flows do not
    exceed their traffic\n   specification as specified during admission control.
    In addition, L3\n   devices may label the frames in such flows with a user_priority
    value\n   to identify their service class.\n   For the purpose of this discussion,
    we will refer to the\n   user_priority value carried in the extended frame header
    as the\n   \"traffic class\" of a packet. Under the ISSLL model, the L3 entities,\n
    \  that send traffic and that use the SBM protocol, may select the\n   appropriate
    traffic class of outgoing packets [RFC-MAP]. This\n   selection may be overridden
    by DSBM devices, in the following manner.\n   once a sender sends a PATH message,
    downstream DSBMs will insert a\n   new traffic class object (TCLASS object) in
    the PATH message that\n   travels to the next L3 device (L3 NHOP for the PATH
    message). To some\n   extent, the TCLASS object contents are treated like the
    ADSPEC object\n   in the RSVP PATH messages.  The L3 device that receives the
    PATH\n   message must remove and store the TCLASS object as part of its PATH\n
    \  state for the session. Later, when the same L3 device needs to\n   forward
    a RSVP RESV message towards the original sender, it must\n   include the TCLASS
    object in the RESV message. When the RESV message\n   arrives at the original
    sender, the sender must use the user_priority\n   value from the TCLASS object
    to override its selection for the\n   traffic class marked in outgoing packets.\n
    \  The format of the TCLASS object is specified in Appendix B.  Note\n   that
    TCLASS and other SBM-specific objects are carried in a RSVP\n   message in addition
    to all the other, normal RSVP objects per RFC\n   2205.\n"
  title: 4.2.2.7 802.1p, User Priority and TCLASS
- contents:
  - "4.2.2.8 Processing the TCLASS Object\n   In summary, use of TCLASS objects requires
    following additions to the\n   conventional RSVP message processing at DSBMs,
    SBMs, and DSBM\n   clients:\n   *  When a DSBM receives a PATH message over a
    managed segment and the\n      PATH message does not include a TCLASS object,
    the DSBM MAY add a\n      TCLASS object to the PATH message before forwarding
    it.  The DSBM\n      determines the appropriate user_priority value for the TCLASS\n
    \     object. A mechanism for selecting the appropriate user_priority\n      value
    is described in an accompanying document [RFC-MAP].\n   *  When SBM or DSBM receives
    a PATH message with a TCLASS object over\n      a managed segment in a L2 domain
    and needs to forward it over a\n      managed segment in the same L2 domain, it
    will store it in its\n      path state and typically forward the message without
    changing the\n      contents of the TCLASS object.  However, if the DSBM/SBM cannot\n
    \     support the service class represented by the user_priority value\n      specified
    by the TCLASS object in the PATH message, it may change\n      the priority value
    in the TCLASS to a semantically \"lower\" service\n      value to reflect its
    capability and store the changed TCLASS value\n      in its path state.\n      [NOTE:
    An accompanying document defines the int-serv mappings over\n      IEEE 802 networks
    [RFC-MAP] provides a precise definition of\n      user_priority values and describes
    how the user_priority values\n      are compared to determine \"lower\" of the
    two values or the\n      \"lowest\" among all the user_priority values.]\n   *
    \ When a DSBM receives a RESV message with a TCLASS object, it may\n      use
    the traffic class information (in addition to the usual\n      flowspec information
    in the RSVP message) for its own admission\n      control for the managed segment.\n
    \     Note that this document does not specify the actual algorithm or\n      policy
    used for admission control. At one extreme, a DSBM may use\n      per-flow reservation
    request as specified by the flowspec for a\n      fine grain admission control.
    At the other extreme, a DSBM may\n      only consider the traffic class information
    for a very coarse-\n      grain admission control based on some static allocation
    of link\n      capacity for each traffic class. Any combination of the options\n
    \     represented by these two extremes may also be used.\n   *  When a DSBM (at
    an L2 or L3) device receives a RESV message\n      without a TCLASS object and
    it needs to forward the RESV message\n      over a managed segment within the
    same L2 domain, it should first\n      check its path state and check whether
    it has stored a TCLASS\n      value. If so, it should include the TCLASS object
    in the outgoing\n      RESV message after performing its own admission control.
    If no\n      TCLASS value is stored, it must forward the RESV message without\n
    \     inserting a TCLASS object.\n   *  When a DSBM client (residing at an L3
    device such as a host or an\n      edge router) receives the TCLASS object in
    a PATH message that it\n      accepts over an interface, it should store the TCLASS
    object as\n      part of its PATH state for the interface. Later, when the client\n
    \     forwards a RESV message for the same session on the interface, the\n      client
    must include the TCLASS object (unchanged from what was\n      received in the
    previous PATH message) in the RESV message it\n      forwards over the interface.\n
    \  *  When a DSBM client receives a TCLASS object in an incoming RESV\n      message
    over a managed segment and local admission control\n      succeeds for the session
    for the outgoing interface over the\n      managed segment, the client must pass
    the user_priority value in\n      the TCLASS object to its local packet classifier.
    This will ensure\n      that the data packets in the admitted RSVP flow that are\n
    \     subsequently forwarded over the outgoing interface will contain\n      the
    appropriate value encoded in their frame header.\n   *  When an L3 device receives
    a PATH or RESV message over a managed\n      segment in one L2 domain and it needs
    to forward the PATH/RESV\n      message over an interface outside that domain,
    the L3 device must\n      remove the TCLASS object (along with LAN_NHOP, RSVP_HOP_L2,
    and\n      LAN_LOOPBACK objects in the case of the PATH message) before\n      forwarding
    the PATH/RESV message. If the outgoing interface is on\n      a separate L2 domain,
    these objects may be regenerated according\n      to the processing rules applicable
    to that interface.\n"
  title: 4.2.2.8 Processing the TCLASS Object
- contents:
  - '5. Detailed Message Processing Rules

    '
  title: 5. Detailed Message Processing Rules
- contents:
  - "5.1. Additional Notes on Terminology\n   *  An L2 device may have several interfaces
    with attached segments\n      that are part of the same L2 domain. A switch in
    a L2 domain is an\n      example of such a device. A device which has several
    interfaces\n      may contain a SBM protocol entity that acts in different\n      capacities
    on each interface. For example, a SBM protocol entity\n      could act as a SBM
    on interface A, and act as a DSBM on interface\n      B.\n   *  A SBM protocol
    entity on a layer 3 device can be a DSBM client,\n      and SBM, a DSBM, or none
    of the above (SBM transparent).  Non-\n      transparent L3 devices can implement
    any combination of these\n      roles simultaneously. DSBM clients always reside
    at L3 devices.\n   *  A SBM protocol entity residing at a layer 2 device can be
    a SBM, a\n      DSBM or none of the above (SBM transparent). A layer 2 device
    will\n      never host a DSBM client.\n"
  title: 5.1. Additional Notes on Terminology
- contents:
  - "5.2. Use Of Reserved IP Multicast Addresses\n   As stated earlier, we require
    that the DSBM clients forward the RSVP\n   PATH messages to their DSBMs in a L2
    domain before they reach the\n   next L3 hop in the path. RSVP PATH messages are
    addressed, according\n   to RFC-2205, to their destination address (which can
    be either an IP\n   unicast or multicast address).  When a L2 device hosts a DSBM,
    a\n   simple-to-implement mechanism must be provided for the device to\n   capture
    an incoming PATH message and hand it over to the local DSBM\n   agent without
    requiring the L2 device to snoop for L3 RSVP messages.\n   In addition, DSBM clients
    need to know how to address SBM messages to\n   the DSBM. For the ease of operation
    and to allow dynamic DSBM-client\n   binding, it should be possible to easily
    detect and address the\n   existing DSBM on a managed segment.\n   To facilitate
    dynamic DSBM-client binding as well as to enable easy\n   detection and capture
    of PATH messages at L2 devices, we require that\n   a DSBM be addressed using
    a logical address rather than a physical\n   address. We make use of reserved
    IP multicast address(es) for the\n   purpose of communication with a DSBM.  In
    particular, we require that\n   when a DSBM client or a SBM forwards a PATH message
    over a managed\n   segment, it is addressed to a reserved IP multicast address.
    Thus, a\n   DSBM on a L2 device needs to be configured in a way to make it easy\n
    \  to intercept the PATH message and forward it to the local SBM\n   protocol
    entity. For example, this may involve simply adding a static\n   entry in the
    device's filtering database (FDB) for the corresponding\n   MAC multicast address
    to ensure the PATH messages get intercepted and\n   are not forwarded further
    without the DSBM intervention.\n   Similarly, a DSBM always sends the PATH messages
    over a managed\n   segment using a reserved IP multicast address and, thus, the
    SBMs or\n   DSBM clients on the managed segments must simply be configured to\n
    \  intercept messages addressed to the reserved multicast address on the\n   appropriate
    interfaces to easily receive PATH messages.\n   RSVP RESV messages continue to
    be unicast to the previous hop address\n   stored as part of the PATH state at
    each intermediate hop.\n   We define use of two reserved IP multicast addresses.
    We call these\n   the \"AllSBM Address\" and the \"DSBMLogicalAddress\". These
    are chosen\n   from the range of local multicast addresses, such that:\n   *  They
    are not passed through layer 3 devices.\n   *  They are passed transparently through
    layer 2 devices which are\n      SBM transparent.\n   *  They are configured in
    the permanent database of layer 2 devices\n      which host SBMs or DSBMs, such
    that they are directed to the SBM\n      management entity in these devices. This
    obviates the need for\n      these devices to explicitly snoop for SBM related
    control packets.\n   *  The two reserved addresses are 224.0.0.16 (DSBMLogicalAddress)
    and\n      224.0.0.17 (AllSBMAddress).\n   These addresses are used as described
    in the following table:\n   Type     DSBMLogicaladdress         AllSBMAddress\n
    \  DSBM     * Sends PATH messages      * Monitors this address to detect\n   Client
    \    to this address            the presence of a DSBM\n                                       *
    Monitors this address to\n                                         receive PATH
    messages\n                                         forwarded by the DSBM\n   SBM
    \     * Sends PATH messages      * Monitors and sends on this\n              to
    this address            address to participate in\n                                         election
    of the DSBM\n                                       * Monitors this address to\n
    \                                        receive PATH messages\n                                         forwarded
    by the DSBM\n   DSBM     * Monitors this address    * Monitors and sends on this\n
    \             for PATH messages          to participate in election\n              directed
    to it             of the DSBM\n                                       * Sends
    PATH messages to this\n                                         address\n   The
    L2 or MAC addresses corresponding to IP multicast addresses are\n   computed algorithmically
    using a reserved L2 address block (the high\n   order 24-bits are 00:00:5e). The
    Assigned Numbers RFC [RFC-1700]\n   gives additional details.\n"
  title: 5.2. Use Of Reserved IP Multicast Addresses
- contents:
  - "5.3. Layer 3 to Layer 2 Address Mapping\n   As stated earlier, DSBMs or DSBM
    clients residing at a L3 device must\n   include a LAN_NHOP_L2 address in the
    LAN_NHOP information so that L2\n   devices along the path of a PATH message do
    not need to separately\n   determine the mapping between the LAN_NHOP_L3 address
    in the LAN_NHOP\n   object and its corresponding L2 address (for example, using
    ARP).\n   For the purpose of such mapping at L3 devices, we assume a mapping\n
    \  function called \"map_address\" that performs the necessary mapping:\n                 L2ADDR
    object = map_addr(L3Addr)\n   We do not specify how the function is implemented;
    the implementation\n   may simply involve access to the local ARP cache entry
    or may require\n   performing an ARP function.  The function returns a L2ADDR
    object\n   that need not be interpreted by an L3 device and can be treated as
    an\n   opaque object.  The format of the L2ADDR object is specified in\n   Appendix
    B.\n"
  title: 5.3. Layer 3 to Layer 2 Address Mapping
- contents:
  - "5.4. Raw vs. UDP Encapsulation\n   We assume that the DSBMs, DSBM clients, and
    SBMs use only raw IP for\n   encapsulating RSVP messages that are forwarded onto
    a L2 domain.\n   Thus, when a SBM protocol entity on a L3 device forwards a RSVP\n
    \  message onto a L2 segment, it will only use RAW IP encapsulation.\n"
  title: 5.4. Raw vs. UDP Encapsulation
- contents:
  - "5.5. The Forwarding Rules\n   The message processing and forwarding rules will
    be described in the\n   context of the sample network illustrated in Figure 2.\n
    \  Figure 2 - A sample network or L2 domain consisting of switched and\n   shared
    L2 segments\n ..........\n          .\n"
  - '+------+  .    +------+  seg A  +------+  seg C  +------+ seg D +------+

    '
  - '|  H1  |_______|  R1  |_________|  S1  |_________|  S2  |_______|  H2  |

    '
  - '|      |  .    |      |         |      |         |      |       |      |

    '
  - "+------+  .    +------+         +------+         +------+       +------+\n          .
    \                       |                /\n"
  - "1.0.0.0   .                        |               /\n          .                        |___
    \          /\n          .                    seg B  |          / seg E\n ..........
    \                          |         /\n                     2.0.0.0          |
    \       /\n                                     +-----------+\n                                     |
    \   S3     |\n                                     |           |\n                                     +-----------+\n
    \                                         |\n                                          |\n
    \                                         |\n                                          |\n
    \                        seg F            |            .................\n                 ------------------------------
    \       .\n                   |         |             |           .\n                +------+
    \ +------+        +------+     .      +------+\n                |  H3  |  |  H4
    \ |        |  R2  |____________|  H5  |\n                |      |  |      |        |
    \     |     .      |      |\n                +------+  +------+        +------+
    \    .      +------+\n                                                       .\n
    \                                                      .     3.0.0.0\n                                                       .................\n
    \  Figure 2 illustrates a sample network topology consisting of three IP\n   subnets
    (1.0.0.0, 2.0.0.0, and 3.0.0.0) interconnected using two\n   routers. The subnet
    2.0.0.0 is an example of a L2 domain consisting\n   of switches, hosts, and routers
    interconnected using switched\n   segments and a shared L2 segment. The sample
    network contains the\n   following devices:\n   Device          Type                    SBM
    Type\n   H1, H5      Host (layer 3)          SBM Transparent\n   H2-H4       Host
    (layer 3)          DSBM Client\n   R1          Router (layer 3)        SBM\n   R2
    \         Router (layer 3)        DSBM for segment F\n   S1          Switch (layer
    2)        DSBM for segments A, B\n   S2          Switch (layer 2)        DSBM
    for segments C, D, E\n   S3          Switch (layer 2)        SBM\n   The following
    paragraphs describe the rules, which each of these\n   devices should use to forward
    PATH messages (rules apply to PATH_TEAR\n   messages as well). They are described
    in the context of the general\n   network illustrated above. While the examples
    do not address every\n   scenario, they do address most of the interesting scenarios.\n
    \  Exceptions can be discussed separately.\n   The forwarding rules are applied
    to received PATH messages (routers\n   and switches) or originating PATH messages
    (hosts), as follows:\n   1. Determine the interface(s) on which to forward the
    PATH message\n      using standard forwarding rules:\n      *  If there is a LAN_LOOPBACK
    object in the PATH message, and it\n         carries the address of this device,
    silently discard the\n         message.  (See the section below on \"Additional
    notes on\n         forwarding the PATH message onto a managed segment).\n      *
    \ Layer 3 devices use the RSVP session address and perform a\n         routing
    lookup to determine the forwarding interface(s).\n      *  Layer 2 devices use
    the LAN_NHOP_L2 address in the LAN_NHOP\n         information and MAC forwarding
    tables to determine the\n         forwarding interface(s). (See the section below
    on \"Additional\n         notes on forwarding the PATH message onto a managed
    segment\")\n   2. For each forwarding interface:\n      *  If the device is a
    layer 3 device, determine whether the\n         interface is on a managed segment
    managed by a DSBM, based on\n         the presence or absence of I_AM_DSBM messages.
    If the interface\n         is not on a managed segment, strip out RSVP_HOP_L2,
    LAN_NHOP,\n         LAN_LOOPBACK, and TCLASS objects (if present), and forward
    to\n         the unicast or multicast destination.\n         (Note that the RSVP
    Class Numbers for these new objects are\n         chosen so that if an RSVP message
    includes these objects, the\n         nodes that are RSVP-aware, but do not participate
    in the SBM\n         protocol, will ignore and silently discard such objects.)\n
    \     *  If the device is a layer 2 device or it is a layer 3 device\n         *and*
    the interface is on a managed segment, proceed to rule\n         #3.\n   3. Forward
    the PATH message onto the managed segment:\n      *  If the device is a layer
    3 device, insert LAN_NHOP address\n         objects, a LAN_LOOPBACK, and a RSVP_HOP_L2
    object into the PATH\n         message. The LAN_NHOP objects carry the LAN_NHOP_L3
    and\n         LAN_NHOP_L2 addresses of the next layer 3 hop. The RSVP_HOP_L2\n
    \        object carries the device's own L2 address, and the\n         LAN_LOOPBACK
    object contains the IP address of the outgoing\n         interface.\n         An
    L3 device should use the map_addr() function described\n         earlier to obtain
    an L2 address corresponding to an IP address.\n      * If the device hosts the
    DSBM for the segment to which the\n         forwarding interface is attached,
    do the following:\n         - Retrieve the PHOP information from the standard
    RSVP HOP\n           object in the PATH message, and store it. This will be used\n
    \          to route RESV messages back through the L2 network. If the\n           PATH
    message arrived over a managed segment, it will also\n           contain the RSVP_HOP_L2
    object; then retrieve and store also\n           the previous hop's L2 address
    in the PATH state.\n         - Copy the IP address of the forwarding interface
    (layer 2\n           devices must also have IP addresses) into the standard RSVP\n
    \          HOP object and the L2 address of the forwarding interface\n           into
    the RSVP_HOP_L2 object.\n         - If the PATH message received does not contain
    the TCLASS\n           object, insert a TCLASS object. The user_priority value\n
    \          inserted in the TCLASS object is based on service mappings\n           internal
    to the device that are configured according to the\n           guidelines listed
    in [RFC-MAP]. If the message already\n           contains the TCLASS object, the
    user_priority value may be\n           changed based again on the service mappings
    internal to the\n           device.\n      *  If the device is a layer 3 device
    and hosts a SBM for the\n         segment to which the forwarding interface is
    attached, it *is\n         required* to retrieve and store the PHOP info.\n         If
    the device is a layer 2 device and hosts a SBM for the\n         segment to which
    the forwarding interface is attached, it is\n         *not* required to retrieve
    and store the PHOP info. If it does\n         not do so, the SBM must leave the
    standard RSVP HOP object and\n         the RSVP_HOP_L2 objects in the PATH message
    intact and it will\n         not receive RESV messages.\n         If the SBM on
    a L2 device chooses to overwrite the RSVP HOP and\n         RSVP_HOP_L2 objects
    with the IP and L2 addresses of its\n         forwarding interface, it will receive
    RESV messages. In this\n         case, it must store the PHOP address info received
    in the\n         standard RSVP_HOP field and RSVP_HOP_L2 objects of the incident\n
    \        PATH message.\n         In both the cases mentioned above (L2 or L3 devices),
    the SBM\n         must forward the TCLASS object in the received PATH message\n
    \        unchanged.\n      *  Copy the IP address of the forwarding interface
    into the\n         LAN_LOOPBACK object, unless the SBM protocol entity is a DSBM\n
    \        reflecting a PATH message back onto the incident interface.\n         (See
    the section below on \"Additional notes on forwarding a\n         PATH message
    onto a managed segment\").\n      *  If the SBM protocol entity is the DSBM for
    the segment to which\n         the forwarding interface is attached, it must send
    the PATH\n         message to the AllSBMAddress.\n      *  If the SBM protocol
    entity is a SBM or a DSBM Client on the\n         segment to which the forwarding
    interface is attached, it must\n         send the PATH message to the DSBMLogicalAddress.\n"
  title: 5.5. The Forwarding Rules
- contents:
  - "5.5.1. Additional notes on forwarding a PATH message onto a managed\n       segment\n
    \  Rule #1 states that normal IEEE 802.1D forwarding rules should be\n   used
    to determine the interfaces on which the PATH message should be\n   forwarded.
    In the case of data packets, standard forwarding rules at\n   a L2 device dictate
    that the packet should not be forwarded on the\n   interface from which it was
    received. However, in the case of a DSBM\n   that receives a PATH message over
    a managed segment, the following\n   exception applies:\n      E1. If the address
    in the LAN_NHOP object is a unicast address,\n          consult the filtering
    database (FDB) to determine whether the\n          destination address is listed
    on the same interface over which\n          the message was received. If yes,
    follow the rule below on\n          \"reflecting a PATH message back onto an interface\"
    described\n          below; otherwise, proceed with the rest of the message\n
    \         processing as usual.\n      E2. If there are members of the multicast
    group address (specified\n          by the addresses in the LAN_NHOP object),
    on the segment from\n          which the message was received, the message should
    be\n          forwarded back onto the interface from which it was received\n          and
    follow the rule on \"reflecting a PATH message back onto an\n          interface\"
    described below.\n   *** Reflecting a PATH message back onto an interface ***\n
    \     Under the circumstances described above, when a DSBM reflects the\n      PATH
    message back onto an interface over which it was received, it\n      must address
    it using the AllSBMAddress.\n      Since it is possible for a DSBM to reflect
    a PATH message back\n      onto the interface from which it was received, precautions
    must be\n      taken to avoid looping these messages indefinitely. The\n      LAN_LOOPBACK
    object addresses this issue. All SBM protocol\n      entities (except DSBMs reflecting
    a PATH message) overwrite the\n      LAN_LOOPBACK object in the PATH message with
    the IP address of the\n      outgoing interface. DSBMs which are reflecting a
    PATH message,\n      leave the LAN_LOOPBACK object unchanged. Thus, SBM protocol\n
    \     entities will always be able to recognize a reflected multicast\n      message
    by the presence of their own address in the LAN_LOOPBACK\n      object. These
    messages should be silently discarded.\n"
  title: 5.5.1. Additional notes on forwarding a PATH message onto a managed
- contents:
  - "5.6. Applying the Rules -- Unicast Session\n   Let's see how the rules are applied
    in the general network\n   illustrated previously (see Figure 2).\n   Assume that
    H1 is sending a PATH for a unicast session for which H5\n   is the receiver. The
    following PATH message is composed by H1:\n                             RSVP Contents\n
    \  RSVP session IP address   IP address of H5 (3.0.0.35)\n   Sender Template           IP
    address of H1 (1.0.0.11)\n   PHOP                      IP address of H1 (1.0.0.11)\n
    \  RSVP_HOP_L2               n/a  (H1 is not sending onto a managed\n                                 segment)\n
    \  LAN_NHOP                  n/a  (H1 is not sending onto a managed\n                                 segment)\n
    \  LAN_LOOPBACK              n/a  (H1 is not sending onto a managed\n                                 segment)\n
    \                            IP Header\n   Source address            IP address
    of H1 (1.0.0.11)\n   Destn address             IP addr of H5 (3.0.0.35, assuming
    raw mode\n                              & router alert)\n                             MAC
    Header\n   Destn address             The L2 addr corresponding to R1 (determined\n
    \                             by map_addr() and routing tables at H1)\n   Since
    H1 is not sending onto a managed segment, the PATH message is\n   composed and
    forwarded according to standard RSVP processing rules.\n   Upon receipt of the
    PATH message, R1 composes and forwards a PATH\n   message as follows:\n                             RSVP
    Contents\n   RSVP session IP address   IP address of H5\n   Sender Template           IP
    address of H1\n   PHOP                      IP address of R1 (2.0.0.1)\n                             (seed
    the return path for RESV messages)\n   RSVP_HOP_L2               L2 address of
    R1\n   LAN_NHOP                  LAN_NHOP_L3 (2.0.0.2) and\n                             LAN_NHOP_L2
    address of R2 (L2ADDR)\n                             (this is the next layer 3
    hop)\n   LAN_LOOPBACK              IP address of R1 (2.0.0.1)\n                             IP
    Header\n   Source address            IP address of H1\n   Destn address             DSBMLogical
    IP address (224.0.0.16)\n                             MAC Header\n   Destn address
    \            DSBMLogical MAC address\n   *  R1 does a routing lookup on the RSVP
    session address, to\n      determine the IP address of the next layer 3 hop, R2.\n
    \  *  It determines that R2 is accessible via seg A and that seg A\n      is managed
    by a DSBM, S1.\n   *  Therefore, it concludes that it is sending onto a managed\n
    \     segment, and composes LAN_NHOP objects to carry the layer 3\n      and layer
    2 next hop addresses. To compose the LAN_NHOP\n      L2ADDR object, it invokes
    the L3 to L2 address mapping function\n      (\"map_address\") to find out the
    MAC address for the next hop\n      L3 device, and then inserts a LAN_NHOP_L2ADDR
    object (that\n      carries the MAC address) in the message.\n   *  Since R1 is
    not the DSBM for seg A, it sends the PATH message\n      to the DSBMLogicalAddress.\n
    \  Upon receipt of the PATH message, S1 composes and forwards a PATH\n   message
    as follows:\n                            RSVP Contents\n   RSVP session IP address
    \ IP address of H5\n   Sender Template          IP address of H1\n   PHOP                     IP
    addr of S1 (seed the return path for RESV\n                            messages)\n
    \  RSVP_HOP_L2              L2 address of S1\n   LAN_NHOP                 LAN_NHOP_L3
    (IP)  and LAN_NHOP_L2\n                                address of R2\n                            (layer
    2 devices do not modify the LAN_NHOP)\n   LAN_LOOPBACK             IP addr of
    S1\n                            IP Header\n   Source address           IP address
    of H1\n   Destn address            AllSBMIPaddr (224.0.0.17, since S1 is the\n
    \                           DSBM for seg B).\n                            MAC
    Header\n   Destn address            All SBM MAC address (since S1 is the DSBM\n
    \                           for seg B).\n   *  S1 looks at the LAN_NHOP address
    information to determine the\n      L2 address towards which it should forward
    the PATH message.\n   *  From the bridge forwarding tables, it determines that
    the L2\n      address is reachable via seg B.\n   *  S1 inserts the RSVP_HOP_L2
    object and overwrites the RSVP HOP\n      object (PHOP) with its own addresses.\n
    \  *  Since S1 is the DSBM for seg B, it addresses the PATH message\n      to
    the AllSBMAddress.\n   Upon receipt of the PATH message, S3 composes and forwards
    a PATH\n   message as follows:\n                            RSVP Contents\n   RSVP
    session IP addr       IP address of H5\n   Sender Template            IP address
    of H1\n   PHOP                       IP addr of S3 (seed the return\n                                  path
    for RESV messages)\n   RSVP_HOP_L2                L2 address of S3\n   LAN_NHOP
    \                  LAN_NHOP_L3 (IP) and\n                              LAN_NHOP_L2
    (MAC) address of R2\n                              (L2 devices don't modify  LAN_NHOP)\n
    \  LAN_LOOPBACK               IP address of S3\n                             IP
    Header\n   Source address              IP address of H1\n   Destn address               DSBMLogical
    IP addr (since S3 is\n                                   not the DSBM for seg
    F)\n                             MAC Header\n   Destn address               DSBMLogical
    MAC address\n   *  S3 looks at the LAN_NHOP address information to determine the\n
    \     L2 address towards which it should forward the PATH message.\n   *  From
    the bridge forwarding tables, it determines that the L2\n      address is reachable
    via segment F.\n   *  It has discovered that R2 is the DSBM for segment F. It\n
    \     therefore sends the PATH message to the DSBMLogicalAddress.\n   *  Note
    that S3 may or may not choose to overwrite the PHOP\n      objects with its own
    IP and L2 addresses. If it does so, it\n      will receive RESV messages. In this
    case, it must also store\n      the PHOP info received in the incident PATH message
    so that\n      it is able to forward the RESV messages on the correct path.\n
    \  Upon receipt of the PATH message, R2 composes and forwards a PATH\n   message
    as follows:\n                             RSVP Contents\n   RSVP session IP addr
    \ IP address of H5\n   Sender Template       IP address of H1\n   PHOP                  IP
    addr of R2 (seed the return path for RESV\n                         messages)\n
    \  RSVP_HOP_L2           Removed by R2  (R2 is not sending onto a\n                             managed
    segment)\n   LAN_NHOP              Removed by R2  (R2 is not sending onto a\n
    \                        managed segment)\n                             IP Header\n
    \  Source address        IP address of H1\n   Destn address         IP address
    of H5, the RSVP session address\n                             MAC Header\n   Destn
    address         L2 addr corresponding to H5, the next\n                             layer
    3 hop\n   *  R2 does a routing lookup on the RSVP session address, to\n      determine
    the IP address of the next layer 3 hop, H5.\n   *  It determines that H5 is accessible
    via a segment for which\n      there is no DSBM (not a managed segment).\n   *
    \ Therefore, it removes the LAN_NHOP and RSVP_HOP_L2 objects\n      and places
    the RSVP session address in the destination\n      address of the IP header. It
    places the L2 address of the\n      next layer 3 hop, into the destination address
    of the MAC\n      header and forwards the PATH message to H5.\n"
  title: 5.6. Applying the Rules -- Unicast Session
- contents:
  - "5.7. Applying the Rules - Multicast Session\n   The rules described above also
    apply to multicast (m/c) sessions.\n   For the purpose of this discussion, it
    is assumed that layer 2\n   devices track multicast group membership on each port
    individually.\n   Layer 2 devices which do not do so, will merely generate extra\n
    \  multicast traffic. This is the case for L2 devices which do not\n   implement
    multicast filtering or GARP/GMRP capability.\n   Assume that H1 is sending a PATH
    for an m/c session for which H3 and\n   H5 are the receivers. The rules are applied
    as they are in the\n   unicast case described previously, until the PATH message
    reaches R2,\n   with the following exception. The RSVP session address and the\n
    \  LAN_NHOP carry the destination m/c addresses rather than the unicast\n   addresses
    carried in the unicast example.\n   Now let's look at the processing applied by
    R2 upon receipt of the\n   PATH message. Recall that R2 is the DSBM for segment
    F. Therefore, S3\n   will have forwarded its PATH message to the DSBMLogicalAddress,
    to be\n   picked up by R2. The PATH message will not have been seen by H3 (one\n
    \  of the m/c receivers), since it monitors only the AllSBMAddress, not\n   the
    DSBMLogicalAddress for incoming PATH messages.  We rely on R2 to\n   reflect the
    PATH message back onto seg f, and to forward it to H5. R2\n   forwards the following
    PATH message onto seg f:\n                           RSVP Contents\n   RSVP session
    addr   m/c session address\n   Sender Template     IP address of H1\n   PHOP                IP
    addr of R2 (seed the return path for\n                       RESV messages)\n
    \  RSVP_HOP_L2         L2 addr of R2\n   LAN_NHOP            m/c session address
    and corresponding L2 address\n   LAN_LOOPBACK        IP addr of S3 (DSBMs reflecting
    a PATH\n                       message don't modify this object)\n                           IP
    Header\n   Source address      IP address of H1\n   Destn address       AllSBMIP
    address (since R2 is the DSBM for seg F)\n                           MAC Header\n
    \  Destn address       AllSBMMAC address (since R2 is the\n                          DSBM
    for seg F)\n   Since H3 is monitoring the All SBM Address, it will receive the
    PATH\n   message reflected by R2. Note that R2 violated the standard\n   forwarding
    rules here by sending an incoming message back onto the\n   interface from which
    it was received. It protected against loops by\n   leaving S3's address in the
    LAN_LOOPBACK object unchanged.\n   R2 forwards the following PATH message on to
    H5:\n                             RSVP Contents\n   RSVP session addr     m/c
    session address\n   Sender Template       IP address of H1\n   PHOP                  IP
    addr of R2 (seed the return path for RESV\n                         messages)\n
    \  RSVP_HOP_L2           Removed by R2 (R2 is not sending onto a\n                         managed
    segment)\n   LAN_NHOP              Removed by R2 (R2 is not sending onto a\n                         managed
    segment)\n   LAN_LOOPBACK          Removed by R2 (R2 is not sending onto a\n                         managed
    segment)\n                             IP Header\n   Source address        IP
    address of H1\n   Destn address         m/c session address\n                             MAC
    Header\n   Destn address         MAC addr corresponding to the m/c\n                         session
    address\n   *  R2 determines that there is an m/c receiver accessible via a\n
    \     segment for which there is no DSBM. Therefore, it removes the\n      LAN_NHOP
    and RSVP_HOP_L2 objects and places the RSVP session\n      address in the destination
    address of the IP header. It\n      places the corresponding L2 address into the
    destination\n      address of the MAC header and multicasts the message towards\n
    \     H5.\n"
  title: 5.7. Applying the Rules - Multicast Session
- contents:
  - "5.8. Merging Traffic Class objects\n   When a DSBM client receives TCLASS objects
    from different senders\n   (different PATH messages) in the same RSVP session
    and needs to\n   combine them for sending back a single RESV message (as in a
    wild-\n   card style reservation), the DSBM client must choose an appropriate\n
    \  value that corresponds to the desired-delay traffic class. An\n   accompanying
    document discusses the guidelines for traffic class\n   selection based on desired
    service and the TSpec information [RFC-\n   MAP].\n   In addition, when a SBM
    or DSBM needs to merge RESVs from different\n   next hops at a merge point, it
    must decide how to handle the TCLASS\n   values in the incoming RESVs if they
    do not match.  Consider the case\n   when a reservation is in place for a flow
    at a DSBM (or SBM) with a\n   successful admission control done for the TCLASS
    requested in the\n   first RESV for the flow. If another RESV (not the refresh
    of the\n   previously admitted RESV) for the same flow arrives at the DSBM, the\n
    \  DSBM must first check the TCLASS value in the new RESV against the\n   TCLASS
    value in the already installed RESV. If the two values are\n   same, the RESV
    requests are merged and the new, merged RESV installed\n   and forwarded using
    the normal rules of message processing. However,\n   if the two values are not
    identical, the DSBM must generate and send\n   a RESV_ERR message towards the
    sender (NHOP) of the newer, RESV\n   message. The RESV_ERR must specify the error
    code corresponding to\n   the RSVP  \"traffic control error\" (RESV_ERR code 21)
    that indicates\n   failure to merge two incompatible service requests (sub-code
    01 for\n   the RSVP traffic control error) [RFC-2205]. The RESV_ERR message may\n
    \  include additional objects to assist downstream nodes in recovering\n   from
    this condition.  The definition and usage of such objects is\n   beyond the scope
    of this memo.\n"
  title: 5.8. Merging Traffic Class objects
- contents:
  - "5.9. Operation of SBM Transparent Devices\n   SBM transparent devices are unaware
    of the entire SBM/DSBM protocol.\n   They do not intercept messages addressed
    to either of the SBM related\n   local group addresses (the DSBMLogicalAddrss
    and the ALLSBMAddress),\n   but instead, pass them through. As a result, they
    do not divide the\n   DSBM election scope, they do not explicitly participate
    in routing of\n   PATH or RESV messages, and they do not participate in admission\n
    \  control. They are entirely transparent with respect to SBM operation.\n   According
    to the definitions provided, physical segments\n   interconnected by SBM transparent
    devices are considered a single\n   managed segment. Therefore, DSBMs must perform
    admission control on\n   such managed segments, with limited knowledge of the
    segment's\n   topology.  In this case, the network administrator should configure\n
    \  the DSBM for each managed segment, with some reasonable approximation\n   of
    the segment's capacity. A conservative policy would configure the\n   DSBM for
    the lowest capacity route through the managed segment. A\n   liberal policy would
    configure the DSBM for the highest capacity\n   route through the managed segment.
    A network administrator will\n   likely choose some value between the two, based
    on the level of\n   guarantee required and some knowledge of likely traffic patterns.\n
    \  This document does not specify the configuration mechanism or the\n   choice
    of a policy.\n"
  title: 5.9. Operation of SBM Transparent Devices
- contents:
  - "5.10. Operation of SBMs Which are NOT DSBMs\n   In the example illustrated, S3
    hosts a SBM, but the SBM on S3 did not\n   win the election to act as DSBM on
    any segment. One might ask what\n   purpose such a SBM protocol entity serves.
    Such SBMs actually provide\n   two useful functions.  First, the additional SBMs
    remain passive in\n   the background for fault tolerance. They listen to the periodic\n
    \  announcements from the current DSBM for the managed segment (Appendix\n   A
    describes this in more detail) and step in to elect a new DSBM when\n   the current
    DSBM fails or ceases to be operational for some reason.\n   Second, such SBMs
    also provide the important service of dividing the\n   election scope and reducing
    the size and complexity of managed\n   segments. For example, consider the sample
    topology in Figure 3\n   again. the device S3 contains an SBM that is not a DSBM
    for any f the\n   segments, B, E, or F, attached to it. However, if the SBM protocol\n
    \  entity on S3 was not present, segments B and F would not be separate\n   segments
    from the point of view of the SBM protocol. Instead, they\n   would constitute
    a single managed segment, managed by a single DSBM.\n   Because the SBM entity
    on S3 divides the election scope, seg B and\n   seg F are each managed by separate
    DSBMs. Each of these segments have\n   a trivial topology and a well defined capacity.
    As a result, the\n   DSBMs for these segments do not need to perform admission
    control\n   based on approximations (as would be the case if S3 were SBM\n   transparent).\n
    \  Note that, SBM protocol entities which are not DSBMs, are not\n   required
    to overwrite the PHOP in incident PATH messages with their\n   own address. This
    is because it is not necessary for RESV messages to\n   be routed through these
    devices. RESV messages are only required to\n   be routed through the correct
    sequence of DSBMs.  SBMs may not\n   process RESV messages that do pass through
    them, other than to\n   forward them towards their destination address, using
    standard\n   forwarding rules.\n   SBM protocol entities which are not DSBMs are
    required to overwrite\n   the address in the LAN_LOOPBACK object with their own
    address, in\n   order to avoid looping multicast messages. However, no state need
    be\n   stored.\n"
  title: 5.10. Operation of SBMs Which are NOT DSBMs
- contents:
  - "6. Inter-Operability Considerations\n   There are a few interesting inter-operability
    issues related to the\n   deployment of a DSBM-based admission control method
    in an environment\n   consisting of network nodes with and without RSVP capability.
    \ In the\n   following, we list some of these scenarios and explain how SBM-aware\n
    \  clients and nodes can operate in those scenarios:\n"
  title: 6. Inter-Operability Considerations
- contents:
  - "6.1. An L2 domain with no RSVP capability.\n   It is possible to envisage L2
    domains that do not use RSVP signaling\n   for requesting resource reservations,
    but, instead, use some other\n   (e.g., SNMP or static configuration) mechanism
    to reserve bandwidth\n   at a particular network device such as a router. In that
    case, the\n   question is how does a DSBM-based admission control method work
    and\n   interoperate with the non-RSVP mechanism.  The SBM-based method does\n
    \  not attempt to provide an admission control solution for such an\n   environment.
    The SBM-based approach is part of an end to end\n   signaling approach to establish
    resource reservations and does not\n   attempt to provide a solution for SNMP-based
    configuration scenario.\n   As stated earlier, the SBM-based approach can, however,
    co-exist with\n   any other, non-RSVP bandwidth allocation mechanism as long as\n
    \  resources being reserved are either partitioned statically between\n   the
    different mechanisms or are resolved dynamically through a common\n   bandwidth
    allocator so that there is no over-commitment of the same\n   resource.\n"
  title: 6.1. An L2 domain with no RSVP capability.
- contents:
  - "6.2. An L2 domain with SBM-transparent L2 Devices.\n   This scenario has been
    addressed earlier in the document. The SBM-\n   based method is designed to operate
    in such an environment.  When\n   SBM-transparent L2 devices interconnect SBM-aware
    devices, the\n   resulting managed segment is a combination of one or more physical\n
    \  segments and the DSBM for the managed segment may not be as efficient\n   in
    allocating resources as it would if all L2 devices were SBM-aware.\n"
  title: 6.2. An L2 domain with SBM-transparent L2 Devices.
- contents:
  - "6.3. An L2 domain on which some RSVP-based senders are not DSBM clients.\n   All
    senders that are sourcing RSVP-based traffic flows onto a managed\n   segment
    MUST be SBM-aware and participate in the SBM protocol.  Use\n   of the standard,
    non-SBM version of RSVP may result in over-\n   allocation of resources, as such
    use bypasses the resource management\n   function of the DSBM. All other senders
    (i.e., senders that are not\n   sending streams subject to RSVP admission control)
    should be elastic\n   applications that send traffic of lower priority than the
    RSVP\n   traffic, and use TCP-like congestion avoidance mechanisms.\n   All DSBMs,
    SBMs, or DSBM clients on a managed segment (a segment with\n   a currently active
    DSBM) must not accept PATH messages from senders\n   that are not SBM-aware. PATH
    messages from such devices can be easily\n   detected by SBMs and DSBM clients
    as they would not be multicast to\n   the ALLSBMAddress (in case of SBMs and DSBM
    clients) or the\n   DSBMLogicalAddress (in case of DSBMs).\n"
  title: 6.3. An L2 domain on which some RSVP-based senders are not DSBM clients.
- contents:
  - "6.4. A non-SBM router that interconnects two DSBM-managed L2 domains.\n   Multicast
    SBM messages (e.g., election and PATH messages) have local\n   scope and are not
    intended to pass between the two domains.  A\n   correctly configured non-SBM
    router will not pass such messages\n   between the domains. A broken router implementation
    that does so may\n   cause incorrect operation of the SBM protocol and consequent
    over- or\n   under-allocation of resources.\n"
  title: 6.4. A non-SBM router that interconnects two DSBM-managed L2 domains.
- contents:
  - "6.5. Interoperability with RSVP clients that use UDP encapsulation and\n   are
    not capable of receiving/sending RSVP messages using RAW_IP\n   This document
    stipulates that DSBMs, DSBM clients, and SBMs use only\n   raw IP for encapsulating
    RSVP messages that are forwarded onto a L2\n   domain. RFC-2205 (the RSVP Proposed
    Standard) includes support for\n   both raw IP and UDP encapsulation. Thus, a
    RSVP node using only the\n   UDP encapsulation will not be able to interoperate
    with the DSBM\n   unless DSBM accepts and supports UDP encapsulated RSVP messages.\n"
  title: 6.5. Interoperability with RSVP clients that use UDP encapsulation and
- contents:
  - "7. Guidelines for Implementers\n   In the following, we provide guidelines for
    implementers on different\n   aspects of the implementation of the SBM-based admission
    control\n   procedure including suggestions for DSBM initialization, etc.\n"
  title: 7. Guidelines for Implementers
- contents:
  - "7.1. DSBM Initialization\n   As stated earlier, DSBM initialization includes
    configuration of\n   maximum bandwidth that can be reserved on a managed segment
    under its\n   control.  We suggest the following guideline.\n   In the case of
    a managed segment consisting of L2 devices\n   interconnected by a single shared
    segment, DSBM entities on such\n   devices should assume the bandwidth of the
    interface as the total\n   link bandwidth. In the case of a DSBM located in a
    L2 switch, it\n   might additionally need to be configured with an estimate of
    the\n   device's switching capacity if that is less than the link bandwidth,\n
    \  and possibly with some estimate of the buffering resources of the\n   switch
    (see [RFC-FRAME] for the architectural model assumed for L2\n   switches). Given
    the total link bandwidth, the DSBM may be further\n   configured to limit the
    maximum amount of bandwidth for RSVP-enabled\n   flows to ensure spare capacity
    for best-effort traffic.\n"
  title: 7.1. DSBM Initialization
- contents:
  - "7.2. Operation of DSBMs in Different L2 Topologies\n   Depending on a L2 topology,
    a DSBM may be called upon to manage\n   resources for one or more segments and
    the implementers must bear in\n   mind efficiency implications of the use of DSBM
    in different L2\n   topologies.  Trivial L2 topologies consist of a single \"physical\n
    \  segment\". In this case, the 'managed segment' is equivalent to a\n   single
    segment. Complex L2 topologies may consist of a number of\n   Admission control
    on such an L2 extended segment can be performed\n   from a single pool of resources,
    similar to a single shared segment,\n   from the point of view of a single DSBM.\n
    \  This configuration compromises the efficiency with which the DSBM can\n   allocate
    resources. This is because the single DSBM is required to\n   make admission control
    decisions for all reservation requests within\n   the L2 topology, with no knowledge
    of the actual physical segments\n   affected by the reservation.\n   We can realize
    improvements in the efficiency of resource allocation\n   by subdividing the complex
    segment into a number of managed segments,\n   each managed by their own DSBM.
    In this case, each DSBM manages a\n   managed segment having a relatively simple
    topology.  Since managed\n   segments are simpler, the DSBM can be configured
    with a more accurate\n   estimate of the resources available for all reservations
    in the\n   managed segment. In the ultimate configuration, each physical segment\n
    \  is a managed segment and is managed by its own DSBM. We make no\n   assumption
    about the number of managed segments but state, simply,\n   that in complex L2
    topologies, the efficiency of resource allocation\n   improves as the granularity
    of managed segments increases.\n"
  title: 7.2. Operation of DSBMs in Different L2 Topologies
- contents:
  - "8. Security Considerations\n   The message formatting and usage rules described
    in this note raise\n   security issues, identical to those raised by the use of
    RSVP and\n   Integrated Services. It is necessary to control and authenticate\n
    \  access to enhanced qualities of service enabled by the technology\n   described
    in this RFC. This requirement is discussed further in\n   [RFC-2205], [RFC-2211],
    and [RFC-2212].\n   [RFC-RSVPMD5] describes the mechanism used to protect the
    integrity\n   of RSVP messages carrying the information described here. A SBM\n
    \  implementation should satisfy the requirements of that RFC and\n   provide
    the suggested mechanisms just as though it were a\n   conventional RSVP implementation.
    It should further use the same\n   mechanisms to protect the additional, SBM-specific
    objects in a\n   message.\n   Finally, it is also necessary to authenticate DSBM
    candidates during\n   the election process, and a mechanism based on a shared
    secret among\n   the DSBM candidates may be used.  The mechanism defined in [RFC-\n
    \  RSVPMD5] should be used.\n"
  title: 8. Security Considerations
- contents:
  - "9. References\n   [RFC 2205]    Braden, R., Zhang, L., Berson,  S., Herzog, S.
    and S.\n                 Jamin, \"Resource ReSerVation Protocol (RSVP) -- Version\n
    \                1 Functional Specification\", RFC 2205, September 1997.\n   [RFC-RSVPMD5]
    Baker, F., Lindell, B. and M. Talwar, \"RSVP\n                 Cryptographic Authentication\",
    RFC 2747, January 2000.\n   [RFC 2206]    Baker, F. and J. Krawczyk, \"RSVP Management
    Information\n                 Base\", RFC 2206, September 1997.\n   [RFC 2211]
    \   Wroclawski, J., \"Specification of the Controlled-Load\n                 Network
    Element Service\", RFC 2211, September 1997.\n   [RFC 2212]    Shenker, S., Partridge,
    C. and  R. Guerin,\n                 \"Specification of Guaranteed Quality of
    Service\", RFC\n                 2212, September 1997.\n   [RFC 2215]    Shenker,
    S. and J. Wroclawski, \"General\n                 Characterization Parameters
    for Integrated Service\n                 Network Elements\", RFC 2215, September
    1997.\n   [RFC 2210]    Wroclawski, J., \"The Use of RSVP with IETF Integrated\n
    \                Services\", RFC 2210, September 1997.\n   [RFC 2213]    Baker,
    F. and  J. Krawczyk, \"Integrated Services\n                 Management Information
    Base\", RFC 2213, September 1997.\n   [RFC-FRAME]   Ghanwani, A., Pace, W., Srinivasan,
    V., Smith, A. and\n                 M.Seaman, \"A Framework for Providing Integrated\n
    \                Services Over Shared and Switched LAN Technologies\",\n                 RFC
    2816, May 2000.\n   [RFC-MAP]     Seaman, M., Smith, A. and E. Crawley, \"Integrated\n
    \                Service Mappings on IEEE 802 Networks\", RFC 2815, May\n                 2000.\n
    \  [IEEE802Q]    \"IEEE Standards for Local and Metropolitan Area\n                 Networks:
    \ Virtual Bridged Local Area Networks\", Draft\n                 Standard P802.1Q/D9,
    February 20, 1998.\n   [IEEEP8021p]  \"Information technology - Telecommunications
    and\n                 information exchange between systems - Local and\n                 metropolitan
    area networks - Common specifications -\n                 Part 3:  Media Access
    Control (MAC) Bridges: Revision\n                 (Incorporating IEEE P802.1p:
    \ Traffic Class Expediting\n                 and Dynamic Multicast Filtering)\",
    ISO/IEC Final CD\n                 15802-3 IEEE P802.1D/D15, November 24, 1997.\n
    \  [IEEE8021D]   \"MAC Bridges\", ISO/IEC 10038, ANSI/IEEE Std 802.1D-\n                 1993.\n"
  title: 9. References
- contents:
  - "A.1. Introduction\n   To simplify the rest of this discussion, we will assume
    that there is\n   a single DSBM for the entire L2 domain (i.e., assume a shared
    L2\n   segment for the entire L2 domain). Later, we will discuss how a DSBM\n
    \  is elected for a half-duplex or full-duplex switched segment.\n   To allow
    for quick recovery from the failure of a DSBM, we assume\n   that additional SBMs
    may be active in a L2 domain for fault\n   tolerance.  When more than one SBM
    is active in a L2 domain, the SBMs\n   use an election algorithm to elect a DSBM
    for the L2 domain. After\n   the DSBM is elected and is operational, other SBMs
    remain passive in\n   the background to step in to elect a new DSBM when necessary.
    \ The\n   protocol for electing and discovering DSBM is called the \"DSBM\n   election
    protocol\" and is described in the rest of this Appendix.\n"
  title: A.1. Introduction
- contents:
  - "A.1.1. How a DSBM Client Detects a Managed Segment\n   Once elected, a DSBM periodically
    multicasts an I_AM_DSBM message on\n   the AllSBMAddress to indicate its presence.
    The message is sent every\n   period (e.g., every 5 seconds) according to the
    RefreshInterval timer\n   value (a configuration parameter).  Absence of such
    a message over a\n   certain time interval (called \"DSBMDeadInterval\"; another\n
    \  configuration parameter typically set to a multiple of\n   RefreshInterval)
    indicates that the DSBM has failed or terminated and\n   triggers another round
    of the DSBM election. The DSBM clients always\n   listen for periodic DSBM advertisements.
    The advertisement includes\n   the unicast IP address of the DSBM (DSBMAddress)
    and DSBM clients\n   send their PATH/RESV (or other) messages to the DSBM. When
    a DSBM\n   client detects the failure of a DSBM, it waits for a subsequent\n   I_AM_DSBM
    advertisement before resuming any communication with the\n   DSBM. During the
    period when a DSBM is not present, a DSBM client may\n   forward outgoing PATH
    messages using the standard RSVP forwarding\n   rules.\n   The exact message formats
    and addresses used for communication with\n   (and among) SBM(s) are described
    in Appendix B.\n"
  title: A.1.1. How a DSBM Client Detects a Managed Segment
- contents:
  - "A.2. Overview of the DSBM Election Procedure\n   When a SBM first starts up,
    it listens for incoming DSBM\n   advertisements for some period to check whether
    a DSBM already exists\n   in its L2 domain. If one already exists (and no new
    election is in\n   progress), the new SBM stays quiet in the background until
    an\n   election of DSBM is necessary. All messages related to the DSBM\n   election
    and DSBM advertisements are always sent to the\n   AllSBMAddress.\n   If no DSBM
    exists, the SBM initiates the election of a DSBM by\n   sending out a DSBM_WILLING
    message that lists its IP address as a\n   candidate DSBM and its \"SBM priority\".
    Each SBM is assigned a\n   priority  to determine its relative precedence. When
    more than one\n   SBM candidate exists, the SBM priority determines who gets to
    be the\n   DSBM based on the relative priority of candidates. If there is a tie\n
    \  based on the priority value, the tie is  broken using the IP\n   addresses
    of tied candidates (one with the higher IP address in the\n   lexicographic order
    wins). The details of the election protocol start\n   in Section A.4.\n"
  title: A.2. Overview of the DSBM Election Procedure
- contents:
  - "A.2.1 Summary of the Election Algorithm\n   For the purpose of the algorithm,
    a SBM is in one of the four states\n   (Idle, DetectDSBM, ElectDSBM, IAMDSBM).\n
    \  A SBM (call it X) starts up in the DetectDSBM state and waits for a\n   ListenInterval
    for incoming I_AM_DSBM (DSBM advertisement) or\n   DSBM_WILLING messages. If an
    I_AM_DSBM advertisement is received\n   during this state, the SBM notes the current
    DSBM (its IP address and\n   priority) and enters the Idle state. If a DSBM_WILLING
    message is\n   received from another SBM (call it Y) during this state, then X\n
    \  enters the ElectDSBM state. Before entering the new state, X first\n   checks
    to see whether it itself is a better candidate than Y and, if\n   so, sends out
    a DSBM_WILLING message and then enters the ElectDSBM\n   state.\n   When a SBM
    (call it X) enters the ElectDSBM state, it sets a timer\n   (called ElectionIntervalTimer,
    and typically set to a value at least\n   equal to the DSBMDeadInterval value)
    to wait for the election to\n   finish and to discover who is the best candidate.
    In this state, X\n   keeps track of the best (or better) candidate seen so far
    (including\n   itself). Whenever it receives another DSBM_WILLING message it updates\n
    \  its notion of the best (or better) candidate based on the priority\n   (and
    tie-breaking) criterion.  During the ElectionInterval, X sends\n   out a DSBM_WILLING
    message every RefreshInterval to (re)assert its\n   candidacy.\n   At the end
    of the ElectionInterval, X checks whether it is the best\n   candidate so far.
    If so, it declares itself to be the DSBM (by\n   sending out the I_AM_DSBM advertisement)
    and enters the IAMDSBM\n   state; otherwise, it decides to wait for the best candidate
    to\n   declare itself the winner. To wait, X re-initializes its ElectDSBM\n   state
    and continues to wait for another round of election (each round\n   lasts for
    an ElectionTimerInterval duration).\n   A SBM is in Idle state when no election
    is in progress and the DSBM\n   is already elected (and happens to be someone
    else).  In this state,\n   it listens  for incoming I_AM_DSBM advertisements and
    uses a\n   DSBMDeadIntervalTimer to detect the failure of DSBM. Every time the\n
    \  advertisement is received, the timer is restarted. If the timer\n   fires,
    the SBM goes into the DetectDSBM state to prepare to elect the\n   new DSBM. If
    a SBM receives a DSBM_WILLING message from the current\n   DSBM in this state,
    the SBM enters the ElectDSBM state after sending\n   out a DSBM_WILLING message
    (to announce its own candidacy).\n   In the IAMDSBM state, the DSBM sends out
    I_AM_DSBM advertisements\n   every refresh interval. If the DSBM wishes to shut
    down (gracefully\n   terminate), it sends out a DSBM_WILLING message (with SBM
    priority\n   value set to zero) to initiate the election procedure. The priority\n
    \  value zero effectively removes the outgoing DSBM from the election\n   procedure
    and makes way for the election of a different DSBM.\n"
  title: A.2.1 Summary of the Election Algorithm
- contents:
  - "A.3. Recovering from DSBM Failure\n   When a DSBM fails (DSBMDeadIntervalTimer
    fires), all the SBMs enter\n   the ElectDSBM state and start the election process.\n
    \  At the end of the ElectionInterval, the elected DSBM sends out an\n   I_AM_DSBM
    advertisement and the DSBM is then operational.\n"
  title: A.3. Recovering from DSBM Failure
- contents:
  - "A.4. DSBM Advertisements\n   The I_AM_DSBM advertisement contains the following
    information:\n   1.  DSBM address information -- contains the IP and L2 addresses
    of\n       the DSBM and its SBM priority (a configuration parameter --\n       priority
    specified by a network administrator). The priority\n       value is used to choose
    among candidate SBMs during the election\n       algorithm. Higher integer values
    indicate higher priority and the\n       value is in the range 0..255. The value
    zero indicates that the\n       SBM is not eligible to be the DSBM.  The IP address
    is required\n       and used for breaking ties. The L2 address is for the interface\n
    \      of the managed segment.\n   2.  RegreshInterval -- contains the value of
    RefreshInterval in\n       seconds.  Value zero indicates the parameter has been
    omitted in\n       the message.  Receivers may substitute their own default value
    in\n       this case.\n   3.  DSBMDeadInterval -- contains the value of DSBMDeadInterval
    in\n       seconds. If the value is omitted (or value zero is specified), a\n
    \      default value (from initial configuration) should be used.\n   4.  Miscellaneous
    configuration information to be advertised to\n       senders on the managed segment.
    See Appendix C for further\n       details.\n"
  title: A.4. DSBM Advertisements
- contents:
  - "A.5. DSBM_WILLING Messages\n   When a SBM wishes to declare its candidacy to
    be the DSBM  during an\n   election phase, it sends out a DSBM_WILLING message.
    The DSBM_WILLING\n   message contains the following information:\n   1.  DSBM
    address information -- Contains the SBM's own addresses (IP\n       and L2 address),
    if it wishes to be the DSBM. The IP address is\n       required and used for breaking
    ties. The L2 address is the\n       address of the interface for the managed segment
    in question.\n       Also, the DSBM address information includes the corresponding\n
    \      priority of the SBM whose address is given above.\n"
  title: A.5. DSBM_WILLING Messages
- contents:
  - "A.6. SBM State Variables\n   For each network interface, a SBM maintains the
    following state\n   variables related to the election of the DSBM for the L2 domain
    on\n   that interface:\n       a) LocalDSBMAddrInfo -- current DSBM's IP address
    (initially,\n       0.0.0.0) and priority. All IP addresses are assumed to be
    in\n       network byte order. In addition, current DSBM's L2 address is\n       also
    stored as part of this state information.\n       b) OwnAddrInfo -- SBM's own
    IP address and L2 address for the\n       interface and its own priority (a configuration
    parameter).\n       c) RefreshInterval in seconds. When the DSBM is not yet elected,\n
    \      it is set to a default value specified as a configuration\n       parameter.\n
    \      d) DSBMDeadInterval in seconds. When the DSBM is not yet elected,\n       it
    is initially set to  a default value specified as a\n       configuration parameter.\n
    \      f) ListenInterval in seconds -- a configuration parameter that\n       decides
    how long a SBM spends in the DetectDSBM state (see\n       below).\n       g)
    ElectionInterval in seconds -- a configuration parameter that\n       decides
    how long a SBM spends in the ElectDSBM state when it has\n       declared its
    candidacy.\n   Figure 3 shows the state transition diagram for the election protocol\n
    \  and the various states are described below. A complete description of\n   the
    state machine is provided in Section A.10.\n"
  title: A.6. SBM State Variables
- contents:
  - "A.7. DSBM Election States\n       DOWN -- SBM is not operational.\n       DetectDSBM
    -- typically, the initial state of a SBM when it\n       starts up. In this state,
    it checks to see whether a DSBM already\n       exists in its domain.\n       Idle
    -- SBM is in this state when no election is in progress and\n       it is not
    the DSBM. In this state, SBM passively monitors the\n       state of the DSBM.\n
    \      ElectDSBM -- SBM is in this state when a DSBM election is in\n       progress.\n
    \      IAMDSBM -- SBM is in this state when it is the DSBM for the L2\n       domain.\n"
  title: A.7. DSBM Election States
- contents:
  - "A.8. Events that cause state changes\n       StartUp -- SBM starts operation.\n
    \      ListenInterval Timeout -- The ListenInterval timer has fired.\n       This
    means that the SBM has monitored its domain to check for an\n       existing DSBM
    or to check whether there are candidates (other\n       than itself) willing to
    be the DSBM.\n       DSBM_WILLING message received -- This means that the SBM
    received\n       a DSBM_WILLING message from some other SBM. Such a message is\n
    \      sent when a SBM wishes to declare its candidacy to be the DSBM.\n       I_AM_DSBM
    message received -- SBM received a DSBM advertisement\n       from the DSBM in
    its L2 domain.\n       DSBMDeadInterval Timeout -- The DSBMDeadIntervalTimer has
    fired.\n       This means that the SBM did not receive even one DSBM\n       advertisement
    during this period and indicates possible failure\n       of the DSBM.\n       RefreshInterval
    Timeout -- The RefreshIntervalTimer has fired. In\n       the IAMDSBM state, this
    means it is the time for sending out the\n       next DSBM advertisement. In the
    ElectDSBM state, the event means\n       that it is the time to send out another
    DSBM_WILLING message.\n       ElectionInterval Timeout -- The ElectionIntervalTimer
    has fired.\n       This means that the SBM has waited long enough after declaring\n
    \      its candidacy to determine whether or not it succeeded.\n"
  title: A.8. Events that cause state changes
- contents:
  - "A.9. State Transition Diagram (Figure 3)\n                                +-----------+\n
    \           +--<--------------<-|DetectDSBM |---->------+\n            |                   +-----------+
    \          |\n            |                                           |\n            |
    \                                          |\n            |                                           |\n
    \           |     +-------------+       +---------+     |\n            +->---|
    \  Idle      |--<>---|ElectDSBM|--<--+\n                  +-------------+       +---------+\n
    \                      |                        |\n                       |                        |\n
    \                      |                        |\n                       |        +-----------+
    \  |\n                       +<<- +---|  IAMDSBM  |-<-+\n                            |
    \  +-----------+\n                            |\n                            |
    \  +-----------+\n                            +>>-| SHUTDOWN  |\n                                +-----------+\n"
  title: A.9. State Transition Diagram (Figure 3)
- contents:
  - "A.10. Election State Machine\n   Based on the events and states described above,
    the state changes at\n   a SBM are described below. Each state change is triggered
    by an event\n   and is typically accompanied by a sequence of actions.  The state\n
    \  machine is described assuming a single threaded implementation (to\n   avoid
    race conditions between state changes and timer events) with no\n   timer events
    occurring during the execution of the state machine.\n   The following routines
    will be frequently used in the description of\n   the state machine:\n   ComparePrio(FirstAddrInfo,
    SecondAddrInfo)\n     -- determines whether the entity represented by the first
    parameter\n       is better than the second entity using the priority information\n
    \      and the IP address information in the two parameters.  If any\n       address
    is zero, that entity automatically loses; then first\n       priorities are compared;
    higher priority candidate wins. If there\n       is a tie based on the priority
    value, the tie is broken using the\n       IP addresses of tied candidates  (one
    with the higher IP address\n       in the lexicographic order wins).  Returns
    TRUE if first entity\n       is a better choice. FALSE otherwise.\n   SendDSBMWilling
    Message()\n   Begin\n       Send out DSBM_WILLING message listing myself as a
    candidate for\n       DSBM (copy OwnAddr and priority into appropriate fields)\n
    \      start RefreshIntervalTimer\n       goto ElectDSBM state\n   End\n   AmIBetterDSBM(OtherAddrInfo)\n
    \  Begin\n       if (ComparePrio(OwnAddrInfo, OtherAddrInfo))\n           return
    TRUE\n       change LocalDSBMInfo = OtherDSBMAddrInfo\n       return FALSE\n   End\n
    \  UpdateDSBMInfo()\n   /* invoked in an assignment such as LocalDSBMInfo = OtherAddrInfo
    */\n   Begin\n       update LocalDSBMInfo such as  IP addr, DSBM L2 address,\n
    \      DSBM priority, RefreshIntervalTimer, DSBMDeadIntervalTimer\n   End\n"
  title: A.10. Election State Machine
- contents:
  - "A.10.1 State Changes\n   In the following, the action \"continue\" or \"continue
    in current\n   state\" means an \"exit\" from the current action sequence without
    a\n   state transition.\n State:      DOWN\n Event:      StartUp\n New State:
    \ DetectDSBM\n Action:     Initialize the local state variables (LocalDSBMADDR
    and\n             LocalDSBMAddrInfo set to 0). Start the ListenIntervalTimer.\n
    State:      DetectDSBM\n New State:  Idle\n Event:      I_AM_DSBM message received\n
    Action:     set LocalDSBMAddrInfo = IncomingDSBMAddrInfo\n             start DeadDSBMInterval
    timer\n             goto Idle State\n State:      DetectDSBM\n Event:      ListenIntervalTimer
    fired\n New State:  ElectDSBM\n Action:     Start ElectionIntervalTimer\n             SendDSBMWillingMessage();\n
    State:      DetectDSBM\n Event:      DSBM_WILLING message received\n New State:
    \ ElectDSBM\n Action:     Cancel any active timers\n             Start ElectionIntervalTimer\n
    \            /* am I a better choice than this dude? */\n             If (ComparePrio(OwnAddrInfo,
    IncomingDSBMInfo)) {\n                 /* I am better */\n                 SendDSBMWillingMessage()\n
    \            } else {\n                 Change LocalDSBMAddrInfo = IncomingDSBMAddrInfo\n
    \                goto ElectDSBM state\n             }\n State:      Idle\n Event:
    \     DSBMDeadIntervalTimer fired.\n New State:  ElectDSBM\n Action:     start
    ElectionIntervalTimer\n             set LocalDSBMAddrInfo = OwnAddrInfo\n             SendDSBMWiliingMessage()\n
    State:      Idle\n Event:      I_AM_DSBM message received.\n New State:  Idle\n
    Action:     /* first check whether anything has changed */\n             if (!ComparePrio(LocalDSBMAddrInfo,
    IncomingDSBMAddrInfo))\n                 change LocalDSBMAddrInfo to reflect new
    info\n             endif\n             restart DSBMDeadIntervalTimer;\n             continue
    in current state;\n State:      Idle\n Event:      DSBM_WILLING Message is received\n
    New State:  Depends on action (ElectDSBM or Idle)\n Action:     /* check whether
    it is from the DSBM itself (shutdown) */\n             if (IncomingDSBMAddr ==
    LocalDSBMAddr) {\n                 cancel active timers\n                 Set
    LocalDSBMAddrInfo = OwnAddrInfo\n                 Start ElectionIntervalTimer\n
    \                SendDSBMWillingMessage() /* goto ElectDSBM state */\n             }\n
    \            /* else, ignore it */\n             continue in current state\n State:
    \     ElectDSBM\n Event:      ElectionIntervalTimer Fired\n New State:  depends
    on action (IAMDSBM or Current State)\n Action:     If (LocalDSBMAddrInfo == OwnAddrInfo)
    {\n                 /* I won */\n                 send I_AM_DSBM message\n                 start
    RefreshIntervalTimer\n                 goto IAMDSBM state\n             } else
    {   /* someone else won, so wait for it to declare\n                          itself
    to be the DSBM */\n                 set LocalDSBMAddressInfo = OwnAddrInfo\n                 start
    ElectionIntervalTimer\n                 SendDSBMWillingMessage()\n                 continue
    in current state\n             }\n State:      ElectDSBM\n Event:      I_AM_DSBM
    message received\n New State:  Idle\n Action:     set LocalDSBMAddrInfo = IncomingDSBMAddrInfo\n
    \            Cancel any active timers\n             start DeadDSBMInterval timer\n
    \            goto Idle State\n State:      ElectDSBM\n Event:      DSBM_WILLING
    message received\n New State:  ElectDSBM\n Action:     Check whether it's a loopback
    and if so, discard, continue;\n             if (!AmIBetterDSBM(IncomingDSBMAddrInfo))
    {\n                 Change LocalDSBMAddrInfo = IncomingDSBMAddrInfo\n                 Cancel
    RefreshIntervalTimer\n             } else if (LocalDSBMAddrInfo == OwnAddrInfo)
    {\n                 SendDSBMWillingMessage()\n             }\n             continue
    in current state\n State:      ElectDSBM\n Event:      RefreshIntervalTimer fired\n
    New State:  ElectDSBM\n Action:     /* continue to send DSBMWilling messages until\n
    \              election interval ends */\n             SendDSBMWillingMessage()\n
    State:      IAMDSBM\n Event:      DSBM_WILLING message received\n New State:  depends
    on action (IAMDSBM or SteadyState)\n Action:     /* check whether other guy is
    better */\n             If (ComparePrio(OwnAddrInfo, IncomingAddrInfo))  {\n             /*
    I am better */\n                 send I_AM_DSBM message\n                 restart
    RefreshIntervalTimer\n                continue in current state\n             }
    else {\n                Set LocalDSBMAddrInfo = IncomingAddrInfo\n                cancel
    active timers\n                start DSBMDeadIntervalTimer\n                goto
    SteadyState\n             }\n State:      IAMDSBM\n Event:      RefreshIntervalTimer
    fired\n New State:  IAMDSBM\n Action:     send I_AM_DSBM message\n             restart
    RefreshIntervalTimer\n State:      IAMDSBM\n Event:      I_AM_DSBM message received\n
    New State:  depends on action (IAMDSBM or Idle)\n Action:     /* check whether
    other guy is better */\n             If (ComparePrio(OwnAddrInfo, IncomingAddrInfo))
    \ {\n                 /* I am better */\n                 send I_AM_DSBM message\n
    \                restart RefreshIntervalTimer\n                 continue in current
    state\n            } else {\n                 Set LocalDSBMAddrInfo = IncomingAddrInfo\n
    \                cancel active timers\n                 start DSBMDeadIntervalTimer\n
    \                goto Idle State\n           }\n State:      IAMDSBM\n Event:
    \     Want to shut myself down\n New State:  DOWN\n Action:     send DSBM_WILLING
    message with My address filled in, but\n             priority set to zero\n             goto
    Down State\n"
  title: A.10.1 State Changes
- contents:
  - "A.10.2 Suggested Values of Interval Timers\n   To avoid DSBM outages for long
    period, to ensure quick recovery from\n   DSBM failures, and to avoid timeout
    of PATH and RESV state at the\n   edge devices, we suggest  the following values
    for various timers.\n   Assuming that the RSVP implementations use a 30 second
    timeout for\n   PATH and RESV refreshes, we suggest that the RefreshIntervalTimer\n
    \  should be set to about 5 seconds with DSBMDeadIntervalTimer set to 15\n   seconds
    (K=3, K*RefreshInterval). The DetectDSBMTimer should be set\n   to a random value
    between (DSBMDeadIntervalTimer,\n   2*DSBMDeadIntervalTimer). The ElectionIntervalTimer
    should be set at\n   least to the value of DSBMDeadIntervalTimer to ensure that
    each SBM\n   has a chance to have its DSBM_WILLING message (sent every\n   RefreshInterval
    in ElectDSBM state) delivered to others.\n"
  title: A.10.2 Suggested Values of Interval Timers
- contents:
  - "A.10.3. Guidelines for Choice of Values for SBM_PRIORITY\n   Network administrators
    should configure SBM protocol entity at each\n   SBM-capable device with the device's
    \"SBM priority\" for each of the\n   interfaces attached to a managed segment.
    SBM_PRIORITY is an 8-bit,\n   unsigned integer value (in the range 0-255) with
    higher integer\n   values denoting higher priority. The value zero for an interface\n
    \  indicates that the SBM protocol entity on the device is not eligible\n   to
    be a DSBM for the segment attached to the interface.\n   A separate range of values
    is reserved for each type of SBM-capable\n   device to reflect the relative priority
    among different classes of\n   L2/L3 devices. L2 devices get higher priority followed
    by routers\n   followed by hosts. The priority values in the range of 128..255
    are\n   reserved for L2 devices, the values in the range of 64..127 are\n   reserved
    for routers, and values in the range of 1..63 are reserved\n   for hosts.\n"
  title: A.10.3. Guidelines for Choice of Values for SBM_PRIORITY
- contents:
  - "A.11. DSBM Election over switched links\n   The election algorithm works as described
    before in this case except\n   each SBM-capable L2 device restricts the scope
    of the election to its\n   local segment. As described in Section B.1 below, all
    messages\n   related to the DSBM election are sent to a special multicast address\n
    \  (AllSBMAddress). AllSBMAddress (its corresponding MAC multicast\n   address)
    is configured in the permanent database of SBM-capable,\n   layer 2 devices so
    that all frames with AllSBMAddress as the\n   destination address are not forwarded
    and instead directed to the SBM\n   management entity in those devices. Thus,
    a DSBM can be elected\n   separately on each point-to-point segment in a switched
    topology. For\n   example, in Figure 2, DSBM for \"segment A\" will be elected
    using the\n   election algorithm between R1 and S1 and none of the election-related\n
    \  messages on this segment will be forwarded by S1 beyond \"segment A\".\n   Similarly,
    a separate election will take place on each segment in\n   this topology.\n   When
    a switched segment is a half-duplex segment, two senders (one\n   sender at each
    end of the link) share the link. In this case, one of\n   the two senders will
    win the DSBM election and will be responsible\n   for managing the segment.\n
    \  If a switched segment is full-duplex, exactly one sender sends on the\n   link
    in each direction. In this case, either one or two DSBMs can\n   exist on such
    a managed segment. If a sender at each end wishes to\n   serve as a DSBM for that
    end, it can declare itself to be the DSBM by\n   sending out an I_AM_DSBM advertisement
    and start managing the\n   resources for the outgoing traffic over the segment.
    \ If one of the\n   two senders does not wish itself to be the DSBM, then the
    other DSBM\n   will not receive any DSBM advertisement from its peer and assume\n
    \  itself to be the DSBM for traffic traversing in both directions over\n   the
    managed segment.\n"
  title: A.11. DSBM Election over switched links
- contents:
  - "Appendix B  Message Encapsulation and Formats\n   To minimize changes to the
    existing RSVP implementations and to\n   ensure quick deployment of a SBM in conjunction
    with RSVP, all\n   communication to and from a DSBM will be performed using messages\n
    \  constructed using the current rules for RSVP message formats and raw\n   IP
    encapsulation. For more details on the RSVP message formats, refer\n   to the
    RSVP specification (RFC 2205).  No changes to the RSVP message\n   formats are
    proposed, but new message types and new L2-specific\n   objects are added to the
    RSVP message formats to accommodate DSBM-\n   related messages. These additions
    are described below.\n"
  title: Appendix B  Message Encapsulation and Formats
- contents:
  - "B.1 Message Addressing\n   For the purpose of DSBM election and detection, AllSBMAddress
    is used\n   as the destination address while sending out both DSBM_WILLING and\n
    \  I_AM_DSBM messages. A DSBM client first detects a managed segment by\n   listening
    to I_AM_DSBM advertisements and records the DSBMAddress\n   (unicast IP address
    of the DSBM).\n"
  title: B.1 Message Addressing
- contents:
  - "B.2. Message Sizes\n   Each message must occupy exactly one IP datagram. If it
    exceeds the\n   MTU, such a datagram will be fragmented by IP and reassembled
    at the\n   recipient node. This has a consequence that a single message may not\n
    \  exceed the maximum IP datagram size, approximately 64K bytes.\n"
  title: B.2. Message Sizes
- contents:
  - "B.3. RSVP-related Message Formats\n   All RSVP messages directed to and from
    a DSBM may contain various\n   RSVP objects defined in the RSVP specification
    and messages continue\n   to follow the formatting rules specified in the RSVP
    specification.\n   In addition, an RSVP implementation must also recognize new
    object\n   classes that are described below.\n"
  title: B.3. RSVP-related Message Formats
- contents:
  - "B.3.1. Object Formats\n   All objects are defined using the format specified
    in the RSVP\n   specification. Each object has a 32-bit header that contains length\n
    \  (of the object in bytes including the object header), the object\n   class
    number, and a C-Type. All unused fields should be set to zero\n   and ignored
    on receipt.\n"
  title: B.3.1. Object Formats
- contents:
  - "B.3.2. SBM Specific Objects\n   Note that the Class-Num values for the SBM specific
    objects\n   (LAN_NHOP, LAN_LOOPBACK, and RSVP_HOP_L2) are chosen from the\n   codespace
    10XXXXXX. This coding assures that non-SBM aware RSVP nodes\n   will ignore the
    objects without forwarding them or generating an\n   error message.\n   Within
    the SBM specific codespace, note the following interpretation\n   of the third
    most significant bit of the Class-Num:\n          a) Objects of the form 100XXXXX
    are to be silently\n             discarded by SBM nodes that do not recognize
    them.\n          b) Objects of the form 101XXXXX are to be silently\n             forwarded
    by SBM nodes that do not recognize them.\n"
  title: B.3.2. SBM Specific Objects
- contents:
  - "B.3.3. IEEE 802 Canonical Address Format\n   The 48-bit MAC Addresses used by
    IEEE 802 were originally defined in\n   terms of wire order transmission of bits
    in the source and\n   destination MAC address fields. The same wire order applied
    to both\n   Ethernet and Token Ring. Since the bit transmission order of Ethernet\n
    \  and Token Ring data differ - Ethernet octets are transmitted least\n   significant
    bit first, Token Ring most significant first - the\n   numeric values naturally
    associated with the same address on\n   different 802 media differ. To facilitate
    the communication of\n   address values in higher layer protocols which might
    span both token\n   ring and Ethernet attached systems connected by bridges, it
    was\n   necessary to define one reference format - the so called canonical\n   format
    for these addresses. Formally the canonical format defines the\n   value of the
    address, separate from the encoding rules used for\n   transmission. It comprises
    a sequence of octets derived from the\n   original wire order transmission bit
    order as follows. The least\n   significant bit of the first octet is the first
    bit transmitted, the\n   next least significant bit the second bit, and so on
    to the most\n   significant bit of the first octet being the 8th bit transmitted;
    the\n   least significant bit of the second octet is the 9th bit transmitted,\n
    \  and so on to the most significant bit of the sixth octet of the\n   canonical
    format being the last bit of the address transmitted.\n   This canonical format
    corresponds to the natural value of the address\n   octets for Ethernet. The actual
    transmission order or formal encoding\n   rules for addresses on media which do
    not transmit bit serially are\n   derived from the canonical format octet values.\n
    \  This document requires that all L2 addresses used in conjunction with\n   the
    SBM protocol be encoded in the canonical format as a sequence of\n   6 octets.
    In the following, we define the object formats for objects\n   that contain L2
    addresses that are based on the canonical\n   representation.\n"
  title: B.3.3. IEEE 802 Canonical Address Format
- contents:
  - "B.3.4. RSVP_HOP_L2 object\n   RSVP_HOP_L2 object uses object class = 161; it
    contains the L2\n   address of the previous hop L3 device in the IEEE Canonical
    address\n   format discussed above.\n   RSVP_HOP_L2 object: class = 161, C-Type
    represents the addressing\n   format used. In our case, C-Type=1 represents the
    IEEE Canonical\n   Address format.\n            0              1             2
    \                3\n   +---------------+---------------+---------------+----------------+\n
    \  |       Length                  |   161         |C-Type(addrtype)|\n   +---------------+---------------+---------------+----------------+\n
    \  |                  Variable length Opaque data                   |\n   +---------------+---------------+---------------+----------------+\n
    \  C-Type = 1 (IEEE Canonical Address format)\n   When C-Type=1, the object format
    is:\n           0               1               2               3\n   +---------------+---------------+---------------+---------------+\n
    \  |              12               |   161         |      1        |\n   +---------------+---------------+---------------+---------------+\n
    \  |             Octets 0-3 of the MAC address                     |\n   +---------------+---------------+---------------+---------------+\n
    \  |  Octets 4-5 of the MAC addr.  |   ///         |     ///       |\n   +---------------+---------------+---------------+---------------+\n
    \  /// -- unused (set to zero)\n"
  title: B.3.4. RSVP_HOP_L2 object
- contents:
  - "B.3.5. LAN_NHOP object\n   LAN_NHOP object represents two objects, namely, LAN_NHOP_L3
    address\n   object and LAN_NHOP_L2 address object.\n        <LAN_NHOP object>
    ::= <LAN_NHOP_L2 object> <LAN_NHOP_L3 object>\n   LAN_NHOP_L2 address object uses
    object class = 162 and uses the same\n   format (but different class number) as
    the RSVP_HOP_L2 object.  It\n   provides the L2 or MAC address of the next hop
    L3 device.\n           0               1               2               3\n   +---------------+---------------+---------------+----------------+\n
    \  |       Length                  |   162         |C-Type(addrtype)|\n   +---------------+---------------+---------------+----------------+\n
    \  |                  Variable length Opaque data                   |\n   +---------------+---------------+---------------+----------------+\n
    \  C-Type = 1 (IEEE 802 Canonical Address Format as defined below) See\n   the
    RSVP_HOP_L2 address object for more details.\n   LAN_NHOP_L3 object uses object
    class = 163 and gives the L3 or IP\n   address of the next hop L3 device.\n   LAN_NHOP_L3
    object: class = 163, C-Type specifies IPv4 or IPv6\n   address family used.\n
    \  IPv4 LAN_NHOP_L3 object: class =163, C-Type = 1\n   +---------------+---------------+---------------+---------------+\n
    \  |       Length = 8              |   163         |       1       |\n   +---------------+---------------+---------------+---------------+\n
    \  |               IPv4 NHOP address                               |\n   +---------------------------------------------------------------+\n
    \  IPv6 LAN_NHOP_L3 object: class =163, C-Type = 2\n   +---------------+---------------+---------------+---------------+\n
    \  |       Length = 20             |   163         |       2       |\n   +---------------+---------------+---------------+---------------+\n
    \  |               IPv6 NHOP address (16 bytes)                    |\n   +---------------------------------------------------------------+\n"
  title: B.3.5. LAN_NHOP object
- contents:
  - "B.3.6. LAN_LOOPBACK Object\n   The LAN_LOOPBACK object gives the IP address of
    the outgoing\n   interface for a PATH message and uses object class=164; both
    IPv4 and\n   IPv6 formats are specified.\n   IPv4 LAN_LOOPBACK object: class =
    164, C-Type = 1\n           0               1               2               3\n
    \  +---------------+---------------+---------------+---------------+\n   |       Length
    \                 |   164         |       1       |\n   +---------------+---------------+---------------+---------------+\n
    \  |                  IPV4 address of an interface                 |\n   +---------------+---------------+---------------+---------------+\n
    \  IPv6 LAN_LOOPBACK object: class = 164, C-Type = 2\n   +---------------+---------------+---------------+---------------+\n
    \  |       Length                  |   164         |       2       |\n   +---------------+---------------+---------------+---------------+\n
    \  |                                                               |\n   +                                                               +\n
    \  |                                                               |\n   +                  IPV6
    address of an interface                 +\n   |                                                               |\n
    \  +                                                               +\n   |                                                               |\n
    \  +---------------+---------------+---------------+---------------+\n"
  title: B.3.6. LAN_LOOPBACK Object
- contents:
  - "B.3.7. TCLASS Object\n   TCLASS object (traffic class based on IEEE 802.1p) uses
    \ object\n   class = 165.\n            0              1               2               3\n
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         Length
    \               |   165         |       1       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |    ///        |    ///        |  ///          | ///     | PV  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  Only  3 bits in data contain the user_priority value (PV).\n"
  title: B.3.7. TCLASS Object
- contents:
  - "B.4. RSVP PATH and PATH_TEAR Message Formats\n   As specified in the RSVP specification,
    a PATH and PATH_TEAR messages\n   contain the RSVP Common Header and the relevant
    RSVP objects.\n   For the RSVP Common Header, refer to the RSVP specification
    (RFC\n   2205). Enhancements to an RSVP_PATH message include additional\n   objects
    as specified below.\n   <PATH Message> ::= <RSVP Common Header> [<INTEGRITY>]\n
    \                  <RSVP_HOP_L2> <LAN_NHOP>\n                   <LAN_LOOPBACK>
    [<TCLASS>]  <SESSION><RSVP_HOP>\n                   <TIME_VALUES> [<POLICY DATA>]
    <sender descriptor>\n   <PATH_TEAR Message> ::= <RSVP Common Header> [<INTEGRITY>]\n
    \                  <LAN_LOOPBACK> <LAN_NHOP> <SESSION> <RSVP_HOP>\n                   [<sender
    descriptor>]\n   If the INTEGRITY object is present, it must immediately follow
    the\n   RSVP common header. L2-specific objects must always precede the\n   SESSION
    object.\n"
  title: B.4. RSVP PATH and PATH_TEAR Message Formats
- contents:
  - "B.5. RSVP RESV Message Format\n   As specified in the RSVP specification, an
    RSVP_RESV message contains\n   the RSVP Common Header and relevant RSVP objects.
    In addition, it may\n   contain an optional TCLASS object as described earlier.\n"
  title: B.5. RSVP RESV Message Format
- contents:
  - "B.6. Additional RSVP message types to handle SBM interactions\n   New RSVP message
    types are introduced to allow interactions between a\n   DSBM and an RSVP node
    (host/router) for the purpose of discovering\n   and binding to a DSBM. New RSVP
    message types needed are as follows:\n   RSVP Msg Type (8 bits)      Value\n   DSBM_WILLING
    \               66\n   I_AM_DSBM                   67\n   All SBM-specific messages
    are formatted as RSVP messages with an RSVP\n   common header followed by SBM-specific
    objects.\n   <SBMP_MESSAGE> ::= <SBMP common header> <SBM-specific objects>\n
    \  where <SBMP common header> ::= <RSVP common Header> [<INTEGRITY>]\n   For each
    SBM message type, there is a set of rules for the\n   permissible choice of object
    types. These rules are specified using\n   Backus-Naur Form (BNF) augmented with
    square brackets surrounding\n   optional sub-sequences. The BNF implies an order
    for the objects in a\n   message. However, in many (but not all) cases, object
    order makes no\n   logical difference. An implementation should create messages
    with the\n   objects in the order shown here, but accept the objects in any\n
    \  permissible order. Any exceptions to this rule will be pointed out in\n   the
    specific message formats.\n   DSBM_WILLING Message\n   <DSBM_WILLING message>
    ::= <SBM Common Header> <DSBM IP ADDRESS>\n                              <DSBM
    L2 address> <SBM PRIORITY>\n   I_AM_DSBM Message\n   <I_AM_DSBM> ::= <SBM Common
    Header> <DSBM IP ADDRESS> <DSBM L2 address>\n                              <SBM
    PRIORITY> <DSBM Timer Intervals>\n                              [<NON_RESV_SEND_LIMIT>]\n
    \  For compatibility reasons, receivers of the I_AM_DSBM message must be\n   prepared
    to receive additional objects of the Unknown Class type\n   [RFC-2205].\n   All
    I_AM_DSBM messages are multicast to the well known AllSBMAddress.\n   The default
    priority of a SBM is 1 and higher priority values\n   represent higher precedence.
    The priority value zero indicates that\n   the SBM is not eligible to be the DSBM.\n
    \  Relevant Objects\n   DSBM IP ADDRESS objects use object class = 42; IPv4 DSBM
    IP ADDRESS\n   object uses <Class=42, C-Type=1> and IPv6 DSBM IP ADDRESS object
    uses\n   <Class=42, C-Type=2>.\n   IPv4 DSBM IP ADDRESS object: class = 42, C-Type
    =1\n           0               1               2               3\n   +---------------+---------------+---------------+---------------+\n
    \  |                       IPv4 DSBM IP Address                    |\n   +---------------+---------------+---------------+---------------+\n
    \  IPv6 DSBM IP ADDRESS object: Class = 42, C-Type = 2\n   +---------------+---------------+---------------+---------------+\n
    \  |                                                               |\n   +                                                               +\n
    \  |                                                               |\n   +                       IPv6
    DSBM IP Address                    +\n   |                                                               |\n
    \  +                                                               +\n   |                                                               |\n
    \  +---------------+---------------+---------------+---------------+\n   <DSBM
    L2 address> Object is the same as <RSVP_HOP_L2> object with C-\n   Type = 1 for
    IEEE Canonical Address format.\n   <DSBM L2 address> ::= <RSVP_HOP_L2>\n   A SBM
    \ may omit this object by including a NULL L2 address object.\n   For C-Type=1
    (IEEE Canonical address format), such a version of the\n   L2 address object contains
    value zero in the six octets corresponding\n   to the MAC address (see section
    B.3.4 for the exact format).\n   SBM_PRIORITY Object: class = 43, C-Type =1\n
    \          0               1               2               3\n   +---------------+---------------+---------------+---------------+\n
    \  |   ///         |   ///         | ///           | SBM priority  |\n   +---------------+---------------+---------------+---------------+\n
    \  TIMER INTERVAL VALUES.\n   The two timer intervals, namely, DSBM Dead Interval
    and DSBM Refresh\n   Interval, are specified as integer values each in the range
    of 0..255\n   seconds. Both values are included in a single \"DSBM Timer Intervals\"\n
    \  object described below.\n   DSBM Timer Intervals Object: class = 44, C-Type
    =1\n   +---------------+---------------+---------------+----------------+\n   |
    \  ///        |   ///          | DeadInterval  | RefreshInterval|\n   +---------------+---------------+---------------+----------------+\n
    \  NON_RESV_SEND_LIMIT Object: class = 45, C-Type = 1\n       0       1       2
    \      3\n   +---------------+---------------+---------------+----------------+\n
    \  | NonResvSendLimit(limit on traffic allowed to send without RESV)|\n   |                                                                |\n
    \  +---------------+---------------+---------------+----------------+\n   <NonResvSendLimit>
    ::= <Intserv Sender_TSPEC object>\n   (class=12, C-Type =2)\n   The NON_RESV_SEND_LIMIT
    object specifies a per-flow limit on the\n   profile of traffic which a sending
    host is allowed to send onto a\n   managed segment without a valid RSVP reservation
    (see Appendix C for\n   further details on the usage of this object). The object
    contains the\n   NonResvSendLimit parameter.  This parameter is equivalent to
    the\n   Intserv SENDER_TSPEC (see RFC 2210 for contents and encoding rules).\n
    \  The SENDER_TSPEC includes five parameters which describe a traffic\n   profile
    (r, b, p, m and M). Sending hosts compare the SENDER_TSPEC\n   describing a sender
    traffic flow to the SENDER_TSPEC advertised by\n   the DSBM. If the SENDER_TSPEC
    of the traffic flow in question is less\n   than or equal to the SENDER_TSPEC
    advertised by the DSBM, it is\n   allowable to send traffic on the corresponding
    flow without a valid\n   RSVP reservation in place. Otherwise it is not.\n   The
    network administrator may configure the DSBM to disallow any sent\n   traffic
    in the absence of an RSVP reservation by configuring a\n   NonResvSendLimit in
    which r = 0, b = 0, p = 0, m = infinity and M =\n   0. Similarly the network administrator
    may allow any traffic to be\n   sent in the absence of an RSVP reservation by
    configuring a\n   NonResvSendLimit in which r = infinity, b = infinity, p = infinity,
    m\n   = 0 and M = infinity. Of course, any of these parameters may be set\n   to
    values between zero and infinity to advertise finite per-flow\n   limits.\n   The
    NON_RESV_SEND_LIMIT object is optional. Senders on a managed\n   segment should
    interpret the absence of the NON_RESV_SEND_LIMIT\n   object as equivalent to an
    infinitely large SENDER_TSPEC (it is\n   permissible to send any traffic profile
    in the absence of an RSVP\n   reservation).\n"
  title: B.6. Additional RSVP message types to handle SBM interactions
- contents:
  - "Appendix C The DSBM as a Source of Centralized Configuration Information\n   There
    are certain configuration parameters which it may be useful to\n   distribute
    to layer-3 senders on a managed segment. The DSBM may\n   serve as a centralized
    management point from which such parameters\n   can easily be distributed. In
    particular,  it is possible for the\n   network administrator configuring a DSBM
    to cause certain\n   configuration parameters to be distributed as objects appended
    to the\n   I_AM_DSBM messages. The following configuration object is defined at\n
    \  this time. Others may be defined in the future. See Appendix B for\n   further
    details regarding the NON_RESV_SEND_LIMIT object.\n"
  title: Appendix C The DSBM as a Source of Centralized Configuration Information
- contents:
  - "C.1. NON_RESV_SEND_LIMIT\n   As we QoS enable layer 2 segments, we expect an
    evolution from\n   subnets comprised of traditional shared segments (with no means
    of\n   traffic separation and no DSBM), to subnets comprised of dedicated\n   segments
    switched by sophisticated switches (with both DSBM and\n   802.1p traffic separation
    capability).\n   A set of intermediate configurations consists of a group of QoS\n
    \  enabled hosts sending onto a traditional shared segment. A layer-3\n   device
    (or a layer-2 device) acts as a DSBM for the shared segment,\n   but cannot enforce
    traffic separation. In such a configuration, the\n   DSBM can be configured to
    limit the number of reservations approved\n   for senders on the segment, but
    cannot prevent them from sending.  As\n   a result, senders may congest the segment
    even though a network\n   administrator has configured an appropriate limit for
    admission\n   control in the DSBM.\n   One solution to this problem which would
    give the network\n   administrator control over the segment, is to require applications\n
    \  (or operating systems on behalf of applications) not to send until\n   they
    have obtained a reservation. This is problematic as most\n   applications are
    used to sending as soon as they wish to and expect\n   to get whatever service
    quality the network is able to grant at that\n   time.  Furthermore, it may often
    be acceptable to allow certain\n   applications to send before a reservation is
    received. For example,\n   on a segment comprised of a single 10 Mbps ethernet
    and 10 hosts, it\n   may be acceptable to allow a 16 Kbps telephony stream to
    be\n   transmitted but not a 3 Mbps video stream.\n   A more pragmatic solution
    then, is to allow the network administrator\n   to set a per-flow limit on the
    amount of non-adaptive traffic which a\n   sender is allowed to generate on a
    managed segment in the absence of\n   a valid reservation. This limit is advertised
    by the DSBM and\n   received by sending hosts. An API on the sending host can
    then\n   approve or deny an application's QoS request based on the resources\n
    \  requested.\n   The NON_RESV_SEND_LIMIT object can be used to advertise a Flowspec\n
    \  which describes the shape of traffic that a sender is allowed to\n   generate
    on a managed segment when its RSVP reservation requests have\n   either not yet
    completed or have been rejected.\n"
  title: C.1. NON_RESV_SEND_LIMIT
- contents:
  - "ACKNOWLEDGEMENTS\n   Authors are grateful to Eric Crawley (Argon), Russ Fenger
    (Intel),\n   David Melman (Siemens), Ramesh Pabbati (Microsoft), Mick Seaman\n
    \  (3COM), Andrew Smith (Extreme Networks) for their constructive\n   comments
    on the SBM design and the earlier versions of this document.\n"
  - "6. Authors' Addresses\n   Raj Yavatkar\n   Intel Corporation\n   2111 N.E. 25th
    Avenue,\n   Hillsboro, OR 97124\n   USA\n   Phone: +1 503-264-9077\n   EMail:
    yavatkar@ibeam.intel.com\n   Don Hoffman\n   Teledesic Corporation\n   2300 Carillon
    Point\n   Kirkland, WA 98033\n   USA\n   Phone: +1 425-602-0000\n   Yoram Bernet\n
    \  Microsoft\n   1 Microsoft Way\n   Redmond, WA 98052\n   USA\n   Phone: +1 206
    936 9568\n   EMail: yoramb@microsoft.com\n   Fred Baker\n   Cisco Systems\n   519
    Lado Drive\n   Santa Barbara, California 93111\n   USA\n   Phone: +1 408 526 4257\n
    \  EMail: fred@cisco.com\n   Michael Speer\n   Sun Microsystems, Inc\n   901 San
    Antonio Road UMPK15-215\n   Palo Alto, CA 94303\n   Phone: +1 650-786-6368\n   EMail:
    speer@Eng.Sun.COM\n"
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: ACKNOWLEDGEMENTS
