- title: __initial_text__
  contents:
  - '      The VCDIFF Generic Differencing and Compression Data Format

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes VCDIFF, a general, efficient and portable data\n\
    \   format suitable for encoding compressed and/or differencing data so\n   that\
    \ they can be easily transported among computers.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n    1.  Executive Summary ...........................................\
    \  2\n    2.  Conventions .................................................  4\n\
    \    3.  Delta Instructions ..........................................  5\n  \
    \  4.  Delta File Organization .....................................  6\n    5.\
    \  Delta Instruction Encoding .................................. 12\n    6.  Decoding\
    \ a Target Window .................................... 20\n    7.  Application-Defined\
    \ Code Tables ............................. 21\n    8.  Performance .................................................\
    \ 22\n    9.  Further Issues .............................................. 24\n\
    \   10.  Summary ..................................................... 25\n  \
    \ 11.  Acknowledgements ............................................ 25\n   12.\
    \  Security Considerations ..................................... 25\n   13.  Source\
    \ Code Availability .................................... 25\n   14.  Intellectual\
    \ Property Rights ................................ 26\n   15.  IANA Considerations\
    \ ......................................... 26\n   16.  References ..................................................\
    \ 26\n   17.  Authors' Addresses .......................................... 28\n\
    \   18.  Full Copyright Statement .................................... 29\n"
- title: 1.  Executive Summary
  contents:
  - "1.  Executive Summary\n   Compression and differencing techniques can greatly\
    \ improve storage\n   and transmission of files and file versions.  Since files\
    \ are often\n   transported across machines with distinct architectures and\n\
    \   performance characteristics, such data should be encoded in a form\n   that\
    \ is portable and can be decoded with little or no knowledge of\n   the encoders.\
    \  This document describes Vcdiff, a compact portable\n   encoding format designed\
    \ for these purposes.\n   Data differencing is the process of computing a compact\
    \ and\n   invertible encoding of a \"target file\" given a \"source file\".  Data\n\
    \   compression is similar, but without the use of source data.  The UNIX\n  \
    \ utilities diff, compress, and gzip are well-known examples of data\n   differencing\
    \ and compression tools.  For data differencing, the\n   computed encoding is\
    \ called a \"delta file\", and for data compression,\n   it is called a \"compressed\
    \ file\".  Delta and compressed files are\n   good for storage and transmission\
    \ as they are often smaller than the\n   originals.\n   Data differencing and\
    \ data compression are traditionally treated as\n   distinct types of data processing.\
    \  However, as shown in the Vdelta\n   technique by Korn and Vo [1], compression\
    \ can be thought of as a\n   special case of differencing in which the source\
    \ data is empty.  The\n   basic idea is to unify the string parsing scheme used\
    \ in the Lempel-\n   Ziv'77 (LZ'77) style compressors [2] and the block-move technique\
    \ of\n   Tichy [3].  Loosely speaking, this works as follows:\n      a. Concatenate\
    \ source and target data.\n      b. Parse the data from left to right as in LZ'77\
    \ but make sure\n         that a parsed segment starts the target data.\n    \
    \  c. Start to output when reaching target data.\n   Parsing is based on string\
    \ matching algorithms, such as suffix trees\n   [4] or hashing with different\
    \ time and space performance\n   characteristics.  Vdelta uses a fast string matching\
    \ algorithm that\n   requires less memory than other techniques [5,6].  However,\
    \ even with\n   this algorithm, the memory requirement can still be prohibitive\
    \ for\n   large files.  A common way to deal with memory limitation is to\n  \
    \ partition an input file into chunks called \"windows\" and process them\n  \
    \ separately.  Here, except for unpublished work by Vo, little has been\n   done\
    \ on designing effective windowing schemes.  Current techniques,\n   including\
    \ Vdelta, simply use source and target windows with\n   corresponding addresses\
    \ across source and target files.\n   String matching and windowing algorithms\
    \ have great influence on the\n   compression rate of delta and compressed files.\
    \  However, it is\n   desirable to have a portable encoding format that is independent\
    \ of\n   such algorithms.  This enables the construction of client-server\n  \
    \ applications in which a server may serve clients with unknown\n   computing\
    \ characteristics.  Unfortunately, all current differencing\n   and compressing\
    \ tools, including Vdelta, fall short in this respect.\n   Their storage formats\
    \ are closely intertwined with the implemented\n   string matching and/or windowing\
    \ algorithms.\n   The encoding format Vcdiff proposed here addresses the above\
    \ issues.\n   Vcdiff achieves the characteristics below:\n      Output compactness:\n\
    \         The basic encoding format compactly represents compressed or\n     \
    \    delta files.  Applications can further extend the basic\n         encoding\
    \ format with \"secondary encoders\" to achieve more\n         compression.\n\
    \      Data portability:\n         The basic encoding format is free from machine\
    \ byte order and\n         word size issues.  This allows data to be encoded on\
    \ one\n         machine and decoded on a different machine with different\n  \
    \       architecture.\n      Algorithm genericity:\n         The decoding algorithm\
    \ is independent from string matching and\n         windowing algorithms.  This\
    \ allows competition among\n         implementations of the encoder while keeping\
    \ the same decoder.\n      Decoding efficiency:\n         Except for secondary\
    \ encoder issues, the decoding algorithm\n         runs in time proportionate\
    \ to the size of the target file and\n         uses space proportionate to the\
    \ maximal window size.  Vcdiff\n         differs from more conventional compressors\
    \ in that it uses only\n         byte-aligned data, thus avoiding bit-level operations,\
    \ which\n         improves decoding speed at the slight cost of compression\n\
    \         efficiency.\n   The combined differencing and compression method is\
    \ called \"delta\n   compression\" [14].  As this way of data processing treats\
    \ compression\n   as a special case of differencing, we shall use the term \"\
    delta file\"\n   to indicate the compressed output for both cases.\n"
- title: 2. Conventions
  contents:
  - "2. Conventions\n   The basic data unit is a byte.  For portability, Vcdiff shall\
    \ limit a\n   byte to its lower eight bits even on machines with larger bytes.\
    \  The\n   bits in a byte are ordered from right to left so that the least\n \
    \  significant bit (LSB) has value 1, and the most significant bit\n   (MSB),\
    \ has value 128.\n   For purposes of exposition in this document, we adopt the\
    \ convention\n   that the LSB is numbered 0, and the MSB is numbered 7.  Bit numbers\n\
    \   never appear in the encoded format itself.\n   Vcdiff encodes unsigned integer\
    \ values using a portable, variable-\n   sized format (originally introduced in\
    \ the Sfio library [7]).  This\n   encoding treats an integer as a number in base\
    \ 128.  Then, each digit\n   in this representation is encoded in the lower seven\
    \ bits of a byte.\n   Except for the least significant byte, other bytes have\
    \ their most\n   significant bit turned on to indicate that there are still more\n\
    \   digits in the encoding.  The two key properties of this integer\n   encoding\
    \ that are beneficial to a data compression format are:\n      a. The encoding\
    \ is portable among systems using 8-bit bytes, and\n      b. Small values are\
    \ encoded compactly.\n   For example, consider the value 123456789, which can\
    \ be represented\n   with four 7-bit digits whose values are 58, 111, 26, 21 in\
    \ order from\n   most to least significant.  Below is the 8-bit byte encoding\
    \ of these\n   digits.  Note that the MSBs of 58, 111 and 26 are on.\n       \
    \       +-------------------------------------------+\n              | 10111010\
    \ | 11101111 | 10011010 | 00010101 |\n              +-------------------------------------------+\n\
    \                MSB+58     MSB+111    MSB+26     0+21\n   Henceforth, the terms\
    \ \"byte\" and \"integer\" will refer to a byte and\n   an unsigned integer as\
    \ described.\n   Algorithms in the C language are occasionally exhibited to clarify\n\
    \   the descriptions.  Such C code is meant for clarification only, and\n   is\
    \ not part of the actual specification of the Vcdiff format.\n   The key words\
    \ \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\"\
    , \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document\
    \ are to be interpreted as described in BCP 14, RFC 2119 [12].\n"
- title: 3.  Delta Instructions
  contents:
  - "3.  Delta Instructions\n   A large target file is partitioned into non-overlapping\
    \ sections\n   called \"target windows\".  These target windows are processed\n\
    \   separately and sequentially based on their order in the target file.\n   A\
    \ target window T, of length t, may be compared against some source\n   data segment\
    \ S, of length s.  By construction, this source data\n   segment S comes either\
    \ from the source file, if one is used, or from\n   a part of the target file\
    \ earlier than T.  In this way, during\n   decoding, S is completely known when\
    \ T is being decoded.\n   The choices of T, t, S and s are made by some window\
    \ selection\n   algorithm, which can greatly affect the size of the encoding.\n\
    \   However, as seen later, these choices are encoded so that no\n   knowledge\
    \ of the window selection algorithm is needed during\n   decoding.\n   Assume\
    \ that S[j] represents the jth byte in S, and T[k] represents\n   the kth byte\
    \ in T.  Then, for the delta instructions, we treat the\n   data windows S and\
    \ T as substrings of a superstring U, formed by\n   concatenating them like this:\n\
    \         S[0]S[1]...S[s-1]T[0]T[1]...T[t-1]\n   The \"address\" of a byte in\
    \ S or T is referred to by its location in\n   U.  For example, the address of\
    \ T[k] is s+k.\n   The instructions to encode and direct the reconstruction of\
    \ a target\n   window are called delta instructions.  There are three types:\n\
    \      ADD:  This instruction has two arguments, a size x and a sequence\n   \
    \         of x bytes to be copied.\n      COPY: This instruction has two arguments,\
    \ a size x and an address\n            p in the string U.  The arguments specify\
    \ the substring of U\n            that must be copied.  We shall assert that such\
    \ a substring\n            must be entirely contained in either S or T.\n    \
    \  RUN:  This instruction has two arguments, a size x and a byte b,\n        \
    \    that will be repeated x times.\n   Below are example source and target windows\
    \ and the delta\n   instructions that encode the target window in terms of the\
    \ source\n   window.\n         a b c d e f g h i j k l m n o p\n         a b c\
    \ d w x y z e f g h e f g h e f g h e f g h z z z z\n         COPY  4, 0\n   \
    \      ADD   4, w x y z\n         COPY  4, 4\n         COPY 12, 24\n         RUN\
    \   4, z\n   Thus, the first letter 'a' in the target window is at location 16\
    \ in\n   the superstring.  Note that the fourth instruction, \"COPY 12, 24\",\n\
    \   copies data from T itself since address 24 is position 8 in T.  This\n   instruction\
    \ also shows that it is fine to overlap the data to be\n   copied with the data\
    \ being copied from, as long as the latter starts\n   earlier.  This enables efficient\
    \ encoding of periodic sequences,\n   i.e., sequences with regularly repeated\
    \ subsequences.  The RUN\n   instruction is a compact way to encode a sequence\
    \ repeating the same\n   byte even though such a sequence can be thought of as\
    \ a periodic\n   sequence with period 1.\n   To reconstruct the target window,\
    \ one simply processes one delta\n   instruction at a time and copies the data,\
    \ either from the source\n   window or the target window being reconstructed,\
    \ based on the type of\n   the instruction and the associated address, if any.\n"
- title: 4.  Delta File Organization
  contents:
  - "4.  Delta File Organization\n   A Vcdiff delta file starts with a Header section\
    \ followed by a\n   sequence of Window sections.  The Header section includes\
    \ magic bytes\n   to identify the file type, and information concerning data processing\n\
    \   beyond the basic encoding format.  The Window sections encode the\n   target\
    \ windows.\n   Below is the overall organization of a delta file.  The indented\n\
    \   items refine the ones immediately above them.  An item in square\n   brackets\
    \ may or may not be present in the file depending on the\n   information encoded\
    \ in the Indicator byte above it.\n      Header\n          Header1           \
    \                       - byte\n          Header2                            \
    \      - byte\n          Header3                                  - byte\n   \
    \       Header4                                  - byte\n          Hdr_Indicator\
    \                            - byte\n          [Secondary compressor ID]     \
    \           - byte\n          [Length of code table data]              - integer\n\
    \          [Code table data]\n              Size of near cache               \
    \    - byte\n              Size of same cache                   - byte\n     \
    \         Compressed code table data\n      Window1\n          Win_Indicator \
    \                           - byte\n          [Source segment size]          \
    \          - integer\n          [Source segment position]                - integer\n\
    \          The delta encoding of the target window\n              Length of the\
    \ delta encoding         - integer\n              The delta encoding\n       \
    \           Size of the target window        - integer\n                  Delta_Indicator\
    \                  - byte\n                  Length of data for ADDs and RUNs\
    \ - integer\n                  Length of instructions and sizes - integer\n  \
    \                Length of addresses for COPYs    - integer\n                \
    \  Data section for ADDs and RUNs   - array of bytes\n                  Instructions\
    \ and sizes section   - array of bytes\n                  Addresses section for\
    \ COPYs      - array of bytes\n      Window2\n      ...\n"
- title: 4.1 The Header Section
  contents:
  - "4.1 The Header Section\n   Each delta file starts with a header section organized\
    \ as below.\n   Note the convention that square-brackets enclose optional items.\n\
    \         Header1                                  - byte = 0xD6\n         Header2\
    \                                  - byte = 0xC3\n         Header3           \
    \                       - byte = 0xC4\n         Header4                      \
    \            - byte\n         Hdr_Indicator                            - byte\n\
    \         [Secondary compressor ID]                - byte\n         [Length of\
    \ code table data]              - integer\n         [Code table data]\n   The\
    \ first three Header bytes are the ASCII characters 'V', 'C' and\n   'D' with\
    \ their most significant bits turned on (in hexadecimal, the\n   values are 0xD6,\
    \ 0xC3, and 0xC4).  The fourth Header byte is\n   currently set to zero.  In the\
    \ future, it might be used to indicate\n   the version of Vcdiff.\n   The Hdr_Indicator\
    \ byte shows if there is any initialization data\n   required to aid in the reconstruction\
    \ of data in the Window sections.\n   This byte MAY have non-zero values for either,\
    \ both, or neither of\n   the two bits VCD_DECOMPRESS and VCD_CODETABLE below:\n\
    \       7 6 5 4 3 2 1 0\n      +-+-+-+-+-+-+-+-+\n      | | | | | | | | |\n  \
    \    +-+-+-+-+-+-+-+-+\n                   ^ ^\n                   | |\n     \
    \              | +-- VCD_DECOMPRESS\n                   +---- VCD_CODETABLE\n\
    \   If bit 0 (VCD_DECOMPRESS) is non-zero, this indicates that a\n   secondary\
    \ compressor may have been used to further compress certain\n   parts of the delta\
    \ encoding data as described in Sections 4.3 and 6.\n   In that case, the ID of\
    \ the secondary compressor is given next.  If\n   this bit is zero, the compressor\
    \ ID byte is not included.\n   If bit 1 (VCD_CODETABLE) is non-zero, this indicates\
    \ that an\n   application-defined code table is to be used for decoding the delta\n\
    \   instructions.  This table itself is compressed.  The length of the\n   data\
    \ comprising this compressed code table and the data follow next.\n   Section\
    \ 7 discusses application-defined code tables.  If this bit is\n   zero, the code\
    \ table data length and the code table data are not\n   included.\n   If both\
    \ bits are set, then the compressor ID byte is included before\n   the code table\
    \ data length and the code table data.\n"
- title: 4.2 The Format of a Window Section
  contents:
  - "4.2 The Format of a Window Section\n   Each Window section is organized as follows:\n\
    \      Win_Indicator                            - byte\n      [Source segment\
    \ length]                  - integer\n      [Source segment position]        \
    \        - integer\n      The delta encoding of the target window\n   Below are\
    \ the details of the various items:\n      Win_Indicator:\n          This byte\
    \ is a set of bits, as shown:\n          7 6 5 4 3 2 1 0\n         +-+-+-+-+-+-+-+-+\n\
    \         | | | | | | | | |\n         +-+-+-+-+-+-+-+-+\n                    \
    \  ^ ^\n                      | |\n                      | +-- VCD_SOURCE\n  \
    \                    +---- VCD_TARGET\n         If bit 0 (VCD_SOURCE) is non-zero,\
    \ this indicates that a\n         segment of data from the \"source\" file was\
    \ used as the\n         corresponding source window of data to encode the target\n\
    \         window.  The decoder will use this same source data segment to\n   \
    \      decode the target window.\n         If bit 1 (VCD_TARGET) is non-zero,\
    \ this indicates that a\n         segment of data from the \"target\" file was\
    \ used as the\n         corresponding source window of data to encode the target\n\
    \         window.  As above, this same source data segment is used to\n      \
    \   decode the target window.\n         The Win_Indicator byte MUST NOT have more\
    \ than one of the bits\n         set (non-zero).  It MAY have none of these bits\
    \ set.\n         If one of these bits is set, the byte is followed by two\n  \
    \       integers to indicate respectively, the length and position of\n      \
    \   the source data segment in the relevant file.  If the indicator\n        \
    \ byte is zero, the target window was compressed by itself\n         without comparing\
    \ against another data segment, and these two\n         integers are not included.\n\
    \      The delta encoding of the target window:\n         This contains the delta\
    \ encoding of the target window, either\n         in terms of the source data\
    \ segment (i.e., VCD_SOURCE or\n         VCD_TARGET was set) or by itself if no\
    \ source window is\n         specified.  This data format is discussed next.\n"
- title: 4.3 The Delta Encoding of a Target Window
  contents:
  - "4.3 The Delta Encoding of a Target Window\n   The delta encoding of a target\
    \ window is organized as follows:\n      Length of the delta encoding        \
    \    - integer\n      The delta encoding\n          Length of the target window\
    \         - integer\n          Delta_Indicator                     - byte\n  \
    \        Length of data for ADDs and RUNs    - integer\n          Length of instructions\
    \ section      - integer\n          Length of addresses for COPYs       - integer\n\
    \          Data section for ADDs and RUNs      - array of bytes\n          Instructions\
    \ and sizes section      - array of bytes\n          Addresses section for COPYs\
    \         - array of bytes\n         Length of the delta encoding:\n         \
    \   This integer gives the total number of remaining bytes that\n            comprise\
    \ the data of the delta encoding for this target\n            window.\n      \
    \   The delta encoding:\n            This contains the data representing the delta\
    \ encoding which\n            is described next.\n         Length of the target\
    \ window:\n            This integer indicates the actual size of the target window\n\
    \            after decompression.  A decoder can use this value to\n         \
    \   allocate memory to store the uncompressed data.\n         Delta_Indicator:\n\
    \            This byte is a set of bits, as shown:\n          7 6 5 4 3 2 1 0\n\
    \         +-+-+-+-+-+-+-+-+\n         | | | | | | | | |\n         +-+-+-+-+-+-+-+-+\n\
    \                    ^ ^ ^\n                    | | |\n                    | |\
    \ +-- VCD_DATACOMP\n                    | +---- VCD_INSTCOMP\n               \
    \     +------ VCD_ADDRCOMP\n              VCD_DATACOMP:   bit value 1.\n     \
    \         VCD_INSTCOMP:   bit value 2.\n              VCD_ADDRCOMP:   bit value\
    \ 4.\n         As discussed, the delta encoding consists of COPY, ADD and RUN\n\
    \         instructions.  The ADD and RUN instructions have accompanying\n    \
    \     unmatched data (that is, data that does not specifically match\n       \
    \  any data in the source window or in some earlier part of the\n         target\
    \ window) and the COPY instructions have addresses of\n         where the matches\
    \ occur.  OPTIONALLY, these types of data MAY\n         be further compressed\
    \ using a secondary compressor.  Thus,\n         Vcdiff separates the encoding\
    \ of the delta instructions into\n         three parts:\n            a. The unmatched\
    \ data in the ADD and RUN instructions,\n            b. The delta instructions\
    \ and accompanying sizes, and\n            c. The addresses of the COPY instructions.\n\
    \         If the bit VCD_DECOMPRESS (Section 4.1) was on, each of these\n    \
    \     sections may have been compressed using the specified secondary\n      \
    \   compressor.  The bit positions 0 (VCD_DATACOMP), 1\n         (VCD_INSTCOMP),\
    \ and 2 (VCD_ADDRCOMP) respectively indicate, if\n         non-zero, that the\
    \ corresponding parts are compressed.  Then,\n         these parts MUST be decompressed\
    \ before decoding the delta\n         instructions.\n      Length of data for\
    \ ADDs and RUNs:\n         This is the length (in bytes) of the section of data\
    \ storing\n         the unmatched data accompanying the ADD and RUN instructions.\n\
    \      Length of instructions section:\n         This is the length (in bytes)\
    \ of the delta instructions and\n         accompanying sizes.\n      Length of\
    \ addresses for COPYs:\n         This is the length (in bytes) of the section\
    \ storing the\n         addresses of the COPY instructions.\n      Data section\
    \ for ADDs and RUNs:\n         This sequence of bytes encodes the unmatched data\
    \ for the ADD\n         and RUN instructions.\n      Instructions and sizes section:\n\
    \         This sequence of bytes encodes the instructions and their\n        \
    \ sizes.\n      Addresses section for COPYs:\n         This sequence of bytes\
    \ encodes the addresses of the COPY\n         instructions.\n"
- title: 5. Delta Instruction Encoding
  contents:
  - "5. Delta Instruction Encoding\n   The delta instructions described in Section\
    \ 3 represent the results\n   of string matching.  For many data differencing\
    \ applications in which\n   the changes between source and target data are small,\
    \ any\n   straightforward representation of these instructions would be\n   adequate.\
    \  However, for applications including differencing of binary\n   files or data\
    \ compression, it is important to encode these\n   instructions well to achieve\
    \ good compression rates.  The keys to\n   this achievement is to efficiently\
    \ encode the addresses of COPY\n   instructions and the sizes of all delta instructions.\n"
- title: 5.1 Address Encoding Modes of COPY Instructions
  contents:
  - "5.1 Address Encoding Modes of COPY Instructions\n   Addresses of COPY instructions\
    \ are locations of matches and often\n   occur close by or even exactly equal\
    \ to one another.  This is because\n   data in local regions are often replicated\
    \ with minor changes.  In\n   turn, this means that coding a newly matched address\
    \ against some\n   recently matched addresses can be beneficial.  To take advantage\
    \ of\n   this phenomenon and encode addresses of COPY instructions more\n   efficiently,\
    \ the Vcdiff data format supports the use of two different\n   types of address\
    \ caches.  Both the encoder and decoder maintain these\n   caches, so that decoder's\
    \ caches remain synchronized with the\n   encoder's caches.\n   a. A \"near\"\
    \ cache is an array with \"s_near\" slots, each containing an\n      address used\
    \ for encoding addresses nearby to previously encoded\n      addresses (in the\
    \ positive direction only).  The near cache also\n      maintains a \"next_slot\"\
    \ index to the near cache.  New entries to\n      the near cache are always inserted\
    \ in the next_slot index, which\n      maintains a circular buffer of the s_near\
    \ most recent addresses.\n   b. A \"same\" cache is an array with \"s_same\",\
    \ with a multiple of 256\n      slots, each containing an address.  The same cache\
    \ maintains a\n      hash table of recent addresses used for repeated encoding\
    \ of the\n      exact same address.\n   By default, the parameters s_near and\
    \ s_same are respectively set to\n   4 and 3.  An encoder MAY modify these values,\
    \ but then it MUST encode\n   the new values in the encoding itself, as discussed\
    \ in Section 7, so\n   that the decoder can properly set up its own caches.\n\
    \   At the start of processing a target window, an implementation\n   (encoder\
    \ or decoder) initializes all of the slots in both caches to\n   zero.  The next_slot\
    \ pointer of the near cache is set to point to\n   slot zero.\n   Each time a\
    \ COPY instruction is processed by the encoder or decoder,\n   the implementation's\
    \ caches are updated as follows, where \"addr\" is\n   the address in the COPY\
    \ instruction.\n   a. The slot in the near cache referenced by the next_slot index\
    \ is\n      set to addr.  The next_slot index is then incremented modulo\n   \
    \   s_near.\n   b. The slot in the same cache whose index is addr%(s_same*256)\
    \ is set\n      to addr.  [We use the C notations of % for modulo and * for\n\
    \      multiplication.]\n"
- title: 5.2 Example code for maintaining caches
  contents:
  - "5.2 Example code for maintaining caches\n   To make clear the above description,\
    \ below are examples of cache data\n   structures and algorithms to initialize\
    \ and update them:\n   typedef struct _cache_s\n   {\n       int*  near;     \
    \ /* array of size s_near        */\n       int   s_near;\n       int   next_slot;\
    \ /* the circular index for near */\n       int*  same;      /* array of size\
    \ s_same*256    */\n       int   s_same;\n   } Cache_t;\n   cache_init(Cache_t*\
    \ ka)\n   {\n       int   i;\n       ka->next_slot = 0;\n       for(i = 0; i <\
    \ ka->s_near; ++i)\n            ka->near[i] = 0;\n       for(i = 0; i < ka->s_same*256;\
    \ ++i)\n            ka->same[i] = 0;\n   }\n   cache_update(Cache_t* ka, int addr)\n\
    \   {\n       if(ka->s_near > 0)\n       {   ka->near[ka->next_slot] = addr;\n\
    \           ka->next_slot = (ka->next_slot + 1) % ka->s_near;\n       }\n    \
    \   if(ka->s_same > 0)\n           ka->same[addr % (ka->s_same*256)] = addr;\n\
    \   }\n"
- title: 5.3 Encoding of COPY instruction addresses
  contents:
  - "5.3 Encoding of COPY instruction addresses\n   The address of a COPY instruction\
    \ is encoded using different modes,\n   depending on the type of cached address\
    \ used, if any.\n   Let \"addr\" be the address of a COPY instruction to be decoded\
    \ and\n   \"here\" be the current location in the target data (i.e., the start\
    \ of\n   the data about to be encoded or decoded).  Let near[j] be the jth\n \
    \  element in the near cache, and same[k] be the kth element in the same\n   cache.\
    \  Below are the possible address modes:\n      VCD_SELF: This mode has value\
    \ 0.  The address was encoded by\n         itself as an integer.\n      VCD_HERE:\
    \ This mode has value 1.  The address was encoded as the\n         integer value\
    \ \"here - addr\".\n      Near modes: The \"near modes\" are in the range [2,s_near+1].\
    \  Let m\n         be the mode of the address encoding.  The address was encoded\n\
    \         as the integer value \"addr - near[m-2]\".\n      Same modes: The \"\
    same modes\" are in the range\n         [s_near+2,s_near+s_same+1].  Let m be\
    \ the mode of the encoding.\n         The address was encoded as a single byte\
    \ b such that \"addr ==\n         same[(m - (s_near+2))*256 + b]\".\n"
- title: 5.4 Example code for encoding and decoding of COPY instruction addresses
  contents:
  - "5.4 Example code for encoding and decoding of COPY instruction addresses\n  \
    \ We show example algorithms below to demonstrate the use of address\n   modes\
    \ more clearly.  The encoder has the freedom to choose address\n   modes, the\
    \ sample addr_encode() algorithm merely shows one way of\n   picking the address\
    \ mode.  The decoding algorithm addr_decode() will\n   uniquely decode addresses,\
    \ regardless of the encoder's algorithm\n   choice.\n   Note that the address\
    \ caches are updated immediately after an address\n   is encoded or decoded. \
    \ In this way, the decoder is always\n   synchronized with the encoder.\n   int\
    \ addr_encode(Cache_t* ka, int addr, int here, int* mode)\n   {\n       int  i,\
    \ d, bestd, bestm;\n       /* Attempt to find the address mode that yields the\n\
    \        * smallest integer value for \"d\", the encoded address\n        * value,\
    \ thereby minimizing the encoded size of the\n        * address. */\n       bestd\
    \ = addr; bestm = VCD_SELF;      /* VCD_SELF == 0 */\n       if((d = here-addr)\
    \ < bestd)\n           { bestd = d; bestm = VCD_HERE; } /* VCD_HERE == 1 */\n\
    \       for(i = 0; i < ka->s_near; ++i)\n           if((d = addr - ka->near[i])\
    \ >= 0 && d < bestd)\n               { bestd = d; bestm = i+2; }\n       if(ka->s_same\
    \ > 0 && ka->same[d = addr%(ka->s_same*256)] == addr)\n           { bestd = d%256;\
    \ bestm = ka->s_near + 2 + d/256; }\n       cache_update(ka,addr);\n       *mode\
    \ = bestm; /* this returns the address encoding mode */\n       return  bestd;\
    \ /* this returns the encoded address       */\n   }\n   Note that the addr_encode()\
    \ algorithm chooses the best address mode\n   using a local optimization, but\
    \ that may not lead to the best\n   encoding efficiency because different modes\
    \ lead to different\n   instruction encodings, as described below.\n   The functions\
    \ addrint() and addrbyte() used in addr_decode(), obtain\n   from the \"Addresses\
    \ section for COPYs\" (Section 4.3), an integer or a\n   byte, respectively. \
    \ These utilities will not be described here.  We\n   simply recall that an integer\
    \ is represented as a compact variable-\n   sized string of bytes, as described\
    \ in Section 2 (i.e., base 128).\n   int addr_decode(Cache_t* ka, int here, int\
    \ mode)\n   {   int  addr, m;\n       if(mode == VCD_SELF)\n            addr =\
    \ addrint();\n       else if(mode == VCD_HERE)\n            addr = here - addrint();\n\
    \       else if((m = mode - 2) >= 0 && m < ka->s_near) /* near cache */\n    \
    \        addr = ka->near[m] + addrint();\n       else /* same cache */\n     \
    \  {    m = mode - (2 + ka->s_near);\n            addr = ka->same[m*256 + addrbyte()];\n\
    \       }\n       cache_update(ka, addr);\n       return addr;\n   }\n"
- title: 5.4 Instruction Codes
  contents:
  - "5.4 Instruction Codes\n   Matches are often short in lengths and separated by\
    \ small amounts of\n   unmatched data.  That is, the lengths of COPY and ADD instructions\n\
    \   are often small.  This is particularly true of binary data such as\n   executable\
    \ files or structured data, such as HTML or XML.  In such\n   cases, compression\
    \ can be improved by combining the encoding of the\n   sizes and the instruction\
    \ types, as well as combining the encoding of\n   adjacent delta instructions\
    \ with sufficiently small data sizes.\n   Effective choices of when to perform\
    \ such combinations depend on many\n   factors including the data being processed\
    \ and the string matching\n   algorithm in use.  For example, if many COPY instructions\
    \ have the\n   same data sizes, it may be worthwhile to encode these instructions\n\
    \   more compactly than others.\n   The Vcdiff data format is designed so that\
    \ a decoder does not need to\n   be aware of the choices made in encoding algorithms.\
    \  This is\n   achieved with the notion of an \"instruction code table\", containing\n\
    \   256 entries.  Each entry defines, either a single delta instruction\n   or\
    \ a pair of instructions that have been combined.  Note that the\n   code table\
    \ itself only exists in main memory, not in the delta file\n   (unless using an\
    \ application-defined code table, described in Section\n   7).  The encoded data\
    \ simply includes the index of each instruction\n   and, since there are only\
    \ 256 indices, each index can be represented\n   as a single byte.\n   Each instruction\
    \ code entry contains six fields, each of which is a\n   single byte with an unsigned\
    \ value:\n          +-----------------------------------------------+\n      \
    \    | inst1 | size1 | mode1 | inst2 | size2 | mode2 |\n          +-----------------------------------------------+\n\
    \   Each triple (inst,size,mode) defines a delta instruction.  The\n   meanings\
    \ of these fields are as follows:\n      inst: An \"inst\" field can have one\
    \ of the four values: NOOP (0),\n            ADD (1), RUN (2) or COPY (3) to indicate\
    \ the instruction\n            types.  NOOP means that no instruction is specified.\
    \  In\n            this case, both the corresponding size and mode fields will\n\
    \            be zero.\n      size: A \"size\" field is zero or positive.  A value\
    \ zero means that\n            the size associated with the instruction is encoded\n\
    \            separately as an integer in the \"Instructions and sizes\n      \
    \      section\" (Section 6).  A positive value for \"size\" defines\n       \
    \     the actual data size.  Note that since the size is\n            restricted\
    \ to a byte, the maximum value for any instruction\n            with size implicitly\
    \ defined in the code table is 255.\n      mode: A \"mode\" field is significant\
    \ only when the associated delta\n            instruction is a COPY.  It defines\
    \ the mode used to encode\n            the associated addresses.  For other instructions,\
    \ this is\n            always zero.\n"
- title: 5.6 The Code Table
  contents:
  - "5.6 The Code Table\n   Following the discussions on address modes and instruction\
    \ code\n   tables, we define a \"Code Table\" to have the data below:\n      \
    \   s_near: the size of the near cache,\n         s_same: the size of the same\
    \ cache,\n         i_code: the 256-entry instruction code table.\n   Vcdiff itself\
    \ defines a \"default code table\" in which s_near is 4 and\n   s_same is 3. \
    \ Thus, there are 9 address modes for a COPY instruction.\n   The first two are\
    \ VCD_SELF (0) and VCD_HERE (1).  Modes 2, 3, 4 and 5\n   are for addresses coded\
    \ against the near cache.  And modes 6, 7  and\n   8, are for addresses coded\
    \ against the same cache.\n        TYPE      SIZE     MODE    TYPE     SIZE  \
    \   MODE     INDEX\n       ---------------------------------------------------------------\n\
    \    1.  RUN         0        0     NOOP       0        0        0\n    2.  ADD\
    \    0, [1,17]     0     NOOP       0        0      [1,18]\n    3.  COPY   0,\
    \ [4,18]     0     NOOP       0        0     [19,34]\n    4.  COPY   0, [4,18]\
    \     1     NOOP       0        0     [35,50]\n    5.  COPY   0, [4,18]     2\
    \     NOOP       0        0     [51,66]\n    6.  COPY   0, [4,18]     3     NOOP\
    \       0        0     [67,82]\n    7.  COPY   0, [4,18]     4     NOOP      \
    \ 0        0     [83,98]\n    8.  COPY   0, [4,18]     5     NOOP       0    \
    \    0     [99,114]\n    9.  COPY   0, [4,18]     6     NOOP       0        0\
    \    [115,130]\n   10.  COPY   0, [4,18]     7     NOOP       0        0    [131,146]\n\
    \   11.  COPY   0, [4,18]     8     NOOP       0        0    [147,162]\n   12.\
    \  ADD       [1,4]      0     COPY     [4,6]      0    [163,174]\n   13.  ADD\
    \       [1,4]      0     COPY     [4,6]      1    [175,186]\n   14.  ADD     \
    \  [1,4]      0     COPY     [4,6]      2    [187,198]\n   15.  ADD       [1,4]\
    \      0     COPY     [4,6]      3    [199,210]\n   16.  ADD       [1,4]     \
    \ 0     COPY     [4,6]      4    [211,222]\n   17.  ADD       [1,4]      0   \
    \  COPY     [4,6]      5    [223,234]\n   18.  ADD       [1,4]      0     COPY\
    \       4        6    [235,238]\n   19.  ADD       [1,4]      0     COPY     \
    \  4        7    [239,242]\n   20.  ADD       [1,4]      0     COPY       4  \
    \      8    [243,246]\n   21.  COPY        4      [0,8]   ADD        1       \
    \ 0    [247,255]\n       ---------------------------------------------------------------\n\
    \   The default instruction code table is depicted above, in a compact\n   representation\
    \ that we use only for descriptive purposes.  See\n   section 7 for the specification\
    \ of how an instruction code table is\n   represented in the Vcdiff encoding format.\
    \  In the depiction, a zero\n   value for size indicates that the size is separately\
    \ coded.  The mode\n   of non-COPY instructions is represented as 0, even though\
    \ they are\n   not used.\n   In the depiction, each numbered line represents one\
    \ or more entries\n   in the actual instruction code table (recall that an entry\
    \ in the\n   instruction code table may represent up to two combined delta\n \
    \  instructions.)  The last column (\"INDEX\") shows which index value, or\n \
    \  range of index values, of the entries are covered by that line.  (The\n   notation\
    \ [i,j] means values from i through j, inclusively.)  The\n   first 6 columns\
    \ of a line in the depiction, describe the pairs of\n   instructions used for\
    \ the corresponding index value(s).\n   If a line in the depiction includes a\
    \ column entry using the [i,j]\n   notation, this means that the line is instantiated\
    \ for each value in\n   the range from i to j, inclusively.  The notation \"0,\
    \ [i,j]\" means\n   that the line is instantiated for the value 0 and for each\
    \ value in\n   the range from i to j, inclusively.\n   If a line in the depiction\
    \ includes more than one entry using the\n   [i,j] notation, implying a \"nested\
    \ loop\" to convert the line to a\n   range of table entries, the first such [i,j]\
    \ range specifies the\n   outer loop, and the second specifies the inner loop.\n\
    \   The below examples should make clear the above description:\n   Line 1 shows\
    \ the single RUN instruction with index 0.  As the size\n   field is 0, this RUN\
    \ instruction always has its actual size encoded\n   separately.\n   Line 2 shows\
    \ the 18 single ADD instructions.  The ADD instruction\n   with size field 0 (i.e.,\
    \ the actual size is coded separately) has\n   index 1.  ADD instructions with\
    \ sizes from 1 to 17 use code indices 2\n   to 18 and their sizes are as given\
    \ (so they will not be separately\n   encoded.)\n   Following the single ADD instructions\
    \ are the single COPY\n   instructions ordered by their address encoding modes.\
    \  For example,\n   line 11 shows the COPY instructions with mode 8, i.e., the\
    \ last of\n   the same cache.  In this case, the COPY instruction with size field\
    \ 0\n   has index 147.  Again, the actual size of this instruction will be\n \
    \  coded separately.\n   Lines 12 to 21 show the pairs of instructions that are\
    \ combined\n   together.  For example, line 12 depicts the 12 entries in which\
    \ an\n   ADD instruction is combined with an immediately following COPY\n   instruction.\
    \  The entries with indices 163, 164, 165 represent the\n   pairs in which the\
    \ ADD instructions all have size 1, while the COPY\n   instructions have mode\
    \ 0 (VCD_SELF) and sizes 4, 5 and 6\n   respectively.\n   The last line, line\
    \ 21, shows the eight instruction pairs, where the\n   first instruction is a\
    \ COPY and the second is an ADD.  In this case,\n   all COPY instructions have\
    \ size 4 with mode ranging from 0 to 8 and\n   all the ADD instructions have size\
    \ 1.  Thus, the entry with the\n   largest index 255 combines a COPY instruction\
    \ of size 4 and mode 8\n   with an ADD instruction of size 1.\n   The choice of\
    \ the minimum size 4 for COPY instructions in the default\n   code table was made\
    \ from experiments that showed that excluding small\n   matches (less then 4 bytes\
    \ long) improved the compression rates.\n"
- title: 6. Decoding a Target Window
  contents:
  - "6. Decoding a Target Window\n   Section 4.3 discusses that the delta instructions\
    \ and associated data\n   are encoded in three arrays of bytes:\n         Data\
    \ section for ADDs and RUNs,\n         Instructions and sizes section, and\n \
    \        Addresses section for COPYs.\n   Further, these data sections may have\
    \ been further compressed by some\n   secondary compressor.  Assuming that any\
    \ such compressed data has\n   been decompressed so that we now have three arrays:\n\
    \         inst: bytes coding the instructions and sizes.\n         data: unmatched\
    \ data associated with ADDs and RUNs.\n         addr: bytes coding the addresses\
    \ of COPYs.\n   These arrays are organized as follows:\n      inst: a sequence\
    \ of (index, [size1], [size2]) tuples, where\n            \"index\" is an index\
    \ into the instruction code table, and\n            size1 and size2 are integers\
    \ that MAY or MAY NOT be included\n            in the tuple as follows.  The entry\
    \ with the given \"index\"\n            in the instruction code table potentially\
    \ defines two delta\n            instructions.  If the first delta instruction\
    \ is not a\n            VCD_NOOP and its size is zero, then size1 MUST be present.\n\
    \            Otherwise, size1 MUST be omitted and the size of the\n          \
    \  instruction (if it is not VCD_NOOP) is as defined in the\n            table.\
    \  The presence or absence of size2 is defined\n            similarly with respect\
    \ to the second delta instruction.\n      data: a sequence of data values, encoded\
    \ as bytes.\n      addr: a sequence of address values.  Addresses are normally\n\
    \            encoded as integers as described in Section 2 (i.e., base\n     \
    \       128).  However, since the same cache emits addresses in the\n        \
    \    range [0,255], same cache addresses are always encoded as a\n           \
    \ single byte.\n   To summarize, each tuple in the \"inst\" array includes an\
    \ index to\n   some entry in the instruction code table that determines:\n   a.\
    \ Whether one or two instructions were encoded and their types.\n   b. If the\
    \ instructions have their sizes encoded separately, these\n      sizes will follow,\
    \ in order, in the tuple.\n   c. If the instructions have accompanying data, i.e.,\
    \ ADDs or RUNs,\n      their data will be in the array \"data\".\n   d. Similarly,\
    \ if the instructions are COPYs, the coded addresses are\n      found in the array\
    \ \"addr\".\n   The decoding procedure simply processes the arrays by reading\
    \ one\n   code index at a time, looking up the corresponding instruction code\n\
    \   entry, then consuming the respective sizes, data and addresses\n   following\
    \ the directions in this entry.  In other words, the decoder\n   maintains an\
    \ implicit next-element pointer for each array;\n   \"consuming\" an instruction\
    \ tuple, data, or address value implies\n   incrementing the associated pointer.\n\
    \   For example, if during the processing of the target window, the next\n   unconsumed\
    \ tuple in the inst array has an index value of 19, then the\n   first instruction\
    \ is a COPY, whose size is found as the immediately\n   following integer in the\
    \ inst array.  Since the mode of this COPY\n   instruction is VCD_SELF, the corresponding\
    \ address is found by\n   consuming the next integer in the addr array.  The data\
    \ array is left\n   intact.  As the second instruction for code index 19 is a\
    \ NOOP, this\n   tuple is finished.\n"
- title: 7. APPLICATION-DEFINED CODE TABLES
  contents:
  - "7. APPLICATION-DEFINED CODE TABLES\n   Although the default code table used in\
    \ Vcdiff is good for general\n   purpose encoders, there are times when other\
    \ code tables may perform\n   better.  For example, to code a file with many identical\
    \ segments of\n   data, it may be advantageous to have a COPY instruction with\
    \ the\n   specific size of these data segments, so that the instruction can be\n\
    \   encoded in a single byte.  Such a special code table MUST then be\n   encoded\
    \ in the delta file so that the decoder can reconstruct it\n   before decoding\
    \ the data.\n   Vcdiff allows an application-defined code table to be specified\
    \ in a\n   delta file with the following data:\n         Size of near cache  \
    \          - byte\n         Size of same cache            - byte\n         Compressed\
    \ code table data\n   The \"compressed code table data\" encodes the delta between\
    \ the\n   default code table (source) and the new code table (target) in the\n\
    \   same manner as described in Section 4.3 for encoding a target window\n   in\
    \ terms of a source window.  This delta is computed using the\n   following steps:\n\
    \   a. Convert the new instruction code table into a string, \"code\", of\n  \
    \    1536 bytes using the below steps in order:\n       i. Add in order the 256\
    \ bytes representing the types of the first\n          instructions in the instruction\
    \ pairs.\n      ii. Add in order the 256 bytes representing the types of the\n\
    \          second instructions in the instruction pairs.\n     iii. Add in order\
    \ the 256 bytes representing the sizes of the first\n          instructions in\
    \ the instruction pairs.\n      iv. Add in order the 256 bytes representing the\
    \ sizes of the\n          second instructions in the instruction pairs.\n    \
    \   v. Add in order the 256 bytes representing the modes of the first\n      \
    \    instructions in the instruction pairs.\n      vi. Add in order the 256 bytes\
    \ representing the modes of the\n          second instructions in the instruction\
    \ pairs.\n   b. Similarly, convert the default code table into a string \"dflt\"\
    .\n   c. Treat the string \"code\" as a target window and \"dflt\" as the\n  \
    \    corresponding source data and apply an encoding algorithm to\n      compute\
    \ the delta encoding of \"code\" in terms of \"dflt\".  This\n      computation\
    \ MUST use the default code table for encoding the delta\n      instructions.\n\
    \   The decoder can then reverse the above steps to decode the compressed\n  \
    \ table data using the method of Section 6, employing the default code\n   table,\
    \ to generate the new code table.  Note that the decoder does\n   not need to\
    \ know about the details of the encoding algorithm used in\n   step (c).  It is\
    \ able to decode the new code table because the Vcdiff\n   format is independent\
    \ from the choice of encoding algorithm, and\n   because the encoder in step (c)\
    \ uses the known, default code table.\n"
- title: 8. Performance
  contents:
  - "8. Performance\n   The encoding format is compact.  For compression only, using\
    \ the LZ-\n   77 string parsing strategy and without any secondary compressors,\
    \ the\n   typical compression rate is better than Unix compress and close to\n\
    \   gzip.  For differencing, the data format is better than all known\n   methods\
    \ in terms of its stated goal, which is primarily decoding\n   speed and encoding\
    \ efficiency.\n   We compare the performance of compress, gzip and Vcdiff using\
    \ the\n   archives of three versions of the Gnu C compiler, gcc-2.95.1.tar,\n\
    \   gcc-2.95.2.tar and gcc-2.95.3.tar.  Gzip was used at its default\n   compression\
    \ level.  The Vcdiff data were obtained using the\n   Vcodex/Vcdiff software (Section\
    \ 13).\n   Below are the different Vcdiff runs:\n      Vcdiff: vcdiff is used\
    \ as a compressor only.\n      Vcdiff-d: vcdiff is used as a differencer only.\
    \  That is, it only\n         compares target data against source data.  Since\
    \ the files\n         involved are large, they are broken into windows.  In this\n\
    \         case, each target window, starting at some file offset in the\n    \
    \     target file, is compared against a source window with the same\n       \
    \  file offset (in the source file).  The source window is also\n         slightly\
    \ larger than the target window to increase matching\n         opportunities.\n\
    \      Vcdiff-dc: This is similar to Vcdiff-d, but vcdiff can also\n         compare\
    \ target data against target data as applicable.  Thus,\n         vcdiff both\
    \ computes differences and compresses data.  The\n         windowing algorithm\
    \ is the same as above.  However, the above\n         hint is recinded in this\
    \ case.\n      Vcdiff-dcw: This is similar to Vcdiff-dc but the windowing\n  \
    \       algorithm uses a content-based heuristic to select a source\n        \
    \ window that is more likely to match with a given target window.\n         Thus,\
    \ the source data segment selected for a target window\n         often will not\
    \ be aligned with the file offsets of this target\n         window.\n        \
    \               gcc-2.95.1     gcc-2.95.2     gcc-2.95.3\n      ---------------------------------------------------------\n\
    \      1. raw size      55,746,560     55,797,760     55,787,520\n      2. compress\
    \         -           19,939,390     19,939,453\n      3. gzip             - \
    \          12,973,443     12,998,097\n      4. Vcdiff           -           15,358,786\
    \     15,371,737\n      5. Vcdiff-d         -              100,971     26,383,849\n\
    \      6. Vcdiff-dc        -               97,246     14,461,203\n      7. Vcdiff-dcw\
    \       -              256,445      1,248,543\n   The above table shows the raw\
    \ sizes of the tar files and the sizes of\n   the compressed results.  The differencing\
    \ results in the gcc-2.95.2\n   column were obtained by compressing gcc-2.95.2,\
    \ given gcc-2.95.1.\n   The same results for the column gcc-2.95.3 were obtained\
    \ by\n   compressing gcc-2.95.3, given gcc-2.95.2.\n   Rows 2, 3 and 4 show that,\
    \ for compression only, the compression rate\n   from Vcdiff is worse than gzip\
    \ and better than compress.\n   The last three rows in the column gcc-2.95.2 show\
    \ that when two file\n   versions are very similar, differencing can give dramatically\
    \ good\n   compression rates.  Vcdiff-d and Vcdiff-dc use the same simple window\n\
    \   selection method of aligning by file offsets, but Vcdiff-dc also does\n  \
    \ compression so its output is slightly smaller.  Vcdiff-dcw uses a\n   content-based\
    \ algorithm to search for source data that likely will\n   match a given target\
    \ window.  Although it does a good job, the\n   algorithm does not always find\
    \ the best matches, which in this case,\n   are given by the simple algorithm\
    \ of Vcdiff-d.  As a result, the\n   output size for Vcdiff-dcw is slightly larger.\n\
    \   The situation is reversed in the gcc-2.95.3 column.  Here, the files\n   and\
    \ their contents were sufficiently rearranged or changed between\n   the making\
    \ of the gcc-2.95.3.tar archive and the gcc-2.95.2 archive\n   so that the simple\
    \ method of aligning windows by file offsets no\n   longer works.  As a result,\
    \ Vcdiff-d and Vcdiff-dc do not perform\n   well.  By allowing compression, along\
    \ with differencing, Vcdiff-dc\n   manages to beat Vcdiff-c, which does compression\
    \ only.  The content-\n   based window matching algorithm in Vcdiff-dcw is effective\
    \ in\n   matching the right source and target windows so that Vcdiff-dcw is\n\
    \   the overall winner.\n"
- title: 9. Further Issues
  contents:
  - "9. Further Issues\n   This document does not address a few issues:\n   Secondary\
    \ compressors:\n      As discussed in Section 4.3, certain sections in the delta\n\
    \      encoding of a window may be further compressed by a secondary\n      compressor.\
    \  In our experience, the basic Vcdiff format is\n      adequate for most purposes\
    \ so that secondary compressors are\n      seldom needed.  In particular, for\
    \ normal use of data\n      differencing, where the files to be compared have\
    \ long stretches\n      of matches, much of the gain in compression rate is already\n\
    \      achieved by normal string matching.  Thus, the use of secondary\n     \
    \ compressors is seldom needed in this case.  However, for\n      applications\
    \ beyond differencing of such nearly identical files,\n      secondary compressors\
    \ may be needed to achieve maximal compressed\n      results.\n      Therefore,\
    \ we recommend leaving the Vcdiff data format defined as\n      in this document\
    \ so that the use of secondary compressors can be\n      implemented when they\
    \ become needed in the future.  The formats of\n      the compressed data via\
    \ such compressors or any compressors that\n      may be defined in the future\
    \ are left open to their\n      implementations.  These could include Huffman\
    \ encoding, arithmetic\n      encoding, and splay tree encoding [8,9].\n   Large\
    \ file system vs. small file system:\n      As discussed in Section 4, a target\
    \ window in a large file may be\n      compared against some source window in\
    \ another file or in the same\n      file (from some earlier part).  In that case,\
    \ the file offset of\n      the source window is specified as a variable-sized\
    \ integer in the\n      delta encoding.  There is a possibility that the encoding\
    \ was\n      computed on a system supporting much larger files than in a system\n\
    \      where the data may be decoded (e.g., 64-bit file systems vs. 32-\n    \
    \  bit file systems).  In that case, some target data may not be\n      recoverable.\
    \  This problem could afflict any compression format,\n      and ought to be resolved\
    \ with a generic negotiation mechanism in\n      the appropriate protocol(s).\n"
- title: 10.  Summary
  contents:
  - "10.  Summary\n   We have described Vcdiff, a general and portable encoding format\
    \ for\n   compression and differencing.  The format is good in that it allows\n\
    \   implementing a decoder without knowledge of the encoders.  Further,\n   ignoring\
    \ the use of secondary compressors not defined within the\n   format, the decoding\
    \ algorithms run in linear time and requires\n   working space proportional to\
    \ window size.\n"
- title: 11. Acknowledgements
  contents:
  - "11. Acknowledgements\n   Thanks are due to Balachander Krishnamurthy, Jeff Mogul\
    \ and Arthur\n   Van Hoff who provided much encouragement to publicize Vcdiff.\
    \  In\n   particular, Jeff helped in clarifying the description of the data\n\
    \   format presented here.\n"
- title: 12. Security Considerations
  contents:
  - "12. Security Considerations\n   Vcdiff only provides a format to encode compressed\
    \ and differenced\n   data.  It does not address any issues concerning how such\
    \ data are,\n   in fact, stored in a given file system or the run-time memory\
    \ of a\n   computer system.  Therefore, we do not anticipate any security issues\n\
    \   with respect to Vcdiff.\n"
- title: 13. Source Code Availability
  contents:
  - "13. Source Code Availability\n   Vcdiff is implemented as a data transforming\
    \ method in Phong Vo's\n   Vcodex library.  AT&T Corp. has made the source code\
    \ for Vcodex\n   available for anyone to use to transmit data via HTTP/1.1 Delta\n\
    \   Encoding [10,11].  The source code and according license is\n   accessible\
    \ at the below URL:\n      http://www.research.att.com/sw/tools\n"
- title: 14. Intellectual Property Rights
  contents:
  - "14. Intellectual Property Rights\n   The IETF has been notified of intellectual\
    \ property rights claimed in\n   regard to some or all of the specification contained\
    \ in this\n   document.  For more information consult the online list of claimed\n\
    \   rights, at <http://www.ietf.org/ipr.html>.\n   The IETF takes no position\
    \ regarding the validity or scope of any\n   intellectual property or other rights\
    \ that might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP 11.  Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n"
- title: 15. IANA Considerations
  contents:
  - "15. IANA Considerations\n   The Internet Assigned Numbers Authority (IANA) administers\
    \ the number\n   space for Secondary Compressor ID values.  Values and their meaning\n\
    \   must be documented in an RFC or other peer-reviewed, permanent, and\n   readily\
    \ available reference, in sufficient detail so that\n   interoperability between\
    \ independent implementations is possible.\n   Subject to these constraints, name\
    \ assignments are First Come, First\n   Served - see RFC 2434 [13].  Legal ID\
    \ values are in the range 1..255.\n   This document does not define any values\
    \ in this number space.\n"
- title: 16. References
  contents:
  - "16. References\n   [1]  D.G. Korn and K.P. Vo, Vdelta: Differencing and Compression,\n\
    \        Practical Reusable Unix Software, Editor B. Krishnamurthy, John\n   \
    \     Wiley & Sons, Inc., 1995.\n   [2]  J. Ziv and A. Lempel, A Universal Algorithm\
    \ for Sequential Data\n        Compression, IEEE Trans. on Information Theory,\
    \ 23(3):337-343,\n        1977.\n   [3]  W. Tichy, The String-to-String Correction\
    \ Problem with Block\n        Moves, ACM Transactions on Computer Systems, 2(4):309-321,\n\
    \        November 1984.\n   [4]  E.M. McCreight, A Space-Economical Suffix Tree\
    \ Construction\n        Algorithm, Journal of the ACM, 23:262-272, 1976.\n   [5]\
    \  J.J. Hunt, K.P. Vo, W. Tichy, An Empirical Study of Delta\n        Algorithms,\
    \ IEEE Software Configuration and Maintenance\n        Workshop, 1996.\n   [6]\
    \  J.J. Hunt, K.P. Vo, W. Tichy, Delta Algorithms: An Empirical\n        Analysis,\
    \ ACM Trans. on Software Engineering and Methodology,\n        7:192-214, 1998.\n\
    \   [7]  D.G. Korn, K.P. Vo, Sfio: A buffered I/O Library, Proc. of the\n    \
    \    Summer '91 Usenix Conference, 1991.\n   [8]  D. W. Jones, Application of\
    \ Splay Trees to Data Compression,\n        CACM, 31(8):996:1007.\n   [9]  M.\
    \ Nelson, J. Gailly, The Data Compression Book, ISBN 1-55851-\n        434-1,\
    \ M&T Books, New York, NY, 1995.\n   [10] J.C. Mogul, F. Douglis, A. Feldmann,\
    \ and B. Krishnamurthy,\n        Potential benefits of delta encoding and data\
    \ compression for\n        HTTP, SIGCOMM '97, Cannes, France, 1997.\n   [11] Mogul,\
    \ J., Krishnamurthy, B., Douglis, F., Feldmann, A., Goland,\n        Y. and A.\
    \ Van Hoff, \"Delta Encoding in HTTP\", RFC 3229, January\n        2002.\n   [12]\
    \ Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n        Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [13] Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an IANA\n        Considerations Section in RFCs\", BCP 26, RFC 2434,\
    \ October 1998.\n   [14] D.G. Korn and K.P. Vo, Engineering a Differencing and\n\
    \        Compression Data Format, Submitted to Usenix'2002, 2001.\n"
- title: 17. Authors' Addresses
  contents:
  - "17. Authors' Addresses\n   Kiem-Phong Vo (main contact)\n   AT&T Labs, Room D223\n\
    \   180 Park Avenue\n   Florham Park, NJ 07932\n   Phone: 1 973 360 8630\n   EMail:\
    \ kpv@research.att.com\n   David G. Korn\n   AT&T Labs, Room D237\n   180 Park\
    \ Avenue\n   Florham Park, NJ 07932\n   Phone: 1 973 360 8602\n   EMail: dgk@research.att.com\n\
    \   Jeffrey C. Mogul\n   Western Research Laboratory\n   Hewlett-Packard Company\n\
    \   1501 Page Mill Road, MS 1251\n   Palo Alto, California, 94304, U.S.A.\n  \
    \ Phone: 1 650 857 2206 (email preferred)\n   EMail: JeffMogul@acm.org\n   Joshua\
    \ P. MacDonald\n   Computer Science Division\n   University of California, Berkeley\n\
    \   345 Soda Hall\n   Berkeley, CA 94720\n   EMail: jmacd@cs.berkeley.edu\n"
- title: 18.  Full Copyright Statement
  contents:
  - "18.  Full Copyright Statement\n   Copyright (C) The Internet Society (2002).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
