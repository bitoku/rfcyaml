- title: __initial_text__
  contents:
  - "                 DOMAIN NAMES - CONCEPTS AND FACILITIES\n1. STATUS OF THIS MEMO\n\
    This RFC is an introduction to the Domain Name System (DNS), and omits\nmany details\
    \ which can be found in a companion RFC, \"Domain Names -\nImplementation and\
    \ Specification\" [RFC-1035].  That RFC assumes that the\nreader is familiar with\
    \ the concepts discussed in this memo.\nA subset of DNS functions and data types\
    \ constitute an official\nprotocol.  The official protocol includes standard queries\
    \ and their\nresponses and most of the Internet class data formats (e.g., host\n\
    addresses).\nHowever, the domain system is intentionally extensible.  Researchers\
    \ are\ncontinuously proposing, implementing and experimenting with new data\n\
    types, query types, classes, functions, etc.  Thus while the components\nof the\
    \ official protocol are expected to stay essentially unchanged and\noperate as\
    \ a production service, experimental behavior should always be\nexpected in extensions\
    \ beyond the official protocol.  Experimental or\nobsolete features are clearly\
    \ marked in these RFCs, and such information\nshould be used with caution.\nThe\
    \ reader is especially cautioned not to depend on the values which\nappear in\
    \ examples to be current or complete, since their purpose is\nprimarily pedagogical.\
    \  Distribution of this memo is unlimited.\n2. INTRODUCTION\nThis RFC introduces\
    \ domain style names, their use for Internet mail and\nhost address support, and\
    \ the protocols and servers used to implement\ndomain name facilities.\n2.1. The\
    \ history of domain names\nThe impetus for the development of the domain system\
    \ was growth in the\nInternet:\n   - Host name to address mappings were maintained\
    \ by the Network\n     Information Center (NIC) in a single file (HOSTS.TXT) which\n\
    \     was FTPed by all hosts [RFC-952, RFC-953].  The total network\n     bandwidth\
    \ consumed in distributing a new version by this\n     scheme is proportional\
    \ to the square of the number of hosts in\n     the network, and even when multiple\
    \ levels of FTP are used,\n     the outgoing FTP load on the NIC host is considerable.\n\
    \     Explosive growth in the number of hosts didn't bode well for\n     the future.\n\
    \   - The network population was also changing in character.  The\n     timeshared\
    \ hosts that made up the original ARPANET were being\n     replaced with local\
    \ networks of workstations.  Local\n     organizations were administering their\
    \ own names and\n     addresses, but had to wait for the NIC to change HOSTS.TXT\
    \ to\n     make changes visible to the Internet at large.  Organizations\n   \
    \  also wanted some local structure on the name space.\n   - The applications\
    \ on the Internet were getting more\n     sophisticated and creating a need for\
    \ general purpose name\n     service.\nThe result was several ideas about name\
    \ spaces and their management\n[IEN-116, RFC-799, RFC-819, RFC-830].  The proposals\
    \ varied, but a\ncommon thread was the idea of a hierarchical name space, with\
    \ the\nhierarchy roughly corresponding to organizational structure, and names\n\
    using \".\"  as the character to mark the boundary between hierarchy\nlevels.\
    \  A design using a distributed database and generalized resources\nwas described\
    \ in [RFC-882, RFC-883].  Based on experience with several\nimplementations, the\
    \ system evolved into the scheme described in this\nmemo.\nThe terms \"domain\"\
    \ or \"domain name\" are used in many contexts beyond the\nDNS described here.\
    \  Very often, the term domain name is used to refer\nto a name with structure\
    \ indicated by dots, but no relation to the DNS.\nThis is particularly true in\
    \ mail addressing [Quarterman 86].\n2.2. DNS design goals\nThe design goals of\
    \ the DNS influence its structure.  They are:\n   - The primary goal is a consistent\
    \ name space which will be used\n     for referring to resources.  In order to\
    \ avoid the problems\n     caused by ad hoc encodings, names should not be required\
    \ to\n     contain network identifiers, addresses, routes, or similar\n     information\
    \ as part of the name.\n   - The sheer size of the database and frequency of updates\n\
    \     suggest that it must be maintained in a distributed manner,\n     with local\
    \ caching to improve performance.  Approaches that\n     attempt to collect a\
    \ consistent copy of the entire database\n     will become more and more expensive\
    \ and difficult, and hence\n     should be avoided.  The same principle holds\
    \ for the structure\n     of the name space, and in particular mechanisms for\
    \ creating\n     and deleting names; these should also be distributed.\n   - Where\
    \ there tradeoffs between the cost of acquiring data, the\n     speed of updates,\
    \ and the accuracy of caches, the source of\n     the data should control the\
    \ tradeoff.\n   - The costs of implementing such a facility dictate that it be\n\
    \     generally useful, and not restricted to a single application.\n     We should\
    \ be able to use names to retrieve host addresses,\n     mailbox data, and other\
    \ as yet undetermined information.  All\n     data associated with a name is tagged\
    \ with a type, and queries\n     can be limited to a single type.\n   - Because\
    \ we want the name space to be useful in dissimilar\n     networks and applications,\
    \ we provide the ability to use the\n     same name space with different protocol\
    \ families or\n     management.  For example, host address formats differ between\n\
    \     protocols, though all protocols have the notion of address.\n     The DNS\
    \ tags all data with a class as well as the type, so\n     that we can allow parallel\
    \ use of different formats for data\n     of type address.\n   - We want name\
    \ server transactions to be independent of the\n     communications system that\
    \ carries them.  Some systems may\n     wish to use datagrams for queries and\
    \ responses, and only\n     establish virtual circuits for transactions that need\
    \ the\n     reliability (e.g., database updates, long transactions); other\n \
    \    systems will use virtual circuits exclusively.\n   - The system should be\
    \ useful across a wide spectrum of host\n     capabilities.  Both personal computers\
    \ and large timeshared\n     hosts should be able to use the system, though perhaps\
    \ in\n     different ways.\n2.3. Assumptions about usage\nThe organization of\
    \ the domain system derives from some assumptions\nabout the needs and usage patterns\
    \ of its user community and is designed\nto avoid many of the the complicated\
    \ problems found in general purpose\ndatabase systems.\nThe assumptions are:\n\
    \   - The size of the total database will initially be proportional\n     to the\
    \ number of hosts using the system, but will eventually\n     grow to be proportional\
    \ to the number of users on those hosts\n     as mailboxes and other information\
    \ are added to the domain\n     system.\n   - Most of the data in the system will\
    \ change very slowly (e.g.,\n     mailbox bindings, host addresses), but that\
    \ the system should\n     be able to deal with subsets that change more rapidly\
    \ (on the\n     order of seconds or minutes).\n   - The administrative boundaries\
    \ used to distribute\n     responsibility for the database will usually correspond\
    \ to\n     organizations that have one or more hosts.  Each organization\n   \
    \  that has responsibility for a particular set of domains will\n     provide\
    \ redundant name servers, either on the organization's\n     own hosts or other\
    \ hosts that the organization arranges to\n     use.\n   - Clients of the domain\
    \ system should be able to identify\n     trusted name servers they prefer to\
    \ use before accepting\n     referrals to name servers outside of this \"trusted\"\
    \ set.\n   - Access to information is more critical than instantaneous\n     updates\
    \ or guarantees of consistency.  Hence the update\n     process allows updates\
    \ to percolate out through the users of\n     the domain system rather than guaranteeing\
    \ that all copies are\n     simultaneously updated.  When updates are unavailable\
    \ due to\n     network or host failure, the usual course is to believe old\n \
    \    information while continuing efforts to update it.  The\n     general model\
    \ is that copies are distributed with timeouts for\n     refreshing.  The distributor\
    \ sets the timeout value and the\n     recipient of the distribution is responsible\
    \ for performing\n     the refresh.  In special situations, very short intervals\
    \ can\n     be specified, or the owner can prohibit copies.\n   - In any system\
    \ that has a distributed database, a particular\n     name server may be presented\
    \ with a query that can only be\n     answered by some other server.  The two\
    \ general approaches to\n     dealing with this problem are \"recursive\", in\
    \ which the first\n     server pursues the query for the client at another server,\
    \ and\n     \"iterative\", in which the server refers the client to another\n\
    \     server and lets the client pursue the query.  Both approaches\n     have\
    \ advantages and disadvantages, but the iterative approach\n     is preferred\
    \ for the datagram style of access.  The domain\n     system requires implementation\
    \ of the iterative approach, but\n     allows the recursive approach as an option.\n\
    The domain system assumes that all data originates in master files\nscattered\
    \ through the hosts that use the domain system.  These master\nfiles are updated\
    \ by local system administrators.  Master files are text\nfiles that are read\
    \ by a local name server, and hence become available\nthrough the name servers\
    \ to users of the domain system.  The user\nprograms access name servers through\
    \ standard programs called resolvers.\nThe standard format of master files allows\
    \ them to be exchanged between\nhosts (via FTP, mail, or some other mechanism);\
    \ this facility is useful\nwhen an organization wants a domain, but doesn't want\
    \ to support a name\nserver.  The organization can maintain the master files locally\
    \ using a\ntext editor, transfer them to a foreign host which runs a name server,\n\
    and then arrange with the system administrator of the name server to get\nthe\
    \ files loaded.\nEach host's name servers and resolvers are configured by a local\
    \ system\nadministrator [RFC-1033].  For a name server, this configuration data\n\
    includes the identity of local master files and instructions on which\nnon-local\
    \ master files are to be loaded from foreign servers.  The name\nserver uses the\
    \ master files or copies to load its zones.  For\nresolvers, the configuration\
    \ data identifies the name servers which\nshould be the primary sources of information.\n\
    The domain system defines procedures for accessing the data and for\nreferrals\
    \ to other name servers.  The domain system also defines\nprocedures for caching\
    \ retrieved data and for periodic refreshing of\ndata defined by the system administrator.\n\
    The system administrators provide:\n   - The definition of zone boundaries.\n\
    \   - Master files of data.\n   - Updates to master files.\n   - Statements of\
    \ the refresh policies desired.\nThe domain system provides:\n   - Standard formats\
    \ for resource data.\n   - Standard methods for querying the database.\n   - Standard\
    \ methods for name servers to refresh local data from\n     foreign name servers.\n\
    2.4. Elements of the DNS\nThe DNS has three major components:\n   - The DOMAIN\
    \ NAME SPACE and RESOURCE RECORDS, which are\n     specifications for a tree structured\
    \ name space and data\n     associated with the names.  Conceptually, each node\
    \ and leaf\n     of the domain name space tree names a set of information, and\n\
    \     query operations are attempts to extract specific types of\n     information\
    \ from a particular set.  A query names the domain\n     name of interest and\
    \ describes the type of resource\n     information that is desired.  For example,\
    \ the Internet\n     uses some of its domain names to identify hosts; queries\
    \ for\n     address resources return Internet host addresses.\n   - NAME SERVERS\
    \ are server programs which hold information about\n     the domain tree's structure\
    \ and set information.  A name\n     server may cache structure or set information\
    \ about any part\n     of the domain tree, but in general a particular name server\n\
    \     has complete information about a subset of the domain space,\n     and pointers\
    \ to other name servers that can be used to lead to\n     information from any\
    \ part of the domain tree.  Name servers\n     know the parts of the domain tree\
    \ for which they have complete\n     information; a name server is said to be\
    \ an AUTHORITY for\n     these parts of the name space.  Authoritative information\
    \ is\n     organized into units called ZONEs, and these zones can be\n     automatically\
    \ distributed to the name servers which provide\n     redundant service for the\
    \ data in a zone.\n   - RESOLVERS are programs that extract information from name\n\
    \     servers in response to client requests.  Resolvers must be\n     able to\
    \ access at least one name server and use that name\n     server's information\
    \ to answer a query directly, or pursue the\n     query using referrals to other\
    \ name servers.  A resolver will\n     typically be a system routine that is directly\
    \ accessible to\n     user programs; hence no protocol is necessary between the\n\
    \     resolver and the user program.\nThese three components roughly correspond\
    \ to the three layers or views\nof the domain system:\n   - From the user's point\
    \ of view, the domain system is accessed\n     through a simple procedure or OS\
    \ call to a local resolver.\n     The domain space consists of a single tree and\
    \ the user can\n     request information from any section of the tree.\n   - From\
    \ the resolver's point of view, the domain system is\n     composed of an unknown\
    \ number of name servers.  Each name\n     server has one or more pieces of the\
    \ whole domain tree's data,\n     but the resolver views each of these databases\
    \ as essentially\n     static.\n   - From a name server's point of view, the domain\
    \ system consists\n     of separate sets of local information called zones.  The\
    \ name\n     server has local copies of some of the zones.  The name server\n\
    \     must periodically refresh its zones from master copies in\n     local files\
    \ or foreign name servers.  The name server must\n     concurrently process queries\
    \ that arrive from resolvers.\nIn the interests of performance, implementations\
    \ may couple these\nfunctions.  For example, a resolver on the same machine as\
    \ a name server\nmight share a database consisting of the the zones managed by\
    \ the name\nserver and the cache managed by the resolver.\n3. DOMAIN NAME SPACE\
    \ and RESOURCE RECORDS\n3.1. Name space specifications and terminology\nThe domain\
    \ name space is a tree structure.  Each node and leaf on the\ntree corresponds\
    \ to a resource set (which may be empty).  The domain\nsystem makes no distinctions\
    \ between the uses of the interior nodes and\nleaves, and this memo uses the term\
    \ \"node\" to refer to both.\nEach node has a label, which is zero to 63 octets\
    \ in length.  Brother\nnodes may not have the same label, although the same label\
    \ can be used\nfor nodes which are not brothers.  One label is reserved, and that\
    \ is\nthe null (i.e., zero length) label used for the root.\nThe domain name of\
    \ a node is the list of the labels on the path from the\nnode to the root of the\
    \ tree.  By convention, the labels that compose a\ndomain name are printed or\
    \ read left to right, from the most specific\n(lowest, farthest from the root)\
    \ to the least specific (highest, closest\nto the root).\nInternally, programs\
    \ that manipulate domain names should represent them\nas sequences of labels,\
    \ where each label is a length octet followed by\nan octet string.  Because all\
    \ domain names end at the root, which has a\nnull string for a label, these internal\
    \ representations can use a length\nbyte of zero to terminate a domain name.\n\
    By convention, domain names can be stored with arbitrary case, but\ndomain name\
    \ comparisons for all present domain functions are done in a\ncase-insensitive\
    \ manner, assuming an ASCII character set, and a high\norder zero bit.  This means\
    \ that you are free to create a node with\nlabel \"A\" or a node with label \"\
    a\", but not both as brothers; you could\nrefer to either using \"a\" or \"A\"\
    .  When you receive a domain name or\nlabel, you should preserve its case.  The\
    \ rationale for this choice is\nthat we may someday need to add full binary domain\
    \ names for new\nservices; existing services would not be changed.\nWhen a user\
    \ needs to type a domain name, the length of each label is\nomitted and the labels\
    \ are separated by dots (\".\").  Since a complete\ndomain name ends with the\
    \ root label, this leads to a printed form which\nends in a dot.  We use this\
    \ property to distinguish between:\n   - a character string which represents a\
    \ complete domain name\n     (often called \"absolute\").  For example, \"poneria.ISI.EDU.\"\
    \n   - a character string that represents the starting labels of a\n     domain\
    \ name which is incomplete, and should be completed by\n     local software using\
    \ knowledge of the local domain (often\n     called \"relative\").  For example,\
    \ \"poneria\" used in the\n     ISI.EDU domain.\nRelative names are either taken\
    \ relative to a well known origin, or to a\nlist of domains used as a search list.\
    \  Relative names appear mostly at\nthe user interface, where their interpretation\
    \ varies from\nimplementation to implementation, and in master files, where they\
    \ are\nrelative to a single origin domain name.  The most common interpretation\n\
    uses the root \".\" as either the single origin or as one of the members\nof the\
    \ search list, so a multi-label relative name is often one where\nthe trailing\
    \ dot has been omitted to save typing.\nTo simplify implementations, the total\
    \ number of octets that represent a\ndomain name (i.e., the sum of all label octets\
    \ and label lengths) is\nlimited to 255.\nA domain is identified by a domain name,\
    \ and consists of that part of\nthe domain name space that is at or below the\
    \ domain name which\nspecifies the domain.  A domain is a subdomain of another\
    \ domain if it\nis contained within that domain.  This relationship can be tested\
    \ by\nseeing if the subdomain's name ends with the containing domain's name.\n\
    For example, A.B.C.D is a subdomain of B.C.D, C.D, D, and \" \".\n3.2. Administrative\
    \ guidelines on use\nAs a matter of policy, the DNS technical specifications do\
    \ not mandate a\nparticular tree structure or rules for selecting labels; its\
    \ goal is to\nbe as general as possible, so that it can be used to build arbitrary\n\
    applications.  In particular, the system was designed so that the name\nspace\
    \ did not have to be organized along the lines of network\nboundaries, name servers,\
    \ etc.  The rationale for this is not that the\nname space should have no implied\
    \ semantics, but rather that the choice\nof implied semantics should be left open\
    \ to be used for the problem at\nhand, and that different parts of the tree can\
    \ have different implied\nsemantics.  For example, the IN-ADDR.ARPA domain is\
    \ organized and\ndistributed by network and host address because its role is to\
    \ translate\nfrom network or host numbers to names; NetBIOS domains [RFC-1001,\
    \ RFC-\n1002] are flat because that is appropriate for that application.\nHowever,\
    \ there are some guidelines that apply to the \"normal\" parts of\nthe name space\
    \ used for hosts, mailboxes, etc., that will make the name\nspace more uniform,\
    \ provide for growth, and minimize problems as\nsoftware is converted from the\
    \ older host table.  The political\ndecisions about the top levels of the tree\
    \ originated in RFC-920.\nCurrent policy for the top levels is discussed in [RFC-1032].\
    \  MILNET\nconversion issues are covered in [RFC-1031].\nLower domains which will\
    \ eventually be broken into multiple zones should\nprovide branching at the top\
    \ of the domain so that the eventual\ndecomposition can be done without renaming.\
    \  Node labels which use\nspecial characters, leading digits, etc., are likely\
    \ to break older\nsoftware which depends on more restrictive choices.\n3.3. Technical\
    \ guidelines on use\nBefore the DNS can be used to hold naming information for\
    \ some kind of\nobject, two needs must be met:\n   - A convention for mapping\
    \ between object names and domain\n     names.  This describes how information\
    \ about an object is\n     accessed.\n   - RR types and data formats for describing\
    \ the object.\nThese rules can be quite simple or fairly complex.  Very often,\
    \ the\ndesigner must take into account existing formats and plan for upward\n\
    compatibility for existing usage.  Multiple mappings or levels of\nmapping may\
    \ be required.\nFor hosts, the mapping depends on the existing syntax for host\
    \ names\nwhich is a subset of the usual text representation for domain names,\n\
    together with RR formats for describing host addresses, etc.  Because we\nneed\
    \ a reliable inverse mapping from address to host name, a special\nmapping for\
    \ addresses into the IN-ADDR.ARPA domain is also defined.\nFor mailboxes, the\
    \ mapping is slightly more complex.  The usual mail\naddress <local-part>@<mail-domain>\
    \ is mapped into a domain name by\nconverting <local-part> into a single label\
    \ (regardles of dots it\ncontains), converting <mail-domain> into a domain name\
    \ using the usual\ntext format for domain names (dots denote label breaks), and\n\
    concatenating the two to form a single domain name.  Thus the mailbox\nHOSTMASTER@SRI-NIC.ARPA\
    \ is represented as a domain name by\nHOSTMASTER.SRI-NIC.ARPA.  An appreciation\
    \ for the reasons behind this\ndesign also must take into account the scheme for\
    \ mail exchanges [RFC-\n974].\nThe typical user is not concerned with defining\
    \ these rules, but should\nunderstand that they usually are the result of numerous\
    \ compromises\nbetween desires for upward compatibility with old usage, interactions\n\
    between different object definitions, and the inevitable urge to add new\nfeatures\
    \ when defining the rules.  The way the DNS is used to support\nsome object is\
    \ often more crucial than the restrictions inherent in the\nDNS.\n3.4. Example\
    \ name space\nThe following figure shows a part of the current domain name space,\
    \ and\nis used in many examples in this RFC.  Note that the tree is a very\nsmall\
    \ subset of the actual name space.\n                                   |\n   \
    \                                |\n             +---------------------+------------------+\n\
    \             |                     |                  |\n            MIL    \
    \               EDU                ARPA\n             |                     |\
    \                  |\n             |                     |                  |\n\
    \       +-----+-----+               |     +------+-----+-----+\n       |     |\
    \     |               |     |      |           |\n      BRL  NOSC  DARPA     \
    \        |  IN-ADDR  SRI-NIC     ACC\n                                   |\n \
    \      +--------+------------------+---------------+--------+\n       |      \
    \  |                  |               |        |\n      UCI      MIT         \
    \        |              UDEL     YALE\n                |                 ISI\n\
    \                |                  |\n            +---+---+              |\n\
    \            |       |              |\n           LCS  ACHILLES  +--+-----+-----+--------+\n\
    \            |             |  |     |     |        |\n            XX         \
    \   A  C   VAXA  VENERA Mockapetris\nIn this example, the root domain has three\
    \ immediate subdomains: MIL,\nEDU, and ARPA.  The LCS.MIT.EDU domain has one immediate\
    \ subdomain named\nXX.LCS.MIT.EDU.  All of the leaves are also domains.\n3.5.\
    \ Preferred name syntax\nThe DNS specifications attempt to be as general as possible\
    \ in the rules\nfor constructing domain names.  The idea is that the name of any\n\
    existing object can be expressed as a domain name with minimal changes.\nHowever,\
    \ when assigning a domain name for an object, the prudent user\nwill select a\
    \ name which satisfies both the rules of the domain system\nand any existing rules\
    \ for the object, whether these rules are published\nor implied by existing programs.\n\
    For example, when naming a mail domain, the user should satisfy both the\nrules\
    \ of this memo and those in RFC-822.  When creating a new host name,\nthe old\
    \ rules for HOSTS.TXT should be followed.  This avoids problems\nwhen old software\
    \ is converted to use domain names.\nThe following syntax will result in fewer\
    \ problems with many\napplications that use domain names (e.g., mail, TELNET).\n\
    <domain> ::= <subdomain> | \" \"\n<subdomain> ::= <label> | <subdomain> \".\"\
    \ <label>\n<label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]\n<ldh-str> ::= <let-dig-hyp>\
    \ | <let-dig-hyp> <ldh-str>\n<let-dig-hyp> ::= <let-dig> | \"-\"\n<let-dig> ::=\
    \ <letter> | <digit>\n<letter> ::= any one of the 52 alphabetic characters A through\
    \ Z in\nupper case and a through z in lower case\n<digit> ::= any one of the ten\
    \ digits 0 through 9\nNote that while upper and lower case letters are allowed\
    \ in domain\nnames, no significance is attached to the case.  That is, two names\
    \ with\nthe same spelling but different case are to be treated as if identical.\n\
    The labels must follow the rules for ARPANET host names.  They must\nstart with\
    \ a letter, end with a letter or digit, and have as interior\ncharacters only\
    \ letters, digits, and hyphen.  There are also some\nrestrictions on the length.\
    \  Labels must be 63 characters or less.\nFor example, the following strings identify\
    \ hosts in the Internet:\nA.ISI.EDU  XX.LCS.MIT.EDU  SRI-NIC.ARPA\n3.6. Resource\
    \ Records\nA domain name identifies a node.  Each node has a set of resource\n\
    information, which may be empty.  The set of resource information\nassociated\
    \ with a particular name is composed of separate resource\nrecords (RRs).  The\
    \ order of RRs in a set is not significant, and need\nnot be preserved by name\
    \ servers, resolvers, or other parts of the DNS.\nWhen we talk about a specific\
    \ RR, we assume it has the following:\nowner           which is the domain name\
    \ where the RR is found.\ntype            which is an encoded 16 bit value that\
    \ specifies the type\n                of the resource in this resource record.\
    \  Types refer to\n                abstract resources.\n                This memo\
    \ uses the following types:\n                A               a host address\n\
    \                CNAME           identifies the canonical name of an\n       \
    \                         alias\n                HINFO           identifies the\
    \ CPU and OS used by a host\n                MX              identifies a mail\
    \ exchange for the\n                                domain.  See [RFC-974 for\
    \ details.\n                NS\n                the authoritative name server\
    \ for the domain\n                PTR\n                a pointer to another part\
    \ of the domain name space\n                SOA\n                identifies the\
    \ start of a zone of authority]\nclass           which is an encoded 16 bit value\
    \ which identifies a\n                protocol family or instance of a protocol.\n\
    \                This memo uses the following classes:\n                IN   \
    \           the Internet system\n                CH              the Chaos system\n\
    TTL             which is the time to live of the RR.  This field is a 32\n   \
    \             bit integer in units of seconds, an is primarily used by\n     \
    \           resolvers when they cache RRs.  The TTL describes how\n          \
    \      long a RR can be cached before it should be discarded.\nRDATA         \
    \  which is the type and sometimes class dependent data\n                which\
    \ describes the resource:\n                A               For the IN class, a\
    \ 32 bit IP address\n                                For the CH class, a domain\
    \ name followed\n                                by a 16 bit octal Chaos address.\n\
    \                CNAME           a domain name.\n                MX          \
    \    a 16 bit preference value (lower is\n                                better)\
    \ followed by a host name willing\n                                to act as a\
    \ mail exchange for the owner\n                                domain.\n     \
    \           NS              a host name.\n                PTR             a domain\
    \ name.\n                SOA             several fields.\nThe owner name is often\
    \ implicit, rather than forming an integral part\nof the RR.  For example, many\
    \ name servers internally form tree or hash\nstructures for the name space, and\
    \ chain RRs off nodes.  The remaining\nRR parts are the fixed header (type, class,\
    \ TTL) which is consistent for\nall RRs, and a variable part (RDATA) that fits\
    \ the needs of the resource\nbeing described.\nThe meaning of the TTL field is\
    \ a time limit on how long an RR can be\nkept in a cache.  This limit does not\
    \ apply to authoritative data in\nzones; it is also timed out, but by the refreshing\
    \ policies for the\nzone.  The TTL is assigned by the administrator for the zone\
    \ where the\ndata originates.  While short TTLs can be used to minimize caching,\
    \ and\na zero TTL prohibits caching, the realities of Internet performance\nsuggest\
    \ that these times should be on the order of days for the typical\nhost.  If a\
    \ change can be anticipated, the TTL can be reduced prior to\nthe change to minimize\
    \ inconsistency during the change, and then\nincreased back to its former value\
    \ following the change.\nThe data in the RDATA section of RRs is carried as a\
    \ combination of\nbinary strings and domain names.  The domain names are frequently\
    \ used\nas \"pointers\" to other data in the DNS.\n3.6.1. Textual expression of\
    \ RRs\nRRs are represented in binary form in the packets of the DNS protocol,\n\
    and are usually represented in highly encoded form when stored in a name\nserver\
    \ or resolver.  In this memo, we adopt a style similar to that used\nin master\
    \ files in order to show the contents of RRs.  In this format,\nmost RRs are shown\
    \ on a single line, although continuation lines are\npossible using parentheses.\n\
    The start of the line gives the owner of the RR.  If a line begins with\na blank,\
    \ then the owner is assumed to be the same as that of the\nprevious RR.  Blank\
    \ lines are often included for readability.\nFollowing the owner, we list the\
    \ TTL, type, and class of the RR.  Class\nand type use the mnemonics defined above,\
    \ and TTL is an integer before\nthe type field.  In order to avoid ambiguity in\
    \ parsing, type and class\nmnemonics are disjoint, TTLs are integers, and the\
    \ type mnemonic is\nalways last. The IN class and TTL values are often omitted\
    \ from examples\nin the interests of clarity.\nThe resource data or RDATA section\
    \ of the RR are given using knowledge\nof the typical representation for the data.\n\
    For example, we might show the RRs carried in a message as:\n    ISI.EDU.    \
    \    MX      10 VENERA.ISI.EDU.\n                    MX      10 VAXA.ISI.EDU.\n\
    \    VENERA.ISI.EDU. A       128.9.0.32\n                    A       10.1.0.52\n\
    \    VAXA.ISI.EDU.   A       10.2.0.27\n                    A       128.9.0.33\n\
    The MX RRs have an RDATA section which consists of a 16 bit number\nfollowed by\
    \ a domain name.  The address RRs use a standard IP address\nformat to contain\
    \ a 32 bit internet address.\nThis example shows six RRs, with two RRs at each\
    \ of three domain names.\nSimilarly we might see:\n    XX.LCS.MIT.EDU. IN    \
    \  A       10.0.0.44\n                    CH      A       MIT.EDU. 2420\nThis\
    \ example shows two addresses for XX.LCS.MIT.EDU, each of a different\nclass.\n\
    3.6.2. Aliases and canonical names\nIn existing systems, hosts and other resources\
    \ often have several names\nthat identify the same resource.  For example, the\
    \ names C.ISI.EDU and\nUSC-ISIC.ARPA both identify the same host.  Similarly,\
    \ in the case of\nmailboxes, many organizations provide many names that actually\
    \ go to the\nsame mailbox; for example Mockapetris@C.ISI.EDU, Mockapetris@B.ISI.EDU,\n\
    and PVM@ISI.EDU all go to the same mailbox (although the mechanism\nbehind this\
    \ is somewhat complicated).\nMost of these systems have a notion that one of the\
    \ equivalent set of\nnames is the canonical or primary name and all others are\
    \ aliases.\nThe domain system provides such a feature using the canonical name\n\
    (CNAME) RR.  A CNAME RR identifies its owner name as an alias, and\nspecifies\
    \ the corresponding canonical name in the RDATA section of the\nRR.  If a CNAME\
    \ RR is present at a node, no other data should be\npresent; this ensures that\
    \ the data for a canonical name and its aliases\ncannot be different.  This rule\
    \ also insures that a cached CNAME can be\nused without checking with an authoritative\
    \ server for other RR types.\nCNAME RRs cause special action in DNS software.\
    \  When a name server\nfails to find a desired RR in the resource set associated\
    \ with the\ndomain name, it checks to see if the resource set consists of a CNAME\n\
    record with a matching class.  If so, the name server includes the CNAME\nrecord\
    \ in the response and restarts the query at the domain name\nspecified in the\
    \ data field of the CNAME record.  The one exception to\nthis rule is that queries\
    \ which match the CNAME type are not restarted.\nFor example, suppose a name server\
    \ was processing a query with for USC-\nISIC.ARPA, asking for type A information,\
    \ and had the following resource\nrecords:\n    USC-ISIC.ARPA   IN      CNAME\
    \   C.ISI.EDU\n    C.ISI.EDU       IN      A       10.0.0.52\nBoth of these RRs\
    \ would be returned in the response to the type A query,\nwhile a type CNAME or\
    \ * query should return just the CNAME.\nDomain names in RRs which point at another\
    \ name should always point at\nthe primary name and not the alias.  This avoids\
    \ extra indirections in\naccessing information.  For example, the address to name\
    \ RR for the\nabove host should be:\n    52.0.0.10.IN-ADDR.ARPA  IN      PTR \
    \    C.ISI.EDU\nrather than pointing at USC-ISIC.ARPA.  Of course, by the robustness\n\
    principle, domain software should not fail when presented with CNAME\nchains or\
    \ loops; CNAME chains should be followed and CNAME loops\nsignalled as an error.\n\
    3.7. Queries\nQueries are messages which may be sent to a name server to provoke\
    \ a\nresponse.  In the Internet, queries are carried in UDP datagrams or over\n\
    TCP connections.  The response by the name server either answers the\nquestion\
    \ posed in the query, refers the requester to another set of name\nservers, or\
    \ signals some error condition.\nIn general, the user does not generate queries\
    \ directly, but instead\nmakes a request to a resolver which in turn sends one\
    \ or more queries to\nname servers and deals with the error conditions and referrals\
    \ that may\nresult.  Of course, the possible questions which can be asked in a\
    \ query\ndoes shape the kind of service a resolver can provide.\nDNS queries and\
    \ responses are carried in a standard message format.  The\nmessage format has\
    \ a header containing a number of fixed fields which\nare always present, and\
    \ four sections which carry query parameters and\nRRs.\nThe most important field\
    \ in the header is a four bit field called an\nopcode which separates different\
    \ queries.  Of the possible 16 values,\none (standard query) is part of the official\
    \ protocol, two (inverse\nquery and status query) are options, one (completion)\
    \ is obsolete, and\nthe rest are unassigned.\nThe four sections are:\nQuestion\
    \        Carries the query name and other query parameters.\nAnswer          Carries\
    \ RRs which directly answer the query.\nAuthority       Carries RRs which describe\
    \ other authoritative servers.\n                May optionally carry the SOA RR\
    \ for the authoritative\n                data in the answer section.\nAdditional\
    \      Carries RRs which may be helpful in using the RRs in the\n            \
    \    other sections.\nNote that the content, but not the format, of these sections\
    \ varies with\nheader opcode.\n3.7.1. Standard queries\nA standard query specifies\
    \ a target domain name (QNAME), query type\n(QTYPE), and query class (QCLASS)\
    \ and asks for RRs which match.  This\ntype of query makes up such a vast majority\
    \ of DNS queries that we use\nthe term \"query\" to mean standard query unless\
    \ otherwise specified.  The\nQTYPE and QCLASS fields are each 16 bits long, and\
    \ are a superset of\ndefined types and classes.\nThe QTYPE field may contain:\n\
    <any type>      matches just that type. (e.g., A, PTR).\nAXFR            special\
    \ zone transfer QTYPE.\nMAILB           matches all mail box related RRs (e.g.\
    \ MB and MG).\n*               matches all RR types.\nThe QCLASS field may contain:\n\
    <any class>     matches just that class (e.g., IN, CH).\n*               matches\
    \ aLL RR classes.\nUsing the query domain name, QTYPE, and QCLASS, the name server\
    \ looks\nfor matching RRs.  In addition to relevant records, the name server may\n\
    return RRs that point toward a name server that has the desired\ninformation or\
    \ RRs that are expected to be useful in interpreting the\nrelevant RRs.  For example,\
    \ a name server that doesn't have the\nrequested information may know a name server\
    \ that does; a name server\nthat returns a domain name in a relevant RR may also\
    \ return the RR that\nbinds that domain name to an address.\nFor example, a mailer\
    \ tying to send mail to Mockapetris@ISI.EDU might\nask the resolver for mail information\
    \ about ISI.EDU, resulting in a\nquery for QNAME=ISI.EDU, QTYPE=MX, QCLASS=IN.\
    \  The response's answer\nsection would be:\n    ISI.EDU.        MX      10 VENERA.ISI.EDU.\n\
    \                    MX      10 VAXA.ISI.EDU.\nwhile the additional section might\
    \ be:\n    VAXA.ISI.EDU.   A       10.2.0.27\n                    A       128.9.0.33\n\
    \    VENERA.ISI.EDU. A       10.1.0.52\n                    A       128.9.0.32\n\
    Because the server assumes that if the requester wants mail exchange\ninformation,\
    \ it will probably want the addresses of the mail exchanges\nsoon afterward.\n\
    Note that the QCLASS=* construct requires special interpretation\nregarding authority.\
    \  Since a particular name server may not know all of\nthe classes available in\
    \ the domain system, it can never know if it is\nauthoritative for all classes.\
    \  Hence responses to QCLASS=* queries can\nnever be authoritative.\n3.7.2. Inverse\
    \ queries (Optional)\nName servers may also support inverse queries that map a\
    \ particular\nresource to a domain name or domain names that have that resource.\
    \  For\nexample, while a standard query might map a domain name to a SOA RR, the\n\
    corresponding inverse query might map the SOA RR back to the domain\nname.\nImplementation\
    \ of this service is optional in a name server, but all\nname servers must at\
    \ least be able to understand an inverse query\nmessage and return a not-implemented\
    \ error response.\nThe domain system cannot guarantee the completeness or uniqueness\
    \ of\ninverse queries because the domain system is organized by domain name\n\
    rather than by host address or any other resource type.  Inverse queries\nare\
    \ primarily useful for debugging and database maintenance activities.\nInverse\
    \ queries may not return the proper TTL, and do not indicate cases\nwhere the\
    \ identified RR is one of a set (for example, one address for a\nhost having multiple\
    \ addresses).  Therefore, the RRs returned in inverse\nqueries should never be\
    \ cached.\nInverse queries are NOT an acceptable method for mapping host addresses\n\
    to host names; use the IN-ADDR.ARPA domain instead.\nA detailed discussion of\
    \ inverse queries is contained in [RFC-1035].\n3.8. Status queries (Experimental)\n\
    To be defined.\n3.9. Completion queries (Obsolete)\nThe optional completion services\
    \ described in RFCs 882 and 883 have been\ndeleted.  Redesigned services may become\
    \ available in the future, or the\nopcodes may be reclaimed for other use.\n4.\
    \ NAME SERVERS\n4.1. Introduction\nName servers are the repositories of information\
    \ that make up the domain\ndatabase.  The database is divided up into sections\
    \ called zones, which\nare distributed among the name servers.  While name servers\
    \ can have\nseveral optional functions and sources of data, the essential task\
    \ of a\nname server is to answer queries using data in its zones.  By design,\n\
    name servers can answer queries in a simple manner; the response can\nalways be\
    \ generated using only local data, and either contains the\nanswer to the question\
    \ or a referral to other name servers \"closer\" to\nthe desired information.\n\
    A given zone will be available from several name servers to insure its\navailability\
    \ in spite of host or communication link failure.  By\nadministrative fiat, we\
    \ require every zone to be available on at least\ntwo servers, and many zones\
    \ have more redundancy than that.\nA given name server will typically support\
    \ one or more zones, but this\ngives it authoritative information about only a\
    \ small section of the\ndomain tree.  It may also have some cached non-authoritative\
    \ data about\nother parts of the tree.  The name server marks its responses to\
    \ queries\nso that the requester can tell whether the response comes from\nauthoritative\
    \ data or not.\n4.2. How the database is divided into zones\nThe domain database\
    \ is partitioned in two ways: by class, and by \"cuts\"\nmade in the name space\
    \ between nodes.\nThe class partition is simple.  The database for any class is\
    \ organized,\ndelegated, and maintained separately from all other classes.  Since,\
    \ by\nconvention, the name spaces are the same for all classes, the separate\n\
    classes can be thought of as an array of parallel namespace trees.  Note\nthat\
    \ the data attached to nodes will be different for these different\nparallel classes.\
    \  The most common reasons for creating a new class are\nthe necessity for a new\
    \ data format for existing types or a desire for a\nseparately managed version\
    \ of the existing name space.\nWithin a class, \"cuts\" in the name space can\
    \ be made between any two\nadjacent nodes.  After all cuts are made, each group\
    \ of connected name\nspace is a separate zone.  The zone is said to be authoritative\
    \ for all\nnames in the connected region.  Note that the \"cuts\" in the name\
    \ space\nmay be in different places for different classes, the name servers may\n\
    be different, etc.\nThese rules mean that every zone has at least one node, and\
    \ hence domain\nname, for which it is authoritative, and all of the nodes in a\n\
    particular zone are connected.  Given, the tree structure, every zone\nhas a highest\
    \ node which is closer to the root than any other node in\nthe zone.  The name\
    \ of this node is often used to identify the zone.\nIt would be possible, though\
    \ not particularly useful, to partition the\nname space so that each domain name\
    \ was in a separate zone or so that\nall nodes were in a single zone.  Instead,\
    \ the database is partitioned\nat points where a particular organization wants\
    \ to take over control of\na subtree.  Once an organization controls its own zone\
    \ it can\nunilaterally change the data in the zone, grow new tree sections\nconnected\
    \ to the zone, delete existing nodes, or delegate new subzones\nunder its zone.\n\
    If the organization has substructure, it may want to make further\ninternal partitions\
    \ to achieve nested delegations of name space control.\nIn some cases, such divisions\
    \ are made purely to make database\nmaintenance more convenient.\n4.2.1. Technical\
    \ considerations\nThe data that describes a zone has four major parts:\n   - Authoritative\
    \ data for all nodes within the zone.\n   - Data that defines the top node of\
    \ the zone (can be thought of\n     as part of the authoritative data).\n   -\
    \ Data that describes delegated subzones, i.e., cuts around the\n     bottom of\
    \ the zone.\n   - Data that allows access to name servers for subzones\n     (sometimes\
    \ called \"glue\" data).\nAll of this data is expressed in the form of RRs, so\
    \ a zone can be\ncompletely described in terms of a set of RRs.  Whole zones can\
    \ be\ntransferred between name servers by transferring the RRs, either carried\n\
    in a series of messages or by FTPing a master file which is a textual\nrepresentation.\n\
    The authoritative data for a zone is simply all of the RRs attached to\nall of\
    \ the nodes from the top node of the zone down to leaf nodes or\nnodes above cuts\
    \ around the bottom edge of the zone.\nThough logically part of the authoritative\
    \ data, the RRs that describe\nthe top node of the zone are especially important\
    \ to the zone's\nmanagement.  These RRs are of two types: name server RRs that\
    \ list, one\nper RR, all of the servers for the zone, and a single SOA RR that\n\
    describes zone management parameters.\nThe RRs that describe cuts around the bottom\
    \ of the zone are NS RRs that\nname the servers for the subzones.  Since the cuts\
    \ are between nodes,\nthese RRs are NOT part of the authoritative data of the\
    \ zone, and should\nbe exactly the same as the corresponding RRs in the top node\
    \ of the\nsubzone.  Since name servers are always associated with zone boundaries,\n\
    NS RRs are only found at nodes which are the top node of some zone.  In\nthe data\
    \ that makes up a zone, NS RRs are found at the top node of the\nzone (and are\
    \ authoritative) and at cuts around the bottom of the zone\n(where they are not\
    \ authoritative), but never in between.\nOne of the goals of the zone structure\
    \ is that any zone have all the\ndata required to set up communications with the\
    \ name servers for any\nsubzones.  That is, parent zones have all the information\
    \ needed to\naccess servers for their children zones.  The NS RRs that name the\n\
    servers for subzones are often not enough for this task since they name\nthe servers,\
    \ but do not give their addresses.  In particular, if the\nname of the name server\
    \ is itself in the subzone, we could be faced with\nthe situation where the NS\
    \ RRs tell us that in order to learn a name\nserver's address, we should contact\
    \ the server using the address we wish\nto learn.  To fix this problem, a zone\
    \ contains \"glue\" RRs which are not\npart of the authoritative data, and are\
    \ address RRs for the servers.\nThese RRs are only necessary if the name server's\
    \ name is \"below\" the\ncut, and are only used as part of a referral response.\n\
    4.2.2. Administrative considerations\nWhen some organization wants to control\
    \ its own domain, the first step\nis to identify the proper parent zone, and get\
    \ the parent zone's owners\nto agree to the delegation of control.  While there\
    \ are no particular\ntechnical constraints dealing with where in the tree this\
    \ can be done,\nthere are some administrative groupings discussed in [RFC-1032]\
    \ which\ndeal with top level organization, and middle level zones are free to\n\
    create their own rules.  For example, one university might choose to use\na single\
    \ zone, while another might choose to organize by subzones\ndedicated to individual\
    \ departments or schools.  [RFC-1033] catalogs\navailable DNS software an discusses\
    \ administration procedures.\nOnce the proper name for the new subzone is selected,\
    \ the new owners\nshould be required to demonstrate redundant name server support.\
    \  Note\nthat there is no requirement that the servers for a zone reside in a\n\
    host which has a name in that domain.  In many cases, a zone will be\nmore accessible\
    \ to the internet at large if its servers are widely\ndistributed rather than\
    \ being within the physical facilities controlled\nby the same organization that\
    \ manages the zone.  For example, in the\ncurrent DNS, one of the name servers\
    \ for the United Kingdom, or UK\ndomain, is found in the US.  This allows US hosts\
    \ to get UK data without\nusing limited transatlantic bandwidth.\nAs the last\
    \ installation step, the delegation NS RRs and glue RRs\nnecessary to make the\
    \ delegation effective should be added to the parent\nzone.  The administrators\
    \ of both zones should insure that the NS and\nglue RRs which mark both sides\
    \ of the cut are consistent and remain so.\n4.3. Name server internals\n4.3.1.\
    \ Queries and responses\nThe principal activity of name servers is to answer standard\
    \ queries.\nBoth the query and its response are carried in a standard message\
    \ format\nwhich is described in [RFC-1035].  The query contains a QTYPE, QCLASS,\n\
    and QNAME, which describe the types and classes of desired information\nand the\
    \ name of interest.\nThe way that the name server answers the query depends upon\
    \ whether it\nis operating in recursive mode or not:\n   - The simplest mode for\
    \ the server is non-recursive, since it\n     can answer queries using only local\
    \ information: the response\n     contains an error, the answer, or a referral\
    \ to some other\n     server \"closer\" to the answer.  All name servers must\n\
    \     implement non-recursive queries.\n   - The simplest mode for the client\
    \ is recursive, since in this\n     mode the name server acts in the role of a\
    \ resolver and\n     returns either an error or the answer, but never referrals.\n\
    \     This service is optional in a name server, and the name server\n     may\
    \ also choose to restrict the clients which can use\n     recursive mode.\nRecursive\
    \ service is helpful in several situations:\n   - a relatively simple requester\
    \ that lacks the ability to use\n     anything other than a direct answer to the\
    \ question.\n   - a request that needs to cross protocol or other boundaries and\n\
    \     can be sent to a server which can act as intermediary.\n   - a network where\
    \ we want to concentrate the cache rather than\n     having a separate cache for\
    \ each client.\nNon-recursive service is appropriate if the requester is capable\
    \ of\npursuing referrals and interested in information which will aid future\n\
    requests.\nThe use of recursive mode is limited to cases where both the client\
    \ and\nthe name server agree to its use.  The agreement is negotiated through\n\
    the use of two bits in query and response messages:\n   - The recursion available,\
    \ or RA bit, is set or cleared by a\n     name server in all responses.  The bit\
    \ is true if the name\n     server is willing to provide recursive service for\
    \ the client,\n     regardless of whether the client requested recursive service.\n\
    \     That is, RA signals availability rather than use.\n   - Queries contain\
    \ a bit called recursion desired or RD.  This\n     bit specifies specifies whether\
    \ the requester wants recursive\n     service for this query.  Clients may request\
    \ recursive service\n     from any name server, though they should depend upon\
    \ receiving\n     it only from servers which have previously sent an RA, or\n\
    \     servers which have agreed to provide service through private\n     agreement\
    \ or some other means outside of the DNS protocol.\nThe recursive mode occurs\
    \ when a query with RD set arrives at a server\nwhich is willing to provide recursive\
    \ service; the client can verify\nthat recursive mode was used by checking that\
    \ both RA and RD are set in\nthe reply.  Note that the name server should never\
    \ perform recursive\nservice unless asked via RD, since this interferes with trouble\
    \ shooting\nof name servers and their databases.\nIf recursive service is requested\
    \ and available, the recursive response\nto a query will be one of the following:\n\
    \   - The answer to the query, possibly preface by one or more CNAME\n     RRs\
    \ that specify aliases encountered on the way to an answer.\n   - A name error\
    \ indicating that the name does not exist.  This\n     may include CNAME RRs that\
    \ indicate that the original query\n     name was an alias for a name which does\
    \ not exist.\n   - A temporary error indication.\nIf recursive service is not\
    \ requested or is not available, the non-\nrecursive response will be one of the\
    \ following:\n   - An authoritative name error indicating that the name does not\n\
    \     exist.\n   - A temporary error indication.\n   - Some combination of:\n\
    \     RRs that answer the question, together with an indication\n     whether\
    \ the data comes from a zone or is cached.\n     A referral to name servers which\
    \ have zones which are closer\n     ancestors to the name than the server sending\
    \ the reply.\n   - RRs that the name server thinks will prove useful to the\n\
    \     requester.\n4.3.2. Algorithm\nThe actual algorithm used by the name server\
    \ will depend on the local OS\nand data structures used to store RRs.  The following\
    \ algorithm assumes\nthat the RRs are organized in several tree structures, one\
    \ for each\nzone, and another for the cache:\n   1. Set or clear the value of\
    \ recursion available in the response\n      depending on whether the name server\
    \ is willing to provide\n      recursive service.  If recursive service is available\
    \ and\n      requested via the RD bit in the query, go to step 5,\n      otherwise\
    \ step 2.\n   2. Search the available zones for the zone which is the nearest\n\
    \      ancestor to QNAME.  If such a zone is found, go to step 3,\n      otherwise\
    \ step 4.\n   3. Start matching down, label by label, in the zone.  The\n    \
    \  matching process can terminate several ways:\n         a. If the whole of QNAME\
    \ is matched, we have found the\n            node.\n            If the data at\
    \ the node is a CNAME, and QTYPE doesn't\n            match CNAME, copy the CNAME\
    \ RR into the answer section\n            of the response, change QNAME to the\
    \ canonical name in\n            the CNAME RR, and go back to step 1.\n      \
    \      Otherwise, copy all RRs which match QTYPE into the\n            answer\
    \ section and go to step 6.\n         b. If a match would take us out of the authoritative\
    \ data,\n            we have a referral.  This happens when we encounter a\n \
    \           node with NS RRs marking cuts along the bottom of a\n            zone.\n\
    \            Copy the NS RRs for the subzone into the authority\n            section\
    \ of the reply.  Put whatever addresses are\n            available into the additional\
    \ section, using glue RRs\n            if the addresses are not available from\
    \ authoritative\n            data or the cache.  Go to step 4.\n         c. If\
    \ at some label, a match is impossible (i.e., the\n            corresponding label\
    \ does not exist), look to see if a\n            the \"*\" label exists.\n   \
    \         If the \"*\" label does not exist, check whether the name\n        \
    \    we are looking for is the original QNAME in the query\n            or a name\
    \ we have followed due to a CNAME.  If the name\n            is original, set\
    \ an authoritative name error in the\n            response and exit.  Otherwise\
    \ just exit.\n            If the \"*\" label does exist, match RRs at that node\n\
    \            against QTYPE.  If any match, copy them into the answer\n       \
    \     section, but set the owner of the RR to be QNAME, and\n            not the\
    \ node with the \"*\" label.  Go to step 6.\n   4. Start matching down in the\
    \ cache.  If QNAME is found in the\n      cache, copy all RRs attached to it that\
    \ match QTYPE into the\n      answer section.  If there was no delegation from\n\
    \      authoritative data, look for the best one from the cache, and\n      put\
    \ it in the authority section.  Go to step 6.\n   5. Using the local resolver\
    \ or a copy of its algorithm (see\n      resolver section of this memo) to answer\
    \ the query.  Store\n      the results, including any intermediate CNAMEs, in\
    \ the answer\n      section of the response.\n   6. Using local data only, attempt\
    \ to add other RRs which may be\n      useful to the additional section of the\
    \ query.  Exit.\n4.3.3. Wildcards\nIn the previous algorithm, special treatment\
    \ was given to RRs with owner\nnames starting with the label \"*\".  Such RRs\
    \ are called wildcards.\nWildcard RRs can be thought of as instructions for synthesizing\
    \ RRs.\nWhen the appropriate conditions are met, the name server creates RRs\n\
    with an owner name equal to the query name and contents taken from the\nwildcard\
    \ RRs.\nThis facility is most often used to create a zone which will be used to\n\
    forward mail from the Internet to some other mail system.  The general\nidea is\
    \ that any name in that zone which is presented to server in a\nquery will be\
    \ assumed to exist, with certain properties, unless explicit\nevidence exists\
    \ to the contrary.  Note that the use of the term zone\nhere, instead of domain,\
    \ is intentional; such defaults do not propagate\nacross zone boundaries, although\
    \ a subzone may choose to achieve that\nappearance by setting up similar defaults.\n\
    The contents of the wildcard RRs follows the usual rules and formats for\nRRs.\
    \  The wildcards in the zone have an owner name that controls the\nquery names\
    \ they will match.  The owner name of the wildcard RRs is of\nthe form \"*.<anydomain>\"\
    , where <anydomain> is any domain name.\n<anydomain> should not contain other\
    \ * labels, and should be in the\nauthoritative data of the zone.  The wildcards\
    \ potentially apply to\ndescendants of <anydomain>, but not to <anydomain> itself.\
    \  Another way\nto look at this is that the \"*\" label always matches at least\
    \ one whole\nlabel and sometimes more, but always whole labels.\nWildcard RRs\
    \ do not apply:\n   - When the query is in another zone.  That is, delegation\
    \ cancels\n     the wildcard defaults.\n   - When the query name or a name between\
    \ the wildcard domain and\n     the query name is know to exist.  For example,\
    \ if a wildcard\n     RR has an owner name of \"*.X\", and the zone also contains\
    \ RRs\n     attached to B.X, the wildcards would apply to queries for name\n \
    \    Z.X (presuming there is no explicit information for Z.X), but\n     not to\
    \ B.X, A.B.X, or X.\nA * label appearing in a query name has no special effect,\
    \ but can be\nused to test for wildcards in an authoritative zone; such a query\
    \ is the\nonly way to get a response containing RRs with an owner name with *\
    \ in\nit.  The result of such a query should not be cached.\nNote that the contents\
    \ of the wildcard RRs are not modified when used to\nsynthesize RRs.\nTo illustrate\
    \ the use of wildcard RRs, suppose a large company with a\nlarge, non-IP/TCP,\
    \ network wanted to create a mail gateway.  If the\ncompany was called X.COM,\
    \ and IP/TCP capable gateway machine was called\nA.X.COM, the following RRs might\
    \ be entered into the COM zone:\n    X.COM           MX      10      A.X.COM\n\
    \    *.X.COM         MX      10      A.X.COM\n    A.X.COM         A       1.2.3.4\n\
    \    A.X.COM         MX      10      A.X.COM\n    *.A.X.COM       MX      10 \
    \     A.X.COM\nThis would cause any MX query for any domain name ending in X.COM\
    \ to\nreturn an MX RR pointing at A.X.COM.  Two wildcard RRs are required\nsince\
    \ the effect of the wildcard at *.X.COM is inhibited in the A.X.COM\nsubtree by\
    \ the explicit data for A.X.COM.  Note also that the explicit\nMX data at X.COM\
    \ and A.X.COM is required, and that none of the RRs above\nwould match a query\
    \ name of XX.COM.\n4.3.4. Negative response caching (Optional)\nThe DNS provides\
    \ an optional service which allows name servers to\ndistribute, and resolvers\
    \ to cache, negative results with TTLs.  For\nexample, a name server can distribute\
    \ a TTL along with a name error\nindication, and a resolver receiving such information\
    \ is allowed to\nassume that the name does not exist during the TTL period without\n\
    consulting authoritative data.  Similarly, a resolver can make a query\nwith a\
    \ QTYPE which matches multiple types, and cache the fact that some\nof the types\
    \ are not present.\nThis feature can be particularly important in a system which\
    \ implements\nnaming shorthands that use search lists beacuse a popular shorthand,\n\
    which happens to require a suffix toward the end of the search list,\nwill generate\
    \ multiple name errors whenever it is used.\nThe method is that a name server\
    \ may add an SOA RR to the additional\nsection of a response when that response\
    \ is authoritative.  The SOA must\nbe that of the zone which was the source of\
    \ the authoritative data in\nthe answer section, or name error if applicable.\
    \  The MINIMUM field of\nthe SOA controls the length of time that the negative\
    \ result may be\ncached.\nNote that in some circumstances, the answer section\
    \ may contain multiple\nowner names.  In this case, the SOA mechanism should only\
    \ be used for\nthe data which matches QNAME, which is the only authoritative data\
    \ in\nthis section.\nName servers and resolvers should never attempt to add SOAs\
    \ to the\nadditional section of a non-authoritative response, or attempt to infer\n\
    results which are not directly stated in an authoritative response.\nThere are\
    \ several reasons for this, including: cached information isn't\nusually enough\
    \ to match up RRs and their zone names, SOA RRs may be\ncached due to direct SOA\
    \ queries, and name servers are not required to\noutput the SOAs in the authority\
    \ section.\nThis feature is optional, although a refined version is expected to\n\
    become part of the standard protocol in the future.  Name servers are\nnot required\
    \ to add the SOA RRs in all authoritative responses, nor are\nresolvers required\
    \ to cache negative results.  Both are recommended.\nAll resolvers and recursive\
    \ name servers are required to at least be\nable to ignore the SOA RR when it\
    \ is present in a response.\nSome experiments have also been proposed which will\
    \ use this feature.\nThe idea is that if cached data is known to come from a particular\
    \ zone,\nand if an authoritative copy of the zone's SOA is obtained, and if the\n\
    zone's SERIAL has not changed since the data was cached, then the TTL of\nthe\
    \ cached data can be reset to the zone MINIMUM value if it is smaller.\nThis usage\
    \ is mentioned for planning purposes only, and is not\nrecommended as yet.\n4.3.5.\
    \ Zone maintenance and transfers\nPart of the job of a zone administrator is to\
    \ maintain the zones at all\nof the name servers which are authoritative for the\
    \ zone.  When the\ninevitable changes are made, they must be distributed to all\
    \ of the name\nservers.  While this distribution can be accomplished using FTP\
    \ or some\nother ad hoc procedure, the preferred method is the zone transfer part\n\
    of the DNS protocol.\nThe general model of automatic zone transfer or refreshing\
    \ is that one\nof the name servers is the master or primary for the zone.  Changes\
    \ are\ncoordinated at the primary, typically by editing a master file for the\n\
    zone.  After editing, the administrator signals the master server to\nload the\
    \ new zone.  The other non-master or secondary servers for the\nzone periodically\
    \ check for changes (at a selectable interval) and\nobtain new zone copies when\
    \ changes have been made.\nTo detect changes, secondaries just check the SERIAL\
    \ field of the SOA\nfor the zone.  In addition to whatever other changes are made,\
    \ the\nSERIAL field in the SOA of the zone is always advanced whenever any\nchange\
    \ is made to the zone.  The advancing can be a simple increment, or\ncould be\
    \ based on the write date and time of the master file, etc.  The\npurpose is to\
    \ make it possible to determine which of two copies of a\nzone is more recent\
    \ by comparing serial numbers.  Serial number advances\nand comparisons use sequence\
    \ space arithmetic, so there is a theoretic\nlimit on how fast a zone can be updated,\
    \ basically that old copies must\ndie out before the serial number covers half\
    \ of its 32 bit range.  In\npractice, the only concern is that the compare operation\
    \ deals properly\nwith comparisons around the boundary between the most positive\
    \ and most\nnegative 32 bit numbers.\nThe periodic polling of the secondary servers\
    \ is controlled by\nparameters in the SOA RR for the zone, which set the minimum\
    \ acceptable\npolling intervals.  The parameters are called REFRESH, RETRY, and\n\
    EXPIRE.  Whenever a new zone is loaded in a secondary, the secondary\nwaits REFRESH\
    \ seconds before checking with the primary for a new serial.\nIf this check cannot\
    \ be completed, new checks are started every RETRY\nseconds.  The check is a simple\
    \ query to the primary for the SOA RR of\nthe zone.  If the serial field in the\
    \ secondary's zone copy is equal to\nthe serial returned by the primary, then\
    \ no changes have occurred, and\nthe REFRESH interval wait is restarted.  If the\
    \ secondary finds it\nimpossible to perform a serial check for the EXPIRE interval,\
    \ it must\nassume that its copy of the zone is obsolete an discard it.\nWhen the\
    \ poll shows that the zone has changed, then the secondary server\nmust request\
    \ a zone transfer via an AXFR request for the zone.  The AXFR\nmay cause an error,\
    \ such as refused, but normally is answered by a\nsequence of response messages.\
    \  The first and last messages must contain\nthe data for the top authoritative\
    \ node of the zone.  Intermediate\nmessages carry all of the other RRs from the\
    \ zone, including both\nauthoritative and non-authoritative RRs.  The stream of\
    \ messages allows\nthe secondary to construct a copy of the zone.  Because accuracy\
    \ is\nessential, TCP or some other reliable protocol must be used for AXFR\nrequests.\n\
    Each secondary server is required to perform the following operations\nagainst\
    \ the master, but may also optionally perform these operations\nagainst other\
    \ secondary servers.  This strategy can improve the transfer\nprocess when the\
    \ primary is unavailable due to host downtime or network\nproblems, or when a\
    \ secondary server has better network access to an\n\"intermediate\" secondary\
    \ than to the primary.\n5. RESOLVERS\n5.1. Introduction\nResolvers are programs\
    \ that interface user programs to domain name\nservers.  In the simplest case,\
    \ a resolver receives a request from a\nuser program (e.g., mail programs, TELNET,\
    \ FTP) in the form of a\nsubroutine call, system call etc., and returns the desired\
    \ information\nin a form compatible with the local host's data formats.\nThe resolver\
    \ is located on the same machine as the program that requests\nthe resolver's\
    \ services, but it may need to consult name servers on\nother hosts.  Because\
    \ a resolver may need to consult several name\nservers, or may have the requested\
    \ information in a local cache, the\namount of time that a resolver will take\
    \ to complete can vary quite a\nbit, from milliseconds to several seconds.\nA\
    \ very important goal of the resolver is to eliminate network delay and\nname\
    \ server load from most requests by answering them from its cache of\nprior results.\
    \  It follows that caches which are shared by multiple\nprocesses, users, machines,\
    \ etc., are more efficient than non-shared\ncaches.\n5.2. Client-resolver interface\n\
    5.2.1. Typical functions\nThe client interface to the resolver is influenced by\
    \ the local host's\nconventions, but the typical resolver-client interface has\
    \ three\nfunctions:\n   1. Host name to host address translation.\n      This\
    \ function is often defined to mimic a previous HOSTS.TXT\n      based function.\
    \  Given a character string, the caller wants\n      one or more 32 bit IP addresses.\
    \  Under the DNS, it\n      translates into a request for type A RRs.  Since the\
    \ DNS does\n      not preserve the order of RRs, this function may choose to\n\
    \      sort the returned addresses or select the \"best\" address if\n      the\
    \ service returns only one choice to the client.  Note that\n      a multiple\
    \ address return is recommended, but a single\n      address may be the only way\
    \ to emulate prior HOSTS.TXT\n      services.\n   2. Host address to host name\
    \ translation\n      This function will often follow the form of previous\n  \
    \    functions.  Given a 32 bit IP address, the caller wants a\n      character\
    \ string.  The octets of the IP address are reversed,\n      used as name components,\
    \ and suffixed with \"IN-ADDR.ARPA\".  A\n      type PTR query is used to get\
    \ the RR with the primary name of\n      the host.  For example, a request for\
    \ the host name\n      corresponding to IP address 1.2.3.4 looks for PTR RRs for\n\
    \      domain name \"4.3.2.1.IN-ADDR.ARPA\".\n   3. General lookup function\n\
    \      This function retrieves arbitrary information from the DNS,\n      and\
    \ has no counterpart in previous systems.  The caller\n      supplies a QNAME,\
    \ QTYPE, and QCLASS, and wants all of the\n      matching RRs.  This function\
    \ will often use the DNS format\n      for all RR data instead of the local host's,\
    \ and returns all\n      RR content (e.g., TTL) instead of a processed form with\
    \ local\n      quoting conventions.\nWhen the resolver performs the indicated\
    \ function, it usually has one of\nthe following results to pass back to the client:\n\
    \   - One or more RRs giving the requested data.\n     In this case the resolver\
    \ returns the answer in the\n     appropriate format.\n   - A name error (NE).\n\
    \     This happens when the referenced name does not exist.  For\n     example,\
    \ a user may have mistyped a host name.\n   - A data not found error.\n     This\
    \ happens when the referenced name exists, but data of the\n     appropriate type\
    \ does not.  For example, a host address\n     function applied to a mailbox name\
    \ would return this error\n     since the name exists, but no address RR is present.\n\
    It is important to note that the functions for translating between host\nnames\
    \ and addresses may combine the \"name error\" and \"data not found\"\nerror conditions\
    \ into a single type of error return, but the general\nfunction should not.  One\
    \ reason for this is that applications may ask\nfirst for one type of information\
    \ about a name followed by a second\nrequest to the same name for some other type\
    \ of information; if the two\nerrors are combined, then useless queries may slow\
    \ the application.\n5.2.2. Aliases\nWhile attempting to resolve a particular request,\
    \ the resolver may find\nthat the name in question is an alias.  For example,\
    \ the resolver might\nfind that the name given for host name to address translation\
    \ is an\nalias when it finds the CNAME RR.  If possible, the alias condition\n\
    should be signalled back from the resolver to the client.\nIn most cases a resolver\
    \ simply restarts the query at the new name when\nit encounters a CNAME.  However,\
    \ when performing the general function,\nthe resolver should not pursue aliases\
    \ when the CNAME RR matches the\nquery type.  This allows queries which ask whether\
    \ an alias is present.\nFor example, if the query type is CNAME, the user is interested\
    \ in the\nCNAME RR itself, and not the RRs at the name it points to.\nSeveral\
    \ special conditions can occur with aliases.  Multiple levels of\naliases should\
    \ be avoided due to their lack of efficiency, but should\nnot be signalled as\
    \ an error.  Alias loops and aliases which point to\nnon-existent names should\
    \ be caught and an error condition passed back\nto the client.\n5.2.3. Temporary\
    \ failures\nIn a less than perfect world, all resolvers will occasionally be unable\n\
    to resolve a particular request.  This condition can be caused by a\nresolver\
    \ which becomes separated from the rest of the network due to a\nlink failure\
    \ or gateway problem, or less often by coincident failure or\nunavailability of\
    \ all servers for a particular domain.\nIt is essential that this sort of condition\
    \ should not be signalled as a\nname or data not present error to applications.\
    \  This sort of behavior\nis annoying to humans, and can wreak havoc when mail\
    \ systems use the\nDNS.\nWhile in some cases it is possible to deal with such\
    \ a temporary problem\nby blocking the request indefinitely, this is usually not\
    \ a good choice,\nparticularly when the client is a server process that could\
    \ move on to\nother tasks.  The recommended solution is to always have temporary\n\
    failure as one of the possible results of a resolver function, even\nthough this\
    \ may make emulation of existing HOSTS.TXT functions more\ndifficult.\n5.3. Resolver\
    \ internals\nEvery resolver implementation uses slightly different algorithms,\
    \ and\ntypically spends much more logic dealing with errors of various sorts\n\
    than typical occurances.  This section outlines a recommended basic\nstrategy\
    \ for resolver operation, but leaves details to [RFC-1035].\n5.3.1. Stub resolvers\n\
    One option for implementing a resolver is to move the resolution\nfunction out\
    \ of the local machine and into a name server which supports\nrecursive queries.\
    \  This can provide an easy method of providing domain\nservice in a PC which\
    \ lacks the resources to perform the resolver\nfunction, or can centralize the\
    \ cache for a whole local network or\norganization.\nAll that the remaining stub\
    \ needs is a list of name server addresses\nthat will perform the recursive requests.\
    \  This type of resolver\npresumably needs the information in a configuration\
    \ file, since it\nprobably lacks the sophistication to locate it in the domain\
    \ database.\nThe user also needs to verify that the listed servers will perform\
    \ the\nrecursive service; a name server is free to refuse to perform recursive\n\
    services for any or all clients.  The user should consult the local\nsystem administrator\
    \ to find name servers willing to perform the\nservice.\nThis type of service\
    \ suffers from some drawbacks.  Since the recursive\nrequests may take an arbitrary\
    \ amount of time to perform, the stub may\nhave difficulty optimizing retransmission\
    \ intervals to deal with both\nlost UDP packets and dead servers; the name server\
    \ can be easily\noverloaded by too zealous a stub if it interprets retransmissions\
    \ as new\nrequests.  Use of TCP may be an answer, but TCP may well place burdens\n\
    on the host's capabilities which are similar to those of a real\nresolver.\n5.3.2.\
    \ Resources\nIn addition to its own resources, the resolver may also have shared\n\
    access to zones maintained by a local name server.  This gives the\nresolver the\
    \ advantage of more rapid access, but the resolver must be\ncareful to never let\
    \ cached information override zone data.  In this\ndiscussion the term \"local\
    \ information\" is meant to mean the union of\nthe cache and such shared zones,\
    \ with the understanding that\nauthoritative data is always used in preference\
    \ to cached data when both\nare present.\nThe following resolver algorithm assumes\
    \ that all functions have been\nconverted to a general lookup function, and uses\
    \ the following data\nstructures to represent the state of a request in progress\
    \ in the\nresolver:\nSNAME           the domain name we are searching for.\nSTYPE\
    \           the QTYPE of the search request.\nSCLASS          the QCLASS of the\
    \ search request.\nSLIST           a structure which describes the name servers\
    \ and the\n                zone which the resolver is currently trying to query.\n\
    \                This structure keeps track of the resolver's current\n      \
    \          best guess about which name servers hold the desired\n            \
    \    information; it is updated when arriving information\n                changes\
    \ the guess.  This structure includes the\n                equivalent of a zone\
    \ name, the known name servers for\n                the zone, the known addresses\
    \ for the name servers, and\n                history information which can be\
    \ used to suggest which\n                server is likely to be the best one to\
    \ try next.  The\n                zone name equivalent is a match count of the\
    \ number of\n                labels from the root down which SNAME has in common\
    \ with\n                the zone being queried; this is used as a measure of how\n\
    \                \"close\" the resolver is to SNAME.\nSBELT           a \"safety\
    \ belt\" structure of the same form as SLIST,\n                which is initialized\
    \ from a configuration file, and\n                lists servers which should be\
    \ used when the resolver\n                doesn't have any local information to\
    \ guide name server\n                selection.  The match count will be -1 to\
    \ indicate that\n                no labels are known to match.\nCACHE        \
    \   A structure which stores the results from previous\n                responses.\
    \  Since resolvers are responsible for\n                discarding old RRs whose\
    \ TTL has expired, most\n                implementations convert the interval\
    \ specified in\n                arriving RRs to some sort of absolute time when\
    \ the RR\n                is stored in the cache.  Instead of counting the TTLs\n\
    \                down individually, the resolver just ignores or discards\n  \
    \              old RRs when it runs across them in the course of a\n         \
    \       search, or discards them during periodic sweeps to\n                reclaim\
    \ the memory consumed by old RRs.\n5.3.3. Algorithm\nThe top level algorithm has\
    \ four steps:\n   1. See if the answer is in local information, and if so return\n\
    \      it to the client.\n   2. Find the best servers to ask.\n   3. Send them\
    \ queries until one returns a response.\n   4. Analyze the response, either:\n\
    \         a. if the response answers the question or contains a name\n       \
    \     error, cache the data as well as returning it back to\n            the client.\n\
    \         b. if the response contains a better delegation to other\n         \
    \   servers, cache the delegation information, and go to\n            step 2.\n\
    \         c. if the response shows a CNAME and that is not the\n            answer\
    \ itself, cache the CNAME, change the SNAME to the\n            canonical name\
    \ in the CNAME RR and go to step 1.\n         d. if the response shows a servers\
    \ failure or other\n            bizarre contents, delete the server from the SLIST\
    \ and\n            go back to step 3.\nStep 1 searches the cache for the desired\
    \ data. If the data is in the\ncache, it is assumed to be good enough for normal\
    \ use.  Some resolvers\nhave an option at the user interface which will force\
    \ the resolver to\nignore the cached data and consult with an authoritative server.\
    \  This\nis not recommended as the default.  If the resolver has direct access\
    \ to\na name server's zones, it should check to see if the desired data is\npresent\
    \ in authoritative form, and if so, use the authoritative data in\npreference\
    \ to cached data.\nStep 2 looks for a name server to ask for the required data.\
    \  The\ngeneral strategy is to look for locally-available name server RRs,\nstarting\
    \ at SNAME, then the parent domain name of SNAME, the\ngrandparent, and so on\
    \ toward the root.  Thus if SNAME were\nMockapetris.ISI.EDU, this step would look\
    \ for NS RRs for\nMockapetris.ISI.EDU, then ISI.EDU, then EDU, and then . (the\
    \ root).\nThese NS RRs list the names of hosts for a zone at or above SNAME. \
    \ Copy\nthe names into SLIST.  Set up their addresses using local data.  It may\n\
    be the case that the addresses are not available.  The resolver has many\nchoices\
    \ here; the best is to start parallel resolver processes looking\nfor the addresses\
    \ while continuing onward with the addresses which are\navailable.  Obviously,\
    \ the design choices and options are complicated\nand a function of the local\
    \ host's capabilities.  The recommended\npriorities for the resolver designer\
    \ are:\n   1. Bound the amount of work (packets sent, parallel processes\n   \
    \   started) so that a request can't get into an infinite loop or\n      start\
    \ off a chain reaction of requests or queries with other\n      implementations\
    \ EVEN IF SOMEONE HAS INCORRECTLY CONFIGURED\n      SOME DATA.\n   2. Get back\
    \ an answer if at all possible.\n   3. Avoid unnecessary transmissions.\n   4.\
    \ Get the answer as quickly as possible.\nIf the search for NS RRs fails, then\
    \ the resolver initializes SLIST from\nthe safety belt SBELT.  The basic idea\
    \ is that when the resolver has no\nidea what servers to ask, it should use information\
    \ from a configuration\nfile that lists several servers which are expected to\
    \ be helpful.\nAlthough there are special situations, the usual choice is two\
    \ of the\nroot servers and two of the servers for the host's domain.  The reason\n\
    for two of each is for redundancy.  The root servers will provide\neventual access\
    \ to all of the domain space.  The two local servers will\nallow the resolver\
    \ to continue to resolve local names if the local\nnetwork becomes isolated from\
    \ the internet due to gateway or link\nfailure.\nIn addition to the names and\
    \ addresses of the servers, the SLIST data\nstructure can be sorted to use the\
    \ best servers first, and to insure\nthat all addresses of all servers are used\
    \ in a round-robin manner.  The\nsorting can be a simple function of preferring\
    \ addresses on the local\nnetwork over others, or may involve statistics from\
    \ past events, such as\nprevious response times and batting averages.\nStep 3\
    \ sends out queries until a response is received.  The strategy is\nto cycle around\
    \ all of the addresses for all of the servers with a\ntimeout between each transmission.\
    \  In practice it is important to use\nall addresses of a multihomed host, and\
    \ too aggressive a retransmission\npolicy actually slows response when used by\
    \ multiple resolvers\ncontending for the same name server and even occasionally\
    \ for a single\nresolver.  SLIST typically contains data values to control the\
    \ timeouts\nand keep track of previous transmissions.\nStep 4 involves analyzing\
    \ responses.  The resolver should be highly\nparanoid in its parsing of responses.\
    \  It should also check that the\nresponse matches the query it sent using the\
    \ ID field in the response.\nThe ideal answer is one from a server authoritative\
    \ for the query which\neither gives the required data or a name error.  The data\
    \ is passed back\nto the user and entered in the cache for future use if its TTL\
    \ is\ngreater than zero.\nIf the response shows a delegation, the resolver should\
    \ check to see\nthat the delegation is \"closer\" to the answer than the servers\
    \ in SLIST\nare.  This can be done by comparing the match count in SLIST with\
    \ that\ncomputed from SNAME and the NS RRs in the delegation.  If not, the reply\n\
    is bogus and should be ignored.  If the delegation is valid the NS\ndelegation\
    \ RRs and any address RRs for the servers should be cached.\nThe name servers\
    \ are entered in the SLIST, and the search is restarted.\nIf the response contains\
    \ a CNAME, the search is restarted at the CNAME\nunless the response has the data\
    \ for the canonical name or if the CNAME\nis the answer itself.\nDetails and implementation\
    \ hints can be found in [RFC-1035].\n6. A SCENARIO\nIn our sample domain space,\
    \ suppose we wanted separate administrative\ncontrol for the root, MIL, EDU, MIT.EDU\
    \ and ISI.EDU zones.  We might\nallocate name servers as follows:\n          \
    \                         |(C.ISI.EDU,SRI-NIC.ARPA\n                         \
    \          | A.ISI.EDU)\n             +---------------------+------------------+\n\
    \             |                     |                  |\n            MIL    \
    \               EDU                ARPA\n             |(SRI-NIC.ARPA,       |(SRI-NIC.ARPA,\
    \    |\n             | A.ISI.EDU           | C.ISI.EDU)       |\n       +-----+-----+\
    \               |     +------+-----+-----+\n       |     |     |             \
    \  |     |      |           |\n      BRL  NOSC  DARPA             |  IN-ADDR \
    \ SRI-NIC     ACC\n                                   |\n       +--------+------------------+---------------+--------+\n\
    \       |        |                  |               |        |\n      UCI    \
    \  MIT                 |              UDEL     YALE\n                |(XX.LCS.MIT.EDU,\
    \ ISI\n                |ACHILLES.MIT.EDU) |(VAXA.ISI.EDU,VENERA.ISI.EDU,\n   \
    \         +---+---+              | A.ISI.EDU)\n            |       |         \
    \     |\n           LCS   ACHILLES +--+-----+-----+--------+\n            |  \
    \           |  |     |     |        |\n            XX            A  C   VAXA \
    \ VENERA Mockapetris\nIn this example, the authoritative name server is shown\
    \ in parentheses\nat the point in the domain tree at which is assumes control.\n\
    Thus the root name servers are on C.ISI.EDU, SRI-NIC.ARPA, and\nA.ISI.EDU.  The\
    \ MIL domain is served by SRI-NIC.ARPA and A.ISI.EDU.  The\nEDU domain is served\
    \ by SRI-NIC.ARPA. and C.ISI.EDU.  Note that servers\nmay have zones which are\
    \ contiguous or disjoint.  In this scenario,\nC.ISI.EDU has contiguous zones at\
    \ the root and EDU domains.  A.ISI.EDU\nhas contiguous zones at the root and MIL\
    \ domains, but also has a non-\ncontiguous zone at ISI.EDU.\n6.1. C.ISI.EDU name\
    \ server\nC.ISI.EDU is a name server for the root, MIL, and EDU domains of the\
    \ IN\nclass, and would have zones for these domains.  The zone data for the\n\
    root domain might be:\n    .       IN      SOA     SRI-NIC.ARPA. HOSTMASTER.SRI-NIC.ARPA.\
    \ (\n                            870611          ;serial\n                   \
    \         1800            ;refresh every 30 min\n                            300\
    \             ;retry every 5 min\n                            604800         \
    \ ;expire after a week\n                            86400)          ;minimum of\
    \ a day\n                    NS      A.ISI.EDU.\n                    NS      C.ISI.EDU.\n\
    \                    NS      SRI-NIC.ARPA.\n    MIL.    86400   NS      SRI-NIC.ARPA.\n\
    \            86400   NS      A.ISI.EDU.\n    EDU.    86400   NS      SRI-NIC.ARPA.\n\
    \            86400   NS      C.ISI.EDU.\n    SRI-NIC.ARPA.   A       26.0.0.73\n\
    \                    A       10.0.0.51\n                    MX      0 SRI-NIC.ARPA.\n\
    \                    HINFO   DEC-2060 TOPS20\n    ACC.ARPA.       A       26.6.0.65\n\
    \                    HINFO   PDP-11/70 UNIX\n                    MX      10 ACC.ARPA.\n\
    \    USC-ISIC.ARPA.  CNAME   C.ISI.EDU.\n    73.0.0.26.IN-ADDR.ARPA.  PTR    SRI-NIC.ARPA.\n\
    \    65.0.6.26.IN-ADDR.ARPA.  PTR    ACC.ARPA.\n    51.0.0.10.IN-ADDR.ARPA.  PTR\
    \    SRI-NIC.ARPA.\n    52.0.0.10.IN-ADDR.ARPA.  PTR    C.ISI.EDU.\n    103.0.3.26.IN-ADDR.ARPA.\
    \ PTR    A.ISI.EDU.\n    A.ISI.EDU. 86400 A      26.3.0.103\n    C.ISI.EDU. 86400\
    \ A      10.0.0.52\nThis data is represented as it would be in a master file.\
    \  Most RRs are\nsingle line entries; the sole exception here is the SOA RR, which\
    \ uses\n\"(\" to start a multi-line RR and \")\" to show the end of a multi-line\
    \ RR.\nSince the class of all RRs in a zone must be the same, only the first RR\n\
    in a zone need specify the class.  When a name server loads a zone, it\nforces\
    \ the TTL of all authoritative RRs to be at least the MINIMUM field\nof the SOA,\
    \ here 86400 seconds, or one day.  The NS RRs marking\ndelegation of the MIL and\
    \ EDU domains, together with the glue RRs for\nthe servers host addresses, are\
    \ not part of the authoritative data in\nthe zone, and hence have explicit TTLs.\n\
    Four RRs are attached to the root node: the SOA which describes the root\nzone\
    \ and the 3 NS RRs which list the name servers for the root.  The\ndata in the\
    \ SOA RR describes the management of the zone.  The zone data\nis maintained on\
    \ host SRI-NIC.ARPA, and the responsible party for the\nzone is HOSTMASTER@SRI-NIC.ARPA.\
    \  A key item in the SOA is the 86400\nsecond minimum TTL, which means that all\
    \ authoritative data in the zone\nhas at least that TTL, although higher values\
    \ may be explicitly\nspecified.\nThe NS RRs for the MIL and EDU domains mark the\
    \ boundary between the\nroot zone and the MIL and EDU zones.  Note that in this\
    \ example, the\nlower zones happen to be supported by name servers which also\
    \ support\nthe root zone.\nThe master file for the EDU zone might be stated relative\
    \ to the origin\nEDU.  The zone data for the EDU domain might be:\n    EDU.  IN\
    \ SOA SRI-NIC.ARPA. HOSTMASTER.SRI-NIC.ARPA. (\n                            870729\
    \ ;serial\n                            1800 ;refresh every 30 minutes\n      \
    \                      300 ;retry every 5 minutes\n                          \
    \  604800 ;expire after a week\n                            86400 ;minimum of\
    \ a day\n                            )\n                    NS SRI-NIC.ARPA.\n\
    \                    NS C.ISI.EDU.\n    UCI 172800 NS ICS.UCI\n              \
    \      172800 NS ROME.UCI\n    ICS.UCI 172800 A 192.5.19.1\n    ROME.UCI 172800\
    \ A 192.5.19.31\n    ISI 172800 NS VAXA.ISI\n                    172800 NS A.ISI\n\
    \                    172800 NS VENERA.ISI.EDU.\n    VAXA.ISI 172800 A 10.2.0.27\n\
    \                    172800 A 128.9.0.33\n    VENERA.ISI.EDU. 172800 A 10.1.0.52\n\
    \                    172800 A 128.9.0.32\n    A.ISI 172800 A 26.3.0.103\n    UDEL.EDU.\
    \  172800 NS LOUIE.UDEL.EDU.\n                    172800 NS UMN-REI-UC.ARPA.\n\
    \    LOUIE.UDEL.EDU. 172800 A 10.0.0.96\n                    172800 A 192.5.39.3\n\
    \    YALE.EDU.  172800 NS YALE.ARPA.\n    YALE.EDU.  172800 NS YALE-BULLDOG.ARPA.\n\
    \    MIT.EDU.  43200 NS XX.LCS.MIT.EDU.\n                      43200 NS ACHILLES.MIT.EDU.\n\
    \    XX.LCS.MIT.EDU.  43200 A 10.0.0.44\n    ACHILLES.MIT.EDU. 43200 A 18.72.0.8\n\
    Note the use of relative names here.  The owner name for the ISI.EDU. is\nstated\
    \ using a relative name, as are two of the name server RR contents.\nRelative\
    \ and absolute domain names may be freely intermixed in a master\n6.2. Example\
    \ standard queries\nThe following queries and responses illustrate name server\
    \ behavior.\nUnless otherwise noted, the queries do not have recursion desired\
    \ (RD)\nin the header.  Note that the answers to non-recursive queries do depend\n\
    on the server being asked, but do not depend on the identity of the\nrequester.\n\
    6.2.1. QNAME=SRI-NIC.ARPA, QTYPE=A\nThe query would look like:\n             \
    \  +---------------------------------------------------+\n    Header     | OPCODE=SQUERY\
    \                                     |\n               +---------------------------------------------------+\n\
    \    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A           |\n      \
    \         +---------------------------------------------------+\n    Answer  \
    \   | <empty>                                           |\n               +---------------------------------------------------+\n\
    \    Authority  | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Additional\
    \ | <empty>                                           |\n               +---------------------------------------------------+\n\
    The response from C.ISI.EDU would be:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE, AA                       |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A           |\n               +---------------------------------------------------+\n\
    \    Answer     | SRI-NIC.ARPA. 86400 IN A 26.0.0.73                |\n      \
    \         |               86400 IN A 10.0.0.51                |\n            \
    \   +---------------------------------------------------+\n    Authority  | <empty>\
    \                                           |\n               +---------------------------------------------------+\n\
    \    Additional | <empty>                                           |\n      \
    \         +---------------------------------------------------+\nThe header of\
    \ the response looks like the header of the query, except\nthat the RESPONSE bit\
    \ is set, indicating that this message is a\nresponse, not a query, and the Authoritative\
    \ Answer (AA) bit is set\nindicating that the address RRs in the answer section\
    \ are from\nauthoritative data.  The question section of the response matches\
    \ the\nquestion section of the query.\nIf the same query was sent to some other\
    \ server which was not\nauthoritative for SRI-NIC.ARPA, the response might be:\n\
    \               +---------------------------------------------------+\n    Header\
    \     | OPCODE=SQUERY,RESPONSE                            |\n               +---------------------------------------------------+\n\
    \    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A           |\n      \
    \         +---------------------------------------------------+\n    Answer  \
    \   | SRI-NIC.ARPA. 1777 IN A 10.0.0.51                 |\n               |  \
    \             1777 IN A 26.0.0.73                 |\n               +---------------------------------------------------+\n\
    \    Authority  | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Additional\
    \ | <empty>                                           |\n               +---------------------------------------------------+\n\
    This response is different from the previous one in two ways: the header\ndoes\
    \ not have AA set, and the TTLs are different.  The inference is that\nthe data\
    \ did not come from a zone, but from a cache.  The difference\nbetween the authoritative\
    \ TTL and the TTL here is due to aging of the\ndata in a cache.  The difference\
    \ in ordering of the RRs in the answer\nsection is not significant.\n6.2.2. QNAME=SRI-NIC.ARPA,\
    \ QTYPE=*\nA query similar to the previous one, but using a QTYPE of *, would\n\
    receive the following response from C.ISI.EDU:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE, AA                       |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=*           |\n               +---------------------------------------------------+\n\
    \    Answer     | SRI-NIC.ARPA. 86400 IN  A     26.0.0.73           |\n      \
    \         |                         A     10.0.0.51           |\n            \
    \   |                         MX    0 SRI-NIC.ARPA.     |\n               |  \
    \                       HINFO DEC-2060 TOPS20     |\n               +---------------------------------------------------+\n\
    \    Authority  | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Additional\
    \ | <empty>                                           |\n               +---------------------------------------------------+\n\
    If a similar query was directed to two name servers which are not\nauthoritative\
    \ for SRI-NIC.ARPA, the responses might be:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE                           |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=*           |\n               +---------------------------------------------------+\n\
    \    Answer     | SRI-NIC.ARPA. 12345 IN     A       26.0.0.73      |\n      \
    \         |                            A       10.0.0.51      |\n            \
    \   +---------------------------------------------------+\n    Authority  | <empty>\
    \                                           |\n               +---------------------------------------------------+\n\
    \    Additional | <empty>                                           |\n      \
    \         +---------------------------------------------------+\nand\n       \
    \        +---------------------------------------------------+\n    Header   \
    \  | OPCODE=SQUERY, RESPONSE                           |\n               +---------------------------------------------------+\n\
    \    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=*           |\n      \
    \         +---------------------------------------------------+\n    Answer  \
    \   | SRI-NIC.ARPA. 1290 IN HINFO  DEC-2060 TOPS20      |\n               +---------------------------------------------------+\n\
    \    Authority  | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Additional\
    \ | <empty>                                           |\n               +---------------------------------------------------+\n\
    Neither of these answers have AA set, so neither response comes from\nauthoritative\
    \ data.  The different contents and different TTLs suggest\nthat the two servers\
    \ cached data at different times, and that the first\nserver cached the response\
    \ to a QTYPE=A query and the second cached the\nresponse to a HINFO query.\n6.2.3.\
    \ QNAME=SRI-NIC.ARPA, QTYPE=MX\nThis type of query might be result from a mailer\
    \ trying to look up\nrouting information for the mail destination HOSTMASTER@SRI-NIC.ARPA.\n\
    The response from C.ISI.EDU would be:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE, AA                       |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=MX          |\n               +---------------------------------------------------+\n\
    \    Answer     | SRI-NIC.ARPA. 86400 IN     MX      0 SRI-NIC.ARPA.|\n      \
    \         +---------------------------------------------------+\n    Authority\
    \  | <empty>                                           |\n               +---------------------------------------------------+\n\
    \    Additional | SRI-NIC.ARPA. 86400 IN     A       26.0.0.73      |\n      \
    \         |                            A       10.0.0.51      |\n            \
    \   +---------------------------------------------------+\nThis response contains\
    \ the MX RR in the answer section of the response.\nThe additional section contains\
    \ the address RRs because the name server\nat C.ISI.EDU guesses that the requester\
    \ will need the addresses in order\nto properly use the information carried by\
    \ the MX.\n6.2.4. QNAME=SRI-NIC.ARPA, QTYPE=NS\nC.ISI.EDU would reply to this\
    \ query with:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE, AA                       |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=NS          |\n               +---------------------------------------------------+\n\
    \    Answer     | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Authority\
    \  | <empty>                                           |\n               +---------------------------------------------------+\n\
    \    Additional | <empty>                                           |\n      \
    \         +---------------------------------------------------+\nThe only difference\
    \ between the response and the query is the AA and\nRESPONSE bits in the header.\
    \  The interpretation of this response is\nthat the server is authoritative for\
    \ the name, and the name exists, but\nno RRs of type NS are present there.\n6.2.5.\
    \ QNAME=SIR-NIC.ARPA, QTYPE=A\nIf a user mistyped a host name, we might see this\
    \ type of query.\nC.ISI.EDU would answer it with:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE, AA, RCODE=NE             |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=SIR-NIC.ARPA., QCLASS=IN, QTYPE=A           |\n               +---------------------------------------------------+\n\
    \    Answer     | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Authority\
    \  | . SOA SRI-NIC.ARPA. HOSTMASTER.SRI-NIC.ARPA.      |\n               |   \
    \    870611 1800 300 604800 86400                |\n               +---------------------------------------------------+\n\
    \    Additional | <empty>                                           |\n      \
    \         +---------------------------------------------------+\nThis response\
    \ states that the name does not exist.  This condition is\nsignalled in the response\
    \ code (RCODE) section of the header.\nThe SOA RR in the authority section is\
    \ the optional negative caching\ninformation which allows the resolver using this\
    \ response to assume that\nthe name will not exist for the SOA MINIMUM (86400)\
    \ seconds.\n6.2.6. QNAME=BRL.MIL, QTYPE=A\nIf this query is sent to C.ISI.EDU,\
    \ the reply would be:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE                           |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=BRL.MIL, QCLASS=IN, QTYPE=A                 |\n               +---------------------------------------------------+\n\
    \    Answer     | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Authority\
    \  | MIL.             86400 IN NS       SRI-NIC.ARPA.  |\n               |   \
    \               86400    NS       A.ISI.EDU.     |\n               +---------------------------------------------------+\n\
    \    Additional | A.ISI.EDU.                A        26.3.0.103     |\n      \
    \         | SRI-NIC.ARPA.             A        26.0.0.73      |\n            \
    \   |                           A        10.0.0.51      |\n               +---------------------------------------------------+\n\
    This response has an empty answer section, but is not authoritative, so\nit is\
    \ a referral.  The name server on C.ISI.EDU, realizing that it is\nnot authoritative\
    \ for the MIL domain, has referred the requester to\nservers on A.ISI.EDU and\
    \ SRI-NIC.ARPA, which it knows are authoritative\nfor the MIL domain.\n6.2.7.\
    \ QNAME=USC-ISIC.ARPA, QTYPE=A\nThe response to this query from A.ISI.EDU would\
    \ be:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE, AA                       |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=USC-ISIC.ARPA., QCLASS=IN, QTYPE=A          |\n               +---------------------------------------------------+\n\
    \    Answer     | USC-ISIC.ARPA. 86400 IN CNAME      C.ISI.EDU.     |\n      \
    \         | C.ISI.EDU.     86400 IN A          10.0.0.52      |\n            \
    \   +---------------------------------------------------+\n    Authority  | <empty>\
    \                                           |\n               +---------------------------------------------------+\n\
    \    Additional | <empty>                                           |\n      \
    \         +---------------------------------------------------+\nNote that the\
    \ AA bit in the header guarantees that the data matching\nQNAME is authoritative,\
    \ but does not say anything about whether the data\nfor C.ISI.EDU is authoritative.\
    \  This complete reply is possible because\nA.ISI.EDU happens to be authoritative\
    \ for both the ARPA domain where\nUSC-ISIC.ARPA is found and the ISI.EDU domain\
    \ where C.ISI.EDU data is\nfound.\nIf the same query was sent to C.ISI.EDU, its\
    \ response might be the same\nas shown above if it had its own address in its\
    \ cache, but might also\nbe:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE, AA                       |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=USC-ISIC.ARPA., QCLASS=IN, QTYPE=A          |\n               +---------------------------------------------------+\n\
    \    Answer     | USC-ISIC.ARPA.   86400 IN CNAME   C.ISI.EDU.      |\n      \
    \         +---------------------------------------------------+\n    Authority\
    \  | ISI.EDU.        172800 IN NS      VAXA.ISI.EDU.   |\n               |   \
    \                        NS      A.ISI.EDU.      |\n               |         \
    \                  NS      VENERA.ISI.EDU. |\n               +---------------------------------------------------+\n\
    \    Additional | VAXA.ISI.EDU.   172800    A       10.2.0.27       |\n      \
    \         |                 172800    A       128.9.0.33      |\n            \
    \   | VENERA.ISI.EDU. 172800    A       10.1.0.52       |\n               |  \
    \               172800    A       128.9.0.32      |\n               | A.ISI.EDU.\
    \      172800    A       26.3.0.103      |\n               +---------------------------------------------------+\n\
    This reply contains an authoritative reply for the alias USC-ISIC.ARPA,\nplus\
    \ a referral to the name servers for ISI.EDU.  This sort of reply\nisn't very\
    \ likely given that the query is for the host name of the name\nserver being asked,\
    \ but would be common for other aliases.\n6.2.8. QNAME=USC-ISIC.ARPA, QTYPE=CNAME\n\
    If this query is sent to either A.ISI.EDU or C.ISI.EDU, the reply would\nbe:\n\
    \               +---------------------------------------------------+\n    Header\
    \     | OPCODE=SQUERY, RESPONSE, AA                       |\n               +---------------------------------------------------+\n\
    \    Question   | QNAME=USC-ISIC.ARPA., QCLASS=IN, QTYPE=A          |\n      \
    \         +---------------------------------------------------+\n    Answer  \
    \   | USC-ISIC.ARPA. 86400 IN CNAME      C.ISI.EDU.     |\n               +---------------------------------------------------+\n\
    \    Authority  | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Additional\
    \ | <empty>                                           |\n               +---------------------------------------------------+\n\
    Because QTYPE=CNAME, the CNAME RR itself answers the query, and the name\nserver\
    \ doesn't attempt to look up anything for C.ISI.EDU.  (Except\npossibly for the\
    \ additional section.)\n6.3. Example resolution\nThe following examples illustrate\
    \ the operations a resolver must perform\nfor its client.  We assume that the\
    \ resolver is starting without a\ncache, as might be the case after system boot.\
    \  We further assume that\nthe system is not one of the hosts in the data and\
    \ that the host is\nlocated somewhere on net 26, and that its safety belt (SBELT)\
    \ data\nstructure has the following information:\n    Match count = -1\n    SRI-NIC.ARPA.\
    \   26.0.0.73       10.0.0.51\n    A.ISI.EDU.      26.3.0.103\nThis information\
    \ specifies servers to try, their addresses, and a match\ncount of -1, which says\
    \ that the servers aren't very close to the\ntarget.  Note that the -1 isn't supposed\
    \ to be an accurate closeness\nmeasure, just a value so that later stages of the\
    \ algorithm will work.\nThe following examples illustrate the use of a cache,\
    \ so each example\nassumes that previous requests have completed.\n6.3.1. Resolve\
    \ MX for ISI.EDU.\nSuppose the first request to the resolver comes from the local\
    \ mailer,\nwhich has mail for PVM@ISI.EDU.  The mailer might then ask for type\
    \ MX\nRRs for the domain name ISI.EDU.\nThe resolver would look in its cache for\
    \ MX RRs at ISI.EDU, but the\nempty cache wouldn't be helpful.  The resolver would\
    \ recognize that it\nneeded to query foreign servers and try to determine the\
    \ best servers to\nquery.  This search would look for NS RRs for the domains ISI.EDU,\
    \ EDU,\nand the root.  These searches of the cache would also fail.  As a last\n\
    resort, the resolver would use the information from the SBELT, copying\nit into\
    \ its SLIST structure.\nAt this point the resolver would need to pick one of the\
    \ three available\naddresses to try.  Given that the resolver is on net 26, it\
    \ should\nchoose either 26.0.0.73 or 26.3.0.103 as its first choice.  It would\n\
    then send off a query of the form:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY                                     |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=ISI.EDU., QCLASS=IN, QTYPE=MX               |\n               +---------------------------------------------------+\n\
    \    Answer     | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Authority\
    \  | <empty>                                           |\n               +---------------------------------------------------+\n\
    \    Additional | <empty>                                           |\n      \
    \         +---------------------------------------------------+\nThe resolver\
    \ would then wait for a response to its query or a timeout.\nIf the timeout occurs,\
    \ it would try different servers, then different\naddresses of the same servers,\
    \ lastly retrying addresses already tried.\nIt might eventually receive a reply\
    \ from SRI-NIC.ARPA:\n               +---------------------------------------------------+\n\
    \    Header     | OPCODE=SQUERY, RESPONSE                           |\n      \
    \         +---------------------------------------------------+\n    Question\
    \   | QNAME=ISI.EDU., QCLASS=IN, QTYPE=MX               |\n               +---------------------------------------------------+\n\
    \    Answer     | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Authority\
    \  | ISI.EDU.        172800 IN NS       VAXA.ISI.EDU.  |\n               |   \
    \                        NS       A.ISI.EDU.     |\n               |         \
    \                  NS       VENERA.ISI.EDU.|\n               +---------------------------------------------------+\n\
    \    Additional | VAXA.ISI.EDU.   172800    A        10.2.0.27      |\n      \
    \         |                 172800    A        128.9.0.33     |\n            \
    \   | VENERA.ISI.EDU. 172800    A        10.1.0.52      |\n               |  \
    \               172800    A        128.9.0.32     |\n               | A.ISI.EDU.\
    \      172800    A        26.3.0.103     |\n               +---------------------------------------------------+\n\
    The resolver would notice that the information in the response gave a\ncloser\
    \ delegation to ISI.EDU than its existing SLIST (since it matches\nthree labels).\
    \  The resolver would then cache the information in this\nresponse and use it\
    \ to set up a new SLIST:\n    Match count = 3\n    A.ISI.EDU.      26.3.0.103\n\
    \    VAXA.ISI.EDU.   10.2.0.27       128.9.0.33\n    VENERA.ISI.EDU. 10.1.0.52\
    \       128.9.0.32\nA.ISI.EDU appears on this list as well as the previous one,\
    \ but that is\npurely coincidental.  The resolver would again start transmitting\
    \ and\nwaiting for responses.  Eventually it would get an answer:\n          \
    \     +---------------------------------------------------+\n    Header     |\
    \ OPCODE=SQUERY, RESPONSE, AA                       |\n               +---------------------------------------------------+\n\
    \    Question   | QNAME=ISI.EDU., QCLASS=IN, QTYPE=MX               |\n      \
    \         +---------------------------------------------------+\n    Answer  \
    \   | ISI.EDU.                MX 10 VENERA.ISI.EDU.     |\n               |  \
    \                       MX 20 VAXA.ISI.EDU.       |\n               +---------------------------------------------------+\n\
    \    Authority  | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Additional\
    \ | VAXA.ISI.EDU.   172800  A  10.2.0.27              |\n               |    \
    \             172800  A  128.9.0.33             |\n               | VENERA.ISI.EDU.\
    \ 172800  A  10.1.0.52              |\n               |                 172800\
    \  A  128.9.0.32             |\n               +---------------------------------------------------+\n\
    The resolver would add this information to its cache, and return the MX\nRRs to\
    \ its client.\n6.3.2. Get the host name for address 26.6.0.65\nThe resolver would\
    \ translate this into a request for PTR RRs for\n65.0.6.26.IN-ADDR.ARPA.  This\
    \ information is not in the cache, so the\nresolver would look for foreign servers\
    \ to ask.  No servers would match,\nso it would use SBELT again.  (Note that the\
    \ servers for the ISI.EDU\ndomain are in the cache, but ISI.EDU is not an ancestor\
    \ of\n65.0.6.26.IN-ADDR.ARPA, so the SBELT is used.)\nSince this request is within\
    \ the authoritative data of both servers in\nSBELT, eventually one would return:\n\
    \               +---------------------------------------------------+\n    Header\
    \     | OPCODE=SQUERY, RESPONSE, AA                       |\n               +---------------------------------------------------+\n\
    \    Question   | QNAME=65.0.6.26.IN-ADDR.ARPA.,QCLASS=IN,QTYPE=PTR |\n      \
    \         +---------------------------------------------------+\n    Answer  \
    \   | 65.0.6.26.IN-ADDR.ARPA.    PTR     ACC.ARPA.      |\n               +---------------------------------------------------+\n\
    \    Authority  | <empty>                                           |\n      \
    \         +---------------------------------------------------+\n    Additional\
    \ | <empty>                                           |\n               +---------------------------------------------------+\n\
    6.3.3. Get the host address of poneria.ISI.EDU\nThis request would translate into\
    \ a type A request for poneria.ISI.EDU.\nThe resolver would not find any cached\
    \ data for this name, but would\nfind the NS RRs in the cache for ISI.EDU when\
    \ it looks for foreign\nservers to ask.  Using this data, it would construct a\
    \ SLIST of the\nform:\n    Match count = 3\n    A.ISI.EDU.      26.3.0.103\n \
    \   VAXA.ISI.EDU.   10.2.0.27       128.9.0.33\n    VENERA.ISI.EDU. 10.1.0.52\n\
    A.ISI.EDU is listed first on the assumption that the resolver orders its\nchoices\
    \ by preference, and A.ISI.EDU is on the same network.\nOne of these servers would\
    \ answer the query.\n7. REFERENCES and BIBLIOGRAPHY\n[Dyer 87]       Dyer, S.,\
    \ and F. Hsu, \"Hesiod\", Project Athena\n                Technical Plan - Name\
    \ Service, April 1987, version 1.9.\n                Describes the fundamentals\
    \ of the Hesiod name service.\n[IEN-116]       J. Postel, \"Internet Name Server\"\
    , IEN-116,\n                USC/Information Sciences Institute, August 1979.\n\
    \                A name service obsoleted by the Domain Name System, but\n   \
    \             still in use.\n[Quarterman 86] Quarterman, J., and J. Hoskins, \"\
    Notable Computer\n                Networks\",Communications of the ACM, October\
    \ 1986,\n                volume 29, number 10.\n[RFC-742]       K. Harrenstien,\
    \ \"NAME/FINGER\", RFC-742, Network\n                Information Center, SRI International,\
    \ December 1977.\n[RFC-768]       J. Postel, \"User Datagram Protocol\", RFC-768,\n\
    \                USC/Information Sciences Institute, August 1980.\n[RFC-793] \
    \      J. Postel, \"Transmission Control Protocol\", RFC-793,\n              \
    \  USC/Information Sciences Institute, September 1981.\n[RFC-799]       D. Mills,\
    \ \"Internet Name Domains\", RFC-799, COMSAT,\n                September 1981.\n\
    \                Suggests introduction of a hierarchy in place of a flat\n   \
    \             name space for the Internet.\n[RFC-805]       J. Postel, \"Computer\
    \ Mail Meeting Notes\", RFC-805,\n                USC/Information Sciences Institute,\
    \ February 1982.\n[RFC-810]       E. Feinler, K. Harrenstien, Z. Su, and V. White,\
    \ \"DOD\n                Internet Host Table Specification\", RFC-810, Network\n\
    \                Information Center, SRI International, March 1982.\n        \
    \        Obsolete.  See RFC-952.\n[RFC-811]       K. Harrenstien, V. White, and\
    \ E. Feinler, \"Hostnames\n                Server\", RFC-811, Network Information\
    \ Center, SRI\n                International, March 1982.\n                Obsolete.\
    \  See RFC-953.\n[RFC-812]       K. Harrenstien, and V. White, \"NICNAME/WHOIS\"\
    , RFC-812,\n                Network Information Center, SRI International, March\n\
    \                1982.\n[RFC-819]       Z. Su, and J. Postel, \"The Domain Naming\
    \ Convention for\n                Internet User Applications\", RFC-819, Network\n\
    \                Information Center, SRI International, August 1982.\n       \
    \         Early thoughts on the design of the domain system.\n               \
    \ Current implementation is completely different.\n[RFC-821]       J. Postel,\
    \ \"Simple Mail Transfer Protocol\", RFC-821,\n                USC/Information\
    \ Sciences Institute, August 1980.\n[RFC-830]       Z. Su, \"A Distributed System\
    \ for Internet Name Service\",\n                RFC-830, Network Information Center,\
    \ SRI International,\n                October 1982.\n                Early thoughts\
    \ on the design of the domain system.\n                Current implementation\
    \ is completely different.\n[RFC-882]       P. Mockapetris, \"Domain names - Concepts\
    \ and\n                Facilities,\" RFC-882, USC/Information Sciences\n     \
    \           Institute, November 1983.\n                Superceeded by this memo.\n\
    [RFC-883]       P. Mockapetris, \"Domain names - Implementation and\n        \
    \        Specification,\" RFC-883, USC/Information Sciences\n                Institute,\
    \ November 1983.\n                Superceeded by this memo.\n[RFC-920]       J.\
    \ Postel and J. Reynolds, \"Domain Requirements\",\n                RFC-920, USC/Information\
    \ Sciences Institute\n                October 1984.\n                Explains\
    \ the naming scheme for top level domains.\n[RFC-952]       K. Harrenstien, M.\
    \ Stahl, E. Feinler, \"DoD Internet Host\n                Table Specification\"\
    , RFC-952, SRI, October 1985.\n                Specifies the format of HOSTS.TXT,\
    \ the host/address\n                table replaced by the DNS.\n[RFC-953]    \
    \   K. Harrenstien, M. Stahl, E. Feinler, \"HOSTNAME Server\",\n             \
    \   RFC-953, SRI, October 1985.\n                This RFC contains the official\
    \ specification of the\n                hostname server protocol, which is obsoleted\
    \ by the DNS.\n                This TCP based protocol accesses information stored\
    \ in\n                the RFC-952 format, and is used to obtain copies of the\n\
    \                host table.\n[RFC-973]       P. Mockapetris, \"Domain System\
    \ Changes and\n                Observations\", RFC-973, USC/Information Sciences\n\
    \                Institute, January 1986.\n                Describes changes to\
    \ RFC-882 and RFC-883 and reasons for\n                them.  Now obsolete.\n\
    [RFC-974]       C. Partridge, \"Mail routing and the domain system\",\n      \
    \          RFC-974, CSNET CIC BBN Labs, January 1986.\n                Describes\
    \ the transition from HOSTS.TXT based mail\n                addressing to the\
    \ more powerful MX system used with the\n                domain system.\n[RFC-1001]\
    \      NetBIOS Working Group, \"Protocol standard for a NetBIOS\n            \
    \    service on a TCP/UDP transport: Concepts and Methods\",\n               \
    \ RFC-1001, March 1987.\n                This RFC and RFC-1002 are a preliminary\
    \ design for\n                NETBIOS on top of TCP/IP which proposes to base\
    \ NetBIOS\n                name service on top of the DNS.\n[RFC-1002]      NetBIOS\
    \ Working Group, \"Protocol standard for a NetBIOS\n                service on\
    \ a TCP/UDP transport: Detailed\n                Specifications\", RFC-1002, March\
    \ 1987.\n[RFC-1010]      J. Reynolds and J. Postel, \"Assigned Numbers\", RFC-1010,\n\
    \                USC/Information Sciences Institute, May 1987\n              \
    \  Contains socket numbers and mnemonics for host names,\n                operating\
    \ systems, etc.\n[RFC-1031]      W. Lazear, \"MILNET Name Domain Transition\"\
    , RFC-1031,\n                November 1987.\n                Describes a plan\
    \ for converting the MILNET to the DNS.\n[RFC-1032]      M. K. Stahl, \"Establishing\
    \ a Domain - Guidelines for\n                Administrators\", RFC-1032, November\
    \ 1987.\n                Describes the registration policies used by the NIC to\n\
    \                administer the top level domains and delegate subzones.\n[RFC-1033]\
    \      M. K. Lottor, \"Domain Administrators Operations Guide\",\n           \
    \     RFC-1033, November 1987.\n                A cookbook for domain administrators.\n\
    [Solomon 82]    M. Solomon, L. Landweber, and D. Neuhengen, \"The CSNET\n    \
    \            Name Server\", Computer Networks, vol 6, nr 3, July 1982.\n     \
    \           Describes a name service for CSNET which is independent\n        \
    \        from the DNS and DNS use in the CSNET.\nIndex\n          A   12\n   \
    \       Absolute names   8\n          Aliases   14, 31\n          Authority  \
    \ 6\n          AXFR   17\n          Case of characters   7\n          CH   12\n\
    \          CNAME   12, 13, 31\n          Completion queries   18\n          Domain\
    \ name   6, 7\n          Glue RRs   20\n          HINFO   12\n          IN   12\n\
    \          Inverse queries   16\n          Iterative   4\n          Label   7\n\
    \          Mailbox names   9\n          MX   12\n          Name error   27, 36\n\
    \          Name servers   5, 17\n          NE   30\n          Negative caching\
    \   44\n          NS   12\n          Opcode   16\n          PTR   12\n       \
    \   QCLASS   16\n          QTYPE   16\n          RDATA   13\n          Recursive\
    \   4\n          Recursive service   22\n          Relative names   7\n      \
    \    Resolvers   6\n          RR   12\n          Safety belt   33\n          Sections\
    \   16\n          SOA   12\n          Standard queries   22\n          Status\
    \ queries   18\n          Stub resolvers   32\n          TTL   12, 13\n      \
    \    Wildcards   25\n          Zone transfers   28\n          Zones   19\n"
