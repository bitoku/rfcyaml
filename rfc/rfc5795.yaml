- contents:
  - '             The RObust Header Compression (ROHC) Framework

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Robust Header Compression (ROHC) protocol provides an efficient,\n
    \  flexible, and future-proof header compression concept.  It is\n   designed
    to operate efficiently and robustly over various link\n   technologies with different
    characteristics.\n   The ROHC framework, along with a set of compression profiles,
    was\n   initially defined in RFC 3095.  To improve and simplify the ROHC\n   specifications,
    this document explicitly defines the ROHC framework\n   and the profile for uncompressed
    separately.  More specifically, the\n   definition of the framework does not modify
    or update the definition\n   of the framework specified by RFC 3095.\n   This
    specification obsoletes RFC 4995.  It fixes one interoperability\n   issue that
    was erroneously introduced in RFC 4995, and adds some\n   minor clarifications.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5795.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . . .
    . . . .  5\n     2.1.  Acronyms . . . . . . . . . . . . . . . . . . . . . . .
    . .  5\n     2.2.  ROHC Terminology . . . . . . . . . . . . . . . . . . . . .
    \ 5\n   3.  Background (Informative) . . . . . . . . . . . . . . . . . . .  8\n
    \    3.1.  Header Compression Fundamentals  . . . . . . . . . . . . .  8\n     3.2.
    \ A Short History of Header Compression  . . . . . . . . . .  9\n   4.  Overview
    of ROHC (Informative) . . . . . . . . . . . . . . . . 10\n     4.1.  General Principles
    . . . . . . . . . . . . . . . . . . . . 10\n     4.2.  Compression Efficiency,
    Robustness, and Transparency . . . 11\n     4.3.  Developing the ROHC Protocol
    . . . . . . . . . . . . . . . 12\n     4.4.  Operational Characteristics of the
    ROHC Channel  . . . . . 13\n     4.5.  Compression and Master Sequence Number
    (MSN) . . . . . . . 14\n     4.6.  Static and Dynamic Parts of a Context  . .
    . . . . . . . . 15\n   5.  The ROHC Framework (Normative) . . . . . . . . . .
    . . . . . . 15\n     5.1.  The ROHC Channel . . . . . . . . . . . . . . . . .
    . . . . 15\n       5.1.1.  Contexts and Context Identifiers . . . . . . . . .
    . . 15\n       5.1.2.  Per-Channel Parameters . . . . . . . . . . . . . . . .
    16\n       5.1.3.  Persistence of Decompressor Contexts . . . . . . . . . 17\n
    \    5.2.  ROHC Packets and Packet Types  . . . . . . . . . . . . . . 17\n       5.2.1.
    \ General Format of ROHC Packets . . . . . . . . . . . . 18\n         5.2.1.1.
    \ Format of the Padding Octet  . . . . . . . . . . . 19\n         5.2.1.2.  Format
    of the Add-CID Octet  . . . . . . . . . . . 19\n         5.2.1.3.  General Format
    of Header . . . . . . . . . . . . . 19\n       5.2.2.  Initialization and Refresh
    (IR) Packet Types . . . . . 20\n         5.2.2.1.  ROHC IR Header Format  . .
    . . . . . . . . . . . . 20\n         5.2.2.2.  ROHC IR-DYN Header Format  . .
    . . . . . . . . . . 21\n       5.2.3.  ROHC Initial Decompressor Processing .
    . . . . . . . . 22\n       5.2.4.  ROHC Feedback  . . . . . . . . . . . . . .
    . . . . . . 23\n         5.2.4.1.  ROHC Feedback Format . . . . . . . . . . .
    . . . . 24\n       5.2.5.  ROHC Segmentation  . . . . . . . . . . . . . . . .
    . . 26\n         5.2.5.1.  Segmentation Usage Considerations  . . . . . . . .
    26\n         5.2.5.2.  Segmentation Protocol  . . . . . . . . . . . . . . 26\n
    \    5.3.  General Encoding Methods . . . . . . . . . . . . . . . . . 28\n       5.3.1.
    \ Header Compression CRCs, Coverage, and Polynomials . . 28\n         5.3.1.1.
    \ 8-bit CRC in IR and IR-DYN Headers . . . . . . . . 28\n         5.3.1.2.  3-bit
    CRC in Compressed Headers  . . . . . . . . . 28\n         5.3.1.3.  7-bit CRC
    in Compressed Headers  . . . . . . . . . 29\n         5.3.1.4.  32-bit Segmentation
    CRC  . . . . . . . . . . . . . 29\n       5.3.2.  Self-Describing Variable-Length
    Values . . . . . . . . 30\n     5.4.  ROHC UNCOMPRESSED -- No Compression  (Profile
    0x0000)  . . 30\n       5.4.1.  IR Packet  . . . . . . . . . . . . . . . . . .
    . . . . 31\n       5.4.2.  Normal Packet  . . . . . . . . . . . . . . . . . .
    . . 32\n       5.4.3.  Context Initialization . . . . . . . . . . . . . . . .
    32\n       5.4.4.  Decompressor Operation . . . . . . . . . . . . . . . . 33\n
    \      5.4.5.  Feedback . . . . . . . . . . . . . . . . . . . . . . . 33\n   6.
    \ Overview of a ROHC Profile (Informative) . . . . . . . . . . . 33\n   7.  Acknowledgments
    \ . . . . . . . . . . . . . . . . . . . . . . . 35\n   8.  IANA Considerations
    \ . . . . . . . . . . . . . . . . . . . . . 35\n   9.  Security Considerations
    \ . . . . . . . . . . . . . . . . . . . 36\n   10. References . . . . . . . .
    . . . . . . . . . . . . . . . . . . 37\n     10.1. Normative References . . .
    . . . . . . . . . . . . . . . . 37\n     10.2. Informative References . . . .
    . . . . . . . . . . . . . . 37\n   Appendix A.  CRC Algorithm . . . . . . . .
    . . . . . . . . . . . . 39\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   For many types of networks, reducing the deployment and
    operational\n   costs by improving the usage of the bandwidth resources is of
    vital\n   importance.  Header compression over a link is possible because some\n
    \  of the information carried within the header of a packet becomes\n   compressible
    between packets belonging to the same flow.\n   For links where the overhead of
    the IP header(s) is problematic, the\n   total size of the header may be significant.
    \ Applications\n   transferring data carried within RTP [RFC3550] will then, in
    addition\n   to link-layer framing, have an IPv4 [RFC0791] header (20 octets),
    a\n   UDP [RFC0768] header (8 octets), and an RTP header (12 octets), for a\n
    \  total of 40 octets.  With IPv6 [RFC2460], the IPv6 header is 40\n   octets
    for a total of 60 octets.  Applications transferring data\n   using TCP [RFC0793]
    will have 20 octets for the transport header, for\n   a total size of 40 octets
    for IPv4 and 60 octets for IPv6.\n   The relative gain for specific flows (or
    applications) depends on the\n   size of the payload used in each packet.  For
    applications such as\n   Voice over IP, where the size of the payload containing
    coded speech\n   can be as small as 15-20 octets, this gain will be quite significant.\n
    \  Similarly, relative gains for TCP flows carrying large payloads (such\n   as
    file transfers) will be less than for flows carrying smaller\n   payloads (such
    as application signaling, e.g., session initiation).\n   As more and more wireless
    link technologies are being deployed to\n   carry IP traffic, care must be taken
    to address the specific\n   characteristics of these technologies within the header
    compression\n   algorithms.  Legacy header compression schemes, such as those
    defined\n   in [RFC2507] and [RFC2508], have been shown to perform inadequately\n
    \  over links where both the lossy behavior and the round-trip times are\n   non-negligible,
    such as those observed, for example, in wireless\n   links and IP tunnels.\n   In
    addition, a header compression scheme should handle the often non-\n   trivial
    residual errors, i.e., where the lower layer may pass a\n   packet that contains
    undetected bit errors to the decompressor.  It\n   should also handle loss and
    reordering before the compression point,\n   as well as on the link between the
    compression and decompression\n   points [RFC4224].\n   The Robust Header Compression
    (ROHC) protocol provides an efficient,\n   flexible, and future-proof header compression
    concept.  It is\n   designed to operate efficiently and robustly over various
    link\n   technologies with different characteristics.\n   RFC 3095 [RFC3095] defines
    the ROHC framework along with an initial\n   set of compression profiles.  To
    improve and simplify the\n   specification, the framework and the profiles' parts
    have been split\n   into separate documents.  This document explicitly defines
    the ROHC\n   framework, but it does not modify or update the definition of the\n
    \  framework specified by RFC 3095; both documents can be used\n   independently
    of each other.  This also implies that implementations\n   based on either definition
    will be compatible and interoperable with\n   each other.  However, it is the
    intent to let this specification\n   replace RFC 3095 as the base specification
    for all profiles defined\n   in the future.\n   This document fixes one interoperability
    issue that was erroneously\n   introduced in RFC 4995.  The fix for this issue
    is located in\n   Section 5.2.4.1 and clarifies the interpretation of the Size
    field in\n   ROHC feedback.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in [RFC2119].\n"
  - contents:
    - "2.1.  Acronyms\n   This section lists most acronyms used for reference.\n   ACK
      \   Acknowledgment.\n   CID    Context Identifier.\n   CO     Compressed Packet
      Format.\n   CRC    Cyclic Redundancy Check.\n   IR     Initialization and Refresh.\n
      \  IR-DYN Initialization and Refresh, Dynamic part.\n   LSB    Least Significant
      Bit.\n   MRRU   Maximum Reconstructed Reception Unit.\n   MSB    Most Significant
      Bit.\n   MSN    Master Sequence Number.\n   NACK   Negative Acknowledgment.\n
      \  ROHC   RObust Header Compression.\n"
    title: 2.1.  Acronyms
  - contents:
    - "2.2.  ROHC Terminology\n   Context\n      The context of the compressor is
      the state it uses to compress a\n      header.  The context of the decompressor
      is the state it uses to\n      decompress a header.  Either of these or the
      two in combination\n      are usually referred to as \"context\", when it is
      clear which is\n      intended.  The context contains relevant information from
      previous\n      headers in the packet flow, such as static fields and possible\n
      \     reference values for compression and decompression.  Moreover,\n      additional
      information describing the packet flow is also part of\n      the context, for
      example, information about the change behavior of\n      fields (e.g., the IP
      Identifier behavior, or the typical inter-\n      packet increase in sequence
      numbers and timestamps).\n   Context damage\n      When the context of the decompressor
      is not consistent with the\n      context of the compressor, decompression may
      fail to reproduce the\n      original header.  This situation can occur when
      the context of the\n      decompressor has not been initialized properly or
      when packets\n      have been lost or damaged between the compressor and decompressor.\n
      \     Packets that cannot be decompressed due to inconsistent contexts\n      are
      said to be lost due to context damage.  Packets that are\n      decompressed
      but contain errors due to inconsistent contexts are\n      said to be damaged
      due to context damage.\n   Context repair mechanisms\n      Mechanisms used
      to resynchronize the contexts -- an important task\n      since context damage
      causes loss propagation.  Examples of such\n      mechanisms are NACK-based
      mechanisms, and the periodic refreshes\n      of important context information,
      usually done in unidirectional\n      operation.  There are also mechanisms
      that can reduce the context\n      inconsistency probability, for example, repetition
      of the same\n      type of information in multiple packets and CRCs that protect\n
      \     context-updating information.\n   CRC-8 validation\n      The validation
      of the integrity against bit error(s) in a received\n      IR and IR-DYN header
      using the 8-bit CRC included in the IR/IR-DYN\n      header.\n   CRC verification\n
      \     The verification of the result of a decompression attempt using\n      the
      3-bit CRC or 7-bit CRC included in the header of a compressed\n      packet
      format.\n   Damage propagation\n      Delivery of incorrect decompressed headers
      due to context damage,\n      such as errors in (i.e., loss of or damage to)
      previous header(s)\n      or feedback.\n   Error detection\n      Detection
      of errors by lower layers.  If error detection is not\n      perfect, there
      will be residual errors.\n   Error propagation\n      Damage propagation or
      loss propagation.\n   ROHC profile\n      A compression protocol that specifies
      how to compress specific\n      header combinations.  A ROHC profile may be
      tailored to handle a\n      specific set of link characteristics, e.g., loss
      characteristics,\n      reordering between compression points, etc.  ROHC profiles
      provide\n      the details of the header compression framework defined in this\n
      \     document, and each compression profile is associated with a unique\n      ROHC
      profile identifier [ROHC-ids].  When setting up a ROHC\n      channel, the set
      of profiles supported by both endpoints of the\n      channel is negotiated,
      and when initializing new contexts, a\n      profile identifier from this negotiated
      set is used to associate\n      each compression context with one specific profile.\n
      \  Link\n      A physical transmission path that constitutes a single IP hop.\n
      \  Loss propagation\n      Loss of headers, due to errors in (i.e., loss of
      or damage to)\n      previous header(s) or feedback.\n   Packet flow\n      A
      sequence of packets where the field values and change patterns\n      of field
      values are such that the headers can be compressed using\n      the same context.\n
      \  Residual error\n      Error introduced during transmission and not detected
      by lower-\n      layer error detection schemes.\n   ROHC channel\n      A logical
      unidirectional point-to-point channel carrying ROHC\n      packets from one
      compressor to one decompressor, optionally\n      carrying ROHC feedback information
      on the behalf of another\n      compressor-decompressor pair operating on a
      separate ROHC channel\n      in the opposite direction.  See also [RFC3759].\n
      \  This document also makes use of the conceptual terminology defined by\n   \"ROHC
      Terminology and Channel Mapping Examples\", RFC 3759 [RFC3759].\n"
    title: 2.2.  ROHC Terminology
  title: 2.  Terminology
- contents:
  - "3.  Background (Informative)\n   This section provides a background to the subject
    of header\n   compression.  The fundamental ideas are described together with
    a\n   discussion about the history of header compression schemes.  The\n   motivations
    driving the development of the various schemes are\n   discussed and their drawbacks
    identified, thereby providing the\n   foundations for the design of the ROHC framework
    and profiles\n   [RFC3095].\n"
  - contents:
    - "3.1.  Header Compression Fundamentals\n   Header compression is possible because
      there is significant\n   redundancy between header field values within packets,
      but in\n   particular between consecutive packets belonging to the same flow.\n
      \  On the path end-to-end, the entire header information is necessary\n   for
      all packets in the flow, but over a single link, some of this\n   information
      becomes redundant and can be reduced, as long as it is\n   transparently recovered
      at the receiving end of the link.  The header\n   size can be reduced by first
      sending field information that is\n   expected to remain static for (at least
      most of) the lifetime of the\n   packet flow.  Further compression is achieved
      for the fields carrying\n   information that changes more dynamically by using
      compression\n   methods tailored to their respective assumed change behavior.\n
      \  To achieve compression and decompression, some necessary information\n   from
      past packets is maintained in a context.  The compressor and the\n   decompressor
      update their respective contexts upon certain, not\n   necessarily synchronized,
      events.  Impairment events may lead to\n   inconsistencies in the decompressor
      context (i.e., context damage),\n   which in turn may cause incorrect decompression.
      \ A Robust Header\n   Compression scheme needs mechanisms to minimize the possibility
      of\n   context damage, in combination with mechanisms for context repair.\n"
    title: 3.1.  Header Compression Fundamentals
  - contents:
    - "3.2.  A Short History of Header Compression\n   The first header compression
      scheme, compressed TCP (CTCP) [RFC1144],\n   was introduced by Van Jacobson.
      \ CTCP, also often referred to as VJ\n   compression, compresses the 40 octets
      of the TCP/IP header down to 4\n   octets.  CTCP uses delta encoding for sequentially
      changing fields.\n   The CTCP compressor detects transport-level retransmissions
      and sends\n   a header that updates the entire context when they occur.  This\n
      \  repair mechanism does not require any explicit signaling between the\n   compressor
      and decompressor.\n   A general IP header compression scheme, IP header compression\n
      \  [RFC2507], improves somewhat on CTCP.  IP header compression (IPHC)\n   can
      compress arbitrary IP, TCP, and UDP headers.  When compressing\n   non-TCP headers,
      IPHC does not use delta encoding and is robust.  The\n   repair mechanism of
      CTCP is augmented with negative acknowledgments,\n   called CONTEXT_STATE messages,
      which speed up the repair.  This\n   context repair mechanism is thus limited
      by the round-trip time of\n   the link.  IPHC does not compress RTP headers.\n
      \  CRTP [RFC2508] is an RTP extension to IPHC.  CRTP compresses the 40\n   octets
      of IPv4/UDP/RTP headers to a minimum of 2 octets when the UDP\n   Checksum is
      not enabled.  If the UDP Checksum is enabled, the minimum\n   CRTP header is
      4 octets.\n   On lossy links with long round-trip times, CRTP does not perform
      well\n   [CRTP-eval].  Each packet lost over the link causes decompression of\n
      \  several subsequent packets to fail, because the context becomes\n   invalidated
      during at least one link round-trip time from the lost\n   packet.  Unfortunately,
      the large headers that CRTP sends when\n   updating the context waste additional
      bandwidth.\n   CRTP uses a local repair mechanism known as TWICE, which was\n
      \  introduced by IPHC.  TWICE derives its name from the observation that\n   when
      the flow of compressed packets is regular, the correct guess\n   when one packet
      is lost between the compression points is to apply\n   the update in the current
      packet twice.  While TWICE improves CRTP\n   performance significantly, [CRTP-eval]
      also found that even with\n   TWICE, CRTP doubled the number of lost packets.\n
      \  An enhanced variant of CRTP, called eCRTP [RFC3545], means to improve\n   the
      robustness of CRTP in the presence of reordering and packet\n   losses, while
      keeping the protocol almost unchanged from CRTP.  As a\n   result, eCRTP does
      provide better means to implement some degree of\n   robustness, albeit at the
      expense of additional overhead, leading to\n   a reduction in compression efficiency
      in comparison to CRTP.\n"
    title: 3.2.  A Short History of Header Compression
  title: 3.  Background (Informative)
- contents:
  - '4.  Overview of ROHC (Informative)

    '
  - contents:
    - "4.1.  General Principles\n   As mentioned earlier, header compression is possible
      per-link due to\n   the fact that there is much redundancy between header field
      values\n   within packets, and especially between consecutive packets belonging\n
      \  to the same flow.  To utilize these properties for header\n   compression,
      there are a few essential steps to consider.\n   The first step consists of
      identifying and grouping packets together\n   into different \"flows\", so that
      packet-to-packet redundancy is\n   maximized in order to improve the compression
      ratio.  Grouping\n   packets into flows is usually based on source and destination
      host\n   (IP) addresses, transport protocol type (e.g., UDP or TCP), process\n
      \  (port) numbers, and potentially additional unique application\n   identifiers,
      such as the synchronization source (SSRC) in RTP\n   [RFC3550].  The compressor
      and decompressor each establish a context\n   for the packet flow and identify
      the context with a Context\n   Identifier (CID) included in each compressed
      header.\n   The second step is to understand the change patterns of the various\n
      \  header fields.  On a high level, header fields fall into one of the\n   following
      classes:\n   INFERRED      These fields contain values that can be inferred
      from\n                 other fields or external sources; for example, the size\n
      \                of the frame carrying the packet can often be derived\n                 from
      the link-layer protocol, and thus does not have to\n                 be transmitted
      by the compression scheme.\n   STATIC        Fields classified as STATIC are
      assumed to be constant\n                 throughout the lifetime of the packet
      flow.  The value\n                 of each field is thus only communicated initially.\n
      \  STATIC-DEF    Fields classified as STATIC-DEF are used to define a\n                 packet
      flow as discussed above.  Packets for which\n                 respective values
      of these fields differ are treated as\n                 belonging to different
      flows.  These fields are in\n                 general compressed as STATIC fields.\n
      \  STATIC-KNOWN  Fields classified as STATIC-KNOWN are expected to have\n                 well-known
      values, and therefore their values do not\n                 need to be communicated.\n
      \  CHANGING      These fields are expected to vary randomly, either\n                 within
      a limited value set or range, or in some other\n                 manner.  CHANGING
      fields are usually handled in more\n                 sophisticated ways based
      on a more detailed\n                 classification of their expected change
      patterns.\n   Finally, the last step is to choose the encoding method(s) that
      will\n   be applied onto different fields based on classification.  The\n   encoding
      methods, in combination with the identified field behavior,\n   provide the
      input to the design of the compressed header formats.\n   The analysis of the
      probability distribution of the identified change\n   patterns then provides
      the means to optimize the packet formats,\n   where the most frequently occurring
      change patterns for a field\n   should be encoded within the most efficient
      format(s).\n   However, compression efficiency has to be traded against two
      other\n   properties: the robustness of the encoding to losses and errors\n
      \  between the compressor and the decompressor, and the ability to\n   detect
      and cope with errors in the decompression process.\n"
    title: 4.1.  General Principles
  - contents:
    - "4.2.  Compression Efficiency, Robustness, and Transparency\n   The performance
      of a header compression protocol can be described\n   with three parameters:
      its compression efficiency, its robustness,\n   and its compression transparency.\n
      \  Compression efficiency\n      The compression efficiency is determined by
      how much the average\n      header size is reduced by applying the compression
      protocol.\n   Robustness\n      A robust protocol tolerates packet losses, residual
      bit errors,\n      and out-of-order delivery on the link over which header\n
      \     compression takes place, without losing additional packets or\n      introducing
      additional errors in decompressed headers.\n   Compression transparency\n      The
      compression transparency is a measure of the extent to which\n      the scheme
      maintains the semantics of the original headers.  If\n      all decompressed
      headers are bitwise identical to the\n      corresponding original headers,
      the scheme is transparent.\n"
    title: 4.2.  Compression Efficiency, Robustness, and Transparency
  - contents:
    - "4.3.  Developing the ROHC Protocol\n   The challenge in developing a header
      compression protocol is to\n   conciliate compression efficiency and robustness
      while maintaining\n   transparency, as increasing robustness will always come
      at the\n   expense of a lower compression efficiency, and vice versa.  The\n
      \  scheme should also be flexible enough in its design to minimize the\n   impacts
      from the varying round-trip times and loss patterns of links\n   where header
      compression will be used.\n   To achieve this, the header compression scheme
      must provide\n   facilities for the decompressor to verify decompression and
      detect\n   potential context damage, as well as context recovery mechanisms
      such\n   as feedback.  Header compression schemes prior to the ones developed\n
      \  by the Robust Header Compression (ROHC) Working Group (WG) were not\n   designed
      with the above high-level objectives in mind.\n   The ROHC WG has developed
      header compression solutions to meet the\n   needs of present and future link
      technologies.  While special\n   attention has been put towards meeting the
      more stringent\n   requirements stemming from the characteristics of wireless
      links, the\n   results are equally applicable to many other link technologies.\n
      \  \"RObust Header Compression (ROHC): Framework and four profiles: RTP,\n   UDP,
      ESP, and uncompressed\" [RFC3095] was published in 2001, as the\n   first output
      of the ROHC WG.  ROHC is a general and extendable\n   framework for header compression,
      on top of which profiles can be\n   defined for compression of different protocols
      headers.  RFC 3095\n   introduced a number of new compression techniques, and
      was successful\n   at living up to the requirements placed on it, as described
      in\n   [RFC3096].\n   Interoperability testing of RFC 3095 confirms the capabilities
      of\n   ROHC to meet its purposes, but feedback from implementers has also\n
      \  indicated that the protocol specification is complex and sometimes\n   obscure.
      \ Most importantly, a clear distinction between framework and\n   profiles is
      not obvious in [RFC3095], which also makes development of\n   additional profiles
      troublesome.  This document therefore aims at\n   explicitly specifying the
      ROHC framework, while a companion document\n   [RFC5225] specifies revised versions
      of the compression profiles of\n   RFC 3095.\n"
    title: 4.3.  Developing the ROHC Protocol
  - contents:
    - "4.4.  Operational Characteristics of the ROHC Channel\n   Robust header compression
      can be used over many types of link\n   technologies.  The ROHC framework provides
      flexibility for profiles\n   to address a wide range of applications, and this
      section lists some\n   of the operational characteristics of the ROHC channel
      (see also\n   [RFC3759]).\n   Multiplexing over a single logical channel\n      The
      ROHC channel provides a mechanism to identify a context within\n      the general
      ROHC packet format.  The CID makes it possible for a\n      logical channel
      that supports ROHC to transport multiple header-\n      compressed flows, while
      still making it possible for a channel to\n      be dedicated to one single
      packet flow without any CID overhead.\n      More specifically, ROHC uses a
      distinct CID space per logical\n      channel, and the CID can be omitted for
      one of the flows over the\n      ROHC channel when configured to use a small
      CID space.\n   Establishment of channel parameters\n      A link layer defining
      support for the ROHC channel must provide\n      the means to establish header
      compression channel parameters (see\n      Section 5.1).  This can be achieved
      through a negotiation\n      mechanism, static provisioning, or some out-of-band
      signaling.\n   Packet type identification\n      The ROHC channel defines a
      packet type identifier space, and puts\n      restrictions with respect to the
      use of a number of identifiers\n      that are common for all ROHC profiles.
      \ Identifiers that have no\n      restrictions, i.e., identifiers that are not
      defined by this\n      document, are available to each profile.  The identifier
      is part\n      of each compressed header, and this makes it possible for the
      link\n      that supports the ROHC channel to allocate one single link-layer\n
      \     payload type for ROHC.\n   Out-of-order delivery between compression endpoints\n
      \     Each profile defines its own level of robustness, including\n      tolerance
      to reordering of packets before but especially between\n      compression endpoints,
      if any.\n      For profiles specified in [RFC3095], the channel between the\n
      \     compressor and decompressor is required to maintain in-order\n      delivery
      of the packets; i.e., the definition of these profiles\n      assumes that the
      decompressor always receives packets in the same\n      order as the compressor
      sent them.  The impacts of reordering on\n      the performance of these profiles
      are described in [RFC4224].\n      However, reordering before the compression
      point is handled, i.e.,\n      these profiles make no assumption that the compressor
      will receive\n      packets in order.\n      For the ROHCv2 profiles specified
      in [RFC5225], their definitions\n      assume that the decompressor can receive
      packets out of order,\n      i.e., not in the same order that the compressor
      sent them.\n      Reordering before the compression point is also dealt with.\n
      \  Duplication of packets\n      The link supporting the ROHC channel is required
      to not duplicate\n      packets (however, duplication of packets can occur before
      they\n      reach the compressor; i.e., there is no assumption that the\n      compressor
      will receive only one copy of each packet).\n   Framing\n      The link layer
      must provide framing that makes it possible to\n      distinguish frame boundaries
      and individual frames.\n   Error detection/protection\n      ROHC profiles should
      be designed to cope with residual errors in\n      the headers delivered to
      the decompressor.  CRCs are used to\n      detect decompression failures and
      to prevent or reduce damage\n      propagation.  However, it is recommended
      that lower layers deploy\n      error detection for ROHC headers and that ROHC
      headers with high\n      residual error rates not be delivered.\n"
    title: 4.4.  Operational Characteristics of the ROHC Channel
  - contents:
    - "4.5.  Compression and Master Sequence Number (MSN)\n   Compression of header
      fields is based on the establishment of a\n   function to a sequence number,
      called the master sequence number\n   (MSN).  This function describes the change
      pattern of the field with\n   respect to a change in the MSN.\n   Change patterns
      include, for example, fields that increase\n   monotonically or by a small value,
      fields that seldom change, and\n   fields that remain unchanging for the entire
      lifetime of the packet\n   flow, in which case the function to the MSN is equivalent
      to a\n   constant value.\n   The compressor first establishes functions for
      each of the header\n   fields, and then reliably communicates the MSN.  When
      the change\n   pattern of the field does not match the established function,
      i.e.,\n   the existing function gives a result that is different from the field\n
      \  in the header being compressed, additional information can be sent to\n   update
      the parameters of that function.\n   The MSN is defined per profile.  It can
      be either derived directly\n   from one of the fields of the protocol being
      compressed (e.g., the\n   RTP SN [RFC5225]), or it can be created and maintained
      by the\n   compressor (e.g., the MSN for compression of UDP in profile 0x0102\n
      \  [RFC5225] or the MSN in ROHC-TCP [RFC4996]).\n"
    title: 4.5.  Compression and Master Sequence Number (MSN)
  - contents:
    - "4.6.  Static and Dynamic Parts of a Context\n   A compression context can be
      conceptually divided into two different\n   parts, the static context and the
      dynamic context, each based on the\n   properties of the fields that are being
      compressed.\n   The static part includes the information necessary to compress
      and\n   decompress the fields whose change behavior is classified as STATIC,\n
      \  STATIC-KNOWN, or STATIC-DEF (as described in Section 4.1 above).\n   The
      dynamic part includes the state maintained for all the other\n   fields, i.e.,
      those that are classified as CHANGING.\n"
    title: 4.6.  Static and Dynamic Parts of a Context
  title: 4.  Overview of ROHC (Informative)
- contents:
  - "5.  The ROHC Framework (Normative)\n   This section normatively defines the parts
    common to all ROHC\n   profiles, i.e., the framework.  The framework specifies
    the\n   requirements and functionality of the ROHC channel, including how to\n
    \  handle multiple compressed packet flows over the same channel.\n   Finally,
    this section specifies encoding methods used in the packet\n   formats that are
    common to all profiles.  These encoding methods may\n   be reused within profile
    specifications for encoding fields in\n   profile-specific parts of a packet format,
    without requiring their\n   redefinition.\n"
  - contents:
    - '5.1.  The ROHC Channel

      '
    - contents:
      - "5.1.1.  Contexts and Context Identifiers\n   Associated with each compressed
        flow is a context.  The context is\n   the state that the compressor and the
        decompressor maintain in order\n   to correctly compress or decompress the
        headers of the packet in the\n   flow.  Each context is identified using a
        CID.\n   A context is considered to be a new context when the CID is\n   associated
        with a profile for the first time since the creation of\n   the ROHC channel,
        or when the CID gets associated from the reception\n   of an IR (this does
        not apply to the IR-DYN) with a different profile\n   than the profile in
        the context.\n   Context information is conceptually kept in a table.  The
        context\n   table is indexed using the CID, which is sent along with compressed\n
        \  headers and feedback information.\n   The CID space can be either small,
        which means that CIDs can take the\n   values 0 through 15, or large, which
        means that CIDs take values\n   between 0 and 2^14 - 1 = 16383.  Whether the
        CID space is large or\n   small MUST be established, possibly by negotiation,
        before any\n   compressed packet may be sent over the ROHC channel.\n   The
        CID space is distinct for each channel, i.e., CID 3 over channel\n   A and
        CID 3 over channel B do not refer to the same context, even if\n   the endpoints
        of A and B are the same nodes.  In particular, CIDs for\n   any pair of ROHC
        channels are not related (two associated ROHC\n   channels serving as feedback
        channels for one another do not even\n   need to have CID spaces of the same
        size).\n"
      title: 5.1.1.  Contexts and Context Identifiers
    - contents:
      - "5.1.2.  Per-Channel Parameters\n   The ROHC channel is based on a number
        of parameters that form part of\n   the established channel state and the
        per-context state.  The state\n   of the ROHC channel MUST be established
        before the first ROHC packet\n   may be sent, which may be achieved using
        negotiation protocols\n   provided by the link layer (see also [RFC3241],
        which describes an\n   option for negotiation of ROHC parameters for PPP).
        \ This section\n   describes some of this channel state information in an
        abstract way:\n   LARGE_CIDS: Boolean; if false, the small CID representation
        (0 octets\n   or 1 prefix octet, covering CID 0 to 15) is used; if true, the
        large\n   CID representation (1 or 2 embedded CID octets covering CID 0 to\n
        \  16383) is used.  See also Section 5.1.1 and Section 5.2.1.3.\n   MAX_CID:
        Non-negative integer; highest CID number to be used by the\n   compressor
        (note that this parameter is not coupled to, but in effect\n   further constrained
        by, LARGE_CIDS).  This value represents an\n   agreement by the decompressor
        that it can provide sufficient memory\n   resources to host at least MAX_CID+1
        contexts; the decompressor MUST\n   maintain established contexts within this
        space until either the CID\n   gets re-used by the establishment of a new
        context, or until the\n   channel is taken down.\n   PROFILES: Set of non-negative
        integers, where each integer indicates\n   a profile supported by both the
        compressor and the decompressor.  A\n   profile is identified by a 16-bit
        value, where the 8 LSB bits\n   indicate the actual profile, and the 8 MSB
        bits indicate the variant\n   of that profile.  The ROHC compressed header
        format identifies the\n   profile used with only the 8 LSB bits; this means
        that if multiple\n   variants of the same profile are available for a ROHC
        channel, the\n   PROFILES set after negotiation MUST NOT include more than
        one variant\n   of the same profile.  The compressor MUST NOT compress using
        a\n   profile that is not in PROFILES.\n   FEEDBACK_FOR: Optional reference
        to a ROHC channel in the opposite\n   direction between the same compression
        endpoints.  If provided, this\n   parameter indicates to which other ROHC
        channel any feedback sent on\n   this ROHC channel refers (see [RFC3759]).\n
        \  MRRU: Non-negative integer.  Maximum Reconstructed Reception Unit.\n   This
        is the size of the largest reconstructed unit in octets that the\n   decompressor
        is expected to reassemble from segments (see\n   Section 5.2.5).  This size
        includes the segmentation CRC.  If MRRU is\n   negotiated to be 0, segmentation
        MUST NOT be used on the channel, and\n   received segments MUST be discarded
        by the decompressor.\n"
      title: 5.1.2.  Per-Channel Parameters
    - contents:
      - "5.1.3.  Persistence of Decompressor Contexts\n   As part of the negotiated
        channel parameters, the compressor and\n   decompressor have through the MAX_CID
        parameter agreed on the highest\n   context identification (CID) number to
        be used.  By agreeing on the\n   MAX_CID, the decompressor also agrees to
        provide memory resources to\n   host at least MAX_CID+1 contexts, and an established
        context with a\n   CID within this negotiated space SHOULD be kept by the
        decompressor\n   until either the CID gets re-used, or the channel is taken
        down or\n   re-negotiated.\n"
      title: 5.1.3.  Persistence of Decompressor Contexts
    title: 5.1.  The ROHC Channel
  - contents:
    - "5.2.  ROHC Packets and Packet Types\n   This section uses the following convention
      in the diagrams when\n   representing various ROHC packet types, formats, and
      fields:\n         - colons \":\" indicate that the part is optional\n         -
      slashes \"/\" indicate variable length\n   The ROHC packet type indication scheme
      has been designed to provide\n   optional padding, a feedback packet type, an
      optional Add-CID octet\n   (which includes 4 bits of CID), and a simple segmentation
      and\n   reassembly mechanism.\n   The following packet types are reserved at
      the ROHC framework level:\n         11100000 : Padding\n         1110nnnn :
      Add-CID octet (nnnn=CID with values 0x1 through 0xF)\n         11110    : Feedback\n
      \        11111000 : IR-DYN packet\n         1111110  : IR packet\n         1111111
      \ : Segment\n   Other packet types can be defined and used by individual profiles:\n
      \        0        : available (not reserved by ROHC framework)\n         10
      \      : available (not reserved by ROHC framework)\n         110      : available
      (not reserved by ROHC framework)\n         1111101  : available (not reserved
      by ROHC framework)\n         11111001 : available (not reserved by ROHC framework)\n"
    - contents:
      - "5.2.1.  General Format of ROHC Packets\n   A ROHC packet has the following
        general format:\n       --- --- --- --- --- --- --- ---\n      :           Padding
        \            :\n       --- --- --- --- --- --- --- ---\n      :           Feedback
        \           :\n       --- --- --- --- --- --- --- ---\n      :            Header
        \            :\n       --- --- --- --- --- --- --- ---\n      :           Payload
        \            :\n       --- --- --- --- --- --- --- ---\n   Padding: Any number
        (zero or more) of padding octets, where the\n   format of a padding octet
        is as defined in Section 5.2.1.1.\n   Feedback: Any number (zero or more)
        of feedback elements, where the\n   format of a feedback element is as defined
        in Section 5.2.4.1.\n   Header: Either a profile-specific CO header (see Section
        5.2.1.3), an\n   IR or IR-DYN header (see Section 5.2.2), or a ROHC Segment
        (see\n   Section 5.2.5).  There can be at most one Header in a ROHC packet,\n
        \  but it may also be omitted (if the packet contains Feedback only).\n   Payload:
        Corresponds to zero or more octets of payload from the\n   uncompressed packet,
        starting with the first octet in the\n   uncompressed packet after the last
        header compressible by the current\n   profile.\n   At least one of Feedback
        or Header MUST be present.\n"
      - contents:
        - "5.2.1.1.  Format of the Padding Octet\n   Padding octet:\n        0   1
          \  2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n      |
          1   1   1   0   0   0   0   0 |\n      +---+---+---+---+---+---+---+---+\n
          \  Note: The Padding octet MUST NOT be interpreted as an Add-CID octet\n
          \  for CID 0.\n"
        title: 5.2.1.1.  Format of the Padding Octet
      - contents:
        - "5.2.1.2.  Format of the Add-CID Octet\n   Add-CID octet:\n        0   1
          \  2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n      |
          1   1   1   0 |      CID      |\n      +---+---+---+---+---+---+---+---+\n
          \  CID: 0x1 through 0xF indicates CIDs 1 through 15.\n   Note: The Padding
          octet looks like an Add-CID octet for CID 0.\n"
        title: 5.2.1.2.  Format of the Add-CID Octet
      - contents:
        - "5.2.1.3.  General Format of Header\n   All ROHC packet types have the following
          general Header format:\n        0              x-1  x       7\n       ---
          --- --- --- --- --- --- ---\n      :         Add-CID octet         :  if
          CID 1-15 and small CIDs\n      +--- --- --- --- ---+--- --- ---+\n      |
          type indication   |   body    |  1 octet (8-x bits of body)\n      +---
          --- --- --- ---+--- --- ---+\n      :                               :\n
          \     /    0, 1, or 2 octets of CID   /  1 or 2 octets if large CIDs\n      :
          \                              :\n      +---+---+---+---+---+---+---+---+\n
          \     /             body              /  variable length\n      +---+---+---+---+---+---+---+---+\n
          \  type indication: ROHC packet type.\n   body: Interpreted according to
          the packet type indication and CID\n   information, as defined by individual
          profiles.\n   Thus, the header either starts with a packet type indication
          or has a\n   packet type indication immediately following an Add-CID octet.\n
          \  When the ROHC channel is configured with a small CID space:\n   o   If
          an Add-CID immediately precedes the packet type indication,\n       the
          packet has the CID of the Add-CID; otherwise, it has CID 0.\n   o   A small
          CID with the value 0 is represented using zero bits;\n       therefore,
          a flow associated with CID 0 has no CID overhead in\n       the compressed
          header.  In such case, Header starts with a packet\n       type indication.\n
          \  o   A small CID with a value from 1 to 15 is represented using the\n
          \      Add-CID octet as described above.  The Header starts with the\n       Add-CID
          octet, followed by a packet type indication.\n   o   There is no large CID
          in the Header.\n   When the ROHC channel is configured with a large CID
          space:\n   o   The large CID is always present and is represented using
          the\n       encoding scheme of Section 5.3.2, limited to two octets.  In
          this\n       case, the Header starts with a packet type indication.\n"
        title: 5.2.1.3.  General Format of Header
      title: 5.2.1.  General Format of ROHC Packets
    - contents:
      - "5.2.2.  Initialization and Refresh (IR) Packet Types\n   IR packet types
        contain a profile identifier, which determines how\n   the rest of the header
        is to be interpreted.  They also associate a\n   profile with a context.  The
        stored profile parameter further\n   determines the syntax and semantics of
        the packet type identifiers\n   and packet types used with a specific context.\n
        \  The IR and IR-DYN packets always update the context for all context-\n
        \  updating fields carried in the header.  They never clear the context,\n
        \  except when initializing a new context (see Section 5.1.1), or unless\n
        \  the profile indicated in the Profile field specifies otherwise.\n"
      - contents:
        - "5.2.2.1.  ROHC IR Header Format\n   The IR header associates a CID with
          a profile, and typically also\n   initializes the context.  It can typically
          also refresh all (or parts\n   of) the context.  For IR, Header has the
          following general format:\n        0   1   2   3   4   5   6   7\n       ---
          --- --- --- --- --- --- ---\n      :         Add-CID octet         :  if
          CID 1-15 and small CID\n      +---+---+---+---+---+---+---+---+\n      |
          1   1   1   1   1   1   0 | x |  IR type octet\n      +---+---+---+---+---+---+---+---+\n
          \     :                               :\n      /      0-2 octets of CID
          \       /  1 or 2 octets if large CIDs\n      :                               :\n
          \     +---+---+---+---+---+---+---+---+\n      |            Profile            |
          \ 1 octet\n      +---+---+---+---+---+---+---+---+\n      |              CRC
          \             |  1 octet\n      +---+---+---+---+---+---+---+---+\n      |
          \                              |\n      / profile-specific information  /
          \ variable length\n      |                               |\n      +---+---+---+---+---+---+---+---+\n
          \  x: Profile-specific information.  Interpreted according to the\n   profile
          indicated in the Profile field of the IR header.\n   Profile: The profile
          associated with the CID.  In the IR header, the\n   profile identifier is
          abbreviated to the 8 least significant bits\n   (see Section 5.1.2).\n   CRC:
          8-bit CRC (see Section 5.3.1.1).\n   Profile-specific information: The content
          of this part of the IR\n   header is defined by the individual profiles.
          \ It is interpreted\n   according to the profile indicated in the Profile
          field.\n"
        title: 5.2.2.1.  ROHC IR Header Format
      - contents:
        - "5.2.2.2.  ROHC IR-DYN Header Format\n   In contrast to the IR header, the
          IR-DYN header can never initialize\n   a non-initialized context.  However,
          it can redefine what profile is\n   associated with a context, if the profile
          indicated in the IR-DYN\n   header allows this.  Thus, this packet type
          is also reserved at the\n   framework level.  The IR-DYN header typically
          also initializes or\n   refreshes parts of a context.  For IR-DYN, Header
          has the following\n   general format:\n        0   1   2   3   4   5   6
          \  7\n       --- --- --- --- --- --- --- ---\n      :         Add-CID octet
          \        :  if CID 1-15 and small CID\n      +---+---+---+---+---+---+---+---+\n
          \     | 1   1   1   1   1   0   0   0 |  IR-DYN type octet\n      +---+---+---+---+---+---+---+---+\n
          \     :                               :\n      /      0-2 octets of CID
          \       /  1 or 2 octets if large CIDs\n      :                               :\n
          \     +---+---+---+---+---+---+---+---+\n      |            Profile            |
          \ 1 octet\n      +---+---+---+---+---+---+---+---+\n      |              CRC
          \             |  1 octet\n      +---+---+---+---+---+---+---+---+\n      |
          \                              |\n      / profile-specific information  /
          \ variable length\n      |                               |\n      +---+---+---+---+---+---+---+---+\n
          \  Profile: The profile associated with the CID.  This is abbreviated in\n
          \  the same way as in IR packets.\n   CRC: 8-bit CRC (see Section 5.3.1.1).\n
          \  Profile-specific information: The content of this part of the IR-DYN\n
          \  header is defined by the individual profiles.  It is interpreted\n   according
          to the profile indicated in the Profile field.\n"
        title: 5.2.2.2.  ROHC IR-DYN Header Format
      title: 5.2.2.  Initialization and Refresh (IR) Packet Types
    - contents:
      - "5.2.3.  ROHC Initial Decompressor Processing\n   Initially, all contexts
        are in no context state.  Thus, all packets\n   referencing a non-initialized
        context, except packets that have\n   enough information on the static fields,
        cannot be decompressed by\n   the decompressor.\n   When the decompressor
        receives a packet of type IR, the profile\n   indicated in the IR packet determines
        how it is to be processed.\n   o  If the 8-bit CRC fails to verify the integrity
        of the header, the\n      packet MUST NOT be decompressed and delivered to
        upper layers.  If\n      a profile is indicated in the context, the logic
        of that profile\n      determines what, if any, feedback is to be sent.  If
        no profile is\n      noted in the context, the logic used to determine what,
        if any,\n      feedback to send is up to the implementation.  However, it
        may be\n      suitable to take no further actions, as any part of the IR header\n
        \     covered by the CRC may have caused the failure.\n   When the decompressor
        receives a packet of type IR-DYN, the profile\n   indicated in the IR-DYN
        packet determines how it is to be processed.\n   o  If the 8-bit CRC fails
        to verify the integrity of the header, the\n      packet MUST NOT be decompressed
        and delivered to upper layers.  If\n      a profile is indicated in the context,
        the logic of that profile\n      determines what, if any, feedback is to be
        sent.  If no profile is\n      noted in the context, the logic used to determine
        what, if any,\n      feedback to send is up to the implementation.  However,
        it may be\n      suitable to take no further actions, as any part of the IR-DYN\n
        \     header covered by the CRC may have caused the failure.\n   o  If the
        context has not already been initialized, the packet MUST\n      NOT be decompressed
        and delivered to upper layers.  The logic of\n      the profile indicated
        in the IR-DYN header (if verified by the\n      8-bit CRC), determines what,
        if any, feedback is to be sent.\n   If a parsing error occurs for any packet
        type, the decompressor MUST\n   discard the packet without further processing.
        \ For example, a CID\n   field is present in the compressed header when the
        large CID space is\n   used for the ROHC channel, and the field is coded using
        the self-\n   describing variable-length encoding of Section 5.3.2; if the
        field\n   starts with 110 or 111, this would generate a parsing error for
        the\n   decompressor because this field must not be encoded with a size\n
        \  larger than 2 octets.\n   It is RECOMMENDED that profiles disallow the
        decompressor to make a\n   decompression attempt for packets carrying only
        a 3-bit CRC after it\n   has invalidated some or all of the entire dynamic
        context, until a\n   packet that contains sufficient information on the dynamic
        fields is\n   received, decompressed, and successfully verified by a 7- or
        8-bit\n   CRC.\n"
      title: 5.2.3.  ROHC Initial Decompressor Processing
    - contents:
      - "5.2.4.  ROHC Feedback\n   Feedback carries information from the decompressor
        to the compressor.\n   Feedback can be sent over a ROHC channel that operates
        in the same\n   direction as the feedback.\n   The general ROHC packet format
        allows transport of feedback using\n   interspersion or piggybacking (see
        [RFC3759]), or a combination of\n   both, over a ROHC channel.  This is facilitated
        by the following\n   properties:\n   Reserved packet type:\n      A feedback
        packet type is reserved at the framework level.  The\n      packet type can
        carry variable-length feedback information.\n   CID information:\n      The
        feedback information sent on a particular channel is passed\n      to, and
        interpreted by, the compressor associated with feedback on\n      that channel.
        \ Thus, each feedback element contains CID\n      information from the channel
        for which the feedback is sent.  The\n      ROHC feedback scheme thus requires
        that a channel carries feedback\n      to at most one compressor.  How a compressor
        is associated with\n      the feedback for a particular channel is outside
        the scope of this\n      specification.  See also [RFC3759].\n   Length information:\n
        \     The length of a feedback element can be determined by examining\n      the
        first few octets of the feedback.  This enables piggybacking\n      of feedback,
        and also the concatenation of more than one feedback\n      element in a packet.
        \ The length information thus decouples the\n      decompressor from the associated
        same-side compressor, as the\n      decompressor can extract the feedback
        information from the\n      compressed header without parsing its content
        and hand over the\n      extracted information.\n   The association between
        compressor-decompressor pairs operating in\n   opposite directions, for the
        purpose of exchanging piggyback and/or\n   interspersed feedback, SHOULD be
        maintained for the lifetime of the\n   ROHC channel.  Otherwise, it is RECOMMENDED
        that the compressor be\n   notified if the feedback channel is no longer available:
        the\n   compressor SHOULD then restart compression by creating a new context\n
        \  for each packet flow, and SHOULD use a CID value that was not\n   previously
        associated with the profile used to compress the flow.\n"
      - contents:
        - "5.2.4.1.  ROHC Feedback Format\n   ROHC defines three different categories
          of feedback messages:\n   acknowledgment (ACK), negative ACK (NACK), and
          NACK for the entire\n   context (STATIC-NACK).  Other types of information
          may be defined in\n   profile-specific feedback information.\n      ACK:
          Acknowledges successful decompression of a packet.  Indicates\n      that
          the decompressor considers its context to be valid.\n      NACK: Indicates
          that the decompressor considers some or all of the\n      dynamic part of
          its context invalid.\n      STATIC-NACK : Indicates that the decompressor
          considers its entire\n      static context invalid, or that it has not been
          established.\n   Feedback sent on a ROHC channel consists of one or more
          concatenated\n   feedback elements, where each feedback element has the
          following\n   format:\n       0   1   2   3   4   5   6   7\n     +---+---+---+---+---+---+---+---+\n
          \    | 1   1   1   1   0 |   Code    |  feedback type\n     +---+---+---+---+---+---+---+---+\n
          \    :             Size              :  if Code = 0\n     +---+---+---+---+---+---+---+---+\n
          \    :         Add-CID octet         :  if for small CIDs and (CID != 0)\n
          \    +---+---+---+---+---+---+---+---+\n     :                               :\n
          \    /           large CID           /  1-2 octets if for large CIDs\n     :
          \                              :\n     +---+---+---+---+---+---+---+---+\n
          \    /         FEEDBACK data         /  variable length\n     +---+---+---+---+---+---+---+---+\n
          \  Code:\n      0 indicates that a Size octet is present.\n      1-7 indicates
          the total size of the FEEDBACK data field and the\n      CID field (if any),
          in octets.\n   Size: Indicates the total size of the FEEDBACK data field
          and the CID\n   field (if any), in octets.\n   FEEDBACK data: FEEDBACK-1
          or FEEDBACK-2 (see below).\n   CID information in a feedback element indicates
          the context for which\n   feedback is sent.  The LARGE_CIDS parameter that
          controls whether a\n   large CID is present is taken from the channel state
          of the receiving\n   compressor's channel, not from the state of the channel
          carrying the\n   feedback.\n   The large CID field, if present, is encoded
          according to\n   Section 5.3.2, and it MUST NOT be encoded using more than
          2 octets.\n   The FEEDBACK data field can have either of the following two
          formats:\n   FEEDBACK-1:\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
          \     | profile-specific information  |  1 octet\n      +---+---+---+---+---+---+---+---+\n
          \  FEEDBACK-2:\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
          \     |Acktype|                       |\n      +---+---+   profile-specific
          \   /  at least 2 octets\n      /             information       |\n      +---+---+---+---+---+---+---+---+\n
          \     Acktype:  0 = ACK\n                1 = NACK\n                2 = STATIC-NACK\n
          \               3 is reserved (MUST NOT be used.  Otherwise unparsable.)\n"
        title: 5.2.4.1.  ROHC Feedback Format
      title: 5.2.4.  ROHC Feedback
    - contents:
      - "5.2.5.  ROHC Segmentation\n   ROHC defines a simple segmentation protocol.
        \ The compressor may\n   perform segmentation, e.g., to accommodate packets
        that are larger\n   than a specific size configured for the channel.\n"
      - contents:
        - "5.2.5.1.  Segmentation Usage Considerations\n   The ROHC segmentation protocol
          is not particularly efficient.  It is\n   not intended to replace link-layer
          segmentation functions; these\n   SHOULD be used whenever available and
          efficient for the task at hand.\n   The ROHC segmentation protocol has been
          designed with an assumption\n   of in-order delivery of packets between
          the compressor and the\n   decompressor, using only a CRC for error detection,
          and no sequence\n   numbers.  If in-order delivery cannot be guaranteed,
          ROHC\n   segmentation MUST NOT be used.\n   The segmentation protocol also
          assumes that all segments of a ROHC\n   packet corresponding to one context
          are received without interference\n   from other ROHC packets over the channel,
          including any ROHC packet\n   corresponding to a different context.  Based
          on this assumption,\n   segments do not carry CID information, and therefore
          cannot be\n   associated with a specific context until all segments have
          been\n   received and the whole unit has been reconstructed.\n"
        title: 5.2.5.1.  Segmentation Usage Considerations
      - contents:
        - "5.2.5.2.  Segmentation Protocol\n   ROHC segmentation is applied to the
          combination of the Header and the\n   Payload fields of the ROHC packet,
          as defined in Section 5.2.1.\n   Segment format:\n        0   1   2   3
          \  4   5   6   7\n      +---+---+---+---+---+---+---+---+\n      | 1   1
          \  1   1   1   1   1 | F |  segment type\n      +---+---+---+---+---+---+---+---+\n
          \     /           Segment             /  variable length\n      +---+---+---+---+---+---+---+---+\n
          \  F: Final bit.  If set, it indicates that this is the last segment of\n
          \  a reconstructed unit.\n   Padding and/or Feedback may precede the segment
          type octet.  There is\n   no per-segment CID, but CID information is of
          course part of the\n   reconstructed unit.  The reconstructed unit MUST
          NOT contain padding,\n   segments, or feedback.\n   When a final segment
          is received, the decompressor reassembles the\n   segment carried in this
          packet and any non-final segments that\n   immediately preceded it into
          a single reconstructed unit, in the\n   order they were received.  All segments
          for one reconstructed unit\n   have to be received consecutively and in
          the correct order by the\n   decompressor.  If a non-segment ROHC packet
          directly follows a non-\n   final segment, the reassembly of the current
          reconstructed unit is\n   aborted and the decompressor MUST discard the
          non-final segments so\n   far received on this channel.\n   Reconstructed
          unit:\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
          \     /            Header             /\n      +---+---+---+---+---+---+---+---+\n
          \     :            Payload            :\n      +---+---+---+---+---+---+---+---+\n
          \     /              CRC              /  4 octets\n      +---+---+---+---+---+---+---+---+\n
          \  Header: See Section 5.2.1\n   Payload: See Section 5.2.1\n   CRC: 32-bit
          CRC computed using the polynomial of Section 5.3.1.4\n   If the reconstructed
          unit is 4 octets or less, or if the CRC fails,\n   or if it is larger than
          the channel parameter MRRU (see\n   Section 5.1.2), the reconstructed unit
          MUST be discarded by the\n   decompressor.  If the CRC succeeds, the reconstructed
          unit can be\n   further processed.\n"
        title: 5.2.5.2.  Segmentation Protocol
      title: 5.2.5.  ROHC Segmentation
    title: 5.2.  ROHC Packets and Packet Types
  - contents:
    - '5.3.  General Encoding Methods

      '
    - contents:
      - "5.3.1.  Header Compression CRCs, Coverage, and Polynomials\n   This section
        describes how to calculate the CRCs used by ROHC.  For\n   all CRCs, the algorithm
        used to calculate the CRC is the same as the\n   one used in [RFC1662], defined
        in Appendix A of this document, with\n   the polynomials specified in subsequent
        sections.\n"
      - contents:
        - "5.3.1.1.  8-bit CRC in IR and IR-DYN Headers\n   The coverage for the 8-bit
          CRC in the IR and IR-DYN headers is\n   profile-dependent, but it MUST cover
          at least the initial part of the\n   header ending with the Profile field,
          including the CID or an Add-CID\n   octet.  Feedback and padding are not
          part of Header (Section 5.2.1)\n   and are thus not included in the CRC
          calculation.  As a rule of thumb\n   for profile specifications, any other
          information that initializes\n   the decompressor context SHOULD also be
          covered by a CRC.\n   More specifically, the 8-bit CRC does not cover only
          and entirely the\n   original uncompressed header; therefore, it does not
          provide the\n   means for the decompressor to verify a decompression attempt,
          or the\n   means to verify the correctness of the entire decompressor context.\n
          \  However, when successful, it does provide enough robustness for the\n
          \  decompressor to update its context with the information carried\n   within
          the IR or the IR-DYN header.\n   The CRC polynomial for the 8-bit CRC is:\n
          \        C(x) = 1 + x + x^2 + x^8\n   When computing the CRC, the CRC field
          in the header is set to zero,\n   and the initial content of the CRC register
          is set to all 1's.\n"
        title: 5.3.1.1.  8-bit CRC in IR and IR-DYN Headers
      - contents:
        - "5.3.1.2.  3-bit CRC in Compressed Headers\n   The 3-bit CRC in compressed
          headers is calculated over all octets of\n   the entire original header,
          before compression, in the following\n   manner.\n   The initial content
          of the CRC register is set to all 1's.\n   The polynomial for the 3-bit
          CRC is:\n         C(x) = 1 + x + x^3\n   The purpose of the 3-bit CRC is
          to provide the means for the\n   decompressor to verify the outcome of a
          decompression attempt for\n   small compressed headers, and to detect context
          damage based on\n   aggregated probability over a number of decompression
          attempts.\n   However, it is too weak to provide enough success guarantees
          from the\n   decompression of one single header.  Therefore, compressed
          headers\n   carrying a 3-bit CRC are normally not suitable to perform context\n
          \  repairs at the decompressor; hence, profiles should refrain from\n   allowing
          decompression of such a header when some or the entire\n   decompressor
          context is assumed invalid.\n"
        title: 5.3.1.2.  3-bit CRC in Compressed Headers
      - contents:
        - "5.3.1.3.  7-bit CRC in Compressed Headers\n   The 7-bit CRC in compressed
          headers is calculated over all octets of\n   the entire original header,
          before compression, in the following\n   manner.\n   The initial content
          of the CRC register is set to all 1's.\n   The polynomial for the 7-bit
          CRC is:\n         C(x) = 1 + x + x^2 + x^3 + x^6 + x^7\n   The purpose of
          the 7-bit CRC is to provide the means for the\n   decompressor to verify
          the outcome of a decompression attempt for a\n   larger compressed header,
          and to provide enough protection to\n   validate a context repair at the
          decompressor.  The 7-bit CRC is\n   strong enough to assume a repair to
          be successful from the\n   decompression of one single header; hence, profiles
          may allow\n   decompression of a header carrying a 7-bit CRC when some of
          the\n   decompressor context is assumed invalid.\n"
        title: 5.3.1.3.  7-bit CRC in Compressed Headers
      - contents:
        - "5.3.1.4.  32-bit Segmentation CRC\n   The 32-bit CRC is used by the segmentation
          scheme to verify the\n   reconstructed unit, and it is thus calculated over
          the segmented\n   unit, i.e., over the Header and the Payload fields of
          the ROHC\n   packet.\n   The initial content of the CRC register is set
          to all 1's.\n   The polynomial for the 32-bit CRC is:\n         C(x) = x^0
          + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +\n                x^11 + x^12
          + x^16 + x^22 + x^23 + x^26 + x^32\n   The purpose of the 32-bit CRC is
          to verify the reconstructed unit.\n"
        title: 5.3.1.4.  32-bit Segmentation CRC
      title: 5.3.1.  Header Compression CRCs, Coverage, and Polynomials
    - contents:
      - "5.3.2.  Self-Describing Variable-Length Values\n   The values of many fields
        and compression parameters can vary widely.\n   To optimize the transfer of
        such values, a variable number of octets\n   are used to encode them.  The
        first few bits of the first octet\n   determine the number of octets used:\n
        \     First bit is 0: 1 octet.\n               7 bits transferred.\n               Up
        to 127 decimal.\n               Encoded octets in hexadecimal: 00 to 7F\n
        \     First bits are 10: 2 octets.\n               14 bits transferred.\n
        \              Up to 16 383 decimal.\n               Encoded octets in hexadecimal:
        80 00 to BF FF\n      First bits are 110: 3 octets.\n               21 bits
        transferred.\n               Up to 2 097 151 decimal.\n               Encoded
        octets in hexadecimal: C0 00 00 to DF FF FF\n      First bits are 111: 4 octets.\n
        \              29 bits transferred.\n               Up to 536 870 911 decimal.\n
        \              Encoded octets in hexadecimal: E0 00 00 00 to FF FF FF FF\n"
      title: 5.3.2.  Self-Describing Variable-Length Values
    title: 5.3.  General Encoding Methods
  - contents:
    - "5.4.  ROHC UNCOMPRESSED -- No Compression  (Profile 0x0000)\n   This section
      describes the uncompressed ROHC profile.  The profile\n   identifier for this
      profile is 0x0000.\n   Profile 0x0000 provides a way to send IP packets without
      compressing\n   them.  This can be used for any packet for which a compression\n
      \  profile is not available in the set of profiles supported by the ROHC\n   channel,
      or for which compression is not desirable for some reason.\n   After initialization,
      the only overhead for sending packets using\n   Profile 0x0000 is the size of
      the CID.  When uncompressed packets are\n   frequent, Profile 0x0000 should
      be associated with a CID the size of\n   zero or one octet.  Profile 0x0000
      SHOULD be associated with at most\n   one CID.\n"
    - contents:
      - "5.4.1.  IR Packet\n   The initialization and refresh packet (IR packet) for
        Profile 0x0000\n   has the following Header format:\n        0   1   2   3
        \  4   5   6   7\n       --- --- --- --- --- --- --- ---\n      :         Add-CID
        octet         : if for small CIDs and (CID != 0)\n      +---+---+---+---+---+---+---+---+\n
        \     | 1   1   1   1   1   1   0 |res|\n      +---+---+---+---+---+---+---+---+\n
        \     :                               :\n      /    0-2 octets of CID info
        \    / 1-2 octets if for large CIDs\n      :                               :\n
        \     +---+---+---+---+---+---+---+---+\n      |         Profile = 0x00        |
        1 octet\n      +---+---+---+---+---+---+---+---+\n      |              CRC
        \             | 1 octet\n      +---+---+---+---+---+---+---+---+\n   res:
        MUST be set to zero; otherwise, the decompressor MUST discard\n   the packet.\n
        \  Profile: 0x00\n   CRC: 8-bit CRC, computed using the polynomial of Section
        5.3.1.1.\n   The CRC covers the first octet of the IR Header through the Profile\n
        \  octet of the IR Header, i.e., it does not cover the CRC itself.\n   Neither
        does it cover any preceding Padding or Feedback, nor the\n   Payload.\n   For
        the IR packet, Payload has the following format:\n       --- --- --- --- ---
        --- --- ---\n      :                               : (optional)\n      /           IP
        packet           / variable length\n      :                               :\n
        \      --- --- --- --- --- --- --- ---\n   IP packet: An uncompressed IP packet
        may be included in the IR\n   packet.  The decompressor determines if the
        IP packet is present by\n   considering the length of the IR packet.\n"
      title: 5.4.1.  IR Packet
    - contents:
      - "5.4.2.  Normal Packet\n   A Normal packet is a normal IP packet plus CID
        information.  For the\n   Normal Packet, the following format corresponds
        to the Header and\n   Payload (as defined in Section 5.2.1):\n        0   1
        \  2   3   4   5   6   7\n       --- --- --- --- --- --- --- ---\n      :
        \        Add-CID octet         : if for small CIDs and (CID != 0)\n      +---+---+---+---+---+---+---+---+\n
        \     |   first octet of IP packet    |\n      +---+---+---+---+---+---+---+---+\n
        \     :                               :\n      /    0-2 octets of CID info
        \    / 1-2 octets if for large CIDs\n      :                               :\n
        \     +---+---+---+---+---+---+---+---+\n      |                               |\n
        \     /       rest of IP packet       / variable length\n      |                               |\n
        \     +---+---+---+---+---+---+---+---+\n   Note that the first octet of the
        IP packet starts with the bit\n   pattern 0100 (IPv4) or 0110 (IPv6).  This
        does not conflict with any\n   reserved packet types.\n   When the channel
        uses small CIDs, and profile 0x0000 is associated\n   with a CID > 0, an Add-CID
        octet precedes the IP packet.  When the\n   channel uses large CIDs, the CID
        is placed so that it starts at the\n   second octet of the combined Header/Payload
        format above.\n   A Normal Packet may carry Padding and/or Feedback as any
        other ROHC\n   packet, preceding the combined Header/Payload.\n"
      title: 5.4.2.  Normal Packet
    - contents:
      - "5.4.3.  Context Initialization\n   The compressor initializes the static
        context associated with the\n   UNCOMPRESSED profile by sending IR packets
        (see Section 5.4.1).\n   During context initialization, it is RECOMMENDED
        that the compressor\n   sends IR packets until it is reasonably confident
        that the\n   decompressor has successfully received at least one IR packet.
        \ For\n   example, this confidence can be based on feedback from the\n   decompressor,
        or on knowledge of the characteristics of the link.\n   The compressor SHOULD
        periodically transmit IR packets for a context\n   associated with the UNCOMPRESSED
        profile, at least until it receives\n   feedback from the decompressor for
        that context.  The compressor MAY\n   stop the periodic sending of IR packets
        once it has received\n   feedback.\n"
      title: 5.4.3.  Context Initialization
    - contents:
      - "5.4.4.  Decompressor Operation\n   When an IR packet is received, the decompressor
        first validates its\n   header using the 8-bit CRC.\n   o   If the header
        fails validation, the decompressor MUST NOT deliver\n       the IP packet
        to upper layers.\n   o   If the header is successfully validated, the decompressor\n
        \      1.  initializes the context if it has no valid context for the\n           given
        CID already associated to the specified profile,\n       2.  delivers the
        IP packet to upper layers if present,\n       3.  MAY send an ACK.\n   When
        any other packet is received while the decompressor has no\n   context, it
        is discarded without further action.\n   When a Normal packet is received
        and the decompressor has a valid\n   context, the IP packet is extracted and
        delivered to upper layers.\n"
      title: 5.4.4.  Decompressor Operation
    - contents:
      - "5.4.5.  Feedback\n   The only kind of feedback defined by Profile 0x0000
        is ACK, using the\n   FEEDBACK-1 format of Section 5.2.4.1, where the value
        of the profile-\n   specific octet in the FEEDBACK-1 is 0 (zero).  The FEEDBACK-2
        format\n   is thus not defined for Profile 0x0000.\n"
      title: 5.4.5.  Feedback
    title: 5.4.  ROHC UNCOMPRESSED -- No Compression  (Profile 0x0000)
  title: 5.  The ROHC Framework (Normative)
- contents:
  - "6.  Overview of a ROHC Profile (Informative)\n   The ROHC protocol consists of
    a framework part and a profile part.\n   The framework defines the mechanisms
    common to all profiles, while\n   the profile defines the compression algorithm
    and profile-specific\n   packet formats.\n   Section 5 specifies the details of
    the ROHC framework.  This section\n   provides an informative overview of the
    elements that make a profile\n   specification.  The normative specification of
    individual profiles is\n   outside the scope of this document.\n   A ROHC profile
    defines the elements that build up the compression\n   protocol.  A ROHC profile
    consists of:\n   Packet formats:\n   o  Bits-on-the-wire\n         The profile
    defines the layout of the bits for profile-specific\n         packet types that
    it defines, and for the profile-specific\n         parts of packet types common
    to all profiles (e.g., IR and IR-\n         DYN).\n   o  Field encodings\n         Bits
    and groups of bits from the packet format layout, referred\n         to as Compressed
    fields, represent the result of an encoding\n         method specific for that
    compressed field within a specific\n         packet format.  The profile defines
    these encoding methods.\n   o  Updating properties\n         The profile-specific
    packet formats may update the state of the\n         decompressor, and may do
    so in different ways.  The profile\n         defines how individual profile-specific
    fields, or entire\n         profile-specific packet types, update the decompressor
    context.\n   o  Verification\n         Packets that update the state of the decompressor
    are verified\n         to prevent incorrect updates to the decompressor context.
    \ The\n         profile defines the mechanisms used to verify the decompression\n
    \        of a packet.\n   Context management:\n   o  Robustness logic\n         Packets
    may be lost or reordered between the compressor and the\n         decompressor.
    \ The profile defines mechanisms to minimize the\n         impacts of such events
    and prevent damage propagation.\n   o  Repair mechanism\n         Despite the
    robustness logic, impairment events may still lead\n         to decompression
    failure(s), and even to context damage at the\n         decompressor.  The profile
    defines context repair mechanisms,\n         including feedback logic if used.\n"
  title: 6.  Overview of a ROHC Profile (Informative)
- contents:
  - "7.  Acknowledgments\n   The authors would like to acknowledge all who have contributed
    to\n   previous ROHC work, and especially to the authors of RFC 3095\n   [RFC3095],
    which is the technical basis for this document.  Thanks\n   also to the various
    individuals who contributed to the RFC 3095\n   corrections and clarifications
    document [RFC4815], from which\n   technical contents, when applicable, have been
    incorporated into this\n   document.  Thanks to Jani Juvan for discovering an
    inconsistency\n   between the feedback structure described in [RFC4995] and the
    one\n   described in [RFC3095], which made this update to [RFC4995]\n   necessary.\n
    \  Committed WG document reviewers were Carl Knutsson, Biplab Sarkar,\n   and
    Robert Stangarone, who reviewed the document during working group\n   last calls.
    \ Additional thanks to Bert Wijnen and Brian Carpenter for\n   comments during
    IETF Last Call.\n"
  title: 7.  Acknowledgments
- contents:
  - "8.  IANA Considerations\n   An IANA registry for \"RObust Header Compression
    (ROHC) Profile\n   Identifiers\" [ROHC-ids] was created by RFC 3095 [RFC3095].
    \ The\n   assignment policy, as outlined by RFC 3095, is the following:\n   The
    ROHC profile identifier is a non-negative integer.  In many\n   negotiation protocols,
    it will be represented as a 16-bit value.  Due\n   to the way the profile identifier
    is abbreviated in ROHC packets, the\n   8 LSBs of the profile identifier have
    a special significance: Two\n   profile identifiers with identical 8 LSBs should
    be assigned only if\n   the higher-numbered one is intended to supersede the lower-numbered\n
    \  one.  To highlight this relationship, profile identifiers should be\n   given
    in hexadecimal (for example, as in 0x1234, which would\n   supersede 0x0A34).\n
    \  Following the policies outlined in [RFC5226], the IANA policy for\n   assigning
    new values for the profile identifier is Specification\n   Required: values and
    their meanings must be documented in an RFC or\n   in some other permanent and
    readily available reference, in\n   sufficient detail that interoperability between
    independent\n   implementations is possible.  In the 8 LSBs, the range 0 to 127
    is\n   reserved for IETF standard-track specifications; the range 128 to 254\n
    \  is available for other specifications that meet this requirement\n   (such
    as Informational RFCs).  The LSB value 255 is reserved for\n   future extensibility
    of the present specification.\n   The following profile identifiers have so far
    been allocated:\n      Profile Identifier    Usage                      Reference\n
    \     ------------------    ----------------------     ---------\n      0x0000
    \               ROHC uncompressed          RFC 5795\n      0x0001                ROHC
    RTP                   RFC 3095\n      0x0002                ROHC UDP                   RFC
    3095\n      0x0003                ROHC ESP                   RFC 3095\n      0x0004
    \               ROHC IP                    RFC 3843\n      0x0005                ROHC
    LLA                   RFC 3242\n      0x0105                ROHC LLA with R-mode
    \      RFC 3408\n      0x0006                ROHC TCP                   RFC 4996\n
    \     0x0007                ROHC RTP/UDP-Lite          RFC 4019\n      0x0008
    \               ROHC UDP-Lite              RFC 4019\n      0x0101                ROHCv2
    RTP                 RFC 5225\n      0x0102                ROHCv2 UDP                 RFC
    5225\n      0x0103                ROHCv2 ESP                 RFC 5225\n      0x0104
    \               ROHCv2 IP                  RFC 5225\n      0x0107                ROHCv2
    RTP/UDP-Lite        RFC 5225\n      0x0108                ROHCv2 UDP-Lite            RFC
    5225\n   New profiles will need new identifiers to be assigned by the IANA,\n
    \  but this document does not require any additional IANA action.\n"
  title: 8.  IANA Considerations
- contents:
  - "9.  Security Considerations\n   Because encryption eliminates the redundancy
    that header compression\n   schemes try to exploit, there is some inducement to
    forego encryption\n   of headers in order to enable operation over low-bandwidth
    links.\n   A malfunctioning or malicious header compressor could cause the\n   header
    decompressor to reconstitute packets that do not match the\n   original packets
    but still have valid headers and possibly also valid\n   transport checksums.
    \ Such corruption may be detected with end-to-end\n   authentication and integrity
    mechanisms, which will not be affected\n   by the compression.  Moreover, the
    ROHC header compression scheme\n   uses an internal checksum for verification
    of reconstructed headers,\n   which reduces the probability of producing decompressed
    headers not\n   matching the original ones without this being noticed.\n   Denial-of-service
    attacks are possible if an intruder can introduce,\n   for example, bogus IR,
    IR-DYN, or feedback packets onto the link and\n   thereby cause compression efficiency
    to be reduced.  However, an\n   intruder having the ability to inject arbitrary
    packets at the link\n   layer in this manner raises additional security issues
    that dwarf\n   those related to the use of header compression.\n"
  title: 9.  Security Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]    Bradner, S., \"Key words for use
      in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [CRTP-eval]  Degermark, M., Hannu, H., Jonsson,
      L., and K. Svanbro,\n                \"\"Evaluation of CRTP Performance over
      Cellular Radio\n                Networks\", IEEE Personal Communication Magazine,
      Volume\n                7, number 4, pp. 20-25, August 2000.\", 2000.\n   [RFC0768]
      \   Postel, J., \"User Datagram Protocol\", STD 6, RFC 768,\n                August
      1980.\n   [RFC0791]    Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n
      \               September 1981.\n   [RFC0793]    Postel, J., \"Transmission
      Control Protocol\", STD 7,\n                RFC 793, September 1981.\n   [RFC1144]
      \   Jacobson, V., \"Compressing TCP/IP headers for low-speed\n                serial
      links\", RFC 1144, February 1990.\n   [RFC1662]    Simpson, W., \"PPP in HDLC-like
      Framing\", STD 51,\n                RFC 1662, July 1994.\n   [RFC2460]    Deering,
      S. and R. Hinden, \"Internet Protocol, Version 6\n                (IPv6) Specification\",
      RFC 2460, December 1998.\n   [RFC2507]    Degermark, M., Nordgren, B., and S.
      Pink, \"IP Header\n                Compression\", RFC 2507, February 1999.\n
      \  [RFC2508]    Casner, S. and V. Jacobson, \"Compressing IP/UDP/RTP\n                Headers
      for Low-Speed Serial Links\", RFC 2508,\n                February 1999.\n   [RFC3095]
      \   Bormann, C., Burmeister, C., Degermark, M., Fukushima,\n                H.,
      Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T.,\n                Le, K.,
      Liu, Z., Martensson, A., Miyazaki, A., Svanbro,\n                K., Wiebke,
      T., Yoshimura, T., and H. Zheng, \"RObust\n                Header Compression
      (ROHC): Framework and four profiles:\n                RTP, UDP, ESP, and uncompressed\",
      RFC 3095, July 2001.\n   [RFC3096]    Degermark, M., \"Requirements for robust
      IP/UDP/RTP\n                header compression\", RFC 3096, July 2001.\n   [RFC3241]
      \   Bormann, C., \"Robust Header Compression (ROHC) over\n                PPP\",
      RFC 3241, April 2002.\n   [RFC3545]    Koren, T., Casner, S., Geevarghese, J.,
      Thompson, B.,\n                and P. Ruddy, \"Enhanced Compressed RTP (CRTP)
      for Links\n                with High Delay, Packet Loss and Reordering\", RFC
      3545,\n                July 2003.\n   [RFC3550]    Schulzrinne, H., Casner,
      S., Frederick, R., and V.\n                Jacobson, \"RTP: A Transport Protocol
      for Real-Time\n                Applications\", STD 64, RFC 3550, July 2003.\n
      \  [RFC3759]    Jonsson, L-E., \"RObust Header Compression (ROHC):\n                Terminology
      and Channel Mapping Examples\", RFC 3759,\n                April 2004.\n   [RFC4224]
      \   Pelletier, G., Jonsson, L-E., and K. Sandlund, \"RObust\n                Header
      Compression (ROHC): ROHC over Channels That Can\n                Reorder Packets\",
      RFC 4224, January 2006.\n   [RFC4815]    Jonsson, L-E., Sandlund, K., Pelletier,
      G., and P.\n                Kremer, \"RObust Header Compression (ROHC): Corrections\n
      \               and Clarifications to RFC 3095\", RFC 4815,\n                February
      2007.\n   [RFC4995]    Jonsson, L-E., Pelletier, G., and K. Sandlund, \"The\n
      \               RObust Header Compression (ROHC) Framework\", RFC 4995,\n                July
      2007.\n   [RFC4996]    Pelletier, G., Sandlund, K., Jonsson, L-E., and M. West,\n
      \               \"RObust Header Compression (ROHC): A Profile for TCP/IP\n                (ROHC-TCP)\",
      RFC 4996, July 2007.\n   [RFC5225]    Pelletier, G. and K. Sandlund, \"RObust
      Header\n                Compression Version 2 (ROHCv2): Profiles for RTP, UDP,\n
      \               IP, ESP and UDP-Lite\", RFC 5225, April 2008.\n   [RFC5226]
      \   Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n                IANA
      Considerations Section in RFCs\", BCP 26, RFC 5226,\n                May 2008.\n
      \  [ROHC-ids]   IANA, \"RObust Header Compression (ROHC) Profile\n                Identifiers\",
      <http://www.iana.org>.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  CRC Algorithm\n     #!/usr/bin/perl -w\n   use strict;\n   #=================================\n
    \  #\n   # ROHC CRC demo - Carsten Bormann cabo@tzi.org 2001-08-02\n   #\n   #
    This little demo shows the four types of CRC in use in RFC 3095,\n   # the specification
    for robust header compression.  Type your data in\n   # hexadecimal form and then
    press Control+D.\n   #\n   #---------------------------------\n   #\n   # utility\n
    \  #\n   sub dump_bytes($) {\n       my $x = shift;\n       my $i;\n       for
    ($i = 0; $i < length($x); ) {\n     printf(\"%02x \", ord(substr($x, $i, 1)));\n
    \    printf(\"\\n\") if (++$i % 16 == 0);\n       }\n       printf(\"\\n\") if
    ($i % 16 != 0);\n   }\n   #---------------------------------\n   #\n   # The CRC
    calculation algorithm.\n   #\n   sub do_crc($$$) {\n       my $nbits = shift;\n
    \      my $poly = shift;\n       my $string = shift;\n       my $crc = ($nbits
    == 32 ? 0xffffffff : (1 << $nbits) - 1);\n       for (my $i = 0; $i < length($string);
    ++$i) {\n         my $byte = ord(substr($string, $i, 1));\n         for( my $b
    = 0; $b < 8; $b++ ) {\n           if (($crc & 1) ^ ($byte & 1)) {\n             $crc
    >>= 1;\n             $crc ^= $poly;\n           } else {\n           $crc >>=
    1;\n           }\n           $byte >>= 1;\n         }\n       }\n       printf
    \"%2d bits, \", $nbits;\n       printf \"CRC: %02x\\n\", $crc;\n   }\n   #---------------------------------\n
    \  #\n   # Test harness\n   #\n   $/ = undef;\n   $_ = <>;         # read until
    EOF\n   my $string = \"\"; # extract all that looks hex:\n   s/([0-9a-fA-F][0-9a-fA-F])/$string
    .= chr(hex($1)), \"\"/eg;\n   dump_bytes($string);\n   #---------------------------------\n
    \  #\n   # 32-bit segmentation CRC\n   # Note that the text implies this is complemented
    like for PPP\n   # (this differs from 8, 7, and 3-bit CRC)\n   #\n   #      C(x)
    = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +\n   #             x^11 + x^12
    + x^16 + x^22 + x^23 + x^26 + x^32\n   #\n   do_crc(32, 0xedb88320, $string);\n
    \  #---------------------------------\n   #\n   # 8-bit IR/IR-DYN CRC\n   #\n
    \  #      C(x) = x^0 + x^1 + x^2 + x^8\n   #\n   do_crc(8, 0xe0, $string);\n   #---------------------------------\n
    \  #\n   # 7-bit FO/SO CRC\n   #\n   #      C(x) = x^0 + x^1 + x^2 + x^3 + x^6
    + x^7\n   #\n   do_crc(7, 0x79, $string);\n   #---------------------------------\n
    \  #\n   # 3-bit FO/SO CRC\n   #\n   #      C(x) = x^0 + x^1 + x^3\n   #\n   do_crc(3,
    0x6, $string);\n"
  title: Appendix A.  CRC Algorithm
- contents:
  - "Authors' Addresses\n   Kristofer Sandlund\n   Ericsson\n   Box 920\n   Lulea
    \ SE-971 28\n   Sweden\n   Phone: +46 (0) 8 404 41 58\n   EMail: kristofer.sandlund@ericsson.com\n
    \  Ghyslain Pelletier\n   Ericsson\n   Box 920\n   Lulea  SE-971 28\n   Sweden\n
    \  Phone: +46 (0) 8 404 29 43\n   EMail: ghyslain.pelletier@ericsson.com\n   Lars-Erik
    Jonsson\n   Optand 737\n   Ostersund  SE-831 92\n   Sweden\n   Phone: +46 76 830
    03 12\n   EMail: lars-erik@lejonsson.com\n"
  title: Authors' Addresses
