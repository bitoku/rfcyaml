- title: __initial_text__
  contents:
  - '                 Sakai-Kasahara Key Encryption (SAKKE)

    '
- title: Abstract
  contents:
  - "Abstract\n   In this document, the Sakai-Kasahara Key Encryption (SAKKE) algorithm\n\
    \   is described.  This uses Identity-Based Encryption to exchange a\n   shared\
    \ secret from a Sender to a Receiver.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It has been approved for\
    \ publication by the Internet\n   Engineering Steering Group (IESG).  Not all\
    \ documents approved by the\n   IESG are a candidate for any level of Internet\
    \ Standard; see Section\n   2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6508.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \      1.1. Requirements Terminology ...................................3\n  \
    \ 2. Notation and Definitions ........................................3\n    \
    \  2.1. Notation ...................................................3\n      2.2.\
    \ Definitions ................................................5\n      2.3. Parameters\
    \ to Be Defined or Negotiated .....................6\n   3. Elliptic Curves and\
    \ Pairings ....................................7\n      3.1. E(F_p^2) and the\
    \ Distortion Map ............................7\n      3.2. The Tate-Lichtenbaum\
    \ Pairing ...............................7\n   4. Representation of Values ........................................9\n\
    \   5. Supporting Algorithms ..........................................10\n  \
    \    5.1. Hashing to an Integer Range ...............................10\n   6.\
    \ The SAKKE Cryptosystem .........................................11\n      6.1.\
    \ Setup .....................................................11\n           6.1.1.\
    \ Secret Key Extraction ..............................11\n           6.1.2. User\
    \ Provisioning ..................................11\n      6.2. Key Exchange ..............................................12\n\
    \           6.2.1. Sender .............................................12\n  \
    \         6.2.2. Receiver ...........................................12\n    \
    \  6.3. Group Communications ......................................13\n   7. Security\
    \ Considerations ........................................13\n   8. References\
    \ .....................................................15\n      8.1. Normative\
    \ References ......................................15\n      8.2. Informative\
    \ References ....................................15\n   Appendix A. Test Data..............................................17\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines an efficient use of Identity-Based\
    \ Encryption\n   (IBE) based on bilinear pairings.  The Sakai-Kasahara IBE\n \
    \  cryptosystem [S-K] is described for establishment of a shared secret\n   value.\
    \  This document adds to the IBE options available in [RFC5091],\n   providing\
    \ an efficient primitive and an additional family of curves.\n   This document\
    \ is restricted to a particular family of curves (see\n   Section 2.1) that have\
    \ the benefit of a simple and efficient method\n   of calculating the pairing\
    \ on which the Sakai-Kasahara IBE\n   cryptosystem is based.\n   IBE schemes allow\
    \ public and private keys to be derived from\n   Identifiers.  In fact, the Identifier\
    \ can itself be viewed as\n   corresponding to a public key or certificate in\
    \ a traditional public\n   key system.  However, in IBE, the Identifier can be\
    \ formed by both\n   Sender and Receiver, which obviates the necessity of providing\
    \ public\n   keys through a third party or of transmitting certified public keys\n\
    \   during each session establishment.  Furthermore, in an IBE system,\n   calculation\
    \ of keys can occur as needed, and indeed, messages can be\n   sent to users who\
    \ are yet to enroll.\n   The Sakai-Kasahara primitive described in this document\
    \ supports\n   simplex transmission of messages from a Sender to a Receiver. \
    \ The\n   choice of elliptic curve pairing on which the primitive is based\n \
    \  allows simple and efficient implementations.\n   The Sakai-Kasahara Key Encryption\
    \ scheme described in this document\n   is drawn from the Sakai-Kasahara Key Encapsulation\
    \ Mechanism (SK-KEM)\n   scheme (as modified to support multi-party communications)\
    \ submitted\n   to the IEEE P1363 Working Group in [SK-KEM].\n"
- title: 1.1.  Requirements Terminology
  contents:
  - "1.1.  Requirements Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  Notation and Definitions
  contents:
  - '2.  Notation and Definitions

    '
- title: 2.1.  Notation
  contents:
  - "2.1.  Notation\n   n      A security parameter; the size of symmetric keys in\
    \ bits to be\n          exchanged by SAKKE.\n   p      A prime, which is the order\
    \ of the finite field F_p.  In this\n          document, p is always congruent\
    \ to 3 modulo 4.\n   F_p    The finite field of order p.\n   F*     The multiplicative\
    \ group of the non-zero elements in the field\n          F; e.g., (F_p)* is the\
    \ multiplicative group of the finite\n          field F_p.\n   q      An odd prime\
    \ that divides p + 1.  To provide the desired level\n          of security, lg(q)\
    \ MUST be greater than 2*n.\n   E      An elliptic curve defined over F_p, having\
    \ a subgroup of order\n          q.  In this document, we use supersingular curves\
    \ with\n          equation y^2 = x^3 - 3 * x modulo p.  This curve is chosen\n\
    \          because of the efficiency and simplicity advantages it offers.\n  \
    \        The choice of -3 for the coefficient of x provides advantages\n     \
    \     for elliptic curve arithmetic that are explained in [P1363].\n         \
    \ A further reason for this choice of curve is that Barreto's\n          trick\
    \ [Barreto] of eliminating the computation of the\n          denominators when\
    \ calculating the pairing applies.\n   E(F)   The additive group of points of\
    \ affine coordinates (x,y) with\n          x, y in the field F, that satisfy the\
    \ curve equation for E.\n   P      A point of E(F_p) that generates the cyclic\
    \ subgroup of order\n          q.  The coordinates of P are given by P = (P_x,P_y).\
    \  These\n          coordinates are in F_p, and they satisfy the curve equation.\n\
    \   0      The null element of any additive group of points on an\n          elliptic\
    \ curve, also called the point at infinity.\n   F_p^2  The extension field of\
    \ degree 2 of the field F_p.  In this\n          document, we use a particular\
    \ instantiation of this field;\n          F_p^2 = F_p[i], where i^2 + 1 = 0.\n\
    \   PF_p   The projectivization of F_p.  We define this to be\n          (F_p^2)*/(F_p)*.\
    \  Note that PF_p is cyclic and has order\n          p + 1, which is divisible\
    \ by q.\n   G[q]   The q-torsion of a group G.  This is the subgroup generated\
    \ by\n          points of order q in G.\n   < , >  A version of the Tate-Lichtenbaum\
    \ pairing.  In this document,\n          this is a bilinear map from E(F_p)[q]\
    \ x E(F_p)[q] onto the\n          subgroup of order q in PF_p.  A full definition\
    \ is given in\n          Section 3.2.\n   Hash   A cryptographic hash function.\n\
    \   lg(x)  The base 2 logarithm of the real value x.\n   The following conventions\
    \ are assumed for curve operations:\n      Point addition - If A and B are two\
    \ points on a curve E, their sum\n         is denoted as A + B.\n      Scalar\
    \ multiplication - If A is a point on a curve, and k an\n         integer, the\
    \ result of adding A to itself a total of k times is\n         denoted [k]A.\n\
    \   We assume that the following concrete representations of mathematical\n  \
    \ objects are used:\n      Elements of F_p - The p elements of F_p are represented\
    \ directly\n         using the integers from 0 to p-1.\n      Elements of F_p^2\
    \ - The elements of F_p^2 = F_p[i] are represented\n         as x_1 + i * x_2,\
    \ where x_1 and x_2 are elements of F_p.\n      Elements of PF_p - Elements of\
    \ PF_p are cosets of (F_p)* in\n         (F_p^2)*.  Every element of F_p^2 can\
    \ be written unambiguously\n         in the form x_1 + i * x_2, where x_1 and\
    \ x_2 are elements of\n         F_p.  Thus, elements of PF_p (except the unique\
    \ element of\n         order 2) can be represented unambiguously by x_2/x_1 in\
    \ F_p.\n         Since q is odd, every element of PF_p[q] can be represented by\n\
    \         an element of F_p in this manner.\n   This representation of elements\
    \ in PF_p[q] allows efficient\n   implementation of PF_p[q] group operations,\
    \ as these can be defined\n   using arithmetic in F_p.  If a and b are elements\
    \ of F_p representing\n   elements A and B of PF_p[q], respectively, then A *\
    \ B in PF_p[q] is\n   represented by (a + b)/(1 - a * b) in F_p.\n"
- title: 2.2.  Definitions
  contents:
  - "2.2.  Definitions\n   Identifier - Each user of an IBE system MUST have a unique,\n\
    \      unambiguous identifying string that can be easily derived by all\n    \
    \  valid communicants.  This string is the user's Identifier.  An\n      Identifier\
    \ is an integer in the range 2 to q-1.  The method by\n      which Identifiers\
    \ are formed MUST be defined for each application.\n   Key Management Service\
    \ (KMS) - The Key Management Service is a\n      trusted third party for the IBE\
    \ system.  It derives system secrets\n      and distributes key material to those\
    \ authorized to obtain it.\n      Applications MAY support mutual communication\
    \ between the users of\n      multiple KMSs.  We denote KMSs by KMS_T, KMS_S,\
    \ etc.\n   Public parameters - The public parameters are a set of parameters\n\
    \      that are held by all users of an IBE system.  Such a system MAY\n     \
    \ contain multiple KMSs.  Each application of SAKKE MUST define the\n      set\
    \ of public parameters to be used.  The parameters needed are p,\n      q, E,\
    \ P, g=<P,P>, Hash, and n.\n   Master Secret (z_T) - The Master Secret z_T is\
    \ the master key\n      generated and privately kept by KMS_T and is used by KMS_T\
    \ to\n      generate the private keys of the users that it provisions; it is\n\
    \      an integer in the range 2 to q-1.\n   KMS Public Key: Z_T = [z_T]P - The\
    \ KMS Public Key Z_T is used to form\n      Public Key Establishment Keys for\
    \ all users provisioned by KMS_T;\n      it is a point of order q in E(F_p). \
    \ It MUST be provisioned by\n      KMS_T to all who are authorized to send messages\
    \ to users of the\n      IBE system.\n   Receiver Secret Key (RSK) - Each user\
    \ enrolled in an IBE system is\n      provisioned with a Receiver Secret Key by\
    \ its KMS.  The RSK\n      provided to a user with Identifier 'a' by KMS_T is\
    \ denoted\n      K_(a,T).  In SAKKE, the RSK is a point of order q in E(F_p).\n\
    \   Shared Secret Value (SSV) - The aim of the SAKKE scheme is for the\n     \
    \ Sender to securely transmit a shared secret value to the Receiver.\n      The\
    \ SSV is an integer in the range 0 to (2^n) - 1.\n   Encapsulated Data - The Encapsulated\
    \ Data are used to transmit secret\n      information securely to the Receiver.\
    \  They can be computed\n      directly from the Receiver's Identifier, the public\
    \ parameters,\n      the KMS Public Key, and the SSV to be transmitted.  In SAKKE,\
    \ the\n      Encapsulated Data are a point of order q in E(F_p) and an integer\n\
    \      in the range 0 to (2^n) - 1.  They are formatted as described in\n    \
    \  Section 4.\n"
- title: 2.3.  Parameters to Be Defined or Negotiated
  contents:
  - "2.3.  Parameters to Be Defined or Negotiated\n   In order for an application\
    \ to make use of the SAKKE algorithm, the\n   communicating hosts MUST agree on\
    \ values for several of the\n   parameters described above.  The curve equation\
    \ (E) and the pairing\n   (< , >) are constant and used for all applications.\n\
    \   For the following parameters, each application MUST either define an\n   application-specific\
    \ constant value or define a mechanism for hosts\n   to negotiate a value:\n \
    \     * n\n      * p\n      * q\n      * P = (P_x,P_y)\n      * g = <P,P>\n  \
    \    * Hash\n"
- title: 3.  Elliptic Curves and Pairings
  contents:
  - "3.  Elliptic Curves and Pairings\n   E is a supersingular elliptic curve (of\
    \ j-invariant 1728).  E(F_p)\n   contains a cyclic subgroup of order q, denoted\
    \ E(F_p)[q], whereas the\n   larger object E(F_p^2) contains the direct product\
    \ of two cyclic\n   subgroups of order q, denoted E(F_p^2)[q].\n   P is a generator\
    \ of E(F_p)[q].  It is specified by the (affine)\n   coordinates (P_x,P_y) in\
    \ F_p, satisfying the curve equation.\n   Routines for point addition and doubling\
    \ on E(F_p) can be found in\n   Appendix A.10 of [P1363].\n"
- title: 3.1.  E(F_p^2) and the Distortion Map
  contents:
  - "3.1.  E(F_p^2) and the Distortion Map\n   If (Q_x,Q_y) are (affine) coordinates\
    \ in F_p for some point (denoted\n   Q) on E(F_p)[q], then (-Q_x,iQ_y) are (affine)\
    \ coordinates in F_p^2\n   for some point on E(F_p^2)[q].  This latter point is\
    \ denoted [i]Q, by\n   analogy with the definition for scalar multiplication.\
    \  The two\n   points P and [i]P together generate E(F_p^2)[q].  The map [i]:\
    \ E(F_p)\n   -> E(F_p^2) is sometimes termed the distortion map.\n"
- title: 3.2.  The Tate-Lichtenbaum Pairing
  contents:
  - "3.2.  The Tate-Lichtenbaum Pairing\n   We proceed to describe the pairing < ,\
    \ > to be used in SAKKE.  We\n   will need to evaluate polynomials f_R that depend\
    \ on points on\n   E(F_p)[q].  Miller's algorithm [Miller] provides a method for\n\
    \   evaluation of f_R(X), where X is some element of E(F_p^2)[q] and R is\n  \
    \ some element of E(F_p)[q] and f_R is some polynomial over F_p whose\n   divisor\
    \ is (q)(R) - (q)(0).  Note that f_R is defined only up to\n   scalars of F_p.\n\
    \   The version of the Tate-Lichtenbaum pairing used in this document is\n   given\
    \ by <R,Q> = f_R([i]Q)^c / (F_p)*.  It satisfies the bilinear\n   relation <[x]R,Q>\
    \ = <R,[x]Q> = <R,Q>^x for all Q, R in E(F_p)[q], for\n   all integers x.  Note\
    \ that the domain of definition is restricted to\n   E(F_p)[q] x E(F_p)[q] so\
    \ that certain optimizations are natural.\n   We provide pseudocode for computing\
    \ <R,Q>, with elliptic curve\n   arithmetic expressed in affine coordinates. \
    \ We make use of Barreto's\n   trick [Barreto] for avoiding the calculation of\
    \ denominators.  Note\n   that this section does not fully describe the most efficient\
    \ way of\n   computing the pairing; it is possible to compute the pairing without\n\
    \   any explicit reference to the extension field F_p^2.  This reduces\n   the\
    \ number and complexity of the operations needed to compute the\n   pairing.\n\
    \   <CODE BEGINS>\n   /*\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as\n   authors of the code.  All rights reserved.\n   Redistribution and use\
    \ in source and binary forms, with or without\n   modification, is permitted pursuant\
    \ to, and subject to the license\n   terms contained in, the Simplified BSD License\
    \ set forth in\n   Section 4.c of the IETF Trust's Legal Provisions Relating to\n\
    \   IETF Documents (http://trustee.ietf.org/license-info).\n   */\n       Routine\
    \ for computing the pairing <R,Q>:\n         Input R, Q points on E(F_p)[q];\n\
    \         Initialize variables:\n           v = (F_p)*;    // An element of PF_p[q]\n\
    \           C = R;         // An element of E(F_p)[q]\n           c = (p+1)/q;\
    \   // An integer\n         for bits of q-1, starting with the second most significant\n\
    \         bit, ending with the least significant bit, do\n           // gradient\
    \ of line through C, C, [-2]C.\n           l = 3*( C_x^2 - 1 ) / ( 2*C_y );\n\
    \           //accumulate line evaluated at [i]Q into v\n           v = v^2 * (\
    \ l*( Q_x + C_x ) + ( i*Q_y - C_y ) );\n           C = [2]C;\n           if bit\
    \ is 1, then\n             // gradient of line through C, R, -C-R.\n         \
    \    l = ( C_y - R_y )/( C_x - R_x );\n             //accumulate line evaluated\
    \ at [i]Q into v\n             v = v * ( l*( Q_x + C_x ) + ( i*Q_y - C_y ) );\n\
    \             C = C+R;\n           end if;\n         end for;\n         t = v^c;\n\
    \         return representative in F_p of t;\n       End of routine;\n       Routine\
    \ for computing representative in F_p of elements of PF_p:\n         Input t,\
    \ in F_p^2, representing an element of PF_p;\n         Represent t as a + i*b,\
    \ with a,b in F_p;\n         return b/a;\n       End of routine;\n   <CODE ENDS>\n"
- title: 4.  Representation of Values
  contents:
  - "4.  Representation of Values\n   This section provides canonical representations\
    \ of values that MUST\n   be used to ensure interoperability of implementations.\
    \  The following\n   representations MUST be used for input into hash functions\
    \ and for\n   transmission.\n   Integers           Integers MUST be represented\
    \ as an octet string,\n                      with bit length a multiple of 8.\
    \  To achieve this,\n                      the integer is represented most significant\
    \ bit\n                      first, and padded with zero bits on the left until\n\
    \                      an octet string of the necessary length is\n          \
    \            obtained.  This is the octet string representation\n            \
    \          described in Section 6 of [RFC6090].\n   F_p elements       Elements\
    \ of F_p MUST be represented as integers in\n                      the range 0\
    \ to p-1 using the octet string\n                      representation defined\
    \ above.  Such octet strings\n                      MUST have length L = Ceiling(lg(p)/8).\n\
    \   PF_p elements      Elements of PF_p MUST be represented as an element\n  \
    \                    of F_p using the algorithm in Section 3.2.  They\n      \
    \                are therefore represented as octet strings as\n             \
    \         defined above and are L octets in length.\n                      Representation\
    \ of the unique element of order 2 in\n                      PF_p will not be\
    \ required.\n   Points on E        Elliptic curve points MUST be represented in\n\
    \                      uncompressed form as defined in Section 2.2 of\n      \
    \                [RFC5480].  For an elliptic curve point (x,y) with\n        \
    \              x and y in F_p, this representation is given by\n             \
    \         0x04 || x' || y', where x' is the octet string\n                   \
    \   representing x, y' is the octet string\n                      representing\
    \ y, and || denotes concatenation.  The\n                      representation\
    \ is 2*L+1 octets in length.\n   Encapsulated Data  The Encapsulated Data MUST\
    \ be represented as an\n                      elliptic curve point concatenated\
    \ with an integer\n                      in the range 0 to (2 ^ n) - 1.  Since\
    \ the length\n                      of the representation of elements of F_p is\
    \ well\n                      defined given p, these data can be unambiguously\n\
    \                      parsed to retrieve their components.  The\n           \
    \           Encapsulated Data is 2*L + n + 1 octets in length.\n"
- title: 5.  Supporting Algorithms
  contents:
  - '5.  Supporting Algorithms

    '
- title: 5.1.  Hashing to an Integer Range
  contents:
  - "5.1.  Hashing to an Integer Range\n   We use the function HashToIntegerRange(\
    \ s, n, hashfn ) to hash\n   strings to an integer range.  Given a string (s),\
    \ a hash function\n   (hashfn), and an integer (n), this function returns a value\
    \ between 0\n   and n - 1.\n   Input:\n      * an octet string, s\n      * an\
    \ integer, n <= (2^hashlen)^hashlen\n      * a hash function, hashfn, with output\
    \ length hashlen bits\n   Output:\n      * an integer, v, in the range 0 to n-1\n\
    \   Method:\n      1) Let A = hashfn( s )\n      2) Let h_0 = 00...00, a string\
    \ of null bits of length hashlen bits\n      3) Let l = Ceiling(lg(n)/hashlen)\n\
    \      4) For each i in 1 to l, do:\n         a) Let h_i = hashfn(h_(i - 1))\n\
    \         b) Let v_i = hashfn(h_i || A), where || denotes concatenation\n    \
    \  5) Let v' = v_1 || ...  || v_l\n      6) Let v = v' mod n\n"
- title: 6.  The SAKKE Cryptosystem
  contents:
  - "6.  The SAKKE Cryptosystem\n   This section describes the Sakai-Kasahara Key\
    \ Encryption algorithm.\n   It draws from the cryptosystem first described in\
    \ [S-K].\n"
- title: 6.1.  Setup
  contents:
  - "6.1.  Setup\n   All users share a set of public parameters with a KMS.  In most\n\
    \   circumstances, it is expected that a system will only use a single\n   KMS.\
    \  However, it is possible for users provisioned by different KMSs\n   to interoperate,\
    \ provided that they use a common set of public\n   parameters and that they each\
    \ possess the necessary KMS Public Keys.\n   In order to facilitate this interoperation,\
    \ it is anticipated that\n   parameters will be published in application-specific\
    \ standards.\n   KMS_T chooses its KMS Master Secret, z_T.  It MUST randomly select\
    \ a\n   value in the range 2 to q-1, and assigns this value to z_T.  It MUST\n\
    \   derive its KMS Public Key, Z_T, by performing the calculation Z_T =\n   [z_T]P.\n"
- title: 6.1.1.  Secret Key Extraction
  contents:
  - "6.1.1.  Secret Key Extraction\n   The KMS derives each RSK from an Identifier\
    \ and its KMS Master\n   Secret.  It MUST derive a RSK for each user that it provisions.\n\
    \   For Identifier 'a', the RSK K_(a,T) provided by KMS_T MUST be derived\n  \
    \ by KMS_T as K_(a,T) = [(a + z_T)^-1]P, where 'a' is interpreted as an\n   integer,\
    \ and the inversion is performed modulo q.\n"
- title: 6.1.2.  User Provisioning
  contents:
  - "6.1.2.  User Provisioning\n   The KMS MUST provide its KMS Public Key to all\
    \ users through an\n   authenticated channel.  RSKs MUST be supplied to all users\
    \ through a\n   channel that provides confidentiality and mutual authentication.\
    \  The\n   mechanisms that provide security for these channels are beyond the\n\
    \   scope of this document: they are application specific.\n   Upon receipt of\
    \ key material, each user MUST verify its RSK.  For\n   Identifier 'a', RSKs from\
    \ KMS_T are verified by checking that the\n   following equation holds: < [a]P\
    \ + Z, K_(a,T) > = g, where 'a' is\n   interpreted as an integer.\n"
- title: 6.2.  Key Exchange
  contents:
  - "6.2.  Key Exchange\n   A Sender forms Encapsulated Data and sends it to the Receiver,\
    \ who\n   processes it.  The result is a shared secret that can be used as\n \
    \  keying material for securing further communications.  We denote the\n   Sender\
    \ A with Identifier 'a'; we denote the Receiver B with\n   Identifier 'b'; Identifiers\
    \ are to be interpreted as integers in the\n   algorithms below.  Let A be provisioned\
    \ by KMS_T and B be provisioned\n   by KMS_S.\n"
- title: 6.2.1.  Sender
  contents:
  - "6.2.1.  Sender\n   In order to form Encapsulated Data to send to device B who\
    \ is\n   provisioned by KMS_S, A needs to hold Z_S.  It is anticipated that\n\
    \   this will have been provided to A by KMS_T along with its User\n   Private\
    \ Keys.  The Sender MUST carry out the following steps:\n      1) Select a random\
    \ ephemeral integer value for the SSV in the\n         range 0 to 2^n - 1;\n \
    \     2) Compute r = HashToIntegerRange( SSV || b, q, Hash );\n      3) Compute\
    \ R_(b,S) = [r]([b]P + Z_S) in E(F_p);\n      4) Compute the Hint, H;\n      \
    \   a) Compute g^r.  Note that g is an element of PF_p[q]\n            represented\
    \ by an element of F_p.  Thus, in order to\n            calculate g^r, the operation\
    \ defined in Section 2.1 for\n            calculation of A * B in PF_p[q] is to\
    \ be used as part of a\n            square and multiply (or similar) exponentiation\
    \ algorithm,\n            rather than the regular F_p operations;\n         b)\
    \ Compute H := SSV XOR HashToIntegerRange( g^r, 2^n, Hash );\n      5) Form the\
    \ Encapsulated Data ( R_(b,S), H ), and transmit it\n         to B;\n      6)\
    \ Output SSV for use to derive key material for the application\n         to be\
    \ keyed.\n"
- title: 6.2.2.  Receiver
  contents:
  - "6.2.2.  Receiver\n   Device B receives Encapsulated Data from device A.  In order\
    \ to\n   process this, it requires its RSK, K_(b,S), which will have been\n  \
    \ provisioned in advance by KMS_S.  The method by which keys are\n   provisioned\
    \ by the KMS is application specific.  The Receiver MUST\n   carry out the following\
    \ steps to derive and verify the SSV:\n      1) Parse the Encapsulated Data (\
    \ R_(b,S), H ), and extract R_(b,S)\n         and H;\n      2) Compute w := <\
    \ R_(b,S), K_(b,S) >.  Note that by bilinearity,\n         w = g^r;\n      3)\
    \ Compute SSV = H XOR HashToIntegerRange( w, 2^n, Hash );\n      4) Compute r\
    \ = HashToIntegerRange( SSV || b, q, Hash );\n      5) Compute TEST = [r]([b]P\
    \ + Z_S) in E(F_p).  If TEST does not\n         equal R_(b,S), then B MUST NOT\
    \ use the SSV to derive key\n         material;\n      6) Output SSV for use to\
    \ derive key material for the application\n         to be keyed.\n"
- title: 6.3.  Group Communications
  contents:
  - "6.3.  Group Communications\n   The SAKKE scheme can be used to exchange SSVs\
    \ for group\n   communications.  To provide a shared secret to multiple Receivers,\
    \ a\n   Sender MUST form Encapsulated Data for each of their Identifiers and\n\
    \   transmit the appropriate data to each Receiver.  Any party possessing\n  \
    \ the group SSV MAY extend the group by forming Encapsulated Data for a\n   new\
    \ group member.\n   While the Sender needs to form multiple Encapsulated Data,\
    \ the fact\n   that the sending operation avoids pairings means that the extension\n\
    \   to multiple Receivers can be carried out more efficiently than for\n   alternative\
    \ IBE schemes that require the Sender to compute a pairing.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This document describes the SAKKE cryptographic\
    \ algorithm.  We assume\n   that the security provided by this algorithm depends\
    \ entirely on the\n   secrecy of the secret keys it uses, and that for an adversary\
    \ to\n   defeat this security, he will need to perform computationally\n   intensive\
    \ cryptanalytic attacks to recover a secret key.  Note that a\n   security proof\
    \ exists for SAKKE in the Random Oracle Model [SK-KEM].\n   When defining public\
    \ parameters, guidance on parameter sizes from\n   [SP800-57] SHOULD be followed.\
    \  Note that the size of the F_p^2\n   discrete logarithm on which the security\
    \ rests is 2*lg(p).  Table 1\n   shows bits of security afforded by various sizes\
    \ of p.  If k bits of\n   security are needed, then lg(q) SHOULD be chosen to\
    \ be at least 2*k.\n   Similarly, if k bits of security are needed, then a hash\
    \ with output\n   size at least 2*k SHOULD be chosen.\n         Bits of Security\
    \ | lg(p)\n         -------------------------\n         80               |   512\n\
    \         112              |  1024\n         128              |  1536\n      \
    \   192              |  3840\n         256              |  7680\n      Table 1:\
    \ Comparable Strengths, Taken from Table 2 of [SP800-57]\n   The KMS Master Secret\
    \ provides the security for each device\n   provisioned by the KMS.  It MUST NOT\
    \ be revealed to any other entity.\n   Each user's RSK protects the SAKKE communications\
    \ it receives.  This\n   key MUST NOT be revealed to any entity other than the\
    \ trusted KMS and\n   the authorized user.\n   In order to ensure that the RSK\
    \ is received only by an authorized\n   device, it MUST be provided through a\
    \ secure channel.  The security\n   offered by this system is no greater than\
    \ the security provided by\n   this delivery channel.\n   Note that IBE systems\
    \ have different properties than other asymmetric\n   cryptographic schemes with\
    \ regard to key recovery.  The KMS (and\n   hence any administrator with appropriate\
    \ privileges) can create RSKs\n   for arbitrary Identifiers, and procedures to\
    \ monitor the creation of\n   RSKs, such as logging of administrator actions,\
    \ SHOULD be defined by\n   any functioning implementation of SAKKE.\n   Identifiers\
    \ MUST be defined unambiguously by each application of\n   SAKKE.  Note that it\
    \ is not necessary to hash the data in a format\n   for Identifiers (except in\
    \ the case where its size would be greater\n   than that of q).  In this way,\
    \ any weaknesses that might be caused by\n   collisions in hash functions can\
    \ be avoided without reliance on the\n   structure of the Identifier format. \
    \ Applications of SAKKE MAY\n   include a time/date component in their Identifier\
    \ format to ensure\n   that Identifiers (and hence RSKs) are only valid for a\
    \ fixed period\n   of time.\n   The randomness of values stipulated to be selected\
    \ at random in\n   SAKKE, as described in this document, is essential to the security\n\
    \   provided by SAKKE.  If the ephemeral value r selected by the Sender\n   is\
    \ not chosen at random, then the SSV, which is used to provide key\n   material\
    \ for further communications, could be predictable.  Guidance\n   on the generation\
    \ of random values for security can be found in\n   [RFC4086].\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC5480]   Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,\n\
    \               \"Elliptic Curve Cryptography Subject Public Key\n           \
    \    Information\", RFC 5480, March 2009.\n   [RFC6090]   McGrew, D., Igoe, K.,\
    \ and M. Salter, \"Fundamental\n               Elliptic Curve Cryptography Algorithms\"\
    , RFC 6090,\n               February 2011.\n   [S-K]       Sakai, R., Ohgishi,\
    \ K., and M. Kasahara, \"ID based\n               cryptosystem based on pairing\
    \ on elliptic curves\",\n               Symposium on Cryptography and Information\
    \ Security -\n               SCIS, 2001.\n   [SK-KEM]    Barbosa, M., Chen, L.,\
    \ Cheng, Z., Chimley, M., Dent, A.,\n               Farshim, P., Harrison, K.,\
    \ Malone-Lee, J., Smart, N., and\n               F. Vercauteren, \"SK-KEM: An\
    \ Identity-Based KEM\",\n               submission for IEEE P1363.3, June 2006,\n\
    \               (http://grouper.ieee.org/groups/1363/IBC/\n               submissions/Barbosa-SK-KEM-2006-06.pdf).\n\
    \   [SP800-57]  Barker, E., Barker, W., Burr, W., Polk, W., and M. Smid,\n   \
    \            \"Recommendation for Key Management - Part 1: General\n         \
    \      (Revised)\", NIST Special Publication 800-57, March 2007.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [Barreto]   Barreto, P., Kim, H., Lynn, B.,\
    \ and M. Scott, \"Efficient\n               Algorithms for Pairing-Based Cryptosystems\"\
    , Advances in\n               Cryptology - Crypto 2002, LNCS 2442, Springer-Verlag\n\
    \               (2002), pp. 354-369.\n   [Miller]    Miller, V., \"The Weil pairing,\
    \ and its efficient\n               calculation\", J. Cryptology 17 (2004), 235-261.\n\
    \   [P1363]     IEEE P1363-2000, \"Standard Specifications for Public-Key\n  \
    \             Cryptography\", 2001.\n   [RFC4086]   Eastlake 3rd, D., Schiller,\
    \ J., and S. Crocker,\n               \"Randomness Requirements for Security\"\
    , BCP 106,\n               RFC 4086, June 2005.\n   [RFC5091]   Boyen, X. and\
    \ L. Martin, \"Identity-Based Cryptography\n               Standard (IBCS) #1:\
    \ Supersingular Curve Implementations\n               of the BF and BB1 Cryptosystems\"\
    , RFC 5091,\n               December 2007.\n   [RFC6509]   Groves, M., \"MIKEY-SAKKE:\
    \ Sakai-Kasahara Key Encryption\n               in Multimedia Internet KEYing\
    \ (MIKEY)\", RFC 6509,\n               February 2012.\n"
- title: Appendix A.  Test Data
  contents:
  - "Appendix A.  Test Data\n   This appendix provides test data for SAKKE with the\
    \ public parameters\n   defined in Appendix A of [RFC6509].  'b' represents the\
    \ Identifier of\n   the Responder.  The value \"mask\" is the value used to mask\
    \ the SSV\n   and is defined to be\n   HashToIntegerRange( g^r, 2^n, Hash ).\n\
    \      // --------------------------------------------------------\n      // The\
    \ KMS generates:\n        z      = AFF429D3 5F84B110 D094803B 3595A6E2 998BC99F\n\
    \        Zx     = 5958EF1B 1679BF09 9B3A030D F255AA6A\n                 23C1D8F1\
    \ 43D4D23F 753E69BD 27A832F3\n                 8CB4AD53 DDEF4260 B0FE8BB4 5C4C1FF5\n\
    \                 10EFFE30 0367A37B 61F701D9 14AEF097\n                 24825FA0\
    \ 707D61A6 DFF4FBD7 273566CD\n                 DE352A0B 04B7C16A 78309BE6 40697DE7\n\
    \                 47613A5F C195E8B9 F328852A 579DB8F9\n                 9B1D0034\
    \ 479EA9C5 595F47C4 B2F54FF2\n        Zy     = 1508D375 14DCF7A8 E143A605 8C09A6BF\n\
    \                 2C9858CA 37C25806 5AE6BF75 32BC8B5B\n                 63383866\
    \ E0753C5A C0E72709 F8445F2E\n                 6178E065 857E0EDA 10F68206 B63505ED\n\
    \                 87E534FB 2831FF95 7FB7DC61 9DAE6130\n                 1EEACC2F\
    \ DA3680EA 4999258A 833CEA8F\n                 C67C6D19 487FB449 059F26CC 8AAB655A\n\
    \                 B58B7CC7 96E24E9A 39409575 4F5F8BAE\n      // --------------------------------------------------------\n\
    \      // Creating Encapsulated Data\n        b      = 3230 31312D30 32007465\
    \ 6C3A2B34\n                 34373730 30393030 31323300\n        SSV    = 12345678\
    \ 9ABCDEF0 12345678 9ABCDEF0\n        r      = HashToIntegerRange(\n         \
    \        12345678 9ABCDEF0 12345678 9ABCDEF0\n                 32303131 2D303200\
    \ 74656C3A 2B343437\n                 37303039 30303132 3300, q, SHA-256 )\n \
    \              = 13EE3E1B 8DAC5DB1 68B1CEB3 2F0566A4\n                 C273693F\
    \ 78BAFFA2 A2EE6A68 6E6BD90F\n                 8206CCAB 84E7F42E D39BD4FB 131012EC\n\
    \                 CA2ECD21 19414560 C17CAB46 B956A80F\n                 58A3302E\
    \ B3E2C9A2 28FBA7ED 34D8ACA2\n                 392DA1FF B0B17B23 20AE09AA EDFD0235\n\
    \                 F6FE0EB6 5337A63F 9CC97728 B8E5AD04\n                 60FADE14\
    \ 4369AA5B 21662132 47712096\n        Rbx    = 44E8AD44 AB8592A6 A5A3DDCA 5CF896C7\n\
    \                 18043606 A01D650D EF37A01F 37C228C3\n                 32FC3173\
    \ 54E2C274 D4DAF8AD 001054C7\n                 6CE57971 C6F4486D 57230432 61C506EB\n\
    \                 F5BE438F 53DE04F0 67C776E0 DD3B71A6\n                 29013328\
    \ 3725A532 F21AF145 126DC1D7\n                 77ECC27B E50835BD 28098B8A 73D9F801\n\
    \                 D893793A 41FF5C49 B87E79F2 BE4D56CE\n        Rby    = 557E134A\
    \ D85BB1D4 B9CE4F8B E4B08A12\n                 BABF55B1 D6F1D7A6 38019EA2 8E15AB1C\n\
    \                 9F76375F DD1210D4 F4351B9A 009486B7\n                 F3ED46C9\
    \ 65DED2D8 0DADE4F3 8C6721D5\n                 2C3AD103 A10EBD29 59248B4E F006836B\n\
    \                 F097448E 6107C9ED EE9FB704 823DF199\n                 F832C905\
    \ AE45F8A2 47A072D8 EF729EAB\n                 C5E27574 B07739B3 4BE74A53 2F747B86\n\
    \        g^r    = 7D2A8438 E6291C64 9B6579EB 3B79EAE9\n                 48B1DE9E\
    \ 5F7D1F40 70A08F8D B6B3C515\n                 6F2201AF FBB5CB9D 82AA3EC0 D0398B89\n\
    \                 ABC78A13 A760C0BF 3F77E63D 0DF3F1A3\n                 41A41B88\
    \ 11DF197F D6CD0F00 3125606F\n                 4F109F40 0F7292A1 0D255E3C 0EBCCB42\n\
    \                 53FB182C 68F09CF6 CD9C4A53 DA6C74AD\n                 007AF36B\
    \ 8BCA979D 5895E282 F483FCD6\n        mask   = HashToIntegerRange(\n         \
    \        7D2A8438 E6291C64 9B6579EB 3B79EAE9\n                 48B1DE9E 5F7D1F40\
    \ 70A08F8D B6B3C515\n                 6F2201AF FBB5CB9D 82AA3EC0 D0398B89\n  \
    \               ABC78A13 A760C0BF 3F77E63D 0DF3F1A3\n                 41A41B88\
    \ 11DF197F D6CD0F00 3125606F\n                 4F109F40 0F7292A1 0D255E3C 0EBCCB42\n\
    \                 53FB182C 68F09CF6 CD9C4A53 DA6C74AD\n                 007AF36B\
    \ 8BCA979D 5895E282 F483FCD6, 2^128, SHA-256 )\n               = 9BD4EA1E 801D37E6\
    \ 2AD2FAB0 D4F5BBF7\n        H      = 89E0BC66 1AA1E916 38E6ACC8 4E496507\n  \
    \    // --------------------------------------------------------\n      // Receiver\
    \ processing\n      // Device receives Kb from the KMS\n        Kbx    = 93AF67E5\
    \ 007BA6E6 A80DA793 DA300FA4\n                 B52D0A74 E25E6E7B 2B3D6EE9 D18A9B5C\n\
    \                 5023597B D82D8062 D3401956 3BA1D25C\n                 0DC56B7B\
    \ 979D74AA 50F29FBF 11CC2C93\n                 F5DFCA61 5E609279 F6175CEA DB00B58C\n\
    \                 6BEE1E7A 2A47C4F0 C456F052 59A6FA94\n                 A634A40D\
    \ AE1DF593 D4FECF68 8D5FC678\n                 BE7EFC6D F3D68353 25B83B2C 6E69036B\n\
    \        Kby    = 155F0A27 241094B0 4BFB0BDF AC6C670A\n                 65C325D3\
    \ 9A069F03 659D44CA 27D3BE8D\n                 F311172B 55416018 1CBE94A2 A783320C\n\
    \                 ED590BC4 2644702C F371271E 496BF20F\n                 588B78A1\
    \ BC01ECBB 6559934B DD2FB65D\n                 2884318A 33D1A42A DF5E33CC 5800280B\n\
    \                 28356497 F87135BA B9612A17 26042440\n                 9AC15FEE\
    \ 996B744C 33215123 5DECB0F5\n      // Device processes Encapsulated Data\n  \
    \      w      = 7D2A8438 E6291C64 9B6579EB 3B79EAE9\n                 48B1DE9E\
    \ 5F7D1F40 70A08F8D B6B3C515\n                 6F2201AF FBB5CB9D 82AA3EC0 D0398B89\n\
    \                 ABC78A13 A760C0BF 3F77E63D 0DF3F1A3\n                 41A41B88\
    \ 11DF197F D6CD0F00 3125606F\n                 4F109F40 0F7292A1 0D255E3C 0EBCCB42\n\
    \                 53FB182C 68F09CF6 CD9C4A53 DA6C74AD\n                 007AF36B\
    \ 8BCA979D 5895E282 F483FCD6\n        SSV    = 12345678 9ABCDEF0 12345678 9ABCDEF0\n\
    \        r      = 13EE3E1B 8DAC5DB1 68B1CEB3 2F0566A4\n                 C273693F\
    \ 78BAFFA2 A2EE6A68 6E6BD90F\n                 8206CCAB 84E7F42E D39BD4FB 131012EC\n\
    \                 CA2ECD21 19414560 C17CAB46 B956A80F\n                 58A3302E\
    \ B3E2C9A2 28FBA7ED 34D8ACA2\n                 392DA1FF B0B17B23 20AE09AA EDFD0235\n\
    \                 F6FE0EB6 5337A63F 9CC97728 B8E5AD04\n                 60FADE14\
    \ 4369AA5B 21662132 47712096\n        TESTx  = 44E8AD44 AB8592A6 A5A3DDCA 5CF896C7\n\
    \                 18043606 A01D650D EF37A01F 37C228C3\n                 32FC3173\
    \ 54E2C274 D4DAF8AD 001054C7\n                 6CE57971 C6F4486D 57230432 61C506EB\n\
    \                 F5BE438F 53DE04F0 67C776E0 DD3B71A6\n                 29013328\
    \ 3725A532 F21AF145 126DC1D7\n                 77ECC27B E50835BD 28098B8A 73D9F801\n\
    \                 D893793A 41FF5C49 B87E79F2 BE4D56CE\n        TESTy  = 557E134A\
    \ D85BB1D4 B9CE4F8B E4B08A12\n                 BABF55B1 D6F1D7A6 38019EA2 8E15AB1C\n\
    \                 9F76375F DD1210D4 F4351B9A 009486B7\n                 F3ED46C9\
    \ 65DED2D8 0DADE4F3 8C6721D5\n                 2C3AD103 A10EBD29 59248B4E F006836B\n\
    \                 F097448E 6107C9ED EE9FB704 823DF199\n                 F832C905\
    \ AE45F8A2 47A072D8 EF729EAB\n                 C5E27574 B07739B3 4BE74A53 2F747B86\n\
    \        TEST == Rb\n      // --------------------------------------------------------\n\
    \      // HashToIntegerRange( M, q, SHA-256 ) example\n        M      = 12345678\
    \ 9ABCDEF0 12345678 9ABCDEF0\n                 32303131 2D303200 74656C3A 2B343437\n\
    \                 37303039 30303132 3300\n        A      = E04D4EF6 9DF86893 22B39AE3\
    \ 80284617\n                 4A93BEDB 1E3D2A2C 5F2C7EA0 05513EBA\n        h0 \
    \    = 00000000 00000000 00000000 00000000\n                 00000000 00000000\
    \ 00000000 00000000\n        h1     = 66687AAD F862BD77 6C8FC18B 8E9F8E20\n  \
    \               08971485 6EE233B3 902A591D 0D5F2925\n        h2     = 2B32DB6C\
    \ 2C0A6235 FB1397E8 225EA85E\n                 0F0E6E8C 7B126D00 16CCBDE0 E667151E\n\
    \        h3     = 12771355 E46CD47C 71ED1721 FD5319B3\n                 83CCA3A1\
    \ F9FCE3AA 1C8CD3BD 37AF20D7\n        h4     = FE15C0D3 EBE314FA D720A08B 839A004C\n\
    \                 2E6386F5 AECC19EC 74807D19 20CB6AEB\n        v1     = FA2656CA\
    \ 1D2DBD79 015AE918 773DFEDC\n                 24957C91 E3C9C335 40D6BF6D 7C3C0055\n\
    \        v2     = F016CD67 59620AD7 87669E3A DD887DF6\n                 25895A91\
    \ 0CEE1486 91A06735 B2F0A248\n        v3     = AC45C6F9 7F83BCE0 A2BBD0A1 4CF4D7F4\n\
    \                 CB3590FB FAF93AE7 1C64E426 185710B5\n        v4     = E65D50BD\
    \ 551A54EF 981F535E 072DE98D\n                 2223ACAD 4621E026 3B0A61EA C56DB078\n\
    \       v mod q = 13EE3E1B 8DAC5DB1 68B1CEB3 2F0566A4\n                 C273693F\
    \ 78BAFFA2 A2EE6A68 6E6BD90F\n                 8206CCAB 84E7F42E D39BD4FB 131012EC\n\
    \                 CA2ECD21 19414560 C17CAB46 B956A80F\n                 58A3302E\
    \ B3E2C9A2 28FBA7ED 34D8ACA2\n                 392DA1FF B0B17B23 20AE09AA EDFD0235\n\
    \                 F6FE0EB6 5337A63F 9CC97728 B8E5AD04\n                 60FADE14\
    \ 4369AA5B 21662132 47712096\n      // --------------------------------------------------------\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Michael Groves\n   CESG\n   Hubble Road\n   Cheltenham\n\
    \   GL51 8HJ\n   UK\n   EMail: Michael.Groves@cesg.gsi.gov.uk\n"
