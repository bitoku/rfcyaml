- title: __initial_text__
  contents:
  - '             The RObust Header Compression (ROHC) Framework

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   The Robust Header Compression (ROHC) protocol provides an efficient,\n\
    \   flexible, and future-proof header compression concept.  It is\n   designed\
    \ to operate efficiently and robustly over various link\n   technologies with\
    \ different characteristics.\n   The ROHC framework, along with a set of compression\
    \ profiles, was\n   initially defined in RFC 3095.  To improve and simplify the\
    \ ROHC\n   specifications, this document explicitly defines the ROHC framework\n\
    \   and the profile for uncompressed separately.  More specifically, the\n   definition\
    \ of the framework does not modify or update the definition\n   of the framework\
    \ specified by RFC 3095.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................4\n  \
    \    2.1. Acronyms ...................................................4\n    \
    \  2.2. ROHC Terminology ...........................................4\n   3. Background\
    \ (Informative) ........................................7\n      3.1. Header Compression\
    \ Fundamentals ............................7\n      3.2. A Short History of Header\
    \ Compression ......................7\n   4. Overview of Robust Header Compression\
    \ (ROHC) (Informative) ......8\n      4.1. General Principles .........................................8\n\
    \      4.2. Compression Efficiency, Robustness, and Transparency ......10\n  \
    \    4.3. Developing the ROHC Protocol ..............................10\n    \
    \  4.4. Operational Characteristics of the ROHC Channel ...........11\n      4.5.\
    \ Compression and Master Sequence Number (MSN) ..............13\n      4.6. Static\
    \ and Dynamic Parts of a Context .....................13\n   5. The ROHC Framework\
    \ (Normative) .................................14\n      5.1. The ROHC Channel\
    \ ..........................................14\n           5.1.1. Contexts and\
    \ Context Identifiers ...................14\n           5.1.2. Per-Channel Parameters\
    \ .............................15\n           5.1.3. Persistence of Decompressor\
    \ Contexts ...............16\n      5.2. ROHC Packets and Packet Types .............................16\n\
    \           5.2.1. General Format of ROHC Packets .....................17\n  \
    \                5.2.1.1. Format of the Padding Octet ...............17\n    \
    \              5.2.1.2. Format of the Add-CID Octet ...............18\n      \
    \            5.2.1.3. General Format of Header ..................18\n        \
    \   5.2.2. Initialization and Refresh (IR) Packet Types .......19\n          \
    \        5.2.2.1. ROHC IR Packet Type .......................20\n            \
    \      5.2.2.2. ROHC IR-DYN Packet Type ...................20\n           5.2.3.\
    \ ROHC Initial Decompressor Processing ...............21\n           5.2.4. ROHC\
    \ Feedback ......................................22\n                  5.2.4.1.\
    \ ROHC Feedback Format ......................23\n           5.2.5. ROHC Segmentation\
    \ ..................................25\n                  5.2.5.1. Segmentation\
    \ Usage Considerations .........25\n                  5.2.5.2. Segmentation Protocol\
    \ .....................26\n      5.3. General Encoding Methods ..................................27\n\
    \           5.3.1. Header Compression CRCs, Coverage and Polynomials ..27\n  \
    \                5.3.1.1. 8-bit CRCs in IR and IR-DYN Headers .......27\n    \
    \              5.3.1.2. 3-bit CRC in Compressed Headers ...........27\n      \
    \            5.3.1.3. 7-bit CRC in Compressed Headers ...........28\n        \
    \          5.3.1.4. 32-bit Segmentation CRC ...................28\n          \
    \ 5.3.2. Self-Describing Variable-Length Values .............29\n      5.4. ROHC\
    \ UNCOMPRESSED -- No Compression  (Profile 0x0000) .....29\n           5.4.1.\
    \ IR Packet ..........................................30\n           5.4.2. Normal\
    \ Packet ......................................31\n           5.4.3. Decompressor\
    \ Operation .............................31\n           5.4.4. Feedback ...........................................32\n\
    \   6. Overview of a ROHC Profile (Informative) .......................32\n  \
    \ 7. Security Considerations ........................................33\n   8.\
    \ IANA Considerations ............................................34\n   9. Acknowledgments\
    \ ................................................35\n   10. References ....................................................35\n\
    \      10.1. Normative References .....................................35\n  \
    \    10.2. Informative References ...................................35\n   Appendix\
    \ A.  CRC Algorithm ........................................37\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   For many types of networks, reducing the deployment and\
    \ operational\n   costs by improving the usage of the bandwidth resources is of\
    \ vital\n   importance.  Header compression over a link is possible because some\n\
    \   of the information carried within the header of a packet becomes\n   compressible\
    \ between packets belonging to the same flow.\n   For links where the overhead\
    \ of the IP header(s) is problematic, the\n   total size of the header may be\
    \ significant.  Applications carrying\n   data carried within RTP [13] will then,\
    \ in addition to link-layer\n   framing, have an IPv4 [10] header (20 octets),\
    \ a UDP [12] header (8\n   octets), and an RTP header (12 octets), for a total\
    \ of 40 octets.\n   With IPv6 [11], the IPv6 header is 40 octets for a total of\
    \ 60\n   octets.  Applications transferring data using TCP [14] will have 20\n\
    \   octets for the transport header, for a total size of 40 octets for\n   IPv4\
    \ and 60 octets for IPv6.\n   The relative gain for specific flows (or applications)\
    \ depends on the\n   size of the payload used in each packet.  For applications\
    \ such as\n   Voice-over-IP, where the size of the payload containing coded speech\n\
    \   can be as small as 15-20 octets, this gain will be quite significant.\n  \
    \ Similarly, relative gains for TCP flows carrying large payloads (such\n   as\
    \ file transfers) will be less than for flows carrying smaller\n   payloads (such\
    \ as application signaling, e.g., session initiation).\n   As more and more wireless\
    \ link technologies are being deployed to\n   carry IP traffic, care must be taken\
    \ to address the specific\n   characteristics of these technologies within the\
    \ header compression\n   algorithms.  Legacy header compression schemes, such\
    \ as those defined\n   in [16] and [17], have been shown to perform inadequately\
    \ over links\n   where both the lossy behavior and the round-trip times are non-\n\
    \   negligible, such as those observed for example in wireless links and\n   IP\
    \ tunnels.\n   In addition, a header compression scheme should handle the often\n\
    \   non-trivial residual errors, i.e., where the lower layer may pass a\n   packet\
    \ that contains undetected bit errors to the decompressor.  It\n   should also\
    \ handle loss and reordering before the compression point,\n   as well as on the\
    \ link between the compression and decompression\n   points [7].\n   The Robust\
    \ Header Compression (ROHC) protocol provides an efficient,\n   flexible, and\
    \ future-proof header compression concept.  It is\n   designed to operate efficiently\
    \ and robustly over various link\n   technologies with different characteristics.\n\
    \   RFC 3095 [3] defines the ROHC framework along with an initial set of\n   compression\
    \ profiles.  To improve and simplify the specification, the\n   framework and\
    \ the profiles' parts have been split into separate\n   documents.  This document\
    \ explicitly defines the ROHC framework, but\n   it does not modify or update\
    \ the definition of the framework\n   specified by RFC 3095; both documents can\
    \ be used independently of\n   each other.  This also implies that implementations\
    \ based on either\n   definition will be compatible and interoperable with each\
    \ other.\n   However, it is the intent to let this specification replace RFC 3095\n\
    \   as the base specification for all profiles defined in the future.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [1].\n"
- title: 2.1.  Acronyms
  contents:
  - "2.1.  Acronyms\n   This section lists most acronyms used for reference.\n   \
    \   ACK    Acknowledgment.\n      CID    Context Identifier.\n      CO     Compressed\
    \ Packet Format.\n      CRC    Cyclic Redundancy Check.\n      IR     Initialization\
    \ and Refresh.\n      IR-DYN Initialization and Refresh, Dynamic part.\n     \
    \ LSB    Least Significant Bit(s).\n      MRRU   Maximum Reconstructed Reception\
    \ Unit.\n      MSB    Most Significant Bit(s).\n      MSN    Master Sequence Number.\n\
    \      NACK   Negative Acknowledgment.\n      ROHC   RObust Header Compression.\n"
- title: 2.2. ROHC Terminology
  contents:
  - "2.2. ROHC Terminology\n   Context\n      The context of the compressor is the\
    \ state it uses to compress a\n      header.  The context of the decompressor\
    \ is the state it uses to\n      decompress a header.  Either of these or the\
    \ two in combination\n      are usually referred to as \"context\", when it is\
    \ clear which is\n      intended.  The context contains relevant information from\
    \ previous\n      headers in the packet flow, such as static fields and possible\n\
    \      reference values for compression and decompression.  Moreover,\n      additional\
    \ information describing the packet flow is also part of\n      the context, for\
    \ example, information about the change behavior of\n      fields (e.g., the IP\
    \ Identifier behavior, or the typical inter-\n      packet increase in sequence\
    \ numbers and timestamps).\n   Context damage\n      When the context of the decompressor\
    \ is not consistent with the\n      context of the compressor, decompression may\
    \ fail to reproduce the\n      original header.  This situation can occur when\
    \ the context of the\n      decompressor has not been initialized properly or\
    \ when packets\n      have been lost or damaged between the compressor and decompressor.\n\
    \      Packets which cannot be decompressed due to inconsistent contexts\n   \
    \   are said to be lost due to context damage.  Packets that are\n      decompressed\
    \ but contain errors due to inconsistent contexts are\n      said to be damaged\
    \ due to context damage.\n   Context repair mechanism\n      Context repair mechanisms\
    \ are used to resynchronize the contexts,\n      an important task since context\
    \ damage causes loss propagation.\n      Examples of such mechanisms are NACK-based\
    \ mechanisms, and the\n      periodic refreshes of important context information,\
    \ usually done\n      in unidirectional operation.  There are also mechanisms\
    \ that can\n      reduce the context inconsistency probability, for example,\n\
    \      repetition of the same type of information in multiple packets and\n  \
    \    CRCs that protect context-updating information.\n   CRC-8 validation\n  \
    \    The CRC-8 validation refers to the validation of the integrity\n      against\
    \ bit error(s) in a received IR and IR-DYN header using the\n      8-bit CRC included\
    \ in the IR/IR-DYN header.\n   CRC verification\n      The CRC verification refers\
    \ to the verification of the result of a\n      decompression attempt using the\
    \ 3-bit CRC or 7-bit CRC included in\n      the header of a compressed packet\
    \ format.\n   Damage propagation\n      Delivery of incorrect decompressed headers\
    \ due to context damage,\n      that is, due to errors in (i.e., loss of or damage\
    \ to) previous\n      header(s) or feedback.\n   Error detection\n      Detection\
    \ of errors by lower layers.  If error detection is not\n      perfect, there\
    \ will be residual errors.\n   Error propagation\n      Damage propagation or\
    \ loss propagation.\n   ROHC profile\n      A ROHC profile is a compression protocol,\
    \ which specifies how to\n      compress specific header combinations.  A ROHC\
    \ profile may be\n      tailored to handle a specific set of link characteristics,\
    \ e.g.,\n      loss characteristics, reordering between compression points, etc.\n\
    \      ROHC profiles provide the details of the header compression\n      framework\
    \ defined in this document, and each compression profile\n      is associated\
    \ with a unique ROHC profile identifier [21].  When\n      setting up a ROHC channel,\
    \ the set of profiles supported by both\n      endpoints of the channel is negotiated,\
    \ and when initializing new\n      contexts, a profile identifier from this negotiated\
    \ set is used to\n      associate each compression context with one specific profile.\n\
    \   Link\n      A physical transmission path that constitutes a single IP hop.\n\
    \   Loss propagation\n      Loss of headers, due to errors in (i.e., loss of or\
    \ damage to)\n      previous header(s) or feedback.\n   Packet flow\n      A sequence\
    \ of packets where the field values and change patterns\n      of field values\
    \ are such that the headers can be compressed using\n      the same context.\n\
    \   Residual error\n      Errors introduced during transmission and not detected\
    \ by lower-\n      layer error detection schemes.\n   ROHC channel\n      A logical\
    \ unidirectional point-to-point channel carrying ROHC\n      packets from one\
    \ compressor to one decompressor, optionally\n      carrying ROHC feedback information\
    \ on the behalf of another\n      compressor-decompressor pair operating on a\
    \ separate ROHC channel\n      in the opposite direction.  See also [5].\n   This\
    \ document also makes use of the conceptual terminology defined by\n   \"ROHC\
    \ Terminology and Channel Mapping Examples\", RFC 3759 [5].\n"
- title: 3.  Background (Informative)
  contents:
  - "3.  Background (Informative)\n   This section provides a background to the subject\
    \ of header\n   compression.  The fundamental ideas are described together with\
    \ a\n   discussion about the history of header compression schemes.  The\n   motivations\
    \ driving the development of the various schemes are\n   discussed and their drawbacks\
    \ identified, thereby providing the\n   foundations for the design of the ROHC\
    \ framework and profiles [3].\n"
- title: 3.1.  Header Compression Fundamentals
  contents:
  - "3.1.  Header Compression Fundamentals\n   Header compression is possible because\
    \ there is significant\n   redundancy between header fields; within the headers\
    \ of a single\n   packet, but in particular between consecutive packets belonging\
    \ to\n   the same flow.  On the path end-to-end, the entire header information\n\
    \   is necessary for all packets in the flow, but over a single link,\n   some\
    \ of this information becomes redundant and can be reduced, as\n   long as it\
    \ is transparently recovered at the receiving end of the\n   link.  The header\
    \ size can be reduced by first sending field\n   information that is expected\
    \ to remain static for (at least most of)\n   the lifetime of the packet flow.\
    \  Further compression is achieved for\n   the fields carrying information that\
    \ changes more dynamically by\n   using compression methods tailored to their\
    \ respective assumed change\n   behavior.\n   To achieve compression and decompression,\
    \ some necessary information\n   from past packets is maintained in a context.\
    \  The compressor and the\n   decompressor update their respective contexts upon\
    \ certain, not\n   necessarily synchronized, events.  Impairment events may lead\
    \ to\n   inconsistencies in the decompressor context (i.e., context damage),\n\
    \   which in turn may cause incorrect decompression.  A Robust Header\n   Compression\
    \ scheme needs mechanisms to minimize the possibility of\n   context damage, in\
    \ combination with mechanisms for context repair.\n"
- title: 3.2.  A Short History of Header Compression
  contents:
  - "3.2.  A Short History of Header Compression\n   The first header compression\
    \ scheme, compressed TCP (CTCP) [15], was\n   introduced by Van Jacobson.  CTCP,\
    \ also often referred to as VJ\n   compression, compresses the 40 octets of the\
    \ TCP/IP header down to 4\n   octets.  CTCP uses delta encoding for sequentially\
    \ changing fields.\n   The CTCP compressor detects transport-level retransmissions\
    \ and sends\n   a header that updates the entire context when they occur.  This\n\
    \   repair mechanism does not require any explicit signaling between the\n   compressor\
    \ and decompressor.\n   A general IP header compression scheme, IP header compression\
    \ [16],\n   improves somewhat on CTCP.  IP Header Compression (IPHC) can compress\n\
    \   arbitrary IP, TCP, and UDP headers.  When compressing non-TCP\n   headers,\
    \ IPHC does not use delta encoding and is robust.  The repair\n   mechanism of\
    \ CTCP is augmented with negative acknowledgments, called\n   CONTEXT_STATE messages,\
    \ which speeds up the repair.  This context\n   repair mechanism is thus limited\
    \ by the round-trip time of the link.\n   IPHC does not compress RTP headers.\n\
    \   CRTP [17] is an RTP extension to IPHC.  CRTP compresses the 40 octets\n  \
    \ of IPv4/UDP/RTP headers to a minimum of 2 octets when the UDP\n   Checksum is\
    \ not enabled.  If the UDP Checksum is enabled, the minimum\n   CRTP header is\
    \ 4 octets.\n   On lossy links with long round-trip times, CRTP does not perform\
    \ well\n   [20].  Each packet lost over the link causes decompression of several\n\
    \   subsequent packets to fail, because the context becomes invalidated\n   during\
    \ at least one link round-trip time from the lost packet.\n   Unfortunately, the\
    \ large headers that CRTP sends when updating the\n   context waste additional\
    \ bandwidth.\n   CRTP uses a local repair mechanism known as TWICE, which was\n\
    \   introduced by IPHC.  TWICE derives its name from the observation that\n  \
    \ when the flow of compressed packets is regular, the correct guess\n   when one\
    \ packet is lost between the compression points is to apply\n   the update in\
    \ the current packet twice.  While TWICE improves CRTP\n   performance significantly,\
    \ [20] also found that even with TWICE, CRTP\n   doubled the number of lost packets.\n\
    \   An enhanced variant of CRTP, called eCRTP [19], means to improve the\n   robustness\
    \ of CRTP in the presence of reordering and packet losses,\n   while keeping the\
    \ protocol almost unchanged from CRTP.  As a result,\n   eCRTP does provide better\
    \ means to implement some degree of\n   robustness, albeit at the expense of additional\
    \ overhead, leading to\n   a reduction in compression efficiency in comparison\
    \ to CRTP.\n"
- title: 4.  Overview of Robust Header Compression (ROHC) (Informative)
  contents:
  - '4.  Overview of Robust Header Compression (ROHC) (Informative)

    '
- title: 4.1.  General Principles
  contents:
  - "4.1.  General Principles\n   As mentioned earlier, header compression is possible\
    \ per-link due to\n   the fact that there is much redundancy between header field\
    \ values\n   within packets, and especially between consecutive packets belonging\n\
    \   to the same flow.  To utilize these properties for header\n   compression,\
    \ there are a few essential steps to consider.\n   The first step consists of\
    \ identifying and grouping packets together\n   into different \"flows\", so that\
    \ packet-to-packet redundancy is\n   maximized in order to improve the compression\
    \ ratio.  Grouping\n   packets into flows is usually based on source and destination\
    \ host\n   (IP) addresses, transport protocol type (e.g., UDP or TCP), process\n\
    \   (port) numbers, and potentially additional unique application\n   identifiers,\
    \ such as the synchronization source (SSRC) in RTP [13].\n   The compressor and\
    \ decompressor each establish a context for the\n   packet flow and identify the\
    \ context with a Context Identifier (CID)\n   included in each compressed header.\n\
    \   The second step is to understand the change patterns of the various\n   header\
    \ fields.  On a high level, header fields fall into one of the\n   following classes:\n\
    \   INFERRED      These fields contain values that can be inferred from\n    \
    \             other fields or external sources, for example, the size\n      \
    \           of the frame carrying the packet can often be derived\n          \
    \       from the link layer protocol, and thus does not have to\n            \
    \     be transmitted by the compression scheme.\n   STATIC        Fields classified\
    \ as STATIC are assumed to be constant\n                 throughout the lifetime\
    \ of the packet flow.  The value\n                 of each field is thus only\
    \ communicated initially.\n   STATIC-DEF    Fields classified as STATIC-DEF are\
    \ used to define a\n                 packet flow as discussed above.  Packets\
    \ for which\n                 respective values of these fields differ are treated\
    \ as\n                 belonging to different flows.  These fields are in\n  \
    \               general compressed as STATIC fields.\n   STATIC-KNOWN  Fields\
    \ classified as STATIC-KNOWN are expected to have\n                 well-known\
    \ values, and therefore their values do not\n                 need to be communicated.\n\
    \   CHANGING      These fields are expected to vary randomly, either\n       \
    \          within a limited value set or range, or in some other\n           \
    \      manner.  CHANGING fields are usually handled in more\n                \
    \ sophisticated ways based on a more detailed\n                 classification\
    \ of their expected change patterns.\n   Finally, the last step is to choose the\
    \ encoding method(s) that will\n   be applied onto different fields based on classification.\
    \  The\n   encoding methods, in combination with the identified field behavior,\n\
    \   provide the input to the design of the compressed header formats.\n   The\
    \ analysis of the probability distribution of the identified change\n   patterns\
    \ then provides the means to optimize the packet formats,\n   where the most frequently\
    \ occurring change patterns for a field\n   should be encoded within the most\
    \ efficient format(s).\n   However, compression efficiency has to be traded against\
    \ two other\n   properties: the robustness of the encoding to losses and errors\n\
    \   between the compressor and the decompressor, and the ability to\n   detect\
    \ and cope with errors in the decompression process.\n"
- title: 4.2.  Compression Efficiency, Robustness, and Transparency
  contents:
  - "4.2.  Compression Efficiency, Robustness, and Transparency\n   The performance\
    \ of a header compression protocol can be described\n   with three parameters:\
    \ its compression efficiency, its robustness,\n   and its compression transparency.\n\
    \   Compression efficiency\n      The compression efficiency is determined by\
    \ how much the average\n      header size is reduced by applying the compression\
    \ protocol.\n   Robustness\n      A robust protocol tolerates packet losses, residual\
    \ bit errors,\n      and out-of-order delivery on the link over which header\n\
    \      compression takes place, without losing additional packets or\n      introducing\
    \ additional errors in decompressed headers.\n   Compression transparency\n  \
    \    The compression transparency is a measure of the extent to which\n      the\
    \ scheme maintains the semantics of the original headers.  If\n      all decompressed\
    \ headers are bitwise identical to the\n      corresponding original headers,\
    \ the scheme is transparent.\n"
- title: 4.3.  Developing the ROHC Protocol
  contents:
  - "4.3.  Developing the ROHC Protocol\n   The challenge in developing a header compression\
    \ protocol is to\n   conciliate compression efficiency and robustness while maintaining\n\
    \   transparency, as increasing robustness will always come at the\n   expense\
    \ of a lower compression efficiency, and vice-versa.  The\n   scheme should also\
    \ be flexible enough in its design to minimize the\n   impacts from the varying\
    \ round-trip times and loss patterns of links\n   where header compression will\
    \ be used.\n   To achieve this, the header compression scheme must provide\n \
    \  facilities for the decompressor to verify decompression and detect\n   potential\
    \ context damage, as well as context recovery mechanisms such\n   as feedback.\
    \  Header compression schemes prior to the ones developed\n   by the Robust Header\
    \ Compression (ROHC) WG were not designed with the\n   above high-level objectives\
    \ in mind.\n   The ROHC WG has developed header compression solutions to meet\
    \ the\n   needs of present and future link technologies.  While special\n   attention\
    \ has been put towards meeting the more stringent\n   requirements stemming from\
    \ the characteristics of wireless links, the\n   results are equally applicable\
    \ to many other link technologies.\n   RFC 3095 [3], \"RObust Header Compression\
    \ (ROHC): Framework and four\n   profiles: RTP, UDP, ESP, and uncompressed\",\
    \ was published in 2001, as\n   the first output of the ROHC WG.  ROHC is a general\
    \ and extendable\n   framework for header compression, on top of which profiles\
    \ can be\n   defined for compression of different protocols headers.  RFC 3095\n\
    \   introduced a number of new compression techniques, and was successful\n  \
    \ at living up to the requirements placed on it, as described in [18].\n   Interoperability\
    \ testing of RFC 3095 confirms the capabilities of\n   ROHC to meet its purposes,\
    \ but feedback from implementers has also\n   indicated that the protocol specification\
    \ is complex and sometimes\n   obscure.  Most importantly, a clear distinction\
    \ between framework and\n   profiles is not obvious in [3], which also makes development\
    \ of\n   additional profiles troublesome.  This document therefore aims at\n \
    \  explicitly specifying the ROHC framework, while a companion document\n   [8]\
    \ specifies revised versions of the compression profiles of RFC\n   3095.\n"
- title: 4.4.  Operational Characteristics of the ROHC Channel
  contents:
  - "4.4.  Operational Characteristics of the ROHC Channel\n   Robust header compression\
    \ can be used over many type of link\n   technologies.  The ROHC framework provides\
    \ flexibility for profiles\n   to address a wide range of applications, and this\
    \ section lists some\n   of the operational characteristics of the ROHC channel\
    \ (see also\n   [5]).\n   Multiplexing over a single logical channel\n      The\
    \ ROHC channel provides a mechanism to identify a context within\n      the general\
    \ ROHC packet format.  The CID makes it possible for a\n      logical channel\
    \ that supports ROHC to transport multiple header-\n      compressed flows, while\
    \ still making it possible for a channel to\n      be dedicated to one single\
    \ packet flow without any CID overhead.\n      More specifically, ROHC uses a\
    \ distinct context identifier space\n      per logical channel, and the context\
    \ identifier can be omitted for\n      one of the flows over the ROHC channel\
    \ when configured to use a\n      small CID space.\n   Establishment of channel\
    \ parameters\n      A link layer defining support for the ROHC channel must provide\n\
    \      the means to establish header compression channel parameters (see\n   \
    \   Section 5.1).  This can be achieved through a negotiation\n      mechanism,\
    \ static provisioning, or some out-of-band signaling.\n   Packet type identification\n\
    \      The ROHC channel defines a packet type identifier space, and puts\n   \
    \   restrictions with respect to the use of a number of identifiers\n      that\
    \ are common for all ROHC profiles.  Identifiers that have no\n      restrictions,\
    \ i.e., identifiers that are not defined by this\n      document, are available\
    \ to each profile.  The identifier is part\n      of each compressed header, and\
    \ this makes it possible for the link\n      that supports the ROHC channel to\
    \ allocate one single link layer\n      payload type for ROHC.\n   Out-of-order\
    \ delivery between compression endpoints\n      Each profile defines its own level\
    \ of robustness, including\n      tolerance to reordering of packets before but\
    \ especially between\n      compression endpoints, if any.\n      For profiles\
    \ specified in [3], the channel between the compressor\n      and decompressor\
    \ is required to maintain in-order delivery of the\n      packets, i.e., the definition\
    \ of these profiles assumes that the\n      decompressor always receives packets\
    \ in the same order as the\n      compressor sent them.  The impacts of reordering\
    \ on the\n      performance of these profiles is described in [7].  However,\n\
    \      reordering before the compression point is handled, i.e., these\n     \
    \ profiles make no assumption that the compressor will receive\n      packets\
    \ in-order.\n      For the ROHCv2 profiles specified in [8], their definitions\
    \ assume\n      that the decompressor can receive packets out-of-order, i.e.,\
    \ not\n      in the same order that the compressor sent them.  Reordering\n  \
    \    before the compression point is also dealt with.\n   Duplication of packets\n\
    \      The link supporting the ROHC channel is required to not duplicate\n   \
    \   packets (however, duplication of packets can occur before they\n      reach\
    \ the compressor, i.e., there is no assumption that the\n      compressor will\
    \ receive only one copy of each packet).\n   Framing\n      The link layer must\
    \ provide framing that makes it possible to\n      distinguish frame boundaries\
    \ and individual frames.\n   Error detection/protection\n      ROHC profiles should\
    \ be designed to cope with residual errors in\n      the headers delivered to\
    \ the decompressor.  CRCs are used to\n      detect decompression failures and\
    \ to prevent or reduce damage\n      propagation.  However, it is recommended\
    \ that lower layers deploy\n      error detection for ROHC headers and that ROHC\
    \ headers with high\n      residual error rates not be delivered.\n"
- title: 4.5.  Compression and Master Sequence Number (MSN)
  contents:
  - "4.5.  Compression and Master Sequence Number (MSN)\n   Compression of header\
    \ fields is based on the establishment of a\n   function to a sequence number,\
    \ called the master sequence number\n   (MSN).  This function describes the change\
    \ pattern of the field with\n   respect to a change in the MSN.\n   Change patterns\
    \ include, for example, fields that increase\n   monotonically or by a small value,\
    \ fields that seldom change,and\n   fields that remain unchanging for the entire\
    \ lifetime of the packet\n   flow, in which case the function to the MSN is equivalent\
    \ to a\n   constant value.\n   The compressor first establishes functions for\
    \ each of the header\n   fields, and then reliably communicates the MSN.  When\
    \ the change\n   pattern of the field does not match the established function,\
    \ i.e.,\n   the existing function gives a result that is different from the field\n\
    \   in the header being compressed, additional information can be sent to\n  \
    \ update the parameters of that function.\n   The MSN is defined per profile.\
    \  It can be either derived directly\n   from one of the fields of the protocol\
    \ being compressed (e.g., the\n   RTP SN [8]), or it can be created and maintained\
    \ by the compressor\n   (e.g., the MSN for compression of UDP in profile 0x0102\
    \ [8] or the\n   MSN in ROHC-TCP [9]).\n"
- title: 4.6.  Static and Dynamic Parts of a Context
  contents:
  - "4.6.  Static and Dynamic Parts of a Context\n   A compression context can be\
    \ conceptually divided into two different\n   parts, the static context and the\
    \ dynamic context, each based on the\n   properties of the fields that are being\
    \ compressed.\n   The static part includes the information necessary to compress\
    \ and\n   decompress the fields whose change behavior is classified as STATIC,\n\
    \   STATIC-KNOWN, or STATIC-DEF (as described in Section 4.1 above).\n   The dynamic\
    \ part includes the state maintained for all the other\n   fields, i.e., those\
    \ that are classified as CHANGING.\n"
- title: 5.  The ROHC Framework (Normative)
  contents:
  - "5.  The ROHC Framework (Normative)\n   This section normatively defines the parts\
    \ common to all ROHC\n   profiles, i.e., the framework.  The framework specifies\
    \ the\n   requirements and functionality of the ROHC channel, including how to\n\
    \   handle multiple compressed packet flows over the same channel.\n   Finally,\
    \ this section specifies encoding methods used in the packet\n   formats that\
    \ are common to all profiles.  These encoding methods may\n   be reused within\
    \ profile specifications for encoding fields in\n   profile-specific parts of\
    \ a packet format, without requiring their\n   redefinition.\n"
- title: 5.1.  The ROHC Channel
  contents:
  - '5.1.  The ROHC Channel

    '
- title: 5.1.1.  Contexts and Context Identifiers
  contents:
  - "5.1.1.  Contexts and Context Identifiers\n   Associated with each compressed\
    \ flow is a context.  The context is\n   the state that the compressor and the\
    \ decompressor maintain in order\n   to correctly compress or decompress the headers\
    \ of the packet in the\n   flow.  Each context is identified using a CID.\n  \
    \ A context is considered to be a new context when the CID is\n   associated with\
    \ a profile for the first time since the creation of\n   the ROHC channel, or\
    \ when the CID gets associated from the reception\n   of an IR (this does not\
    \ apply to the IR-DYN) with a different profile\n   than the profile in the context.\n\
    \   Context information is conceptually kept in a table.  The context\n   table\
    \ is indexed using the CID, which is sent along with compressed\n   headers and\
    \ feedback information.\n   The CID space can be either small, which means that\
    \ CIDs can take the\n   values 0 through 15, or large, which means that CIDs take\
    \ values\n   between 0 and 2^14 - 1 = 16383.  Whether the CID space is large or\n\
    \   small MUST be established, possibly by negotiation, before any\n   compressed\
    \ packet may be sent over the ROHC channel.\n   The CID space is distinct for\
    \ each channel, i.e., CID 3 over channel\n   A and CID 3 over channel B do not\
    \ refer to the same context, even if\n   the endpoints of A and B are the same\
    \ nodes.  In particular, CIDs for\n   any pair of ROHC channels are not related\
    \ (two associated ROHC\n   channels serving as feedback channels for one another\
    \ do not even\n   need to have CID spaces of the same size).\n"
- title: 5.1.2.  Per-Channel Parameters
  contents:
  - "5.1.2.  Per-Channel Parameters\n   The ROHC channel is based on a number of parameters\
    \ that form part of\n   the established channel state and the per-context state.\
    \  The state\n   of the ROHC channel MUST be established before the first ROHC\
    \ packet\n   may be sent, which may be achieved using negotiation protocols\n\
    \   provided by the link layer (see also [4], which describes an option\n   for\
    \ negotiation of ROHC parameters for PPP).  This section describes\n   some of\
    \ this channel state information in an abstract way:\n   LARGE_CIDS: Boolean;\
    \ if false, the small CID representation (0 octets\n      or 1 prefix octet, covering\
    \ CID 0 to 15) is used; if true, the\n      large CID representation (1 or 2 embedded\
    \ CID octets covering CID\n      0 to 16383) is used.  See also 5.1.1 and 5.2.1.3.\n\
    \   MAX_CID: Non-negative integer; highest CID number to be used by the\n    \
    \  compressor (note that this parameter is not coupled to, but in\n      effect\
    \ further constrained by, LARGE_CIDS).  This value represents\n      an agreement\
    \ by the decompressor that it can provide sufficient\n      memory resources to\
    \ host at least MAX_CID+1 contexts; the\n      decompressor MUST maintain established\
    \ contexts within this space\n      until either the CID gets re-used by the establishment\
    \ of a new\n      context, or until the channel is taken down.\n   PROFILES: Set\
    \ of non-negative integers, where each integer indicates\n      a profile supported\
    \ by both the compressor and the decompressor.\n      A profile is identified\
    \ by a 16-bit value, where the 8 LSB bits\n      indicate the actual profile,\
    \ and the 8 MSB bits indicate the\n      variant of that profile.  The ROHC compressed\
    \ header format\n      identifies the profile used with only the 8 LSB bits; this\
    \ means\n      that if multiple variants of the same profile are available for\
    \ a\n      ROHC channel, the PROFILES set after negotiation MUST NOT include\n\
    \      more than one variant of the same profile.  The compressor MUST\n     \
    \ NOT compress using a profile that is not in PROFILES.\n   FEEDBACK_FOR: Optional\
    \ reference to a ROHC channel in the opposite\n      direction between the same\
    \ compression endpoints.  If provided,\n      this parameter indicates to which\
    \ other ROHC channel any feedback\n      sent on this ROHC channel refers (see\
    \ [5]).\n   MRRU: Non-negative integer.  Maximum Reconstructed Reception Unit.\n\
    \      This is the size of the largest reconstructed unit in octets that\n   \
    \   the decompressor is expected to reassemble from segments (see\n      Section\
    \ 5.2.5).  This size includes the segmentation CRC.  If MRRU\n      is negotiated\
    \ to be 0, segmentation MUST NOT be used on the\n      channel, and received segments\
    \ MUST be discarded by the\n      decompressor.\n"
- title: 5.1.3.  Persistence of Decompressor Contexts
  contents:
  - "5.1.3.  Persistence of Decompressor Contexts\n   As part of the negotiated channel\
    \ parameters, the compressor and\n   decompressor have through the MAX_CID parameter\
    \ agreed on the highest\n   context identification (CID) number to be used.  By\
    \ agreeing on the\n   MAX_CID, the decompressor also agrees to provide memory\
    \ resources to\n   host at least MAX_CID+1 contexts, and an established context\
    \ with a\n   CID within this negotiated space SHOULD be kept by the decompressor\n\
    \   until either the CID gets re-used, or the channel is taken down or\n   re-negotiated.\n"
- title: 5.2.  ROHC Packets and Packet Types
  contents:
  - "5.2.  ROHC Packets and Packet Types\n   This section uses the following convention\
    \ in the diagrams when\n   representing various ROHC packet types, formats, and\
    \ fields:\n      - colons \":\" indicate that the part is optional\n      - slashes\
    \ \"/\" indicate variable length\n   The ROHC packet type indication scheme has\
    \ been designed to provide\n   optional padding, a feedback packet type, an optional\
    \ Add-CID octet\n   (which includes 4 bits of CID), and a simple segmentation\
    \ and\n   reassembly mechanism.\n   The following packet types are reserved at\
    \ the ROHC framework level:\n      11100000 : Padding\n      1110nnnn : Add-CID\
    \ octet (nnnn=CID with values 0x1 through 0xF)\n      11110    : Feedback\n  \
    \    11111000 : IR-DYN packet\n      1111110  : IR packet\n      1111111  : Segment\n\
    \   Other packet types can be defined and used by individual profiles:\n     \
    \ 0        : available (not reserved by ROHC framework)\n      10       : available\
    \ (not reserved by ROHC framework)\n      110      : available (not reserved by\
    \ ROHC framework)\n      1111101  : available (not reserved by ROHC framework)\n\
    \      11111001 : available (not reserved by ROHC framework)\n"
- title: 5.2.1.  General Format of ROHC Packets
  contents:
  - "5.2.1.  General Format of ROHC Packets\n   A ROHC packet has the following general\
    \ format:\n    --- --- --- --- --- --- --- ---\n   :           Padding       \
    \      :\n    --- --- --- --- --- --- --- ---\n   :           Feedback       \
    \     :\n    --- --- --- --- --- --- --- ---\n   :            Header         \
    \    :\n    --- --- --- --- --- --- --- ---\n   :           Payload          \
    \   :\n    --- --- --- --- --- --- --- ---\n   Padding: Any number (zero or more)\
    \ of padding octets, where the\n      format of a padding octet is as defined\
    \ in Section 5.2.1.1.\n   Feedback: Any number (zero or more) of feedback elements,\
    \ where the\n      format of a feedback element is as defined in Section 5.2.4.1.\n\
    \   Header: Either a profile-specific CO header (see Section 5.2.1.3), an\n  \
    \    IR or IR-DYN header (see Section 5.2.2), or a ROHC Segment (see\n      Section\
    \ 5.2.5).  There can be at most one Header in a ROHC packet,\n      but it may\
    \ also be omitted (if the packet contains Feedback only).\n   Payload: Corresponds\
    \ to zero or more octets of payload from the\n      uncompressed packet, starting\
    \ with the first octet in the\n      uncompressed packet after the last header\
    \ compressible by the\n      current profile.\n   At least one of Feedback or\
    \ Header MUST be present.\n"
- title: 5.2.1.1.  Format of the Padding Octet
  contents:
  - "5.2.1.1.  Format of the Padding Octet\n   Padding octet:\n     0   1   2   3\
    \   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   1   1   0  \
    \ 0   0   0   0 |\n   +---+---+---+---+---+---+---+---+\n   Note: The Padding\
    \ octet MUST NOT be interpreted as an Add-CID octet\n   for CID 0.\n"
- title: 5.2.1.2.  Format of the Add-CID Octet
  contents:
  - "5.2.1.2.  Format of the Add-CID Octet\n   Add-CID octet:\n     0   1   2   3\
    \   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   1   1   0 |\
    \      CID      |\n   +---+---+---+---+---+---+---+---+\n   CID: 0x1 through 0xF\
    \ indicates CIDs 1 through 15.\n   Note: The Padding octet looks like an Add-CID\
    \ octet for CID 0.\n"
- title: 5.2.1.3.  General Format of Header
  contents:
  - "5.2.1.3.  General Format of Header\n   All ROHC packet types have the following\
    \ general Header format:\n     0              x-1  x       7\n    --- --- ---\
    \ --- --- --- --- ---\n   :         Add-CID octet         :  if CID 1-15 and small\
    \ CIDs\n   +--- --- --- --- ---+--- --- ---+\n   | type indication   |   body\
    \    |  1 octet (8-x bits of body)\n   +--- --- --- --- ---+--- --- ---+\n   :\
    \                               :\n   /    0, 1, or 2 octets of CID   /  1 or\
    \ 2 octets if large CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   /             body              /  variable length\n   +---+---+---+---+---+---+---+---+\n\
    \   type indication: ROHC packet type.\n   body: Interpreted according to the\
    \ packet type indication and CID\n      information, as defined by individual\
    \ profiles.\n   Thus, the header either starts with a packet type indication or\
    \ has a\n   packet type indication immediately following an Add-CID octet.\n \
    \  When the ROHC channel is configured with a small CID space:\n      o  If an\
    \ Add-CID immediately precedes the packet type indication,\n         the packet\
    \ has the CID of the Add-CID; otherwise, it has CID 0.\n      o  A small CID with\
    \ the value 0 is represented using zero bits;\n         therefore, a flow associated\
    \ with CID 0 has no CID overhead in\n         the compressed header.  In such\
    \ case, Header starts with a\n         packet type indication.\n      o  A small\
    \ CID with a value from 1 to 15 is represented using the\n         Add-CID octet\
    \ as described above.  The Header starts with the\n         Add-CID octet, followed\
    \ by a packet type indication.\n      o  There is no large CID in the Header.\n\
    \   When the ROHC channel is configured with a large CID space:\n      o  The\
    \ large CID is always present and is represented using the\n         encoding\
    \ scheme of Section 5.3.2, limited to two octets.  In\n         this case, the\
    \ Header starts with a packet type indication.\n"
- title: 5.2.2.  Initialization and Refresh (IR) Packet Types
  contents:
  - "5.2.2.  Initialization and Refresh (IR) Packet Types\n   IR packet types contain\
    \ a profile identifier, which determines how\n   the rest of the header is to\
    \ be interpreted.  They also associate a\n   profile with a context.  The stored\
    \ profile parameter further\n   determines the syntax and semantics of the packet\
    \ type identifiers\n   and packet types used with a specific context.\n   The\
    \ IR and IR-DYN packets always update the context for all context-\n   updating\
    \ fields carried in the header.  They never clear the context,\n   except when\
    \ initializing a new context (see Section 5.1.1), or unless\n   the profile indicated\
    \ in the Profile field specifies otherwise.\n"
- title: 5.2.2.1.  ROHC IR Packet Type
  contents:
  - "5.2.2.1.  ROHC IR Packet Type\n   The IR header associates a CID with a profile,\
    \ and typically also\n   initializes the context.  It can typically also refresh\
    \ all (or parts\n   of) the context.  For IR, Header has the following general\
    \ format:\n     0   1   2   3   4   5   6   7\n    --- --- --- --- --- --- ---\
    \ ---\n   :         Add-CID octet         :  if CID 1-15 and small CID\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   1   1   0 | x |  IR type octet\n   +---+---+---+---+---+---+---+---+\n\
    \   :                               :\n   /      0-2 octets of CID        /  1\
    \ or 2 octets if large CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   |            Profile            |  1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |              CRC              |  1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   / profile specific information  /  variable\
    \ length\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \   x: Profile specific information.  Interpreted according to the\n      profile\
    \ indicated in the Profile field of the IR header.\n   Profile: The profile associated\
    \ with the CID.  In the IR header, the\n      profile identifier is abbreviated\
    \ to the 8 least significant bits\n      (see Section 5.1.2).\n   CRC: 8-bit CRC\
    \ (see Section 5.3.1.1).\n   Profile specific information: The content of this\
    \ part of the IR\n      header is defined by the individual profiles.  It is interpreted\n\
    \      according to the profile indicated in the Profile field.\n"
- title: 5.2.2.2.  ROHC IR-DYN Packet Type
  contents:
  - "5.2.2.2.  ROHC IR-DYN Packet Type\n   In contrast to the IR header, the IR-DYN\
    \ header can never initialize\n   a non-initialized context.  However, it can\
    \ redefine what profile is\n   associated with a context, if the profile indicated\
    \ in the IR-DYN\n   header allows this.  Thus, this packet type is also reserved\
    \ at the\n   framework level.  The IR-DYN header typically also initializes or\n\
    \   refreshes parts of a context.  For IR-DYN, Header has the following\n   general\
    \ format:\n     0   1   2   3   4   5   6   7\n    --- --- --- --- --- --- ---\
    \ ---\n   :         Add-CID octet         :  if CID 1-15 and small CID\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   1   0   0   0 |  IR-DYN type octet\n   +---+---+---+---+---+---+---+---+\n\
    \   :                               :\n   /      0-2 octets of CID        /  1\
    \ or 2 octets if large CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   |            Profile            |  1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |              CRC              |  1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   / profile specific information  /  variable\
    \ length\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \   Profile: The profile associated with the CID.  This is abbreviated in\n  \
    \    the same way as in IR packets.\n   CRC: 8-bit CRC (see Section 5.3.1.1).\n\
    \   Profile specific information: The content of this part of the IR-DYN\n   \
    \   header is defined by the individual profiles.  It is interpreted\n      according\
    \ to the profile indicated in the Profile field.\n"
- title: 5.2.3.  ROHC Initial Decompressor Processing
  contents:
  - "5.2.3.  ROHC Initial Decompressor Processing\n   Initially, all contexts are\
    \ in no context state.  Thus, all packets\n   referencing a non-initialized context,\
    \ except packets that have\n   enough information on the static fields, cannot\
    \ be decompressed by\n   the decompressor.\n   When the decompressor receives\
    \ a packet of type IR, the profile\n   indicated in the IR packet determines how\
    \ it is to be processed.\n      o  If the 8-bit CRC fails to verify the integrity\
    \ of the Header,\n         the packet MUST NOT be decompressed and delivered to\
    \ upper\n         layers.  If a profile is indicated in the context, the logic\
    \ of\n         that profile determines what, if any, feedback is to be sent.\n\
    \         If no profile is noted in the context, the logic used to\n         determine\
    \ what, if any, feedback to send is up to the\n         implementation.  However,\
    \ it may be suitable to take no further\n         actions, as any part of the\
    \ IR header covered by the CRC may\n         have caused the failure.\n   When\
    \ the decompressor receives a packet of type IR-DYN, the profile\n   indicated\
    \ in the IR-DYN packet determines how it is to be processed.\n      o  If the\
    \ 8-bit CRC fails to verify the integrity of the header,\n         the packet\
    \ MUST NOT be decompressed and delivered to upper\n         layers.  If a profile\
    \ is indicated in the context, the logic of\n         that profile determines\
    \ what, if any, feedback is to be sent.\n         If no profile is noted in the\
    \ context, the logic used to\n         determine what, if any, feedback to send\
    \ is up to the\n         implementation.  However, it may be suitable to take\
    \ no further\n         actions, as any part of the IR-DYN header covered by the\
    \ CRC\n         may have caused the failure.\n      o  If the context has not\
    \ already been initialized, the packet\n         MUST NOT be decompressed and\
    \ delivered to upper layers.  The\n         logic of the profile indicated in\
    \ the IR-DYN header (if\n         verified by the 8-bit CRC), determines what,\
    \ if any, feedback\n         is to be sent.\n   If a parsing error occurs for\
    \ any packet type, the decompressor MUST\n   discard the packet without further\
    \ processing.  For example, a CID\n   field is present in the compressed header\
    \ when the large CID space is\n   used for the ROHC channel, and the field is\
    \ coded using the self-\n   describing variable-length encoding of Section 5.3.2;\
    \ if the field\n   starts with 110 or 111, this would generate a parsing error\
    \ for the\n   decompressor because this field must not be encoded with a size\n\
    \   larger than 2 octets.\n   It is RECOMMENDED that profiles disallow the decompressor\
    \ to make a\n   decompression attempt for packets carrying only a 3-bit CRC after\
    \ it\n   has invalidated some or all of the entire dynamic context, until a\n\
    \   packet that contains sufficient information on the dynamic fields is\n   received,\
    \ decompressed, and successfully verified by a 7- or 8-bit\n   CRC.\n"
- title: 5.2.4.  ROHC Feedback
  contents:
  - "5.2.4.  ROHC Feedback\n   Feedback carries information from the decompressor\
    \ to compressor.\n   Feedback can be sent over a ROHC channel that operates in\
    \ the same\n   direction as the feedback.\n   The general ROHC packet format allows\
    \ transport of feedback using\n   interspersion or piggybacking (see [5]), or\
    \ a combination of both,\n   over a ROHC channel.  This is facilitated by the\
    \ following\n   properties:\n   Reserved packet type:\n      A feedback packet\
    \ type is reserved at the framework level.  The\n      packet type can carry variable-length\
    \ feedback information.\n   CID information:\n      The feedback information sent\
    \ on a particular channel is passed\n      to, and interpreted by, the compressor\
    \ associated with feedback on\n      that channel.  Thus, each feedback element\
    \ contains CID\n      information from the channel for which the feedback is sent.\
    \  The\n      ROHC feedback scheme thus requires that a channel carries feedback\n\
    \      to at most one compressor.  How a compressor is associated with\n     \
    \ the feedback for a particular channel is outside the scope of this\n      specification.\
    \  See also [5].\n   Length information:\n      The length of a feedback element\
    \ can be determined by examining\n      the first few octets of the feedback.\
    \  This enables piggybacking\n      of feedback, and also the concatenation of\
    \ more than one feedback\n      element in a packet.  The length information thus\
    \ decouples the\n      decompressor from the associated same-side compressor,\
    \ as the\n      decompressor can extract the feedback information from the\n \
    \     compressed header without parsing its content and hand over the\n      extracted\
    \ information.\n   The association between compressor-decompressor pairs operating\
    \ in\n   opposite directions, for the purpose of exchanging piggyback and/or\n\
    \   interspersed feedback, SHOULD be maintained for the lifetime of the\n   ROHC\
    \ channel.  Otherwise, it is RECOMMENDED that the compressor be\n   notified if\
    \ the feedback channel is no longer available: the\n   compressor SHOULD then\
    \ restart compression by creating a new context\n   for each packet flow, and\
    \ SHOULD use a CID value that was not\n   previously associated with the profile\
    \ used to compress the flow.\n"
- title: 5.2.4.1.  ROHC Feedback Format
  contents:
  - "5.2.4.1.  ROHC Feedback Format\n   ROHC defines three different categories of\
    \ feedback messages:\n   acknowledgment (ACK), negative ACK (NACK), and NACK for\
    \ the entire\n   context (STATIC-NACK).  Other types of information may be defined\
    \ in\n   profile-specific feedback information.\n   ACK         : Acknowledges\
    \ successful decompression of a packet.\n                 Indicates that the decompressor\
    \ considers its context\n                 to be valid.\n   NACK        : Indicates\
    \ that the decompressor considers some or all\n                 of the dynamic\
    \ part of its context invalid.\n   STATIC-NACK : Indicates that the decompressor\
    \ considers its entire\n                 static context invalid, or that it has\
    \ not been\n                 established.\n   Feedback sent on a ROHC channel\
    \ consists of one or more concatenated\n   feedback elements, where each feedback\
    \ element has the following\n   format:\n     0   1   2   3   4   5   6   7\n\
    \   +---+---+---+---+---+---+---+---+\n   | 1   1   1   1   0 |   Code    |  feedback\
    \ type\n   +---+---+---+---+---+---+---+---+\n   :             Size          \
    \    :  if Code = 0\n   +---+---+---+---+---+---+---+---+\n   :         Add-CID\
    \ octet         :  if for small CIDs and (CID != 0)\n   +---+---+---+---+---+---+---+---+\n\
    \   :                               :\n   /  large CID (5.3.2 encoding)   /  1-2\
    \ octets if for large CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   /         FEEDBACK data         /  variable length\n   +---+---+---+---+---+---+---+---+\n\
    \   Code: 0 indicates that a Size octet is present.\n         1-7 indicates the\
    \ size of the feedback data field, in octets.\n   Size: Indicates the size of\
    \ the feedback data field, in octets.\n   FEEDBACK data: FEEDBACK-1 or FEEDBACK-2\
    \ (see below).\n   CID information in a feedback element indicates the context\
    \ for which\n   feedback is sent.  The LARGE_CIDS parameter that controls whether\
    \ a\n   large CID is present is taken from the channel state of the receiving\n\
    \   compressor's channel, not from the state of the channel carrying the\n   feedback.\n\
    \   The large CID field, if present, is encoded according to Section\n   5.3.2,\
    \ and it MUST NOT be encoded using more than 2 octets.\n   The FEEDBACK data field\
    \ can have either of the following two formats:\n   FEEDBACK-1:\n     0   1  \
    \ 2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | profile specific\
    \ information  |  1 octet\n   +---+---+---+---+---+---+---+---+\n   FEEDBACK-2:\n\
    \     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n  \
    \ |Acktype|                       |\n   +---+---+   profile specific    /  at\
    \ least 2 octets\n   /             information       |\n   +---+---+---+---+---+---+---+---+\n\
    \   Acktype:  0 = ACK\n             1 = NACK\n             2 = STATIC-NACK\n \
    \            3 is reserved (MUST NOT be used.  Otherwise unparseable.)\n"
- title: 5.2.5.  ROHC Segmentation
  contents:
  - "5.2.5.  ROHC Segmentation\n   ROHC defines a simple segmentation protocol.  The\
    \ compressor may\n   perform segmentation, e.g., to accommodate packets that are\
    \ larger\n   than a specific size configured for the channel.\n"
- title: 5.2.5.1.  Segmentation Usage Considerations
  contents:
  - "5.2.5.1.  Segmentation Usage Considerations\n   The ROHC segmentation protocol\
    \ is not particularly efficient.  It is\n   not intended to replace link layer\
    \ segmentation functions; these\n   SHOULD be used whenever available and efficient\
    \ for the task at hand.\n   The ROHC segmentation protocol has been designed with\
    \ an assumption\n   of in-order delivery of packets between the compressor and\
    \ the\n   decompressor, using only a CRC for error detection, and no sequence\n\
    \   numbers.  If in-order delivery cannot be guaranteed, ROHC\n   segmentation\
    \ MUST NOT be used.\n   The segmentation protocol also assumes that all segments\
    \ of a ROHC\n   packet corresponding to one context are received without interference\n\
    \   from other ROHC packets over the channel, including any ROHC packet\n   corresponding\
    \ to a different context.  Based on this assumption,\n   segments do not carry\
    \ CID information, and therefore cannot be\n   associated with a specific context\
    \ until all segments have been\n   received and the whole unit has been reconstructed.\n"
- title: 5.2.5.2.  Segmentation Protocol
  contents:
  - "5.2.5.2.  Segmentation Protocol\n   ROHC segmentation is applied to the combination\
    \ of the Header and the\n   Payload fields of the ROHC packet, as defined in Section\
    \ 5.2.1.\n   Segment format:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   1   1   1 | F |  segment type\n   +---+---+---+---+---+---+---+---+\n\
    \   /           Segment             /  variable length\n   +---+---+---+---+---+---+---+---+\n\
    \   F: Final bit.  If set, it indicates that this is the last segment of\n   \
    \   a reconstructed unit.\n   Padding and/or Feedback may precede the segment\
    \ type octet.  There is\n   no per-segment CID, but CID information is of course\
    \ part of the\n   reconstructed unit.  The reconstructed unit MUST NOT contain\
    \ padding,\n   segments, or feedback.\n   When a final segment is received, the\
    \ decompressor reassembles the\n   segment carried in this packet and any non-final\
    \ segments that\n   immediately preceded it into a single reconstructed unit,\
    \ in the\n   order they were received.  All segments for one reconstructed unit\n\
    \   have to be received consecutively and in the correct order by the\n   decompressor.\
    \  If a non-segment ROHC packet directly follows a non-\n   final segment, the\
    \ reassembly of the current reconstructed unit is\n   aborted and the decompressor\
    \ MUST discard the non-final segments so\n   far received on this channel.\n \
    \  Reconstructed unit:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   /            Header             /  (see Section 5.2.1)\n   +---+---+---+---+---+---+---+---+\n\
    \   :            Payload            :  (see Section 5.2.1)\n   +---+---+---+---+---+---+---+---+\n\
    \   /              CRC              /  4 octets\n   +---+---+---+---+---+---+---+---+\n\
    \   CRC: 32-bit CRC computed using the polynomial of Section 5.3.1.4.\n   If the\
    \ reconstructed unit is 4 octets or less, or if the CRC fails,\n   or if it is\
    \ larger than the channel parameter MRRU (see Section\n   5.1.2), the reconstructed\
    \ unit MUST be discarded by the decompressor.\n   If the CRC succeeds, the reconstructed\
    \ unit can be further processed.\n"
- title: 5.3.  General Encoding Methods
  contents:
  - '5.3.  General Encoding Methods

    '
- title: 5.3.1.  Header Compression CRCs, Coverage and Polynomials
  contents:
  - "5.3.1.  Header Compression CRCs, Coverage and Polynomials\n   This section describes\
    \ how to calculate the CRCs used by ROHC.  For\n   all CRCs, the algorithm used\
    \ to calculate the CRC is the same as the\n   one used in [2], defined in Appendix\
    \ A of this document, with the\n   polynomials specified in subsequent sections.\n"
- title: 5.3.1.1.  8-bit CRCs in IR and IR-DYN Headers
  contents:
  - "5.3.1.1.  8-bit CRCs in IR and IR-DYN Headers\n   The coverage for the 8-bit\
    \ CRC in the IR and IR-DYN headers is\n   profile-dependent, but it MUST cover\
    \ at least the initial part of the\n   header ending with the Profile field, including\
    \ the CID or an Add-CID\n   octet.  Feedback and padding are not part of Header\
    \ (Section 5.2.1)\n   and are thus not included in the CRC calculation.  As a\
    \ rule of thumb\n   for profile specifications, any other information that initializes\n\
    \   the decompressor context SHOULD also be covered by a CRC.\n   More specifically,\
    \ the 8-bit CRC does not cover only and entirely the\n   original uncompressed\
    \ header; therefore, it does not provide the\n   means for the decompressor to\
    \ verify a decompression attempt, or the\n   means to verify the correctness of\
    \ the entire decompressor context.\n   However, when successful, it does provide\
    \ enough robustness for the\n   decompressor to update its context with the information\
    \ carried\n   within the IR or the IR-DYN header.\n   The CRC polynomial for the\
    \ 8-bit CRC is:\n      C(x) = 1 + x + x^2 + x^8\n   When computing the CRC, the\
    \ CRC field in the header is set to zero,\n   and the initial content of the CRC\
    \ register is set to all 1's.\n"
- title: 5.3.1.2.  3-bit CRC in Compressed Headers
  contents:
  - "5.3.1.2.  3-bit CRC in Compressed Headers\n   The 3-bit CRC in compressed headers\
    \ is calculated over all octets of\n   the entire original header, before compression,\
    \ in the following\n   manner.\n   The initial content of the CRC register is\
    \ set to all 1's.\n   The polynomial for the 3-bit CRC is:\n      C(x) = 1 + x\
    \ + x^3\n   The purpose of the 3-bit CRC is to provide the means for the\n   decompressor\
    \ to verify the outcome of a decompression attempt for\n   small compressed headers,\
    \ and to detect context damage based on\n   aggregated probability over a number\
    \ of decompression attempts.  It\n   is however too weak to provide enough success\
    \ guarantees from the\n   decompression of one single header.  Therefore, compressed\
    \ headers\n   carrying a 3-bit CRC are normally not suitable to perform context\n\
    \   repairs at the decompressor; hence, profiles should refrain from\n   allowing\
    \ decompression of such a header when some or the entire\n   decompressor context\
    \ is assumed invalid.\n"
- title: 5.3.1.3.  7-bit CRC in Compressed Headers
  contents:
  - "5.3.1.3.  7-bit CRC in Compressed Headers\n   The 7-bit CRC in compressed headers\
    \ is calculated over all octets of\n   the entire original header, before compression,\
    \ in the following\n   manner.\n   The initial content of the CRC register is\
    \ set to all 1's.\n   The polynomial for the 7-bit CRC is:\n      C(x) = 1 + x\
    \ + x^2 + x^3 + x^6 + x^7\n   The purpose of the 7-bit CRC is to provide the means\
    \ for the\n   decompressor to verify the outcome of a decompression attempt for\
    \ a\n   larger compressed header, and to provide enough protection to\n   validate\
    \ a context repair at the decompressor.  The 7-bit CRC is\n   strong enough to\
    \ assume a repair to be successful from the\n   decompression of one single header;\
    \ hence, profiles may allow\n   decompression of a header carrying a 7-bit CRC\
    \ when some of the\n   decompressor context is assumed invalid.\n"
- title: 5.3.1.4.  32-bit Segmentation CRC
  contents:
  - "5.3.1.4.  32-bit Segmentation CRC\n   The 32-bit CRC is used by the segmentation\
    \ scheme to verify the\n   reconstructed unit, and it is thus calculated over\
    \ the segmented\n   unit, i.e., over the Header and the Payload fields of the\
    \ ROHC\n   packet.\n   The initial content of the CRC register is set to all 1's.\n\
    \   The polynomial for the 32-bit CRC is:\n      C(x) = x^0 + x^1 + x^2 + x^4\
    \ + x^5 + x^7 + x^8 + x^10 +\n             x^11 + x^12 + x^16 + x^22 + x^23 +\
    \ x^26 + x^32.\n   The purpose of the 32-bit CRC is to verify the reconstructed\
    \ unit.\n"
- title: 5.3.2.  Self-Describing Variable-Length Values
  contents:
  - "5.3.2.  Self-Describing Variable-Length Values\n   The values of many fields\
    \ and compression parameters can vary widely.\n   To optimize the transfer of\
    \ such values, a variable number of octets\n   are used to encode them.  The first\
    \ few bits of the first octet\n   determine the number of octets used:\n   First\
    \ bit is 0: 1 octet.\n            7 bits transferred.\n            Up to 127 decimal.\n\
    \            Encoded octets in hexadecimal: 00 to 7F\n   First bits are 10: 2\
    \ octets.\n            14 bits transferred.\n            Up to 16 383 decimal.\n\
    \            Encoded octets in hexadecimal: 80 00 to BF FF\n   First bits are\
    \ 110: 3 octets.\n            21 bits transferred.\n            Up to 2 097 151\
    \ decimal.\n            Encoded octets in hexadecimal: C0 00 00 to DF FF FF\n\
    \   First bits are 111: 4 octets.\n            29 bits transferred.\n        \
    \    Up to 536 870 911 decimal.\n            Encoded octets in hexadecimal: E0\
    \ 00 00 00 to FF FF FF FF\n"
- title: 5.4.  ROHC UNCOMPRESSED -- No Compression  (Profile 0x0000)
  contents:
  - "5.4.  ROHC UNCOMPRESSED -- No Compression  (Profile 0x0000)\n   This section\
    \ describes the uncompressed ROHC profile.  The profile\n   identifier for this\
    \ profile is 0x0000.\n   Profile 0x0000 provides a way to send IP packets without\
    \ compressing\n   them.  This can be used for any packet for which a compression\n\
    \   profile is not available in the set of profiles supported by the ROHC\n  \
    \ channel, or for which compression is not desirable for some reason.\n   After\
    \ initialization, the only overhead for sending packets using\n   Profile 0x0000\
    \ is the size of the CID.  When uncompressed packets are\n   frequent, Profile\
    \ 0x0000 should be associated with a CID the size of\n   zero or one octet.  Profile\
    \ 0x0000 SHOULD be associated with at most\n   one CID.\n"
- title: 5.4.1.  IR Packet
  contents:
  - "5.4.1.  IR Packet\n   The initialization and refresh packet (IR packet) for Profile\
    \ 0x0000\n   has the following Header format:\n     0   1   2   3   4   5   6\
    \   7\n    --- --- --- --- --- --- --- ---\n   :         Add-CID octet       \
    \  : if for small CIDs and (CID != 0)\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   1   1   0 |res|\n   +---+---+---+---+---+---+---+---+\n\
    \   :                               :\n   /    0-2 octets of CID info     / 1-2\
    \ octets if for large CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   |         Profile = 0x00        | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |              CRC              | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   res: MUST be set to zero; otherwise, the decompressor MUST discard\n     \
    \   the packet.\n   Profile: 0x00\n   CRC: 8-bit CRC, computed using the polynomial\
    \ of Section 5.3.1.1.\n        The CRC covers the first octet of the IR Header\
    \ through the\n        Profile octet of the IR Header, i.e., it does not cover\
    \ the CRC\n        itself.  Neither does it cover any preceding Padding or\n \
    \       Feedback, nor the Payload.\n   For the IR packet, Payload has the following\
    \ format:\n    --- --- --- --- --- --- --- ---\n   :                         \
    \      : (optional)\n   /           IP packet           / variable length\n  \
    \ :                               :\n    --- --- --- --- --- --- --- ---\n   IP\
    \ packet: An uncompressed IP packet may be included in the IR\n      packet. \
    \ The decompressor determines if the IP packet is present\n      by considering\
    \ the length of the IR packet.\n"
- title: 5.4.2.  Normal Packet
  contents:
  - "5.4.2.  Normal Packet\n   A Normal packet is a normal IP packet plus CID information.\
    \  For the\n   Normal Packet, the following format corresponds to the Header and\n\
    \   Payload (as defined in Section 5.2.1):\n     0   1   2   3   4   5   6   7\n\
    \    --- --- --- --- --- --- --- ---\n   :         Add-CID octet         : if\
    \ for small CIDs and (CID != 0)\n   +---+---+---+---+---+---+---+---+\n   |  \
    \ first octet of IP packet    |\n   +---+---+---+---+---+---+---+---+\n   :  \
    \                             :\n   /    0-2 octets of CID info     / 1-2 octets\
    \ if for large CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   /       rest of IP packet       / variable\
    \ length\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \   Note that the first octet of the IP packet starts with the bit\n   pattern\
    \ 0100 (IPv4) or 0110 (IPv6).  This does not conflict with any\n   reserved packet\
    \ types.\n   When the channel uses small CIDs, and profile 0x0000 is associated\n\
    \   with a CID > 0, an Add-CID octet precedes the IP packet.  When the\n   channel\
    \ uses large CIDs, the CID is placed so that it starts at the\n   second octet\
    \ of the combined Header/Payload format above.\n   A Normal Packet may carry Padding\
    \ and/or Feedback as any other ROHC\n   packet, preceding the combined Header/Payload.\n"
- title: 5.4.3.  Decompressor Operation
  contents:
  - "5.4.3.  Decompressor Operation\n   When an IR packet is received, the decompressor\
    \ first validates its\n   header using the 8-bit CRC.\n   o  If the header fails\
    \ validation, the decompressor MUST NOT deliver\n      the IP packet to upper\
    \ layers.\n   o  If the header is successfully validated, the decompressor\n \
    \        1) initializes the context if it has no valid context for the\n     \
    \       given CID already associated to the specified profile,\n         2) delivers\
    \ the IP packet to upper layers if present,\n         3) MAY send an ACK.\n  \
    \ When any other packet is received while the decompressor has no\n   context,\
    \ it is discarded without further action.\n   When a Normal packet is received\
    \ and the decompressor has a valid\n   context, the IP packet is extracted and\
    \ delivered to upper layers.\n"
- title: 5.4.4.  Feedback
  contents:
  - "5.4.4.  Feedback\n   The only kind of feedback defined by Profile 0x0000 is ACK,\
    \ using the\n   FEEDBACK-1 format of Section 5.2.4.1, where the value of the profile-\n\
    \   specific octet in the FEEDBACK-1 is 0 (zero).  The FEEDBACK-2 format\n   is\
    \ thus not defined for Profile 0x0000.\n"
- title: 6.  Overview of a ROHC Profile (Informative)
  contents:
  - "6.  Overview of a ROHC Profile (Informative)\n   The ROHC protocol consists of\
    \ a framework part and a profile part.\n   The framework defines the mechanisms\
    \ common to all profiles, while\n   the profile defines the compression algorithm\
    \ and profile specific\n   packet formats.\n   Section 5 specifies the details\
    \ of the ROHC framework.  This section\n   provides an informative overview of\
    \ the elements that make a profile\n   specification.  The normative specification\
    \ of individual profiles is\n   outside the scope of this document.\n   A ROHC\
    \ profile defines the elements that build up the compression\n   protocol.  A\
    \ ROHC profile consists of:\n   Packet formats:\n   o  Bits-on-the-wire\n    \
    \  The profile defines the layout of the bits for profile-specific\n      packet\
    \ types that it defines, and for the profile-specific parts\n      of packet types\
    \ common to all profiles (e.g., IR and IR-DYN).\n   o  Field encodings\n     \
    \ Bits and groups of bits from the packet format layout, referred to\n      as\
    \ Compressed fields, represents the result of an encoding method\n      specific\
    \ for that compressed field within a specific packet\n      format.  The profile\
    \ defines these encoding methods.\n   o  Updating properties\n      The profile-specific\
    \ packet formats may update the state of the\n      decompressor, and may do so\
    \ in different ways.  The profile\n      defines how individual profile-specific\
    \ fields, or entire\n      profile-specific packet types, update the decompressor\
    \ context.\n   o  Verification\n      Packets that update the state of the decompressor\
    \ are verified to\n      prevent incorrect updates to the decompressor context.\
    \  The\n      profile defines the mechanisms used to verify the decompression\
    \ of\n      a packet.\n   Context management:\n   o  Robustness logic\n      Packets\
    \ may be lost or reordered between the compressor and the\n      decompressor.\
    \  The profile defines mechanism to minimize the\n      impacts of such events\
    \ and prevent damage propagation.\n   o  Repair mechanism\n      Despite the robustness\
    \ logic, impairment events may still lead to\n      decompression failure(s),\
    \ and even to context damage at the\n      decompressor.  The profile defines\
    \ context repair mechanisms,\n      including feedback logic if used.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Because encryption eliminates the redundancy\
    \ that header compression\n   schemes try to exploit, there is some inducement\
    \ to forego encryption\n   of headers in order to enable operation over low-bandwidth\
    \ links.\n   A malfunctioning or malicious header compressor could cause the\n\
    \   header decompressor to reconstitute packets that do not match the\n   original\
    \ packets but still have valid headers and possibly also valid\n   transport checksums.\
    \  Such corruption may be detected with end-to-end\n   authentication and integrity\
    \ mechanisms, which will not be affected\n   by the compression.  Moreover, the\
    \ ROHC header compression scheme\n   uses an internal checksum for verification\
    \ of reconstructed headers,\n   which reduces the probability of producing decompressed\
    \ headers not\n   matching the original ones without this being noticed.\n   Denial-of-service\
    \ attacks are possible if an intruder can introduce,\n   for example, bogus IR,\
    \ IR-DYN, or FEEDBACK packets onto the link and\n   thereby cause compression\
    \ efficiency to be reduced.  However, an\n   intruder having the ability to inject\
    \ arbitrary packets at the link\n   layer in this manner raises additional security\
    \ issues that dwarf\n   those related to the use of header compression.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   An IANA registry for \"RObust Header Compression\
    \ (ROHC) Profile\n   Identifiers\" [21] was created by RFC 3095 [3].  The assignment\n\
    \   policy, as outlined by RFC 3095, is the following:\n   The ROHC profile identifier\
    \ is a non-negative integer.  In many\n   negotiation protocols, it will be represented\
    \ as a 16-bit value.  Due\n   to the way the profile identifier is abbreviated\
    \ in ROHC packets, the\n   8 least significant bits of the profile identifier\
    \ have a special\n   significance: Two profile identifiers with identical 8 LSBs\
    \ should be\n   assigned only if the higher-numbered one is intended to supersede\
    \ the\n   lower-numbered one.  To highlight this relationship, profile\n   identifiers\
    \ should be given in hexadecimal (as in 0x1234, which would\n   for example supersede\
    \ 0x0A34).\n   Following the policies outlined in [22], the IANA policy for\n\
    \   assigning new values for the profile identifier shall be\n   Specification\
    \ Required: values and their meanings must be documented\n   in an RFC or in some\
    \ other permanent and readily available reference,\n   in sufficient detail that\
    \ interoperability between independent\n   implementations is possible.  In the\
    \ 8 LSBs, the range 0 to 127 is\n   reserved for IETF standard-track specifications;\
    \ the range 128 to 254\n   is available for other specifications that meet this\
    \ requirement\n   (such as Informational RFCs).  The LSB value 255 is reserved\
    \ for\n   future extensibility of the present specification.\n   The following\
    \ profile identifiers have so far been allocated:\n   Profile Identifier    Usage\
    \                      Reference\n   ------------------    ----------------------\
    \     ---------\n   0x0000                ROHC uncompressed          RFC 4995\n\
    \   0x0001                ROHC RTP                   RFC 3095\n   0x0002     \
    \           ROHC UDP                   RFC 3095\n   0x0003                ROHC\
    \ ESP                   RFC 3095\n   0x0004                ROHC IP           \
    \         RFC 3843\n   0x0005                ROHC LLA                   RFC 3242\n\
    \   0x0105                ROHC LLA with R-mode       RFC 3408\n   0x0006     \
    \           ROHC TCP                   RFC 4996\n   0x0007                ROHC\
    \ RTP/UDP-Lite          RFC 4019\n   0x0008                ROHC UDP-Lite     \
    \         RFC 4019\n   New profiles will need new identifiers to be assigned by\
    \ the IANA,\n   but this document does not require any additional IANA action.\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   The authors would like to acknowledge all who have contributed\
    \ to\n   previous ROHC work, and especially to the authors of RFC 3095 [3],\n\
    \   which is the technical basis for this document.  Thanks also to the\n   various\
    \ individuals who contributed to the RFC 3095 corrections and\n   clarifications\
    \ document [6], from which technical contents, when\n   applicable, have been\
    \ incorporated into this document.  Committed WG\n   document reviewers were Carl\
    \ Knutsson and Biplab Sarkar, who reviewed\n   the document during working group\
    \ last-call.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [2]  Simpson, W., \"PPP in HDLC-like Framing\"\
    , STD 51, RFC 1662, July\n        1994.\n   [3]  Bormann, C., Burmeister, C.,\
    \ Degermark, M., Fukushima, H.,\n        Hannu, H., Jonsson, L-E., Hakenberg,\
    \ R., Koren, T., Le, K., Liu,\n        Z., Martensson, A., Miyazaki, A., Svanbro,\
    \ K., Wiebke, T.,\n        Yoshimura, T., and H. Zheng, \"RObust Header Compression\
    \ (ROHC):\n        Framework and four profiles: RTP, UDP, ESP, and uncompressed\"\
    ,\n        RFC 3095, July 2001.\n   [4]  Bormann, C., \"Robust Header Compression\
    \ (ROHC) over PPP\", RFC\n        3241, April 2002.\n   [5]  Jonsson, L-E., \"\
    RObust Header Compression (ROHC): Terminology\n        and Channel Mapping Examples\"\
    , RFC 3759, April 2004.\n   [6]  Jonsson, L-E., Sandlund, K., Pelletier, G., and\
    \ P. Kremer,\n        \"RObust Header Compression (ROHC): Corrections and\n  \
    \      Clarifications to RFC 3095\", RFC 4815, February 2007.\n   [7]  Pelletier,\
    \ G., Jonsson, L-E., and K. Sandlund, \"RObust Header\n        Compression (ROHC):\
    \ ROHC over Channels That Can Reorder\n        Packets\", RFC 4224, January 2006.\n\
    \   [8]  Pelletier, G. and K. Sandlund, \"RObust Header Compression\n        Version\
    \ 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP, and UDP\n        Lite\", Work in\
    \ Progress, September 2006.\n   [9]  Pelletier, G., Sandlund, K., Jonsson, L-E.,\
    \ and M. West, \"RObust\n        Header Compression (ROHC): A Profile for TCP/IP\
    \ (ROHC-TCP)\", RFC\n        4996, July 2007.\n   [10] Postel, J., \"Internet\
    \ Protocol\", STD 5, RFC 791, September 1981.\n   [11] Deering, S. and R. Hinden,\
    \ \"Internet Protocol, Version 6 (IPv6)\n        Specification\", RFC 2460, December\
    \ 1998.\n   [12] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August\n\
    \        1980.\n   [13] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson,\n\
    \        \"RTP: A Transport Protocol for Real-Time Applications\", STD 64,\n \
    \       RFC 3550, July 2003.\n   [14] Postel, J., \"Transmission Control Protocol\"\
    , STD 7, RFC 793,\n        September 1981.\n   [15] Jacobson, V., \"Compressing\
    \ TCP/IP headers for low-speed serial\n        links\", RFC 1144, February 1990.\n\
    \   [16] Degermark, M., Nordgren, B., and S. Pink, \"IP Header\n        Compression\"\
    , RFC 2507, February 1999.\n   [17] Casner, S. and V. Jacobson, \"Compressing\
    \ IP/UDP/RTP Headers for\n        Low-Speed Serial Links\", RFC 2508, February\
    \ 1999.\n   [18] Degermark, M., \"Requirements for robust IP/UDP/RTP header\n\
    \        compression\", RFC 3096, July 2001.\n   [19] Koren, T., Casner, S., Geevarghese,\
    \ J., Thompson, B., and P.\n        Ruddy, \"Enhanced Compressed RTP (CRTP) for\
    \ Links with High\n        Delay, Packet Loss and Reordering\", RFC 3545, July\
    \ 2003.\n   [20] Degermark, M., Hannu, H., Jonsson, L.E., and K. Svanbro,\n  \
    \      \"Evaluation of CRTP Performance over Cellular Radio Networks\",\n    \
    \    IEEE Personal Communication Magazine, Volume 7, number 4, pp.\n        20-25,\
    \ August 2000.\n   [21] IANA registry, \"RObust Header Compression (ROHC) Profile\n\
    \        Identifiers\", http://www.iana.org/assignments/rohc-pro-ids\n   [22]\
    \ Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA\n        Considerations\
    \ Section in RFCs\", BCP 26, RFC 2434, October 1998.\n"
- title: Appendix A.  CRC Algorithm
  contents:
  - "Appendix A.  CRC Algorithm\n   #!/usr/bin/perl -w\n   use strict;\n   #=================================\n\
    \   #\n   # ROHC CRC demo - Carsten Bormann cabo@tzi.org 2001-08-02\n   #\n  \
    \ # This little demo shows the four types of CRC in use in RFC 3095,\n   # the\
    \ specification for robust header compression.  Type your data in\n   # hexadecimal\
    \ form and then press Control+D.\n   #\n   #---------------------------------\n\
    \   #\n   # utility\n   #\n   sub dump_bytes($) {\n       my $x = shift;\n   \
    \    my $i;\n       for ($i = 0; $i < length($x); ) {\n     printf(\"%02x \",\
    \ ord(substr($x, $i, 1)));\n     printf(\"\\n\") if (++$i % 16 == 0);\n      \
    \ }\n       printf(\"\\n\") if ($i % 16 != 0);\n   }\n   #---------------------------------\n\
    \   #\n   # The CRC calculation algorithm.\n   #\n   sub do_crc($$$) {\n     \
    \  my $nbits = shift;\n       my $poly = shift;\n       my $string = shift;\n\
    \       my $crc = ($nbits == 32 ? 0xffffffff : (1 << $nbits) - 1);\n       for\
    \ (my $i = 0; $i < length($string); ++$i) {\n         my $byte = ord(substr($string,\
    \ $i, 1));\n         for( my $b = 0; $b < 8; $b++ ) {\n           if (($crc &\
    \ 1) ^ ($byte & 1)) {\n             $crc >>= 1;\n             $crc ^= $poly;\n\
    \           } else {\n           $crc >>= 1;\n           }\n           $byte >>=\
    \ 1;\n         }\n       }\n       printf \"%2d bits, \", $nbits;\n       printf\
    \ \"CRC: %02x\\n\", $crc;\n   }\n   #---------------------------------\n   #\n\
    \   # Test harness\n   #\n   $/ = undef;\n   $_ = <>;         # read until EOF\n\
    \   my $string = \"\"; # extract all that looks hex:\n   s/([0-9a-fA-F][0-9a-fA-F])/$string\
    \ .= chr(hex($1)), \"\"/eg;\n   dump_bytes($string);\n   #---------------------------------\n\
    \   #\n   # 32-bit segmentation CRC\n   # Note that the text implies this is complemented\
    \ like for PPP\n   # (this differs from 8, 7, and 3-bit CRC)\n   #\n   #     \
    \ C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +\n   #             x^11\
    \ + x^12 + x^16 + x^22 + x^23 + x^26 + x^32\n   #\n   do_crc(32, 0xedb88320, $string);\n\
    \   #---------------------------------\n   #\n   # 8-bit IR/IR-DYN CRC\n   #\n\
    \   #      C(x) = x^0 + x^1 + x^2 + x^8\n   #\n   do_crc(8, 0xe0, $string);\n\
    \   #---------------------------------\n   #\n   # 7-bit FO/SO CRC\n   #\n   #\
    \      C(x) = x^0 + x^1 + x^2 + x^3 + x^6 + x^7\n   #\n   do_crc(7, 0x79, $string);\n\
    \   #---------------------------------\n   #\n   # 3-bit FO/SO CRC\n   #\n   #\
    \      C(x) = x^0 + x^1 + x^3\n   #\n   do_crc(3, 0x6, $string);\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Lars-Erik Jonsson\n   Optand 737\n   SE-831 92 Ostersund,\
    \ Sweden\n   Phone: +46 70 365 20 58\n   EMail: lars-erik@lejonsson.com\n   Ghyslain\
    \ Pelletier\n   Ericsson AB\n   Box 920\n   SE-971 28 Lulea, Sweden\n   Phone:\
    \ +46 8 404 29 43\n   Fax:   +46 920 996 21\n   EMail: ghyslain.pelletier@ericsson.com\n\
    \   Kristofer Sandlund\n   Ericsson AB\n   Box 920\n   SE-971 28 Lulea, Sweden\n\
    \   Phone: +46 8 404 41 58\n   Fax:   +46 920 996 21\n   EMail: kristofer.sandlund@ericsson.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
