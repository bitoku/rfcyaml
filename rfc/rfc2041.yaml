- title: __initial_text__
  contents:
  - '                         Mobile Network Tracing

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   Mobile networks are both poorly understood and difficult to\n  \
    \ experiment with.  This RFC argues that mobile network tracing\n   provides both\
    \ tools to improve our understanding of wireless\n   channels, as well as to build\
    \ realistic, repeatable testbeds for\n   mobile software and systems.  The RFC\
    \ is a status report on our work\n   tracing mobile networks.  Our goal is to\
    \ begin discussion on a\n   standard format for mobile network tracing as well\
    \ as a testbed for\n   mobile systems research.  We present our format for collecting\
    \ mobile\n   network traces, and tools to produce from such traces analytical\n\
    \   models of mobile network behavior.\n   We also describe a set of tools to\
    \ provide network modulation based\n   on collected traces.  Modulation allows\
    \ the emulation of wireless\n   channel latency, bandwidth, loss, and error rates\
    \ on private, wired\n   networks.  This allows system designers to test systems\
    \ in a\n   realistic yet repeatable manner.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   How does one accurately capture and reproduce the observed\
    \ behavior\n   of a network?  This is an especially challenging problem in mobile\n\
    \   computing because the network quality experienced by a mobile host\n   can\
    \ vary dramatically over time and space.  Neither long-term average\n   measures\
    \ nor simple analytical models can capture the variations in\n   bandwidth, latency,\
    \ and signal degradation observed by such a host.\n   In this RFC, we describe\
    \ a solution based on network tracing.  Our\n   solution consists of two phases:\
    \  trace recording and trace\n   modulation.\n   In the trace recording phase,\
    \ an experimenter with an instrumented\n   mobile host physically traverses a\
    \ path of interest to him.  During\n   the traversal, packets from a known workload\
    \ are generated from a\n   static host.  The mobile host records observations\
    \ of both packets\n   received from the known workload as well as the device\n\
    \   characteristics during the workload.  At the end of the traversal,\n   the\
    \ list of observations represents an accurate trace of the observed\n   network\
    \ behavior for this traversal.  By performing multiple\n   traversals of the same\
    \ path, and by using different workloads, one\n   can obtain a trace family that\
    \ collectively characterizes network\n   quality on that path.\n   In the trace\
    \ modulation phase, mobile system and application software\n   is subjected to\
    \ the network behavior observed in a recorded trace.\n   The mobile software is\
    \ run on a LAN-attached host whose kernel is\n   modified to read a file containing\
    \ the trace (possibly postprocessed\n   for efficiency,) and to delay, drop or\
    \ otherwise degrade packets in\n   accordance with the behavior described by the\
    \ trace.  The mobile\n   software thus experiences network quality indistinguishable\
    \ from that\n   recorded in the trace.  It is important to note that trace modulation\n\
    \   is fully transparent to mobile software --- no source or binary\n   changes\
    \ have to be made.\n   Trace-based approaches have proved to be of great value\
    \ in areas such\n   as file system design [2, 10, 11] and computer architecture.\
    \  [1, 5,\n   13] Similarly, we anticipate that network tracing will prove valuable\n\
    \   in many aspects of mobile system design and implementation.  For\n   example,\
    \ detailed analyses of traces can provide insights into the\n   behavior of mobile\
    \ networks and validate predictive models.  As\n   another example, it can play\
    \ an important role in stress testing and\n   debugging by providing the opportunity\
    \ to reproduce the network\n   conditions under which a bug was originally uncovered.\
    \  As a third\n   example, it enables a system under development to be subjected\
    \ to\n   network conditions observed in distant real-life environments.  As a\n\
    \   final example, a set of traces can be used as a benchmark family for\n   evaluating\
    \ and comparing the adaptive capabilities of alternative\n   mobile system designs.\n\
    \   Our goal in writing this RFC is to encourage the development of a\n   widely-accepted\
    \ standard format for network traces.  Such\n   standardization will allow traces\
    \ to be easily shared.  It will also\n   foster the development and widespread\
    \ use of trace-based benchmarks.\n   While wireless mobile networks are the primary\
    \ motivation for this\n   work, we have made every effort to ensure that our work\
    \ is applicable\n   to other types of networks.  For example, the trace format\
    \ and some\n   of the tools may be valuable in analyzing and modeling ATM networks.\n\
    \   The rest of this RFC is organized as follows.  We begin by examining\n   the\
    \ properties of wireless networks and substantiating the claim that\n   it is\
    \ difficult to model such networks.  Next, in Section 3, we\n   describe the factors\
    \ that should be taken into account in designing a\n   trace format.  We present\
    \ the details of a proposed trace format\n   standard in Section 4.  Section 5\
    \ presents a set of tools that we\n   have built for the collection, analysis\
    \ and replay of traces.\n   Finally, we conclude with a discussion of related\
    \ and future work.\n"
- title: 2. Modeling Wireless Networks
  contents:
  - "2. Modeling Wireless Networks\n   Wireless channels are particularly complex\
    \ to model, because of their\n   inherent dependence on the physical properties\
    \ of radio waves (such\n   as reflections from \"hard\" surfaces, diffraction\
    \ around corners, and\n   scattering caused by small objects) and the site specific\
    \ geometries\n   in which the channel is formed.  They are usually modeled as\
    \ a time-\n   and distance-varying signal strength, capturing the statistical\n\
    \   nature of the interaction among reflected radio waves.  The signal\n   strength\
    \ can vary by several orders of magnitude (+ or - 20-30 dB)\n   within a short\
    \ distance.  While there have been many efforts to\n   obtain general models of\
    \ radio propagation inside buildings and over\n   the wide area, these efforts\
    \ have yielded inherently inaccurate\n   models that can vary from actual measurements\
    \ by an order of\n   magnitude or more.\n   Signal-to-noise ratio, or SNR, is\
    \ a measure of the received signal\n   quality.  If the SNR is too low, the received\
    \ signal will not be\n   detected at the receiver, yielding bit errors and packet\
    \ losses.  But\n   SNR is not the only effect that can lead to losses.  Another\
    \ is\n   inter-symbol interference caused by delay spread, that is, the\n   delayed\
    \ arrival of an earlier transmitted symbol that took a\n   circuitous propagation\
    \ path to arrive at the receiver, thereby\n   (partially) canceling out the current\
    \ symbol.  Yet another problem is\n   doppler shift, which causes frequency shifts\
    \ in the arrived signal\n   due to relative velocities of the transmitter and\
    \ the receiver,\n   thereby complicating the successful reception of the signal.\
    \  If\n   coherent reception is being used, receiver synchronization can be\n\
    \   lost.\n   More empirically, it has been observed that wireless channels adhere\n\
    \   to a two state error model.  In other words, channels are usually\n   well\
    \ behaved but occasionally go into a bad state in which many burst\n   errors\
    \ occur within a small time interval.\n   Developers of network protocols and\
    \ mobility algorithms must\n   experiment with realistic channel parameters. \
    \ It is highly desirable\n   that the wireless network be modeled in a thoroughly\
    \ reproducible\n   fashion.  This would allow an algorithm and its variations\
    \ to be\n   evaluated in a controlled and repeatable way.  Yet the above\n   discussion\
    \ makes it clear that whether analytical models are used or\n   even actual experimentation\
    \ with the network itself, the results will\n   be either inaccurate or unlikely\
    \ to be reproducible.  A trace-based\n   approach alleviates these problems.\n"
- title: 3. Desirable Trace Format Properties
  contents:
  - "3. Desirable Trace Format Properties\n   In designing our trace format, we have\
    \ been guided by three\n   principles.  First, the format should be extensible.\
    \  Second, it\n   should be self-describing.  Third, traces should be easy to\
    \ manage.\n   This section describes how each of these principles has affected\
    \ our\n   design.\n   Although we have found several interesting uses for network\
    \ traces,\n   it is certain that more will evolve over time.  As the traces are\n\
    \   used in new ways, it may be necessary to add new data to the trace\n   format.\
    \  Rather than force the trace format to be redesigned, we have\n   structured\
    \ the format to be extensible.  There is a built-in\n   mechanism to add to the\
    \ kinds of data that can be recorded in network\n   traces.\n   This extensibility\
    \ is of little use if the tool set needs to change\n   as the trace format is\
    \ extended.  Recognizing this, we have made the\n   format -- particularly the\
    \ extensible portions -- self-describing.\n   Thus, old versions of tools can\
    \ continue to work with extended\n   traces, if perhaps in a less than optimal\
    \ way.\n   In our experience with other tracing systems, management of trace\n\
    \   files is often difficult at best.  Common problems include the need\n   to\
    \ manage multiple trace files as a unit, not easily being able to\n   extract\
    \ the salient features of large trace files, and having to use\n   dedicated trace\
    \ management tools to perform even the simplest tasks.\n   To help cope with file\
    \ management, we have designed the the traces to\n   be split or merged easily.\
    \  To reduce dependence on specialized\n   tools, we've chosen to store some descriptive\
    \ information as ASCII\n   strings, allowing minimal access to the standard UNIX\
    \ tool suite.\n"
- title: 4. Trace Format
  contents:
  - "4. Trace Format\n   This section describes the format for network traces.  We\
    \ begin by\n   presenting the basic abstractions that are key to the trace format:\n\
    \   the record, and the track, a collection of related records.  We then\n   describe\
    \ the records at the beginning and end of a trace, the header\n   and footer.\
    \  The bulk of the section describes the three kinds of\n   record tracks:  packet,\
    \ device, and general.  These also make up the\n   bulk of the actual trace. \
    \ We conclude the section with a discussion\n   of two special purpose records:\
    \  the annotation and the trace data\n   loss records.\n"
- title: 4.1. Basic Abstractions
  contents:
  - '4.1. Basic Abstractions

    '
- title: 4.1.1. Records
  contents:
  - "4.1.1. Records\n   A record is the smallest unit of trace data.  There are several\n\
    \   different types of records, each of which is discussed in Sections\n   4.2\
    \ through 4.7.  All of the records share several features in\n   common; these\
    \ features are described here.\n   Records are composed of fields, which are stored\
    \ in network order.\n   Most of the fields in our records are word-sized.  Although\
    \ this may\n   be wasteful in space, we chose to leave room to grow and keep trace\n\
    \   management simple.\n   The first field in each record is a magic word, a random\
    \ 32 bit\n   pattern that both identifies the record's type and lends some\n \
    \  confidence that the record is well formed.  Many record types have\n   both\
    \ required and optional fields; thus they can be of variable size.\n   We place\
    \ every record's size in its second field.  By comparing the\n   size of a record\
    \ to the known constraints for the record's type, we\n   can gain further confidence\
    \ that a record is well-formed.  This basic\n   record structure is illustrated\
    \ in Figure 1.\n   All records also contain a two-word timestamp.  This timestamp\
    \ can\n   take one of two formats:  timeval or timespec.  Only one of the two\n\
    \   formats is used in any given trace, and the format is specified at\n   the\
    \ start of a trace file.  The first word in either format is the\n   number of\
    \ seconds that have elapsed since midnight, January 1, 1970.\n   The second word\
    \ is the additional fractions of a second.  In the\n   timeval format, these fractions\
    \ are expressed in microseconds, in the\n   same way that many current operating\
    \ systems express time.  In the\n   timespec format, these fractions are expressed\
    \ in nanoseconds, the\n   POSIX time standard.  We've chosen these two values\
    \ since they are\n   convenient, cover most current and anticipated systems' notions\
    \ of\n   time, and offer appropriate granularity for measuring network events.\n\
    \                          +------------------+\n                          | Magic\
    \ Number     |\n                          | Size of Record   |\n             \
    \             +------------------+\n                          | Required Fields\
    \  |\n                          |       ...        |\n                       \
    \   +------------------+\n                          | Optional Fields  |\n   \
    \                       |       ...        |\n                          +------------------+\n\
    \                        Figure 1: Record format\n"
- title: 4.1.2. Tracks
  contents:
  - "4.1.2. Tracks\n   Many of the record types have both fixed, required fields,\
    \ as well as\n   a set of optional fields.  It is these options that provide\n\
    \   extensibility to our trace format.  However, to provide a self-\n   describing\
    \ trace, we need some compact way of determining which\n   optional fields are\
    \ present in a given record.  To do this, we group\n   related sets of packets\
    \ into tracks.  For example, a set of records\n   that captured packet activity\
    \ for a single protocol between two\n   machines might be put together into a\
    \ track.  A track is a header\n   followed by some number of related records;\
    \ the header completely\n   describes the format of the individual records.  Records\
    \ from\n   separate tracks can be interleaved with one another, so long as the\n\
    \   header for each individual track appears before any of the track's\n   records.\
    \  Figure 2 shows an example of how records from different\n   tracks might be\
    \ interleaved.\n   Track headers describe their records' content through property\
    \ lists.\n   An entry in a property list is a two-element tuple consisting of\
    \ a\n   name and a value.  The name is a word which identifies the property\n\
    \   defined by this entry.  Some of these properties are measured only\n   once\
    \ for a track, for example, the address of a one-hop router in a\n   track recording\
    \ packets from that router.  Others are measured once\n   per record in that track,\
    \ such as the signal strength of a device\n   which changes over time.  The former,\
    \ which we call header-only\n   properties, have their most significant name bit\
    \ set.  The value\n   field of a header-only property holds the measured value\
    \ of the\n   property.  Otherwise, the value field holds the number of words used\n\
    \   in each of the track's records.\n       +----------++----------++----------++----------++----------+\n\
    \       | Track #1 || Track #1 || Track #2 || Track #1 || Track #2 |\n       |\
    \ Header   || Entry    || Header   || Entry    || Entry    |\n       +----------++----------++----------++----------++----------+\n\
    \                  Figure 2: Interleaved track records\n   Those properties measured\
    \ in each record in the track are grouped\n   together in a value list at the\
    \ end of each such record.  They appear\n   in the same order that was specified\
    \ in the track header's property\n   list so that tools can properly attribute\
    \ data.  Thus, even if a tool\n   doesn't know what property a particular name\
    \ represents, it can\n   identify which parts of a trace record are measuring\
    \ that property,\n   and ignore them.\n"
- title: 4.2. Trace Headers and Footers
  contents:
  - "4.2. Trace Headers and Footers\n   Trace files begin with a trace header, and\
    \ end with a trace footer.\n   The formats of these appear in Figure 3.  The header\
    \ specifies\n   whether this trace was collected on a single machine, or was merged\n\
    \   from several other traces.  In the former case, the IP address and\n   host\
    \ name of the machine are recorded.  In the latter, the IP address\n   is taken\
    \ from the family of Class E address, which are invalid.  We\n   use a family\
    \ of invalid addresses so that even if we cannot identify\n   a number of hosts\
    \ participating in the trace we can still distinguish\n   records from distinct\
    \ hosts.\n      #define TR_DATESZ   32\n      #define TR_NAMESZ   64\n      struct\
    \ tr_header_t {\n          u_int32_t        h_magic;\n          u_int32_t    \
    \    h_size;\n          u_int32_t        h_time_fmt;         /* usec or nsec */\n\
    \          struct tr_time_t h_ts;               /* starting time */\n        \
    \  char             h_date[TR_DATESZ];  /* Date collected */\n          char \
    \            h_agent[TR_NAMESZ]; /* DNS name */\n          u_int32_t        h_agent_ip;\n\
    \          char             h_desc[0];          /* variable size */\n      };\n\
    \      struct tr_end_t {\n          u_int32_t         e_magic;\n          u_int32_t\
    \         e_size;\n          struct tr_time_t  e_ts;        /* end time */\n \
    \         char              e_date[32];  /* Date end written */\n      };\n  \
    \             Figure 3: Trace header and footer records\n   The trace header also\
    \ specifies which time stamp format is used in\n   the trace, and the time at\
    \ which the trace begins.  There is a\n   variable-length description that is\
    \ a string meant to provide details\n   of how the trace was collected.  The trace\
    \ footer contains only the\n   time at which the trace ended; it serves primarily\
    \ as a marker to\n   show the trace is complete.\n   Unlike other kinds of records\
    \ in the trace format, the header and\n   footer records have several ASCII fields.\
    \  This is to allow standard\n   utilities some access to the contents of the\
    \ trace, without resorting\n   to specialized tools.\n"
- title: 4.3. Packet Tracks
  contents:
  - "4.3. Packet Tracks\n   Measuring packet activity is the main focus of the network\
    \ tracing\n   project.  Packet activity is recorded in tracks, with a packet header\n\
    \   and a set of packet entries.  A single track is meant to capture the\n   activity\
    \ of a single protocol, traffic from a single router, or some\n   other subset\
    \ of the total traffic seen by a machine.  The required\n   portions of packet\
    \ headers and entries are presented in Figure 4.\n   Packet track headers identify\
    \ which host generated the trace records\n   for that track, as well as the time\
    \ at which the track began.  It\n   records the device on which these packets\
    \ are received or sent, and\n   the protocol used to ship the packet; these allow\
    \ interpretation of\n   device-specific or protocol-specific options.  The header\
    \ concludes\n   with the property list for the track.\n      struct tr_pkt_hdr_t\
    \ {\n          u_int32_t            ph_magic;\n          u_int32_t           \
    \ ph_size;\n          u_int32_t            ph_defines;  /* magic number defined\
    \ */\n          struct tr_time_t     ph_ts;\n          u_int32_t            ph_ip;\
    \       /* host generating stream */\n          u_int32_t            ph_dev_type;\
    \ /* device collected from */\n          u_int32_t            ph_protocol; /*\
    \ protocol */\n          struct tr_prop_lst_t ph_plist[0]; /* variable size */\n\
    \      };\n      struct tr_pkt_ent_t {\n          u_int32_t        pe_magic;\n\
    \          u_int32_t        pe_size;\n          struct tr_time_t pe_ts;\n    \
    \      u_int32_t        pe_psize;    /* packet size */\n          u_int32_t  \
    \      pe_vlist[0]; /* variable size */\n      };\n               Figure 4: Packet\
    \ header and entry records\n   A packet entry is generated for every traced packet.\
    \  It contains the\n   size of the traced packet, the time at which the packet\
    \ was sent or\n   received, and the list of property measurements as specified\
    \ in the\n   track header.\n   The options we have defined to date are in Table\
    \ 1.  Several of these\n   have played an important role in our early experiments.\
    \  ADDR_PEER\n   identifies the senders of traffic during the experiment.  We\
    \ can\n   determine network performance using either PKT_SENTTIME for one-way\n\
    \   traffic between two hosts with closely synchronized clocks, or round\n   trip\
    \ ICMP ECHO traffic and the ICMP_PINGTIME option.  Tracking\n   PKT_SEQUENCE numbers\
    \ sheds light on both loss rates and patterns.\n   Section 5 discusses how these\
    \ measurements are used.\n"
- title: 4.4. Device Tracks
  contents:
  - "4.4. Device Tracks\n   Our trace format records details of the devices which\
    \ carry network\n   traffic.  To date, we've found this most useful for correlating\
    \ lost\n   packets with various signal parameters provided by wireless devices.\n\
    \   The required portions of device header and entry records appear in\n   Figure\
    \ 5, and are quite simple.  Device track headers identify the\n   host generating\
    \ the track's records, the time at which the\n   observation starts, and the type\
    \ of device that is being traced.\n   Each entry contains the time of the observation,\
    \ and the list of\n   optional characteristics.\n   +---------------+-----------------------------------------------+\n\
    \   | ADDR_PEER     | Address of peer host                          |\n   | ADDR_LINK\
    \     | Address of one-hop router                     |\n   | BS_LOC_X      |\
    \ One-hop router's X coordinate (header only)   |\n   | BS_LOC_Y      | One-hop\
    \ router's Y coordinate (header only)   |\n   | PKT_SEQUENCE  | Sequence number\
    \ of packet                     |\n   | PKT_SENTTIME  | Time packet was sent \
    \                         |\n   | PKT_HOPS      | Number of hops packet took \
    \                   |\n   | SOCK_PORTS    | Sending and receiving ports      \
    \             |\n   | IP_PROTO      | Protocol number of an IP packet        \
    \       |\n   | ICMP_PINGTIME | Roundtrip time of an ICMP ECHO/REPLY pair    \
    \ |\n   | ICMP_KIND     | Type and code of an ICMP packet               |\n  \
    \ | ICMP_ID       | The id field of an ICMP packet                |\n   | PROTO_FLAGS\
    \   | Protocol-specific flags                       |\n   | PROTO_ERRLIST | Protocol-specific\
    \ status/error words          |\n   +---------------+-----------------------------------------------+\n\
    \          Table 1: Current optional fields for packet entries\n      struct tr_dev_hdr_t\
    \ {\n          u_int32_t            dh_magic;\n          u_int32_t           \
    \ dh_size;\n          u_int32_t            dh_defines;  /* Magic number defined\
    \ */\n          struct tr_time_t     dh_ts;\n          u_int32_t            dh_ip;\
    \       /* host generating stream */\n          u_int32_t            dh_dev_type;\
    \ /* device described */\n          struct tr_prop_lst_t dh_plist[0]; /* Variable\
    \ size */\n      };\n      struct tr_dev_ent_t {\n          u_int32_t        de_magic;\n\
    \          u_int32_t        de_size;\n          struct tr_time_t de_ts;\n    \
    \      u_int32_t        de_vlist[0]; /* Variable size */\n      };\n         \
    \      Figure 5: Device header and entry records\n   These optional characteristics,\
    \ listed in Table 2, are mostly\n   concerned with the signal parameters of the\
    \ wireless interfaces we\n   have available.  Interpreting these parameters is\
    \ heavily device-\n   dependent.  We give examples of how we've used device observations\
    \ in\n   Section 5.\n  +-----------------+--------------------------------------------------+\n\
    \  | DEV_ID          | Major and minor number of device (header only)   |\n  |\
    \ DEV_STATUS      | Device specific status registers                 |\n  | WVLN_SIGTONOISE\
    \ | Signal to noise ratio reported by WaveLAN        |\n  | WVLN_SIGQUALITY |\
    \ Signal quality reported by WaveLAN               |\n  | WVLN_SILENCELVL | WaveLAN\
    \ silence level                            |\n  +-----------------+--------------------------------------------------+\n\
    \          Table 2: Current optional fields for packet entries\n"
- title: 4.5. Miscellaneous Tracks
  contents:
  - "4.5. Miscellaneous Tracks\n   We use miscellaneous, or general, tracks to record\
    \ things that don't\n   fit clearly in either the packet or device model.  At\
    \ the moment,\n   physical location of a mobile host is the only attribute tracked\
    \ in\n   general trace records.  The required portion of the general header\n\
    \   and entry records is shown in Figure 6, the two optional properties\n   are\
    \ in Table 3.  In addition to the property list, general headers\n   have only\
    \ the IP address of the host generating the record and the\n   time at which observations\
    \ began.  General entries have only a\n   timestamp, and the optional fields.\n"
- title: 4.6. Annotations
  contents:
  - "4.6. Annotations\n   An experimenter may occasionally want to embed arbitrary\
    \ descriptive\n   text into a trace.  We include annotation records to provide\
    \ for\n   this.  Such records are not part of a track; they stand alone.  The\n\
    \   structure of an annotation record is shown in Figure 7.  Annotations\n   include\
    \ the time at which the annotation was inserted in the trace,\n   the host which\
    \ inserted the annotation, and the variable-sized text\n   of the annotation itself.\n\
    \      struct tr_gen_hdr_t {\n          u_int32_t            gh_magic;\n     \
    \     u_int32_t            gh_size;\n          u_int32_t            gh_defines;\n\
    \          struct tr_time_t     gh_ts;\n          u_int32_t            gh_ip;\n\
    \          struct tr_prop_lst_t gh_plist[0]; /* Variable size */\n      };\n \
    \     struct tr_gen_ent_t {\n          u_int32_t        ge_magic;\n          u_int32_t\
    \        ge_size;\n          struct tr_time_t ge_ts;\n          u_int32_t    \
    \    ge_vlist[0]; /* Variable size */\n      };\n               Figure 6: General\
    \ header and entry records\n      +------------+--------------------------------------------+\n\
    \      | MH_LOC_X   | Mobile host's X coordinate (map-relative)  |\n      | MH_LOC_Y\
    \   | Mobile host's Y coordinate (map-relative)  |\n      | MH_LOC_LAT | Mobile\
    \ host's GPS latitude                 |\n      | MH_LOC_LON | Mobile host's GPS\
    \ longitude                |\n      +------------+--------------------------------------------+\n\
    \          Table 3: Current optional fields for general entries\n      struct\
    \ tr_annote_t {\n          u_int32_t        a_magic;\n          u_int32_t    \
    \    a_size;\n          struct tr_time_t a_ts;\n          u_int32_t        a_ip;\n\
    \          char             a_text[0]; /* variable size */\n      };\n       \
    \               Figure 7: Annotation records\n"
- title: 4.7. Lost Trace Data
  contents:
  - "4.7. Lost Trace Data\n   It is possible that, during collection, some trace records\
    \ may be\n   lost due to trace buffer overflow or other reasons.  Rather than\n\
    \   throw such traces away, or worse, ignoring the lost data, we've\n   included\
    \ a loss record to count the types of other records which are\n   lost in the\
    \ course of trace collection.  Loss records are shown in\n   Figure 8.\n     \
    \ struct tr_loss_t {\n          u_int32_t        l_magic;\n          u_int32_t\
    \        l_size;\n          struct tr_time_t l_ts;\n          u_int32_t      \
    \  l_ip;\n          u_int32_t        l_pkthdr;\n          u_int32_t        l_pktent;\n\
    \          u_int32_t        l_devhdr;\n          u_int32_t        l_devent;\n\
    \          u_int32_t        l_annote;\n      };\n                         Figure\
    \ 8: Loss records\n"
- title: 5. Software Components
  contents:
  - "5. Software Components\n   In this section, we describe the set of tools that\
    \ have been built to\n   date for mobile network tracing.  We believe many of\
    \ these tools are\n   widely applicable to network tracing tasks, but some have\
    \ particular\n   application to mobile network tracing.  We begin with an overview\
    \ of\n   the tools, their applicability, and the platforms on which they are\n\
    \   currently supported, as well as those they are being ported to.  This\n  \
    \ information is summarized in Table 4.\n   We have made every effort to minimize\
    \ dependencies of our software on\n   anything other than protocol and device\
    \ specifications.  As a result,\n   we expect ports to other BSD-derived systems\
    \ to be straightforward;\n   ports to other UNIX systems may be more complicated,\
    \ but feasible.\n   There are three categories into which our tracing tools can\
    \ be\n   placed:  trace collection, trace modulation, and trace analysis.\n  \
    \ Trace collection tools are used for generating new traces.  They\n   record\
    \ information about the general networking facilities, as well\n   as data specific\
    \ to mobile situations:  mobile host location, base\n   station location, and\
    \ wireless device characteristics.  These tools\n   are currently supported on\
    \ BSDI, and are being ported to NetBSD. We\n   describe these tools in Section\
    \ 5.1.\n   Trace modulation tools emulate the performance of a traced wireless\n\
    \   network on a private wired network.  The trace modulation tools,\n   discussed\
    \ in Section 5.2, are currently supported on NetBSD\n   platforms.  They are geared\
    \ toward replaying low speed/quality\n   networks on faster and more reliable\
    \ ones, and are thus most\n   applicable to reproducing mobile environments.\n\
    \   In Section 5.3, we conclude with a set of trace processing and\n   analysis\
    \ tools, which are currently supported on both NetBSD and BSDI\n   platforms.\
    \  Our analyses to date have focused on properties of\n   wireless networks, and\
    \ are most directly applicable to mobile traces.\n   The processing tools, however,\
    \ are of general utility.\n                  +--------------+--------------+--------------+\n\
    \                  | Collection   | Modulation   | Analysis     |\n      +-----------+--------------+--------------+--------------+\n\
    \      | NetBSD    | In Progress  | Supported    | Supported    |\n      | BSDI\
    \      | Supported    | Planned      | Supported    |\n      +-----------+--------------+--------------+--------------+\n"
- title: This table summarizes the currently supported platforms for the tracing
  contents:
  - 'This table summarizes the currently supported platforms for the tracing

    '
- title: tool suites, and the platforms to which ports are underway.
  contents:
  - "tool suites, and the platforms to which ports are underway.\n               \
    \        Table 4: Tool Availability\n"
- title: 5.1. Trace Collection Tools
  contents:
  - "5.1. Trace Collection Tools\n   The network trace collection facility comprises\
    \ two key components:\n   the trace agent and the trace collector.  They are shown\
    \ in Figure 9.\n   The trace agent resides in the kernel where it can obtain data\
    \ that\n   is either expensive to obtain or inaccessible from the user level.\n\
    \   The agent collects and buffers data in kernel memory; the user-level\n   trace\
    \ collector periodically extracts data from this kernel buffer\n   and writes\
    \ it to disk.  The buffer amortizes the fixed costs of data\n   transfer across\
    \ a large number of records, minimizing the impact of\n   data transfer on system\
    \ performance.  The trace collector retrieves\n   data through a pseudo-device,\
    \ ensuring that only a single -- and\n   therefore complete -- trace file is being\
    \ generated from a single\n   experiment.  To provide simplicity and efficiency,\
    \ the collector does\n   not interpret extracted data; it is instead processed\
    \ off-line by the\n   post-processing and analysis tools described in Sections\
    \ 5.2 and 5.3.\n   There are three sorts of data collected by the tracing tools:\
    \ network\n   traffic, network device characteristics, and mobile host location.\n\
    \   The first two are collected in much the same way; we describe the\n   methodology\
    \ in Section 5.1.1.  The last is collected in two novel\n   ways.  These collection\
    \ methods are addressed in Section 5.1.2.\n                                  \
    \   +-----------+  write to disk\n                                     | Trace\
    \     | ==============>\n                                     | Collector |\n\
    \                                     +-----------+\n                        \
    \                     A\n     ========================================|===== kernel\
    \ boundary\n     +-----------------+                     |\n     | Transport Layer\
    \ |                     |\n     |-----------------|             +------------------+\n\
    \     |  Network Layer  |------------>| Trace   +------+ |\n     |-----------------|\
    \             | Agent   |buffer| |\n     |  NI |  NI |  NI |------------>|   \
    \      +------+ |\n     +-----------------+             +------------------+\n\
    \ This figure illustrates the components of trace collection.  The NI's\n    \
    \                    are network interfaces.\n                Figure 9: Components\
    \ of trace collection\n"
- title: 5.1.1. Traffic and Device Collection
  contents:
  - "5.1.1. Traffic and Device Collection\n   The trace agent exports a set of function\
    \ calls for traffic and\n   device data collection.  Traffic data is collected\
    \ on a per-packet\n   basis.  This is done via a function called from device drivers\
    \ with\n   the packet and a device identifier as arguments.  For each packet,\n\
    \   the trace record contains the source and destination address options.\n  \
    \ Since our trace format assembles related packets into tracks, common\n   information,\
    \ such as the destination address, is recorded in the\n   track header to reduce\
    \ the record size for each packet entry.  We\n   also record the size of each\
    \ packet.\n   Information beyond packet size and address information is typically\n\
    \   protocol-dependent.  For transport protocols such as UDP and TCP, for\n  \
    \ example, we record the source and destination port numbers; TCP\n   packet records\
    \ also contain the sequence number.  For ICMP packets,\n   we record their type,\
    \ code and additional type-dependent data.  As\n   explained in Section 5.2.3,\
    \ we record the identifier, sequence number\n   and time stamp for ICMP ECHOREPLY\
    \ packets.\n   Before appending the record to the trace buffer, we check to see\
    \ if\n   it is the first record in a track.  If so, we create a new packet\n \
    \  track header, and write it to the buffer prior the packet entry.\n   Our trace\
    \ collection facility provides similar mechanisms to record\n   device-specific\
    \ data such as signal quality, signal level, and noise\n   level.  Hooks to these\
    \ facilities can be easily added to the device\n   drivers to invoke these tracing\
    \ mechanisms.  The extensible and\n   self-describing features of our trace format\
    \ allow us to capture a\n   wide variety of data specific to particular network\
    \ interfaces.\n   For wireless network devices, we record several signal quality\n\
    \   measurements that the interfaces provide.  Although some interfaces,\n   such\
    \ as NCR's WaveLAN, can supply this of information for every\n   packet received,\
    \ most devices average their measurements over a\n   longer period of time.  As\
    \ a result, we only trace these measurements\n   periodically.  It is up to the\
    \ device drivers to determine the\n   frequency at which data is reported to the\
    \ trace agent.\n   When devices support it, we also trace status and error events.\
    \  The\n   types of errors, such as CRC or buffer overflow, allow us to\n   determine\
    \ causes for some observed packet losses.  For example, we\n   can attribute loss\
    \ to either the wireless channel or the network\n   interface.\n"
- title: 5.1.2. Location Tracing
  contents:
  - "5.1.2. Location Tracing\n   At first thought, recording the position of a mobile\
    \ host seems\n   straightforward.  It can be approximated by recording the base\n\
    \   station (BS) with which the mobile host is communicating.  However,\n   due\
    \ to the large coverage area provided by most radio interfaces,\n   this information\
    \ provides a loose approximation at best.  In\n   commercial deployments, we may\
    \ not be able to reliably record the\n   base station with which a mobile host\
    \ communicates.  This section\n   outlines our collection strategy for location\
    \ information in both\n   outdoor and indoor environments.\n   The solution that\
    \ we have considered for wide-area, outdoor\n   environments makes use of the\
    \ Global Positioning System (GPS). The\n   longitude and latitude information\
    \ provided by the GPS device is\n   recorded in a general track.\n   Indoor environments\
    \ require a different approach because the\n   satellite signals cannot reach\
    \ a GPS device inside a building.  We\n   considered deploying an infrared network\
    \ similar to the Active Badge\n   [14] or the ParcTab [12]; however, this significant\
    \ addition to the\n   wireless infrastructure is not an option for most research\
    \ groups.\n   As an alternative, we have developed a graphical tool that displays\n\
    \   the image of a building map and expects the user to \"click\" their\n   location\
    \ as they move; the coordinates on the map are recorded in one\n   or more general\
    \ tracks.  The header of such tracks can also record\n   the coordinates of the\
    \ base stations if they are known.\n   An extension can be easily added to this\
    \ tool to permit multiple\n   maps.  As the user requests that a new map be loaded\
    \ into the\n   graphical tracing tool, a new location track is created along with\
    \ an\n   annotation record that captures the file name of that image.\n   Locations\
    \ of new base stations can be recorded in this new track\n   header.  Each location\
    \ track should represent a different physical\n   and wireless environment.\n"
- title: 5.2. Trace Modulation Tools
  contents:
  - "5.2. Trace Modulation Tools\n   A key tool we have built around our trace format\
    \ is PaM, the Packet\n   Modulator.  The idea behind PaM is to take traces that\
    \ were collected\n   by a mobile host and distill them into modulation traces.\
    \  These\n   modulation traces capture the networking environment seen by the\n\
    \   traced host, and are used by a PaM kernel to delay, drop, or corrupt\n   incoming\
    \ and outgoing packets.  With PaM, we've built a testbed that\n   can repeatably,\
    \ reliably mimic live systems under certain mobile\n   scenarios.\n   There are\
    \ three main components to PaM. First, we've built a kernel\n   capable of delaying,\
    \ dropping, and corrupting packets to match the\n   characteristics of some observed\
    \ network.  Second, we've defined a\n   modulation trace format to describe how\
    \ such a kernel should modulate\n   packets.  Third, we've built a tool to generate\
    \ modulation traces\n   from certain classes of raw traces collected by mobile\
    \ hosts.\n"
- title: 5.2.1. Packet Modulation
  contents:
  - "5.2.1. Packet Modulation\n   The PaM modulation tool has been placed in the kernel\
    \ between the IP\n   layer and the underlying interfaces.  The tool intercepts\
    \ incoming\n   and outgoing packets, and may choose to drop it, corrupt it, or\
    \ delay\n   it.  Dropping an incoming or outgoing packet is easy, simply don't\n\
    \   forward it along.  Similarly, we can corrupt a packet by flipping\n   some\
    \ bits in the packet before forwarding it.\n   Correctly delaying a packet is\
    \ slightly more complicated.  We model\n   the delay a packet experiences as the\
    \ time it takes the sender to put\n   the packet onto the network interface plus\
    \ the time it takes for the\n   last byte to propagate to the receiver.  The former,\
    \ the transmission\n   time, is the size of the packet divided by the available\
    \ bandwidth;\n   the latter is latency.\n   Our approach at delay modulation is\
    \ simple -- we assume that the\n   actual network over which packets travel is\
    \ much faster and of better\n   quality than the one we are trying to emulate,\
    \ and can thus ignore\n   it.  We delay the packet according to our latency and\
    \ bandwidth\n   targets, and then decide whether to drop or corrupt it.  We take\
    \ care\n   to ensure that packet modulation does not unduly penalize other\n \
    \  system activity, using the internal system clock to schedule packets.\n   Since\
    \ this clock is at a large granularity compared to delay\n   resolution, we try\
    \ to keep the average error in scheduling to a\n   minimum, rather than scheduling\
    \ each packet at exactly the right\n   time.\n"
- title: 5.2.2. Modulation Traces
  contents:
  - "5.2.2. Modulation Traces\n   To tell the PaM kernel how the modulation parameters\
    \ change over\n   time, we provide it with a series of modulation-trace entries.\
    \  Each\n   of these entries sets loss and corruption percentages, as well as\n\
    \   network latency and inter-byte time, which is 1/bandwidth.  These\n   entries\
    \ are stored in a trace file, the format of which is much\n   simpler than record-format\
    \ traces, and is designed for efficiency in\n   playback.  The format of modulation\
    \ traces is shown in Figure 10.\n      struct tr_rep_hdr_t {\n          u_int32_t\
    \        rh_magic;\n          u_int32_t        rh_size;\n          u_int32_t \
    \       rh_time_fmt;         /* nsec or used */\n          struct tr_time_t rh_ts;\n\
    \          char             rh_date[TR_DATESZ];\n          char             rh_agent[TR_NAMESZ];\n\
    \          u_int32_t        rh_ip;\n          u_int32_t        rh_ibt_ticks; \
    \       /* units/sec, ibt */\n          u_int32_t        rh_lat_ticks;       \
    \ /* units/sec, lat */\n          u_int32_t        rh_loss_max;         /* max\
    \ loss rate */\n          u_int32_t        rh_crpt_max;         /* max corrupt\
    \ rate */\n          char             rh_desc[0];          /* variable size */\n\
    \      };\n      struct tr_rep_ent_t {\n          u_int32_t         re_magic;\n\
    \          struct tr_time_t  re_dur;          /* duration of entry */\n      \
    \    u_int32_t         re_lat;          /* latency */\n          u_int32_t   \
    \      re_ibt;          /* inter-byte time */\n          u_int32_t         re_loss;\
    \         /* loss rate */\n          u_int32_t         re_crpt;         /* corrupt\
    \ rate */\n      };\n                   Figure 10: Modulation trace format\n \
    \  Modulation traces begin with a header that is much like that found in\n   record-format\
    \ trace headers.  Modulation headers additionally carry\n   the units in which\
    \ latency and inter-byte time are expressed, and the\n   maximum values for loss\
    \ and corruption rates.  Individual entries\n   contain the length of time for\
    \ which the entry applies as well as the\n   latency, inter-byte time, loss rate,\
    \ and corruption rate.\n"
- title: 5.2.3. Trace Transformation
  contents:
  - "5.2.3. Trace Transformation\n   How can we generate these descriptive modulation\
    \ traces from the\n   recorded observational traces described in Section 4?  To\
    \ ensure a\n   high-quality modulation trace, we limit ourselves to a very narrow\n\
    \   set of source traces.  As our experience with modulation traces is\n   limited,\
    \ we use a simple but tunable algorithm to generate them.\n   Our basic strategy\
    \ for determining latency and bandwidth is tied\n   closely to our model of packet\
    \ delays:  delay is equal to\n   transmission time plus latency.  We further assume\
    \ that packets which\n   traversed the network near one another in time experienced\
    \ the same\n   latency and bandwidth during transit.  Given this, we look for\
    \ two\n   packets of different size that were sent close to one another along\n\
    \   the same path; from the transit times and sizes of these packets, we\n   can\
    \ determine the near-instantaneous bandwidth and latency of the\n   end-to-end\
    \ path covered by those packets.  If traced packet traffic\n   contains sequence\
    \ numbers, loss rates are fairly easy to calculate.\n   Likewise, if the protocol\
    \ is capable of marking corrupt packets,\n   corruption information can be stored\
    \ and then extracted from recorded\n   traces.\n   Using timestamped packet observations\
    \ to derive network latency and\n   bandwidth requires very accurate timing. \
    \ Unfortunately, the laptops\n   we have on hand have clocks that drift non-negligibly.\
    \  We have\n   chosen not to use protocols such as NTP [9] for two reasons.  First,\n\
    \   they produce network traffic above and beyond that in the known\n   traced\
    \ workload.  Second, and perhaps more importantly, they can\n   cause the clock\
    \ to speed up or slow down during adjustment.  Such\n   clock movements can play\
    \ havoc with careful measurement.\n   As a result, we can only depend on the timestamps\
    \ of a single machine\n   to determine packet transit times.  So, we use the ICMP\
    \ ECHO service\n   to provide workloads on traced machines; the ECHO request is\n\
    \   timestamped on it's way out, and the corresponding ECHOREPLY is\n   traced.\
    \  We have modified the ping program to alternate between small\n   and large\
    \ packets.  Traces that capture such altered ping traffic can\n   then be subject\
    \ to our transformation tool.\n   The tool itself uses a simple sliding window\
    \ scheme to generate\n   modulation entries.  For each window position in the\
    \ recorded trace,\n   we determine the loss rate, and the average latency and\
    \ bandwidth\n   experienced by pairs of ICMP ECHO packets.  The size and granularity\n\
    \   of the sliding window are parameters of the transformation; as we\n   gain\
    \ experience both in analysis and modulation of wireless traces,\n   we expect\
    \ to be able to recommend good window sizes.\n   Unfortunately, our wireless devices\
    \ do not report corrupt packets;\n   they are dropped by the hardware without\
    \ operating system\n   notification.  However, our modulation system will also\
    \ coerce any\n   such corruptions to an increased loss rate, duplicating the behavior\n\
    \   in the original network.\n"
- title: 5.3. Trace Analysis Tools
  contents:
  - "5.3. Trace Analysis Tools\n   A trace is only as useful as its processing tools.\
    \  The requirements\n   for such tools tools include robustness, flexibility,\
    \ and\n   portability.  Having an extensible trace format places additional\n\
    \   emphasis on the ability to work with future versions.  To this end,\n   we\
    \ provide a general processing library as a framework for users to\n   easily\
    \ develop customized processing tools; this library is designed\n   to provide\
    \ both high portability and good performance.\n   In this section, we first present\
    \ the trace library.  We then\n   describe a set of tools for simple post-processing\
    \ and preparing the\n   trace for further analyses.  We conclude with a brief\
    \ description of\n   our analysis tools that are applied to this minimally processed\
    \ data.\n"
- title: 5.3.1. Trace Library
  contents:
  - "5.3.1. Trace Library\n   The trace library provides an interface that applications\
    \ can use to\n   simplify interaction with network traces, including functions\
    \ to\n   read, write, and print trace records.  The trace reading and writing\n\
    \   functions manage byte swapping as well as optional integrity checking\n  \
    \ of the trace as it is read or written.  The library employs a\n   buffering\
    \ strategy that is optimized to trace I/O. Trace printing\n   facilities are provided\
    \ for both debugging and parsing purposes.\n"
- title: 5.3.2. Processing Tools
  contents:
  - "5.3.2. Processing Tools\n   The processing tools are generally the simplest set\
    \ of tools we have\n   built around the trace format.  By far the most complicated\
    \ one is\n   the modulation-trace transformation tool described in Section 5.2.3;\n\
    \   the remainder are quite simple in comparison.  The first such tool is\n  \
    \ a parser that prints the content of an entire trace.  With the trace\n   library,\
    \ it is less than a single page of C code.  For each record,\n   it prints the\
    \ known data fields along with their textual names,\n   followed by all the optional\
    \ properties and values.\n   Since many analysis tasks tend to work with records\
    \ of the same type,\n   an enhanced version of the parser can split the trace\
    \ data by tracks\n   into many files, one per track.  Each line of the output\
    \ text files\n   contains a time stamp followed by the integer values of all the\n\
    \   optional data in a track entry; in this form traces are amenable to\n   further\
    \ analysis be scripts written in an interpreted language such\n   as perl.\n \
    \  We have developed a small suite of tools providing simple functions\n   such\
    \ as listing all the track headers and changing the trace\n   description as they\
    \ have been needed.  With the trace library, each\n   such tool is trivial to\
    \ construct.\n"
- title: 5.3.3. Analysis Tools
  contents:
  - "5.3.3. Analysis Tools\n   Analysis tools depend greatly on the kind of information\
    \ an\n   experimenter wants to extract from the trace; our tools show our own\n\
    \   biases in experimentation.  Most analyses derive common statistical\n   descriptions\
    \ of traces, or establish some correlation between the\n   trace data sets.\n\
    \   As early users of the trace format and collection tools, we have\n   developed\
    \ a few analysis tools to study the behavior of the wireless\n   networks at our\
    \ disposal.  We have been particularly interested in\n   loss characteristics\
    \ of wireless channels and their relation to\n   signal quality and the position\
    \ of the mobile host.  In this section,\n   we briefly present some of these tools\
    \ to hint at the kind of\n   experimentation possible with our trace format.\n\
    \   Loss characteristics are among the most interesting aspects of\n   wireless\
    \ networks, and certainly among the least well understood.  To\n   shed light\
    \ on this area, we have created tools to extract the loss\n   information from\
    \ collected traces; in addition to calculating the\n   standard parameters such\
    \ as the packet loss rate, the tool also\n   derives transitional probabilities\
    \ for a two-state error model.\n   This has proven to be a simple yet powerful\
    \ model for capturing the\n   burstiness observed in wireless loss rates due to\
    \ fading signals.  To\n   help visualize the channel behavior in the presence\
    \ of mobility, our\n   tool can replay the movement of the mobile host while plotting\
    \ the\n   loss rate as it changes with time.  It also allows us to zoom in the\n\
    \   locations along the path and obtain detailed statistics over\n   arbitrary\
    \ time intervals.\n   Our traces can be further analyzed to understand the relationship\n\
    \   between channel behavior and the signal quality.  For wireless\n   devices\
    \ like the NCR WaveLAN, we can easily obtain measurements of\n   signal quality,\
    \ signal strength, and noise level.  We have developed\n   a simple statistical\
    \ tool to test the correlation between measured\n   signal and the loss characteristics.\
    \  Variations of this test are\n   also possible using different combinations\
    \ of the three signal\n   measurements and the movement of the host.\n   The question\
    \ of just how mobile such mobile hosts are can also be\n   investigated through\
    \ our traces.  Position data are provided by\n   traces that either involved GPS\
    \ or user-supplied positions with our\n   trace collection tools.  This data is\
    \ valuable for comparing and\n   validating various mobility prediction algorithms.\
    \  Given adequate\n   network infrastructure and good signal measurements, we\
    \ can determine\n   the mobile location within a region that is significantly\
    \ smaller\n   than the cell size.  We are developing a tool to combine position\n\
    \   information and signal measurement from many traces to identify the\n   \"\
    signal quality\" signature for different regions inside a building.\n   Once this\
    \ signature database is completed and validated, it can be\n   used to generate\
    \ position information for other traces that contain\n   only the signal quality\
    \ information.\n"
- title: 6. Related Work
  contents:
  - "6. Related Work\n   The previous work most relevant to mobile network tracing\
    \ falls into\n   two camps.  The first, chiefly exemplified by tcpdump [7] and\
    \ the BSD\n   Packet Filter, or BPF [8], collect network traffic data.  The second,\n\
    \   notably Delayline [6], and the later Probe/Fault Injection Tool [4],\n   and\
    \ the University of Lancaster's netowrk emulator [3], provide\n   network modulation\
    \ similar to PaM.\n   There are many systems that record network packet traffic;\
    \ the de\n   facto standard is tcpdump, which works in concert with a packet\n\
    \   filter such as BPF. The packet filter is given a small piece of code\n   that\
    \ describes packets of interest, and the first several bytes of\n   each packet\
    \ found to be interesting is copied to a buffer for tcpdump\n   to consume.  This\
    \ architecture is efficient, flexible, and has\n   rightly found great favor with\
    \ the networking community.\n   However, tcpdump cpatures only traffic data. \
    \ It records neither\n   information concerning mobile networking devices nor\
    \ mobile host\n   location.  Rather than adding seperate software components to\
    \ a host\n   running tcpdump to capture this additional data, we have chosen to\n\
    \   follow an integrative approach to ease trace file administration.  We\n  \
    \ have kept the lessons of tcpdump and BPF to heart; namely copying\n   only the\
    \ information necessary, and transferring data up to user\n   level in batches.\
    \  It may well pay to investigate either\n   incorporating device and location\
    \ information directly into BPF, or\n   taking the flexible filtering mechanism\
    \ of BPF and including it in\n   our trace collection software.  For the moment,\
    \ we do not know\n   exactly what data we will need to explore the properties\
    \ of mobile\n   networks, and therefore do not exclude any data.\n   There are\
    \ three notable systems that provide packet modulation\n   similar to PaM. The\
    \ earliest such work is Delayline, a system\n   designed to emulate wide-area\
    \ networks atop local-area ones; a goal\n   similar to PaM's.  The most striking\
    \ difference between Delayline and\n   PaM is that Delayline's emulation takes\
    \ place entirely at the user-\n   level, and requires applications to be recompiled\
    \ against a library\n   emulating the BSD socket system and library calls.  While\
    \ this is a\n   portable approach that works well in the absence of kernel-level\n\
    \   source access, it has the disadvantage that not all network traffic\n   passes\
    \ through the emulation layer; such traffic may have a profound\n   impact on\
    \ the performance of the final system.  Delayline also\n   differs from PaM in\
    \ that the emulated network uses a single set of\n   parameters for each emulated\
    \ connection; performance remains fairly\n   constant, and cannot change much\
    \ over time.\n   The Lancaster network emulator was designed explicitly to model\n\
    \   mobile networks.  Rather than providing per-host modulation, it uses\n   a\
    \ single, central server through which all network traffic from\n   instrumented\
    \ applications passes.  While this system also does not\n   capture all traffic\
    \ into and out of a particular host, it does allow\n   modulation based on multiple\
    \ hosts sharing a single emulated medium.\n   There is a mechanism to change the\
    \ parameters of emulation between\n   hosts, though it is fairly cumbersome. \
    \ The system uses a\n   configuration file that can be changed and re-read while\
    \ the system\n   is running.\n   The system closest in spirit to PaM is the Probe/Fault\
    \ Injection\n   Tool.  This system's design philosophy allows an arbitrary protocol\n\
    \   layer -- including device drivers -- to be encapsulated by a layer\n   below\
    \ to modulate existing traffic, and a layer above to generate\n   test traffic.\
    \  The parameters of modulation are provided by a script\n   in an interpreted\
    \ language, presently Tcl, providing considerable\n   flexibility.  However, there\
    \ is no mechanism to synthesize such\n   scripts -- they must be explicitly designed.\
    \  Furthermore, the use of\n   an interpreted language such as Tcl limits the\
    \ use of PFI to user-\n   level implementations of network drivers, and may have\
    \ performance\n   implications.\n"
- title: 7. Future Work
  contents:
  - "7. Future Work\n   This work is very much in its infancy; we have only begun\
    \ to explore\n   the possible uses for mobile network traces.  We have uncovered\n\
    \   several areas of further work.\n   The trace format as it stands is very IP-centric.\
    \  While one could\n   imagine using unknown IP addresses for non-IP hosts, while\
    \ using\n   header-only properties to encode other addressing schemes, this is\n\
    \   cumbersome at best.  We are looking into ways to more conveniently\n   encode\
    \ other addressing schemes, but are content to focus on IP\n   networks for the\
    \ moment.\n   Two obvious questions concerning wireless media are the following.\n\
    \   How does a group of machines perform when sharing the same bandwidth?\n  \
    \ How asymmetric is the performance of real-world wireless channels?\n   While\
    \ we do have tools for merging traces taken from multiple hosts\n   into a single\
    \ trace file, we've not yet begun to examine such\n   multiple-host scenarios\
    \ in depth.  We are also looking into\n   instrumenting wireless base stations\
    \ as well as end-point hosts.\n   Much of our planned work involves the PaM testbed.\
    \  First and\n   foremost, many wireless channels are known to be asymmetric;\n\
    \   splitting the replay trace into incoming and outgoing modulation\n   entries\
    \ is of paramount importance.  We would like to extend PaM to\n   handle multiple\
    \ emulated interfaces as well as applying different\n   modulation parameters\
    \ to packets from or to different destinations.\n   One could also imagine tracing\
    \ performance from several different\n   networking environments, and switching\
    \ between such environments\n   under application control.  For example, consider\
    \ a set of traces\n   showing radio performance at various altitudes; an airplane\
    \ simulator\n   in a dive would switch from high-altitude modulation traces to\
    \ low-\n   altitude ones.\n   Finally, we are anxious to begin exploring the properties\
    \ of real-\n   world mobile networks, and subjecting our own mobile system designs\n\
    \   to PaM to see how they perform.  We hope others can make use of our\n   tools\
    \ to do the same.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors wish to thank Dave Johnson, who provided early\
    \ pointers\n   to related work and helped us immeasurably in RFC formatting. \
    \ We\n   also wish to thank those who offered comments on early drafts of the\n\
    \   document:  Mike Davis, Barbara Denny, Mark Lewis, and Hui Zhang.\n   Finally,\
    \ we would like to thank Bruce Maggs and Chris Hobbs, our\n   first customers!\n\
    \   This research was supported by the Air Force Materiel Command (AFMC)\n   and\
    \ ARPA under contract numbers F196828-93-C-0193 and DAAB07-95-C-\n   D154, and\
    \ the State of California MICRO Program.  Additional support\n   was provided\
    \ by AT&T, Hughes Aircraft, IBM Corp., Intel Corp., and\n   Metricom.  The views\
    \ and conclusions contained here are those of the\n   authors and should not be\
    \ interpreted as necessarily representing the\n   official policies or endorsements,\
    \ either express or implied, of\n   AFMC, ARPA, AT&T, Hughes, IBM, Intel, Metricom,\
    \ Carnegie Mellon\n   University, the University of California, the State of California,\
    \ or\n   the U.S. Government.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   This RFC raises no security considerations.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Questions about this document can be directed to the authors:\n\
    \   Brian D. Noble\n   Computer Science Department\n   Carnegie Mellon University\n\
    \   5000 Forbes Avenue\n   Pittsburgh, PA  15213-3891\n   Phone:  +1-412-268-7399\n\
    \   Fax:    +1-412-268-5576\n   EMail: bnoble@cs.cmu.edu\n   Giao T. Nguyen\n\
    \   Room 473 Soda Hall #1776 (Research Office)\n   University of California, Berkeley\n\
    \   Berkeley, CA  94720-1776\n   Phone:  +1-510-642-8919\n   Fax:    +1-510-642-5775\n\
    \   EMail: gnguyen@cs.berkeley.edu\n   Mahadev Satyanarayanan\n   Computer Science\
    \ Department\n   Carnegie Mellon University\n   5000 Forbes Avenue\n   Pittsburgh,\
    \ PA  15213-3891\n   Phone:  +1-412-268-3743\n   Fax:    +1-412-268-5576\n   EMail:\
    \ satya@cs.cmu.edu\n   Randy H. Katz\n   Room 231 Soda Hall #1770 (Administrative\
    \ Office)\n   University of California, Berkeley\n   Berkeley, CA  94720-1770\n\
    \   Phone:  +1-510-642-0253\n   Fax:    +1-510-642-2845\n   EMail: randy@cs.berkeley.edu\n"
- title: References
  contents:
  - "References\n    [1] Chen, J. B., and Bershad, B. N.  The Impact of Operating\
    \ System\n        Structure on Memory System Performance.  In Proceedings of the\n\
    \        14th ACM Symposium on Operating System Principles (Asheville,\n     \
    \   NC, December 1993).\n    [2] Dahlin, M., Mather, C., Wang, R., Anderson, T.,\
    \ and Patterson,\n        D.  A Quantitative Analysis of Cache Policies for Scalable\n\
    \        Network File Systems.  In Proceedings of the 1994 ACM SIGMETRICS\n  \
    \      Conference on Measurement and Modeling of Computer Systems\n        (Nashville,\
    \ TN, May 1994).\n    [3] Davies, N., Blair, G. S., Cheverst, K., and Friday,\
    \ A.  A\n        Network Emulator to Support the Development of Adaptive\n   \
    \     Applications.  In Proceedings of the 2nd USENIX Symposium on\n        Mobile\
    \ and Location Independent Computing (April 10-11 1995).\n    [4] Dawson, S.,\
    \ and Jahanian, F.  Probing and Fault Injection of\n        Dependable Distributed\
    \ Protocols.  The Computer Jouranl 38, 4\n        (1995).\n    [5] Gloy, N., Young,\
    \ C., Chen, J. B., and Smith, M. D.  An Analysis\n        of Dynamic Branch Prediction\
    \ Schemes on System Workloads.  In\n        The Proceedings of the 23rd Annual\
    \ International Symposium on\n        Computer Architecture (May 1996).\n    [6]\
    \ Ingham, D. B., and Parrington, G. D.  Delayline:  A Wide-Area\n        Network\
    \ Emulation Tool.  Computing Systems 7, 3 (1994).\n    [7] Jacobson, V., Leres,\
    \ C., and McCanne, S.  The Tcpdump Manual\n        Page.  Lawrence Berkeley Laboratory,\
    \ Berkeley, CA.\n    [8] McCanne, S., and Jacobson, V.  The BSD Packet Filter:\
    \  A New\n        Architecture for User-level Packet Capture.  In Proceedings\
    \ of\n        the 1993 Winter USENIX Technical Conference (San Deigo, CA,\n  \
    \      January 1993).\n    [9] Mills, D. L.  Improved Algorithms for Synchronizing\
    \ Computer\n        Network Clocks.  IEEE/ACM Transactions on Networking 3, 3\
    \ (June\n        1995).\n   [10] Mummert, L. B., Ebling, M. R., and Satyanarayanan,\
    \ M.\n        Exploiting Weak Connectivity for Mobile File Access.  In\n     \
    \   Proceedings of the 15th Symposium on Operating System Prinicples\n       \
    \ (Copper Mountain, CO, December 1995).\n   [11] Nelson, M. N., Welch, B. B.,\
    \ and Ousterhout, J. K.  Caching in\n        the Sprite Network File System. \
    \ ACM Transactions on Computer\n        Systems 6, 1 (February 1988).\n   [12]\
    \ Schilit, B., Adams, N., Gold, R., Tso, M., and Want, R.  The\n        PARCTAB\
    \ Mobile Computing System.  In Proceedings of the 4th IEEE\n        Workshop on\
    \ Workstation Operating Systems (Napa, CA, October\n        1993), pp. 34--39.\n\
    \   [13] Uhlig, R., Nagle, D., Stanley, T., Mudge, T., Sechrest, S., and\n   \
    \     Brown, R.  Design Tradeoffs for Software-Managed TLBs.  ACM\n        Transactions\
    \ on Computer Systems 12, 3 (August 1994).\n   [14] Want, R., Hopper, A., Falcao,\
    \ V., and Gibbons, J.  The Active\n        Badge Location System.  ACM Transactions\
    \ on Information Systems\n        10, 1 (January 1992), 91--102.\n"
