- title: __initial_text__
  contents:
  - "                 Multipurpose Internet Mail Extensions\n                    \
    \        (MIME) Part One:\n                   Format of Internet Message Bodies\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   STD 11, RFC 822, defines a message representation protocol specifying\n\
    \   considerable detail about US-ASCII message headers, and leaves the\n   message\
    \ content, or message body, as flat US-ASCII text.  This set of\n   documents,\
    \ collectively called the Multipurpose Internet Mail\n   Extensions, or MIME,\
    \ redefines the format of messages to allow for\n    (1)   textual message bodies\
    \ in character sets other than\n          US-ASCII,\n    (2)   an extensible set\
    \ of different formats for non-textual\n          message bodies,\n    (3)   multi-part\
    \ message bodies, and\n    (4)   textual header information in character sets\
    \ other than\n          US-ASCII.\n   These documents are based on earlier work\
    \ documented in RFC 934, STD\n   11, and RFC 1049, but extends and revises them.\
    \  Because RFC 822 said\n   so little about message bodies, these documents are\
    \ largely\n   orthogonal to (rather than a revision of) RFC 822.\n   This initial\
    \ document specifies the various headers used to describe\n   the structure of\
    \ MIME messages. The second document, RFC 2046,\n   defines the general structure\
    \ of the MIME media typing system and\n   defines an initial set of media types.\
    \ The third document, RFC 2047,\n   describes extensions to RFC 822 to allow non-US-ASCII\
    \ text data in\n   Internet mail header fields. The fourth document, RFC 2048,\
    \ specifies\n   various IANA registration procedures for MIME-related facilities.\
    \ The\n   fifth and final document, RFC 2049, describes MIME conformance\n   criteria\
    \ as well as providing some illustrative examples of MIME\n   message formats,\
    \ acknowledgements, and the bibliography.\n   These documents are revisions of\
    \ RFCs 1521, 1522, and 1590, which\n   themselves were revisions of RFCs 1341\
    \ and 1342.  An appendix in RFC\n   2049 describes differences and changes from\
    \ previous versions.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction .........................................\
    \    3\n   2. Definitions, Conventions, and Generic BNF Grammar ....    5\n  \
    \ 2.1 CRLF ................................................    5\n   2.2 Character\
    \ Set .......................................    6\n   2.3 Message .............................................\
    \    6\n   2.4 Entity ..............................................    6\n  \
    \ 2.5 Body Part ...........................................    7\n   2.6 Body\
    \ ................................................    7\n   2.7 7bit Data ...........................................\
    \    7\n   2.8 8bit Data ...........................................    7\n  \
    \ 2.9 Binary Data .........................................    7\n   2.10 Lines\
    \ ..............................................    7\n   3. MIME Header Fields\
    \ ...................................    8\n   4. MIME-Version Header Field ............................\
    \    8\n   5. Content-Type Header Field ............................   10\n  \
    \ 5.1 Syntax of the Content-Type Header Field .............   12\n   5.2 Content-Type\
    \ Defaults ...............................   14\n   6. Content-Transfer-Encoding\
    \ Header Field ...............   14\n   6.1 Content-Transfer-Encoding Syntax ....................\
    \   14\n   6.2 Content-Transfer-Encodings Semantics ................   15\n  \
    \ 6.3 New Content-Transfer-Encodings ......................   16\n   6.4 Interpretation\
    \ and Use ..............................   16\n   6.5 Translating Encodings ...............................\
    \   18\n   6.6 Canonical Encoding Model ............................   19\n  \
    \ 6.7 Quoted-Printable Content-Transfer-Encoding ..........   19\n   6.8 Base64\
    \ Content-Transfer-Encoding ....................   24\n   7. Content-ID Header\
    \ Field ..............................   26\n   8. Content-Description Header\
    \ Field .....................   27\n   9. Additional MIME Header Fields ........................\
    \   27\n   10. Summary .............................................   27\n  \
    \ 11. Security Considerations .............................   27\n   12. Authors'\
    \ Addresses ..................................   28\n   A. Collected Grammar ....................................\
    \   29\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Since its publication in 1982, RFC 822 has defined the standard\n\
    \   format of textual mail messages on the Internet.  Its success has\n   been\
    \ such that the RFC 822 format has been adopted, wholly or\n   partially, well\
    \ beyond the confines of the Internet and the Internet\n   SMTP transport defined\
    \ by RFC 821.  As the format has seen wider use,\n   a number of limitations have\
    \ proven increasingly restrictive for the\n   user community.\n   RFC 822 was\
    \ intended to specify a format for text messages.  As such,\n   non-text messages,\
    \ such as multimedia messages that might include\n   audio or images, are simply\
    \ not mentioned.  Even in the case of text,\n   however, RFC 822 is inadequate\
    \ for the needs of mail users whose\n   languages require the use of character\
    \ sets richer than US-ASCII.\n   Since RFC 822 does not specify mechanisms for\
    \ mail containing audio,\n   video, Asian language text, or even text in most\
    \ European languages,\n   additional specifications are needed.\n   One of the\
    \ notable limitations of RFC 821/822 based mail systems is\n   the fact that they\
    \ limit the contents of electronic mail messages to\n   relatively short lines\
    \ (e.g. 1000 characters or less [RFC-821]) of\n   7bit US-ASCII.  This forces\
    \ users to convert any non-textual data\n   that they may wish to send into seven-bit\
    \ bytes representable as\n   printable US-ASCII characters before invoking a local\
    \ mail UA (User\n   Agent, a program with which human users send and receive mail).\n\
    \   Examples of such encodings currently used in the Internet include\n   pure\
    \ hexadecimal, uuencode, the 3-in-4 base 64 scheme specified in\n   RFC 1421,\
    \ the Andrew Toolkit Representation [ATK], and many others.\n   The limitations\
    \ of RFC 822 mail become even more apparent as gateways\n   are designed to allow\
    \ for the exchange of mail messages between RFC\n   822 hosts and X.400 hosts.\
    \  X.400 [X400] specifies mechanisms for the\n   inclusion of non-textual material\
    \ within electronic mail messages.\n   The current standards for the mapping of\
    \ X.400 messages to RFC 822\n   messages specify either that X.400 non-textual\
    \ material must be\n   converted to (not encoded in) IA5Text format, or that they\
    \ must be\n   discarded, notifying the RFC 822 user that discarding has occurred.\n\
    \   This is clearly undesirable, as information that a user may wish to\n   receive\
    \ is lost.  Even though a user agent may not have the\n   capability of dealing\
    \ with the non-textual material, the user might\n   have some mechanism external\
    \ to the UA that can extract useful\n   information from the material.  Moreover,\
    \ it does not allow for the\n   fact that the message may eventually be gatewayed\
    \ back into an X.400\n   message handling system (i.e., the X.400 message is \"\
    tunneled\"\n   through Internet mail), where the non-textual information would\n\
    \   definitely become useful again.\n   This document describes several mechanisms\
    \ that combine to solve most\n   of these problems without introducing any serious\
    \ incompatibilities\n   with the existing world of RFC 822 mail.  In particular,\
    \ it\n   describes:\n    (1)   A MIME-Version header field, which uses a version\n\
    \          number to declare a message to be conformant with MIME\n          and\
    \ allows mail processing agents to distinguish\n          between such messages\
    \ and those generated by older or\n          non-conformant software, which are\
    \ presumed to lack\n          such a field.\n    (2)   A Content-Type header field,\
    \ generalized from RFC 1049,\n          which can be used to specify the media\
    \ type and subtype\n          of data in the body of a message and to fully specify\n\
    \          the native representation (canonical form) of such\n          data.\n\
    \    (3)   A Content-Transfer-Encoding header field, which can be\n          used\
    \ to specify both the encoding transformation that\n          was applied to the\
    \ body and the domain of the result.\n          Encoding transformations other\
    \ than the identity\n          transformation are usually applied to data in order\
    \ to\n          allow it to pass through mail transport mechanisms\n         \
    \ which may have data or character set limitations.\n    (4)   Two additional\
    \ header fields that can be used to\n          further describe the data in a\
    \ body, the Content-ID and\n          Content-Description header fields.\n   All\
    \ of the header fields defined in this document are subject to the\n   general\
    \ syntactic rules for header fields specified in RFC 822.  In\n   particular,\
    \ all of these header fields except for Content-Disposition\n   can include RFC\
    \ 822 comments, which have no semantic content and\n   should be ignored during\
    \ MIME processing.\n   Finally, to specify and promote interoperability, RFC 2049\
    \ provides a\n   basic applicability statement for a subset of the above mechanisms\n\
    \   that defines a minimal level of \"conformance\" with this document.\n   HISTORICAL\
    \ NOTE:  Several of the mechanisms described in this set of\n   documents may\
    \ seem somewhat strange or even baroque at first reading.\n   It is important\
    \ to note that compatibility with existing standards\n   AND robustness across\
    \ existing practice were two of the highest\n   priorities of the working group\
    \ that developed this set of documents.\n   In particular, compatibility was always\
    \ favored over elegance.\n   Please refer to the current edition of the \"Internet\
    \ Official\n   Protocol Standards\" for the standardization state and status of\
    \ this\n   protocol.  RFC 822 and STD 3, RFC 1123 also provide essential\n   background\
    \ for MIME since no conforming implementation of MIME can\n   violate them.  In\
    \ addition, several other informational RFC documents\n   will be of interest\
    \ to the MIME implementor, in particular RFC 1344,\n   RFC 1345, and RFC 1524.\n"
- title: 2.  Definitions, Conventions, and Generic BNF Grammar
  contents:
  - "2.  Definitions, Conventions, and Generic BNF Grammar\n   Although the mechanisms\
    \ specified in this set of documents are all\n   described in prose, most are\
    \ also described formally in the augmented\n   BNF notation of RFC 822. Implementors\
    \ will need to be familiar with\n   this notation in order to understand this\
    \ set of documents, and are\n   referred to RFC 822 for a complete explanation\
    \ of the augmented BNF\n   notation.\n   Some of the augmented BNF in this set\
    \ of documents makes named\n   references to syntax rules defined in RFC 822.\
    \  A complete formal\n   grammar, then, is obtained by combining the collected\
    \ grammar\n   appendices in each document in this set with the BNF of RFC 822\
    \ plus\n   the modifications to RFC 822 defined in RFC 1123 (which specifically\n\
    \   changes the syntax for `return', `date' and `mailbox').\n   All numeric and\
    \ octet values are given in decimal notation in this\n   set of documents. All\
    \ media type values, subtype values, and\n   parameter names as defined are case-insensitive.\
    \  However, parameter\n   values are case-sensitive unless otherwise specified\
    \ for the specific\n   parameter.\n   FORMATTING NOTE:  Notes, such at this one,\
    \ provide additional\n   nonessential information which may be skipped by the\
    \ reader without\n   missing anything essential.  The primary purpose of these\
    \ non-\n   essential notes is to convey information about the rationale of this\n\
    \   set of documents, or to place these documents in the proper\n   historical\
    \ or evolutionary context.  Such information may in\n   particular be skipped\
    \ by those who are focused entirely on building a\n   conformant implementation,\
    \ but may be of use to those who wish to\n   understand why certain design choices\
    \ were made.\n"
- title: 2.1.  CRLF
  contents:
  - "2.1.  CRLF\n   The term CRLF, in this set of documents, refers to the sequence\
    \ of\n   octets corresponding to the two US-ASCII characters CR (decimal value\n\
    \   13) and LF (decimal value 10) which, taken together, in this order,\n   denote\
    \ a line break in RFC 822 mail.\n"
- title: 2.2.  Character Set
  contents:
  - "2.2.  Character Set\n   The term \"character set\" is used in MIME to refer to\
    \ a method of\n   converting a sequence of octets into a sequence of characters.\
    \  Note\n   that unconditional and unambiguous conversion in the other direction\n\
    \   is not required, in that not all characters may be representable by a\n  \
    \ given character set and a character set may provide more than one\n   sequence\
    \ of octets to represent a particular sequence of characters.\n   This definition\
    \ is intended to allow various kinds of character\n   encodings, from simple single-table\
    \ mappings such as US-ASCII to\n   complex table switching methods such as those\
    \ that use ISO 2022's\n   techniques, to be used as character sets.  However,\
    \ the definition\n   associated with a MIME character set name must fully specify\
    \ the\n   mapping to be performed.  In particular, use of external profiling\n\
    \   information to determine the exact mapping is not permitted.\n   NOTE: The\
    \ term \"character set\" was originally to describe such\n   straightforward schemes\
    \ as US-ASCII and ISO-8859-1 which have a\n   simple one-to-one mapping from single\
    \ octets to single characters.\n   Multi-octet coded character sets and switching\
    \ techniques make the\n   situation more complex. For example, some communities\
    \ use the term\n   \"character encoding\" for what MIME calls a \"character set\"\
    , while\n   using the phrase \"coded character set\" to denote an abstract mapping\n\
    \   from integers (not octets) to characters.\n"
- title: 2.3.  Message
  contents:
  - "2.3.  Message\n   The term \"message\", when not further qualified, means either\
    \ a\n   (complete or \"top-level\") RFC 822 message being transferred on a\n \
    \  network, or a message encapsulated in a body of type \"message/rfc822\"\n \
    \  or \"message/partial\".\n"
- title: 2.4.  Entity
  contents:
  - "2.4.  Entity\n   The term \"entity\", refers specifically to the MIME-defined\
    \ header\n   fields and contents of either a message or one of the parts in the\n\
    \   body of a multipart entity.  The specification of such entities is\n   the\
    \ essence of MIME.  Since the contents of an entity are often\n   called the \"\
    body\", it makes sense to speak about the body of an\n   entity.  Any sort of\
    \ field may be present in the header of an entity,\n   but only those fields whose\
    \ names begin with \"content-\" actually have\n   any MIME-related meaning.  Note\
    \ that this does NOT imply thay they\n   have no meaning at all -- an entity that\
    \ is also a message has non-\n   MIME header fields whose meanings are defined\
    \ by RFC 822.\n"
- title: 2.5.  Body Part
  contents:
  - "2.5.  Body Part\n   The term \"body part\" refers to an entity inside of a multipart\n\
    \   entity.\n"
- title: 2.6.  Body
  contents:
  - "2.6.  Body\n   The term \"body\", when not further qualified, means the body\
    \ of an\n   entity, that is, the body of either a message or of a body part.\n\
    \   NOTE:  The previous four definitions are clearly circular.  This is\n   unavoidable,\
    \ since the overall structure of a MIME message is indeed\n   recursive.\n"
- title: 2.7.  7bit Data
  contents:
  - "2.7.  7bit Data\n   \"7bit data\" refers to data that is all represented as relatively\n\
    \   short lines with 998 octets or less between CRLF line separation\n   sequences\
    \ [RFC-821].  No octets with decimal values greater than 127\n   are allowed and\
    \ neither are NULs (octets with decimal value 0).  CR\n   (decimal value 13) and\
    \ LF (decimal value 10) octets only occur as\n   part of CRLF line separation\
    \ sequences.\n"
- title: 2.8.  8bit Data
  contents:
  - "2.8.  8bit Data\n   \"8bit data\" refers to data that is all represented as relatively\n\
    \   short lines with 998 octets or less between CRLF line separation\n   sequences\
    \ [RFC-821]), but octets with decimal values greater than 127\n   may be used.\
    \  As with \"7bit data\" CR and LF octets only occur as part\n   of CRLF line\
    \ separation sequences and no NULs are allowed.\n"
- title: 2.9.  Binary Data
  contents:
  - "2.9.  Binary Data\n   \"Binary data\" refers to data where any sequence of octets\
    \ whatsoever\n   is allowed.\n"
- title: 2.10.  Lines
  contents:
  - "2.10.  Lines\n   \"Lines\" are defined as sequences of octets separated by a\
    \ CRLF\n   sequences.  This is consistent with both RFC 821 and RFC 822.\n   \"\
    Lines\" only refers to a unit of data in a message, which may or may\n   not correspond\
    \ to something that is actually displayed by a user\n   agent.\n"
- title: 3.  MIME Header Fields
  contents:
  - "3.  MIME Header Fields\n   MIME defines a number of new RFC 822 header fields\
    \ that are used to\n   describe the content of a MIME entity.  These header fields\
    \ occur in\n   at least two contexts:\n    (1)   As part of a regular RFC 822\
    \ message header.\n    (2)   In a MIME body part header within a multipart\n \
    \         construct.\n   The formal definition of these header fields is as follows:\n\
    \     entity-headers := [ content CRLF ]\n                       [ encoding CRLF\
    \ ]\n                       [ id CRLF ]\n                       [ description\
    \ CRLF ]\n                       *( MIME-extension-field CRLF )\n     MIME-message-headers\
    \ := entity-headers\n                             fields\n                   \
    \          version CRLF\n                             ; The ordering of the header\n\
    \                             ; fields implied by this BNF\n                 \
    \            ; definition should be ignored.\n     MIME-part-headers := entity-headers\n\
    \                          [ fields ]\n                          ; Any field not\
    \ beginning with\n                          ; \"content-\" can have no defined\n\
    \                          ; meaning and may be ignored.\n                   \
    \       ; The ordering of the header\n                          ; fields implied\
    \ by this BNF\n                          ; definition should be ignored.\n   The\
    \ syntax of the various specific MIME header fields will be\n   described in the\
    \ following sections.\n"
- title: 4.  MIME-Version Header Field
  contents:
  - "4.  MIME-Version Header Field\n   Since RFC 822 was published in 1982, there\
    \ has really been only one\n   format standard for Internet messages, and there\
    \ has been little\n   perceived need to declare the format standard in use.  This\
    \ document\n   is an independent specification that complements RFC 822.  Although\n\
    \   the extensions in this document have been defined in such a way as to\n  \
    \ be compatible with RFC 822, there are still circumstances in which it\n   might\
    \ be desirable for a mail-processing agent to know whether a\n   message was composed\
    \ with the new standard in mind.\n   Therefore, this document defines a new header\
    \ field, \"MIME-Version\",\n   which is to be used to declare the version of the\
    \ Internet message\n   body format standard in use.\n   Messages composed in accordance\
    \ with this document MUST include such\n   a header field, with the following\
    \ verbatim text:\n     MIME-Version: 1.0\n   The presence of this header field\
    \ is an assertion that the message\n   has been composed in compliance with this\
    \ document.\n   Since it is possible that a future document might extend the message\n\
    \   format standard again, a formal BNF is given for the content of the\n   MIME-Version\
    \ field:\n     version := \"MIME-Version\" \":\" 1*DIGIT \".\" 1*DIGIT\n   Thus,\
    \ future format specifiers, which might replace or extend \"1.0\",\n   are constrained\
    \ to be two integer fields, separated by a period.  If\n   a message is received\
    \ with a MIME-version value other than \"1.0\", it\n   cannot be assumed to conform\
    \ with this document.\n   Note that the MIME-Version header field is required\
    \ at the top level\n   of a message.  It is not required for each body part of\
    \ a multipart\n   entity.  It is required for the embedded headers of a body of\
    \ type\n   \"message/rfc822\" or \"message/partial\" if and only if the embedded\n\
    \   message is itself claimed to be MIME-conformant.\n   It is not possible to\
    \ fully specify how a mail reader that conforms\n   with MIME as defined in this\
    \ document should treat a message that\n   might arrive in the future with some\
    \ value of MIME-Version other than\n   \"1.0\".\n   It is also worth noting that\
    \ version control for specific media types\n   is not accomplished using the MIME-Version\
    \ mechanism.  In particular,\n   some formats (such as application/postscript)\
    \ have version numbering\n   conventions that are internal to the media format.\
    \  Where such\n   conventions exist, MIME does nothing to supersede them.  Where\
    \ no\n   such conventions exist, a MIME media type might use a \"version\"\n \
    \  parameter in the content-type field if necessary.\n   NOTE TO IMPLEMENTORS:\
    \  When checking MIME-Version values any RFC 822\n   comment strings that are\
    \ present must be ignored.  In particular, the\n   following four MIME-Version\
    \ fields are equivalent:\n     MIME-Version: 1.0\n     MIME-Version: 1.0 (produced\
    \ by MetaSend Vx.x)\n     MIME-Version: (produced by MetaSend Vx.x) 1.0\n    \
    \ MIME-Version: 1.(produced by MetaSend Vx.x)0\n   In the absence of a MIME-Version\
    \ field, a receiving mail user agent\n   (whether conforming to MIME requirements\
    \ or not) may optionally\n   choose to interpret the body of the message according\
    \ to local\n   conventions.  Many such conventions are currently in use and it\n\
    \   should be noted that in practice non-MIME messages can contain just\n   about\
    \ anything.\n   It is impossible to be certain that a non-MIME mail message is\n\
    \   actually plain text in the US-ASCII character set since it might well\n  \
    \ be a message that, using some set of nonstandard local conventions\n   that\
    \ predate MIME, includes text in another character set or non-\n   textual data\
    \ presented in a manner that cannot be automatically\n   recognized (e.g., a uuencoded\
    \ compressed UNIX tar file).\n"
- title: 5.  Content-Type Header Field
  contents:
  - "5.  Content-Type Header Field\n   The purpose of the Content-Type field is to\
    \ describe the data\n   contained in the body fully enough that the receiving\
    \ user agent can\n   pick an appropriate agent or mechanism to present the data\
    \ to the\n   user, or otherwise deal with the data in an appropriate manner. The\n\
    \   value in this field is called a media type.\n   HISTORICAL NOTE:  The Content-Type\
    \ header field was first defined in\n   RFC 1049.  RFC 1049 used a simpler and\
    \ less powerful syntax, but one\n   that is largely compatible with the mechanism\
    \ given here.\n   The Content-Type header field specifies the nature of the data\
    \ in the\n   body of an entity by giving media type and subtype identifiers, and\n\
    \   by providing auxiliary information that may be required for certain\n   media\
    \ types.  After the media type and subtype names, the remainder\n   of the header\
    \ field is simply a set of parameters, specified in an\n   attribute=value notation.\
    \  The ordering of parameters is not\n   significant.\n   In general, the top-level\
    \ media type is used to declare the general\n   type of data, while the subtype\
    \ specifies a specific format for that\n   type of data.  Thus, a media type of\
    \ \"image/xyz\" is enough to tell a\n   user agent that the data is an image,\
    \ even if the user agent has no\n   knowledge of the specific image format \"\
    xyz\".  Such information can\n   be used, for example, to decide whether or not\
    \ to show a user the raw\n   data from an unrecognized subtype -- such an action\
    \ might be\n   reasonable for unrecognized subtypes of text, but not for\n   unrecognized\
    \ subtypes of image or audio.  For this reason, registered\n   subtypes of text,\
    \ image, audio, and video should not contain embedded\n   information that is\
    \ really of a different type.  Such compound\n   formats should be represented\
    \ using the \"multipart\" or \"application\"\n   types.\n   Parameters are modifiers\
    \ of the media subtype, and as such do not\n   fundamentally affect the nature\
    \ of the content.  The set of\n   meaningful parameters depends on the media type\
    \ and subtype.  Most\n   parameters are associated with a single specific subtype.\
    \  However, a\n   given top-level media type may define parameters which are applicable\n\
    \   to any subtype of that type.  Parameters may be required by their\n   defining\
    \ content type or subtype or they may be optional. MIME\n   implementations must\
    \ ignore any parameters whose names they do not\n   recognize.\n   For example,\
    \ the \"charset\" parameter is applicable to any subtype of\n   \"text\", while\
    \ the \"boundary\" parameter is required for any subtype of\n   the \"multipart\"\
    \ media type.\n   There are NO globally-meaningful parameters that apply to all\
    \ media\n   types.  Truly global mechanisms are best addressed, in the MIME\n\
    \   model, by the definition of additional Content-* header fields.\n   An initial\
    \ set of seven top-level media types is defined in RFC 2046.\n   Five of these\
    \ are discrete types whose content is essentially opaque\n   as far as MIME processing\
    \ is concerned.  The remaining two are\n   composite types whose contents require\
    \ additional handling by MIME\n   processors.\n   This set of top-level media\
    \ types is intended to be substantially\n   complete.  It is expected that additions\
    \ to the larger set of\n   supported types can generally be accomplished by the\
    \ creation of new\n   subtypes of these initial types.  In the future, more top-level\
    \ types\n   may be defined only by a standards-track extension to this standard.\n\
    \   If another top-level type is to be used for any reason, it must be\n   given\
    \ a name starting with \"X-\" to indicate its non-standard status\n   and to avoid\
    \ a potential conflict with a future official name.\n"
- title: 5.1.  Syntax of the Content-Type Header Field
  contents:
  - "5.1.  Syntax of the Content-Type Header Field\n   In the Augmented BNF notation\
    \ of RFC 822, a Content-Type header field\n   value is defined as follows:\n \
    \    content := \"Content-Type\" \":\" type \"/\" subtype\n                *(\"\
    ;\" parameter)\n                ; Matching of media type and subtype\n       \
    \         ; is ALWAYS case-insensitive.\n     type := discrete-type / composite-type\n\
    \     discrete-type := \"text\" / \"image\" / \"audio\" / \"video\" /\n      \
    \                \"application\" / extension-token\n     composite-type := \"\
    message\" / \"multipart\" / extension-token\n     extension-token := ietf-token\
    \ / x-token\n     ietf-token := <An extension token defined by a\n           \
    \         standards-track RFC and registered\n                    with IANA.>\n\
    \     x-token := <The two characters \"X-\" or \"x-\" followed, with\n       \
    \          no intervening white space, by any token>\n     subtype := extension-token\
    \ / iana-token\n     iana-token := <A publicly-defined extension token. Tokens\n\
    \                    of this form must be registered with IANA\n             \
    \       as specified in RFC 2048.>\n     parameter := attribute \"=\" value\n\
    \     attribute := token\n                  ; Matching of attributes\n       \
    \           ; is ALWAYS case-insensitive.\n     value := token / quoted-string\n\
    \     token := 1*<any (US-ASCII) CHAR except SPACE, CTLs,\n                 or\
    \ tspecials>\n     tspecials :=  \"(\" / \")\" / \"<\" / \">\" / \"@\" /\n   \
    \                \",\" / \";\" / \":\" / \"\\\" / <\">\n                   \"\
    /\" / \"[\" / \"]\" / \"?\" / \"=\"\n                   ; Must be in quoted-string,\n\
    \                   ; to use within parameter values\n   Note that the definition\
    \ of \"tspecials\" is the same as the RFC 822\n   definition of \"specials\" with\
    \ the addition of the three characters\n   \"/\", \"?\", and \"=\", and the removal\
    \ of \".\".\n   Note also that a subtype specification is MANDATORY -- it may\
    \ not be\n   omitted from a Content-Type header field.  As such, there are no\n\
    \   default subtypes.\n   The type, subtype, and parameter names are not case\
    \ sensitive.  For\n   example, TEXT, Text, and TeXt are all equivalent top-level\
    \ media\n   types.  Parameter values are normally case sensitive, but sometimes\n\
    \   are interpreted in a case-insensitive fashion, depending on the\n   intended\
    \ use.  (For example, multipart boundaries are case-sensitive,\n   but the \"\
    access-type\" parameter for message/External-body is not\n   case-sensitive.)\n\
    \   Note that the value of a quoted string parameter does not include the\n  \
    \ quotes.  That is, the quotation marks in a quoted-string are not a\n   part\
    \ of the value of the parameter, but are merely used to delimit\n   that parameter\
    \ value.  In addition, comments are allowed in\n   accordance with RFC 822 rules\
    \ for structured header fields.  Thus the\n   following two forms\n     Content-type:\
    \ text/plain; charset=us-ascii (Plain text)\n     Content-type: text/plain; charset=\"\
    us-ascii\"\n   are completely equivalent.\n   Beyond this syntax, the only syntactic\
    \ constraint on the definition\n   of subtype names is the desire that their uses\
    \ must not conflict.\n   That is, it would be undesirable to have two different\
    \ communities\n   using \"Content-Type: application/foobar\" to mean two different\n\
    \   things.  The process of defining new media subtypes, then, is not\n   intended\
    \ to be a mechanism for imposing restrictions, but simply a\n   mechanism for\
    \ publicizing their definition and usage.  There are,\n   therefore, two acceptable\
    \ mechanisms for defining new media subtypes:\n    (1)   Private values (starting\
    \ with \"X-\") may be defined\n          bilaterally between two cooperating agents\
    \ without\n          outside registration or standardization. Such values\n  \
    \        cannot be registered or standardized.\n    (2)   New standard values\
    \ should be registered with IANA as\n          described in RFC 2048.\n   The\
    \ second document in this set, RFC 2046, defines the initial set of\n   media\
    \ types for MIME.\n"
- title: 5.2.  Content-Type Defaults
  contents:
  - "5.2.  Content-Type Defaults\n   Default RFC 822 messages without a MIME Content-Type\
    \ header are taken\n   by this protocol to be plain text in the US-ASCII character\
    \ set,\n   which can be explicitly specified as:\n     Content-type: text/plain;\
    \ charset=us-ascii\n   This default is assumed if no Content-Type header field\
    \ is specified.\n   It is also recommend that this default be assumed when a\n\
    \   syntactically invalid Content-Type header field is encountered. In\n   the\
    \ presence of a MIME-Version header field and the absence of any\n   Content-Type\
    \ header field, a receiving User Agent can also assume\n   that plain US-ASCII\
    \ text was the sender's intent.  Plain US-ASCII\n   text may still be assumed\
    \ in the absence of a MIME-Version or the\n   presence of an syntactically invalid\
    \ Content-Type header field, but\n   the sender's intent might have been otherwise.\n"
- title: 6.  Content-Transfer-Encoding Header Field
  contents:
  - "6.  Content-Transfer-Encoding Header Field\n   Many media types which could be\
    \ usefully transported via email are\n   represented, in their \"natural\" format,\
    \ as 8bit character or binary\n   data.  Such data cannot be transmitted over\
    \ some transfer protocols.\n   For example, RFC 821 (SMTP) restricts mail messages\
    \ to 7bit US-ASCII\n   data with lines no longer than 1000 characters including\
    \ any trailing\n   CRLF line separator.\n   It is necessary, therefore, to define\
    \ a standard mechanism for\n   encoding such data into a 7bit short line format.\
    \  Proper labelling\n   of unencoded material in less restrictive formats for\
    \ direct use over\n   less restrictive transports is also desireable.  This document\n\
    \   specifies that such encodings will be indicated by a new \"Content-\n   Transfer-Encoding\"\
    \ header field.  This field has not been defined by\n   any previous standard.\n"
- title: 6.1.  Content-Transfer-Encoding Syntax
  contents:
  - "6.1.  Content-Transfer-Encoding Syntax\n   The Content-Transfer-Encoding field's\
    \ value is a single token\n   specifying the type of encoding, as enumerated below.\
    \  Formally:\n     encoding := \"Content-Transfer-Encoding\" \":\" mechanism\n\
    \     mechanism := \"7bit\" / \"8bit\" / \"binary\" /\n                  \"quoted-printable\"\
    \ / \"base64\" /\n                  ietf-token / x-token\n   These values are\
    \ not case sensitive -- Base64 and BASE64 and bAsE64\n   are all equivalent. \
    \ An encoding type of 7BIT requires that the body\n   is already in a 7bit mail-ready\
    \ representation.  This is the default\n   value -- that is, \"Content-Transfer-Encoding:\
    \ 7BIT\" is assumed if the\n   Content-Transfer-Encoding header field is not present.\n"
- title: 6.2.  Content-Transfer-Encodings Semantics
  contents:
  - "6.2.  Content-Transfer-Encodings Semantics\n   This single Content-Transfer-Encoding\
    \ token actually provides two\n   pieces of information.  It specifies what sort\
    \ of encoding\n   transformation the body was subjected to and hence what decoding\n\
    \   operation must be used to restore it to its original form, and it\n   specifies\
    \ what the domain of the result is.\n   The transformation part of any Content-Transfer-Encodings\
    \ specifies,\n   either explicitly or implicitly, a single, well-defined decoding\n\
    \   algorithm, which for any sequence of encoded octets either transforms\n  \
    \ it to the original sequence of octets which was encoded, or shows\n   that it\
    \ is illegal as an encoded sequence.  Content-Transfer-\n   Encodings transformations\
    \ never depend on any additional external\n   profile information for proper operation.\
    \ Note that while decoders\n   must produce a single, well-defined output for\
    \ a valid encoding no\n   such restrictions exist for encoders: Encoding a given\
    \ sequence of\n   octets to different, equivalent encoded sequences is perfectly\
    \ legal.\n   Three transformations are currently defined: identity, the \"quoted-\n\
    \   printable\" encoding, and the \"base64\" encoding.  The domains are\n   \"\
    binary\", \"8bit\" and \"7bit\".\n   The Content-Transfer-Encoding values \"7bit\"\
    , \"8bit\", and \"binary\" all\n   mean that the identity (i.e. NO) encoding transformation\
    \ has been\n   performed.  As such, they serve simply as indicators of the domain\
    \ of\n   the body data, and provide useful information about the sort of\n   encoding\
    \ that might be needed for transmission in a given transport\n   system.  The\
    \ terms \"7bit data\", \"8bit data\", and \"binary data\" are\n   all defined\
    \ in Section 2.\n   The quoted-printable and base64 encodings transform their\
    \ input from\n   an arbitrary domain into material in the \"7bit\" range, thus\
    \ making it\n   safe to carry over restricted transports.  The specific definition\
    \ of\n   the transformations are given below.\n   The proper Content-Transfer-Encoding\
    \ label must always be used.\n   Labelling unencoded data containing 8bit characters\
    \ as \"7bit\" is not\n   allowed, nor is labelling unencoded non-line-oriented\
    \ data as\n   anything other than \"binary\" allowed.\n   Unlike media subtypes,\
    \ a proliferation of Content-Transfer-Encoding\n   values is both undesirable\
    \ and unnecessary.  However, establishing\n   only a single transformation into\
    \ the \"7bit\" domain does not seem\n   possible.  There is a tradeoff between\
    \ the desire for a compact and\n   efficient encoding of largely- binary data\
    \ and the desire for a\n   somewhat readable encoding of data that is mostly,\
    \ but not entirely,\n   7bit.  For this reason, at least two encoding mechanisms\
    \ are\n   necessary: a more or less readable encoding (quoted-printable) and a\n\
    \   \"dense\" or \"uniform\" encoding (base64).\n   Mail transport for unencoded\
    \ 8bit data is defined in RFC 1652.  As of\n   the initial publication of this\
    \ document, there are no standardized\n   Internet mail transports for which it\
    \ is legitimate to include\n   unencoded binary data in mail bodies.  Thus there\
    \ are no\n   circumstances in which the \"binary\" Content-Transfer-Encoding is\n\
    \   actually valid in Internet mail.  However, in the event that binary\n   mail\
    \ transport becomes a reality in Internet mail, or when MIME is\n   used in conjunction\
    \ with any other binary-capable mail transport\n   mechanism, binary bodies must\
    \ be labelled as such using this\n   mechanism.\n   NOTE: The five values defined\
    \ for the Content-Transfer-Encoding field\n   imply nothing about the media type\
    \ other than the algorithm by which\n   it was encoded or the transport system\
    \ requirements if unencoded.\n"
- title: 6.3.  New Content-Transfer-Encodings
  contents:
  - "6.3.  New Content-Transfer-Encodings\n   Implementors may, if necessary, define\
    \ private Content-Transfer-\n   Encoding values, but must use an x-token, which\
    \ is a name prefixed by\n   \"X-\", to indicate its non-standard status, e.g.,\
    \ \"Content-Transfer-\n   Encoding: x-my-new-encoding\".  Additional standardized\
    \ Content-\n   Transfer-Encoding values must be specified by a standards-track\
    \ RFC.\n   The requirements such specifications must meet are given in RFC 2048.\n\
    \   As such, all content-transfer-encoding namespace except that\n   beginning\
    \ with \"X-\" is explicitly reserved to the IETF for future\n   use.\n   Unlike\
    \ media types and subtypes, the creation of new Content-\n   Transfer-Encoding\
    \ values is STRONGLY discouraged, as it seems likely\n   to hinder interoperability\
    \ with little potential benefit\n"
- title: 6.4.  Interpretation and Use
  contents:
  - "6.4.  Interpretation and Use\n   If a Content-Transfer-Encoding header field\
    \ appears as part of a\n   message header, it applies to the entire body of that\
    \ message.  If a\n   Content-Transfer-Encoding header field appears as part of\
    \ an entity's\n   headers, it applies only to the body of that entity.  If an\
    \ entity is\n   of type \"multipart\" the Content-Transfer-Encoding is not permitted\
    \ to\n   have any value other than \"7bit\", \"8bit\" or \"binary\".  Even more\n\
    \   severe restrictions apply to some subtypes of the \"message\" type.\n   It\
    \ should be noted that most media types are defined in terms of\n   octets rather\
    \ than bits, so that the mechanisms described here are\n   mechanisms for encoding\
    \ arbitrary octet streams, not bit streams.  If\n   a bit stream is to be encoded\
    \ via one of these mechanisms, it must\n   first be converted to an 8bit byte\
    \ stream using the network standard\n   bit order (\"big-endian\"), in which the\
    \ earlier bits in a stream\n   become the higher-order bits in a 8bit byte.  A\
    \ bit stream not ending\n   at an 8bit boundary must be padded with zeroes. RFC\
    \ 2046 provides a\n   mechanism for noting the addition of such padding in the\
    \ case of the\n   application/octet-stream media type, which has a \"padding\"\
    \ parameter.\n   The encoding mechanisms defined here explicitly encode all data\
    \ in\n   US-ASCII.  Thus, for example, suppose an entity has header fields\n \
    \  such as:\n     Content-Type: text/plain; charset=ISO-8859-1\n     Content-transfer-encoding:\
    \ base64\n   This must be interpreted to mean that the body is a base64 US-ASCII\n\
    \   encoding of data that was originally in ISO-8859-1, and will be in\n   that\
    \ character set again after decoding.\n   Certain Content-Transfer-Encoding values\
    \ may only be used on certain\n   media types.  In particular, it is EXPRESSLY\
    \ FORBIDDEN to use any\n   encodings other than \"7bit\", \"8bit\", or \"binary\"\
    \ with any composite\n   media type, i.e. one that recursively includes other\
    \ Content-Type\n   fields.  Currently the only composite media types are \"multipart\"\
    \ and\n   \"message\".  All encodings that are desired for bodies of type\n  \
    \ multipart or message must be done at the innermost level, by encoding\n   the\
    \ actual body that needs to be encoded.\n   It should also be noted that, by definition,\
    \ if a composite entity\n   has a transfer-encoding value such as \"7bit\", but\
    \ one of the enclosed\n   entities has a less restrictive value such as \"8bit\"\
    , then either the\n   outer \"7bit\" labelling is in error, because 8bit data\
    \ are included,\n   or the inner \"8bit\" labelling placed an unnecessarily high\
    \ demand on\n   the transport system because the actual included data were actually\n\
    \   7bit-safe.\n   NOTE ON ENCODING RESTRICTIONS:  Though the prohibition against\
    \ using\n   content-transfer-encodings on composite body data may seem overly\n\
    \   restrictive, it is necessary to prevent nested encodings, in which\n   data\
    \ are passed through an encoding algorithm multiple times, and\n   must be decoded\
    \ multiple times in order to be properly viewed.\n   Nested encodings add considerable\
    \ complexity to user agents:  Aside\n   from the obvious efficiency problems with\
    \ such multiple encodings,\n   they can obscure the basic structure of a message.\
    \  In particular,\n   they can imply that several decoding operations are necessary\
    \ simply\n   to find out what types of bodies a message contains.  Banning nested\n\
    \   encodings may complicate the job of certain mail gateways, but this\n   seems\
    \ less of a problem than the effect of nested encodings on user\n   agents.\n\
    \   Any entity with an unrecognized Content-Transfer-Encoding must be\n   treated\
    \ as if it has a Content-Type of \"application/octet-stream\",\n   regardless\
    \ of what the Content-Type header field actually says.\n   NOTE ON THE RELATIONSHIP\
    \ BETWEEN CONTENT-TYPE AND CONTENT-TRANSFER-\n   ENCODING: It may seem that the\
    \ Content-Transfer-Encoding could be\n   inferred from the characteristics of\
    \ the media that is to be encoded,\n   or, at the very least, that certain Content-Transfer-Encodings\
    \ could\n   be mandated for use with specific media types.  There are several\n\
    \   reasons why this is not the case. First, given the varying types of\n   transports\
    \ used for mail, some encodings may be appropriate for some\n   combinations of\
    \ media types and transports but not for others.  (For\n   example, in an 8bit\
    \ transport, no encoding would be required for text\n   in certain character sets,\
    \ while such encodings are clearly required\n   for 7bit SMTP.)\n   Second, certain\
    \ media types may require different types of transfer\n   encoding under different\
    \ circumstances.  For example, many PostScript\n   bodies might consist entirely\
    \ of short lines of 7bit data and hence\n   require no encoding at all.  Other\
    \ PostScript bodies (especially\n   those using Level 2 PostScript's binary encoding\
    \ mechanism) may only\n   be reasonably represented using a binary transport encoding.\n\
    \   Finally, since the Content-Type field is intended to be an open-ended\n  \
    \ specification mechanism, strict specification of an association\n   between\
    \ media types and encodings effectively couples the\n   specification of an application\
    \ protocol with a specific lower-level\n   transport.  This is not desirable since\
    \ the developers of a media\n   type should not have to be aware of all the transports\
    \ in use and\n   what their limitations are.\n"
- title: 6.5.  Translating Encodings
  contents:
  - "6.5.  Translating Encodings\n   The quoted-printable and base64 encodings are\
    \ designed so that\n   conversion between them is possible.  The only issue that\
    \ arises in\n   such a conversion is the handling of hard line breaks in quoted-\n\
    \   printable encoding output. When converting from quoted-printable to\n   base64\
    \ a hard line break in the quoted-printable form represents a\n   CRLF sequence\
    \ in the canonical form of the data. It must therefore be\n   converted to a corresponding\
    \ encoded CRLF in the base64 form of the\n   data.  Similarly, a CRLF sequence\
    \ in the canonical form of the data\n   obtained after base64 decoding must be\
    \ converted to a quoted-\n   printable hard line break, but ONLY when converting\
    \ text data.\n"
- title: 6.6.  Canonical Encoding Model
  contents:
  - "6.6.  Canonical Encoding Model\n   There was some confusion, in the previous\
    \ versions of this RFC,\n   regarding the model for when email data was to be\
    \ converted to\n   canonical form and encoded, and in particular how this process\
    \ would\n   affect the treatment of CRLFs, given that the representation of\n\
    \   newlines varies greatly from system to system, and the relationship\n   between\
    \ content-transfer-encodings and character sets.  A canonical\n   model for encoding\
    \ is presented in RFC 2049 for this reason.\n"
- title: 6.7.  Quoted-Printable Content-Transfer-Encoding
  contents:
  - "6.7.  Quoted-Printable Content-Transfer-Encoding\n   The Quoted-Printable encoding\
    \ is intended to represent data that\n   largely consists of octets that correspond\
    \ to printable characters in\n   the US-ASCII character set.  It encodes the data\
    \ in such a way that\n   the resulting octets are unlikely to be modified by mail\
    \ transport.\n   If the data being encoded are mostly US-ASCII text, the encoded\
    \ form\n   of the data remains largely recognizable by humans.  A body which is\n\
    \   entirely US-ASCII may also be encoded in Quoted-Printable to ensure\n   the\
    \ integrity of the data should the message pass through a\n   character-translating,\
    \ and/or line-wrapping gateway.\n   In this encoding, octets are to be represented\
    \ as determined by the\n   following rules:\n    (1)   (General 8bit representation)\
    \ Any octet, except a CR or\n          LF that is part of a CRLF line break of\
    \ the canonical\n          (standard) form of the data being encoded, may be\n\
    \          represented by an \"=\" followed by a two digit\n          hexadecimal\
    \ representation of the octet's value.  The\n          digits of the hexadecimal\
    \ alphabet, for this purpose,\n          are \"0123456789ABCDEF\".  Uppercase\
    \ letters must be\n          used; lowercase letters are not allowed.  Thus, for\n\
    \          example, the decimal value 12 (US-ASCII form feed) can\n          be\
    \ represented by \"=0C\", and the decimal value 61 (US-\n          ASCII EQUAL\
    \ SIGN) can be represented by \"=3D\".  This\n          rule must be followed\
    \ except when the following rules\n          allow an alternative encoding.\n\
    \    (2)   (Literal representation) Octets with decimal values of\n          33\
    \ through 60 inclusive, and 62 through 126, inclusive,\n          MAY be represented\
    \ as the US-ASCII characters which\n          correspond to those octets (EXCLAMATION\
    \ POINT through\n          LESS THAN, and GREATER THAN through TILDE,\n      \
    \    respectively).\n    (3)   (White Space) Octets with values of 9 and 32 MAY\
    \ be\n          represented as US-ASCII TAB (HT) and SPACE characters,\n     \
    \     respectively, but MUST NOT be so represented at the end\n          of an\
    \ encoded line.  Any TAB (HT) or SPACE characters\n          on an encoded line\
    \ MUST thus be followed on that line\n          by a printable character.  In\
    \ particular, an \"=\" at the\n          end of an encoded line, indicating a\
    \ soft line break\n          (see rule #5) may follow one or more TAB (HT) or\
    \ SPACE\n          characters.  It follows that an octet with decimal\n      \
    \    value 9 or 32 appearing at the end of an encoded line\n          must be\
    \ represented according to Rule #1.  This rule is\n          necessary because\
    \ some MTAs (Message Transport Agents,\n          programs which transport messages\
    \ from one user to\n          another, or perform a portion of such transfers)\
    \ are\n          known to pad lines of text with SPACEs, and others are\n    \
    \      known to remove \"white space\" characters from the end\n          of a\
    \ line.  Therefore, when decoding a Quoted-Printable\n          body, any trailing\
    \ white space on a line must be\n          deleted, as it will necessarily have\
    \ been added by\n          intermediate transport agents.\n    (4)   (Line Breaks)\
    \ A line break in a text body, represented\n          as a CRLF sequence in the\
    \ text canonical form, must be\n          represented by a (RFC 822) line break,\
    \ which is also a\n          CRLF sequence, in the Quoted-Printable encoding.\
    \  Since\n          the canonical representation of media types other than\n \
    \         text do not generally include the representation of\n          line\
    \ breaks as CRLF sequences, no hard line breaks\n          (i.e. line breaks that\
    \ are intended to be meaningful\n          and to be displayed to the user) can\
    \ occur in the\n          quoted-printable encoding of such types.  Sequences\n\
    \          like \"=0D\", \"=0A\", \"=0A=0D\" and \"=0D=0A\" will routinely\n \
    \         appear in non-text data represented in quoted-\n          printable,\
    \ of course.\n          Note that many implementations may elect to encode the\n\
    \          local representation of various content types directly\n          rather\
    \ than converting to canonical form first,\n          encoding, and then converting\
    \ back to local\n          representation.  In particular, this may apply to plain\n\
    \          text material on systems that use newline conventions\n          other\
    \ than a CRLF terminator sequence.  Such an\n          implementation optimization\
    \ is permissible, but only\n          when the combined canonicalization-encoding\
    \ step is\n          equivalent to performing the three steps separately.\n  \
    \  (5)   (Soft Line Breaks) The Quoted-Printable encoding\n          REQUIRES\
    \ that encoded lines be no more than 76\n          characters long.  If longer\
    \ lines are to be encoded\n          with the Quoted-Printable encoding, \"soft\"\
    \ line breaks\n          must be used.  An equal sign as the last character on\
    \ a\n          encoded line indicates such a non-significant (\"soft\")\n    \
    \      line break in the encoded text.\n   Thus if the \"raw\" form of the line\
    \ is a single unencoded line that\n   says:\n     Now's the time for all folk\
    \ to come to the aid of their country.\n   This can be represented, in the Quoted-Printable\
    \ encoding, as:\n     Now's the time =\n     for all folk to come=\n      to the\
    \ aid of their country.\n   This provides a mechanism with which long lines are\
    \ encoded in such a\n   way as to be restored by the user agent.  The 76 character\
    \ limit does\n   not count the trailing CRLF, but counts all other characters,\n\
    \   including any equal signs.\n   Since the hyphen character (\"-\") may be represented\
    \ as itself in the\n   Quoted-Printable encoding, care must be taken, when encapsulating\
    \ a\n   quoted-printable encoded body inside one or more multipart entities,\n\
    \   to ensure that the boundary delimiter does not appear anywhere in the\n  \
    \ encoded body.  (A good strategy is to choose a boundary that includes\n   a\
    \ character sequence such as \"=_\" which can never appear in a\n   quoted-printable\
    \ body.  See the definition of multipart messages in\n   RFC 2046.)\n   NOTE:\
    \ The quoted-printable encoding represents something of a\n   compromise between\
    \ readability and reliability in transport.  Bodies\n   encoded with the quoted-printable\
    \ encoding will work reliably over\n   most mail gateways, but may not work perfectly\
    \ over a few gateways,\n   notably those involving translation into EBCDIC.  A\
    \ higher level of\n   confidence is offered by the base64 Content-Transfer-Encoding.\
    \  A way\n   to get reasonably reliable transport through EBCDIC gateways is to\n\
    \   also quote the US-ASCII characters\n     !\"#$@[\\]^`{|}~\n   according to\
    \ rule #1.\n   Because quoted-printable data is generally assumed to be line-\n\
    \   oriented, it is to be expected that the representation of the breaks\n   between\
    \ the lines of quoted-printable data may be altered in\n   transport, in the same\
    \ manner that plain text mail has always been\n   altered in Internet mail when\
    \ passing between systems with differing\n   newline conventions.  If such alterations\
    \ are likely to constitute a\n   corruption of the data, it is probably more sensible\
    \ to use the\n   base64 encoding rather than the quoted-printable encoding.\n\
    \   NOTE: Several kinds of substrings cannot be generated according to\n   the\
    \ encoding rules for the quoted-printable content-transfer-\n   encoding, and\
    \ hence are formally illegal if they appear in the output\n   of a quoted-printable\
    \ encoder. This note enumerates these cases and\n   suggests ways to handle such\
    \ illegal substrings if any are\n   encountered in quoted-printable data that\
    \ is to be decoded.\n    (1)   An \"=\" followed by two hexadecimal digits, one\
    \ or both\n          of which are lowercase letters in \"abcdef\", is formally\n\
    \          illegal. A robust implementation might choose to\n          recognize\
    \ them as the corresponding uppercase letters.\n    (2)   An \"=\" followed by\
    \ a character that is neither a\n          hexadecimal digit (including \"abcdef\"\
    ) nor the CR\n          character of a CRLF pair is illegal.  This case can be\n\
    \          the result of US-ASCII text having been included in a\n          quoted-printable\
    \ part of a message without itself\n          having been subjected to quoted-printable\
    \ encoding.  A\n          reasonable approach by a robust implementation might\
    \ be\n          to include the \"=\" character and the following\n          character\
    \ in the decoded data without any\n          transformation and, if possible,\
    \ indicate to the user\n          that proper decoding was not possible at this\
    \ point in\n          the data.\n    (3)   An \"=\" cannot be the ultimate or\
    \ penultimate character\n          in an encoded object.  This could be handled\
    \ as in case\n          (2) above.\n    (4)   Control characters other than TAB,\
    \ or CR and LF as\n          parts of CRLF pairs, must not appear. The same is\
    \ true\n          for octets with decimal values greater than 126.  If\n     \
    \     found in incoming quoted-printable data by a decoder, a\n          robust\
    \ implementation might exclude them from the\n          decoded data and warn\
    \ the user that illegal characters\n          were discovered.\n    (5)   Encoded\
    \ lines must not be longer than 76 characters,\n          not counting the trailing\
    \ CRLF. If longer lines are\n          found in incoming, encoded data, a robust\n\
    \          implementation might nevertheless decode the lines, and\n         \
    \ might report the erroneous encoding to the user.\n   WARNING TO IMPLEMENTORS:\
    \  If binary data is encoded in quoted-\n   printable, care must be taken to encode\
    \ CR and LF characters as \"=0D\"\n   and \"=0A\", respectively.  In particular,\
    \ a CRLF sequence in binary\n   data should be encoded as \"=0D=0A\".  Otherwise,\
    \ if CRLF were\n   represented as a hard line break, it might be incorrectly decoded\
    \ on\n   platforms with different line break conventions.\n   For formalists,\
    \ the syntax of quoted-printable data is described by\n   the following grammar:\n\
    \     quoted-printable := qp-line *(CRLF qp-line)\n     qp-line := *(qp-segment\
    \ transport-padding CRLF)\n                qp-part transport-padding\n     qp-part\
    \ := qp-section\n                ; Maximum length of 76 characters\n     qp-segment\
    \ := qp-section *(SPACE / TAB) \"=\"\n                   ; Maximum length of 76\
    \ characters\n     qp-section := [*(ptext / SPACE / TAB) ptext]\n     ptext :=\
    \ hex-octet / safe-char\n     safe-char := <any octet with decimal value of 33\
    \ through\n                  60 inclusive, and 62 through 126>\n             \
    \     ; Characters not listed as \"mail-safe\" in\n                  ; RFC 2049\
    \ are also not recommended.\n     hex-octet := \"=\" 2(DIGIT / \"A\" / \"B\" /\
    \ \"C\" / \"D\" / \"E\" / \"F\")\n                  ; Octet must be used for characters\
    \ > 127, =,\n                  ; SPACEs or TABs at the ends of lines, and is\n\
    \                  ; recommended for any character not listed in\n           \
    \       ; RFC 2049 as \"mail-safe\".\n     transport-padding := *LWSP-char\n \
    \                         ; Composers MUST NOT generate\n                    \
    \      ; non-zero length transport\n                          ; padding, but receivers\
    \ MUST\n                          ; be able to handle padding\n              \
    \            ; added by message transports.\n   IMPORTANT:  The addition of LWSP\
    \ between the elements shown in this\n   BNF is NOT allowed since this BNF does\
    \ not specify a structured\n   header field.\n"
- title: 6.8.  Base64 Content-Transfer-Encoding
  contents:
  - "6.8.  Base64 Content-Transfer-Encoding\n   The Base64 Content-Transfer-Encoding\
    \ is designed to represent\n   arbitrary sequences of octets in a form that need\
    \ not be humanly\n   readable.  The encoding and decoding algorithms are simple,\
    \ but the\n   encoded data are consistently only about 33 percent larger than\
    \ the\n   unencoded data.  This encoding is virtually identical to the one used\n\
    \   in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.\n   A\
    \ 65-character subset of US-ASCII is used, enabling 6 bits to be\n   represented\
    \ per printable character. (The extra 65th character, \"=\",\n   is used to signify\
    \ a special processing function.)\n   NOTE:  This subset has the important property\
    \ that it is represented\n   identically in all versions of ISO 646, including\
    \ US-ASCII, and all\n   characters in the subset are also represented identically\
    \ in all\n   versions of EBCDIC. Other popular encodings, such as the encoding\n\
    \   used by the uuencode utility, Macintosh binhex 4.0 [RFC-1741], and\n   the\
    \ base85 encoding specified as part of Level 2 PostScript, do not\n   share these\
    \ properties, and thus do not fulfill the portability\n   requirements a binary\
    \ transport encoding for mail must meet.\n   The encoding process represents 24-bit\
    \ groups of input bits as output\n   strings of 4 encoded characters.  Proceeding\
    \ from left to right, a\n   24-bit input group is formed by concatenating 3 8bit\
    \ input groups.\n   These 24 bits are then treated as 4 concatenated 6-bit groups,\
    \ each\n   of which is translated into a single digit in the base64 alphabet.\n\
    \   When encoding a bit stream via the base64 encoding, the bit stream\n   must\
    \ be presumed to be ordered with the most-significant-bit first.\n   That is,\
    \ the first bit in the stream will be the high-order bit in\n   the first 8bit\
    \ byte, and the eighth bit will be the low-order bit in\n   the first 8bit byte,\
    \ and so on.\n   Each 6-bit group is used as an index into an array of 64 printable\n\
    \   characters.  The character referenced by the index is placed in the\n   output\
    \ string.  These characters, identified in Table 1, below, are\n   selected so\
    \ as to be universally representable, and the set excludes\n   characters with\
    \ particular significance to SMTP (e.g., \".\", CR, LF)\n   and to the multipart\
    \ boundary delimiters defined in RFC 2046 (e.g.,\n   \"-\").\n               \
    \     Table 1: The Base64 Alphabet\n     Value Encoding  Value Encoding  Value\
    \ Encoding  Value Encoding\n         0 A            17 R            34 i     \
    \       51 z\n         1 B            18 S            35 j            52 0\n \
    \        2 C            19 T            36 k            53 1\n         3 D   \
    \         20 U            37 l            54 2\n         4 E            21 V \
    \           38 m            55 3\n         5 F            22 W            39 n\
    \            56 4\n         6 G            23 X            40 o            57\
    \ 5\n         7 H            24 Y            41 p            58 6\n         8\
    \ I            25 Z            42 q            59 7\n         9 J            26\
    \ a            43 r            60 8\n        10 K            27 b            44\
    \ s            61 9\n        11 L            28 c            45 t            62\
    \ +\n        12 M            29 d            46 u            63 /\n        13\
    \ N            30 e            47 v\n        14 O            31 f            48\
    \ w         (pad) =\n        15 P            32 g            49 x\n        16\
    \ Q            33 h            50 y\n   The encoded output stream must be represented\
    \ in lines of no more\n   than 76 characters each.  All line breaks or other characters\
    \ not\n   found in Table 1 must be ignored by decoding software.  In base64\n\
    \   data, characters other than those in Table 1, line breaks, and other\n   white\
    \ space probably indicate a transmission error, about which a\n   warning message\
    \ or even a message rejection might be appropriate\n   under some circumstances.\n\
    \   Special processing is performed if fewer than 24 bits are available\n   at\
    \ the end of the data being encoded.  A full encoding quantum is\n   always completed\
    \ at the end of a body.  When fewer than 24 input bits\n   are available in an\
    \ input group, zero bits are added (on the right)\n   to form an integral number\
    \ of 6-bit groups.  Padding at the end of\n   the data is performed using the\
    \ \"=\" character.  Since all base64\n   input is an integral number of octets,\
    \ only the following cases can\n   arise: (1) the final quantum of encoding input\
    \ is an integral\n   multiple of 24 bits; here, the final unit of encoded output\
    \ will be\n   an integral multiple of 4 characters with no \"=\" padding, (2)\
    \ the\n   final quantum of encoding input is exactly 8 bits; here, the final\n\
    \   unit of encoded output will be two characters followed by two \"=\"\n   padding\
    \ characters, or (3) the final quantum of encoding input is\n   exactly 16 bits;\
    \ here, the final unit of encoded output will be three\n   characters followed\
    \ by one \"=\" padding character.\n   Because it is used only for padding at the\
    \ end of the data, the\n   occurrence of any \"=\" characters may be taken as\
    \ evidence that the\n   end of the data has been reached (without truncation in\
    \ transit).  No\n   such assurance is possible, however, when the number of octets\n\
    \   transmitted was a multiple of three and no \"=\" characters are\n   present.\n\
    \   Any characters outside of the base64 alphabet are to be ignored in\n   base64-encoded\
    \ data.\n   Care must be taken to use the proper octets for line breaks if base64\n\
    \   encoding is applied directly to text material that has not been\n   converted\
    \ to canonical form.  In particular, text line breaks must be\n   converted into\
    \ CRLF sequences prior to base64 encoding.  The\n   important thing to note is\
    \ that this may be done directly by the\n   encoder rather than in a prior canonicalization\
    \ step in some\n   implementations.\n   NOTE: There is no need to worry about\
    \ quoting potential boundary\n   delimiters within base64-encoded bodies within\
    \ multipart entities\n   because no hyphen characters are used in the base64 encoding.\n"
- title: 7.  Content-ID Header Field
  contents:
  - "7.  Content-ID Header Field\n   In constructing a high-level user agent, it may\
    \ be desirable to allow\n   one body to make reference to another.  Accordingly,\
    \ bodies may be\n   labelled using the \"Content-ID\" header field, which is syntactically\n\
    \   identical to the \"Message-ID\" header field:\n     id := \"Content-ID\" \"\
    :\" msg-id\n   Like the Message-ID values, Content-ID values must be generated\
    \ to be\n   world-unique.\n   The Content-ID value may be used for uniquely identifying\
    \ MIME\n   entities in several contexts, particularly for caching data\n   referenced\
    \ by the message/external-body mechanism.  Although the\n   Content-ID header\
    \ is generally optional, its use is MANDATORY in\n   implementations which generate\
    \ data of the optional MIME media type\n   \"message/external-body\".  That is,\
    \ each message/external-body entity\n   must have a Content-ID field to permit\
    \ caching of such data.\n   It is also worth noting that the Content-ID value\
    \ has special\n   semantics in the case of the multipart/alternative media type.\
    \  This\n   is explained in the section of RFC 2046 dealing with\n   multipart/alternative.\n"
- title: 8.  Content-Description Header Field
  contents:
  - "8.  Content-Description Header Field\n   The ability to associate some descriptive\
    \ information with a given\n   body is often desirable.  For example, it may be\
    \ useful to mark an\n   \"image\" body as \"a picture of the Space Shuttle Endeavor.\"\
    \  Such text\n   may be placed in the Content-Description header field.  This\
    \ header\n   field is always optional.\n     description := \"Content-Description\"\
    \ \":\" *text\n   The description is presumed to be given in the US-ASCII character\n\
    \   set, although the mechanism specified in RFC 2047 may be used for\n   non-US-ASCII\
    \ Content-Description values.\n"
- title: 9.  Additional MIME Header Fields
  contents:
  - "9.  Additional MIME Header Fields\n   Future documents may elect to define additional\
    \ MIME header fields\n   for various purposes.  Any new header field that further\
    \ describes\n   the content of a message should begin with the string \"Content-\"\
    \ to\n   allow such fields which appear in a message header to be\n   distinguished\
    \ from ordinary RFC 822 message header fields.\n     MIME-extension-field := <Any\
    \ RFC 822 header field which\n                              begins with the string\n\
    \                              \"Content-\">\n"
- title: 10.  Summary
  contents:
  - "10.  Summary\n   Using the MIME-Version, Content-Type, and Content-Transfer-Encoding\n\
    \   header fields, it is possible to include, in a standardized way,\n   arbitrary\
    \ types of data with RFC 822 conformant mail messages.  No\n   restrictions imposed\
    \ by either RFC 821 or RFC 822 are violated, and\n   care has been taken to avoid\
    \ problems caused by additional\n   restrictions imposed by the characteristics\
    \ of some Internet mail\n   transport mechanisms (see RFC 2049).\n   The next\
    \ document in this set, RFC 2046, specifies the initial set of\n   media types\
    \ that can be labelled and transported using these headers.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   Security issues are discussed in the second\
    \ document in this set, RFC\n   2046.\n"
- title: 12.  Authors' Addresses
  contents:
  - "12.  Authors' Addresses\n   For more information, the authors of this document\
    \ are best contacted\n   via Internet mail:\n   Ned Freed\n   Innosoft International,\
    \ Inc.\n   1050 East Garvey Avenue South\n   West Covina, CA 91790\n   USA\n \
    \  Phone: +1 818 919 3600\n   Fax:   +1 818 919 3614\n   EMail: ned@innosoft.com\n\
    \   Nathaniel S. Borenstein\n   First Virtual Holdings\n   25 Washington Avenue\n\
    \   Morristown, NJ 07960\n   USA\n   Phone: +1 201 540 8967\n   Fax:   +1 201\
    \ 993 3032\n   EMail: nsb@nsb.fv.com\n   MIME is a result of the work of the Internet\
    \ Engineering Task Force\n   Working Group on RFC 822 Extensions.  The chairman\
    \ of that group,\n   Greg Vaudreuil, may be reached at:\n   Gregory M. Vaudreuil\n\
    \   Octel Network Services\n   17080 Dallas Parkway\n   Dallas, TX 75248-1905\n\
    \   USA\n   EMail: Greg.Vaudreuil@Octel.Com\n"
- title: Appendix A -- Collected Grammar
  contents:
  - "Appendix A -- Collected Grammar\n   This appendix contains the complete BNF grammar\
    \ for all the syntax\n   specified by this document.\n   By itself, however, this\
    \ grammar is incomplete.  It refers by name to\n   several syntax rules that are\
    \ defined by RFC 822.  Rather than\n   reproduce those definitions here, and risk\
    \ unintentional differences\n   between the two, this document simply refers the\
    \ reader to RFC 822\n   for the remaining definitions. Wherever a term is undefined,\
    \ it\n   refers to the RFC 822 definition.\n  attribute := token\n           \
    \    ; Matching of attributes\n               ; is ALWAYS case-insensitive.\n\
    \  composite-type := \"message\" / \"multipart\" / extension-token\n  content\
    \ := \"Content-Type\" \":\" type \"/\" subtype\n             *(\";\" parameter)\n\
    \             ; Matching of media type and subtype\n             ; is ALWAYS case-insensitive.\n\
    \  description := \"Content-Description\" \":\" *text\n  discrete-type := \"text\"\
    \ / \"image\" / \"audio\" / \"video\" /\n                   \"application\" /\
    \ extension-token\n  encoding := \"Content-Transfer-Encoding\" \":\" mechanism\n\
    \  entity-headers := [ content CRLF ]\n                    [ encoding CRLF ]\n\
    \                    [ id CRLF ]\n                    [ description CRLF ]\n \
    \                   *( MIME-extension-field CRLF )\n  extension-token := ietf-token\
    \ / x-token\n  hex-octet := \"=\" 2(DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"\
    E\" / \"F\")\n               ; Octet must be used for characters > 127, =,\n \
    \              ; SPACEs or TABs at the ends of lines, and is\n               ;\
    \ recommended for any character not listed in\n               ; RFC 2049 as \"\
    mail-safe\".\n  iana-token := <A publicly-defined extension token. Tokens\n  \
    \               of this form must be registered with IANA\n                 as\
    \ specified in RFC 2048.>\n  ietf-token := <An extension token defined by a\n\
    \                 standards-track RFC and registered\n                 with IANA.>\n\
    \  id := \"Content-ID\" \":\" msg-id\n  mechanism := \"7bit\" / \"8bit\" / \"\
    binary\" /\n               \"quoted-printable\" / \"base64\" /\n             \
    \  ietf-token / x-token\n  MIME-extension-field := <Any RFC 822 header field which\n\
    \                           begins with the string\n                         \
    \  \"Content-\">\n  MIME-message-headers := entity-headers\n                 \
    \         fields\n                          version CRLF\n                   \
    \       ; The ordering of the header\n                          ; fields implied\
    \ by this BNF\n                          ; definition should be ignored.\n  MIME-part-headers\
    \ := entity-headers\n                       [fields]\n                       ;\
    \ Any field not beginning with\n                       ; \"content-\" can have\
    \ no defined\n                       ; meaning and may be ignored.\n         \
    \              ; The ordering of the header\n                       ; fields implied\
    \ by this BNF\n                       ; definition should be ignored.\n  parameter\
    \ := attribute \"=\" value\n  ptext := hex-octet / safe-char\n  qp-line := *(qp-segment\
    \ transport-padding CRLF)\n             qp-part transport-padding\n  qp-part :=\
    \ qp-section\n             ; Maximum length of 76 characters\n  qp-section :=\
    \ [*(ptext / SPACE / TAB) ptext]\n  qp-segment := qp-section *(SPACE / TAB) \"\
    =\"\n                ; Maximum length of 76 characters\n  quoted-printable :=\
    \ qp-line *(CRLF qp-line)\n  safe-char := <any octet with decimal value of 33\
    \ through\n               60 inclusive, and 62 through 126>\n               ;\
    \ Characters not listed as \"mail-safe\" in\n               ; RFC 2049 are also\
    \ not recommended.\n  subtype := extension-token / iana-token\n  token := 1*<any\
    \ (US-ASCII) CHAR except SPACE, CTLs,\n              or tspecials>\n  transport-padding\
    \ := *LWSP-char\n                       ; Composers MUST NOT generate\n      \
    \                 ; non-zero length transport\n                       ; padding,\
    \ but receivers MUST\n                       ; be able to handle padding\n   \
    \                    ; added by message transports.\n  tspecials :=  \"(\" / \"\
    )\" / \"<\" / \">\" / \"@\" /\n                \",\" / \";\" / \":\" / \"\\\"\
    \ / <\">\n                \"/\" / \"[\" / \"]\" / \"?\" / \"=\"\n            \
    \    ; Must be in quoted-string,\n                ; to use within parameter values\n\
    \  type := discrete-type / composite-type\n  value := token / quoted-string\n\
    \  version := \"MIME-Version\" \":\" 1*DIGIT \".\" 1*DIGIT\n  x-token := <The\
    \ two characters \"X-\" or \"x-\" followed, with\n              no  intervening\
    \ white space, by any token>\n"
