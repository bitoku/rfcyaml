- title: __initial_text__
  contents:
  - "              Proposal for an MGCP Advanced Audio Package\nStatus of this Memo\n\
    \   This memo provides information for the Internet community.  It does\n   not\
    \ specify an Internet standard of any kind.  Distribution of this\n   memo is\
    \ unlimited.\nCopyright Notice\n   Copyright (C) The Internet Society (2000).\
    \  All Rights Reserved.\nAbstract\n   This document is a proposal to add a new\
    \ event/signal package to the\n   MGCP (Media Gateway Control Protocol) protocol\
    \ to control an ARF\n   (Audio Resource Function) which may reside on a Media\
    \ Gateway or\n   specialized Audio Server.\n   This event package provides support\
    \ for the standard IVR (Interactive\n   Voice Response) operations of PlayAnnouncement,\
    \ PlayCollect, and\n   PlayRecord.  It supports direct references to simple audio\
    \ as well as\n   indirect references to simple and complex audio. It provides\
    \ audio\n   variables, control of audio interruptibility, digit buffer control,\n\
    \   special key sequences, and support for reprompting during data\n   collection.\
    \  It also provides an arbitrary number of user defined\n   qualifiers to be used\
    \ in resolving complex audio structures.  For\n   example, the user could define\
    \ qualifiers for any or all of the\n   following: language, accent, audio file\
    \ format, gender, speaker, or\n   customer.\nTable of Contents\n   1. Introduction\
    \ ................................................  2\n   1.1. Audio Segments\
    \ ............................................  3\n   1.1.1. Sequences And Sets\
    \ ......................................  3\n   1.1.2. Segment Types ...........................................\
    \  4\n   2. Advanced Audio Package ......................................  5\n\
    \   3. Events ......................................................  5\n   4.\
    \ Event Parameters ............................................  7\n   5. Return\
    \ Parameters ...........................................  7\n   6. Variables ...................................................\
    \ 14\n   7. Selectors ................................................... 17\n\
    \   8. Aliases ..................................................... 18\n   9.\
    \ Examples .................................................... 21\n   10. Formal\
    \ Syntax Description .................................. 22\n   11. References\
    \ ................................................. 22\n   12. Formal Syntax Description\
    \ .................................. 25\n   13. References .................................................\
    \ 32\n   14. Author's Address ........................................... 33\n\
    \   15. Full Copyright Statement ................................... 34\n1.  Introduction\n\
    \   The following syntax supports both simple and complex audio\n   structures.\
    \  A simple audio structure might be a single announcement\n   such as \"Welcome\
    \ to Bell South's Automated Directory Assistance\n   Service\".  A more complex\
    \ audio structure might consist of an\n   announcement followed by voice variable\
    \ followed by another\n   announcement, for example \"There are thirty seven minutes\
    \ remaining\n   on your prepaid calling card,\" where \"There are\" is a prompt,\
    \ the\n   number of minutes is a voice variable, and \"minutes remaining on your\n\
    \   prepaid calling card\" is another prompt.\n   It is also possible to define\
    \ complex audio structures that are\n   qualified by user defined selectors such\
    \ as language, audio file\n   format, gender, accent, customer, or voice talent.\
    \  For instance, if\n   the above example were qualified by language and accent\
    \ selectors, it\n   would be possible to play \"There are thirty seven minutes\
    \ remaining\n   on your prepaid calling card\" in English spoken with a southern\n\
    \   accent or in English spoken with a mid-western accent, providing that\n  \
    \ the audio to support this had been provisioned.\n   There are two methods of\
    \ specifying complex audio.  The first is to\n   directly reference the individual\
    \ components.  This requires a\n   complete description of each component to be\
    \ specified via the\n   protocol.  The second method is to provision the components\
    \ on the\n   Audio Server as a single entity and to export a reference to that\n\
    \   entity to the call agent.  In this case, only the reference (plus any\n  \
    \ dynamic data required, such as a variable data) is passed via the\n   protocol,\
    \ and no specification of individual components is necessary.\n   The Audio Server\
    \ Package provides significant functionality most of\n   which is controlled via\
    \ protocol parameters.  Most parameters are\n   optional, and where ever possible\
    \ default to reasonable values.  An\n   audio application that references to provisioned,\
    \ complex audio\n   structures, and which takes advantage of parameter optionality\
    \ and\n   defaults, can specify audio events using a minimum of syntax.\n1.1.\
    \  Background\n   The next two sections contain background information which may\
    \ be\n   helpful in understanding the syntax.\n1.1.1.  Sequence And Sets\n   The\
    \ syntax supports abstractions of set and sequence for storing and\n   referencing\
    \ audio data.\n   A sequence is a provisioned sequence of one or more audio segments.\n\
    \   Component segments are not necessarily all of the same type.  Every\n   sequence\
    \ is assigned a unique segment id.  On playback, a sequence id\n   reference is\
    \ deconstructed into its individual parts, each of which\n   is played in order.\n\
    \   A set is a provisioned collection of audio segments with an\n   associated\
    \ selector.  On playback, the selector value is resolved to\n   a particular set\
    \ element.  Selector types are supported by the\n   syntax, but individual selector\
    \ types are not defined in the syntax\n   except for the pre-defined language\
    \ selector; they are instead\n   defined by the user (i.e.  provisioner).  A user\
    \ could define one or\n   more of the following selector types: language, accent,\
    \ audio file\n   format, gender, accent, customer, or day of the week.  For each\n\
    \   selector type, the user must define a range of valid values.  The\n   user\
    \ may also choose to define a default value.  At runtime if a\n   selector value\
    \ is not supplied the default value is used.\n   For example, to support an application\
    \ which plays a particular piece\n   of audio in either English, French, or Russian,\
    \ a provisioner would\n   define a set with the pre-defined selector, \"Lang\"\
    , and would define\n   three possible values for that selector, \"eng\", \"fra\"\
    , and \"rus\".\n   The provisioner would then provision three recordings of the\
    \ prompt,\n   one in each language, and would associate the French recording with\n\
    \   the \"fra\" selector value, etc.  The provisioner also could define a\n  \
    \ default value of the selector when no selector value is supplied,\n   \"eng\"\
    \ for instance.  The entire set would be assigned a unique\n   segment id.\n \
    \  At runtime a reference to the set with the selector set to \"rus\"\n   would\
    \ result in the Russian version of the prompt being played.  A\n   reference to\
    \ the set with no selector would result in the English\n   version of the prompt\
    \ being played since English has been set as the\n   default selector value.\n\
    \   Nested definition of both sets and sequences is allowed, i.e. it\n   legal\
    \ to define a set of sets or a sequence of sequences.  In\n   addition, audio\
    \ structures may also be specified by intermixing sets\n   and sequences, and\
    \ it is possible to specify a set of sequences or a\n   sequence containing one\
    \ or more set elements.  Direct or transitive\n   definition of a set or segment\
    \ in terms of itself is not allowed.\n1.1.2.  Segment Types\n   The syntax supports\
    \ the following segment types:\n      RECORDING:  A reference by unique id to\
    \ a single piece of recorded\n      audio.\n      RECORDINGs may be provisioned\
    \ or they may be made during the\n      course of a call.  A RECORDING made during\
    \ the course of a call\n      can be temporary or persistent.  A temporary RECORDING\
    \ lasts only\n      for the life of the call during which it was recorded.  A\n\
    \      persistent RECORDING lasts beyond the live of the call during\n      which\
    \ it was recorded.\n      A provisioned RECORDING may be replaced (or overridden)\
    \ by a\n      persistent RECORDING.  A reference to the id of the provisioned\n\
    \      RECORDING will then resolve to the persistent RECORDING.  The\n      overriding\
    \ persistent audio can subsequently be deleted and the\n      original provisioned\
    \ audio can be restored.\n      A provisioned RECORDING may be overridden more\
    \ than once.  In this\n      case, the id of the provisioned RECORDING refers\
    \ to the latest\n      overriding RECORDING.  When the overriding RECORDING is\
    \ deleted,\n      the original provisioned RECORDING is restored, even if the\n\
    \      segment has been overridden multiple times.\n      TEXT:  A reference to\
    \ a block of text to be converted to speech or\n      to be displayed on a device.\
    \ Reference may be by unique id to a\n      block of provisioned text or by direct\
    \ specification of text in a\n      parameter.\n      SILENCE:  A specification\
    \ of a length of silence to be played in\n      units of 100 milliseconds.\n \
    \     TONE: The specification of a tone to be played by algorithmic\n      generation.\
    \  Most tones however will probably be recorded, not\n      generated. Exact specification\
    \ of this segment type is tbd.\n      VARIABLE:  The specification of a voice\
    \ variable by the parameters\n      of type, subtype, and value.  Specification\
    \ of variables is\n      considered in more detail in a subsequent section of\
    \ this\n      document.\n      SEQUENCE: A reference by unique id to a provisioned\
    \ sequence of\n      mixed RECORDING, TEXT, SILENCE, TONE, VARIABLE, SET, or SEQUENCE\n\
    \      segments. Nested definition of SEQUENCE segments is allowed.\n      Direct\
    \ or transitive definition of a SEQUENCE segment in terms of\n      itself is\
    \ not allowed.\n      SET:  A  reference by unique id to a provisioned set of\
    \ segments.\n      The intended and recommended use of the SET type is that all\n\
    \      segments in the set should be semantically equivalent, however\n      there\
    \ is no real way of enforcing this restriction either in the\n      protocol or\
    \ in provisioning.  Every set has an associated selector\n      which is used\
    \ at runtime to resolve the set reference to a\n      specific element of the\
    \ set.  The elements of a set may one of the\n      following segment types: \
    \ RECORDING, TEXT, TONE, SILENCE,\n      SEQUENCE, or SET.  Specific selector\
    \ types are not specified by\n      the protocol and must be defined by the user.\
    \  Nested definition\n      of SET segments is allowed. Direct or transitive definition\
    \ of a\n      SET segment in terms of itself is not allowed.\n2.  Advanced Audio\
    \ Package\n   Package Name: AU\n   This package defines events and signals for\
    \ an ARF package for an\n   Audio Server Media Gateway.\n3.  Events\n______________________________________________________________________\n\
    | Symbol       |   Definition           |  R   |   S       Duration   |\n|______________|________________________|______|______________________|\n\
    | pa(parms)    |   PlayAnnouncement     |      |   TO      variable   |\n| pc(parms)\
    \    |   PlayCollect          |      |   TO      variable   |\n| pr(parms)   \
    \ |   PlayRecord           |      |   TO      variable   |\n| es(parm)     | \
    \  EndSignal            |      |   BR                 |\n| oc(parms)    |   OperationComplete\
    \    |  x   |                      |\n| of(parms)    |   OperationFailed     \
    \ |  x   |                      |\n|______________|________________________|______|______________________|\n\
    \   The events provided by the AS Package are defined as follows:\n   PlayAnnouncement:\n\
    \      Plays an announcement in situations where there is no need for\n      interaction\
    \ with the user.  Because there is no need to monitor\n      the incoming media\
    \ stream this event is an efficient mechanism for\n      treatments, informational\
    \ announcements, etc.\n   PlayCollect:\n      Plays a prompt and collects DTMF\
    \ digits entered by a user.  If no\n      digits are entered or an invalid digit\
    \ pattern is entered, the\n      user may be reprompted and given another chance\
    \ to enter a correct\n      pattern of digits.  The following digits are supported:\
    \  0-9, *,\n      #, A, B, C, D.  By default PlayCollect does not play an initial\n\
    \      prompt, makes only one attempt to collect digits, and therefore\n     \
    \ functions as a simple Collect operation.  Various special purpose\n      keys,\
    \ key sequences, and key sets can be defined for use during\n      the PlayCollect\
    \ operation.\n   PlayRecord:\n      Plays a prompt and records user speech.  If\
    \ the user does not\n      speak, the user may be reprompted and given another\
    \ chance to\n      record.  By default PlayRecord does not play an initial prompt,\n\
    \      makes only one attempt to record, and therefore functions as a\n      simple\
    \ Record operation.\n   OperationComplete:\n      Detected upon the successful\
    \ completion of a Play, PlayRecord, or\n      Play Collect signal.\n   OperationFailed:\n\
    \      Detected upon the failure of a Play, PlayRecord, or PlayCollect\n     \
    \ signal.\n   EndSignal:\n      Gracefully terminates a Play, PlayCollect, or\
    \ PlayRecord signal.\n      For each of these signals, if the signal is terminated\
    \ with the\n      EndSignal signal the resulting OperationComplete event or\n\
    \      OperationFailed event will contain all the parameters it would\n      normally,\
    \ including any collected digits or the recording id of\n      the recording that\
    \ was in progress when the EndSignal signal was\n      received.\n4.  Signal Interactions\n\
    \   If an Advanced Audio Package signal is active on an endpoint and\n   another\
    \ signal of the same type is applied, the two signals including\n   parameters\
    \ and parameter values will compared  If the signals are\n   identical, the signal\
    \ in progress will be allowed to continue and the\n   new signal will be discarded.\
    \ Because of this behavior the Advanced\n   Audio Package may not interoperate\
    \ well with some other packages such\n   as the Line and Trunk packages.\n5. \
    \ Parameters\n   The PlayAnnouncement, PlayRecord, and PlayCollect events may\
    \ each be\n   qualified by a string of parameters, most of which are optional.\n\
    \   Where appropriate,  parameters default to reasonable values.  The\n   only\
    \ event with a required parameter is PlayAnnouncement.  If a\n   Play-Announcement\
    \ event is not provided with a parameter specifying\n   some form of playable\
    \ audio an error is returned to the application.\n   These parameters are shown\
    \ in the following table:\n_______________________________________________________________________\n\
    | Parameters                                                           |\n|______________________________________________________________________|\n\
    | Symbol    |  Definition                     |   pl   |  pc    |  pr  |\n|___________|_________________________________|________|________|______|\n\
    | an        |  announcement                   |   x    |        |      |\n| ip\
    \        |  initial prompt                 |        |  x     |  x   |\n| rp  \
    \      |  reprompt                       |        |  x     |  x   |\n| nd    \
    \    |  no digits reprompt             |        |  x     |      |\n| ns      \
    \  |  no speech reprompt             |        |        |  x   |\n| fa        |\
    \  failure announcement           |        |  x     |  x   |\n| sa        |  success\
    \ announcement           |        |  x     |  x   |\n| ni        |  non-interruptible\
    \ play         |        |  x     |  x   |\n| it        |  iterations         \
    \            |   x    |        |      |\n| iv        |  interval             \
    \          |   x    |        |      |\n| du        |  duration               \
    \        |   x    |        |      |\n| sp        |  speed                    \
    \      |   x    |  x     |  x   |\n| vl        |  volume                     \
    \    |   x    |  x     |  x   |\n| cb        |  clear digit buffer           \
    \  |        |  x     |  x   |\n| mx        |  maximum # of digits            |\
    \        |  x     |      |\n| mn        |  minimum # of digits            |  \
    \      |  x     |      |\n| dp        |  digit pattern                  |    \
    \    |  x     |      |\n| fdt       |  first digit timer              |      \
    \  |  x     |      |\n| idt       |  inter digit timer              |        |\
    \  x     |      |\n| edt       |  extra digit timer              |        |  x\
    \     |      |\n| prt       |  pre-speech timer               |        |     \
    \   |  x   |\n| pst       |  post-speech timer              |        |       \
    \ |  x   |\n| rlt       |  total recording length timer   |        |        |\
    \  x   |\n| rsk       |  restart key                    |        |  x     |  x\
    \   |\n| rik       |  reinput key                    |        |  x     |  x  \
    \ |\n| rtk       |  return key                     |        |  x     |  x   |\n\
    | psk       |  position key                   |        |  x     |  x   |\n| stk\
    \       |  stop key                       |        |  x     |  x   |\n| sik  \
    \     |  start input key                |        |  x     |      |\n| eik    \
    \   |  end input key                  |        |  x     |  x   |\n| iek      \
    \ |  include end input key          |        |  x     |      |\n| na        |\
    \  number of attempts             |        |  x     |  x   |\n|___________|_________________________________|________|________|______|\n\
    \   Parameters to the Advanced Audio Package events are defined as\n   follows:\n\
    \   Announcement:\n      An announcement to be played.  Consists of one or more\
    \ audio\n      segments.\n   Initial Prompt:\n      The initial announcement prompting\
    \ the user to either enter DTMF\n      digits or to speak.  Consists of one or\
    \ more audio segments.  If\n      not specified (the default), the event immediately\
    \ begins digit\n      collection or recording.\n   Reprompt:\n      Played after\
    \ the user has made an error such as entering an\n      invalid digit pattern\
    \ or not speaking.  Consists of one or more\n      audio segments.  Defaults to\
    \ the Initial Prompt.\n   No Digits Reprompt:\n      Played after the user has\
    \ failed to enter a valid digit pattern\n      during a PlayCollect event.  Consists\
    \ of one or more audio\n      segments.  Defaults to the Reprompt.\n   No Speech\
    \ Reprompt:\n      Played after the user has failed to speak during a PlayRecord\n\
    \      event.  Consists of one or more audio segments.  Defaults to the\n    \
    \  Reprompt.\n   Failure Announcement:\n      Played when all data entry attempts\
    \ have failed.  Consists of one\n      or more audio segments.  No default.\n\
    \   Success Announcement:\n      Played when data collection has succeeded.  Consists\
    \ of one or\n      more audio segments.  No default.\n   Non-Interruptible Play:\n\
    \      If set to true, initial prompt is not interruptible by either\n      voice\
    \ or digits.  Defaults to false.  Valid values are the text\n      strings \"\
    true\" and \"false\".\n   Iterations:\n      The maximum number of times an announcement\
    \ is to be played.  A\n      value of minus one (-1) indicates the announcement\
    \ is to be\n      repeated forever. Defaults to one (1).\n   Interval:\n     \
    \ The interval of silence to be inserted between iterative plays.\n      Specified\
    \ in units of 100 milliseconds.  Defaults to 10 (1\n      second).\n   Duration:\n\
    \      The maximum amount of time to play and possibly replay an\n      announcement.\
    \ Takes precedence over iteration and interval.\n      Specified in units of 100\
    \ milliseconds.  No default.\n   Speed:\n      The relative playback speed of\
    \ announcement specifiable as a\n      positive or negative percentage of the\
    \ original playback speed.\n   Volume:\n      The relative playback volume of\
    \ announcement specifiable as a\n      positive or negative decibel variation\
    \ from the original play-back\n      volume.\n   Clear Digit Buffer:\n      If\
    \ set to true, clears the digit buffer before playing the initial\n      prompt.\
    \  Defaults to false.  Valid values are the text strings\n      \"true\" and \"\
    false\".\n   Maximum # Of Digits:\n      The maximum number of digits to collect.\
    \  Defaults to one.  This\n      parameter should not be specified if the Digit\
    \ Pattern parameter\n      is present.\n   Minimum # Of Digits:\n      The minimum\
    \ number of digits to collect.  Defaults to one.  This\n      parameter should\
    \ not be specified if the Digit Pattern parameter\n      is present.\n   Digit\
    \ Pattern:\n      A legal digit map as described in section 7.1.14 of the Megaco\n\
    \      protocol [6] using the DTMF mappings associated with the Megaco\n     \
    \ DTMF Detection Package described in the Megaco protocol document\n      [6].\
    \  This parameter should not be specified if one or both of the\n      Minimum\
    \ # Of Digits parameter and the Maximum Number Of Digits\n      parameter is present.\n\
    \   First Digit Timer:\n      The amount of time allowed for the user to enter\
    \ the first digit.\n      Specified in units of 100 milliseconds.  50 (5 seconds).\n\
    \   Inter Digit Timer:\n      The amount of time allowed for the user to enter\
    \ each subsequent\n      digit. Specified units of 100 milliseconds seconds. \
    \ Defaults to\n      30 (3 seconds).\n   Extra Digit Timer:\n      The amount\
    \ of time to wait for a user to enter a final digit once\n      the maximum expected\
    \ amount of digits have been entered.\n      Typically this timer is used to wait\
    \ for a terminating key in\n      applications where a specific key has been defined\
    \ to terminate\n      input.  Specified in units of 100 milliseconds. If not specified,\n\
    \      this timer is not activated.\n   Pre-speech Timer:\n      The amount of\
    \ time to wait for the user to initially speak.\n      Specified in units of 100\
    \ milliseconds.  Defaults to 30 (3\n      seconds).\n   Post-speech Timer:\n \
    \     The amount of silence necessary after the end of the last speech\n     \
    \ segment for the recording to be considered complete.  Specified in\n      units\
    \ of 100 milliseconds.  Defaults to 20 (2 seconds).\n   Recording Length Timer:\n\
    \      The maximum allowable length of the recording, not including pre\n    \
    \  or post speech silence.  Specified in units of 100 milliseconds.\n      This\
    \ parameter is mandatory.\n   Restart Key:\n      Defines a key sequence consisting\
    \ of a command key optionally\n      followed by zero or more keys.  This key\
    \ sequence has the\n      following action:  discard any digits collected or recording\
    \ in\n      progress, replay the prompt, and resume digit collection or\n    \
    \  recording.  No default.  An application that defines more than one\n      command\
    \ key sequence, will typically use the same command key for\n      all command\
    \ key sequences.  If more than one command key sequence\n      is defined, then\
    \ all key sequences must consist of a command key\n      plus at least one other\
    \ key.\n   Reinput Key:\n      Defines a key sequence consisting of a command\
    \ key optionally\n      followed by zero or more keys.  This key sequence has\
    \ the\n      following action: discard any digits collected or recordings in\n\
    \      progress and resume digit collection or recording. No default.  An\n  \
    \    application that defines more than one command key sequence, will\n     \
    \ typically use the same command key for all command key sequences.\n      If\
    \ more than one command key sequence is defined, then all key\n      sequences\
    \ must consist of a command key plus at least one other\n      key.\n   Return\
    \ Key:\n      Defines a key sequence consisting of a command key optionally\n\
    \      followed by zero or more keys.  This key sequence has the\n      following\
    \ action:  terminate the current event and any queued\n      event and return\
    \ the terminating key sequence to the call\n      processing agent.  No default.\
    \   An application that defines more\n      than one command key sequence, will\
    \ typically use the same command\n      key for all command key sequences.  If\
    \ more than one command key\n      sequence is defined, then all key sequences\
    \ must consist of a\n      command key plus at least one other key.\n   Position\
    \ Key:\n      Defines a key with the following action.  Stop playing the current\n\
    \      announcement and resume playing at the beginning of the first,\n      last,\
    \ previous, next, or the current segment of the announcement.\n      No default.\
    \  The actions for the position key are fst, lst, prv,\n      nxt, and cur.\n\
    \   Stop Key:\n      Defines a key with the following action.  Terminate playback\
    \ of\n      the announcement.  No default.\n   Start Input Keys:\n      Defines\
    \ a set of keys that are acceptable as the first digit\n      collected. This\
    \ set of keys can be specified to interrupt a\n      playing announcement or to\
    \ not interrupt a playing announcement.\n      The default key set is 0-9. The\
    \ default behavior is to interrupt a\n      playing announcement when a Start\
    \ Input Key is pressed.  This\n      behavior can be overidden for the initial\
    \ prompt only by using the\n      ni (Non-Interruptible Play) parameter.  Specification\
    \ is a list of\n      keys with no separators, e.g.  123456789#.\n   End Input\
    \ Key:\n      Specifies a key that signals the end of digit collection or voice\n\
    \      recording. The default end input key is the # key. To specify that\n  \
    \    no End Input Key be used the parameter is set to the string\n      \"null\"\
    .  The default behavior not to return the End Input Key in\n      the digits returned\
    \ to the call agent.  This behavior can be\n      overidden by the Include End\
    \ Input Key (eik) parameter.\n   Include End Input Key:\n      By default the\
    \ End Input Key is not included in the collected\n      digits returned to the\
    \ call agent.  If this parameter is set to\n      \"true\" then the End Input\
    \ Key will be returned with the collected\n      digits returned to the call agent.\
    \  Default is \"false\".\n   Number Of Attempts:\n      The number of attempts\
    \ the user needed to enter a valid digit\n      pattern or to make a recording.\
    \  Defaults to 1.  Also used as a\n      return parameter to indicate the number\
    \ of attempts the user made.\n   Record Persistent Audio:\n      If set to true,\
    \ the recording that is made is persistent instead\n      of temporary.  Defaults\
    \ to false.  Valid values are the text\n      strings \"true\" and \"false\".\n\
    \   Delete Persistent Audio\n      Indicates that the specified persistent audio\
    \ segment is to be\n      deleted. This parameter is carried by the PlayRecord\
    \ event,\n      although nothing is either played or recorded in this case.\n\
    \   Override Audio:\n      Indicates that the specified provisioned audio segment\
    \ is to be\n      overridden with a persistent audio segment to be recorded in\
    \ the\n      PlayRecord operation that carries this parameter.\n   Restore Audio:\n\
    \      Indicates that the provisioned audio segment originally associated\n  \
    \    with the specified segment id is to be restored and that the\n      overriding\
    \ persistent audio is to be deleted.  This parameter is\n      carried by the\
    \ PlayRecord event, although nothing is either played\n      or recorded in this\
    \ case.\n6.  Return Parameters\n   Each event has an associated set of possible\
    \ return parameters  which\n   are listed in the following tables.\n________________________________________________________________________\n\
    | Return Parameters                                                     |\n|_______________________________________________________________________|\n\
    | Symbol    |   Definition                   |  pl    |   pc    |  pr   |\n|___________|________________________________|________|_________|_______|\n\
    | vi        |   voice interrupt              |        |         |  x    |\n| ik\
    \        |   interrupting key sequence    |        |   x     |       |\n| ap \
    \       |   amount played                |        |   x     |  x    |\n| na  \
    \      |   number of attempts           |        |   x     |  x    |\n| dc   \
    \     |   digits collected             |        |   x     |       |\n| ri    \
    \    |   recording id                 |        |         |  x    |\n| rc     \
    \   |   return code                  |  x     |   x     |  x    |\n|___________|________________________________|________|_________|_______|\n\
    \   Voice Interrupted:\n      Set to \"true\" if the initial prompt of a PlayRecord\
    \ operation was\n      interrupted by voice.  Defaults to \"false\".\n   Interrupting\
    \ Key Sequence:\n      The key or key sequence that interrupted the initial prompt\
    \ of a\n      PlayCollect specified using the digit map characters \"0\" through\n\
    \      \"9\" and \"A\" through \"F\" as defined in the DTMF Detection Package\n\
    \      in the Megaco protocol document [6].\n   Amount Played:\n      The length\
    \ played of an initial prompt if the prompt was\n      interrupted, in 100 ms\
    \ units.\n   Number Of Attempts:\n      The number of attempts the user needed\
    \ to enter a valid digit\n      pattern or to make a recording.  Defaults to 1.\
    \  Also used as an\n      input parameter to specify the number of attempts the\
    \ user will be\n      allowed to enter a valid digit pattern or make a recording.\n\
    \   Digits Collected:\n      The DTMF digits that were collected during a PlayCollect\
    \ operation\n      specified using the digit map characters \"0\" through \"9\"\
    \ and \"A\"\n      through \"F\" as defined in the DTMF Detection Package in the\
    \ Megaco\n      protocol document [6].\n   Recording ID:\n      A 32 bit binary\
    \ integer assigned to audio recorded during the Play\n      Record operation.\n\
    \   Return Code:\n      A return code giving the final status  of  the  operation.\
    \   Two\n      ranges are defined:\n                   _________________________________\n\
    \                   | Range  |        Meaning        |\n                   |________|_______________________|\n\
    \                   |100-199 | successful completion |\n                   |300-399\
    \ | error                 |\n                   |________|_______________________|\n\
    \   The following return codes are define:\n________________________________________________________________________\n\
    |Return Code |                         Meaning                          |\n|____________|__________________________________________________________|\n\
    |    100     | Success                                                  |\n| \
    \   300     | Unspecified failure                                      |\n|  \
    \  301     | Bad audio ID                                             |\n|   \
    \ 302     | Bad selector type                                        |\n|    303\
    \     | Bad selector value                                       |\n|    304 \
    \    | Variable type not supported                              |\n|    305  \
    \   | Variable subtype not supported                           |\n|    306   \
    \  | Invalid variable name                                    |\n|    307    \
    \ | Variable value out of range                              |\n|    308     |\
    \ Inconsistent variable specification                      |\n|    309     | Alias\
    \ not found                                          |\n|    310     | Extra sequence\
    \ data                                      |\n|    311     | Missing sequence\
    \ data                                    |\n|    312     | Mismatch between play\
    \ specification and provisioned data |\n|    313     | Language not set      \
    \                                   |\n|    314     | Remove override error  \
    \                                  |\n|    315     | Override error          \
    \                                 |\n|    316     | Delete audio error       \
    \                                |\n|    317     | Unable to record temporary\
    \ audio                         |\n|    318     | Unable to delete temporary audio\
    \                         |\n|    319     | Unable to record persistent audio\
    \                        |\n|    320     | Unable to delete persistent audio \
    \                       |\n|    321     | Unable to override non-existent segment\
    \ id               |\n|    322     | Unable to remove override from non-existent\
    \ segment id   |\n|    323     | Provisioning error                          \
    \             |\n|    324     | Unspecified hardware failure                 \
    \            |\n|    325     | Syntax error                                  \
    \           |\n|    326     | No digits                                      \
    \          |\n|    327     | No speech                                       \
    \         |\n|    328     | Spoke too long                                   \
    \        |\n|    329     | Digit pattern not matched                         \
    \       |\n|    330     | Max attempts exceeded                              \
    \      |\n|____________|__________________________________________________________|\n\
    \   Here are some examples of how the return parameters are used:\n   The PlayAnnouncement\
    \ event completed successfully:\n      O: AU/oc(rc=100)\n   The PlayAnnouncement\
    \ event failed because an alias was not found:\n      O: AU/of(rc=309)\n   The\
    \ PlayCollect event completed successfully on the user's second\n   attempt when\
    \ the user entered the digits 04375182:\n      O: AU/oc(rc=100 na=2 dc=04375182)\n\
    \   The PlayRecord event was successful on the user's first attempt; the\n   id\
    \ of the recording made by the user is 983:\n      O: AU/oc(rc=100 na=1 ri=983)\n\
    7.  Segment Descriptors\n   Segment descriptors are used with the an, ip, rp,\
    \ nd, ns, fa, and sa\n   parameters to define the segments that make up an announcement.\n\
    ________________________________________________________________________\n|  \
    \                       Segment Descriptors                           |\n|_______________________________________________________________________|\n\
    |      Symbol                        |         Definition               |\n|____________________________________|__________________________________|\n\
    |      32 bit binary number          |         segment identifier       |\n| \
    \     ts                            |         text to speech           |\n|  \
    \    dt                            |         display text             |\n|   \
    \   si                            |         silence                  |\n|    \
    \  to                            |         tone                     |\n|     \
    \ vb                            |         variable                 |\n|____________________________________|__________________________________|\n\
    \   Segment Identifier:\n      A 32 bit binary integer identifying a provisioned\
    \ entity such as a\n      recording, set, sequence, etc.\n   Text To Speech:\n\
    \      Specifies a text string to be converted to speech.\n   Display Text:\n\
    \      Specifies a text string to be displayed on a device.\n   Silence:\n   \
    \   Specifies a length of silence to be played in units of 100\n      milliseconds.\n\
    \   Tone:\n      Specifies a tone to be played by algorithmic generation.  Exact\n\
    \      specification of this parameter is tbd.  Most tones will likely be\n  \
    \    recorded, not generated.\n   Variable:\n      Specifies a voice variable\
    \ by type, subtype, and value.  Variables\n      are more completely defined in\
    \ a subsequent section of the\n      document.\n8.  Variables\n   The syntax supports\
    \ two kinds of variables.  Embedded embedded\n   variables are variables that\
    \ have been provisioned as part of a\n   segment.  Standalone variables are completely\
    \ specified in the\n   protocol message.\n   Typically embedded variables are\
    \ provisioned along with recorded\n   speech, e.g. \"A representative will be\
    \ with you in approximately 5\n   minutes.  If you would prefer to leave a voice\
    \ message, press 1 now\".\n   where the variable is the number of minutes. This\
    \ kind of variable is\n   often referred to as an embedded variable.\n   Variables\
    \ are specified by the following parameters: type, subtype,\n   and value.  Variable\
    \ types include Date, Money, Number, Time, etc.\n   Subtype is a refinement of\
    \ type.  For example the variable type Money\n   might have an associated range\
    \ of subtypes such as Dollar, Rupee,\n   Dinar, etc.  Not all variables require\
    \ a subtype, and for these\n   variables the subtype parameter should be set to\
    \ null.\n   For embedded variables, the type and subtype must be provisioned.\n\
    \   The value may be provisioned.  If it is not provisioned it must be\n   specified\
    \ as part of the variable reference.  In a list of segments,\n   an embedded variable\
    \ value specification applies only to the segment\n   that directly precedes it.\
    \  If a segment has multiple embedded\n   variables, the values must be given\
    \ in the order in which the\n   variables are encountered when the segment is\
    \ played.\n   Some examples follow below:\n   A standalone variable:\n      S:\
    \ pa(an=vb(mny,usd,1153))\n   An embedded variable:\n      S: pa(an=37<1153>)\n\
    \   Not all variables, such as the date variable shown in the next\n   example,\
    \ require a subtype.  In that case, the subtype is encoded\n   with the value\
    \ \"null\":\n      S: pa(an=vb(dat,null,101598))\n   In some cases it may be desirable\
    \ to play an announcement that\n   contains an embedded variable without playing\
    \ the variable itself.\n   To do this a single \"null\" is provided for the value:\n\
    \      S: pa(an=37<null>)\n________________________________________________________________________\n\
    | Variables Qualifiers                                                  |\n|_______________________________________________________________________|\n\
    | Symbol  | Definition               |  Type  | Subtype   | Subtype Of  |\n|_________|__________________________|________|___________|_____________|\n\
    | dat     | date                     |  x     |           |             |\n| dig\
    \     | digits                   |  x     |           |             |\n| gen \
    \    | generic                  |        | x         | dig         |\n| ndn  \
    \   | North American DN        |        | x         | dig         |\n| dur   \
    \  | duration                 |  x     |           |             |\n| mth    \
    \ | month                    |  x     |           |             |\n| mny     |\
    \ money                    |  x     |           |             |\n| num     | number\
    \                   |  x     |           |             |\n| crd     | cardinal\
    \                 |        | x         | nm          |\n| ord     | ordinal  \
    \                |        | x         | nm          |\n| sil     | silence   \
    \               |  x     |           |             |\n| str     | string     \
    \              |  x     |           |             |\n| txt     | text        \
    \             |  x     |           |             |\n| dsp     | display text \
    \            |        | x         | txt         |\n| spk     | text to speech\
    \           |        | x         | txt         |\n| tme     | time           \
    \          |  x     |           |             |\n| t12     | twelve hour format\
    \       |        | x         | tme         |\n| t24     | twenty four hour format\
    \  |        | x         | tme         |\n| ton     | tone                    \
    \ |  x     |           |             |\n| wkd     | weekday                  |\
    \  x     |           |             |\n|_________|__________________________|________|___________|_____________|\n\
    \   Date:\n      Speaks a date specified as YYYYMMDD (per ISO 8601, International\n\
    \      Date and Time Notation [7]).  For example \"19981015\" is spoken as\n \
    \     \"October fifteenth nineteen ninety eight\".\n   Digits:\n      Speaks a\
    \ string of digits one at a time.  If the subtype is North\n      American DN,\
    \ the format of which is NPA-NXX-XXXX, the digits are\n      spoken with appropriate\
    \ pauses between the NPA and NXX and between\n      the NXX and XXXX.  If the\
    \ subtype is generic, the digits are\n      spoken no pauses.\n   Duration:\n\
    \      Duration is specified in seconds and is spoken in one or more\n      units\
    \ of time as appropriate, e.g. \"3661\" is spoken as \"One hour,\n      one minute,\
    \ and one second\".\n   Money:\n      Money is specified in the smallest units\
    \ of a given currency and\n      is spoken in one or more units of currency as\
    \ appropriate, e.g.\n      \"110\" in U.S. Dollars would be spoken \"one dollar\
    \ and ten cents\".\n      The three letter codes defined in ISO 4217, Currency\
    \ And Funds\n      Code List [5] are used to specify the currency subtype. A small\n\
    \      excerpt from ISO 4217 follows:\n      __________________________________________________________\n\
    \      |Alpha-code | Numeric-code | Currency |      Entity       |\n      |___________|______________|__________|___________________|\n\
    \      |GQE        | 226          | Ekwele   | Equatorial Guinea |\n      |GRD\
    \        | 300          | Drachma  | Greece            |\n      |GTQ        |\
    \ 320          | Quetzal  | Guatemala         |\n      |___________|______________|__________|___________________|\n\
    \      Money can be specified in negative or positive units of currency.\n   \
    \   In the above example \"-110\" would be spoken as \"minus one dollar\n    \
    \  and ten cents\".\n   Month:\n      Speaks the specified month, e.g. \"10\"\
    \ is spoken as \"October\".\n      Specification is in MM format with \"01\" denoting\
    \ January, \"02\"\n      denoting February, etc.\n   Number:\n      Speaks a number\
    \ in cardinal form or in ordinal form.  For example,\n      \"100\" is spoken\
    \ as \"one hundred\" in cardinal form and \"one\n      hundredth\" in ordinal\
    \ form.  Cardinal numbers can be specified as\n      negative or positive.\n \
    \  Silence:\n      Plays a specified period of silence.  Specification is in 100\n\
    \      millisecond units.\n   String:\n      Speaks each character of a string,\
    \ e.g. \"a34bc\" is spoken \"A,\n      three, four, b, c\".  Valid characters\
    \ are a-z, A-Z, 0-9, #, and *.\n   Text:\n      Produces the specified text as\
    \ speech or displays it on a device.\n   Time:\n      Speaks a time in either\
    \ twelve hour format or twenty four hour\n      format depending on the specified\
    \ subtype. For example \"1700\" is\n      spoken as \"Five pm\" in twelve hour\
    \ format or as \"Seventeen hundred\n      hours\" in twenty four hour format.\
    \  Specification is in HHMM\n      format per ISO 8601, International Data and\
    \ Time Notation [7].\n   Tone:\n      Plays an algorithmically generated tone,\
    \ specification of which is\n      tbd. Probably most applications will use prerecorded\
    \ tones.\n   Weekday:\n      Speaks the day of the week, e.g. \"Monday\".  Weekdays\
    \ are specified\n      as single digits, with \"1\" denoting Sunday, \"2\" denoting\
    \ Monday,\n      etc.\n9.  Selectors\n   Selector types, except for the pre-defined\
    \ \"Lang\" (language)\n   selector, are definable by the user and may be applied\
    \ to an\n   individual segment within an operation or to all the segments in an\n\
    \   operation.  For each selector type, the user must also define a range\n  \
    \ of values that the selector can assume.\n   For example, if the user defines\
    \ a selector of type \"phase-of-the-\n   moon\", he might also define the legal\
    \ values for that selector to be\n   \"new\", \"half\", \"full\", \"harvest\"\
    , and \"blue\".  For the selector to\n   actually work at runtime, audio associated\
    \ with each of the selector\n   values must be provisioned.\n   Although not required,\
    \ it is suggested that the three letter codes\n   defined in ISO standard 639-2,\
    \ Code For The Representation Of Names\n   Of Languages [4] be used as values\
    \ for user defined language\n   selectors.  A small excerpt from ISO 639-2 follows:\n\
    \                             _________________\n                            \
    \ |Code | Language |\n                             |_____|__________|\n      \
    \                       |cze  | Czech    |\n                             |cym\
    \  | Welsh    |\n                             |dan  | Danish   |\n           \
    \                  |_____|__________|\n   Selectors can apply to entire operations\
    \ or to a segment within an\n   operation.  If an operation contains multiple\
    \ segments, each segment\n   may have its own set of selectors. If selectors for\
    \ an individual\n   segment and selectors for the entire operation are present,\
    \ the\n   selector for the individual segment takes precedence for that\n   segment.\
    \  The selectors for the operation apply to all segments\n   within that operation\
    \ that do not have individual segment selectors.\n   If a selector set is not\
    \ specified, provisioned defaults are used.\n   Selectors are applied to variables\
    \ only after the variable has been\n   resolved. For instance if a date variable\
    \ resolved to \"October 15th,\n   1998\" the voice with which the variable is\
    \ spoken could resolve to\n   either male or female if a gender selector had been\
    \ defined.\n10.  Aliases\n   Aliasing of audio segments is supported.  The alias\
    \ to segment id\n   mapping is provisioned and at runtime the alias is resolved\
    \ to its\n   associated segment id. The syntax for an alias is inclusion of the\n\
    \   alias between two forward slashes, e.g.:\n      S: pa(an=/not-in-service/)\n\
    11.  Examples\n   This section presents a number of examples of how the syntax\
    \ is used.\n   Note that arguments to an event are separated by a one or more\n\
    \   whitespace characters, which can be either an ASCII space character\n   or\
    \ an ASCII tabulation character.\n   Play an announcement that consists of a single\
    \ segment:\n      S: pa(an=39)\n   Play an announcement that consists of multiple\
    \ segments:\n      S: pa(an=39,40,47)\n   Play an announcement that consists of\
    \ a recording followed by silence\n   followed by text to speech followed by a\
    \ standalone voice variable:\n      S: pa(an=39 si(30) ts(hello) vb(my,usd,3999))\n\
    \   Play an announcement with an embedded variable.  If the first three\n   segments\
    \ of the previous announcement were provisioned as segment 40,\n   the following\
    \ would be exactly equivalent to the play in the\n   preceding example:\n    \
    \  S: pa(an=40<3999>)\n   Play an announcement with two embedded variables:\n\
    \      S: pa(an=113<3999,10151998>)\n   Play a prompt and collect a single digit.\
    \  If need be, play a\n   reprompt, a no digits prompt, and a success or failure\
    \ announcement.\n   Give the user three attempts to enter a digit:\n      S: pc(ip=21\
    \ rp=109 nd=102 fa=81 sa=72 na=3)\n   Play a prompt and collect a single digit.\
    \  If the user does not enter\n   a digit replay the initial prompt.  Give the\
    \ user three attempts to\n   enter a digit:\n      S: pc(ip=21 na=3)\n   Play\
    \ a prompt and record voice.  If the user does not speak play a no\n   speech\
    \ prompt.  Give the user two attempts to record:\n      S: pr(ip=22 ns=42 na=2)\n\
    \   Play an announcement at ninety percent of its original speed and five\n  \
    \ decibels softer than its original volume.  Play the announcement\n   three times\
    \ with two seconds of silence between plays.\n      S: pa(an=27 sp=90 vl=-5 it=3\
    \ iv=20)\n   Give the user two attempts to enter a three digit pattern.  Clear\
    \ the\n   digit buffer before playing the prompt. The user can signal end of\n\
    \   input using the # key, which is not returned to the call agent with\n   the\
    \ collected digits.\n      S: pc(ip=43 cb=true mn=3 mx=3 na=2)\n   Give the user\
    \ three attempts to enter a three digit pattern.  If the\n   user enters one digits\
    \ or two digits on the first or second attempts\n   a reprompt is played.  If\
    \ the user enters no digits on the first or\n   second attempts a no digits reprompt\
    \ is played.  If all three\n   attempts fail, a failure announcement is played.\
    \  If one of the\n   attempts is successful, a success announcement is played\
    \ and the\n   collected digits are returned to the call agent.  The user can signal\n\
    \   end of input using the # key.  If the # key terminates a successful\n   input\
    \ attempt, the collected digits, but not the # key, are returned\n   to the call\
    \ agent.\n      S: pc(ip=87 rp=5 nd=409 fa=9 sa=18 mx=3 na=3)\n   Give the user\
    \ a single attempt to enter a a 1 to 4 digit pattern,\n   allow 8 seconds for\
    \ the user to enter the first digit, and allow 6\n   seconds for the user to enter\
    \ each subsequent digit.  If the\n   subsequent digit timer expires after the\
    \ user has less than four\n   digits, the digits collected are returned to the\
    \ call agent.  The\n   user can signal end of input using the # key which is not\
    \ returned to\n   the call agent with the collected digits.\n      S: pc(ip=4\
    \ fdt=80 idt=60 mx=4)\n   Give the user three chances to enter an 11 digit number\
    \ that begins\n   with 0 or 1.  If the user makes a mistake while entering digits,\
    \ he\n   can press the * key to discard any digits already collected, replay\n\
    \   the prompt, and resume collection.\n      S: pc(ip=33 mn=11 mx=11 sik=01 rsk=*\
    \ na=3)\n   Give the user three chances to enter an 11 digit number that begins\n\
    \   with 0 or 1.  If the user makes a mistake while entering digits, he\n   can\
    \ press the key sequence *11 to discard any digits already\n   collected, replay\
    \ the prompt, and resume collection.  If the user\n   enters the key sequence\
    \ *12 the play collect is terminated along with\n   any queued events, and the\
    \ terminating key sequence is returned to\n   the call agent for processing.\n\
    \      S: pc(ip=33 mn=11 mx=11 sik=01 rsk=*11 rtk=*12 na=3)\n   Give the user\
    \ two chances to make a recording.  After playing the\n   prompt, wait 5 seconds\
    \ for the user to speak, otherwise replay the\n   initial prompt and try again.\
    \  If the user does speak, wait for seven\n   seconds after speech stops to make\
    \ sure the user is finished.  If the\n   recording is successful, return a reference\
    \ to the recording to the\n   call agent.\n      S: pr(ip=6 prt=50 pst=70 na=2)\n\
    \   Play an announcement in the default language:\n      S: pa(an=5)\n   Play\
    \ the same announcement the English.  In the first example, the\n   selector applies\
    \ to the an segment; in the second it applies to the\n   pa operation.  For these\
    \ particular examples, the net effect is the\n   same.\n      S: pa(an=5[Lang=eng])\
    \    or    S: pa(an=5)[Lang=eng]\n   Play an announcement in Danish using a female\
    \ voice with a Cajun\n   accent.\n      S: pa(an=6)[Lang=dan,gender=female,accent=cajun]\n\
    \   Play the first part of an announcement in English, the second part in\n  \
    \ the default language, and the third part in French.\n      S: pa(an=5[Lang=eng],6,7[Language=fra])\n\
    \   Play an announcement with an embedded variable in English:\n      S: pa(an=5<101599>)[Lang=eng]\n\
    12.  Formal Syntax Description\nAudPkgEvent = PlayAnnouncement / PlayCollect /\
    \ PlayRecord /\n              OperationComplete / OperationFailed / EndSignal\n\
    PlayAnnouncement =  [ AdvAudioPkgToken SLASH ]  PlayAnnToken\n               \
    \     LPAREN PlayAnnParmList RPAREN  [ OpSelectorList ]\nPlayCollect  =  [ AdvAudioPkgToken\
    \ SLASH ]  PlayColToken\n                LPAREN [ PlayColParmList ]  RPAREN  [\
    \ OpSelectorList ]\nPlayRecord  =  [ AdvAudioPkgToken SLASH ]  PlayRecToken\n\
    \               LPAREN [ PlayRecParmList ]  RPAREN  [ OpSelectorList ]\nOperationComplete\
    \  =  [ AdvAudioPkgToken SLASH ]  OpCompleteToken\n               LPAREN OpCompleteParmList\
    \  RPAREN\nOperationFailed  =  [ AdvAudioPkgToken SLASH ]  OpFailedToken\n   \
    \            LPAREN ReturnCodeParm RPAREN\nEndSignal  =  [ AdvAudioPkgToken SLASH\
    \ ]  EndSignalToken\n              LPAREN SignalParm RPAREN\nOpSelectorList  =\
    \   LSQUARE OpSelector *( COMMA OpSelector ) RSQUARE\nOpSelector  =  NAME EQUALS\
    \ NAME\nPlayAnnParmList  =  PlayAnnParm *( WSP PlayAnnParm )\nPlayColParmList\
    \  =  PlayColParm *( WSP PlayColParm )\nPlayRecParmList  =  PlayRecParm *( WSP\
    \ PlayRecParm )\nOpCompleteParmList  =  OpCompleteParm *( WSP OpCompleteParm )\n\
    PlayAnnParm  =  ( AnnouncementParm / IterationsParm / IntervalParm /\n       \
    \           DurationParm / SpeedParm / VolumeParm )\nPlayColParm  =  ( InitPromptParm\
    \ / RepromptParm / NoDigitsParm /\n                  FailAnnParm / SuccessAnnParm\
    \ / NoInterruptParm /\n                  SpeedParm / VolumeParm / ClearBufferParm\
    \ /\n                  MaxDigitsParm / MinDigitsParm / DigitPatternParm /\n  \
    \                FirstDigitParm / InterDigitParm / ExtraDigitParm /\n        \
    \          RestartKeyParm / ReinputKeyParm / ReturnKeyParm /\n               \
    \   PosKeyParm / StopKeyParm / StartInputKeyParm /\n                  EndInputKeyParm\
    \ / IncludeEndInputKey /\n                  NumAttemptsParm  )\nPlayRecParm  =\
    \  ( InitPromptParm / RepromptParm / NoSpeechParm /\n                  FailAnnParm\
    \ / SuccessAnnParm / NoInterruptParm /\n                  SpeedParm / VolumeParm\
    \ / ClearBufferParm /\n                  PreSpeechParm / PostSpeechParm / RecordLenParm\
    \ /\n                  RestartKeyParm / ReinputKeyParm / ReturnKeyParm /\n   \
    \               PosKeyParm / StopKeyParm / EndInputKeyParm /\n               \
    \   RecPersistParm / OverrideAudioParm /\n                  RestoreAudioParm /\
    \  DeletePersistParm /\n                  NumAttemptsParm  )\nOpCompleteParm \
    \ =  ( VoiceInterruptParm / IntKeySeqParm /\n                     NumAttemptsParm\
    \ / AmtPlayedParm / DigitsColParm /\n                     RecordingIdParm / ReturnCodeParm\
    \ )\nAnnouncementParm  =  AnParmToken EQUALS Segmentlist\nInitPromptParm  =  IpParmToken\
    \ EQUALS  Segmentlist\nRepromptParm  =  RpParmToken EQUALS Segmentlist\nNoDigitsParm\
    \  =  NdParmToken EQUALS Segmentlist\nNoSpeechParm  =  NsParmToken EQUALS Segmentlist\n\
    FailAnnParm  =  FaParmToken EQUALS Segmentlist\nSuccessAnnParm  =  SaParmToken\
    \ EQUALS Segmentlist\nDurationParm  =  DuParmToken EQUALS NUMBER\nIterationsParm\
    \  =  ItParmToken EQUALS ( NUMBER / \"-1\" )\nIntervalParm  =  IvParmToken EQUALS\
    \ NUMBER\nSpeedParm  =  SpParmToken EQUALS SIGNEDINT\nVolumeParm  =  VlParmToken\
    \ EQUALS SIGNEDINT\nNoInterruptParm  =  NiParmToken EQUALS BOOLSTR\nClearBufferParm\
    \  =  CbParmToken EQUALS BOOLSTR\nMaxDigitsParm  =  MxParmToken EQUALS NUMBER\n\
    MinDigitsParm  =  MnParmToken EQUALS NUMBER\nDigitPatternParm  =  DpParmToken\
    \ EQUALS DIGITPATTERN\nFirstDigitParm  =  FdtParmToken EQUALS NUMBER\nInterDigitParm\
    \  =  IdtParmToken EQUALS NUMBER\nExtraDigitParm  =  EdtParmToken EQUALS NUMBER\n\
    PreSpeechParm  =  PrtParmToken EQUALS NUMBER\nPostSpeechParm  =  PstParmToken\
    \ EQUALS NUMBER\nRecordLenParm   =  RltParmToken EQUALS NUMBER\nRestartKeyParm\
    \  =  RskParmToken EQUALS CommandKeySequence\nReinputKeyParm    =  RikParmToken\
    \ EQUALS CommandKeySequence\nReturnKeyParm    =  RtkParmToken EQUALS CommandKeySequence\n\
    PosKeyParm   =  PskParmToken EQUALS KeyPadKey COMMA PosKeyAction\nPosKeyAction\
    \  =  FirstSegmentToken / LastSegmentToken /\n                 PreviousSegmentToken\
    \ / NextSegmentToken /\n                 CurrentSegmentToken\nStopKeyParm    =\
    \  StkParmToken EQUALS KeyPadKey\nStartInputKeyParm  =  SikParmToken EQUALS KeySet\n\
    EndInputKeyParm  =  EikParmToken EQUALS KeyPadKey\nIncludeEndinputKey  =  IekParmToken\
    \ EQUALS BOOLSTR\nRecPersistParm  =  RpaParmToken EQUALS BOOLSTR\nOverrideAudioParm\
    \  =  OaParmToken EQUALS SEGID\nRestoreAudioParm  =  RaParmToken EQUALS SEGID\n\
    DeletePersistParm  =  DpaParmToken EQUALS SEGID\nNumAttemptsParm  =  NaParmToken\
    \ EQUALS NUMBER\nVoiceInterruptParm  =  ViParmToken EQUALS BOOLSTR\nIntKeySeqParm\
    \  =  IkParmToken EQUALS CommandKeySequence\nAmtPlayedParm  =  ApParmToken EQUALS\
    \ NUMBER\nDigitsColParm  =  DcParmToken EQUALS KeySequence\nRecordingIdParm  =\
    \  RiParmToken EQUALS NUMBER\nReturnCodeParm  =  RcParmToken EQUALS  3*3(DIGIT)\n\
    KeyPadKey    =  \"1\" / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\"\
    \ / \"9\" /\n                \"*\" / \"#\"\nCommandKeySequence  =  1*3(KeyPadKey)\n\
    KeySequence = 1*64(KeyPadKey)\nKeySet       =   1*11(KeyPadKey)\nSignalParm  =\
    \  SgParmToken  EQUALS ( PlayAnnToken / PlayColToken /\n               PlayRecToken\
    \ ) RPAREN\nSegmentlist  =  SegmentDescriptor  *( COMMA SegmentDescriptor )\n\
    SegmentDescriptor  =  ( ( SegmentId [ EmbedVarList ]\n                       \
    \   [ SegSelectorList ]  ) /\n                        ( TextToSpeechSeg [ SegSelectorList\
    \ ]  ) /\n                        ( DisplayTextSeg [ SegSelectorList ]  )  /\n\
    \                        ( VariableSeg [ SegSelectorList ]  ) /\n            \
    \              SilenceSeg )\nSegmentId  =  ( Segid / Alias )\nTextToSpeechSeg\
    \  =  TextToSpeechSegToken LPAREN NAME RPAREN\nDisplayTextSeg  =  DisplayTextSegToken\
    \ LPAREN NAME RPAREN\nSilenceSeg  =  SilenceSegToken LPAREN NAME RPAREN\nVariableSeg\
    \  =  VariableSegToken LPAREN FullSpecVar RPAREN\nSegid  =  NUMBER\nAlias  = \
    \ SLASH NAME SLASH\nEmbedVarList  =  LANGLE NAME *( COMMA  NAME  ) RANGLE\nSegSelectorList\
    \  =  LSQUARE SegSelector *( COMMA SegSelector ) RSQUARE\nSegSelector  =  NAME\
    \ EQUALS NAME\nFullSpecVar  =  ( DateVariable / DigitsVariable / DurationVariable\
    \ /\n                  MonthVariable / MoneyVariable / NumberVariable /\n    \
    \              SilenceVariable / StringVariable / TextVariable /\n           \
    \       TimeVariable / WeekdayVariable )\nDateVariable  =   DateVarToken COMMA\
    \ NullStrToken COMMA Date\nDate  =  8*8(DIGIT)\nDigitsVariable  =  DigitsVarToken\
    \ COMMA (NorthAmericanDnToken /\n                   GenericDigitsToken) COMMA\
    \ NUMBER\nDurationVariable  =  DurationVarToken COMMA NullStrToken COMMA NUMBER\n\
    MoneyVariable  =  MoneyVarToken COMMA 3*3(ALPHA) COMMA OPTSIGNEDINT\nMonthVariable\
    \  =  MonthVarToken COMMA NullStrToken COMMA Month\nMonth = \"01\" / \"02\" /\
    \ \"03\" / \"04\" / \"05\" / \"06\" / \"07\" / \"08\" / \"09\" /\n        \"10\"\
    \ / \"11\" / \"12\"\nNumberVariable  =  (NumberVarToken COMMA CardinalNumberToken\
    \ COMMA\n                    OPTSIGNEDINT) / (NumberVarToken COMMA\n         \
    \           OrdinalNumberToken COMMA NUMBER)\nSilenceVariable  =  SilenceVarToken\
    \ COMMA  NullStrToken COMMA NUMBER\nStringVariable  =  StringVarToken COMMA NullStrToken\
    \ COMMA *(KeyPadKey)\n                   OrdinalNumberToken) COMMA NUMBER\nSilenceVariable\
    \  =  SilenceVarToken COMMA  NullStrToken COMMA NUMBER\nStringVariable  =  StringVarToken\
    \ COMMA NullStrToken COMMA\n                   *(KeyPadKey)\nTextVariable  = \
    \ TextVarToken COMMA (DisplayTextToken /\n                 TextToSpeechToken)\
    \ COMMA NAME\nTimeVariable  =  TimeVarToken COMMA (TwelveHourFormatToken /\n \
    \                TwentyFourHourFormatToken) COMMA 4*4(DIGIT)\nWeekdayVariable\
    \  =  WeekdayVarToken COMMA NullStrToken COMMA NAME\nAdvAudioPkgToken       =\
    \  \"A\"\nPlayAnnToken           =  \"pa\"\nPlayColToken           =  \"pc\"\n\
    PlayRecToken           =  \"pr\"\nOpCompleteToken        =  \"oc\"\nOpFailedToken\
    \          =  \"of\"\nEndSignalToken         =  \"es\"\nTextToSpeechSegToken \
    \  =  \"ts\"\nDisplayTextSegToken    =  \"dt\"\nSilenceSegToken        =  \"si\"\
    \nVariableSegToken       =  \"vb\"\nAnParmToken    =  \"an\"\nIpParmToken    =\
    \  \"ip\"\nRpParmToken    =  \"rp\"\nNdParmToken    =  \"nd\"\nNsParmToken   \
    \ =  \"ns\"\nFaParmToken    =  \"fa\"\nSaParmToken    =  \"sa\"\nNiParmToken \
    \   =  \"ni\"\nItParmToken    =  \"it\"\nIvParmToken    =  \"iv\"\nDuParmToken\
    \    =  \"du\"\nSpParmToken    =  \"sp\"\nVlParmToken    =  \"vl\"\nCbParmToken\
    \    =  \"cb\"\nMxParmToken    =  \"mx\"\nMnParmToken    =  \"mn\"\nDpParmToken\
    \    =  \"dp\"\nFdtParmToken   =  \"fdt\"\nIdtParmToken   =  \"idt\"\nEdtParmToken\
    \   =  \"edt\"\nPrtParmToken   =  \"prt\"\nPstParmToken   =  \"pst\"\nRltParmToken\
    \   =  \"rlt\"\nRskParmToken   =  \"rsk\"\nRikParmToken   =  \"rik\"\nRtkParmToken\
    \   =  \"rtk\"\nPskParmToken   =  \"psk\"\nStkParmToken   =  \"stk\"\nSikParmToken\
    \   =  \"sik\"\nEikParmToken   =  \"eik\"\nIekParmToken   =  \"iek\"\nRpaParmToken\
    \   =  \"rpa\"\nDpaParmToken   =  \"dpa\"\nOaParmToken    =  \"oa\"\nRaParmToken\
    \    =  \"ra\"\nNaParmToken    =  \"na\"\nRidParmToken   =  \"rid\"\nViParmToken\
    \    =  \"vi\"\nIkParmToken    =  \"ik\"\nApParmToken    =  \"ap\"\nDcParmToken\
    \    =  \"dc\"\nRiParmToken    =  \"ri\"\nRcParmToken    =  \"rc\"\nSgParmToken\
    \    =  \"sg\"\nDateVarToken       =  \"dat\"\nDigitsVarToken     =  \"dig\"\n\
    DuratioNVarToken   =  \"dur\"\nMoneyVarToken      =  \"mny\"\nMonthVarToken  \
    \    =  \"mth\"\nNumberVarToken     =  \"num\"\nSilenceVarToken    =  \"sil\"\n\
    StringVarToken     =  \"str\"\nTextVarToken       =  \"txt\"\nTimeVarToken   \
    \    =  \"tme\"\nWeekdayVarToken    =  \"wkd\"\nGenericDigitsToken         = \
    \ \"gen\"\nNorthAmericanDnSToken      =  \"ndn\"\nCardinalNumberToken        =\
    \  \"crd\"\nOrdinalNumberToken         =  \"ord\"\nDisplayTextToken          \
    \ =  \"dsp\"\nTextToSpeechToken          =  \"spk\"\nTwelveHourFormatToken   \
    \   =  \"t12\"\nTwentyFourHourFormatToken  =  \"t24\"\nNullStrToken  =  \"null\"\
    \nFirstSegmentToken     =  \"fst\"\nLastSegmentToken      =  \"lst\"\nPreviousSegmentToken\
    \  =  \"prv\"\nNextSegmentToken      =  \"nxt\"\nCurrentSegmentToken   =  \"cur\"\
    \nBOOLSTR       =  \"true\" / \"false\"\nNAMECHAR      =  ALPHA / DIGIT / \"_\"\
    \ / \"-\"\nNAME          =  1*64(NAMECHAR)\nNUMBER        =  DIGIT *31(DIGIT)\n\
    SIGNEDINT     =  (\"+\" / \"-\") DIGIT *31(DIGIT)\nOPTSIGNEDINT  =  [\"+\" / \"\
    -\"] DIGIT *31(DIGIT)\nEQUALS        =  \"=\"\nCOMMA         =  \",\"\nLSQUARE\
    \       =  \"[\"\nRSQUARE       =  \"]\"\nLANGLE        =  \"<\"\nRANGLE     \
    \   =  \">\"\nLPAREN        =  \"(\"\nRPAREN        =  \")\"\nSLASH         =\
    \  \"/\"\nWSP           =  SP / HTAB\n13.  References\n   [1] Bradner, S., \"\
    Key words for use in RFCs to Indicate Requirement\n       Levels\", BCP 14, RFC\
    \ 2119, March 1997.\n   [2] Arango, M., Dugan, A., Elliott, I., Huitema, C. and\
    \ S. Pickett,\n       \"Media Gateway Control Protocol (MGCP) Version 0.1\", RFC\
    \ 2705,\n       October 1999.\n   [3] Cromwell, D. and M. Durling, \"Requirements\
    \ For Control Of A Media\n       Services Function\", Version 0.0, Work in Progres..\n\
    \   [4] ISO 639-2, \"Code For The Representation Of Names Of Languages\",\n  \
    \     1998.\n   [5] ISO 4217, \"Currency And Funds Code List\", 1981.\n   [6]\
    \ Cuervo, F., Hill, B., Greene, N., Huitema, C., Rayhan, A., Rosen,\n       B.\
    \ and J. Segers, \"Megaco Protocol\", RFC 2885, August 2000.\n   [7] ISO 8601,\
    \ \"International Date and Time Notation\", 1998.\n14.  Author's Address\n   David\
    \ Cromwell\n   Nortel Networks\n   Box 13478\n   35 Davis Drive\n   Research Triangle\
    \ Park, NC 27709\n   Phone: 919-991-8870\n   EMail: cromwell@nortelnetworks.com\n\
    15.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\nAcknowledgement\n   Funding for the RFC Editor function\
    \ is currently provided by the\n   Internet Society.\n"
