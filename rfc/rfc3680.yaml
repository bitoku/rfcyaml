- contents:
  - '  A Session Initiation Protocol (SIP) Event Package for Registrations

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document defines a Session Initiation Protocol (SIP) event\n
    \  package for registrations.  Through its REGISTER method, SIP allows a\n   user
    agent to create, modify, and delete registrations.\n   Registrations can also
    be altered by administrators in order to\n   enforce policy.  As a result, these
    registrations represent a piece\n   of state in the network that can change dynamically.
    \ There are many\n   cases where a user agent would like to be notified of changes
    in this\n   state.  This event package defines a mechanism by which those user\n
    \  agents can request and obtain such notifications.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction .................................................
    \ 2\n   2.  Terminology ..................................................  3\n
    \  3.  Usage Scenarios ..............................................  3\n       3.1.
    \ Forcing Re-Authentication ..............................  3\n       3.2.  Composing
    Presence .....................................  3\n       3.3.  Welcome Notices
    ........................................  4\n   4.  Package Definition ...........................................
    \ 4\n       4.1.  Event Package Name .....................................  4\n
    \      4.2.  Event Package Parameters ...............................  5\n       4.3.
    \ SUBSCRIBE Bodies .......................................  5\n       4.4.  Subscription
    Duration ..................................  5\n       4.5.  NOTIFY Bodies ..........................................
    \ 6\n       4.6.  Notifier Processing of SUBSCRIBE Requests ..............  6\n
    \      4.7.  Notifier Generation of NOTIFY Requests .................  7\n             4.7.1.
    \ The Registration State Machine .................  7\n             4.7.2.  Applying
    the state machine .....................  9\n       4.8.  Subscriber Processing
    of NOTIFY Requests ...............  9\n       4.9.  Handling of Forked Requests
    ............................  9\n       4.10. Rate of Notifications ..................................
    10\n       4.11. State Agents ........................................... 10\n
    \  5.  Registration Information ..................................... 10\n       5.1.
    \ Structure of Registration Information .................. 10\n       5.2.  Computing
    Registrations from the Document .............. 14\n       5.3.  Example ................................................
    15\n       5.4.  XML Schema ............................................. 16\n
    \  6.  Example Call Flow ............................................ 18\n   7.
    \ Security Considerations ...................................... 21\n   8.  IANA
    Considerations .......................................... 21\n       8.1.  SIP
    Event Package Registration ......................... 21\n       8.2.  application/reginfo+xml
    MIME Registration .............. 22\n       8.3.  URN Sub-Namespace Registration
    for\n             urn:ietf:params:xml:ns:reginfo ......................... 23\n
    \  9.  References ................................................... 23\n       9.1.
    \ Normative References ................................... 23\n       9.2.  Informative
    References ................................. 24\n   10. Contributors .................................................
    25\n   11. Acknowledgements ............................................. 25\n
    \  12. Author's Address ............................................. 25\n   13.
    Full Copyright Statement ..................................... 26\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Session Initiation Protocol (SIP) [1] provides all of
    the\n   functions needed for the establishment and maintenance of\n   communications
    sessions between users.  One of the functions it\n   provides is a registration
    operation.  A registration is a binding\n   between a SIP URI, called an address-of-record,
    and one or more\n   contact URIs.  These contact URIs represent additional resources
    that\n   can be contacted in order to reach the user identified by the\n   address-of-record.
    \ When a proxy receives a request within its domain\n   of administration, it
    uses the Request-URI as an address-of-record,\n   and uses the contacts bound
    to the address-of-record to forward (or\n   redirect) the request.\n   The SIP
    REGISTER method provides a way for a user agent to manipulate\n   registrations.
    \ Contacts can be added or removed, and the current set\n   of contacts can be
    queried.  Registrations can also change as a\n   result of administrator policy.
    \ For example, if a user is suspected\n   of fraud, their registration can be
    deleted so that they cannot\n   receive any requests.  Registrations also expire
    after some time if\n   not refreshed.\n   Registrations represent a dynamic piece
    of state maintained by the\n   network.  There are many cases in which user agents
    would like to\n   know about changes to the state of registrations.  The SIP Events\n
    \  Framework [2] defines a generic framework for subscription to, and\n   notification
    of, events related to SIP systems.  The framework\n   defines the methods SUBSCRIBE
    and NOTIFY, and introduces the notion\n   of a package.  A package is a concrete
    application of the event\n   framework to a particular class of events.  Packages
    have been\n   defined for user presence [9], for example.  This specification\n
    \  defines a package for registration state.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\",\n
    \  \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",\n
    \  and \"OPTIONAL\" are to be interpreted as described in BCP 14, RFC 2119\n   [3]
    and indicate requirement levels for compliant implementations.\n"
  title: 2.  Terminology
- contents:
  - "3.  Usage Scenarios\n   There are many applications of this event package.  A
    few are\n   documented here for illustrative purposes.\n"
  - contents:
    - "3.1.  Forcing Re-Authentication\n   It is anticipated that many SIP devices
      will be wireless devices that\n   will be always-on, and therefore, continually
      registered to the\n   network.  Unfortunately, history has shown that these
      devices can be\n   compromised.  To deal with this, an administrator will want
      to\n   terminate or shorten a registration, and ask the device to\n   re-register
      so it can be re-authenticated.  To do this, the device\n   subscribes to the
      registration event package for the\n   address-of-record that it is registering
      contacts against.  When the\n   administrator shortens registration (for example,
      when fraud is\n   suspected) the registration server sends a notification to
      the\n   device.  It can then re-register and re-authenticate itself.  If it\n
      \  cannot re-authenticate, the expiration will terminate shortly\n   thereafter.\n"
    title: 3.1.  Forcing Re-Authentication
  - contents:
    - "3.2.  Composing Presence\n   An important concept to understand is the relationship
      between this\n   event package and the event package for user presence [9].
      \ User\n   presence represents the willingness and ability of a user to\n   communicate
      with other users on the network.  It is composed of a set\n   of contact addresses
      that represent the various means for contacting\n   the user.  Those contact
      addresses might represent the contact\n   address for voice, for example.  Typically,
      the contact address\n   listed for voice will be an address-of-record.  The
      status of that\n   contact (whether its open or closed) may depend on any number
      of\n   factors, including the state of any registrations against that\n   address-of-record.
      \ As a result, registration state can be viewed as\n   an input to the process
      which determines the presence state of a\n   user.  Effectively, registration
      state is \"raw\" data, which is\n   combined with other information about a
      user to generate a document\n   that describes the user's presence.\n   In fact,
      this event package allows for a presence server to be\n   separated from a SIP
      registration server, yet still use registration\n   information to construct
      a presence document.  When a presence server\n   receives a presence subscription
      for some user, the presence server\n   itself would generate a subscription
      to the registration server for\n   the registration event package.  As a result,
      the presence server\n   would learn about the registration state for that user,
      and it could\n   use that information to generate presence documents.\n"
    title: 3.2.  Composing Presence
  - contents:
    - "3.3.  Welcome Notices\n   A common service in current mobile networks are \"welcome
      notices\".\n   When the user turns on their phone in a foreign country, they
      receive\n   a message that welcomes them to the country, and provides information\n
      \  on transportation services, for example.\n   In order to implement this service
      in a SIP system, an application\n   server can subscribe to the registration
      state of the user.  When the\n   user turns on their phone, the phone will generate
      a registration.\n   This will result in a notification being sent to the application
      that\n   the user has registered.  The application can then send a SIP MESSAGE\n
      \  request [10] to the device, welcoming the user and providing any\n   necessary
      information.\n"
    title: 3.3.  Welcome Notices
  title: 3.  Usage Scenarios
- contents:
  - "4.  Package Definition\n   This section fills in the details needed to specify
    an event package\n   as defined in Section 4.4 of [2].\n"
  - contents:
    - "4.1.  Event Package Name\n   The SIP Events specification requires package
      definitions to specify\n   the name of their package or template-package.\n
      \  The name of this package is \"reg\".  As specified in [2], this value\n   appears
      in the Event header present in SUBSCRIBE and NOTIFY requests.\n   Example:\n
      \  Event: reg\n"
    title: 4.1.  Event Package Name
  - contents:
    - "4.2.  Event Package Parameters\n   The SIP Events specification requires package
      and template-package\n   definitions to specify any package specific parameters
      of the Event\n   header that are used by it.\n   No package specific Event header
      parameters are defined for this\n   event package.\n"
    title: 4.2.  Event Package Parameters
  - contents:
    - "4.3.  SUBSCRIBE Bodies\n   The SIP Events specification requires package or
      template-package\n   definitions to define the usage, if any, of bodies in SUBSCRIBE\n
      \  requests.\n   A SUBSCRIBE for registration events MAY contain a body.  This
      body\n   would serve the purpose of filtering the subscription.  The\n   definition
      of such a body is outside the scope of this specification.\n   A SUBSCRIBE for
      the registration package MAY be sent without a body.\n   This implies that the
      default registration filtering policy has been\n   requested. The default policy
      is:\n      o  Notifications are generated every time there is any change in\n
      \        the state of any of the registered contacts for the resource\n         being
      subscribed to.  Those notifications only contain\n         information on the
      contacts whose state has changed.\n      o  Notifications triggered from a SUBSCRIBE
      contain full state\n         (the list of all contacts bound to the address-of-record).\n
      \  Of course, the server can apply any policy it likes to the\n   subscription.\n"
    title: 4.3.  SUBSCRIBE Bodies
  - contents:
    - "4.4.  Subscription Duration\n   The SIP Events specification requires package
      definitions to define a\n   default value for subscription durations, and to
      discuss reasonable\n   choices for durations when they are explicitly specified.\n
      \  Registration state changes as contacts are created through REGISTER\n   requests,
      and then time out due to lack of refresh.  Their rate of\n   change is therefore
      related to the typical registration expiration.\n   Since the default expiration
      for registrations is 3600 seconds, the\n   default duration of subscriptions
      to registration state is slightly\n   longer, 3761 seconds. This helps avoid
      any potential problems with\n   coupling of subscription and registration refreshes.
      \ Of course,\n   clients MAY include an Expires header in the SUBSCRIBE request
      asking\n   for a different duration.\n"
    title: 4.4.  Subscription Duration
  - contents:
    - "4.5.  NOTIFY Bodies\n   The SIP Events specification requires package definitions
      to describe\n   the allowed set of body types in NOTIFY requests, and to specify
      the\n   default value to be used when there is no Accept header in the\n   SUBSCRIBE
      request.\n   The body of a notification of a change in registration state contains\n
      \  a registration information document.  This document describes some or\n   all
      of the contacts associated with a particular address-of-record.\n   All subscribers
      and notifiers MUST support the\n   \"application/reginfo+xml\" format described
      in Section 5.  The\n   subscribe request MAY contain an Accept header field.
      \ If no such\n   header field is present, it has a default value of\n   \"application/reginfo+xml\".
      \ If the header field is present, it MUST\n   include \"application/reginfo+xml\",
      and MAY include any other types\n   capable of representing registration information.\n
      \  Of course, the notifications generated by the server MUST be in one\n   of
      the formats specified in the Accept header field in the SUBSCRIBE\n   request.\n"
    title: 4.5.  NOTIFY Bodies
  - contents:
    - "4.6.  Notifier Processing of SUBSCRIBE Requests\n   The SIP Events framework
      specifies that packages should define any\n   package-specific processing of
      SUBSCRIBE requests at a notifier,\n   specifically with regards to authentication
      and authorization.\n   Registration state can be sensitive information.  Therefore,
      all\n   subscriptions to it SHOULD be authenticated and authorized before\n
      \  approval.  Authentication MAY be performed using any of the\n   techniques
      available through SIP, including digest, S/MIME, TLS or\n   other transport
      specific mechanisms [1].  Authorization policy is at\n   the discretion of the
      administrator, as always.  However, a few\n   recommendations can be made.\n
      \  It is RECOMMENDED that a user be allowed to subscribe to their own\n   registration
      state.  Such subscriptions are useful when there are\n   many devices that represent
      a user, each of which needs to learn the\n   registration state of the other
      devices.  We also anticipate that\n   applications and automata will frequently
      be subscribers to the\n   registration state.  In those cases, authorization
      policy will\n   typically be provided ahead of time.\n"
    title: 4.6.  Notifier Processing of SUBSCRIBE Requests
  - contents:
    - "4.7.  Notifier Generation of NOTIFY Requests\n   The SIP Event framework requests
      that packages specify the conditions\n   under which notifications are sent
      for that package, and how such\n   notifications are constructed.\n   To determine
      when a notifier should send notifications of changes in\n   registration state,
      we define a finite state machine (FSM) that\n   represents the state of a contact
      for a particular address-of-record.\n   Transitions in this state machine MAY
      result in the generation of\n   notifications.  These notifications will carry
      information on the new\n   state and the event which triggered the state change.
      \ It is\n   important to note that this FSM is just a model of the registration\n
      \  state machinery maintained by a server.  An implementation would map\n   its
      own state machines to this one in an implementation-specific\n   manner.\n"
    - contents:
      - "4.7.1.  The Registration State Machine\n   The underlying state machine for
        a registration is shown in Figure 1.\n   The machine is very simple.  An instance
        of this machine is\n   associated with each address-of-record.  When there
        are no contacts\n   registered to the address-of-record, the state machine
        is in the init\n   state.  It is important to note that this state machine
        exists, and\n   is well-defined, for each address-of-record in the domain,
        even if\n   there are no contacts registered to it.  This allows a user agent
        to\n   subscribe to an address-of-record, and learn that there are no\n   contacts
        registered to it.  When the first contact is registered to\n   that address-of-record,
        the state machine moves from init to active.\n                           +------------+\n
        \                          |            |\n                           |    Init
        \   |\n                           |            |\n                           +------------+\n
        \                                 |\n                                  V\n
        \                          +------------+\n                           |            |\n
        \                          |   Active   |\n                           |            |\n
        \                          +------------+\n                                  |\n
        \                                 V\n                           +------------+\n
        \                          |            |\n                           | Terminated
        |\n                           |            |\n                           +------------+\n
        \                  Figure 1: Registration State Machine\n   As long as there
        is at least one contact bound to the address-of-\n   record, the state machine
        remains in the active state.  When the last\n   contact expires or is removed,
        the registration transitions to\n   terminated.  From there, it immediately
        transitions back to the init\n   state.  This transition is invisible, in
        that it MUST NOT ever be\n   reported to a subscriber in a NOTIFY request.\n
        \     This allows for an implementation optimization whereby the\n      registrar
        can destroy the objects associated with the registration\n      state machine
        once it enters the terminated state and a NOTIFY has\n      been sent. Instead,
        the registrar can assume that, if the objects\n      for that state machine
        no longer exist, the state machine is in\n      the init state.\n   In addition
        to this state machine, each registration is associated\n   with a set of contacts,
        each of which is modeled with its own state\n   machine.  Unlike the FSM for
        the address-of-record, which exists even\n   when no contacts are registered,
        the per-contact FSM is instantiated\n   when the contact is registered, and
        deleted when it is removed.  The\n   diagram for the per-contact state machine
        is shown in Figure 2.  This\n   FSM is identical to the registration state
        machine in terms of its\n   states, but has many more transition events.\n
        \  When a new contact is added, the FSM for it is instantiated, and it\n   moves
        into the active state. Because of that, the init state here is\n   transient.
        \ There are two ways in which it can become active.  One is\n   through an
        actual SIP REGISTER request (corresponding to the\n   registered event), and
        the other is when the contact is created\n   administratively, or through
        some non-SIP means (the created event).\n                                 +------+\n
        \                                |      | refreshed\n                                 |
        \     | shortened\n                                 V      |\n    +------------+
        \           +------------+            +------------+\n    |            |            |
        \           |            |            |\n    |    Init    |----------->|   Active
        \  |----------->| Terminated |\n    |            |            |            |
        \           |            |\n    +------------+ registered +------------+ expired
        \   +------------+\n                   created                   deactivated\n
        \                                            probation\n                                             unregistered\n
        \                                            rejected\n                      Figure
        2: Contact State Machine\n   The FSM remains in the active state so long as
        the contact is bound\n   to the address-of-record.  When a contact is refreshed
        through a\n   REGISTER request, the FSM stays in the same state, but a refreshed\n
        \  event is generated.  Likewise, when an administrator modifies the\n   expiration
        time of a binding (without deleting the binding) to\n   trigger the contact
        to re-register and possibly re-authenticate, the\n   FSM stays in the active
        state, but a shortened event is generated.\n   When the contact is no longer
        bound to the address-of-record, the FSM\n   moves to the terminated state,
        and once a NOTIFY is sent, the state\n   machine is destroyed.  As a result,
        the terminated state is\n   effectively transient.  There are several reasons
        this can happen.\n   The first is an expiration, which occurs when the contact
        was not\n   refreshed by a REGISTER request.  The second reason is deactivated.\n
        \  This occurs when the administrator has removed the contact as a valid\n
        \  binding, but still wishes the client to attempt to re-register the\n   contact.
        \ In contrast, the rejected event occurs when an active\n   contact is removed
        by the administrator, but\n   re-registrations will not help to re-establish
        it.  This might occur\n   if a user does not pay their bills, for example.
        \ The probation event\n   occurs when an active contact is removed by the
        administrator, and\n   the administrator wants the client to re-register,
        but to do so at a\n   later time.  The unregistered event occurs when a REGISTER
        request\n   sets the expiration time of that contact to zero.\n"
      title: 4.7.1.  The Registration State Machine
    - contents:
      - "4.7.2.  Applying the state machine\n   The server MAY generate a notification
        to subscribers when any event\n   occurs in either the address-of-record or
        per-contact state machines,\n   except for the transition from terminated
        to init in the address-of-\n   record state machine. As noted above, a notification
        MUST NOT be sent\n   in this case. For other transitions, whether the server
        sends a\n   notification or not is policy dependent. However, several guidelines\n
        \  are defined.\n   As a general rule, when a subscriber is authorized to
        receive\n   notifications about a set of registrations, it is RECOMMENDED
        that\n   notifications contain information about those contacts which have\n
        \  changed state (and thus triggered a notification), instead of\n   delivering
        the current state of every contact in all registrations.\n   However, notifications
        triggered as a result of a fetch operation (a\n   SUBSCRIBE with Expires of
        0) SHOULD result in the full state of all\n   contacts for all registrations
        to be present in the NOTIFY.\n"
      title: 4.7.2.  Applying the state machine
    title: 4.7.  Notifier Generation of NOTIFY Requests
  - contents:
    - "4.8.  Subscriber Processing of NOTIFY Requests\n   The SIP Events framework
      expects packages to specify how a subscriber\n   processes NOTIFY requests in
      any package specific ways, and in\n   particular, how it uses the NOTIFY requests
      to construct a coherent\n   view of the state of the subscribed resource.  Typically,
      the NOTIFY\n   will only contain information for contacts whose state has changed.\n
      \  To construct a coherent view of the total state of all registrations,\n   the
      subscriber will need to combine NOTIFYs received over time.  The\n   details
      of this process depend on the document format used to convey\n   registration
      state.  Section 5 outlines the process for the\n   application/reginfo+xml format.\n"
    title: 4.8.  Subscriber Processing of NOTIFY Requests
  - contents:
    - "4.9.  Handling of Forked Requests\n   The SIP Events framework mandates that
      packages indicate whether or\n   not forked SUBSCRIBE requests can install multiple
      subscriptions.\n   Registration state is normally stored in some repository
      (whether it\n   be co-located with a proxy/registrar or in a separate database).
      \ As\n   such, there is usually a single place where the contact information\n
      \  for a particular address-of-record is resident.  This implies that a\n   subscription
      for this information is readily handled by a single\n   element with access
      to this repository.  There is, therefore, no\n   compelling need for a subscription
      to registration information to\n   fork.  As a result, a subscriber MUST NOT
      create multiple dialogs as\n   a result of a single subscription request.  The
      required processing\n   to guarantee that only a single dialog is established
      is described in\n   Section 4.4.9 of the SIP Events framework [2].\n"
    title: 4.9.  Handling of Forked Requests
  - contents:
    - "4.10.  Rate of Notifications\n   The SIP Events framework mandates that packages
      define a maximum rate\n   of notifications for their package.\n   For reasons
      of congestion control, it is important that the rate of\n   notifications not
      become excessive.  As a result, it is RECOMMENDED\n   that the server not generate
      notifications for a single subscriber at\n   a rate faster than once every 5
      seconds.\n"
    title: 4.10.  Rate of Notifications
  - contents:
    - "4.11.  State Agents\n   The SIP Events framework asks packages to consider
      the role of state\n   agents in their design.\n   State agents have no role
      in the handling of this package.\n"
    title: 4.11.  State Agents
  title: 4.  Package Definition
- contents:
  - '5.  Registration Information

    '
  - contents:
    - "5.1.  Structure of Registration Information\n   Registration information is
      an XML document [4] that MUST be\n   well-formed and SHOULD be valid.  Registration
      information documents\n   MUST be based on XML 1.0 and MUST be encoded using
      UTF-8.  This\n   specification makes use of XML namespaces for identifying\n
      \  registration information documents and document fragments.  The\n   namespace
      URI for elements defined by this specification is a URN\n   [5], using the namespace
      identifier 'ietf' defined by [6] and\n   extended by [7].  This URN is:\n      urn:ietf:params:xml:ns:reginfo\n
      \  A registration information document begins with the root element tag\n   \"reginfo\".
      \ It consists of any number of \"registration\" sub-elements,\n   each of which
      contains the registration state for a particular\n   address-of-record.  The
      registration information for a particular\n   address-of-record MUST be contained
      within a single \"registration\"\n   element; it cannot be spread across multiple
      \"registration\" elements\n   within a document.  Other elements from different
      namespaces MAY be\n   present for the purposes of extensibility; elements or
      attributes\n   from unknown namespaces MUST be ignored.  There are two attributes\n
      \  associated with the \"reginfo\" element, both of which MUST be present:\n
      \       version: This attribute allows the recipient of registration\n                 information
      documents to properly order them.  Versions\n                 start at 0, and
      increment by one for each new document\n                 sent to a subscriber.
      \ Versions are scoped within a\n                 subscription.  Versions MUST
      be representable using a\n                 32 bit integer.\n        state:   This
      attribute indicates whether the document contains\n                 the full
      registration state, or whether it contains\n                 only information
      on those registrations which have\n                 changed since the previous
      document (partial).\n   Note that the document format explicitly allows for
      conveying\n   information on multiple addresses-of-record.  This enables\n   subscriptions
      to groups of registrations, where such a group is\n   identified by some kind
      of URI.  For example, a domain might define\n   sip:allusers@example.com as
      a subscribable resource that generates\n   notifications when the state of any
      address-of-record in the domain\n   changes.\n   The \"registration\" element
      has a list of any number of \"contact\"\n   sub-elements, each of which contains
      information on a single contact.\n   Other elements from different namespaces
      MAY be present for the\n   purposes of extensibility; elements or attributes
      from unknown\n   namespaces MUST be ignored.  There are three attributes associated\n
      \  with the \"registration\" element, all of which MUST be present:\n      aor:
      \  The aor attribute contains a URI which is the address-of-\n             record
      this registration refers to.\n      id:    The id attribute identifies this
      registration.  It MUST be\n             unique amongst all other id attributes
      present in other\n             registration elements conveyed to the subscriber
      within the\n             scope of their subscription.  In particular, if two
      URI\n             identifying an address-of-record differ after their\n             canonicalization
      according to the procedures in step 5 of\n             Section 10.3 of RFC 3261
      [1], the id attributes in the\n             \"registration\" elements for those
      addresses-of-record MUST\n             differ.  Furthermore, the id attribute
      for a \"registration\"\n             element for a particular address-of-record
      MUST be the same\n             across all notifications sent within the subscription.\n
      \     state: The state attribute indicates the state of the\n             registration.
      \ The valid values are \"init\", \"active\" and\n             \"terminated\".\n
      \  The \"contact\" element contains a \"uri\" element, an optional\n   \"display-name\"
      element, and an optional \"unknown-param\" element.\n   Other elements from
      different namespaces MAY be present for the\n   purposes of extensibility; elements
      or attributes from unknown\n   namespaces MUST be ignored.  There are several
      attributes associated\n   with the \"contact\" element which MUST be present:\n
      \     id:    The id attribute identifies this contact.  It MUST be\n             unique
      amongst all other id attributes present in other\n             contact elements
      conveyed to the subscriber within the\n             scope of their subscription.
      \ In particular, if the URI for\n             two contacts differ (based on
      the URI comparison rules in\n             RFC 3261 [1]), the id attributes for
      those contacts MUST\n             differ.  However, unlike the id attribute
      for an address-\n             of-record, if the URI for two contacts are the
      same, their\n             id attributes SHOULD be the same across notifications.\n
      \            This requirement is at SHOULD strength, and not MUST\n             strength,
      since it is difficult to compute such an id as a\n             function of the
      URI without retaining additional state.  No\n             hash function applied
      to the URI can, in fact, meet a MUST\n             requirement.  This is because
      equality of the SIP URI is\n             not transitive.  However, a hash function
      which includes\n             unknown URI parameters (that is, any not defined
      in RFC\n             3261), will always result in a value that is the different\n
      \            if two URI are different, and usually the same if the URI\n             are
      equal.\n      state: The state attribute indicates the state of the contact.\n
      \            The valid values are \"active\" and \"terminated\".\n      event:
      The event attribute indicates the event which caused the\n             contact
      state machine to go into its current state.  Valid\n             values are
      registered, created, refreshed, shortened,\n             expired, deactivated,
      probation, unregistered and rejected.\n   If the event attribute has a value
      of shortened, the \"expires\"\n   attribute MUST be present.  It contains an
      unsigned long integer\n   which indicates the number of seconds remaining until
      the binding is\n   due to expire.  This attribute MAY be included with any event\n
      \  attribute value for which the state of the contact is active.\n   If the
      event attribute has a value of probation, the \"retry-after\"\n   attribute
      MUST be present.  It contains an unsigned long integer\n   which indicates the
      amount of seconds after which the owner of the\n   contact is expected to retry
      its registration.\n   The optional \"duration-registered\" attribute conveys
      the amount of\n   time that the contact has been bound to the address-of-record,
      in\n   seconds.  The optional \"q\" attribute conveys the relative priority
      of\n   this contact compared to other registered contacts.  The optional\n   \"callid\"
      attribute contains the current Call-ID carried in the\n   REGISTER that was
      last used to update this contact, and the optional\n   \"cseq\" attribute contains
      the last CSeq value present in a REGISTER\n   request that updated this contact
      value.\n   The \"uri\" element contains the URI associated with that contact.
      \ The\n   \"display-name\" element contains the display name for the contact.\n
      \  The \"display-name\" element MAY contain the xml:lang attribute to\n   indicate
      the language of the display name.\n   The \"unknown-param\" element is used
      to convey contact header field\n   parameters that are not specified in RFC
      3261.  One example are the\n   user agent capability parameters specified in
      [11].  Each \"unknown-\n   param\" element describes a single contact header
      field parameter.\n   The name of the parameter is contained in the mandatory
      name\n   attribute of the \"unknown-param\" element, and the value of the\n
      \  parameter is the content of the \"unknown-param\" element.  For contact\n
      \  header field parameters that have no value, the content of the\n   \"unknown-param\"
      element is empty.\n"
    title: 5.1.  Structure of Registration Information
  - contents:
    - "5.2.  Computing Registrations from the Document\n   Typically, the NOTIFY for
      registration information will only contain\n   information about those contacts
      whose state has changed.  To\n   construct a coherent view of the total state
      of all registrations, a\n   subscriber will need to combine NOTIFYs received
      over time.  The\n   subscriber maintains a table for each registration it receives\n
      \  information for.  Each registration is uniquely identified by the\n   \"id\"
      attribute in the \"registration\" element.  Each table contains a\n   row for
      each contact in that registration.  Each row is indexed by\n   the unique ID
      for that contact.  It is conveyed in the \"id\" attribute\n   of the \"contact\"
      element.  The contents of each row contain the state\n   of that contact as
      conveyed in the \"contact\" element.  The tables are\n   also associated with
      a version number.  The version number MUST be\n   initialized with the value
      of the \"version\" attribute from the\n   \"reginfo\" element in the first document
      received.  Each time a new\n   document is received, the value of the local
      version number, and the\n   \"version\" attribute in the new document, are compared.
      \ If the value\n   in the new document is one higher than the local version
      number, the\n   local version number is increased by one, and the document is\n
      \  processed.  If the value in the document is more than one higher than\n   the
      local version number, the local version number is set to the\n   value in the
      new document, the document is processed, and the\n   subscriber SHOULD generate
      a refresh request to trigger a full state\n   notification.  If the value in
      the document is less than the local\n   version, the document is discarded without
      processing.\n   The processing of the document depends on whether it contains
      full or\n   partial state.  If it contains full state, indicated by the value
      of\n   the \"state\" attribute in the \"reginfo\" element, the contents of all\n
      \  tables associated with this subscription are flushed.  They are\n   re-populated
      from the document.  A new table is created for each\n   \"registration\" element,
      and a new row in each table is created for\n   each \"contact\" element.  If
      the reginfo contains partial state, as\n   indicated by the value of the \"state\"
      attribute in the \"reginfo\"\n   element, the document is used to update the
      existing tables.  For\n   each \"registration\" element, the subscriber checks
      to see if a table\n   exists for that registration.  This check is done by comparing
      the\n   value in the \"id\" attribute of the \"registration\" element with the
      ID\n   associated with the table.  If a table doesn't exist for that\n   registration,
      one is created.  For each \"contact\" element in the\n   registration, the subscriber
      checks to see whether a row exists for\n   that contact.  This check is done
      by comparing the ID in the \"id\"\n   attribute of the \"contact\" element with
      the ID associated with the\n   row.  If the contact doesn't exist in the table,
      a row is added, and\n   its state is set to the information from that \"contact\"
      element.  If\n   the contact does exist, its state is updated to be the information\n
      \  from that \"contact\" element.  If a row is updated or created, such\n   that
      its state is now terminated, that entry MAY be removed from the\n   table at
      any time.\n"
    title: 5.2.  Computing Registrations from the Document
  - contents:
    - "5.3.  Example\n   The following is an example registration information document:\n
      \  <?xml version=\"1.0\"?>\n       <reginfo xmlns=\"urn:ietf:params:xml:ns:reginfo\"\n
      \          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                    version=\"0\"
      state=\"full\">\n         <registration aor=\"sip:user@example.com\" id=\"as9\"\n
      \                      state=\"active\">\n           <contact id=\"76\" state=\"active\"
      event=\"registered\"\n                    duration-registered=\"7322\"\n                    q=\"0.8\">\n
      \                   <uri>sip:user@pc887.example.com</uri>\n           </contact>\n
      \          <contact id=\"77\" state=\"terminated\" event=\"expired\"\n                    duration-registered=\"3600\"\n
      \                   q=\"0.5\">\n                    <uri>sip:user@university.edu</uri>\n
      \          </contact>\n         </registration>\n       </reginfo>\n"
    title: 5.3.  Example
  - contents:
    - "5.4.  XML Schema\n   The following is the schema definition of the reginfo
      format:\n"
    - '<?xml version="1.0" encoding="UTF-8"?>

      '
    - '<xs:schema targetNamespace="urn:ietf:params:xml:ns:reginfo"

      '
    - 'xmlns:tns="urn:ietf:params:xml:ns:reginfo"

      '
    - 'xmlns:xs="http://www.w3.org/2001/XMLSchema"

      '
    - "elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\">\n  <!--
      This import brings in the XML language attribute xml:lang-->\n  <xs:import namespace=\"http://www.w3.org/XML/1998/namespace\"\n"
    - "schemaLocation=\"http://www.w3.org/2001/03/xml.xsd\"/>\n  <xs:element name=\"reginfo\">\n
      \  <xs:complexType>\n    <xs:sequence>\n     <xs:element ref=\"tns:registration\"
      minOccurs=\"0\"\n"
    - "maxOccurs=\"unbounded\"/>\n     <xs:any namespace=\"##other\" processContents=\"lax\"
      minOccurs=\"0\"\n"
    - "maxOccurs=\"unbounded\"/>\n    </xs:sequence>\n    <xs:attribute name=\"version\"
      type=\"xs:nonNegativeInteger\"\n"
    - "use=\"required\"/>\n    <xs:attribute name=\"state\" use=\"required\">\n     <xs:simpleType>\n
      \     <xs:restriction base=\"xs:string\">\n       <xs:enumeration value=\"full\"/>\n
      \      <xs:enumeration value=\"partial\"/>\n      </xs:restriction>\n     </xs:simpleType>\n
      \   </xs:attribute>\n   </xs:complexType>\n  </xs:element>\n  <xs:element name=\"registration\">\n
      \  <xs:complexType>\n    <xs:sequence>\n     <xs:element ref=\"tns:contact\"
      minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n     <xs:any namespace=\"##other\"
      processContents=\"lax\" minOccurs=\"0\"\n"
    - "maxOccurs=\"unbounded\"/>\n    </xs:sequence>\n    <xs:attribute name=\"aor\"
      type=\"xs:anyURI\" use=\"required\"/>\n    <xs:attribute name=\"id\" type=\"xs:string\"
      use=\"required\"/>\n    <xs:attribute name=\"state\" use=\"required\">\n     <xs:simpleType>\n
      \     <xs:restriction base=\"xs:string\">\n       <xs:enumeration value=\"init\"/>\n
      \      <xs:enumeration value=\"active\"/>\n       <xs:enumeration value=\"terminated\"/>\n
      \     </xs:restriction>\n     </xs:simpleType>\n    </xs:attribute>\n   </xs:complexType>\n
      \ </xs:element>\n  <xs:element name=\"contact\">\n   <xs:complexType>\n    <xs:sequence>\n
      \    <xs:element name=\"uri\" type=\"xs:anyURI\"/>\n     <xs:element name=\"display-name\"
      minOccurs=\"0\">\n      <xs:complexType>\n       <xs:simpleContent>\n        <xs:extension
      base=\"xs:string\">\n         <xs:attribute ref=\"xml:lang\" use=\"optional\"/>\n
      \       </xs:extension>\n       </xs:simpleContent>\n      </xs:complexType>\n
      \    </xs:element>\n     <xs:element name=\"unknown-param\" minOccurs=\"0\"\n"
    - "maxOccurs=\"unbounded\">\n      <xs:complexType>\n       <xs:simpleContent>\n
      \       <xs:extension base=\"xs:string\">\n         <xs:attribute name=\"name\"
      type=\"xs:string\" use=\"required\"/>\n        </xs:extension>\n       </xs:simpleContent>\n
      \     </xs:complexType>\n     </xs:element>\n     <xs:any namespace=\"##other\"
      processContents=\"lax\" minOccurs=\"0\"\n"
    - "maxOccurs=\"unbounded\"/>\n    </xs:sequence>\n    <xs:attribute name=\"state\"
      use=\"required\">\n     <xs:simpleType>\n      <xs:restriction base=\"xs:string\">\n
      \      <xs:enumeration value=\"active\"/>\n       <xs:enumeration value=\"terminated\"/>\n
      \     </xs:restriction>\n     </xs:simpleType>\n    </xs:attribute>\n    <xs:attribute
      name=\"event\" use=\"required\">\n     <xs:simpleType>\n      <xs:restriction
      base=\"xs:string\">\n       <xs:enumeration value=\"registered\"/>\n       <xs:enumeration
      value=\"created\"/>\n       <xs:enumeration value=\"refreshed\"/>\n       <xs:enumeration
      value=\"shortened\"/>\n       <xs:enumeration value=\"expired\"/>\n       <xs:enumeration
      value=\"deactivated\"/>\n       <xs:enumeration value=\"probation\"/>\n       <xs:enumeration
      value=\"unregistered\"/>\n       <xs:enumeration value=\"rejected\"/>\n      </xs:restriction>\n
      \    </xs:simpleType>\n    </xs:attribute>\n    <xs:attribute name=\"duration-registered\"
      type=\"xs:unsignedLong\"/>\n    <xs:attribute name=\"expires\" type=\"xs:unsignedLong\"/>\n
      \   <xs:attribute name=\"retry-after\" type=\"xs:unsignedLong\"/>\n    <xs:attribute
      name=\"id\" type=\"xs:string\" use=\"required\"/>\n    <xs:attribute name=\"q\"
      type=\"xs:string\"/>\n    <xs:attribute name=\"callid\" type=\"xs:string\"/>\n
      \   <xs:attribute name=\"cseq\" type=\"xs:unsignedLong\"/>\n   </xs:complexType>\n
      \ </xs:element>\n"
    - '</xs:schema>

      '
    title: 5.4.  XML Schema
  title: 5.  Registration Information
- contents:
  - "6.  Example Call Flow\n        User              Registrar          Application\n
    \         |                   |(1) SUBSCRIBE      |\n          |                   |Event:reg
    \         |\n          |                   |<------------------|\n          |
    \                  |(2) 200 OK         |\n          |                   |------------------>|\n
    \         |                   |(3) NOTIFY         |\n          |                   |------------------>|\n
    \         |                   |(4) 200 OK         |\n          |                   |<------------------|\n
    \         |(5) REGISTER       |                   |\n          |------------------>|
    \                  |\n          |(6) 200 OK         |                   |\n          |<------------------|
    \                  |\n          |                   |(7) NOTIFY         |\n          |
    \                  |------------------>|\n          |                   |(8) 200
    OK         |\n          |                   |<------------------|\n          |(9)
    MESSAGE        |                   |\n          |<--------------------------------------|\n
    \               Figure 3: Example Call Flow\n   This section provides an example
    call flow, shown in Figure 3.  It\n   shows an implementation of the welcome notice
    application described\n   in Section 3.3.  First, the application SUBSCRIBEs to
    the\n   registration event package for the desired user (1):\n   SUBSCRIBE sip:joe@example.com
    SIP/2.0\n   Via: SIP/2.0/UDP app.example.com;branch=z9hG4bKnashds7\n   From: sip:app.example.com;tag=123aa9\n
    \  To: sip:joe@example.com\n   Call-ID: 9987@app.example.com\n   CSeq: 9887 SUBSCRIBE\n
    \  Contact: sip:app.example.com\n   Event: reg\n   Max-Forwards: 70\n   Accept:
    application/reginfo+xml\n   The registrar (which is acting as the notifier for
    the registration\n   event package) generates a 200 OK to the SUBSCRIBE:\n   SIP/2.0
    200 OK\n   Via: SIP/2.0/UDP app.example.com;branch=z9hG4bKnashds7\n     ;received=192.0.2.1\n
    \  From: sip:app.example.com;tag=123aa9\n   To: sip:joe@example.com;tag=xyzygg\n
    \  Call-ID: 9987@app.example.com\n   CSeq: 9987 SUBSCRIBE\n   Contact: sip:server19.example.com\n
    \  Expires: 3600\n   The registrar then generates a notification (3) with the
    current\n   state.  Since there is no active registration, the state of the\n
    \  registration is \"init\":\n   NOTIFY sip:app.example.com SIP/2.0\n   Via: SIP/2.0/UDP
    server19.example.com;branch=z9hG4bKnasaii\n   From: sip:joe@example.com;tag=xyzygg\n
    \  To: sip:app.example.com;tag=123aa9\n   Call-ID: 9987@app.example.com\n   CSeq:
    1288 NOTIFY\n   Contact: sip:server19.example.com\n   Event: reg\n   Max-Forwards:
    70\n   Content-Type: application/reginfo+xml\n   Content-Length: ...\n   <?xml
    version=\"1.0\"?>\n   <reginfo xmlns=\"urn:ietf:params:xml:ns:reginfo\"\n                version=\"0\"
    state=\"full\">\n     <registration aor=\"sip:joe@example.com\" id=\"a7\" state=\"init\"
    />\n   </reginfo>\n   Later on, the user registers (5):\n   REGISTER sip:example.com
    SIP/2.0\n   Via: SIP/2.0/UDP pc34.example.com;branch=z9hG4bKnaaff\n   From: sip:joe@example.com;tag=99a8s\n
    \  To: sip:joe@example.com\n   Call-ID: 88askjda9@pc34.example.com\n   CSeq: 9976
    REGISTER\n   Contact: sip:joe@pc34.example.com\n   This results in a NOTIFY being
    generated to the application (7):\n   NOTIFY sip:app.example.com SIP/2.0\n   Via:
    SIP/2.0/UDP server19.example.com;branch=z9hG4bKnasaij\n   From: sip:joe@example.com;tag=xyzygg\n
    \  To: sip:app.example.com;tag=123aa9\n   Call-ID: 9987@app.example.com\n   CSeq:
    1289 NOTIFY\n   Contact: sip:server19.example.com\n   Event: reg\n   Max-Forwards:
    70\n   Content-Type: application/reginfo+xml\n   Content-Length: ...\n   <?xml
    version=\"1.0\"?>\n   <reginfo xmlns=\"urn:ietf:params:xml:ns:reginfo\"\n             version=\"1\"
    state=\"partial\">\n     <registration aor=\"sip:joe@example.com\" id=\"a7\" state=\"active\">\n
    \      <contact id=\"76\" state=\"active\" event=\"registered\"\n             duration-registered=\"0\">\n
    \         <uri>sip:joe@pc34.example.com</uri>\n       </contact>\n     </registration>\n
    \  </reginfo>\n   The application can then send its instant message to the device
    (9):\n   MESSAGE sip:joe@pc34.example.com SIP/2.0\n   Via: SIP/2.0/UDP app.example.com;branch=z9hG4bKnashds8\n
    \  From: sip:app.example.com;tag=123aa10\n   To: sip:joe@example.com\n   Call-ID:
    9988@app.example.com\n   CSeq: 82779 MESSAGE\n   Max-Forwards: 70\n   Content-Type:
    text/plain\n   Content-Length: ...\n   Welcome to the example.com service!\n"
  title: 6.  Example Call Flow
- contents:
  - "7.  Security Considerations\n   Security considerations for SIP event packages
    are discussed in RFC\n   3265 [2], and those considerations apply here.\n   Registration
    information is sensitive, potentially private,\n   information.  Subscriptions
    to this event package SHOULD be\n   authenticated and authorized according to
    local policy.  Some policy\n   guidelines are suggested in Section 4.6.  In addition,
    notifications\n   SHOULD be sent in such a way to ensure confidentiality, message\n
    \  integrity and verification of subscriber identity, such as sending\n   subscriptions
    and notifications using a SIPS URL or protecting the\n   notification bodies with
    S/MIME.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   This document registers a new SIP Event Package,
    a new MIME type\n   (application/reginfo+xml), and a new XML namespace.\n"
  - contents:
    - "8.1.  SIP Event Package Registration\n   Package name: reg\n   Type: package\n
      \  Contact: Jonathan Rosenberg, <jdrosen@jdrosen.net>\n   Published Specification:
      RFC 3680.\n"
    title: 8.1.  SIP Event Package Registration
  - contents:
    - "8.2.  application/reginfo+xml MIME Registration\n   MIME media type name: application\n
      \  MIME subtype name: reginfo+xml\n   Mandatory parameters: none\n   Optional
      parameters: Same as charset parameter application/xml\n        as specified
      in RFC 3023 [8].\n   Encoding considerations: Same as encoding considerations
      of\n        application/xml as specified in RFC 3023 [8].\n   Security considerations:
      See Section 10 of RFC 3023 [8] and\n        Section 7 of this specification.\n
      \  Interoperability considerations: none.\n   Published specification: This
      document.\n   Applications which use this media type: This document type is\n
      \       being used in notifications to alert SIP user agents that\n        their
      registrations have expired and must be redone.\n   Additional Information:\n
      \       Magic Number: None\n        File Extension: .rif or .xml\n        Macintosh
      file type code: \"TEXT\"\n   Personal and email address for further information:
      Jonathan\n        Rosenberg, <jdrosen@jdrosen.net>\n   Intended usage: COMMON\n
      \  Author/Change controller: The IETF.\n"
    title: 8.2.  application/reginfo+xml MIME Registration
  - contents:
    - "8.3.  URN Sub-Namespace Registration for urn:ietf:params:xml:ns:reginfo\n   This
      section registers a new XML namespace, as per the guidelines in\n   [7].\n    URI:
      The URI for this namespace is\n         urn:ietf:params:xml:ns:reginfo.\n    Registrant
      Contact: IETF, SIMPLE working group,\n         <simple@ietf.org>, Jonathan Rosenberg\n
      \        <jdrosen@jdrosen.net>.\n    XML:\n      BEGIN\n      <?xml version=\"1.0\"?>\n
      \     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.0//EN\"\n                \"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd\">\n
      \     <html xmlns=\"http://www.w3.org/1999/xhtml\">\n      <head>\n        <meta
      http-equiv=\"content-type\"\n           content=\"text/html;charset=iso-8859-1\"/>\n
      \       <title>Registration Information Namespace</title>\n      </head>\n      <body>\n
      \        <h1>Namespace for Registration Information</h1>\n         <h2>urn:ietf:params:xml:ns:reginfo</h2>\n
      \        <p>See <a href=\"ftp://ftp.rfc-editor.org/in-notes/rfc3680.txt\">\n
      \               RFC3680</a>.</p>\n       </body>\n      </html>\n      END\n"
    title: 8.3.  URN Sub-Namespace Registration for urn:ietf:params:xml:ns:reginfo
  title: 8.  IANA Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [1]  Rosenberg, J., Schulzrinne, H., Camarillo,
      G., Johnston, A.,\n        Peterson, J., Sparks, R., Handley, M. and E. Schooler,
      \"SIP:\n        Session Initiation Protocol\", RFC 3261, June 2002.\n   [2]
      \ Roach, A., \"Session Initiation Protocol (SIP)-Specific Event\n        Notification\",
      RFC 3265, June 2002.\n   [3]  Bradner, S., \"Key words for use in RFCs to indicate
      requirement\n        levels\", BCP 14, RFC 2119, March 1997.\n   [4]  W. W.
      W. C. (W3C), \"Extensible markup language (xml) 1.0.\" The\n        XML 1.0
      spec can be found at\n        http://www.w3.org/TR/1998/REC-xml-19980210.\n
      \  [5]  Moats, R., \"URN Syntax\", RFC 2141, May 1997.\n   [6]  Moats, R., \"A
      URN Namespace for IETF Documents\", RFC 2648,\n        August 1999.\n   [7]
      \ Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, January\n        2004.\n
      \  [8]  Murata, M., St. Laurent, S. and D. Kohn, \"XML media types\", RFC\n
      \       3023, January 2001.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [9]  Rosenberg, J., \"Session initiation protocol
      (SIP) extensions for\n        presence\", Work In Progress.\n   [10] Campbell,
      B., Rosenberg, J., Schulzrinne, H., Huitema, C. and D.\n        Gurle, \"Session
      Initiation Protocol (SIP) Extension for Instant\n        Messaging\", RFC 3428,
      December 2002.\n   [11] Schulzrinne, H. and J. Rosenberg, \"Session initiation
      protocol\n        (SIP) caller preferences and callee capabilities\", Work In\n
      \       Progress.\n   [12] Mayer, G. and M. Beckmann, \"Registration event package\",
      Work In\n        Progress.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "10.  Contributors\n   This document is based heavily on the registration event
    package\n   originally proposed by Beckmann and Mayer in [12].  They can be\n
    \  contacted at:\n   Georg Mayer\n   Siemens AG\n   Hoffmannstr. 51\n   Munich
    \ 81359\n   Germany\n   EMail: Georg.Mayer@icn.siemens.de\n   Mark Beckmann\n
    \  Siemens AG\n   P.O. Box 100702\n   Salzgitter  38207\n   Germany\n   EMail:
    Mark.Beckmann@siemens.com\n   Rohan Mahy provided editorial work in order to progress
    this\n   specification.  His contact address is:\n   Rohan Mahy\n   Cisco Systems\n
    \  170 West Tasman Dr, MS: SJC-21/3/3\n   Phone: +1 408 526 8570\n   EMail: rohan@cisco.com\n"
  title: 10.  Contributors
- contents:
  - "11.  Acknowledgements\n   We would like to thank Dean Willis for his support.\n"
  title: 11.  Acknowledgements
- contents:
  - "12.  Author's Address\n   Jonathan Rosenberg\n   dynamicsoft\n   600 Lanidex
    Plaza\n   Parsippany, NJ 07054\n   EMail: jdrosen@dynamicsoft.com\n"
  title: 12.  Author's Address
- contents:
  - "13.  Full Copyright Statement\n   Copyright (C) The Internet Society (2004).
    \ This document is subject\n   to the rights, licenses and restrictions contained
    in BCP 78 and\n   except as set forth therein, the authors retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE\n   REPRESENTS OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE\n   INTERNET ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: 13.  Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed\n
    \  to pertain to the implementation or use of the technology\n   described in
    this document or the extent to which any license\n   under such rights might or
    might not be available; nor does it\n   represent that it has made any independent
    effort to identify any\n   such rights.  Information on the procedures with respect
    to\n   rights in RFC documents can be found in BCP 78 and BCP 79.\n   Copies of
    IPR disclosures made to the IETF Secretariat and any\n   assurances of licenses
    to be made available, or the result of an\n   attempt made to obtain a general
    license or permission for the use\n   of such proprietary rights by implementers
    or users of this\n   specification can be obtained from the IETF on-line IPR repository\n
    \  at http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention\n   any copyrights, patents or patent applications, or other\n
    \  proprietary rights that may cover technology that may be required\n   to implement
    this standard.  Please address the information to the\n   IETF at ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
